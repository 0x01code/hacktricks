# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)를 사용하여 세계에서 가장 **고급 커뮤니티 도구**를 활용한 **워크플로우를 쉽게 구축하고 자동화**하세요.\
오늘 바로 액세스하세요:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 자신의 해킹 기법을 공유하세요.

</details>

## iOS 기본 사항

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## 테스트 환경

이 페이지에서는 **iOS 시뮬레이터**, **에뮬레이터** 및 **탈옥**에 대한 정보를 찾을 수 있습니다:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## 초기 분석

### 기본 iOS 테스트 작업

테스트 중에는 **여러 작업이 제안**됩니다(장치에 연결, 파일 읽기/쓰기/업로드/다운로드, 일부 도구 사용 등). 따라서 이러한 작업을 수행하는 방법을 모르는 경우, **페이지를 읽기 시작**하세요:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
다음 단계에서는 앱이 장치에 **설치되어 있어야 하며** 이미 앱의 **IPA 파일**을 얻었어야 합니다.\
이를 수행하는 방법은 [Basic iOS Testing Operations](basic-ios-testing-operations.md) 페이지를 읽어보세요.
{% endhint %}

### 기본 정적 분석

**MobSF** 도구를 사용하여 IPA 파일에 대한 자동 정적 분석을 수행하는 것이 좋습니다.

바이너리에 **보호 기능이 있는지 확인**:

*   **PIE (Position Independent Executable)**: 활성화되면 애플리케이션이 시작될 때마다 랜덤한 메모리 주소로 로드되어 초기 메모리 주소를 예측하기 어려워집니다.

```bash
otool -hv <app-binary> | grep PIE   # PIE 플래그를 포함해야 합니다.
```
*   **Stack Canaries**: 함수를 호출하기 전에 스택에 'canary' 값을 놓고 함수가 종료될 때 다시 유효성을 검사하여 스택의 무결성을 확인합니다.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard 및 stack_chk_fail 심볼을 포함해야 합니다.
```
*   **ARC (Automatic Reference Counting)**: 일반적인 메모리 손상 결함을 방지하기 위해

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release 심볼을 포함해야 합니다.
```
*   **암호화된 바이너리**: 바이너리는 암호화되어야 합니다.

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid는 1이어야 합니다.
```

**민감한/보안에 취약한 함수 식별**

*   **약한 해시 알고리즘**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux에서
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **보안에 취약한 난수 함수**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux에서
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **보안에 취약한 'Malloc' 함수**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_malloc"

# Linux에서
grep -iER "_malloc"
```
*   **보안에 취약하고 취약한 함수**

```bash
# iOS 장치에서
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux에서
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### 기본 동적 분석

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)가 수행하는 동적 분석을 확인하세요. 다른 뷰를 탐색하고 상호 작용해야 하지만 여러 클래스를 후킹하고 다른 작업을 수행하며 완료되면 보고서를 준비합니다.

### 설치된 앱 목록

명령어 `frida-ps -Uai`를 사용하여 설치된 앱의 **번들 식별자**를 확인하세요:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### 기본 열거 및 후킹

애플리케이션의 구성 요소를 **열거**하고, objection을 사용하여 **메소드와 클래스를 쉽게 후킹**하는 방법을 배워보세요:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA 구조

**IPA 파일**의 구조는 기본적으로 **압축된 패키지**입니다. 확장자를 `.zip`로 변경하여 압축을 해제하면 내용물을 확인할 수 있습니다. 이 구조에서 **번들(Bundle)**은 설치 준비가 된 완전히 패키지된 애플리케이션을 나타냅니다. 내부에는 `<NAME>.app`이라는 디렉토리가 있으며, 이 디렉토리에는 애플리케이션의 리소스가 포함되어 있습니다.

* **`Info.plist`**: 이 파일은 애플리케이션의 구체적인 구성 세부 정보를 보유합니다.
* **`_CodeSignature/`**: 이 디렉토리에는 번들 내의 모든 파일의 무결성을 보장하는 서명이 포함된 plist 파일이 포함되어 있습니다.
* **`Assets.car`**: 아이콘과 같은 에셋 파일을 저장하는 압축된 아카이브입니다.
* **`Frameworks/`**: 이 폴더에는 `.dylib` 또는 `.framework` 파일 형식일 수 있는 애플리케이션의 네이티브 라이브러리가 위치합니다.
* **`PlugIns/`**: 이 폴더에는 `.appex` 파일로 알려진 애플리케이션의 확장이 포함될 수 있지만 항상 존재하지는 않습니다.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): 오프라인 사용을 위해 애플리케이션의 영구 데이터를 저장하고, 임시 데이터를 캐시하며, 단일 기기에서 앱의 실행 취소 기능을 추가하는 데 사용됩니다. 단일 iCloud 계정에서 여러 기기 간에 데이터를 동기화하려면 Core Data가 스키마를 CloudKit 컨테이너에 자동으로 미러링합니다.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` 파일은 애플리케이션 또는 번들의 유형과 생성자 코드를 지정하는 대체 방법입니다.
* **en.lproj, fr.proj, Base.lproj**: 해당 특정 언어에 대한 리소스와 언어를 지원하지 않을 경우의 기본 리소스를 포함하는 언어 팩입니다.
* **보안**: `_CodeSignature/` 디렉토리는 디지털 서명을 통해 번들된 모든 파일의 무결성을 확인하여 앱의 보안에 중요한 역할을 합니다.
* **자산 관리**: `Assets.car` 파일은 그래픽 자산을 효율적으로 관리하기 위해 압축을 사용하며, 애플리케이션 성능을 최적화하고 전체 크기를 줄이는 데 중요합니다.
* **프레임워크 및 플러그인**: 이러한 디렉토리는 iOS 애플리케이션의 모듈성을 강조하며, 재사용 가능한 코드 라이브러리(`Frameworks/`)를 포함하고 앱 기능을 확장(`PlugIns/`)할 수 있도록 합니다.
* **로캘라이제이션**: 이 구조는 여러 언어를 지원하여 특정 언어 팩의 리소스를 포함하여 전역 애플리케이션 사용을 용이하게 합니다.

**Info.plist**

**Info.plist**는 iOS 애플리케이션의 중요한 구성 데이터를 **키-값** 쌍의 형태로 캡슐화하는 데 중요한 역할을 합니다. 이 파일은 애플리케이션 뿐만 아니라 번들 내에 포함된 앱 확장 및 프레임워크에도 필수적입니다. 이 파일은 XML 또는 이진 형식으로 구성되며, 앱 권한부터 보안 구성까지 다양한 중요한 정보를 포함합니다. 사용 가능한 키에 대한 자세한 탐색을 위해 [**Apple 개발자 문서**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc)를 참조할 수 있습니다.

이 파일을 더 쉽게 작업하기 위해 XML 변환은 macOS의 `plutil` (버전 10.2 이상에서 기본으로 제공) 또는 Linux의 `plistutil`을 사용하여 간편하게 수행할 수 있습니다. 변환을 위한 명령어는 다음과 같습니다:

- **macOS용**:
```bash
$ plutil -convert xml1 Info.plist
```
- **리눅스용**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** 파일이 누설할 수 있는 다양한 정보 중에서, 주목할 만한 항목은 앱 권한 문자열 (`UsageDescription`), 사용자 정의 URL 스키마 (`CFBundleURLTypes`), 그리고 App Transport Security의 구성 (`NSAppTransportSecurity`) 등이 있습니다. 이러한 항목들은 파일을 검사하거나 간단한 `grep` 명령을 사용하여 손쉽게 찾을 수 있습니다:
```bash
$ grep -i <keyword> Info.plist
```
**데이터 경로**

iOS 환경에서는 디렉토리가 **시스템 애플리케이션**과 **사용자 설치 애플리케이션**을 위해 특별히 지정됩니다. 시스템 애플리케이션은 `/Applications` 디렉토리에 있으며, 사용자 설치 앱은 `/private/var/containers/` 아래에 배치됩니다. 이러한 애플리케이션들은 **128비트 UUID**라는 고유 식별자가 할당되어 있어 디렉토리 이름의 무작위성으로 인해 앱의 폴더를 수동으로 찾는 작업이 어렵습니다.

사용자 설치 앱의 설치 디렉토리를 쉽게 찾기 위해 **objection 도구**는 유용한 `env` 명령을 제공합니다. 이 명령은 해당 앱에 대한 자세한 디렉토리 정보를 공개합니다. 아래는 이 명령을 사용하는 예시입니다:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
대신, `find` 명령어를 사용하여 `/private/var/containers` 내에서 앱 이름을 검색할 수도 있습니다:
```bash
find /private/var/containers -name "Progname*"
```
`ps`와 `lsof`와 같은 명령어를 사용하여 앱의 프로세스를 식별하고 각각 앱의 열린 파일 목록을 확인할 수도 있습니다. 이를 통해 애플리케이션의 활성 디렉토리 경로에 대한 통찰력을 얻을 수 있습니다:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**번들 디렉토리:**

* **AppName.app**
* 이것은 IPA에서 본 것과 같은 애플리케이션 번들입니다. 필수 애플리케이션 데이터, 정적 콘텐츠 및 애플리케이션의 컴파일된 이진 파일이 포함되어 있습니다.
* 이 디렉토리는 사용자에게 보이지만 **사용자는 쓸 수 없습니다**.
* 이 디렉토리의 내용은 **백업되지 않습니다**.
* 이 폴더의 내용은 코드 서명을 **검증하는 데 사용**됩니다.

**데이터 디렉토리:**

* **Documents/**
* 사용자가 생성하는 모든 데이터가 포함되어 있습니다. 애플리케이션 최종 사용자가 이 데이터의 생성을 시작합니다.
* 사용자에게 보이며 **사용자는 쓸 수 있습니다**.
* 이 디렉토리의 내용은 **백업됩니다**.
* 앱은 `NSURLIsExcludedFromBackupKey`를 설정하여 경로를 비활성화할 수 있습니다.
* **Library/**
* **사용자별이 아닌 파일**인 **캐시**, **환경 설정**, **쿠키** 및 속성 목록 (plist) 구성 파일과 같은 모든 파일이 포함되어 있습니다.
* iOS 앱은 일반적으로 `Application Support` 및 `Caches` 하위 디렉토리를 사용하지만, 앱은 사용자 정의 하위 디렉토리를 생성할 수 있습니다.
* **Library/Caches/**
* **반영구적으로 캐시된 파일**이 포함되어 있습니다.
* 사용자에게 보이지 않으며 **사용자는 쓸 수 없습니다**.
* 이 디렉토리의 내용은 **백업되지 않습니다**.
* 앱이 실행되지 않을 때 및 저장 공간이 부족할 때 OS가 이 디렉토리의 파일을 자동으로 삭제할 수 있습니다.
* **Library/Application Support/**
* 앱 실행에 필요한 **지속적인 파일**이 포함되어 있습니다.
* 사용자에게 **보이지 않으며** 사용자는 쓸 수 없습니다.
* 이 디렉토리의 내용은 **백업됩니다**.
* 앱은 `NSURLIsExcludedFromBackupKey`를 설정하여 경로를 비활성화할 수 있습니다.
* **Library/Preferences/**
* 애플리케이션이 다시 시작된 후에도 **지속될 수 있는 속성을 저장하는 데 사용**됩니다.
* 정보는 애플리케이션 샌드박스 내의 암호화되지 않은 plist 파일인 \[BUNDLE\_ID].plist에 저장됩니다.
* `NSUserDefaults`를 사용하여 저장된 모든 키/값 쌍은 이 파일에서 찾을 수 있습니다.
* **tmp/**
* 앱 시작 간에 지속되지 않아도 되는 **임시 파일**을 작성하는 데 이 디렉토리를 사용합니다.
* 비지속성 캐시된 파일이 포함되어 있습니다.
* 사용자에게 **보이지 않습니다**.
* 이 디렉토리의 내용은 백업되지 않습니다.
* 앱이 실행되지 않을 때 및 저장 공간이 부족할 때 OS가 이 디렉토리의 파일을 자동으로 삭제할 수 있습니다.

iGoat-Swift의 번들 디렉토리 (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) 내부에 있는 애플리케이션 번들 (.app) 디렉토리를 자세히 살펴보겠습니다:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### 이진 역어셈블링

`<application-name>.app` 폴더 내부에 `<application-name>`이라는 이진 파일이 있습니다. 이 파일이 **실행**될 파일입니다. **`otool`** 도구를 사용하여 이진 파일을 기본적으로 검사할 수 있습니다:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**앱이 암호화되었는지 확인**

다음을 확인하십시오:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**바이너리 분해**

텍스트 섹션을 분해합니다:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**Objective-C 세그먼트**를 출력하려면 다음을 사용할 수 있습니다:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
더 간결한 Objective-C 코드를 얻기 위해 [**class-dump**](http://stevenygard.com/projects/class-dump/)를 사용할 수 있습니다:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
그러나 이진 파일을 분해하는 가장 좋은 옵션은 [**Hopper**](https://www.hopperapp.com/download.html?)와 [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/)입니다.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)를 사용하여 세계에서 가장 고급스러운 커뮤니티 도구를 활용한 **워크플로우를 쉽게 구축하고 자동화**할 수 있습니다.\
오늘 바로 액세스하세요:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 데이터 저장

iOS가 기기에 데이터를 저장하는 방법에 대해 알아보려면 이 페이지를 읽으세요:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
다음 정보를 저장하는 위치는 앱을 **설치한 직후**, 앱의 **모든 기능을 확인한 후** 및 **한 사용자에서 로그아웃하고 다른 사용자로 로그인한 후**에 확인해야 합니다.\
목표는 앱의 **민감한 정보**(비밀번호, 토큰), 현재 사용자 및 이전에 로그인한 사용자의 정보를 찾는 것입니다.
{% endhint %}

### Plist

**plist** 파일은 **키-값 쌍을 포함하는** 구조화된 XML 파일입니다. 이는 지속적인 데이터를 저장하는 방법이므로 때로는 이러한 파일에 **민감한 정보를 찾을 수 있습니다**. 앱을 설치한 후와 앱을 강도롭게 사용한 후에 이러한 파일을 확인하는 것이 좋습니다.

plist 파일에서 데이터를 지속적으로 저장하는 가장 일반적인 방법은 **NSUserDefaults**를 사용하는 것입니다. 이 plist 파일은 **`Library/Preferences/<appBundleID>.plist`**에 앱 샌드박스 내에 저장됩니다.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) 클래스는 기본 시스템과 상호 작용하기 위한 프로그래밍 인터페이스를 제공합니다. 기본 시스템을 통해 애플리케이션은 **사용자 기본 설정**에 따라 동작을 사용자 정의할 수 있습니다. `NSUserDefaults`에 저장된 데이터는 애플리케이션 번들에서 볼 수 있습니다. 이 클래스는 데이터를 plist 파일에 저장하지만 소량의 데이터와 함께 사용하기 위해 설계되었습니다.

이 데이터는 신뢰할 수 있는 컴퓨터를 통해 직접 액세스할 수 없지만 **백업**을 수행하여 액세스할 수 있습니다.

`NSUserDefaults`를 사용하여 저장된 정보를 덤프할 수 있으며, objection의 `ios nsuserdefaults get`을 사용하여 정보를 가져올 수 있습니다.

애플리케이션이 사용하는 모든 plist를 찾으려면 `/private/var/mobile/Containers/Data/Application/{APPID}`에 액세스하여 다음을 실행하세요:
```bash
find ./ -name "*.plist"
```
**XML 또는 이진 (bplist) 형식의 파일을 XML로 변환하는 방법은 운영 체제에 따라 다양합니다:**

**macOS 사용자를 위한 방법:**
`plutil` 명령어를 사용하세요. 이것은 macOS (10.2+)에 내장된 도구로, 이 목적을 위해 설계되었습니다:
```bash
$ plutil -convert xml1 Info.plist
```
**리눅스 사용자를 위한:**
먼저 `libplist-utils`를 설치한 다음 `plistutil`을 사용하여 파일을 변환하세요:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objection 세션 내에서:**
모바일 애플리케이션을 분석하기 위해, 특정 명령어를 사용하여 plist 파일을 직접 변환할 수 있습니다:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1)는 애플리케이션의 모델 레이어를 관리하기 위한 프레임워크입니다. [Core Data는 SQLite를 영구 저장소로 사용할 수 있지만](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), 프레임워크 자체는 데이터베이스가 아닙니다.\
CoreData는 기본적으로 데이터를 암호화하지 않습니다. 그러나 CoreData에 추가적인 암호화 레이어를 추가할 수 있습니다. 자세한 내용은 [GitHub Repo](https://github.com/project-imas/encrypted-core-data)를 참조하십시오.

애플리케이션의 SQLite Core Data 정보는 경로 `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`에서 찾을 수 있습니다.

**만약 SQLite를 열고 민감한 정보에 접근할 수 있다면, 설정이 잘못되었다는 것을 발견한 것입니다.**

{% code title="iGoat에서 가져온 코드" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase)은 SQLite 위에 구축된 키/값 저장소입니다.\
Yap 데이터베이스는 SQLite 데이터베이스이므로 이전 섹션에서 제안된 명령을 사용하여 해당 데이터베이스를 찾을 수 있습니다.

### 다른 SQLite 데이터베이스

응용 프로그램이 자체 SQLite 데이터베이스를 생성하는 것은 일반적입니다. 그들은 그들 위에 **민감한** **데이터**를 **저장**할 수 있으며 암호화되지 않은 채로 남겨둘 수 있습니다. 따라서 응용 프로그램 디렉토리 내의 모든 데이터베이스를 확인하는 것이 항상 흥미로울 수 있습니다. 따라서 데이터가 저장된 응용 프로그램 디렉토리로 이동합니다 (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase 실시간 데이터베이스

개발자는 Firebase 실시간 데이터베이스를 통해 **NoSQL 클라우드 호스팅 데이터베이스**에 데이터를 **저장 및 동기화**할 수 있습니다. 데이터는 JSON 형식으로 저장되며, 실시간으로 연결된 모든 클라이언트에 동기화됩니다.

Firebase 데이터베이스의 구성 오류를 확인하는 방법은 다음에서 찾을 수 있습니다:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm 데이터베이스

[Realm Objective-C](https://realm.io/docs/objc/latest/)와 [Realm Swift](https://realm.io/docs/swift/latest/)는 Apple에서 제공하지 않는 강력한 데이터 저장 대안을 제공합니다. 기본적으로 데이터는 암호화되지 않은 상태로 저장되며, 특정 구성을 통해 암호화할 수 있습니다.

데이터베이스는 다음 위치에 있습니다: `/private/var/mobile/Containers/Data/Application/{APPID}`. 이 파일들을 탐색하기 위해 다음과 같은 명령을 사용할 수 있습니다:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
이러한 데이터베이스 파일을 보려면 [**Realm Studio**](https://github.com/realm/realm-studio) 도구를 사용하는 것이 좋습니다.

Realm 데이터베이스 내에서 암호화를 구현하려면 다음 코드 스니펫을 사용할 수 있습니다:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite 데이터베이스

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios)는 **가벼운** 및 **내장형** 데이터베이스 엔진으로, **문서 지향** (NoSQL) 접근 방식을 따릅니다. **iOS** 및 **macOS**에 네이티브로 설계되어 있으며 데이터를 신속하게 동기화하는 기능을 제공합니다.

장치에서 잠재적인 Couchbase 데이터베이스를 식별하기 위해 다음 디렉토리를 검사해야 합니다:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### 쿠키

iOS는 각 앱 폴더 내의 **`Library/Cookies/cookies.binarycookies`**에 앱의 쿠키를 저장합니다. 그러나 개발자들은 때때로 백업에서 해당 **쿠키 파일에 접근할 수 있기 때문에** 이를 **키체인**에 저장하기로 결정합니다.

쿠키 파일을 검사하려면 [**이 파이썬 스크립트**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser)를 사용하거나 objection의 **`ios cookies get`**을 사용할 수 있습니다.\
또한 objection을 사용하여 이러한 파일을 JSON 형식으로 변환하고 데이터를 검사할 수도 있습니다.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### 캐시

기본적으로 NSURLSession은 **HTTP 요청 및 응답을 Cache.db 데이터베이스에 저장**합니다. 이 데이터베이스에는 토큰, 사용자 이름 또는 기타 민감한 정보가 캐시되었을 경우 **민감한 데이터**가 포함될 수 있습니다. 캐시된 정보를 찾으려면 앱의 데이터 디렉토리 (`/var/mobile/Containers/Data/Application/<UUID>`)를 열고 `/Library/Caches/<Bundle Identifier>`로 이동하십시오. **WebKit 캐시도 Cache.db 파일에 저장**됩니다. **Objection**은 `sqlite connect Cache.db` 명령을 사용하여 데이터베이스를 열고 상호 작용할 수 있습니다. 이는 **일반 SQLite 데이터베이스**입니다.

요청 또는 응답에 민감한 정보가 포함될 수 있으므로 이 데이터의 캐싱을 비활성화하는 것이 좋습니다. 아래 목록은 이를 달성하는 다양한 방법을 보여줍니다:

1. 로그아웃 후 캐시된 응답을 제거하는 것이 좋습니다. Apple에서 제공하는 [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses)라는 메서드를 사용하여 이 작업을 수행할 수 있습니다. 다음과 같이 이 메서드를 호출할 수 있습니다:

`URLCache.shared.removeAllCachedResponses()`

이 메서드는 Cache.db 파일에서 모든 캐시된 요청과 응답을 제거합니다.
2. 쿠키의 이점을 사용할 필요가 없다면 URLSession의 [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) 구성 속성을 사용하는 것이 좋습니다. 이렇게 하면 쿠키와 캐시 저장이 비활성화됩니다.

[Apple 문서](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`임시 세션 구성 객체는 기본 세션 구성(기본값 참조)과 유사하지만 해당 세션 객체는 캐시, 자격 증명 저장소 또는 디스크에 관련된 세션 데이터를 저장하지 않습니다. 대신 세션 관련 데이터는 RAM에 저장됩니다. 임시 세션이 데이터를 디스크에 기록하는 유일한 경우는 URL의 내용을 파일로 기록하도록 지시할 때뿐입니다.`
3. 캐시 정책을 [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed)로 설정하여 캐시를 메모리나 디스크에 저장하지 않도록 비활성화할 수도 있습니다.

### 스냅샷

홈 버튼을 누를 때마다 iOS는 현재 화면의 **스냅샷을 찍어** 애플리케이션으로의 전환을 더 부드럽게 할 수 있습니다. 그러나 현재 화면에 **민감한 데이터**가 있는 경우, 이 데이터는 **이미지에 저장**되어 **재부팅을 거치더라도 유지**됩니다. 이 스냅샷은 홈 화면을 두 번 탭하여 앱 간에 전환할 수도 있습니다.

아이폰이 탈옥되지 않은 경우, **공격자**는 이러한 스냅샷을 볼 수 있으려면 **장치에 액세스**할 수 있어야 합니다. 기본적으로 마지막 스냅샷은 애플리케이션의 샌드박스에 `Library/Caches/Snapshots/` 또는 `Library/SplashBoard/Snapshots` 폴더에 저장됩니다 (신뢰할 수 있는 컴퓨터는 iOX 7.0부터 파일 시스템에 액세스할 수 없습니다).

이러한 부적절한 동작을 방지하는 한 가지 방법은 `ApplicationDidEnterBackground()` 함수를 사용하여 스냅샷을 찍기 전에 빈 화면이나 민감한 데이터를 제거하는 것입니다.

다음은 기본 스크린샷을 설정하는 샘플 개선 방법입니다.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C는 Apple의 iOS 및 macOS 애플리케이션 개발에 사용되는 프로그래밍 언어입니다. C 언어를 기반으로 하며, Smalltalk 스타일의 객체 지향 프로그래밍을 지원합니다. Objective-C는 iOS 애플리케이션의 코어 프레임워크와 라이브러리에 널리 사용되며, 애플리케이션의 동작을 제어하고 사용자 인터페이스를 구축하는 데 사용됩니다.

Objective-C는 iOS 애플리케이션의 취약점을 찾고 악용하는 데 사용될 수 있습니다. 악의적인 해커는 Objective-C 코드를 분석하여 취약점을 발견하고 악용할 수 있습니다. 따라서 iOS 애플리케이션을 보호하기 위해서는 Objective-C 코드의 보안을 강화해야 합니다.

Objective-C 코드의 취약점을 찾기 위해 다양한 기법과 도구를 사용할 수 있습니다. 예를 들어, 정적 분석 도구를 사용하여 코드를 검사하고 취약점을 식별할 수 있습니다. 또한 동적 분석을 통해 애플리케이션의 실행 중에 취약점을 탐지할 수도 있습니다.

Objective-C 코드의 취약점을 방지하기 위해 몇 가지 보안 사례를 따를 수 있습니다. 예를 들어, 입력 유효성 검사를 수행하여 악의적인 입력을 방지할 수 있습니다. 또한 메모리 관리를 신중하게 처리하여 버퍼 오버플로우와 같은 취약점을 방지할 수 있습니다.

Objective-C 코드의 취약점을 찾고 보호하기 위해서는 iOS 애플리케이션 개발에 대한 깊은 이해와 경험이 필요합니다. 따라서 iOS 애플리케이션을 개발하거나 보안을 강화하려는 경우, Objective-C에 대한 지식을 습득하는 것이 중요합니다.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
이 코드는 애플리케이션이 백그라운드로 전환될 때 배경 이미지를 `overlayImage.png`로 설정합니다. `overlayImage.png`는 항상 현재 뷰를 덮어씌우기 때문에 민감한 데이터 누출을 방지합니다.

### 키체인

iOS 키체인에 액세스하고 관리하기 위해 [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper)와 같은 도구가 있으며, 이는 탈옥된 기기에 적합합니다. 또한, [**Objection**](https://github.com/sensepost/objection)은 비슷한 목적을 위해 `ios keychain dump` 명령을 제공합니다.

#### **자격 증명 저장**

**NSURLCredential** 클래스는 NSUserDefaults나 다른 래퍼를 거치지 않고 키체인에 직접 민감한 정보를 저장하는 데 이상적입니다. 로그인 후 자격 증명을 저장하기 위해 다음 Swift 코드를 사용합니다:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
이러한 저장된 자격 증명을 추출하기 위해 Objection의 `ios nsurlcredentialstorage dump` 명령을 사용합니다.

## **사용자 정의 키보드 및 키보드 캐시**

iOS 8.0부터 사용자는 **설정 > 일반 > 키보드 > 키보드**에서 관리 가능한 사용자 정의 키보드 확장을 설치할 수 있습니다. 이러한 키보드는 확장된 기능을 제공하지만, 키 입력 기록 및 데이터를 외부 서버로 전송하는 위험을 가지고 있습니다. 그러나 사용자는 네트워크 액세스가 필요한 키보드에 대해 알림을 받습니다. 앱은 민감한 정보 입력에 대해 사용자 정의 키보드의 사용을 제한할 수 있습니다.

**보안 권장 사항:**
- 보안을 강화하기 위해 타사 키보드를 비활성화하는 것이 좋습니다.
- 기본 iOS 키보드의 자동 수정 및 자동 제안 기능에 주의해야 합니다. 이 기능은 `Library/Keyboard/{locale}-dynamic-text.dat` 또는 `/private/var/mobile/Library/Keyboard/dynamic-text.dat`에 위치한 캐시 파일에 민감한 정보를 저장할 수 있습니다. 이러한 캐시 파일은 정기적으로 민감한 데이터를 확인해야 합니다. **설정 > 일반 > 초기화 > 키보드 사전 재설정**을 통해 캐시된 데이터를 지우는 것이 권장됩니다.
- 네트워크 트래픽을 가로채면 사용자 정의 키보드가 원격으로 키 입력을 전송하는지 확인할 수 있습니다.

### **텍스트 필드 캐싱 방지**

[UITextInputTraits 프로토콜](https://developer.apple.com/reference/uikit/uitextinputtraits)은 자동 수정 및 보안 텍스트 입력을 관리하기 위한 속성을 제공합니다. 예를 들어, 자동 수정을 비활성화하고 보안 텍스트 입력을 활성화하는 것은 다음과 같이 할 수 있습니다:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
또한, 개발자는 특히 비밀번호와 PIN과 같은 민감한 정보를 입력하는 텍스트 필드에서 `autocorrectionType`을 `UITextAutocorrectionTypeNo`로 설정하고 `secureTextEntry`를 `YES`로 설정하여 캐싱을 비활성화해야 합니다.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **로그**

디버깅 코드는 종종 **로그 기록**을 사용합니다. **로그에는 민감한 정보가 포함**될 수 있으므로 위험이 따릅니다. 이전에는 iOS 6 및 이전 버전에서 모든 앱이 로그에 액세스할 수 있어 민감한 데이터 유출의 위험이 있었습니다. **현재는 애플리케이션이 자신의 로그에만 액세스할 수 있도록 제한**되어 있습니다.

그러나 **잠금 해제된 기기에 물리적 액세스** 권한이 있는 공격자는 컴퓨터에 기기를 연결하고 **로그를 읽을 수 있습니다**. 앱을 제거한 후에도 로그는 디스크에 남아 있음을 주의해야 합니다.

위험을 완화하기 위해 앱과 상호 작용하여 모든 기능과 입력을 철저히 확인하여 민감한 정보가 부주의하게 기록되지 않도록 해야 합니다.

잠재적인 유출을 확인하기 위해 앱의 소스 코드를 검토할 때, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf`와 같은 내장 함수에 대한 **미리 정의된** 및 **사용자 정의 로깅 문장**을 찾아야 하며, 사용자 정의 구현에 대한 `Logging` 또는 `Logfile`과 같은 언급도 확인해야 합니다.

### **시스템 로그 모니터링**

앱은 민감할 수 있는 다양한 정보를 기록합니다. 이러한 로그를 모니터링하기 위해 다음과 같은 도구와 명령을 사용할 수 있습니다:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
유용합니다. 또한, **Xcode**는 콘솔 로그를 수집하는 방법을 제공합니다:

1. Xcode를 엽니다.
2. iOS 기기를 연결합니다.
3. **Window** -> **Devices and Simulators**로 이동합니다.
4. 기기를 선택합니다.
5. 조사 중인 문제를 트리거합니다.
6. **Open Console** 버튼을 사용하여 새 창에서 로그를 확인합니다.

더 고급 로깅을 위해서는 기기 쉘에 연결하고 **socat**을 사용하여 실시간 로그 모니터링을 할 수 있습니다:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
로그 활동을 관찰하기 위한 명령어는 문제 진단이나 로그에서의 잠재적인 데이터 유출 식별에 매우 유용할 수 있습니다.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)를 사용하여 세계에서 가장 고급인 커뮤니티 도구를 기반으로 한 **워크플로우를 쉽게 구축하고 자동화**할 수 있습니다.\
오늘 바로 액세스하세요:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## 백업

iOS에는 iTunes(맥OS 카탈리나 이전 버전까지), Finder(맥OS 카탈리나 이후 버전부터) 또는 iCloud를 통해 장치 데이터 사본을 쉽게 만들 수 있는 **자동 백업 기능**이 통합되어 있습니다. 이러한 백업은 Apple Pay 세부 정보 및 Touch ID 설정과 같은 매우 민감한 요소를 제외한 거의 모든 장치 데이터를 포함합니다.

### 보안 위험

백업에 **설치된 앱과 그 데이터**가 포함되면 데이터 유출 가능성과 **백업 수정이 앱 기능을 변경**할 수 있는 위험성이 증가합니다. 이러한 위험을 완화하기 위해 **앱의 디렉토리나 하위 디렉토리에 민감한 정보를 평문으로 저장하지 않는 것이 좋습니다**.

### 백업에서 파일 제외하기

`Documents/` 및 `Library/Application Support/`에 있는 파일은 기본적으로 백업됩니다. 개발자는 `NSURLIsExcludedFromBackupKey`를 사용하여 `NSURL setResourceValue:forKey:error:`를 통해 특정 파일이나 디렉토리를 백업에서 제외할 수 있습니다. 이러한 관행은 민감한 데이터가 백업에 포함되는 것을 방지하기 위해 중요합니다.

### 취약점 테스트

앱의 백업 보안을 평가하기 위해, Finder를 사용하여 **백업을 생성**한 다음 [Apple의 공식 문서](https://support.apple.com/en-us/HT204215)의 안내를 따라 백업을 찾습니다. 백업을 분석하여 앱 동작에 영향을 줄 수 있는 민감한 데이터나 설정을 확인합니다.

민감한 정보는 명령 줄 도구나 [iMazing](https://imazing.com)과 같은 애플리케이션을 사용하여 찾을 수 있습니다. 암호화된 백업의 경우, 백업의 루트에 있는 "Manifest.plist" 파일에서 "IsEncrypted" 키를 확인하여 암호화 여부를 확인할 수 있습니다.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
암호화된 백업 파일을 다루기 위해, [DinoSec의 GitHub 저장소](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts)에서 제공하는 Python 스크립트인 **backup_tool.py**와 **backup_passwd.py**가 유용할 수 있습니다. 다만, 최신 iTunes/Finder 버전과 호환성을 위해 조정이 필요할 수 있습니다. [**iOSbackup** 도구](https://pypi.org/project/iOSbackup/)는 비밀번호로 보호된 백업 내의 파일에 접근하는 또 다른 옵션입니다.

### 앱 동작 수정하기

백업 수정을 통해 앱 동작을 변경하는 예시로는 [Bither 비트코인 지갑 앱](https://github.com/bither/bither-ios)이 있습니다. 이 앱에서는 UI 잠금 PIN이 **pin_code** 키 아래의 `net.bither.plist`에 저장됩니다. 이 키를 plist에서 제거하고 백업을 복원하면 PIN 요구 사항이 제거되어 제한 없이 액세스할 수 있습니다.

## 민감한 데이터에 대한 메모리 테스트 요약

애플리케이션의 메모리에 저장된 민감한 정보를 다룰 때는 이 데이터의 노출 시간을 제한하는 것이 중요합니다. 메모리 내용을 조사하는 두 가지 주요 접근 방식이 있습니다: **메모리 덤프 생성**과 **실시간으로 메모리 분석**. 덤프 프로세스나 분석 중에 중요한 데이터를 놓칠 수 있는 등 각 방법에는 도전 과제가 있습니다.

## **메모리 덤프 검색 및 분석**

유선된 기기와 비유선된 기기 모두에서 [objection](https://github.com/sensepost/objection)과 [Fridump](https://github.com/Nightbringer21/fridump)와 같은 도구를 사용하여 앱의 프로세스 메모리를 덤프할 수 있습니다. 덤프한 후에는 찾고자 하는 정보의 성격에 따라 다양한 도구를 사용하여 이 데이터를 분석할 수 있습니다.

메모리 덤프에서 문자열을 추출하기 위해 `strings` 또는 `rabin2 -zz`와 같은 명령을 사용할 수 있습니다:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
더 자세한 분석을 위해 특정 데이터 유형이나 패턴을 검색하는 경우, **radare2**는 광범위한 검색 기능을 제공합니다:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **런타임 메모리 분석**

**r2frida**는 메모리 덤프 없이 앱의 메모리를 실시간으로 검사하는 강력한 대안을 제공합니다. 이 도구를 사용하면 실행 중인 애플리케이션의 메모리에 직접 검색 명령을 실행할 수 있습니다:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## 암호화 결함

### 키 관리 과정의 미숙함

일부 개발자는 민감한 데이터를 로컬 저장소에 저장하고 코드에서 하드코딩/예측 가능한 키로 암호화합니다. 이는 공격자가 기밀 정보를 추출할 수 있는 역공학을 통해 이루어질 수 있으므로 이를 수행해서는 안 됩니다.

### 보안이 취약하거나 사용되지 않는 알고리즘의 사용

개발자는 **사용되지 않는 알고리즘**을 사용하여 **인증** 확인, 데이터 **저장** 또는 **전송**을 수행해서는 안 됩니다. 이러한 알고리즘 중 일부는 RC4, MD4, MD5, SHA1 등입니다. 예를 들어 암호를 저장하기 위해 해시가 사용된다면, 소금(salt)과 함께 해시 브루트 포스에 강한 알고리즘을 사용해야 합니다.

### 확인

코드에서 **하드코딩된** 비밀번호/비밀 정보를 찾을 수 있는지, 그리고 해당 정보가 **예측 가능한지**, 코드가 어떤 종류의 **약한** **암호화** 알고리즘을 사용하는지 확인하는 것이 주요한 점검 사항입니다.

흥미로운 점은 **objection**을 사용하여 일부 **암호화** **라이브러리**를 자동으로 **모니터링**할 수 있다는 것입니다. 다음과 같이 수행할 수 있습니다:
```swift
ios monitor crypt
```
**더 많은 정보**는 iOS 암호화 API 및 라이브러리에 대해 [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)에서 확인할 수 있습니다.

## 로컬 인증

**로컬 인증**은 특히 암호화 방법을 통해 원격 엔드포인트의 접근을 보호하는 경우에 중요한 역할을 합니다. 여기에서 중요한 점은 적절한 구현 없이 로컬 인증 메커니즘은 우회될 수 있다는 것입니다.

애플의 **[로컬 인증 프레임워크](https://developer.apple.com/documentation/localauthentication)**와 **[키체인](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)**은 각각 사용자 인증 대화 상자를 용이하게 처리하고 비밀 데이터를 안전하게 처리하기 위한 강력한 API를 제공합니다. Secure Enclave는 Touch ID의 지문 ID를 안전하게 보호하며, Face ID는 생체 인식 데이터를 유출하지 않고 얼굴 인식에 의존합니다.

Touch ID/Face ID를 통합하기 위해 개발자는 두 가지 API 선택지가 있습니다:
- **`LocalAuthentication.framework`**: 생체 인증 데이터에 액세스할 수 없는 고수준 사용자 인증을 위한 것입니다.
- **`Security.framework`**: 생체 인증을 통해 비밀 데이터를 안전하게 보호하기 위한 낮은 수준의 키체인 서비스 액세스입니다. 다양한 [오픈 소스 래퍼](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id)를 사용하면 키체인 액세스가 간단해집니다.

{% hint style="danger" %}
그러나 `LocalAuthentication.framework`와 `Security.framework` 모두 인증 프로세스에 대한 데이터를 전송하지 않고 주로 부울 값만 반환하기 때문에 우회될 수 있는 취약점이 있습니다. 자세한 내용은 [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)를 참조하십시오.
{% endhint %}

### 로컬 인증 구현

사용자 인증을 위해 개발자는 **`LAContext`** 클래스 내의 **`evaluatePolicy`** 메서드를 사용해야 합니다. 다음 중 하나를 선택할 수 있습니다:
- **`deviceOwnerAuthentication`**: Touch ID 또는 장치 암호를 요청하며, 둘 다 사용하지 않는 경우 실패합니다.
- **`deviceOwnerAuthenticationWithBiometrics`**: 오로지 Touch ID를 요청합니다.

**`evaluatePolicy`**에서 반환된 부울 값으로 성공적인 인증을 나타낼 수 있으며, 잠재적인 보안 결함을 강조합니다.

### 키체인을 사용한 로컬 인증

iOS 앱에서 **로컬 인증**을 구현하기 위해서는 **키체인 API**를 사용하여 인증 토큰과 같은 비밀 데이터를 안전하게 저장해야 합니다. 이 과정은 데이터가 사용자에 의해만 액세스될 수 있도록 보장하기 위해 장치 암호나 Touch ID와 같은 생체 인증을 사용합니다.

키체인은 `SecAccessControl` 속성을 사용하여 항목에 액세스를 제한할 수 있으며, 사용자가 Touch ID나 장치 암호를 통해 성공적으로 인증할 때까지 항목에 대한 액세스를 제한합니다. 이 기능은 보안을 강화하는 데 중요합니다.

아래는 Swift와 Objective-C에서 문자열을 키체인에 저장하고 검색하는 방법을 보여주는 코드 예제입니다. 이 예제는 특히 Touch ID 인증이 필요하도록 액세스 제어를 설정하고, 데이터가 설정된 장치에서만 액세스할 수 있도록 하는 조건에서 작동합니다.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}목표-C
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

이제 우리는 키체인에서 저장된 항목을 요청할 수 있습니다. 키체인 서비스는 사용자에게 인증 대화 상자를 표시하고 적절한 지문이 제공되었는지 여부에 따라 데이터 또는 nil을 반환합니다.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}목표-C
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### 탐지

앱에서 프레임워크의 사용은 앱 바이너리의 공유 동적 라이브러리 목록을 분석하여 탐지할 수도 있습니다. 이를 위해 `otool`을 사용할 수 있습니다:
```bash
$ otool -L <AppName>.app/<AppName>
```
만약 앱에서 `LocalAuthentication.framework`를 사용한다면, 출력에는 다음 두 줄이 포함됩니다 (`LocalAuthentication.framework`는 내부적으로 `Security.framework`를 사용합니다):

```plaintext
[+] LocalAuthentication.framework is being used
[+] Security.framework is being used
```
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
만약 `Security.framework`가 사용된다면, 두 번째 것만 표시됩니다.

### 로컬 인증 프레임워크 우회

#### **Objection**

**Objection 바이오메트릭스 우회**를 통해, [이 GitHub 페이지](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass)에서 사용 가능한 기술로 **LocalAuthentication** 메커니즘을 우회할 수 있습니다. 이 접근 방식의 핵심은 **Frida**를 활용하여 `evaluatePolicy` 함수를 조작하여 실제 인증 성공 여부와 관계없이 항상 `True` 결과를 반환하도록 하는 것입니다. 이는 결함이 있는 생체 인증 프로세스를 우회하는 데 특히 유용합니다.

이 우회를 활성화하기 위해 다음 명령을 사용합니다:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
이 명령은 Objection이 작업을 등록하여 `evaluatePolicy` 검사의 결과를 `True`로 변경하는 일련의 과정을 시작합니다.

#### Frida

[DVIA-v2 애플리케이션](https://github.com/prateek147/DVIA-v2)에서 **`evaluatePolicy`**의 사용 예시:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
로컬 인증의 **우회**를 위해 Frida 스크립트를 작성합니다. 이 스크립트는 **evaluatePolicy** 확인을 대상으로 하며, 콜백을 가로채어 항상 **success=1**을 반환하도록 보장합니다. 콜백의 동작을 변경함으로써 인증 확인이 효과적으로 우회됩니다.

아래 스크립트는 **evaluatePolicy** 메서드의 결과를 수정하기 위해 주입됩니다. 이 스크립트는 콜백의 결과를 항상 성공으로 표시하도록 변경합니다.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida 스크립트를 주입하고 생체 인증을 우회하기 위해 다음 명령을 사용합니다:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC를 통한 민감한 기능 노출

### 사용자 정의 URI 핸들러 / 딥링크 / 사용자 정의 스키마

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Universal Links

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity 공유

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### 앱 확장

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### 직렬화 및 인코딩

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## 네트워크 통신

**암호화 없이** 통신이 발생하지 않는지 확인하는 것이 중요하며, 애플리케이션이 서버의 TLS 인증서를 올바르게 **검증**하는지도 확인해야 합니다.\
이러한 문제를 확인하기 위해 **Burp**와 같은 프록시를 사용할 수 있습니다:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### 호스트 이름 확인

TLS 인증서를 올바르게 검증하는 일반적인 문제는 인증서가 **신뢰할 수 있는 CA에 의해 서명되었는지** 확인하는 것이지만, 인증서의 **호스트 이름**이 액세스 중인 호스트 이름과 일치하는지 **확인하지 않는 것**입니다.\
이 문제를 Burp를 사용하여 확인하려면, iPhone에서 Burp CA를 신뢰한 후, Burp를 사용하여 **다른 호스트 이름에 대한 새 인증서를 생성**하고 사용할 수 있습니다. 애플리케이션이 여전히 작동하는 경우, 취약점이 존재하는 것입니다.

### 인증서 핀단

애플리케이션이 SSL 핀단을 올바르게 사용하는 경우, 인증서가 예상대로인 경우에만 애플리케이션이 작동합니다. 테스트 중인 애플리케이션의 경우, Burp가 자체 인증서를 제공하기 때문에 문제가 발생할 수 있습니다.\
이 보호 기능을 우회하기 위해 탈옥된 장치에서 [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) 애플리케이션을 설치하거나 [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)를 설치할 수 있습니다.

또한 **objection**의 `ios sslpinning disable`을 사용할 수도 있습니다.

## 기타

* **`/System/Library`**에는 시스템 애플리케이션에서 사용하는 전화에 설치된 프레임워크가 있습니다.
* 사용자가 앱 스토어에서 설치한 애플리케이션은 **`/User/Applications`**에 위치합니다.
* 그리고 **`/User/Library`**에는 사용자 레벨 애플리케이션에서 저장된 데이터가 포함되어 있습니다.
* **`/User/Library/Notes/notes.sqlite`**에 애플리케이션 내에 저장된 노트를 읽을 수 있습니다.
* 설치된 애플리케이션의 폴더 내부(**`/User/Applications/<APP ID>/`**)에서 몇 가지 흥미로운 파일을 찾을 수 있습니다:
* **`iTunesArtwork`**: 앱에서 사용하는 아이콘
* **`iTunesMetadata.plist`**: 앱 스토어에서 사용되는 앱 정보
* **`/Library/*`**: 환경 설정 및 캐시가 포함되어 있습니다. **`/Library/Cache/Snapshots/*`**에서는 백그라운드로 보내기 전에 애플리케이션에 대한 스냅샷을 찾을 수 있습니다.

### 핫 패칭/강제 업데이트

개발자는 앱을 다시 제출하고 승인될 때까지 기다릴 필요 없이 모든 설치된 앱을 원격으로 **즉시 패치**할 수 있습니다.\
이를 위해 일반적으로 [**JSPatch**](https://github.com/bang590/JSPatch)와 같은 것이 사용됩니다. 그러나 [Siren](https://github.com/ArtSabintsev/Siren) 및 [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker)와 같은 다른 옵션도 있습니다.\
**이는 악성 제3자 SDK에 의해 남용될 수 있는 위험한 메커니즘이므로 자동 업데이트에 사용되는 방법(있는 경우)을 확인하고 테스트하는 것이 좋습니다.** 이를 위해 이전 버전의 앱을 다운로드해 볼 수 있습니다.

### 제3자

**제3자 SDK**의 중요한 도전 과제는 그들의 기능에 대한 **세분화된 제어 부재**입니다. 개발자는 다음과 같은 선택을 직면합니다: 잠재적인 보안 취약점과 개인 정보 보호 문제를 포함한 모든 기능을 통합하거나 이러한 이점을 완전히 포기합니다. 종종 개발자는 이러한 SDK 내에서 취약점을 패치할 수 없습니다. 또한 SDK가 커뮤니티에서 신뢰를 얻으면 일부는 악성 코드를 포함할 수도 있습니다.

제3자 SDK가 제공하는 서비스에는 사용자 동작 추적, 광고 표시 또는 사용자 경험 향상이 포함될 수 있습니다. 그러나 이는 개발자가 이러한 라이브러리에서 실행되는 코드를 완전히 인식하지 못할 수 있으므로 잠재적인 개인 정보 보호 및 보안 위험을 야기할 수 있습니다. 제3자 서비스와 공유되는 정보는 필요한 정보에 한정되도록 하고 민감한 데이터가 노출되지 않도록 해야 합니다.

제3자 서비스의 구현은 일반적으로 독립 실행형 라이브러리 또는 완전한 SDK 형태로 제공됩니다. 이러한 서비스와 공유되는 데이터는 **익명화**되어야 하며 개인 식별 정보(PII)의 공개를 방지해야 합니다.

애플리케이션이 사용하는 라이브러리를 식별하기 위해 **`otool`** 명령을 사용할 수 있습니다. 이 도구는 애플리케이션과 각 공유 라이브러리에 대해 실행되어 추가 라이브러리를 발견할 수 있습니다.
```bash
otool -L <application_path>
```
## **참고 자료 및 추가 자원**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS 및 모바일 앱 펜테스팅 - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS 무료 강좌([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C 버전 [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift 버전
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)를 사용하여 세계에서 가장 고급인 커뮤니티 도구를 활용한 **워크플로우를 쉽게 구축하고 자동화**하세요.\
오늘 바로 액세스하세요:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>로부터 제로에서 영웅까지 AWS 해킹 배우기!</summary>

HackTricks를 지원하는 다른 방법:

* 회사를 **HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**구독 플랜**](https://github.com/sponsors/carlospolop)을 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 **팔로우**하세요. 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **당신의 해킹 기교를 공유**하세요.

</details>
