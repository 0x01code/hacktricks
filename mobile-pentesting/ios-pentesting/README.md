# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik en outomatiese werksvloei te bou met behulp van die w√™reld se mees gevorderde gemeenskaplike gereedskap.\
Kry vandag toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks wil adverteer** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

## iOS Basiese beginsels

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Toetsomgewing

Op hierdie bladsy kan jy inligting vind oor die **iOS-simuleerder**, **emulators** en **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Aanvanklike analise

### Basiese iOS-toetsoperasies

Tydens die toetsing sal verskeie operasies voorgestel word (verbind met die toestel, lees/skryf/oplaai/aflaai l√™ers, gebruik van gereedskap...). As jy dus nie weet hoe om enige van hierdie aksies uit te voer nie, **begin deur die bladsy te lees**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Vir die volgende stappe **moet die toepassing ge√Ønstalleer wees** op die toestel en moet jy reeds die **IPA-l√™er** van die toepassing verkry het.\
Lees die [Basiese iOS-toetsoperasies](basic-ios-testing-operations.md) bladsy om te leer hoe om dit te doen.
{% endhint %}

### Basiese statiese analise

Dit word aanbeveel om die instrument [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) te gebruik om 'n outomatiese statiese analise op die IPA-l√™er uit te voer.

Identifikasie van **beskermings wat teenwoordig is in die bin√™re l√™er**:

*   **PIE (Position Independent Executable)**: Wanneer dit geaktiveer is, laai die toepassing in 'n willekeurige geheue-adres elke keer as dit begin, wat dit moeiliker maak om sy aanvanklike geheue-adres te voorspel.

```bash
otool -hv <app-bin√™re> | grep PIE   # Dit moet die PIE-vlag insluit
```
*   **Stack Canaries**: Om die integriteit van die stapel te valideer, word 'n 'kanarie'-waarde op die stapel geplaas voordat 'n funksie geroep word en weer gevalideer sodra die funksie eindig.

```bash
otool -I -v <app-bin√™re> | grep stack_chk   # Dit moet die simbole: stack_chk_guard en stack_chk_fail insluit
```
*   **ARC (Automatic Reference Counting)**: Om algemene geheuekorruptie-foute te voorkom

```bash
otool -I -v <app-bin√™re> | grep objc_release   # Dit moet die _objc_release-simbool insluit
```
*   **Versleutelde Bin√™re**: Die bin√™re l√™er moet versleutel wees

```bash
otool -arch all -Vl <app-bin√™re> | grep -A5 LC_ENCRYPT   # Die cryptid moet 1 wees
```

**Identifikasie van Sensitiewe/Onveilige Funksies**

*   **Swak Hashing-algoritmes**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Op Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Onveilige Willekeurige Funksies**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Op Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Onveilige 'Malloc'-Funksie**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_malloc"

# Op Linux
grep -iER "_malloc"
```
*   **Onveilige en Kwesbare Funksies**

```bash
# Op die iOS-toestel
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Op Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Basiese Dinamiese Analise

Kyk na die dinamiese analise wat [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) uitvoer. Jy sal deur die verskillende aansigte moet blaai en met hulle moet interaksie h√™, maar dit sal verskeie klasse koppel en ander dinge doen en 'n verslag voorberei sodra jy klaar is.

### Lys van Ge√Ønstalleerde Toepassings

Gebruik die opdrag `frida-ps -Uai` om die **bundel-identifiseerder** van die ge√Ønstalleerde toepassings te bepaal:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Basiese Enumerasie & Hooking

Leer hoe om die komponente van die toepassing te **enumerateer** en hoe om maklik **metodes en klasse te hook** met objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA-Struktuur

Die struktuur van 'n **IPA-l√™er** is essensieel di√© van 'n **gezippte pakkie**. Deur die uitbreiding te verander na `.zip`, kan dit **gedekomprimeer** word om sy inhoud te onthul. Binne hierdie struktuur verteenwoordig 'n **Bundel** 'n volledig verpakte toepassing gereed vir installasie. Binne-in sal jy 'n gids vind met die naam `<NAME>.app`, wat die hulpbronne van die toepassing inkapsuleer.

* **`Info.plist`**: Hierdie l√™er bevat spesifieke konfigurasiebesonderhede van die toepassing.
* **`_CodeSignature/`**: Hierdie gids bevat 'n plist-l√™er wat 'n handtekening bevat wat die integriteit van alle l√™ers in die bundel verseker.
* **`Assets.car`**: 'n Gekomprimeerde argief wat batesl√™ers soos ikone stoor.
* **`Frameworks/`**: Hierdie gids bevat die toepassing se inheemse biblioteke, wat in die vorm van `.dylib`- of `.framework`-l√™ers kan wees.
* **`PlugIns/`**: Dit kan uitbreidings van die toepassing insluit, bekend as `.appex`-l√™ers, alhoewel hulle nie altyd teenwoordig is nie.
*¬†[**`Kerndata`**](https://developer.apple.com/documentation/coredata): Dit word gebruik om jou toepassing se permanente data vir aflyngebruik te stoor, tydelike data te kasheer en ongedaanmaakfunksionaliteit by jou app op 'n enkele toestel by te voeg. Om data oor meerdere toestelle in 'n enkele iCloud-rekening te sinchroniseer, spie√´l Kerndata outomaties jou skema na 'n CloudKit-houer.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Die `PkgInfo`-l√™er is 'n alternatiewe manier om die tipe en skepperkodes van jou toepassing of bundel te spesifiseer.
* **en.lproj, fr.proj, Base.lproj**: Dit is die taalpakkies wat hulpbronne vir daardie spesifieke tale bevat, en 'n verstekhulpbron in die geval dat 'n taal nie ondersteun word nie.
* **Sekuriteit**: Die `_CodeSignature/`-gids speel 'n kritieke rol in die veiligheid van die app deur die integriteit van alle gebundelde l√™ers deur digitale handtekeninge te verifieer.
* **Batebestuur**: Die `Assets.car`-l√™er gebruik kompressie om grafiese bates doeltreffend te bestuur, wat noodsaaklik is vir die optimalisering van toepassingsprestasie en die vermindering van die algehele grootte daarvan.
* **Raamwerke en Inproppe**: Hierdie gidse beklemtoon die modulariteit van iOS-toepassings, wat ontwikkelaars in staat stel om herbruikbare kodelibras (`Frameworks/`) in te sluit en app-funksionaliteit uit te brei (`PlugIns/`).
* **Lokalisering**: Die struktuur ondersteun meertaligheid, wat globale toepassingsbereik fasiliteer deur hulpbronne vir spesifieke taalpakkies in te sluit.

**Info.plist**

Die **Info.plist** dien as 'n hoeksteen vir iOS-toepassings, wat sleutelkonfigurasiedata inkapsuleer in die vorm van **sleutel-waarde** pare. Hierdie l√™er is nie net 'n vereiste vir toepassings nie, maar ook vir app-uitbreidings en raamwerke wat daarmee saamgevoeg is. Dit is gestruktureer in XML of 'n bin√™re formaat en bevat kritieke inligting wat wissel van app-toestemmings tot sekuriteitskonfigurasies. Vir 'n gedetailleerde verkenning van beskikbare sleutels kan verwys word na die [**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Vir diegene wat met hierdie l√™er wil werk in 'n toegankliker formaat, kan die XML-omskakeling moeiteloos bereik word deur die gebruik van `plutil` op macOS (beskikbaar as 'n standaard op weergawes 10.2 en later) of `plistutil` op Linux. Die opdragte vir omskakeling is as volg:

- **Vir macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Vir Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Onder die menigte van inligting wat die **Info.plist** l√™er kan onthul, sluit merkwaardige inskrywings in soos app-toestemmingsstrings (`UsageDescription`), aangepaste URL-skemas (`CFBundleURLTypes`), en konfigurasies vir App Transport Security (`NSAppTransportSecurity`). Hierdie inskrywings, tesame met ander soos uitgevoerde/ingevoerde aangepaste dokumenttipes (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), kan maklik opgespoor word deur die l√™er te ondersoek of 'n eenvoudige `grep`-opdrag te gebruik:
```bash
$ grep -i <keyword> Info.plist
```
**Data Paaie**

In die iOS-omgewing word gidsies spesifiek aangewys vir **sisteemtoepassings** en **gebruiker-ge√Ønstalleerde toepassings**. Sisteemtoepassings bly in die `/Applications` gids, terwyl gebruiker-ge√Ønstalleerde toepassings onder `/private/var/containers/` geplaas word. Hierdie toepassings word toegewys aan 'n unieke identifiseerder wat bekend staan as 'n **128-bit UUID**, wat die taak van die handmatige vind van 'n toepassing se gidsie uitdagend maak as gevolg van die willekeurigheid van die gidsnaam.

Om die ontdekking van 'n gebruiker-ge√Ønstalleerde toepassing se installasiegids te vergemaklik, bied die **objection tool** 'n nuttige bevel, `env`. Hierdie bevel onthul gedetailleerde gidsinligting vir die betrokke toepassing. Hieronder is 'n voorbeeld van hoe om hierdie bevel te gebruik:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatiewelik kan die app-naam binne die `/private/var/containers` gesoek word met behulp van die `find`-opdrag:
```bash
find /private/var/containers -name "Progname*"
```
Opdragte soos `ps` en `lsof` kan ook gebruik word om die proses van die app te identifiseer en oop l√™ers te lys, onderskeidelik, wat insig bied in die aktiewe gidspaaie van die toepassing:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Bundelgids:**

* **AppName.app**
* Dit is die toepassingsbundel soos voorheen in die IPA gesien, dit bevat noodsaaklike toepassingsdata, statiese inhoud sowel as die toepassing se saamgestelde bin√™re l√™er.
* Hierdie gids is sigbaar vir gebruikers, maar **gebruikers kan nie daarin skryf nie**.
* Inhoud in hierdie gids word **nie rugsteun gegee nie**.
* Die inhoud van hierdie gids word gebruik om die kodesignatuur te **valideer**.

**Datagids:**

* **Documents/**
* Bevat alle gebruikers gegenereerde data. Die toepassing se eindgebruiker begin die skepping van hierdie data.
* Sigbaar vir gebruikers en **gebruikers kan daarin skryf**.
* Inhoud in hierdie gids word **rugsteun gegee**.
* Die toepassing kan paaie uitskakel deur `NSURLIsExcludedFromBackupKey` in te stel.
* **Library/**
* Bevat alle **l√™ers wat nie gebruikers-spesifiek is nie**, soos **geheue-opberging**, **voorkeure**, **koekies**, en eiendomslys (plist) konfigurasie l√™ers.
* iOS-toepassings gebruik gewoonlik die `Application Support` en `Caches` subgidse, maar die toepassing kan aangepaste subgidse skep.
* **Library/Caches/**
* Bevat **semi-blywende gegispte l√™ers**.
* Onsigbaar vir gebruikers en **gebruikers kan nie daarin skryf nie**.
* Inhoud in hierdie gids word **nie rugsteun gegee nie**.
* Die bedryfstelsel kan hierdie gids se l√™ers outomaties verwyder wanneer die toepassing nie loop nie en stoorruimte min is.
* **Library/Application Support/**
* Bevat **blywende l√™ers** wat nodig is vir die uitvoering van die toepassing.
* **Onsigbaar** vir gebruikers en gebruikers kan nie daarin skryf nie.
* Inhoud in hierdie gids word **rugsteun gegee**.
* Die toepassing kan paaie uitskakel deur `NSURLIsExcludedFromBackupKey` in te stel.
* **Library/Preferences/**
* Word gebruik om eienskappe te stoor wat **selfs na die herbegin van 'n toepassing volhou**.
* Inligting word onversleutel binne die toepassing se sandput in 'n plist-l√™er genaamd \[BUNDLE\_ID].plist gestoor.
* Al die sleutel/waarde-pare wat met `NSUserDefaults` gestoor word, kan in hierdie l√™er gevind word.
* **tmp/**
* Gebruik hierdie gids om **tydelike l√™ers** te skryf wat nie tussen toepassingsbeginne volhou nie.
* Bevat nie-blywende gegispte l√™ers.
* **Onsigbaar** vir gebruikers.
* Inhoud in hierdie gids word nie rugsteun gegee nie.
* Die bedryfstelsel kan hierdie gids se l√™ers outomaties verwyder wanneer die toepassing nie loop nie en stoorruimte min is nie.

Kom ons kyk nou na iGoat-Swift se Toepassingsbundel (.app) gids binne die Bundelgids (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Bin√™re Omkeer

Binne die `<application-name>.app`-map sal jy 'n bin√™re l√™er kry genaamd `<application-name>`. Dit is die l√™er wat **uitgevoer** sal word. Jy kan 'n basiese inspeksie van die bin√™re l√™er doen met die hulpmiddel **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Kyk of die app versleutel is**

Kyk of daar enige uitset is vir:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Ontleding van die bin√™re**

Ontleed die teksafdeling:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Om die **Objective-C-segment** van die voorbeeldtoepassing af te druk, kan 'n mens die volgende gebruik:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Om 'n meer kompakte Objective-C-kode te verkry, kan jy [**class-dump**](http://stevenygard.com/projects/class-dump/) gebruik:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Togtans, die beste opsies om die bin√™re l√™er te ontbind is: [**Hopper**](https://www.hopperapp.com/download.html?) en [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik werkstrome te bou en outomatiseer met behulp van die w√™reld se mees gevorderde gemeenskaplike gereedskap.\
Kry Vandag Toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Data Berging

Om te leer hoe iOS data in die toestel stoor, lees hierdie bladsy:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Die volgende plekke om inligting te stoor moet **direk na die installering van die toepassing** nagegaan word, **nadat al die funksies** van die toepassing nagegaan is, en selfs nadat **uitgelog is uit een gebruiker en ingelog is as 'n ander een**.\
Die doel is om **ongebeskermd sensitiewe inligting** van die toepassing (wagwoorde, tokens), van die huidige gebruiker en van vorige aangemelde gebruikers te vind.
{% endhint %}

### Plist

**plist**-l√™ers is gestruktureerde XML-l√™ers wat **sleutel-waarde pare bevat**. Dit is 'n manier om volgehoue data te stoor, so soms kan jy **sensitiewe inligting in hierdie l√™ers vind**. Dit word aanbeveel om hierdie l√™ers na die installering van die app en na intensiewe gebruik daarvan te ondersoek om te sien of nuwe data geskryf word.

Die mees algemene manier om data in plist-l√™ers vol te hou, is deur die gebruik van **NSUserDefaults**. Hierdie plist-l√™er word binne die app-sandbox gestoor in **`Library/Preferences/<appBundleID>.plist`**

Die [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) klas bied 'n programmatiese koppelvlak vir die interaksie met die verstekstelsel. Die verstekstelsel maak dit vir 'n toepassing moontlik om sy gedrag aan te pas volgens **gebruikersvoorkeure**. Data wat deur `NSUserDefaults` gestoor word, kan in die toepassingsbundel besigtig word. Hierdie klas stoor **data** in 'n **plist-l√™er**, maar dit is bedoel om met klein hoeveelhede data gebruik te word.

Hierdie data kan nie direk via 'n betroubare rekenaar benader word nie, maar kan benader word deur 'n **back-up** uit te voer.

Jy kan die gestoorde inligting **dump** deur **`NSUserDefaults`** te gebruik met behulp van objection se `ios nsuserdefaults get`

Om al die plist-l√™ers wat deur die toepassing gebruik word, te vind, kan jy toegang verkry tot `/private/var/mobile/Containers/Data/Application/{APPID}` en die volgende uitvoer:
```bash
find ./ -name "*.plist"
```
Om l√™ers vanaf **XML of bin√™re (bplist)** formaat na XML te omskep, is verskeie metodes beskikbaar, afhangende van jou bedryfstelsel:

**Vir macOS-gebruikers:**
Gebruik die `plutil` opdrag. Dit is 'n ingeboude hulpmiddel in macOS (10.2+), ontwerp vir hierdie doel:

```bash
plutil -convert xml1 <file>
```

Hierdie opdrag sal die l√™er omskep na XML-formaat en dit sal die oorspronklike l√™er vervang met die nuwe XML-l√™er.
```bash
$ plutil -convert xml1 Info.plist
```
**Vir Linux-gebruikers:**
Installeer eers `libplist-utils` en gebruik dan `plistutil` om jouw l√™er om te skakel:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Binne 'n Objection-sessie:**
Vir die analise van mobiele toepassings, stel 'n spesifieke bevel jou in staat om plist-l√™ers direk om te skakel:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) is 'n raamwerk vir die bestuur van die model-laag van voorwerpe in jou aansoek. [Core Data kan SQLite gebruik as sy volhoubare stoor](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), maar die raamwerk self is nie 'n databasis nie.\
CoreData enkripteer nie sy data standaard nie. 'n Bykomende enkripsie-laag kan egter by CoreData gevoeg word. Sien die [GitHub Repo](https://github.com/project-imas/encrypted-core-data) vir meer besonderhede.

Jy kan die SQLite Core Data-inligting van 'n aansoek vind in die pad `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**As jy die SQLite kan oopmaak en toegang tot sensitiewe inligting kan verkry, het jy 'n verkeerde konfigurasie gevind.**

{% code title="Kode van iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) is 'n sleutel/waarde-stoor wat gebou is op SQLite.\
Aangesien die Yap-databasis sqlite-databasisse is, kan jy hulle vind deur die voorgestelde opdrag in die vorige afdeling te gebruik.

### Ander SQLite-databasisse

Dit is algemeen vir programme om hul eie sqlite-databasis te skep. Hulle kan **sensitiewe** **data** daarop **berg** en dit onversleuteld agterlaat. Daarom is dit altyd interessant om elke databasis binne die toepassingsgids te ondersoek. Gaan dus na die toepassingsgids waar die data gestoor word (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databasis

Ontwikkelaars kan data stoor en sinchroniseer binne 'n NoSQL-wolk-gehoste databasis deur middel van Firebase Real-Time Databasisse. Die data word in JSON-formaat gestoor en word in werklike tyd gesinchroniseer na alle gekoppelde kli√´nte.

Jy kan hier vind hoe om vir verkeerd gekonfigureerde Firebase databasisse te kyk:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm databasisse

[Realm Objective-C](https://realm.io/docs/objc/latest/) en [Realm Swift](https://realm.io/docs/swift/latest/) bied 'n kragtige alternatief vir data-opberging wat nie deur Apple voorsien word nie. Standaard stoor hulle data onversleutel, met versleuteling beskikbaar deur spesifieke konfigurasie.

Die databasisse is gele√´ by: `/private/var/mobile/Containers/Data/Application/{APPID}`. Om hierdie l√™ers te verken, kan mens opdragte soos die volgende gebruik:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Om hierdie databasisl√™ers te sien, word die [**Realm Studio**](https://github.com/realm/realm-studio) hulpmiddel aanbeveel.

Om versleuteling binne 'n Realm-databasis te implementeer, kan die volgende kodefragment gebruik word:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Databasis

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) word beskryf as 'n **liggewig** en **ingebedde** databasis-enjin wat die **dokumentgeori√´nteerde** (NoSQL) benadering volg. Dit is ontwerp om inheems te wees aan **iOS** en **macOS**, en bied die vermo√´ om data naadloos te sinchroniseer.

Om potensi√´le Couchbase-databasisse op 'n toestel te identifiseer, moet die volgende gids ondersoek word:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Koekies

iOS stoor die koekies van die programme in die **`Library/Cookies/cookies.binarycookies`** binne elke program se vouer. Ontwikkelaars besluit egter soms om hulle in die **sleutelketting** te stoor, aangesien die genoemde **koekie-l√™er in rugsteun toeganklik is**.

Om die koekie-l√™er te ondersoek, kan jy [**hierdie Python-skripsie**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) gebruik of gebruik maak van objection se **`ios cookies get`.**\
**Jy kan ook objection gebruik om hierdie l√™ers na 'n JSON-formaat te omskep en die data te ondersoek.**
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Standaard stoor NSURLSession data, soos **HTTP-aanvrae en -antwoorde in die Cache.db** databasis. Hierdie databasis kan **sensitiewe data** bevat, as tokens, gebruikersname of enige ander sensitiewe inligting gestoor is. Om die gestoorde inligting te vind, open die data-gids van die app (`/var/mobile/Containers/Data/Application/<UUID>`) en gaan na `/Library/Caches/<Bundle Identifier>`. Die **WebKit-cache word ook in die Cache.db**-l√™er gestoor. **Objection** kan die databasis oopmaak en daarmee interaksie h√™ met die opdrag `sqlite connect Cache.db`, aangesien dit 'n **normale SQLite-databasis** is.

Dit word **aanbeveel om hierdie data se caching uit te skakel**, aangesien dit sensitiewe inligting in die versoek of antwoord kan bevat. Die volgende lys toon verskillende maniere om dit te bereik:

1. Dit word aanbeveel om gestoorde antwoorde te verwyder na afmelding. Dit kan gedoen word met die metode wat deur Apple voorsien word, genaamd [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Jy kan hierdie metode so oproep:

`URLCache.shared.removeAllCachedResponses()`

Hierdie metode sal alle gestoorde versoek en antwoorde uit die Cache.db-l√™er verwyder.
2. As jy nie die voordeel van koekies hoef te gebruik nie, word dit aanbeveel om net die [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfigurasie-eienskap van URLSession te gebruik, wat die stoor van koekies en Cache uitskakel.

[Apple-dokumentasie](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`'n Ephemeral-sessiekonfigurasie-objek is soortgelyk aan 'n verstek-sessiekonfigurasie (sien verstek), behalwe dat die ooreenstemmende sessie-objek nie Cache, geloofsbriewestoorplekke of enige sessie-verwante data na skyf stoor nie. In plaas daarvan word sessie-verwante data in RAM gestoor. Die enigste keer wat 'n ephemeral-sessie data na skyf skryf, is wanneer jy dit s√™ om die inhoud van 'n URL na 'n l√™er te skryf.`
3. Cache kan ook uitgeskakel word deur die Cache-beleid in te stel op [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Dit sal die stoor van Cache in enige vorm, hetsy in geheue of op skyf, uitskakel.

### Snapshots

Telkens as jy die tuisknoppie druk, neem iOS **'n skermafdruk van die huidige skerm** om die oorgang na die toepassing baie vlotter te maak. As daar egter **sensitiewe data** in die huidige skerm is, sal dit in die **beeld gestoor word** (wat **oorleef** **herlaaiings**). Dit is die skermafdrukke wat jy ook kan toegang deur dubbel te tik op die tuisskerm om tussen programme te skakel.

Tensy die iPhone gejailbreak is, moet die **aanvaller** toegang tot die **ontgrendelde toestel** h√™ om hierdie skermafdrukke te sien. Standaard word die laaste skermafdruk gestoor in die toepassing se sandput in die `Library/Caches/Snapshots/` of `Library/SplashBoard/Snapshots`-gids (vertroude rekenaars kan nie die l√™ersisteem vanaf iOS 7.0 toegang nie).

Een manier om hierdie slegte gedrag te voorkom, is om 'n le√´ skerm te plaas of die sensitiewe data te verwyder voordat die skermafdruk geneem word deur die `ApplicationDidEnterBackground()`-funksie te gebruik.

Die volgende is 'n voorbeeld van 'n herstelmetode wat 'n verstekskermafdruk sal instel.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C is 'n objekgeori√´nteerde programmeertaal wat gebruik word vir die ontwikkeling van iOS-toepassings. Dit is 'n uitbreiding van die C-programmeertaal en voeg 'n stel objekgeori√´nteerde funksies en sintaksis by. Objective-C is die prim√™re programmeertaal wat gebruik word vir die ontwikkeling van iOS-toepassings voordat Swift bekend gestel is.

Objective-C is 'n kragtige taal wat 'n groot verskeidenheid funksies en biblioteke bied vir die ontwikkeling van iOS-toepassings. Dit maak gebruik van 'n sintaksis wat bekend staan as "message passing" om met objekte te kommunikeer. Hierdie sintaksis maak dit moontlik om metode-oproepe na objekte te maak en data tussen objekte te stuur.

Objective-C bied ook 'n sterk refleksie-meganisme wat dit moontlik maak om objekte te ondersoek en te manipuleer tydens uitvoering. Hierdie refleksie-meganisme kan gebruik word vir gevorderde tegnieke soos swak punte-ontleding en dinamiese kode-generering.

As jy belangstel in die ontwikkeling van iOS-toepassings, is dit belangrik om 'n goeie begrip van Objective-C te h√™. Dit sal jou help om die iOS-raamwerk en biblioteke te verstaan en om effektiewe en kragtige toepassings te ontwikkel.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Hierdie stel die agtergrondbeeld na `overlayImage.png` wanneer die toepassing agtergrond toegepas word. Dit voorkom dat sensitiewe data uitlek omdat `overlayImage.png` altyd die huidige aansig sal oorskryf.

### Sleutelbos

Vir toegang tot en bestuur van die iOS-sleutelbos, is daar gereedskap soos [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) beskikbaar, wat geskik is vir gejailbreakte toestelle. Daarbenewens bied [**Objection**](https://github.com/sensepost/objection) die opdrag `ios keychain dump` vir soortgelyke doeleindes.

#### **Bewaring van Geldele**

Die **NSURLCredential**-klas is ideaal vir die stoor van sensitiewe inligting direk in die sleutelbos, sonder die behoefte aan NSUserDefaults of ander omhulsels. Om geldele na aanmelding te stoor, word die volgende Swift-kode gebruik:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Om hierdie gestoorde geloofsbriewe te onttrek, word die bevel `ios nsurlcredentialstorage dump` van Objection gebruik.

## **Aangepaste Sleutelborde en Sleutelbord Cache**

Met iOS 8.0 en later kan gebruikers aangepaste sleutelborduitbreidings installeer, wat bestuurbaar is onder **Instellings > Algemeen > Sleutelbord > Sleutelborde**. Terwyl hierdie sleutelborde uitgebreide funksionaliteit bied, stel dit 'n risiko van sleutelbordlogboekinskrywing en die oordra van data na eksterne bedieners, alhoewel gebruikers in kennis gestel word van sleutelborde wat netwerktoegang vereis. Apps kan, en moet, die gebruik van aangepaste sleutelborde vir sensitiewe inligting beperk.

**Veiligheidsaanbevelings:**
- Dit word aanbeveel om derdeparty-sleutelborde te deaktiveer vir verbeterde veiligheid.
- Wees bewus van die outokorreksie en outo-voorstel funksies van die verstek iOS-sleutelbord, wat sensitiewe inligting in kasl√™ers wat in `Library/Keyboard/{locale}-dynamic-text.dat` of `/private/var/mobile/Library/Keyboard/dynamic-text.dat` gele√´ is, kan stoor. Hierdie kasl√™ers moet gereeld nagegaan word vir sensitiewe data. Dit word aanbeveel om die sleutelbordwoordeboek te herstel via **Instellings > Algemeen > Herstel > Herstel Sleutelbordwoordeboek** om gekasheerde data te skoonmaak.
- Die onderskepping van netwerkverkeer kan onthul of 'n aangepaste sleutelbord sleutelinskrywings op afstand oordra.

### **Voorkoming van Teksveldkasgebruik**

Die [UITextInputTraits-protokol](https://developer.apple.com/reference/uikit/uitextinputtraits) bied eienskappe om outokorreksie en veilige teksinskrywing te bestuur, wat noodsaaklik is vir die voorkoming van die kasgebruik van sensitiewe inligting. Byvoorbeeld, die deaktivering van outokorreksie en die aktivering van veilige teksinskrywing kan bereik word met:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Daarbenewens moet ontwikkelaars verseker dat teksvelde, veral di√© vir die invoer van sensitiewe inligting soos wagwoorde en PIN-kodes, die gebruik van 'n cache deaktiveer deur `autocorrectionType` in te stel op `UITextAutocorrectionTypeNo` en `secureTextEntry` op `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Logs**

Foutopsporingskode behels dikwels die gebruik van **logging**. Daar is 'n risiko betrokke aangesien **logs sensitiewe inligting kan bevat**. Voorheen, in iOS 6 en vorige weergawes, was logs toeganklik vir alle programme, wat 'n risiko van lekkasie van sensitiewe data inhou. **Nou is programme beperk tot toegang tot slegs hul eie logs**.

Ten spyte van hierdie beperkings kan 'n **aanvaller met fisiese toegang** tot 'n ontgrendelde toestel dit steeds uitbuit deur die toestel aan 'n rekenaar te koppel en die logs te lees. Dit is belangrik om daarop te let dat logs op die skyf bly selfs nadat die toepassing gede√Ønstalleer is.

Om risiko's te verminder, word dit aanbeveel om **deeglik met die toepassing te interaksieer**, deur al sy funksionaliteite en insette te verken om te verseker dat geen sensitiewe inligting onbedoeld geregistreer word nie.

Wanneer jy die bronkode van die toepassing ondersoek vir potensi√´le lekke, soek na beide **voorgedefinieerde** en **aangepaste loggingverklarings** met sleutelwoorde soos `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` vir ingeboude funksies, en enige verwysings na `Logging` of `Logfile` vir aangepaste implementasies.

### **Monitering van Stelsellogs**

Toepassings registreer verskeie stukke inligting wat sensitief kan wees. Om hierdie logs te monitor, kan gereedskap en opdragte soos:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
is nuttig. Daarbenewens bied **Xcode** 'n manier om konsole-logboeke te versamel:

1. Maak Xcode oop.
2. Verbind die iOS-toestel.
3. Navigeer na **Window** -> **Devices and Simulators**.
4. Kies jou toestel.
5. Trigger die probleem wat jy ondersoek.
6. Gebruik die **Open Console**-knoppie om logboeke in 'n nuwe venster te sien.

Vir meer gevorderde logboekhouding kan die verbind van die toestel se skulp en die gebruik van **socat** werkliktyd-logmonitoring bied:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Gevolg deur bevele om logaktiwiteite waar te neem, wat van onschatbare waarde kan wees vir die diagnose van probleme of die identifisering van potensi√´le datalekke in logboeke.


***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik werkstrome te bou en outomatiseer wat aangedryf word deur die w√™reld se mees gevorderde gemeenskapsinstrumente.\
Kry vandag toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Agteruitkopie√´

**Outomatiese agteruitkopie√´** is ge√Øntegreer in iOS, wat die skep van toesteldata-afskrifte fasiliteer deur middel van iTunes (tot macOS Catalina), Finder (vanaf macOS Catalina voort) of iCloud. Hierdie agteruitkopie√´ dek byna alle toesteldata, met uitsondering van hoogs sensitiewe elemente soos Apple Pay besonderhede en Touch ID konfigurasies.

### Sekuriteitsrisiko's

Die insluiting van **ge√Ønstalleerde programme en hul data** in agteruitkopie√´ bring die kwessie van potensi√´le **datalekke** na vore en die risiko dat **agteruitkopiewysigings programme se funksionaliteit kan verander**. Dit word aanbeveel om **sensitiewe inligting nie in plain text** binne enige program se gids of subgidse te stoor nie om hierdie risiko's te verminder.

### Uitsluiting van l√™ers uit agteruitkopie√´

L√™ers in `Documents/` en `Library/Application Support/` word standaard agteruitgekopieer. Ontwikkelaars kan spesifieke l√™ers of gidse uitsluit van agteruitkopie√´ deur gebruik te maak van `NSURL setResourceValue:forKey:error:` met die `NSURLIsExcludedFromBackupKey`. Hierdie praktyk is noodsaaklik om sensitiewe data te beskerm teen insluiting in agteruitkopie√´.

### Toetsing vir kwesbaarhede

Om die agteruitkopie-sekuriteit van 'n program te assesseer, begin deur 'n agteruitkopie te skep met behulp van Finder, en vind dit dan met behulp van die riglyne van [Apple se amptelike dokumentasie](https://support.apple.com/en-us/HT204215). Analiseer die agteruitkopie vir sensitiewe data of konfigurasies wat gewysig kan word om die program se gedrag te be√Ønvloed.

Sensitiewe inligting kan opgespoor word met behulp van opdraglyninstrumente of toepassings soos [iMazing](https://imazing.com). Vir ge√´nkripteerde agteruitkopie√´ kan die teenwoordigheid van enkripsie bevestig word deur die "IsEncrypted" sleutel in die "Manifest.plist" l√™er by die agteruitkopie se hoof te kontroleer.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Vir die hanteer van versleutelde rugsteun, kan Python-skripte beskikbaar in [DinoSec se GitHub-opberging](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), soos **backup_tool.py** en **backup_passwd.py**, nuttig wees, alhoewel dit moontlik aanpassings mag vereis vir die verenigbaarheid met die nuutste iTunes/Finder-weergawes. Die [**iOSbackup**-hulpmiddel](https://pypi.org/project/iOSbackup/) is 'n ander opsie vir toegang tot l√™ers binne wagwoord-beskermde rugsteun.

### Wysiging van App-gedrag

'n Voorbeeld van die wysiging van app-gedrag deur middel van rugsteun-wysigings word gedemonstreer in die [Bither bitcoin-bewaarbeurs-app](https://github.com/bither/bither-ios), waar die UI-sluitpenkode binne `net.bither.plist` onder die **pin_code**-sleutel gestoor word. Die verwydering van hierdie sleutel uit die plist en die herstel van die rugsteun verwyder die PIN-vereiste en bied onbeperkte toegang.

## Opsomming van Geheuetoetsing vir Sensitiewe Data

Wanneer dit kom by die hantering van sensitiewe inligting wat in 'n toepassing se geheue gestoor word, is dit noodsaaklik om die blootstellingsduur van hierdie data te beperk. Daar is twee prim√™re benaderings om geheue-inhoud te ondersoek: **die skep van 'n geheue-dump** en **die analise van die geheue in werklike tyd**. Beide metodes het hul uitdagings, insluitend die potensiaal om kritieke data tydens die dump-proses of analise te mis.

## **Ophaling en Analise van 'n Geheue-dump**

Vir beide gekraakte en nie-gekraakte toestelle, maak gereedskap soos [objection](https://github.com/sensepost/objection) en [Fridump](https://github.com/Nightbringer21/fridump) dit moontlik om 'n toepassing se prosesgeheue te dump. Nadat dit gedump is, vereis die analise van hierdie data verskeie gereedskap, afhangende van die aard van die inligting wat jy soek.

Om strings uit 'n geheue-dump te onttrek, kan opdragte soos `strings` of `rabin2 -zz` gebruik word:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Vir meer gedetailleerde analise, insluitend die soeke na spesifieke datatipes of patrone, bied **radare2** uitgebreide soekmoontlikhede:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Uitvoertydgeheue-analise**

**r2frida** bied 'n kragtige alternatief vir die inspekteer van 'n toepassing se geheue in werklike tyd, sonder om 'n geheue-dump te benodig. Hierdie instrument maak dit moontlik om soekopdragte direk op die lopende toepassing se geheue uit te voer:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Gebroke Kriptografie

### Swak Sleutelbestuurprosesse

Sommige ontwikkelaars stoor sensitiewe data in die plaaslike stoor en versleutel dit met 'n sleutel wat hardgekodifiseer/voorspelbaar in die kode is. Dit moet nie gedoen word nie, aangesien sommige omkeerwerk dit moontlik maak vir aanvallers om die vertroulike inligting te onttrek.

### Gebruik van Onveilige en/of Verouderde Algoritmes

Ontwikkelaars moet nie **verouderde algoritmes** gebruik om outorisasie **toetse** uit te voer, data te **stoor** of te **stuur** nie. Sommige van hierdie algoritmes is: RC4, MD4, MD5, SHA1... As **hasings** byvoorbeeld gebruik word om wagwoorde te stoor, moet hasings wat bestand is teen brutaal krag met sout gebruik word.

### Toets

Die belangrikste toetse om uit te voer is om te kyk of jy **hardgekodifiseerde** wagwoorde/geheime in die kode kan vind, of dit **voorspelbaar** is, en of die kode van 'n soort **swak** **kriptografie**-algoritmes gebruik maak.

Dit is interessant om te weet dat jy sommige **kripto**-biblioteke outomaties kan **monitor** deur **objection** te gebruik met:
```swift
ios monitor crypt
```
Vir **meer inligting** oor iOS kriptografiese API's en biblioteke, besoek [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Plaaslike Verifikasie

**Plaaslike verifikasie** speel 'n belangrike rol, veral wanneer dit kom by die beskerming van toegang tot 'n afgele√´ eindpunt deur middel van kriptografiese metodes. Die essensie hier is dat sonder behoorlike implementering, plaaslike verifikasiemeganismes omseil kan word.

Apple se **[Plaaslike Verifikasie-raamwerk](https://developer.apple.com/documentation/localauthentication)** en die **[sleutelbos](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** bied robuuste API's vir ontwikkelaars om gebruikersverifikasie-dialoge te fasiliteer en geheime data veilig te hanteer. Die Veilige Enclave verseker vingerafdruk-ID vir Touch ID, terwyl Face ID staatmaak op gesigsherkenning sonder om biometriese data in gevaar te stel.

Om Touch ID/Face ID te integreer, het ontwikkelaars twee API-keuses:
- **`LocalAuthentication.framework`** vir ho√´vlak-gebruikersverifikasie sonder toegang tot biometriese data.
- **`Security.framework`** vir laervlak-sleutelbosdiensetoegang, wat geheime data veilig stel met biometriese verifikasie. Verskeie [oopbron-omhullings](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) maak sleutelbostoegang eenvoudiger.

{% hint style="danger" %}
Nietemin, beide `LocalAuthentication.framework` en `Security.framework` het kwesbaarhede, aangesien hulle hoofsaaklik boole-waardes teruggee sonder om data vir verifikasieprosesse oor te dra, wat hulle vatbaar maak vir omseiling (verwys na [Don't touch me that way, deur David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementering van Plaaslike Verifikasie

Om gebruikers te vra vir verifikasie, moet ontwikkelaars die **`evaluatePolicy`**-metode binne die **`LAContext`**-klas gebruik en kies tussen:
- **`deviceOwnerAuthentication`**: Vra vir Touch ID of toestel wagwoord, faal as geen van beide geaktiveer is nie.
- **`deviceOwnerAuthenticationWithBiometrics`**: Vra eksklusief vir Touch ID.

'n Suksesvolle verifikasie word aangedui deur 'n boole-waarde wat teruggegee word deur **`evaluatePolicy`**, wat 'n potensi√´le sekuriteitsfout aandui.

### Plaaslike Verifikasie met Sleutelbos

Die implementering van **plaaslike verifikasie** in iOS-toepassings behels die gebruik van **sleutelbos-API's** om geheime data soos verifikasie-token te veilig stoor. Hierdie proses verseker dat die data slegs deur die gebruiker toeganklik is deur middel van hul toestel wagwoord of biometriese verifikasie soos Touch ID.

Die sleutelbos bied die vermo√´ om items met die `SecAccessControl`-eienskap in te stel, wat toegang tot die item beperk totdat die gebruiker suksesvol verifieer deur middel van Touch ID of toestel wagwoord. Hierdie funksie is krities vir die verbetering van sekuriteit.

Hieronder is voorbeeldkodes in Swift en Objective-C wat demonstreer hoe om 'n string na die sleutelbos te stoor en te herwin, deur gebruik te maak van hierdie sekuriteitskenmerke. Die voorbeelde wys spesifiek hoe om toegangsbeheer in te stel om Touch ID-verifikasie te vereis en te verseker dat die data slegs toeganklik is op die toestel waarop dit opgestel is, onder die voorwaarde dat 'n toestel wagwoord gekonfigureer is.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}Doel-C
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Nou kan ons die gestoorde item van die sleutelketting aanvra. Sleutelkettingdienste sal die verifikasievenster aan die gebruiker vertoon en data of nil teruggee, afhangende van of 'n geskikte vingerafdruk voorsien is of nie.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}Doel-C
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Opmerking

Die gebruik van raamwerke in 'n toepassing kan ook opgespoor word deur die analise van die lys gedeelde dinamiese biblioteke van die toepassingsbin√™re. Dit kan gedoen word deur gebruik te maak van `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
As `LocalAuthentication.framework` in 'n app gebruik word, sal die uitset beide van die volgende lyne bevat (onthou dat `LocalAuthentication.framework` `Security.framework` onder die kap gebruik):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
As `Security.framework` gebruik word, sal slegs die tweede een vertoon word.

### Plaaslike Verifikasie Raamwerk Omspring

#### **Objection**

Deur middel van die **Objection Biometrie Omspring**, wat op [hierdie GitHub-bladsy](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) gevind kan word, is daar 'n tegniek beskikbaar om die **LocalAuthentication** meganisme te omseil. Die kern van hierdie benadering behels die gebruik van **Frida** om die `evaluatePolicy` funksie te manipuleer, sodat dit altyd 'n `True` uitkoms gee, ongeag die werklike verifikasie sukses. Dit is veral nuttig vir die omseil van gebrekkige biometriese verifikasieprosesse.

Om hierdie omspring te aktiveer, word die volgende bevel gebruik:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Hierdie bevel stel 'n reeks in waar Objection 'n taak registreer wat die uitkoms van die `evaluatePolicy`-toets effektief verander na `True`.

#### Frida

'n Voorbeeld van die gebruik van **`evaluatePolicy`** van die [DVIA-v2-toepassing](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Om die **omseiling** van Plaaslike Verifikasie te bereik, word 'n Frida-skrips geskryf. Hierdie skrips teiken die **evaluatePolicy**-kontrole en onderskep sy terugroep om te verseker dat dit altyd **success=1** teruggee. Deur die gedrag van die terugroep te verander, word die verifikasie-kontrole effektief omseil.

Die onderstaande skrips word ingesluit om die resultaat van die **evaluatePolicy**-metode te wysig. Dit verander die resultaat van die terugroep om altyd sukses aan te dui.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Om die Frida-skrip in te spuit en die biometriese verifikasie te omseil, word die volgende bevel gebruik:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Sensitiewe Funksionaliteit Blootstelling deur IPC

### Aangepaste URI Handlers / Deeplinks / Aangepaste Skemas

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Universele Skakels

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Deling

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App Uitbreidings

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serialisering en Enkodering

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Netwerk Kommunikasie

Dit is belangrik om te kontroleer dat geen kommunikasie plaasvind **sonder versleuteling** en dat die toepassing die TLS-sertifikaat van die bediener korrek **valideer**.\
Om hierdie soort probleme te ondersoek, kan jy 'n proksi soos **Burp** gebruik:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Naam van bediener kontroleer

Een algemene probleem met die validering van die TLS-sertifikaat is om te kontroleer of die sertifikaat deur 'n **vertroude** **CA** onderteken is, maar **nie kontroleer** of **die naam van die bediener** van die sertifikaat die naam van die bediener is wat benader word nie.\
Om hierdie probleem te ondersoek met behulp van Burp, nadat jy die Burp CA op die iPhone vertrou, kan jy **'n nuwe sertifikaat met Burp vir 'n ander naam van die bediener** skep en dit gebruik. As die toepassing steeds werk, is iets kwesbaar.

### Sertifikaat Pinning

As 'n toepassing SSL Pinning korrek gebruik, sal die toepassing slegs werk as die sertifikaat die verwagte een is. Wanneer jy 'n toepassing toets, **kan dit 'n probleem wees omdat Burp sy eie sertifikaat sal gebruik.**\
Om hierdie beskerming binne 'n jailbroken-toestel te omseil, kan jy die toepassing [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) installeer of [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) installeer.

Jy kan ook **objection's** `ios sslpinning disable` gebruik

## Verskillende

* In **`/System/Library`** kan jy die raamwerke wat in die foon ge√Ønstalleer is en deur stelseltoepassings gebruik word, vind.
* Die toepassings wat deur die gebruiker van die App Store ge√Ønstalleer is, is gele√´ binne **`/User/Applications`**
* En die **`/User/Library`** bevat data wat deur gebruikersvlaktoepassings gestoor is.
* Jy kan toegang verkry tot **`/User/Library/Notes/notes.sqlite`** om die notas wat binne die toepassing gestoor is, te lees.
* Binne die vouer van 'n ge√Ønstalleerde toepassing (**`/User/Applications/<APP ID>/`**) kan jy 'n paar interessante l√™ers vind:
* **`iTunesArtwork`**: Die ikoon wat deur die app gebruik word
* **`iTunesMetadata.plist`**: Inligting van die app wat in die App Store gebruik word
* **`/Library/*`**: Bevat die voorkeure en cache. In **`/Library/Cache/Snapshots/*`** kan jy die oorsig vind wat van die toepassing geneem is voordat dit na die agtergrond gestuur is.

### Warm Patching/Verpligte Opdatering

Die ontwikkelaars kan alle installasies van hul toepassing **onmiddellik herstel** sonder om die toepassing na die App Store te stuur en te wag tot dit goedgekeur word.\
Hiervoor word gewoonlik [**JSPatch**](https://github.com/bang590/JSPatch)** gebruik.** Maar daar is ook ander opsies soos [Siren](https://github.com/ArtSabintsev/Siren) en [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Dit is 'n gevaarlike meganisme wat misbruik kan word deur kwaadwillige derde party SDK's, daarom word dit aanbeveel om te ondersoek watter metode gebruik word vir outomatiese opdatering (indien enige) en dit te toets.** Jy kan probeer om 'n vorige weergawe van die toepassing af te laai vir hierdie doel.

### Derde Party

'n Belangrike uitdaging met **3de party SDK's** is die **gebrek aan fynkontrole** oor hul funksionaliteite. Ontwikkelaars staan voor 'n keuse: √≥f die SDK integreer en al sy funksies aanvaar, insluitende potensi√´le sekuriteitskwessies en privaatheidskwessies, √≥f die voordele daarvan heeltemal verwerp. Ontwikkelaars is dikwels nie in staat om kwessies binne hierdie SDK's self te herstel nie. Verder, soos SDK's vertroue in die gemeenskap verwerf, mag sommige malware bevat.

Die dienste wat deur derde party SDK's verskaf word, kan gebruikersgedragopsporing, advertensie-uitstallings of gebruikerservaringsverbeterings insluit. Dit bring egter 'n risiko mee, aangesien ontwikkelaars nie ten volle bewus is van die kode wat deur hierdie biblioteke uitgevoer word nie, wat moontlike privaatheids- en sekuriteitsrisiko's tot gevolg kan h√™. Dit is noodsaaklik om die inligting wat met derde party dienste gedeel word, te beperk tot wat nodig is en te verseker dat geen sensitiewe data blootgestel word nie.

Implementering van derde party dienste kom gewoonlik in twee vorme voor: 'n afsonderlike biblioteek of 'n volledige SDK. Om gebruikersprivaatheid te beskerm, moet enige data wat met hierdie dienste gedeel word, **geanonimiseer** word om die bekendmaking van Persoonlik Identifiseerbare Inligting (PII) te voorkom.

Om die biblioteke wat 'n toepassing gebruik, te identifiseer, kan die **`otool`**-opdrag gebruik word. Hierdie hulpmiddel moet teen die toepassing en elke gedeelde biblioteek wat dit gebruik, uitgevoer word om addisionele biblioteke te ontdek.
```bash
otool -L <application_path>
```
## **Verwysings & Meer Hulpbronne**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS gratis kursus([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C weergawe [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift weergawe
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Gebruik [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) om maklik **werkstrome** te bou en outomatiseer met behulp van die w√™reld se **mees gevorderde** gemeenskapsinstrumente.\
Kry vandag toegang:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks wil adverteer** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
