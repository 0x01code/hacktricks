# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)を使用して、世界で最も先進的なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスを取得:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>で**ゼロからヒーローまでのAWSハッキング**を学びましょう！</summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウェグ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出してください。

</details>

## iOSの基礎

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## テスト環境

このページでは、**iOSシミュレータ**、**エミュレータ**、および**ジェイルブレイク**に関する情報を見つけることができます:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## 初期分析

### 基本的なiOSテスト操作

テスト中には、**いくつかの操作が提案される**（デバイスへの接続、ファイルの読み書き/アップロード/ダウンロード、いくつかのツールの使用など）。したがって、これらのアクションのいずれかを実行する方法がわからない場合は、**ページを読み始めてください**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
次の手順では、アプリがデバイスに**インストールされている必要があり**、アプリケーションの**IPAファイルをすでに取得している必要があります。\
これを行う方法については、[基本的なiOSテスト操作](basic-ios-testing-operations.md)ページを読んでください。
{% endhint %}

### 基本的な静的解析

ツール[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)を使用して、IPAファイルに対して自動的な静的解析を実行することをお勧めします。

バイナリに存在する**保護の識別**:

*   **PIE（Position Independent Executable）**：有効になっている場合、アプリケーションは起動するたびにランダムなメモリアドレスにロードされ、初期メモリアドレスを予測するのが難しくなります。

```bash
otool -hv <app-binary> | grep PIE   # PIEフラグを含める必要があります
```
*   **スタックキャナリー**：スタックの整合性を検証するために、関数を呼び出す前にスタックに「キャナリー」値が配置され、関数が終了すると再度検証されます。

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guardおよびstack_chk_failのシンボルを含める必要があります
```
*   **ARC（Automatic Reference Counting）**：一般的なメモリ破損の欠陥を防ぐため

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_releaseシンボルを含める必要があります
```
*   **暗号化されたバイナリ**：バイナリは暗号化されている必要があります

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptidは1である必要があります
```

**機密性の高い/安全でない関数の識別**

*   **弱いハッシュアルゴリズム**

```bash
# iOSデバイス上で
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux上で
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **安全でないランダム関数**

```bash
# iOSデバイス上で
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux上で
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **安全でない'Malloc'関数**

```bash
# iOSデバイス上で
otool -Iv <app> | grep -w "_malloc"

# Linux上で
grep -iER "_malloc"
```
*   **安全で脆弱な関数**

```bash
# iOSデバイス上で
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux上で
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### 基本的な動的解析

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)が実行する動的解析をチェックしてください。異なるビューをナビゲートし、それらと対話する必要がありますが、いくつかのクラスをフックし、他のことを行い、完了したらレポートを準備します。

### インストールされたアプリのリスト表示

`frida-ps -Uai`コマンドを使用して、インストールされたアプリの**バンドル識別子**を決定します。
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### 基本列挙とフック

アプリケーションのコンポーネントを列挙する方法と、objectionを使用して簡単にメソッドやクラスをフックする方法を学びます:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPAの構造

**IPAファイル**の構造は基本的に**圧縮されたパッケージ**です。拡張子を`.zip`に変更することで、その内容を明らかにするために**展開**できます。この構造の中で、**Bundle**はインストールの準備が整った完全なパッケージ化されたアプリケーションを表します。内部には、アプリケーションのリソースをカプセル化する`<NAME>.app`というディレクトリが含まれています。

* **`Info.plist`**: このファイルにはアプリケーションの特定の構成詳細が格納されています。
* **`_CodeSignature/`**: このディレクトリには、バンドル内のすべてのファイルの整合性を確保する署名を含むplistファイルが含まれています。
* **`Assets.car`**: アイコンなどのアセットファイルを保存する圧縮アーカイブです。
* **`Frameworks/`**: このフォルダには、`.dylib`または`.framework`形式のアプリケーションのネイティブライブラリが含まれています。
* **`PlugIns/`**: これには、`.appex`ファイルとして知られるアプリケーションの拡張機能が含まれる場合がありますが、常に存在するわけではありません。
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): これは、アプリケーションの永続データをオフラインで保存し、一時データをキャッシュし、単一デバイスでアプリに元に戻す機能を追加するために使用されます。単一のiCloudアカウント内の複数のデバイス間でデータを同期するために、Core Dataはスキーマを自動的にCloudKitコンテナにミラーリングします。
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo`ファイルは、アプリケーションまたはバンドルのタイプと作成者コードを指定する別の方法です。
* **en.lproj, fr.proj, Base.lproj**: これらは、特定の言語のリソースを含み、言語がサポートされていない場合のデフォルトリソースを含む言語パックです。
* **セキュリティ**: `_CodeSignature/`ディレクトリは、デジタル署名を介してバンドルされたすべてのファイルの整合性を検証することで、アプリのセキュリティに重要な役割を果たします。
* **アセット管理**: `Assets.car`ファイルは、グラフィカルアセットを効率的に管理するために圧縮を使用し、アプリケーションのパフォーマンスを最適化し、全体のサイズを削減するために重要です。
* **フレームワークとプラグイン**: これらのディレクトリは、iOSアプリケーションのモジュラリティを強調し、再利用可能なコードライブラリ(`Frameworks/`)を含めたり、アプリの機能を拡張したり(`PlugIns/`)することを可能にします。
* **ローカライゼーション**: この構造は複数の言語をサポートし、特定の言語パックのリソースを含むことで、グローバルなアプリケーションの到達範囲を広げるのを支援します。

**Info.plist**

**Info.plist**は、iOSアプリケーションの基盤となるものであり、**キー-値**のペアの形式で重要な構成データをカプセル化します。このファイルは、アプリケーションだけでなく、バンドル内にバンドルされたアプリ拡張機能やフレームワークにとっても必須です。XMLまたはバイナリ形式で構造化され、アプリの権限からセキュリティ構成まで、重要な情報が含まれています。利用可能なキーの詳細な探索については、[**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc)を参照してください。

このファイルをよりアクセスしやすい形式で扱いたい場合、macOSでは`plutil`（バージョン10.2以降でネイティブで利用可能）またはLinuxでは`plistutil`を使用して、XML変換を簡単に行うことができます。変換のためのコマンドは次のとおりです:

* **macOS用**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Linuxの場合**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Info.plist**ファイルが漏洩する可能性のある情報の中には、アプリの許可文字列（`UsageDescription`）、カスタムURLスキーム（`CFBundleURLTypes`）、App Transport Securityの構成（`NSAppTransportSecurity`）などがあります。これらのエントリは、ファイルを検査するか、単純な`grep`コマンドを使用して簡単に見つけることができます。
```bash
$ grep -i <keyword> Info.plist
```
**データパス**

iOS環境では、ディレクトリが**システムアプリケーション**と**ユーザーがインストールしたアプリケーション**のために特に指定されています。システムアプリケーションは`/Applications`ディレクトリにあり、ユーザーがインストールしたアプリケーションは`/var/mobile/containers/Data/Application/`以下に配置されます。これらのアプリケーションには**128ビットUUID**として知られる一意の識別子が割り当てられており、ディレクトリ名のランダム性によりアプリのフォルダを手動で見つける作業が困難になります。

{% hint style="warning" %}
iOSのアプリケーションはサンドボックス化される必要があるため、各アプリには**`$HOME/Library/Containers`**内にアプリの**`CFBundleIdentifier`**をフォルダ名とするフォルダもあります。

ただし、両方のフォルダ（データフォルダとコンテナフォルダ）には、キー`MCMetadataIdentifier`で両方のファイルをリンクする**`.com.apple.mobile_container_manager.metadata.plist`**というファイルが含まれています。
{% endhint %}

ユーザーがインストールしたアプリのインストールディレクトリを発見するために、**objectionツール**は便利な`env`コマンドを提供しています。このコマンドは、対象のアプリに関する詳細なディレクトリ情報を表示します。以下は、このコマンドの使用方法の例です：
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
または、`find`コマンドを使用して`/private/var/containers`内でアプリ名を検索できます：
```bash
find /private/var/containers -name "Progname*"
```
Commands such as `ps` and `lsof` can also be utilized to identify the app's process and list open files, respectively, providing insights into the application's active directory paths:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**バンドルディレクトリ:**

* **AppName.app**
* これはIPAで以前に見られたアプリケーションバンドルであり、基本的なアプリケーションデータ、静的コンテンツ、およびアプリケーションのコンパイルされたバイナリを含んでいます。
* このディレクトリはユーザーに見えますが、**ユーザーは書き込むことはできません**。
* このディレクトリ内のコンテンツは**バックアップされません**。
* このフォルダの内容は**コード署名を検証するために使用**されます。

**データディレクトリ:**

* **Documents/**
* すべてのユーザー生成データが含まれています。アプリケーションエンドユーザーがこのデータの作成を開始します。
* ユーザーに見え、**ユーザーは書き込むことができます**。
* このディレクトリ内のコンテンツは**バックアップされます**。
* アプリは`NSURLIsExcludedFromBackupKey`を設定してパスを無効にできます。
* **Library/**
* **ユーザー固有でないファイル**、**キャッシュ**、**設定**、**クッキー**、およびプロパティリスト（plist）構成ファイルなどが含まれています。
* iOSアプリは通常、`Application Support`および`Caches`サブディレクトリを使用しますが、アプリはカスタムサブディレクトリを作成できます。
* **Library/Caches/**
* **一時的なキャッシュファイル**が含まれています。
* ユーザーには見えず、**ユーザーは書き込むことはできません**。
* このディレクトリ内のコンテンツは**バックアップされません**。
* アプリが実行されていないときやストレージ容量が不足しているとき、OSはこのディレクトリのファイルを自動的に削除する場合があります。
* **Library/Application Support/**
* アプリの実行に必要な**永続的なファイル**が含まれています。
* ユーザーには**見えず**、ユーザーは書き込むことはできません。
* このディレクトリ内のコンテンツは**バックアップされます**。
* アプリは`NSURLIsExcludedFromBackupKey`を設定してパスを無効にできます。
* **Library/Preferences/**
* アプリケーションが再起動しても**永続化されるプロパティを保存**するために使用されます。
* 情報は、\[BUNDLE\_ID].plistというplistファイル内に暗号化されていない形でアプリケーションサンドボックス内に保存されます。
* `NSUserDefaults`を使用して保存されたすべてのキー/値ペアはこのファイルに見つけることができます。
* **tmp/**
* アプリの起動間に**永続化する必要のない一時ファイル**を書き込むためにこのディレクトリを使用します。
* 非永続的なキャッシュファイルが含まれています。
* ユーザーには**見えません**。
* このディレクトリ内のコンテンツはバックアップされません。
* OSはアプリが実行されていないときやストレージ容量が不足しているとき、このディレクトリのファイルを自動的に削除する場合があります。

iGoat-Swiftのアプリケーションバンドル（.app）ディレクトリをバンドルディレクトリ内（`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`）で詳しく見てみましょう。
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### バイナリリバース

`<application-name>.app`フォルダーの中には、`<application-name>`という名前のバイナリファイルが含まれています。これが**実行**されるファイルです。ツール**`otool`**を使用してバイナリの基本的な検査を行うことができます：
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**アプリが暗号化されているかどうかを確認する**

次の出力があるかどうかを確認します：
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**バイナリの逆アセンブル**

テキストセクションを逆アセンブルします：
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
**サンプルアプリケーションのObjective-Cセグメント**を印刷するには、次のようにします：
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
以下は、よりコンパクトなObjective-Cコードを取得するために使用できる[**class-dump**](http://stevenygard.com/projects/class-dump/)です:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
しかし、バイナリを逆アセンブルするための最良のオプションは、[**Hopper**](https://www.hopperapp.com/download.html?) と [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/) です。

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) を使用して、世界で最も高度なコミュニティツールによって強化された **ワークフローを簡単に構築** し、**自動化** します。\
今すぐアクセスしてください：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## データストレージ

iOS がデバイス内にデータを保存する方法について学ぶには、このページを読んでください：

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
情報を保存するための以下の場所は、**アプリケーションをインストール直後**、**アプリケーションのすべての機能を確認した後**、さらには**1人のユーザーからログアウトして別のユーザーにログインした後**にチェックする必要があります。\
目標は、アプリケーション（パスワード、トークン）、現在のユーザー、以前にログインしたユーザーの **保護されていない機密情報** を見つけることです。
{% endhint %}

### Plist

**plist** ファイルは、**キーと値のペアを含む** 構造化された XML ファイルです。これは永続データを保存する方法であり、したがって、これらのファイルに **機密情報が含まれていることがあります**。アプリをインストールした後や頻繁に使用した後にこれらのファイルをチェックすることをお勧めします。

plist ファイルにデータを永続化する最も一般的な方法は、**NSUserDefaults** の使用です。この plist ファイルは、**`Library/Preferences/<appBundleID>.plist`** 内のアプリケーションサンドボックスに保存されます。

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) クラスは、デフォルトシステムとのやり取りのためのプログラムインターフェースを提供します。デフォルトシステムにより、アプリケーションは **ユーザーの設定に応じて動作をカスタマイズ** できます。`NSUserDefaults` に保存されたデータは、アプリケーションバンドル内で表示できます。このクラスは、**少量のデータ** と一緒に使用することを意図しています。

このデータは、信頼されたコンピュータを介して直接アクセスできませんが、**バックアップ** を実行することでアクセスできます。

`NSUserDefaults` を使用して保存された情報を **`dump`** するには、objection の `ios nsuserdefaults get` を使用できます。

アプリケーションが使用するすべての plist を見つけるには、`/private/var/mobile/Containers/Data/Application/{APPID}` にアクセスして次のコマンドを実行します：
```bash
find ./ -name "*.plist"
```
以下は、**XMLまたはバイナリ（bplist）**形式のファイルをXML形式に変換するための、オペレーティングシステムに応じたさまざまな方法です：

**macOSユーザー向け：** `plutil`コマンドを利用します。macOS（10.2以上）に組み込まれているこのツールは、この目的に特化しています。
```bash
$ plutil -convert xml1 Info.plist
```
**Linuxユーザーの場合:** まず`libplist-utils`をインストールし、その後`plistutil`を使用してファイルを変換します:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Objectionセッション内：** モバイルアプリケーションを分析する際、特定のコマンドを使用してplistファイルを直接変換することができます：
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1)は、アプリケーションのモデルレイヤーを管理するためのフレームワークです。[Core Dataは永続ストアとしてSQLiteを使用することができます](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/)が、フレームワーク自体はデータベースではありません。\
CoreDataはデフォルトではデータを暗号化しません。ただし、追加の暗号化レイヤーをCoreDataに追加することができます。詳細については、[GitHubリポジトリ](https://github.com/project-imas/encrypted-core-data)を参照してください。

アプリケーションのSQLite Core Data情報は、パス`/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`にあります。

**SQLiteを開いて機密情報にアクセスできる場合、設定ミスを見つけたことになります。**
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase)はSQLiteの上に構築されたキー/値ストアです。\
YapデータベースはSQLiteデータベースなので、前のセクションで提案されたコマンドを使用して見つけることができます。

### その他のSQLiteデータベース

アプリケーションが独自のSQLiteデータベースを作成することは一般的です。それらには**機密データ**が格納されている可能性があり、それが暗号化されていないままになっていることがあります。そのため、アプリケーションディレクトリ内のすべてのデータベースをチェックすることは常に興味深いです。したがって、データが保存されているアプリケーションディレクトリに移動します (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time Databases

開発者はFirebase Real-Time Databasesを通じて、**NoSQLクラウドホスト型データベース**内でデータを**保存および同期**することができます。データはJSON形式で保存され、リアルタイムですべての接続されたクライアントに同期されます。

ミス構成されたFirebaseデータベースをチェックする方法は[こちら](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)で見つけることができます。

### Realm databases

[Realm Objective-C](https://realm.io/docs/objc/latest/)および[Realm Swift](https://realm.io/docs/swift/latest/)は、Appleによって提供されていないデータ保存の強力な代替手段を提供します。デフォルトでは、データは暗号化されず、特定の構成を介して暗号化が可能です。

データベースは次の場所にあります：`/private/var/mobile/Containers/Data/Application/{APPID}`。これらのファイルを調査するために、次のようなコマンドを利用することができます：
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
これらのデータベースファイルを表示するには、[**Realm Studio**](https://github.com/realm/realm-studio) ツールが推奨されています。

Realmデータベース内で暗号化を実装するには、次のコードスニペットを使用できます:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite データベース

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios)は、**軽量**かつ**組み込み**のデータベースエンジンであり、**ドキュメント指向**（NoSQL）アプローチに従っています。**iOS**と**macOS**向けにネイティブに設計されており、データをシームレスに同期する機能を提供しています。

デバイス上で潜在的なCouchbaseデータベースを特定するには、次のディレクトリを調査する必要があります：
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

iOSはアプリのクッキーを各アプリのフォルダ内の**`Library/Cookies/cookies.binarycookies`**に保存します。ただし、開発者は時々、**クッキーファイルがバックアップでアクセスできる**ため、それらを**キーチェーン**に保存することを選択することがあります。

クッキーファイルを検査するには、[**このPythonスクリプト**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser)を使用するか、objectionの**`ios cookies get`**を使用できます。\
**また、objectionを使用して**これらのファイルをJSON形式に変換してデータを検査することもできます。
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### キャッシュ

デフォルトでは、NSURLSessionは**HTTPリクエストとレスポンスをCache.dbデータベースに保存**します。このデータベースには、**トークン、ユーザー名、またはその他の機密情報**がキャッシュされている場合があります。キャッシュされた情報を見つけるには、アプリのデータディレクトリを開き (`/var/mobile/Containers/Data/Application/<UUID>`)、`/Library/Caches/<Bundle Identifier>`に移動します。**WebKitキャッシュもCache.dbファイルに保存**されています。**Objection**は、`sqlite connect Cache.db`コマンドでデータベースを開いて操作できます。これは**通常のSQLiteデータベース**です。

このデータのキャッシュを無効にすることを**お勧め**します。リクエストやレスポンスに機密情報が含まれている可能性があるためです。以下は、これを実現するさまざまな方法のリストです：

1. ログアウト後にキャッシュされたレスポンスを削除することをお勧めします。Appleが提供する[`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses)メソッドを使用してこれを行うことができます。以下のようにこのメソッドを呼び出すことができます：

`URLCache.shared.removeAllCachedResponses()`

このメソッドは、Cache.dbファイルからすべてのキャッシュされたリクエストとレスポンスを削除します。
2. クッキーの利点を利用する必要がない場合は、URLSessionの[.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral)構成プロパティを使用することをお勧めします。これにより、クッキーとキャッシュの保存が無効になります。

[Appleのドキュメント](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`ephemeralセッション構成オブジェクトは、デフォルトのセッション構成（defaultを参照）と似ていますが、対応するセッションオブジェクトはキャッシュ、資格情報ストア、またはディスクにセッション関連データを保存しません。代わりに、セッション関連データはRAMに保存されます。ephemeralセッションがデータをディスクに書き込む唯一の場合は、URLの内容をファイルに書き込むように指示した場合です。`
3. キャッシュポリシーを[.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed)に設定することで、キャッシュをメモリやディスクに保存しないように無効にすることもできます。

### スナップショット

ホームボタンを押すたびに、iOSは**現在の画面のスナップショット**を取得して、アプリケーションへの遷移をよりスムーズに行うことができます。ただし、**現在の画面に機密データ**がある場合、それは**画像に保存**されます（これは**再起動を超えて永続化**されます）。これらは、アプリケーション間を切り替えるためにホーム画面をダブルタップすることでアクセスできるスナップショットです。

iPhoneがジェイルブレイクされていない限り、**攻撃者**はこれらのスクリーンショットを見るためには**デバイスをアンロック**する必要があります。デフォルトでは、最後のスナップショットはアプリケーションのサンドボックス内の`Library/Caches/Snapshots/`または`Library/SplashBoard/Snapshots`フォルダに保存されます（信頼されたコンピュータはiOS 7.0からファイルシステムにアクセスできません）。

この悪い動作を防ぐ方法の1つは、スナップショットを取る前に空白の画面を表示するか、機密データを削除することです。これは`ApplicationDidEnterBackground()`関数を使用して行います。

以下は、デフォルトのスクリーンショットを設定するサンプルの緩和方法です。

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**  
Objective-C:
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
### Keychain

iOSキーチェーンへのアクセスと管理には、[**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper)などのツールが利用可能で、ジェイルブレイクされたデバイスに適しています。さらに、[**Objection**](https://github.com/sensepost/objection)は同様の目的のために`ios keychain dump`コマンドを提供しています。

#### **資格情報の保存**

**NSURLCredential**クラスは、NSUserDefautsや他のラッパーをバイパスして、キーチェーンに直接機密情報を保存するのに最適です。ログイン後に資格情報を保存するには、次のSwiftコードが使用されます：
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
## **カスタムキーボードとキーボードキャッシュ**

iOS 8.0以降、ユーザーは**Settings > General > Keyboard > Keyboards**の下で管理されるカスタムキーボード拡張機能をインストールできます。これらのキーボードは拡張機能を提供しますが、キーストロークの記録や外部サーバーへのデータ送信のリスクがあります。ただし、ユーザーにはネットワークアクセスが必要なキーボードについて通知されます。アプリは、カスタムキーボードの使用を機密情報の入力に制限すべきです。

**セキュリティ推奨事項:**

* セキュリティを強化するために、サードパーティのキーボードを無効にすることが推奨されています。
* デフォルトのiOSキーボードの自動修正やオートサジェスト機能に注意することが重要です。これらは`Library/Keyboard/{locale}-dynamic-text.dat`または`/private/var/mobile/Library/Keyboard/dynamic-text.dat`にあるキャッシュファイルに機密情報を保存する可能性があります。これらのキャッシュファイルは定期的に機密データをチェックする必要があります。キーボード辞書を**Settings > General > Reset > Reset Keyboard Dictionary**からリセットしてキャッシュされたデータをクリアすることが推奨されています。
* ネットワークトラフィックを傍受することで、カスタムキーボードがリモートでキーストロークを送信しているかどうかがわかります。

### **テキストフィールドのキャッシュを防止する**

[UITextInputTraitsプロトコル](https://developer.apple.com/reference/uikit/uitextinputtraits)は、自動修正やセキュアなテキスト入力を管理するプロパティを提供し、機密情報のキャッシュを防ぐために重要です。たとえば、自動修正を無効にし、セキュアなテキスト入力を有効にすることは、次のように実現できます:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
さらに、開発者は、特にパスワードやPINなどの機密情報を入力するためのテキストフィールドについて、`autocorrectionType`を`UITextAutocorrectionTypeNo`に設定し、`secureTextEntry`を`YES`に設定することでキャッシュを無効にするようにする必要があります。
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **ログ**

デバッグコードの解析には、**ログ**の使用がよく含まれます。**ログには機密情報が含まれる可能性**があります。以前は、iOS 6およびそれ以前のバージョンでは、すべてのアプリがログにアクセスできるため、機密データの漏洩のリスクがありました。**現在、アプリケーションは自分自身のログにのみアクセスできるように制限されています**。

これらの制限にもかかわらず、**ロック解除されたデバイスに物理的アクセス**を持つ攻撃者は、デバイスをコンピュータに接続してログを**読む**ことでこれを悪用することができます。ログはアプリのアンインストール後もディスク上に残っていることに注意することが重要です。

リスクを軽減するためには、アプリと**徹底的にやり取り**し、機密情報が誤ってログに記録されていないかを確認することが推奨されています。

潜在的な漏洩を確認するためにアプリのソースコードを確認する際には、`NSLog`、`NSAssert`、`NSCAssert`、`fprintf`などの組み込み関数に関連する**事前定義**および**カスタムログステートメント**、`Logging`や`Logfile`などのキーワードを使用したカスタム実装に注意してください。

### **システムログの監視**

アプリはさまざまな情報をログに記録しますが、これらは機密情報になる可能性があります。これらのログを監視するために、次のようなツールやコマンドが使用されます：
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
以下は、ハッキング技術に関する本の内容です。ファイル mobile-pentesting/ios-pentesting/README.md からのコンテンツです。

Xcode は便利です。さらに、**Xcode** にはコンソールログを収集する方法が用意されています：

1. Xcode を開きます。
2. iOS デバイスを接続します。
3. **Window** -> **Devices and Simulators** に移動します。
4. デバイスを選択します。
5. 調査中の問題をトリガーします。
6. **Open Console** ボタンを使用して、新しいウィンドウでログを表示します。

より高度なログ記録のために、デバイスシェルに接続して **socat** を使用してリアルタイムのログ監視を行うことができます。
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
***

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks)を使用して、世界で最も先進的なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスしてください：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## バックアップ

iOSには**オートバックアップ機能**が統合されており、iTunes（macOS Catalinaまで）、Finder（macOS Catalina以降）、またはiCloudを介してデバイスデータのコピーを簡単に作成できます。これらのバックアップには、Apple Payの詳細やTouch IDの構成などの非常に機密性の高い要素を除く、ほぼすべてのデバイスデータが含まれています。

### セキュリティリスク

バックアップに**インストールされたアプリとそのデータ**が含まれることで、**データ漏洩**の問題が生じ、**バックアップの変更がアプリの機能を変更**するリスクがあります。これらのリスクを軽減するために、**アプリのディレクトリやサブディレクトリに機密情報を平文で保存しない**ことが推奨されています。

### バックアップからファイルを除外

`Documents/`および`Library/Application Support/`内のファイルはデフォルトでバックアップされます。開発者は`NSURL setResourceValue:forKey:error:`を使用して`NSURLIsExcludedFromBackupKey`と共に特定のファイルやディレクトリをバックアップから除外できます。この慣行は、機密データがバックアップに含まれるのを防ぐために重要です。

### 脆弱性のテスト

アプリのバックアップセキュリティを評価するためには、Finderを使用して**バックアップを作成**し、次に[Appleの公式ドキュメント](https://support.apple.com/en-us/HT204215)のガイダンスに従ってそのバックアップを特定します。バックアップを機密データや構成が変更されてアプリの動作に影響を与える可能性があるかどうかを分析します。

機密情報は、コマンドラインツールや[iMazing](https://imazing.com)などのアプリケーションを使用して検索できます。暗号化されたバックアップの場合、暗号化の存在は、バックアップのルートにある"Manifest.plist"ファイルで"IsEncrypted"キーを確認することで確認できます。
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
### 暗号化されたバックアップの取り扱い

[DinoSecのGitHubリポジトリ](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts)にあるPythonスクリプト、**backup\_tool.py**や**backup\_passwd.py**などは、最新のiTunes/Finderバージョンとの互換性を確保するために調整が必要かもしれませんが、暗号化されたバックアップを扱うのに役立つかもしれません。パスワードで保護されたバックアップ内のファイルにアクセスするための別のオプションとして、[**iOSbackup**ツール](https://pypi.org/project/iOSbackup/)があります。

### アプリの動作の変更

バックアップの修正を通じてアプリの動作を変更する例として、[Bither bitcoin walletアプリ](https://github.com/bither/bither-ios)があります。ここでは、UIロックPINが**pin\_code**キーの下に`net.bither.plist`に保存されています。このキーをplistから削除し、バックアップを復元すると、PINの要件が削除され、制限なしにアクセスできます。

## 機密データのメモリテストに関する要約

アプリケーションのメモリに保存されている機密情報を取り扱う際には、このデータの露出時間を制限することが重要です。メモリコンテンツを調査するための主なアプローチには、**メモリダンプの作成**と**リアルタイムでのメモリの分析**があります。両方の方法には、ダンププロセスや分析中に重要なデータを見逃す可能性など、それぞれの課題があります。

## **メモリダンプの取得と分析**

脱獄済みおよび非脱獄済みデバイスの両方で、[objection](https://github.com/sensepost/objection)や[Fridump](https://github.com/Nightbringer21/fridump)などのツールを使用して、アプリのプロセスメモリをダンプすることができます。ダンプした後、このデータを分析するには、検索している情報の性質に応じてさまざまなツールが必要です。

メモリダンプから文字列を抽出するには、`strings`や`rabin2 -zz`などのコマンドを使用できます。
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
より詳細な分析には、特定のデータタイプやパターンを検索するために、**radare2** が広範な検索機能を提供しています:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **ランタイムメモリ解析**

**r2frida**は、メモリダンプを必要とせずに、リアルタイムでアプリのメモリを調査する強力な代替手段を提供します。このツールは、実行中のアプリケーションのメモリ上で直接検索コマンドを実行できるようにします。
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## 破れた暗号化

### 鍵管理プロセスの不備

一部の開発者は機密データをローカルストレージに保存し、コード内でハードコード化/予測可能なキーで暗号化しています。これは行ってはいけません。逆向きの操作により、攻撃者が機密情報を抽出できる可能性があります。

### 安全でないおよび/または非推奨のアルゴリズムの使用

開発者は**非推奨のアルゴリズム**を使用して認証**チェック**、データの**保存**または**送信**を行うべきではありません。これらのアルゴリズムの一部には、RC4、MD4、MD5、SHA1などがあります。たとえばパスワードを保存するために**ハッシュ**が使用されている場合、ソルトを使用したハッシュブルートフォース**耐性**が必要です。

### チェック

コード内に**ハードコード**されたパスワード/シークレットが見つかるか、それらが**予測可能**であるか、コードがある種の**弱い** **暗号化**アルゴリズムを使用しているかを確認するために行う主なチェックです。

興味深いことに、**objection**を使用していくつかの**暗号** **ライブラリ**を自動的に**監視**できます。
```swift
ios monitor crypt
```
**iOS暗号APIおよびライブラリに関する詳細**については、[https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)にアクセスしてください。

## ローカル認証

**ローカル認証**は、特に暗号化手法を介してリモートエンドポイントへのアクセスを保護する場合に重要な役割を果たします。適切な実装がないと、ローカル認証メカニズムは回避される可能性があります。

Appleの[**ローカル認証フレームワーク**](https://developer.apple.com/documentation/localauthentication)と[**キーチェーン**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)は、開発者がユーザー認証ダイアログを容易にし、秘密データを安全に処理するための堅牢なAPIを提供しています。セキュアエンクレーブはTouch IDの指紋IDを保護し、Face IDは生体認証データを漏洩せずに顔認識に依存しています。

Touch ID/Face IDを統合するために、開発者は2つのAPI選択肢があります：

* **`LocalAuthentication.framework`**：生体認証データにアクセスせずに高レベルのユーザー認証を行います。
* **`Security.framework`**：生体認証で秘密データを保護し、キーチェーンサービスにアクセスします。さまざまな[オープンソースのラッパー](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id)がキーチェーンアクセスを簡素化します。

{% hint style="danger" %}
ただし、`LocalAuthentication.framework`と`Security.framework`の両方には脆弱性があり、認証プロセスのためのデータを送信せずに主にブール値を返すため、バイパスされやすくなっています（[Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)を参照）。
{% endhint %}

### ローカル認証の実装

ユーザーに認証を求めるために、開発者は**`LAContext`**クラス内の**`evaluatePolicy`**メソッドを使用し、次のいずれかを選択する必要があります：

* **`deviceOwnerAuthentication`**：Touch IDまたはデバイスのパスコードを求め、どちらも有効でない場合は失敗します。
* **`deviceOwnerAuthenticationWithBiometrics`**：Touch IDのみを求めます。

**`evaluatePolicy`**からのブール値の返り値によって、成功した認証が示され、潜在的なセキュリティ上の欠陥が強調されます。

### キーチェーンを使用したローカル認証

iOSアプリで**ローカル認証**を実装するには、認証トークンなどの秘密データを安全に保存するために**キーチェーンAPI**を使用します。このプロセスにより、データはユーザーによってのみアクセスでき、デバイスのパスコードやTouch IDなどの生体認証を使用して認証されます。

キーチェーンは、`SecAccessControl`属性を持つアイテムを設定する機能を提供し、ユーザーがTouch IDまたはデバイスのパスコードで正常に認証するまでアイテムへのアクセスを制限します。この機能はセキュリティを向上させるために重要です。

以下に、SwiftとObjective-Cでのコード例を示し、これらのセキュリティ機能を活用してキーチェーンに文字列を保存および取得する方法を示しています。これらの例は、Touch ID認証が必要であり、デバイスのパスコードが構成されている場合にのみデータにアクセスできるようにするためのアクセス制御の設定方法を具体的に示しています。

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

iOSアプリケーションのペネトレーションテストでは、Objective-Cコードの理解が重要です。Objective-CはiOSアプリケーションの開発で広く使用されているプログラミング言語です。アプリケーションのセキュリティを評価する際には、Objective-Cのコードを分析し、潜在的な脆弱性を特定する必要があります。{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

これで、キーチェーンから保存されたアイテムをリクエストできます。キーチェーンサービスは、適切な指紋が提供されたかどうかに応じて、ユーザーに認証ダイアログを表示し、データまたはnilを返します。
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

iOSアプリケーションのペネトレーションテストでは、Objective-Cコードを理解することが重要です。Objective-CはiOSアプリケーションの開発で広く使用されているプログラミング言語です。ペネトレーションテスターはObjective-Cコードを分析し、セキュリティ上の脆弱性を特定するために、Objective-Cの基本的な構文や主要なセキュリティ関連の問題に精通している必要があります。{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
### 検知

アプリ内でのフレームワークの使用は、アプリのバイナリの共有ダイナミックライブラリのリストを分析することで検出することもできます。これは `otool` を使用して行うことができます：
```bash
$ otool -L <AppName>.app/<AppName>
```
もしアプリで`LocalAuthentication.framework`が使用されている場合、出力には以下の2行が含まれます（`LocalAuthentication.framework`は内部で`Security.framework`を使用していることを覚えておいてください）:
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
### ローカル認証フレームワークバイパス

#### **Objection**

**Objectionバイオメトリックバイパス**により、[このGitHubページ](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass)にある、**LocalAuthentication**メカニズムを克服するためのテクニックが利用可能です。このアプローチの中心には、`evaluatePolicy`関数を操作するために**Frida**を活用し、実際の認証成功に関係なく常に`True`の結果を返すようにします。これは、欠陥のある生体認証プロセスを回避するのに特に役立ちます。

このバイパスをアクティブ化するには、次のコマンドを使用します：
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
このコマンドは、Objectionがタスクを登録し、`evaluatePolicy` チェックの結果を `True` に効果的に変更するシーケンスを開始します。

#### Frida

[DVIA-v2アプリケーション](https://github.com/prateek147/DVIA-v2) から **`evaluatePolicy`** の使用例:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
以下は、**evaluatePolicy** メソッドの結果を変更するために注入されたスクリプトです。このスクリプトは、コールバックの結果を常に成功を示すように変更します。
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
以下のコマンドを使用して、Fridaスクリプトをインジェクトし、生体認証をバイパスします:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPCを介した機密機能の露出

### カスタムURIハンドラー / ディープリンク / カスタムスキーム

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### ユニバーサルリンク

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Sharing

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### アプリ拡張機能

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### シリアル化とエンコーディング

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## ネットワーク通信

通信が**暗号化なし**で行われていないことを確認し、アプリケーションがサーバーのTLS証明書を正しく**検証**していることも重要です。\
この種の問題をチェックするためには、**Burp**のようなプロキシを使用できます:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### ホスト名の確認

TLS証明書を検証する一般的な問題の1つは、証明書が**信頼されるCA**によって署名されていることを確認することですが、証明書の**ホスト名**がアクセスされているホスト名と一致しているかどうかを**確認しない**ことです。\
この問題をBurpを使用してチェックするには、iPhoneでBurp CAを信頼した後、Burpで異なるホスト名用の新しい証明書を作成して使用できます。アプリケーションがまだ動作する場合、何かが脆弱です。

### 証明書ピニング

アプリケーションが正しくSSLピニングを使用している場合、アプリケーションは期待される証明書でのみ動作します。アプリケーションをテストする際には、**これは問題になる可能性があります。Burpは独自の証明書を提供します。**\
この保護をバイパスするために、ジェイルブレイクされたデバイス内でアプリケーション[**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2)をインストールするか、[**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)をインストールできます。

また、**objection**の`ios sslpinning disable`を使用することもできます。

## その他

* **`/System/Library`**には、システムアプリケーションで使用される電話にインストールされたフレームワークがあります。
* ユーザーがApp Storeからインストールしたアプリケーションは**`/User/Applications`**内にあります。
* **`/User/Library`**には、ユーザーレベルのアプリケーションによって保存されたデータが含まれています。
* **`/User/Library/Notes/notes.sqlite`**にアクセスして、アプリケーション内に保存されたノートを読むことができます。
* インストールされたアプリケーションのフォルダー内（**`/User/Applications/<APP ID>/`**）には、いくつかの興味深いファイルがあります:
  * **`iTunesArtwork`**: アプリで使用されるアイコン
  * **`iTunesMetadata.plist`**: App Storeで使用されるアプリの情報
  * **`/Library/*`**: 偏好設定とキャッシュが含まれています。**`/Library/Cache/Snapshots/*`**には、アプリをバックグラウンドに送信する前に行われたスナップショットがあります。

### ホットパッチング/強制更新

開発者は、アプリケーションを再提出して承認されるまで待つことなく、すべてのインストールされたアプリケーションをリモートで**即座にパッチ**することができます。\
この目的のためには通常、[**JSPatch**](https://github.com/bang590/JSPatch)**などが使用されます。** ただし、[Siren](https://github.com/ArtSabintsev/Siren)や[react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker)などの他のオプションもあります。\
**これは悪意のある第三者SDKによって悪用される可能性がある危険なメカニズムであるため、自動更新にどのような方法が使用されているか（あれば）を確認し、テストすることが推奨されます。** この目的のために以前のバージョンのアプリをダウンロードしてみることができます。

### サードパーティ

**第三者SDK**に関する重要な課題の1つは、その機能に対する**細かい制御の欠如**です。開発者は、SDKを統合してそのすべての機能、潜在的なセキュリティの脆弱性やプライバシー上の懸念を含むかどうかを受け入れるか、その利点を完全に放棄するかの選択を迫られます。これらのSDK内の脆弱性をパッチすることができないこともよくあります。さらに、SDKがコミュニティ内で信頼を得るにつれて、一部はマルウェアを含むようになることがあります。

第三者SDKが提供するサービスには、ユーザーの行動追跡、広告表示、ユーザーエクスペリエンスの向上などが含まれる場合があります。ただし、これにはリスクが伴います。開発者はこれらのライブラリによって実行されるコードについて完全に認識していない可能性があるため、潜在的なプライバシーやセキュリティリスクが発生する可能性があります。第三者サービスと共有される情報を必要最小限に抑え、機密データが公開されないようにすることが重要です。

第三者サービスの実装は通常、スタンドアロンライブラリまたは完全なSDKの2つの形式で提供されます。これらのサービスと共有されるすべてのデータは、個人を特定できる情報（PII）の開示を防ぐために**匿名化**されるべきです。

アプリケーションが使用するライブラリを特定するには、**`otool`**コマンドを使用できます。このツールは、アプリケーションとそれが使用する各共有ライブラリに対して実行され、追加のライブラリを発見するのに役立ちます。
```bash
otool -L <application_path>
```
## **参考文献とその他のリソース**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS無料コース([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-Cバージョン [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swiftバージョン
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks)を使用して、世界で最も高度なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスしてください：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)、当社の独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを発見
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローしてください。
* **HackTricks**および**HackTricks Cloud**のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
