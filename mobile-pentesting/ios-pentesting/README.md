# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas da comunidade mais avan√ßada do mundo.\
Acesse hoje mesmo:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>

## Conceitos B√°sicos do iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Ambiente de Testes

Nesta p√°gina, voc√™ pode encontrar informa√ß√µes sobre o **simulador iOS**, **emuladores** e **jailbreaking:**

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## An√°lise Inicial

### Opera√ß√µes B√°sicas de Teste do iOS

Durante o teste, **v√°rias opera√ß√µes ser√£o sugeridas** (conectar ao dispositivo, ler/escrever/fazer upload/download de arquivos, usar algumas ferramentas...). Portanto, se voc√™ n√£o souber como realizar alguma dessas a√ß√µes, por favor, **comece lendo a p√°gina**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Para os pr√≥ximos passos, **o aplicativo deve estar instalado** no dispositivo e voc√™ deve ter obtido o **arquivo IPA** do aplicativo.\
Leia a p√°gina [Opera√ß√µes B√°sicas de Teste do iOS](basic-ios-testing-operations.md) para aprender como fazer isso.
{% endhint %}

### An√°lise Est√°tica B√°sica

√â recomendado usar a ferramenta [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) para realizar uma An√°lise Est√°tica autom√°tica no arquivo IPA.

Identifica√ß√£o das **prote√ß√µes presentes no bin√°rio**:

*   **PIE (Executable Posicionamento Independente)**: Quando ativado, o aplicativo carrega em um endere√ßo de mem√≥ria aleat√≥rio toda vez que √© iniciado, tornando mais dif√≠cil prever seu endere√ßo de mem√≥ria inicial.

```bash
otool -hv <app-binary> | grep PIE   # Deve incluir a flag PIE
```
*   **Can√°rios de Pilha**: Para validar a integridade da pilha, um valor 'can√°rio' √© colocado na pilha antes de chamar uma fun√ß√£o e √© validado novamente quando a fun√ß√£o termina.

```bash
otool -I -v <app-binary> | grep stack_chk   # Deve incluir os s√≠mbolos: stack_chk_guard e stack_chk_fail
```
*   **ARC (Contagem Autom√°tica de Refer√™ncias)**: Para prevenir falhas comuns de corrup√ß√£o de mem√≥ria

```bash
otool -I -v <app-binary> | grep objc_release   # Deve incluir o s√≠mbolo _objc_release
```
*   **Bin√°rio Criptografado**: O bin√°rio deve estar criptografado

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # O cryptid deve ser 1
```

**Identifica√ß√£o de Fun√ß√µes Sens√≠veis/Inseguras**

*   **Algoritmos de Hashing Fracos**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# No linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fun√ß√µes Rand√¥micas Inseguras**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# No linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fun√ß√£o 'Malloc' Insegura**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_malloc"

# No linux
grep -iER "_malloc"
```
*   **Fun√ß√µes Inseguras e Vulner√°veis**

```bash
# No dispositivo iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# No linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### An√°lise Din√¢mica B√°sica

Confira a an√°lise din√¢mica que o [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) realiza. Voc√™ precisar√° navegar pelas diferentes visualiza√ß√µes e interagir com elas, mas ele ir√° conectar v√°rias classes e fazer outras coisas, e preparar√° um relat√≥rio quando voc√™ terminar.

### Listando Apps Instalados

Use o comando `frida-ps -Uai` para determinar o **identificador de pacote** dos aplicativos instalados:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Enumera√ß√£o B√°sica & Hooking

Aprenda como **enumerar os componentes do aplicativo** e como **facilmente hookar m√©todos e classes** com o objection:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Estrutura do IPA

A estrutura de um arquivo **IPA** √© essencialmente a de um **pacote compactado**. Renomeando sua extens√£o para `.zip`, ele pode ser **descompactado** para revelar seu conte√∫do. Dentro desta estrutura, um **Bundle** representa um aplicativo totalmente empacotado pronto para instala√ß√£o. Dentro, voc√™ encontrar√° um diret√≥rio chamado `<NOME>.app`, que encapsula os recursos do aplicativo.

* **`Info.plist`**: Este arquivo cont√©m detalhes espec√≠ficos de configura√ß√£o do aplicativo.
* **`_CodeSignature/`**: Este diret√≥rio inclui um arquivo plist que cont√©m uma assinatura, garantindo a integridade de todos os arquivos no pacote.
* **`Assets.car`**: Um arquivo de arquivo comprimido que armazena arquivos de recursos como √≠cones.
* **`Frameworks/`**: Esta pasta abriga as bibliotecas nativas do aplicativo, que podem estar na forma de arquivos `.dylib` ou `.framework`.
* **`PlugIns/`**: Isso pode incluir extens√µes para o aplicativo, conhecidas como arquivos `.appex`, embora nem sempre estejam presentes.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): √â usado para salvar os dados permanentes do seu aplicativo para uso offline, para armazenar dados tempor√°rios e adicionar funcionalidade de desfazer ao seu aplicativo em um √∫nico dispositivo. Para sincronizar dados em v√°rios dispositivos em uma √∫nica conta iCloud, o Core Data espelha automaticamente seu esquema para um cont√™iner CloudKit.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): O arquivo `PkgInfo` √© uma maneira alternativa de especificar os c√≥digos de tipo e criador de seu aplicativo ou pacote.
* **en.lproj, fr.proj, Base.lproj**: S√£o os pacotes de idiomas que cont√™m recursos para esses idiomas espec√≠ficos e um recurso padr√£o no caso de um idioma n√£o ser suportado.
* **Seguran√ßa**: O diret√≥rio `_CodeSignature/` desempenha um papel cr√≠tico na seguran√ßa do aplicativo, verificando a integridade de todos os arquivos empacotados por meio de assinaturas digitais.
* **Gerenciamento de Ativos**: O arquivo `Assets.car` usa compress√£o para gerenciar eficientemente ativos gr√°ficos, crucial para otimizar o desempenho do aplicativo e reduzir seu tamanho total.
* **Frameworks e PlugIns**: Esses diret√≥rios destacam a modularidade dos aplicativos iOS, permitindo que os desenvolvedores incluam bibliotecas de c√≥digo reutiliz√°veis (`Frameworks/`) e estendam a funcionalidade do aplicativo (`PlugIns/`).
* **Localiza√ß√£o**: A estrutura suporta v√°rios idiomas, facilitando o alcance global do aplicativo ao incluir recursos para pacotes de idiomas espec√≠ficos.

**Info.plist**

O **Info.plist** serve como uma pedra angular para aplicativos iOS, encapsulando dados de configura√ß√£o chave na forma de pares de **chave-valor**. Este arquivo √© um requisito n√£o apenas para aplicativos, mas tamb√©m para extens√µes de aplicativos e frameworks empacotados dentro. Ele √© estruturado em XML ou em um formato bin√°rio e cont√©m informa√ß√µes cr√≠ticas que v√£o desde permiss√µes de aplicativos at√© configura√ß√µes de seguran√ßa. Para uma explora√ß√£o detalhada das chaves dispon√≠veis, pode-se consultar a [**Documenta√ß√£o para Desenvolvedores da Apple**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc).

Para aqueles que desejam trabalhar com este arquivo em um formato mais acess√≠vel, a convers√£o para XML pode ser feita facilmente atrav√©s do uso do `plutil` no macOS (dispon√≠vel nativamente nas vers√µes 10.2 e posteriores) ou `plistutil` no Linux. Os comandos para convers√£o s√£o os seguintes:

* **Para macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
* **Para Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Entre a mir√≠ade de informa√ß√µes que o arquivo **Info.plist** pode divulgar, entradas not√°veis incluem strings de permiss√£o do aplicativo (`UsageDescription`), esquemas de URL personalizados (`CFBundleURLTypes`), e configura√ß√µes para a Seguran√ßa de Transporte do Aplicativo (`NSAppTransportSecurity`). Essas entradas, juntamente com outras como tipos de documentos personalizados exportados/importados (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), podem ser facilmente localizadas inspecionando o arquivo ou empregando um simples comando `grep`:
```bash
$ grep -i <keyword> Info.plist
```
**Caminhos de Dados**

No ambiente iOS, diret√≥rios s√£o designados especificamente para **aplica√ß√µes do sistema** e **aplica√ß√µes instaladas pelo usu√°rio**. As aplica√ß√µes do sistema residem no diret√≥rio `/Applications`, enquanto as aplica√ß√µes instaladas pelo usu√°rio s√£o colocadas em `/var/mobile/containers/Data/Application/`. Essas aplica√ß√µes recebem um identificador √∫nico conhecido como **UUID de 128 bits**, tornando a tarefa de localizar manualmente a pasta de um aplicativo desafiadora devido √† aleatoriedade dos nomes dos diret√≥rios.

{% hint style="warning" %}
Como as aplica√ß√µes no iOS devem ser isoladas, cada aplicativo ter√° tamb√©m uma pasta dentro de **`$HOME/Library/Containers`** com o **`CFBundleIdentifier`** do aplicativo como nome da pasta.

No entanto, ambas as pastas (de dados e de cont√™iner) possuem o arquivo **`.com.apple.mobile_container_manager.metadata.plist`** que vincula ambos os arquivos na chave `MCMetadataIdentifier`).
{% endhint %}

Para facilitar a descoberta do diret√≥rio de instala√ß√£o de um aplicativo instalado pelo usu√°rio, a ferramenta **objection** fornece um comando √∫til, `env`. Este comando revela informa√ß√µes detalhadas do diret√≥rio para o aplicativo em quest√£o. Abaixo est√° um exemplo de como usar este comando:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativamente, o nome do aplicativo pode ser pesquisado dentro de `/private/var/containers` usando o comando `find`:
```bash
find /private/var/containers -name "Progname*"
```
Comandos como `ps` e `lsof` tamb√©m podem ser utilizados para identificar o processo do aplicativo e listar arquivos abertos, respectivamente, fornecendo informa√ß√µes sobre os caminhos do diret√≥rio ativo do aplicativo:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Diret√≥rio do pacote:**

* **AppName.app**
* Este √© o Pacote de Aplicativo, como visto anteriormente no IPA, ele cont√©m dados essenciais do aplicativo, conte√∫do est√°tico, bem como o bin√°rio compilado do aplicativo.
* Este diret√≥rio √© vis√≠vel para os usu√°rios, mas **os usu√°rios n√£o podem escrever nele**.
* O conte√∫do deste diret√≥rio **n√£o √© backup**.
* O conte√∫do desta pasta √© usado para **validar a assinatura do c√≥digo**.

**Diret√≥rio de dados:**

* **Documents/**
* Cont√©m todos os dados gerados pelo usu√°rio. O usu√°rio final do aplicativo inicia a cria√ß√£o desses dados.
* Vis√≠vel para os usu√°rios e **os usu√°rios podem escrever nele**.
* O conte√∫do deste diret√≥rio √© **backup**.
* O aplicativo pode desabilitar caminhos definindo `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Cont√©m todos os **arquivos que n√£o s√£o espec√≠ficos do usu√°rio**, como **caches**, **prefer√™ncias**, **cookies** e arquivos de configura√ß√£o de lista de propriedades (plist).
* Os aplicativos iOS geralmente usam os subdiret√≥rios `Application Support` e `Caches`, mas o aplicativo pode criar subdiret√≥rios personalizados.
* **Library/Caches/**
* Cont√©m **arquivos em cache semi-persistentes**.
* Invis√≠vel para os usu√°rios e **os usu√°rios n√£o podem escrever nele**.
* O conte√∫do deste diret√≥rio **n√£o √© backup**.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o aplicativo n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.
* **Library/Application Support/**
* Cont√©m **arquivos persistentes necess√°rios para executar o aplicativo**.
* **Invis√≠vel** **para** **os** **usu√°rios** e os usu√°rios n√£o podem escrever nele.
* O conte√∫do deste diret√≥rio √© **backup**.
* O aplicativo pode desabilitar caminhos definindo `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Usado para armazenar propriedades que podem **persistir mesmo depois que um aplicativo √© reiniciado**.
* As informa√ß√µes s√£o salvas, n√£o criptografadas, dentro do sandbox do aplicativo em um arquivo plist chamado \[BUNDLE\_ID].plist.
* Todos os pares chave/valor armazenados usando `NSUserDefaults` podem ser encontrados neste arquivo.
* **tmp/**
* Use este diret√≥rio para escrever **arquivos tempor√°rios** que n√£o precisam persistir entre os lan√ßamentos do aplicativo.
* Cont√©m arquivos em cache n√£o persistentes.
* **Invis√≠vel** para os usu√°rios.
* O conte√∫do deste diret√≥rio n√£o √© backup.
* O sistema operacional pode excluir automaticamente os arquivos deste diret√≥rio quando o aplicativo n√£o est√° em execu√ß√£o e o espa√ßo de armazenamento est√° baixo.

Vamos dar uma olhada mais de perto no diret√≥rio do Pacote de Aplicativo (.app) do iGoat-Swift dentro do diret√≥rio do Pacote (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Revers√£o Bin√°ria

Dentro da pasta `<nome-do-aplicativo>.app`, voc√™ encontrar√° um arquivo bin√°rio chamado `<nome-do-aplicativo>`. Este √© o arquivo que ser√° **executado**. Voc√™ pode realizar uma inspe√ß√£o b√°sica do bin√°rio com a ferramenta **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Verifique se o aplicativo est√° criptografado**

Veja se h√° alguma sa√≠da para:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Desmontando o bin√°rio**

Desmonte a se√ß√£o de texto:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Para imprimir o segmento **Objective-C** do aplicativo de exemplo, pode-se usar:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Para obter um c√≥digo Objective-C mais compacto, voc√™ pode usar [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
No entanto, as melhores op√ß√µes para desmontar o bin√°rio s√£o: [**Hopper**](https://www.hopperapp.com/download.html?) e [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Armazenamento de Dados

Para aprender como o iOS armazena dados no dispositivo, leia esta p√°gina:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Os seguintes locais para armazenar informa√ß√µes devem ser verificados **logo ap√≥s a instala√ß√£o do aplicativo**, **ap√≥s verificar todas as funcionalidades** do aplicativo e mesmo ap√≥s **sair de um usu√°rio e entrar em outro**.\
O objetivo √© encontrar **informa√ß√µes sens√≠veis desprotegidas** do aplicativo (senhas, tokens), do usu√°rio atual e de usu√°rios anteriormente logados.
{% endhint %}

### Plist

Os arquivos **plist** s√£o arquivos XML estruturados que **cont√™m pares chave-valor**. √â uma forma de armazenar dados persistentes, ent√£o √†s vezes voc√™ pode encontrar **informa√ß√µes sens√≠veis nesses arquivos**. √â recomendado verificar esses arquivos ap√≥s instalar o aplicativo e ap√≥s us√°-lo intensivamente para ver se novos dados s√£o gravados.

A forma mais comum de persistir dados em arquivos plist √© atrav√©s do uso do **NSUserDefaults**. Este arquivo plist √© salvo dentro do sandbox do aplicativo em **`Library/Preferences/<appBundleID>.plist`**

A classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fornece uma interface program√°tica para interagir com o sistema padr√£o. O sistema padr√£o permite que um aplicativo personalize seu comportamento de acordo com as **prefer√™ncias do usu√°rio**. Os dados salvos pelo `NSUserDefaults` podem ser visualizados no pacote do aplicativo. Esta classe armazena **dados** em um **arquivo plist**, mas √© destinada a ser usada com pequenas quantidades de dados.

Esses dados n√£o podem ser acessados diretamente por um computador confi√°vel, mas podem ser acessados fazendo um **backup**.

Voc√™ pode **extrair** as informa√ß√µes salvas usando **`NSUserDefaults`** usando o `ios nsuserdefaults get` do objection.

Para encontrar todos os plists usados pelo aplicativo, voc√™ pode acessar `/private/var/mobile/Containers/Data/Application/{APPID}` e executar:
```bash
find ./ -name "*.plist"
```
Para converter arquivos do formato **XML ou bin√°rio (bplist)** para XML, est√£o dispon√≠veis v√°rios m√©todos, dependendo do seu sistema operacional:

**Para usu√°rios do macOS:** Utilize o comando `plutil`. √â uma ferramenta integrada no macOS (10.2+), projetada para esse fim:
```bash
$ plutil -convert xml1 Info.plist
```
**Para Usu√°rios Linux:** Primeiro, instale `libplist-utils` e depois utilize `plistutil` para converter seu arquivo:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Dentro de uma Sess√£o do Objection:** Para analisar aplicativos m√≥veis, um comando espec√≠fico permite converter arquivos plist diretamente:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) √© um framework para gerenciar a camada de modelo de objetos em sua aplica√ß√£o. [O Core Data pode usar o SQLite como seu armazenamento persistente](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mas o pr√≥prio framework n√£o √© um banco de dados. CoreData n√£o criptografa seus dados por padr√£o. No entanto, uma camada adicional de criptografia pode ser adicionada ao CoreData. Consulte o [Reposit√≥rio do GitHub](https://github.com/project-imas/encrypted-core-data) para mais detalhes.

Voc√™ pode encontrar as informa√ß√µes do SQLite Core Data de um aplicativo no caminho `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Se voc√™ conseguir abrir o SQLite e acessar informa√ß√µes sens√≠veis, ent√£o encontrou uma m√° configura√ß√£o.**
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) √© um armazenamento de chave/valor constru√≠do em cima do SQLite.\
Como os bancos de dados Yap s√£o bancos de dados sqlite, voc√™ pode encontr√°-los usando o comando proposto na se√ß√£o anterior.

### Outros Bancos de Dados SQLite

√â comum que aplicativos criem seu pr√≥prio banco de dados sqlite. Eles podem estar armazenando dados sens√≠veis neles e deixando-os n√£o criptografados. Portanto, √© sempre interessante verificar cada banco de dados dentro do diret√≥rio de aplicativos. Portanto, v√° para o diret√≥rio do aplicativo onde os dados s√£o salvos (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bancos de Dados em Tempo Real do Firebase

Os desenvolvedores podem **armazenar e sincronizar dados** em um **banco de dados hospedado na nuvem NoSQL** por meio dos Bancos de Dados em Tempo Real do Firebase. Armazenados em formato JSON, os dados s√£o sincronizados em tempo real para todos os clientes conectados.

Voc√™ pode aprender como verificar bancos de dados do Firebase mal configurados aqui:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bancos de Dados Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) e [Realm Swift](https://realm.io/docs/swift/latest/) oferecem uma alternativa poderosa para armazenamento de dados, n√£o fornecida pela Apple. Por padr√£o, eles **armazenam dados n√£o criptografados**, com criptografia dispon√≠vel por meio de configura√ß√£o espec√≠fica.

Os bancos de dados est√£o localizados em: `/private/var/mobile/Containers/Data/Application/{APPID}`. Para explorar esses arquivos, pode-se utilizar comandos como:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Para visualizar esses arquivos de banco de dados, √© recomendada a utiliza√ß√£o da ferramenta [**Realm Studio**](https://github.com/realm/realm-studio).

Para implementar a criptografia dentro de um banco de dados Realm, o seguinte trecho de c√≥digo pode ser utilizado:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bancos de Dados do Couchbase Lite

O [Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) √© descrito como um mecanismo de banco de dados **leve** e **embutido** que segue a abordagem **orientada a documentos** (NoSQL). Projetado para ser nativo do **iOS** e **macOS**, oferece a capacidade de sincronizar dados de forma transparente.

Para identificar poss√≠veis bancos de dados do Couchbase em um dispositivo, o seguinte diret√≥rio deve ser inspecionado:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Cookies

O iOS armazena os cookies dos aplicativos na pasta **`Library/Cookies/cookies.binarycookies`** dentro da pasta de cada aplicativo. No entanto, os desenvolvedores √†s vezes decidem salv√°-los no **keychain** j√° que o **arquivo de cookies mencionado pode ser acessado em backups**.

Para inspecionar o arquivo de cookies, voc√™ pode usar [**este script em python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou usar o comando **`ios cookies get`** do objection.\
**Voc√™ tamb√©m pode usar o objection para** converter esses arquivos para um formato JSON e inspecionar os dados.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Por padr√£o, o NSURLSession armazena dados, como **solicita√ß√µes e respostas HTTP no banco de dados Cache.db**. Este banco de dados pode conter **dados sens√≠veis**, como tokens, nomes de usu√°rio ou qualquer outra informa√ß√£o sens√≠vel que tenha sido armazenada em cache. Para encontrar as informa√ß√µes em cache, abra o diret√≥rio de dados do aplicativo (`/var/mobile/Containers/Data/Application/<UUID>`) e v√° para `/Library/Caches/<Bundle Identifier>`. O **cache do WebKit tamb√©m √© armazenado no arquivo Cache.db**. O **Objection** pode abrir e interagir com o banco de dados com o comando `sqlite connect Cache.db`, pois √© um **banco de dados SQLite normal**.

√â **recomendado desativar o cache desses dados**, pois pode conter informa√ß√µes sens√≠veis na solicita√ß√£o ou resposta. A lista abaixo mostra diferentes maneiras de alcan√ßar isso:

1.  √â recomendado remover as respostas em cache ap√≥s o logout. Isso pode ser feito com o m√©todo fornecido pela Apple chamado [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Voc√™ pode chamar este m√©todo da seguinte forma:

`URLCache.shared.removeAllCachedResponses()`

Este m√©todo remover√° todas as solicita√ß√µes e respostas em cache do arquivo Cache.db.
2.  Se voc√™ n√£o precisa usar os cookies, seria recomendado usar apenas a propriedade de configura√ß√£o [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) do URLSession, que desativar√° o salvamento de cookies e caches.

[Documenta√ß√£o da Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Um objeto de configura√ß√£o de sess√£o ef√™mera √© semelhante a uma configura√ß√£o de sess√£o padr√£o (consulte padr√£o), exceto que o objeto de sess√£o correspondente n√£o armazena caches, armazenamentos de credenciais ou quaisquer dados relacionados √† sess√£o no disco. Em vez disso, os dados relacionados √† sess√£o s√£o armazenados na RAM. A √∫nica vez que uma sess√£o ef√™mera grava dados no disco √© quando voc√™ diz a ela para gravar o conte√∫do de uma URL em um arquivo.`
3. O cache tamb√©m pode ser desativado definindo a Pol√≠tica de Cache para [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Isso desativar√° o armazenamento de cache de qualquer maneira, seja na mem√≥ria ou no disco.

### Snapshots

Sempre que voc√™ pressiona o bot√£o home, o iOS **tira um instant√¢neo da tela atual** para poder fazer a transi√ß√£o para o aplicativo de uma maneira muito mais suave. No entanto, se **dados sens√≠veis** estiverem presentes na tela atual, eles ser√£o **salvos** na **imagem** (que **persiste** **atrav√©s** **dos** **rein√≠cios**). Estes s√£o os instant√¢neos aos quais voc√™ tamb√©m pode acessar ao tocar duas vezes na tela inicial para alternar entre aplicativos.

A menos que o iPhone esteja com jailbreak, o **atacante** precisa ter **acesso** ao **dispositivo** **desbloqueado** para ver essas capturas de tela. Por padr√£o, o √∫ltimo instant√¢neo √© armazenado no sandbox do aplicativo em `Library/Caches/Snapshots/` ou na pasta `Library/SplashBoard/Snapshots` (os computadores confi√°veis n√£o podem acessar o sistema de arquivos a partir do iOS 7.0).

Uma maneira de evitar esse comportamento indesejado √© colocar uma tela em branco ou remover os dados sens√≠veis antes de tirar o instant√¢neo usando a fun√ß√£o `ApplicationDidEnterBackground()`.

A seguir, um m√©todo de remedia√ß√£o de exemplo que definir√° uma captura de tela padr√£o.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
**Objective-C:**
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Este define a imagem de fundo para `overlayImage.png` sempre que a aplica√ß√£o √© colocada em segundo plano. Isso previne vazamentos de dados sens√≠veis porque `overlayImage.png` sempre substituir√° a visualiza√ß√£o atual.

### Chaveiro

Para acessar e gerenciar o chaveiro do iOS, ferramentas como [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) est√£o dispon√≠veis, adequadas para dispositivos com jailbreak. Al√©m disso, o [**Objection**](https://github.com/sensepost/objection) fornece o comando `ios keychain dump` para fins semelhantes.

#### **Armazenamento de Credenciais**

A classe **NSURLCredential** √© ideal para salvar informa√ß√µes sens√≠veis diretamente no chaveiro, contornando a necessidade de NSUserDefaults ou outros inv√≥lucros. Para armazenar credenciais ap√≥s o login, o seguinte c√≥digo Swift √© usado:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Para extrair essas credenciais armazenadas, √© utilizado o comando `ios nsurlcredentialstorage dump` do Objection.

## **Teclados Personalizados e Cache de Teclado**

A partir do iOS 8.0, os usu√°rios podem instalar extens√µes de teclado personalizadas, que s√£o gerenci√°veis em **Configura√ß√µes > Geral > Teclado > Teclados**. Embora esses teclados ofere√ßam funcionalidades estendidas, eles representam um risco de registro de teclas e transmiss√£o de dados para servidores externos, embora os usu√°rios sejam notificados sobre teclados que exigem acesso √† rede. Os aplicativos podem e devem restringir o uso de teclados personalizados para a entrada de informa√ß√µes sens√≠veis.

**Recomenda√ß√µes de Seguran√ßa:**

* √â aconselh√°vel desativar os teclados de terceiros para seguran√ßa aprimorada.
* Esteja ciente das funcionalidades de autocorre√ß√£o e de sugest√µes autom√°ticas do teclado padr√£o do iOS, que podem armazenar informa√ß√µes sens√≠veis em arquivos de cache localizados em `Library/Keyboard/{locale}-dynamic-text.dat` ou `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Esses arquivos de cache devem ser verificados regularmente em busca de dados sens√≠veis. Recomenda-se redefinir o dicion√°rio do teclado via **Configura√ß√µes > Geral > Redefinir > Redefinir Dicion√°rio do Teclado** para limpar os dados em cache.
* A intercepta√ß√£o do tr√°fego de rede pode revelar se um teclado personalizado est√° transmitindo pressionamentos de teclas remotamente.

### **Prevenindo o Cache de Campos de Texto**

O protocolo [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) oferece propriedades para gerenciar a autocorre√ß√£o e a entrada de texto segura, essenciais para prevenir o cache de informa√ß√µes sens√≠veis. Por exemplo, desativar a autocorre√ß√£o e habilitar a entrada de texto segura pode ser alcan√ßado com:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Al√©m disso, os desenvolvedores devem garantir que os campos de texto, especialmente aqueles para inserir informa√ß√µes sens√≠veis como senhas e PINs, desativem o cache definindo `autocorrectionType` como `UITextAutocorrectionTypeNo` e `secureTextEntry` como `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Registos**

Depurar c√≥digo frequentemente envolve o uso de **registos**. Existe um risco, uma vez que os **registos podem conter informa√ß√µes sens√≠veis**. Anteriormente, no iOS 6 e em vers√µes anteriores, os registos eram acess√≠veis a todas as aplica√ß√µes, representando um risco de fuga de dados sens√≠veis. **Agora, as aplica√ß√µes est√£o restritas a aceder apenas aos seus pr√≥prios registos**.

Apesar destas restri√ß√µes, um **atacante com acesso f√≠sico** a um dispositivo desbloqueado ainda pode explorar isso ao ligar o dispositivo a um computador e **ler os registos**. √â importante notar que os registos permanecem no disco mesmo ap√≥s a desinstala√ß√£o da aplica√ß√£o.

Para mitigar os riscos, √© aconselh√°vel **interagir minuciosamente com a aplica√ß√£o**, explorando todas as suas funcionalidades e entradas para garantir que nenhuma informa√ß√£o sens√≠vel esteja a ser registada inadvertidamente.

Ao rever o c√≥digo-fonte da aplica√ß√£o em busca de poss√≠veis fugas, procure tanto por **declara√ß√µes de registo predefinidas** quanto por **declara√ß√µes de registo personalizadas** usando palavras-chave como `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` para fun√ß√µes integradas, e quaisquer men√ß√µes a `Logging` ou `Logfile` para implementa√ß√µes personalizadas.

### **Monitorizar Registos do Sistema**

As aplica√ß√µes registam v√°rias informa√ß√µes que podem ser sens√≠veis. Para monitorizar estes registos, ferramentas e comandos como:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
S√£o √∫teis. Al√©m disso, **Xcode** fornece uma maneira de coletar logs do console:

1. Abra o Xcode.
2. Conecte o dispositivo iOS.
3. Navegue at√© **Window** -> **Devices and Simulators**.
4. Selecione seu dispositivo.
5. Acione o problema que est√° investigando.
6. Use o bot√£o **Open Console** para visualizar os logs em uma nova janela.

Para um registro mais avan√ßado, conectar-se ao shell do dispositivo e usar **socat** pode fornecer monitoramento de log em tempo real:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Seguido por comandos para observar atividades de log, que podem ser inestim√°veis para diagnosticar problemas ou identificar poss√≠veis vazamentos de dados nos logs.

***

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir facilmente e **automatizar fluxos de trabalho** com as ferramentas comunit√°rias mais avan√ßadas do mundo.\
Acesse hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Backups

Recursos de **auto-backup** est√£o integrados ao iOS, facilitando a cria√ß√£o de c√≥pias de dados do dispositivo atrav√©s do iTunes (at√© o macOS Catalina), Finder (a partir do macOS Catalina) ou iCloud. Esses backups abrangem quase todos os dados do dispositivo, excluindo elementos altamente sens√≠veis como detalhes do Apple Pay e configura√ß√µes do Touch ID.

### Riscos de Seguran√ßa

A inclus√£o de **aplicativos instalados e seus dados** nos backups levanta a quest√£o de poss√≠veis **vazamentos de dados** e o risco de que **modifica√ß√µes nos backups possam alterar a funcionalidade do aplicativo**. √â aconselh√°vel **n√£o armazenar informa√ß√µes sens√≠veis em texto simples** dentro do diret√≥rio de qualquer aplicativo ou seus subdiret√≥rios para mitigar esses riscos.

### Excluindo Arquivos dos Backups

Arquivos em `Documents/` e `Library/Application Support/` s√£o automaticamente inclu√≠dos nos backups. Os desenvolvedores podem excluir arquivos ou diret√≥rios espec√≠ficos dos backups usando `NSURL setResourceValue:forKey:error:` com a chave `NSURLIsExcludedFromBackupKey`. Essa pr√°tica √© crucial para proteger dados sens√≠veis de serem inclu√≠dos nos backups.

### Testando Vulnerabilidades

Para avaliar a seguran√ßa do backup de um aplicativo, comece por **criar um backup** usando o Finder e, em seguida, localize-o seguindo as orienta√ß√µes da [documenta√ß√£o oficial da Apple](https://support.apple.com/en-us/HT204215). Analise o backup em busca de dados sens√≠veis ou configura√ß√µes que possam ser alteradas para afetar o comportamento do aplicativo.

Informa√ß√µes sens√≠veis podem ser procuradas usando ferramentas de linha de comando ou aplicativos como [iMazing](https://imazing.com). Para backups criptografados, a presen√ßa de criptografia pode ser confirmada verificando a chave "IsEncrypted" no arquivo "Manifest.plist" na raiz do backup.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Para lidar com backups criptografados, scripts Python dispon√≠veis no [reposit√≥rio GitHub da DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts), como **backup\_tool.py** e **backup\_passwd.py**, podem ser √∫teis, embora possam exigir ajustes para compatibilidade com as vers√µes mais recentes do iTunes/Finder. A ferramenta [**iOSbackup**](https://pypi.org/project/iOSbackup/) √© outra op√ß√£o para acessar arquivos em backups protegidos por senha.

### Modificando o Comportamento do Aplicativo

Um exemplo de altera√ß√£o no comportamento do aplicativo por meio de modifica√ß√µes no backup √© demonstrado no aplicativo de carteira de bitcoins Bither (https://github.com/bither/bither-ios), onde o PIN de bloqueio da interface do usu√°rio √© armazenado em `net.bither.plist` sob a chave **pin\_code**. Remover essa chave do plist e restaurar o backup remove o requisito do PIN, fornecendo acesso irrestrito.

## Resumo sobre Teste de Mem√≥ria para Dados Sens√≠veis

Ao lidar com informa√ß√µes sens√≠veis armazenadas na mem√≥ria de um aplicativo, √© crucial limitar o tempo de exposi√ß√£o desses dados. Existem duas abordagens principais para investigar o conte√∫do da mem√≥ria: **criar um despejo de mem√≥ria** e **analisar a mem√≥ria em tempo real**. Ambos os m√©todos t√™m seus desafios, incluindo a possibilidade de perder dados cr√≠ticos durante o processo de despejo ou an√°lise.

## **Recuperando e Analisando um Despejo de Mem√≥ria**

Para dispositivos com e sem jailbreak, ferramentas como [objection](https://github.com/sensepost/objection) e [Fridump](https://github.com/Nightbringer21/fridump) permitem o despejo da mem√≥ria do processo de um aplicativo. Uma vez despejados, analisar esses dados requer v√°rias ferramentas, dependendo da natureza das informa√ß√µes que voc√™ est√° procurando.

Para extrair strings de um despejo de mem√≥ria, comandos como `strings` ou `rabin2 -zz` podem ser usados:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Para uma an√°lise mais detalhada, incluindo a busca por tipos de dados ou padr√µes espec√≠ficos, o **radare2** oferece amplas capacidades de pesquisa:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **An√°lise de Mem√≥ria em Tempo de Execu√ß√£o**

**r2frida** fornece uma alternativa poderosa para inspecionar a mem√≥ria de um aplicativo em tempo real, sem a necessidade de um despejo de mem√≥ria. Esta ferramenta permite a execu√ß√£o de comandos de pesquisa diretamente na mem√≥ria do aplicativo em execu√ß√£o:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Criptografia Quebrada

### Processos de Gerenciamento de Chave Fracos

Alguns desenvolvedores salvam dados sens√≠veis no armazenamento local e os criptografam com uma chave codificada/previs√≠vel no c√≥digo. Isso n√£o deve ser feito, pois a revers√£o pode permitir que os atacantes extraiam as informa√ß√µes confidenciais.

### Uso de Algoritmos Inseguros e/ou Obsoletos

Os desenvolvedores n√£o devem usar **algoritmos obsoletos** para realizar **verifica√ß√µes** de autoriza√ß√£o, **armazenar** ou **enviar** dados. Alguns desses algoritmos s√£o: RC4, MD4, MD5, SHA1... Se **hashes** forem usados para armazenar senhas, por exemplo, hashes resistentes a ataques de for√ßa bruta devem ser usados com salt.

### Verifica√ß√£o

As principais verifica√ß√µes a serem realizadas s√£o encontrar senhas/segredos **codificados** no c√≥digo, ou se eles s√£o **previs√≠veis**, e se o c√≥digo est√° usando algum tipo de algoritmos de **criptografia** **fracos**.

√â interessante saber que voc√™ pode **monitorar** algumas **bibliotecas de criptografia** automaticamente usando **objection** com:
```swift
ios monitor crypt
```
Para **mais informa√ß√µes** sobre APIs e bibliotecas criptogr√°ficas do iOS, acesse [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Autentica√ß√£o Local

A **autentica√ß√£o local** desempenha um papel crucial, especialmente quando se trata de proteger o acesso em um ponto remoto por meio de m√©todos criptogr√°ficos. A ess√™ncia aqui √© que, sem uma implementa√ß√£o adequada, os mecanismos de autentica√ß√£o local podem ser contornados.

O [**framework de Autentica√ß√£o Local da Apple**](https://developer.apple.com/documentation/localauthentication) e o [**keychain**](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) fornecem APIs robustas para os desenvolvedores facilitarem di√°logos de autentica√ß√£o do usu√°rio e lidarem de forma segura com dados secretos, respectivamente. O Secure Enclave protege a identifica√ß√£o de impress√£o digital para o Touch ID, enquanto o Face ID depende do reconhecimento facial sem comprometer os dados biom√©tricos.

Para integrar o Touch ID/Face ID, os desenvolvedores t√™m duas op√ß√µes de API:

* **`LocalAuthentication.framework`** para autentica√ß√£o de usu√°rio em alto n√≠vel sem acesso aos dados biom√©tricos.
* **`Security.framework`** para acesso a servi√ßos de chaveiro em n√≠vel mais baixo, protegendo dados secretos com autentica√ß√£o biom√©trica. V√°rios [envolt√≥rios de c√≥digo aberto](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) tornam o acesso ao chaveiro mais simples.

{% hint style="danger" %}
No entanto, tanto `LocalAuthentication.framework` quanto `Security.framework` apresentam vulnerabilidades, pois retornam principalmente valores booleanos sem transmitir dados para processos de autentica√ß√£o, tornando-os suscet√≠veis a contornos (consulte [Don't touch me that way, de David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementando Autentica√ß√£o Local

Para solicitar autentica√ß√£o aos usu√°rios, os desenvolvedores devem utilizar o m√©todo **`evaluatePolicy`** dentro da classe **`LAContext`**, escolhendo entre:

* **`deviceOwnerAuthentication`**: Solicita o Touch ID ou o c√≥digo de acesso do dispositivo, falhando se nenhum estiver habilitado.
* **`deviceOwnerAuthenticationWithBiometrics`**: Solicita exclusivamente o Touch ID.

Uma autentica√ß√£o bem-sucedida √© indicada por um valor booleano retornado de **`evaluatePolicy`**, destacando uma poss√≠vel falha de seguran√ßa.

### Autentica√ß√£o Local usando Keychain

Implementar a **autentica√ß√£o local** em aplicativos iOS envolve o uso de **APIs de chaveiro** para armazenar de forma segura dados secretos, como tokens de autentica√ß√£o. Esse processo garante que os dados s√≥ possam ser acessados pelo usu√°rio, usando o c√≥digo de acesso do dispositivo ou autentica√ß√£o biom√©trica como o Touch ID.

O chaveiro oferece a capacidade de definir itens com o atributo `SecAccessControl`, que restringe o acesso ao item at√© que o usu√°rio autentique com sucesso via Touch ID ou c√≥digo de acesso do dispositivo. Esse recurso √© crucial para aprimorar a seguran√ßa.

Abaixo est√£o exemplos de c√≥digo em Swift e Objective-C demonstrando como salvar e recuperar uma string do chaveiro, aproveitando esses recursos de seguran√ßa. Os exemplos mostram especificamente como configurar o controle de acesso para exigir autentica√ß√£o do Touch ID e garantir que os dados sejam acess√≠veis apenas no dispositivo em que foram configurados, sob a condi√ß√£o de que um c√≥digo de acesso do dispositivo esteja configurado.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}

## Introdu√ß√£o

O iOS √© um sistema operacional m√≥vel desenvolvido pela Apple Inc. exclusivamente para seus dispositivos. O iOS √© conhecido por sua seguran√ßa robusta, o que torna o pentesting de aplicativos iOS um desafio interessante.

## Ferramentas de Pentesting para iOS

Existem v√°rias ferramentas de pentesting dispon√≠veis para testar a seguran√ßa de aplicativos iOS. Algumas das ferramentas populares incluem:

- **Burp Suite**: Uma ferramenta poderosa para testar a seguran√ßa de aplicativos m√≥veis, incluindo aplicativos iOS.
- **MobSF (Mobile Security Framework)**: Uma estrutura automatizada de teste de seguran√ßa para aplicativos m√≥veis que suporta testes de aplicativos iOS.
- **Needle**: Uma estrutura de inje√ß√£o de depend√™ncia para testar aplicativos iOS.
- **Cycript**: Uma ferramenta de depura√ß√£o e explora√ß√£o interativa para aplicativos iOS.

## Metodologia de Pentesting para iOS

Ao realizar pentesting em aplicativos iOS, √© importante seguir uma metodologia bem definida. Alguns passos comuns incluem:

1. **Coleta de Informa√ß√µes**: Compreender o aplicativo e suas funcionalidades.
2. **An√°lise Est√°tica**: Analisar o c√≥digo do aplicativo em busca de vulnerabilidades.
3. **An√°lise Din√¢mica**: Testar o aplicativo em tempo de execu√ß√£o para identificar poss√≠veis vulnerabilidades.
4. **Testes de Seguran√ßa**: Realizar testes de seguran√ßa, como testes de autentica√ß√£o, autoriza√ß√£o, criptografia, etc.
5. **Relat√≥rio de Vulnerabilidades**: Documentar e relatar todas as vulnerabilidades encontradas durante o teste.

Lembre-se de sempre obter permiss√£o adequada antes de realizar pentesting em aplicativos iOS para garantir conformidade legal e √©tica.

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Agora podemos solicitar o item salvo do chaveiro. Os servi√ßos do chaveiro apresentar√£o o di√°logo de autentica√ß√£o ao usu√°rio e retornar√£o os dados ou nulo, dependendo se uma impress√£o digital adequada foi fornecida ou n√£o.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}

## Introdu√ß√£o

O Objective-C √© uma linguagem de programa√ß√£o amplamente utilizada para o desenvolvimento de aplicativos iOS. Nesta se√ß√£o, discutiremos algumas das vulnerabilidades de seguran√ßa comuns associadas ao desenvolvimento de aplicativos iOS usando Objective-C.

## Inje√ß√£o de C√≥digo

A inje√ß√£o de c√≥digo √© uma t√©cnica comum usada por hackers para inserir e executar c√≥digo malicioso em um aplicativo iOS. Isso pode ser feito explorando vulnerabilidades no c√≥digo Objective-C do aplicativo.

## Armazenamento Inseguro de Dados

O armazenamento inseguro de dados ocorre quando informa√ß√µes confidenciais, como senhas ou chaves de API, s√£o armazenadas de forma insegura no aplicativo iOS. Isso pode levar a vazamentos de dados e comprometer a seguran√ßa do aplicativo.

## Comunica√ß√£o Insegura

A comunica√ß√£o insegura ocorre quando os dados s√£o transmitidos de forma n√£o criptografada, tornando-os vulner√°veis a ataques de intercepta√ß√£o. √â importante garantir que todas as comunica√ß√µes entre o aplicativo iOS e os servidores sejam seguras e criptografadas.

## Conclus√£o

Ao desenvolver aplicativos iOS em Objective-C, √© crucial estar ciente das vulnerabilidades de seguran√ßa comuns e implementar pr√°ticas recomendadas para proteger os dados dos usu√°rios e a integridade do aplicativo.

{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Detec√ß√£o

O uso de frameworks em um aplicativo tamb√©m pode ser detectado analisando a lista de bibliotecas din√¢micas compartilhadas do bin√°rio do aplicativo. Isso pode ser feito usando `otool`:
```bash
$ otool -L <AppName>.app/<AppName>
```
Se o `LocalAuthentication.framework` for usado em um aplicativo, a sa√≠da conter√° ambas as seguintes linhas (lembre-se de que o `LocalAuthentication.framework` usa o `Security.framework` internamente):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Se for usado o `Security.framework`, apenas o segundo ser√° mostrado.

### Bypass do Framework de Autentica√ß√£o Local

#### **Objection**

Atrav√©s do **Objection Biometrics Bypass**, localizado nesta [p√°gina do GitHub](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), uma t√©cnica est√° dispon√≠vel para contornar o mecanismo de **LocalAuthentication**. O cerne dessa abordagem envolve a alavancagem do **Frida** para manipular a fun√ß√£o `evaluatePolicy`, garantindo que ela produza consistentemente um resultado `True`, independentemente do sucesso real da autentica√ß√£o. Isso √© particularmente √∫til para contornar processos de autentica√ß√£o biom√©trica com falhas.

Para ativar esse bypass, o seguinte comando √© utilizado:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Este comando inicia uma sequ√™ncia onde o Objection registra uma tarefa que altera efetivamente o resultado da verifica√ß√£o `evaluatePolicy` para `True`.

#### Frida

Um exemplo de uso do **`evaluatePolicy`** do aplicativo [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Para alcan√ßar a **burla** da Autentica√ß√£o Local, √© escrito um script Frida. Este script tem como alvo a verifica√ß√£o **evaluatePolicy**, interceptando o seu retorno para garantir que ele retorne **success=1**. Ao alterar o comportamento do retorno, a verifica√ß√£o de autentica√ß√£o √© efetivamente burlada.

O script abaixo √© injetado para modificar o resultado do m√©todo **evaluatePolicy**. Ele altera o resultado do retorno para sempre indicar sucesso.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Para injetar o script Frida e contornar a autentica√ß√£o biom√©trica, √© utilizado o seguinte comando:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposi√ß√£o de Funcionalidades Sens√≠veis Atrav√©s de IPC

### Manipula√ß√£o de URI Personalizada / Deeplinks / Esquemas Personalizados

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Links Universais

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Compartilhamento de UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extens√µes de Aplicativos

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serializa√ß√£o e Codifica√ß√£o

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Comunica√ß√£o de Rede

√â importante verificar se n√£o h√° comunica√ß√£o ocorrendo **sem criptografia** e tamb√©m se a aplica√ß√£o est√° corretamente **validando o certificado TLS** do servidor.\
Para verificar esse tipo de problema, voc√™ pode usar um proxy como o **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Verifica√ß√£o de Nome de Host

Um problema comum na valida√ß√£o do certificado TLS √© verificar se o certificado foi assinado por uma **CA confi√°vel**, mas **n√£o verificar** se **o nome do host** do certificado √© o nome do host sendo acessado.\
Para verificar esse problema usando o Burp, ap√≥s confiar na CA do Burp no iPhone, voc√™ pode **criar um novo certificado com o Burp para um nome de host diferente** e us√°-lo. Se a aplica√ß√£o ainda funcionar, ent√£o algo est√° vulner√°vel.

### Pinagem de Certificado

Se uma aplica√ß√£o estiver usando corretamente a Pinagem SSL, ent√£o a aplica√ß√£o s√≥ funcionar√° se o certificado for o esperado. Ao testar uma aplica√ß√£o **isso pode ser um problema, pois o Burp servir√° seu pr√≥prio certificado.**\
Para contornar essa prote√ß√£o em um dispositivo com jailbreak, voc√™ pode instalar o aplicativo [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou instalar [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Voc√™ tamb√©m pode usar `ios sslpinning disable` do **objection**

## Diversos

* Em **`/System/Library`** voc√™ pode encontrar os frameworks instalados no telefone usados pelas aplica√ß√µes do sistema
* As aplica√ß√µes instaladas pelo usu√°rio na App Store est√£o localizadas dentro de **`/User/Applications`**
* E o **`/User/Library`** cont√©m dados salvos pelas aplica√ß√µes de n√≠vel de usu√°rio
* Voc√™ pode acessar **`/User/Library/Notes/notes.sqlite`** para ler as notas salvas dentro da aplica√ß√£o.
* Dentro da pasta de uma aplica√ß√£o instalada (**`/User/Applications/<ID DO APP>/`**) voc√™ pode encontrar alguns arquivos interessantes:
  * **`iTunesArtwork`**: O √≠cone usado pelo aplicativo
  * **`iTunesMetadata.plist`**: Informa√ß√µes do aplicativo usadas na App Store
  * **`/Library/*`**: Cont√©m as prefer√™ncias e cache. Em **`/Library/Cache/Snapshots/*`** voc√™ pode encontrar o snapshot realizado pela aplica√ß√£o antes de envi√°-la para segundo plano.

### Hot Patching/Atualiza√ß√£o For√ßada

Os desenvolvedores podem remotamente **corrigir todas as instala√ß√µes de seu aplicativo instantaneamente** sem precisar reenviar o aplicativo para a App Store e esperar pela aprova√ß√£o.\
Para esse fim, geralmente √© usado o [**JSPatch**](https://github.com/bang590/JSPatch)**.** Mas existem outras op√ß√µes tamb√©m, como [Siren](https://github.com/ArtSabintsev/Siren) e [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Este √© um mecanismo perigoso que poderia ser abusado por SDKs de terceiros maliciosos, portanto √© recomendado verificar qual m√©todo √© usado para atualiza√ß√£o autom√°tica (se houver) e test√°-lo.** Voc√™ pode tentar baixar uma vers√£o anterior do aplicativo para esse fim.

### Terceiros

Um desafio significativo com **SDKs de terceiros** √© a **falta de controle granular** sobre suas funcionalidades. Os desenvolvedores se deparam com uma escolha: integrar o SDK e aceitar todas as suas funcionalidades, incluindo poss√≠veis vulnerabilidades de seguran√ßa e preocupa√ß√µes com privacidade, ou renunciar completamente aos seus benef√≠cios. Muitas vezes, os desenvolvedores n√£o conseguem corrigir vulnerabilidades dentro desses SDKs por conta pr√≥pria. Al√©m disso, √† medida que os SDKs ganham confian√ßa na comunidade, alguns podem come√ßar a conter malware.

Os servi√ßos fornecidos por SDKs de terceiros podem incluir rastreamento de comportamento do usu√°rio, exibi√ß√£o de an√∫ncios ou aprimoramentos da experi√™ncia do usu√°rio. No entanto, isso introduz um risco, pois os desenvolvedores podem n√£o estar totalmente cientes do c√≥digo executado por essas bibliotecas, levando a potenciais riscos de privacidade e seguran√ßa. √â crucial limitar as informa√ß√µes compartilhadas com servi√ßos de terceiros ao que √© necess√°rio e garantir que nenhum dado sens√≠vel seja exposto.

A implementa√ß√£o de servi√ßos de terceiros geralmente vem em duas formas: uma biblioteca independente ou um SDK completo. Para proteger a privacidade do usu√°rio, quaisquer dados compartilhados com esses servi√ßos devem ser **anonimizados** para evitar a divulga√ß√£o de Informa√ß√µes Pessoalmente Identific√°veis (IPI).

Para identificar as bibliotecas que uma aplica√ß√£o utiliza, o comando **`otool`** pode ser empregado. Esta ferramenta deve ser executada contra a aplica√ß√£o e cada biblioteca compartilhada que ela utiliza para descobrir bibliotecas adicionais.
```bash
otool -L <application_path>
```
## **Refer√™ncias e Mais Recursos**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Curso gratuito de iOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Vers√£o Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Vers√£o Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Use [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) para construir e **automatizar fluxos de trabalho** facilmente com as **ferramentas comunit√°rias mais avan√ßadas do mundo**.\
Tenha Acesso Hoje:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira [**produtos oficiais PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou nos siga no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
