# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Pogledajte [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnove iOS-a

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Testno okruženje

Na ovoj stranici možete pronaći informacije o **iOS simulatoru**, **emulatorima** i **jailbreaking-u**:

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Početna analiza

### Osnovne operacije testiranja iOS-a

Tokom testiranja će biti predložene **neke operacije** (povezivanje sa uređajem, čitanje/pisanje/otpisivanje/preuzimanje fajlova, korišćenje nekih alata...). Ako ne znate kako da izvršite neku od ovih radnji, **počnite čitati stranicu**:

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Za sledeće korake, **aplikacija treba biti instalirana** na uređaju i već treba da ste dobili **IPA fajl** aplikacije.\
Pročitajte stranicu [Osnovne operacije testiranja iOS-a](basic-ios-testing-operations.md) da biste naučili kako to uraditi.
{% endhint %}

### Osnovna statička analiza

Preporučuje se korišćenje alata [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) za automatsku statičku analizu IPA fajla.

Identifikacija **zaštita koje su prisutne u binarnom fajlu**:

*   **PIE (Position Independent Executable)**: Kada je omogućeno, aplikacija se učitava na nasumičnu memorijsku adresu svaki put kada se pokrene, što otežava predviđanje početne memorijske adrese.

```bash
otool -hv <app-binary> | grep PIE   # Trebalo bi da sadrži zastavicu PIE
```
*   **Stack Canaries**: Da bi se potvrdila celovitost steka, vrednost 'canary' se postavlja na stek pre poziva funkcije i ponovo se proverava nakon završetka funkcije.

```bash
otool -I -v <app-binary> | grep stack_chk   # Trebalo bi da sadrži simbole: stack_chk_guard i stack_chk_fail
```
*   **ARC (Automatic Reference Counting)**: Da bi se sprečile uobičajene greške korupcije memorije

```bash
otool -I -v <app-binary> | grep objc_release   # Trebalo bi da sadrži simbol _objc_release
```
*   **Enkriptovani binarni fajl**: Binarni fajl treba biti enkriptovan

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptid treba da bude 1
```

**Identifikacija osetljivih/nepouzdanih funkcija**

*   **Slabe heš funkcije**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Na linux-u
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Nepouzdane slučajne funkcije**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Na linux-u
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Nepouzdana 'Malloc' funkcija**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_malloc"

# Na linux-u
grep -iER "_malloc"
```
*   **Nepouzdane i ranjive funkcije**

```bash
# Na iOS uređaju
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Na linux-u
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Osnovna dinamička analiza

Pogledajte dinamičku analizu koju [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) vrši. Morate da se kretate kroz različite prikaze i da s njima interagujete, ali će se povezivati sa nekoliko klasa i obavljati druge radnje, a zatim će pripremiti izveštaj kada završite.

### Lista instaliranih aplikacija

Koristite komandu `frida-ps -Uai` da biste odredili **identifikator paketa** instaliranih aplikacija:
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### Osnovno prebrojavanje i hakovanje

Naučite kako da **prebrojite komponente aplikacije** i kako lako da **hakujete metode i klase** pomoću objekcije:

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Struktura IPA fajla

Struktura **IPA fajla** je suštinski kao kod **zipovanog paketa**. Promenom ekstenzije u `.zip`, može se **dekompresovati** i otkriti njegov sadržaj. U ovoj strukturi, **Bundle** predstavlja potpuno zapakovanu aplikaciju spremnu za instalaciju. Unutar nje, nalazi se direktorijum nazvan `<IME>.app`, koji sadrži resurse aplikacije.

* **`Info.plist`**: Ovaj fajl sadrži specifične konfiguracione detalje aplikacije.
* **`_CodeSignature/`**: Ovaj direktorijum uključuje plist fajl koji sadrži potpis, obezbeđujući integritet svih fajlova u paketu.
* **`Assets.car`**: Kompresovani arhiv koji čuva fajlove resursa kao što su ikone.
* **`Frameworks/`**: Ovaj folder sadrži nativne biblioteke aplikacije, koje mogu biti u obliku `.dylib` ili `.framework` fajlova.
* **`PlugIns/`**: Ovde se mogu nalaziti proširenja aplikacije, poznata kao `.appex` fajlovi, mada nisu uvek prisutni.
* [**`Core Data`**](https://developer.apple.com/documentation/coredata): Koristi se za čuvanje trajnih podataka aplikacije za offline upotrebu, keširanje privremenih podataka i dodavanje mogućnosti poništavanja u aplikaciji na jednom uređaju. Da biste sinhronizovali podatke na više uređaja u jednom iCloud nalogu, Core Data automatski reflektuje vašu šemu u CloudKit kontejneru.
* [**`PkgInfo`**](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): Fajl `PkgInfo` je alternativni način za specificiranje tipa i kreator koda vaše aplikacije ili paketa.
* **en.lproj, fr.proj, Base.lproj**: Ovo su jezički paketi koji sadrže resurse za određene jezike, i podrazumevani resurs u slučaju da jezik nije podržan.
* **Bezbednost**: Direktorijum `_CodeSignature/` igra ključnu ulogu u bezbednosti aplikacije tako što proverava integritet svih zapakovanih fajlova putem digitalnih potpisa.
* **Upravljanje resursima**: Fajl `Assets.car` koristi kompresiju kako bi efikasno upravljao grafičkim resursima, što je ključno za optimizaciju performansi aplikacije i smanjenje njene ukupne veličine.
* **Framework-i i PlugIn-ovi**: Ovi direktorijumi naglašavaju modularnost iOS aplikacija, omogućavajući programerima da uključe ponovno upotrebljive biblioteke koda (`Frameworks/`) i prošire funkcionalnost aplikacije (`PlugIns/`).
* **Lokalizacija**: Struktura podržava više jezika, olakšavajući globalno dostizanje aplikacije uključivanjem resursa za određene jezičke pakete.

**Info.plist**

**Info.plist** služi kao osnova za iOS aplikacije, enkapsulirajući ključne konfiguracione podatke u obliku **ključ-vrednost** parova. Ovaj fajl je neophodan ne samo za aplikacije, već i za proširenja aplikacija i framework-ove koji su zapakovani unutar njih. Struktura fajla može biti u XML ili binarnom formatu i sadrži ključne informacije koje se kreću od dozvola aplikacije do konfiguracija bezbednosti. Za detaljnije istraživanje dostupnih ključeva, možete se referisati na [**Apple Developer dokumentaciju**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Za one koji žele da rade sa ovim fajlom u pristupačnijem formatu, konverzija u XML format se može lako postići korišćenjem `plutil` na macOS-u (dostupan nativno u verzijama 10.2 i novijim) ili `plistutil` na Linux-u. Komande za konverziju su sledeće:

- **Za macOS**:
```bash
$ plutil -convert xml1 Info.plist
```
- **Za Linux**:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
Među mnoštvom informacija koje **Info.plist** datoteka može otkriti, značajni unosi uključuju nizove dozvola aplikacije (`UsageDescription`), prilagođene URL sheme (`CFBundleURLTypes`) i konfiguracije za sigurnost transporta aplikacije (`NSAppTransportSecurity`). Ovi unosi, zajedno sa drugima poput izvezenih/uvezenih prilagođenih tipova dokumenata (`UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`), mogu se lako pronaći inspekcijom datoteke ili upotrebom jednostavne `grep` komande:
```bash
$ grep -i <keyword> Info.plist
```
**Putanje podataka**

U iOS okruženju, direktorijumi su posebno namenjeni **sistemskim aplikacijama** i **korisnički instaliranim aplikacijama**. Sistemski aplikacije se nalaze u direktorijumu `/Applications`, dok se korisnički instalirane aplikacije smeštaju pod `/private/var/containers/`. Ove aplikacije su dodeljene jedinstveni identifikator poznat kao **128-bitni UUID**, što čini zadatkom ručnog pronalaženja foldera aplikacije izazovnim zbog nasumičnosti imena direktorijuma.

Da bi se olakšalo otkrivanje direktorijuma instalacije korisnički instalirane aplikacije, **objection alat** pruža korisnu komandu, `env`. Ova komanda otkriva detaljne informacije o direktorijumu za aplikaciju u pitanju. U nastavku je prikazan primer kako koristiti ovu komandu:
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Alternativno, ime aplikacije može biti pretraženo unutar `/private/var/containers` koristeći `find` komandu:
```bash
find /private/var/containers -name "Progname*"
```
Komande poput `ps` i `lsof` takođe mogu biti iskorišćene kako bi se identifikovali procesi aplikacije i izlistali otvoreni fajlovi, pružajući uvid u aktivne putanje direktorijuma aplikacije:
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
**Direktorijum paketa:**

* **AppName.app**
* Ovo je paket aplikacije koji je vidljiv u IPA formatu, sadrži osnovne podatke aplikacije, statički sadržaj kao i prevedeni binarni fajl aplikacije.
* Ovaj direktorijum je vidljiv korisnicima, ali **korisnici ne mogu pisati u njega**.
* Sadržaj ovog direktorijuma **se ne bekapuje**.
* Sadržaj ovog foldera se koristi za **validaciju potpisa koda**.

**Direktorijum podataka:**

* **Documents/**
* Sadrži sve podatke koje generiše korisnik. Kreiranje ovih podataka inicira sam korisnik aplikacije.
* Vidljiv korisnicima i **korisnici mogu pisati u njega**.
* Sadržaj ovog direktorijuma **se bekapuje**.
* Aplikacija može onemogućiti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Sadrži sve **fajlove koji nisu specifični za korisnika**, kao što su **keš memorija**, **postavke**, **kolačići** i konfiguracioni fajlovi u obliku property liste (plist).
* iOS aplikacije obično koriste poddirektorijume `Application Support` i `Caches`, ali aplikacija može kreirati i prilagođene poddirektorijume.
* **Library/Caches/**
* Sadrži **polu-persistentne keširane fajlove**.
* Nevidljiv korisnicima i **korisnici ne mogu pisati u njega**.
* Sadržaj ovog direktorijuma **se ne bekapuje**.
* Operativni sistem može automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladištenje.
* **Library/Application Support/**
* Sadrži **persistentne fajlove** neophodne za pokretanje aplikacije.
* **Nevidljiv** korisnicima i korisnici ne mogu pisati u njega.
* Sadržaj ovog direktorijuma **se bekapuje**.
* Aplikacija može onemogućiti putanje postavljanjem `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Koristi se za čuvanje svojstava koja **mogu trajati čak i nakon ponovnog pokretanja aplikacije**.
* Informacije se čuvaju nešifrovano unutar peska aplikacije u plist fajlu koji se zove \[BUNDLE\_ID].plist.
* Svi parovi ključ/vrednost koji se čuvaju koristeći `NSUserDefaults` mogu se pronaći u ovom fajlu.
* **tmp/**
* Koristite ovaj direktorijum za pisanje **privremenih fajlova** koji ne moraju trajati između pokretanja aplikacije.
* Sadrži ne-persistentne keširane fajlove.
* **Nevidljiv** korisnicima.
* Sadržaj ovog direktorijuma se ne bekapuje.
* Operativni sistem može automatski obrisati fajlove iz ovog direktorijuma kada aplikacija nije pokrenuta i kada je malo slobodnog prostora za skladištenje.

Pogledajmo detaljnije direktorijum aplikacije iGoat-Swift (.app) unutar direktorijuma Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`):
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Binarno obrtanje

Unutar foldera `<ime-aplikacije>.app` pronaći ćete binarnu datoteku nazvanu `<ime-aplikacije>`. Ovo je datoteka koja će biti **izvršena**. Možete izvršiti osnovnu inspekciju binarne datoteke pomoću alata **`otool`**:
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**Proverite da li je aplikacija enkriptovana**

Proverite da li postoji bilo kakav izlaz za:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**Razlaganje binarnog koda**

Razloži tekstualnu sekciju:
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Da biste odštampali **Objective-C segment** uzorka aplikacije, možete koristiti:
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Da biste dobili kompaktniji Objective-C kod, možete koristiti [**class-dump**](http://stevenygard.com/projects/class-dump/):
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Međutim, najbolje opcije za rastavljanje binarnog koda su: [**Hopper**](https://www.hopperapp.com/download.html?) i [**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** uz pomoć najnaprednijih alata zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Skladištenje podataka

Da biste saznali kako iOS skladišti podatke na uređaju, pročitajte ovu stranicu:

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Sledeća mesta za skladištenje informacija treba proveriti **odmah nakon instaliranja aplikacije**, **nakon provere svih funkcionalnosti** aplikacije i čak nakon **odjavljivanja sa jednog korisnika i prijavljivanja na drugog**.\
Cilj je pronaći **nezaštićene osetljive informacije** aplikacije (lozinke, tokene), trenutnog korisnika i prethodno prijavljenih korisnika.
{% endhint %}

### Plist

**plist** fajlovi su strukturirani XML fajlovi koji **sadrže parove ključ-vrednost**. To je način za skladištenje trajnih podataka, pa se ponekad može pronaći **osetljive informacije u ovim fajlovima**. Preporučuje se provera ovih fajlova nakon instaliranja aplikacije i nakon intenzivnog korišćenja kako bi se videlo da li su upisani novi podaci.

Najčešći način za trajno skladištenje podataka u plist fajlovima je kroz korišćenje **NSUserDefaults**. Ovaj plist fajl se čuva unutar aplikacije u **`Library/Preferences/<appBundleID>.plist`**

Klasa [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) pruža programski interfejs za interakciju sa podrazumevanim sistemom. Podrazumevani sistem omogućava aplikaciji da prilagodi svoje ponašanje prema **korisničkim preferencama**. Podaci sačuvani pomoću `NSUserDefaults` mogu se videti u paketu aplikacije. Ova klasa skladišti **podatke** u **plist** **fajl**, ali je namenjena za korišćenje sa malim količinama podataka.

Ovi podaci ne mogu se više direktno pristupiti putem pouzdanog računara, ali se mogu pristupiti izvršavanjem **rezervne kopije**.

Možete **izvući** sačuvane informacije koristeći **`NSUserDefaults`** pomoću komande `ios nsuserdefaults get` u alatu objection.

Da biste pronašli sve plist fajlove koje koristi aplikacija, možete pristupiti `/private/var/mobile/Containers/Data/Application/{APPID}` i pokrenuti:
```bash
find ./ -name "*.plist"
```
Da biste konvertovali fajlove iz **XML ili binarnog (bplist)** formata u XML, dostupne su različite metode u zavisnosti od vašeg operativnog sistema:

**Za korisnike macOS-a:**
Koristite `plutil` komandu. To je ugrađeni alat u macOS-u (verzija 10.2+), dizajniran za tu svrhu:
```bash
$ plutil -convert xml1 Info.plist
```
**Za korisnike Linuxa:**
Prvo instalirajte `libplist-utils`, a zatim koristite `plistutil` da biste konvertovali vaš fajl:
```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
**Unutar Objection sesije:**
Za analizu mobilnih aplikacija, određena komanda vam omogućava da direktno konvertujete plist fajlove:
```bash
ios plist cat /private/var/mobile/Containers/Data/Application/<Application-UUID>/Library/Preferences/com.some.package.app.plist
```
### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1) je okvir za upravljanje slojem modela objekata u vašoj aplikaciji. [Core Data može koristiti SQLite kao svoje trajno skladište](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), ali sam okvir nije baza podataka.\
CoreData ne šifrira podatke prema zadanim postavkama. Međutim, dodatni sloj šifriranja može se dodati CoreData. Pogledajte [GitHub Repo](https://github.com/project-imas/encrypted-core-data) za više detalja.

Informacije o SQLite Core Data aplikacije možete pronaći na putanji `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Ako možete otvoriti SQLite i pristupiti osjetljivim informacijama, onda ste pronašli grešku u konfiguraciji.**

{% code title="Kod iz iGoat-a" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) je skladište ključ/vrednost izgrađeno na vrhu SQLite-a.\
Pošto su Yap baze podataka sqlite baze podataka, možete ih pronaći koristeći prethodno navedenu komandu.

### Ostale SQLite baze podataka

Često se dešava da aplikacije kreiraju svoje sopstvene sqlite baze podataka. Mogu da **čuvaju** **osetljive** **podatke** na njima i ostave ih nešifrovane. Zbog toga je uvek interesantno proveriti svaku bazu podataka unutar direktorijuma aplikacije. Zato idite u direktorijum aplikacije gde se podaci čuvaju (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebase Real-Time baze podataka

Razvojnim programerima je omogućeno da **skladište i sinhronizuju podatke** unutar **NoSQL baze podataka u oblaku** putem Firebase Real-Time baza podataka. Podaci se čuvaju u JSON formatu i sinhronizuju se u realnom vremenu sa svim povezanim klijentima.

Kako proveriti da li su Firebase baze podataka konfigurisane na pogrešan način možete pronaći ovde:

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realm baze podataka

[Realm Objective-C](https://realm.io/docs/objc/latest/) i [Realm Swift](https://realm.io/docs/swift/latest/) pružaju moćnu alternativu za skladištenje podataka koju Apple ne pruža. Podaci se podrazumevano **čuvaju nešifrovano**, a šifrovanje je dostupno putem određene konfiguracije.

Baze podataka se nalaze na lokaciji: `/private/var/mobile/Containers/Data/Application/{APPID}`. Za istraživanje ovih fajlova, mogu se koristiti komande kao što su:
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Za pregledanje ovih baza podataka preporučuje se alat [**Realm Studio**](https://github.com/realm/realm-studio).

Za implementaciju enkripcije unutar Realm baze podataka, može se koristiti sledeći kod:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite baze podataka

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) je opisan kao **lagani** i **ugrađeni** baza podataka engine koji sledi **dokument-orientisani** (NoSQL) pristup. Dizajniran da bude prirodan za **iOS** i **macOS**, nudi mogućnost sinhronizacije podataka bez problema.

Da biste identifikovali potencijalne Couchbase baze podataka na uređaju, treba pregledati sledeći direktorijum:
```bash
ls /private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/
```
### Kolačići

iOS čuva kolačiće aplikacija u **`Library/Cookies/cookies.binarycookies`** unutar svake fascikle aplikacije. Međutim, programeri ponekad odluče da ih sačuvaju u **keychain-u** jer se pomenuti **fajl sa kolačićima može pristupiti u rezervnim kopijama**.

Da biste pregledali fajl sa kolačićima, možete koristiti [**ovaj Python skript**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ili koristiti objection-ovu komandu **`ios cookies get`.**\
**Takođe možete koristiti objection da** konvertujete ove fajlove u JSON format i pregledate podatke.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Keširanje

Podrazumevano, NSURLSession čuva podatke, kao što su **HTTP zahtevi i odgovori u bazi podataka Cache.db**. Ova baza podataka može sadržati **osetljive podatke**, ako su tokeni, korisnička imena ili bilo koje druge osetljive informacije keširane. Da biste pronašli keširane informacije, otvorite direktorijum podataka aplikacije (`/var/mobile/Containers/Data/Application/<UUID>`) i idite na `/Library/Caches/<Bundle Identifier>`. **WebKit keširanje takođe se čuva u fajlu Cache.db**. **Objection** može otvoriti i interagovati sa bazom podataka pomoću komande `sqlite connect Cache.db`, jer je to **obična SQLite baza podataka**.

Preporučuje se **onemogućavanje keširanja ovih podataka**, jer mogu sadržati osetljive informacije u zahtevu ili odgovoru. Sledeća lista prikazuje različite načine postizanja ovoga:

1. Preporučuje se uklanjanje keširanih odgovora nakon odjavljivanja. To se može uraditi pomoću metode koju je obezbedio Apple pod nazivom [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Možete pozvati ovu metodu na sledeći način:

`URLCache.shared.removeAllCachedResponses()`

Ova metoda će ukloniti sve keširane zahteve i odgovore iz fajla Cache.db.
2. Ako ne morate koristiti prednosti kolačića, preporučuje se korišćenje [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) konfiguracionog svojstva URLSession, koje će onemogućiti čuvanje kolačića i keširanje.

[Apple dokumentacija](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral):

`Objekat konfiguracije privremene sesije sličan je objektu konfiguracije podrazumevane sesije (vidi podrazumevano), osim što odgovarajući objekat sesije ne čuva kešove, skladišta akreditacija ili bilo koje podatke vezane za sesiju na disku. Umesto toga, podaci vezani za sesiju se čuvaju u RAM-u. Jedini put kada privremena sesija upisuje podatke na disk je kada joj kažete da upiše sadržaj URL-a u fajl.`
3. Keširanje se takođe može onemogućiti postavljanjem politike keširanja na [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). To će onemogućiti čuvanje keša na bilo koji način, bilo u memoriji ili na disku.

### Snimci ekrana

Svaki put kada pritisnete dugme za početni ekran, iOS **pravi snimak trenutnog ekrana** kako bi mogao da izvrši prelazak na aplikaciju na mnogo glađi način. Međutim, ako se **osetljivi podaci** nalaze na trenutnom ekranu, oni će biti **sačuvani** u **slici** (koja **preživljava** **ponovno pokretanje** uređaja). Ovo su snimci ekrana do kojih možete pristupiti i dvostrukim dodirivanjem početnog ekrana kako biste prebacili aplikacije.

Ako iPhone nije jailbroken, **napadač** mora imati **pristup** **odblokiranom** uređaju da bi video ove snimke ekrana. Podrazumevano, poslednji snimak se čuva u sandboxu aplikacije u fascikli `Library/Caches/Snapshots/` ili `Library/SplashBoard/Snapshots` (povereni računari ne mogu pristupiti fajl sistemu od iOS 7.0).

Jedan način da se spreči ovo neželjeno ponašanje je da se postavi prazan ekran ili ukloni osetljivi podaci pre snimanja snimka korišćenjem funkcije `ApplicationDidEnterBackground()`.

Evo primera metode za ispravljanje koja će postaviti podrazumevani snimak.

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C:

Objective-C je objektno orijentisani programski jezik koji se koristi za razvoj aplikacija za iOS operativni sistem. Ovaj jezik je nastao kao proširenje jezika C i koristi se za pisanje aplikacija za iPhone, iPad i iPod Touch uređaje.

Objective-C ima bogatu sintaksu koja omogućava programerima da kreiraju objekte, definišu metode i koriste nasleđivanje. Ovaj jezik takođe podržava dinamičko povezivanje, što znači da se metode mogu pozivati u toku izvršavanja programa.

Kada se radi pentesting na iOS aplikacijama, važno je razumeti Objective-C jezik kako biste mogli da analizirate izvorni kod i identifikujete potencijalne ranjivosti. Ovaj jezik se često koristi za implementaciju funkcionalnosti kao što su autentifikacija, enkripcija i komunikacija sa serverom.

U nastavku su navedene neke od osnovnih karakteristika Objective-C jezika:

- Objektno orijentisana paradigma: Objective-C je baziran na objektno orijentisanoj paradigmi, što znači da se programiranje vrši pomoću objekata koji imaju svoje osobine i metode.
- Nasleđivanje: Objective-C podržava nasleđivanje, što omogućava programerima da kreiraju hijerarhiju klasa i dele funkcionalnosti između njih.
- Dinamičko povezivanje: Objective-C podržava dinamičko povezivanje, što znači da se metode mogu pozivati u toku izvršavanja programa.
- Poruke: Umesto poziva funkcija, u Objective-C jeziku se koriste poruke za komunikaciju između objekata.
- ARC (Automatsko upravljanje memorijom): Objective-C podržava ARC, što znači da se automatski upravlja memorijom i programerima nije potrebno ručno oslobađati memoriju.

Razumevanje Objective-C jezika je ključno za uspešno pentesting iOS aplikacija. Proučavanje sintakse, koncepta i funkcionalnosti ovog jezika će vam pomoći da identifikujete ranjivosti i izvršite sigurnosne testove na iOS aplikacijama.
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Ovo postavlja pozadinsku sliku na `overlayImage.png` kada se aplikacija prebaci u pozadinu. To sprečava curenje osetljivih podataka jer će `overlayImage.png` uvek prekriti trenutni prikaz.

### Keychain

Za pristupanje i upravljanje iOS keychain-om, dostupni su alati poput [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper), koji su pogodni za jailbroken uređaje. Dodatno, [**Objection**](https://github.com/sensepost/objection) pruža komandu `ios keychain dump` za slične svrhe.

#### **Čuvanje akreditiva**

Klasa **NSURLCredential** je idealna za čuvanje osetljivih informacija direktno u keychain-u, zaobilazeći potrebu za NSUserDefaults ili drugim omotačima. Za čuvanje akreditiva nakon prijave, koristi se sledeći Swift kod:
```swift
NSURLCredential *credential;
credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Da biste izvukli ove sačuvane akreditive, koristi se Objection-ova komanda `ios nsurlcredentialstorage dump`.

## **Prilagođene tastature i keš tastature**

Od iOS 8.0 nadalje, korisnici mogu instalirati prilagođene tastaturne ekstenzije, koje se mogu upravljati pod **Podešavanja > Opšte > Tastatura > Tastature**. Iako ove tastature nude proširene funkcionalnosti, predstavljaju rizik od beleženja unosa tastature i slanja podataka na eksterne servere, iako korisnici dobijaju obaveštenje o tastaturama koje zahtevaju pristup mreži. Aplikacije mogu, i trebaju, ograničiti upotrebu prilagođenih tastatura za unos osetljivih informacija.

**Preporuke za bezbednost:**
- Preporučuje se onemogućavanje tastatura trećih strana radi poboljšane bezbednosti.
- Treba biti svestan funkcija automatske ispravke i automatskih predloga podrazumevane iOS tastature, koje mogu čuvati osetljive informacije u keš fajlovima koji se nalaze u `Library/Keyboard/{locale}-dynamic-text.dat` ili `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Ovi keš fajlovi trebaju redovno biti proveravani radi osetljivih podataka. Preporučuje se resetovanje rečnika tastature putem **Podešavanja > Opšte > Resetuj > Resetuj rečnik tastature** kako bi se očistili keširani podaci.
- Presretanje mrežnog saobraćaja može otkriti da li prilagođena tastatura prenosi unose tastature na daljinu.

### **Sprječavanje keširanja polja za tekst**

Protokol [UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) nudi osobine za upravljanje automatskom ispravkom i unosom sigurnog teksta, što je ključno za sprečavanje keširanja osetljivih informacija. Na primer, onemogućavanje automatske ispravke i omogućavanje unosa sigurnog teksta može se postići sa:
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
Dodatno, programeri bi trebali osigurati da tekstualna polja, posebno ona za unos osetljivih informacija poput lozinki i PIN-ova, onemoguće keširanje postavljanjem `autocorrectionType` na `UITextAutocorrectionTypeNo` i `secureTextEntry` na `YES`.
```objectivec
UITextField *textField = [[UITextField alloc] initWithFrame:frame];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Zapisi**

Otklanjanje grešaka u kodu često uključuje korišćenje **zapisa**. Postoji rizik jer **zapisi mogu sadržavati osetljive informacije**. Ranije, u iOS 6 i starijim verzijama, zapisi su bili dostupni svim aplikacijama, što je predstavljalo rizik od curenja osetljivih podataka. **Sada, aplikacije su ograničene da pristupaju samo svojim zapisima**.

Uprkos ovim ograničenjima, **napadač sa fizičkim pristupom** otključanom uređaju i dalje može iskoristiti ovo povezivanjem uređaja sa računarom i **čitanjem zapisa**. Važno je napomenuti da zapisi ostaju na disku čak i nakon deinstalacije aplikacije.

Da bi se smanjili rizici, preporučuje se **temeljno interagovati sa aplikacijom**, istražujući sve njene funkcionalnosti i unose kako bi se osiguralo da se slučajno ne beleže osetljive informacije.

Pregledanjem izvornog koda aplikacije u potrazi za potencijalnim curenjima, potrebno je tražiti kako **unapred definisane** tako i **prilagođene izjave za beleženje** koristeći ključne reči kao što su `NSLog`, `NSAssert`, `NSCAssert`, `fprintf` za ugrađene funkcije, kao i bilo kakve pomena `Logging` ili `Logfile` za prilagođene implementacije.

### **Pratiti sistemske zapise**

Aplikacije beleže različite informacije koje mogu biti osetljive. Za praćenje ovih zapisa, koriste se alati i komande poput:
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To capture the device logs
```
su korisniku. Dodatno, **Xcode** pruža način za prikupljanje konzolnih zapisa:

1. Otvorite Xcode.
2. Povežite iOS uređaj.
3. Idite na **Window** -> **Devices and Simulators**.
4. Odaberite svoj uređaj.
5. Pokrenite problem koji istražujete.
6. Koristite dugme **Open Console** da biste pregledali zapise u novom prozoru.

Za naprednije zapisivanje, povezivanje sa ljuskom uređaja i korišćenje **socat**-a može omogućiti praćenje zapisa u realnom vremenu:
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock
```
Prateći naredbe za posmatranje aktivnosti dnevnika, koje mogu biti neprocenjive za dijagnostikovanje problema ili identifikaciju potencijalnog curenja podataka u dnevnicima.


***

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da lako izgradite i **automatizujete tokove rada** koji se pokreću najnaprednijim alatima zajednice na svetu.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Rezervne kopije

**Automatske funkcije rezervnog kopiranja** su integrisane u iOS, olakšavajući kreiranje kopija podataka uređaja putem iTunes-a (do macOS Catalina), Finder-a (od macOS Catalina nadalje) ili iCloud-a. Ove rezervne kopije obuhvataju skoro sve podatke uređaja, izuzev visoko osetljivih elemenata kao što su detalji Apple Pay-a i konfiguracije Touch ID-a.

### Bezbednosni rizici

Uključivanje **instaliranih aplikacija i njihovih podataka** u rezervne kopije postavlja pitanje potencijalnog **curenja podataka** i rizika da **izmene rezervne kopije mogu promeniti funkcionalnost aplikacija**. Preporučuje se da se **ne čuvaju osetljive informacije u tekstualnom formatu** unutar direktorijuma aplikacije ili njenih poddirektorijuma kako bi se umanjili ovi rizici.

### Isključivanje fajlova iz rezervnih kopija

Podrazumevano se vrši rezervno kopiranje fajlova u `Documents/` i `Library/Application Support/`. Razvojni programeri mogu isključiti određene fajlove ili direktorijume iz rezervnih kopija koristeći `NSURL setResourceValue:forKey:error:` sa `NSURLIsExcludedFromBackupKey`. Ova praksa je ključna za zaštitu osetljivih podataka od uključivanja u rezervne kopije.

### Testiranje ranjivosti

Da biste procenili sigurnost rezervne kopije aplikacije, prvo **kreirajte rezervnu kopiju** koristeći Finder, a zatim je pronađite koristeći uputstva iz [zvanične dokumentacije Apple-a](https://support.apple.com/en-us/HT204215). Analizirajte rezervnu kopiju u potrazi za osetljivim podacima ili konfiguracijama koje bi mogle biti promenjene kako bi se uticalo na ponašanje aplikacije.

Osetljive informacije mogu se pronaći korišćenjem alata komandne linije ili aplikacija poput [iMazing](https://imazing.com). Za šifrovane rezervne kopije, prisustvo šifrovanja se može potvrditi proverom ključa "IsEncrypted" u fajlu "Manifest.plist" u korenu rezervne kopije.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
Za rukovanje sa enkriptovanim rezervnim kopijama, Python skripte dostupne u [DinoSec-ovom GitHub repozitorijumu](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), poput **backup_tool.py** i **backup_passwd.py**, mogu biti korisne, iako potencijalno zahtevaju prilagođavanje za kompatibilnost sa najnovijim verzijama iTunes/Finder-a. [**iOSbackup** alat](https://pypi.org/project/iOSbackup/) je još jedna opcija za pristupanje datotekama unutar zaštićenih rezervnih kopija.

### Modifikacija ponašanja aplikacije

Primer izmene ponašanja aplikacije putem modifikacija rezervne kopije je prikazan u [Bither bitcoin novčanik aplikaciji](https://github.com/bither/bither-ios), gde se PIN za zaključavanje korisničkog interfejsa čuva unutar `net.bither.plist` pod ključem **pin_code**. Uklanjanje ovog ključa iz plist datoteke i vraćanje rezervne kopije uklanja zahtev za PIN-om, pružajući neograničen pristup.

## Rezime testiranja memorije za osetljive podatke

Kada se bavite osetljivim informacijama koje se čuvaju u memoriji aplikacije, ključno je ograničiti vreme izlaganja ovih podataka. Postoje dva osnovna pristupa istraživanju sadržaja memorije: **kreiranje memorijskog ispisa** i **analiza memorije u realnom vremenu**. Oba metoda imaju svoje izazove, uključujući mogućnost propuštanja ključnih podataka tokom procesa ispisa ili analize.

## **Dobijanje i analiza memorijskog ispisa**

Za uređaje sa i bez džailbrejka, alati poput [objection](https://github.com/sensepost/objection) i [Fridump](https://github.com/Nightbringer21/fridump) omogućavaju ispisivanje memorije procesa aplikacije. Nakon što se ispise, za analizu ovih podataka su potrebni razni alati, u zavisnosti od prirode informacija koje tražite.

Za izvlačenje nizova iz memorijskog ispisa, mogu se koristiti komande poput `strings` ili `rabin2 -zz`:
```bash
# Extracting strings using strings command
$ strings memory > strings.txt

# Extracting strings using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Za detaljniju analizu, uključujući pretragu određenih vrsta podataka ili uzoraka, **radare2** nudi široke mogućnosti pretrage:
```bash
$ r2 <name_of_your_dump_file>
[0x00000000]> /?
...
```
## **Analiza memorije u toku izvršavanja**

**r2frida** pruža moćnu alternativu za inspekciju memorije aplikacije u realnom vremenu, bez potrebe za memorijalnim iskopom. Ovaj alat omogućava izvršavanje pretraga direktno nad memorijom pokrenute aplikacije:
```bash
$ r2 frida://usb//<name_of_your_app>
[0x00000000]> /\ <search_command>
```
## Slomljena kriptografija

### Slabi procesi upravljanja ključevima

Neki programeri čuvaju osetljive podatke u lokalnom skladištu i šifruju ih ključem koji je unapred definisan/predvidljiv u kodu. Ovo ne bi trebalo da se radi jer neko ko vrši reverzno inženjering može da izvuče poverljive informacije.

### Korišćenje nesigurnih i/ili zastarelih algoritama

Programeri ne bi trebalo da koriste **zastarele algoritme** za izvršavanje **provera** autorizacije, **skladištenje** ili **slanje** podataka. Neki od ovih algoritama su: RC4, MD4, MD5, SHA1... Ako se koriste **heševi** za skladištenje lozinki, na primer, treba koristiti heševe koji su otporni na napade brute-force uz upotrebu soli.

### Provera

Glavne provere koje treba izvršiti su da li možete pronaći **unapred definisane** lozinke/tajne u kodu, ili da li su one **predvidljive**, i da li kod koristi neku vrstu **slabe** **kriptografije** algoritme.

Interesantno je znati da možete **automatski pratiti** neke **kripto** **biblioteke** koristeći **objection** sa:
```swift
ios monitor crypt
```
Za **više informacija** o iOS kriptografskim API-ima i bibliotekama posetite [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Lokalna autentifikacija

**Lokalna autentifikacija** igra ključnu ulogu, posebno kada je u pitanju zaštita pristupa na udaljenom krajnjem tačkom putem kriptografskih metoda. Suština ovde je da bez odgovarajuće implementacije, mehanizmi lokalne autentifikacije mogu biti zaobiđeni.

Apple-ov **[Local Authentication framework](https://developer.apple.com/documentation/localauthentication)** i **[keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)** pružaju snažne API-je za razvojne programere kako bi olakšali dijaloge autentifikacije korisnika i sigurno rukovali tajnim podacima, redom. Secure Enclave obezbeđuje sigurnost otiska prsta za Touch ID, dok se Face ID oslanja na prepoznavanje lica bez ugrožavanja biometrijskih podataka.

Da bi integrisali Touch ID/Face ID, programeri imaju dva izbora API-ja:
- **`LocalAuthentication.framework`** za autentifikaciju korisnika na visokom nivou bez pristupa biometrijskim podacima.
- **`Security.framework`** za pristup uslugama keša na nižem nivou, obezbeđujući tajne podatke biometrijskom autentifikacijom. Razni [open-source omotači](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id) olakšavaju pristup kešu.

{% hint style="danger" %}
Međutim, kako `LocalAuthentication.framework` tako i `Security.framework` predstavljaju ranjivosti, jer uglavnom vraćaju boolean vrednosti bez prenosa podataka za autentifikacione procese, čime su podložni zaobilaženju (videti [Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)).
{% endhint %}

### Implementacija lokalne autentifikacije

Da bi korisnike upitali za autentifikaciju, programeri treba da koriste metodu **`evaluatePolicy`** unutar klase **`LAContext`**, birajući između:
- **`deviceOwnerAuthentication`**: Upita za Touch ID ili šifru uređaja, neuspevajući ako nijedno nije omogućeno.
- **`deviceOwnerAuthenticationWithBiometrics`**: Isključivo upita za Touch ID.

Uspešna autentifikacija se označava boolean vrednošću koju vraća **`evaluatePolicy`**, ukazujući na potencijalnu sigurnosnu manu.

### Lokalna autentifikacija korišćenjem keša

Implementacija **lokane autentifikacije** u iOS aplikacijama uključuje korišćenje **keš API-ja** za sigurno čuvanje tajnih podataka kao što su autentifikacioni tokeni. Ovaj proces osigurava da podaci mogu biti pristupljeni samo od strane korisnika, koristeći njihovu šifru uređaja ili biometrijsku autentifikaciju poput Touch ID-a.

Keš nudi mogućnost postavljanja stavki sa atributom `SecAccessControl`, koji ograničava pristup stavci sve dok korisnik uspešno autentifikuje putem Touch ID-a ili šifre uređaja. Ova funkcija je ključna za poboljšanje sigurnosti.

U nastavku su prikazani primeri koda u Swift-u i Objective-C-u koji demonstriraju kako sačuvati i dobiti string iz keša, koristeći ove sigurnosne funkcije. Primeri posebno pokazuju kako postaviti kontrolu pristupa koja zahteva autentifikaciju putem Touch ID-a i osigurava da su podaci dostupni samo na uređaju na kojem su postavljeni, pod uslovom da je konfigurisana šifra uređaja.

{% tabs %}
{% tab title="Swift" %}
```swift
// From https://github.com/mufambisi/owasp-mstg/blob/master/Document/0x06f-Testing-Local-Authentication.md

// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

Sada možemo zatražiti sačuvanu stavku iz ključnog lanca. Usluge ključnog lanca će prikazati dijalog za autentifikaciju korisniku i vratiti podatke ili nil u zavisnosti od toga da li je pružen odgovarajući otisak prsta ili ne.
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### Otkrivanje

Korišćenje okvira u aplikaciji takođe može biti otkriveno analizom liste deljenih dinamičkih biblioteka aplikacije. To se može uraditi korišćenjem `otool` alata:
```bash
$ otool -L <AppName>.app/<AppName>
```
Ako se koristi `LocalAuthentication.framework` u aplikaciji, izlaz će sadržavati oba sledeća reda (zapamtite da `LocalAuthentication.framework` koristi `Security.framework` ispod haube):
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
Ako se koristi `Security.framework`, prikazuje se samo drugi.

### Zaobilaženje okvira za lokalnu autentifikaciju

#### **Objection**

Kroz **Objection Biometrics Bypass**, koji se nalazi na [ovoj GitHub stranici](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass), dostupna je tehnika za prevazilaženje mehanizma **LocalAuthentication**. Srž ovog pristupa je korišćenje **Fride** za manipulaciju funkcijom `evaluatePolicy`, osiguravajući da uvek daje rezultat `True`, bez obzira na stvarni uspeh autentifikacije. Ovo je posebno korisno za zaobilaženje nedostataka biometrijskih autentifikacionih procesa.

Za aktiviranje ovog zaobilaženja koristi se sledeća komanda:
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Ova komanda pokreće sekvencu u kojoj Objection registruje zadatak koji efektivno menja rezultat provere `evaluatePolicy` na `True`.

#### Frida

Primer korišćenja **`evaluatePolicy`** iz aplikacije [DVIA-v2](https://github.com/prateek147/DVIA-v2):
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Da bi se postigao **bypass** lokalne autentifikacije, napisan je Frida skript. Ovaj skript cilja na proveru **evaluatePolicy**, presrećući njegov povratni poziv kako bi se osiguralo da uvek vraća **success=1**. Menjanjem ponašanja povratnog poziva, provera autentifikacije se efektivno zaobilazi.

Skript ispod se ubacuje kako bi se izmenio rezultat metode **evaluatePolicy**. Menja rezultat povratnog poziva kako bi uvek pokazivao uspeh.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```
Da biste ubacili Frida skriptu i zaobišli biometrijsku autentifikaciju, koristi se sledeća komanda:
```bash
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Otkrivanje osetljive funkcionalnosti putem IPC-a

### Prilagođeni URI rukovaoci / Duboki linkovi / Prilagođene šeme

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Univerzalni linkovi

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Deljenje preko UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### App ekstenzije

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### Serijalizacija i enkodiranje

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Mrežna komunikacija

Važno je proveriti da se ne odvija nikakva komunikacija **bez enkripcije** i da aplikacija pravilno **proverava TLS sertifikat** servera.\
Da biste proverili ove vrste problema, možete koristiti proxy kao što je **Burp**:

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### Provera imena hosta

Često se javlja problem prilikom provere TLS sertifikata, gde se proverava da li je sertifikat potpisan od strane **pouzdane** **CA**, ali se **ne proverava** da li je **ime hosta** na sertifikatu ime hosta koje se pristupa.\
Da biste proverili ovaj problem koristeći Burp, nakon što ste poverili Burp CA na iPhone-u, možete **kreirati novi sertifikat sa Burp-om za drugi naziv hosta** i koristiti ga. Ako aplikacija i dalje radi, onda je nešto ranjivo.

### Prikivanje sertifikata

Ako aplikacija pravilno koristi SSL Prikivanje, tada će aplikacija raditi samo ako je sertifikat onaj koji se očekuje. Prilikom testiranja aplikacije, **ovo može biti problem jer će Burp koristiti svoj sertifikat.**\
Da biste zaobišli ovu zaštitu na jailbroken uređaju, možete instalirati aplikaciju [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ili instalirati [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Takođe možete koristiti **objection's** `ios sslpinning disable`

## Razno

* U **`/System/Library`** možete pronaći okvire instalirane na telefonu koje koriste sistemski programi
* Aplikacije koje je korisnik instalirao iz App Store-a nalaze se unutar **`/User/Applications`**
* A **`/User/Library`** sadrži podatke koje je korisnik sačuvao u aplikacijama na nivou korisnika
* Možete pristupiti **`/User/Library/Notes/notes.sqlite`** da biste pročitali beleške sačuvane u aplikaciji.
* Unutar fascikle instalirane aplikacije (**`/User/Applications/<APP ID>/`**) možete pronaći neke zanimljive datoteke:
* **`iTunesArtwork`**: Ikona koju koristi aplikacija
* **`iTunesMetadata.plist`**: Informacije o aplikaciji koje se koriste u App Store-u
* **`/Library/*`**: Sadrži postavke i keš. U **`/Library/Cache/Snapshots/*`** možete pronaći snimak koji je napravljen aplikaciji pre nego što je poslata u pozadinu.

### Hot Patching/Enforced Updateing

Razvojni programeri mogu daljinski **popraviti sve instalacije svoje aplikacije odmah** bez potrebe da ponovo podnesu aplikaciju App Store-u i čekaju odobrenje.\
U tu svrhu se obično koristi [**JSPatch**](https://github.com/bang590/JSPatch)**.** Ali postoje i druge opcije kao što su [Siren](https://github.com/ArtSabintsev/Siren) i [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**Ovo je opasni mehanizam koji može biti zloupotrebljen od strane zlonamernih SDK-ova, stoga se preporučuje provera koje metode se koriste za automatsko ažuriranje (ako ih ima) i testiranje.** Možete pokušati preuzeti prethodnu verziju aplikacije u tu svrhu.

### Treće strane

Značajan izazov sa **SDK-ovima trećih strana** je **nedostatak granularne kontrole** nad njihovim funkcionalnostima. Razvojni programeri se suočavaju sa izborom: ili integrišu SDK i prihvataju sve njegove funkcije, uključujući potencijalne sigurnosne ranjivosti i probleme privatnosti, ili potpuno odustaju od njegovih prednosti. Često, razvojni programeri nisu u mogućnosti da sami isprave ranjivosti unutar ovih SDK-ova. Osim toga, kako SDK-ovi stiču poverenje u zajednici, neki od njih mogu sadržati zlonamerni softver.

Usluge koje pružaju SDK-ovi trećih strana mogu uključivati praćenje ponašanja korisnika, prikazivanje reklama ili poboljšanje korisničkog iskustva. Međutim, to predstavlja rizik jer razvojni programeri možda nisu potpuno svesni koda koji se izvršava u ovim bibliotekama, što može dovesti do potencijalnih problema sa privatnošću i sigurnošću. Važno je ograničiti informacije koje se dele sa uslugama trećih strana samo na ono što je neophodno i obezbediti da nijedan osetljivi podatak nije izložen.

Implementacija usluga trećih strana obično dolazi u dva oblika: samostalna biblioteka ili potpuni SDK. Da bi se zaštitila privatnost korisnika, svi podaci koji se dele sa ovim uslugama trebaju biti **anonimizovani** kako bi se sprečilo otkrivanje lično prepoznatljivih informacija (PII).

Da biste identifikovali biblioteke koje aplikacija koristi, možete koristiti komandu **`otool`**. Ovaj alat treba pokrenuti protiv aplikacije i svake deljene biblioteke koju koristi kako biste otkrili dodatne biblioteke.
```bash
otool -L <application_path>
```
## **Reference & Dodatni resursi**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0057/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0058/)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0059/)
* [https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage](https://mas.owasp.org/MASTG/iOS/0x06d-Testing-Data-Storage)
* [https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way](https://coderwall.com/p/kjb3lw/storing-password-in-keychain-the-smart-way)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0055/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0053)
* [https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/](https://mas.owasp.org/MASTG/techniques/ios/MASTG-TECH-0060/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0058)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0060)
* [https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/](https://mas.owasp.org/MASTG/Android/0x05f-Testing-Local-Authentication/)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064](https://mas.owasp.org/MASTG/tests/ios/MASVS-AUTH/MASTG-TEST-0064)
* [https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc](https://medium.com/securing/bypassing-your-apps-biometric-checks-on-ios-c2555c81a2dc)
* [https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054](https://mas.owasp.org/MASTG/tests/ios/MASVS-STORAGE/MASTG-TEST-0054)
* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS besplatni kurs ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-C verzija [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swift verzija
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Koristite [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) da biste lako izgradili i **automatizovali radne tokove** pokretane najnaprednijim alatima zajednice.\
Dobijte pristup danas:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
