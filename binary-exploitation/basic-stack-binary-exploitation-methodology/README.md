# 基本二进制利用方法论

{% hint style="success" %}
学习并练习 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习并练习 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}

## ELF 基本信息

在开始利用任何东西之前，了解 **ELF 二进制文件** 的结构的一部分是很有趣的：

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## 利用工具

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## 栈溢出方法论

有这么多技术，最好有一个方案，确定何时使用每种技术。请注意，相同的保护措施会影响不同的技术。您可以在每个保护部分找到绕过保护的方法，但在这个方法论中没有提到。

## 控制流

有不同的方法可以控制程序的流程：

* [**栈溢出**](../stack-overflow/) 覆盖栈上的返回指针或 EBP -> ESP -> EIP。
* 可能需要滥用 [**整数溢出**](../integer-overflow.md) 来引发溢出
* 或通过 **任意写入 + 写入何处执行**。
* [**格式化字符串**](../format-strings/)**：**滥用 `printf` 在任意地址写入任意内容。
* [**数组索引**](../array-indexing.md)：滥用设计不良的索引以控制某些数组并进行任意写入。
* 可能需要滥用 [**整数溢出**](../integer-overflow.md) 来引发溢出
* **bof to WWW via ROP**：滥用缓冲区溢出构建 ROP 并能够获得 WWW。

您可以在以下位置找到 **写入何处执行** 技术：

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## 永久循环

需要考虑的一点是通常**仅利用漏洞一次可能不足以执行成功的利用**，特别是需要绕过某些保护措施。因此，有趣的是讨论一些选项，**使单个漏洞在二进制文件的同一执行中可多次利用**：

* 在 **ROP** 链中写入 **`main` 函数的地址** 或漏洞发生的地址。
* 控制适当的 ROP 链，您可能能够执行该链中的所有操作
* 在 **GOT 中的 `exit` 地址**（或二进制文件在结束之前使用的任何其他函数）中写入返回到漏洞的地址
* 如 [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop) 中所述，这里存储 2 个函数，一个用于再次调用漏洞，另一个用于调用 **`__libc_csu_fini`**，后者将再次调用 `.fini_array` 中的函数。

## 利用目标

### 目标：调用现有函数

* [**ret2win**](./#ret2win)：代码中有一个需要调用的函数（可能带有一些特定参数）以获取标志。
* 在没有 [**PIE**](../common-binary-protections-and-bypasses/pie/) 和 [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) 的常规 bof 中，只需在栈中存储的返回地址中写入地址。
* 在带有 [**PIE**](../common-binary-protections-and-bypasses/pie/) 的 bof 中，您将需要绕过它
* 在带有 [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) 的 bof 中，您将需要绕过它
* 如果需要设置多个参数以正确调用 **ret2win** 函数，可以使用：
* 如果有足够的 gadget，可以使用 [**ROP**](./#rop-and-ret2...-techniques) 链来准备所有参数
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)（如果可以调用此系统调用）来控制许多寄存器
* 来自 [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) 和 [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) 的 gadget 来控制多个寄存器
* 通过 [**Write What Where**](../arbitrary-write-2-exec/)，您可以滥用其他漏洞（非 bof）来调用 **`win`** 函数。
* [**指针重定向**](../stack-overflow/pointer-redirecting.md)：如果栈包含将要调用的函数的指针，或者包含将要被有趣函数（system 或 printf）使用的字符串的指针，可以覆盖该地址。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) 或 [**PIE**](../common-binary-protections-and-bypasses/pie/) 可能会影响地址。
* [**未初始化变量**](../stack-overflow/uninitialized-variables.md)：你永远不知道。

### 目标：RCE

#### 通过 shellcode，如果 nx 禁用或将 shellcode 与 ROP 混合：

* [**(Stack) Shellcode**](./#stack-shellcode)：这对于在栈中存储 shellcode 并在覆盖返回指针之前或之后跳转到它以执行它非常有用：
* **在任何情况下，如果有** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**，在常规 bof 中，您将需要绕过（泄漏）它**
* **没有** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **和** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md)，可以跳转到栈的地址，因为它永远不会改变
* **有** [**ASLR**](../common-binary-protections-and-bypasses/aslr/)，您将需要使用诸如 [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) 的技术来跳转到它
* **有** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md)，您将需要使用一些 [**ROP**](../rop-return-oriented-programing/) **来调用 `memprotect`** 并使某些页面 `rwx`，然后 **在那里存储 shellcode**（例如调用 read）然后跳转到那里。
* 这将混合 shellcode 与 ROP 链。
#### 通过系统调用

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): 用于调用 `execve` 以运行任意命令。您需要能够找到**调用特定系统调用的参数的gadgets**。
* 如果启用了[**ASLR**](../common-binary-protections-and-bypasses/aslr/)或[**PIE**](../common-binary-protections-and-bypasses/pie/)，您需要打败它们**以使用二进制文件或库中的ROP gadgets**。
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)可用于准备**ret2execve**
* 来自[**ret2csu**](../rop-return-oriented-programing/ret2csu.md)和[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)的gadgets可用于控制多个寄存器

#### 通过libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): 用于调用库中的函数（通常来自**`libc`**）如**`system`**并带有一些准备好的参数（例如`'/bin/sh'`）。您需要二进制文件**加载包含您想要调用的函数的库**（通常是libc）。
* 如果**静态编译且没有**[**PIE**](../common-binary-protections-and-bypasses/pie/)，`system`和`/bin/sh`的**地址**不会改变，因此可以静态使用它们。
* **没有**[**ASLR**](../common-binary-protections-and-bypasses/aslr/) **并且知道加载的libc版本**，`system`和`/bin/sh`的**地址**不会改变，因此可以静态使用它们。
* 具有[**ASLR**](../common-binary-protections-and-bypasses/aslr/) **但没有**[**PIE**](../common-binary-protections-and-bypasses/pie/)**，知道libc并且二进制文件使用`system`**函数时，可以**`ret`到GOT中system的地址**，参数为`'/bin/sh'`的地址（您需要弄清楚这一点）。
* 具有[ASLR](../common-binary-protections-and-bypasses/aslr/)但没有[PIE](../common-binary-protections-and-bypasses/pie/)，知道libc并且**二进制文件不使用`system`**：
* 使用[**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)解析`system`的地址并调用它&#x20;
* **绕过**[**ASLR**](../common-binary-protections-and-bypasses/aslr/)并计算内存中`system`和`'/bin/sh'`的地址。
* 具有[**ASLR**](../common-binary-protections-and-bypasses/aslr/) **和** [**PIE**](../common-binary-protections-and-bypasses/pie/) **但不知道libc**：您需要：
* 绕过[**PIE**](../common-binary-protections-and-bypasses/pie/)
* 找到使用的**`libc`版本**（泄漏几个函数地址）
* 检查**具有ASLR的先前情况**以继续。

#### 通过EBP/RBP

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): 控制ESP以通过堆栈中存储的EBP控制RET。
* 用于**off-by-one**堆栈溢出
* 作为控制EIP的替代方式，滥用EIP在内存中构造有效负载，然后通过EBP跳转到它

#### 杂项

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): 如果堆栈包含将要调用的函数的指针或将被有趣函数（如system或printf）使用的字符串的指针，可以覆盖该地址。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)或[**PIE**](../common-binary-protections-and-bypasses/pie/)可能会影响地址。
* [**未初始化的变量**](../stack-overflow/uninitialized-variables.md): 永远不知道

{% hint style="success" %}
学习并练习AWS黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks培训AWS红队专家（ARTE）**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习并练习GCP黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks培训GCP红队专家（GRTE）**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持HackTricks</summary>

* 查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享黑客技巧。

</details>
{% endhint %}
