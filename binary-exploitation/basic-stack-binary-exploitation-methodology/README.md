# 二进制基础利用方法论

<details>

<summary><strong>从零开始学习AWS黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFT](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## ELF基础信息

在开始利用任何东西之前，了解**ELF二进制文件**的结构的一部分是很有趣的：

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## 利用工具

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## 栈溢出方法论

有这么多技术，有一个方案可以确定每种技术何时有用是很好的。请注意，相同的保护措施会影响不同的技术。您可以在每个保护部分找到绕过保护措施的方法，但在这个方法论中没有。

## 控制流程

有不同的方法可以控制程序的流程：

* [**栈溢出**](../stack-overflow/) 覆盖栈上的返回指针或 EBP -> ESP -> EIP。
* 可能需要滥用[**整数溢出**](../integer-overflow.md) 来引发溢出
* 或通过**任意写入 + 写入何处执行**来实现
* [**格式化字符串**](../format-strings/)**：**滥用 `printf` 来在任意地址写入任意内容。
* [**数组索引**](../array-indexing.md)：滥用设计不良的索引以控制某些数组并获得任意写入。
* 可能需要滥用[**整数溢出**](../integer-overflow.md) 来引发溢出
* **bof to WWW via ROP**：滥用缓冲区溢出来构建ROP，从而能够获得WWW。

您可以在以下位置找到**写入何处执行**技术：

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## 永久循环

需要考虑的一点是通常**仅利用一次漏洞可能不足以执行成功的利用**，特别是需要绕过一些保护措施。因此，有趣的是讨论一些选项，**使单个漏洞在二进制文件的同一执行中可利用多次**：

* 在**ROP**链中写入**`main`函数的地址**或漏洞发生的地址。
* 通过控制适当的ROP链，您可能能够执行该链中的所有操作
* 在**GOT中写入`exit`地址**（或二进制文件在结束之前使用的任何其他函数的地址），以返回到漏洞处
* 如[**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)中所述，将2个函数存储在这里，一个用于再次调用漏洞，另一个用于调用**`__libc_csu_fini`**，后者将再次调用`.fini_array`中的函数。

## 利用目标

### 目标：调用现有函数

* [**ret2win**](./#ret2win)：代码中有一个需要调用的函数（可能带有一些特定参数）以获取标志。
* 在**没有** [**PIE**](../common-binary-protections-and-bypasses/pie/) **和** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) **的常规bof中，您只需要在栈中存储的返回地址中写入地址。
* 在带有[**PIE**](../common-binary-protections-and-bypasses/pie/)的bof中，您将需要绕过它
* 在带有[**canary**](../common-binary-protections-and-bypasses/stack-canaries/)的bof中，您将需要绕过它
* 如果需要设置多个参数以正确调用**ret2win**函数，您可以使用：
* 如果有足够的gadgets，可以使用[**ROP**](./#rop-and-ret2...-techniques)链来准备所有参数
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)（如果可以调用此系统调用）来控制许多寄存器
* 来自[**ret2csu**](../rop-return-oriented-programing/ret2csu.md)和[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)的gadgets来控制多个寄存器
* 通过[**写入何处执行**](../arbitrary-write-2-exec/)，您可以滥用其他漏洞（而非bof）来调用**`win`**函数。
* [**指针重定向**](../stack-overflow/pointer-redirecting.md)：如果栈包含指向将要被调用的函数或将被有趣函数（如system或printf）使用的字符串的指针，可以覆盖该地址。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) 或 [**PIE**](../common-binary-protections-and-bypasses/pie/) 可能会影响地址。
* [**未初始化变量**](../stack-overflow/uninitialized-variables.md)：您永远不知道。

### 目标：RCE

#### 通过shellcode，如果nx被禁用或将shellcode与ROP混合：

* [**(Stack) Shellcode**](./#stack-shellcode)：这对于在覆盖返回指针之前或之后在栈中存储shellcode，然后**跳转到它**以执行它是有用的：
* **在任何情况下，如果有** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)**，在常规bof中您将需要绕过（泄漏）它
* **没有** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **和** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md)，可以跳转到栈的地址，因为它永远不会改变
* **有** [**ASLR**](../common-binary-protections-and-bypasses/aslr/)，您将需要使用诸如[**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md)之类的技术来跳转到它
* **有** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md)，您将需要使用一些[**ROP**](../rop-return-oriented-programing/) **来调用`memprotect`**，使某些页面`rwx`，然后**在那里存储shellcode**（例如调用read）然后跳转到那里。
* 这将混合shellcode与ROP链。
#### 通过系统调用

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): 用于调用 `execve` 以运行任意命令。您需要能够找到**调用特定系统调用的参数的gadgets**。
* 如果启用了[**ASLR**](../common-binary-protections-and-bypasses/aslr/)或[**PIE**](../common-binary-protections-and-bypasses/pie/)，您需要打败它们**以使用二进制文件或库中的ROP gadgets**。
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming/)可用于准备**ret2execve**
* 来自[**ret2csu**](../rop-return-oriented-programing/ret2csu.md)和[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)的gadgets可用于控制多个寄存器

#### 通过libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): 用于调用库中的函数（通常来自**`libc`**）如**`system`**并带有一些准备好的参数（例如`'/bin/sh'`）。您需要二进制文件**加载包含您想要调用的函数的库**（通常是libc）。
* 如果**静态编译且没有**[**PIE**](../common-binary-protections-and-bypasses/pie/)，`system`和`/bin/sh`的**地址**不会改变，因此可以静态使用它们。
* **没有**[**ASLR**](../common-binary-protections-and-bypasses/aslr/) **并且知道加载的libc版本**，`system`和`/bin/sh`的**地址**不会改变，因此可以静态使用它们。
* 具有[**ASLR**](../common-binary-protections-and-bypasses/aslr/) **但没有**[**PIE**](../common-binary-protections-and-bypasses/pie/)**，知道libc并且二进制文件使用`system`**函数时，可以**`ret`到GOT中system的地址**并带有`'/bin/sh'`的地址（您需要弄清楚这一点）。
* 具有[ASLR](../common-binary-protections-and-bypasses/aslr/)但没有[PIE](../common-binary-protections-and-bypasses/pie/)，知道libc并且**没有二进制文件使用`system`**：
* 使用[**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)解析`system`的地址并调用它&#x20;
* **绕过**[**ASLR**](../common-binary-protections-and-bypasses/aslr/)并计算内存中`system`和`'/bin/sh'`的地址。
* 具有[**ASLR**](../common-binary-protections-and-bypasses/aslr/) **和** [**PIE**](../common-binary-protections-and-bypasses/pie/) **但不知道libc**：您需要：
* 绕过[**PIE**](../common-binary-protections-and-bypasses/pie/)
* 找到使用的**`libc`版本**（泄漏几个函数地址）
* 检查**具有ASLR的先前情况**以继续。

#### 通过EBP/RBP

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): 控制ESP以通过堆栈中存储的EBP控制RET。
* 用于**off-by-one**堆栈溢出
* 作为控制EIP的替代方式，滥用EIP在内存中构造有效负载，然后通过EBP跳转到它

#### 杂项

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): 如果堆栈包含将要调用的函数的指针或将被有趣函数（如system或printf）使用的字符串的指针，可以覆盖该地址。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)或[**PIE**](../common-binary-protections-and-bypasses/pie/)可能会影响地址。
* [**未初始化的变量**](../stack-overflow/uninitialized-variables.md): 永远不知道

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF版HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**上关注**我们。
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
