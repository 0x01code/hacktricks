# Temel İkili Sömürü Metodolojisi

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>

## ELF Temel Bilgileri

Herhangi bir şeyi sömürmeye başlamadan önce bir **ELF ikilisinin** yapısının bir kısmını anlamak ilginç olabilir:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Sömürü Araçları

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## Yığın Taşması Metodolojisi

Bu kadar teknikle birlikte her teknik ne zaman kullanışlı olacağını belirten bir şemaya sahip olmak iyidir. Aynı korumalar farklı teknikleri etkileyecektir. Korumaları atlatma yollarını her koruma bölümünde bulabilirsiniz ancak bu metodolojide değil.

## Akışı Kontrol Etme

Bir programın akışını kontrol etmenin farklı yolları vardır:

* [**Yığın Taşmaları**](../stack-overflow/): Yığın üzerindeki dönüş işaretçisini veya EBP -> ESP -> EIP'yi üzerine yazarak.
* Taşmayı tetiklemek için bir [**Tamsayı Taşmaları**](../integer-overflow.md) kullanmanız gerekebilir
* Veya **Keyfi Yazma + Ne Nerede Yazma ile Yürütme**
* [**Biçim dizeleri**](../format-strings/)**:** `printf`'i kötüye kullanarak keyfi içeriği keyfi adreslere yazmak.
* [**Dizi İndeksleme**](../array-indexing.md): Kötü tasarlanmış bir dizinlemeyi kötüye kullanarak bazı dizileri kontrol edebilir ve keyfi yazma alabilirsiniz.
* Taşmayı tetiklemek için bir [**Tamsayı Taşmaları**](../integer-overflow.md) kullanmanız gerekebilir
* **bof to WWW via ROP**: Bir tampon taşmasını kötüye kullanarak bir ROP oluşturmak ve bir WWW almak için.

**Ne Nerede Yazma Yürütme** tekniklerini şurada bulabilirsiniz:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Sonsuz Döngüler

Dikkate alınması gereken bir şey genellikle **bir zafiyetin sadece bir kez sömürülmesinin yeterli olmayabileceğidir**, özellikle bazı korumaların atlatılması gerekebilir. Bu nedenle, **aynı yürütmede bir zafiyeti birden fazla kez sömürülebilir hale getirmek için bazı seçenekleri** tartışmak ilginçtir:

* Bir **ROP** zincirine **`main` işlevinin adresini** veya **zafiyetin meydana geldiği adrese** yazın.
* Uygun bir ROP zincirini kontrol ederek o zincirdeki tüm işlemleri gerçekleştirebilirsiniz
* **`exit` adresini GOT'a yazın** (veya bitmeden önce kullanılan başka bir işlevin adresini) **zafiyete geri dönmek için**
* [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)'de açıklandığı gibi, burada 2 işlev saklayın, biri zafiyeti tekrar çağırmak için diğeri `.fini_array` işlevini tekrar çağıracak olan**`__libc_csu_fini`** işlevini çağırmak için.

## Sömürü Hedefleri

### Hedef: Varolan bir işlevi çağırmak

* [**ret2win**](./#ret2win): Çağrılması gereken bir işlev (belki belirli parametrelerle) varsa bayrağı almak için.
* [**PIE**](../common-binary-protections-and-bypasses/pie/) **olmadan** ve [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) ile bir bof'ta sadece yığında depolanan dönüş adresine adresi yazmanız yeterli olacaktır.
* [**PIE**](../common-binary-protections-and-bypasses/pie/) ile bir bof'ta, bunu atlatmanız gerekecektir
* [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) ile bir bof'ta, bunu atlatmanız gerekecektir
* **ret2win** işlevini doğru şekilde çağırmak için birden fazla parametre ayarlamanız gerekiyorsa şunları kullanabilirsiniz:
* **Yeterli sayıda araç** varsa [**ROP**](./#rop-and-ret2...-techniques) **zinciri**
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming.md) (bu sistem çağrısını yapabiliyorsanız) birçok kaydı kontrol etmek için
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) ve [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) 'dan araçlar kullanarak birçok kaydı kontrol etmek için
* Bir [**Ne Nerede Yazma**](../arbitrary-write-2-exec/) kullanarak diğer zafiyetleri (bof olmayanları) kötüye kullanarak **`win`** işlevini çağırabilirsiniz.
* [**İşaretçileri Yönlendirme**](../stack-overflow/pointer-redirecting.md): Yığında, çağrılacak bir işlevin işaretçilerini veya bir işlev tarafından kullanılacak bir dizeye işaretçiler varsa, o adresi üzerine yazabilirsiniz.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) veya [**PIE**](../common-binary-protections-and-bypasses/pie/) adresleri etkileyebilir.
* [**İlklenmemiş değişkenler**](../stack-overflow/uninitialized-variables.md): Asla bilemezsiniz.

### Hedef: Uzaktan Kod Yürütme (RCE)

#### Nx devre dışı bırakılmışsa veya kodu karıştırarak shellcode ile:

* [**(Yığın) Shellcode**](./#stack-shellcode): Bu, bir shellcode'u yığında depolamak ve ardından dönüş işaretçisini üzerine yazarak ona atlamak ve çalıştırmak için kullanışlıdır:
* **Her durumda, bir** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)** varsa**, düzenli bir bof'ta bunu atlatmanız gerekecektir
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ve** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) olmadan yığının adresine atlamak mümkündür çünkü asla değişmeyecektir
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) ile, ona atlamak için [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md) gibi teknikler gerekecektir
* [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) ile, bir [**ROP**](../rop-return-oriented-programing/) kullanarak `memprotect`'i çağırmak ve bazı sayfaları `rwx` yapmak için gerekecektir, ardından oraya shellcode'u depolamak için (örneğin okuma çağırarak) ve ardından oraya atlamak için.
* Bu, shellcode'u bir ROP zinciri ile karıştıracaktır.
#### Syscall Yoluyla

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv.md): Herhangi bir komutu çalıştırmak için `execve`'yi çağırmak için kullanışlıdır. **Belirli bir syscall'ı parametrelerle çağırmak için gerekli olan gadget'ları bulabilmeniz gerekir**.
* Eğer [**ASLR**](../common-binary-protections-and-bypasses/aslr/) veya [**PIE**](../common-binary-protections-and-bypasses/pie/) etkinse, ROP gadget'larını kullanabilmek için bunları **geçmek zorundasınız**.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming.md) **ret2execve'yi hazırlamak için** kullanışlı olabilir.
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) ve [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) ile çeşitli register'ları kontrol etmek için gadget'lar

#### Libc Üzerinden

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Genellikle **`libc`** gibi bir kütüphaneden bir fonksiyonu (genellikle **`system`**) çağırmak için kullanışlıdır ve bazı hazırlanmış argümanlarla (ör. `'/bin/sh'`). Çağırmak istediğiniz fonksiyonun kütüphaneyi yüklemesi gerekir (genellikle libc).
* **Statik olarak derlenmiş ve** [**PIE**](../common-binary-protections-and-bypasses/pie/) **etkin değilse**, `system` ve `/bin/sh`'nin **adresleri değişmeyecek**, bu yüzden bunları statik olarak kullanmak mümkündür.
* **ASLR olmadan** [**ve yüklü libc sürümünü bildiğinizde**, `system` ve `/bin/sh`'nin **adresleri değişmeyecek**, bu yüzden bunları statik olarak kullanmak mümkündür.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ancak** [**PIE**](../common-binary-protections-and-bypasses/pie/) **etkin değilse**, libc'yi bildiğiniz ve binary'nin `system` fonksiyonunu kullandığı durumda, `'/bin/sh'` adresiyle birlikte **GOT'taki system adresine `ret` yapmak** mümkündür (bunu çözmeniz gerekecek).
* [ASLR](../common-binary-protections-and-bypasses/aslr/) **ancak** [PIE](../common-binary-protections-and-bypasses/pie/) **etkin değilse**, libc'yi bildiğiniz ve **binary'nin `system`'i kullanmadığı durumda**:
* `system` adresini çözmek ve çağırmak için [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) kullanın
* **ASLR'yi atlayın** ve `system` ve `'/bin/sh'` adreslerini hafızada hesaplayın.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ve** [**PIE**](../common-binary-protections-and-bypasses/pie/) **etkin ve libc sürümünü bilmiyorsanız**: Şunları yapmanız gerekir:
* [PIE'yi atlayın](../common-binary-protections-and-bypasses/pie/)
* Kullanılan **`libc` sürümünü** bulun (birkaç fonksiyon adresini sızdırın)
* Devam etmek için **ASLR ile önceki senaryoları kontrol edin**.

#### EBP/RBP Üzerinden

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): ESP'yi kontrol ederek stack'te depolanan EBP aracılığıyla RET'i kontrol etmek.
* **Off-by-one** stack overflow'lar için kullanışlıdır
* EIP'yi kontrol etmeyi sonlandırmanın alternatif bir yol olarak kullanışlıdır, EIP'yi hafızada payload'ı oluşturmak için kötüye kullanırken ve ardından EBP aracılığıyla ona atlayarak.

#### Çeşitli

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Stack'te çağrılacak bir fonksiyonun veya ilginç bir fonksiyon tarafından kullanılacak bir dizeye işaret eden işaretçiler varsa, o adresi üzerine yazmak mümkündür.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) veya [**PIE**](../common-binary-protections-and-bypasses/pie/) adresleri etkileyebilir.
* [**İlklenmemiş değişkenler**](../stack-overflow/uninitialized-variables.md): Asla bilemezsiniz
