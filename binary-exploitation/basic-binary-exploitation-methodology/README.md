# ベーシックバイナリエクスプロイテーション手法

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい場合は**、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[Telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**する。
* **ハッキングトリックを共有するには**、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## ELF基本情報

何かをエクスプロイトする前に、**ELFバイナリ**の構造の一部を理解することが興味深いです：

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## エクスプロイトツール

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## スタックオーバーフローメソドロジー

多くのテクニックがあるため、各テクニックがいつ役立つかを把握しておくと良いです。同じ保護が異なるテクニックに影響を与えることに注意してください。保護のセクションごとに保護をバイパスする方法を見つけることができますが、この手法ではありません。

## フローの制御

プログラムのフローを制御する方法はいくつかあります：

* **スタックオーバーフロー**：スタックからリターンポインタまたはEBP -> ESP -> EIPを上書きします。
* [**整数オーバーフロー**](../integer-overflow.md)を悪用してオーバーフローを引き起こす必要がある場合があります
* または**任意の書き込み+書き込む場所への実行**を介して
* **フォーマット文字列**：`printf`を悪用して、任意のアドレスに任意のコンテンツを書き込みます。
* [**配列インデックス**](../array-indexing.md)：設計が不十分なインデックスを悪用して、いくつかの配列を制御し、任意の書き込みを取得できるようにします。
* [**整数オーバーフロー**](../integer-overflow.md)を悪用してオーバーフローを引き起こす必要がある場合があります
* **bof to WWW via ROP**：バッファオーバーフローを悪用してROPを構築し、WWWを取得できるようにします。

**Write What Where to Execution**のテクニックは以下で見つけることができます：

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## 永続的なループ

考慮すべき重要な点は、通常**脆弱性の単一のエクスプロイトだけでは十分でない**ことが多いということです。特にいくつかの保護をバイパスする必要がある場合があります。したがって、**単一の脆弱性を同じバイナリの実行中に複数回エクスプロイト可能にする**いくつかのオプションについて議論することが興味深いです：

* **ROP**チェーンに**`main`関数のアドレス**または**脆弱性が発生しているアドレス**を書き込む
* 適切なROPチェーンを制御することで、そのチェーン内のすべてのアクションを実行できるかもしれません
* **`exit`アドレスをGOT**（またはバイナリが終了する前に使用される他の関数）に書き込んで、**脆弱性に戻るアドレス**を指定します
* [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)で説明されているように、ここに2つの関数を保存し、脆弱性を再度呼び出すための1つと`.fini_array`から再度関数を呼び出す`__libc_csu_fini`を呼び出すためのもう1つを保存します。

## エクスプロイトの目標

### 目標：既存の関数を呼び出す

* [**ret2win**](./#ret2win)：呼び出す必要のあるコード内の関数（おそらく特定のパラメータを使用して）があります。
* **通常のPIE**なしの**bof**で、スタックに格納されたリターンアドレスにアドレスを書き込むだけです
* [**PIE**](../common-binary-protections-and-bypasses/pie/)での**bof**では、バイパスする必要があります
* [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)での**bof**では、バイパスする必要があります
* **ret2win**関数を正しく呼び出すために複数のパラメータを設定する必要がある場合は、次のようにできます：
* **ROP**チェーン（十分なガジェットがある場合）を使用してすべてのパラメータを準備する
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming.md)（このシステムコールを呼び出すことができる場合）を使用して多くのレジスタを制御する
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)および[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)からのガジェットを使用して複数のレジスタを制御する
* [**Write What Where**](../arbitrary-write-2-exec/)を介して、他の脆弱性（bof以外）を悪用して**`win`**関数を呼び出すことができます。
* [**ポインターリダイレクト**](../stack-overflow/pointer-redirecting.md)：スタックに関数へのポインターが含まれている場合、そのアドレスを上書きすることができます。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)がアドレスに影響を与える可能性があります。
* [**未初期化変数**](../stack-overflow/uninitialized-variables.md)：わからないことがあります。

### 目標：RCE

#### nxが無効になっている場合やシェルコードをROPと混在させる場合：

* **（スタック）シェルコード**：これは、スタックにシェルコードを保存してからリターンポインタを上書きし、それをジャンプして実行するために使用されます：
* **通常のbof**で[**canary**](../common-binary-protections-and-bypasses/stack-canaries/)がある場合、バイパス（リーク）する必要があります
* **ASLR**なしの**nx**なしの場合、スタックのアドレスにジャンプできるため、アドレスにジャンプできます
* **ASLR**がある場合、[**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md)などのテクニックを使用してジャンプする必要があります
* **nx**がある場合、[**ROP**](../rop-return-oriented-programing/)を使用して`memprotect`を呼び出し、ページを`rwx`に変更してから、そこにシェルコードを保存してからジャンプする必要があります（たとえば、readを呼び出して）。
* これにより、シェルコードがROPチェーンと混在します。
#### シスコール経由

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv/): 任意のコマンドを実行するために`execve`を呼び出すのに便利です。**特定のシスコールをパラメータとともに呼び出すためのガジェットを見つける必要があります**。
* もし[**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)が有効になっている場合、バイナリやライブラリからのROPガジェットを使用するためにそれらを打破する必要があります。
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming.md)は**ret2execve**を準備するのに役立ちます。
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)や[**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md)から複数のレジスタを制御するためのガジェット

#### libc経由

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): 通常は**`libc`**からの関数（通常は**`system`**）を呼び出すのに便利です。いくつかの準備された引数（例：`'/bin/sh'`）と共に。呼び出したい関数を含むライブラリをバイナリが**ロードする必要があります**。
* **静的にコンパイルされており**[**PIE**](../common-binary-protections-and-bypasses/pie/) **が無効**の場合、`system`と`/bin/sh`の**アドレス**は変わらないため、それらを静的に使用することが可能です。
* **ASLR**なしで**libcのバージョンを知っている場合**、`system`と`/bin/sh`の**アドレス**は変わらないため、それらを静的に使用することが可能です。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **が有効で**[**PIE**](../common-binary-protections-and-bypasses/pie/)**が無効**の場合、libcを知っていてバイナリが`system`を使用している場合、`'/bin/sh'`のアドレスをパラメータとして`GOT`内のsystemのアドレスに**`ret`することが可能です**（これを解明する必要があります）。
* [ASLR](../common-binary-protections-and-bypasses/aslr/) **が有効で**[PIE](../common-binary-protections-and-bypasses/pie/)**が無効**の場合、libcを知っていて**バイナリが`system`を使用していない場合**：
* [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md)を使用して`system`のアドレスを解決し、それを呼び出す&#x20;
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)を**バイパス**して、メモリ内の`system`と`'/bin/sh'`のアドレスを計算します。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **および** [**PIE**](../common-binary-protections-and-bypasses/pie/) **が有効で**libcを知らない**場合：以下が必要です：
* [**PIE**](../common-binary-protections-and-bypasses/pie/)をバイパスする
* 使用されている**`libc`バージョン**を見つける（いくつかの関数アドレスをリークさせる）
* 続行するために**ASLRの前述のシナリオ**を確認します。

#### EBP/RBP経由

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): スタック内の保存されたEBPを介してRETを制御するためにESPを制御します。
* **オフバイワン**スタックオーバーフローに便利
* EIPを制御する代わりの方法として役立ち、EIPを悪用してメモリ内でペイロードを構築し、それにEBPを介してジャンプする方法

#### その他

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): スタックに呼び出される関数へのポインタや、興味深い関数（systemやprintf）で使用される文字列へのポインタが含まれている場合、そのアドレスを上書きすることが可能です。
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/)または[**PIE**](../common-binary-protections-and-bypasses/pie/)がアドレスに影響を与える可能性があります。
* [**Uninitialized variables**](../stack-overflow/uninitialized-variables.md): 予測できません。
