# Temel İkili Sömürü Metodolojisi

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR göndererek paylaşın.

</details>

## ELF Temel Bilgileri

Herhangi bir şeyi sömürmeye başlamadan önce, bir ELF ikili dosyasının yapısının bir kısmını anlamak ilginç olabilir:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Sömürü Araçları

{% content-ref url="tools/" %}
[tools](tools/)
{% endcontent-ref %}

## Yığın Taşması Metodolojisi

Bu kadar teknikle, her teknik ne zaman kullanışlı olacak bir şema oluşturmak iyidir. Aynı korumaların farklı teknikleri etkileyeceğini unutmayın. Her koruma bölümünde korumaları atlatma yollarını bulabilirsiniz, ancak bu metodolojide değil.

## Akışı Kontrol Etme

Bir programın akışını kontrol etmenin farklı yolları olabilir:

* [**Yığın Taşmaları**](../stack-overflow/): Yığınından dönüş işaretçisini veya EBP -> ESP -> EIP'yi üzerine yazarak.
* Taşmayı tetiklemek için bir [**Tamsayı Taşmaları**](../integer-overflow.md) kullanmanız gerekebilir
* Veya **Keyfi Yazma + Ne Nerede Yazma ile Yürütme**
* [**Biçim Dizileri**](../format-strings/)**:** `printf`'i kötüye kullanarak keyfi içeriği keyfi adreslere yazmak.
* [**Dizi İndeksleme**](../array-indexing.md): Kötü tasarlanmış bir dizinlemeyi kötüye kullanarak bazı dizileri kontrol edebilir ve keyfi yazma alabilirsiniz.
* Taşmayı tetiklemek için bir [**Tamsayı Taşmaları**](../integer-overflow.md) kullanmanız gerekebilir
* **bof to WWW via ROP**: Bir tampon taşmasını kötüye kullanarak bir ROP oluşturmak ve bir WWW almak için.

**Ne Nerede Yazma ile Yürütme** tekniklerini şurada bulabilirsiniz:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Sonsuz Döngüler

Genellikle **bir zafiyetin sadece bir kez sömürülmesinin yeterli olmayabileceğini** ve özellikle bazı korumaların atlatılması gerektiğini unutmamak önemlidir. Bu nedenle, **bir zafiyeti aynı ikili dosyanın yürütülmesinde birkaç kez sömürülebilir hale getirmek için bazı seçenekleri** tartışmak ilginçtir:

* Bir **ROP** zincirine **`main` işlevinin adresini** veya **zafiyetin meydana geldiği adrese** yazın.
* Uygun bir ROP zincirini kontrol ederek, o zincirdeki tüm işlemleri gerçekleştirebilirsiniz
* **`exit` adresini GOT'a yazın** (veya bitmeden önce ikili dosya tarafından kullanılan başka bir işlev) **zafiyete geri dönmek için** adresi
* [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)'de açıklandığı gibi, burada 2 işlev saklayın, biri zafiyeti tekrar çağırmak için diğeri `.fini_array` işlevini tekrar çağıracak olan `__libc_csu_fini` işlevini çağırmak için.

## Sömürü Hedefleri

### Hedef: Varolan bir işlevi Çağırmak

* [**ret2win**](./#ret2win): Çağırmanız gereken bir işlev (belki belirli parametrelerle) varsa bayrağı almak için.
* [**PIE**](../common-binary-protections-and-bypasses/pie/) ve [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) olmadan bir **düzenli bof** durumunda, yığında depolanan dönüş adresine adresi yazmanız yeterli olacaktır.
* [**PIE**](../common-binary-protections-and-bypasses/pie/) ile bir bof durumunda, bunu atlatmanız gerekecektir
* [**canary**](../common-binary-protections-and-bypasses/stack-canaries/) ile bir bof durumunda, bunu atlatmanız gerekecektir
* **ret2win** işlevini doğru şekilde çağırmak için birden fazla parametre ayarlamanız gerekiyorsa şunları kullanabilirsiniz:
* **Yeterli sayıda araç** varsa [**ROP**](./#rop-and-ret2...-techniques) zinciri tüm parametreleri hazırlamak için
* [**SROP**](../rop-return-oriented-programing/ret2esp-ret2reg/srop-sigreturn-oriented-programming.md) (bu sistem çağrısını yapabiliyorsanız) birçok kaydı kontrol etmek için
* [**ret2csu**](../rop-return-oriented-programing/ret2csu.md)'dan araçlar birkaç kaydı kontrol etmek için
* Bir [**Ne Nerede Yazma**](../arbitrary-write-2-exec/) ile başka zafiyetleri (bof olmayanlar) kötüye kullanarak **`win`** işlevini çağırabilirsiniz.
* [**İşaretçileri Yönlendirme**](../stack-overflow/pointer-redirecting.md): Yığında, çağrılacak bir işlevin işaretçilerini veya bir işlev tarafından kullanılacak bir dizeye işaret eden işaretçiler varsa, o adresi üzerine yazabilirsiniz.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) veya [**PIE**](../common-binary-protections-and-bypasses/pie/) adresleri etkileyebilir.
* [**İlklenmemiş değişkenler**](../stack-overflow/uninitialized-variables.md): Asla bilemezsiniz.

### Hedef: Uzaktan Kod Yürütme (RCE)

#### Nx devre dışı bırakılmışsa veya kodu karıştırarak shellcode ile:

* [**(Yığın) Shellcode**](./#stack-shellcode): Bu, bir shellcode'u yığında depolamak ve ardından dönüş işaretçisini üzerine yazarak ona atlamak ve çalıştırmak için kullanışlıdır:
* **Her durumda, bir** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/)** varsa**, düzenli bir bof durumunda bunu atlatmanız gerekecektir
* **ASLR** ve [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) olmadan, yığının adresine atlamak mümkündür çünkü asla değişmeyecektir
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) ile, buna atlamak için [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg/) gibi teknikler gerekecektir
* [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) ile, bir sayfayı `rwx` yapmak için bazı [**ROP**](../rop-return-oriented-programing/) kullanarak `memprotect`'i çağırmak ve ardından oraya shellcode'u depolamak (örneğin okuma çağrısı yaparak) ve ardından oraya atlamak gerekecektir.
* Bu, bir ROP zinciri ile shellcode'u karıştıracaktır.
#### Syscall ile

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv.md): Herhangi bir komut çalıştırmak için `execve`'yi çağırmak için kullanışlıdır. **Belirli bir syscall'ı parametreleriyle çağırmak için gadget'ları bulabilmeniz gerekir**.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) veya [**PIE**](../common-binary-protections-and-bypasses/pie/) etkinse, ROP gadget'larını kullanabilmek için bunları **geçmek zorundasınız**.
* [**SROP**](../rop-return-oriented-programing/ret2esp-ret2reg/srop-sigreturn-oriented-programming.md) hazırlamak için **ret2execve**'yi kullanışlı olabilir

#### Libc ile

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Genellikle **`libc`** gibi bir kütüphaneden bir fonksiyonu (genellikle **`system`**) çağırmak için kullanışlıdır ve bazı hazırlanmış argümanlarla (ör. `'/bin/sh'`). Çağırmak istediğiniz fonksiyonu içeren kütüphaneyi **yüklemek için** binary'ye ihtiyacınız vardır.
* **Statik olarak derlenmiş ve** [**PIE**](../common-binary-protections-and-bypasses/pie/) **olmayan durumlarda**, `system` ve `/bin/sh`'nin **adresleri değişmeyecek**, bu yüzden bunları statik olarak kullanmak mümkündür.
* **ASLR olmadan ve yüklenen libc sürümünü bildiğinizde**, `system` ve `/bin/sh`'nin **adresleri değişmeyecek**, bu yüzden bunları statik olarak kullanmak mümkündür.
* [ASLR](../common-binary-protections-and-bypasses/aslr/) **ancak** [PIE](../common-binary-protections-and-bypasses/pie/)** olmadığında, libc'yi bildiğiniz ve binary'nin `system` fonksiyonunu kullandığı durumda**, `'/bin/sh'` adresiyle birlikte **GOT'taki system adresine** `ret` yapmak mümkündür (bunu çözmeniz gerekecek).
* [ASLR](../common-binary-protections-and-bypasses/aslr/) **ancak** [PIE](../common-binary-protections-and-bypasses/pie/)** olmadığında, libc'yi bildiğiniz ve binary'nin `system`'i kullanmadığı durumda**:
* **`ret2dlresolve`**'yi kullanarak `system`'in adresini çözümlemek ve çağırmak için
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **geçmek ve bellekteki `system` ve `'/bin/sh'` adresini hesaplamak**.
* [ASLR](../common-binary-protections-and-bypasses/aslr/) **ve** [PIE](../common-binary-protections-and-bypasses/pie/) **ve libc'yi bilmediğiniz durumlarda**: Şunları yapmanız gerekir:
* [PIE](../common-binary-protections-and-bypasses/pie/) **geçmek**
* Kullanılan **`libc` sürümünü** bulmak (birkaç fonksiyon adresini sızdırmak)
* Devam etmek için **ASLR ile önceki senaryoları kontrol edin**.

#### EBP/RBP ile

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): ESP'yi kontrol ederek depolanan EBP ile RET'i kontrol etme.
* **Off-by-one** stack overflow'lar için kullanışlıdır
* EIP'yi kontrol etmeyi sonlandırmanın alternatif bir yol olarak kullanışlıdır, EIP'yi hafızada payload'ı oluşturmak için kötüye kullanırken ve ardından EBP aracılığıyla ona atlayarak.

#### Çeşitli

* [**Pointers Redirecting**](../stack-overflow/pointer-redirecting.md): Stack'te çağrılacak bir fonksiyonun veya ilginç bir fonksiyon tarafından kullanılacak bir dizenin adreslerini içeren işaretçiler varsa, o adresi üzerine yazmak mümkündür.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) veya [**PIE**](../common-binary-protections-and-bypasses/pie/) adresleri etkileyebilir.
* [**İlklenmemiş değişkenler**](../stack-overflow/uninitialized-variables.md): Asla bilemezsiniz
