# Podstawowa Metodologia Eksploatacji Binarnych

<details>

<summary><strong>Dowiedz się, jak hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) albo **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe Informacje o ELF

Zanim zaczniesz eksploatować cokolwiek, warto zrozumieć część struktury **binarnego pliku ELF**:

{% content-ref url="elf-tricks.md" %}
[elf-tricks.md](elf-tricks.md)
{% endcontent-ref %}

## Narzędzia Eksploatacji

{% content-ref url="tools/" %}
[narzędzia](tools/)
{% endcontent-ref %}

## Metodologia Przepełnienia Stosu

Z tak wieloma technikami dobrze jest mieć schemat, kiedy każda technika będzie przydatna. Zauważ, że te same zabezpieczenia będą wpływać na różne techniki. Sposoby obejścia zabezpieczeń można znaleźć w każdej sekcji zabezpieczeń, ale nie w tej metodologii.

## Kontrolowanie Przepływu

Istnieje kilka sposobów, w jaki można kontrolować przepływ programu:

* [**Przepełnienia Stosu**](../stack-overflow/) nadpisywanie wskaźnika powrotu ze stosu lub EBP -> ESP -> EIP.
* Być może trzeba wykorzystać [**Przepełnienia Liczb Całkowitych**](../integer-overflow.md), aby spowodować przepełnienie.
* Lub poprzez **Arbitrary Writes + Write What Where to Execution**
* [**Formatowanie łańcuchów**](../format-strings/)**:** Wykorzystanie `printf` do zapisywania dowolnej zawartości pod dowolnymi adresami.
* [**Indeksowanie Tablic**](../array-indexing.md): Wykorzystanie źle zaprojektowanego indeksowania, aby móc kontrolować niektóre tablice i uzyskać dowolny zapis.
* Być może trzeba wykorzystać [**Przepełnienia Liczb Całkowitych**](../integer-overflow.md), aby spowodować przepełnienie
* **bof to WWW via ROP**: Wykorzystanie przepełnienia bufora do skonstruowania ROP i uzyskania WWW.

Techniki **Write What Where to Execution** można znaleźć w:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

## Wieczne Pętle

Warto wziąć pod uwagę, że zazwyczaj **jedna eksploatacja podatności może nie wystarczyć** do wykonania udanego ataku, zwłaszcza gdy trzeba ominąć pewne zabezpieczenia. Dlatego interesujące jest omówienie kilku opcji, aby **umożliwić wielokrotne wykorzystanie jednej podatności** w tym samym wykonaniu binarnego pliku:

* Zapisz w łańcuchu **ROP** adres funkcji **`main`** lub adres, gdzie występuje **podatność**.
* Kontrolując odpowiedni łańcuch ROP, możesz wykonać wszystkie akcje w tym łańcuchu.
* Zapisz adres **`exit` w GOT** (lub dowolnej innej funkcji używanej przez binarny plik przed zakończeniem) adres, aby wrócić **do podatności**.
* Jak wyjaśniono w [**.fini\_array**](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md#eternal-loop)**,** przechowuj tutaj 2 funkcje, jedną do ponownego wywołania podatności i drugą do wywołania**`__libc_csu_fini`**, która ponownie wywoła funkcję z `.fini_array`.

## Cele Eksploatacji

### Cel: Wywołanie Istniejącej Funkcji

* [**ret2win**](./#ret2win): Istnieje funkcja w kodzie, którą musisz wywołać (być może z określonymi parametrami), aby uzyskać flagę.
* W zwykłym przepełnieniu bufora bez [**PIE**](../common-binary-protections-and-bypasses/pie/) **i** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), wystarczy zapisać adres w adresie powrotu przechowywanym na stosie.
* W przypadku przepełnienia bufora z [**PIE**](../common-binary-protections-and-bypasses/pie/), będziesz musiał je ominąć.
* W przypadku przepełnienia bufora z [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), będziesz musiał je ominąć.
* Jeśli musisz ustawić kilka parametrów, aby poprawnie wywołać funkcję **ret2win**, możesz użyć:
* Łańcucha [**ROP**](./#rop-and-ret2...-techniques) **jeśli jest wystarczająco dużo gadżetów**, aby przygotować wszystkie parametry
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming.md) (jeśli można wywołać ten syscall) do kontrolowania wielu rejestrów
* Gadżetów z [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) i [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) do kontrolowania kilku rejestrów
* Poprzez [**Write What Where**](../arbitrary-write-2-exec/) można wykorzystać inne podatności (nie bof), aby wywołać funkcję **`win`**.
* [**Przekierowywanie Wskaźników**](../stack-overflow/pointer-redirecting.md): W przypadku, gdy stos zawiera wskaźniki do funkcji, która ma zostać wywołana lub do ciągu znaków, który ma być użyty przez interesującą funkcję (system lub printf), można nadpisać ten adres.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) lub [**PIE**](../common-binary-protections-and-bypasses/pie/) mogą wpłynąć na adresy.
* [**Nie zainicjowane zmienne**](../stack-overflow/uninitialized-variables.md): Nigdy nie wiesz.

### Cel: RCE

#### Poprzez shellcode, jeśli nx jest wyłączone lub łączenie shellcode z ROP:

* [**(Stack) Shellcode**](./#stack-shellcode): Jest to przydatne do przechowywania shellcode'u na stosie przed lub po nadpisaniu wskaźnika powrotu, a następnie **skok do niego** w celu wykonania:
* **W każdym przypadku, jeśli jest** [**canary**](../common-binary-protections-and-bypasses/stack-canaries/), w zwykłym przepełnieniu bufora trzeba go ominąć (wyciek).
* **Bez** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **i** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md) można skoczyć pod adres stosu, ponieważ nie zmieni się on nigdy
* **Z** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) będziesz musiał użyć technik takich jak [**ret2esp/ret2reg**](../rop-return-oriented-programing/ret2esp-ret2reg.md), aby skoczyć do niego
* **Z** [**nx**](../common-binary-protections-and-bypasses/no-exec-nx.md), będziesz musiał użyć pewnego [**ROP**](../rop-return-oriented-programing/) **do wywołania `memprotect`** i uczynienia pewnej strony `rwx`, aby następnie **przechować tam shellcode** (wywołując na przykład read) i potem skoczyć tam.
* To połączy shellcode z łańcuchem ROP.
#### Za pomocą wywołań systemowych

* [**Ret2syscall**](../rop-return-oriented-programing/rop-syscall-execv.md): Przydatne do wywołania `execve` w celu uruchomienia dowolnych poleceń. Musisz być w stanie znaleźć **gadżety do wywołania określonego wywołania systemowego z parametrami**.
* Jeśli są włączone [**ASLR**](../common-binary-protections-and-bypasses/aslr/) lub [**PIE**](../common-binary-protections-and-bypasses/pie/), będziesz musiał je pokonać, **aby użyć gadżetów ROP** z binariów lub bibliotek.
* [**SROP**](../rop-return-oriented-programing/srop-sigreturn-oriented-programming.md) może być przydatne do przygotowania **ret2execve**.
* Gadżety z [**ret2csu**](../rop-return-oriented-programing/ret2csu.md) i [**ret2vdso**](../rop-return-oriented-programing/ret2vdso.md) do kontrolowania kilku rejestrów

#### Za pomocą libc

* [**Ret2lib**](../rop-return-oriented-programing/ret2lib/): Przydatne do wywołania funkcji z biblioteki (zazwyczaj z **`libc`**) jak **`system`** z przygotowanymi argumentami (np. `'/bin/sh'`). Potrzebujesz, aby binarny **załadował bibliotekę** z funkcją, którą chcesz wywołać (zazwyczaj libc).
* Jeśli jest **skompilowany statycznie i nie ma** [**PIE**](../common-binary-protections-and-bypasses/pie/), **adres** `system` i `/bin/sh` nie zmienią się, więc można ich użyć statycznie.
* **Bez** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **i znając wersję libc** załadowaną, **adres** `system` i `/bin/sh` nie zmienią się, więc można ich użyć statycznie.
* Z [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ale bez** [**PIE**](../common-binary-protections-and-bypasses/pie/), znając libc i z binarnym używającym funkcji `system`, można **`ret` do adresu systemu w GOT** z adresem `'/bin/sh'` w parametrze (trzeba to ustalić).
* Z [ASLR](../common-binary-protections-and-bypasses/aslr/) ale bez [PIE](../common-binary-protections-and-bypasses/pie/), znając libc i **bez użycia binarnego `system`**:
* Użyj [**`ret2dlresolve`**](../rop-return-oriented-programing/ret2dlresolve.md) do rozwiązania adresu `system` i jego wywołania&#x20;
* **Ominięcie** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) i obliczenie adresu `system` i `'/bin/sh'` w pamięci.
* **Z** [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **i** [**PIE**](../common-binary-protections-and-bypasses/pie/) **i nie znając wersji libc**: Musisz:
* Ominąć [**PIE**](../common-binary-protections-and-bypasses/pie/)
* Znaleźć używaną **wersję libc** (wyciek kilku adresów funkcji)
* Sprawdź **poprzednie scenariusze z ASLR**, aby kontynuować.

#### Za pomocą EBP/RBP

* [**Stack Pivoting / EBP2Ret / EBP Chaining**](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md): Kontroluj ESP, aby kontrolować RET poprzez przechowywane EBP na stosie.
* Przydatne do przepełnień stosu **off-by-one**
* Przydatne jako alternatywny sposób na kontrolowanie EIP, wykorzystując EIP do konstruowania ładunku w pamięci, a następnie skakania do niego za pomocą EBP

#### Różne

* [**Przekierowywanie wskaźników**](../stack-overflow/pointer-redirecting.md): W przypadku, gdy stos zawiera wskaźniki do funkcji, która ma zostać wywołana lub do ciągu znaków, który ma być użyty przez interesującą funkcję (system lub printf), możliwe jest nadpisanie tego adresu.
* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) lub [**PIE**](../common-binary-protections-and-bypasses/pie/) mogą wpłynąć na adresy.
* [**Nie zainicjowane zmienne**](../stack-overflow/uninitialized-variables.md): Nigdy nie wiesz

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
