# 未排序 Bin 攻击

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的**公司在 HackTricks 中做广告**或**下载 PDF 版本的 HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在 **Twitter** 上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## 基本信息

有关未排序 Bin 是什么的更多信息，请查看此页面：

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

未排序列表能够将地址写入到块的 `bk` 地址中的 `unsorted_chunks (av)`。因此，如果攻击者能够**修改未排序 Bin 中块内的 bk 指针的地址**，他就能够**将该地址写入到任意地址**，这有助于泄漏 libc 地址或绕过某些防御。

因此，基本上，这种攻击允许**用一个大数值覆盖一些任意地址**（一个可能是堆地址或 libc 地址的地址），比如一些可能会泄漏的堆地址或一些限制，比如全局变量 **`global_max_fast`**，以允许创建更大尺寸的快速 Bin 块（从未排序 Bin 攻击转变为快速 Bin 攻击）。

{% hint style="success" %}
查看 [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) 中提供的示例，并使用 0x4000 和 0x5000 代替 0x400 和 0x500 作为块大小（以避免 tcaches），可以看到**现在**触发错误 **`malloc(): unsorted double linked list corrupted`**。

因此，这种未排序 Bin 攻击现在（除其他检查外）还需要能够修复双重链接列表，以便绕过 `victim->bck->fd == victim` 或不是 `victim->fd == av (arena)`。这意味着我们想要写入的地址必须在其 `fd` 位置具有伪造块的地址，并且伪造块的 `fd` 指向 arena。
{% endhint %}

{% hint style="danger" %}
请注意，此攻击会破坏未排序 Bin（因此也会破坏小块和大块）。因此，我们现在只能**使用快速 Bin 中的分配**（更复杂的程序可能会进行其他分配并崩溃），要触发此攻击，我们必须**分配相同大小的块，否则程序将崩溃**。

请注意，使 **`global_max_fast`** 可能会在这种情况下有所帮助，相信快速 Bin 将能够处理直到利用完成的所有其他分配。
{% endhint %}

来自 [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) 的代码很好地解释了这一点，尽管如果您修改 malloc 分配的内存大小足够大，以避免 tcache，您会发现先前提到的错误出现，阻止了这种技术：**`malloc(): unsorted double linked list corrupted`**

## 参考资料和其他示例

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* 目标是用大于 4869 的值覆盖一个全局变量，以便获取标志，且未启用 PIE。
* 可以生成任意大小的块，并且有所需大小的堆溢出。
* 攻击开始创建 3 个块：chunk0 用于利用溢出，chunk1 用于溢出，chunk2 以防止顶部块合并前两个块。
* 然后，释放 chunk1，并将 chunk0 溢出到 chunk1 的 `bk` 指针，使得 `bk = magic - 0x10`。
* 然后，分配与 chunk1 相同大小的 chunk3，这将触发未排序 Bin 攻击，并修改全局变量的值，从而可能获取标志。
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* 合并函数存在漏洞，因为如果传递的两个索引相同，它将对其进行重新分配，然后释放它，但返回一个可以使用的已释放区域的指针。
* 因此，**创建 2 个块**：**chunk0** 将与自身合并，chunk1 用于防止与顶部块合并。然后，两次调用合并函数与 chunk0，这将导致使用后释放。
* 然后，调用 **`view`** 函数，索引为 2（使用后释放块的索引），这将**泄漏一个 libc 地址**。
* 由于二进制文件只允许 malloc 大于 **`global_max_fast`** 的大小，因此不使用 fastbin，将使用未排序 Bin 攻击来覆盖全局变量 `global_max_fast`。
* 然后，可以使用索引 2（使用后释放指针）调用编辑函数，并将 `bk` 指针覆盖为指向 `p64(global_max_fast-0x10)`。然后，创建一个新块将使用先前受损的释放地址（0x20）将**触发未排序 Bin 攻击**，覆盖 `global_max_fast` 为一个非常大的值，现在可以在快速 Bin 中创建块。
* 现在执行**快速 Bin 攻击**：
* 首先发现可以在 **`__free_hook`** 位置使用大小为 200 的快速 **块**：
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* 如果我们设法在此位置获得大小为 0x200 的快速块，就可以覆盖将执行的函数指针
* 为此，创建大小为 `0xfc` 的新块，并两次调用合并函数，这样我们就可以获得一个大小为 `0xfc*2 = 0x1f8` 的已释放块的指针在快速 Bin 中。
* 然后，在此块中调用编辑函数以修改此快速 Bin 的 **`fd`** 地址，使其指向先前的 **`__free_hook`** 函数。
* 然后，创建一个大小为`0x1f8`的块，以从快速分配区域中检索先前无用的块，然后创建另一个大小为`0x1f8`的块，以在**`__free_hook`**中获取一个快速分配区域块，该块被覆盖为**`system`**函数的地址。
* 最后，释放一个包含字符串`/bin/sh\x00`的块，调用删除函数，触发指向带有`/bin/sh\x00`作为参数的`system`的**`__free_hook`**函数。

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
