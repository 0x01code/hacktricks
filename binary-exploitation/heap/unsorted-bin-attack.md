# Unsorted Bin Attack

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)</strong>를 통해 **제로부터 영웅까지 AWS 해킹을 배우세요**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 얻으세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소로 **PR 제출**하여 해킹 트릭을 공유하세요.

</details>

## 기본 정보

Unsorted bin이 무엇인지에 대한 자세한 정보는 다음 페이지를 확인하세요:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Unsorted 리스트는 청크의 `bk` 주소에 `unsorted_chunks (av)`의 주소를 쓸 수 있습니다. 따라서, 공격자가 unsorted bin 내부의 청크에서 **bk 포인터의 주소를 수정**할 수 있다면, 임의의 주소에 해당 주소를 쓸 수 있어 libc 주소를 노출하거나 일부 방어를 우회하는 데 도움이 될 수 있습니다.

따라서, 기본적으로 이 공격은 **큰 숫자(힙 주소 또는 libc 주소가 될 수 있는 주소)로 임의의 주소를 덮어쓸 수 있게 했으며**, 누출될 수 있는 스택 주소 또는 전역 변수인 **`global_max_fast`**와 같은 제한을 우회하여 더 큰 크기의 fast bin bins를 생성할 수 있도록 허용합니다 (unsorted bin 공격에서 fast bin 공격으로 전환).

{% hint style="success" %}
[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle)에서 제공된 예제를 살펴보고 0x400과 0x500 대신 0x4000과 0x5000을 사용하여 (tcaches를 피하기 위해) **현재** 오류 **`malloc(): unsorted double linked list corrupted`**가 트리거되는 것을 볼 수 있습니다.

따라서, 이제 이 unsorted bin 공격은 (다른 확인 사항과 함께) 또한 이중 연결 목록을 수정할 수 있어야 하므로 `victim->bck->fd == victim` 또는 `victim->fd == av (arena)`가 우회되어야 합니다. 즉, 우리가 원하는 주소는 가짜 청크의 `fd` 위치에 가짜 청크의 주소가 있어야 하며, 가짜 청크의 `fd`가 아레나를 가리켜야 합니다.
{% endhint %}

{% hint style="danger" %}
이 공격은 unsorted bin (작은 크기 및 큰 크기도)를 손상시킵니다. 따라서 이제 **이제 fast bin에서만 할당을 사용할 수 있습니다** (더 복잡한 프로그램은 다른 할당을 수행하고 충돌할 수 있음) 및 이를 트리거하려면 **같은 크기로 할당해야 합니다.**

이 경우 **`global_max_fast`**를 만드는 것이 도움이 될 수 있으며, fast bin이 모든 다른 할당을 처리할 수 있을 것으로 신뢰할 수 있습니다. 공격이 완료될 때까지.
{% endhint %}

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html)의 코드는 매우 잘 설명하고 있지만, malloc을 수정하여 tcache에 끝나지 않도록 충분히 큰 메모리를 할당하면 이전에 언급한 오류가 발생하여 이 기술을 방지하는 것을 볼 수 있습니다: **`malloc(): unsorted double linked list corrupted`**

## 참고 및 다른 예제

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* 글로벌 변수를 4869보다 큰 값으로 덮어쓰기 위한 목표이며, PIE가 활성화되지 않았습니다.
* 임의의 크기의 청크를 생성할 수 있으며 원하는 크기의 힙 오버플로우가 있습니다.
* 공격은 오버플로우를 악용하기 위해 chunk0, 오버플로우될 chunk1 및 이전 청크를 합병하지 않도록 하는 chunk2를 생성하여 시작됩니다.
* 그런 다음, chunk1이 해제되고 chunk0이 chunk1의 `bk` 포인터로 오버플로우되어야 합니다: `bk = magic - 0x10`
* 그런 다음, chunk1과 동일한 크기로 chunk3이 할당되며, 이는 unsorted bin 공격을 트리거하고 글로벌 변수의 값을 수정하여 플래그를 얻을 수 있게 합니다.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* 병합 함수는 두 인덱스가 동일한 경우 다시 할당하고 해제하지만 사용할 수 있는 그 해제된 영역을 가리키는 포인터를 반환합니다.
* 따라서, **2개의 청크가 생성**됩니다: **chunk0**은 자체와 병합되고 이전 청크와 병합되지 않도록 하기 위해 chunk1이 생성됩니다. 그런 다음, **chunk0으로 병합 함수가 두 번 호출**되어 사용 후 무료가 발생합니다.
* 그런 다음, **`view`** 함수가 사용 후 무료 청크의 인덱스인 2로 호출되어 **libc 주소를 노출**합니다.
* 바이너리가 **`global_max_fast`**보다 큰 크기의 malloc만 허용하는 보호를 가지고 있기 때문에 fastbin을 사용하지 않으므로 unsorted bin 공격을 사용하여 글로벌 변수 `global_max_fast`를 덮어쓸 수 있습니다.
* 그런 다음, 사용 후 무료 포인터인 인덱스 2로 편집 함수를 호출하여 `bk` 포인터를 `p64(global_max_fast-0x10)`을 가리키도록 덮어쓸 수 있습니다. 그런 다음, 새로운 청크를 생성하면 이전에 손상된 무료 주소(0x20)가 사용되어 **unsorted bin 공격이 트리거**되어 `global_max_fast`가 매우 큰 값으로 덮어씌워져 이제 fast bin에 청크를 생성할 수 있게 됩니다.
* 이제 **fast bin 공격**이 수행됩니다:
* 먼저 **`__free_hook` 위치에서 크기가 200인 fast 청크로 작업할 수 있다는 것을 발견**했습니다:
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* 이 위치에 크기가 0x200인 fast 청크를 얻으면 실행될 함수 포인터를 덮어쓸 수 있습니다.
* 이를 위해 크기 `0xfc`의 새로운 청크가 생성되고 해당 포인터로 병합 함수가 두 번 호출되어 fast bin에서 크기 `0xfc*2 = 0x1f8`의 해제된 청크에 대한 포인터를 얻습니다.
* 그런 다음, 이 청크에서 edit 함수가 호출되어 이 fast bin의 `fd` 주소를 이전 **`__free_hook`** 함수를 가리키도록 수정합니다.
* 그런 다음, 크기가 `0x1f8`인 청크가 생성되어 빠른 bin에서 이전에 사용되지 않았던 청크를 검색하여 `0x1f8` 크기의 또 다른 청크가 **`__free_hook`**에서 빠른 bin 청크를 가져오고, 이는 **`system`** 함수의 주소로 덮어씁니다.
* 마지막으로 `/bin/sh\x00` 문자열을 포함하는 청크가 삭제 함수를 호출하여 해제되고, `/bin/sh\x00`을 매개변수로 하는 system을 가리키는 **`__free_hook`** 함수가 트리거됩니다.

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 <strong>AWS 해킹을 제로부터 전문가로 배우세요</strong>!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 PDF로 HackTricks를 다운로드하고 싶다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 **Discord 그룹**에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 팔로우하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
