# Attacco al Bin Non Ordinato

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e ai repository github di [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informazioni di Base

Per ulteriori informazioni su cosa sia un bin non ordinato, controlla questa pagina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Le liste non ordinate sono in grado di scrivere l'indirizzo in `unsorted_chunks (av)` nell'indirizzo `bk` del chunk. Pertanto, se un attaccante pu√≤ **modificare l'indirizzo del puntatore bk** in un chunk all'interno del bin non ordinato, potrebbe essere in grado di **scrivere quell'indirizzo in un indirizzo arbitrario** che potrebbe essere utile per ottenere un leak di indirizzi libc o bypassare alcune difese.

Quindi, fondamentalmente, questo attacco permette di **sovrascrivere un indirizzo arbitrario con un numero grande** (un indirizzo che potrebbe essere un indirizzo di heap o un indirizzo libc) come un indirizzo di stack che potrebbe essere leakato o una restrizione come la variabile globale **`global_max_fast`** per consentire di creare bin rapidi con dimensioni maggiori (e passare da un attacco al bin non ordinato a un attacco al bin rapido).

{% hint style="success" %}
Guardando l'esempio fornito in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e utilizzando 0x4000 e 0x5000 invece di 0x400 e 0x500 come dimensioni dei chunk (per evitare tcaches) √® possibile vedere che **oggi** l'errore **`malloc(): unsorted double linked list corrupted`** viene attivato.

Pertanto, questo attacco al bin non ordinato ora (tra altri controlli) richiede anche di essere in grado di correggere la lista doppiamente collegata in modo che venga bypassato `victim->bck->fd == victim` o non `victim->fd == av (arena)`. Ci√≤ significa che l'indirizzo in cui vogliamo scrivere deve avere l'indirizzo del chunk falso nella sua posizione `fd` e che il `fd` del chunk falso punti all'arena.
{% endhint %}

{% hint style="danger" %}
Nota che questo attacco corrompe il bin non ordinato (quindi anche quello piccolo e grande). Quindi possiamo **usare solo allocazioni dal bin rapido ora** (un programma pi√π complesso potrebbe fare altre allocazioni e bloccarsi), e per attivare questo dobbiamo **allocare la stessa dimensione o il programma si bloccher√†.**

Nota che rendere **`global_max_fast`** potrebbe aiutare in questo caso fidandosi che il bin rapido sar√† in grado di gestire tutte le altre allocazioni fino a quando l'exploit non √® completato.
{% endhint %}

Il codice di [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) lo spiega molto bene, anche se se si modificano le malloc per allocare memoria sufficientemente grande in modo che non finisca in un tcache, si pu√≤ vedere che compare l'errore precedentemente menzionato che impedisce questa tecnica: **`malloc(): unsorted double linked list corrupted`**

## Riferimenti e Altri Esempi

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* L'obiettivo √® sovrascrivere una variabile globale con un valore maggiore di 4869 in modo da poter ottenere il flag e PIE non √® abilitato.
* √à possibile generare chunk di dimensioni arbitrarie e c'√® un heap overflow con la dimensione desiderata.
* L'attacco inizia creando 3 chunk: chunk0 per sfruttare l'overflow, chunk1 per essere sovraffollato e chunk2 in modo che il chunk superiore non consolidi quelli precedenti.
* Quindi, chunk1 viene liberato e chunk0 viene sovraffollato in modo che il puntatore `bk` di chunk1 punti a: `bk = magic - 0x10`
* Successivamente, viene allocato chunk3 con la stessa dimensione di chunk1, il che attiver√† l'attacco al bin non ordinato e modificher√† il valore della variabile globale, rendendo possibile ottenere il flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La funzione di merge √® vulnerabile perch√© se entrambi gli indici passati sono gli stessi, realloc su di esso e quindi lo libera ma restituisce un puntatore a quella regione liberata che pu√≤ essere utilizzato.
* Pertanto, **vengono creati 2 chunk**: **chunk0** che verr√† unito con se stesso e chunk1 per evitare la consolidazione con il chunk superiore. Quindi, la **funzione di merge viene chiamata con chunk0** due volte, causando un use after free.
* Successivamente, viene chiamata la funzione **`view`** con indice 2 (che √® l'indice del chunk use after free), che **fa trapelare un indirizzo libc**.
* Poich√© il binario ha protezioni per allocare solo dimensioni maggiori di **`global_max_fast`** quindi non viene utilizzato alcun fastbin, verr√† utilizzato un attacco al bin non ordinato per sovrascrivere la variabile globale `global_max_fast`.
* Quindi, √® possibile chiamare la funzione di modifica con l'indice 2 (il puntatore use after free) e sovrascrivere il puntatore `bk` per puntare a `p64(global_max_fast-0x10)`. Quindi, creando un nuovo chunk verr√† utilizzato l'indirizzo di free compromesso in precedenza (0x20) attiver√† **l'attacco al bin non ordinato** sovrascrivendo il `global_max_fast` con un valore molto grande, consentendo ora di creare chunk nei bin rapidi.
* Ora viene eseguito un **attacco al fast bin**:
* Prima di tutto si scopre che √® possibile lavorare con **chunk rapidi di dimensione 200** nella posizione di **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se riusciamo a ottenere un chunk rapido di dimensione 0x200 in questa posizione, sar√† possibile sovrascrivere un puntatore di funzione che verr√† eseguito
* Per fare ci√≤, viene creato un nuovo chunk di dimensione `0xfc` e la funzione di merge viene chiamata con quel puntatore due volte, in questo modo otteniamo un puntatore a un chunk liberato di dimensione `0xfc*2 = 0x1f8` nel fast bin.
* Quindi, viene chiamata la funzione di modifica in questo chunk per modificare l'indirizzo **`fd`** di questo fast bin in modo che punti alla funzione precedente di **`__free_hook`**.
* Quindi, viene creato un chunk con dimensione `0x1f8` per recuperare dal fast bin il chunk inutilizzato precedente in modo da creare un altro chunk di dimensione `0x1f8` per ottenere un chunk fast bin nel **`__free_hook`** che viene sovrascritto con l'indirizzo della funzione **`system`**.
* Infine, viene liberato un chunk contenente la stringa `/bin/sh\x00` chiamando la funzione di eliminazione, attivando la funzione **`__free_hook`** che punta a system con `/bin/sh\x00` come parametro.
