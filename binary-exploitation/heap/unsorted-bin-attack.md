# Ongeorden Bin√™re Aanval

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

Vir meer inligting oor wat 'n ongeorden bin√™re is, kyk na hierdie bladsy:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Ongeorden lysies kan die adres na `ongesorteerde brokke (av)` in die `bk`-adres van die brokkie skryf. Daarom, as 'n aanvaller die adres van die bk-aanwyser in 'n brokkie binne die ongeorden bin√™re kan **verander**, kan hy in staat wees om **daardie adres in 'n willekeurige adres te skryf** wat nuttig kan wees om 'n libc-adres te lek of om sekere verdediging te omseil.

Dus, hierdie aanval maak dit basies moontlik om **'n willekeurige adres met 'n groot nommer te oorskryf** ( 'n adres wat 'n heap-adres of 'n libc-adres kan wees) soos 'n sekere stapeladres wat gelekt kan word of 'n sekere beperking soos die globale veranderlike **`global_max_fast`** om groter grootte vinnige binne te skep (en oorgaan van 'n ongeorden bin√™re aanval na 'n vinnige bin√™re aanval).

{% hint style="success" %}
Deur na die voorbeeld te kyk wat verskaf is in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) en 0x4000 en 0x5000 in plaas van 0x400 en 0x500 as brokkie groottes te gebruik (om tcaches te vermy), is dit moontlik om te sien dat **teenwoordig** die fout **`malloc(): ongesorteerde dubbel gekoppelde lys gekorrupteer`** geaktiveer word.

Daarom vereis hierdie ongeorden bin√™re aanval nou (onder andere kontroles) ook dat die dubbel gekoppelde lys reggestel moet word sodat dit omseil word `victim->bck->fd == victim` of nie `victim->fd == av (arena)`. Dit beteken dat die adres waar ons wil skryf, die adres van die vals brokkie in sy `fd`-posisie moet h√™ en dat die vals brokkie `fd` na die arena moet wys.
{% endhint %}

{% hint style="danger" %}
Let daarop dat hierdie aanval die ongeorden bin√™re beskadig (dus klein en groot ook). Dus kan ons nou slegs **toewysings van die vinnige binne gebruik** ( 'n meer komplekse program kan ander toewysings doen en vasloop), en om dit te aktiveer moet ons **dieselfde grootte toewys anders sal die program vasloop.**

Let daarop dat die maak van **`global_max_fast`** mag help in hierdie geval deur te vertrou dat die vinnige bin in staat sal wees om al die ander toewysings te hanteer totdat die uitbuiting voltooi is.
{% endhint %}

Die kode van [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) verduidelik dit baie goed, alhoewel as jy die mallocs wysig om geheue groot genoeg toe te ken sodat dit nie in 'n tcache eindig nie, kan jy sien dat die voorheen genoemde fout voorkom wat hierdie tegniek voorkom: **`malloc(): ongesorteerde dubbel gekoppelde lys gekorrupteer`**

## Ongeorden Bin√™re Infolek Aanval

Dit is eintlik 'n baie basiese konsep. Die brokkies in die ongeorden bin√™re gaan dubbel aanwysers h√™ om die bin√™re te skep. Die eerste brokkie in die ongeorden bin√™re sal eintlik die **FD** en die **BK** skakels h√™ wat **na 'n deel van die hoof-arena (libc) wys**.\
Daarom, as jy 'n brokkie binne 'n ongeorden bin kan **plaas en dit lees** (gebruik na vry) of **dit weer toeken sonder om ten minste 1 van die aanwysers te oorskryf** om dit dan **te lees**, kan jy 'n **libc-informasie lek** h√™.

## Verwysings & Ander voorbeelde

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Die doel is om 'n globale veranderlike met 'n waarde groter as 4869 te oorskryf sodat dit moontlik is om die vlag te kry en PIE is nie geaktiveer nie.
* Dit is moontlik om brokkies van willekeurige groottes te genereer en daar is 'n heap-oorvloei met die gewenste grootte.
* Die aanval begin deur 3 brokkies te skep: brokkie0 om die oorvloei te misbruik, brokkie1 om oorvloei te h√™ en brokkie2 sodat die boonste brokkie nie die voriges konsolideer nie.
* Dan word brokkie1 vrygestel en brokkie0 word oorvloei sodat die `bk`-aanwyser van brokkie1 na `bk = magic - 0x10` wys.
* Dan word brokkie3 toegewys met dieselfde grootte as brokkie1, wat die ongeorden bin√™re aanval sal aktiveer en die waarde van die globale veranderlike sal wysig, wat dit moontlik maak om die vlag te kry.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die saamvoegfunksie is kwesbaar omdat as beide indekse wat oorgedra word dieselfde is, sal dit daarop herallokeer en dit dan vrymaak, maar 'n aanwyser na daardie vrygemaakte gebied teruggee wat gebruik kan word.
* Daarom word **2 brokkies geskep**: **brokkie0** wat met homself saamgevoeg sal word en brokkie1 om te voorkom dat dit saamgevoeg word met die boonste brokkie. Dan word die **saamvoegfunksie met brokkie0** twee keer geroep wat 'n gebruik na vry sal veroorsaak.
* Dan word die **`view`-funksie geroep met indeks 2** (wat die indeks van die gebruik na vry brokkie is), wat 'n **libc-adres sal lek**.
* Aangesien die bin√™re beskermings het om slegs groottes groter as **`global_max_fast`** toe te ken sodat geen vinnige bin gebruik word nie, gaan 'n ongeorden bin√™re aanval gebruik word om die globale veranderlike `global_max_fast` te oorskryf.
* Dan is dit moontlik om die wysigingsfunksie met indeks 2 (die gebruik na vry aanwyser) te roep en die `bk`-aanwyser te oorskryf om te wys na `p64(global_max_fast-0x10)`. Dan, deur 'n nuwe brokkie te skep, sal die voorheen gekompromitteerde vry adres (0x20) gebruik word om die ongeorden bin√™re aanval te **aktiveer** deur die `global_max_fast` te oorskryf met 'n baie groot waarde, wat nou toelaat om brokkies in vinnige bakkies te skep.
* Nou word 'n **vinnige bin-aanval** uitgevoer:
* Eerstens word ontdek dat dit moontlik is om met vinnige **brokkies van grootte 200** in die **`__free_hook`-lokasie** te werk:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* As ons daarin slaag om 'n vinnige blok van grootte 0x200 op hierdie plek te kry, sal dit moontlik wees om 'n funksie-aanwyser te oorskryf wat uitgevoer sal word
* Hiervoor word 'n nuwe blok van grootte `0xfc` geskep en die saamgevoegde funksie word twee keer geroep met daardie aanwyser, op hierdie manier verkry ons 'n aanwyser na 'n vrygemaakte blok van grootte `0xfc*2 = 0x1f8` in die vinnige bin.
* Dan word die wysigingsfunksie in hierdie blok geroep om die **`fd`**-adres van hierdie vinnige bin te wysig om te wys na die vorige **`__free_hook`**-funksie.
* Dan word 'n blok met grootte `0x1f8` geskep om uit die vinnige bin die vorige nuttelose blok te herwin sodat 'n ander blok met grootte `0x1f8` geskep kan word om 'n vinnige bin-blok in die **`__free_hook`** te kry wat oorskryf is met die adres van die **`system`**-funksie.
* En uiteindelik word 'n blok wat die string `/bin/sh\x00` bevat, vrygemaak deur die verwyderingsfunksie te roep, wat die **`__free_hook`**-funksie aktiveer wat na system wys met `/bin/sh\x00` as parameter.

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
