# Unsorted Bin Attack

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)</strong>를 통해 **제로부터 영웅까지 AWS 해킹을 배우세요**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소로 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

unsorted bin이 무엇인지에 대한 자세한 정보는 다음 페이지를 확인하세요:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

정렬되지 않은 목록은 `unsorted_chunks (av)`의 주소를 청크의 `bk` 주소에 쓸 수 있습니다. 따라서, 공격자가 정렬되지 않은 bin 내부의 청크에서 **bk 포인터의 주소를 수정**할 수 있다면, 임의의 주소에 해당 주소를 쓸 수 있어 libc 주소를 노출하거나 일부 방어를 우회하는 데 도움이 될 수 있습니다.

따라서, 기본적으로 이 공격은 **큰 숫자(힙 주소 또는 libc 주소가 될 수 있는 주소)로 일부 임의의 주소를 덮어쓸 수 있게 했으며**, 누출될 수 있는 스택 주소 또는 전역 변수인 **`global_max_fast`**와 같은 제한을 우회하여 더 큰 크기의 fast bin bins를 생성할 수 있도록 허용하여 정렬되지 않은 bin 공격에서 fast bin 공격으로 전환할 수 있습니다.

{% hint style="success" %}
[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle)에서 제공된 예제를 살펴보고 0x400과 0x500 대신 0x4000과 0x5000을 사용하여 (tcaches를 피하기 위해) **현재** 오류 **`malloc(): unsorted double linked list corrupted`**가 트리거되는 것을 볼 수 있습니다.

따라서, 이제 이 unsorted bin 공격은 (다른 확인 사항과 함께) 또한 이중 연결 목록을 수정할 수 있어야 하므로 이중 연결 목록이 우회되어야 합니다 `victim->bck->fd == victim` 또는 `victim->fd == av (arena)`. 즉, 우리가 원하는 주소는 가짜 청크의 주소가 `fd` 위치에 있어야 하며, 가짜 청크 `fd`가 아레나를 가리켜야 합니다.
{% endhint %}

{% hint style="danger" %}
이 공격은 정렬되지 않은 bin을 손상시킵니다 (따라서 작은 크기와 큰 크기도 손상됨). 따라서 이제 **이제 fast bin에서 할당만 사용할 수 있습니다** (더 복잡한 프로그램은 다른 할당을 수행하고 충돌할 수 있음) 및 이를 트리거하려면 **동일한 크기로 할당해야 합니다.**

이 경우 **`global_max_fast`**를 만드는 것이 도움이 될 수 있으며, fast bin이 모든 다른 할당을 처리할 수 있을 것으로 신뢰할 수 있습니다. 이 공격을 완료할 때까지.
{% endhint %}

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html)의 코드는 매우 잘 설명하고 있지만, malloc을 수정하여 tcache에 끝나지 않도록 충분히 큰 메모리를 할당하면 이전에 언급한 오류가 발생하여 이 기술을 방지하는 것을 볼 수 있습니다: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

이것은 실제로 매우 기본적인 개념입니다. 정렬되지 않은 bin의 청크는 bin을 만들기 위해 이중 포인터를 가지게 됩니다. 정렬되지 않은 bin의 첫 번째 청크는 실제로 **FD** 및 **BK** 링크가 **메인 아레나(libc)의 일부를 가리키게 됩니다**.\
따라서, **unsorted bin에 청크를 넣고 읽을 수 있게 하거나** (free 후 사용) **적어도 1개의 포인터를 덮어쓰지 않고 다시 할당하여** 그 후 **읽을 수 있다면**, **libc 정보 누출**이 가능합니다.

## 참조 및 다른 예제

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* 글로벌 변수를 4869보다 큰 값으로 덮어쓰기 위한 목표이며, PIE가 활성화되지 않았습니다.
* 임의의 크기의 청크를 생성할 수 있으며 원하는 크기의 힙 오버플로우가 있습니다.
* 공격은 3개의 청크를 생성하여 시작됩니다: 오버플로우를 악용하기 위한 청크0, 오버플로우될 청크1 및 이전 청크를 합병하지 않도록 하는 청크2.
* 그런 다음, 청크1이 해제되고 청크0이 오버플로우되어 `bk` 포인터가 `bk = magic - 0x10`를 가리키도록 합니다.
* 그런 다음, 청크3이 청크1과 동일한 크기로 할당되어 정렬되지 않은 bin 공격을 트리거하고 글로벌 변수의 값을 수정하여 플래그를 획득할 수 있게 합니다.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* 병합 함수는 두 인덱스가 동일한 경우 다시 할당하고 그 후에 해제하지만 사용할 수 있는 그 해제된 영역을 가리키는 포인터를 반환합니다.
* 따라서, **2개의 청크가 생성**됩니다: **자신과 병합될 청크0** 및 이전 청크와 병합되지 않도록 하는 청크1. 그런 다음, **청크0으로 병합 함수가 두 번 호출**되어 사용 후 해제가 발생합니다.
* 그런 다음, **`view`** 함수가 사용 후 해제된 청크의 인덱스인 2로 호출되어 **libc 주소를 누출**합니다.
* 바이너리가 **`global_max_fast`**보다 큰 크기의 malloc만 허용하도록 보호되어 있으므로 fastbin을 사용하지 않으므로 unsorted bin 공격을 사용하여 글로벌 변수 `global_max_fast`를 덮어쓸 수 있습니다.
* 그런 다음, 사용 후 해제된 포인터인 인덱스 2로 편집 함수를 호출하여 `bk` 포인터를 `p64(global_max_fast-0x10)`을 가리키도록 덮어쓰고, 이전에 손상된 해제 주소(0x20)를 사용하여 새로운 청크를 만들면 **unsorted bin 공격이 트리거**되어 `global_max_fast`를 덮어쓰고 매우 큰 값으로 설정하여 이제 fast bin에 청크를 생성할 수 있습니다.
* 이제 **fast bin 공격**이 수행됩니다:
* 먼저 **`__free_hook` 위치에 크기가 200인 fast 청크로 작업할 수 있다는 것을 발견**했습니다:
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* 만약 우리가 이 위치에 크기 0x200의 빠른 청크를 얻는다면, 실행될 함수 포인터를 덮어쓸 수 있을 것입니다.
* 이를 위해 크기 `0xfc`의 새로운 청크가 생성되고 병합된 함수가 해당 포인터로 두 번 호출되어, 우리는 빠른 빈에서 크기가 `0xfc*2 = 0x1f8`인 해제된 청크를 가리키는 포인터를 얻습니다.
* 그런 다음, 이 청크에서 **`fd`** 주소를 이전 **`__free_hook`** 함수를 가리키도록 수정하기 위해 편집 함수가 호출됩니다.
* 그런 다음, 크기가 `0x1f8`인 청크가 생성되어 빠른 빈에서 이전에 쓸모없던 청크를 검색하고, 다른 크기가 `0x1f8`인 청크가 **`__free_hook`**에 있는 빠른 빈 청크를 얻어 **`system`** 함수의 주소로 덮어씁니다.
* 마지막으로 `/bin/sh\x00` 문자열이 포함된 청크가 삭제 함수를 호출하여 해제되고, **`__free_hook`** 함수가 트리거되어 `/bin/sh\x00`을 매개변수로 사용하여 시스템을 가리킵니다.
