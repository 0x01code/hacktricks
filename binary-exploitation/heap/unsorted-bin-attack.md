# Ataque ao Bin N√£o Ordenado

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

Para obter mais informa√ß√µes sobre o que √© um bin n√£o ordenado, consulte esta p√°gina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

As listas n√£o ordenadas s√£o capazes de escrever o endere√ßo para `unsorted_chunks (av)` no endere√ßo `bk` do chunk. Portanto, se um atacante puder **modificar o endere√ßo do ponteiro bk** em um chunk dentro do bin n√£o ordenado, ele poder√° **escrever esse endere√ßo em um endere√ßo arbitr√°rio** que poderia ser √∫til para vazar endere√ßos de libc ou contornar algumas defesas.

Portanto, basicamente, esse ataque permite **sobrescrever um endere√ßo arbitr√°rio com um n√∫mero grande** (um endere√ßo que poderia ser um endere√ßo de heap ou um endere√ßo de libc) como algum endere√ßo de pilha que poderia ser vazado ou alguma restri√ß√£o como a vari√°vel global **`global_max_fast`** para permitir a cria√ß√£o de bins r√°pidos com tamanhos maiores (e passar de um ataque ao bin n√£o ordenado para um ataque ao bin r√°pido).

{% hint style="success" %}
Ao analisar o exemplo fornecido em [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e usando 0x4000 e 0x5000 em vez de 0x400 e 0x500 como tamanhos de chunk (para evitar tcaches), √© poss√≠vel ver que **atualmente** o erro **`malloc(): unsorted double linked list corrupted`** √© acionado.

Portanto, esse ataque ao bin n√£o ordenado agora (entre outras verifica√ß√µes) tamb√©m requer ser capaz de corrigir a lista duplamente encadeada para que isso seja contornado `victim->bck->fd == victim` ou n√£o `victim->fd == av (arena)`. O que significa que o endere√ßo onde queremos escrever deve ter o endere√ßo do chunk falso em sua posi√ß√£o `fd` e que o `fd` do chunk falso est√° apontando para a arena.
{% endhint %}

{% hint style="danger" %}
Observe que esse ataque corrompe o bin n√£o ordenado (portanto, tamb√©m o pequeno e o grande). Portanto, agora s√≥ podemos **usar aloca√ß√µes do bin r√°pido** (um programa mais complexo pode fazer outras aloca√ß√µes e travar), e para acionar isso devemos **alocar o mesmo tamanho ou o programa travar√°.**

Observe que fazer **`global_max_fast`** pode ajudar nesse caso, confiando que o bin r√°pido ser√° capaz de lidar com todas as outras aloca√ß√µes at√© que a explora√ß√£o seja conclu√≠da.
{% endhint %}

O c√≥digo de [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) explica muito bem, embora se voc√™ modificar as aloca√ß√µes para alocar mem√≥ria grande o suficiente para n√£o terminar em um tcache, voc√™ ver√° que o erro mencionado anteriormente aparece, impedindo essa t√©cnica: **`malloc(): unsorted double linked list corrupted`**

## Refer√™ncias e Outros exemplos

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* O objetivo √© sobrescrever uma vari√°vel global com um valor maior que 4869 para ser poss√≠vel obter a flag e o PIE n√£o estar habilitado.
* √â poss√≠vel gerar chunks de tamanhos arbitr√°rios e h√° um estouro de heap com o tamanho desejado.
* O ataque come√ßa criando 3 chunks: chunk0 para abusar do estouro, chunk1 para ser estourado e chunk2 para que o chunk superior n√£o consolide os anteriores.
* Em seguida, o chunk1 √© liberado e o chunk0 √© estourado para que o ponteiro `bk` do chunk1 aponte para: `bk = magic - 0x10`
* Em seguida, o chunk3 √© alocado com o mesmo tamanho que o chunk1, o que acionar√° o ataque ao bin n√£o ordenado e modificar√° o valor da vari√°vel global, tornando poss√≠vel obter a flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* A fun√ß√£o de mesclagem √© vulner√°vel porque se ambos os √≠ndices passados forem iguais, ele realocar√° e em seguida liberar√°, mas retornando um ponteiro para aquela regi√£o liberada que pode ser usada.
* Portanto, **s√£o criados 2 chunks**: **chunk0** que ser√° mesclado consigo mesmo e chunk1 para evitar a consolida√ß√£o com o chunk superior. Em seguida, a **fun√ß√£o de mesclagem √© chamada com o chunk0** duas vezes, o que causar√° um uso ap√≥s a libera√ß√£o.
* Em seguida, a fun√ß√£o **`view`** √© chamada com o √≠ndice 2 (que √© o √≠ndice do chunk de uso ap√≥s a libera√ß√£o), que ir√° **vazar um endere√ßo de libc**.
* Como o bin√°rio tem prote√ß√µes para alocar apenas tamanhos maiores que **`global_max_fast`** para que nenhum fastbin seja usado, um ataque ao bin n√£o ordenado ser√° usado para sobrescrever a vari√°vel global `global_max_fast`.
* Em seguida, √© poss√≠vel chamar a fun√ß√£o de edi√ß√£o com o √≠ndice 2 (o ponteiro de uso ap√≥s a libera√ß√£o) e sobrescrever o ponteiro `bk` para apontar para `p64(global_max_fast-0x10)`. Em seguida, criar um novo chunk usar√° o endere√ßo de libera√ß√£o comprometido anteriormente (0x20) e **acionar√° o ataque ao bin n√£o ordenado** sobrescrevendo o `global_max_fast` com um valor muito grande, permitindo agora criar chunks em bins r√°pidos.
* Agora um **ataque ao fast bin** √© realizado:
* Primeiramente, √© descoberto que √© poss√≠vel trabalhar com **chunks r√°pidos de tamanho 200** na localiza√ß√£o de **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se conseguirmos obter um chunk r√°pido de tamanho 0x200 nessa localiza√ß√£o, ser√° poss√≠vel sobrescrever um ponteiro de fun√ß√£o que ser√° executado
* Para isso, √© criado um novo chunk de tamanho `0xfc` e a fun√ß√£o de mesclagem √© chamada com esse ponteiro duas vezes, dessa forma obtemos um ponteiro para um chunk liberado de tamanho `0xfc*2 = 0x1f8` no fast bin.
* Em seguida, a fun√ß√£o de edi√ß√£o √© chamada nesse chunk para modificar o endere√ßo **`fd`** desse fast bin para apontar para a fun√ß√£o anterior de **`__free_hook`**.
* Em seguida, um chunk com tamanho `0x1f8` √© criado para recuperar do fast bin o chunk in√∫til anterior, ent√£o outro chunk de tamanho `0x1f8` √© criado para obter um chunk do fast bin no **`__free_hook`** que √© sobrescrito com o endere√ßo da fun√ß√£o **`system`**.
* E finalmente um chunk contendo a string `/bin/sh\x00` √© liberado chamando a fun√ß√£o de exclus√£o, acionando a fun√ß√£o **`__free_hook`** que aponta para system com `/bin/sh\x00` como par√¢metro.
