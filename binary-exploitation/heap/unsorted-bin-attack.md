# Sıralanmamış Bin Saldırısı

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Sıralanmamış bir liste, bir parçanın `bk` adresindeki `sıralanmamış_parçalar (av)` adresini yazabilmektedir. Bu nedenle, bir saldırgan bir parçanın içindeki `bk` işaretçisinin adresini değiştirebilirse, bu adresi rastgele bir adrese yazabilir ve bu, bir libc adresini sızdırmak veya bazı savunmaları atlamak için yardımcı olabilir.

Yani, temelde bu saldırı, bir adrese büyük bir sayı (bir heap adresi veya bir libc adresi olabilecek bir adres) yazmayı sağladı. Bu, sızdırılabilecek bir yığın adresi veya global değişken olan `global_max_fast` gibi bir kısıtlamayı geçmek için hızlı binlerin daha büyük boyutlarında hızlı binler oluşturmasına izin vermek için kullanılabilir (ve sıralanmamış bir bin saldırısından hızlı bir bin saldırısına geçmek).

{% hint style="success" %}
[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) adresinde sağlanan örneğe bakarak ve 0x400 ve 0x500 yerine 0x4000 ve 0x5000 kullanarak (tcaches'i önlemek için) günümüzde **`malloc(): sıralanmamış çift bağlantılı liste bozuldu`** hatasının tetiklendiğini görebilirsiniz.

Bu nedenle, bu sıralanmamış bin saldırısı artık (diğer kontroller arasında) çift bağlantılı listeyi düzeltme yeteneğine de sahip olmalıdır, böylece bu, `victim->bck->fd == victim` veya `victim->fd == av (arena)` olmalıdır. Bu, yazmak istediğimiz adresin, sahte parçanın `fd` konumunda olması gerektiği ve sahte parçanın `fd`nin arenaya işaret etmesi gerektiği anlamına gelir.
{% endhint %}

{% hint style="danger" %}
Bu saldırı sıralanmamış bin'i bozar (bu nedenle küçük ve büyük de). Bu nedenle şimdi sadece **hızlı binlerden tahsisler kullanabiliriz** (daha karmaşık bir program başka tahsisler yapabilir ve çökebilir) ve bunu tetiklemek için **aynı boyutta tahsis yapmalıyız veya program çökecektir.**

Bu durumda **`global_max_fast`** yapmak, hızlı binin tüm diğer tahsislerle ilgileneceğine güvenmek bu durumda yardımcı olabilir ve saldırı tamamlandığında hızlı bir binde parçalar oluşturulabilir.
{% endhint %}

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) tarafından sağlanan kod bunu çok iyi açıklıyor, ancak malloc'ları tcache'e sona ermeyecek kadar büyük bir bellek ayırmak için değiştirirseniz, önce bahsedilen hata ortaya çıkarak bu tekniği engellediğini görebilirsiniz: **`malloc(): sıralanmamış çift bağlantılı liste bozuldu`**

## Sıralanmamış Bin Bilgi Sızdırma Saldırısı

Bu aslında çok temel bir kavramdır. Sıralanmamış bindeki parçalar, bin oluşturmak için çift işaretçilere sahip olacaklardır. Sıralanmamış bindeki ilk parça aslında **FD** ve **BK** bağlantılarını **ana arenanın (libc)** bir kısmına işaret edecek şekilde olacaktır.\
Bu nedenle, bir parçayı sıralanmamış bir bine yerleştirebilir ve onu okuyabilirsiniz (kullanımdan sonra serbest bırakma) veya en azından 1 işaretçiyi üzerine yazmadan tekrar tahsis edebilir ve ardından onu **okuyabilirseniz**, bir **libc bilgi sızıntısı** elde edebilirsiniz.

## Referanslar ve Diğer Örnekler

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Amacı, global bir değişkeni 4869'dan büyük bir değerle üzerine yazmaktır, böylece bayrağı almak mümkün olur ve PIE etkin değildir.
* Keyfi boyutlarda parçalar oluşturulabilir ve istenen boyutta bir yığın taşması vardır.
* Saldırı, taşmanın kötüye kullanılması için 3 parça oluşturarak başlar: taşmayı kötüye kullanmak için chunk0, taşınacak chunk1 ve önceki parçaları birleştirmemesi için chunk2.
* Ardından, chunk1 serbest bırakılır ve chunk0 taşmaya uğratılır, böylece chunk1'in `bk` işaretçisi şuna işaret eder: `bk = magic - 0x10`
* Ardından, chunk1 ile aynı boyutta chunk3 tahsis edilir, bu da sıralanmamış bin saldırısını tetikler ve global değişkenin değerini değiştirir, bayrağı almayı mümkün kılar.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Birleştirme işlevi savunmasızdır çünkü geçilen her iki dizin de aynıysa onu yeniden boyutlandırır ve ardından serbest bırakır ancak kullanılabilecek bir serbest bırakılmış bölgeye bir işaretçi döndürür.
* Bu nedenle, **2 parça oluşturulur**: **chunk0** kendisiyle birleştirilecek ve üst parçayla birleşmesini önlemek için chunk1. Ardından, **birleştirme işlevi chunk0 ile iki kez çağrılır**, bu da kullanımdan sonra serbest bırakma hatasına neden olur.
* Ardından, **`view`** işlevi kullanımdan sonra serbest bırakılan parçanın dizini olan 2 ile çağrılır, bu da bir libc adresi **sızdırır**.
* Binary, sadece **`global_max_fast`**'tan büyük boyutlarda malloc yapmasına izin veren korumalara sahip olduğundan hiçbir fastbin kullanılmaz, bu nedenle sıralanmamış bin saldırısı, global değişken `global_max_fast`'ı üzerine yazmak için kullanılacaktır.
* Ardından, kullanımdan sonra serbest bırakılan işaretçi olan 2 diziniyle edit işlevi çağrılabilir ve `bk` işaretçisinin `p64(global_max_fast-0x10)`'a işaret etmesi sağlanabilir. Ardından, yeni bir parça oluşturulduğunda önceki tehlikeye atıfta bulunan serbest bırakma adresi (0x20) **sıralanmamış bin saldırısını tetikleyecektir**, `global_max_fast`'ı çok büyük bir değerle üzerine yazarak artık hızlı binlerde parçalar oluşturulabilir.
* Şimdi bir **hızlı bin saldırısı** gerçekleştirilir:
* İlk olarak, **`__free_hook`** konumunda **200 boyutunda hızlı parçalarla çalışılabileceği keşfedilir**:
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Eğer bu konumda boyutu 0x200 olan hızlı bir parça elde edebilirsek, çalıştırılacak bir işlev işaretçisini üzerine yazmak mümkün olacaktır.
* Bunun için, boyutu `0xfc` olan yeni bir parça oluşturulur ve birleştirilmiş işlev bu işaretçiyle iki kez çağrılır, bu şekilde hızlı bin içinde boyutu `0xfc*2 = 0x1f8` olan bir serbest bırakılmış parça işaretçisi elde edilir.
* Ardından, bu parçada **`fd`** adresini önceki **`__free_hook`** işlevine işaret etmek için düzenleme işlevi çağrılır.
* Daha sonra, hızlı bin içindeki önceki gereksiz parçayı almak için boyutu `0x1f8` olan bir parça oluşturulur, böylece **`__free_hook`** içinde **`system`** işlevinin adresiyle üzerine yazılmış bir hızlı bin parçası alınır.
* Ve son olarak, `/bin/sh\x00` dizesini içeren bir parça, silme işlevini çağırarak serbest bırakılır, **`__free_hook`** işlevini tetikleyerek `/bin/sh\x00` parametresiyle sistem işlevine işaret eder.

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) arasında
* 💬 **Discord grubuna** katılın (https://discord.gg/hRep4RUj7f) veya **telegram grubuna** (https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'ı takip edin.
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
