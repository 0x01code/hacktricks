# Attacco al Bin non ordinato

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di base

Per ulteriori informazioni su cosa sia un bin non ordinato, controlla questa pagina:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Le liste non ordinate sono in grado di scrivere l'indirizzo in `unsorted_chunks (av)` nell'indirizzo `bk` del chunk. Pertanto, se un attaccante pu√≤ **modificare l'indirizzo del puntatore bk** in un chunk all'interno del bin non ordinato, potrebbe essere in grado di **scrivere quell'indirizzo in un indirizzo arbitrario** che potrebbe essere utile per ottenere un indirizzo libc o bypassare alcune difese.

Quindi, fondamentalmente, questo attacco permette di **sovrascrivere un indirizzo arbitrario con un numero grande** (un indirizzo che potrebbe essere un indirizzo di heap o un indirizzo libc) come un indirizzo di stack che potrebbe essere rilevato o una restrizione come la variabile globale **`global_max_fast`** per consentire di creare bin veloci con dimensioni maggiori (e passare da un attacco al bin non ordinato a un attacco al bin veloce).

{% hint style="success" %}
Guardando l'esempio fornito in [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) e utilizzando 0x4000 e 0x5000 invece di 0x400 e 0x500 come dimensioni dei chunk (per evitare i tcaches) √® possibile vedere che **oggi** l'errore **`malloc(): unsorted double linked list corrupted`** viene attivato.

Pertanto, questo attacco al bin non ordinato ora (tra altri controlli) richiede anche di essere in grado di correggere la lista doppiamente collegata in modo che venga bypassato `victim->bck->fd == victim` o no `victim->fd == av (arena)`. Ci√≤ significa che l'indirizzo in cui vogliamo scrivere deve avere l'indirizzo del chunk falso nella sua posizione `fd` e che il `fd` del chunk falso punti all'arena.
{% endhint %}

{% hint style="danger" %}
Nota che questo attacco corrompe il bin non ordinato (quindi anche quello piccolo e grande). Quindi possiamo **usare solo assegnazioni dal bin veloce ora** (un programma pi√π complesso potrebbe fare altre assegnazioni e bloccarsi), e per attivare questo dobbiamo **assegnare la stessa dimensione o il programma si bloccher√†.**

Nota che rendere **`global_max_fast`** potrebbe aiutare in questo caso fidandosi che il bin veloce sar√† in grado di gestire tutte le altre assegnazioni fino a quando l'exploit non √® completato.
{% endhint %}

Il codice di [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) lo spiega molto bene, anche se se si modificano le malloc per allocare memoria sufficientemente grande in modo che non finisca in un tcache, si pu√≤ vedere che compare l'errore precedentemente menzionato: **`malloc(): unsorted double linked list corrupted`**

## Attacco di Infoleak al Bin non ordinato

Questo √® in realt√† un concetto molto basilare. I chunk nel bin non ordinato avranno puntatori doppi per creare il bin. Il primo chunk nel bin non ordinato avr√† effettivamente i collegamenti **FD** e **BK** **che puntano a una parte dell'arena principale (libc)**.\
Pertanto, se puoi **mettere un chunk all'interno di un bin non ordinato e leggerlo** (uso dopo la liberazione) o **allocarlo di nuovo senza sovrascrivere almeno 1 dei puntatori** per poi **leggerlo**, puoi ottenere un **leak di info sulla libc**.

## Riferimenti e Altri esempi

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* L'obiettivo √® sovrascrivere una variabile globale con un valore maggiore di 4869 in modo da poter ottenere il flag e PIE non √® abilitato.
* √à possibile generare chunk di dimensioni arbitrarie e c'√® un overflow di heap con la dimensione desiderata.
* L'attacco inizia creando 3 chunk: chunk0 per sfruttare l'overflow, chunk1 per essere sovrascritto e chunk2 in modo che il chunk superiore non consolidi quelli precedenti.
* Quindi, chunk1 viene liberato e chunk0 viene sovrascritto in modo che il puntatore `bk` di chunk1 punti a: `bk = magic - 0x10`
* Quindi, chunk3 viene allocato con la stessa dimensione di chunk1, il che attiver√† l'attacco al bin non ordinato e modificher√† il valore della variabile globale, rendendo possibile ottenere il flag.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* La funzione di merge √® vulnerabile perch√© se entrambi gli indici passati sono gli stessi, realloc su di esso e poi lo libera ma restituisce un puntatore a quella regione liberata che pu√≤ essere utilizzato.
* Pertanto, **vengono creati 2 chunk**: **chunk0** che verr√† unito con se stesso e chunk1 per evitare la consolidazione con il chunk superiore. Quindi, la **funzione di merge viene chiamata con chunk0** due volte, causando un uso dopo la liberazione.
* Quindi, la funzione **`view`** viene chiamata con l'indice 2 (che √® l'indice del chunk uso dopo la liberazione), che **fa trapelare un indirizzo libc**.
* Poich√© il binario ha protezioni per allocare solo dimensioni maggiori di **`global_max_fast`** quindi nessun fastbin viene utilizzato, verr√† utilizzato un attacco al bin non ordinato per sovrascrivere la variabile globale `global_max_fast`.
* Quindi, √® possibile chiamare la funzione di modifica con l'indice 2 (il puntatore uso dopo la liberazione) e sovrascrivere il puntatore `bk` per puntare a `p64(global_max_fast-0x10)`. Quindi, creando un nuovo chunk user√† l'indirizzo di free compromesso in precedenza (0x20) attiver√† l'attacco al bin non ordinato sovrascrivendo il `global_max_fast` con un valore molto grande, consentendo ora di creare chunk nei bin veloci.
* Ora viene eseguito un **attacco al bin veloce**:
* Prima di tutto si scopre che √® possibile lavorare con **chunk veloci di dimensione 200** nella posizione **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Se riusciamo ad ottenere un fast chunk di dimensione 0x200 in questa posizione, sar√† possibile sovrascrivere un puntatore a funzione che verr√† eseguito
* Per fare ci√≤, viene creato un nuovo chunk di dimensione `0xfc` e la funzione merged viene chiamata con quel puntatore due volte, in questo modo otteniamo un puntatore a un chunk liberato di dimensione `0xfc*2 = 0x1f8` nel fast bin.
* Successivamente, la funzione edit viene chiamata in questo chunk per modificare l'indirizzo **`fd`** di questo fast bin in modo che punti alla precedente funzione **`__free_hook`**.
* Poi, viene creato un chunk di dimensione `0x1f8` per recuperare dal fast bin il chunk inutile precedente, quindi viene creato un altro chunk di dimensione `0x1f8` per ottenere un chunk fast bin nel **`__free_hook`** che viene sovrascritto con l'indirizzo della funzione **`system`**.
* Infine, viene liberato un chunk contenente la stringa `/bin/sh\x00` chiamando la funzione delete, attivando la funzione **`__free_hook`** che punta a system con `/bin/sh\x00` come parametro.

<details>

<summary><strong>Impara l'hacking su AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
