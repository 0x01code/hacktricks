# Unsorted Bin Attack

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

F√ºr weitere Informationen dar√ºber, was ein unsortierter Bin ist, siehe diese Seite:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Unsortierte Listen k√∂nnen die Adresse von `unsorted_chunks (av)` in die `bk`-Adresse des Chunks schreiben. Daher k√∂nnte ein Angreifer, wenn er die Adresse des bk-Zeigers in einem Chunk im unsortierten Bin **√§ndern kann**, in der Lage sein, **diese Adresse an eine beliebige Adresse zu schreiben**, was hilfreich sein k√∂nnte, um eine libc-Adresse zu leaken oder einige Verteidigungen zu umgehen.

Also erm√∂glichte dieser Angriff im Grunde genommen, **eine beliebige Adresse mit einer gro√üen Zahl zu √ºberschreiben** (eine Adresse, die eine Heap-Adresse oder eine libc-Adresse sein k√∂nnte), wie z.B. eine Stack-Adresse, die geleakt werden k√∂nnte, oder eine Einschr√§nkung wie die globale Variable **`global_max_fast`**, um die Erstellung von Fast-Bin-Bins mit gr√∂√üeren Gr√∂√üen zu erm√∂glichen (und von einem unsortierten Bin-Angriff zu einem Fast-Bin-Angriff √ºberzugehen).

{% hint style="success" %}
Wenn Sie sich das Beispiel unter [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) ansehen und 0x4000 und 0x5000 anstelle von 0x400 und 0x500 als Chunksgr√∂√üen verwenden (um tcaches zu vermeiden), ist es m√∂glich festzustellen, dass heutzutage der Fehler **`malloc(): unsorted double linked list corrupted`** ausgel√∂st wird.

Daher erfordert dieser unsortierte Bin-Angriff jetzt (unter anderem √úberpr√ºfungen) auch, dass die doppelt verkettete Liste korrigiert werden kann, sodass dies umgangen wird `victim->bck->fd == victim` oder nicht `victim->fd == av (arena)`. Das bedeutet, dass die Adresse, an der wir schreiben m√∂chten, die Adresse des gef√§lschten Chunks an ihrer `fd`-Position haben muss und dass der gef√§lschte Chunk `fd` auf die Arena zeigt.
{% endhint %}

{% hint style="danger" %}
Beachten Sie, dass dieser Angriff den unsortierten Bin besch√§digt (und damit auch den kleinen und gro√üen). Daher k√∂nnen wir jetzt nur noch **Zuweisungen aus dem Fast Bin verwenden** (ein komplexeres Programm k√∂nnte andere Zuweisungen vornehmen und abst√ºrzen), und um dies auszul√∂sen, m√ºssen wir **die gleiche Gr√∂√üe zuweisen, oder das Programm wird abst√ºrzen**.

Beachten Sie, dass es in diesem Fall hilfreich sein kann, **`global_max_fast`** zu machen, in der Annahme, dass der Fast Bin in der Lage sein wird, sich um alle anderen Zuweisungen zu k√ºmmern, bis das Exploit abgeschlossen ist.
{% endhint %}

Der Code von [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) erkl√§rt es sehr gut, obwohl, wenn Sie die mallocs so √§ndern, dass sie Speicher in ausreichender Gr√∂√üe zuweisen, sodass sie nicht in einem tcache enden, k√∂nnen Sie feststellen, dass der zuvor erw√§hnte Fehler auftritt und diese Technik verhindert: **`malloc(): unsorted double linked list corrupted`**

## Referenzen & Weitere Beispiele

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Das Ziel ist es, eine globale Variable mit einem Wert gr√∂√üer als 4869 zu √ºberschreiben, um die Flagge zu erhalten, wobei PIE nicht aktiviert ist.
* Es ist m√∂glich, Chunks beliebiger Gr√∂√üe zu generieren, und es gibt einen Heap-√úberlauf mit der gew√ºnschten Gr√∂√üe.
* Der Angriff beginnt mit der Erstellung von 3 Chunks: Chunk0, um den √úberlauf auszunutzen, Chunk1, der √ºberlaufen wird, und Chunk2, damit der Top-Chunk die vorherigen nicht konsolidiert.
* Dann wird Chunk1 freigegeben und Chunk0 wird so √ºberlaufen, dass der `bk`-Zeiger von Chunk1 auf `bk = magic - 0x10` zeigt.
* Anschlie√üend wird Chunk3 mit derselben Gr√∂√üe wie Chunk1 allokiert, was den unsortierten Bin-Angriff ausl√∂st und den Wert der globalen Variablen √§ndert, sodass es m√∂glich ist, die Flagge zu erhalten.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die Merge-Funktion ist anf√§llig, weil sie, wenn beide √ºbergebenen Indizes gleich sind, darauf reallociert und dann freigibt, aber einen Zeiger auf diesen freigegebenen Bereich zur√ºckgibt, der verwendet werden kann.
* Daher werden **2 Chunks erstellt**: **Chunk0**, der mit sich selbst zusammengef√ºhrt wird, und Chunk1, um eine Konsolidierung mit dem Top-Chunk zu verhindern. Dann wird die **Merge-Funktion zweimal mit Chunk0** aufgerufen, was zu einem Use-After-Free f√ºhrt.
* Dann wird die **`view`**-Funktion mit Index 2 aufgerufen (der Index des Use-After-Free-Chunks), was dazu f√ºhrt, dass eine libc-Adresse geleakt wird.
* Da das Bin√§rprogramm Schutzmechanismen hat, um nur Gr√∂√üen gr√∂√üer als **`global_max_fast`** zu mallocen, sodass kein Fastbin verwendet wird, wird ein unsortierter Bin-Angriff verwendet, um die globale Variable `global_max_fast` zu √ºberschreiben.
* Dann ist es m√∂glich, die Edit-Funktion mit dem Index 2 (dem Use-After-Free-Zeiger) aufzurufen und den `bk`-Zeiger so zu √ºberschreiben, dass er auf `p64(global_max_fast-0x10)` zeigt. Anschlie√üend wird durch das Erstellen eines neuen Chunks die zuvor kompromittierte freie Adresse (0x20) verwendet, um den unsortierten Bin-Angriff auszul√∂sen und das `global_max_fast` zu √ºberschreiben, was eine sehr gro√üe Zahl erm√∂glicht, um jetzt Chunks in Fastbins zu erstellen.
* Nun wird ein **Fastbin-Angriff** durchgef√ºhrt:
* Zun√§chst wird festgestellt, dass es m√∂glich ist, mit schnellen **Chunks der Gr√∂√üe 200** an der Stelle des **`__free_hook`** zu arbeiten:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Wenn es gelingt, einen schnellen Chunk der Gr√∂√üe 0x200 an dieser Stelle zu erhalten, ist es m√∂glich, einen Funktionszeiger zu √ºberschreiben, der ausgef√ºhrt wird.
* Dazu wird ein neuer Chunk der Gr√∂√üe `0xfc` erstellt und die Merge-Funktion wird zweimal mit diesem Zeiger aufgerufen, wodurch ein Zeiger auf einen freigegebenen Chunk der Gr√∂√üe `0xfc*2 = 0x1f8` im Fastbin erhalten wird.
* Dann wird die Edit-Funktion mit diesem Chunk aufgerufen, um die **`fd`**-Adresse dieses Fastbins so zu √§ndern, dass sie auf die vorherige **`__free_hook`**-Funktion zeigt.
* Dann wird ein Chunk mit der Gr√∂√üe `0x1f8` erstellt, um aus dem Fast Bin den vorherigen nutzlosen Chunk abzurufen, sodass ein weiterer Chunk mit der Gr√∂√üe `0x1f8` erstellt wird, um einen Fast Bin Chunk im **`__free_hook`** zu erhalten, der mit der Adresse der **`system`** Funktion √ºberschrieben ist.
* Und schlie√ülich wird ein Chunk mit dem String `/bin/sh\x00` freigegeben, indem die L√∂schfunktion aufgerufen wird, wodurch die **`__free_hook`** Funktion ausgel√∂st wird, die auf system mit `/bin/sh\x00` als Parameter verweist.

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
