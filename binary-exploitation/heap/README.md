# Σωρός

## Βασικά για τον Σωρό

Ο σωρός είναι βασικά το μέρος όπου ένα πρόγραμμα θα μπορεί να αποθηκεύει δεδομένα όταν ζητά δεδομένα καλώντας συναρτήσεις όπως **`malloc`**, `calloc`... Επιπλέον, όταν αυτή η μνήμη δεν χρειάζεται πλέον, γίνεται διαθέσιμη καλώντας τη συνάρτηση **`free`**.

Όπως φαίνεται, βρίσκεται αμέσως μετά από το σημείο όπου φορτώνεται το δυαδικό στη μνήμη (ελέγξτε την ενότητα `[heap]`):

<figure><img src="../../.gitbook/assets/image (1241).png" alt=""><figcaption></figcaption></figure>

### Βασική Δέσμη Εκχώρησης

Όταν ζητείται να αποθηκευτεί κάποιο δεδομένο στο σωρό, κάποιος χώρος του σωρού του εκχωρείται. Αυτός ο χώρος θα ανήκει σε μια δέσμη και μόνο τα ζητηθέντα δεδομένα + ο χώρος των κεφαλίδων της δέσμης + η ελάχιστη μετατόπιση μεγέθους δέσμης θα είναι κρατημένα για το κομμάτι. Ο στόχος είναι να κρατηθεί όσο το δυνατόν λιγότερη μνήμη χωρίς να γίνει περίπλοκο να βρεθεί πού βρίσκεται κάθε κομμάτι. Γι' αυτό, χρησιμοποιείται η πληροφορία μεταδεδομένων κομματιών για να γνωρίζουμε πού βρίσκεται κάθε χρησιμοποιούμενο/ελεύθερο κομμάτι.

Υπάρχουν διαφορετικοί τρόποι για την εκχώρηση χώρου κυρίως ανάλογα με τη χρησιμοποιούμενη δέσμη, αλλά μια γενική μεθοδολογία είναι η ακόλουθη:

* Το πρόγραμμα ξεκινάει ζητώντας συγκεκριμένη ποσότητα μνήμης.
* Αν στη λίστα των κομματιών υπάρχει κάποιο διαθέσιμο αρκετά μεγάλο για να καλύψει το αίτημα, θα χρησιμοποιηθεί.
* Αυτό μπορεί ακόμη να σημαίνει ότι μέρος του διαθέσιμου κομματιού θα χρησιμοποιηθεί για αυτό το αίτημα και το υπόλοιπο θα προστεθεί στη λίστα των κομματιών
* Αν δεν υπάρχει διαθέσιμο κομμάτι στη λίστα αλλά υπάρχει ακόμη χώρος στην εκχωρημένη μνήμη του σωρού, ο διαχειριστής του σωρού δημιουργεί ένα νέο κομμάτι
* Αν δεν υπάρχει αρκετός χώρος στο σωρό για να εκχωρηθεί το νέο κομμάτι, ο διαχειριστής του σωρού ζητά από τον πυρήνα να επεκτείνει τη μνήμη που εκχωρείται στο σωρό και στη συνέχεια να χρησιμοποιήσει αυτή τη μνήμη για τη δημιουργία του νέου κομματιού
* Αν αποτύχει τα παραπάνω, το `malloc` επιστρέφει null.

Σημειώστε ότι αν η ζητούμενη **μνήμη ξεπεράσει ένα κατώτατο όριο**, θα χρησιμοποιηθεί το **`mmap`** για να χαρτογραφήσει τη ζητούμενη μνήμη.

### Αρένες

Σε **πολυνηματικές** εφαρμογές, ο διαχειριστής του σωρού πρέπει να αποτρέψει τις **συνθήκες ανταγωνισμού** που θα μπορούσαν να οδηγήσουν σε κολάπτες. Αρχικά, αυτό επιτυγχάνονταν χρησιμοποιώντας ένα **καθολικό κλειδαριά** για να εξασφαλίσει ότι μόνο ένα νήμα θα μπορούσε να έχει πρόσβαση στο σωρό ταυτόχρονα, αλλά αυτό προκαλούσε **προβλήματα απόδοσης** λόγω του φραγμού που προκαλούσε η κλειδαριά.

Για να αντιμετωπίσει αυτό, ο αναθέτης σωρού ptmalloc2 εισήγαγε "αρένες", όπου **κάθε αρένα** λειτουργεί ως ένας **ξεχωριστός σωρός** με τις **δικές της** δομές **δεδομένων** και **κλειδαριά**, επιτρέποντας σε πολλά νήματα να εκτελούν λειτουργίες σωρού χωρίς να επηρεάζουν ο ένας τον άλλο, όσον αφορά τις αρένες.

Η προεπιλεγμένη "κύρια" αρένα χειρίζεται τις λειτουργίες σωρού για μονονηματικές εφαρμογές. Όταν προστίθενται **νέα νήματα**, ο διαχειριστής του σωρού αναθέτει σε αυτά **δευτερεύουσες αρένες** για να μειώσει τον ανταγωνισμό. Πρώτα προσπαθεί να συνδέσει κάθε νέο νήμα σε μια αχρησιμοποίητη αρένα, δημιουργώντας νέες αν χρειαστεί, μέχρι ένα όριο 2 φορές του αριθμού των πυρήνων CPU για συστήματα 32-bit και 8 φορές για συστήματα 64-bit. Αφού επιτευχθεί το όριο, τα νήματα πρέπει να μοιράζονται αρένες, οδηγώντας σε πιθανό ανταγωνισμό.

Αντίθετα με την κύρια αρένα, η οποία επεκτείνεται χρησιμοποιώντας την κλήση συστήματος `brk`, οι δευτερεύουσες αρένες δημιουργούν "υποσωρούς" χρησιμοποιώντας `mmap` και `mprotect` για να προσομοιώσουν τη συμπεριφορά του σωρού, επιτρέποντας ευελιξία στη διαχείριση μνήμης για πολυνηματικές λειτουργίες.

### Υποσωροί

Οι υποσωροί λειτουργούν ως αποθεματικά μνήμης για τις δευτερεύουσες αρένες σε πολυνηματικές εφαρμογές, επιτρέποντάς τους να αυξάνονται και να διαχειρίζονται τις δικές τους περιοχές σωρού ξεχωριστά από τον κύριο σωρό. Εδώ είναι πώς οι υποσωροί διαφέρουν από τον αρχικό σωρό και πώς λειτουργούν:

1. **Αρχικός Σωρός έναντι Υποσωρών**:
* Ο αρχικός σωρός βρίσκεται αμέσως μετά το δυαδικό του προγράμματος στη μνήμη και επεκτείνεται χρησιμοποιώντας την κλήση συστήματος `sbrk`.
* Οι υποσωροί, που χρησιμοποιούνται από τις δευτερεύουσες αρένες, δημιουργούνται μέσω `mmap`, μιας κλήσης συστήματος που χαρτογραφεί μια συγκεκριμένη περιοχή μνήμης.
2. **Εκχώρηση Μνήμης με το `mmap`**:
* Όταν ο διαχειριστής του σωρού δημιουργεί έναν υποσωρό, εκχωρεί ένα μεγάλο τμήμα μνήμης μέσω `mmap`. Αυτή η εκχώρηση δεν κατανέμει μνήμη αμέσως· απλώς καθορίζει μια περιοχή που άλλες διεργασίες του συστήματος ή εκχωρήσεις δεν πρέπει να χρησιμοποιούν.
* Από προεπιλογή, το μέγεθος της εκχωρημένης μνήμης για έναν υποσωρό είναι 1 MB για διεργασίες 32-bit και 64 MB για διεργασίες 64-bit.
3. **Σταδιακή Επέκταση με το `mprotect`**:
* Η εκχωρημέ
## Bins

Για να βελτιωθεί η αποδοτικότητα στον τρόπο αποθήκευσης των τμημάτων, κάθε τμήμα δεν βρίσκεται μόνο σε μια συνδεδεμένη λίστα, αλλά υπάρχουν διάφοροι τύποι. Αυτοί είναι οι κάδοι και υπάρχουν 5 τύποι κάδων: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) μικροί κάδοι, 63 μεγάλοι κάδοι, 1 μη ταξινομημένος κάδος, 10 γρήγοροι κάδοι και 64 κάδοι tcache ανά νήμα.

Η αρχική διεύθυνση για κάθε μη ταξινομημένο, μικρό και μεγάλο κάδο βρίσκεται μέσα στον ίδιο πίνακα. Το δείκτης 0 δεν χρησιμοποιείται, ο 1 είναι ο μη ταξινομημένος κάδος, οι κάδοι 2-64 είναι μικροί κάδοι και οι κάδοι 65-127 είναι μεγάλοι κάδοι.

### Μικροί Κάδοι

Οι μικροί κάδοι είναι ταχύτεροι από τους μεγάλους κάδους αλλά πιο αργοί από τους γρήγορους κάδους.

Κάθε κάδος από τους 62 θα έχει **τμήματα με τον ίδιο μέγεθος**: 16, 24, ... (με μέγιστο μέγεθος 504 bytes σε 32bit και 1024 σε 64bit). Αυτό βοηθάει στην ταχύτητα εύρεσης του κάδου όπου θα πρέπει να γίνει μια εκχώρηση χώρου και στην εισαγωγή και αφαίρεση καταχωρήσεων σε αυτές τις λίστες.

### Μεγάλοι Κάδοι

Αντίθετα με τους μικρούς κάδους, οι οποίοι διαχειρίζονται τμήματα με σταθερά μεγέθη, κάθε **μεγάλος κάδος διαχειρίζεται ένα εύρος μεγεθών τμημάτων**. Αυτό είναι πιο ευέλικτο, επιτρέποντας στο σύστημα να φιλοξενεί **διάφορα μεγέθη** χωρίς την ανάγκη για έναν ξεχωριστό κάδο για κάθε μέγεθος.

Σε έναν διαχειριστή μνήμης, οι μεγάλοι κάδοι ξεκινούν από εκεί που τελειώνουν οι μικροί κάδοι. Τα εύρη για τους μεγάλους κάδους μεγαλώνουν σταδιακά, που σημαίνει ότι ο πρώτος κάδος μπορεί να καλύπτει τμήματα από 512 έως 576 bytes, ενώ ο επόμενος καλύπτει από 576 έως 640 bytes. Αυτό το πρότυπο συνεχίζεται, με τον μεγαλύτερο κάδο να περιέχει όλα τα τμήματα άνω των 1MB.

Οι μεγάλοι κάδοι είναι πιο αργοί στη λειτουργία σε σύγκριση με τους μικρούς κάδους επειδή πρέπει **να ταξινομήσουν και να αναζητήσουν μέσω μιας λίστας με διαφορετικά μεγέθη τμημάτων για να βρουν την καλύτερη ταιριάστηκα για μια εκχώρηση**. Όταν ένα τμήμα εισάγεται σε έναν μεγάλο κάδο, πρέπει να ταξινομηθεί, και όταν γίνεται εκχώρηση μνήμης, το σύστημα πρέπει να βρει το σωστό τμήμα. Αυτή η επιπλέον εργασία τους καθιστά **πιο αργούς**, αλλά επειδή οι μεγάλες εκχωρήσεις είναι λιγότερο συνηθισμένες από τις μικρές, είναι μια αποδεκτή ανταλλαγή.

Υπάρχουν:

* 32 κάδοι εύρους 64B
* 16 κάδοι εύρους 512B
* 8 κάδοι εύρους 4096B
* 4 κάδοι εύρους 32768B
* 2 κάδοι εύρους 262144B
* 1 κάδος για υπενθυμίσεις μεγεθών

### Μη Ταξινομημένος Κάδος

Ο μη ταξινομημένος κάδος είναι ένας **γρήγορος προσωρινός χώρος** που χρησιμοποιείται από τον διαχειριστή στοίβας για να κάνει την εκχώρηση μνήμης πιο γρήγορη. Έτσι λειτουργεί: Όταν ένα πρόγραμμα απελευθερώνει μνήμη, ο διαχειριστής στοίβας δεν το τοποθετεί αμέσως σε ένα συγκεκριμένο κάδο. Αντ' αυτού, πρώτα προσπαθεί να **συγχωνεύσει το με οποιαδήποτε γειτονικά ελεύθερα τμήματα** για να δημιουργήσει ένα μεγαλύτερο τμήμα ελεύθερης μνήμης. Στη συνέχεια, το τοποθετεί αυτό το νέο τμήμα σε ένα γενικό κάδο που ονομάζεται "μη ταξινομημένος κάδος".

Όταν ένα πρόγραμμα ζητά **μνήμη**, ο διαχειριστής στοίβας **ελέγχει πρώτα τον μη ταξινομημένο κάδο** για να δει αν υπάρχει ένα τμήμα του σωστού μεγέθους. Αν βρει ένα, το χρησιμοποιεί αμέσως, που είναι ταχύτερο από την αναζήτηση σε άλλους κάδους. Αν δε βρει ένα κατάλληλο τμήμα, μεταφέρει τα ελεύθερα τμήματα στους σωστούς κάδους τους, είτε μικρούς είτε μεγάλους, με βάση το μέγεθός τους.

Έτσι, ο μη ταξινομημένος κάδος είναι ένας τρόπος για να επιταχυνθεί η εκχώρηση μνήμης με την ταχεία επαναχρησιμοποίηση πρόσφατα απελευθερωμένης μνήμης και τη μείωση της ανάγκης για χρονοβόρες αναζητήσεις και συγχωνεύσεις.

{% hint style="danger" %}
Σημειώστε ότι ακόμα και αν τα τμήματα είναι διαφορετικών κατηγοριών, από καιρό σε καιρό, αν ένα διαθέσιμο τμήμα συγκρούεται με ένα άλλο διαθέσιμο τμήμα (ακόμα κι αν είναι διαφορετικών κατηγοριών), θα συγχωνευτούν.
{% endhint %}

### Γρήγοροι Κάδοι

Οι γρήγοροι κάδοι σχεδιάστηκαν για να **επιταχύνουν την εκχώρηση μνήμης για μικρά τμήματα** κρατώντας πρόσφατα απελευθερωμένα τμήματα σε μια δομή γρήγορης πρόσβασης. Αυτοί οι κάδοι χρησιμοποιούν μια προσέγγιση Τελευταίο Εισερχόμενο, Πρώτο Εξερχόμενο (LIFO), που σημαίνει ότι το **πιο πρόσφατα απελευθερωμένο τμήμα είναι το πρώτο** που θα επαναχρησιμοποιηθεί όταν υπάρχει αίτηση για νέα εκχώρηση. Αυτή η συμπεριφορά είναι επωφελής για την ταχύτητα, καθώς είναι πιο γρήγορο να εισαχθεί και να αφαιρεθεί από την κορυφή ενός σωρού (LIFO) σε σύγκριση με μια ουρά (FIFO).

Επιπλέον, **οι γρήγοροι κάδοι χρησιμοποιούν μονόδεσμες λίστες**, όχι διπλά δεσμευμένες, που βελτιώνει περαιτέρω την ταχύτητα. Δεδομένου ότι τα τμήματα στους γρήγορους κάδους δε συγχωνεύονται με γειτονικά, δεν χρειάζεται μια πολύπλοκη δομή που επιτρέπει την αφαίρεση από τη μέση. Μια μονόδεσμη λίστα είναι απλούστερη και ταχύτερη για αυτές τις λειτουργίες.

Βασικά, αυτό που σ
### Τακτική των κάδων

#### Για την εκχώρηση:

1. Αν υπάρχει διαθέσιμο τμήμα στο Tcache αυτού του μεγέθους, χρησιμοποιήστε το Tcache
2. Αν είναι πολύ μεγάλο, χρησιμοποιήστε το mmap
3. Αποκτήστε το κλείδωμα σωρού της αρένας και:
1. Αν υπάρχει αρκετό μικρό μέγεθος, τμήμα fast bin διαθέσιμο του ζητούμενου μεγέθους, χρησιμοποιήστε το και προ-γεμίστε το Tcache από το fast bin
2. Ελέγξτε κάθε καταχώρηση στη λίστα μη ταξινομημένων αναζητώντας ένα τμήμα αρκετά μεγάλο, και προ-γεμίστε το Tcache αν είναι δυνατόν
3. Ελέγξτε τους μικρούς κάδους ή τους μεγάλους κάδους (σύμφωνα με το ζητούμενο μέγεθος) και προ-γεμίστε το Tcache αν είναι δυνατόν
4. Δημιουργήστε ένα νέο τμήμα από διαθέσιμη μνήμη
1. Αν δεν υπάρχει διαθέσιμη μνήμη, αποκτήστε περισσότερη χρησιμοποιώντας `sbrk`
2. Αν η κύρια μνήμη του σωρού δεν μπορεί να αυξηθεί περισσότερο, δημιουργήστε ένα νέο χώρο χρησιμοποιώντας το mmap
5. Αν τίποτα δεν λειτούργησε, επιστρέψτε null

**Για την απελευθέρωση:**

1. Αν ο δείκτης είναι Null, ολοκληρώστε
2. Εκτελέστε ελέγχους ακεραιότητας `free` στο τμήμα για να επιχειρήσετε να επιβεβαιώσετε ότι είναι έγκυρο τμήμα
1. Αν είναι αρκετά μικρό και το Tcache δεν είναι γεμάτο, τοποθετήστε το εκεί
2. Αν το bit M είναι ενεργοποιημένο (όχι σωρός), χρησιμοποιήστε το `munmap`
3. Λάβετε το κλείδωμα σωρού της αρένας:
1. Αν χωράει σε ένα fastbin, τοποθετήστε το εκεί
2. Αν το τμήμα είναι > 64KB, συγχωνεύστε αμέσως τα fastbins και τοποθετήστε τα αποτελέσματα συγχωνευμένων τμημάτων στον μη ταξινομημένο κάδο.
3. Συγχωνεύστε το τμήμα προς τα πίσω και προς τα εμπρός με τα γειτονικά ελεύθερα τμήματα στους μικρούς, μεγάλους και μη ταξινομημένους κάδους αν υπάρχουν.
4. Αν είναι στην κορυφή της κεφαλής, συγχωνεύστε το στην αχρησιμοποίητη μνήμη
5. Αν δεν είναι στα προηγούμενα, αποθηκεύστε το στη λίστα μη ταξινομημένων
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Ορίστε ένα σημείο διακοπής στο τέλος της κύριας συνάρτησης και ας ανακαλύψουμε πού αποθηκεύτηκε η πληροφορία:

<figure><img src="../../.gitbook/assets/image (1239).png" alt=""><figcaption></figcaption></figure>

Είναι δυνατόν να δούμε ότι η συμβολοσειρά "panda" αποθηκεύτηκε στη διεύθυνση `0xaaaaaaac12a0` (η οποία ήταν η διεύθυνση που δόθηκε ως απάντηση από την malloc μέσα στο `x0`). Ελέγχοντας 0x10 bytes πριν από αυτήν, είναι δυνατόν να δούμε ότι το `0x0` αντιπροσωπεύει ότι το **προηγούμενο τμήμα δεν χρησιμοποιείται** (μήκος 0) και ότι το μήκος αυτού του τμήματος είναι `0x21`.

Τα επιπλέον κενά που διατηρούνται (0x21-0x10=0x11) προέρχονται από τα **προστιθέμενα κεφαλίδες** (0x10) και το 0x1 δεν σημαίνει ότι κρατήθηκαν 0x21B αλλά τα τελευταία 3 bits του μήκους της τρέχουσας κεφαλίδας έχουν κάποιες ειδικές σημασίες. Δεδομένου ότι το μήκος είναι πάντα σε ευθυγραμμισμένα 16-byte (σε μηχανές 64bit), αυτά τα bits προφανώς δεν θα χρησιμοποιηθούν ποτέ από τον αριθμό μήκους.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
##

## Αναφορές

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
