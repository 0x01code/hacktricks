# Heap

## Fondamentaux du tas

Le tas est essentiellement l'endroit où un programme pourra stocker des données lorsqu'il demande des données en appelant des fonctions telles que **`malloc`**, `calloc`... De plus, lorsque cette mémoire n'est plus nécessaire, elle est libérée en appelant la fonction **`free`**.

Comme le montre l'image ci-dessous, le tas se situe juste après le chargement binaire en mémoire (vérifiez la section `[heap]`):

<figure><img src="../../.gitbook/assets/image (1241).png" alt=""><figcaption></figcaption></figure>

### Allocation de morceaux de base

Lorsqu'il est demandé de stocker des données dans le tas, un espace du tas lui est alloué. Cet espace appartiendra à un compartiment et seules les données demandées + l'espace des en-têtes de compartiment + le décalage de taille minimale du compartiment seront réservés pour le morceau. L'objectif est de réserver autant de mémoire que possible sans compliquer la recherche de chaque morceau. Pour cela, les informations de métadonnées du morceau sont utilisées pour savoir où se trouve chaque morceau utilisé/libre.

Il existe différentes façons de réserver l'espace principalement en fonction du compartiment utilisé, mais une méthodologie générale est la suivante :

* Le programme commence par demander une certaine quantité de mémoire.
* S'il y a un morceau disponible dans la liste des morceaux assez grand pour répondre à la demande, il sera utilisé.
* Cela peut même signifier que partie du morceau disponible sera utilisée pour cette demande et le reste sera ajouté à la liste des morceaux.
* S'il n'y a pas de morceau disponible dans la liste mais qu'il reste de l'espace dans la mémoire allouée du tas, le gestionnaire de tas crée un nouveau morceau.
* S'il n'y a pas assez d'espace de tas pour allouer le nouveau morceau, le gestionnaire de tas demande au noyau d'étendre la mémoire allouée au tas, puis utilise cette mémoire pour générer le nouveau morceau.
* Si tout échoue, `malloc` renvoie null.

Notez que si la mémoire demandée **dépasse un seuil**, **`mmap`** sera utilisé pour mapper la mémoire demandée.

### Arènes

Dans les applications **multithread**, le gestionnaire de tas doit prévenir les **conditions de concurrence** qui pourraient entraîner des plantages. Initialement, cela était fait en utilisant un **mutex global** pour garantir qu'un seul thread pouvait accéder au tas à la fois, mais cela causait des **problèmes de performance** en raison de l'engorgement induit par le mutex.

Pour remédier à cela, l'allocateur de tas ptmalloc2 a introduit des "arènes", où **chaque arène** agit comme un **tas séparé** avec ses **propres** structures **de données** et **mutex**, permettant à plusieurs threads d'effectuer des opérations de tas sans interférer les uns avec les autres, tant qu'ils utilisent des arènes différentes.

L'arène "principale" par défaut gère les opérations de tas pour les applications monofils. Lorsque de **nouveaux threads** sont ajoutés, le gestionnaire de tas leur attribue des **arènes secondaires** pour réduire les conflits. Il tente d'abord d'attacher chaque nouveau thread à une arène inutilisée, en en créant de nouvelles si nécessaire, jusqu'à une limite de 2 fois le nombre de cœurs CPU pour les systèmes 32 bits et 8 fois pour les systèmes 64 bits. Une fois la limite atteinte, les **threads doivent partager des arènes**, entraînant des conflits potentiels.

Contrairement à l'arène principale, qui s'étend en utilisant l'appel système `brk`, les arènes secondaires créent des "sous-tas" en utilisant `mmap` et `mprotect` pour simuler le comportement du tas, permettant une flexibilité dans la gestion de la mémoire pour les opérations multithread.

### Sous-tas

Les sous-tas servent de réserves de mémoire pour les arènes secondaires dans les applications multithread, leur permettant de croître et de gérer leurs propres régions de tas séparément du tas principal. Voici comment les sous-tas diffèrent du tas initial et comment ils fonctionnent :

1. **Tas initial vs. Sous-tas** :
* Le tas initial se trouve directement après le binaire du programme en mémoire, et il s'étend en utilisant l'appel système `sbrk`.
* Les sous-tas, utilisés par les arènes secondaires, sont créés via `mmap`, un appel système qui mappe une région mémoire spécifiée.
2. **Réservation de mémoire avec `mmap`** :
* Lorsque le gestionnaire de tas crée un sous-tas, il réserve un grand bloc de mémoire via `mmap`. Cette réservation n'alloue pas immédiatement de mémoire ; elle désigne simplement une région que d'autres processus système ou allocations ne devraient pas utiliser.
* Par défaut, la taille réservée pour un sous-tas est de 1 Mo pour les processus 32 bits et de 64 Mo pour les processus 64 bits.
3. **Expansion progressive avec `mprotect`** :
* La région mémoire réservée est initialement marquée comme `PROT_NONE`, indiquant que le noyau n'a pas besoin d'allouer de mémoire physique à cet espace pour le moment.
* Pour "étendre" le sous-tas, le gestionnaire de tas utilise `mprotect` pour changer les autorisations de page de `PROT_NONE` à `PROT_READ | PROT_WRITE`, incitant le noyau à allouer de la mémoire physique aux adresses précédemment réservées. Cette approche étape par étape permet au sous-tas de s'étendre selon les besoins.
* Une fois que tout le sous-tas est épuisé, le gestionnaire de tas crée un nouveau sous-tas pour continuer l'allocation.

### Métadonnées

Comme mentionné précédemment, ces morceaux ont également des métadonnées, très bien représentées dans cette image :

<figure><img src="../../.gitbook/assets/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Les métadonnées sont généralement 0x08B, indiquant la taille actuelle du morceau en utilisant les 3 derniers bits pour indiquer :

* `A` : Si 1, il provient d'un sous-tas, si 0, il est dans l'arène principale
* `M` : Si 1, ce morceau fait partie d'un espace alloué avec mmap et non d'un tas
* `P` : Si 1, le morceau précédent est en cours d'utilisation

Ensuite, l'espace pour les données utilisateur, et enfin 0x08B pour indiquer la taille du morceau précédent lorsque le morceau est disponible (ou pour stocker les données utilisateur lorsqu'il est alloué).

De plus, lorsque disponible, les données utilisateur sont également utilisées pour contenir certaines données :

* Pointeur vers le morceau suivant
* Pointeur vers le morceau précédent
* Taille du morceau suivant dans la liste
* Taille du morceau précédent dans la liste

<figure><img src="../../.gitbook/assets/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Remarquez comment en liant la liste de cette manière, il n'est pas nécessaire d'avoir un tableau où chaque morceau est enregistré.

## Protections de libération

Afin de se protéger contre les abus accidentels ou intentionnels de la fonction de libération, avant d'exécuter ses actions, elle effectue quelques vérifications :

* Elle vérifie que l'adresse [est alignée](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4182) sur une limite de 8 octets ou 16 octets sur une limite de 64 bits (`(adresse % 16) == 0`), car _malloc_ garantit que toutes les allocations sont alignées.
* Elle vérifie que le champ de taille du morceau n'est pas impossible - soit parce qu'il est [trop petit](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4318), trop grand, pas une taille alignée, ou [chevaucherait la fin de l'espace d'adressage du processus](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4175).
* Elle vérifie que le morceau se trouve [dans les limites de l'arène](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l4318).
* Elle vérifie que le morceau n'est pas déjà marqué comme libre en vérifiant le bit "P" correspondant qui se trouve dans les métadonnées au début du morceau suivant.
## Bins

Pour améliorer l'efficacité de la façon dont les morceaux sont stockés, chaque morceau n'est pas simplement dans une liste chaînée, mais il existe plusieurs types. Ce sont les bacs et il y a 5 types de bacs : [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) petits bacs, 63 grands bacs, 1 bac non trié, 10 bacs rapides et 64 bacs tcache par fil.

L'adresse initiale de chaque bac non trié, petit et grand est à l'intérieur du même tableau. L'index 0 n'est pas utilisé, 1 est le bac non trié, les bacs 2-64 sont les petits bacs et les bacs 65-127 sont les grands bacs.

### Petits Bacs

Les petits bacs sont plus rapides que les grands bacs mais plus lents que les bacs rapides.

Chaque bac des 62 aura des **morceaux de la même taille** : 16, 24, ... (avec une taille maximale de 504 octets en 32 bits et 1024 en 64 bits). Cela aide à accélérer la recherche du bac où un espace doit être alloué et l'insertion et la suppression des entrées dans ces listes.

### Grands Bacs

Contrairement aux petits bacs, qui gèrent des morceaux de tailles fixes, chaque **grand bac gère une plage de tailles de morceaux**. Cela est plus flexible, permettant au système de s'adapter à **diverses tailles** sans avoir besoin d'un bac séparé pour chaque taille.

Dans un allocateur de mémoire, les grands bacs commencent là où les petits bacs se terminent. Les plages pour les grands bacs augmentent progressivement, ce qui signifie que le premier bac peut couvrir des morceaux de 512 à 576 octets, tandis que le suivant couvre de 576 à 640 octets. Ce schéma se poursuit, le plus grand bac contenant tous les morceaux de plus de 1 Mo.

Les grands bacs sont plus lents à manipuler par rapport aux petits bacs car ils doivent **trier et rechercher dans une liste de tailles de morceaux variables pour trouver le meilleur ajustement** pour une allocation. Lorsqu'un morceau est inséré dans un grand bac, il doit être trié, et lorsqu'une mémoire est allouée, le système doit trouver le bon morceau. Ce travail supplémentaire les rend **plus lents**, mais comme les allocations importantes sont moins courantes que les petites, c'est un compromis acceptable.

Il y a :

* 32 bacs de plage de 64B
* 16 bacs de plage de 512B
* 8 bacs de plage de 4096B
* 4 bacs de plage de 32768B
* 2 bacs de plage de 262144B
* 1 bac pour les tailles restantes

### Bac non trié

Le bac non trié est un **cache rapide** utilisé par le gestionnaire de tas pour rendre l'allocation de mémoire plus rapide. Voici comment cela fonctionne : lorsque un programme libère de la mémoire, le gestionnaire de tas ne la place pas immédiatement dans un bac spécifique. Au lieu de cela, il essaie d'abord de **la fusionner avec des morceaux libres voisins** pour créer un bloc plus grand de mémoire libre. Ensuite, il place ce nouveau morceau dans un bac général appelé le "bac non trié".

Lorsqu'un programme **demande de la mémoire**, le gestionnaire de tas **vérifie d'abord le bac non trié** pour voir s'il y a un morceau de la bonne taille. S'il en trouve un, il l'utilise immédiatement, ce qui est plus rapide que de rechercher dans d'autres bacs. S'il ne trouve pas de morceau adapté, il déplace les morceaux libérés dans leurs bacs corrects, petits ou grands, en fonction de leur taille.

Ainsi, le bac non trié est un moyen d'accélérer l'allocation de mémoire en réutilisant rapidement la mémoire libérée récemment et en réduisant le besoin de recherches et de fusions chronophages.

{% hint style="danger" %}
Notez que même si les morceaux sont de catégories différentes, de temps en temps, si un morceau disponible entre en collision avec un autre morceau disponible (même s'ils sont de catégories différentes), ils seront fusionnés.
{% endhint %}

### Bacs rapides

Les bacs rapides sont conçus pour **accélérer l'allocation de mémoire pour de petits morceaux** en conservant les morceaux récemment libérés dans une structure d'accès rapide. Ces bacs utilisent une approche Last-In, First-Out (LIFO), ce qui signifie que le **morceau libéré le plus récemment est le premier** à être réutilisé lorsqu'il y a une nouvelle demande d'allocation. Ce comportement est avantageux pour la vitesse, car il est plus rapide d'insérer et de supprimer en haut d'une pile (LIFO) par rapport à une file d'attente (FIFO).

De plus, **les bacs rapides utilisent des listes chaînées simples**, pas doubles, ce qui améliore encore la vitesse. Comme les morceaux dans les bacs rapides ne sont pas fusionnés avec les voisins, il n'est pas nécessaire d'avoir une structure complexe permettant le retrait du milieu. Une liste chaînée simple est plus simple et plus rapide pour ces opérations.

Essentiellement, ce qui se passe ici, c'est que l'en-tête (le pointeur vers le premier morceau à vérifier) pointe toujours vers le dernier morceau libéré de cette taille. Ainsi :

* Lorsqu'un nouveau morceau est alloué de cette taille, l'en-tête pointe vers un morceau libre à utiliser. Comme ce morceau libre pointe vers le suivant à utiliser, cette adresse est stockée dans l'en-tête afin que la prochaine allocation sache où obtenir un morceau disponible.
* Lorsqu'un morceau est libéré, le morceau libre sauvegarde l'adresse du morceau disponible actuel et l'adresse de ce nouveau morceau libéré est placée dans l'en-tête.

{% hint style="danger" %}
Les morceaux dans les bacs rapides ne sont pas automatiquement définis comme disponibles, ils restent donc comme morceaux de bac rapide pendant un certain temps au lieu de pouvoir fusionner avec d'autres morceaux.
{% endhint %}

### Bacs Tcache (Cache par fil)

Même si les threads essaient d'avoir leur propre tas (voir [Arenas](./#arenas) et [Sous-tas](./#subheaps)), il est possible qu'un processus avec beaucoup de threads (comme un serveur web) **finisse par partager le tas avec d'autres threads**. Dans ce cas, la principale solution est l'utilisation de **verrous**, ce qui pourrait **ralentir considérablement les threads**.

Par conséquent, un tcache est similaire à un bac rapide par fil de discussion de la manière dont c'est une **liste chaînée simple** qui ne fusionne pas les morceaux. Chaque fil de discussion a **64 bacs tcache à liste chaînée simple**. Chaque bac peut contenir un maximum de [7 morceaux de même taille](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) allant de [24 à 1032B sur les systèmes 64 bits et de 12 à 516B sur les systèmes 32 bits](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Lorsqu'un fil de discussion libère** un morceau, **s'il n'est pas trop gros** pour être alloué dans le tcache et que le bac tcache respectif **n'est pas plein** (déjà 7 morceaux), **il sera alloué là-dedans**. S'il ne peut pas aller dans le tcache, il devra attendre que le verrou du tas soit disponible pour pouvoir effectuer l'opération de libération globalement.

Lorsqu'un **morceau est alloué**, s'il y a un morceau libre de la taille nécessaire dans le **tcache, il l'utilisera**, sinon, il devra attendre que le verrou du tas soit disponible pour en trouver un dans les bacs globaux ou en créer un nouveau.\
Il y a aussi une optimisation, dans ce cas, tout en ayant le verrou du tas, le fil de discussion **remplira son tcache avec des morceaux de tas (7) de la taille demandée**, donc s'il en a besoin de plus, il les trouvera dans le tcache.
### Ordre des bacs

#### Pour l'allocation :

1. Si un chunk disponible dans le Tcache de cette taille, utilisez le Tcache
2. S'il est très grand, utilisez mmap
3. Obtenez le verrou du tas de l'arène et :
   1. Si une taille suffisamment petite est disponible, utilisez un chunk de fastbin de la taille demandée, utilisez-le et préremplissez le tcache à partir du fastbin
   2. Vérifiez chaque entrée dans la liste non triée à la recherche d'un chunk suffisamment grand et préremplissez le tcache si possible
   3. Vérifiez les petits bacs ou les grands bacs (selon la taille demandée) et préremplissez le tcache si possible
   4. Créez un nouveau chunk à partir de la mémoire disponible
      1. S'il n'y a pas de mémoire disponible, obtenez-en davantage en utilisant `sbrk`
      2. Si la mémoire principale du tas ne peut pas être agrandie davantage, créez un nouvel espace en utilisant mmap
   5. Si rien n'a fonctionné, renvoyez null

**Pour la libération :**

1. Si le pointeur est Null, terminez
2. Effectuez des vérifications de cohérence `free` dans le chunk pour essayer de vérifier qu'il s'agit d'un chunk légitime
   1. S'il est assez petit et que le tcache n'est pas plein, mettez-le là
   2. Si le bit M est défini (pas de tas), utilisez `munmap`
   3. Obtenez le verrou du tas de l'arène :
      1. S'il correspond à un fastbin, mettez-le là
      2. Si le chunk est > 64 Ko, consolidez immédiatement les fastbins et placez les chunks fusionnés résultants dans le bac non trié.
      3. Fusionnez le chunk vers l'arrière et vers l'avant avec les chunks libérés voisins dans les petits, grands et bacs non triés s'il y en a.
      4. S'il se trouve en haut de la tête, fusionnez-le dans la mémoire inutilisée
      5. Si ce ne sont pas les précédents, stockez-le dans la liste non triée

\

Exemple rapide de tas provenant de [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) mais en arm64 :
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Définissez un point d'arrêt à la fin de la fonction principale et découvrons où les informations ont été stockées :

<figure><img src="../../.gitbook/assets/image (1239).png" alt=""><figcaption></figcaption></figure>

Il est possible de voir que la chaîne panda a été stockée à `0xaaaaaaac12a0` (qui était l'adresse donnée en réponse par malloc à l'intérieur de `x0`). En vérifiant les 0x10 octets avant, il est possible de voir que le `0x0` représente que le **chunk précédent n'est pas utilisé** (longueur 0) et que la longueur de ce chunk est `0x21`.

Les espaces supplémentaires réservés (0x21-0x10=0x11) proviennent des **en-têtes ajoutés** (0x10) et 0x1 ne signifie pas qu'il a été réservé 0x21B mais les 3 derniers bits de la longueur de l'en-tête actuel ont des significations spéciales. Comme la longueur est toujours alignée sur 16 octets (sur les machines 64 bits), ces bits ne seront en réalité jamais utilisés par le nombre de longueur.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
##

## Références

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
