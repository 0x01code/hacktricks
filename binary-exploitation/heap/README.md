# Heap

## Grundlagen des Heaps

Der Heap ist im Grunde der Ort, an dem ein Programm Daten speichern kann, wenn es Daten anfordert, indem es Funktionen wie **`malloc`**, `calloc` aufruft. Darüber hinaus wird dieser Speicher freigegeben, wenn er nicht mehr benötigt wird, indem die Funktion **`free`** aufgerufen wird.

Wie gezeigt wird, befindet sich der Heap direkt nach dem Laden des Binärdatei im Speicher (überprüfen Sie den Abschnitt `[heap]`):

<figure><img src="../../.gitbook/assets/image (1241).png" alt=""><figcaption></figcaption></figure>

### Grundlegende Chunk-Allokation

Wenn Daten im Heap gespeichert werden sollen, wird ein Teil des Heaps dafür allokiert. Dieser Speicher gehört zu einem Bin und nur die angeforderten Daten + der Speicher der Bin-Header + der minimale Bin-Größenoffset werden für den Chunk reserviert. Das Ziel ist es, so wenig Speicher wie möglich zu reservieren, ohne es kompliziert zu machen, herauszufinden, wo sich jeder Chunk befindet. Dafür werden die Metadaten-Chunk-Informationen verwendet, um zu wissen, wo sich jeder benutzte/freie Chunk befindet.

Es gibt verschiedene Möglichkeiten, den Speicher zu reservieren, hauptsächlich abhängig vom verwendeten Bin, aber eine allgemeine Methodik ist wie folgt:

* Das Programm beginnt mit der Anforderung einer bestimmten Menge an Speicher.
* Wenn in der Liste der Chunks jemand verfügbar ist, der groß genug ist, um die Anforderung zu erfüllen, wird er verwendet.
* Dies kann sogar bedeuten, dass ein Teil des verfügbaren Chunks für diese Anforderung verwendet wird und der Rest zur Chunks-Liste hinzugefügt wird.
* Wenn kein verfügbarer Chunk in der Liste vorhanden ist, aber noch Speicher im allokierten Heap-Speicher vorhanden ist, erstellt der Heap-Manager einen neuen Chunk.
* Wenn nicht genügend Heap-Speicher vorhanden ist, um den neuen Chunk zuzuweisen, fordert der Heap-Manager den Kernel auf, den dem Heap allokierten Speicher zu erweitern und diesen Speicher dann zu verwenden, um den neuen Chunk zu generieren.
* Wenn alles fehlschlägt, gibt `malloc` null zurück.

Beachten Sie, dass, wenn der angeforderte **Speicher eine Schwelle überschreitet**, **`mmap`** verwendet wird, um den angeforderten Speicher abzubilden.

### Arenen

In **multithreaded** Anwendungen muss der Heap-Manager **Rennbedingungen** verhindern, die zu Abstürzen führen könnten. Anfangs wurde dies mit einem **globalen Mutex** erreicht, um sicherzustellen, dass nur ein Thread gleichzeitig auf den Heap zugreifen konnte, aber dies führte aufgrund des durch den Mutex verursachten Engpasses zu **Leistungsproblemen**.

Um dies zu lösen, führte der ptmalloc2-Heap-Allocator "Arenen" ein, wobei **jede Arena** als **eigener Heap** mit eigenen Datenstrukturen und Mutex fungiert, sodass mehrere Threads Heap-Operationen ausführen können, ohne sich gegenseitig zu beeinträchtigen, solange sie verschiedene Arenen verwenden.

Die Standard-"main"-Arena behandelt Heap-Operationen für Single-Thread-Anwendungen. Wenn **neue Threads** hinzugefügt werden, weist der Heap-Manager ihnen **sekundäre Arenen** zu, um die Kontention zu verringern. Zuerst versucht er, jeden neuen Thread einer unbenutzten Arena zuzuweisen, wobei bei Bedarf neue erstellt werden, bis zu einer Grenze von 2-mal den CPU-Kernen für 32-Bit-Systeme und 8-mal für 64-Bit-Systeme. Sobald die Grenze erreicht ist, **müssen Threads Arenen teilen**, was zu potenzieller Kontention führt.

Im Gegensatz zur Hauptarena, die die `brk`-Systemaufruf verwendet, erstellen sekundäre Arenen "Subheaps" mit `mmap` und `mprotect`, um das Verhalten des Heaps zu simulieren und die Speicherverwaltung für Multithread-Operationen flexibel zu gestalten.

### Subheaps

Subheaps dienen als Speichervorräte für sekundäre Arenen in Multithread-Anwendungen, die es ihnen ermöglichen, ihre eigenen Heap-Regionen separat vom Haupt-Heap zu erweitern und zu verwalten. Hier ist, wie sich Subheaps vom ursprünglichen Heap unterscheiden und wie sie funktionieren:

1. **Ursprünglicher Heap vs. Subheaps**:
* Der ursprüngliche Heap befindet sich direkt nach der Binärdatei des Programms im Speicher und erweitert sich mit dem `sbrk`-Systemaufruf.
* Subheaps, die von sekundären Arenen verwendet werden, werden durch `mmap` erstellt, einem Systemaufruf, der eine bestimmte Speicherregion abbildet.
2. **Speichervorbelegung mit `mmap`**:
* Wenn der Heap-Manager einen Subheap erstellt, reserviert er einen großen Speicherblock durch `mmap`. Diese Reservierung allokiert nicht sofort Speicher; sie kennzeichnet lediglich einen Bereich, den andere Systemprozesse oder Allokationen nicht verwenden sollten.
* Standardmäßig beträgt die reservierte Größe für einen Subheap 1 MB für 32-Bit-Prozesse und 64 MB für 64-Bit-Prozesse.
3. **Schrittweise Erweiterung mit `mprotect`**:
* Der reservierte Speicherbereich ist anfangs als `PROT_NONE` markiert, was bedeutet, dass der Kernel diesem Bereich noch keinen physischen Speicher zuweist.
* Um den Subheap zu "erweitern", verwendet der Heap-Manager `mprotect`, um die Seitenerlaubnis von `PROT_NONE` auf `PROT_READ | PROT_WRITE` zu ändern, wodurch der Kernel aufgefordert wird, physischen Speicher an die zuvor reservierten Adressen zuzuweisen. Dieser schrittweise Ansatz ermöglicht es dem Subheap, bei Bedarf zu expandieren.
* Sobald der gesamte Subheap erschöpft ist, erstellt der Heap-Manager einen neuen Subheap, um die Allokation fortzusetzen.

### malloc\_state

**Jeder Heap** (Hauptarena oder Arenen anderer Threads) hat eine **`malloc_state`-Struktur**.\
Es ist wichtig zu beachten, dass die **`malloc_state`-Struktur der Hauptarena** eine **globale Variable in der libc** ist (und daher im libc-Speicherbereich liegt).\
Im Falle der **`malloc_state`**-Strukturen der Heaps von Threads befinden sie sich **innerhalb des eigenen Thread-"Heaps"**.

Es gibt einige interessante Dinge, die aus dieser Struktur hervorgehen (siehe untenstehenden C-Code):

* Der `mchunkptr bins[NBINS * 2 - 2];` enthält **Zeiger** auf die **ersten und letzten Chunks** der kleinen, großen und unsortierten **Bins** (das -2 bedeutet, dass der Index 0 nicht verwendet wird).
* Daher wird der **erste Chunk** dieser Bins einen **rückwärts Zeiger auf diese Struktur** haben und der **letzte Chunk** dieser Bins wird einen **Vorwärtszeiger** auf diese Struktur haben. Das bedeutet im Grunde, dass wenn Sie diese Adressen in der Hauptarena **leaken**, haben Sie einen Zeiger auf die Struktur in der **libc**.
* Die Strukturen `struct malloc_state *next;` und `struct malloc_state *next_free;` sind verkettete Listen von Arenen.
* Der `top`-Chunk ist der letzte "Chunk", der im Grunde **den gesamten verbleibenden Heap-Speicher** darstellt. Sobald der Top-Chunk "leer" ist, ist der Heap vollständig genutzt und es muss mehr Speicher angefordert werden.
* Der `last reminder`-Chunk stammt aus Fällen, in denen ein Chunk mit genau der richtigen Größe nicht verfügbar ist und daher ein größerer Chunk aufgeteilt wird, wobei ein Zeiger auf den verbleibenden Teil hier platziert wird.
```c
// From https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_state
struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);
/* Flags (formerly in max_fast).  */
int flags;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];
/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;
/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;
/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;
/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;
/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */

INTERNAL_SIZE_T attached_threads;
/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};

typedef struct malloc_state *mstate;
```
### malloc\_chunk

Diese Struktur repräsentiert einen bestimmten Speicherbereich. Die verschiedenen Felder haben unterschiedliche Bedeutungen für allokierte und nicht allokierte Speicherbereiche.
```c
// From https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
Wie zuvor kommentiert, haben diese Chunks auch Metadaten, die sehr gut in diesem Bild dargestellt sind:

<figure><img src="../../.gitbook/assets/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

Die Metadaten sind normalerweise 0x08B, was die aktuelle Chunkgröße angibt und die letzten 3 Bits verwendet, um anzugeben:

* `A`: Wenn 1, stammt es aus einem Unterheap, wenn 0, gehört es zum Hauptbereich
* `M`: Wenn 1, ist dieser Chunk Teil eines mit mmap allokierten Speicherbereichs und nicht Teil eines Heaps
* `P`: Wenn 1, ist der vorherige Chunk in Benutzung

Dann folgt der Platz für die Benutzerdaten und schließlich 0x08B, um die Größe des vorherigen Chunks anzuzeigen, wenn der Chunk verfügbar ist (oder um Benutzerdaten zu speichern, wenn er allokiert ist).

Darüber hinaus werden, wenn verfügbar, die Benutzerdaten auch verwendet, um einige Daten zu enthalten:

* Zeiger auf den nächsten Chunk
* Zeiger auf den vorherigen Chunk
* Größe des nächsten Chunks in der Liste
* Größe des vorherigen Chunks in der Liste



<figure><img src="../../.gitbook/assets/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

{% hint style="info" %}
Beachten Sie, wie das Liken der Liste auf diese Weise verhindert, dass ein Array benötigt wird, in dem jeder einzelne Chunk registriert wird.
{% endhint %}

### Schnelles Heap-Beispiel

Schnelles Heap-Beispiel von [https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html) aber in arm64:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
Setzen Sie einen Haltepunkt am Ende der Hauptfunktion und finden wir heraus, wo die Informationen gespeichert wurden:

<figure><img src="../../.gitbook/assets/image (1239).png" alt=""><figcaption></figcaption></figure>

Es ist möglich zu sehen, dass der String panda unter `0xaaaaaaac12a0` gespeichert wurde (die Adresse, die von malloc innerhalb von `x0` als Antwort gegeben wurde). Wenn Sie 0x10 Bytes davor überprüfen, ist zu sehen, dass das `0x0` bedeutet, dass der **vorherige Chunk nicht verwendet wird** (Länge 0) und dass die Länge dieses Chunks `0x21` beträgt.

Die zusätzlichen reservierten Leerzeichen (0x21-0x10=0x11) stammen von den **hinzugefügten Headern** (0x10) und 0x1 bedeutet nicht, dass 0x21B reserviert wurde, sondern die letzten 3 Bits der Länge des aktuellen Headers haben einige spezielle Bedeutungen. Da die Länge immer auf 16-Byte ausgerichtet ist (bei 64-Bit-Maschinen), werden diese Bits tatsächlich nie von der Längenzahl verwendet.
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
## Bins & Speicherzuweisungen/Freigaben

Überprüfen Sie, was Bins sind, wie sie organisiert sind und wie der Speicher in folgenden Dateien allokiert und freigegeben wird:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

## Sicherheitsüberprüfungen von Heap-Funktionen

Funktionen, die mit dem Heap arbeiten, führen bestimmte Überprüfungen durch, bevor sie ihre Aktionen ausführen, um sicherzustellen, dass der Heap nicht beschädigt wurde:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Referenzen

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
