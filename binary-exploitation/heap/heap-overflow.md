# 堆溢出

<details>

<summary><strong>从零开始学习AWS黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

堆溢出类似于[**栈溢出**](../stack-overflow/)，但发生在堆中。基本上意味着在堆中保留了一些空间来存储一些数据，**存储的数据大于所保留的空间**。

在栈溢出中，我们知道一些寄存器，如指令指针或堆栈帧，将从堆栈中恢复，并且可能会滥用这一点。在堆溢出的情况下，**堆块中默认没有存储任何敏感信息**，可以被溢出。但是，可能存在敏感信息或指针，因此此漏洞的**严重性取决于**可以**覆盖哪些数据**以及攻击者如何滥用此漏洞。

{% hint style="success" %}
为了找到溢出偏移量，您可以使用与[**栈溢出**](../stack-overflow/#finding-stack-overflows-offsets)相同的模式。
{% endhint %}

### 栈溢出 vs 堆溢出

在栈溢出中，当漏洞触发时，堆栈中将出现的排列和数据相当可靠。这是因为堆栈是线性的，在冲突内存中始终增加，在程序运行的特定位置，堆栈内存通常存储类似类型的数据，并且具有一些特定结构，每个函数使用的堆栈部分末尾有一些指针。

然而，在堆溢出的情况下，由于使用的内存不是线性的，而是通常在内存的分离位置分配的块（不是相邻的），这是因为**通过大小分隔分配的bins和zones**，以及**在分配新块之前使用先前释放的内存**。很难知道将与易受堆溢出的对象发生冲突的对象是什么。因此，当发现堆溢出时，需要找到一种**可靠的方法**，使期望的对象**在易受溢出的对象旁边**。

用于此目的的一种技术是**堆整理**，例如在[**此文章**](https://azeria-labs.com/grooming-the-ios-kernel-heap/)中使用。文章中解释了在iOS内核中，当一个区域的内存用完以存储内存块时，它会通过一个内核页扩展，然后将该页分割为预期大小的块，这些块将按顺序使用（直到iOS版本9.2，然后这些块以随机方式使用，以增加这些攻击的利用难度）。

因此，在先前的文章中，发生堆溢出时，为了强制溢出的对象与受害者顺序发生冲突，通过几个线程强制执行**`kallocs`**以确保所有空闲块都被填充，并创建一个新页面。

为了强制使用特定大小的对象填充，与iOS mach端口相关联的**离线分配**是一个理想的选择。通过精心制作消息的大小，可以精确指定`kalloc`分配的大小，当相应的mach端口被销毁时，相应的分配将立即释放回`kfree`。

然后，可以**释放**其中一些占位符。**`kalloc.4096`**空闲列表以后进先出的顺序释放元素，这基本上意味着如果释放了一些占位符，并且尝试在分配易受溢出的对象时分配多个受害者对象，那么很可能该对象将被一个受害者对象跟随。

### 示例libc

在[**此页面**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html)中，可以找到一个基本的堆溢出仿真，展示了如何通过覆盖下一个块的使用中的前一个位和前一个大小的位置，可以**整理已使用的块**（使其认为未使用），然后再次分配它，从而能够覆盖正在不同指针中使用的数据。

另一个来自[**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html)的示例展示了一个CTF的非常基本示例，其中可以利用**堆溢出**调用winner函数以**获取标志**。

在[**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html)示例中，可以看到如何利用缓冲区溢出**在附近的块中覆盖地址**，其中**用户的任意数据**将被写入。

### 示例ARM64

在页面[https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/)中，您可以找到一个堆溢出示例，其中将要执行的命令存储在溢出块的下一个块中。因此，可以通过覆盖它来修改要执行的命令，例如使用简单的利用方式：
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

其他支持HackTricks的方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
