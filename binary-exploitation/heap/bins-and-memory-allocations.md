# Bins & Alokacje Pamięci

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe Informacje

Aby poprawić efektywność przechowywania kawałków, każdy kawałek nie jest przechowywany tylko w jednej liście połączonej, ale istnieje kilka typów. Są to tzw. "bins", a istnieje 5 typów bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) małych bins, 63 dużych bins, 1 bin niesortowany, 10 szybkich bins i 64 bins tcache na wątek.

Początkowy adres do każdego binu niesortowanego, małego i dużego znajduje się w tej samej tablicy. Indeks 0 jest nieużywany, 1 to bin niesortowany, biny 2-64 to małe biny, a biny 65-127 to duże biny.

### Małe Biny

Małe biny są szybsze niż duże biny, ale wolniejsze niż szybkie biny.

Każdy bin spośród 62 będzie miał **kawałki o tej samej wielkości**: 16, 24, ... (z maksymalną wielkością 504 bajtów w systemach 32-bitowych i 1024 w systemach 64-bitowych). Pomaga to w szybkości znajdowania bina, w którym powinno być przydzielone miejsce oraz w wstawianiu i usuwaniu wpisów na tych listach.

### Duże Biny

W przeciwieństwie do małych binów, które zarządzają kawałkami o stałych rozmiarach, każdy **duży bin obsługuje zakres rozmiarów kawałków**. Jest to bardziej elastyczne, pozwalając systemowi na dostosowanie się do **różnych rozmiarów** bez konieczności posiadania osobnego bina dla każdego rozmiaru.

W alokatorze pamięci, duże biny zaczynają się tam, gdzie kończą się małe biny. Zakresy dla dużych binów rosną stopniowo, co oznacza, że pierwszy bin może obejmować kawałki od 512 do 576 bajtów, podczas gdy następny obejmuje 576 do 640 bajtów. Ten wzorzec kontynuuje się, a największy bin zawiera wszystkie kawałki powyżej 1 MB.

Duże biny są wolniejsze w działaniu w porównaniu do małych binów, ponieważ muszą **sortować i przeszukiwać listę różnych rozmiarów kawałków, aby znaleźć najlepsze dopasowanie** dla alokacji. Gdy kawałek jest wstawiany do dużego bina, musi być posortowany, a podczas alokacji pamięci system musi znaleźć odpowiedni kawałek. Dodatkowa praca sprawia, że są one **wolniejsze**, ale ponieważ duże alokacje są mniej powszechne niż małe, jest to akceptowalny kompromis.

Istnieją:

* 32 biny o zakresie 64B
* 16 binów o zakresie 512B
* 8 binów o zakresie 4096B
* 4 biny o zakresie 32768B
* 2 biny o zakresie 262144B
* 1 bin na pozostałe rozmiary

### Bin Niesortowany

Bin niesortowany to **szybka pamięć podręczna** używana przez menedżera sterty do przyspieszenia alokacji pamięci. Oto jak to działa: gdy program zwalnia pamięć, menedżer sterty nie umieszcza jej od razu w konkretnym binie. Zamiast tego najpierw próbuje **połączyć ją z sąsiednimi wolnymi kawałkami**, aby utworzyć większy blok wolnej pamięci. Następnie umieszcza ten nowy kawałek w ogólnym binie o nazwie "bin niesortowany".

Gdy program **prosi o pamięć**, menedżer sterty **sprawdza bin niesortowany**, aby zobaczyć, czy jest tam kawałek wystarczającego rozmiaru. Jeśli znajdzie odpowiedni kawałek, używa go od razu. Jeśli nie znajdzie odpowiedniego kawałka, przenosi zwolnione kawałki do odpowiadających im binów, małych lub dużych, w zależności od ich rozmiaru.

Więc bin niesortowany to sposób przyspieszenia alokacji pamięci poprzez szybkie ponowne wykorzystanie niedawno zwolnionej pamięci i zmniejszenie potrzeby czasochłonnego wyszukiwania i łączenia.

{% hint style="danger" %}
Zauważ, że nawet jeśli kawałki należą do różnych kategorii, jeśli dostępny kawałek koliduje z innym dostępnym kawałkiem (nawet jeśli są to różne kategorie), zostaną one połączone.
{% endhint %}

### Szybkie Biny

Szybkie biny są zaprojektowane, aby **przyspieszyć alokację pamięci dla małych kawałków**, trzymając niedawno zwolnione kawałki w strukturze szybkiego dostępu. Te biny używają podejścia Last-In, First-Out (LIFO), co oznacza, że **najbardziej niedawno zwolniony kawałek jest pierwszy** do ponownego użycia, gdy występuje nowe żądanie alokacji. To zachowanie jest korzystne dla szybkości, ponieważ jest szybciej wstawiać i usuwać z góry stosu (LIFO) w porównaniu do kolejki (FIFO).

Dodatkowo, **szybkie biny używają list jednokierunkowych**, a nie dwukierunkowych, co dodatkowo poprawia szybkość. Ponieważ kawałki w szybkich binach nie są łączone z sąsiadami, nie ma potrzeby skomplikowanej struktury, która pozwala na usuwanie ze środka. Lista jednokierunkowa jest prostsza i szybsza dla tych operacji.

W zasadzie, to co się dzieje tutaj, to że nagłówek (wskaźnik do pierwszego kawałka do sprawdzenia) zawsze wskazuje na najnowszy zwolniony kawałek tego rozmiaru. Więc:

* Gdy nowy kawałek jest alokowany o tym rozmiarze, nagłówek wskazuje na wolny kawałek do użycia. Ponieważ ten wolny kawałek wskazuje na następny do użycia, ten adres jest przechowywany w nagłówku, aby następna alokacja wiedziała, gdzie znaleźć dostępny kawałek.
* Gdy kawałek jest zwalniany, wolny kawałek zapisze adres do aktualnie dostępnego kawałka, a adres do tego nowo zwolnionego kawałka zostanie umieszczony w nagłówku.

{% hint style="danger" %}
Kawałki w szybkich binach nie są automatycznie ustawiane jako dostępne, więc pozostają jako kawałki szybkich binów przez pewien czas zamiast móc łączyć się z innymi kawałkami.
{% endhint %}

### Biny Tcache (Pamięć Podręczna na Wątek)

Mimo że wątki starają się mieć swoją własną stertę (patrz [Areny](bins-and-memory-allocations.md#arenas) i [Podsterty](bins-and-memory-allocations.md#subheaps)), istnieje możliwość, że proces z wieloma wątkami (np. serwer sieciowy) **będzie dzielił stertę z innymi wątkami**. W takim przypadku głównym rozwiązaniem jest użycie **blokad**, które mogą **znacznie spowolnić wątki**.

Dlatego tcache jest podobne do szybkiego bina na wątek w taki sposób, że jest to **lista jednokierunkowa**, która nie łączy kawałków. Każdy wątek ma **64 jednokierunkowe biny tcache**. Każdy bin może zawierać maksymalnie [7 kawałków tego samego rozmiaru](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) o rozmiarach od [24 do 1032B w systemach 64-bitowych i od 12 do 516B w systemach 32-bitowych](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Gdy wątek zwalnia** kawałek, **jeśli nie jest zbyt duży** do alokacji w tcache i odpowiedni bin tcache **nie jest pełny** (już 7 kawałków), **zostanie tam zaalokowany**. Jeśli nie może trafić do tcache, będzie musiał czekać na blokadę sterty, aby móc wykonać operację zwolnienia globalnie.

Gdy **kawałek jest alokowany**, jeśli istnieje wolny kawałek potrzebnego rozmiaru w **tcache, zostanie użyty**, jeśli nie, będzie musiał czekać na blokadę sterty, aby znaleźć go w globalnych binach lub utworzyć nowy.\
Istnieje także optymalizacja, w tym przypadku, podczas posiadania blokady sterty, wątek **wypełni swoje tcache kawałkami sterty (7) o żądanym rozmiarze**, więc jeśli potrzebuje więcej, znajdzie je w tcache.
## Przepływ alokacji

{% hint style="success" %}
(Ta obecna wyjaśnienie pochodzi z [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Sprawdź ostatnią wersję i zaktualizuj)
{% endhint %}

Alokacje są ostatecznie wykonywane za pomocą funkcji: `void * _int_malloc (mstate av, size_t bytes)` i mają taki porządek:

1. Aktualizuje `bytes`, aby uwzględnić **wyrównania**, itp.
2. Sprawdza, czy `av` jest **NULL** czy nie.
3. W przypadku braku **dostępnej areny** (gdy `av` jest NULL), wywołuje `sysmalloc`, aby uzyskać fragment za pomocą mmap. Jeśli operacja powiedzie się, wywołuje `alloc_perturb`. Zwraca wskaźnik.
4. W zależności od rozmiaru:
* \[Dodatkowe w stosunku do oryginału] Użyj tcache przed sprawdzeniem następnego fastbinu.
* \[Dodatkowe w stosunku do oryginału] Jeśli brak tcache, ale używany jest inny bin (patrz późniejszy krok), spróbuj wypełnić tcache z tego bina.
* Jeśli rozmiar mieści się w zakresie **fastbin**:
1. Uzyskuje indeks do tablicy fastbinów, aby uzyskać odpowiedni bin zgodnie z żądanym rozmiarem.
2. Usuwa pierwszy fragment z tego bina i ustawia `victim` na niego.
3. Jeśli `victim` jest NULL, przechodzi do następnego przypadku (smallbin).
4. Jeśli `victim` nie jest NULL, sprawdza rozmiar fragmentu, aby upewnić się, że należy on do tego konkretnego bina. W przeciwnym razie zostanie zgłoszony błąd ("malloc(): pamięć została uszkodzona (fast)").
5. Wywołuje `alloc_perturb`, a następnie zwraca wskaźnik.
* Jeśli rozmiar mieści się w zakresie **smallbin**:
1. Uzyskuje indeks do tablicy smallbinów, aby uzyskać odpowiedni bin zgodnie z żądanym rozmiarem.
2. Jeśli w tym binie nie ma fragmentów, przechodzi do następnego przypadku. Sprawdzane jest to poprzez porównanie wskaźników `bin` i `bin->bk`.
3. `victim` jest ustawiony na `bin->bk` (ostatni fragment w binie). Jeśli jest NULL (co zdarza się podczas `inicjalizacji`), wywołuje `malloc_consolidate` i pomija ten cały krok sprawdzania różnych binów.
4. W przeciwnym razie, gdy `victim` nie jest NULL, sprawdza, czy `victim->bk->fd` i `victim` są równe czy nie. Jeśli nie są równe, zostanie zgłoszony błąd (`malloc(): pamięć listy dwukierunkowej smallbin została uszkodzona`).
5. Ustawia bit PREV\_INSUSE dla następnego fragmentu (w pamięci, nie w liście dwukierunkowej) dla `victim`.
6. Usuwa ten fragment z listy bina.
7. Ustawia odpowiedni bit areny dla tego fragmentu w zależności od `av`.
8. Wywołuje `alloc_perturb`, a następnie zwraca wskaźnik.
* Jeśli rozmiar nie mieści się w zakresie smallbin:
1. Uzyskuje indeks do tablicy largebinów, aby uzyskać odpowiedni bin zgodnie z żądanym rozmiarem.
2. Sprawdza, czy `av` ma fastchunki czy nie. Jest to sprawdzane poprzez sprawdzenie `FASTCHUNKS_BIT` w `av->flags`. Jeśli tak, wywołuje `malloc_consolidate` na `av`.
5. Jeśli jeszcze nie został zwrócony żaden wskaźnik, oznacza to jedno lub więcej z następujących przypadków:
1. Rozmiar mieści się w zakresie 'fastbin', ale brak dostępnych fastchunków.
2. Rozmiar mieści się w zakresie 'smallbin', ale brak dostępnych smallchunków (wywołuje `malloc_consolidate` podczas inicjalizacji).
3. Rozmiar mieści się w zakresie 'largebin'.
6. Następnie sprawdzane są **nieuporządkowane fragmenty** i przeglądane fragmenty są umieszczane w binach. Jest to jedyne miejsce, gdzie fragmenty są umieszczane w binach. Iteruje się po nieuporządkowanym binie od 'TAIL'.
1. `victim` wskazuje na bieżący rozważany fragment.
2. Sprawdza, czy rozmiar fragmentu `victim` mieści się w zakresie minimalnym (`2*SIZE_SZ`) i maksymalnym (`av->system_mem`). W przeciwnym razie zostanie zgłoszony błąd (`malloc(): pamięć została uszkodzona`).
3. Jeśli (rozmiar żądanego fragmentu mieści się w zakresie smallbin) i (`victim` jest ostatnim resztkowym fragmentem) i (jest to jedyny fragment w nieuporządkowanym binie) i (rozmiar fragmentów >= żądany): **Podziel fragment na 2 fragmenty**:
* Pierwszy fragment pasuje do żądanego rozmiaru i jest zwracany.
* Pozostały fragment staje się nowym ostatnim resztkowym fragmentem. Jest ponownie wstawiany do nieuporządkowanego bina.
1. Ustawia pola `chunk_size` i `chunk_prev_size` odpowiednio dla obu fragmentów.
2. Pierwszy fragment jest zwracany po wywołaniu `alloc_perturb`.
3. Jeśli powyższy warunek jest fałszywy, kontrola dochodzi tutaj. Usuwa `victim` z nieuporządkowanego bina. Jeśli rozmiar `victim` dokładnie pasuje do żądanego rozmiaru, zwraca ten fragment po wywołaniu `alloc_perturb`.
4. Jeśli rozmiar `victim` mieści się w zakresie smallbin, dodaj fragment do odpowiedniego smallbinu na `HEAD`.
5. W przeciwnym razie wstaw do odpowiedniego largebinu, zachowując porządek sortowania:
6. Najpierw sprawdza ostatni fragment (najmniejszy). Jeśli `victim` jest mniejszy niż ostatni fragment, wstawia go na końcu.
7. W przeciwnym razie pętla znajduje fragment o rozmiarze >= rozmiaru `victim`. Jeśli rozmiar jest dokładnie taki sam, zawsze wstawia go na drugiej pozycji.
8. Powtarza ten cały krok maksymalnie `MAX_ITERS` (10000) razy lub dopóki wszystkie fragmenty w nieuporządkowanym binie nie zostaną wyczerpane.
7. Po sprawdzeniu nieuporządkowanych fragmentów, sprawdź, czy żądany rozmiar nie mieści się w zakresie smallbin, jeśli tak, sprawdź **largebiny**.
1. Uzyskuje indeks do tablicy largebinów, aby uzyskać odpowiedni bin zgodnie z żądanym rozmiarem.
2. Jeśli rozmiar największego fragmentu (pierwszy fragment w binie) jest większy niż żądany rozmiar:
1. Iteruje od 'TAIL', aby znaleźć fragment (`victim`) o najmniejszym rozmiarze >= żądanego rozmiaru.
2. Wywołuje `unlink`, aby usunąć fragment `victim` z bina.
3. Oblicza `remainder_size` dla fragmentu `victim` (będzie to rozmiar fragmentu `victim` - żądany rozmiar).
4. Jeśli ten `remainder_size` >= `MINSIZE` (minimalny rozmiar fragmentu, wliczając nagłówki), dzieli fragment na dwa fragmenty. W przeciwnym razie cały fragment `victim` zostanie zwrócony. Wstaw pozostały fragment do nieuporządkowanego bina (na końcu 'TAIL'). W nieuporządkowanym binie sprawdzane jest, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. W przeciwnym razie zostanie zgłoszony błąd ("malloc(): uszkodzone nieuporządkowane fragmenty").
5. Zwraca fragment `victim` po wywołaniu `alloc_perturb`.
8. Do tej pory sprawdziliśmy nieuporządkowany bin oraz odpowiedni fast, small lub large bin. Zauważ, że pojedynczy bin (fast lub small) był sprawdzany z **dokładnym** rozmiarem żądanego fragmentu. Powtarzaj następujące kroki, aż wszystkie biny zostaną wyczerpane:
1. Indeks do tablicy binów jest inkrementowany, aby sprawdzić następny bin.
2. Użyj mapy `av->binmap`, aby pominąć biny, które są puste.
3. `victim` wskazuje na 'TAIL' bieżącego bina.
4. Używając mapy binów, zapewnia, że jeśli bin zostanie pominięty (w powyższym 2. kroku), na pewno jest pusty. Jednak nie zapewnia, że wszystkie puste biny zostaną pominięte. Sprawdź, czy `victim` jest pusty czy nie. Jeśli jest pusty, ponownie pomiń bin i powtórz powyższy proces (lub 'kontynuuj' tę pętlę), aż dotrzemy do niepustego bina.
5. Podziel fragment (`victim` wskazuje na ostatni fragment niepustego bina) na dwa fragmenty. Wstaw pozostały fragment do nieuporządkowanego bina (na końcu 'TAIL'). W nieuporządkowanym binie sprawdzane jest, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. W przeciwnym razie zostanie zgłoszony błąd ("malloc(): uszkodzone nieuporządkowane fragmenty 2").
6. Zwraca fragment `victim` po wywołaniu `alloc_perturb`.
9. Jeśli nadal nie zostanie znaleziony pusty bin, fragment 'top' zostanie użyty do obsługi żądania:
1. `victim` wskazuje na `av->top`.
2. Jeśli rozmiar fragmentu 'top' >= 'żądany rozmiar' + `MINSIZE`, dzieli go na dwa fragmenty. W tym przypadku pozostały fragment staje się nowym fragmentem 'top', a inny fragment jest zwracany użytkownikowi po wywołaniu `alloc_perturb`.
3. Sprawdza, czy `av` ma fastchunki czy nie. Jest to sprawdzane poprzez sprawdzenie `FASTCHUNKS_BIT` w `av->flags`. Jeśli tak, wywołuje `malloc_consolidate` na `av`. Powrót do kroku 6 (gdzie sprawdzamy nieuporządkowany bin).
4. Jeśli `av` nie ma fastchunków, wywołuje `sysmalloc` i zwraca uzyskany wskaźnik po wywołaniu `alloc_perturb`.
## Wolny przepływ

{% hint style="success" %}
(Treść ta pochodzi z [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Sprawdź ostatnią wersję i zaktualizuj)
{% endhint %}

Ostateczna funkcja zwalniania fragmentów pamięci to `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Sprawdź, czy `p` znajduje się przed `p + chunksize(p)` w pamięci (aby uniknąć zawijania). W przeciwnym razie zostanie zgłoszony błąd (`free(): invalid pointer`).
2. Sprawdź, czy rozmiar fragmentu wynosi co najmniej `MINSIZE` lub jest wielokrotnością `MALLOC_ALIGNMENT`. W przeciwnym razie zostanie zgłoszony błąd (`free(): invalid size`).
3. Jeśli rozmiar fragmentu znajduje się na liście fastbin:
1. Sprawdź, czy rozmiar następnego fragmentu mieści się między minimalnym a maksymalnym rozmiarem (`av->system_mem`), w przeciwnym razie zgłoś błąd (`free(): invalid next size (fast)`).
2. Wywołaj `free_perturb` na fragmencie.
3. Ustaw `FASTCHUNKS_BIT` dla `av`.
4. Pobierz indeks do tablicy fastbin zgodnie z rozmiarem fragmentu.
5. Sprawdź, czy góra pojemnika nie jest fragmentem, który dodajemy. W przeciwnym razie zgłoś błąd (`double free or corruption (fasttop)`).
6. Sprawdź, czy rozmiar fragmentu fastbin na górze jest taki sam jak dodawany fragment. W przeciwnym razie zgłoś błąd (`invalid fastbin entry (free)`).
7. Wstaw fragment na górę listy fastbin i zwróć.
4. Jeśli fragment nie jest zmapowany:
1. Sprawdź, czy fragment jest górnym fragmentem czy nie. Jeśli tak, zgłoś błąd (`double free or corruption (top)`).
2. Sprawdź, czy następny fragment (według pamięci) mieści się w granicach areny. Jeśli nie, zgłoś błąd (`double free or corruption (out)`).
3. Sprawdź, czy poprzedni fragment następnego fragmentu (według pamięci) jest oznaczony jako używany czy nie. Jeśli nie, zgłoś błąd (`double free or corruption (!prev)`).
4. Sprawdź, czy rozmiar następnego fragmentu mieści się między minimalnym a maksymalnym rozmiarem (`av->system_mem`). Jeśli nie, zgłoś błąd (`free(): invalid next size (normal)`).
5. Wywołaj `free_perturb` na fragmencie.
6. Jeśli poprzedni fragment (według pamięci) nie jest używany, wywołaj `unlink` na poprzednim fragmencie.
7. Jeśli następny fragment (według pamięci) nie jest górnym fragmentem:
1. Jeśli następny fragment nie jest używany, wywołaj `unlink` na następnym fragmencie.
2. Połącz fragment z poprzednim, następnym (według pamięci), jeśli którykolwiek jest wolny, i dodaj go na początek nieposortowanego pojemnika. Przed wstawieniem sprawdź, czy `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` czy nie. Jeśli nie, zgłoś błąd ("free(): corrupted unsorted chunks").
8. Jeśli następny fragment (według pamięci) był górnym fragmentem, odpowiednio połącz fragmenty w pojedynczy górny fragment.
5. Jeśli fragment był zmapowany, wywołaj `munmap_chunk`.

## Sprawdzenia bezpieczeństwa funkcji sterty

Sprawdź sprawdzenia bezpieczeństwa wykonywane przez często używane funkcje w stercie w:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Odnośniki

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
