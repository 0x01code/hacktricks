# Bins & Asignaciones de Memoria

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Informaci칩n B치sica

Para mejorar la eficiencia en c칩mo se almacenan los fragmentos, cada fragmento no est치 solo en una lista enlazada, sino que hay varios tipos. Estos son los bins y hay 5 tipos de bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) bins peque침os, 63 bins grandes, 1 bin desordenado, 10 bins r치pidos y 64 bins tcache por hilo.

La direcci칩n inicial de cada bin desordenado, peque침o y grande est치 dentro del mismo array. El 칤ndice 0 no se utiliza, el 1 es el bin desordenado, los bins 2-64 son bins peque침os y los bins 65-127 son bins grandes.

### Bins Peque침os

Los bins peque침os son m치s r치pidos que los bins grandes pero m치s lentos que los bins r치pidos.

Cada bin de los 62 tendr치 **fragmentos del mismo tama침o**: 16, 24, ... (con un tama침o m치ximo de 504 bytes en 32 bits y 1024 en 64 bits). Esto ayuda en la rapidez para encontrar el bin donde se debe asignar un espacio e insertar y eliminar entradas en estas listas.

### Bins Grandes

A diferencia de los bins peque침os, que gestionan fragmentos de tama침os fijos, cada **bin grande maneja un rango de tama침os de fragmentos**. Esto es m치s flexible, permitiendo al sistema acomodar **varios tama침os** sin necesidad de un bin separado para cada tama침o.

En un asignador de memoria, los bins grandes comienzan donde terminan los bins peque침os. Los rangos para los bins grandes crecen progresivamente, lo que significa que el primer bin podr칤a cubrir fragmentos de 512 a 576 bytes, mientras que el siguiente cubre de 576 a 640 bytes. Este patr칩n contin칰a, con el bin m치s grande que contiene todos los fragmentos por encima de 1MB.

Los bins grandes son m치s lentos de operar en comparaci칩n con los bins peque침os porque deben **ordenar y buscar a trav칠s de una lista de tama침os de fragmentos variables para encontrar el mejor ajuste** para una asignaci칩n. Cuando se inserta un fragmento en un bin grande, debe ser ordenado, y al asignar memoria, el sistema debe encontrar el fragmento adecuado. Este trabajo adicional los hace **m치s lentos**, pero como las asignaciones grandes son menos comunes que las peque침as, es un compromiso aceptable.

Hay:

* 32 bins de rango de 64B
* 16 bins de rango de 512B
* 8 bins de rango de 4096B
* 4 bins de rango de 32768B
* 2 bins de rango de 262144B
* 1 bin para tama침os restantes

### Bin Desordenado

El bin desordenado es una **cach칠 r치pida** utilizada por el administrador de mont칩n para hacer que la asignaci칩n de memoria sea m치s r치pida. As칤 es como funciona: Cuando un programa libera memoria, el administrador de mont칩n no la coloca inmediatamente en un bin espec칤fico. En su lugar, primero intenta **fusionarla con cualquier fragmento libre vecino** para crear un bloque m치s grande de memoria libre. Luego, coloca este nuevo fragmento en un bin general llamado "bin desordenado".

Cuando un programa **solicita memoria**, el administrador de mont칩n **verifica el bin desordenado** para ver si hay un fragmento de tama침o suficiente. Si encuentra uno, lo utiliza de inmediato. Si no encuentra un fragmento adecuado, mueve los fragmentos liberados a sus bins correspondientes, ya sea peque침os o grandes, seg칰n su tama침o.

Por lo tanto, el bin desordenado es una forma de acelerar la asignaci칩n de memoria reutilizando r치pidamente la memoria liberada recientemente y reduciendo la necesidad de b칰squedas y fusiones que consumen tiempo.

{% hint style="danger" %}
Ten en cuenta que incluso si los fragmentos son de diferentes categor칤as, si un fragmento disponible est치 colisionando con otro fragmento disponible (incluso si son de diferentes categor칤as), se fusionar치n.
{% endhint %}

### Bins R치pidos

Los bins r치pidos est치n dise침ados para **acelerar la asignaci칩n de memoria para fragmentos peque침os** manteniendo fragmentos liberados recientemente en una estructura de acceso r치pido. Estos bins utilizan un enfoque de 칔ltimo en Entrar, Primero en Salir (LIFO), lo que significa que el **fragmento liberado m치s recientemente es el primero** en ser reutilizado cuando hay una nueva solicitud de asignaci칩n. Este comportamiento es ventajoso para la velocidad, ya que es m치s r치pido insertar y eliminar desde la parte superior de una pila (LIFO) en comparaci칩n con una cola (FIFO).

Adem치s, **los bins r치pidos utilizan listas enlazadas simples**, no dobles, lo que mejora a칰n m치s la velocidad. Dado que los fragmentos en los bins r치pidos no se fusionan con vecinos, no es necesario una estructura compleja que permita la eliminaci칩n desde el medio. Una lista enlazada simple es m치s simple y r치pida para estas operaciones.

B치sicamente, lo que sucede aqu칤 es que el encabezado (el puntero al primer fragmento a verificar) siempre apunta al fragmento liberado m치s reciente de ese tama침o. Entonces:

* Cuando se asigna un nuevo fragmento de ese tama침o, el encabezado apunta a un fragmento libre para usar. Como este fragmento libre apunta al siguiente fragmento a usar, esta direcci칩n se almacena en el encabezado para que la pr칩xima asignaci칩n sepa d칩nde obtener un fragmento disponible.
* Cuando se libera un fragmento, el fragmento libre guardar치 la direcci칩n al fragmento disponible actual y la direcci칩n a este fragmento reci칠n liberado se colocar치 en el encabezado.

{% hint style="danger" %}
Los fragmentos en los bins r치pidos no se establecen autom치ticamente como disponibles, por lo que se mantienen como fragmentos de bin r치pido durante alg칰n tiempo en lugar de poder fusionarse con otros fragmentos.
{% endhint %}

### Bins Tcache (Cach칠 por Hilo)

Aunque los hilos intentan tener su propio mont칩n (ver [Arenas](bins-and-memory-allocations.md#arenas) y [Submontones](bins-and-memory-allocations.md#subheaps)), existe la posibilidad de que un proceso con muchos hilos (como un servidor web) **termine compartiendo el mont칩n con otros hilos**. En este caso, la soluci칩n principal es el uso de **bloqueos**, que podr칤an **ralentizar significativamente los hilos**.

Por lo tanto, un tcache es similar a un bin r치pido por hilo en el sentido de que es una **lista enlazada simple** que no fusiona fragmentos. Cada hilo tiene **64 bins tcache enlazados individualmente**. Cada bin puede tener un m치ximo de [7 fragmentos del mismo tama침o](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) que van desde [24 a 1032B en sistemas de 64 bits y de 12 a 516B en sistemas de 32 bits](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

Cuando un hilo **libera** un fragmento, **si no es demasiado grande** para ser asignado en el tcache y el bin tcache **no est치 lleno** (ya tiene 7 fragmentos), **se asignar치 all칤**. Si no puede ir al tcache, deber치 esperar a que el bloqueo del mont칩n est칠 disponible para poder realizar la operaci칩n de liberaci칩n global.

Cuando se **asigna un fragmento**, si hay un fragmento libre del tama침o necesario en el **tcache, se utilizar치**, de lo contrario, deber치 esperar a que el bloqueo del mont칩n est칠 disponible para encontrar uno en los bins globales o crear uno nuevo.\
Tambi칠n hay una optimizaci칩n, en este caso, mientras tiene el bloqueo del mont칩n, el hilo **llenar치 su tcache con fragmentos del mont칩n (7) del tama침o solicitado**, por lo que en caso de que necesite m치s, los encontrar치 en el tcache.
## Flujo de Asignaci칩n

{% hint style="success" %}
(Esta explicaci칩n actual es de [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Verificar la 칰ltima versi칩n y actualizarla)
{% endhint %}

Las asignaciones se realizan finalmente con la funci칩n: `void * _int_malloc (mstate av, size_t bytes)` y siguen este orden:

1. Actualiza `bytes` para tener en cuenta **alineaciones**, etc.
2. Verifica si `av` es **NULL** o no.
3. En caso de ausencia de **치rea utilizable** (cuando `av` es NULL), llama a `sysmalloc` para obtener un fragmento usando mmap. Si tiene 칠xito, llama a `alloc_perturb`. Devuelve el puntero.
4. Dependiendo del tama침o:
* \[Adici칩n a lo original] Usa tcache antes de verificar el siguiente fastbin.
* \[Adici칩n a lo original] Si no hay tcache pero se utiliza un bin diferente (ver paso posterior), intenta llenar tcache desde ese bin.
* Si el tama침o cae en el rango de **fastbin**:
1. Obtiene un 칤ndice en el array de fastbin para acceder a un bin apropiado seg칰n el tama침o solicitado.
2. Elimina el primer fragmento en ese bin y hace que `v칤ctima` apunte a 칠l.
3. Si `v칤ctima` es NULL, pasa al siguiente caso (smallbin).
4. Si `v칤ctima` no es NULL, verifica el tama침o del fragmento para asegurarse de que pertenezca a ese bin en particular. De lo contrario, se lanza un error ("malloc(): corrupci칩n de memoria (fast)").
5. Llama a `alloc_perturb` y luego devuelve el puntero.
* Si el tama침o cae en el rango de **smallbin**:
1. Obtiene un 칤ndice en el array de smallbin para acceder a un bin apropiado seg칰n el tama침o solicitado.
2. Si no hay fragmentos en este bin, pasa al siguiente caso. Esto se verifica comparando los punteros `bin` y `bin->bk`.
3. `v칤ctima` se iguala a `bin->bk` (el 칰ltimo fragmento en el bin). Si es NULL (ocurre durante la `inicializaci칩n`), llama a `malloc_consolidate` y salta este paso completo de verificaci칩n en diferentes bins.
4. De lo contrario, cuando `v칤ctima` no es NULL, verifica si `victim->bk->fd` y `v칤ctima` son iguales o no. Si no son iguales, se lanza un error (`malloc(): lista doblemente enlazada de smallbin corrompida`).
5. Establece el bit PREV\_INSUSE para el siguiente fragmento (en memoria, no en la lista doblemente enlazada) para `v칤ctima`.
6. Elimina este fragmento de la lista del bin.
7. Establece el bit de arena apropiado para este fragmento seg칰n `av`.
8. Llama a `alloc_perturb` y luego devuelve el puntero.
* Si el tama침o no cae en el rango de smallbin:
1. Obtiene un 칤ndice en el array de largebin para acceder a un bin apropiado seg칰n el tama침o solicitado.
2. Verifica si `av` tiene fastchunks o no. Esto se hace verificando el `FASTCHUNKS_BIT` en `av->flags`. Si es as칤, llama a `malloc_consolidate` en `av`.
5. Si a칰n no se ha devuelto ning칰n puntero, esto significa uno o m치s de los siguientes casos:
1. El tama침o cae en el rango de 'fastbin' pero no hay fastchunk disponible.
2. El tama침o cae en el rango de 'smallbin' pero no hay smallchunk disponible (llama a `malloc_consolidate` durante la inicializaci칩n).
3. El tama침o cae en el rango de 'largebin'.
6. A continuaci칩n, se verifican los **fragmentos no ordenados** y los fragmentos recorridos se colocan en bins. Este es el 칰nico lugar donde se colocan los fragmentos en bins. Itera el bin no ordenado desde la 'COLA'.
1. `v칤ctima` apunta al fragmento actual que se est치 considerando.
2. Verifica si el tama침o del fragmento de `v칤ctima` est치 dentro del rango m칤nimo (`2*SIZE_SZ`) y m치ximo (`av->system_mem`). De lo contrario, lanza un error (`malloc(): corrupci칩n de memoria`).
3. Si (el tama침o del fragmento solicitado cae en el rango de smallbin) y (`v칤ctima` es el 칰ltimo fragmento restante) y (es el 칰nico fragmento en el bin no ordenado) y (el tama침o de los fragmentos >= el solicitado): **Divide el fragmento en 2 fragmentos**:
* El primer fragmento coincide con el tama침o solicitado y se devuelve.
* El fragmento restante se convierte en el nuevo 칰ltimo fragmento restante. Se inserta de nuevo en el bin no ordenado.
1. Establece los campos `chunk_size` y `chunk_prev_size` apropiadamente para ambos fragmentos.
2. Se devuelve el primer fragmento despu칠s de llamar a `alloc_perturb`.
3. Si la condici칩n anterior es falsa, el control llega aqu칤. Elimina `v칤ctima` del bin no ordenado. Si el tama침o de `v칤ctima` coincide exactamente con el tama침o solicitado, devuelve este fragmento despu칠s de llamar a `alloc_perturb`.
4. Si el tama침o de `v칤ctima` cae en el rango de smallbin, agrega el fragmento en el smallbin apropiado en la `CABEZA`.
5. De lo contrario, inserta en el largebin apropiado manteniendo el orden ordenado:
6. Primero verifica el 칰ltimo fragmento (m치s peque침o). Si `v칤ctima` es m치s peque침a que el 칰ltimo fragmento, lo inserta al final.
7. De lo contrario, bucle para encontrar un fragmento con un tama침o >= al tama침o de `v칤ctima`. Si el tama침o es exactamente el mismo, siempre se inserta en la segunda posici칩n.
8. Repite este paso completo un m치ximo de `MAX_ITERS` (10000) veces o hasta que se agoten todos los fragmentos en el bin no ordenado.
7. Despu칠s de verificar los fragmentos no ordenados, verifica si el tama침o solicitado no cae en el rango de smallbin, si es as칤, verifica los **largebins**.
1. Obtiene un 칤ndice en el array de largebin para acceder a un bin apropiado seg칰n el tama침o solicitado.
2. Si el tama침o del fragmento m치s grande (el primer fragmento en el bin) es mayor que el tama침o solicitado:
1. Itera desde la 'COLA' para encontrar un fragmento (`v칤ctima`) con el tama침o m치s peque침o >= al tama침o solicitado.
2. Llama a `unlink` para eliminar el fragmento `v칤ctima` del bin.
3. Calcula `remainder_size` para el fragmento de `v칤ctima` (esto ser치 el tama침o del fragmento de `v칤ctima` - tama침o solicitado).
4. Si este `remainder_size` >= `MINSIZE` (el tama침o m칤nimo del fragmento incluyendo los encabezados), divide el fragmento en dos fragmentos. De lo contrario, se devolver치 todo el fragmento de `v칤ctima`. Inserta el fragmento restante en el bin no ordenado (en el extremo 'COLA'). Se realiza una verificaci칩n en el bin no ordenado si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Se lanza un error de lo contrario ("malloc(): fragmentos no ordenados corruptos").
5. Devuelve el fragmento de `v칤ctima` despu칠s de llamar a `alloc_perturb`.
8. Hasta ahora, hemos verificado el bin no ordenado y tambi칠n el respectivo bin fast, small o large. Tenga en cuenta que se verific칩 un solo bin (fast o small) usando el tama침o **exacto** del fragmento solicitado. Repita los siguientes pasos hasta que se agoten todos los bins:
1. Se incrementa el 칤ndice en el array de bin para verificar el siguiente bin.
2. Usa el mapa `av->binmap` para saltar los bins que est치n vac칤os.
3. `v칤ctima` apunta a la 'COLA' del bin actual.
4. El uso del binmap asegura que si se salta un bin (en el paso 2 anterior), definitivamente est치 vac칤o. Sin embargo, no garantiza que se salten todos los bins vac칤os. Verifica si la v칤ctima est치 vac칤a o no. Si est치 vac칤a, nuevamente salta el bin y repite el proceso anterior (o 'contin칰a' este bucle) hasta llegar a un bin no vac칤o.
5. Divide el fragmento (`v칤ctima` apunta al 칰ltimo fragmento de un bin no vac칤o) en dos fragmentos. Inserta el fragmento restante en el bin no ordenado (en el extremo 'COLA'). Se realiza una verificaci칩n en el bin no ordenado si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Se lanza un error de lo contrario ("malloc(): fragmentos no ordenados corruptos 2").
6. Devuelve el fragmento de `v칤ctima` despu칠s de llamar a `alloc_perturb`.
9. Si a칰n no se encuentra un bin vac칤o, se utilizar치 el fragmento 'top' para atender la solicitud:
1. `v칤ctima` apunta a `av->top`.
2. Si el tama침o del fragmento 'top' >= 'tama침o solicitado' + `MINSIZE`, div칤dalo en dos fragmentos. En este caso, el fragmento restante se convierte en el nuevo fragmento 'top' y el otro fragmento se devuelve al usuario despu칠s de llamar a `alloc_perturb`.
3. Verifica si `av` tiene fastchunks o no. Esto se hace verificando el `FASTCHUNKS_BIT` en `av->flags`. Si es as칤, llama a `malloc_consolidate` en `av`. Vuelve al paso 6 (donde verificamos el bin no ordenado).
4. Si `av` no tiene fastchunks, llama a `sysmalloc` y devuelve el puntero obtenido despu칠s de llamar a `alloc_perturb`.
## Flujo Libre

{% hint style="success" %}
(Esta explicaci칩n actual es de [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Verificar la 칰ltima versi칩n y actualizarla)
{% endhint %}

La funci칩n final que libera fragmentos de memoria es `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Verificar si `p` est치 antes de `p + chunksize(p)` en la memoria (para evitar desbordamientos). De lo contrario, se lanza un error (`free(): invalid pointer`).
2. Verificar si el fragmento tiene al menos el tama침o `MINSIZE` o es un m칰ltiplo de `MALLOC_ALIGNMENT`. De lo contrario, se lanza un error (`free(): invalid size`).
3. Si el tama침o del fragmento est치 en la lista de fastbins:
1. Verificar si el tama침o del siguiente fragmento est치 entre el tama침o m칤nimo y m치ximo (`av->system_mem`), lanzar un error (`free(): invalid next size (fast)`) de lo contrario.
2. Llamar a `free_perturb` en el fragmento.
3. Establecer `FASTCHUNKS_BIT` para `av`.
4. Obtener el 칤ndice en el array de fastbins seg칰n el tama침o del fragmento.
5. Verificar si la parte superior del bin no es el fragmento que vamos a agregar. De lo contrario, lanzar un error (`double free or corruption (fasttop)`).
6. Verificar si el tama침o del fragmento de fastbin en la parte superior es el mismo que el fragmento que estamos agregando. De lo contrario, lanzar un error (`invalid fastbin entry (free)`).
7. Insertar el fragmento en la parte superior de la lista de fastbins y retornar.
4. Si el fragmento no est치 asignado din치micamente:
1. Verificar si el fragmento es el fragmento superior o no. Si es as칤, se lanza un error (`double free or corruption (top)`).
2. Verificar si el siguiente fragmento (por memoria) est치 dentro de los l칤mites del 치rea. Si no, se lanza un error (`double free or corruption (out)`).
3. Verificar si el bit previo en uso del siguiente fragmento (por memoria) est치 marcado o no. Si no, se lanza un error (`double free or corruption (!prev)`).
4. Verificar si el tama침o del siguiente fragmento est치 entre el tama침o m칤nimo y m치ximo (`av->system_mem`). Si no, se lanza un error (`free(): invalid next size (normal)`).
5. Llamar a `free_perturb` en el fragmento.
6. Si el fragmento previo (por memoria) no est치 en uso, llamar a `unlink` en el fragmento previo.
7. Si el siguiente fragmento (por memoria) no es el fragmento superior:
1. Si el siguiente fragmento no est치 en uso, llamar a `unlink` en el siguiente fragmento.
2. Fusionar el fragmento con el anterior, siguiente (por memoria), si alguno est치 libre y agregarlo al principio del bin desordenado. Antes de insertar, verificar si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` o no. Si no, se lanza un error ("free(): corrupted unsorted chunks").
8. Si el siguiente fragmento (por memoria) era un fragmento superior, fusionar los fragmentos adecuadamente en un 칰nico fragmento superior.
5. Si el fragmento estaba asignado din치micamente, llamar a `munmap_chunk`.

## Verificaciones de Seguridad de Funciones de Heap

Verifique las verificaciones de seguridad realizadas por funciones ampliamente utilizadas en el heap en:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Referencias

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
