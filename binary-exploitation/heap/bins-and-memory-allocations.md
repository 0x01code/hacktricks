# Bins & Memory Allocations

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>

## 基本情報

チャンクが格納される効率を向上させるために、各チャンクは1つのリンクリストにだけではなく、複数のタイプに分かれています。これらはビンであり、5種類のビンがあります：[62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) small bins、63 large bins、1 unsorted bin、10 fast bins、およびスレッドごとに64 tcache bins。

各unsorted、small、large binsへの初期アドレスは同じ配列内にあります。インデックス0は未使用で、1はunsorted bin、2から64はsmall bins、65から127はlarge binsです。

### Small Bins

Small binsはlarge binsよりも速く、fast binsよりも遅いです。

62の各binには**同じサイズのチャンク**があります：16、24、...（32ビットでは最大504バイト、64ビットでは1024バイト）。これにより、空間を割り当てるべきビンを見つける速度や、これらのリストへのエントリの挿入と削除の速度が向上します。

### Large Bins

固定サイズのチャンクを管理するsmall binsとは異なり、各**large binはチャンクサイズの範囲を扱います**。これにより、システムが**さまざまなサイズ**を別々のビンなしで収容できるようになります。

メモリアロケーターでは、large binsはsmall binsが終わるところから始まります。large binsの範囲は徐々に大きくなり、最初のbinは512から576バイトのチャンクをカバーし、次のbinは576から640バイトをカバーします。このパターンは続き、最大のbinには1MB以上のすべてのチャンクが含まれます。

large binsはsmall binsと比較して操作が遅くなります。なぜなら、適切な割り当てを見つけるために**さまざまなチャンクサイズのリストをソートして検索**する必要があるからです。チャンクがlarge binに挿入されるときはソートする必要があり、メモリが割り当てられるときは適切なチャンクを見つける必要があります。この追加作業により、large binsは**遅く**なりますが、大きな割り当ては小さな割り当てよりも一般的ではないため、受け入れられるトレードオフです。

以下があります：

* 64B範囲の32 bins
* 512B範囲の16 bins
* 4096B範囲の8 bins
* 32768B範囲の4 bins
* 262144B範囲の2 bins
* 残りのサイズ用の1 bin

### Unsorted Bin

unsorted binは、メモリ割り当てを迅速に行うためにヒープマネージャーが使用する**高速キャッシュ**です。動作方法は次のとおりです：プログラムがメモリを解放するとき、ヒープマネージャーはそれをすぐに特定のビンに入れません。代わりに、隣接する空きチャンクとマージして大きな空きメモリブロックを作成しようとします。その後、この新しいチャンクを「unsorted bin」と呼ばれる一般的なビンに配置します。

プログラムがメモリを要求するとき、ヒープマネージャーはunsorted binをチェックして十分なサイズのチャンクがあるかどうかを確認します。適切なチャンクが見つかれば、すぐに使用します。適切なチャンクが見つからない場合は、サイズに基づいてそれらを対応するsmall binまたはlarge binに移動します。

したがって、unsorted binは、最近解放されたメモリを迅速に再利用し、時間のかかる検索とマージの必要性を減らすことでメモリ割り当てを高速化する方法です。

{% hint style="danger" %}
異なるカテゴリのチャンクであっても、利用可能なチャンクが他の利用可能なチャンクと衝突している場合（カテゴリが異なっていても）、それらはマージされます。
{% endhint %}

### Fast Bins

Fast binsは、最近解放されたチャンクをクイックアクセス構造に保持することで、小さなチャンクのメモリ割り当てを**高速化する**ように設計されています。これらのビンは、最後に解放されたチャンクが新しい割り当て要求があるときに最初に再利用される**Last-In, First-Out（LIFO）**アプローチを使用します。この動作は速度にとって有利であり、スタック（LIFO）のトップから挿入および削除を行うのは、キュー（FIFO）よりも速いからです。

さらに、**fast binsは単方向リンクリスト**を使用し、ダブルリンクリストではないため、速度が向上します。fast binsのチャンクは隣接するチャンクとマージされないため、中央からの削除を許可する複雑な構造は不要です。単方向リンクリストは、これらの操作に対してより単純で速いです。

基本的に、ここで起こることは、ヘッダー（チェックする最初のチャンクへのポインタ）が常にそのサイズの最新の解放されたチャンクを指すようになっていることです。したがって：

* そのサイズの新しいチャンクが割り当てられると、ヘッダーは使用する空きチャンクを指すようになります。この空きチャンクが次に使用するチャンクを指しているため、このアドレスはヘッダーに保存され、次の割り当てがどこから利用可能なチャンクを取得するかを知ることができます。
* チャンクが解放されると、空きチャンクは現在の利用可能なチャンクへのアドレスを保存し、この新しく解放されたチャンクへのアドレスがヘッダーに配置されます。

{% hint style="danger" %}
fast binsのチャンクは自動的に利用可能に設定されないため、他のチャンクとマージできる代わりに一定時間fast binチャンクとして保持されます。
{% endhint %}

### Tcache（スレッドごとのキャッシュ）Bins

スレッドは独自のヒープを持とうとしますが（[Arenas](bins-and-memory-allocations.md#arenas)および[Subheaps](bins-and-memory-allocations.md#subheaps)を参照）、多くのスレッドを持つプロセス（Webサーバーなど）**は他のスレッドとヒープを共有する可能性**があります。この場合、主な解決策は**ロッカー**の使用であり、これによりスレッドの**遅延が著しく遅くなる**可能性があります。

したがって、tcacheは、スレッドごとのfast binのように、チャンクをマージしない**単方向リンクリスト**であるという点で似ています。各スレッドには**64個の単方向リンクtcache bins**があります。各ビンには、[64ビットシステムでは24から1032B、32ビットシステムでは12から516B](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315)の[同じサイズのチャンクが最大7つ](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323)含まれます。

スレッドが**チャンクを解放する**とき、それがtcacheに割り当てられるには**大きすぎない**かつ対応するtcache binが**満杯でない**（すでに7つのチャンクがある）必要があります。tcacheに移動できない場合は、グローバルなビンで解放操作を行うためにヒープロックを待たなければなりません。

**チャンクが割り当てられる**とき、**Tcacheに必要なサイズの空きチャンクがあれば使用**されます。そうでない場合は、グローバルビンで見つけるためにヒープロックを待たなければなりません。\
また、この場合の最適化があり、ヒープロックを取得する間、スレッドは要求されたサイズのヒープチャンク（7つ）でTcacheを埋めることになります。したがって、必要があればTcacheでそれらを見つけることができます。
## 割り当てフロー

{% hint style="success" %}
(この現在の説明は[https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions)から取得されています。TODO: 最新バージョンを確認して更新する)
{% endhint %}

割り当ては最終的に関数`void * _int_malloc (mstate av, size_t bytes)`で実行され、以下の順序で行われます:

1. **アライメント**などを考慮して`bytes`を更新します。
2. `av`が**NULL**かどうかをチェックします。
3. **使用可能なアリーナ**が存在しない場合（`av`がNULLの場合）、`sysmalloc`を呼び出してmmapを使用してチャンクを取得します。成功した場合、`alloc_perturb`を呼び出します。ポインタを返します。
4. サイズに応じて:
* \[元の内容に追加] 次のfastbinをチェックする前にtcacheを使用します。
* \[元の内容に追加] tcacheがないが異なるbinが使用される場合（後のステップで説明）、そのbinからtcacheを埋めようとします。
* サイズが**fastbin**範囲にある場合:&#x20;
1. 適切なbinにアクセスするためのfastbin配列へのインデックスを取得します。
2. そのbin内の最初のチャンクを削除し、`victim`をそれを指すようにします。
3. `victim`がNULLの場合は、次のケース（smallbin）に進みます。
4. `victim`がNULLでない場合は、そのチャンクのサイズをチェックして、特定のbinに属していることを確認します。そうでない場合はエラー（"malloc(): memory corruption (fast)"）がスローされます。
5. `alloc_perturb`を呼び出してからポインタを返します。
* サイズが**smallbin**範囲にある場合:
1. 適切なbinにアクセスするためのsmallbin配列へのインデックスを取得します。
2. このbinにチャンクがない場合は、次のケースに進みます。これは、ポインタ`bin`と`bin->bk`を比較して確認されます。
3. `victim`は`bin->bk`（bin内の最後のチャンク）に等しくなります。NULLの場合（`初期化`中に発生）、`malloc_consolidate`を呼び出して、異なるbinをチェックするこの完全なステップをスキップします。
4. それ以外の場合、`victim`がNULLでない場合は、`victim->bk->fd`と`victim`が等しいかどうかをチェックします。等しくない場合は、エラー（`malloc(): smallbin double linked list corrupted`）がスローされます。
5. `victim`の次のチャンク（ダブルリンクリストではなくメモリ内）のためにPREV\_INSUSEビットを設定します。
6. このチャンクをbinリストから削除します。
7. `av`に応じてこのチャンクの適切なアリーナビットを設定します。
8. `alloc_perturb`を呼び出してからポインタを返します。
* サイズがsmallbin範囲にない場合:
1. 適切なbinにアクセスするためのlargebin配列へのインデックスを取得します。
2. `av`にfastchunksがあるかどうかを確認します。これは、`av->flags`の`FASTCHUNKS_BIT`をチェックすることで行われます。そうであれば、`av`で`malloc_consolidate`を呼び出します。
5. まだポインタが返されていない場合、次のいずれかが1つ以上の場合を示します:
1. サイズが「fastbin」範囲に該当するが、fastchunkが利用できない場合。
2. サイズが「smallbin」範囲に該当するが、smallchunkが利用できない場合（初期化中に`malloc_consolidate`を呼び出す）。
3. サイズが「largbin」範囲に該当する場合。
6. 次に、**unsorted chunks**がチェックされ、トラバースされたチャンクがbinに配置されます。これは、チャンクがbinに配置される唯一の場所です。unsorted binを'TAIL'から反復処理します。
1. `victim`は現在考慮されているチャンクを指します。
2. `victim`のチャンクサイズが最小値（`2*SIZE_SZ`）と最大値（`av->system_mem`）の範囲内にあるかどうかをチェックします。そうでない場合はエラー（`malloc(): memory corruption`）がスローされます。
3. （要求されたチャンクのサイズがsmallbin範囲にある）かつ（`victim`が最後の残りのチャンクであり）かつ（unsorted bin内に唯一のチャンクであり）かつ（チャンクのサイズが要求されたサイズ以上である）場合: **チャンクを2つに分割**します:
* 最初のチャンクは要求されたサイズに一致し、返されます。
* 残りのチャンクは新しい最後の残りのチャンクとなります。これはunsorted binに再挿入されます。
1. 両方のチャンクの`chunk_size`と`chunk_prev_size`フィールドを適切に設定します。
2. 最初のチャンクは`alloc_perturb`を呼び出した後に返されます。
3. 上記の条件が偽の場合、ここに制御が到達します。`victim`をunsorted binから削除します。`victim`のサイズが要求されたサイズと完全に一致する場合は、これを返します（`alloc_perturb`を呼び出した後）。
4. `victim`のサイズがsmallbin範囲にある場合、チャンクを適切なsmallbinに`HEAD`に追加します。
5. それ以外の場合は、適切なlargebinに挿入し、ソートされた順序を維持します:
6. 最後のチャンク（最小）を最初にチェックします。`victim`が最後のチャンクよりも小さい場合、最後に挿入します。
7. それ以外の場合は、`victim`よりもサイズが大きいチャンクを見つけるためにループします。サイズが完全に同じ場合は、常に2番目の位置に挿入します。
8. このステップ全体を最大`MAX_ITERS`（10000）回、またはunsorted bin内のすべてのチャンクが使い果たされるまで繰り返します。
7. unsorted chunksをチェックした後、要求されたサイズがsmallbin範囲にない場合は、**largebins**をチェックします。
1. 適切なbinにアクセスするためのlargebin配列へのインデックスを取得します。
2. 最大のチャンク（bin内の最初のチャンク）のサイズが要求されたサイズよりも大きい場合:
1. 'TAIL'からイテレートして、要求されたサイズ以上の最小サイズのチャンク（`victim`）を見つけます。
2. `unlink`を呼び出して、binから`victim`チャンクを削除します。
3. `victim`のチャンクの`remainder_size`を計算します（これは`victim`のチャンクサイズ - 要求されたサイズになります）。
4. この`remainder_size`が`MINSIZE`（ヘッダを含む最小のチャンクサイズ）以上であれば、チャンクを2つに分割します。そうでない場合、全体の`victim`チャンクが返されます。残りのチャンクをunsorted binに挿入します（'TAIL'の末尾に）。unsorted binで`unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`をチェックします。そうでない場合はエラーがスローされます（"malloc(): corrupted unsorted chunks"）。
5. `victim`チャンクを`alloc_perturb`を呼び出してから返します。
8. これまでにunsorted binとそれに対応するfast、small、またはlarge binをチェックしました。要求されたチャンクの**正確な**サイズで単一のbin（fastまたはsmall）がチェックされました。すべてのbinが使い果たされるまで以下の手順を繰り返します:
1. bin配列へのインデックスを増やして、次のbinをチェックします。
2. 空のbinをスキップするために`av->binmap`マップを使用します。
3. `victim`を現在のbinの'TAIL'に指します。
4. binmapを使用すると、binがスキップされた場合（上記の2番目のステップで）、それは確実に空であることを保証します。ただし、すべての空のbinがスキップされることは保証しません。victimが空かどうかをチェックします。空の場合は、再度binをスキップして上記のプロセスを繰り返します（またはこのループを「継続」します）。
5. チャンクを分割します（`victim`は空でないbinの最後のチャンクを指します）。残りのチャンクをunsorted binに挿入します（'TAIL'の末尾に）。unsorted binで`unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`をチェックします。そうでない場合はエラーがスローされます（"malloc(): corrupted unsorted chunks 2"）。
6. `victim`チャンクを`alloc_perturb`を呼び出してから返します。
9. まだ空のbinが見つからない場合、'top'チャンクがリクエストを処理するために使用されます:
1. `victim`は`av->top`を指します。
2. 'top'チャンクのサイズが'requested size' + `MINSIZE`よりも大きい場合、それを2つのチャンクに分割します。この場合、残りのチャンクは新しい'top'チャンクとなり、他のチャンクは`alloc_perturb`を呼び出してユーザーに返されます。
3. `av`にfastchunksがあるかどうかを確認します。これは、`av->flags`の`FASTCHUNKS_BIT`をチェックすることで行われます。そうであれば、`av`で`malloc_consolidate`を呼び出します。ステップ6（unsorted binをチェックする場所）に戻ります。
4. `av`にfastchunksがない場合、`sysmalloc`を呼び出して、`alloc_perturb`を呼び出して得られたポインタを返します。
## フリーフロー

{% hint style="success" %}
(この説明は[https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)から取得されています。TODO: 最新バージョンを確認して更新する)
{% endhint %}

メモリのチャンクを解放する最終関数は `_int_free (mstate av, mchunkptr p, int have_lock)` です：

1. `p` がメモリ内の `p + chunksize(p)` より前にあるかどうかをチェックします（ラップを避けるため）。そうでない場合はエラー (`free(): invalid pointer`) が発生します。
2. チャンクが少なくとも `MINSIZE` または `MALLOC_ALIGNMENT` の倍数のサイズであるかどうかをチェックします。そうでない場合はエラー (`free(): invalid size`) が発生します。
3. チャンクのサイズが fastbin リストに含まれる場合：
1. 次のチャンクのサイズが最小サイズと最大サイズ (`av->system_mem`) の間にあるかどうかをチェックし、そうでない場合はエラー (`free(): invalid next size (fast)`) が発生します。
2. チャンクに `free_perturb` を呼び出します。
3. `av` のために `FASTCHUNKS_BIT` を設定します。
4. チャンクサイズに応じて fastbin 配列内のインデックスを取得します。
5. バイナリのトップが追加するチャンクでないことを確認します。そうでない場合はエラー (`double free or corruption (fasttop)`) が発生します。
6. バイナリのトップにある fastbin チャンクのサイズが追加するチャンクと同じかどうかを確認します。そうでない場合はエラー (`invalid fastbin entry (free)`) が発生します。
7. チャンクを fastbin リストのトップに挿入して返します。
4. チャンクが mmapped されていない場合：
1. チャンクがトップチャンクかどうかをチェックします。はいの場合、エラー (`double free or corruption (top)`) が発生します。
2. 次のチャンク（メモリ上）がアリーナの境界内にあるかどうかをチェックします。そうでない場合はエラー (`double free or corruption (out)`) が発生します。
3. 次のチャンク（メモリ上）の前の使用ビットがマークされているかどうかをチェックします。そうでない場合はエラー (`double free or corruption (!prev)`) が発生します。
4. 次のチャンクのサイズが最小サイズと最大サイズ (`av->system_mem`) の間にあるかどうかをチェックします。そうでない場合はエラー (`free(): invalid next size (normal)`) が発生します。
5. チャンクに `free_perturb` を呼び出します。
6. 前のチャンク（メモリ上）が使用されていない場合、前のチャンクに `unlink` を呼び出します。
7. 次のチャンク（メモリ上）がトップチャンクでない場合：
1. 次のチャンクが使用されていない場合、次のチャンクに `unlink` を呼び出します。
2. チャンクを前のチャンク、次のチャンク（メモリ上）とマージし、空きがあれば未整列バイナリの先頭に追加します。挿入する前に、`unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` かどうかを確認します。そうでない場合はエラー ("free(): corrupted unsorted chunks") が発生します。
8. 次のチャンク（メモリ上）がトップチャンクだった場合、適切にチャンクを単一のトップチャンクにマージします。
5. チャンクが mmapped されていた場合、`munmap_chunk` を呼び出します。

## ヒープ関数のセキュリティチェック

ヒープ内で頻繁に使用される関数によって実行されるセキュリティチェックを確認します:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## 参考文献

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* 💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする
* **ハッキングトリックを共有する** には、[**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の GitHub リポジトリに PR を提出してください

</details>
