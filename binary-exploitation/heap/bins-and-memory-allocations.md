# Bins & Assegnazioni di Memoria

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di Base

Per migliorare l'efficienza su come i chunk sono memorizzati, ogni chunk non √® solo in una lista concatenata, ma ci sono diversi tipi. Questi sono i bins e ci sono 5 tipi di bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) small bins, 63 large bins, 1 unsorted bin, 10 fast bins e 64 tcache bins per thread.

L'indirizzo iniziale per ogni bin non ordinato, small e large √® all'interno dello stesso array. L'indice 0 non √® utilizzato, 1 √® l'unsorted bin, i bins 2-64 sono small bins e i bins 65-127 sono large bins.

### Small Bins

I small bins sono pi√π veloci dei large bins ma pi√π lenti dei fast bins.

Ogni bin dei 62 avr√† **chunk della stessa dimensione**: 16, 24, ... (con una dimensione massima di 504 byte in 32 bit e 1024 in 64 bit). Questo aiuta nella velocit√† nel trovare il bin in cui dovrebbe essere allocato uno spazio e nell'inserimento e rimozione delle voci in queste liste.

### Large Bins

A differenza dei small bins, che gestiscono chunk di dimensioni fisse, ogni **large bin gestisce un intervallo di dimensioni di chunk**. Questo √® pi√π flessibile, consentendo al sistema di ospitare **varie dimensioni** senza la necessit√† di un bin separato per ogni dimensione.

In un allocatore di memoria, i large bins iniziano dove finiscono i small bins. Gli intervalli per i large bins crescono progressivamente, il che significa che il primo bin potrebbe coprire chunk da 512 a 576 byte, mentre il successivo copre da 576 a 640 byte. Questo modello continua, con il bin pi√π grande che contiene tutti i chunk sopra 1MB.

I large bins sono pi√π lenti da gestire rispetto ai small bins perch√© devono **ordinare e cercare in una lista di dimensioni di chunk variabili per trovare la migliore corrispondenza** per un'allocazione. Quando un chunk viene inserito in un large bin, deve essere ordinato e quando viene allocata memoria, il sistema deve trovare il chunk giusto. Questo lavoro aggiuntivo li rende **pi√π lenti**, ma poich√© le allocazioni di grandi dimensioni sono meno comuni di quelle piccole, √® un compromesso accettabile.

Ci sono:

* 32 bins di intervallo 64B
* 16 bins di intervallo 512B
* 8 bins di intervallo 4096B
* 4 bins di intervallo 32768B
* 2 bins di intervallo 262144B
* 1 bin per dimensioni rimanenti

### Unsorted Bin

L'unsorted bin √® una **cache veloce** utilizzata dal gestore dell'heap per rendere pi√π veloce l'allocazione di memoria. Ecco come funziona: quando un programma libera memoria, il gestore dell'heap non la mette immediatamente in un bin specifico. Invece, cerca prima di **unirla con eventuali chunk liberi adiacenti** per creare un blocco pi√π grande di memoria libera. Quindi, inserisce questo nuovo chunk in un bin generale chiamato "unsorted bin".

Quando un programma **richiede memoria**, il gestore dell'heap **controlla l'unsorted bin** per vedere se c'√® un chunk di dimensioni adeguate. Se ne trova uno, lo utilizza immediatamente. Se non trova un chunk adatto, sposta i chunk liberati nei rispettivi bins, sia small che large, in base alla loro dimensione.

Quindi, l'unsorted bin √® un modo per velocizzare l'allocazione di memoria riutilizzando rapidamente la memoria liberata di recente e riducendo la necessit√† di ricerche e fusioni che richiedono tempo.

{% hint style="danger" %}
Nota che anche se i chunk sono di categorie diverse, se un chunk disponibile entra in collisione con un altro chunk disponibile (anche se sono di categorie diverse), verranno uniti.
{% endhint %}

### Fast Bins

I fast bins sono progettati per **accelerare l'allocazione di memoria per chunk piccoli** mantenendo i chunk liberati di recente in una struttura di accesso rapido. Questi bins utilizzano un approccio Last-In, First-Out (LIFO), il che significa che il **chunk liberato pi√π di recente √® il primo** ad essere riutilizzato quando c'√® una nuova richiesta di allocazione. Questo comportamento √® vantaggioso per la velocit√†, poich√© √® pi√π veloce inserire e rimuovere dalla cima di uno stack (LIFO) rispetto a una coda (FIFO).

Inoltre, **i fast bins utilizzano liste collegate singolarmente**, non doppie, il che migliora ulteriormente la velocit√†. Poich√© i chunk nei fast bins non vengono uniti con i vicini, non c'√® bisogno di una struttura complessa che consenta la rimozione dal mezzo. Una lista collegata singolarmente √® pi√π semplice e veloce per queste operazioni.

Fondamentalmente, ci√≤ che accade qui √® che l'intestazione (il puntatore al primo chunk da controllare) punta sempre all'ultimo chunk liberato di quella dimensione. Quindi:

* Quando viene allocato un nuovo chunk di quella dimensione, l'intestazione punta a un chunk libero da utilizzare. Poich√© questo chunk libero punta al successivo da utilizzare, questo indirizzo viene memorizzato nell'intestazione in modo che la prossima allocazione sappia dove ottenere un chunk disponibile
* Quando un chunk viene liberato, il chunk libero salver√† l'indirizzo al chunk disponibile corrente e l'indirizzo a questo nuovo chunk liberato verr√† messo nell'intestazione

{% hint style="danger" %}
I chunk nei fast bins non vengono automaticamente impostati come disponibili, quindi rimangono come chunk fast bin per un po' di tempo invece di poter essere uniti con altri chunk.
{% endhint %}

### Tcache (Cache Per-Thread)

Anche se i thread cercano di avere il proprio heap (vedi [Arenas](bins-and-memory-allocations.md#arenas) e [Subheaps](bins-and-memory-allocations.md#subheaps)), c'√® la possibilit√† che un processo con molti thread (come un server web) **finir√† per condividere l'heap con altri thread**. In questo caso, la soluzione principale √® l'uso di **lock**, che potrebbero **sopprimere significativamente i thread**.

Pertanto, una tcache √® simile a un fast bin per thread nel senso che √® una **lista collegata singolarmente** che non unisce i chunk. Ogni thread ha **64 tcache bins collegati singolarmente**. Ogni bin pu√≤ avere un massimo di [7 chunk della stessa dimensione](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) che vanno da [24 a 1032B nei sistemi a 64 bit e da 12 a 516B nei sistemi a 32 bit](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Quando un thread libera** un chunk, **se non √® troppo grande** da essere allocato nella tcache e il rispettivo bin tcache **non √® pieno** (gi√† 7 chunk), **verr√† allocato l√¨**. Se non pu√≤ andare nella tcache, dovr√† attendere il lock dell'heap per poter eseguire l'operazione di liberazione globalmente.

Quando viene **allocato un chunk**, se c'√® un chunk libero della dimensione necessaria nella **tcache lo utilizzer√†**, altrimenti dovr√† attendere il lock dell'heap per poterne trovare uno nei bin globali o crearne uno nuovo.\
C'√® anche un'ottimizzazione, in questo caso, mentre ha il lock dell'heap, il thread **riempir√† la sua tcache con chunk dell'heap (7) della dimensione richiesta**, quindi nel caso ne abbia bisogno di pi√π, li trover√† nella tcache.
## Flusso di Allocazione

{% hint style="success" %}
(Questa spiegazione attuale proviene da [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Controllare l'ultima versione e aggiornarla)
{% endhint %}

Le allocazioni vengono infine eseguite con la funzione: `void * _int_malloc (mstate av, size_t bytes)` e seguono questo ordine:

1. Aggiorna `bytes` per gestire **allineamenti**, ecc.
2. Controlla se `av` √® **NULL** o meno.
3. Nel caso di assenza di **arena utilizzabile** (quando `av` √® NULL), chiama `sysmalloc` per ottenere un chunk usando mmap. Se ha successo, chiama `alloc_perturb`. Restituisce il puntatore.
4. A seconda della dimensione:
* \[Aggiunta all'originale] Usa tcache prima di controllare il prossimo fastbin.
* \[Aggiunta all'originale] Se non c'√® tcache ma viene utilizzato un bin diverso (vedi passaggio successivo), cerca di riempire la tcache da quel bin.
* Se la dimensione rientra nell'intervallo del **fastbin**:
1. Ottieni l'indice nell'array fastbin per accedere a un bin appropriato in base alla dimensione richiesta.
2. Rimuove il primo chunk in quel bin e fa puntare `victim` ad esso.
3. Se `victim` √® NULL, passa al caso successivo (smallbin).
4. Se `victim` non √® NULL, controlla la dimensione del chunk per assicurarti che appartenga a quel particolare bin. Altrimenti viene generato un errore ("malloc(): memory corruption (fast)").
5. Chiama `alloc_perturb` e quindi restituisce il puntatore.
* Se la dimensione rientra nell'intervallo dello **smallbin**:
1. Ottieni l'indice nell'array smallbin per accedere a un bin appropriato in base alla dimensione richiesta.
2. Se non ci sono chunk in questo bin, passa al caso successivo. Questo viene verificato confrontando i puntatori `bin` e `bin->bk`.
3. `victim` viene reso uguale a `bin->bk` (l'ultimo chunk nel bin). Se √® NULL (avviene durante l'`inizializzazione`), chiama `malloc_consolidate` e salta questo passaggio completo di controllo in bin diversi.
4. Altrimenti, quando `victim` non √® NULL, controlla se `victim->bk->fd` e `victim` sono uguali o meno. Se non sono uguali, viene generato un errore (`malloc(): smallbin double linked list corrupted`).
5. Imposta il bit PREV\_INSUSE per il prossimo chunk (in memoria, non nella lista doppiamente concatenata) per `victim`.
6. Rimuovi questo chunk dall'elenco del bin.
7. Imposta il bit di arena appropriato per questo chunk in base a `av`.
8. Chiama `alloc_perturb` e quindi restituisce il puntatore.
* Se la dimensione non rientra nell'intervallo dello smallbin:
1. Ottieni l'indice nell'array largebin per accedere a un bin appropriato in base alla dimensione richiesta.
2. Verifica se `av` ha fastchunks o meno. Questo viene fatto controllando il `FASTCHUNKS_BIT` in `av->flags`. In tal caso, chiama `malloc_consolidate` su `av`.
5. Se non √® ancora stato restituito alcun puntatore, ci√≤ indica uno o pi√π dei seguenti casi:
1. La dimensione rientra nell'intervallo 'fastbin' ma non √® disponibile alcun fastchunk.
2. La dimensione rientra nell'intervallo 'smallbin' ma non √® disponibile alcun smallchunk (chiama `malloc_consolidate` durante l'inizializzazione).
3. La dimensione rientra nell'intervallo 'largbin'.
6. Successivamente, vengono controllati gli **unsorted chunks** e i chunk attraversati vengono inseriti nei bin. Questo √® l'unico punto in cui i chunk vengono inseriti nei bin. Itera il bin non ordinato dalla 'TAIL'.
1. `victim` punta al chunk attuale in considerazione.
2. Controlla se la dimensione del chunk di `victim` √® compresa nell'intervallo minimo (`2*SIZE_SZ`) e massimo (`av->system_mem`). Altrimenti viene generato un errore (`malloc(): memory corruption`).
3. Se (la dimensione del chunk richiesta rientra nell'intervallo dello smallbin) e (`victim` √® l'ultimo chunk rimanente) e (√® l'unico chunk nel bin non ordinato) e (la dimensione dei chunk >= quella richiesta): **Dividi il chunk in 2 chunk**:
* Il primo chunk corrisponde alla dimensione richiesta e viene restituito.
* Il chunk residuo diventa il nuovo ultimo chunk rimanente. Viene reinserito nel bin non ordinato.
1. Imposta correttamente i campi `chunk_size` e `chunk_prev_size` per entrambi i chunk.
2. Il primo chunk viene restituito dopo aver chiamato `alloc_perturb`.
3. Se la condizione precedente √® falsa, il controllo arriva qui. Rimuovi `victim` dal bin non ordinato. Se la dimensione di `victim` corrisponde esattamente alla dimensione richiesta, restituisci questo chunk dopo aver chiamato `alloc_perturb`.
4. Se la dimensione di `victim` rientra nell'intervallo dello smallbin, aggiungi il chunk nell'appropriato smallbin alla `HEAD`.
5. Altrimenti inserisci nell'appropriato largebin mantenendo l'ordine ordinato:
6. Controlla prima l'ultimo chunk (il pi√π piccolo). Se `victim` √® pi√π piccolo dell'ultimo chunk, inseriscilo alla fine.
7. Altrimenti, fai un loop per trovare un chunk con dimensione >= dimensione di `victim`. Se le dimensioni sono esattamente le stesse, inserisci sempre nella seconda posizione.
8. Ripeti questo intero passaggio un massimo di `MAX_ITERS` (10000) volte o fino a quando tutti i chunk nel bin non ordinato vengono esauriti.
7. Dopo aver controllato i chunk non ordinati, verifica se la dimensione richiesta non rientra nell'intervallo dello smallbin, in tal caso controlla i **largebins**.
1. Ottieni l'indice nell'array largebin per accedere a un bin appropriato in base alla dimensione richiesta.
2. Se la dimensione del chunk pi√π grande (il primo chunk nel bin) √® maggiore della dimensione richiesta:
1. Itera dalla 'TAIL' per trovare un chunk (`victim`) con la dimensione pi√π piccola >= la dimensione richiesta.
2. Chiama `unlink` per rimuovere il chunk `victim` dal bin.
3. Calcola `remainder_size` per il chunk di `victim` (questo sar√† la dimensione del chunk di `victim` - dimensione richiesta).
4. Se questo `remainder_size` >= `MINSIZE` (la dimensione minima del chunk inclusi gli header), dividi il chunk in due chunk. Altrimenti, l'intero chunk di `victim` verr√† restituito. Inserisci il chunk residuo nel bin non ordinato (alla fine di 'TAIL'). Viene effettuato un controllo nel bin non ordinato se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Altrimenti viene generato un errore ("malloc(): corrupted unsorted chunks").
5. Restituisci il chunk `victim` dopo aver chiamato `alloc_perturb`.
8. Fino a questo momento, abbiamo controllato il bin non ordinato e anche il rispettivo fast, small o large bin. Nota che un singolo bin (fast o small) √® stato controllato utilizzando la dimensione **esatta** del chunk richiesto. Ripeti i seguenti passaggi fino a quando tutti i bin vengono esauriti:
1. L'indice nell'array bin viene incrementato per controllare il bin successivo.
2. Usa la mappa `av->binmap` per saltare i bin vuoti.
3. `victim` punta alla 'TAIL' del bin corrente.
4. Utilizzando la binmap si assicura che se un bin viene saltato (nel passaggio 2 precedente), √® sicuramente vuoto. Tuttavia, non garantisce che tutti i bin vuoti verranno saltati. Controlla se il victim √® vuoto o meno. Se √® vuoto, salta nuovamente il bin e ripeti il processo sopra (o 'continua' questo loop) fino a quando non si arriva a un bin non vuoto.
5. Dividi il chunk (`victim` punta all'ultimo chunk di un bin non vuoto) in due chunk. Inserisci il chunk residuo nel bin non ordinato (alla fine di 'TAIL'). Viene effettuato un controllo nel bin non ordinato se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Altrimenti viene generato un errore ("malloc(): corrupted unsorted chunks 2").
6. Restituisci il chunk `victim` dopo aver chiamato `alloc_perturb`.
9. Se ancora non viene trovato alcun bin vuoto, il chunk 'top' verr√† utilizzato per soddisfare la richiesta:
1. `victim` punta a `av->top`.
2. Se la dimensione del chunk 'top' >= 'dimensione richiesta' + `MINSIZE`, dividilo in due chunk. In questo caso, il chunk residuo diventa il nuovo chunk 'top' e l'altro chunk viene restituito all'utente dopo aver chiamato `alloc_perturb`.
3. Verifica se `av` ha fastchunks o meno. Questo viene fatto controllando il `FASTCHUNKS_BIT` in `av->flags`. In tal caso, chiama `malloc_consolidate` su `av`. Torna al passaggio 6 (dove controlliamo il bin non ordinato).
4. Se `av` non ha fastchunks, chiama `sysmalloc` e restituisci il puntatore ottenuto dopo aver chiamato `alloc_perturb`.
## Flusso Gratuito

{% hint style="success" %}
(Questa spiegazione attuale proviene da [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Controllare l'ultima versione e aggiornarla)
{% endhint %}

La funzione finale che libera i chunk di memoria √® `_int_free (mstate av, mchunkptr p, int have_lock)` :

1. Controlla se `p` si trova prima di `p + chunksize(p)` in memoria (per evitare il wrapping). Altrimenti viene generato un errore (`free(): invalid pointer`).
2. Controlla se il chunk √® di almeno dimensione `MINSIZE` o un multiplo di `MALLOC_ALIGNMENT`. Altrimenti viene generato un errore (`free(): invalid size`).
3. Se la dimensione del chunk rientra nella lista fastbin:
1. Controlla se la dimensione del chunk successivo √® compresa tra la dimensione minima e massima (`av->system_mem`), altrimenti genera un errore (`free(): invalid next size (fast)`).
2. Chiama `free_perturb` sul chunk.
3. Imposta `FASTCHUNKS_BIT` per `av`.
4. Ottiene l'indice nell'array fastbin in base alla dimensione del chunk.
5. Controlla se la cima del bin non √® il chunk che stiamo per aggiungere. Altrimenti, genera un errore (`double free or corruption (fasttop)`).
6. Controlla se la dimensione del chunk fastbin in cima √® la stessa del chunk che stiamo aggiungendo. Altrimenti, genera un errore (`invalid fastbin entry (free)`).
7. Inserisce il chunk in cima alla lista fastbin e restituisce.
4. Se il chunk non √® mappato:
1. Controlla se il chunk √® il chunk in cima o meno. Se s√¨, viene generato un errore (`double free or corruption (top)`).
2. Controlla se il chunk successivo (per memoria) rientra nei limiti dell'arena. Se non lo fa, viene generato un errore (`double free or corruption (out)`).
3. Controlla se il bit precedente in uso del chunk successivo (per memoria) √® contrassegnato o meno. Se non lo √®, viene generato un errore (`double free or corruption (!prev)`).
4. Controlla se la dimensione del chunk successivo √® compresa tra la dimensione minima e massima (`av->system_mem`). Se non lo √®, viene generato un errore (`free(): invalid next size (normal)`).
5. Chiama `free_perturb` sul chunk.
6. Se il chunk precedente (per memoria) non √® in uso, chiama `unlink` sul chunk precedente.
7. Se il chunk successivo (per memoria) non √® il chunk in cima:
1. Se il chunk successivo non √® in uso, chiama `unlink` sul chunk successivo.
2. Unisce il chunk con il precedente, il successivo (per memoria), se presente, √® libero e lo aggiunge all'inizio del bin non ordinato. Prima di inserire, controlla se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` o no. Se no, viene generato un errore ("free(): corrupted unsorted chunks").
8. Se il chunk successivo (per memoria) era un chunk in cima, unisce i chunk in modo appropriato in un unico chunk in cima.
5. Se il chunk era mappato, chiama `munmap_chunk`.

## Controlli di Sicurezza delle Funzioni di Heap

Controlla i controlli di sicurezza eseguiti dalle funzioni ampiamente utilizzate nell'heap in:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Riferimenti

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
