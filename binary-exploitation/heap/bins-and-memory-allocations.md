# Bins & Memory Allocations

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 제로부터 전문가까지 배우세요</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** 깃허브 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 기본 정보

청크가 저장되는 효율성을 향상시키기 위해 각 청크는 하나의 연결된 목록에만 있지 않고 여러 유형의 bin이 있습니다. 이들은 bins이며 5 종류의 bins이 있습니다: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) small bins, 63 large bins, 1 unsorted bin, 10 fast bins, 그리고 스레드 당 64개의 tcache bins이 있습니다.

각 unsorted, small, large bins의 초기 주소는 동일한 배열 내에 있습니다. 인덱스 0은 사용되지 않으며, 1은 unsorted bin이고, 2-64는 small bins이며, 65-127는 large bins입니다.

### Small Bins

Small bins은 large bins보다 빠르지만 fast bins보다 느립니다.

62개의 각 bin은 **동일한 크기의 청크**를 가집니다: 16, 24, ... (32비트 시스템에서 최대 크기는 504바이트이며, 64비트 시스템에서는 1024바이트). 이는 공간을 할당할 bin을 찾고 이러한 목록에 항목을 삽입하고 제거하는 속도를 돕습니다.

### Large Bins

고정된 크기의 청크를 관리하는 small bins과 달리, **각 large bin은 청크 크기 범위를 처리**합니다. 이는 시스템이 **다양한 크기를 수용**할 수 있도록 하여 각 크기에 대해 별도의 bin이 필요하지 않게 합니다.

메모리 할당기에서 large bins는 small bins가 끝나는 곳에서 시작합니다. large bins의 범위는 점진적으로 커지며, 첫 번째 bin은 512에서 576바이트의 청크를 포함하고, 다음 bin은 576에서 640바이트의 청크를 포함합니다. 이 패턴은 계속되며, 가장 큰 bin에는 1MB 이상의 모든 청크가 포함됩니다.

Large bins는 작은 bins보다 **청크 크기가 다양한 목록을 정렬하고 검색**해야 하기 때문에 작업 속도가 느립니다. 청크가 large bin에 삽입되면 정렬되어야 하며, 메모리가 할당될 때 시스템은 적절한 청크를 찾아야 합니다. 이 추가 작업으로 인해 속도가 **느려지지만**, 대부분의 작은 할당이 작은 것보다 적기 때문에 허용할 수 있는 교환입니다.

다음과 같은 large bins이 있습니다:

* 64B 범위의 32개 bins
* 512B 범위의 16개 bins
* 4096B 범위의 8개 bins
* 32768B 범위의 4개 bins
* 262144B 범위의 2개 bins
* 나머지 크기를 위한 1개 bins

### Unsorted bin

unsorted bin은 메모리 할당을 빠르게 만들기 위해 힙 관리자가 사용하는 **빠른 캐시**입니다. 작동 방식은 다음과 같습니다: 프로그램이 메모리를 해제하면 힙 관리자는 즉시 특정 bin에 넣지 않습니다. 대신, 주변의 빈 청크와 병합하여 더 큰 빈 메모리 블록을 만듭니다. 그런 다음,이 새로운 청크를 "unsorted bin"이라고 불리는 일반 bin에 배치합니다.

프로그램이 **메모리를 요청**하면 힙 관리자는 unsorted bin을 **검사하여 충분한 크기의 청크가 있는지 확인**합니다. 적합한 청크를 찾으면 즉시 사용합니다. 적합한 청크를 찾을 수 없으면 해제된 청크를 해당 크기에 따라 작은 bins 또는 large bins로 이동합니다.

따라서 unsorted bin은 최근에 해제된 메모리를 빠르게 재사용하여 메모리 할당을 가속화하고 시간 소모적인 검색 및 병합을 줄이는 방법입니다.

{% hint style="danger" %}
다른 카테고리의 청크이더라도 사용 가능한 청크가 충돌하는 경우 병합됩니다.
{% endhint %}

### Fast bins

Fast bins은 최근에 해제된 청크를 빠르게 액세스하는 구조에 유지하여 작은 청크에 대한 메모리 할당을 가속화하기 위해 설계되었습니다. 이러한 bins은 후입선출 (LIFO) 접근 방식을 사용하여, 새로운 할당 요청이 있을 때 **가장 최근에 해제된 청크가 먼저** 재사용됩니다. 이 동작은 속도 측면에서 유리합니다. LIFO 스택의 맨 위에서 삽입 및 제거하는 것이 큐 (FIFO)보다 빠릅니다.

또한, **fast bins은 단일 연결 목록**을 사용하며 이는 속도를 더 향상시킵니다. fast bins의 청크는 이웃과 병합되지 않기 때문에 중간에서 제거를 허용하는 복잡한 구조가 필요하지 않습니다. 단일 연결 목록은 이러한 작업에 대해 더 간단하고 빠릅니다.

기본적으로 여기서 발생하는 일은 헤더(사용할 첫 번째 청크를 가리키는 포인터)가 항상 해당 크기의 최신 해제된 청크를 가리키도록 하는 것입니다. 따라서:

* 해당 크기의 새로운 청크가 할당되면 헤더는 사용할 수 있는 빈 청크를 가리킵니다. 이 빈 청크가 사용할 다음 청크를 가리키고 있으므로 이 주소는 헤더에 저장되어 다음 할당이 어디에서 사용 가능한 청크를 가져올지 알 수 있습니다.
* 청크가 해제되면 빈 청크는 현재 사용 가능한 청크의 주소를 저장하고 이 새로 해제된 청크의 주소가 헤더에 저장됩니다.

{% hint style="danger" %}
fast bins의 청크는 자동으로 사용 가능한 상태로 설정되지 않으므로 다른 청크와 병합할 수 있는 대신 어느 정도의 시간 동안 fast bin 청크로 유지됩니다.
{% endhint %}

### Tcache (스레드별 캐시) Bins

스레드가 자체 힙을 가지려고 노력하더라도 (Arenas](bins-and-memory-allocations.md#arenas) 및 [Subheaps](bins-and-memory-allocations.md#subheaps) 참조), 많은 스레드(예: 웹 서버)를 가진 프로세스가 다른 스레드와 힙을 공유할 수 있습니다. 이 경우, 주요 솔루션은 **락**을 사용하는 것이며, 이는 **스레드의 속도를 상당히 늦출 수 있습니다**.

따라서 tcache는 각 스레드 당 fast bin과 유사한 방식으로 작동합니다. 이는 병합된 청크를 사용하지 않는 **단일 연결 목록**입니다. 각 스레드에는 **64개의 단일 연결 tcache bins**가 있습니다. 각 bin은 [64비트 시스템에서 24에서 1032B, 32비트 시스템에서 12에서 516B](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315) 범위의 최대 [7개의 동일한 크기 청크](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323)를 가질 수 있습니다.

**스레드가 청크를 해제**하면, **tcache에 할당할 크기가 너무 크지 않고** 해당 tcache bin **이미 가득 차지 않았다면**, **해당 tcache에 할당**됩니다. tcache로 이동할 수 없는 경우 전역 bins에서 찾거나 새로운 것을 만들기 위해 힙 락을 기다려야 합니다.\
**청크가 할당**될 때, **Tcache에 필요한 크기의 빈 청크가 있는 경우 사용**하고, 그렇지 않으면 전역 bins에서 찾거나 새로운 것을 만들기 위해 힙 락을 기다려야 합니다.\
또한 최적화가 있으며, 이 경우 힙 락을 사용하는 동안 스레드는 요청된 크기의 힙 청크(7개)로 Tcache를 채우므로 필요한 경우 Tcache에서 찾을 수 있습니다.
## 할당 흐름

{% hint style="success" %}
(현재 설명은 [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)에서 가져왔습니다. TODO: 최신 버전을 확인하고 업데이트하세요)
{% endhint %}

할당은 최종적으로 함수 `void * _int_malloc (mstate av, size_t bytes)`를 사용하여 수행되며 다음과 같은 순서로 진행됩니다:

1. **정렬** 등을 처리하기 위해 `bytes`를 업데이트합니다.
2. `av`가 **NULL**인지 여부를 확인합니다.
3. **사용 가능한 아레나**가 없는 경우 (`av`가 NULL인 경우), mmap을 사용하여 청크를 얻기 위해 `sysmalloc`을 호출합니다. 성공하면 `alloc_perturb`를 호출합니다. 포인터를 반환합니다.
4. 크기에 따라:
* \[원본에 추가] 다음 fastbin을 확인하기 전에 tcache를 사용합니다.
* \[원본에 추가] tcache가 없지만 다른 bin을 사용하는 경우 (나중에 설명), 해당 bin에서 tcache를 채우려고 시도합니다.
* 크기가 **fastbin** 범위에 속하는 경우:&#x20;
1. 요청 크기에 따라 적절한 bin에 액세스하기 위해 fastbin 배열에 인덱스를 가져옵니다.&#x20;
2. 해당 bin에서 첫 번째 청크를 제거하고 `victim`을 해당 청크를 가리키도록 만듭니다.
3. `victim`이 NULL인 경우 다음 경우로 이동합니다 (smallbin).
4. `victim`이 NULL이 아닌 경우 청크의 크기를 확인하여 해당 특정 bin에 속하는지 확인합니다. 그렇지 않으면 오류("malloc(): memory corruption (fast)")가 발생합니다.
5. `alloc_perturb`를 호출한 다음 포인터를 반환합니다.
* 크기가 **smallbin** 범위에 속하는 경우:
1. 요청 크기에 따라 적절한 bin에 액세스하기 위해 smallbin 배열에 인덱스를 가져옵니다.
2. 이 bin에 청크가 없는 경우 다음 경우로 이동합니다. 이는 포인터 `bin`과 `bin->bk`를 비교하여 확인됩니다.
3. `victim`은 `bin->bk` (bin의 마지막 청크)로 만듭니다. 이 값이 NULL인 경우 (`초기화` 중에 발생), `malloc_consolidate`를 호출하고 다른 bin을 확인하는 이 단계를 건너뜁니다.
4. 그렇지 않으면, `victim`이 NULL이 아닌 경우 `victim->bk->fd`와 `victim`이 동일한지 확인합니다. 동일하지 않으면 오류(`malloc(): smallbin double linked list corrupted`)가 발생합니다.
5. `victim`에 대해 다음 청크에 대해 PREV\_INSUSE 비트를 설정합니다 (`victim`이 이중 연결 목록이 아닌 메모리에서).
6. 이 청크를 bin 목록에서 제거합니다.
7. `av`에 따라 이 청크에 대한 적절한 아레나 비트를 설정합니다.
8. `alloc_perturb`를 호출한 다음 포인터를 반환합니다.
* 크기가 smallbin 범위에 속하지 않는 경우:
1. 요청 크기에 따라 적절한 bin에 액세스하기 위해 largebin 배열에 인덱스를 가져옵니다.
2. `av`에 fastchunks가 있는지 확인합니다. 이는 `av->flags`에서 `FASTCHUNKS_BIT`를 확인하여 수행됩니다. 그렇다면 `av`에서 `malloc_consolidate`를 호출합니다.
5. 아직 포인터가 반환되지 않은 경우 하나 이상의 다음 경우 중 하나 이상을 나타냅니다:
1. 크기가 'fastbin' 범위에 속하지만 fastchunk가 없는 경우.
2. 크기가 'smallbin' 범위에 속하지만 smallchunk가 없는 경우 (`초기화` 중에 `malloc_consolidate`를 호출).
3. 크기가 'largbin' 범위에 속하는 경우.
6. 다음으로 **정렬되지 않은 청크**를 확인하고 순회된 청크를 bin에 배치합니다. 여기서만 청크가 bin에 배치됩니다. 'TAIL'에서 정렬되지 않은 bin을 반복합니다.
1. `victim`은 고려 중인 현재 청크를 가리킵니다.
2. `victim`의 청크 크기가 최소 (`2*SIZE_SZ`) 및 최대 (`av->system_mem`) 범위 내에 있는지 확인합니다. 그렇지 않으면 오류(`malloc(): memory corruption`)가 발생합니다.
3. (요청된 청크의 크기가 smallbin 범위에 속하고) (`victim`이 마지막 나머지 청크이고) (정렬되지 않은 bin에 있는 유일한 청크이고) (청크 크기 >= 요청된 크기인 경우): **청크를 2개로 분할**합니다:
* 첫 번째 청크는 요청된 크기와 일치하며 반환됩니다.
* 남은 청크는 새로운 마지막 나머지 청크가 됩니다. 이것은 정렬되지 않은 bin에 다시 삽입됩니다.
1. 두 청크에 대해 `chunk_size` 및 `chunk_prev_size` 필드를 적절하게 설정합니다.
2. `alloc_perturb`를 호출한 다음 첫 번째 청크를 반환합니다.
3. 위의 조건이 거짓인 경우 여기에 도달합니다. `victim`을 정렬되지 않은 bin에서 제거합니다. `victim`의 크기가 정확히 요청된 크기와 일치하는 경우 `alloc_perturb`를 호출한 후 이 청크를 반환합니다.
4. `victim`의 크기가 smallbin 범위에 속하는 경우 해당 청크를 적절한 smallbin에 `HEAD`에 추가합니다.
5. 그렇지 않으면 적절한 largebin에 삽입하면서 정렬된 순서를 유지합니다:
6. 마지막 청크(가장 작은)를 먼저 확인합니다. `victim`이 마지막 청크보다 작으면 마지막에 삽입합니다.
7. 그렇지 않으면 `victim`의 크기보다 크기가 같거나 큰 청크를 찾기 위해 루프를 반복합니다. 크기가 정확히 같은 경우 항상 두 번째 위치에 삽입합니다.
8. 이러한 단계를 최대 `MAX_ITERS` (10000)번 반복하거나 정렬되지 않은 bin의 모든 청크가 소진될 때까지 반복합니다.
7. 정렬되지 않은 청크를 확인한 후 요청된 크기가 smallbin 범위에 속하지 않으면 **largebins**를 확인합니다.
1. 요청된 크기에 따라 적절한 bin에 액세스하기 위해 largebin 배열에 인덱스를 가져옵니다.
2. 청크의 크기(첫 번째 청크)가 요청된 크기보다 큰 경우:
1. 'TAIL'에서 시작하여 요청된 크기보다 크거나 같은 크기의 청크(`victim`)를 찾습니다.
2. `unlink`를 호출하여 bin에서 `victim` 청크를 제거합니다.
3. `victim`의 청크에 대한 `remainder_size`를 계산합니다(이는 `victim`의 청크 크기 - 요청된 크기가 됩니다).
4. 이 `remainder_size`가 `MINSIZE` (헤더를 포함한 최소 청크 크기)보다 크면 청크를 두 개로 분할합니다. 그렇지 않으면 전체 `victim` 청크가 반환됩니다. 나머지 청크를 정렬되지 않은 bin에 삽입합니다('TAIL' 끝). 정렬되지 않은 bin에서 `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`를 확인합니다. 그렇지 않으면 오류가 발생합니다("malloc(): corrupted unsorted chunks").
5. `victim` 청크를 `alloc_perturb`를 호출한 후 반환합니다.
8. 지금까지 정렬되지 않은 bin과 해당 fast, small 또는 large bin을 확인했습니다. 요청된 청크의 **정확한** 크기를 사용하여 단일 bin(fast 또는 small)을 확인했습니다. 모든 bin이 소진될 때까지 다음 단계를 반복합니다:
1. bin 배열에 대한 인덱스를 증가시켜 다음 bin을 확인합니다.
2. 빈 bin을 건너뛰기 위해 `av->binmap` 맵을 사용합니다.
3. `victim`은 현재 bin의 'TAIL'을 가리킵니다.
4. binmap을 사용하면 bin이 건너뛰어진 경우(위의 2번째 단계에서), 해당 bin이 확실히 비어 있는 것을 보장합니다. 그러나 모든 빈 bin이 건너뛰어지는 것을 보장하지는 않습니다. `victim`이 비어 있는지 확인합니다. 비어 있으면 다시 bin을 건너뛰고 위의 프로세스를 반복하거나 이 루프를 '계속'합니다. 비어 있지 않은 bin에 도달할 때까지 반복합니다.
5. 청크를 분할합니다(`victim`은 비어 있지 않은 bin의 마지막 청크를 가리킵니다). 나머지 청크를 정렬되지 않은 bin에 삽입합니다('TAIL'에). 정렬되지 않은 bin에서 `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`를 확인합니다. 그렇지 않으면 오류가 발생합니다("malloc(): corrupted unsorted chunks 2").
6. `victim` 청크를 `alloc_perturb`를 호출한 후 반환합니다.
9. 여전히 빈 bin을 찾을 수 없는 경우 'top' 청크를 사용하여 요청을 처리합니다:
1. `victim`은 `av->top`을 가리킵니다.
2. 'top' 청크의 크기가 '요청된 크기' + `MINSIZE`보다 큰 경우, 두 개의 청크로 분할합니다. 이 경우, 나머지 청크가 새 'top' 청크가 되고 다른 청크는 `alloc_perturb`를 호출한 후 사용자에게 반환됩니다.
3. `av`에 fastchunks가 있는지 확인합니다. 이는 `av->flags`에서 `FASTCHUNKS_BIT`를 확인하여 수행됩니다. 그렇다면 `av`에서 `malloc_consolidate`를 호출합니다. 단계 6(정렬되지 않은 bin을 확인하는 단계)로 돌아갑니다.
4. `av`에 fastchunks가 없는 경우, `sysmalloc`을 호출하고 `alloc_perturb`를 호출한 후 얻은 포인터를 반환합니다.
## 자유 흐름

{% hint style="success" %}
(현재 설명은 [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)에서 가져왔습니다. TODO: 최신 버전을 확인하고 업데이트하십시오)
{% endhint %}

메모리 조각을 해제하는 최종 함수는 `_int_free (mstate av, mchunkptr p, int have_lock)` 입니다:

1. `p`가 메모리에서 `p + chunksize(p)`보다 앞에 있는지 확인합니다 (wrap을 피하기 위함). 그렇지 않으면 오류 (`free(): invalid pointer`)가 발생합니다.
2. 청크가 적어도 `MINSIZE` 크기이거나 `MALLOC_ALIGNMENT`의 배수인지 확인합니다. 그렇지 않으면 오류 (`free(): invalid size`)가 발생합니다.
3. 청크의 크기가 fastbin 목록에 속하는 경우:
1. 다음 청크의 크기가 최소 크기와 최대 크기 (`av->system_mem`) 사이에 있는지 확인하고, 그렇지 않으면 오류 (`free(): invalid next size (fast)`)가 발생합니다.
2. 청크에 `free_perturb`를 호출합니다.
3. `av`에 `FASTCHUNKS_BIT`를 설정합니다.
4. 청크 크기에 따라 fastbin 배열에 인덱스를 가져옵니다.
5. 바인의 맨 위가 추가할 청크가 아닌지 확인합니다. 그렇지 않으면 오류 (`double free or corruption (fasttop)`)가 발생합니다.
6. 맨 위의 fastbin 청크의 크기가 추가하는 청크와 같은지 확인합니다. 그렇지 않으면 오류 (`invalid fastbin entry (free)`)가 발생합니다.
7. 청크를 fastbin 목록 맨 위에 삽입하고 반환합니다.
4. 청크가 mmapped가 아닌 경우:
1. 청크가 맨 위 청크인지 확인합니다. 맞다면 오류 (`double free or corruption (top)`)가 발생합니다.
2. 다음 청크 (메모리 상)가 아레나의 경계 내에 있는지 확인합니다. 그렇지 않으면 오류 (`double free or corruption (out)`)가 발생합니다.
3. 다음 청크 (메모리 상)의 이전 사용 비트가 표시되어 있는지 확인합니다. 그렇지 않으면 오류 (`double free or corruption (!prev)`)가 발생합니다.
4. 다음 청크의 크기가 최소 크기와 최대 크기 (`av->system_mem`) 사이에 있는지 확인합니다. 그렇지 않으면 오류 (`free(): invalid next size (normal)`)가 발생합니다.
5. 청크에 `free_perturb`를 호출합니다.
6. 이전 청크 (메모리 상)가 사용 중이 아니라면, 이전 청크에 `unlink`를 호출합니다.
7. 다음 청크 (메모리 상)가 맨 위 청크가 아닌 경우:
1. 다음 청크가 사용 중이 아니라면, 다음 청크에 `unlink`를 호출합니다.
2. 청크를 이전, 다음 (메모리 상)과 병합하고, 무료인 경우 미분류된 바인의 맨 위에 추가합니다. 삽입하기 전에 `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`를 확인합니다. 그렇지 않으면 오류 ("free(): corrupted unsorted chunks")가 발생합니다.
8. 다음 청크 (메모리 상)가 맨 위 청크였다면, 청크를 적절하게 병합하여 단일 맨 위 청크로 병합합니다.
5. 청크가 mmapped인 경우, `munmap_chunk`를 호출합니다.

## 힙 함수 보안 검사

힙에서 자주 사용되는 함수들이 수행하는 보안 검사를 확인하십시오:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## 참고 자료

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
