# Bins & Speicherzuweisungen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Um die Effizienz bei der Speicherung von Chunks zu verbessern, ist jeder Chunk nicht nur in einer verketteten Liste, sondern es gibt mehrere Typen. Dies sind die Bins, und es gibt 5 Arten von Bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) Small Bins, 63 Large Bins, 1 Unsorted Bin, 10 Fast Bins und 64 Tcache Bins pro Thread.

Die Anfangsadresse f√ºr jeden unsortierten, kleinen und gro√üen Bin befindet sich im selben Array. Der Index 0 wird nicht verwendet, 1 ist der unsortierte Bin, Bins 2-64 sind kleine Bins und Bins 65-127 sind gro√üe Bins.

### Small Bins

Kleine Bins sind schneller als gro√üe Bins, aber langsamer als schnelle Bins.

Jeder Bin der 62 wird **Chunks derselben Gr√∂√üe haben**: 16, 24, ... (mit einer maximalen Gr√∂√üe von 504 Bytes in 32-Bit und 1024 in 64-Bit). Dies hilft bei der Geschwindigkeit beim Auffinden des Bins, in dem ein Speicherplatz zugewiesen werden soll, und beim Einf√ºgen und Entfernen von Eintr√§gen in diesen Listen.

### Large Bins

Im Gegensatz zu kleinen Bins, die Chunks fester Gr√∂√üen verwalten, handhabt jeder **gro√üe Bin einen Bereich von Chunkgr√∂√üen**. Dies ist flexibler und erm√∂glicht es dem System, **verschiedene Gr√∂√üen** ohne die Notwendigkeit eines separaten Bins f√ºr jede Gr√∂√üe unterzubringen.

In einem Speicherzuweiser beginnen gro√üe Bins dort, wo kleine Bins enden. Die Bereiche f√ºr gro√üe Bins werden progressiv gr√∂√üer, was bedeutet, dass der erste Bin Chunks von 512 bis 576 Bytes abdecken k√∂nnte, w√§hrend der n√§chste 576 bis 640 Bytes abdeckt. Dieses Muster setzt sich fort, wobei der gr√∂√üte Bin alle Chunks √ºber 1 MB enth√§lt.

Gro√üe Bins sind langsamer zu bedienen im Vergleich zu kleinen Bins, da sie eine Liste von variierenden Chunkgr√∂√üen **sortieren und durchsuchen m√ºssen, um die beste Passform** f√ºr eine Zuweisung zu finden. Wenn ein Chunk in einen gro√üen Bin eingef√ºgt wird, muss er sortiert werden, und wenn Speicher allokiert wird, muss das System den richtigen Chunk finden. Diese zus√§tzliche Arbeit macht sie **langsamer**, aber da gro√üe Zuweisungen weniger h√§ufig sind als kleine, ist dies ein akzeptabler Kompromiss.

Es gibt:

* 32 Bins im Bereich von 64B
* 16 Bins im Bereich von 512B
* 8 Bins im Bereich von 4096B
* 4 Bins im Bereich von 32768B
* 2 Bins im Bereich von 262144B
* 1 Bin f√ºr verbleibende Gr√∂√üen

### Unsorted Bin

Der unsortierte Bin ist ein **schneller Cache**, den der Speicher-Manager verwendet, um die Speicherzuweisung zu beschleunigen. So funktioniert es: Wenn ein Programm Speicher freigibt, platziert der Speicher-Manager ihn nicht sofort in einem bestimmten Bin. Stattdessen versucht er zuerst, ihn mit benachbarten freien Chunks zu **zusammenzuf√ºhren, um einen gr√∂√üeren Block freien Speichers zu erstellen**. Dann platziert er diesen neuen Chunk in einem allgemeinen Bin namens "unsortierter Bin".

Wenn ein Programm **Speicher anfordert**, √ºberpr√ºft der Speicher-Manager den unsortierten Bin, um zu sehen, ob es einen ausreichend gro√üen Chunk gibt. Wenn er einen findet, verwendet er ihn sofort. Wenn er keinen geeigneten Chunk findet, verschiebt er die freigegebenen Chunks in ihre entsprechenden Bins, entweder klein oder gro√ü, basierend auf ihrer Gr√∂√üe.

Der unsortierte Bin ist also eine M√∂glichkeit, die Speicherzuweisung zu beschleunigen, indem k√ºrzlich freigegebener Speicher schnell wiederverwendet wird und die Notwendigkeit zeitaufw√§ndiger Suchen und Zusammenf√ºhrungen reduziert wird.

{% hint style="danger" %}
Beachten Sie, dass auch wenn Chunks unterschiedlichen Kategorien angeh√∂ren, wenn ein verf√ºgbarer Chunk mit einem anderen verf√ºgbaren Chunk kollidiert (auch wenn sie unterschiedlichen Kategorien angeh√∂ren), werden sie zusammengef√ºhrt.
{% endhint %}

### Fast Bins

Schnelle Bins sind darauf ausgelegt, die **Speicherzuweisung f√ºr kleine Chunks zu beschleunigen**, indem k√ºrzlich freigegebene Chunks in einer schnell zug√§nglichen Struktur aufbewahrt werden. Diese Bins verwenden einen Last-In, First-Out (LIFO)-Ansatz, was bedeutet, dass der **zuletzt freigegebene Chunk der erste** ist, der wiederverwendet wird, wenn eine neue Zuweisungsanforderung vorliegt. Dieses Verhalten ist vorteilhaft f√ºr die Geschwindigkeit, da es schneller ist, vom oberen Ende eines Stapels (LIFO) einzuf√ºgen und zu entfernen im Vergleich zu einer Warteschlange (FIFO).

Zus√§tzlich **verwenden schnelle Bins einfach verkettete Listen**, nicht doppelt verkettete, was die Geschwindigkeit weiter verbessert. Da Chunks in schnellen Bins nicht mit Nachbarn zusammengef√ºhrt werden, ist keine komplexe Struktur erforderlich, die das Entfernen aus der Mitte erm√∂glicht. Eine einfach verkettete Liste ist einfacher und schneller f√ºr diese Operationen.

Im Grunde genommen zeigt der Header (der Zeiger auf den ersten Chunk, der √ºberpr√ºft werden soll) immer auf den zuletzt freigegebenen Chunk dieser Gr√∂√üe. Also:

* Wenn ein neuer Chunk dieser Gr√∂√üe allokiert wird, zeigt der Header auf einen freien Chunk, der verwendet werden soll. Da dieser freie Chunk auf den n√§chsten zu verwendenden zeigt, wird diese Adresse im Header gespeichert, damit die n√§chste Zuweisung wei√ü, wo sie einen verf√ºgbaren Chunk erh√§lt.
* Wenn ein Chunk freigegeben wird, speichert der freie Chunk die Adresse zum aktuellen verf√ºgbaren Chunk, und die Adresse zu diesem neu freigegebenen Chunk wird im Header gespeichert.

{% hint style="danger" %}
Chunks in schnellen Bins werden nicht automatisch als verf√ºgbar festgelegt, sodass sie f√ºr einige Zeit als schnelle Bin-Chunks bleiben, anstatt mit anderen Chunks zusammengef√ºhrt werden zu k√∂nnen.
{% endhint %}

### Tcache (Pro-Thread-Cache) Bins

Auch wenn Threads versuchen, ihren eigenen Heap zu haben (siehe [Arenas](bins-and-memory-allocations.md#arenas) und [Subheaps](bins-and-memory-allocations.md#subheaps)), besteht die M√∂glichkeit, dass ein Prozess mit vielen Threads (wie ein Webserver) **den Heap mit anderen Threads teilen wird**. In diesem Fall ist die Hauptl√∂sung die Verwendung von **Sperren**, die die Threads **erheblich verlangsamen k√∂nnen**.

Daher ist ein Tcache √§hnlich einem schnellen Bin pro Thread in der Hinsicht, dass es sich um eine **einfach verkettete Liste** handelt, die Chunks nicht zusammenf√ºhrt. Jeder Thread hat **64 einfach verkettete Tcache-Bins**. Jeder Bin kann maximal [7 Chunks derselben Gr√∂√üe haben](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) im Bereich von [24 bis 1032B auf 64-Bit-Systemen und 12 bis 516B auf 32-Bit-Systemen](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Wenn ein Thread** einen Chunk freigibt, **wenn er nicht zu gro√ü ist**, um im Tcache allokiert zu werden, und der entsprechende Tcache-Bin **nicht voll ist** (bereits 7 Chunks), **wird er dort allokiert**. Wenn er nicht in den Tcache gehen kann, muss er auf das Freigeben der globalen Sperre warten, um die Freigabeoperation global durchf√ºhren zu k√∂nnen.

Wenn ein **Chunk allokiert wird**, und es gibt einen freien Chunk der ben√∂tigten Gr√∂√üe im **Tcache, wird er verwendet**, wenn nicht, muss er auf das Freigeben der globalen Sperre warten, um einen im globalen Bin zu finden oder einen neuen zu erstellen.\
Es gibt auch eine Optimierung, in diesem Fall, w√§hrend die globale Sperre vorhanden ist, wird der Thread **seinen Tcache mit Heap-Chunks (7) der angeforderten Gr√∂√üe f√ºllen**, sodass er sie im Tcache finden kann, falls er mehr ben√∂tigt.
## Zuweisungsfluss

{% hint style="success" %}
(Diese aktuelle Erkl√§rung stammt von [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Letzte Version √ºberpr√ºfen und aktualisieren)
{% endhint %}

Zuweisungen werden schlie√ülich mit der Funktion durchgef√ºhrt: `void * _int_malloc (mstate av, size_t bytes)` und haben diese Reihenfolge:

1. Aktualisiert `bytes`, um sich um **Ausrichtungen** usw. zu k√ºmmern.
2. √úberpr√ºft, ob `av` **NULL** ist oder nicht.
3. Im Falle des Fehlens einer **verwendbaren Arena** (wenn `av` NULL ist), ruft `sysmalloc` auf, um einen Chunk unter Verwendung von mmap zu erhalten. Wenn erfolgreich, ruft `alloc_perturb` auf. Gibt den Zeiger zur√ºck.
4. Abh√§ngig von der Gr√∂√üe:
* \[Zusatz zum Original] Verwenden Sie tcache, bevor der n√§chste fastbin √ºberpr√ºft wird.
* \[Zusatz zum Original] Wenn kein tcache vorhanden ist, aber ein anderer Bin verwendet wird (siehe sp√§terer Schritt), versuchen Sie, den tcache aus diesem Bin zu f√ºllen.
* Wenn die Gr√∂√üe in den **fastbin**-Bereich f√§llt:
1. Ermittelt den Index im fastbin-Array, um je nach Anforderungsgr√∂√üe auf einen geeigneten Bin zuzugreifen.
2. Entfernt den ersten Chunk in diesem Bin und l√§sst `victim` darauf zeigen.
3. Wenn `victim` NULL ist, fahren Sie mit dem n√§chsten Fall fort (smallbin).
4. Wenn `victim` nicht NULL ist, √ºberpr√ºfen Sie die Gr√∂√üe des Chunks, um sicherzustellen, dass er zu diesem bestimmten Bin geh√∂rt. Andernfalls wird ein Fehler ("malloc(): memory corruption (fast)") ausgegeben.
5. Ruft `alloc_perturb` auf und gibt dann den Zeiger zur√ºck.
* Wenn die Gr√∂√üe in den **smallbin**-Bereich f√§llt:
1. Ermittelt den Index im smallbin-Array, um je nach Anforderungsgr√∂√üe auf einen geeigneten Bin zuzugreifen.
2. Wenn in diesem Bin keine Chunks vorhanden sind, fahren Sie mit dem n√§chsten Fall fort. Dies wird √ºberpr√ºft, indem die Zeiger `bin` und `bin->bk` verglichen werden.
3. `victim` wird auf `bin->bk` (der letzte Chunk im Bin) gesetzt. Wenn es NULL ist (tritt w√§hrend der `Initialisierung` auf), rufen Sie `malloc_consolidate` auf und √ºberspringen Sie diesen gesamten Schritt der √úberpr√ºfung in verschiedene Bins.
4. Andernfalls, wenn `victim` nicht NULL ist, √ºberpr√ºfen Sie, ob `victim->bk->fd` und `victim` gleich sind oder nicht. Wenn sie nicht gleich sind, wird ein Fehler (`malloc(): smallbin double linked list corrupted`) ausgegeben.
5. Setzt das PREV\_INSUSE-Bit f√ºr den n√§chsten Chunk (im Speicher, nicht in der doppelt verketteten Liste) f√ºr `victim`.
6. Entfernt diesen Chunk aus der Bin-Liste.
7. Setzt das entsprechende Arena-Bit f√ºr diesen Chunk abh√§ngig von `av`.
8. Ruft `alloc_perturb` auf und gibt dann den Zeiger zur√ºck.
* Wenn die Gr√∂√üe nicht in den smallbin-Bereich f√§llt:
1. Ermittelt den Index im largebin-Array, um je nach Anforderungsgr√∂√üe auf einen geeigneten Bin zuzugreifen.
2. √úberpr√ºfen Sie, ob `av` Fastchunks hat oder nicht. Dies wird √ºberpr√ºft, indem das `FASTCHUNKS_BIT` in `av->flags` √ºberpr√ºft wird. Wenn ja, rufen Sie `malloc_consolidate` auf `av` auf.
5. Wenn noch kein Zeiger zur√ºckgegeben wurde, bedeutet dies eine oder mehrere der folgenden F√§lle:
1. Die Gr√∂√üe f√§llt in den 'fastbin'-Bereich, aber kein Fastchunk ist verf√ºgbar.
2. Die Gr√∂√üe f√§llt in den 'smallbin'-Bereich, aber kein Smallchunk ist verf√ºgbar (ruft `malloc_consolidate` w√§hrend der Initialisierung auf).
3. Die Gr√∂√üe f√§llt in den 'largebin'-Bereich.
6. Als N√§chstes werden **unsortierte Chunks** √ºberpr√ºft und durchlaufen, und die Chunks werden in Bins platziert. Dies ist der einzige Ort, an dem Chunks in Bins platziert werden. Iterieren Sie den unsortierten Bin vom 'TAIL'.
1. `victim` zeigt auf den aktuellen betrachteten Chunk.
2. √úberpr√ºfen Sie, ob die Chunkgr√∂√üe von `victim` im Bereich des Minimums (`2*SIZE_SZ`) und des Maximums (`av->system_mem`) liegt. Andernfalls wird ein Fehler (`malloc(): memory corruption`) ausgegeben.
3. Wenn (die Gr√∂√üe des angeforderten Chunks f√§llt in den smallbin-Bereich) und (`victim` ist der letzte Restchunk) und (es ist der einzige Chunk im unsortierten Bin) und (die Chunkgr√∂√üe >= die angeforderte): **Teilen Sie den Chunk in 2 Chunks auf**:
* Der erste Chunk entspricht der angeforderten Gr√∂√üe und wird zur√ºckgegeben.
* Der √ºbrig gebliebene Chunk wird zum neuen letzten Restchunk. Er wird wieder in den unsortierten Bin eingef√ºgt.
1. Setzt `chunk_size` und `chunk_prev_size` Felder f√ºr beide Chunks entsprechend.
2. Der erste Chunk wird nach dem Aufruf von `alloc_perturb` zur√ºckgegeben.
3. Wenn die obige Bedingung falsch ist, gelangt die Steuerung hierher. Entfernen Sie `victim` aus dem unsortierten Bin. Wenn die Gr√∂√üe von `victim` genau der angeforderten Gr√∂√üe entspricht, geben Sie diesen Chunk nach dem Aufruf von `alloc_perturb` zur√ºck.
4. Wenn die Gr√∂√üe von `victim` in den smallbin-Bereich f√§llt, f√ºgen Sie den Chunk im entsprechenden smallbin am `HEAD` ein.
5. F√ºgen Sie andernfalls in den entsprechenden largebin ein, w√§hrend die sortierte Reihenfolge beibehalten wird:
6. √úberpr√ºft zuerst den letzten Chunk (kleinster). Wenn `victim` kleiner als der letzte Chunk ist, f√ºgen Sie ihn am Ende ein.
7. Andernfalls suchen Sie nach einem Chunk mit einer Gr√∂√üe >= der Gr√∂√üe von `victim`. Wenn die Gr√∂√üe genau gleich ist, f√ºgen Sie immer an zweiter Stelle ein.
8. Wiederholen Sie diesen gesamten Schritt maximal `MAX_ITERS` (10000) Mal oder bis alle Chunks im unsortierten Bin ersch√∂pft sind.
7. Nach √úberpr√ºfung der unsortierten Chunks √ºberpr√ºfen Sie, ob die angeforderte Gr√∂√üe nicht in den smallbin-Bereich f√§llt, wenn ja, √ºberpr√ºfen Sie dann die **largebins**.
1. Ermitteln Sie den Index im largebin-Array, um je nach Anforderungsgr√∂√üe auf einen geeigneten Bin zuzugreifen.
2. Wenn die Gr√∂√üe des gr√∂√üten Chunks (der erste Chunk im Bin) gr√∂√üer ist als die angeforderte Gr√∂√üe:
1. Iterieren Sie vom 'TAIL', um einen Chunk (`victim`) mit der kleinsten Gr√∂√üe >= der angeforderten Gr√∂√üe zu finden.
2. Rufen Sie `unlink` auf, um den `victim`-Chunk aus dem Bin zu entfernen.
3. Berechnen Sie `remainder_size` f√ºr den Chunk von `victim` (dies wird die Chunkgr√∂√üe von `victim` - angeforderte Gr√∂√üe sein).
4. Wenn diese `remainder_size` >= `MINSIZE` (die minimale Chunkgr√∂√üe einschlie√ülich der Header), teilen Sie den Chunk in zwei Chunks auf. Andernfalls wird der gesamte `victim`-Chunk zur√ºckgegeben. F√ºgen Sie den Restchunk in den unsortierten Bin ein (am Ende des 'TAIL'). Es wird im unsortierten Bin √ºberpr√ºft, ob `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ist. Andernfalls wird ein Fehler ausgegeben ("malloc(): corrupted unsorted chunks").
5. Geben Sie den `victim`-Chunk nach dem Aufruf von `alloc_perturb` zur√ºck.
8. Bisher haben wir den unsortierten Bin √ºberpr√ºft und auch den entsprechenden fast-, small- oder large-Bin. Beachten Sie, dass ein einzelner Bin (schnell oder klein) mit der **genauen** Gr√∂√üe des angeforderten Chunks √ºberpr√ºft wurde. Wiederholen Sie die folgenden Schritte, bis alle Bins ersch√∂pft sind:
1. Der Index im Bin-Array wird inkrementiert, um den n√§chsten Bin zu √ºberpr√ºfen.
2. Verwenden Sie die `av->binmap`-Karte, um leere Bins zu √ºberspringen.
3. `victim` zeigt auf den 'TAIL' des aktuellen Bins.
4. Durch die Verwendung der Binmap wird sichergestellt, dass, wenn ein Bin √ºbersprungen wird (im obigen 2. Schritt), er definitiv leer ist. Es wird jedoch nicht sichergestellt, dass alle leeren Bins √ºbersprungen werden. √úberpr√ºfen Sie, ob das Opfer leer ist oder nicht. Wenn leer, √ºberspringen Sie erneut den Bin und wiederholen Sie den obigen Prozess (oder 'setzen' Sie diese Schleife fort), bis wir zu einem nicht leeren Bin gelangen.
5. Teilen Sie den Chunk auf (`victim` zeigt auf den letzten Chunk eines nicht leeren Bins) in zwei Chunks auf. F√ºgen Sie den Restchunk in den unsortierten Bin ein (am Ende des 'TAIL'). Es wird im unsortierten Bin √ºberpr√ºft, ob `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ist. Andernfalls wird ein Fehler ausgegeben ("malloc(): corrupted unsorted chunks 2").
6. Geben Sie den `victim`-Chunk nach dem Aufruf von `alloc_perturb` zur√ºck.
9. Wenn immer noch kein leerer Bin gefunden wird, wird der 'top'-Chunk verwendet, um die Anforderung zu bedienen:
1. `victim` zeigt auf `av->top`.
2. Wenn die Gr√∂√üe des 'top'-Chunks >= 'angeforderte Gr√∂√üe' + `MINSIZE` ist, teilen Sie ihn in zwei Chunks auf. In diesem Fall wird der Restchunk zum neuen 'top'-Chunk und der andere Chunk wird nach dem Aufruf von `alloc_perturb` an den Benutzer zur√ºckgegeben.
3. √úberpr√ºfen Sie, ob `av` Fastchunks hat oder nicht. Dies wird √ºberpr√ºft, indem das `FASTCHUNKS_BIT` in `av->flags` √ºberpr√ºft wird. Wenn ja, rufen Sie `malloc_consolidate` auf `av` auf. Gehen Sie zur√ºck zu Schritt 6 (wo wir den unsortierten Bin √ºberpr√ºfen).
4. Wenn `av` keine Fastchunks hat, rufen Sie `sysmalloc` auf und geben den erhaltenen Zeiger nach dem Aufruf von `alloc_perturb` zur√ºck.
## Freier Fluss

{% hint style="success" %}
(Diese aktuelle Erkl√§rung stammt von [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: √úberpr√ºfen Sie die letzte Version und aktualisieren Sie sie)
{% endhint %}

Die endg√ºltige Funktion zum Freigeben von Speicherbl√∂cken ist `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. √úberpr√ºfen, ob `p` vor `p + chunksize(p)` im Speicher liegt (um ein Umwickeln zu vermeiden). Andernfalls wird ein Fehler (`free(): invalid pointer`) ausgegeben.
2. √úberpr√ºfen, ob der Chunk mindestens die Gr√∂√üe `MINSIZE` oder ein Vielfaches von `MALLOC_ALIGNMENT` hat. Andernfalls wird ein Fehler (`free(): invalid size`) ausgegeben.
3. Wenn die Gr√∂√üe des Chunks in der Fastbin-Liste liegt:
1. √úberpr√ºfen, ob die Gr√∂√üe des n√§chsten Chunks zwischen der minimalen und maximalen Gr√∂√üe (`av->system_mem`) liegt, andernfalls wird ein Fehler (`free(): invalid next size (fast)`) ausgegeben.
2. Ruft `free_perturb` f√ºr den Chunk auf.
3. Setzen von `FASTCHUNKS_BIT` f√ºr `av`.
4. Index in das Fastbin-Array entsprechend der Chunkgr√∂√üe erhalten.
5. √úberpr√ºfen, ob der oberste Eintrag im Bin nicht der Chunk ist, den wir hinzuf√ºgen m√∂chten. Andernfalls wird ein Fehler (`double free or corruption (fasttop)`) ausgegeben.
6. √úberpr√ºfen, ob die Gr√∂√üe des Fastbin-Chunks oben die gleiche ist wie der Chunk, den wir hinzuf√ºgen. Andernfalls wird ein Fehler (`invalid fastbin entry (free)`) ausgegeben.
7. Den Chunk oben in die Fastbin-Liste einf√ºgen und zur√ºckgeben.
4. Wenn der Chunk nicht gemappt ist:
1. √úberpr√ºfen, ob der Chunk der oberste Chunk ist oder nicht. Wenn ja, wird ein Fehler (`double free or corruption (top)`) ausgegeben.
2. √úberpr√ºfen, ob der n√§chste Chunk (nach Speicher) innerhalb der Grenzen der Arena liegt. Andernfalls wird ein Fehler (`double free or corruption (out)`) ausgegeben.
3. √úberpr√ºfen, ob das vorherige In-Use-Bit des n√§chsten Chunks (nach Speicher) markiert ist oder nicht. Andernfalls wird ein Fehler (`double free or corruption (!prev)`) ausgegeben.
4. √úberpr√ºfen, ob die Gr√∂√üe des n√§chsten Chunks zwischen der minimalen und maximalen Gr√∂√üe (`av->system_mem`) liegt. Andernfalls wird ein Fehler (`free(): invalid next size (normal)`) ausgegeben.
5. `free_perturb` f√ºr den Chunk aufrufen.
6. Wenn der vorherige Chunk (nach Speicher) nicht in Benutzung ist, `unlink` auf dem vorherigen Chunk aufrufen.
7. Wenn der n√§chste Chunk (nach Speicher) nicht der oberste Chunk ist:
1. Wenn der n√§chste Chunk nicht in Benutzung ist, `unlink` auf dem n√§chsten Chunk aufrufen.
2. Den Chunk mit vorherigem, n√§chstem (nach Speicher) zusammenf√ºhren, falls einer frei ist, und ihn an den Anfang des unsortierten Bins hinzuf√ºgen. Vor dem Einf√ºgen √ºberpr√ºfen, ob `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` oder nicht. Andernfalls wird ein Fehler ("free(): corrupted unsorted chunks") ausgegeben.
8. Wenn der n√§chste Chunk (nach Speicher) ein oberster Chunk war, die Chunks entsprechend zu einem einzelnen obersten Chunk zusammenf√ºhren.
5. Wenn der Chunk gemappt war, `munmap_chunk` aufrufen.

## Sicherheits√ºberpr√ºfungen der Heap-Funktionen

√úberpr√ºfen Sie die Sicherheits√ºberpr√ºfungen, die von stark genutzten Funktionen im Heap durchgef√ºhrt werden in:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Referenzen

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
