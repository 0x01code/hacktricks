# Bins & Memory Toekenning

<details>

<summary><strong>Leer AWS hakwerk vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

Om die doeltreffendheid van hoe stukke gestoor word te verbeter, is elke stuk nie net in een gekoppelde lys nie, maar daar is verskeie tipes. Dit is die bins en daar is 5 tipes bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) klein bins, 63 groot bins, 1 ongesorteerde bin, 10 vinnige bins en 64 tcache bins per draad.

Die aanvanklike adres vir elke ongesorteerde, klein en groot bins is binne dieselfde reeks. Die indeks 0 word nie gebruik nie, 1 is die ongesorteerde bin, bins 2-64 is klein bins en bins 65-127 is groot bins.

### Klein Bins

Klein bins is vinniger as groot bins maar stadiger as vinnige bins.

Elke bin van die 62 sal **stukke van dieselfde grootte h√™**: 16, 24, ... (met 'n maksimum grootte van 504 byte in 32-bits en 1024 in 64-bits). Dit help om die spoed te verhoog om die bin te vind waar 'n spasie toegewys moet word en om inskrywings op hierdie lyste in te voeg en te verwyder.

### Groot Bins

In teenstelling met klein bins, wat stukke van vaste groottes bestuur, hanteer elke **groot bin 'n reeks stukgroottes**. Dit is meer buigsaam, wat die stelsel in staat stel om **verskeie groottes** te akkommodeer sonder 'n afsonderlike bin vir elke grootte nodig te h√™.

In 'n geheue-toekenner begin groot bins waar klein bins eindig. Die reekse vir groot bins word progressief groter, wat beteken dat die eerste bin dalk stukke van 512 tot 576 byte dek, terwyl die volgende 576 tot 640 byte dek. Hierdie patroon gaan voort, met die grootste bin wat alle stukke bo 1MB bevat.

Groot bins is stadiger om te bedryf in vergelyking met klein bins omdat hulle moet **sorteer en deur 'n lys van wisselende stukgroottes soek om die beste pas te vind** vir 'n toekenning. Wanneer 'n stuk in 'n groot bin ingevoeg word, moet dit gesorteer word, en wanneer geheue toegewys word, moet die stelsel die regte stuk vind. Hierdie ekstra werk maak hulle **stadiger**, maar aangesien groot toekenning minder algemeen is as klein een, is dit 'n aanvaarbare afweging.

Daar is:

* 32 bins van 64B reeks
* 16 bins van 512B reeks
* 8 bins van 4096B reeks
* 4 bins van 32768B reeks
* 2 bins van 262144B reeks
* 1 bin vir oorblywende groottes

### Ongesorteerde Bin

Die ongesorteerde bin is 'n **vinnige buffer** wat deur die geheue-bestuurder gebruik word om geheue toekenning vinniger te maak. So werk dit: Wanneer 'n program geheue vrymaak, plaas die geheue-bestuurder dit nie dadelik in 'n spesifieke bin nie. In plaas daarvan probeer dit eers om dit **saam te voeg met enige aangrensende vry stukke** om 'n groter blok vry geheue te skep. Dan plaas dit hierdie nuwe stuk in 'n algemene bin genaamd die "ongesorteerde bin."

Wanneer 'n program **vir geheue vra**, **kontroleer die geheue-bestuurder die ongesorteerde bin** om te sien of daar 'n stuk van genoeg grootte is. As dit een vind, gebruik dit dit dadelik. As dit nie 'n geskikte stuk vind nie, skuif dit die vrygemaakte stukke na hul ooreenstemmende bins, klein of groot, gebaseer op hul grootte.

Dus, die ongesorteerde bin is 'n manier om geheue toekenning te versnel deur onlangs vrygemaakte geheue vinnig te hergebruik en die behoefte aan tydrowende soektogte en samenvoegings te verminder.

{% hint style="danger" %}
Let daarop dat selfs al is stukke van verskillende kategorie√´, as 'n beskikbare stuk bots met 'n ander beskikbare stuk (selfs al is hulle van verskillende kategorie√´), sal hulle saamgevoeg word.
{% endhint %}

### Vinnige Bins

Vinnige bins is ontwerp om **geheue toekenning vir klein stukke te versnel** deur onlangs vrygemaakte stukke in 'n vinnig toeganklike struktuur te hou. Hierdie bins gebruik 'n Laaste-In, Eerste-Uit (LIFO) benadering, wat beteken dat die **mees onlangs vrygemaakte stuk eerste** hergebruik word wanneer daar 'n nuwe toekenningsversoek is. Hierdie gedrag is voordelig vir spoed, aangesien dit vinniger is om van die boonste van 'n stok (LIFO) in te voeg en te verwyder in vergelyking met 'n ry (FIFO).

Daarbenewens **gebruik vinnige bins enkelgelinkte lyste**, nie dubbelgelinkte nie, wat die spoed verder verbeter. Aangesien stukke in vinnige bins nie saamgevoeg word met bure nie, is daar geen behoefte aan 'n komplekse struktuur wat verwydering uit die middel toelaat nie. 'n Enkelgelinkte lys is eenvoudiger en vinniger vir hierdie operasies.

Basies, wat hier gebeur, is dat die kop (die aanwyser na die eerste stuk om te kontroleer) altyd na die mees onlangs vrygemaakte stuk van daardie grootte wys. So:

* Wanneer 'n nuwe stuk van daardie grootte toegewys word, wys die kop na 'n vry stuk om te gebruik. Aangesien hierdie vry stuk na die volgende een om te gebruik wys, word hierdie adres in die kop gestoor sodat die volgende toekenning weet waar om 'n beskikbare stuk te kry
* Wanneer 'n stuk vrygemaak word, sal die vry stuk die adres na die huidige beskikbare stuk stoor en die adres na hierdie nuut vrygemaakte stuk sal in die kop geplaas word

{% hint style="danger" %}
Stukke in vinnige bins word nie outomaties as beskikbaar ingestel nie, sodat hulle vir 'n tyd as vinnige bin stukke bly in plaas daarvan om met ander stukke saamgevoeg te kan word.
{% endhint %}

### Tcache (Per-Draad Cache) Bins

Selfs al probeer drade hul eie geheue h√™ (sien [Arenas](bins-and-memory-allocations.md#arenas) en [Subheaps](bins-and-memory-allocations.md#subheaps)), is daar die moontlikheid dat 'n proses met baie drade (soos 'n webbediener) **die geheue met ander drade sal deel**. In hierdie geval is die hoofoplossing die gebruik van **sluiters**, wat die drade aansienlik **stadiger kan maak**.

Daarom is 'n tcache soortgelyk aan 'n vinnige bin per draad op die manier dat dit 'n **enkelgelinkte lys** is wat nie stukke saamvoeg nie. Elke draad het **64 enkelgelinkte tcache bins**. Elke bin kan 'n maksimum van [7 stukke van dieselfde grootte h√™](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) wat wissel van [24 tot 1032B op 64-bits stelsels en 12 tot 516B op 32-bits stelsels](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Wanneer 'n draad 'n stuk vrymaak**, **as dit nie te groot is** om in die tcache toegewys te word en die betrokke tcache bin **nie vol is** (reeds 7 stukke), **sal dit daar toegewys word**. As dit nie na die tcache kan gaan nie, sal dit moet wag vir die geheue-sluiting om die vry operasie globaal uit te voer.

Wanneer 'n **stuk toegewys word**, as daar 'n vry stuk van die benodigde grootte in die **Tcache is, sal dit dit gebruik**, indien nie, sal dit moet wag vir die geheue-sluiting om een in die globale bins te vind of 'n nuwe een te skep.\
Daar is ook 'n optimisering, in hierdie geval, terwyl die geheue-sluiting het, sal die draad **sy Tcache met geheue stukke (7) van die gevraagde grootte vul**, sodat as dit meer benodig, sal dit hulle in die Tcache vind.
## Toewysingsvloei

{% hint style="success" %}
(Die huidige verduideliking is vanaf [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Kontroleer die laaste weergawe en werk dit by)
{% endhint %}

Toewysings word uiteindelik uitgevoer met die funksie: `void * _int_malloc (mstate av, size_t bytes)` en volg hierdie orde:

1. Werk `bytes` by om sorg te dra vir **uitlyning**, ens.
2. Kontroleer of `av` **NULL** is of nie.
3. In die geval van afwesigheid van 'n **bruikbare arena** (wanneer `av` NULL is), roep `sysmalloc` aan om 'n brokkie te verkry deur middel van mmap. Indien suksesvol, roep `alloc_perturb` aan. Gee die wyser terug.
4. Afhangende van die grootte:
* \[Byvoeging tot die oorspronklike] Gebruik tcache voordat die volgende fastbin nagegaan word.
* \[Byvoeging tot die oorspronklike] Indien geen tcache nie maar 'n ander bin gebruik word (sien later stap), probeer om tcache van daardie bin te vul.
* Indien die grootte binne die **fastbin**-reeks val:
1. Kry indeks in die fastbin-reeks om toegang tot 'n toepaslike bin volgens die versoekte grootte te verkry.
2. Verwyder die eerste brokkie in daardie bin en laat `victim` daarna wys.
3. Indien `victim` NULL is, gaan voort na die volgende geval (smallbin).
4. Indien `victim` nie NULL is nie, kontroleer die grootte van die brokkie om te verseker dat dit aan daardie spesifieke bin behoort. 'n Fout ("malloc(): memory corruption (fast)") word andersins gegooi.
5. Roep `alloc_perturb` aan en gee dan die wyser terug.
* Indien die grootte binne die **smallbin**-reeks val:
1. Kry indeks in die smallbin-reeks om toegang tot 'n toepaslike bin volgens die versoekte grootte te verkry.
2. Indien daar geen brokkies in hierdie bin is nie, gaan voort na die volgende geval. Dit word nagegaan deur die wysers `bin` en `bin->bk` te vergelyk.
3. `victim` word gelyk gestel aan `bin->bk` (die laaste brokkie in die bin). Indien dit NULL is (gebeur tydens `initialization`), roep `malloc_consolidate` aan en slaan hierdie volledige stap van die nagaan in verskillende bakkies oor.
4. Andersins, wanneer `victim` nie NULL is nie, kontroleer of `victim->bk->fd` en `victim` gelyk is of nie. Indien hulle nie gelyk is nie, word 'n fout (`malloc(): smallbin double linked list corrupted`) gegooi.
5. Stel die PREV\_INSUSE-bit in vir die volgende brokkie (in geheue, nie in die dubbelgekoppelde lys) vir `victim`.
6. Verwyder hierdie brokkie uit die binlys.
7. Stel die toepaslike arena-bit vir hierdie brokkie in afhangende van `av`.
8. Roep `alloc_perturb` aan en gee dan die wyser terug.
* Indien die grootte nie binne die smallbin-reeks val nie:
1. Kry indeks in die largebin-reeks om toegang tot 'n toepaslike bin volgens die versoekte grootte te verkry.
2. Sien of `av` vinnigbrokkies het of nie. Dit word gedoen deur die `FASTCHUNKS_BIT` in `av->flags` te kontroleer. Indien wel, roep `malloc_consolidate` aan op `av`.
5. Indien nog geen wyser teruggegee is nie, dui dit op een of meer van die volgende gevalle:
1. Grootte val binne die 'fastbin'-reeks maar geen vinnige brokkie is beskikbaar nie.
2. Grootte val binne die 'smallbin'-reeks maar geen kleinbrokkie is beskikbaar nie (roep `malloc_consolidate` tydens inisialisering aan).
3. Grootte val binne die 'largbin'-reeks.
6. Volgende word **ongesorteerde brokkies** nagegaan en deurgegaan brokkies word in bakkies geplaas. Dit is die enigste plek waar brokkies in bakkies geplaas word. Itereer die ongesorteerde bin vanaf die 'TAIL'.
1. `victim` wys na die huidige brokkie wat oorweeg word.
2. Kontroleer of die grootte van `victim` se brokkie binne die minimum (`2*SIZE_SZ`) en maksimum (`av->system_mem`) reeks val. Gooi anders 'n fout (`malloc(): memory corruption`).
3. Indien (grootte van versoekte brokkie val binne smallbin-reeks) en (`victim` is die laaste oorblywende brokkie) en (dit is die enigste brokkie in die ongesorteerde bin) en (die grootte van die brokkies >= die versoekte een): **Breek die brokkie in 2 brokkies**:
* Die eerste brokkie stem ooreen met die versoekte grootte en word teruggegee.
* Oorblywende brokkie word die nuwe laaste oorblywende brokkie. Dit word teruggeplaas in die ongesorteerde bin.
1. Stel `chunk_size` en `chunk_prev_size` velde toepaslik vir beide brokkies.
2. Die eerste brokkie word teruggegee na die aanroeping van `alloc_perturb`.
3. Indien die bogenoemde toestand vals is, bereik beheer hierdie punt. Verwyder `victim` uit die ongesorteerde bin. Indien die grootte van `victim` presies ooreenstem met die versoekte grootte, gee hierdie brokkie terug na die aanroeping van `alloc_perturb`.
4. Indien die grootte van `victim` binne die smallbin-reeks val, voeg die brokkie by in die toepaslike smallbin by die `HEAD`.
5. Andersins voeg in die toepaslike largebin in terwyl die gesorteerde orde gehandhaaf word:
6. Eerste kontroleer die laaste brokkie (kleinste). Indien `victim` kleiner is as die laaste brokkie, voeg dit by die laaste.
7. Anders, loop om 'n brokkie met grootte >= grootte van `victim` te vind. Indien die grootte presies dieselfde is, voeg altyd in die tweede posisie in.
8. Herhaal hierdie hele stap 'n maksimum van `MAX_ITERS` (10000) keer of totdat alle brokkies in die ongesorteerde bin uitgeput is.
7. Na die nagaan van ongesorteerde brokkies, kontroleer of die versoekte grootte nie binne die smallbin-reeks val nie, indien wel, kontroleer dan **largebins**.
1. Kry indeks in die largebin-reeks om toegang tot 'n toepaslike bin volgens die versoekte grootte te verkry.
2. Indien die grootte van die grootste brokkie (die eerste brokkie in die bin) groter is as die versoekte grootte:
1. Itereer vanaf 'TAIL' om 'n brokkie (`victim`) met die kleinste grootte >= die versoekte grootte te vind.
2. Roep `unlink` aan om die `victim`-brokkie uit die bin te verwyder.
3. Bereken `remainder_size` vir die `victim` se brokkie (dit sal die grootte van die `victim`-brokkie - versoekte grootte wees).
4. Indien hierdie `remainder_size` >= `MINSIZE` (die minimum brokkie grootte insluitend die koppe), verdeel die brokkie in twee brokkies. Andersins sal die hele `victim`-brokkie teruggegee word. Plaas die oorblywende brokkie in die ongesorteerde bin (by die 'TAIL'-einde). 'n Kontrole word in die ongesorteerde bin gemaak of `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. 'n Fout word andersins gegooi ("malloc(): corrupted unsorted chunks").
5. Gee die `victim`-brokkie terug na die aanroeping van `alloc_perturb`.
8. Tot dusver is die ongesorteerde bin en ook die betrokke vinnige, klein of groot bin nagegaan. Let daarop dat 'n enkele bin (vinnig of klein) nagegaan is met die **presiese** grootte van die versoekte brokkie. Herhaal die volgende stappe totdat alle bakkies uitgeput is:
1. Die indeks in die bin-reeks word verhoog om die volgende bin te nagaan.
2. Gebruik `av->binmap`-kaart om oor bakkies wat leeg is, te spring.
3. `victim` wys na die 'TAIL' van die huidige bin.
4. Deur die binmap te gebruik, word verseker dat as 'n bin oorgeslaan word (in die bogenoemde 2de stap), dit beslis leeg is. Dit verseker egter nie dat alle le√´ bakkies oorgeslaan sal word nie. Kontroleer of die victim leeg is of nie. Indien leeg, slaan weer die bin oor en herhaal die bogenoemde proses (of 'n voortsetting van hierdie lus) totdat ons by 'n nie-le√´ bin uitkom.
5. Verdeel die brokkie (`victim` wys na die laaste brokkie van 'n nie-le√´ bin) in twee brokkies. Plaas die oorblywende brokkie in die ongesorteerde bin (by die 'TAIL'-einde). 'n Kontrole word in die ongesorteerde bin gemaak of `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. 'n Fout word andersins gegooi ("malloc(): corrupted unsorted chunks 2").
6. Gee die `victim`-brokkie terug na die aanroeping van `alloc_perturb`.
9. Indien nog geen le√´ bin gevind word nie, sal die 'top'-brokkie gebruik word om die versoek te dien:
1. `victim` wys na `av->top`.
2. Indien die grootte van die 'top'-brokkie >= 'versoekte grootte' + `MINSIZE` is, verdeel dit in twee brokkies. In hierdie geval word die oorblywende brokkie die nuwe 'top'-brokkie en die ander brokkie word aan die gebruiker teruggegee na die aanroeping van `alloc_perturb`.
3. Sien of `av` vinnigbrokkies het of nie. Dit word gedoen deur die `FASTCHUNKS_BIT` in `av->flags` te kontroleer. Indien wel, roep `malloc_consolidate` aan op `av`. Keer terug na stap 6 (waar ons die ongesorteerde bin nagaan).
4. Indien `av` nie vinnigbrokkies het nie, roep `sysmalloc` aan en gee die wyser terug wat verkry is na die aanroeping van `alloc_perturb`.
## Vrye Vloei

{% hint style="success" %}
(Hierdie huidige verduideliking is vanaf [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Kontroleer die laaste weergawe en werk dit by)
{% endhint %}

Die finale funksie wat stukke geheue vrymaak is `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Kontroleer of `p` voor `p + chunksize(p)` in die geheue is (om oorvloei te voorkom). 'n Fout (`free(): ongeldige wyser`) word andersins gegooi.
2. Kontroleer of die stuk ten minste die grootte `MINSIZE` of 'n veelvoud van `MALLOC_ALIGNMENT` het. 'n Fout (`free(): ongeldige grootte`) word andersins gegooi.
3. As die grootte van die stuk in die fastbin-lys val:
1. Kontroleer of die grootte van die volgende stuk tussen die minimum en maksimum grootte (`av->system_mem`) is, gooi anders 'n fout (`free(): ongeldige volgende grootte (vinnig)`) uit.
2. Roep `free_perturb` aan op die stuk.
3. Stel `FASTCHUNKS_BIT` in vir `av`.
4. Kry indeks in die fastbin-lys volgens stukgrootte.
5. Kontroleer of die boonste van die bin nie die stuk is wat ons gaan byvoeg nie. Anders, gooi 'n fout (`dubbele vry of korrupsie (vinnigtop)`) uit.
6. Kontroleer of die grootte van die vinnige bin-stuk bo-aan dieselfde is as die stuk wat ons byvoeg. Anders, gooi 'n fout (`ongeldige vinnige bin-inskrywing (vry)`) uit.
7. Voeg die stuk by die boonste van die vinnige bin-lys in en keer terug.
4. As die stuk nie gemap is nie:
1. Kontroleer of die stuk die boonste stuk is of nie. Indien wel, word 'n fout (`dubbele vry of korrupsie (bo)`) uitgegooi.
2. Kontroleer of die volgende stuk (volgens geheue) binne die grense van die arena is. Indien nie, word 'n fout (`dubbele vry of korrupsie (uit)`) uitgegooi.
3. Kontroleer of die vorige in gebruik bit van die volgende stuk (volgens geheue) gemerk is of nie. Indien nie, word 'n fout (`dubbele vry of korrupsie (!vorige)`) uitgegooi.
4. Kontroleer of die grootte van die volgende stuk tussen die minimum en maksimum grootte (`av->system_mem`) is. Indien nie, word 'n fout (`free(): ongeldige volgende grootte (normaal)`) uitgegooi.
5. Roep `free_perturb` aan op die stuk.
6. As die vorige stuk (volgens geheue) nie in gebruik is nie, roep `unlink` aan op die vorige stuk.
7. As die volgende stuk (volgens geheue) nie die boonste stuk is nie:
1. As die volgende stuk nie in gebruik is nie, roep `unlink` aan op die volgende stuk.
2. Kombineer die stuk met die vorige, volgende (volgens geheue), indien enige is vry en voeg dit by die kop van die ongesorteerde bin. Voordat dit ingevoeg word, kontroleer of `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` of nie. Indien nie, word 'n fout ("free(): gekorruppeerde ongesorteerde stukke") uitgegooi.
8. As die volgende stuk (volgens geheue) 'n boonste stuk was, kombineer die stukke toepaslik in 'n enkele boonste stuk.
5. As die stuk gemap was, roep `munmap_chunk` aan.

## Geheuefunksies Sekuriteitskontroles

Kontroleer die sekuriteitskontroles wat uitgevoer word deur baie gebruikte funksies in die geheue in:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Verwysings

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
