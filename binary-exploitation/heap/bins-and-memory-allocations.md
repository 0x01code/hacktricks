# Bins & Εκχωρήσεις Μνήμης

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε την [**Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Για να βελτιώσετε την αποδοτικότητα στον τρόπο αποθήκευσης των τμημάτων, κάθε τμήμα δεν βρίσκεται μόνο σε μια συνδεδεμένη λίστα, αλλά υπάρχουν διάφοροι τύποι. Αυτοί είναι οι bins και υπάρχουν 5 τύποι bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) μικροί bins, 63 μεγάλοι bins, 1 unsorted bin, 10 fast bins και 64 tcache bins ανά νήμα.

Η αρχική διεύθυνση για κάθε unsorted, small και large bin βρίσκεται μέσα στον ίδιο πίνακα. Το δείκτης 0 δεν χρησιμοποιείται, το 1 είναι το unsorted bin, τα bins 2-64 είναι μικροί bins και τα bins 65-127 είναι μεγάλοι bins.

### Μικροί Bins

Οι μικροί bins είναι ταχύτεροι από τους μεγάλους bins αλλά πιο αργοί από τους fast bins.

Κάθε bin από τα 62 θα έχει **chunks του ίδιου μεγέθους**: 16, 24, ... (με μέγιστο μέγεθος 504 bytes σε 32bits και 1024 σε 64bits). Αυτό βοηθάει στην ταχύτητα εύρεσης του bin όπου θα πρέπει να γίνει εκχώρηση χώρου και στην εισαγωγή και αφαίρεση καταχωρήσεων σε αυτές τις λίστες.

### Μεγάλοι Bins

Αντίθετα με τους μικρούς bins, οι οποίοι διαχειρίζονται τμήματα με σταθερά μεγέθη, κάθε **μεγάλος bin διαχειρίζεται ένα εύρος μεγεθών τμημάτων**. Αυτό είναι πιο ευέλικτο, επιτρέποντας στο σύστημα να φιλοξενεί **διάφορα μεγέθη** χωρίς την ανάγκη για έναν ξεχωριστό bin για κάθε μέγεθος.

Σε έναν διαχειριστή μνήμης, οι μεγάλοι bins ξεκινούν από εκεί που τελειώνουν οι μικροί bins. Τα εύρη των μεγάλων bins μεγαλώνουν σταδιακά, που σημαίνει ότι το πρώτο bin μπορεί να καλύπτει τμήματα από 512 έως 576 bytes, ενώ το επόμενο καλύπτει από 576 έως 640 bytes. Αυτό το πρότυπο συνεχίζεται, με τον μεγαλύτερο bin να περιέχει όλα τα τμήματα άνω των 1MB.

Οι μεγάλοι bins είναι πιο αργοί στη λειτουργία σε σύγκριση με τους μικρούς bins επειδή πρέπει **να ταξινομήσουν και να αναζητήσουν μέσω μιας λίστας με διαφορετικά μεγέθη τμημάτων για να βρουν την καλύτερη ταιριάστηκη** για μια εκχώρηση. Όταν ένα τμήμα εισάγεται σε έναν μεγάλο bin, πρέπει να ταξινομηθεί, και όταν γίνεται εκχώρηση μνήμης, το σύστημα πρέπει να βρει το σωστό τμήμα. Αυτή η επιπλέον εργασία τους καθιστά **πιο αργούς**, αλλά επειδή οι μεγάλες εκχωρήσεις είναι λιγότερο συνηθισμένες από τις μικρές, είναι μια αποδεκτή ανταλλαγή.

Υπάρχουν:

* 32 bins εύρους 64B
* 16 bins εύρους 512B
* 8 bins εύρους 4096B
* 4 bins εύρους 32768B
* 2 bins εύρους 262144B
* 1 bin για υπενθύμιση μεγεθών

### Unsorted bin

Το unsorted bin είναι ένα **γρήγορο cache** που χρησιμοποιεί ο διαχειριστής του σωρού για να κάνει την εκχώρηση μνήμης πιο γρήγορη. Έτσι λειτουργεί: Όταν ένα πρόγραμμα απελευθερώνει μνήμη, ο διαχειριστής του σωρού δεν την τοποθετεί αμέσως σε ένα συγκεκριμένο bin. Αντ' αυτού, πρώτα προσπαθεί να **συγχωνεύσει με οποιαδήποτε γειτονικά ελεύθερα τμήματα** για να δημιουργήσει ένα μεγαλύτερο τμήμα ελεύθερης μνήμης. Στη συνέχεια, το τοποθετεί αυτό το νέο τμήμα σε ένα γενικό bin που ονομάζεται "unsorted bin".

Όταν ένα πρόγραμμα ζητά μνήμη, ο διαχειριστής του σωρού **ελέγχει το unsorted bin** για να δει αν υπάρχει ένα τμήμα αρκετά μεγάλο. Αν βρει ένα, το χρησιμοποιεί αμέσως. Αν δεν βρει ένα κατάλληλο τμήμα, μεταφέρει τα ελεύθερα τμήματα στα αντίστοιχα bins τους, είτε μικρά είτε μεγάλα, με βάση το μέγεθός τους.

Έτσι, το unsorted bin είναι ένας τρόπος για να επιταχυνθεί η εκχώρηση μνήμης με την γρήγορη επαναχρησιμοποίηση πρόσφατα απελευθερωμένης μνήμης και τη μείωση της ανάγκης για χρονοβόρες αναζητήσεις και συγχωνεύσεις.

{% hint style="danger" %}
Σημειώστε ότι ακόμα και αν τα τμήματα είναι διαφορετικών κατηγοριών, αν ένα διαθέσιμο τμήμα συγκρούεται με ένα άλλο διαθέσιμο τμήμα (ακόμα κι αν είναι διαφορετικών κατηγοριών), θα συγχωνευτούν.
{% endhint %}

### Fast bins

Οι fast bins σχεδιάστηκαν για να **επιταχύνουν την εκχώρηση μνήμης για μικρά τμήματα** κρατώντας πρόσφατα απελευθερωμένα τμήματα σε μια δομή γρήγορης πρόσβασης. Αυτά τα bins χρησιμοποιούν μια προσέγγιση Last-In, First-Out (LIFO), που σημαίνει ότι το **πιο πρόσφατα απελευθερωμένο τμήμα είναι το πρώτο** που θα χρησιμοποιηθεί όταν υπάρχει αίτηση για νέα εκχώρηση. Αυτή η συμπεριφορά είναι επωφελής για την ταχύτητα, καθώς είναι πιο γρήγορο να εισάγετε και να αφαιρέσετε από την κορυφή μιας στοίβας (LIFO) σε σύγκριση με μια ουρά (FIFO).

Επιπλέον, **οι fast bins χρησιμοποιούν μονόδεσμες λίστες**, όχι διπλές, που βελτιώνει περαιτέρω την ταχύτητα. Δεδομένου ότι τα τμήματα στους fast bins δεν συγ
## Ροή Κατανομής

{% hint style="success" %}
(Η τρέχουσα εξήγηση προέρχεται από [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Ελέγξτε την τελευταία έκδοση και ενημερώστε την)
{% endhint %}

Οι κατανομές πραγματοποιούνται τελικά με τη λειτουργία: `void * _int_malloc (mstate av, size_t bytes)` και ακολουθούν αυτήν τη σειρά:

1. Ενημερώνει το `bytes` για να αντιμετωπίσει τις **ευθυγραμμίσεις**, κ.λπ.
2. Ελέγχει αν το `av` είναι **NULL** ή όχι.
3. Στην περίπτωση απουσίας **χρήσιμης αρένας** (όταν το `av` είναι NULL), καλεί το `sysmalloc` για να λάβει κομμάτι χρησιμοποιώντας το mmap. Εάν είναι επιτυχές, καλεί το `alloc_perturb`. Επιστρέφει το δείκτη.
4. Ανάλογα με το μέγεθος:
* \[Προσθήκη στον αρχικό κώδικα] Χρησιμοποιήστε το tcache πριν ελέγξετε τον επόμενο fastbin.
* \[Προσθήκη στον αρχικό κώδικα] Αν δεν υπάρχει tcache αλλά χρησιμοποιείται διαφορετικός bin (δείτε το επόμενο βήμα), προσπαθήστε να γεμίσετε το tcache από αυτόν τον bin
* Αν το μέγεθος ανήκει στο εύρος του **fastbin**:
1. Πάρτε δείκτη στον πίνακα fastbin για να έχετε πρόσβαση σε ένα κατάλληλο bin σύμφωνα με το μέγεθος του αιτήματος.
2. Αφαιρεί το πρώτο κομμάτι σε αυτόν τον bin και κάνει το `victim` να δείχνει σε αυτό.
3. Αν το `victim` είναι NULL, προχωρήστε στην επόμενη περίπτωση (smallbin).
4. Αν το `victim` δεν είναι NULL, ελέγξτε το μέγεθος του κομματιού για να βεβαιωθείτε ότι ανήκει σε αυτόν τον συγκεκριμένο bin. Διαφορετικά εκτοξεύεται ένα σφάλμα ("malloc(): μνήμη που διαφθείρεται (fast)").
5. Καλεί το `alloc_perturb` και στη συνέχεια επιστρέφει το δείκτη.
* Αν το μέγεθος ανήκει στο εύρος του **smallbin**:
1. Πάρτε δείκτη στον πίνακα smallbin για να έχετε πρόσβαση σε ένα κατάλληλο bin σύμφωνα με το μέγεθος του αιτήματος.
2. Αν δεν υπάρχουν κομμάτια σε αυτόν τον bin, προχωρήστε στην επόμενη περίπτωση. Αυτό ελέγχεται συγκρίνοντας τους δείκτες `bin` και `bin->bk`.
3. Το `victim` γίνεται ίσο με το `bin->bk` (το τελευταίο κομμάτι στο bin). Αν είναι NULL (συμβαίνει κατά την `αρχικοποίηση`), καλέστε το `malloc_consolidate` και παραλείψτε αυτό το πλήρες βήμα ελέγχου σε διαφορετικούς bins.
4. Διαφορετικά, όταν το `victim` δεν είναι NULL, ελέγξτε αν `victim->bk->fd` και `victim` είναι ίσα ή όχι. Αν δεν είναι ίσα, εκτοξεύεται ένα σφάλμα (`malloc(): διπλή διαφθορά μικρού bin`). 
5. Ορίζει το bit PREV\_INSUSE για το επόμενο κομμάτι (στη μνήμη, όχι στη διπλά συνδεδεμένη λίστα) για το `victim`.
6. Αφαιρεί αυτό το κομμάτι από τη λίστα του bin.
7. Ορίζει το κατάλληλο bit αρένας για αυτό το κομμάτι ανάλογα με το `av`.
8. Καλεί το `alloc_perturb` και στη συνέχεια επιστρέφει το δείκτη.
* Αν το μέγεθος δεν ανήκει στο εύρος του smallbin:
1. Πάρτε δείκτη στον πίνακα largebin για να έχετε πρόσβαση σε ένα κατάλληλο bin σύμφωνα με το μέγεθος του αιτήματος.
2. Δείτε αν το `av` έχει fastchunks ή όχι. Αυτό γίνεται ελέγχοντας το `FASTCHUNKS_BIT` στα `av->flags`. Αν ναι, καλέστε το `malloc_consolidate` στο `av`.
5. Αν δεν έχει επιστραφεί ακόμα δείκτης, αυτό υποδηλώνει ένα ή περισσότερα από τα ακόλουθα περιστατικά:
1. Το μέγεθος ανήκει στο εύρος 'fastbin' αλλά δεν υπάρχει fastchunk διαθέσιμο.
2. Το μέγεθος ανήκει στο εύρος 'smallbin' αλλά δεν υπάρχει smallchunk διαθέσιμο (καλεί το `malloc_consolidate` κατά την αρχικοποίηση).
3. Το μέγεθος ανήκει στο εύρος 'largebin'.
6. Στη συνέχεια, ελέγχονται **αταξινόμητα κομμάτια** και τα κομμάτια που διατρέχονται τοποθετούνται σε bins. Αυτό είναι το μόνο σημείο όπου τα κομμάτια τοποθετούνται σε bins. Διατρέξτε τον αταξινόμητο bin από το 'TAIL'.
1. Το `victim` δείχνει στο τρέχον κομμάτι που εξετάζεται.
2. Ελέγξτε αν το μέγεθος του κομματιού `victim` βρίσκεται εντός του ελάχιστου (`2*SIZE_SZ`) και μέγιστου (`av->system_mem`) εύρους. Διαφορετικά εκτοξεύεται ένα σφάλμα (`malloc(): διαφθορά μνήμης`).
3. Αν (το μέγεθος του αιτούμενου κομματιού ανήκει στο εύρος του smallbin) και (`victim` είναι το τελευταίο κομμάτι υπολοίπου) και (είναι το μοναδικό κομμάτι στον αταξινόμητο bin) και (το μέγεθος των κομματιών >= αυτού που ζητήθηκε): **Διαίρεσε το κομμάτι σε 2 κομμάτια**:
* Το πρώτο κομμάτι ταιριάζει με το ζητούμενο μέγεθος και επιστρέφεται.
* Το υπόλοιπο κομμάτι γίνεται το νέο τελευταίο κομμάτι υπολοίπου. Εισάγεται πίσω στον αταξινόμητο bin.
1. Ορίστε τα πεδία `chunk_size` και `chunk_prev_size` κατάλληλα για τα δύο κομμάτια.
2. Το πρώτο κομμάτι επιστρέφεται μετά την κλήση του `alloc_perturb`.
3. Αν η παραπάνω συνθήκη είναι ψευδής, η έλεγχος φτάνει εδώ. Αφαιρέστε το `victim` από τον αταξινόμητο bin. Αν το μέγεθος του `victim` ταιριάζει ακριβώς με το ζητούμενο μέγεθος, επιστρέψτε αυτό το κομμάτι μετά την κλήση του `alloc_perturb`.
4. Αν το μέγεθος του `victim` ανήκει στο εύρος του smallbin, προσθέστε το κομμάτι στον κατάλληλο smallbin στο `HEAD`.
5. Διαφορετικά εισάγετε στον κατάλληλο largebin διατηρώντας την ταξινομημένη σειρά:
6. Ελέγξτε πρώτα το τελευταίο κομμάτι (το μικρότερο). Αν το `victim` είναι μικρότερο από το τελευταίο κομμάτι, εισάγετέ το στο τέλος.
7. Διαφορετικά, επαναλάβετε για να βρείτε ένα κομμάτι με μέγεθος >= του `victim`. Αν το μέγεθος είναι ακριβώς το ίδιο, εισάγετε πάντα στη δεύτερη θέση.
8. Επαναλάβετε αυτό το βήμα μέγιστο `MAX_ITERS` (10000) φορές ή μέχρι να εξαντληθούν όλα τα κομμάτια στον αταξινόμητο bin.
7. Μετά τον έλεγχο των αταξινόμητων κομματιών, ελέγξτε αν το ζητούμενο μέγεθος δεν ανήκει στο εύρος του smallbin, αν ναι τότε ελέγξτε τα **largebins**.
1. Πάρτε δείκτη στον πίνακα largebin για να έχετε πρόσβαση σε ένα κατάλληλο
## Ελεύθερη Ροή

{% hint style="success" %}
(Η τρέχουσα εξήγηση προέρχεται από [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Ελέγξτε την τελευταία έκδοση και ενημερώστε την)
{% endhint %}

Η τελική συνάρτηση που ελευθερώνει κομμάτια μνήμης είναι η `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Ελέγξτε εάν το `p` βρίσκεται πριν από το `p + chunksize(p)` στη μνήμη (για να αποφευχθεί η τυλιγμένη μνήμη). Διαφορετικά εκτοξεύεται ένα σφάλμα (`free(): μη έγκυρος δείκτης`).
2. Ελέγξτε εάν το μέγεθος του κομματιού είναι τουλάχιστον `MINSIZE` ή πολλαπλάσιο του `MALLOC_ALIGNMENT`. Διαφορετικά εκτοξεύεται ένα σφάλμα (`free(): μη έγκυρο μέγεθος`).
3. Εάν το μέγεθος του κομματιού ανήκει στη λίστα fastbin:
1. Ελέγξτε εάν το μέγεθος του επόμενου κομματιού βρίσκεται μεταξύ ελάχιστου και μέγιστου μεγέθους (`av->system_mem`), διαφορετικά εκτοξεύεται ένα σφάλμα (`free(): μη έγκυρο μέγεθος επόμενου (fast)`) αλλιώς.
2. Καλεί το `free_perturb` στο κομμάτι.
3. Ορίζει το `FASTCHUNKS_BIT` για το `av`.
4. Παίρνει δείκτη στον πίνακα fastbin ανάλογα με το μέγεθος του κομματιού.
5. Ελέγχει εάν η κορυφή του κάδου δεν είναι το κομμάτι που πρόκειται να προστεθεί. Διαφορετικά, εκτοξεύεται ένα σφάλμα (`διπλή ελευθέρωση ή διαφθορά (fasttop)`).
6. Ελέγχει εάν το μέγεθος του κομματιού fastbin στην κορυφή είναι το ίδιο με το κομμάτι που προσθέτουμε. Διαφορετικά, εκτοξεύεται ένα σφάλμα (`μη έγκυρη είσοδος fastbin (ελεύθερη)`).
7. Εισάγει το κομμάτι στην κορυφή της λίστας fastbin και επιστρέφει.
4. Εάν το κομμάτι δεν είναι mmapped:
1. Ελέγξτε εάν το κομμάτι είναι το κορυφαίο κομμάτι ή όχι. Εάν ναι, εκτοξεύεται ένα σφάλμα (`διπλή ελευθέρωση ή διαφθορά (κορυφή) `).
2. Ελέγξτε εάν το επόμενο κομμάτι (με βάση τη μνήμη) βρίσκεται εντός των ορίων της αρένας. Αν όχι, εκτοξεύεται ένα σφάλμα (`διπλή ελευθέρωση ή διαφθορά (έξω) `).
3. Ελέγξτε εάν το προηγούμενο bit χρήσης του επόμενου κομματιού (με βάση τη μνήμη) είναι σημασμένο ή όχι. Αν όχι, εκτοξεύεται ένα σφάλμα (`διπλή ελευθέρωση ή διαφθορά (!prev) `).
4. Ελέγξτε εάν το μέγεθος του επόμενου κομματιού βρίσκεται μεταξύ του ελάχιστου και μέγιστου μεγέθους (`av->system_mem`). Αν όχι, εκτοξεύεται ένα σφάλμα (`free(): μη έγκυρο μέγεθος επόμενου (κανονικό) `).
5. Καλεί το `free_perturb` στο κομμάτι.
6. Εάν το προηγούμενο κομμάτι (με βάση τη μνήμη) δεν είναι σε χρήση, καλέστε το `unlink` στο προηγούμενο κομμάτι.
7. Εάν το επόμενο κομμάτι (με βάση τη μνήμη) δεν είναι κορυφαίο κομμάτι:
1. Αν το επόμενο κομμάτι δεν είναι σε χρήση, καλέστε το `unlink` στο επόμενο κομμάτι.
2. Συγχωνεύστε το κομμάτι με το προηγούμενο, το επόμενο (με βάση τη μνήμη), αν υπάρχει ελεύθερο, και προσθέστε το στην αρχή του unsorted bin. Πριν την εισαγωγή, ελέγξτε εάν `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ή όχι. Αν όχι, εκτοξεύεται ένα σφάλμα ("free(): διαφθορά στα unsorted chunks").
8. Εάν το επόμενο κομμάτι (με βάση τη μνήμη) ήταν κορυφαίο κομμάτι, συγχωνεύστε τα κομμάτια κατάλληλα σε ένα μοναδικό κορυφαίο κομμάτι.
5. Αν το κομμάτι ήταν mmapped, καλέστε το `munmap_chunk`.

## Έλεγχοι Ασφαλείας Συναρτήσεων Κάδου

Ελέγξτε τους έλεγχους ασφαλείας που πραγματοποιούνται από συχνά χρησιμοποιούμενες συναρτήσεις στον κάδο σε:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Αναφορές

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
