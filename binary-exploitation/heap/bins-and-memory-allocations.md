# Bins & Aloca√ß√µes de Mem√≥ria

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

Para melhorar a efici√™ncia na forma como os chunks s√£o armazenados, cada chunk n√£o est√° apenas em uma lista encadeada, mas existem v√°rios tipos. Estes s√£o os bins e existem 5 tipos de bins: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) small bins, 63 large bins, 1 unsorted bin, 10 fast bins e 64 tcache bins por thread.

O endere√ßo inicial para cada bin n√£o ordenado, small e large est√° dentro do mesmo array. O √≠ndice 0 n√£o √© usado, 1 √© o bin n√£o ordenado, os bins 2-64 s√£o os small bins e os bins 65-127 s√£o os large bins.

### Small Bins

Os small bins s√£o mais r√°pidos do que os large bins, mas mais lentos do que os fast bins.

Cada bin dos 62 ter√° **chunks do mesmo tamanho**: 16, 24, ... (com um tamanho m√°ximo de 504 bytes em 32 bits e 1024 em 64 bits). Isso ajuda na velocidade para encontrar o bin onde um espa√ßo deve ser alocado e inserir e remover entradas nessas listas.

### Large Bins

Ao contr√°rio dos small bins, que gerenciam chunks de tamanhos fixos, cada **large bin lida com uma faixa de tamanhos de chunk**. Isso √© mais flex√≠vel, permitindo que o sistema acomode **v√°rios tamanhos** sem precisar de um bin separado para cada tamanho.

Em um alocador de mem√≥ria, os large bins come√ßam onde os small bins terminam. As faixas para os large bins crescem progressivamente, o que significa que o primeiro bin pode cobrir chunks de 512 a 576 bytes, enquanto o pr√≥ximo cobre de 576 a 640 bytes. Esse padr√£o continua, com o maior bin contendo todos os chunks acima de 1MB.

Os large bins s√£o mais lentos de operar em compara√ß√£o com os small bins porque eles precisam **ordenar e pesquisar em uma lista de tamanhos de chunk variados para encontrar o melhor encaixe** para uma aloca√ß√£o. Quando um chunk √© inserido em um large bin, ele precisa ser ordenado, e quando a mem√≥ria √© alocada, o sistema deve encontrar o chunk certo. Esse trabalho extra os torna **mais lentos**, mas como aloca√ß√µes grandes s√£o menos comuns do que as pequenas, √© uma troca aceit√°vel.

Existem:

* 32 bins de faixa de 64B
* 16 bins de faixa de 512B
* 8 bins de faixa de 4096B
* 4 bins de faixa de 32768B
* 2 bins de faixa de 262144B
* 1 bin para tamanhos restantes

### Unsorted Bin

O unsorted bin √© um **cache r√°pido** usado pelo gerenciador de heap para tornar a aloca√ß√£o de mem√≥ria mais r√°pida. Veja como funciona: Quando um programa libera mem√≥ria, o gerenciador de heap n√£o a coloca imediatamente em um bin espec√≠fico. Em vez disso, primeiro tenta **fundir com quaisquer chunks livres vizinhos** para criar um bloco maior de mem√≥ria livre. Em seguida, coloca esse novo chunk em um bin geral chamado "unsorted bin".

Quando um programa **solicita mem√≥ria**, o gerenciador de heap **verifica o unsorted bin** para ver se h√° um chunk de tamanho suficiente. Se encontrar um, ele o usa imediatamente. Se n√£o encontrar um chunk adequado, move os chunks liberados para seus bins correspondentes, seja small ou large, com base em seus tamanhos.

Portanto, o unsorted bin √© uma maneira de acelerar a aloca√ß√£o de mem√≥ria reutilizando rapidamente a mem√≥ria liberada recentemente e reduzindo a necessidade de pesquisas e fus√µes demoradas.

{% hint style="danger" %}
Observe que mesmo que os chunks sejam de categorias diferentes, se um chunk dispon√≠vel estiver colidindo com outro chunk dispon√≠vel (mesmo que sejam de categorias diferentes), eles ser√£o mesclados.
{% endhint %}

### Fast Bins

Os fast bins s√£o projetados para **acelerar a aloca√ß√£o de mem√≥ria para pequenos chunks** mantendo chunks liberados recentemente em uma estrutura de acesso r√°pido. Esses bins usam uma abordagem Last-In, First-Out (LIFO), o que significa que o **chunk liberado mais recentemente √© o primeiro** a ser reutilizado quando h√° uma nova solicita√ß√£o de aloca√ß√£o. Esse comportamento √© vantajoso para a velocidade, pois √© mais r√°pido inserir e remover do topo de uma pilha (LIFO) em compara√ß√£o com uma fila (FIFO).

Al√©m disso, **os fast bins usam listas encadeadas simples**, n√£o duplamente encadeadas, o que melhora ainda mais a velocidade. Como os chunks nos fast bins n√£o s√£o mesclados com vizinhos, n√£o h√° necessidade de uma estrutura complexa que permita a remo√ß√£o do meio. Uma lista encadeada simples √© mais simples e r√°pida para essas opera√ß√µes.

Basicamente, o que acontece aqui √© que o cabe√ßalho (o ponteiro para o primeiro chunk a ser verificado) est√° sempre apontando para o chunk liberado mais recentemente desse tamanho. Portanto:

* Quando um novo chunk √© alocado desse tamanho, o cabe√ßalho est√° apontando para um chunk livre para usar. Como esse chunk livre est√° apontando para o pr√≥ximo a ser usado, esse endere√ßo √© armazenado no cabe√ßalho para que a pr√≥xima aloca√ß√£o saiba onde obter um chunk dispon√≠vel.
* Quando um chunk √© liberado, o chunk livre salvar√° o endere√ßo para o chunk dispon√≠vel atual e o endere√ßo para esse chunk rec√©m-liberado ser√° colocado no cabe√ßalho.

{% hint style="danger" %}
Chunks nos fast bins n√£o s√£o definidos automaticamente como dispon√≠veis, ent√£o eles permanecem como chunks de fast bin por algum tempo em vez de poderem ser mesclados com outros chunks.
{% endhint %}

### Tcache (Cache por Thread) Bins

Mesmo que as threads tentem ter sua pr√≥pria heap (veja [Arenas](bins-and-memory-allocations.md#arenas) e [Subheaps](bins-and-memory-allocations.md#subheaps)), h√° a possibilidade de que um processo com muitas threads (como um servidor web) **acabe compartilhando a heap com outras threads**. Nesse caso, a solu√ß√£o principal √© o uso de **lockers**, que podem **desacelerar significativamente as threads**.

Portanto, um tcache √© semelhante a um fast bin por thread no sentido de que √© uma **lista encadeada simples** que n√£o mescla chunks. Cada thread tem **64 tcache bins encadeados simples**. Cada bin pode ter um m√°ximo de [7 chunks do mesmo tamanho](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) variando de [24 a 1032B em sistemas de 64 bits e de 12 a 516B em sistemas de 32 bits](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

Quando uma thread **libera** um chunk, **se n√£o for muito grande** para ser alocado no tcache e o respectivo bin do tcache **n√£o estiver cheio** (j√° com 7 chunks), **ele ser√° alocado l√°**. Se n√£o puder ir para o tcache, precisar√° esperar o bloqueio da heap para poder realizar a opera√ß√£o de libera√ß√£o globalmente.

Quando um **chunk √© alocado**, se houver um chunk livre do tamanho necess√°rio no **Tcache, ele ser√° usado**, caso contr√°rio, precisar√° esperar o bloqueio da heap para poder encontrar um nos bins globais ou criar um novo.\
H√° tamb√©m uma otimiza√ß√£o, nesse caso, enquanto tiver o bloqueio da heap, a thread **preencher√° seu Tcache com chunks da heap (7) do tamanho solicitado**, para que, caso precise de mais, os encontre no Tcache.
## Fluxo de Aloca√ß√£o

{% hint style="success" %}
(Esta explica√ß√£o atual √© de [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Verificar √∫ltima vers√£o e atualiz√°-la)
{% endhint %}

As aloca√ß√µes s√£o finalmente realizadas com a fun√ß√£o: `void * _int_malloc (mstate av, size_t bytes)` e seguem esta ordem:

1. Atualiza `bytes` para cuidar dos **alinhamentos**, etc.
2. Verifica se `av` √© **NULL** ou n√£o.
3. No caso de aus√™ncia de **arena utiliz√°vel** (quando `av` √© NULL), chama `sysmalloc` para obter um chunk usando mmap. Se bem-sucedido, chama `alloc_perturb`. Retorna o ponteiro.
4. Dependendo do tamanho:
* \[Adi√ß√£o ao original] Usa tcache antes de verificar o pr√≥ximo fastbin.
* \[Adi√ß√£o ao original] Se n√£o houver tcache, mas um bin diferente for usado (ver etapa posterior), tenta preencher a tcache a partir desse bin.
* Se o tamanho estiver na faixa do **fastbin**:
1. Obt√©m o √≠ndice na matriz fastbin para acessar um bin apropriado de acordo com o tamanho solicitado.
2. Remove o primeiro chunk nesse bin e faz com que `victim` aponte para ele.
3. Se `victim` for NULL, passa para o pr√≥ximo caso (smallbin).
4. Se `victim` n√£o for NULL, verifica o tamanho do chunk para garantir que perten√ßa a esse bin espec√≠fico. Caso contr√°rio, √© lan√ßado um erro ("malloc(): corrup√ß√£o de mem√≥ria (fast)").
5. Chama `alloc_perturb` e ent√£o retorna o ponteiro.
* Se o tamanho estiver na faixa do **smallbin**:
1. Obt√©m o √≠ndice na matriz smallbin para acessar um bin apropriado de acordo com o tamanho solicitado.
2. Se n√£o houver chunks neste bin, passa para o pr√≥ximo caso. Isso √© verificado comparando os ponteiros `bin` e `bin->bk`.
3. `victim` √© igual a `bin->bk` (o √∫ltimo chunk no bin). Se for NULL (ocorre durante a `inicializa√ß√£o`), chama `malloc_consolidate` e pula esta etapa completa de verifica√ß√£o em bins diferentes.
4. Caso contr√°rio, quando `victim` n√£o for NULL, verifica se `victim->bk->fd` e `victim` s√£o iguais ou n√£o. Se n√£o forem iguais, √© lan√ßado um erro (`malloc(): lista duplamente vinculada smallbin corrompida`).
5. Define o bit PREV\_INSUSE para o pr√≥ximo chunk (na mem√≥ria, n√£o na lista duplamente vinculada) para `victim`.
6. Remove este chunk da lista do bin.
7. Define o bit de arena apropriado para este chunk dependendo de `av`.
8. Chama `alloc_perturb` e ent√£o retorna o ponteiro.
* Se o tamanho n√£o estiver na faixa do smallbin:
1. Obt√©m o √≠ndice na matriz largebin para acessar um bin apropriado de acordo com o tamanho solicitado.
2. Verifica se `av` possui fastchunks ou n√£o. Isso √© feito verificando o `FASTCHUNKS_BIT` em `av->flags`. Se sim, chama `malloc_consolidate` em `av`.
5. Se nenhum ponteiro foi retornado ainda, isso significa um ou mais dos seguintes casos:
1. O tamanho est√° na faixa do 'fastbin' mas nenhum fastchunk est√° dispon√≠vel.
2. O tamanho est√° na faixa do 'smallbin' mas nenhum smallchunk est√° dispon√≠vel (chama `malloc_consolidate` durante a inicializa√ß√£o).
3. O tamanho est√° na faixa do 'largebin'.
6. Em seguida, os **chunks n√£o ordenados** s√£o verificados e os chunks percorridos s√£o colocados em bins. Este √© o √∫nico lugar onde os chunks s√£o colocados em bins. Itera o bin n√£o ordenado a partir do 'TAIL'.
1. `victim` aponta para o chunk atual em considera√ß√£o.
2. Verifica se o tamanho do chunk de `victim` est√° dentro da faixa m√≠nima (`2*SIZE_SZ`) e m√°xima (`av->system_mem`). Lan√ßa um erro (`malloc(): corrup√ß√£o de mem√≥ria`) caso contr√°rio.
3. Se (o tamanho do chunk solicitado est√° na faixa do smallbin) e (`victim` √© o √∫ltimo chunk restante) e (√© o √∫nico chunk no bin n√£o ordenado) e (o tamanho dos chunks >= o solicitado): **Divide o chunk em 2 chunks**:
* O primeiro chunk corresponde ao tamanho solicitado e √© retornado.
* O chunk restante se torna o novo √∫ltimo chunk restante. Ele √© reinserido no bin n√£o ordenado.
1. Define os campos `chunk_size` e `chunk_prev_size` apropriadamente para ambos os chunks.
2. O primeiro chunk √© retornado ap√≥s chamar `alloc_perturb`.
3. Se a condi√ß√£o acima for falsa, o controle chega aqui. Remove `victim` do bin n√£o ordenado. Se o tamanho de `victim` corresponder exatamente ao tamanho solicitado, retorne este chunk ap√≥s chamar `alloc_perturb`.
4. Se o tamanho de `victim` estiver na faixa do smallbin, adicione o chunk no smallbin apropriado no `HEAD`.
5. Caso contr√°rio, insira no largebin apropriado mantendo a ordem classificada:
6. Primeiro verifica o √∫ltimo chunk (menor). Se `victim` for menor que o √∫ltimo chunk, insere-o no final.
7. Caso contr√°rio, fa√ßa um loop para encontrar um chunk com tamanho >= tamanho de `victim`. Se o tamanho for exatamente o mesmo, sempre insira na segunda posi√ß√£o.
8. Repita toda essa etapa um m√°ximo de `MAX_ITERS` (10000) vezes ou at√© que todos os chunks no bin n√£o ordenado se esgotem.
7. Ap√≥s verificar os chunks n√£o ordenados, verifique se o tamanho solicitado n√£o est√° na faixa do smallbin, se sim, verifique os **largebins**.
1. Obt√©m o √≠ndice na matriz largebin para acessar um bin apropriado de acordo com o tamanho solicitado.
2. Se o tamanho do maior chunk (o primeiro chunk no bin) for maior que o tamanho solicitado:
1. Itera a partir do 'TAIL' para encontrar um chunk (`victim`) com o menor tamanho >= o tamanho solicitado.
2. Chama `unlink` para remover o chunk `victim` do bin.
3. Calcula `remainder_size` para o chunk de `victim` (este ser√° o tamanho do chunk de `victim` - tamanho solicitado).
4. Se este `remainder_size` >= `MINSIZE` (o tamanho m√≠nimo do chunk incluindo os cabe√ßalhos), divide o chunk em dois chunks. Caso contr√°rio, o chunk inteiro de `victim` ser√° retornado. Insira o chunk restante no bin n√£o ordenado (no final do 'TAIL'). √â feita uma verifica√ß√£o no bin n√£o ordenado se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Um erro √© lan√ßado caso contr√°rio ("malloc(): chunks n√£o ordenados corrompidos").
5. Retorna o chunk `victim` ap√≥s chamar `alloc_perturb`.
8. At√© agora, verificamos o bin n√£o ordenado e tamb√©m o respectivo fast, small ou large bin. Observe que um √∫nico bin (fast ou small) foi verificado usando o tamanho **exato** do chunk solicitado. Repita as seguintes etapas at√© que todos os bins se esgotem:
1. O √≠ndice na matriz bin √© incrementado para verificar o pr√≥ximo bin.
2. Usa o mapa `av->binmap` para pular os bins vazios.
3. `victim` aponta para o 'TAIL' do bin atual.
4. Usando o binmap garante que se um bin for pulado (no segundo passo acima), ele est√° definitivamente vazio. No entanto, n√£o garante que todos os bins vazios ser√£o pulados. Verifique se o victim est√° vazio ou n√£o. Se estiver vazio, pule novamente o bin e repita o processo acima (ou 'continue' este loop) at√© chegarmos a um bin n√£o vazio.
5. Divida o chunk (`victim` aponta para o √∫ltimo chunk de um bin n√£o vazio) em dois chunks. Insira o chunk restante no bin n√£o ordenado (no final do 'TAIL'). √â feita uma verifica√ß√£o no bin n√£o ordenado se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Um erro √© lan√ßado caso contr√°rio ("malloc(): chunks n√£o ordenados corrompidos 2").
6. Retorna o chunk `victim` ap√≥s chamar `alloc_perturb`.
9. Se ainda nenhum bin vazio for encontrado, o chunk 'top' ser√° usado para atender √† solicita√ß√£o:
1. `victim` aponta para `av->top`.
2. Se o tamanho do chunk 'top' >= 'tamanho solicitado' + `MINSIZE`, divida-o em dois chunks. Neste caso, o chunk restante se torna o novo chunk 'top' e o outro chunk √© retornado ao usu√°rio ap√≥s chamar `alloc_perturb`.
3. Verifica se `av` possui fastchunks ou n√£o. Isso √© feito verificando o `FASTCHUNKS_BIT` em `av->flags`. Se sim, chama `malloc_consolidate` em `av`. Retorna para a etapa 6 (onde verificamos o bin n√£o ordenado).
4. Se `av` n√£o tiver fastchunks, chama `sysmalloc` e retorna o ponteiro obtido ap√≥s chamar `alloc_perturb`.
## Fluxo Livre

{% hint style="success" %}
(Esta explica√ß√£o atual √© de [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Verificar √∫ltima vers√£o e atualiz√°-la)
{% endhint %}

A fun√ß√£o final que libera peda√ßos de mem√≥ria √© `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Verificar se `p` est√° antes de `p + chunksize(p)` na mem√≥ria (para evitar embrulhar). Um erro (`free(): ponteiro inv√°lido`) √© lan√ßado caso contr√°rio.
2. Verificar se o peda√ßo tem pelo menos o tamanho `MINSIZE` ou √© um m√∫ltiplo de `MALLOC_ALIGNMENT`. Um erro (`free(): tamanho inv√°lido`) √© lan√ßado caso contr√°rio.
3. Se o tamanho do peda√ßo estiver na lista fastbin:
1. Verificar se o tamanho do pr√≥ximo peda√ßo est√° entre o tamanho m√≠nimo e m√°ximo (`av->system_mem`), lan√ßar um erro (`free(): tamanho pr√≥ximo inv√°lido (r√°pido)`) caso contr√°rio.
2. Chamar `free_perturb` no peda√ßo.
3. Definir `FASTCHUNKS_BIT` para `av`.
4. Obter √≠ndice na matriz fastbin de acordo com o tamanho do peda√ßo.
5. Verificar se o topo do bin n√£o √© o peda√ßo que estamos adicionando. Caso contr√°rio, lan√ßar um erro (`dupla libera√ß√£o ou corrup√ß√£o (topo r√°pido)`).
6. Verificar se o tamanho do peda√ßo fastbin no topo √© o mesmo que o peda√ßo que estamos adicionando. Caso contr√°rio, lan√ßar um erro (`entrada fastbin inv√°lida (libera√ß√£o)`).
7. Inserir o peda√ßo no topo da lista fastbin e retornar.
4. Se o peda√ßo n√£o estiver mapeado:
1. Verificar se o peda√ßo √© o peda√ßo superior ou n√£o. Se sim, um erro (`dupla libera√ß√£o ou corrup√ß√£o (topo)`) √© lan√ßado.
2. Verificar se o pr√≥ximo peda√ßo (por mem√≥ria) est√° dentro dos limites da arena. Se n√£o estiver, um erro (`dupla libera√ß√£o ou corrup√ß√£o (fora)`) √© lan√ßado.
3. Verificar se o bit anterior em uso do pr√≥ximo peda√ßo (por mem√≥ria) est√° marcado ou n√£o. Se n√£o estiver, um erro (`dupla libera√ß√£o ou corrup√ß√£o (!prev)`) √© lan√ßado.
4. Verificar se o tamanho do pr√≥ximo peda√ßo est√° entre o tamanho m√≠nimo e m√°ximo (`av->system_mem`). Se n√£o estiver, um erro (`free(): tamanho pr√≥ximo inv√°lido (normal)`) √© lan√ßado.
5. Chamar `free_perturb` no peda√ßo.
6. Se o peda√ßo anterior (por mem√≥ria) n√£o estiver em uso, chamar `unlink` no peda√ßo anterior.
7. Se o pr√≥ximo peda√ßo (por mem√≥ria) n√£o for o peda√ßo superior:
1. Se o pr√≥ximo peda√ßo n√£o estiver em uso, chamar `unlink` no pr√≥ximo peda√ßo.
2. Mesclar o peda√ßo com o anterior, pr√≥ximo (por mem√≥ria), se algum estiver livre e adicion√°-lo ao in√≠cio do bin n√£o ordenado. Antes de inserir, verificar se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ou n√£o. Se n√£o, um erro ("free(): peda√ßos n√£o ordenados corrompidos") √© lan√ßado.
8. Se o pr√≥ximo peda√ßo (por mem√≥ria) era um peda√ßo superior, mesclar os peda√ßos apropriadamente em um √∫nico peda√ßo superior.
5. Se o peda√ßo estava mapeado, chamar `munmap_chunk`.

## Verifica√ß√µes de Seguran√ßa das Fun√ß√µes de Heap

Verifique as verifica√ß√µes de seguran√ßa realizadas por fun√ß√µes amplamente utilizadas no heap em:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Refer√™ncias

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Obtenha o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
