# Bins & Ugawaji wa Kumbukumbu

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Taarifa Msingi

Ili kuboresha ufanisi wa jinsi vipande vinavyohifadhiwa, kila kipande sio tu kwenye orodha moja iliyounganishwa, bali kuna aina kadhaa. Hizi ni bakuli na kuna aina 5 za bakuli: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) bakuli ndogo, 63 bakuli kubwa, 1 bakuli lisilo na mpangilio, 10 bakuli za haraka na 64 bakuli za tcache kwa kila mnyororo.

Anwani ya awali kwa kila bakuli lisilo na mpangilio, bakuli dogo na kubwa iko ndani ya safu moja. Indeksi 0 haifai, 1 ni bakuli lisilo na mpangilio, bakuli 2-64 ni bakuli ndogo na bakuli 65-127 ni bakuli kubwa.

### Bakuli Ndogo

Bakuli ndogo ni haraka kuliko bakuli kubwa lakini polepole kuliko bakuli za haraka.

Kila bakuli kati ya 62 itakuwa na **vipande vya saizi ile ile**: 16, 24, ... (na saizi ya juu ya byte 504 katika bits 32 na 1024 katika bits 64). Hii husaidia katika kasi ya kupata bakuli ambapo nafasi inapaswa kutengwa na kuingiza na kuondoa viingilio kwenye orodha hizi.

### Bakuli Kubwa

Tofauti na bakuli ndogo, ambazo hushughulikia vipande vya saizi iliyowekwa, kila **bakuli kubwa hushughulikia safu ya saizi za vipande**. Hii ni ya kubadilika zaidi, kuruhusu mfumo kuhifadhi **saizi tofauti** bila kuhitaji bakuli tofauti kwa kila saizi.

Katika mpangilio wa kumbukumbu, bakuli kubwa huanza pale bakuli ndogo inapoishia. Safu za bakuli kubwa hukua kwa ukubwa unaokua, maana bakuli la kwanza linaweza kufunika vipande kutoka 512 hadi 576 byte, wakati ufuatao unafunika 576 hadi 640 byte. Mtindo huu unaendelea, na bakuli kubwa zaidi ikijumuisha vipande vyote zaidi ya 1MB.

Bakuli kubwa ni polepole kufanya kazi ikilinganishwa na bakuli ndogo kwa sababu lazima **zipange na kutafuta kupitia orodha ya saizi tofauti za vipande ili kupata saizi bora** kwa kutengwa. Wakati kipande kinapowekwa kwenye bakuli kubwa, lazima kipangwe, na wakati kumbukumbu inatengwa, mfumo lazima ipate kipande sahihi. Kazi hii ya ziada inawafanya kuwa **polepole**, lakini kwa kuwa vipande vikubwa ni nadra kuliko vya kawaida, ni sawa kufanya biashara hiyo.

Kuna:

* Bakuli 32 za safu ya 64B
* Bakuli 16 za safu ya 512B
* Bakuli 8 za safu ya 4096B
* Bakuli 4 za safu ya 32768B
* Bakuli 2 za safu ya 262144B
* Bakuli 1 kwa ajili ya saizi zilizobaki

### Bakuli Lisilo na Mpangilio

Bakuli lisilo na mpangilio ni **akiba ya haraka** inayotumiwa na meneja wa kumbukumbu ili kufanya kutenga kwa haraka kwa kumbukumbu. Hivi ndivyo inavyofanya kazi: Wakati programu inaachilia kumbukumbu, meneja wa kumbukumbu haitoi mara moja kwenye bakuli maalum. Badala yake, kwanza inajaribu **kulijumuisha na vipande vya bure vya jirani** ili kuunda kibodi kikubwa cha kumbukumbu ya bure. Kisha, inaweka kipande kipya hiki kwenye bakuli la jumla linaloitwa "bakuli lisilo na mpangilio."

Wakati programu **inaomba kumbukumbu**, meneja wa kumbukumbu **huchunguza bakuli lisilo na mpangilio** kuona ikiwa kuna kipande cha saizi ya kutosha. Ikiwa inapata moja, inaitumia mara moja. Ikiwa haina kipande kinachofaa, inahamisha vipande vilivyofutwa kwenye bakuli zao husika, iwe ndogo au kubwa, kulingana na saizi zao.

Kwa hivyo, bakuli lisilo na mpangilio ni njia ya kuharakisha kutenga kwa kumbukumbu kwa haraka kwa kutumia tena kumbukumbu iliyofutwa hivi karibuni na kupunguza haja ya kutafuta na kujumuisha kwa muda mrefu.

{% hint style="danger" %}
Tafadhali kumbuka kwamba hata kama vipande ni vya makundi tofauti, ikiwa kipande kinachopatikana kinaingiliana na kipande kingine kilichopo (hata kama ni vikundi tofauti), vitajumuishwa.
{% endhint %}

### Bakuli za Haraka

Bakuli za haraka zimeundwa kuharakisha **kutenga kwa kumbukumbu kwa vipande vidogo** kwa kuweka vipande vilivyofutwa hivi karibuni katika muundo wa kupata haraka. Bakuli hizi hutumia njia ya Mwisho-Kuingia, Mwanzo-Kutoka (LIFO), maana kwamba **kipande kilichofutwa hivi karibuni ndicho kwanza** kutumika wakati kuna ombi jipya la kutenga. Tabia hii ni nzuri kwa kasi, kwani ni haraka kuingiza na kuondoa kutoka juu ya rundo (LIFO) ikilinganishwa na foleni (FIFO).

Zaidi ya hayo, **bakuli za haraka hutumia orodha za kushikamana moja**, sio mbili, ambayo inaboresha kasi zaidi. Kwa kuwa vipande katika bakuli za haraka havijajumuishwa na majirani, hakuna haja ya muundo tata unaoruhusu kuondolewa katikati. Orodha ya kushikamana moja ni rahisi na haraka kwa shughuli hizi.

Kimsingi, kinachotokea hapa ni kwamba kichwa (kiashiria cha kipande cha kwanza cha kuangalia) kinaelekeza daima kwenye kipande kilichofutwa hivi karibuni cha saizi hiyo. Kwa hivyo:

* Wakati kipande kipya kinatengwa cha saizi hiyo, kichwa kinaelekeza kwenye kipande cha bure cha kutumia. Kwa kuwa kipande hiki cha bure kinaelekeza kwenye kipande kinachofuata cha kutumia, anwani hii inahifadhiwa kwenye kichwa ili kutolewa ijayo ijue wapi kupata kipande kinachopatikana
* Wakati kipande kinapofutwa, kipande cha bure kitahifadhi anwani ya kipande kinachopatikana kwa sasa na anwani ya kipande hiki kilichofutwa itawekwa kwenye kichwa

{% hint style="danger" %}
Vipande katika bakuli za haraka havijaainishwa moja kwa moja kama vinavyopatikana hivyo vinabaki kama vipande vya bakuli za haraka kwa muda fulani badala ya kuweza kujumuishwa na vipande vingine.
{% endhint %}

### Bakuli za Tcache (Akiba kwa Mnyororo)

Ingawa nyuzi zinajaribu kuwa na kumbukumbu yao wenyewe (angalia [Arenas](bins-and-memory-allocations.md#arenas) na [Subheaps](bins-and-memory-allocations.md#subheaps)), kuna uwezekano kwamba mchakato na nyuzi nyingi (kama seva ya wavuti) **itamaliza kushiriki kumbukumbu na nyuzi nyingine**. Katika kesi hii, suluhisho kuu ni matumizi ya **lockers**, ambayo yanaweza **kupunguza kasi kwa kiasi kikubwa nyuzi**.

Kwa hivyo, tcache ni sawa na bakuli la haraka kwa kila nyuzi kwa njia kwamba ni **orodha ya kushikamana moja** ambayo haifanyi vipande. Kila nyuzi ina **bakuli 64 za tcache za kushikamana moja**. Kila bakuli inaweza kuwa na kiwango cha juu cha [vipande 7 vya saizi ile ile](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) kutoka [24 hadi 1032B kwenye mifumo ya 64-bit na 12 hadi 516B kwenye mifumo ya 32-bit](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Wakati nyuzi inafuta** kipande, **ikiwa sio kikubwa sana** kutengwa kwenye tcache na bakuli ya tcache **haiko kamili** (tayari vipande 7), **itawekwa hapo**. Ikiwa haitaweza kwenda kwenye tcache, italazimika kusubiri kwa ajili ya kufungua kumbukumbu ili kufanya operesheni ya kufuta kwa jumla.

Wakati **kipande kinapotengwa**, ikiwa kuna kipande cha bure cha saizi inayohitajika kwenye **Tcache itakitumia**, ikiwa la, italazimika kusubiri kwa kufungua kumbukumbu ili kupata moja kwenye bakuli za jumla au kuunda mpya.\
Kuna pia uboreshaji, katika kesi hii, wakati wa kufungua kumbukumbu, nyuzi **itajaza Tcache yake na vipande vya kumbukumbu (7) vya saizi inayohitajika**, hivyo ikihitaji zaidi, itavipata kwenye Tcache.
## Mchakato wa Kutengwa

{% hint style="success" %}
(Maelezo haya ya sasa yanatoka kwa [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Angalia toleo la mwisho na ulishe)
{% endhint %}

Uteuzi unafanywa hatimaye na kazi: `void * _int_malloc (mstate av, size_t bytes)` na una mpangilio huu:

1. Inasasisha `bytes` kuchukua huduma ya **upangaji**, n.k.
2. Inachunguza kama `av` ni **NULL** au la.
3. Katika kesi ya kutokuwepo kwa **eneo linaloweza kutumika** (wakati `av` ni NULL), inaita `sysmalloc` kupata kipande kwa kutumia mmap. Ikiwa mafanikio, inaita `alloc_perturb`. Inarudisha kipande.
4. Kulingana na ukubwa:
* \[Ongeza kwa asili] Tumia tcache kabla ya kuangalia fastbin inayofuata.
* \[Ongeza kwa asili] Ikiwa hakuna tcache lakini bakuli tofauti inatumika (angalia hatua inayofuata), jaribu kujaza tcache kutoka kwa bakuli hilo
* Ikiwa ukubwa unaanguka katika safu ya **fastbin**:&#x20;
1. Pata kiashiria katika safu ya fastbin ili kupata bakuli sahihi kulingana na ukubwa wa ombi.&#x20;
2. Ondoa kipande cha kwanza katika bakuli hilo na fanya `victim` ielekee hiyo.
3. Ikiwa `victim` ni NULL, endelea kwa kesi inayofuata (smallbin).
4. Ikiwa `victim` sio NULL, angalia ukubwa wa kipande ili kuhakikisha kuwa kinamiliki bakuli hilo maalum. Kosa ("malloc(): memory corruption (fast)") hutupwa vinginevyo.
5. Inaita `alloc_perturb` na kisha inarudisha kipande.
* Ikiwa ukubwa unaanguka katika safu ya **smallbin**:
1. Pata kiashiria katika safu ya smallbin ili kupata bakuli sahihi kulingana na ukubwa wa ombi.
2. Ikiwa hakuna vipande katika bakuli hili, endelea kwa kesi inayofuata. Hii inachunguzwa kwa kulinganisha pointers `bin` na `bin->bk`.
3. `victim` inafanywa sawa na `bin->bk` (kipande cha mwisho katika bakuli). Ikiwa ni NULL (inasababishwa wakati wa `initialization`), ita `malloc_consolidate` na ruka hatua kamili ya kuangalia katika bakuli tofauti.
4. Vinginevyo, wakati `victim` sio NULL, angalia ikiwa `victim->bk->fd` na `victim` ni sawa au la. Ikiwa sio sawa, kosa (`malloc(): smallbin double linked list corrupted`) hutupwa.
5. Weka biti ya PREV\_INSUSE kwa kipande kinachofuata (kwenye kumbukumbu, sio kwenye orodha iliyofungwa mara mbili) kwa `victim`.
6. Ondoa kipande hiki kutoka kwenye orodha ya bakuli.
7. Weka biti sahihi ya uwanja kwa kipande hiki kulingana na `av`.
8. Inaita `alloc_perturb` na kisha inarudisha kipande.
* Ikiwa ukubwa hauna katika safu ya smallbin:
1. Pata kiashiria katika safu ya largebin ili kupata bakuli sahihi kulingana na ukubwa wa ombi.
2. Angalia ikiwa `av` ina fastchunks au la. Hii inafanywa kwa kuangalia `FASTCHUNKS_BIT` katika `av->flags`. Ikiwa ndivyo, ita `malloc_consolidate` kwenye `av`.
5. Ikiwa hakuna kipande kilichorudishwa bado, hii inaonyesha moja au zaidi ya hali zifuatazo:
1. Ukubwa unaanguka katika safu ya 'fastbin' lakini hakuna fastchunk inapatikana.
2. Ukubwa unaanguka katika safu ya 'smallbin' lakini hakuna smallchunk inapatikana (inaita `malloc_consolidate` wakati wa initialization).
3. Ukubwa unaanguka katika safu ya 'largbin'.
6. Kisha, **vipande visivyo na mpangilio** vinachunguzwa na vipande vilivyopangwa katika bakuli. Hii ndio mahali pekee ambapo vipande vinawekwa katika bakuli. Pitia bakuli lisilopangwa kutoka 'MKIA'.
1. `victim` inaelekeza kipande cha sasa kinachofikiriwa.
2. Angalia ikiwa ukubwa wa kipande cha `victim` uko ndani ya kiwango cha chini (`2*SIZE_SZ`) na cha juu (`av->system_mem`). Tupa kosa (`malloc(): memory corruption`) vinginevyo.
3. Ikiwa (ukubwa wa kipande kilichoombwa unaanguka katika safu ya smallbin) na (`victim` ni kipande cha mabaki cha mwisho) na (ni kipande kimoja tu katika bakuli lisilopangwa) na (ukubwa wa vipande >= ule ulioombwa): **Gawanya kipande katika vipande 2**:
* Kipande cha kwanza kinalingana na ukubwa ulioombwa na kurudishwa.
* Kipande kilichobaki kinakuwa kipande kipya cha mabaki cha mwisho. Kinaingizwa tena kwenye bakuli lisilopangwa.
1. Weka `chunk_size` na `chunk_prev_size` kwa vipande vyote viwili kwa usahihi.
2. Kipande cha kwanza kurudishwa baada ya kuita `alloc_perturb`.
3. Ikiwa hali iliyotajwa hapo juu sio kweli, udhibiti unafikia hapa. Ondoa `victim` kutoka kwenye bakuli lisilopangwa. Ikiwa ukubwa wa `victim` unalingana na ukubwa ulioombwa kikamilifu, rudisha kipande hiki baada ya kuita `alloc_perturb`.
4. Ikiwa ukubwa wa `victim` unaanguka katika safu ya smallbin, ongeza kipande katika smallbin sahihi kwenye `KICHWA`.
5. Vinginevyo ingiza kwenye largebin sahihi wakati wa kudumisha mpangilio uliopangwa:
6. Kwanza angalia kipande cha mwisho (kidogo). Ikiwa `victim` ni ndogo kuliko kipande cha mwisho, ingiza kwenye mwisho.
7. Vinginevyo, endelea kutafuta kipande chenye ukubwa >= ukubwa wa `victim`. Ikiwa ukubwa ni sawa kabisa, ingiza daima kwenye nafasi ya pili.
8. Rudia hatua hii nzima kwa kiwango cha juu cha `MAX_ITERS` (10000) au hadi vipande vyote katika bakuli lisilopangwa vikome.
7. Baada ya kuangalia vipande visivyo na mpangilio, angalia ikiwa ukubwa ulioombwa hauna katika safu ya smallbin, ikiwa ndivyo basi angalia **largebins**.
1. Pata kiashiria katika safu ya largebin ili kupata bakuli sahihi kulingana na ukubwa wa ombi.
2. Ikiwa ukubwa wa kipande kikubwa zaidi (kipande cha kwanza katika bakuli) ni kubwa kuliko ukubwa ulioombwa:
1. Pitia kutoka 'MKIA' ili kupata kipande (`victim`) chenye ukubwa mdogo zaidi au sawa na ukubwa ulioombwa.
2. Ita `unlink` kuondoa kipande cha `victim` kutoka kwenye bakuli.
3. Hesabu `remainder_size` kwa kipande cha `victim` (hii itakuwa ukubwa wa kipande cha `victim` - ukubwa ulioombwa).
4. Ikiwa hii `remainder_size` >= `MINSIZE` (ukubwa wa chini wa kipande pamoja na vichwa), gawa kipande katika vipande viwili. Vinginevyo, kipande chote cha `victim` kitarejeshwa. Ingiza kipande kilichobaki kwenye bakuli lisilopangwa (mwisho wa 'MKIA'). Kunaangalia kwenye bakuli lisilopangwa ikiwa `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Kosa hutupwa vinginevyo ("malloc(): corrupted unsorted chunks").
5. Rudisha kipande cha `victim` baada ya kuita `alloc_perturb`.
8. Mpaka sasa, tumekagua bakuli lisilopangwa na pia bakuli husika la haraka, dogo au kubwa. Tafadhali kumbuka kwamba bakuli moja (haraka au dogo) ilikaguliwa kwa kutumia ukubwa **sahihi** wa kipande kilichoombwa. Rudia hatua zifuatazo hadi bakuli zote zitakapomalizika:
1. Kiashiria katika safu ya bakuli huongezwa ili kuangalia bakuli inayofuata.
2. Tumia ramani ya `av->binmap` kupita kwenye bakuli zilizo tupu.
3. `victim` inaelekezwa kwenye 'MKIA' ya bakuli la sasa.
4. Kutumia ramani ya bakuli kuhakikisha kuwa ikiwa bakuli imepita (katika hatua ya 2 hapo juu), bila shaka ni tupu. Walakini, haitahakikishi kuwa bakuli zote tupu zitapuuzwa. Angalia ikiwa `victim` ni tupu au la. Ikiwa tupu, rudia kupita kwenye bakuli na kurudia mchakato huu (au 'endelea' mzunguko huu) hadi tutakapofika kwenye bakuli lisilo tupu.
5. Gawa kipande (`victim` inaelekeza kipande cha mwisho cha bakuli lisilo tupu) katika vipande viwili. Ingiza kipande kilichobaki kwenye bakuli lisilopangwa (mwisho wa 'MKIA'). Kunaangalia kwenye bakuli lisilopangwa ikiwa `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Kosa hutupwa vinginevyo ("malloc(): corrupted unsorted chunks 2").
6. Rudisha kipande cha `victim` baada ya kuita `alloc_perturb`.
9. Ikiwa bado hakuna bakuli tupu iliyopatikana, kipande cha 'juu' kitatumika kuhudumia ombi:
1. `victim` inaelekeza `av->juu`.
2. Ikiwa ukubwa wa kipande cha 'juu' >= 'ukubwa ulioombwa' + `MINSIZE`, gawa katika vipande viwili. Katika kesi hii, kipande kilichobaki kinakuwa kipande kipya cha 'juu' na kipande kingine kurudishwa kwa mtumiaji baada ya kuita `alloc_perturb`.
3. Angalia ikiwa `av` ina fastchunks au la. Hii inafanywa kwa kuangalia `FASTCHUNKS_BIT` katika `av->flags`. Ikiwa ndivyo, ita `malloc_consolidate` kwenye `av`. Rudia hatua ya 6 (ambapo tunachunguza bakuli lisilopangwa).
4. Ikiwa `av` haina fastchunks, ita `sysmalloc` na rudisha kipande kilichopatikana baada ya kuita `alloc_perturb`.
## Mtiririko wa Bure

{% hint style="success" %}
(Maelezo haya ya sasa yanatoka kwa [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Angalia toleo la mwisho na ulishe)
{% endhint %}

Kazi ya mwisho ya kufuta vipande vya kumbukumbu ni `_int_free (mstate av, mchunkptr p, int have_lock)` :

1. Angalia ikiwa `p` iko kabla ya `p + chunksize(p)` kwenye kumbukumbu (ili kuepuka kurudia). Kosa (`free(): invalid pointer`) hutupwa vinginevyo.
2. Angalia ikiwa kipande kina ukubwa wa angalau `MINSIZE` au ni maradufu ya `MALLOC_ALIGNMENT`. Kosa (`free(): invalid size`) hutupwa vinginevyo.
3. Ikiwa ukubwa wa kipande uko kwenye orodha ya fastbin:
1. Angalia ikiwa ukubwa wa kipande kinachofuata uko kati ya ukubwa wa chini na wa juu (`av->system_mem`), kutupa kosa (`free(): invalid next size (fast)`) vinginevyo.
2. Piga simu kwa `free_perturb` kwenye kipande.
3. Weka `FASTCHUNKS_BIT` kwa `av`.
4. Pata indeksi kwenye safu ya fastbin kulingana na ukubwa wa kipande.
5. Angalia ikiwa juu ya beni sio kipande tunachotaka kuongeza. Vinginevyo, kutupa kosa (`double free or corruption (fasttop)`).
6. Angalia ikiwa ukubwa wa kipande cha fastbin juu ni sawa na kipande tunachoongeza. Vinginevyo, kutupa kosa (`invalid fastbin entry (free)`).
7. Ingiza kipande juu ya orodha ya fastbin na rudi.
4. Ikiwa kipande sio mmapped:
1. Angalia ikiwa kipande ni kipande cha juu au la. Ikiwa ndio, kosa (`double free or corruption (top)`) hutupwa.
2. Angalia ikiwa kipande kinachofuata (kwa kumbukumbu) kipo ndani ya mipaka ya uwanja. Ikiwa sivyo, kosa (`double free or corruption (out)`) hutupwa.
3. Angalia ikiwa biti ya kutumika kabla ya kipande kinachofuata (kwa kumbukumbu) imehakikishwa au la. Ikiwa sivyo, kosa (`double free or corruption (!prev)`) hutupwa.
4. Angalia ikiwa ukubwa wa kipande kinachofuata uko kati ya ukubwa wa chini na wa juu (`av->system_mem`). Ikiwa sivyo, kosa (`free(): invalid next size (normal)`) hutupwa.
5. Piga simu kwa `free_perturb` kwenye kipande.
6. Ikiwa kipande cha awali (kwa kumbukumbu) hakijatumika, piga simu kwa `unlink` kwenye kipande cha awali.
7. Ikiwa kipande kinachofuata (kwa kumbukumbu) sio kipande cha juu:
1. Ikiwa kipande kinachofuata hakijatumika, piga simu kwa `unlink` kwenye kipande kinachofuata.
2. Unganisha kipande na cha awali, kinachofuata (kwa kumbukumbu), ikiwa kipo huru na kiweke kwenye kichwa cha beni isiyopangwa. Kabla ya kuingiza, angalia ikiwa `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` au la. Ikiwa sivyo, kosa ("free(): corrupted unsorted chunks") hutupwa.
8. Ikiwa kipande kinachofuata (kwa kumbukumbu) kilikuwa kipande cha juu, unganisha vipande kwa usahihi kuwa kipande kimoja cha juu.
5. Ikiwa kipande kilikuwa mmapped, piga simu kwa `munmap_chunk`.

## Angalia Uthibitisho wa Usalama wa Kazi za Beni

Angalia uthibitisho wa usalama uliofanywa na kazi zinazotumiwa sana kwenye beni katika:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Marejeo

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
