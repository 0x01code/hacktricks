# Bins & Aloakcije memorije

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Kako bi se pobolj≈°ala efikasnost ƒçuvanja delova, svaki deo nije sme≈°ten samo u jednoj povezanoj listi, veƒá postoje razliƒçite vrste. To su binovi i postoji 5 vrsta binova: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) mali binovi, 63 velika binova, 1 nesortirani bin, 10 brzih binova i 64 tcache binova po niti.

Poƒçetna adresa za svaki nesortirani, mali i veliki bin je unutar istog niza. Indeks 0 nije kori≈°ƒáen, 1 je nesortirani bin, binovi 2-64 su mali binovi, a binovi 65-127 su veliki binovi.

### Mali binovi

Mali binovi su br≈æi od velikih binova, ali sporiji od brzih binova.

Svaki bin od 62 ƒáe imati **delove iste veliƒçine**: 16, 24, ... (sa maksimalnom veliƒçinom od 504 bajta u 32-bitnom i 1024 u 64-bitnom re≈æimu). Ovo poma≈æe u brzini pronala≈æenja binova gde treba alocirati prostor i ubacivanju i uklanjanju unosa sa ovih listi.

### Veliki binovi

Za razliku od malih binova, koji upravljaju delovima fiksnih veliƒçina, svaki **veliki bin upravlja opsegom veliƒçina delova**. Ovo je fleksibilnije, omoguƒáavajuƒái sistemu da se prilagodi **razliƒçitim veliƒçinama** bez potrebe za posebnim binom za svaku veliƒçinu.

U alokatoru memorije, veliki binovi poƒçinju tamo gde se zavr≈°avaju mali binovi. Opsezi za velike binove postaju sve veƒái, ≈°to znaƒçi da prvi bin mo≈æe obuhvatiti delove od 512 do 576 bajtova, dok sledeƒái obuhvata 576 do 640 bajtova. Ovaj obrazac se nastavlja, pri ƒçemu najveƒái bin sadr≈æi sve delove iznad 1MB.

Veliki binovi su sporiji za rad u poreƒëenju sa malim binovima jer moraju **sortirati i pretra≈æivati listu delova razliƒçitih veliƒçina kako bi prona≈°li najbolje odgovarajuƒái** za alokaciju. Kada se deo ubaci u veliki bin, mora biti sortiran, a prilikom alokacije memorije, sistem mora pronaƒái odgovarajuƒái deo. Ovaj dodatni rad ih ƒçini **sporijim**, ali buduƒái da su velike alokacije manje uobiƒçajene od malih, to je prihvatljiva trgovina.

Postoje:

* 32 binova opsega 64B
* 16 binova opsega 512B
* 8 binova opsega 4096B
* 4 binova opsega 32768B
* 2 binova opsega 262144B
* 1 bin za preostale veliƒçine

### Nesortirani bin

Nesortirani bin je **brza ke≈° memorija** koju koristi menad≈æer hipa kako bi ubrzao alokaciju memorije. Evo kako funkcioni≈°e: Kada program oslobodi memoriju, menad≈æer hipa je ne stavlja odmah u odreƒëeni bin. Umesto toga, prvo poku≈°ava **da je spoji sa bilo kojim susednim slobodnim delovima** kako bi stvorio veƒái blok slobodne memorije. Zatim, sme≈°ta ovaj novi deo u op≈°ti bin nazvan "nesortirani bin".

Kada program **zatra≈æi memoriju**, menad≈æer hipa **proverava nesortirani bin** da vidi da li postoji deo dovoljne veliƒçine. Ako pronaƒëe jedan, odmah ga koristi. Ako ne pronaƒëe odgovarajuƒái deo, premesti osloboƒëene delove u njihove odgovarajuƒáe binove, bilo male ili velike, na osnovu njihove veliƒçine.

Dakle, nesortirani bin je naƒçin da se ubrza alokacija memorije brzim ponovnim kori≈°ƒáenjem nedavno osloboƒëene memorije i smanjenjem potrebe za vremenski zahtevnim pretragama i spajanjima.

{% hint style="danger" %}
Imajte na umu da ƒçak i ako su delovi razliƒçitih kategorija, ako dostupan deo kolidira sa drugim dostupnim delom (ƒçak i ako su razliƒçitih kategorija), biƒáe spojeni.
{% endhint %}

### Brzi binovi

Brzi binovi su dizajnirani da **ubrzaju alokaciju memorije za male delove** ƒçuvanjem nedavno osloboƒëenih delova u strukturi brzog pristupa. Ovi binovi koriste pristup poslednji unutra, prvi napolje (LIFO), ≈°to znaƒçi da je **najskorije osloboƒëeni deo prvi** koji ƒáe biti ponovo kori≈°ƒáen kada postoji nova zahtev za alokacijom. Ovo pona≈°anje je korisno za brzinu, jer je br≈æe ubaciti i ukloniti sa vrha steka (LIFO) u poreƒëenju sa redom (FIFO).

Dodatno, **brzi binovi koriste jednostruko povezane liste**, a ne dvostruko povezane, ≈°to dodatno pobolj≈°ava brzinu. Buduƒái da se delovi u brzim binovima ne spajaju sa susedima, nema potrebe za slo≈æenom strukturom koja omoguƒáava uklanjanje iz sredine. Jednostruko povezana lista je jednostavnija i br≈æa za ove operacije.

U osnovi, ovde se de≈°ava da je zaglavlje (pokazivaƒç na prvi deo koji treba proveriti) uvek usmereno na najskorije osloboƒëeni deo te veliƒçine. Dakle:

* Kada se alocira novi deo te veliƒçine, zaglavlje pokazuje na slobodan deo za kori≈°ƒáenje. Po≈°to ovaj slobodan deo pokazuje na sledeƒái deo za kori≈°ƒáenje, ova adresa je saƒçuvana u zaglavlju tako da sledeƒáa alokacija zna gde da dobije dostupan deo
* Kada se deo oslobodi, slobodan deo ƒáe saƒçuvati adresu trenutno dostupnog dela i adresa ovog novootvorenog dela ƒáe biti sme≈°tena u zaglavlje

{% hint style="danger" %}
Delovi u brzim binovima nisu automatski postavljeni kao dostupni tako da se zadr≈æavaju kao delovi brzih binova neko vreme umesto da mogu da se spoje sa drugim delovima.
{% endhint %}

### Tcache (Tcache po niti)

Iako niti poku≈°avaju da imaju svoj sopstveni hip (videti [Arenas](bins-and-memory-allocations.md#arenas) i [Pod-hipovi](bins-and-memory-allocations.md#subheaps)), postoji moguƒánost da ƒáe proces sa puno niti (kao ≈°to je veb server) **zavr≈°iti deljenjem hipa sa drugim nitima**. U ovom sluƒçaju, glavno re≈°enje je kori≈°ƒáenje **brava**, koje mogu **znatno usporiti niti**.

Stoga, tcache je sliƒçan brzom binu po niti na naƒçin da je **jednostruko povezana lista** koja ne spaja delove. Svaka nit ima **64 jednostruko povezana tcache bina**. Svaki bin mo≈æe imati maksimum [7 delova iste veliƒçine](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) u opsegu od [24 do 1032B na 64-bitnim sistemima i od 12 do 516B na 32-bitnim sistemima](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

Kada jedna nit oslobodi deo, **ako nije prevelik** da bi bio alociran u tcache i odgovarajuƒái tcache bin **nije pun** (veƒá 7 delova), **biƒáe alociran tamo**. Ako ne mo≈æe da ide u tcache, moraƒáe da saƒçeka da se hip zakljuƒça kako bi mogao da izvr≈°i globalnu operaciju oslobaƒëanja.

Kada se **deo alocira**, ako postoji slobodan deo potrebne veliƒçine u **Tcache-u, koristiƒáe ga**, ako ne, moraƒáe da saƒçeka da se hip zakljuƒça kako bi prona≈°ao jedan u globalnim binovima ili kreirao novi.\
Postoji i optimizacija, u ovom sluƒçaju, dok ima hip zakljuƒçan, nit **ƒáe popuniti svoj Tcache hip delovima (7) tra≈æene veliƒçine**, tako da ako zatreba vi≈°e, moƒái ƒáe da ih pronaƒëe u Tcache-u.
## Tok dodele

{% hint style="success" %}
(Ovo trenutno obja≈°njenje je sa [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Proveri poslednju verziju i a≈æuriraj je)
{% endhint %}

Dodele se konaƒçno vr≈°e funkcijom: `void * _int_malloc (mstate av, size_t bytes)` i slede ovaj redosled:

1. A≈æurira `bytes` da se pobrine za **poravnanja**, itd.
2. Proverava da li je `av` **NULL** ili nije.
3. U sluƒçaju odsustva **upotrebljive arene** (kada je `av` NULL), poziva `sysmalloc` da dobije blok koristeƒái mmap. Ako je uspe≈°no, poziva `alloc_perturb`. Vraƒáa pokazivaƒç.
4. Zavisno od veliƒçine:
* \[Dodatak originalu] Koristi tcache pre provere sledeƒáeg fastbin-a.
* \[Dodatak originalu] Ako nema tcache-a veƒá se koristi drugi bin (vidi kasniji korak), poku≈°ajte da popunite tcache iz tog bina.
* Ako veliƒçina spada u opseg **fastbin-a**:
1. Dobija indeks u nizu fastbin-a da pristupi odgovarajuƒáem binu prema veliƒçini zahteva.
2. Uklanja prvi blok iz tog bina i ƒçini da `victim` na njega pokazuje.
3. Ako je `victim` NULL, prelazi na sledeƒái sluƒçaj (smallbin).
4. Ako `victim` nije NULL, proverava veliƒçinu bloka da bi se osiguralo da pripada tom odreƒëenom binu. Inaƒçe se baca gre≈°ka ("malloc(): memory corruption (fast)").
5. Poziva `alloc_perturb` i zatim vraƒáa pokazivaƒç.
* Ako veliƒçina spada u opseg **smallbin-a**:
1. Dobija indeks u nizu smallbin-a da pristupi odgovarajuƒáem binu prema veliƒçini zahteva.
2. Ako nema blokova u ovom binu, prelazi na sledeƒái sluƒçaj. Ovo se proverava poreƒëenjem pokazivaƒça `bin` i `bin->bk`.
3. `victim` postaje jednak `bin->bk` (poslednji blok u binu). Ako je NULL (de≈°ava se tokom `inicijalizacije`), poziva `malloc_consolidate` i preskaƒçe ovaj kompletan korak provere u razliƒçitim binovima.
4. Inaƒçe, kada je `victim` ne NULL, proverava da li su `victim->bk->fd` i `victim` jednaki ili ne. Ako nisu jednaki, baca se gre≈°ka (`malloc(): smallbin double linked list corrupted`).
5. Postavlja bit PREV\_INSUSE za sledeƒái blok (u memoriji, ne u dvostrukom povezanom listu) za `victim`.
6. Uklanja ovaj blok iz liste binova.
7. Postavlja odgovarajuƒái bit arene za ovaj blok u zavisnosti od `av`.
8. Poziva `alloc_perturb` i zatim vraƒáa pokazivaƒç.
* Ako veliƒçina ne spada u opseg smallbin-a:
1. Dobija indeks u nizu largebin-a da pristupi odgovarajuƒáem binu prema veliƒçini zahteva.
2. Vidi da li `av` ima brze blokove ili ne. Ovo se radi proverom `FASTCHUNKS_BIT` u `av->flags`. Ako da, poziva `malloc_consolidate` na `av`.
5. Ako jo≈° uvek nije vraƒáen pokazivaƒç, to oznaƒçava jedan ili vi≈°e sledeƒáih sluƒçajeva:
1. Veliƒçina spada u opseg 'fastbin-a' ali nema dostupnih brzih blokova.
2. Veliƒçina spada u opseg 'smallbin-a' ali nema dostupnih malih blokova (poziva `malloc_consolidate` tokom inicijalizacije).
3. Veliƒçina spada u opseg 'largebin-a'.
6. Zatim se proveravaju **nesortirani blokovi** i pretra≈æeni blokovi se sme≈°taju u binove. Ovo je jedino mesto gde se blokovi sme≈°taju u binove. Iterira se nesortirani bin od 'TAIL'.
1. `victim` pokazuje na trenutni blok koji se razmatra.
2. Proverava da li je veliƒçina bloka `victim` unutar minimalnog (`2*SIZE_SZ`) i maksimalnog (`av->system_mem`) opsega. Inaƒçe se baca gre≈°ka (`malloc(): memory corruption`).
3. Ako (veliƒçina tra≈æenog bloka spada u opseg smallbin-a) i (`victim` je poslednji preostali blok) i (to je jedini blok u nesortiranom binu) i (veliƒçina blokova >= tra≈æena): **Podeli blok na 2 bloka**:
* Prvi blok odgovara tra≈æenoj veliƒçini i vraƒáa se.
* Preostali blok postaje novi poslednji preostali blok. Ubacuje se nazad u nesortirani bin.
1. Postavlja `chunk_size` i `chunk_prev_size` polja na odgovarajuƒái naƒçin za oba bloka.
2. Prvi blok se vraƒáa nakon poziva `alloc_perturb`.
3. Ako je gornji uslov netaƒçan, kontrola dolazi ovde. Uklanja `victim` iz nesortiranog bin. Ako veliƒçina `victim` odgovara taƒçno tra≈æenoj veliƒçini, vrati ovaj blok nakon poziva `alloc_perturb`.
4. Ako veliƒçina `victim` spada u opseg smallbin-a, dodaj blok u odgovarajuƒái smallbin na `HEAD`.
5. Inaƒçe ubaci u odgovarajuƒái largebin odr≈æavajuƒái sortiran redosled:
6. Prvo proverava poslednji blok (najmanji). Ako je `victim` manji od poslednjeg bloka, ubaci ga na poslednje mesto.
7. Inaƒçe, petlja da pronaƒëe blok sa veliƒçinom >= veliƒçini `victim`. Ako je veliƒçina taƒçno ista, uvek ubaci na drugo mesto.
8. Ponovi ovaj korak maksimalno `MAX_ITERS` (10000) puta ili dok se svi blokovi u nesortiranom binu ne iscrpe.
7. Nakon provere nesortiranih blokova, proveri da li tra≈æena veliƒçina ne spada u opseg smallbin-a, ako da, onda proveri **largebin-ove**.
1. Dobija indeks u nizu largebin-a da pristupi odgovarajuƒáem binu prema veliƒçini zahteva.
2. Ako je veliƒçina najveƒáeg bloka (prvi blok u binu) veƒáa od tra≈æene veliƒçine:
1. Iterira od 'TAIL' da pronaƒëe blok (`victim`) sa najmanjom veliƒçinom >= tra≈æene veliƒçine.
2. Poziva `unlink` da ukloni blok `victim` iz bina.
3. Izraƒçunava `remainder_size` za blok `victim` (ovo ƒáe biti veliƒçina bloka `victim` - tra≈æena veliƒçina).
4. Ako je ovaj `remainder_size` >= `MINSIZE` (minimalna veliƒçina bloka ukljuƒçujuƒái zaglavlja), podeli blok na dva bloka. Inaƒçe, ceo blok `victim` ƒáe biti vraƒáen. Ubaci preostali blok u nesortirani bin (na 'TAIL' kraju). Vr≈°i se provera u nesortiranom binu da li `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Inaƒçe se baca gre≈°ka ("malloc(): corrupted unsorted chunks").
5. Vrati blok `victim` nakon poziva `alloc_perturb`.
8. Do sada smo proverili nesortirani bin i takoƒëe odgovarajuƒái fast, small ili large bin. Napomena da je jedan bin (brzi ili mali) proveren koristeƒái **taƒçno** veliƒçinu tra≈æenog bloka. Ponavljajte sledeƒáe korake dok se svi binovi ne iscrpe:
1. Indeks u nizu binova se poveƒáava da bi se proverio sledeƒái bin.
2. Koristi `av->binmap` mapu da preskoƒçi prazne binove.
3. `victim` pokazuje na 'TAIL' trenutnog bina.
4. Kori≈°ƒáenjem binmapa osigurava se da ako je bin preskoƒçen (u prethodnom 2. koraku), definitivno je prazan. Meƒëutim, ne garantuje da ƒáe svi prazni binovi biti preskoƒçeni. Proveri da li je `victim` prazan ili ne. Ako je prazan, ponovo preskoƒçi bin i ponovi gore navedeni proces (ili 'nastavi' ovu petlju) dok ne stignemo do nepopunjenog bina.
5. Podeli blok (`victim` pokazuje na poslednji blok nepopunjenog bina) na dva bloka. Ubaci preostali blok u nesortirani bin (na 'TAIL' kraju). Vr≈°i se provera u nesortiranom binu da li `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Inaƒçe se baca gre≈°ka ("malloc(): corrupted unsorted chunks 2").
6. Vrati blok `victim` nakon poziva `alloc_perturb`.
9. Ako jo≈° uvek nije pronaƒëen prazan bin, 'top' blok ƒáe se koristiti za obradu zahteva:
1. `victim` pokazuje na `av->top`.
2. Ako je veliƒçina 'top' bloka >= 'tra≈æena veliƒçina' + `MINSIZE`, podeli ga na dva bloka. U ovom sluƒçaju, preostali blok postaje novi 'top' blok i drugi blok se vraƒáa korisniku nakon poziva `alloc_perturb`.
3. Vidi da li `av` ima brze blokove ili ne. Ovo se radi proverom `FASTCHUNKS_BIT` u `av->flags`. Ako da, poziva `malloc_consolidate` na `av`. Vrati se na korak 6 (gde proveravamo nesortirani bin).
4. Ako `av` nema brze blokove, poziva `sysmalloc` i vraƒáa dobijeni pokazivaƒç nakon poziva `alloc_perturb`.
## Slobodan protok

{% hint style="success" %}
(Ovo trenutno obja≈°njenje je sa [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: Proverite poslednju verziju i a≈æurirajte je)
{% endhint %}

Konaƒçna funkcija oslobaƒëanja delova memorije je `_int_free (mstate av, mchunkptr p, int have_lock)`:

1. Proverava da li je `p` pre `p + chunksize(p)` u memoriji (kako bi se izbeglo prelamanje). U suprotnom se baca gre≈°ka (`free(): invalid pointer`).
2. Proverava da li je veliƒçina bloka barem `MINSIZE` ili vi≈°ekratnik `MALLOC_ALIGNMENT`. U suprotnom se baca gre≈°ka (`free(): invalid size`).
3. Ako veliƒçina bloka spada u listu fastbin:
1. Proverava da li je veliƒçina sledeƒáeg bloka izmeƒëu minimalne i maksimalne veliƒçine (`av->system_mem`), inaƒçe se baca gre≈°ka (`free(): invalid next size (fast)`).
2. Poziva `free_perturb` na bloku.
3. Postavlja `FASTCHUNKS_BIT` za `av`.
4. Dobija indeks u nizu fastbin prema veliƒçini bloka.
5. Proverava da li vrh bin-a nije blok koji dodajemo. U suprotnom, baca se gre≈°ka (`double free or corruption (fasttop)`).
6. Proverava da li je veliƒçina bloka u fastbin-u na vrhu ista kao veliƒçina bloka koji dodajemo. U suprotnom, baca se gre≈°ka (`invalid fastbin entry (free)`).
7. Ubacuje blok na vrh liste fastbin-a i vraƒáa.
4. Ako blok nije mapiran:
1. Proverava da li je blok vrhunski blok ili ne. Ako jeste, baca se gre≈°ka (`double free or corruption (top)`).
2. Proverava da li je sledeƒái blok (po memoriji) unutar granica arene. Ako nije, baca se gre≈°ka (`double free or corruption (out)`).
3. Proverava da li je prethodni bit sledeƒáeg bloka (po memoriji) oznaƒçen kao u upotrebi ili ne. Ako nije, baca se gre≈°ka (`double free or corruption (!prev)`).
4. Proverava da li je veliƒçina sledeƒáeg bloka izmeƒëu minimalne i maksimalne veliƒçine (`av->system_mem`). Ako nije, baca se gre≈°ka (`free(): invalid next size (normal)`).
5. Poziva `free_perturb` na bloku.
6. Ako prethodni blok (po memoriji) nije u upotrebi, poziva `unlink` na prethodnom bloku.
7. Ako sledeƒái blok (po memoriji) nije vrhunski blok:
1. Ako sledeƒái blok nije u upotrebi, poziva `unlink` na sledeƒáem bloku.
2. Spaja blok sa prethodnim, sledeƒáim (po memoriji), ako je bilo slobodno i dodaje ga na poƒçetak nesortiranog bin-a. Pre ubacivanja, proverava da li `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ili ne. Ako nije, baca se gre≈°ka ("free(): corrupted unsorted chunks").
8. Ako je sledeƒái blok (po memoriji) bio vrhunski blok, spaja blokove na odgovarajuƒái naƒçin u jedan vrhunski blok.
5. Ako je blok bio mapiran, poziva `munmap_chunk`.

## Provere bezbednosti funkcija heap-a

Proverite provere bezbednosti koje vr≈°e ƒçesto kori≈°ƒáene funkcije u heap-u u:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Reference

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
