# Bins & 内存分配

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的**公司在 HackTricks 中做广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFT**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** 上关注**我们。
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## 基本信息

为了提高块存储的效率，每个块不仅仅在一个链接列表中，而是有几种类型。这些是 bins，有 5 种类型的 bins：[62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) 小型 bins，63 大型 bins，1 未排序 bin，10 快速 bins 和每个线程 64 个 tcache bins。

每个未排序、小型和大型 bins 的初始地址都在同一个数组内。索引 0 未使用，1 是未排序 bin，bins 2-64 是小型 bins，bins 65-127 是大型 bins。

### 小型 Bins

小型 bins 比大型 bins 更快，但比快速 bins 更慢。

62 个 bins 中的每个 bin 将具有**相同大小的块**：16、24、...（在 32 位系统中最大大小为 504 字节，在 64 位系统中为 1024 字节）。这有助于加快查找应分配空间的 bin、插入和删除这些列表中的条目的速度。

### 大型 Bins

与管理固定大小块的小型 bins 不同，每个**大型 bin 处理一系列块大小**。这更加灵活，允许系统**容纳各种大小**而无需为每个大小单独设置 bin。

在内存分配器中，大型 bins 从小型 bins 结束的地方开始。大型 bins 的范围逐渐变大，意味着第一个 bin 可能覆盖从 512 到 576 字节的块，而下一个覆盖从 576 到 640 字节的块。这种模式继续下去，最大的 bin 包含所有大于 1MB 的块。

与小型 bins 相比，大型 bins 操作速度较慢，因为它们必须**对包含不同块大小的列表进行排序和搜索**，以找到最佳匹配的分配。当将块插入大型 bin 时，必须对其进行排序，当分配内存时，系统必须找到正确的块。这额外的工作使它们**更慢**，但由于大型分配比小型分配更少见，这是一个可以接受的折衷。

有：

* 32 个 64B 范围的 bins
* 16 个 512B 范围的 bins
* 8 个 4096B 范围的 bins
* 4 个 32768B 范围的 bins
* 2 个 262144B 范围的 bins
* 1 个用于剩余大小的 bins

### 未排序 Bin

未排序 bin 是堆管理器用于加快内存分配的**快速缓存**。它的工作原理是：当程序释放内存时，堆管理器不会立即将其放入特定的 bin 中。相反，它首先尝试**将其与任何相邻的空闲块合并**，以创建一个更大的空闲内存块。然后，它将这个新块放入一个称为“未排序 bin”的通用 bin 中。

当程序**请求内存**时，堆管理器**检查未排序 bin**，看看是否有足够大小的块。如果找到一个，它立即使用。如果找不到合适的块，它将释放的块移动到其相应的 bins 中，无论是小型还是大型，基于它们的大小。

因此，未排序 bin 是通过快速重用最近释放的内存来加速内存分配，并减少耗时的搜索和合并的需求。

{% hint style="danger" %}
请注意，即使块属于不同的类别，如果一个可用块与另一个可用块发生冲突（即使它们属于不同的类别），它们将被合并。
{% endhint %}

### 快速 Bins

快速 bins 旨在通过将最近释放的块保留在快速访问结构中来**加速小块的内存分配**。这些 bins 使用后进先出（LIFO）方法，这意味着**最近释放的块是**在有新的分配请求时**首先被重用**。这种行为对速度有利，因为与队列（FIFO）相比，从栈顶（LIFO）插入和删除更快。

此外，**快速 bins 使用单链表**，而不是双链表，这进一步提高了速度。由于快速 bins 中的块不会与相邻块合并，因此不需要允许从中间删除的复杂结构。单链表对于这些操作更简单、更快。

基本上，这里发生的是，头部（指向要检查的第一个块的指针）始终指向该大小的最新释放块。因此：

* 当分配该大小的新块时，头部指向一个可用的空闲块以供使用。由于此空闲块指向下一个要使用的块，因此将此地址存储在头部中，以便下一个分配知道从哪里获取可用块
* 当释放块时，空闲块将保存当前可用块的地址，并将这个新释放块的地址放入头部

{% hint style="danger" %}
快速 bins 中的块不会自动设置为可用，因此它们会保持一段时间作为快速 bin 块，而不是能够与其他块合并。
{% endhint %}

### Tcache（每线程缓存）Bins

尽管线程尝试拥有自己的堆（参见[竞技场](bins-and-memory-allocations.md#arenas)和[子堆](bins-and-memory-allocations.md#subheaps)），但存在一个可能性，即具有大量线程的进程（如 Web 服务器）**最终会与其他线程共享堆**。在这种情况下，主要解决方案是使用**锁**，这可能**显著减慢线程**。

因此，tcache 类似于每个线程的快速 bin，因为它是一个**单链表**，不合并块。每个线程有**64 个单链式 tcache bins**。每个 bin 可以拥有最多[7 个相同大小的块](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323)，范围从[24 到 1032B（64 位系统）和 12 到 516B（32 位系统）](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315)。

当一个线程**释放**一个块时，**如果它不太大**以至于无法在 tcache 中分配，并且相应的 tcache bin **不满**（已有 7 个块），**它将被分配到那里**。如果无法进入 tcache，它将需要等待堆锁以能够在全局 bins 中执行释放操作。

当**分配块**时，如果在**Tcache 中有所需大小的空闲块，它将使用它**，否则，它将需要等待堆锁以能够在全局 bins 中找到一个或创建一个新的。\
还有一个优化，在这种情况下，持有堆锁时，线程**将用请求大小的堆块（7 个）填充其 Tcache**，因此如果需要更多，它将在 Tcache 中找到它们。
## 分配流程

{% hint style="success" %}
(此当前解释来自[https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: 检查最新版本并更新)
{% endhint %}

分配最终通过函数执行：`void * _int_malloc (mstate av, size_t bytes)`，并按照以下顺序进行：

1. 更新 `bytes` 以处理**对齐**等问题。
2. 检查 `av` 是否为**NULL**。
3. 在**可用的区域**缺失的情况下（当 `av` 为 NULL 时），调用 `sysmalloc` 使用 mmap 获取块。如果成功，调用 `alloc_perturb`。返回指针。
4. 根据大小不同：
* \[原文添加] 在检查下一个 fastbin 之前使用 tcache。
* \[原文添加] 如果没有 tcache 但使用了不同的 bin（见后续步骤），尝试从该 bin 填充 tcache。
* 如果大小在**fastbin**范围内：
1. 获取索引以访问适当的 bin 中的第一个块。
2. 移除该 bin 中的第一个块，并使 `victim` 指向它。
3. 如果 `victim` 为 NULL，则转到下一个情况（smallbin）。
4. 如果 `victim` 不为 NULL，则检查块的大小以确保它属于该特定 bin。否则会抛出错误（"malloc(): memory corruption (fast)"）。
5. 调用 `alloc_perturb`，然后返回指针。
* 如果大小在**smallbin**范围内：
1. 获取索引以访问适当的 bin 中的第一个块。
2. 如果该 bin 中没有块，则转到下一个情况。通过比较指针 `bin` 和 `bin->bk` 来检查。
3. 使 `victim` 等于 `bin->bk`（该 bin 中的最后一个块）。如果它为 NULL（在 `初始化` 期间发生），则调用 `malloc_consolidate` 并跳过检查不同 bin 的完整步骤。
4. 否则，当 `victim` 不为 NULL 时，检查 `victim->bk->fd` 和 `victim` 是否相等。如果它们不相等，则抛出错误（"malloc(): smallbin double linked list corrupted"）。
5. 为下一个块（在内存中，而不是在双向链表中）设置 PREV\_INSUSE 位。
6. 从 bin 列表中移除此块。
7. 根据 `av` 设置此块的适当区域位。
8. 调用 `alloc_perturb`，然后返回指针。
* 如果大小不在 smallbin 范围内：
1. 获取索引以访问适当的 bin 中的第一个块。
2. 查看 `av` 是否有 fastchunks。通过检查 `av->flags` 中的 `FASTCHUNKS_BIT` 来完成。如果是，则在 `av` 上调用 `malloc_consolidate`。
5. 如果尚未返回指针，则表示以下一种或多种情况：
1. 大小在 'fastbin' 范围内，但没有可用的 fastchunk。
2. 大小在 'smallbin' 范围内，但没有可用的 smallchunk（在初始化期间调用 `malloc_consolidate`）。
3. 大小在 'largbin' 范围内。
6. 接下来，检查**未排序的块**，并将遍历的块放入 bin 中。这是唯一将块放入 bin 中的地方。从 'TAIL' 迭代未排序的 bin。
1. `victim` 指向当前考虑的块。
2. 检查 `victim` 的块大小是否在最小值（`2*SIZE_SZ`）和最大值（`av->system_mem`）范围内。否则抛出错误（"malloc(): memory corruption"）。
3. 如果（请求的块大小在 smallbin 范围内）且（`victim` 是最后的剩余块）且（它是未排序 bin 中的唯一块）且（块大小 >= 请求的大小）：**将块分成 2 个块**：
* 第一个块匹配请求的大小并返回。
* 剩余块成为新的最后剩余块。将其插入未排序的 bin 中。
1. 适当设置这两个块的 `chunk_size` 和 `chunk_prev_size` 字段。
2. 在调用 `alloc_perturb` 后返回第一个块。
3. 如果上述条件为假，则控制到此处。从未排序的 bin 中移除 `victim`。如果 `victim` 的大小与请求的大小完全匹配，则在调用 `alloc_perturb` 后返回此块。
4. 如果 `victim` 的大小在 smallbin 范围内，则将块添加到适当的 smallbin 中的 `HEAD`。
5. 否则，插入到适当的 largebin 中并保持排序顺序：
6. 首先检查最后一个块（最小的）。如果 `victim` 小于最后一个块，则将其插入到最后。
7. 否则，循环查找大小 >= `victim` 大小的块。如果大小完全相同，则始终插入到第二个位置。
8. 最多重复此整个步骤 `MAX_ITERS`（10000 次）或直到未排序 bin 中的所有块用尽。
7. 检查未排序块后，检查请求的大小是否不在 smallbin 范围内，如果是，则检查**largebins**。
1. 获取索引以访问适当的 bin 中的第一个块。
2. 如果最大块的大小（bin 中的第一个块）大于请求的大小：
1. 从 'TAIL' 开始迭代以找到一个大小 >= 请求大小的块（`victim`）。
2. 调用 `unlink` 以从 bin 中移除 `victim` 块。
3. 为 `victim` 的块计算 `remainder_size`（这将是 `victim` 的块大小 - 请求的大小）。
4. 如果此 `remainder_size` >= `MINSIZE`（包括头部的最小块大小），则将块分成两个块。否则，整个 `victim` 块将被返回。将剩余块插入未排序的 bin 中（在 'TAIL' 末尾）。在未排序的 bin 中检查是否 `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`。否则抛出错误（"malloc(): corrupted unsorted chunks"）。
5. 在调用 `alloc_perturb` 后返回 `victim` 块。
8. 到目前为止，我们已经检查了未排序 bin 以及相应的 fast、small 或 large bin。请注意，使用**确切**请求块大小检查了单个 bin（fast 或 small）。重复以下步骤直到所有 bin 被用尽：
1. 递增 bin 数组的索引以检查下一个 bin。
2. 使用 `av->binmap` 映射跳过空的 bin。
3. `victim` 指向当前 bin 的 'TAIL'。
4. 使用 binmap 确保如果跳过了一个 bin（在上述第 2 步中），则它肯定是空的。但这并不保证所有空的 bin 都会被跳过。检查 victim 是否为空。如果为空，则再次跳过该 bin 并重复上述过程（或“继续”此循环），直到到达非空 bin。
5. 将块分割为两个块（`victim` 指向非空 bin 的最后一个块）。将剩余块插入未排序的 bin 中（在 'TAIL' 末尾）。在未排序的 bin 中检查是否 `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`。否则抛出错误（"malloc(): corrupted unsorted chunks 2"）。
6. 在调用 `alloc_perturb` 后返回 `victim` 块。
9. 如果仍未找到空的 bin，则将使用 'top' 块来处理请求：
1. `victim` 指向 `av->top`。
2. 如果 'top' 块的大小 >= '请求的大小' + `MINSIZE`，则将其分成两个块。在这种情况下，剩余块成为新的 'top' 块，并在调用 `alloc_perturb` 后将另一个块返回给用户。
3. 查看 `av` 是否有 fastchunks。通过检查 `av->flags` 中的 `FASTCHUNKS_BIT` 来完成。如果是，则在 `av` 上调用 `malloc_consolidate`。返回到步骤 6（检查未排序 bin）。
4. 如果 `av` 没有 fastchunks，则调用 `sysmalloc` 并在调用 `alloc_perturb` 后返回获得的指针。
## 自由流动

{% hint style="success" %}
(此当前解释来自[https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions). TODO: 检查最新版本并更新)
{% endhint %}

释放内存块的最终函数是 `_int_free (mstate av, mchunkptr p, int have_lock)`：

1. 检查 `p` 是否在内存中的 `p + chunksize(p)` 之前（避免包装）。否则会抛出错误 (`free(): invalid pointer`)。
2. 检查内存块的大小是否至少为 `MINSIZE` 或 `MALLOC_ALIGNMENT` 的倍数。否则会抛出错误 (`free(): invalid size`)。
3. 如果内存块的大小在 fastbin 列表中：
   1. 检查下一个内存块的大小是否在最小和最大大小 (`av->system_mem`) 之间，否则抛出错误 (`free(): invalid next size (fast)`)。
   2. 对内存块调用 `free_perturb`。
   3. 为 `av` 设置 `FASTCHUNKS_BIT`。
   4. 根据内存块大小获取 fastbin 数组中的索引。
   5. 检查 bin 顶部是否不是我们要添加的内存块。否则抛出错误 (`double free or corruption (fasttop)`)。
   6. 检查顶部的 fastbin 内存块大小是否与我们要添加的内存块大小相同。否则抛出错误 (`invalid fastbin entry (free)`)。
   7. 将内存块插入到 fastbin 列表的顶部并返回。
4. 如果内存块未被映射：
   1. 检查内存块是否为顶部块。如果是，则抛出错误 (`double free or corruption (top)`)。
   2. 检查下一个内存块（按内存）是否在区域的边界内。如果不是，则抛出错误 (`double free or corruption (out)`)。
   3. 检查下一个内存块（按内存）的前一个使用位是否标记。如果没有，则抛出错误 (`double free or corruption (!prev)`)。
   4. 检查下一个内存块的大小是否在最小和最大大小 (`av->system_mem`) 之间。如果不是，则抛出错误 (`free(): invalid next size (normal)`)。
   5. 对内存块调用 `free_perturb`。
   6. 如果前一个内存块（按内存）未被使用，则对前一个内存块调用 `unlink`。
   7. 如果下一个内存块（按内存）不是顶部块：
      1. 如果下一个内存块未被使用，则对下一个内存块调用 `unlink`。
      2. 合并前一个、下一个内存块（按内存）中的空闲块，并将其添加到未排序 bin 的头部。在插入之前，检查 `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` 是否成立。如果不成立，则抛出错误 ("free(): corrupted unsorted chunks")。
   8. 如果下一个内存块（按内存）是顶部块，则将内存块适当地合并为单个顶部块。
5. 如果内存块已被映射，则调用 `munmap_chunk`。

## 堆函数安全检查

查看堆中常用函数执行的安全检查：

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## 参考资料

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions)
