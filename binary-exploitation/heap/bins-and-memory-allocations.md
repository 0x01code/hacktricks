# Bins & Allocations M√©moire

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de Base

Pour am√©liorer l'efficacit√© de la fa√ßon dont les morceaux sont stock√©s, chaque morceau n'est pas simplement dans une liste cha√Æn√©e, mais il existe plusieurs types. Ce sont les bacs et il y a 5 types de bacs : [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) petits bacs, 63 grands bacs, 1 bac non tri√©, 10 bacs rapides et 64 bacs tcache par fil.

L'adresse initiale de chaque bac non tri√©, petit et grand est √† l'int√©rieur du m√™me tableau. L'index 0 n'est pas utilis√©, 1 est le bac non tri√©, les bacs 2-64 sont des petits bacs et les bacs 65-127 sont des grands bacs.

### Petits Bacs

Les petits bacs sont plus rapides que les grands bacs mais plus lents que les bacs rapides.

Chaque bac des 62 aura des **morceaux de la m√™me taille** : 16, 24, ... (avec une taille maximale de 504 octets en 32 bits et 1024 en 64 bits). Cela aide √† acc√©l√©rer la recherche du bac o√π un espace doit √™tre allou√© et l'insertion et la suppression des entr√©es dans ces listes.

### Grands Bacs

Contrairement aux petits bacs, qui g√®rent des morceaux de tailles fixes, chaque **grand bac g√®re une plage de tailles de morceaux**. Cela est plus flexible, permettant au syst√®me de s'adapter √† **diverses tailles** sans avoir besoin d'un bac s√©par√© pour chaque taille.

Dans un allocateur de m√©moire, les grands bacs commencent l√† o√π les petits bacs se terminent. Les plages pour les grands bacs augmentent progressivement, ce qui signifie que le premier bac peut couvrir des morceaux de 512 √† 576 octets, tandis que le suivant couvre de 576 √† 640 octets. Ce sch√©ma se poursuit, le plus grand bac contenant tous les morceaux de plus de 1 Mo.

Les grands bacs sont plus lents √† manipuler par rapport aux petits bacs car ils doivent **trier et rechercher dans une liste de tailles de morceaux variables pour trouver le meilleur ajustement** pour une allocation. Lorsqu'un morceau est ins√©r√© dans un grand bac, il doit √™tre tri√©, et lorsqu'une m√©moire est allou√©e, le syst√®me doit trouver le bon morceau. Ce travail suppl√©mentaire les rend **plus lents**, mais comme les allocations importantes sont moins courantes que les petites, c'est un compromis acceptable.

Il y a :

* 32 bacs de plage de 64B
* 16 bacs de plage de 512B
* 8 bacs de plage de 4096B
* 4 bacs de plage de 32768B
* 2 bacs de plage de 262144B
* 1 bac pour les tailles restantes

### Bac Non Tri√©

Le bac non tri√© est un **cache rapide** utilis√© par le gestionnaire de tas pour rendre l'allocation de m√©moire plus rapide. Voici comment cela fonctionne : lorsque un programme lib√®re de la m√©moire, le gestionnaire de tas ne la place pas imm√©diatement dans un bac sp√©cifique. Au lieu de cela, il essaie d'abord de **la fusionner avec d'autres morceaux libres voisins** pour cr√©er un bloc plus important de m√©moire libre. Ensuite, il place ce nouveau morceau dans un bac g√©n√©ral appel√© le "bac non tri√©".

Lorsqu'un programme **demande de la m√©moire**, le gestionnaire de tas **v√©rifie le bac non tri√©** pour voir s'il y a un morceau de taille suffisante. S'il en trouve un, il l'utilise imm√©diatement. S'il ne trouve pas de morceau adapt√©, il d√©place les morceaux lib√©r√©s vers leurs bacs correspondants, petits ou grands, en fonction de leur taille.

Ainsi, le bac non tri√© est un moyen d'acc√©l√©rer l'allocation de m√©moire en r√©utilisant rapidement la m√©moire lib√©r√©e r√©cemment et en r√©duisant le besoin de recherches et de fusions chronophages.

{% hint style="danger" %}
Notez que m√™me si les morceaux sont de cat√©gories diff√©rentes, si un morceau disponible entre en collision avec un autre morceau disponible (m√™me s'ils sont de cat√©gories diff√©rentes), ils seront fusionn√©s.
{% endhint %}

### Bacs Rapides

Les bacs rapides sont con√ßus pour **acc√©l√©rer l'allocation de m√©moire pour de petits morceaux** en conservant les morceaux lib√©r√©s r√©cemment dans une structure d'acc√®s rapide. Ces bacs utilisent une approche Last-In, First-Out (LIFO), ce qui signifie que le **morceau lib√©r√© le plus r√©cemment est le premier** √† √™tre r√©utilis√© lorsqu'il y a une nouvelle demande d'allocation. Ce comportement est avantageux pour la vitesse, car il est plus rapide d'ins√©rer et de supprimer en haut d'une pile (LIFO) par rapport √† une file (FIFO).

De plus, **les bacs rapides utilisent des listes cha√Æn√©es simples**, pas doubles, ce qui am√©liore encore la vitesse. Comme les morceaux dans les bacs rapides ne sont pas fusionn√©s avec les voisins, il n'est pas n√©cessaire d'avoir une structure complexe permettant la suppression au milieu. Une liste cha√Æn√©e simple est plus simple et plus rapide pour ces op√©rations.

Essentiellement, ce qui se passe ici, c'est que l'en-t√™te (le pointeur vers le premier morceau √† v√©rifier) pointe toujours vers le dernier morceau lib√©r√© de cette taille. Ainsi :

* Lorsqu'un nouveau morceau est allou√© de cette taille, l'en-t√™te pointe vers un morceau libre √† utiliser. Comme ce morceau libre pointe vers le suivant √† utiliser, cette adresse est stock√©e dans l'en-t√™te afin que la prochaine allocation sache o√π obtenir un morceau disponible.
* Lorsqu'un morceau est lib√©r√©, le morceau libre sauvegardera l'adresse du morceau disponible actuel et l'adresse de ce nouveau morceau lib√©r√© sera plac√©e dans l'en-t√™te.

{% hint style="danger" %}
Les morceaux dans les bacs rapides ne sont pas automatiquement d√©finis comme disponibles, ils restent donc comme morceaux de bac rapide pendant un certain temps au lieu de pouvoir fusionner avec d'autres morceaux.
{% endhint %}

### Bacs Tcache (Cache Par-Fil)

M√™me si les threads essaient d'avoir leur propre tas (voir [Arenas](bins-and-memory-allocations.md#arenas) et [Sous-tas](bins-and-memory-allocations.md#subheaps)), il est possible qu'un processus avec beaucoup de threads (comme un serveur web) **finisse par partager le tas avec d'autres threads**. Dans ce cas, la principale solution est l'utilisation de **verrous**, ce qui pourrait **ralentir consid√©rablement les threads**.

Par cons√©quent, un tcache est similaire √† un bac rapide par fil de discussion de la mani√®re dont c'est une **liste cha√Æn√©e simple** qui ne fusionne pas les morceaux. Chaque fil de discussion a **64 bacs tcache √† liste cha√Æn√©e simple**. Chaque bac peut avoir un maximum de [7 morceaux de m√™me taille](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) allant de [24 √† 1032B sur les syst√®mes 64 bits et de 12 √† 516B sur les syst√®mes 32 bits](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315).

**Lorsqu'un fil de discussion lib√®re** un morceau, **s'il n'est pas trop gros** pour √™tre allou√© dans le tcache et que le bac tcache respectif **n'est pas plein** (d√©j√† 7 morceaux), **il sera allou√© l√†-dedans**. S'il ne peut pas aller dans le tcache, il devra attendre que le verrou du tas soit en mesure d'effectuer l'op√©ration de lib√©ration globalement.

Lorsqu'un **morceau est allou√©**, s'il y a un morceau libre de la taille n√©cessaire dans le **tcache, il l'utilisera**, sinon, il devra attendre que le verrou du tas soit en mesure d'en trouver un dans les bacs globaux ou d'en cr√©er un nouveau.\
Il y a aussi une optimisation, dans ce cas, tout en ayant le verrou du tas, le fil de discussion **remplira son tcache avec des morceaux de tas (7) de la taille demand√©e**, donc s'il en a besoin de plus, il les trouvera dans le tcache.
## Flux d'Allocation

{% hint style="success" %}
(Cette explication actuelle provient de [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). √Ä FAIRE : V√©rifier la derni√®re version et la mettre √† jour)
{% endhint %}

Les allocations sont finalement effectu√©es avec la fonction : `void * _int_malloc (mstate av, size_t bytes)` et suivent cet ordre :

1. Met √† jour `bytes` pour prendre en compte les **alignements**, etc.
2. V√©rifie si `av` est **NULL** ou non.
3. En cas d'absence d'**ar√®ne utilisable** (lorsque `av` est NULL), appelle `sysmalloc` pour obtenir un morceau en utilisant mmap. Si r√©ussi, appelle `alloc_perturb`. Renvoie le pointeur.
4. Selon la taille :
* \[Ajout √† l'original] Utilise le tcache avant de v√©rifier le prochain fastbin.
* \[Ajout √† l'original] S'il n'y a pas de tcache mais qu'un autre bin est utilis√© (voir √©tape suivante), essayez de remplir le tcache √† partir de ce bin
* Si la taille se situe dans la plage du **fastbin** :
1. Obtient l'index dans le tableau fastbin pour acc√©der √† un bin appropri√© en fonction de la taille demand√©e.
2. Retire le premier morceau de ce bin et fait pointer `victim` vers celui-ci.
3. Si `victim` est NULL, passe au cas suivant (smallbin).
4. Si `victim` n'est pas NULL, v√©rifie la taille du morceau pour s'assurer qu'il appartient √† ce bin particulier. Une erreur ("malloc(): corruption de la m√©moire (fast)") est renvoy√©e sinon.
5. Appelle `alloc_perturb` puis renvoie le pointeur.
* Si la taille se situe dans la plage du **smallbin** :
1. Obtient l'index dans le tableau smallbin pour acc√©der √† un bin appropri√© en fonction de la taille demand√©e.
2. S'il n'y a pas de morceaux dans ce bin, passe au cas suivant. Cela est v√©rifi√© en comparant les pointeurs `bin` et `bin->bk`.
3. `victim` est √©gal √† `bin->bk` (le dernier morceau dans le bin). S'il est NULL (se produit pendant l'`initialisation`), appelle `malloc_consolidate` et saute cette √©tape compl√®te de v√©rification dans diff√©rents bins.
4. Sinon, lorsque `victim` n'est pas NULL, v√©rifie si `victim->bk->fd` et `victim` sont √©gaux ou non. S'ils ne sont pas √©gaux, une erreur (`malloc(): liste doublement cha√Æn√©e smallbin corrompue`) est renvoy√©e.
5. D√©finit le bit PREV\_INSUSE pour le prochain morceau (en m√©moire, pas dans la liste doublement cha√Æn√©e) pour `victim`.
6. Retire ce morceau de la liste du bin.
7. D√©finit le bit d'ar√®ne appropri√© pour ce morceau en fonction de `av`.
8. Appelle `alloc_perturb` puis renvoie le pointeur.
* Si la taille ne se situe pas dans la plage du smallbin :
1. Obtient l'index dans le tableau largebin pour acc√©der √† un bin appropri√© en fonction de la taille demand√©e.
2. V√©rifie si `av` a des fastchunks ou non. Cela est fait en v√©rifiant le `FASTCHUNKS_BIT` dans `av->flags`. Si c'est le cas, appelle `malloc_consolidate` sur `av`.
5. Si aucun pointeur n'a encore √©t√© renvoy√©, cela signifie un ou plusieurs des cas suivants :
1. La taille se situe dans la plage des 'fastbin' mais aucun fastchunk n'est disponible.
2. La taille se situe dans la plage des 'smallbin' mais aucun smallchunk n'est disponible (appelle `malloc_consolidate` pendant l'initialisation).
3. La taille se situe dans la plage des 'largbin'.
6. Ensuite, les **morceaux non tri√©s** sont v√©rifi√©s et les morceaux parcourus sont plac√©s dans des bins. C'est le seul endroit o√π les morceaux sont plac√©s dans des bins. It√®re le bin non tri√© depuis la 'QUEUE'.
1. `victim` pointe vers le morceau actuel en cours d'examen.
2. V√©rifie si la taille du morceau de `victim` est dans la plage minimale (`2*SIZE_SZ`) et maximale (`av->system_mem`). Renvoie une erreur (`malloc(): corruption de la m√©moire`) sinon.
3. Si (la taille du morceau demand√© se situe dans la plage du smallbin) et (`victim` est le dernier morceau restant) et (c'est le seul morceau dans le bin non tri√©) et (la taille des morceaux >= celle demand√©e) : **Divise le morceau en 2 morceaux** :
* Le premier morceau correspond √† la taille demand√©e et est renvoy√©.
* Le morceau restant devient le nouveau dernier morceau restant. Il est r√©ins√©r√© dans le bin non tri√©.
1. D√©finit les champs `chunk_size` et `chunk_prev_size` de mani√®re appropri√©e pour les deux morceaux.
2. Le premier morceau est renvoy√© apr√®s avoir appel√© `alloc_perturb`.
3. Si la condition ci-dessus est fausse, le contr√¥le arrive ici. Retire `victim` du bin non tri√©. Si la taille de `victim` correspond exactement √† la taille demand√©e, renvoie ce morceau apr√®s avoir appel√© `alloc_perturb`.
4. Si la taille de `victim` se situe dans la plage du smallbin, ajoute le morceau dans le smallbin appropri√© √† la 'T√äTE'.
5. Sinon, ins√®re dans le largebin appropri√© tout en maintenant l'ordre tri√© :
6. V√©rifie d'abord le dernier morceau (le plus petit). Si `victim` est plus petit que le dernier morceau, l'ins√®re en dernier.
7. Sinon, boucle pour trouver un morceau avec une taille >= la taille de `victim`. Si la taille est exactement la m√™me, l'ins√®re toujours en deuxi√®me position.
8. R√©p√®te cette √©tape un maximum de `MAX_ITERS` (10000) fois ou jusqu'√† ce que tous les morceaux du bin non tri√© soient √©puis√©s.
7. Apr√®s avoir v√©rifi√© les morceaux non tri√©s, v√©rifie si la taille demand√©e ne se situe pas dans la plage du smallbin, si c'est le cas, v√©rifie les **largebins**.
1. Obtient l'index dans le tableau largebin pour acc√©der √† un bin appropri√© en fonction de la taille demand√©e.
2. Si la taille du plus grand morceau (le premier morceau dans le bin) est sup√©rieure √† la taille demand√©e :
1. It√®re depuis la 'QUEUE' pour trouver un morceau (`victim`) avec la plus petite taille >= la taille demand√©e.
2. Appelle `unlink` pour retirer le morceau `victim` du bin.
3. Calcule `remainder_size` pour le morceau de `victim` (ce sera la taille du morceau de `victim` - taille demand√©e).
4. Si cette `remainder_size` >= `MINSIZE` (la taille minimale du morceau incluant les en-t√™tes), divise le morceau en deux morceaux. Sinon, le morceau entier de `victim` sera renvoy√©. Ins√®re le morceau restant dans le bin non tri√© (√† la fin de la 'QUEUE'). Une v√©rification est effectu√©e dans le bin non tri√© pour savoir si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Une erreur est renvoy√©e sinon ("malloc(): morceaux non tri√©s corrompus").
5. Renvoie le morceau `victim` apr√®s avoir appel√© `alloc_perturb`.
8. Jusqu'√† pr√©sent, nous avons v√©rifi√© le bin non tri√© et √©galement le bin rapide, petit ou grand respectif. Notez qu'un seul bin (rapide ou petit) a √©t√© v√©rifi√© en utilisant la taille **exacte** du morceau demand√©. R√©p√©tez les √©tapes suivantes jusqu'√† ce que tous les bins soient √©puis√©s :
1. L'index dans le tableau de bins est incr√©ment√© pour v√©rifier le bin suivant.
2. Utilise la carte `av->binmap` pour sauter les bins vides.
3. `victim` pointe vers la 'QUEUE' du bin actuel.
4. En utilisant la binmap, assurez-vous que si un bin est saut√© (dans la 2√®me √©tape ci-dessus), il est certainement vide. Cependant, cela ne garantit pas que tous les bins vides seront saut√©s. V√©rifiez si le victim est vide ou non. S'il est vide, sautez √† nouveau le bin et r√©p√©tez le processus ci-dessus (ou 'continuez' cette boucle) jusqu'√† ce que nous arrivions √† un bin non vide.
5. Divisez le morceau (`victim` pointe vers le dernier morceau d'un bin non vide) en deux morceaux. Ins√©rez le morceau restant dans le bin non tri√© (√† la fin de la 'QUEUE'). Une v√©rification est effectu√©e dans le bin non tri√© pour savoir si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`. Une erreur est renvoy√©e sinon ("malloc(): morceaux non tri√©s corrompus 2").
6. Renvoie le morceau `victim` apr√®s avoir appel√© `alloc_perturb`.
9. Si aucun bin vide n'est encore trouv√©, le morceau 'top' sera utilis√© pour r√©pondre √† la demande :
1. `victim` pointe vers `av->top`.
2. Si la taille du morceau 'top' >= 'taille demand√©e' + `MINSIZE`, le divise en deux morceaux. Dans ce cas, le morceau restant devient le nouveau morceau 'top' et l'autre morceau est renvoy√© √† l'utilisateur apr√®s avoir appel√© `alloc_perturb`.
3. V√©rifiez si `av` a des fastchunks ou non. Cela est fait en v√©rifiant le `FASTCHUNKS_BIT` dans `av->flags`. Si c'est le cas, appelle `malloc_consolidate` sur `av`. Retour √† l'√©tape 6 (o√π nous v√©rifions le bin non tri√©).
4. Si `av` n'a pas de fastchunks, appelle `sysmalloc` et renvoie le pointeur obtenu apr√®s avoir appel√© `alloc_perturb`.
## Flux Libre

{% hint style="success" %}
(Cette explication actuelle provient de [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions). TODO: V√©rifiez la derni√®re version et mettez-la √† jour)
{% endhint %}

La fonction finale lib√©rant des morceaux de m√©moire est `_int_free (mstate av, mchunkptr p, int have_lock)` :

1. V√©rifiez si `p` est avant `p + chunksize(p)` dans la m√©moire (pour √©viter le d√©bordement). Une erreur (`free(): pointeur invalide`) est d√©clench√©e sinon.
2. V√©rifiez si le morceau a au moins une taille `MINSIZE` ou un multiple de `MALLOC_ALIGNMENT`. Une erreur (`free(): taille invalide`) est d√©clench√©e sinon.
3. Si la taille du morceau se trouve dans la liste fastbin :
1. V√©rifiez si la taille du morceau suivant est entre la taille minimale et maximale (`av->system_mem`), d√©clenchez une erreur (`free(): taille suivante invalide (rapide)`) sinon.
2. Appelle `free_perturb` sur le morceau.
3. D√©finit `FASTCHUNKS_BIT` pour `av`.
4. Obtenez l'index dans le tableau fastbin en fonction de la taille du morceau.
5. V√©rifiez si le sommet du bac n'est pas le morceau que nous allons ajouter. Sinon, d√©clenchez une erreur (`double lib√©ration ou corruption (fasttop)`).
6. V√©rifiez si la taille du morceau fastbin au sommet est la m√™me que celle du morceau que nous ajoutons. Sinon, d√©clenchez une erreur (`entr√©e fastbin invalide (lib√©ration)`).
7. Ins√©rez le morceau au sommet de la liste fastbin et retournez.
4. Si le morceau n'est pas mapp√© en m√©moire :
1. V√©rifiez si le morceau est le morceau sup√©rieur ou non. Si oui, une erreur (`double lib√©ration ou corruption (top)`) est d√©clench√©e.
2. V√©rifiez si le morceau suivant (par m√©moire) est dans les limites de l'ar√®ne. Sinon, une erreur (`double lib√©ration ou corruption (out)`) est d√©clench√©e.
3. V√©rifiez si le bit pr√©c√©dent du morceau suivant (par m√©moire) est marqu√© ou non. Sinon, une erreur (`double lib√©ration ou corruption (!prev)`) est d√©clench√©e.
4. V√©rifiez si la taille du morceau suivant est entre la taille minimale et maximale (`av->system_mem`). Sinon, une erreur (`free(): taille suivante invalide (normale)`) est d√©clench√©e.
5. Appelez `free_perturb` sur le morceau.
6. Si le morceau pr√©c√©dent (par m√©moire) n'est pas utilis√©, appelez `unlink` sur le morceau pr√©c√©dent.
7. Si le morceau suivant (par m√©moire) n'est pas le morceau sup√©rieur :
1. Si le morceau suivant n'est pas utilis√©, appelez `unlink` sur le morceau suivant.
2. Fusionnez le morceau avec le pr√©c√©dent, le suivant (par m√©moire), si l'un est libre, et ajoutez-le en t√™te du bac non tri√©. Avant d'ins√©rer, v√©rifiez si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` ou non. Sinon, une erreur ("free(): morceaux non tri√©s corrompus") est d√©clench√©e.
8. Si le morceau suivant (par m√©moire) √©tait un morceau sup√©rieur, fusionnez les morceaux de mani√®re appropri√©e en un seul morceau sup√©rieur.
5. Si le morceau √©tait mapp√© en m√©moire, appelez `munmap_chunk`.

## V√©rifications de S√©curit√© des Fonctions de la Heap

Consultez les v√©rifications de s√©curit√© effectu√©es par les fonctions largement utilis√©es dans la heap dans :

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## R√©f√©rences

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez** üí¨ le [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
