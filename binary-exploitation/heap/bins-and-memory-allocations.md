# Bins & Bellek Tahsisi

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Parçaların nasıl depolandığındaki verimliliği artırmak için her parça sadece bir bağlı liste içinde değil, farklı türlerde bulunur. Bunlar "bins" olarak adlandırılır ve 5 tür bin vardır: [62](https://sourceware.org/git/gitweb.cgi?p=glibc.git;a=blob;f=malloc/malloc.c;h=6e766d11bc85b6480fa5c9f2a76559f8acf9deb5;hb=HEAD#l1407) küçük bins, 63 büyük bins, 1 sıralanmamış bin, 10 hızlı bins ve her iş parçacığı için 64 tcache bin'i.

Sıralanmamış, küçük ve büyük bins için her birinin başlangıç adresi aynı dizinin içindedir. İndeks 0 kullanılmaz, 1 sıralanmamış bin, 2-64 arası küçük bins ve 65-127 arası büyük bins olarak belirlenmiştir.

### Küçük Bins

Küçük bins, büyük binsden daha hızlı ancak hızlı binsden daha yavaştır.

62'nin her bir bininde **aynı boyutta parçalar** bulunur: 16, 24, ... (32 bitlerde maksimum 504 bayt, 64 bitlerde 1024 bayta kadar). Bu, bir alana yer tahsis edilecek binin bulunması, girişlerin eklenmesi ve çıkarılması hızını artırır.

### Büyük Bins

Küçük binslerin aksine, her **büyük bin bir parça boyutu aralığını yönetir**. Bu, sistemin **farklı boyutları** ayrı birer bin olmadan barındırabilmesini sağlar.

Bir bellek tahsisçısında, büyük binsler küçük binslerin bittiği yerden başlar. Büyük binsler için aralıklar giderek daha büyük hale gelir, yani ilk bin 512 ila 576 bayt arasındaki parçaları kapsarken, bir sonraki 576 ila 640 baytı kapsar. Bu desen devam eder ve en büyük bin tüm 1MB üzerindeki parçaları içerir.

Büyük binsler, bir tahsis için en iyi uyumu bulmak için **farklı parça boyutlarının listesini sıralamak ve aramak zorunda olduklarından küçük binslere göre daha yavaş çalışır**. Bir parça büyük bine eklenirken sıralanmalı ve bellek tahsis edilirken sistem doğru parçayı bulmalıdır. Bu ek iş, onları **daha yavaş** yapar, ancak büyük tahsisler küçük olanlardan daha az yaygın olduğundan, kabul edilebilir bir takas yapılır.

Şunlar vardır:

* 64B aralığındaki 32 bin
* 512B aralığındaki 16 bin
* 4096B aralığındaki 8 bin
* 32768B aralığındaki 4 bin
* 262144B aralığındaki 2 bin
* Geri kalan boyutlar için 1 bin

### Sıralanmamış Bin

Sıralanmamış bin, bellek tahsisini hızlandırmak için kullanılan bir **hızlı önbellektir**. İşte nasıl çalışır: Bir program belleği serbest bıraktığında, bellek yöneticisi hemen onu belirli bir bine koymaz. Bunun yerine, öncelikle yan yana gelen serbest parçaları birleştirerek daha büyük bir serbest bellek bloğu oluşturmaya çalışır. Daha sonra, bu yeni parçayı "sıralanmamış bin" adı verilen genel bir bine yerleştirir.

Bir program **bellek istediğinde**, bellek yöneticisi **sıralanmamış bin'i kontrol eder** ve yeterli boyutta bir parça bulunup bulunmadığını kontrol eder. Bir uygun parça bulursa, hemen kullanır. Uygun bir parça bulamazsa, serbest bırakılan parçaları boyutlarına bağlı olarak küçük veya büyük bine taşır.

Bu nedenle, sıralanmamış bin, bellek tahsisini hızlandırmak için son zamanlarda serbest bırakılan belleği hızlı bir şekilde yeniden kullanarak ve zaman alıcı aramaları ve birleştirmeleri azaltarak hafızayı hızlandırır.

{% hint style="danger" %}
Farklı kategorilerdeki parçalar bile olsa, mevcut bir parça başka bir mevcut parçayla çakışıyorsa (farklı kategorilerde olsalar bile), birleştirileceklerdir.
{% endhint %}

### Hızlı Bins

Hızlı binsler, küçük parçalar için bellek tahsisini hızlandırmak için tasarlanmıştır ve son zamanlarda serbest bırakılan parçaları hızlı erişim yapısında tutarak çalışır. Bu binsler, Son Giren İlk Çıkar (LIFO) yaklaşımını kullanır, yani **en son serbest bırakılan parça**, yeni bir tahsis isteği olduğunda ilk olarak yeniden kullanılır. Bu davranış, hız için avantajlıdır, çünkü bir yığının üstünden (LIFO) ekleme ve çıkarma işlemleri bir kuyruktan (FIFO) daha hızlıdır.

Ayrıca, **hızlı binsler tek yönlü bağlı listeleri** kullanır, çift yönlü bağlı listelerden değil, bu da hızı artırır. Hızlı binslerdeki parçalar komşularla birleştirilmediğinden, ortadan kaldırma işlemleri için karmaşık bir yapıya gerek yoktur. Tek yönlü bağlı liste, bu işlemler için daha basit ve daha hızlıdır.

Temelde burada olan şey, başlık (kontrol edilecek ilk parça için işaretçi) her zaman o boyuttaki en son serbest bırakılan parçaya işaret eder. Dolayısıyla:

* Bu boyutta yeni bir parça tahsis edildiğinde, başlık kullanılacak bir boş parçaya işaret eder. Bu boş parça bir sonraki kullanılacak parçaya işaret ettiğinden, bu adres başlıkta saklanır, böylece bir sonraki tahsis nereden alacağını bilir
* Bir parça serbest bırakıldığında, boş parça mevcut kullanılabilir parçanın adresini kaydeder ve bu yeni serbest bırakılan parçanın adresi başlığa konur

{% hint style="danger" %}
Hızlı binslerdeki parçalar otomatik olarak kullanılabilir olarak ayarlanmaz, bu nedenle diğer parçalarla birleşebilme yeteneğine sahip olmazlar ve bir süre hızlı bin parçaları olarak kalırlar.
{% endhint %}

### Tcache (İş Parçacığına Özel Önbellek) Bins

İş parçacıkları kendi belleklerine sahip olmaya çalışsa da (bkz. [Arenalar](bins-and-memory-allocations.md#arenas) ve [Alt Bellekler](bins-and-memory-allocations.md#subheaps)), birçok iş parçacığına sahip bir sürecin (örneğin bir web sunucusu) **başka iş parçacıklarıyla belleği paylaşması olasılığı** vardır. Bu durumda, ana çözüm **kilitlerin** kullanılmasıdır, bu da **iş parçacıklarını önemli ölçüde yavaşlatabilir**.

Bu nedenle, bir tcache, her iş parçacığı için bir hızlı bin gibi **tek yönlü bağlı liste** olan bir yapıdır ve parçaları birleştirmez. Her iş parçacığı **64 tek yönlü tcache bin'ine** sahiptir. Her bir bin, [64 bit sistemlerde 24 ila 1032B ve 32 bit sistemlerde 12 ila 516B arasında](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l315) olan [7 aynı boyutta parça](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=2527e2504761744df2bdb1abdc02d936ff907ad2;hb=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc#l323) içerebilir.

Bir iş parçacığı bir parçayı serbest bıraktığında, **eğer çok büyük değilse** ve ilgili tcache bin **dolu değilse** (zaten 7 parça), **oraya tahsis edilir**. Tcache'e gidemiyorsa, genel bine serbest bırakma işlemini yapabilmek için bellek kilidini beklemek zorunda kalır.

Bir **parça tahsis edildiğinde**, eğer **Tcache'te ihtiyaç duyulan boyutta bir boş parça varsa kullanılır**, yoksa genel bine bir tane bulmak veya yeni bir tane oluşturmak için bellek kilidini beklemek zorunda kalır.\
Bu durumda bir optimizasyon da vardır, bellek kilidini alırken, iş parçacığı **istenen boyutta Tcache'ine heap parçaları (7) doldurur**, böylece daha fazla ihtiyaç duyarsa Tcache'te bulabilir.
## Tahsis Akışı

{% hint style="success" %}
(Bu mevcut açıklama [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/core_functions) adresinden alınmıştır. TODO: Son sürümü kontrol edin ve güncelleyin)
{% endhint %}

Tahsisler sonunda şu işlevle gerçekleştirilir: `void * _int_malloc (mstate av, size_t bytes)` ve şu sıraya sahiptir:

1. **Hizalamaları** vb. dikkate almak için `bytes` güncellenir.
2. `av`'nin **NULL** olup olmadığı kontrol edilir.
3. **Kullanılabilir alan** eksikliği durumunda (av NULL olduğunda), mmap kullanarak parça almak için `sysmalloc` çağrılır. Başarılı olursa, `alloc_perturb` çağrılır. İşaretçi döndürülür.
4. Boyuta bağlı olarak:
* \[Orijinal ek] Bir sonraki fastbin'i kontrol etmeden önce tcache kullanılır.
* \[Orijinal ek] Tcache yoksa ancak farklı bir bin kullanılıyorsa (daha sonraki adımlarda görülecek), tcache'i o bini doldurmaya çalışır.
* Boyut **fastbin** aralığına düşerse:&#x20;
1. Uygun bir bin erişmek için fastbin dizisine endeks alınır.
2. Bu bindeki ilk parçayı çıkarır ve `victim`'ı ona işaret eder.
3. Eğer `victim` NULL ise, bir sonraki duruma geçilir (smallbin).
4. Eğer `victim` NULL değilse, parçanın boyutunu kontrol etmek için onun o belirli bine ait olduğundan emin olmak için kontrol edilir. Aksi takdirde bir hata ("malloc(): bellek bozulması (hızlı)") fırlatılır.
5. `alloc_perturb` çağrılır ve ardından işaretçi döndürülür.
* Boyut **smallbin** aralığına düşerse:
1. Uygun bir bin erişmek için smallbin dizisine endeks alınır.
2. Bu binde parça yoksa, bir sonraki duruma geçilir. Bu, `bin` ve `bin->bk` işaretçilerini karşılaştırarak kontrol edilir.
3. `victim`, `bin->bk`'ye (bindeki son parça) eşitlenir. Eğer NULL ise (başlangıçta gerçekleşir), `malloc_consolidate` çağrılır ve farklı binalara bakma adımı tamamen atlanır.
4. Aksi takdirde, `victim` NULL değilse, `victim->bk->fd` ve `victim`'ın eşit olup olmadığı kontrol edilir. Eğer eşit değillerse, bir hata (`malloc(): smallbin çift bağlı liste bozulmuş`) fırlatılır.
5. `victim` için bir sonraki parça için (bellekte, çift bağlı listede değil) PREV_INSUSE biti ayarlanır.
6. Bu parça bin listesinden çıkarılır.
7. Bu parçaya uygun arena biti `av`'ye bağlı olarak ayarlanır.
8. `alloc_perturb` çağrılır ve ardından işaretçi döndürülür.
* Boyut **smallbin** aralığına düşmezse:
1. Uygun bir bin erişmek için largebin dizisine endeks alınır.
2. `av`'nin fastchunks'a sahip olup olmadığı kontrol edilir. Bu, `av->flags` içindeki `FASTCHUNKS_BIT`'i kontrol ederek yapılır. Öyleyse, `av` üzerinde `malloc_consolidate` çağrılır.
5. Henüz bir işaretçi döndürülmemişse, bu bir veya daha fazla aşağıdaki durumdan birini gösterir:
1. Boyut 'fastbin' aralığına düşer ancak hızlı parça mevcut değildir.
2. Boyut 'smallbin' aralığına düşer ancak küçük parça mevcut değildir (başlangıçta `malloc_consolidate` çağrılır).
3. Boyut 'largebin' aralığına düşer.
6. Sonra, **sırasız parçalar** kontrol edilir ve gezilen parçalar binalara yerleştirilir. Parçaların binalara yerleştirildiği tek yer burasıdır. Sırasız bin 'TAIL'den iterasyon yapılır.
1. `victim`, üzerinde durulan mevcut parçayı işaret eder.
2. `victim`'ın parça boyutunun minimum (`2*SIZE_SZ`) ve maksimum (`av->system_mem`) aralığında olup olmadığı kontrol edilir. Aksi takdirde bir hata (`malloc(): bellek bozulması`) fırlatılır.
3. Eğer (istenen parça boyutu smallbin aralığına düşerse) ve (`victim` son kalan parça ise) ve (sırasız binde tek parça varsa) ve (parçanın boyutu istenen boyuttan büyükse): **Parçayı 2 parçaya ayır**:
* İlk parça istenen boyuta uyar ve döndürülür.
* Geriye kalan parça yeni son kalan parça olur. Bu sırasız bine geri eklenir.
1. Her iki parça için de `chunk_size` ve `chunk_prev_size` alanları uygun şekilde ayarlanır.
2. İlk parça, `alloc_perturb` çağrıldıktan sonra döndürülür.
3. Yukarıdaki koşul yanlışsa, kontrol buraya ulaşır. `victim` sırasız binde çıkarılır. `victim`'ın boyutu tam olarak istenen boyuta uyuşuyorsa, bu parça `alloc_perturb` çağrıldıktan sonra döndürülür.
4. Eğer `victim`'ın boyutu smallbin aralığına düşerse, parça uygun smallbin'e `HEAD`'e eklenir.
5. Aksi takdirde, uygun sıralı düzende büyük bin içine eklenir:
6. En küçük son parçayı (en küçük) kontrol eder. Eğer `victim` en küçük parçadan küçükse, en sona eklenir.
7. Aksi takdirde, `victim`'ın boyutundan büyük veya eşit bir parça bulmak için döngü yapılır. Boyut tam olarak aynıysa, her zaman ikinci pozisyona eklenir.
8. Bu adım maksimum `MAX_ITERS` (10000) kez veya sırasız bindeki tüm parçalar tükenene kadar tekrarlanır.
7. Sırasız parçalar kontrol edildikten sonra, istenen boyutun smallbin aralığına düşmediği kontrol edilir, öyleyse **largebin'leri** kontrol edilir.
1. Uygun bir bin erişmek için largebin dizisine endeks alınır.
2. En büyük parçanın boyutu (bindeki ilk parça) istenen boyuttan büyükse:
1. Bir parça (`victim`) bulmak için 'TAIL'den iterasyon yapılır, istenen boyuttan büyük veya eşit en küçük boyuta sahip.
2. `victim` parçasını bindeki çıkarmak için `unlink` çağrılır.
3. `victim`'ın parçası için `remainder_size` hesaplanır (bu, `victim`'ın parça boyutu - istenen boyut olacaktır).
4. Eğer bu `remainder_size` >= `MINSIZE` (başlık dahil minimum parça boyutu), parçayı iki parçaya böler. Aksi takdirde, tüm `victim` parçası döndürülür. Geriye kalan parça sırasız bine eklenir ('TAIL' sonunda). Sırasız binde `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` kontrol edilir. Aksi takırdi hata fırlatılır ("malloc(): bozuk sırasız parçalar").
5. `victim` parça, `alloc_perturb` çağrıldıktan sonra döndürülür.
8. Şimdiye kadar, sırasız bin ve ilgili fast, small veya large bin kontrol edildi. Unutmayın ki tek bir bin (hızlı veya küçük) istenen parça boyutunun **tam olarak** kontrol edildiği yerdir. Tüm binalar tükenene kadar aşağıdaki adımları tekrarlayın:
1. Bin dizisine erişim endeksi artırılır.
2. Boş olan binaları atlamak için `av->binmap` haritası kullanılır.
3. `victim` mevcut binin 'TAIL'ine işaret eder.
4. Bin haritası, bir binin atlandığını (yukarıdaki 2. adımda) kesinlikle boş olduğunu sağlar. Ancak, tüm boş binaların atlanacağını garanti etmez. `victim`'ın boş olup olmadığı kontrol edilir. Eğer boşsa, tekrar bin atlanır ve yukarıdaki işlem tekrarlanır (veya bu döngü 'devam' eder) boş olmayan bir bine ulaşılana kadar.
5. Parça ikiye bölünür (`victim`, dolu olmayan bir binin son parçasını işaret eder). Geriye kalan parça sırasız bine eklenir ('TAIL' sonunda). Sırasız binde `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` kontrol edilir. Aksi takdirde hata fırlatılır ("malloc(): bozuk sırasız parçalar 2").
6. `victim` parça, `alloc_perturb` çağrıldıktan sonra döndürülür.
9. Hala boş bir bin bulunamazsa, 'top' parçası isteği karşılamak için kullanılacaktır:
1. `victim`, `av->top`'a işaret eder.
2. 'top' parçasının boyutu >= 'istenilen boyut' + `MINSIZE` ise, ikiye bölünür. Bu durumda, geriye kalan parça yeni 'top' parça olur ve diğer parça `alloc_perturb` çağrıldıktan sonra kullanıcıya döndürülür.
3. `av`'nin fastchunks'a sahip olup olmadığı kontrol edilir. Bu, `av->flags` içindeki `FASTCHUNKS_BIT`'i kontrol ederek yapılır. Öyleyse, `av` üzerinde `malloc_consolidate` çağrılır. 6. adıma geri dönülür (sırasız bin kontrol edildiği yer).
4. Eğer `av`'nin fastchunks'u yoksa, `sysmalloc` çağrılır ve `alloc_perturb` çağrıldıktan sonra elde edilen işaretçi döndürülür.
## Serbest Akış

{% hint style="success" %}
(Bu mevcut açıklama [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions) adresinden alınmıştır. TODO: Son sürümü kontrol edin ve güncelleyin)
{% endhint %}

Hafıza parçalarını serbest bırakan son işlev `_int_free (mstate av, mchunkptr p, int have_lock)` şöyledir:

1. `p`, bellekte `p + chunksize(p)`'den önce mi diye kontrol edilir (sarılma olmaması için). Aksi takdirde bir hata (`free(): invalid pointer`) oluşturulur.
2. Parçanın en az `MINSIZE` boyutunda veya `MALLOC_ALIGNMENT`'ın katı olup olmadığı kontrol edilir. Aksi takdirde bir hata (`free(): invalid size`) oluşturulur.
3. Eğer parçanın boyutu fastbin listesine düşerse:
1. Sonraki parçanın boyutunun minimum ve maksimum boyut (`av->system_mem`) arasında olup olmadığı kontrol edilir, aksi takdirde bir hata (`free(): invalid next size (fast)`) oluşturulur.
2. Parçada `free_perturb` çağrılır.
3. `av` için `FASTCHUNKS_BIT` ayarlanır.
4. Parçanın boyutuna göre fastbin dizisine endeks alınır.
5. Kovanın en üstünde ekleyeceğimiz parçanın parça olmadığı kontrol edilir. Aksi takdirde bir hata (`double free or corruption (fasttop)`) oluşturulur.
6. Kovanın en üstündeki fastbin parçanın boyutunun ekleyeceğimiz parça ile aynı olup olmadığı kontrol edilir. Aksi takdirde bir hata (`invalid fastbin entry (free)`) oluşturulur.
7. Parçayı fastbin listesinin en üstüne ekleyin ve dönün.
4. Eğer parça mmapped değilse:
1. Parçanın en üst parça olup olmadığı kontrol edilir. Eğer öyleyse, bir hata (`double free or corruption (top)`) oluşturulur.
2. Sonraki parçanın (bellek tarafından) arenanın sınırları içinde olup olmadığı kontrol edilir. Değilse, bir hata (`double free or corruption (out)`) oluşturulur.
3. Sonraki parçanın (bellek tarafından) önceki kullanımda işaretlenmiş olup olmadığı kontrol edilir. Değilse, bir hata (`double free or corruption (!prev)`) oluşturulur.
4. Sonraki parçanın boyutunun minimum ve maksimum boyut (`av->system_mem`) arasında olup olmadığı kontrol edilir. Değilse, bir hata (`free(): invalid next size (normal)`) oluşturulur.
5. Parçada `free_perturb` çağrılır.
6. Önceki parça (bellek tarafından) kullanımda değilse, önceki parçada `unlink` çağrılır.
7. Sonraki parça (bellek tarafından) en üst parça değilse:
1. Sonraki parça kullanımda değilse, sonraki parçada `unlink` çağrılır.
2. Parçayı önceki, sonraki (bellek tarafından) parçalarla birleştirin, herhangi biri boşsa ve bunu sırasız kovaya ekleyin. Eklerken, `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)` olup olmadığı kontrol edilir. Değilse, bir hata ("free(): corrupted unsorted chunks") oluşturulur.
8. Sonraki parça (bellek tarafından) en üst parça ise, parçaları uygun şekilde tek bir en üst parçaya birleştirin.
5. Eğer parça mmapped ise, `munmap_chunk` çağrılır.

## Hafıza İşlevleri Güvenlik Kontrolleri

Hafızada sıkça kullanılan işlevlerde gerçekleştirilen güvenlik kontrollerini kontrol edin:

{% content-ref url="heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-functions-security-checks.md)
{% endcontent-ref %}

## Referanslar

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
* [https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions](https://heap-exploitation.dhavalkapil.com/diving\_into\_glibc\_heap/core\_functions)
