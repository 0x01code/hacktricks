# ファーストフィット

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェック！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする**
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリにPRを提出する**

</details>

## **ファーストフィット**

glibcを使用してプログラム内のメモリを解放すると、異なる "bins" がメモリチャンクを管理するために使用されます。ここでは、2つの一般的なシナリオ、unsorted bins と fastbins の簡略化された説明があります。

### Unsorted Bins

高速チャンクでないメモリチャンクを解放すると、それはunsorted bin に移動します。このbin は、新しく解放されたチャンクが前方（"head"）に追加されるリストのように機能します。新しいメモリチャンクを要求すると、アロケータはunsorted bin を後方（"tail"）から見て、必要なサイズのチャンクを見つけます。unsorted bin のチャンクが必要なものよりも大きい場合、分割され、前半部分が返され、残りの部分がbin に残ります。

例:

* 300バイト (`a`) を割り当て、次に250バイト (`b`) を割り当て、`a` を解放してから再度250バイト (`c`) を要求します。
* `a` を解放すると、unsorted bin に移動します。
* その後250バイトを再度要求すると、アロケータはtail にある `a` を見つけて分割し、リクエストに合う部分を返し、残りをbin に保持します。
* `c` は以前の `a` を指し示し、`a` の内容で埋められます。
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbinsは小さなメモリチャンクに使用されます。Unsorted binsとは異なり、fastbinsは新しいチャンクを先頭に追加し、Last-In-First-Out（LIFO）の動作を作成します。メモリの小さなチャンクを要求すると、アロケータはfastbinの先頭から取得します。

例：

- 20バイトずつ4つのチャンク（`a`、`b`、`c`、`d`）を割り当てます。
- 任意の順序でそれらを解放すると、解放されたチャンクはfastbinの先頭に追加されます。
- その後、20バイトのチャンクを要求すると、アロケータはfastbinの先頭から最近解放されたチャンクを返します。
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## その他の参考文献と例

* [https://heap-exploitation.dhavalkapil.com/attacks/first\_fit](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64。Use after free: ユーザーオブジェクトを生成し、それを解放し、解放されたチャンクを取得するオブジェクトを生成し、それに書き込みを許可し、**以前のものからuser->passwordの位置を上書き**します。ユーザーを再利用して、**パスワードチェックをバイパス**します。
