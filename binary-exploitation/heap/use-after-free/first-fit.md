# First Fit

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## **First Fit**

Cuando liberas memoria en un programa que utiliza glibc, se utilizan diferentes "bins" para gestionar los fragmentos de memoria. Aqu칤 tienes una explicaci칩n simplificada de dos escenarios comunes: bins desordenados y fastbins.

### Bins Desordenados

Cuando liberas un fragmento de memoria que no es un fragmento r치pido, va al bin desordenado. Este bin act칰a como una lista donde se a침aden los nuevos fragmentos liberados al frente (la "cabeza"). Cuando solicitas un nuevo fragmento de memoria, el asignador mira el bin desordenado desde atr치s (la "cola") para encontrar un fragmento lo suficientemente grande. Si un fragmento del bin desordenado es m치s grande de lo que necesitas, se divide, devolviendo la parte delantera y manteniendo la parte restante en el bin.

Ejemplo:

* Asignas 300 bytes (`a`), luego 250 bytes (`b`), liberas `a` y solicitas de nuevo 250 bytes (`c`).
* Cuando liberas `a`, va al bin desordenado.
* Si luego solicitas 250 bytes de nuevo, el asignador encuentra `a` en la cola y lo divide, devolviendo la parte que se ajusta a tu solicitud y manteniendo el resto en el bin.
* `c` apuntar치 al `a` anterior y estar치 lleno con los datos de `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se utilizan para fragmentos de memoria peque침os. A diferencia de los contenedores no ordenados, los fastbins a침aden nuevos fragmentos al principio, creando un comportamiento de 칰ltimo en entrar, primero en salir (LIFO). Si solicitas un fragmento peque침o de memoria, el asignador tomar치 del principio del fastbin.

Ejemplo:

* Asignas cuatro fragmentos de 20 bytes cada uno (`a`, `b`, `c`, `d`).
* Cuando los liberas en cualquier orden, los fragmentos liberados se a침aden al principio del fastbin.
* Si luego solicitas un fragmento de 20 bytes, el asignador devolver치 el fragmento liberado m치s recientemente del principio del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Otras Referencias y Ejemplos

* [https://heap-exploitation.dhavalkapil.com/attacks/first\_fit](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Use after free: Generar un objeto de usuario, liberarlo, generar un objeto que obtiene el fragmento liberado y permite escribir en 칠l, **sobrescribiendo la posici칩n de la contrase침a de usuario** de la anterior. Reutilizar el usuario para **burlar la verificaci칩n de la contrase침a**
