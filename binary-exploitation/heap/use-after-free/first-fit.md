# Prva Fit

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## **Prva Fit**

Kada oslobađate memoriju u programu koristeći glibc, različite "kante" se koriste za upravljanje delovima memorije. Evo pojednostavljena objašnjenja dva uobičajena scenarija: nesortirane kante i brze kante.

### Nesortirane Kante

Kada oslobodite deo memorije koji nije brzi deo, on ide u nesortiranu kantu. Ova kanta deluje kao lista gde se novi oslobođeni delovi dodaju na početak („glavu“). Kada zatražite novi deo memorije, alokator gleda u nesortiranu kantu sa zadnje strane („rep“) kako bi pronašao deo koji je dovoljno velik. Ako je deo iz nesortirane kante veći od onoga što vam je potrebno, on se deli, pri čemu se vraća prednji deo i ostatak ostaje u kanti.

Primer:

* Alokujete 300 bajtova (`a`), zatim 250 bajtova (`b`), oslobodite `a` i zatim ponovo zatražite 250 bajtova (`c`).
* Kada oslobodite `a`, ide u nesortiranu kantu.
* Ako zatim ponovo zatražite 250 bajtova, alokator pronalazi `a` na repu i deli ga, vraćajući deo koji odgovara vašem zahtevu i zadržavajući ostatak u kanti.
* `c` će pokazivati na prethodni `a` i biti popunjen sa `a`-ima.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbins se koriste za male memorijske blokove. Za razliku od nesortiranih kanti, fastbins dodaju nove blokove na početak, stvarajući ponašanje poslednji unutra - prvi napolje (LIFO). Ako zatražite mali blok memorije, alokator će uzeti blok sa početka fastbina.

Primer:

* Alokujete četiri bloka od po 20 bajtova svaki (`a`, `b`, `c`, `d`).
* Kada ih oslobodite u bilo kom redosledu, oslobođeni blokovi se dodaju na početak fastbina.
* Ako zatim zatražite blok od 20 bajtova, alokator će vratiti najskorije oslobođeni blok sa početka fastbina.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Ostale reference i primeri

* [https://heap-exploitation.dhavalkapil.com/attacks/first\_fit](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Korišćenje nakon oslobađanja: Generisanje korisničkog objekta, oslobađanje istog, generisanje objekta koji dobija oslobođeni blok i omogućava pisanje u njega, **prepisivanje pozicije korisnikovog->šifra** iz prethodnog. Ponovno korišćenje korisnika da **zaobiđe proveru šifre**
