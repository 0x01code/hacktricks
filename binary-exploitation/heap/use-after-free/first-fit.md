# First Fit

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **First Fit**

Quando liberi la memoria in un programma utilizzando glibc, vengono utilizzati diversi "bin" per gestire i blocchi di memoria. Ecco una spiegazione semplificata di due scenari comuni: unsorted bins e fastbins.

### Unsorted Bins

Quando liberi un blocco di memoria che non √® un blocco veloce, va al bin non ordinato. Questo bin funziona come una lista in cui i nuovi blocchi liberati vengono aggiunti all'inizio (la "testa"). Quando richiedi un nuovo blocco di memoria, l'allocatore guarda il bin non ordinato dalla fine (la "coda") per trovare un blocco abbastanza grande. Se un blocco dal bin non ordinato √® pi√π grande di quanto necessiti, viene diviso, con la parte anteriore restituita e la parte rimanente che rimane nel bin.

Esempio:

* Alloci 300 byte (`a`), quindi 250 byte (`b`), liberi `a` e richiedi di nuovo 250 byte (`c`).
* Quando liberi `a`, va al bin non ordinato.
* Se successivamente richiedi di nuovo 250 byte, l'allocatore trova `a` in coda e lo divide, restituendo la parte che soddisfa la tua richiesta e mantenendo il resto nel bin.
* `c` punter√† al precedente `a` e sar√† riempito con i dati di `a`.
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

I fastbins sono utilizzati per piccoli blocchi di memoria. A differenza dei blocchi non ordinati, i fastbins aggiungono nuovi blocchi all'inizio, creando un comportamento di tipo ultimo ad entrare, primo ad uscire (LIFO). Se richiedi un piccolo blocco di memoria, l'allocatore prelever√† dalla testa del fastbin.

Esempio:

* Alloci quattro blocchi di 20 byte ciascuno (`a`, `b`, `c`, `d`).
* Quando li liberi in qualsiasi ordine, i blocchi liberati vengono aggiunti alla testa del fastbin.
* Se successivamente richiedi un blocco da 20 byte, l'allocatore restituir√† il blocco liberato pi√π di recente dalla testa del fastbin.
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## Altri riferimenti ed esempi

* [https://heap-exploitation.dhavalkapil.com/attacks/first\_fit](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64. Uso dopo la liberazione: Generare un oggetto utente, liberarlo, generare un oggetto che ottiene il pezzo liberato e consente di scriverci sopra, sovrascrivendo la posizione di user->password da quello precedente. Riutilizzare l'utente per aggirare il controllo della password
