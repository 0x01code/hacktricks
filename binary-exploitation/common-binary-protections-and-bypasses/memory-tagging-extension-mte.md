# Memory Tagging Extension (MTE)

{% hint style="success" %}
Lernen Sie und √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie und √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys einreichen.

</details>
{% endhint %}

## Grundlegende Informationen

**Memory Tagging Extension (MTE)** ist darauf ausgelegt, die Softwarezuverl√§ssigkeit und -sicherheit zu verbessern, indem **Speicherfehler erkannt und verhindert** werden, wie Puffer√ºberl√§ufe und Use-after-Free-Schwachstellen. MTE, als Teil der **ARM**-Architektur, bietet einen Mechanismus, um jedem Speicherbereich ein **kleines Tag anzuh√§ngen** und einem **entsprechenden Tag jeden Zeiger** zuzuweisen, der auf diesen Speicher verweist. Dieser Ansatz erm√∂glicht die Erkennung illegaler Speicherzugriffe zur Laufzeit und reduziert das Risiko, solche Schwachstellen zur Ausf√ºhrung beliebigen Codes auszunutzen erheblich.

### **Wie Memory Tagging Extension funktioniert**

MTE arbeitet, indem der Speicher in kleine, festgelegte Bl√∂cke unterteilt wird, wobei jedem Block ein Tag zugewiesen wird, das in der Regel einige Bits gro√ü ist.&#x20;

Wenn ein Zeiger erstellt wird, um auf diesen Speicher zu verweisen, erh√§lt er dasselbe Tag. Dieses Tag wird in den **unbenutzten Bits eines Speicherzeigers** gespeichert und verkn√ºpft den Zeiger effektiv mit seinem entsprechenden Speicherblock.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wenn ein Programm √ºber einen Zeiger auf den Speicher zugreift, √ºberpr√ºft die MTE-Hardware, ob das **Tag des Zeigers mit dem Tag des Speicherblocks √ºbereinstimmt**. Wenn die Tags **nicht √ºbereinstimmen**, deutet dies auf einen **illegalen Speicherzugriff hin**.

### MTE-Zeiger-Tags

Tags innerhalb eines Zeigers werden in 4 Bits im oberen Byte gespeichert:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Daher erm√∂glicht dies bis zu **16 verschiedene Tagwerte**.

### MTE-Speicher-Tags

Jede **16B physischen Speichers** haben ein entsprechendes **Speicher-Tag**.

Die Speicher-Tags werden in einem **dedizierten RAM-Bereich** gespeichert (nicht f√ºr den normalen Gebrauch zug√§nglich). Mit 4-Bit-Tags f√ºr jeden 16B-Speicher k√∂nnen bis zu 3% des RAMs verwendet werden.

ARM f√ºhrt die folgenden Anweisungen ein, um diese Tags im dedizierten RAM-Speicher zu manipulieren:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## √úberpr√ºfungsmodi

### Sync

Die CPU √ºberpr√ºft die Tags **w√§hrend der Ausf√ºhrung des Befehls**, und bei einer Nicht√ºbereinstimmung wird eine Ausnahme ausgel√∂st.\
Dies ist die langsamste und sicherste Methode.

### Async

Die CPU √ºberpr√ºft die Tags **asynchron**, und wenn eine Nicht√ºbereinstimmung gefunden wird, setzt sie ein Ausnahmebit in einem der Systemregister. Es ist **schneller** als die vorherige Methode, kann jedoch **nicht genau angeben**, welcher Befehl die Nicht√ºbereinstimmung verursacht hat, und l√∂st die Ausnahme nicht sofort aus, was dem Angreifer Zeit gibt, seinen Angriff abzuschlie√üen.

### Mixed

???

## Implementierungs- & Erkennungsbeispiele

Genannt Hardware-Tag-basiertes KASAN, MTE-basiertes KASAN oder In-Kernel MTE.\
Die Kernel-Allokatoren (wie `kmalloc`) werden **dieses Modul aufrufen**, das den Tag vorbereitet (zuf√§llig) an den allokierten Kernel-Speicher anh√§ngt und an den zur√ºckgegebenen Zeiger.

Beachten Sie, dass nur gen√ºgend Speichergranulate (je 16B) f√ºr die angeforderte Gr√∂√üe markiert werden. Wenn also eine Gr√∂√üe von 35 angefordert wurde und ein Block von 60B gegeben wurde, werden die ersten 16\*3 = 48B mit diesem Tag markiert und der **Rest** wird mit einem sogenannten **ung√ºltigen Tag (0xE)** markiert.

Der Tag **0xF** ist der **Match-All-Zeiger**. Ein Speicher mit diesem Zeiger erlaubt den Zugriff auf seinen Speicher mit **beliebigem Tag** (keine Nicht√ºbereinstimmungen). Dies k√∂nnte verhindern, dass MET einen Angriff erkennt, wenn dieser Tag im angegriffenen Speicher verwendet wird.

Daher gibt es nur **14 Werte**, die verwendet werden k√∂nnen, um Tags zu generieren, da 0xE und 0xF reserviert sind, was die Wahrscheinlichkeit des **Wiederverwendens von Tags** auf 1/17 -> etwa **7%** reduziert.

Wenn der Kernel auf das **ung√ºltige Tag-Granulat** zugreift, wird die **Nicht√ºbereinstimmung erkannt**. Wenn er auf eine andere Speicherstelle zugreift, wird die Nicht√ºbereinstimmung erkannt, wenn der **Speicher einen anderen Tag** (oder den ung√ºltigen Tag) hat. Wenn der Angreifer Gl√ºck hat und der Speicher den gleichen Tag verwendet, wird dies nicht erkannt. Die Chancen liegen bei etwa 7%.

Ein weiterer Fehler tritt im **letzten Granulat** des allokierten Speichers auf. Wenn die Anwendung 35B angefordert hat, wurde das Granulat von 32 bis 48 gegeben. Daher verwenden die **Bytes von 36 bis 47 den gleichen Tag**, obwohl sie nicht angefordert wurden. Wenn der Angreifer auf **diese zus√§tzlichen Bytes zugreift, wird dies nicht erkannt**.

Wenn **`kfree()`** ausgef√ºhrt wird, wird der Speicher mit dem ung√ºltigen Speicher-Tag versehen, sodass bei einem **Use-After-Free**, wenn der Speicher erneut zugegriffen wird, die **Nicht√ºbereinstimmung erkannt wird**.

Jedoch, bei einem Use-After-Free, wenn der gleiche **Block wieder mit dem SELBEN Tag** wie zuvor allokiert wird, kann ein Angreifer diesen Zugriff nutzen, ohne dass dies erkannt wird (ca. 7% Chance).

Au√üerdem verwenden nur **`slab` und `page_alloc`** markierten Speicher, aber in Zukunft wird dies auch bei `vmalloc`, `stack` und `globals` verwendet werden (zum Zeitpunkt des Videos k√∂nnen diese noch missbraucht werden).

Wenn eine **Nicht√ºbereinstimmung erkannt wird**, wird der Kernel **abst√ºrzen**, um eine weitere Ausnutzung und Wiederholungen des Exploits zu verhindern (MTE hat keine falschen Positiven).

## Referenzen

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
