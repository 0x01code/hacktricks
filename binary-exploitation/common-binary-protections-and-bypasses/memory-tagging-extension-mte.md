# Memory Tagging Extension (MTE)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

**Memory Tagging Extension (MTE)** ist darauf ausgelegt, die Softwarezuverl√§ssigkeit und -sicherheit zu verbessern, indem **Speicherfehler erkannt und verhindert** werden, wie Puffer√ºberl√§ufe und Use-after-Free-Schwachstellen. MTE, als Teil der **ARM**-Architektur, bietet einen Mechanismus, um jeder Speicherzuweisung ein **kleines Tag anzuh√§ngen** und einem **entsprechenden Tag f√ºr jeden Zeiger**, der auf diesen Speicher verweist. Dieser Ansatz erm√∂glicht die Erkennung illegaler Speicherzugriffe zur Laufzeit und reduziert das Risiko, solche Schwachstellen zur Ausf√ºhrung beliebigen Codes auszunutzen erheblich.

### **Wie Memory Tagging Extension funktioniert**

MTE arbeitet, indem der Speicher in kleine, festgelegte Bl√∂cke unterteilt wird, wobei jedem Block ein Tag zugewiesen wird, das in der Regel einige Bits gro√ü ist.&#x20;

Wenn ein Zeiger erstellt wird, um auf diesen Speicher zu verweisen, erh√§lt er dasselbe Tag. Dieses Tag wird in den **unbenutzten Bits eines Speicherzeigers** gespeichert und verkn√ºpft effektiv den Zeiger mit seinem entsprechenden Speicherblock.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Wenn ein Programm √ºber einen Zeiger auf den Speicher zugreift, √ºberpr√ºft die MTE-Hardware, ob das **Tag des Zeigers mit dem Tag des Speicherblocks √ºbereinstimmt**. Wenn die Tags **nicht √ºbereinstimmen**, deutet dies auf einen **illegalen Speicherzugriff hin**.

### MTE-Zeiger-Tags

Tags innerhalb eines Zeigers werden in 4 Bits im oberen Byte gespeichert:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Daher sind bis zu **16 verschiedene Tagwerte** m√∂glich.

### MTE-Speichertags

Jede **16B physischen Speichers** haben ein entsprechendes **Speichertag**.

Die Speichertags werden in einem **dedizierten RAM-Bereich** gespeichert (nicht f√ºr den normalen Gebrauch zug√§nglich). Mit 4-Bit-Tags f√ºr jeden 16B-Speichertag bis zu 3% des RAMs.

ARM f√ºhrt die folgenden Anweisungen ein, um diese Tags im dedizierten RAM-Speicher zu manipulieren:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## √úberpr√ºfungsmodi

### Sync

Die CPU √ºberpr√ºft die Tags **w√§hrend der Ausf√ºhrung des Befehls**, bei einer Nicht√ºbereinstimmung wird eine Ausnahme ausgel√∂st.\
Dies ist die langsamste und sicherste Methode.

### Async

Die CPU √ºberpr√ºft die Tags **asynchron**, und wenn eine Nicht√ºbereinstimmung gefunden wird, setzt sie ein Ausnahmebit in einem der Systemregister. Es ist **schneller** als die vorherige Methode, kann jedoch **nicht genau angeben**, welcher Befehl die Nicht√ºbereinstimmung verursacht hat, und l√∂st die Ausnahme nicht sofort aus, was dem Angreifer Zeit gibt, seinen Angriff abzuschlie√üen.

### Mixed

???

## Implementierungs- & Erkennungsbeispiele

Genannt Hardware-Tag-basiertes KASAN, MTE-basiertes KASAN oder In-Kernel MTE.\
Die Kernel-Allokatoren (wie `kmalloc`) werden **dieses Modul aufrufen**, das den Tag vorbereitet (zuf√§llig) an den allokierten Kernel-Speicher anh√§ngt und an den zur√ºckgegebenen Zeiger.

Beachten Sie, dass nur gen√ºgend Speichergranulate (je 16B) f√ºr die angeforderte Gr√∂√üe markiert werden. Wenn also eine Gr√∂√üe von 35 angefordert wurde und ein Block von 60B gegeben wurde, werden die ersten 16\*3 = 48B mit diesem Tag markiert und der **Rest** wird mit einem sogenannten **ung√ºltigen Tag (0xE)** markiert.

Der Tag **0xF** ist der **Match-All-Zeiger**. Ein Speicher mit diesem Zeiger erlaubt den Zugriff auf seinen Speicher mit **beliebigem Tag** (keine Nicht√ºbereinstimmungen). Dies k√∂nnte verhindern, dass MET einen Angriff erkennt, wenn dieser Tag im angegriffenen Speicher verwendet wird.

Daher gibt es nur **14 Werte**, die verwendet werden k√∂nnen, um Tags zu generieren, da 0xE und 0xF reserviert sind, was eine Wahrscheinlichkeit des **Wiederverwendens von Tags** von 1/17 ergibt -> etwa **7%**.

Wenn der Kernel auf das **ung√ºltige Tag-Granulat** zugreift, wird die **Nicht√ºbereinstimmung erkannt**. Wenn er auf eine andere Speicherstelle zugreift, wird die Nicht√ºbereinstimmung erkannt, wenn der **Speicher einen anderen Tag** hat (oder den ung√ºltigen Tag). Wenn der Angreifer Gl√ºck hat und der Speicher denselben Tag verwendet, wird dies nicht erkannt. Die Chancen liegen bei etwa 7%.

Ein weiterer Fehler tritt im **letzten Granulat** des allokierten Speichers auf. Wenn die Anwendung 35B angefordert hat, wurde das Granulat von 32 bis 48 gegeben. Daher verwenden die **Bytes von 36 bis 47 denselben Tag**, obwohl sie nicht angefordert wurden. Wenn der Angreifer auf **diese zus√§tzlichen Bytes zugreift, wird dies nicht erkannt**.

Wenn **`kfree()`** ausgef√ºhrt wird, wird der Speicher mit dem ung√ºltigen Speichertag versehen, sodass bei einem **Use-After-Free**, wenn der Speicher erneut zugegriffen wird, die **Nicht√ºbereinstimmung erkannt wird**.

Jedoch, bei einem Use-After-Free, wenn derselbe **Block erneut mit DEMSELBEN Tag** wie zuvor allokiert wird, kann ein Angreifer diesen Zugriff nutzen und dies wird nicht erkannt (ca. 7% Chance).

Au√üerdem verwenden nur **`slab` und `page_alloc`** markierten Speicher, aber in Zukunft wird dies auch bei `vmalloc`, `stack` und `globals` verwendet (zum Zeitpunkt des Videos k√∂nnen diese noch missbraucht werden).

Wenn eine **Nicht√ºbereinstimmung erkannt wird**, wird der Kernel **abst√ºrzen**, um eine weitere Ausnutzung und Wiederholungen des Exploits zu verhindern (MTE hat keine falschen Positiven).

## Referenzen

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
