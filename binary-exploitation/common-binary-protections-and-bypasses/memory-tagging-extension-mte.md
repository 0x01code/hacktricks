# Proširenje oznake memorije (MTE)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodiču PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

**Proširenje oznake memorije (MTE)** je dizajnirano da poboljša pouzdanost i sigurnost softvera **detektovanjem i sprečavanjem grešaka povezanih sa memorijom**, kao što su preplavljenje bafera i ranjivosti korišćenja nakon oslobađanja. MTE, kao deo **ARM** arhitekture, pruža mehanizam za povezivanje **male oznake sa svakom alokacijom memorije** i **odgovarajućom oznakom sa svakim pokazivačem** koji referiše na tu memoriju. Ovaj pristup omogućava detektovanje nelegalnih pristupa memoriji u toku izvršavanja, značajno smanjujući rizik od iskorišćavanja takvih ranjivosti za izvršavanje proizvoljnog koda.

### **Kako radi proširenje oznake memorije**

MTE funkcioniše tako što **deli memoriju na male blokove fiksne veličine, pri čemu se svakom bloku dodeljuje oznaka**, obično nekoliko bitova u veličini.&#x20;

Kada se kreira pokazivač koji pokazuje na tu memoriju, on dobija istu oznaku. Ova oznaka se čuva u **neiskorišćenim bitovima pokazivača memorije**, efikasno povezujući pokazivač sa odgovarajućim blokom memorije.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Kada program pristupa memoriji putem pokazivača, MTE hardver proverava da li **oznaka pokazivača odgovara oznaci bloka memorije**. Ako se oznake **ne poklapaju**, to ukazuje na **nelegalan pristup memoriji**.

### Oznake pokazivača MTE

Oznake unutar pokazivača se čuvaju u 4 bita unutar gornjeg bajta:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Stoga, ovo omogućava do **16 različitih vrednosti oznaka**.

### Oznake memorije MTE

Svaka **16B fizičke memorije** ima odgovarajuću **oznaku memorije**.

Oznake memorije se čuvaju u **dedikovanom RAM regionu** (nije dostupan za normalnu upotrebu). Imajući 4bitne oznake za svakih 16B oznaka memorije do 3% RAM-a.

ARM uvodi sledeće instrukcije za manipulisanje ovim oznakama u dedikovanom RAM memoriji:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Provera režima

### Sinkrono

CPU proverava oznake **tokom izvršavanja instrukcije**, ako postoji neslaganje, podiže izuzetak.\
Ovo je najsporije i najsigurnije.

### Asinkrono

CPU proverava oznake **asinkrono**, i kada se pronađe neslaganje, postavlja bit izuzetka u jedan od sistemskih registara. Brže je od prethodnog, ali **nije u mogućnosti da pokaže** tačnu instrukciju koja je uzrokovala neslaganje i ne podiže izuzetak odmah, pružajući vremena napadaču da završi svoj napad.

### Mešovito

???

## Primeri implementacije i detekcije

Nazvan Hardverski Tag-Based KASAN, MTE-based KASAN ili in-kernel MTE.\
Kernel alokatori (poput `kmalloc`) će **pozvati ovaj modul** koji će pripremiti oznaku za korišćenje (nasumično) i priložiti je na alocirani kernel prostor i na vraćeni pokazivač.

Imajte na umu da će označiti **samo dovoljno memorijskih granula** (svaka 16B) za traženu veličinu. Dakle, ako je tražena veličina bila 35 i dodeljen je slajb od 60B, označiće prvih 16\*3 = 48B ovom oznakom, a **ostatak** će biti **označen** tzv. **nevažećom oznakom (0xE)**.

Oznaka **0xF** je **poklapanje svih pokazivača**. Memorija sa ovim pokazivačem dozvoljava **bilo koju oznaku za pristup** svojoj memoriji (bez neslaganja). Ovo bi moglo sprečiti MET da otkrije napad ako se ove oznake koriste u napadnutoj memoriji.

Stoga postoji samo **14 vrednosti** koje se mogu koristiti za generisanje oznaka jer su 0xE i 0xF rezervisani, dajući verovatnoću **ponovne upotrebe oznaka** od 1/17 -> oko **7%**.

Ako kernel pristupi **nevažećoj memorijskoj granuli**, **neslaganje** će biti **detektovano**. Ako pristupi drugoj memorijskoj lokaciji, ako **memorija ima drugačiju oznaku** (ili nevažeću oznaku), neslaganje će biti **detektovano**. Ako napadač ima sreće i memorija koristi istu oznaku, neće biti detektovano. Verovatnoća je oko 7%.

Još jedan problem se javlja u **poslednjoj granuli** alocirane memorije. Ako je aplikacija zatražila 35B, dodeljena je granula od 32 do 48. Stoga, **bajtovi od 36 do 47 koriste istu oznaku** ali nisu bili traženi. Ako napadač pristupi **ovim dodatnim bajtovima, to neće biti detektovano**.

Kada se izvrši **`kfree()`**, memorija se ponovo označava nevažećom oznakom, tako da u **upotrebi nakon oslobađanja**, kada se memorija ponovo pristupi, **neslaganje se detektuje**.

Međutim, u upotrebi nakon oslobađanja, ako se isti **blok ponovo alocira sa ISTOM oznakom** kao prethodno, napadač će moći da koristi ovaj pristup i to neće biti detektovano (oko 7% šanse).

Osim toga, samo **`slab` i `page_alloc`** koriste označenu memoriju, ali u budućnosti će se ovo koristiti i u `vmalloc`, `stack` i `globals` (u trenutku videa ovo još uvek može biti zloupotrebljeno).

Kada se **detektuje neslaganje**, kernel će **paničiti** kako bi sprečio dalje iskorišćavanje i pokušaje eksploatacije (MTE nema lažnih pozitiva).

## Reference

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
