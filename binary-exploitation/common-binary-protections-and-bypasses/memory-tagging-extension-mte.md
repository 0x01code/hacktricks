# Επέκταση Επισήμανσης Μνήμης (MTE)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Η **Επέκταση Επισήμανσης Μνήμης (MTE)** σχεδιάστηκε για να βελτιώσει την αξιοπιστία και την ασφάλεια λογισμικού με το **ανίχνευση και πρόληψη σφαλμάτων σχετικών με τη μνήμη**, όπως η υπέρβαση buffer και οι ευπάθειες χρήσης μετά την απελευθέρωση. Η MTE, ως μέρος της αρχιτεκτονικής **ARM**, παρέχει ένα μηχανισμό για να συνδέσει ένα **μικρό ετικέτα σε κάθε δέσμευση μνήμης** και μια **αντίστοιχη ετικέτα σε κάθε δείκτη** που αναφέρεται σε αυτήν τη μνήμη. Αυτή η προσέγγιση επιτρέπει την ανίχνευση παράνομων προσβάσεων μνήμης κατά την εκτέλεση, μειώνοντας σημαντικά τον κίνδυνο εκμετάλλευσης τέτοιων ευπαθειών για την εκτέλεση αυθαίρετου κώδικα.

### **Πώς Λειτουργεί η Επέκταση Επισήμανσης Μνήμης**

Η MTE λειτουργεί με τον **διαχωρισμό της μνήμης σε μικρά, σταθερού μεγέθους τμήματα, με κάθε τμήμα να έχει ανατεθεί μια ετικέτα,** τυπικά μερικά bits σε μέγεθος.&#x20;

Όταν δημιουργείται ένας δείκτης για να δείχνει σε αυτήν τη μνήμη, λαμβάνει την ίδια ετικέτα. Αυτή η ετικέτα αποθηκεύεται στα **αχρησιμοποίητα bits ενός δείκτη μνήμης**, συνδέοντας αποτελεσματικά τον δείκτη με το αντίστοιχο τμήμα μνήμης.

<figure><img src="../../.gitbook/assets/image (1199).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Όταν ένα πρόγραμμα έχει πρόσβαση στη μνήμη μέσω ενός δείκτη, το υλικό MTE ελέγχει ότι η **ετικέτα του δείκτη ταιριάζει με την ετικέτα του τμήματος μνήμης**. Αν οι ετικέτες **δεν ταιριάζουν**, υποδηλώνει μια **παράνομη πρόσβαση στη μνήμη**.

### Ετικέτες Δεικτών MTE

Οι ετικέτες μέσα σε έναν δείκτη αποθηκεύονται σε 4 bits μέσα στο πάνω byte:

<figure><img src="../../.gitbook/assets/image (1200).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Επομένως, αυτό επιτρέπει έως και **16 διαφορετικές τιμές ετικετών**.

### Ετικέτες Μνήμης MTE

Κάθε **16Β φυσικής μνήμης** έχουν μια αντίστοιχη **ετικέτα μνήμης**.

Οι ετικέτες μνήμης αποθηκεύονται σε μια **αφιερωμένη περιοχή RAM** (μη προσβάσιμη για κανονική χρήση). Έχοντας ετικέτες 4 bits για κάθε 16Β ετικέτες μνήμης μέχρι 3% της RAM.

Η ARM εισάγει τις ακόλουθες οδηγίες για την επεξεργασία αυτών των ετικετών στην αφιερωμένη μνήμη RAM:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Έλεγχος Λειτουργιών

### Συγχρονισμένος

Η CPU ελέγχει τις ετικέτες **κατά την εκτέλεση της εντολής**, αν υπάρχει αναντιστοιχία, εκτοξεύει μια εξαίρεση.\
Αυτό είναι το πιο αργό και ασφαλές.

### Ασύγχρονος

Η CPU ελέγχει τις ετικέτες **ασύγχρονα**, και όταν βρεθεί μια αναντιστοιχία, ορίζει ένα bit εξαίρεσης σε ένα από τα καταχωρητές του συστήματος. Είναι **ταχύτερο** από το προηγούμενο αλλά **δεν μπορεί να εντοπίσει** ακριβώς την εντολή που προκάλεσε την αναντιστοιχία και δεν εκτοξεύει αμέσως την εξαίρεση, δίνοντας χρόνο στον επιτιθέμενο να ολοκληρώσει την επίθεσή του.

### Μικτός

???

## Υλοποίηση & Παραδείγματα Ανίχνευσης

Ονομάζεται Hardware Tag-Based KASAN, MTE-based KASAN ή in-kernel MTE.\
Οι διαχειριστές πυρήνα (όπως το `kmalloc`) θα **καλέσουν αυτή τη μονάδα** η οποία θα προετοιμάσει την ετικέτα που θα χρησιμοποιηθεί (τυχαία) για να την επισυνάψει στον χώρο πυρήνα που διατίθεται και στον επιστρεφόμενο δείκτη.

Σημειώστε ότι θα **επισημάνει μόνο αρκετά κομμάτια μνήμης** (16B το καθένα) για το ζητούμενο μέγεθος. Έτσι, αν το ζητούμενο μέγεθος ήταν 35 και δόθηκε ένα κομμάτι 60B, θα επισημάνει τα πρώτα 16\*3 = 48B με αυτή την ετικέτα και τα **υπόλοιπα** θα είναι **επισημασμένα** με μια τέτοια **μη έγκυρη ετικέτα (0xE)**.

Η ετικέτα **0xF** είναι το **αντιστοιχίζει όλους τους δείκτες**. Μια μνήμη με αυτόν το δείκτη επιτρέπει τη χρήση **οποιασδήποτε ετικέτας** για την πρόσβαση στη μνήμη της (χωρίς αναντιστοιχίες). Αυτό θα μπορούσε να αποτρέψει το MET από τον εντοπισμό μιας επίθεσης εάν αυτές οι ετικέτες χρησιμοποιούνται στη μνήμη που επιτίθεται.

Συνεπώς, υπάρχουν μόνο **14 τιμές** που μπορούν να χρησιμοποιηθούν για τη δημιουργία ετικετών καθώς τα 0xE και 0xF είναι κρατημένα, δίνοντας μια πιθανότητα **επαναχρησιμοποίησης ετικετών** 1/17 -> περίπου **7%**.

Εάν ο πυρήνας έχει πρόσβαση στο **κομμάτι μνήμης με τη μη έγκυρη ετικέτα**, η **αναντιστοιχία** θα **ανιχνευθεί**. Εάν έχει πρόσβαση σε άλλη τοποθεσία μνήμης, αν η **μνήμη έχει διαφορετική ετικέτα** (ή τη μη έγκυρη ετικέτα) η αναντιστοιχία θα **ανιχνευθεί**. Εάν ο επιτιθέμενος έχει την τύχη και η μνήμη χρησιμοποιεί την ίδια ετικέτα, δεν θα ανιχνευθεί. Οι πιθανότητες είναι περίπου 7%.

Μια άλλη αδυναμία συμβαίνει στο **τελευταίο κομμάτι** της εκχωρημένης μνήμης. Αν η εφαρμογή ζήτησε 35B, της δόθηκε το κομμάτι από 32 έως 48. Συνεπώς, τα **bytes από 36 έως 47 χρησιμοποιούν την ίδια ετικέτα** αλλά δεν ζητήθηκαν. Αν ο επιτιθέμενος έχει πρόσβαση **σε αυτά τα επιπλέον bytes, αυτό δεν ανιχνεύεται**.

Όταν εκτελείται το **`kfree()`**, η μνήμη επανασημαίνεται με τη μη έγκυρη ετικέτα μνήμης, έτσι σε ένα **use-after-free**, όταν η μνήμη έχει ξανά πρόσβαση, η **αναντιστοιχία ανιχνεύεται**.

Ωστόσο, σε ένα use-after-free, αν το ίδιο **κομμάτι επανεκχωρηθεί με ΤΗΝ ΙΔΙΑ ετικέτα** όπως προηγουμένως, ένας επιτιθέμενος θα μπορεί να χρησιμοποιήσει αυτήν την πρόσβαση και αυτό δεν θα ανιχνευθεί (περίπου 7% πιθανότητα).

Επιπλέον, μόνο οι **`slab` και `page_alloc`** χρησιμοποιούν ετικεταρισμένη μνήμη αλλά στο μέλλον αυτό θα χρησιμοποιηθεί επίσης σε `vmalloc`, `stack` και `globals` (στη στιγμή του βίντεο αυτά μπορούν ακόμα να καταχραστούνται).

Όταν ανιχνευθεί μια **αναντιστοιχία**, ο πυρήνας θα **πανικοβάλλει** για να αποτρέψει περαιτέρω εκμετάλλευση και επαναλήψεις της εκμετάλλευσης (το MTE δεν έχει Ϩενικά θετικά).

## Αναφορές

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
