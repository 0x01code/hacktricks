# Estensione del Tagging della Memoria (MTE)

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di Base

Il **Memory Tagging Extension (MTE)** √® progettato per migliorare l'affidabilit√† e la sicurezza del software **rilevando e prevenendo errori legati alla memoria**, come buffer overflow e vulnerabilit√† di uso dopo la liberazione. MTE, come parte dell'architettura **ARM**, fornisce un meccanismo per allegare un **piccolo tag ad ogni allocazione di memoria** e un **tag corrispondente ad ogni puntatore** che fa riferimento a quella memoria. Questo approccio consente di rilevare gli accessi illegali alla memoria durante l'esecuzione, riducendo significativamente il rischio di sfruttare tali vulnerabilit√† per eseguire codice arbitrario.

### **Come Funziona l'Estensione del Tagging della Memoria**

MTE opera **dividendo la memoria in blocchi di dimensioni fisse, con ciascun blocco assegnato un tag,** tipicamente di pochi bit di dimensione.&#x20;

Quando viene creato un puntatore per puntare a quella memoria, ottiene lo stesso tag. Questo tag √® memorizzato nei **bit non utilizzati di un puntatore di memoria**, collegando efficacemente il puntatore al suo blocco di memoria corrispondente.

<figure><img src="../../.gitbook/assets/image (1202).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Quando un programma accede alla memoria attraverso un puntatore, l'hardware MTE controlla che il **tag del puntatore corrisponda al tag del blocco di memoria**. Se i tag **non corrispondono**, indica un **accesso illegale alla memoria.**

### Tag dei Puntatori MTE

I tag all'interno di un puntatore sono memorizzati in 4 bit all'interno del byte superiore:

<figure><img src="../../.gitbook/assets/image (1203).png" alt=""><figcaption><p><a href="https://www.youtube.com/watch?v=UwMt0e_dC_Q">https://www.youtube.com/watch?v=UwMt0e_dC_Q</a></p></figcaption></figure>

Pertanto, ci√≤ consente fino a **16 diversi valori di tag**.

### Tag della Memoria MTE

Ogni **16B di memoria fisica** ha un **tag di memoria corrispondente**.

I tag di memoria sono memorizzati in una **regione RAM dedicata** (non accessibile per un uso normale). Avendo tag di 4 bit per ogni 16B di tag di memoria fino al 3% di RAM.

ARM introduce le seguenti istruzioni per manipolare questi tag nella memoria RAM dedicata:
```
STG [<Xn/SP>], #<simm>    Store Allocation (memory) Tag
LDG <Xt>, [<Xn/SP>]       Load Allocatoin (memory) Tag
IRG <Xd/SP>, <Xn/SP>      Insert Random [pointer] Tag
...
```
## Modalit√† di controllo

### Sync

La CPU controlla i tag **durante l'esecuzione dell'istruzione**, se c'√® una discrepanza, genera un'eccezione.\
Questa √® la pi√π lenta e sicura.

### Async

La CPU controlla i tag **in modo asincrono**, e quando trova una discrepanza imposta un bit di eccezione in uno dei registri di sistema. √à **pi√π veloce** della precedente ma non √® in grado di indicare l'istruzione esatta che ha causato la discrepanza e non genera immediatamente l'eccezione, dando del tempo all'attaccante per completare il suo attacco.

### Misto

???

## Esempi di Implementazione e Rilevamento

Chiamato KASAN basato su tag hardware, KASAN basato su MTE o MTE nel kernel.\
Gli allocatori del kernel (come `kmalloc`) **chiameranno questo modulo** che preparer√† il tag da utilizzare (casualmente) lo attaccher√† allo spazio kernel allocato e al puntatore restituito.

Si noti che verranno **contrassegnati solo abbastanza granuli di memoria** (16B ciascuno) per la dimensione richiesta. Quindi se la dimensione richiesta era 35 e veniva dato uno slab di 60B, verranno contrassegnati i primi 16\*3 = 48B con questo tag e il **resto** verr√† **contrassegnato** con un cosiddetto **tag non valido (0xE)**.

Il tag **0xF** √® il **puntatore di corrispondenza totale**. Una memoria con questo puntatore consente **l'uso di qualsiasi tag** per accedere alla sua memoria (nessuna discrepanza). Questo potrebbe impedire a MET di rilevare un attacco se questo tag viene utilizzato nella memoria attaccata.

Pertanto ci sono solo **14 valori** che possono essere utilizzati per generare tag poich√© 0xE e 0xF sono riservati, dando una probabilit√† di **riutilizzo dei tag** pari a 1/17 -> circa **7%**.

Se il kernel accede al **granulo di tag non valido**, la **discrepanza** verr√† **rilevata**. Se accede a un'altra posizione di memoria, se la **memoria ha un tag diverso** (o il tag non valido) la discrepanza verr√† **rilevata**. Se l'attaccante ha fortuna e la memoria utilizza lo stesso tag, non verr√† rilevata. Le probabilit√† sono circa del 7%.

Un altro bug si verifica nell'**ultimo granulo** della memoria allocata. Se l'applicazione ha richiesto 35B, le √® stato dato il granulo dal 32 al 48. Pertanto, i **byte dal 36 al 47 utilizzano lo stesso tag** ma non sono stati richiesti. Se l'attaccante accede a **questi byte extra, ci√≤ non viene rilevato**.

Quando viene eseguito **`kfree()`**, la memoria viene contrassegnata nuovamente con il tag di memoria non valido, quindi in un **uso dopo la liberazione**, quando la memoria viene nuovamente accessa, la **discrepanza viene rilevata**.

Tuttavia, in un uso dopo la liberazione, se lo stesso **blocco viene riallocato nuovamente con lo STESSO tag** come precedentemente, un attaccante potr√† utilizzare questo accesso e ci√≤ non verr√† rilevato (circa il 7% di probabilit√†).

Inoltre, solo **`slab` e `page_alloc`** utilizzano la memoria contrassegnata ma in futuro questo verr√† utilizzato anche in `vmalloc`, `stack` e `globals` (al momento del video questi possono ancora essere abusati).

Quando viene rilevata una **discrepanza**, il kernel **va in panico** per impedire ulteriori sfruttamenti e tentativi dell'exploit (MTE non ha falsi positivi).

## Riferimenti

* [https://www.youtube.com/watch?v=UwMt0e\_dC\_Q](https://www.youtube.com/watch?v=UwMt0e\_dC\_Q)
