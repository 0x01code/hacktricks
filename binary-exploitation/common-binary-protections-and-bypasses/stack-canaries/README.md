# Stack Canaries

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**

*Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do* [**HackTricks**](https://github.com/carlospolop/hacktricks) *e* [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **StackGuard e StackShield**

**StackGuard** insere um valor especial conhecido como **canary** antes do **EIP (Extended Instruction Pointer)**, especificamente `0x000aff0d` (representando nulo, nova linha, EOF, retorno de carro) para proteger contra estouros de buffer. No entanto, fun√ß√µes como `recv()`, `memcpy()`, `read()` e `bcopy()` permanecem vulner√°veis, e n√£o protege o **EBP (Base Pointer)**.

**StackShield** adota uma abordagem mais sofisticada do que o StackGuard, mantendo uma **Global Return Stack**, que armazena todos os endere√ßos de retorno (**EIPs**). Essa configura√ß√£o garante que qualquer estouro n√£o cause danos, pois permite a compara√ß√£o entre os endere√ßos de retorno armazenados e reais para detectar ocorr√™ncias de estouro. Al√©m disso, o StackShield pode verificar o endere√ßo de retorno em rela√ß√£o a um valor de limite para detectar se o **EIP** aponta para fora do espa√ßo de dados esperado. No entanto, essa prote√ß√£o pode ser contornada por t√©cnicas como Return-to-libc, ROP (Return-Oriented Programming) ou ret2ret, indicando que o StackShield tamb√©m n√£o protege vari√°veis locais.

## **Protetor de Stack Smash (ProPolice) `-fstack-protector`:**

Esse mecanismo coloca um **canary** antes do **EBP** e reorganiza as vari√°veis locais para posicionar buffers em endere√ßos de mem√≥ria mais altos, impedindo que eles sobrescrevam outras vari√°veis. Ele tamb√©m copia com seguran√ßa os argumentos passados na pilha acima das vari√°veis locais e usa essas c√≥pias como argumentos. No entanto, n√£o protege arrays com menos de 8 elementos ou buffers dentro de uma estrutura do usu√°rio.

O **canary** √© um n√∫mero aleat√≥rio derivado de `/dev/urandom` ou um valor padr√£o de `0xff0a0000`. Ele √© armazenado no **TLS (Thread Local Storage)**, permitindo que espa√ßos de mem√≥ria compartilhados entre threads tenham vari√°veis globais ou est√°ticas espec√≠ficas da thread. Essas vari√°veis s√£o inicialmente copiadas do processo pai, e os processos filhos podem alterar seus dados sem afetar o pai ou irm√£os. No entanto, se um **`fork()`** √© usado sem criar um novo canary, todos os processos (pai e filhos) compartilham o mesmo canary, tornando-o vulner√°vel. Na arquitetura **i386**, o canary √© armazenado em `gs:0x14`, e no **x86\_64**, em `fs:0x28`.

Essa prote√ß√£o local identifica fun√ß√µes com buffers vulner√°veis a ataques e injeta c√≥digo no in√≠cio dessas fun√ß√µes para colocar o canary e no final para verificar sua integridade.

Quando um servidor web usa `fork()`, ele permite um ataque de for√ßa bruta para adivinhar o byte do canary por byte. No entanto, usar `execve()` ap√≥s `fork()` sobrescreve o espa√ßo de mem√≥ria, anulando o ataque. `vfork()` permite que o processo filho execute sem duplica√ß√£o at√© tentar escrever, momento em que uma duplicata √© criada, oferecendo uma abordagem diferente para a cria√ß√£o de processos e manipula√ß√£o de mem√≥ria.

### Comprimentos

Em bin√°rios `x64`, o cookie do canary √© um qword de **`0x8`** bytes. Os **sete primeiros bytes s√£o aleat√≥rios** e o √∫ltimo byte √© um **byte nulo**.

Em bin√°rios `x86`, o cookie do canary √© um dword de **`0x4`** bytes. Os **tr√™s primeiros bytes s√£o aleat√≥rios** e o √∫ltimo byte √© um **byte nulo**.

{% hint style="danger" %}
O byte menos significativo de ambos os canaries √© um byte nulo porque ser√° o primeiro na pilha vindo de endere√ßos mais baixos e, portanto, **fun√ß√µes que leem strings ir√£o parar antes de l√™-lo**.
{% endhint %}

## Bypasses

**Vazando o canary** e ent√£o sobrescrevendo-o (por exemplo, estouro de buffer) com seu pr√≥prio valor.

* Se o **canary for bifurcado em processos filhos**, pode ser poss√≠vel **for√ß√°-lo** um byte de cada vez:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Se houver alguma **vulnerabilidade de vazamento ou leitura arbitr√°ria interessante** no bin√°rio, pode ser poss√≠vel vazar:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Sobrescrevendo ponteiros armazenados na pilha**

A pilha vulner√°vel a um estouro de pilha pode **conter endere√ßos de strings ou fun√ß√µes que podem ser sobrescritos** para explorar a vulnerabilidade sem precisar alcan√ßar o canary da pilha. Verifique:

{% content-ref url="../../stack-overflow/pointer-redirecting.md" %}
[pointer-redirecting.md](../../stack-overflow/pointer-redirecting.md)
{% endcontent-ref %}

* **Modificando tanto o canary mestre quanto o da thread**

Um **estouro de buffer em uma fun√ß√£o com thread** protegida com canary pode ser usado para **modificar o canary mestre da thread**. Como resultado, a mitiga√ß√£o √© in√∫til porque a verifica√ß√£o √© feita com dois canaries que s√£o iguais (embora modificados).

Este ataque √© realizado no writeup: [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)

* **Modificar a entrada GOT de `__stack_chk_fail`**

Se o bin√°rio tiver Partial RELRO, ent√£o voc√™ pode usar uma escrita arbitr√°ria para modificar a **entrada GOT de `__stack_chk_fail`** para ser uma fun√ß√£o fict√≠cia que n√£o bloqueia o programa se o canary for modificado.

Este ataque √© realizado no writeup: [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)

## Refer√™ncias

* [https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html](https://guyinatuxedo.github.io/7.1-mitigation\_canary/index.html)
* [http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads](http://7rocky.github.io/en/ctf/htb-challenges/pwn/robot-factory/#canaries-and-threads)
* [https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/](https://7rocky.github.io/en/ctf/other/securinets-ctf/scrambler/)
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.
