# Κανάρια Στοίβας

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## **StackGuard και StackShield**

Το **StackGuard** εισάγει μια ειδική τιμή γνωστή ως **κανάριο** πριν από το **EIP (Επεκτεινόμενο Δείκτη Εντολών)**, συγκεκριμένα `0x000aff0d` (που αντιπροσωπεύει το null, τη νέα γραμμή, το EOF, την αλλαγή γραμμής) για προστασία από υπερχείλιση buffer. Ωστόσο, λειτουργίες όπως `recv()`, `memcpy()`, `read()` και `bcopy()` παραμένουν ευάλωτες, και δεν προστατεύει το **EBP (Βασικό Δείκτη)**.

Το **StackShield** ακολουθεί μια πιο εξελιγμένη προσέγγιση από το StackGuard διατηρώντας ένα **Καθολικό Στοίβα Επιστροφής**, το οποίο αποθηκεύει όλες τις διευθύνσεις επιστροφής (**EIPs**). Αυτή η ρύθμιση εξασφαλίζει ότι οποιαδήποτε υπερχείλιση δεν προκαλεί ζημιά, καθώς επιτρέπει τη σύγκριση μεταξύ αποθηκευμένων και πραγματικών διευθύνσεων επιστροφής για την ανίχνευση εμφανίσεων υπερχείλισης. Επιπλέον, το StackShield μπορεί να ελέγξει τη διεύθυνση επιστροφής έναντι μιας τιμής ορίου για να ανιχνεύσει αν η **EIP** δείχνει έξω από τον αναμενόμενο χώρο δεδομένων. Ωστόσο, αυτή η προστασία μπορεί να παρακαμφθεί μέσω τεχνικών όπως Return-to-libc, ROP (Return-Oriented Programming) ή ret2ret, υποδεικνύοντας ότι το StackShield επίσης δεν προστατεύει τοπικές μεταβλητές.

## **Προστάτης Καταπονήσεων Στοίβας (ProPolice) `-fstack-protector`:**

Αυτός ο μηχανισμός τοποθετεί ένα **κανάριο** πριν από το **EBP**, και αναδιατάσσει τις τοπικές μεταβλητές για να τοποθετήσει τα buffers σε υψηλότερες διευθύνσεις μνήμης, αποτρέποντας την υπεργραφή άλλων μεταβλητών. Επίσης, αντιγράφει με ασφάλεια τα ορίσματα που περνιούνται στη στοίβα πάνω από τις τοπικές μεταβλητές και χρησιμοποιεί αυτές τις αντιγραφές ως ορίσματα. Ωστόσο, δεν προστατεύει πίνακες με λιγότερα από 8 στοιχεία ή buffers μέσα σε δομή χρήστη.

Το **κανάριο** είναι ένας τυχαίος αριθμός που προέρχεται από το `/dev/urandom` ή μια προεπιλεγμένη τιμή του `0xff0a0000`. Αποθηκεύεται στο **TLS (Αποθήκευση Τοπικών Νημάτων)**, επιτρέποντας κοινόχρηστους χώρους μνήμης ανάμεσα σε νήματα να έχουν μεταβλητές παγκόσμιες ή στατικές μεταβλητές νήματος. Αυτές οι μεταβλητές αντιγράφονται αρχικά από τη διεργασία γονέα, και οι διεργασίες παιδιά μπορούν να τροποποιήσουν τα δεδομένα τους χωρίς να επηρεάζουν το γονέα ή τα αδέλφια. Ωστόσο, αν χρησιμοποιηθεί ένα **`fork()` χωρίς τη δημιουργία ενός νέου καναριού, όλες οι διεργασίες (γονέας και παιδιά) μοιράζονται το ίδιο κανάρι**, καθιστώντας το ευάλωτο. Στην αρχιτεκτονική **i386**, το κανάρι αποθηκεύεται στο `gs:0x14`, και στο **x86\_64**, στο `fs:0x28`.

Αυτή η τοπική προστασία αναγνωρίζει λειτουργίες με buffers ευάλωτους σε επιθέσεις και ενθέτει κώδικα στην αρχή αυτών των λειτουργιών για να τοποθετήσει το κανάρι, και στο τέλος για να επαληθεύσει την ακεραιότητά του.

Όταν ένας διακομιστής web χρησιμοποιεί το `fork()`, ενεργοποιεί μια επίθεση δοκιμής με βία για να μαντέψει το κανάρι byte με byte. Ωστόσο, χρησιμοποιώντας το `execve()` μετά το `fork()` αντικαθιστά τον χώρο μνήμης, αναιρώντας την επίθεση. Το `vfork()` επιτρέπει στη διεργασία παιδί να εκτελείται χωρίς αντιγραφή μέχρι να προσπαθήσει να γράψει, στο σημείο που δημιουργείται ένα αντίγραφο, προσφέροντας μια διαφορετική προσέγγιση στη δημιουργία διεργασίας και στη διαχείριση μνήμης.

### Μήκη

Σε δυαδικά `x64`, το κανάρι cookie είναι ένα **`0x8`** byte qword. Τα **πρώτα επτά bytes είναι τυχαία** και το τελευταίο byte είναι ένα **null byte**.

Σε δυαδικά `x86`, το κανάρι cookie είναι ένα **`0x4`** byte dword. Τα **πρώτα τρία bytes είναι τυχαία** και το τελευταίο byte είναι ένα **null byte**.

{% hint style="danger" %}
Το λιγότερο σημαντικό byte και των δύο καναριών είναι ένα null byte επειδή θα είναι το πρώτο στη στοίβα προερχόμενο από χαμηλότερες διευθύνσεις και επομένως **οι λειτουργίες που διαβάζουν συμβολοσειρές θα σταματήσουν πριν το διαβάσουν**.
{% endhint %}

## Παρακάμψεις

**Διαρροή του καναριού** και στη συνέχεια υπεργραφή του (π.χ. υπερχείλιση buffer) με τη δική του τιμή.

* Αν το **κανάρι δημιουργείται σε παιδικές διεργασίες** είναι δυνατό να **επιτεθείτε με βία** ένα byte κάθε φορά:

{% content-ref url="bf-forked-stack-canaries.md" %}
[bf-forked-stack-canaries.md](bf-forked-stack-canaries.md)
{% endcontent-ref %}

* Αν υπάρχει κάποια ενδιαφέρουσα **διαρροή ή αυθαίρετη ανάγνωση ευπαθειών** στο δυαδικό μπορεί να είναι δυνατή η διαρροή του:

{% content-ref url="print-stack-canary.md" %}
[print-stack-canary.md](print-stack-canary.md)
{% endcontent-ref %}

* **Υπεργραφή δεικτών αποθηκευμένων στη στοίβα**

Η στοίβα που είναι ευάλωτη σε υπερχείλιση στοίβας μπορεί να **περιέ
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
