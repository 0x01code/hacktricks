# Relro

{% hint style="success" %}
Impara e pratica l'Hacking su AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Impara e pratica l'Hacking su GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Sostieni HackTricks</summary>

* Controlla i [**piani di abbonamento**](https://github.com/sponsors/carlospolop)!
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Relro

**RELRO** sta per **Relocation Read-Only**, ed √® una funzionalit√† di sicurezza utilizzata nei binari per mitigare i rischi associati agli sovrascritture della **GOT (Global Offset Table)**. Vediamo i due tipi distinti di questa funzionalit√† per chiarezza: **Partial RELRO** e **Full RELRO**.

### **Partial RELRO**

**Partial RELRO** adotta un approccio pi√π semplice per migliorare la sicurezza senza influire significativamente sulle prestazioni del binario. Posizionando la GOT sopra le variabili del programma in memoria, Partial RELRO mira a prevenire che gli overflow di buffer raggiungano e corrompano la GOT.

Questo **non impedisce** che la GOT sia abusata **da vulnerabilit√† di scrittura arbitraria**.

### **Full RELRO**

**Full RELRO** aumenta la protezione rendendo la GOT e la sezione .fini\_array completamente **di sola lettura**. Una volta che il binario inizia, tutti gli indirizzi delle funzioni vengono risolti e caricati nella GOT, quindi la GOT viene contrassegnata come di sola lettura, impedendo efficacemente qualsiasi modifica ad essa durante l'esecuzione.

Tuttavia, il compromesso con Full RELRO riguarda le prestazioni e il tempo di avvio. Poich√© √® necessario risolvere tutti i simboli dinamici all'avvio prima di contrassegnare la GOT come di sola lettura, i **binari con Full RELRO abilitato potrebbero avere tempi di caricamento pi√π lunghi**. Questo sovraccarico aggiuntivo all'avvio √® il motivo per cui Full RELRO non √® abilitato per impostazione predefinita in tutti i binari.

√à possibile verificare se Full RELRO √® **abilitato** in un binario con:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
## Bypass

Se Full RELRO √® abilitato, l'unico modo per evitarlo √® trovare un altro modo che non richieda di scrivere nella tabella GOT per ottenere l'esecuzione arbitraria.

Si noti che **la GOT di LIBC di solito √® Partial RELRO**, quindi pu√≤ essere modificata con una scrittura arbitraria. Ulteriori informazioni in [Targetting libc GOT entries](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries)**.**
