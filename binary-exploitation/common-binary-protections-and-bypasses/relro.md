# Relro

{% hint style="success" %}
Ucz się i praktykuj Hacking AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Ucz się i praktykuj Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Dziel się trikami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na githubie.

</details>
{% endhint %}

## Relro

**RELRO** oznacza **Relocation Read-Only** i jest funkcją zabezpieczeń stosowaną w plikach binarnych w celu zmniejszenia ryzyka związanego z nadpisywaniem **GOT (Global Offset Table)**. Rozbijmy ten koncept na dwa różne typy dla jasności: **Częściowy RELRO** i **Pełny RELRO**.

### **Częściowy RELRO**

**Częściowy RELRO** stosuje prostsze podejście do zwiększenia bezpieczeństwa bez znacznego wpływu na wydajność binarnego pliku. Poprzez **umieszczenie GOT powyżej zmiennych programu w pamięci, Częściowy RELRO ma na celu zapobieganie dotarciu i uszkodzeniu GOT przez przepełnienie bufora**.&#x20;

To **nie zapobiega nadużywaniu GOT** z **ran** podatności.

### **Pełny RELRO**

**Pełny RELRO** podnosi ochronę poprzez **czynienie GOT i sekcji .fini\_array** całkowicie **tylko do odczytu.** Gdy binarny plik zaczyna działać, wszystkie adresy funkcji są rozwiązane i załadowane do GOT, a następnie GOT jest oznaczane jako tylko do odczytu, efektywnie uniemożliwiając jakiekolwiek modyfikacje podczas działania.

Jednakże, w przypadku Pełnego RELRO, kompromis dotyczy wydajności i czasu uruchamiania. Ponieważ należy rozwiązać wszystkie symbole dynamiczne podczas uruchamiania przed oznaczeniem GOT jako tylko do odczytu, **binarne pliki z włączonym Pełnym RELRO mogą doświadczyć dłuższych czasów ładowania**. Dodatkowe obciążenie podczas uruchamiania to powód, dla którego Pełny RELRO nie jest domyślnie włączony we wszystkich binarnych plikach.

Można sprawdzić, czy Pełny RELRO jest **włączony** w binarnym pliku za pomocą:
```bash
readelf -l /proc/ID_PROC/exe | grep BIND_NOW
```
## Ominięcie

Jeśli pełne RELRO jest włączone, jedynym sposobem na jego ominięcie jest znalezienie innej drogi, która nie wymaga zapisu do tabeli GOT, aby uzyskać dowolne wykonanie.

Zauważ, że **GOT LIBC jest zazwyczaj częściowo RELRO**, więc może być zmodyfikowany za pomocą dowolnego zapisu. Więcej informacji w [Targetting libc GOT entries](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries)**.**
