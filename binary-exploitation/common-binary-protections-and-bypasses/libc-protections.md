# Zaštita libc biblioteke

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Prinudno poravnanje delova

**Malloc** dodeljuje memoriju u grupama od **8 bajtova (32-bitni) ili 16 bajtova (64-bitni)**. To znači da bi kraj delova u 32-bitnim sistemima trebalo da se poravna sa **0x8**, a u 64-bitnim sistemima sa **0x0**. Bezbednosna funkcija proverava da li se svaki deo **pravilno poravna** na ovim specifičnim lokacijama pre korišćenja pokazivača iz bin-a.

### Bezbednosne prednosti

Prinudno poravnanje delova u 64-bitnim sistemima značajno poboljšava bezbednost Malloc-a tako što **ograničava postavljanje lažnih delova na samo 1 od svakih 16 adresa**. Ovo otežava napore za eksploataciju, posebno u scenarijima gde korisnik ima ograničenu kontrolu nad ulaznim vrednostima, čineći napade složenijim i težim za uspešno izvršavanje.

* **Napad na Fastbin preko \_\_malloc\_hook**

Nove pravila poravnanja u Malloc-u takođe sprečavaju klasičan napad koji uključuje `__malloc_hook`. Prethodno, napadači su mogli manipulisati veličinom dela da bi **prepisali ovaj pokazivač funkcije** i stekli **izvršavanje koda**. Sada, stroga zahtevnost poravnanja osigurava da takve manipulacije više nisu izvodljive, zatvarajući uobičajenu rutu eksploatacije i poboljšavajući ukupnu bezbednost.

## Mutilacija pokazivača na fastbin-ovima i tcache-u

**Mutilacija pokazivača** je bezbednosno unapređenje koje se koristi za zaštitu **fastbin i tcache Fd pokazivača** u operacijama upravljanja memorijom. Ova tehnika pomaže u sprečavanju određenih vrsta taktika eksploatacije memorije, posebno onih koje ne zahtevaju procurele informacije o memoriji ili koje direktno manipulišu lokacijama memorije u odnosu na poznate pozicije (relativno **prepisivanje**).

Srce ove tehnike je formula za zamagljivanje:

**`Novi_Ptr = (L >> 12) XOR P`**

* **L** je **Lokacija Skladištenja** pokazivača.
* **P** je stvarni **fastbin/tcache Fd Pokazivač**.

Razlog za bitovno pomeranje lokacije skladištenja (L) za 12 bitova udesno pre XOR operacije je ključan. Ova manipulacija rešava ranjivost inherentnu u determinističkoj prirodi najmanje značajnih 12 bitova adresa memorije, koji su obično predvidljivi zbog ograničenja arhitekture sistema. Pomeranjem bitova, predvidljivi deo se izbacuje iz jednačine, poboljšavajući nasumičnost novog, mutiliranog pokazivača i time štiteći se od eksploatacija koje se oslanjaju na predvidljivost ovih bitova.

Ovaj mutilirani pokazivač koristi postojeću nasumičnost koju pruža **Randomizacija Izgleda Adresnog Prostora (ASLR)**, koja nasumično raspoređuje adrese koje koriste programi kako bi otežala napadačima da predvide raspored memorije procesa.

**Demutilacija** pokazivača radi povratka originalne adrese uključuje korišćenje iste XOR operacije. Ovde se mutilirani pokazivač tretira kao P u formuli, i kada se XOR-uje sa nepromenjenom lokacijom skladištenja (L), rezultira otkrivanjem originalnog pokazivača. Ova simetrija u mutilaciji i demutilaciji osigurava da sistem može efikasno enkodirati i dekodirati pokazivače bez značajnog opterećenja, dok istovremeno značajno povećava bezbednost protiv napada koji manipulišu pokazivačima memorije.

### Bezbednosne prednosti

Mutilacija pokazivača ima za cilj da **spreči delimično i potpuno prepisivanje pokazivača u heap** upravljanju, što je značajno unapređenje u bezbednosti. Ova funkcija utiče na tehnike eksploatacije na nekoliko načina:

1. **Sprečavanje Prepisivanja Relativnih Bajtova**: Prethodno, napadači su mogli promeniti deo pokazivača da bi **preusmerili delove heap-a na različite lokacije bez poznavanja tačnih adresa**, tehnika vidljiva u eksploataciji **House of Roman** bez procurele informacije. Sa mutilacijom pokazivača, takva relativna prepisivanja **bez procurele heap-a sada zahtevaju grubu silu**, značajno smanjujući verovatnoću uspeha.
2. **Povećana Težina Napada na Tcache Bin/Fastbin**: Uobičajeni napadi koji prepisuju pokazivače funkcija (poput `__malloc_hook`) manipulacijom unosa fastbin-a ili tcache-a su otežani. Na primer, napad može uključivati procurelu LibC adrese, oslobađanje dela u tcache bin, a zatim prepisivanje Fd pokazivača da bi ga preusmerio na `__malloc_hook` za izvršavanje proizvoljnog koda. Sa mutilacijom pokazivača, ovi pokazivači moraju biti pravilno mutilirani, **zahtevajući procurelu heap-a za tačnu manipulaciju**, čime se podiže barijera eksploatacije.
3. **Potreba za Procurenim Heap Adresama na Ne-Heap Lokacijama**: Kreiranje lažnog dela na ne-heap lokacijama (kao što su stek, .bss sekcija ili PLT/GOT) sada takođe **zahteva procurelu heap-a** zbog potrebe za mutilacijom pokazivača. Ovo povećava složenost eksploatisanja ovih oblasti, slično zahtevu za manipulisanjem LibC adresa.
4. **Procurenje Adresa Heap-a Postaje Izazovnije**: Mutilacija pokazivača ograničava korisnost Fd pokazivača u fastbin i tcache bin-ovima kao izvora za procurene adrese heap-a. Međutim, pokazivači u nesortiranim, malim i velikim bin-ovima ostaju nemutilirani, i dalje korisni za procurene adrese. Ova promena tera napadače da istraže ove bin-ove za iskoristive informacije, iako neke tehnike i dalje mogu omogućiti demutilaciju pokazivača pre procure, iako uz određena ograničenja.

### **Demutilacija pokazivača sa procurelom heap-a**

{% hint style="danger" %}
Za bolje objašnjenje procesa [**proverite originalni post ovde**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Pregled Algoritma

Formula korišćena za mutilaciju i demutilaciju pokazivača je:&#x20;

**`Novi_Ptr = (L >> 12) XOR P`**

Gde je **L** lokacija skladištenja, a **P** je Fd pokazivač. Kada se **L** pomeri udesno za 12 bitova, otkrivaju se najznačajniji bitovi **P**, zbog prirode **XOR**, koji daje 0 kada se bitovi XOR-uju sa samim sobom.

**Ključni Koraci u Algoritmu:**

1. **Početna Procena Najznačajnijih Bitova**: XOR-ovanjem pomerene **L** sa **P**, efikasno dobijate gornjih 12 bitova **P** jer će pomerena deo **L** biti nula, ostavljajući odgovarajuće bitove **P** nepromenjene.
2. **Obnova Bitova Pokazivača**: Pošto je XOR reverzibilan, znajući rezultat i jedan od operanada vam omogućava da izračunate drugi operand. Ova osobina se koristi za zaključivanje celog skupa bitova za **P** sukcesivnim XOR-ovanjem poznatih setova bitova sa delovima mutiliranog pokazivača.
3. **Iterativna Demutilacija**: Proces se ponavlja, svaki put koristeći novo otkrivene bitove **P** iz prethodnog koraka za dekodiranje sledećeg segmenta mutiliranog pokazivača, dok se ne oporave svi bitovi.
4. **Rukovanje Determinističkim Bitovima**: Poslednjih 12 bitova **L** su izgubljeni zbog pomeranja, ali su deterministički i mogu se rekonstruisati nakon procesa.

Implementaciju ovog algoritma možete pronaći ovde: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Zaštita pokazivača

Zaštita pokazivača je tehnika zaštite od eksploatacije koja se koristi u glibc-u kako bi se zaštitili uskladišteni pokazivači funkcija, posebno oni registrovani pozivima biblioteke poput `atexit()`. Ova zaštita uključuje mešanje pokazivača XOR operacijom sa tajnom uskladištenom u podacima niti (`fs:0x30`) i primenom bitovske rotacije. Ovaj mehanizam ima za cilj da spreči napadače da preuzmu kontrolu toka izvršavanja preko prepisivanja pokazivača funkcija.

### **Bajpasovanje zaštite pokazivača pomoću curenja informacija**

1. **Razumevanje operacija zaštite pokazivača:** Mešanje pokazivača se vrši korišćenjem makroa `PTR_MANGLE` koji XOR-uje pokazivač sa 64-bitnom tajnom, a zatim vrši levu rotaciju za 0x11 bitova. Obrnuta operacija za vraćanje originalnog pokazivača se obavlja pomoću `PTR_DEMANGLE`.
2. **Strategija napada:** Napad se zasniva na pristupu poznatog teksta, gde napadač mora znati kako izgledaju originalna i mešana verzija pokazivača kako bi zaključio tajnu koja se koristi za mešanje.
3. **Eksploatisanje poznatih tekstova:**
* **Identifikacija fiksnih pokazivača funkcija:** Proučavanjem izvornog koda glibc-a ili inicijalizovanih tabela pokazivača funkcija (kao što su `__libc_pthread_functions`), napadač može pronaći predvidljive pokazivače funkcija.
* **Računanje tajne:** Korišćenjem poznatog pokazivača funkcije poput `__pthread_attr_destroy` i njegove mešane verzije iz tabele pokazivača funkcija, tajna se može izračunati vraćanjem rotacije (desna rotacija) mešanog pokazivača, a zatim XOR-ovanjem sa adresom funkcije.
4. **Alternativni poznati tekstovi:** Napadač takođe može eksperimentisati sa mešanjem pokazivača poznatim vrednostima poput 0 ili -1 kako bi videli da li ove vrednosti proizvode prepoznatljive obrasce u memoriji, potencijalno otkrivajući tajnu kada se ovi obrasci pronađu u isecima memorije.
5. **Praktična primena:** Nakon što se izračuna tajna, napadač može manipulisati pokazivačima na kontrolisan način, suštinski zaobilazeći zaštitu pokazivača u višenitnoj aplikaciji sa znanjem o baznoj adresi libc-a i sposobnošću čitanja proizvoljnih lokacija u memoriji.

## Reference

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
