# Προστασίες Libc

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε την [**Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Επιβολή Στοίβας Τμημάτων

Το **Malloc** εκχωρεί μνήμη σε **ομάδες 8 bytes (32-bit) ή 16 bytes (64-bit)**. Αυτό σημαίνει ότι το τέλος των τμημάτων σε συστήματα 32-bit πρέπει να ευθυγραμμίζεται με το **0x8**, και σε συστήματα 64-bit με το **0x0**. Η λειτουργία ασφαλείας ελέγχει ότι κάθε τμήμα **ευθυγραμμίζεται σωστά** σε αυτές τις συγκεκριμένες θέσεις πριν χρησιμοποιηθεί ένας δείκτης από ένα bin.

### Οφέλη Ασφάλειας

Η επιβολή της ευθυγράμμισης τμημάτων σε συστήματα 64-bit ενισχύει σημαντικά την ασφάλεια του Malloc με τον τρόπο που **περιορίζει την τοποθέτηση ψεύτικων τμημάτων σε μόνο 1 στις 16 διευθύνσεις**. Αυτό δυσκολεύει τις προσπάθειες εκμετάλλευσης, ειδικά σε σενάρια όπου ο χρήστης έχει περιορισμένο έλεγχο επί των τιμών εισόδου, καθιστώντας τις επιθέσεις πιο πολύπλοκες και δυσκολότερες να εκτελεστούν με επιτυχία.

* **Επίθεση Fastbin στο \_\_malloc\_hook**

Οι νέοι κανόνες ευθυγράμμισης στο Malloc εμποδίζουν επίσης μια κλασική επίθεση που αφορά το `__malloc_hook`. Προηγουμένως, οι επιτιθέμενοι μπορούσαν να διαμορφώσουν τα μεγέθη τμημάτων για να **αντικαταστήσουν αυτόν τον δείκτη συνάρτησης** και να κερδίσουν **εκτέλεση κώδικα**. Τώρα, η αυστηρή απαίτηση ευθυγράμμισης εξασφαλίζει ότι τέτοιες διαμορφώσεις δεν είναι πλέον εφικτές, κλείνοντας έτσι μια κοινή διαδρομή εκμετάλλευσης και ενισχύοντας συνολικά την ασφάλεια.

## Ανακάτεμα Δεικτών σε fastbins και tcache

Το **Ανακάτεμα Δεικτών** είναι μια ασφαλειακή βελτίωση που χρησιμοποιείται για την προστασία των **fastbin και tcache Fd δεικτών** σε λειτουργίες διαχείρισης μνήμης. Αυτή η τεχνική βοηθά στην πρόληψη ορισμένων τύπων εκμετάλλευσης μνήμης, ειδικά αυτών που δεν απαιτούν διαρροή πληροφοριών μνήμης ή που διαμορφώνουν άμεσα τοποθεσίες μνήμης σχετικά με γνωστές θέσεις (σχετικές **αντικαταστάσεις**).

Η καρδιά αυτής της τεχνικής είναι μια τύπου ασάφειας:

**`Νέος_Δείκτης = (L >> 12) XOR P`**

* **L** είναι η **Τοποθεσία Αποθήκευσης** του δείκτη.
* **P** είναι ο πραγματικός **fastbin/tcache Fd Δείκτης**.

Ο λόγος για τον οποίο γίνεται δυαδική μετατόπιση της τοποθεσίας αποθήκευσης (L) κατά 12 bits πριν τη λειτουργία XOR είναι κρίσιμος. Αυτή η διαμόρφωση αντιμετωπίζει μια ευπάθεια που είναι ενσωματωμένη στην προσδιοριστική φύση των λιγότερο σημαντικών 12 bits των διευθύνσεων μνήμης, τα οποία είναι συνήθως προβλέψιμα λόγω περιορισμών της αρχιτεκτονικής του συστήματος. Με τη μετατόπιση των bits, η προβλέψιμη μερίδα αφαιρείται από την εξίσωση, ενισχύοντας την τυχαιότητα του νέου, ανακατεμένου δείκτη και κατ' επέκταση προστατεύοντας ενάντια σε επιθέσεις που βασίζονται στην προβλέψιμότητα αυτών των bits.

Αυτός ο ανακατεμένος δείκτης εκμεταλλεύεται την υπάρχουσα τυχαιότητα που παρέχεται από το **Address Space Layout Randomization (ASLR)**, το οποίο τυχαιοποιεί τις διευθύνσεις που χρησιμοποιούνται από τα προγράμματα για να δυσκολέψει τους επιτιθέμενους να προβλέψουν τη μνημιακή διάταξη ενός διεργασίας.

**Ανακατεμένος Δείκτης με Διαρροή Μνήμης**

{% hint style="danger" %}
Για μια καλύτερη εξήγηση της διαδικασίας [**ελέγξτε την αρχική ανάρτηση από εδώ**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Επισκόπηση Αλγορίθμου

Η τύπου χρησιμοποιούμενη για το ανακάτεμα και την αποκωδικοποίηση των δεικτών είναι:&#x20;

**`Νέος_Δείκτης = (L >> 12) XOR P`**

Όπου το **L** είναι η τοποθεσία αποθήκευσης και το **P** είναι ο Fd δείκτης. Όταν το **L** μετατοπίζεται δεξιά κατά 12 bits, αποκαλύπτει τα πιο σημαντικά bits του **P**, λόγω της φύσης του **XOR**, που εξάγει 0 όταν τα bits XOR-άρονται με τον εαυτό τους.

**Βασικά Βήματα στον Αλγόριθμο:**

1. **Αρχική Διαρροή των Πιο Σημαντικών Bits**: Με το XOR του μετατοπισμένου **L** με το **P**, παίρνετε αποτελεσματικά τα πρώτα 12 bits του **P** επειδή η μετατοπισμένη περιοχή του **L** θα είναι μηδέν, αφήνοντας τα αντίστοιχα bits του **P** αναλλοίωτα.
2. **Ανάκτηση των Bits του Δείκτη**: Καθώς το XOR είναι αντιστρέψιμο, γνωρίζοντας το αποτέλεσμα και ένα από τα ορίσματα σας επιτρέπει να υπολογίσετε το άλλο όρισμα. Αυτή η ιδιότητα χρησιμοποιείται για να εξάγετε ολόκληρο το σύνολο των bits για το **P** με τον διαδοχικό XOR γνωστών συνόλων bits με τμήματα του ανακατεμένου δείκτη.
3. **Επαναλαμβανόμενο Ανακάτεμα**: Η διαδικασία επαναλαμβάνεται, κάθε φορά χρησιμοποιώντας τα νεότερα ανακαλυφθέντα bits του **P** από το προηγούμεν
## Προστασία Pointer Guard

Το Pointer guard είναι μια τεχνική μείωσης εκμετάλλευσης που χρησιμοποιείται στο glibc για την προστασία αποθηκευμένων δεικτών συνάρτησης, ιδιαίτερα αυτών που έχουν καταχωρηθεί από κλήσεις βιβλιοθήκης όπως το `atexit()`. Αυτή η προστασία περιλαμβάνει την ανακάτεμα των δεικτών με XOR με ένα μυστικό που αποθηκεύεται στα δεδομένα νήματος (`fs:0x30`) και την εφαρμογή ενός δυαδικού περιστροφής. Αυτό το μηχανισμό στοχεύει στο να αποτρέψει τους επιτιθέμενους από το να αρπάξουν τον έλεγχο ροής με τον παρεμβολή στους δείκτες συνάρτησης.

### **Παράκαμψη του Pointer Guard με έκθεση**

1. **Κατανόηση των Λειτουργιών του Pointer Guard:** Το ανακάτεμα των δεικτών γίνεται χρησιμοποιώντας τον μακρό `PTR_MANGLE` που κάνει XOR τον δείκτη με ένα μυστικό 64 bit και στη συνέχεια εκτελεί μια αριστερή περιστροφή 0x11 bits. Η αντίστροφη λειτουργία για την ανάκτηση του αρχικού δείκτη χειρίζεται από το `PTR_DEMANGLE`.
2. **Στρατηγική Επίθεσης:** Η επίθεση βασίζεται σε μια προσέγγιση γνωστού κειμένου, όπου ο επιτιθέμενος πρέπει να γνωρίζει τόσο την αρχική όσο και τη μετασχηματισμένη εκδοχή ενός δείκτη για να συμπεράνει το μυστικό που χρησιμοποιείται για τον μετασχηματισμό.
3. **Εκμετάλλευση Γνωστών Κειμένων:**
* **Αναγνώριση Σταθερών Δεικτών Συνάρτησης:** Με την εξέταση του πηγαίου κώδικα του glibc ή των πινάκων δεικτών συνάρτησης που αρχικοποιούνται (όπως το `__libc_pthread_functions`), ένας επιτιθέμενος μπορεί να βρει προβλέψιμους δείκτες συνάρτησης.
* **Υπολογισμός του Μυστικού:** Χρησιμοποιώντας έναν γνωστό δείκτη συνάρτησης όπως το `__pthread_attr_destroy` και τη μετασχηματισμένη του εκδοχή από τον πίνακα δεικτών συνάρτησης, το μυστικό μπορεί να υπολογιστεί αναστρέφοντας την περιστροφή (δεξιά περιστροφή) του μετασχηματισμένου δείκτη και στη συνέχεια κάνοντας XOR με τη διεύθυνση της συνάρτησης.
4. **Εναλλακτικά Κείμενα:** Ο επιτιθέμενος μπορεί επίσης να πειραματιστεί με τον μετασχηματισμό δεικτών με γνωστές τιμές όπως το 0 ή το -1 για να δει αν αυτές παράγουν αναγνωρίσιμα πρότυπα στη μνήμη, αποκαλύπτοντας πιθανώς το μυστικό όταν αυτά τα πρότυπα βρίσκονται σε αναλήψεις μνήμης.
5. **Πρακτική Εφαρμογή:** Μετά τον υπολογισμό του μυστικού, ένας επιτιθέμενος μπορεί να χειρίζεται τους δείκτες με έλεγχο, παρακάμπτοντας ουσιαστικά την προστασία του Pointer Guard σε μια εφαρμογή πολλαπλών νημάτων με γνώση της βάσης δεδομένων libc και τη δυνατότητα ανάγνωσης αυθαίρετων τοποθεσιών μνήμης.

## Αναφορές

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
