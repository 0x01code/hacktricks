# Libc Korumaları

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahraman olmaya kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* **Katılın** 💬 [**Discord grubumuza**](https://discord.gg/hRep4RUj7f) veya [**telegram grubumuza**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Parça Hizalaması Zorlaması

**Malloc**, belleği **8 bayt (32 bit) veya 16 bayt (64 bit) gruplarında** ayırır. Bu, 32 bit sistemlerde parçaların sonunun **0x8** ile, 64 bit sistemlerde ise **0x0** ile hizalanması gerektiği anlamına gelir. Güvenlik özelliği, bir kutudan bir işaretçi kullanmadan önce her parçanın bu belirli konumlarda **doğru şekilde hizalandığını** kontrol eder.

### Güvenlik Avantajları

64 bit sistemlerde parça hizalamasının zorunlu olması, Malloc'un güvenliğini önemli ölçüde artırır çünkü sahte parçaların yerleştirilmesini sadece **her 16 adresin 1'inde** sınırlar. Bu, özellikle kullanıcının giriş değerleri üzerinde sınırlı kontrolü olduğu senaryolarda saldırıları daha karmaşık ve başarılı bir şekilde gerçekleştirmeyi zorlaştırır.

* **\_\_malloc\_hook Üzerindeki Fastbin Saldırısı**

Malloc'daki yeni hizalama kuralları, `__malloc_hook`'u içeren klasik bir saldırıyı da engeller. Önceden saldırganlar, parça boyutlarını manipüle ederek bu fonksiyon işaretçisini **üzerine yazabilir** ve **kod yürütme** elde edebilirdi. Şimdi, sıkı hizalama gereksinimi, böyle manipülasyonların artık mümkün olmadığından emin olur, yaygın bir sömürü yolunu kapatır ve genel güvenliği artırır.

## Fastbin ve tcache Üzerinde İşaretçi Karıştırma

**İşaretçi Karıştırma**, bellek yönetimi işlemlerinde **fastbin ve tcache Fd işaretçilerini korumak için kullanılan bir güvenlik artışıdır**. Bu teknik, sızdırılmış bellek bilgilerini gerektirmeyen veya bilinen konumlara doğrudan bellek konumlarını manipüle eden belirli türde bellek sömürü taktiklerini önlemeye yardımcı olur (göreceli **üzerine yazmalar**).

Bu tekniğin çekirdeği bir karıştırma formülüdür:

**`Yeni_Ptr = (L >> 12) XOR P`**

* **L**, işaretçinin **Depolama Konumu**'dur.
* **P**, gerçek **fastbin/tcache Fd İşaretçisi**'dir.

Depolama konumunun (L) XOR işleminden önce 12 bit sağa kaydırılmasının nedeni kritiktir. Bu manipülasyon, bellek adreslerinin en az anlamlı 12 bitinin belirlenmiş doğasıyla ilgili bir zayıflığı ele alır. Bitleri kaydırarak, tahmin edilebilir kısmın denklem dışına çıkarılması, yeni, karışık işaretçinin rastgeleliğini artırır ve bu sayede bu bitlerin tahmin edilebilirliğine dayanan saldırılara karşı koruma sağlar.

Bu karışık işaretçi, programların kullandığı adresleri rastgele hale getiren **Adres Alanı Düzeni Rastgeleleştirme (ASLR)** tarafından sağlanan mevcut rastgeleliği kullanır.

İşaretçiyi orijinal adresi almak için **karıştırma işlemi** aynı XOR işlemi kullanılarak gerçekleştirilir. Burada, karışık işaretçi formülde P olarak işlem görür ve değişmeyen depolama konumu (L) ile XOR işlemine tabi tutulduğunda orijinal işaretçi ortaya çıkar. Bu karıştırma ve çözme simetrisi, sistemin bellek işaretçilerini etkili bir şekilde kodlamasına ve kodlamasına olanak tanırken, bellek işaretçilerini manipüle eden saldırılara karşı güvenliği önemli ölçüde artırır.

### Güvenlik Avantajları

İşaretçi karıştırma, heap yönetiminde **kısmi ve tam işaretçi üzerine yazmaları önlemeyi amaçlar**, güvenlik açısından önemli bir artış sağlar. Bu özellik, sömürü tekniklerini birkaç şekilde etkiler:

1. **Bye Byte Göreceli Üzerine Yazmaların Önlenmesi**: Önceden, saldırganlar, **kesin adresleri bilmeden** heap parçalarını farklı konumlara yönlendirmek için işaretçinin bir kısmını değiştirebilirdi, bu teknik, sızıntısız **House of Roman** sömürüsünde açıkça görülebilir. İşaretçi karıştırma ile, bu tür göreceli üzerine yazmalar **bir heap sızıntısı olmadan artık kaba kuvvet gerektirir**, başarılı olma olasılıklarını büyük ölçüde azaltır.
2. **Tcache Bin/Fastbin Saldırılarının Zorlaştırılması**: Fastbin veya tcache girişlerini manipüle ederek işlev işaretçilerini (örneğin, `__malloc_hook`) üzerine yazan yaygın saldırılar engellenir. Örneğin, bir saldırı, bir LibC adresi sızdırmayı, bir parçayı tcache binine serbest bırakmayı ve ardından Fd işaretçisini `__malloc_hook`'a yönlendirmek için üzerine yazmayı içerebilir. İşaretçi karıştırma ile, bu işaretçilerin doğru şekilde karıştırılması gerekmektedir, **doğru manipülasyon için bir heap sızıntısı gerektirir**, böylece sömürü engeli yükseltilir.
3. **Heap Sızıntıları İçin Heap Sızıntıları Gerekliliği**: Sahte bir parça oluşturmak artık heap sızıntısı gerektiren non-heap alanlarda (örneğin, yığın, .bss bölümü veya PLT/GOT) da **gereklidir**. Bu, bu alanların sömürülmesinin karmaşıklığını artırır, LibC adreslerini manipüle etme gereksinimi gibi.
4. **Heap Adreslerinin Sızdırılması Daha Zor Hale Gelir**: İşaretçi karıştırma, fastbin ve tcache kutularındaki Fd işaretçilerinin heap adres sızıntıları için kullanışlılığını kısıtlar. Bununla birlikte, sıralanmamış, küçük ve büyük kutulardaki işaretçiler karıştırılmamış olarak kalır, bu nedenle hala adres sızıntıları için kullanılabilirler. Bu değişiklik, saldırganları bu kutularda sömürülebilir bilgileri keşfetmeye zorlar, ancak bazı teknikler hala bir sızıntıdan önce işaretçilerin çözülmesine izin verebilir, ancak kısıtlamalarla.

### **Heap Sızıntısı ile İşaretçilerin Çözülmesi**

{% hint style="danger" %}
İşlemi daha iyi açıklamak için [**buradan orijinal gönderiyi kontrol edin**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algoritma Genel Bakış

İşaretçilerin karıştırılması ve çözülmesi için kullanılan formül:&#x20;

**`Yeni_Ptr = (L >> 12) XOR P`**

Burada **L**, depolama konumu ve **P**, Fd işaretçisidir. **L**'nin 12 bit sağa kaydırılmasıyla, **XOR**'un doğası gereği, kendisiyle XOR işlemi yapıldığında 0 çıktığından dolayı, **P**'nin en üst 12 bitini elde edersiniz.

**Algoritmadaki Ana Adımlar:**

1. **En Önemli Bitlerin Başlangıç Sızıntısı**: Kaydırılmış **L**'yi **P** ile XORladığınızda, kaydırılmış **L**'nin sıfır olacağından dolayı, **P**'nin ilgili bitleri değişmeden kalır ve **P**'nin en üst 12 bitini elde edersiniz.
2. **İşaretçi Bitlerinin Kurtarılması**: XOR tersine çevrilebilir olduğundan, sonucu ve bir operatörü bildiğinizde diğer operatörü hesaplayabilirsiniz. Bu özellik, karışık işaretçinin parçalarını sırayla XORlayarak **P**'nin tam kümesini çıkarmak için kullanılır.
3. **İteratif Karıştırma Çözme**: İşlem, her seferinde önceki adımdan elde edilen **P**'nin yeni keşfedilen bitlerini kullanarak tekrarlanır, tüm bitler kurtarıldığında.
4. **Belirlenen Bitlerin İşlenmesi**: Kaydırma nedeniyle **L**'nin son 12 biti kaybolur, ancak bunlar belirlidir ve işlem sonrası yeniden oluşturulabilir.

Bu algoritmanın bir uygulamasını burada bulabilirsiniz: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Pointer Guard

Pointer guard, glibc'de kullanılan bir sömürü koruma tekniğidir ve özellikle `atexit()` gibi kütüphane çağrıları tarafından kaydedilen işlev işaretçilerini korumak için kullanılır. Bu koruma, işaretçileri `fs:0x30` konumundaki bir gizli değerle XOR işlemine tabi tutarak ve bit düzeyinde bir döndürme işlemi uygulayarak karıştırarak gerçekleştirilir. Bu mekanizma, saldırganların işlev işaretçilerini üzerine yazarak kontrol akışını ele geçirmesini engellemeyi amaçlar.

### **Pointer Guard'ı Bir Sızıntı ile Atlatma**

1. **Pointer Guard İşlemlerini Anlama:** İşaretçilerin karıştırılması `PTR_MANGLE` makrosu kullanılarak yapılır. Bu makro işaretçiyi bir 64 bitlik gizli değerle XOR'lar ve ardından 0x11 bitlik bir sola döndürme işlemi gerçekleştirir. Orijinal işaretçiyi kurtarmak için ters işlem `PTR_DEMANGLE` tarafından gerçekleştirilir.
2. **Saldırı Stratejisi:** Saldırı, bilinen-metin yaklaşımına dayanır, saldırganın karıştırma için kullanılan gizli değeri çıkarmak için bir işaretçinin hem orijinal hem de karıştırılmış sürümlerini bilmelidir.
3. **Bilinen Metinlerin Sömürülmesi:**
* **Sabit İşlev İşaretçilerini Tanımlama:** glibc kaynak kodunu inceleyerek veya `__libc_pthread_functions` gibi başlatılmış işlev işaretçisi tablolarını inceleyerek, saldırgan öngörülebilir işlev işaretçileri bulabilir.
* **Gizli Değeri Hesaplama:** `__pthread_attr_destroy` gibi bilinen bir işlev işaretçisi ve işlev işaretçisi tablosundan karıştırılmış sürümü kullanarak, gizli değer, karıştırılmış işaretçiyi ters döndürerek (sağa döndürme) ve ardından işlevin adresiyle XOR işlemi yaparak hesaplanabilir.
4. **Alternatif Metinler:** Saldırgan, bellekte tanınabilir desenler oluşturup oluşturmadığını görmek için bilinen değerlerle (örneğin 0 veya -1) işaretçileri karıştırmayı deneyebilir; bu desenler bellek dökümlerinde bulunduğunda gizli değeri ortaya çıkarabilir.
5. **Pratik Uygulama:** Gizli değeri hesapladıktan sonra, bir saldırgan libc taban adresini ve keyfi bellek konumlarını okuma yeteneği ile çoklu iş parçacıklı bir uygulamada Pointer Guard korumasını atlayabilir, işaretçileri kontrol edilmiş bir şekilde manipüle edebilir.

## Referanslar

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
