# Protezioni di Libc

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Applicazione dell'Allineamento dei Chunk

**Malloc** alloca memoria in **gruppi di 8 byte (32-bit) o 16 byte (64-bit)**. Ci√≤ significa che la fine dei chunk nei sistemi a 32 bit dovrebbe allinearsi con **0x8**, e nei sistemi a 64 bit con **0x0**. La funzionalit√† di sicurezza controlla che ogni chunk **si allinei correttamente** in queste posizioni specifiche prima di utilizzare un puntatore da un bin.

### Benefici per la Sicurezza

L'applicazione dell'allineamento dei chunk nei sistemi a 64 bit migliora significativamente la sicurezza di Malloc limitando il posizionamento dei chunk falsi a solo 1 su ogni 16 indirizzi. Ci√≤ complica gli sforzi di exploit, specialmente in scenari in cui l'utente ha un controllo limitato sui valori di input, rendendo gli attacchi pi√π complessi e difficili da eseguire con successo.

* **Attacco Fastbin su \_\_malloc\_hook**

Le nuove regole di allineamento in Malloc ostacolano anche un attacco classico che coinvolge il `__malloc_hook`. Precedentemente, gli attaccanti potevano manipolare le dimensioni dei chunk per **sovrascrivere questo puntatore di funzione** e ottenere **esecuzione di codice**. Ora, il rigoroso requisito di allineamento garantisce che tali manipolazioni non siano pi√π valide, chiudendo una via comune di exploit e potenziando la sicurezza complessiva.

## Mascheramento dei Puntatori su fastbins e tcache

Il **Mascheramento dei Puntatori** √® un potenziamento della sicurezza utilizzato per proteggere i **puntatori Fd di fastbin e tcache** nelle operazioni di gestione della memoria. Questa tecnica aiuta a prevenire certi tipi di tattiche di exploit di memoria, in particolare quelle che non richiedono informazioni di memoria divulgate o che manipolano direttamente le posizioni di memoria relative a posizioni conosciute (sovrascritture **relative**).

Il cuore di questa tecnica √® una formula di oscuramento:

**`Nuovo_Ptr = (L >> 12) XOR P`**

* **L** √® la **Posizione di Archiviazione** del puntatore.
* **P** √® il vero **Puntatore Fd di fastbin/tcache**.

Il motivo per cui lo spostamento bit a bit della posizione di archiviazione (L) di 12 bit verso destra prima dell'operazione XOR √® critico. Questa manipolazione affronta una vulnerabilit√† intrinseca nella natura deterministica dei 12 bit meno significativi degli indirizzi di memoria, che sono tipicamente prevedibili a causa dei vincoli dell'architettura di sistema. Spostando i bit, la porzione prevedibile viene esclusa dall'equazione, migliorando la casualit√† del nuovo puntatore mascherato e proteggendo cos√¨ dagli exploit che si basano sulla prevedibilit√† di questi bit.

Questo puntatore mascherato sfrutta la casualit√† esistente fornita dalla **Randomizzazione dello Spazio degli Indirizzi (ASLR)**, che randomizza gli indirizzi utilizzati dai programmi per rendere difficile ai malintenzionati prevedere la disposizione della memoria di un processo.

**Demascherare** il puntatore per recuperare l'indirizzo originale coinvolge l'utilizzo della stessa operazione XOR. Qui, il puntatore mascherato √® trattato come P nella formula, e quando XORato con la posizione di archiviazione invariata (L), si ottiene il puntatore originale. Questa simmetria nel mascheramento e demascheramento garantisce che il sistema possa codificare e decodificare efficientemente i puntatori senza un overhead significativo, aumentando notevolmente la sicurezza contro gli attacchi che manipolano i puntatori di memoria.

### Benefici per la Sicurezza

Il mascheramento dei puntatori mira a **prevenire sovrascritture parziali e complete dei puntatori nell'heap**, un miglioramento significativo in termini di sicurezza. Questa funzionalit√† influisce sulle tecniche di exploit in diversi modi:

1. **Prevenzione delle Sovrascritture Relative di Byte**: Precedentemente, gli attaccanti potevano modificare parte di un puntatore per **reindirizzare i chunk dell'heap verso posizioni diverse senza conoscere gli indirizzi esatti**, una tecnica evidente nell'exploit **House of Roman** senza leak. Con il mascheramento dei puntatori, tali sovrascritture relative **senza un leak dell'heap richiedono ora un attacco a forza bruta**, riducendo drasticamente la probabilit√† di successo.
2. **Aumento della Difficolt√† degli Attacchi a Tcache Bin/Fastbin**: Gli attacchi comuni che sovrascrivono i puntatori di funzione (come `__malloc_hook`) manipolando le voci fastbin o tcache sono ostacolati. Ad esempio, un attacco potrebbe coinvolgere il leak di un indirizzo LibC, liberare un chunk nel tcache bin, e quindi sovrascrivere il puntatore Fd per reindirizzarlo a `__malloc_hook` per l'esecuzione di codice arbitrario. Con il mascheramento dei puntatori, questi puntatori devono essere correttamente mascherati, **necessitando di un leak dell'heap per una manipolazione accurata**, elevando cos√¨ la barriera dell'exploit.
3. **Necessit√† di Leak dell'Heap in Posizioni Non-Heap**: Creare un chunk falso in aree non-heap (come lo stack, la sezione .bss o PLT/GOT) ora richiede anche un leak dell'heap a causa della necessit√† di mascheramento dei puntatori. Ci√≤ estende la complessit√† nell'exploit di queste aree, simile alla necessit√† di manipolare gli indirizzi LibC.
4. **Rendere pi√π Complicato il Leak degli Indirizzi dell'Heap**: Il mascheramento dei puntatori limita l'utilit√† dei puntatori Fd nei fastbin e tcache bin come fonti di leak degli indirizzi dell'heap. Tuttavia, i puntatori nei bin non ordinati, piccoli e grandi rimangono non mascherati, quindi ancora utilizzabili per il leak degli indirizzi. Questo spinge gli attaccanti a esplorare questi bin per informazioni sfruttabili, anche se alcune tecniche potrebbero ancora consentire di demascherare i puntatori prima di un leak, sebbene con vincoli.

### **Demascherare i Puntatori con un Leak dell'Heap**

{% hint style="danger" %}
Per una migliore spiegazione del processo [**controlla il post originale da qui**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Panoramica dell'Algoritmo

La formula utilizzata per mascherare e demascherare i puntatori √®:&#x20;

**`Nuovo_Ptr = (L >> 12) XOR P`**

Dove **L** √® la posizione di archiviazione e **P** √® il puntatore Fd. Quando **L** viene spostato a destra di 12 bit, si ottengono i bit pi√π significativi di **P**, a causa della natura di **XOR**, che restituisce 0 quando i bit vengono XORati con se stessi.

**Passaggi Chiave nell'Algoritmo:**

1. **Leak Iniziale dei Bit pi√π Significativi**: XORando lo spostato **L** con **P**, si ottengono efficacemente i primi 12 bit di **P** poich√© la porzione spostata di **L** sar√† zero, lasciando invariati i bit corrispondenti di **P**.
2. **Recupero dei Bit del Puntatore**: Poich√© XOR √® reversibile, conoscere il risultato e uno degli operandi consente di calcolare l'altro operando. Questa propriet√† √® utilizzata per dedurre l'intero set di bit per **P** XORando successivamente set di bit con parti del puntatore mascherato.
3. **Demascheramento Iterativo**: Il processo viene ripetuto, ogni volta utilizzando i bit di **P** appena scoperti dal passaggio precedente per decodificare il segmento successivo del puntatore mascherato, fino a quando tutti i bit sono recuperati.
4. **Gestione dei Bit Deterministici**: I 12 bit finali di **L** vengono persi a causa dello spostamento, ma sono deterministici e possono essere ricostruiti post-processo.

Puoi trovare un'implementazione di questo algoritmo qui: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Protezione Pointer Guard

Pointer guard √® una tecnica di mitigazione degli exploit utilizzata in glibc per proteggere i puntatori di funzione memorizzati, in particolare quelli registrati dalle chiamate di libreria come `atexit()`. Questa protezione coinvolge la mescolatura dei puntatori tramite XOR con un segreto memorizzato nei dati del thread (`fs:0x30`) e l'applicazione di una rotazione bit a bit. Questo meccanismo mira a impedire agli attaccanti di dirottare il flusso di controllo sovrascrivendo i puntatori di funzione.

### **Bypass di Pointer Guard con un leak**

1. **Comprensione delle Operazioni di Pointer Guard:** La mescolatura dei puntatori avviene utilizzando la macro `PTR_MANGLE` che esegue l'XOR del puntatore con un segreto a 64 bit e poi esegue una rotazione a sinistra di 0x11 bit. L'operazione inversa per recuperare il puntatore originale √® gestita da `PTR_DEMANGLE`.
2. **Strategia di Attacco:** L'attacco si basa su un approccio di testo noto, dove l'attaccante deve conoscere sia la versione originale che quella mescolata di un puntatore per dedurre il segreto usato per la mescolatura.
3. **Sfruttare i Testi Noto:**
* **Identificare i Puntatori di Funzione Fissi:** Esaminando il codice sorgente di glibc o le tabelle dei puntatori di funzione inizializzati (come `__libc_pthread_functions`), un attaccante pu√≤ trovare puntatori di funzione prevedibili.
* **Calcolare il Segreto:** Utilizzando un puntatore di funzione noto come `__pthread_attr_destroy` e la sua versione mescolata dalla tabella dei puntatori di funzione, il segreto pu√≤ essere calcolato ruotando all'indietro (rotazione a destra) il puntatore mescolato e quindi facendo XOR con l'indirizzo della funzione.
4. **Testi Alternativi:** L'attaccante pu√≤ anche sperimentare la mescolatura dei puntatori con valori noti come 0 o -1 per vedere se questi producono pattern identificabili in memoria, rivelando potenzialmente il segreto quando tali pattern vengono trovati negli snapshot di memoria.
5. **Applicazione Pratica:** Dopo aver calcolato il segreto, un attaccante pu√≤ manipolare i puntatori in modo controllato, bypassando essenzialmente la protezione Pointer Guard in un'applicazione multithread con la conoscenza dell'indirizzo di base di libc e la capacit√† di leggere posizioni di memoria arbitrarie.

## Riferimenti

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
