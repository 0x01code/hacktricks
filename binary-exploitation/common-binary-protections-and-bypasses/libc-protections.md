# Libc-Schutzmechanismen

{% hint style="success" %}
Lernen Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
{% endhint %}

## Chunk-Alignment-Durchsetzung

**Malloc** alloziert Speicher in **8-Byte (32-Bit) oder 16-Byte (64-Bit) Gruppierungen**. Dies bedeutet, dass das Ende von Chunks in 32-Bit-Systemen mit **0x8** und in 64-Bit-Systemen mit **0x0** ausgerichtet sein sollte. Das Sicherheitsmerkmal √ºberpr√ºft, ob jeder Chunk **korrekt an diesen spezifischen Positionen ausgerichtet ist**, bevor ein Zeiger aus einem Bin verwendet wird.

### Sicherheitsvorteile

Die Durchsetzung der Chunk-Ausrichtung in 64-Bit-Systemen verbessert die Sicherheit von Malloc erheblich, indem sie die Platzierung von Fake-Chunks auf nur **1 von 16 Adressen** beschr√§nkt. Dies erschwert Exploitationsversuche erheblich, insbesondere in Szenarien, in denen der Benutzer nur begrenzte Kontrolle √ºber Eingabewerte hat, was Angriffe komplexer und schwieriger ausf√ºhrbar macht.

* **Fastbin-Angriff auf \_\_malloc\_hook**

Die neuen Ausrichtungsregeln in Malloc vereiteln auch einen klassischen Angriff, der den `__malloc_hook` betrifft. Fr√ºher konnten Angreifer Chunk-Gr√∂√üen manipulieren, um diesen Funktionszeiger zu **√ºberschreiben** und **Codeausf√ºhrung** zu erlangen. Die strikten Ausrichtungsanforderungen stellen nun sicher, dass solche Manipulationen nicht mehr m√∂glich sind, was einen h√§ufigen Ausbeutungsweg schlie√üt und die Gesamtsicherheit verbessert.

## Zeigermanipulation auf Fastbins und Tcache

**Zeigermanipulation** ist eine Sicherheitsverbesserung, die dazu dient, **Fastbin- und Tcache-Fd-Zeiger** bei Speicherverwaltungsvorg√§ngen zu sch√ºtzen. Diese Technik hilft, bestimmte Arten von Speicher-Exploit-Taktiken zu verhindern, insbesondere solche, die keine durchgesickerten Speicherinformationen erfordern oder die Speicherpositionen direkt relativ zu bekannten Positionen manipulieren (relative **√úberschreibungen**).

Der Kern dieser Technik ist eine Verschleierungsformel:

**`Neuer_Ptr = (L >> 12) XOR P`**

* **L** ist der **Speicherort** des Zeigers.
* **P** ist der tats√§chliche **Fastbin/Tcache-Fd-Zeiger**.

Der Grund f√ºr die bitweise Verschiebung des Speicherorts (L) um 12 Bits nach rechts vor der XOR-Operation ist entscheidend. Diese Manipulation behebt eine Schwachstelle, die in der deterministischen Natur der am wenigsten signifikanten 12 Bits von Speicheradressen liegt, die aufgrund von Systemarchitektur-Einschr√§nkungen typischerweise vorhersehbar sind. Durch Verschieben der Bits wird der vorhersehbare Teil aus der Gleichung entfernt, die Zuf√§lligkeit des neuen, verschleierten Zeigers verbessert und damit gegen Angriffe gesch√ºtzt, die auf der Vorhersagbarkeit dieser Bits beruhen.

Dieser verschleierte Zeiger nutzt die bereits vorhandene Zuf√§lligkeit von **Address Space Layout Randomization (ASLR)**, die Adressen, die von Programmen verwendet werden, zuf√§llig macht, um es Angreifern zu erschweren, das Speicherlayout eines Prozesses vorherzusagen.

**Das Entschleiern** des Zeigers, um die urspr√ºngliche Adresse abzurufen, beinhaltet die Verwendung derselben XOR-Operation. Hier wird der verschleierte Zeiger als P in der Formel behandelt, und wenn er mit dem unver√§nderten Speicherort (L) XOR-verkn√ºpft wird, wird der urspr√ºngliche Zeiger offengelegt. Diese Symmetrie beim Verschleiern und Entschleiern gew√§hrleistet, dass das System Zeiger effizient codieren und decodieren kann, ohne signifikante Overheads zu verursachen, und die Sicherheit gegen Angriffe, die Speicherzeiger manipulieren, erheblich erh√∂ht.

### Sicherheitsvorteile

Die Zeigerverschleierung zielt darauf ab, **partielle und vollst√§ndige Zeiger√ºberschreibungen im Heap**-Management zu verhindern, was eine erhebliche Sicherheitsverbesserung darstellt. Diese Funktion beeinflusst Exploit-Techniken auf verschiedene Weise:

1. **Verhinderung von Bye-Byte-Relativen √úberschreibungen**: Fr√ºher konnten Angreifer einen Teil eines Zeigers √§ndern, um **Heap-Chunks zu verschiedenen Positionen umzuleiten, ohne genaue Adressen zu kennen**, eine Technik, die im leckfreien **House of Roman**-Exploit offensichtlich ist. Mit der Zeigerverschleierung erfordern solche relativen √úberschreibungen **ohne ein Heap-Leck jetzt Brute-Force**, was ihre Erfolgschancen drastisch reduziert.
2. **Erh√∂hte Schwierigkeit von Tcache-Bin/Fastbin-Angriffen**: H√§ufige Angriffe, die Funktionszeiger (wie `__malloc_hook`) √ºberschreiben, indem sie Fastbin- oder Tcache-Eintr√§ge manipulieren, werden behindert. Zum Beispiel k√∂nnte ein Angriff das Offenlegen einer LibC-Adresse, das Freigeben eines Chunks in den Tcache-Bin und das √úberschreiben des Fd-Zeigers beinhalten, um ihn auf `__malloc_hook` umzuleiten, um beliebigen Code auszuf√ºhren. Mit der Zeigerverschleierung m√ºssen diese Zeiger korrekt verschleiert sein, **was ein Heap-Leck f√ºr eine genaue Manipulation erforderlich macht**, wodurch die Ausbeutungsh√ºrde erh√∂ht wird.
3. **Erfordernis von Heap-Lecks an Nicht-Heap-Positionen**: Das Erstellen eines Fake-Chunks in Nicht-Heap-Bereichen (wie dem Stack, dem .bss-Abschnitt oder PLT/GOT) erfordert jetzt ebenfalls ein Heap-Leck aufgrund der Notwendigkeit der Zeigerverschleierung. Dies erh√∂ht die Komplexit√§t bei der Ausnutzung dieser Bereiche, √§hnlich der Anforderung an die Manipulation von LibC-Adressen.
4. **Das Offenlegen von Heap-Adressen wird schwieriger**: Die Zeigerverschleierung beschr√§nkt die N√ºtzlichkeit von Fd-Zeigern in Fastbin- und Tcache-Bins als Quellen f√ºr Heap-Adresslecks. Zeiger in unsortierten, kleinen und gro√üen Bins bleiben jedoch unverschleiert und sind daher weiterhin f√ºr das Offenlegen von Adressen verwendbar. Diese Verschiebung zwingt Angreifer dazu, diese Bins nach ausnutzbaren Informationen zu durchsuchen, obwohl einige Techniken m√∂glicherweise immer noch das Entschleiern von Zeigern vor einem Leck erm√∂glichen, wenn auch mit Einschr√§nkungen.

### **Entschl√ºsselung von Zeigern mit einem Heap-Leck**

{% hint style="danger" %}
F√ºr eine bessere Erkl√§rung des Prozesses [**√ºberpr√ºfen Sie den Originalbeitrag hier**](https://maxwelldulin.com/BlogPost?post=5445977088).
{% endhint %}

### Algorithmus√ºbersicht

Die Formel f√ºr das Verschleiern und Entschleiern von Zeigern lautet:&#x20;

**`Neuer_Ptr = (L >> 12) XOR P`**

Dabei ist **L** der Speicherort und **P** der Fd-Zeiger. Wenn **L** um 12 Bits nach rechts verschoben wird, werden die signifikantesten Bits von **P** freigelegt, aufgrund der Natur von **XOR**, die 0 ausgibt, wenn Bits mit sich selbst XOR-verkn√ºpft werden.

**Wichtige Schritte im Algorithmus:**

1. **Erstes Offenlegen der signifikantesten Bits**: Durch XOR-Verkn√ºpfung des verschobenen **L** mit **P** erhalten Sie effektiv die oberen 12 Bits von **P**, da der verschobene Teil von **L** null sein wird und die entsprechenden Bits von **P** unver√§ndert bleiben.
2. **Wiederherstellung von Zeigerbits**: Da XOR umkehrbar ist, erm√∂glicht es, das Ergebnis und einen der Operanden zu kennen, den anderen Operanden zu berechnen. Diese Eigenschaft wird verwendet, um den gesamten Satz von Bits f√ºr **P** zu deduzieren, indem bekannte Bitsets sukzessive mit Teilen des verschleierten Zeigers XOR-verkn√ºpft werden.
3. **Iteratives Entschleiern**: Der Prozess wird wiederholt, wobei jedes Mal die neu entdeckten Bits von **P** aus dem vorherigen Schritt verwendet werden, um das n√§chste Segment des verschleierten Zeigers zu decodieren, bis alle Bits wiederhergestellt sind.
4. **Behandlung deterministischer Bits**: Die letzten 12 Bits von **L** gehen aufgrund der Verschiebung verloren, aber sie sind deterministisch und k√∂nnen nach dem Prozess rekonstruiert werden.

Eine Implementierung dieses Algorithmus finden Sie hier: [https://github.com/mdulin2/mangle](https://github.com/mdulin2/mangle)
## Pointer Guard

Pointer Guard ist eine Exploit-Minderungstechnik, die in glibc verwendet wird, um gespeicherte Funktionszeiger zu sch√ºtzen, insbesondere solche, die von Bibliotheksaufrufen wie `atexit()` registriert wurden. Dieser Schutz beinhaltet das Verwirren der Zeiger durch XOR-Verkn√ºpfung mit einem im Thread-Datenbereich (`fs:0x30`) gespeicherten Geheimnis und Anwendung einer bitweisen Rotation. Dieser Mechanismus zielt darauf ab, zu verhindern, dass Angreifer die Kontrollfluss√ºbernahme durch √úberschreiben von Funktionszeigern durchf√ºhren.

### **Bypassing Pointer Guard mit einem Leak**

1. **Verst√§ndnis der Pointer Guard Operationen:** Das Verwirren (Mangeln) von Zeigern wird mit dem `PTR_MANGLE`-Makro durchgef√ºhrt, das den Zeiger mit einem 64-Bit-Geheimnis XOR-verkn√ºpft und dann eine Linksrotation um 0x11 Bits durchf√ºhrt. Die Umkehrung zur Wiederherstellung des Original-Zeigers wird von `PTR_DEMANGLE` behandelt.
2. **Angriffsstrategie:** Der Angriff basiert auf einem Known-Plaintext-Ansatz, bei dem der Angreifer sowohl die Original- als auch die ver√§nderten Versionen eines Zeigers kennen muss, um das f√ºr das Verwirren verwendete Geheimnis abzuleiten.
3. **Ausnutzen bekannter Klartexte:**
* **Identifizierung fester Funktionszeiger:** Durch Untersuchung des glibc-Quellcodes oder initialisierter Funktionszeiger-Tabellen (wie `__libc_pthread_functions`) kann ein Angreifer vorhersehbare Funktionszeiger finden.
* **Berechnung des Geheimnisses:** Unter Verwendung eines bekannten Funktionszeigers wie `__pthread_attr_destroy` und seiner ver√§nderten Version aus der Funktionszeiger-Tabelle kann das Geheimnis berechnet werden, indem der ver√§nderte Zeiger r√ºckw√§rts rotiert (Rechtsrotation) und dann mit der Adresse der Funktion XOR-verkn√ºpft wird.
4. **Alternative Klartexte:** Der Angreifer kann auch versuchen, Zeiger mit bekannten Werten wie 0 oder -1 zu ver√§ndern, um zu sehen, ob diese identifizierbare Muster im Speicher erzeugen, die m√∂glicherweise das Geheimnis offenbaren, wenn diese Muster in Speicherausz√ºgen gefunden werden.
5. **Praktische Anwendung:** Nach Berechnung des Geheimnisses kann ein Angreifer Zeiger auf kontrollierte Weise manipulieren und somit den Pointer Guard-Schutz in einer Mehrfadenanwendung umgehen, wenn er die Basisadresse von libc kennt und die F√§higkeit besitzt, beliebige Speicherorte zu lesen.

## Referenzen

* [https://maxwelldulin.com/BlogPost?post=5445977088](https://maxwelldulin.com/BlogPost?post=5445977088)
* [https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1](https://blog.infosectcbr.com.au/2020/04/bypassing-pointer-guard-in-linuxs-glibc.html?m=1)
