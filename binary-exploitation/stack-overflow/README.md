# Desbordamiento de Pila

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipo Rojo de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## ¿Qué es un Desbordamiento de Pila?

Un **desbordamiento de pila** es una vulnerabilidad que ocurre cuando un programa escribe más datos en la pila de los que se le asignan para contener. Estos datos adicionales **sobrescribirán el espacio de memoria adyacente**, lo que lleva a la corrupción de datos válidos, la interrupción del flujo de control y potencialmente la ejecución de código malicioso. Este problema suele surgir debido al uso de funciones inseguras que no realizan comprobaciones de límites en la entrada.

El principal problema de esta sobrescritura es que el **puntero de instrucción guardado (EIP/RIP)** y el **puntero de base guardado (EBP/RBP)** para volver a la función anterior se **almacenan en la pila**. Por lo tanto, un atacante podrá sobrescribir esos valores y **controlar el flujo de ejecución del programa**.

La vulnerabilidad suele surgir porque una función **copia dentro de la pila más bytes de los asignados para ella**, pudiendo así sobrescribir otras partes de la pila.

Algunas funciones comunes vulnerables a esto son: **`strcpy`, `strcat`, `sprintf`, `gets`**... Además, funciones como **`fgets`**, **`read` & `memcpy`** que toman un **argumento de longitud**, podrían utilizarse de manera vulnerable si la longitud especificada es mayor que la asignada.

Por ejemplo, las siguientes funciones podrían ser vulnerables:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Encontrar los desplazamientos de desbordamiento de pila

La forma más común de encontrar desbordamientos de pila es proporcionar una entrada muy grande de `A`s (por ejemplo, `python3 -c 'print("A"*1000)'`) y esperar un `Segmentation Fault` que indique que se intentó acceder a la **dirección `0x41414141`**.

Además, una vez que se haya encontrado que hay una vulnerabilidad de desbordamiento de pila, será necesario encontrar el desplazamiento hasta que sea posible **sobrescribir la dirección de retorno**, para esto generalmente se utiliza una **secuencia de De Bruijn**. Que para un alfabeto dado de tamaño _k_ y subsecuencias de longitud _n_ es una **secuencia cíclica en la que cada subsecuencia posible de longitud _n_** aparece exactamente una vez como una subsecuencia contigua.

De esta manera, en lugar de tener que averiguar manualmente qué desplazamiento se necesita para controlar el EIP, es posible usar una de estas secuencias como relleno y luego encontrar el desplazamiento de los bytes que terminaron sobrescribiéndola.

Es posible utilizar **pwntools** para esto:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
o **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Explotando Desbordamientos de Pila

Durante un desbordamiento (suponiendo que el tamaño del desbordamiento es lo suficientemente grande) podrás **sobrescribir** valores de variables locales dentro de la pila hasta llegar a los valores guardados de **EBP/RBP y EIP/RIP (o incluso más)**.\
La forma más común de abusar de este tipo de vulnerabilidad es **modificando la dirección de retorno** para que cuando la función termine, el **flujo de control sea redirigido a donde el usuario lo especifique** en este puntero.

Sin embargo, en otros escenarios tal vez solo **sobrescribir algunos valores de variables en la pila** sea suficiente para la explotación (como en desafíos CTF sencillos).

### Ret2win

En este tipo de desafíos CTF, hay una **función** **dentro** del binario que **nunca es llamada** y que **necesitas llamar para ganar**. Para estos desafíos solo necesitas encontrar el **desplazamiento para sobrescribir la dirección de retorno** y **encontrar la dirección de la función** a llamar (generalmente [**ASLR**](../common-binary-protections-and-bypasses/aslr/) estaría deshabilitado) para que cuando la función vulnerable retorne, se llame a la función oculta:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Shellcode en la Pila

En este escenario, el atacante podría colocar un shellcode en la pila y abusar del EIP/RIP controlado para saltar al shellcode y ejecutar código arbitrario:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### Técnicas ROP y Ret2...

Esta técnica es el marco fundamental para evadir la protección principal de la técnica anterior: **No ejecución en la pila (NX)**. Y permite realizar varias otras técnicas (ret2lib, ret2syscall...) que terminarán ejecutando comandos arbitrarios abusando de las instrucciones existentes en el binario:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Desbordamientos de Montón

Un desbordamiento no siempre ocurrirá en la pila, también podría ocurrir en el **montón**, por ejemplo:

{% content-ref url="../heap/heap-overflow.md" %}
[heap-overflow.md](../heap/heap-overflow.md)
{% endcontent-ref %}

## Tipos de protecciones

Existen varias protecciones que intentan prevenir la explotación de vulnerabilidades, consúltalas en:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
