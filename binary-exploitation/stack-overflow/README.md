# スタックオーバーフロー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じて、ゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリに提出する

</details>

## スタックオーバーフローとは

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたデータよりも多くのデータを書き込むと発生する脆弱性です。この余分なデータは、隣接するメモリ空間を**上書き**し、有効なデータの破損、制御フローの混乱、および悪意のあるコードの実行を引き起こす可能性があります。この問題は、入力に対して境界チェックを実行しない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**保存された命令ポインタ（EIP/RIP）**と**保存されたベースポインタ（EBP/RBP）**が前の関数に戻るために**スタックに保存されている**ことです。したがって、攻撃者はこれらを上書きして**プログラムの実行フローを制御**することができます。

この脆弱性は通常、関数が**割り当てられた量よりも多くのバイトをスタックにコピー**するために発生します。そのため、スタックの他の部分を上書きできます。

このような脆弱性に対して脆弱な一般的な関数には、**`strcpy`、`strcat`、`sprintf`、`gets`**などがあります。また、**`fgets`**、**`read`**、**`memcpy`**などの長さ引数を取る関数は、指定された長さが割り当てられた長さよりも大きい場合に脆弱な方法で使用される可能性があります。

たとえば、次の関数は脆弱性のある可能性があります：
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローのオフセットを見つける

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな入力の `A`（例：`python3 -c 'print("A"*1000)'`）を与え、**アドレス `0x41414141` にアクセスしようとしました** と示す `Segmentation Fault` が発生することを期待することです。

さらに、スタックオーバーフローの脆弱性が見つかったら、**リターンアドレスを上書きできるまでのオフセットを見つける必要があります**。これには通常、**De Bruijn sequence** が使用されます。これは、サイズ _k_ のアルファベットと長さ _n_ の部分列が与えられた場合、**すべての可能な長さ _n_ の部分列が連続した部分列として正確に一度だけ現れる** 循環シーケンスです。

これにより、EIP を制御するために手動でどのオフセットが必要かを特定する必要がなくなり、これらのシーケンスの1つをパディングとして使用し、それを上書きしたバイトのオフセットを見つけることができます。

これには **pwntools** を使用することができます：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または**GEF**：
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分に大きいと仮定）、スタック内のローカル変数の値を**上書き**して、保存された**EBP/RBPとEIP/RIP（またはそれ以上）**に到達するまで上書きできます。\
この種の脆弱性を悪用する最も一般的な方法は、**戻りアドレスを変更**して、関数が終了するときに**制御フローがユーザーが指定した場所にリダイレクト**されるようにすることです。

ただし、他のシナリオでは、単に**スタック内のいくつかの変数の値を上書き**するだけで、悪用が可能になることがあります（簡単なCTFチャレンジなど）。

### Ret2win

この種のCTFチャレンジでは、バイナリ内に**呼び出されない関数**があり、**それを呼び出して勝利する必要がある**。これらのチャレンジでは、**戻りアドレスを上書きするオフセットを見つけ**、呼び出す関数のアドレスを見つける必要があります（通常、[**ASLR**](../common-binary-protections-and-bypasses/aslr/)は無効になっている可能性があります）。脆弱な関数が戻ると、隠された関数が呼び出されます。

{% content-ref url="ret2win.md" %}
[ret2win.md](ret2win.md)
{% endcontent-ref %}

### スタックシェルコード

このシナリオでは、攻撃者はスタックにシェルコードを配置し、制御可能なEIP/RIPを悪用してシェルコードにジャンプし、任意のコードを実行できます。

{% content-ref url="stack-shellcode.md" %}
[stack-shellcode.md](stack-shellcode.md)
{% endcontent-ref %}

### ROPおよびRet2...テクニック

このテクニックは、前述のテクニックに対する主要な保護をバイパスするための基本的なフレームワークです：**実行不可スタック（NX）**。これにより、バイナリ内の既存の命令を悪用して任意のコマンドを実行するための他のいくつかのテクニック（ret2lib、ret2syscallなど）を実行できます。

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## 保護の種類

脆弱性の悪用を防ぐためのいくつかの保護があります。詳細は以下を参照してください：

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
