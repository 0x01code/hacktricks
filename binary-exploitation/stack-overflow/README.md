# Estouro de Pilha

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## O que √© um Estouro de Pilha

Um **estouro de pilha** √© uma vulnerabilidade que ocorre quando um programa escreve mais dados na pilha do que foi alocado para armazenar. Esses dados em excesso ir√£o **sobrescrever o espa√ßo de mem√≥ria adjacente**, levando √† corrup√ß√£o de dados v√°lidos, interrup√ß√£o do fluxo de controle e potencialmente √† execu√ß√£o de c√≥digo malicioso. Esse problema frequentemente surge devido ao uso de fun√ß√µes inseguras que n√£o realizam verifica√ß√£o de limites na entrada.

O principal problema dessa sobrescrita √© que o **ponteiro de instru√ß√£o salvo (EIP/RIP)** e o **ponteiro de base salvo (EBP/RBP)** para retornar √† fun√ß√£o anterior s√£o **armazenados na pilha**. Portanto, um atacante poder√° sobrescrev√™-los e **controlar o fluxo de execu√ß√£o do programa**.

A vulnerabilidade geralmente surge porque uma fun√ß√£o **copia mais bytes para dentro da pilha do que a quantidade alocada para ela**, podendo assim sobrescrever outras partes da pilha.

Algumas fun√ß√µes comuns vulner√°veis a isso s√£o: **`strcpy`, `strcat`, `sprintf`, `gets`**... Al√©m disso, fun√ß√µes como **`fgets`**, **`read` & `memcpy`** que recebem um **argumento de comprimento**, podem ser usadas de forma vulner√°vel se o comprimento especificado for maior do que o alocado.

Por exemplo, as seguintes fun√ß√µes poderiam ser vulner√°veis:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Encontrando os deslocamentos de Estouro de Pilha

A maneira mais comum de encontrar estouros de pilha √© fornecer uma entrada muito grande de `A`s (por exemplo, `python3 -c 'print("A"*1000)'`) e esperar um `Segmentation Fault` indicando que o **endere√ßo `0x41414141` foi tentado a ser acessado**.

Al√©m disso, uma vez que voc√™ descobrir que h√° uma vulnerabilidade de Estouro de Pilha, ser√° necess√°rio encontrar o deslocamento at√© ser poss√≠vel **sobrescrever o endere√ßo de retorno**, para isso geralmente √© usado uma **sequ√™ncia de De Bruijn**. Que para um dado alfabeto de tamanho _k_ e subsequ√™ncias de comprimento _n_ √© uma **sequ√™ncia c√≠clica na qual toda subsequ√™ncia poss√≠vel de comprimento _n_** aparece exatamente uma vez como uma subsequ√™ncia cont√≠gua.

Dessa forma, em vez de precisar descobrir manualmente qual deslocamento √© necess√°rio para controlar o EIP, √© poss√≠vel usar uma dessas sequ√™ncias como preenchimento e depois encontrar o deslocamento dos bytes que acabaram sobrescrevendo-o.

√â poss√≠vel usar o **pwntools** para isso:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ou **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Explorando Estouros de Pilha

Durante um estouro (supondo que o tamanho do estouro seja grande o suficiente), voc√™ ser√° capaz de **sobrescrever** valores de vari√°veis locais dentro da pilha at√© atingir o **EBP/RBP e EIP/RIP salvos (ou at√© mais)**.\
A maneira mais comum de abusar desse tipo de vulnerabilidade √© **modificando o endere√ßo de retorno** para que, quando a fun√ß√£o terminar, o **fluxo de controle seja redirecionado para onde o usu√°rio especificou** nesse ponteiro.

No entanto, em outros cen√°rios, talvez apenas **sobrescrever alguns valores de vari√°veis na pilha** seja suficiente para a explora√ß√£o (como em desafios CTF f√°ceis).

### Ret2win

Neste tipo de desafios CTF, h√° uma **fun√ß√£o** **dentro** do bin√°rio que **nunca √© chamada** e que **voc√™ precisa chamar para vencer**. Para esses desafios, voc√™ s√≥ precisa encontrar o **deslocamento para sobrescrever o endere√ßo de retorno** e **encontrar o endere√ßo da fun√ß√£o** a ser chamada (geralmente [**ASLR**](../common-binary-protections-and-bypasses/aslr/) estaria desativado) para que, quando a fun√ß√£o vulner√°vel retornar, a fun√ß√£o oculta ser√° chamada:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Shellcode na Pilha

Neste cen√°rio, o atacante poderia colocar um shellcode na pilha e abusar do EIP/RIP controlado para pular para o shellcode e executar c√≥digo arbitr√°rio:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### T√©cnicas ROP & Ret2...

Essa t√©cnica √© o framework fundamental para contornar a principal prote√ß√£o da t√©cnica anterior: **Pilha n√£o execut√°vel (NX)**. E permite realizar v√°rias outras t√©cnicas (ret2lib, ret2syscall...) que acabar√£o executando comandos arbitr√°rios abusando de instru√ß√µes existentes no bin√°rio:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Estouros de Heap

Um estouro nem sempre vai ocorrer na pilha, tamb√©m pode ocorrer no **heap**, por exemplo:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Tipos de prote√ß√µes

Existem v√°rias prote√ß√µes que tentam evitar a explora√ß√£o de vulnerabilidades, verifique-as em:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
