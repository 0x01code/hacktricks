# Stack Overflow

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Stack Overflow Nedir

Bir **stack overflow** (yığın taşması), bir programın yığına ayrılan kapasiteden daha fazla veri yazdığında meydana gelen bir güvenlik açığıdır. Bu fazla veri, **bitişik bellek alanını üzerine yazarak** geçerli verilerin bozulmasına, kontrol akışının bozulmasına ve potansiyel olarak kötü amaçlı kodun yürütülmesine neden olabilir. Bu sorun genellikle, giriş üzerinde sınırların kontrol edilmediği güvensiz işlevlerin kullanılmasından kaynaklanır.

Bu üzerine yazma sorununun ana nedeni, **kaydedilmiş komut işaretçisi (EIP/RIP)** ve **kaydedilmiş taban işaretçisi (EBP/RBP)** gibi önceki işleve geri dönüş için **yığında saklanan değerlerdir**. Bu nedenle, bir saldırgan bunları üzerine yazabilir ve programın **yürütme akışını kontrol edebilir**.

Bu zafiyet genellikle bir işlevin **yığına ayrılan miktarın üzerinde bayt kopyaladığı** durumlarda ortaya çıkar, bu nedenle yığının diğer kısımlarını üzerine yazabilir.

Bu duruma yol açan bazı yaygın işlevler: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ayrıca, bir **uzunluk argümanı alan** **`fgets`**, **`read` & `memcpy`** gibi işlevler, belirtilen uzunluğun ayrılan miktarından büyük olması durumunda zafiyetli bir şekilde kullanılabilir.

Örneğin, aşağıdaki işlevler zafiyetli olabilir:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflow Ofsetlerini Bulma

Stack overflow'ları bulmanın en yaygın yolu, çok büyük bir `A` girdisi vermek (örneğin `python3 -c 'print("A"*1000)'`) ve **`0x41414141` adresine erişilmeye çalışıldığını** gösteren bir `Segmentation Fault` almayı beklemektir.

Ayrıca, Stack Overflow zafiyetini bulduktan sonra, **dönüş adresini üzerine yazabileceğiniz ofseti bulmanız gerekecektir**, bunun için genellikle bir **De Bruijn dizisi** kullanılır. Bu, _k_ boyutunda bir alfabeye ve _n_ uzunluğundaki alt dizilere sahip bir dizi olup, **her olası _n_ uzunluğundaki alt dizinin tam olarak bir kez** ardışık bir alt dizi olarak göründüğü döngüsel bir dizidir.

Bu şekilde, EIP'yi kontrol etmek için hangi ofsetin gerektiğini el ile bulmak yerine, bu dizilerden birini dolgu olarak kullanmak ve ardından üzerine yazılan baytların ofsetini bulmak mümkündür.

Bunun için genellikle **pwntools** kullanılabilir:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
veya **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Yığın Taşmalarını Sömürme

Taşma sırasında (taşma boyutu yeterince büyükse) yığın içindeki yerel değişkenlerin değerlerini **üzerine yazabilirsiniz** ve kaydedilmiş **EBP/RBP ve EIP/RIP'yi (hatta daha fazlasını)** bulana kadar devam edebilirsiniz.\
Bu tür bir zafiyeti istismar etmenin en yaygın yolu, **dönüş adresini değiştirmektir**, böylece işlev bittiğinde **kontrol akışı kullanıcının belirttiği yere yönlendirilir**.

Ancak, diğer senaryolarda belki sadece **yığında bazı değişken değerlerini üzerine yazmak** yeterli olabilir (kolay CTF zorluklarında olduğu gibi).

### Ret2win

Bu tür CTF zorluklarında, **asla çağrılmayan** bir **işlev** **içinde** bulunan ve **kazanmak için çağrılması gereken bir işlev** bulunmaktadır. Bu zorluklarda sadece **dönüş adresini üzerine yazmak için ofseti bulmanız** ve çağrılacak işlevin adresini bulmanız gerekir (genellikle [**ASLR**](../common-binary-protections-and-bypasses/aslr/) devre dışı bırakılmış olacaktır), bu sayede zafiyetli işlev döndüğünde gizli işlev çağrılacaktır:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Yığın Kabuk Kodu

Bu senaryoda saldırgan, yığına bir kabuk kodu yerleştirebilir ve kontrol edilen EIP/RIP'yi kabuk koda atlamak ve keyfi kodu yürütmek için kullanabilir:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROP ve Ret2... teknikleri

Bu teknik, önceki tekniğin ana korumasını atlamak için temel çerçevedir: **Yürütülebilir yığın yok (NX)**. Ve bu, ikili dosyadaki mevcut talimatları istismar ederek keyfi komutları yürütmeyi sonlandıran çeşitli diğer teknikleri gerçekleştirmenizi sağlar (ret2lib, ret2syscall...):

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Koruma Türleri

Zafiyetlerin istismarını önlemeye çalışan çeşitli korumalar bulunmaktadır, bunları kontrol edin:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
