# Υπερχείλιση Στοίβας

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Τι είναι η Υπερχείλιση Στοίβας

Η **υπερχείλιση στοίβας** είναι μια ευπάθεια που συμβαίνει όταν ένα πρόγραμμα γράφει περισσότερα δεδομένα στη στοίβα από ό,τι έχει εκχωρηθεί για να κρατήσει. Αυτά τα περισσότερα δεδομένα θα **αντικαταστήσουν τον δίπλα μνημονικό χώρο**, οδηγώντας στη διαφθορά των έγκυρων δεδομένων, στη διαταραχή της ροής ελέγχου και πιθανώς στην εκτέλεση κακόβουλου κώδικα. Αυτό το πρόβλημα προκύπτει συχνά λόγω της χρήσης μη ασφαλών συναρτήσεων που δεν πραγματοποιούν έλεγχο ορίων στην είσοδο.

Το κύριο πρόβλημα αυτής της υπερχείλισης είναι ότι ο **αποθηκευμένος δείκτης οδηγιών (EIP/RIP)** και ο **αποθηκευμένος δείκτης βάσης (EBP/RBP)** για την επιστροφή στην προηγούμενη συνάρτηση **αποθηκεύονται στη στοίβα**. Επομένως, ένας επιτιθέμενος θα μπορεί να αντικαταστήσει αυτούς και να **ελέγχει τη ροή εκτέλεσης του προγράμματος**.

Η ευπάθεια προκύπτει συνήθως επειδή μια συνάρτηση **αντιγράφει μέσα στη στοίβα περισσότερα bytes από την ποσότητα που έχει εκχωρηθεί γι' αυτήν**, επομένως είναι δυνατή η αντικατάσταση άλλων τμημάτων της στοίβας.

Κάποιες συνήθεις συναρτήσεις ευάλωτες σε αυτό είναι: **`strcpy`, `strcat`, `sprintf`, `gets`**... Επίσης, συναρτήσεις όπως **`fgets`**, **`read` & `memcpy`** που παίρνουν ένα **όριο μήκους**, μπορεί να χρησιμοποιηθούν με ευάλωτο τρόπο αν το καθορισμένο μήκος είναι μεγαλύτερο από το εκχωρημένο. 

Για παράδειγμα, οι ακόλουθες συναρτήσεις θα μπορούσαν να είναι ευάλωτες:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Εύρεση αντιστοιχιών υπερχείλισης στο stack

Ο πιο συνηθισμένος τρόπος για να βρείτε αντιστοιχίες υπερχείλισης στο stack είναι να δώσετε ένα πολύ μεγάλο είσοδο από `A` (π.χ. `python3 -c 'print("A"*1000)'`) και να περιμένετε ένα `Segmentation Fault` που υποδηλώνει ότι **προσπαθήθηκε να προσπεράσει η διεύθυνση `0x41414141`**.

Επιπλέον, αφού εντοπίσετε ότι υπάρχει ευπάθεια στο stack, θα χρειαστεί να βρείτε την αντιστοίχιση μέχρι να είναι δυνατόν να **αντικαταστήσετε τη διεύθυνση επιστροφής**, για αυτό συνήθως χρησιμοποιείται μια **ακολουθία De Bruijn**. Η οποία για ένα δεδομένο αλφάβητο μεγέθους _k_ και υποακολουθίες μήκους _n_ είναι μια **κυκλική ακολουθία στην οποία κάθε δυνατή υποακολουθία μήκους _n_** εμφανίζεται ακριβώς μία φορά ως μια συνεχής υποακολουθία.

Με αυτόν τον τρόπο, αντί να χρειάζεται να καθορίσετε με το χέρι ποια αντιστοίχιση χρειάζεται για να ελέγξετε το EIP, είναι δυνατό να χρησιμοποιηθεί μια από αυτές τις ακολουθίες ως γέμισμα και στη συνέχεια να βρεθεί η αντιστοίχιση των bytes που τελείωσαν με τον παρακάτω επικαλυπτόμενο.

Είναι δυνατό να χρησιμοποιηθεί το **pwntools** γι' αυτό:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
ή **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Εκμετάλλευση Υπερχείλισης Στοίβας

Κατά τη διάρκεια μιας υπερχείλισης (υποθέτοντας ότι το μέγεθος της υπερχείλισης είναι αρκετά μεγάλο) θα μπορείτε να **αντικαταστήσετε** τιμές τοπικών μεταβλητών μέσα στη στοίβα μέχρι να φτάσετε τα αποθηκευμένα **EBP/RBP και EIP/RIP (ή ακόμα περισσότερα)**.\
Ο πιο συνηθισμένος τρόπος εκμετάλλευσης αυτού του τύπου ευπαθειών είναι με το **τροποποίηση της διεύθυνσης επιστροφής** έτσι ώστε όταν η συνάρτηση τελειώσει, η **ροή ελέγχου θα ανακατευθυνθεί όπου ο χρήστης καθόρισε** σε αυτό το δείκτη.

Ωστόσο, σε άλλα σενάρια ίσως απλά **η υπεργραφή μερικών τιμών μεταβλητών στη στοίβα** είναι αρκετή για την εκμετάλλευση (όπως σε εύκολες προκλήσεις CTF).

### Ret2win

Σε αυτού του τύπου προκλήσεις CTF, υπάρχει μια **συνάρτηση** **μέσα** στο δυαδικό που **ποτέ δεν καλείται** και **πρέπει να καλέσετε για να κερδίσετε**. Για αυτές τις προκλήσεις απλά πρέπει να βρείτε τη **μετατόπιση για την υπεργραφή της διεύθυνσης επιστροφής** και να βρείτε τη διεύθυνση της συνάρτησης που πρέπει να καλέσετε (συνήθως το [**ASLR**](../common-binary-protections-and-bypasses/aslr/) θα είναι απενεργοποιημένο) έτσι ώστε όταν η ευπαθής συνάρτηση επιστρέψει, η κρυφή συνάρτηση θα κληθεί:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Shellcode Στοίβας

Σε αυτό το σενάριο ο επιτιθέμενος θα μπορούσε να τοποθετήσει ένα shellcode στη στοίβα και να εκμεταλλευτεί τον ελεγχόμενο EIP/RIP για να μεταβεί στο shellcode και να εκτελέσει αυθαίρετο κώδικα:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROP & Τεχνικές Ret2...

Αυτή η τεχνική είναι το θεμελιώδες πλαίσιο για να παρακάμψετε την κύρια προστασία στην προηγούμενη τεχνική: **Μη εκτελέσιμη στοίβα (NX)**. Και επιτρέπει την εκτέλεση πολλών άλλων τεχνικών (ret2lib, ret2syscall...) που θα οδηγήσουν στην εκτέλεση αυθαίρετων εντολών εκμεταλλευόμενοι υπάρχουσες οδηγίες στο δυαδικό:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Υπερχειλίσεις Σωρού

Μια υπερχείλιση δεν θα είναι πάντα στη στοίβα, μπορεί επίσης να είναι στο **σωρό** για παράδειγμα:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Τύποι προστασιών

Υπάρχουν πολλές προστασίες που προσπαθούν να αποτρέψουν την εκμετάλλευση ευπαθειών, ελέγξτε τις σε:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
