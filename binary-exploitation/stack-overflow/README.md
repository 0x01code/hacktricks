# スタックオーバーフロー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じて、ゼロからヒーローまでAWSハッキングを学びましょう</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをご覧ください
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください**。

</details>

## スタックオーバーフローとは

**スタックオーバーフロー**は、プログラムがスタックに割り当てられたデータよりも多くのデータを書き込むと発生する脆弱性です。この余分なデータは、**隣接するメモリ領域を上書き**し、有効なデータの破損、制御フローの混乱、および悪意のあるコードの実行を引き起こす可能性があります。この問題は、入力に対して境界チェックを実行しない安全でない関数の使用によってしばしば発生します。

この上書きの主な問題は、**保存された命令ポインタ（EIP/RIP）**および**保存されたベースポインタ（EBP/RBP）**が前の関数に戻るために**スタックに保存されている**ことです。したがって、攻撃者はこれらを上書きして**プログラムの実行フローを制御**することができます。

この脆弱性は通常、関数が**スタック内に割り当てられた量よりも多くのバイトをコピー**するために発生します。そのため、スタックの他の部分を上書きできます。

この脆弱性に対して脆弱な一般的な関数には、**`strcpy`、`strcat`、`sprintf`、`gets`**などがあります。また、**`fgets`**、**`read`、`memcpy`**などの長さ引数を取る関数は、指定された長さが割り当てられた長さよりも大きい場合に脆弱な方法で使用される可能性があります。

たとえば、次の関数は脆弱になる可能性があります：
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### スタックオーバーフローのオフセットを見つける

スタックオーバーフローを見つける最も一般的な方法は、非常に大きな入力を与えることです（例：`python3 -c 'print("A"*1000)'`）そして、**アドレス `0x41414141` にアクセスしようとしました** と示す `Segmentation Fault` が発生することを期待することです。

さらに、スタックオーバーフローの脆弱性が見つかったら、**リターンアドレスを上書きできるまでのオフセットを見つける必要があります**。これには通常、**De Bruijn sequence** が使用されます。これは、サイズ _k_ のアルファベットと長さ _n_ の部分列が与えられた場合、**すべての可能な長さ _n_ の部分列が連続した部分列として正確に一度だけ現れる** 循環列です。

これにより、EIP を制御するために必要なオフセットを手動で特定する必要がなくなり、これらのシーケンスの1つをパディングとして使用し、それを上書きしたバイトのオフセットを見つけることができます。

これには **pwntools** を使用することができます：
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
または **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## スタックオーバーフローの悪用

オーバーフロー中（オーバーフローサイズが十分に大きいと仮定）、スタック内のローカル変数の値を**上書き**することができます。保存された**EBP/RBPとEIP/RIP（またはそれ以上）**に到達するまでです。\
この種の脆弱性を悪用する最も一般的な方法は、**戻りアドレスを変更**して、関数が終了するときに**制御フローがユーザーが指定した場所にリダイレクト**されるようにすることです。

ただし、他のシナリオでは、単にスタック内のいくつかの変数の値を**上書き**するだけで、悪用が可能になることがあります（簡単なCTFチャレンジなど）。

### Ret2win

この種のCTFチャレンジでは、バイナリ内に**呼び出されない関数**があり、**それを呼び出して勝利する必要がある**ことがあります。これらのチャレンジでは、**戻りアドレスを上書きするオフセット**を見つけ、呼び出す関数のアドレスを見つける必要があります（通常、[**ASLR**](../common-binary-protections-and-bypasses/aslr/)は無効になっている可能性があります）。脆弱な関数が戻ると、隠された関数が呼び出されます。

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### スタックシェルコード

このシナリオでは、攻撃者はスタックにシェルコードを配置し、制御可能なEIP/RIPを悪用してシェルコードにジャンプし、任意のコードを実行できます。

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROPおよびRet2...テクニック

このテクニックは、前述のテクニックの主要な保護をバイパスするための基本的なフレームワークです：**実行可能スタック（NX）がない**。これにより、バイナリ内の既存の命令を悪用して任意のコマンドを実行することができる他のいくつかのテクニック（ret2lib、ret2syscallなど）を実行できます。

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## ヒープオーバーフロー

オーバーフローが必ずしもスタックにあるとは限らず、**ヒープ**にあることもあります。例えば：

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## 保護の種類

脆弱性の悪用を防ぐためのいくつかの保護があります。詳細は以下を参照してください：

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
