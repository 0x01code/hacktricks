# Stack Overflow

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini edinin**](https://peass.creator-spring.com)
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Stack Overflow Nedir

Bir **stack overflow** (yığın taşması), bir programın yığına ayrılan alanın kapasitesinden fazla veri yazdığı bir güvenlik açığıdır. Bu fazla veri, **bitişik bellek alanını üzerine yazacak**, geçerli verilerin bozulmasına, kontrol akışının bozulmasına ve potansiyel olarak kötü amaçlı kodun yürütülmesine neden olacaktır. Bu sorun genellikle, giriş üzerinde sınırlar kontrolü yapmayan güvensiz işlevlerin kullanılmasından kaynaklanır.

Bu üzerine yazma işleminin ana sorunu, **kaydedilmiş komut işaretçisi (EIP/RIP)** ve **kaydedilmiş taban işaretçisi (EBP/RBP)**'nin önceki işleve geri dönüş için **yığında depolanmasıdır**. Bu nedenle, bir saldırgan bunları üzerine yazabilir ve programın **yürütme akışını kontrol edebilir**.

Bu zafiyet genellikle bir işlevin **yığına ayrılan miktarından daha fazla bayt kopyaladığı** için ortaya çıkar, bu nedenle yığının diğer kısımlarını üzerine yazabilir.

Bu zafiyete duyarlı olan bazı yaygın işlevler: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ayrıca, bir **uzunluk argümanı alan** **`fgets`**, **`read` & `memcpy`** gibi işlevler, belirtilen uzunluğun ayrılan uzunluktan büyük olduğu durumlarda zafiyetli bir şekilde kullanılabilir.

Örneğin, aşağıdaki işlevler zafiyete açık olabilir:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Overflow Ofsetlerini Bulma

Yığın taşmalarını bulmanın en yaygın yolu, çok büyük bir `A` girişi vermek (örneğin `python3 -c 'print("A"*1000)'`) ve **erişilmeye çalışılan adresin `0x41414141` olduğunu gösteren** bir `Segmentation Fault` beklemektir.

Ayrıca, Yığın Taşma açığı bulduğunuzda, genellikle bir **De Bruijn dizisi** kullanılır. Bu, _k_ boyutunda bir alfabeye ve _n_ uzunluğundaki alt dizilere sahip bir dizi olup, **her olası _n_ uzunluğundaki alt dizinin tam olarak bir kez** ardışık bir alt dizi olarak göründüğü döngüsel bir dizidir.

Bu şekilde, EIP'yi kontrol etmek için hangi ofsetin gerektiğini el ile bulmak yerine, bu dizilerden birini dolgu olarak kullanmak ve ardından üzerine yazılan baytların ofsetini bulmak mümkündür.

Bunun için genellikle **pwntools** kullanılabilir:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
veya **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Yığın Taşmalarını Sömürme

Taşma sırasında (taşma boyutu yeterince büyükse) yığın içindeki yerel değişkenlerin değerlerini **üzerine yazabilirsiniz** ve kaydedilmiş **EBP/RBP ve EIP/RIP'yi (hatta daha fazlasını)** bulana kadar.\
Bu tür bir zafiyeti istismar etmenin en yaygın yolu, **dönüş adresini değiştirmektir**, böylece işlev bittiğinde **kontrol akışı kullanıcının belirttiği yere yönlendirilir**.

Ancak, diğer senaryolarda belki sadece **yığında bazı değişken değerlerini üzerine yazmak** yeterli olabilir (kolay CTF zorluklarında olduğu gibi).

### Ret2win

Bu tür CTF zorluklarında, **asla çağrılmayan** bir **işlev** **içinde** bulunan ve **çağrılması gereken bir işlev** bulunmaktadır. Bu zorluklarda sadece **dönüş adresini üzerine yazmak için ofseti bulmanız** ve çağrılacak işlevin adresini bulmanız yeterlidir (genellikle [**ASLR**](../common-binary-protections-and-bypasses/aslr/) devre dışı bırakılmış olacaktır), bu sayede zafiyetli işlev döndüğünde gizli işlev çağrılacaktır:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Yığın Kabuk Kodu

Bu senaryoda saldırgan, yığında bir kabuk kodu yerleştirebilir ve kontrol edilen EIP/RIP'yi kötü amaçlı kodu çalıştırmak için kabuk kodusuna atlamak için kullanabilir:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROP ve Ret2... teknikleri

Bu teknik, önceki tekniğe başlıca korumayı atlamak için temel çerçevedir: **Yürütülebilir yığın yok (NX)**. Ve ikili dosyadaki mevcut talimatları kötüye kullanarak keyfi komutları çalıştırmayı sağlayan diğer teknikleri gerçekleştirmenize olanak tanır (ret2lib, ret2syscall...):

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Yığın Taşmaları

Bir taşma her zaman yığında olmayabilir, örneğin **yığın** içinde de olabilir:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Koruma Türleri

Zafiyetlerin istismarını önlemeye çalışan çeşitli korumalar bulunmaktadır, bunları kontrol edin:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
