# Stack Overflow

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Stack Overflow Nedir

Bir **yığın taşması (stack overflow)**, bir programın yığına ayrılan kapasiteden daha fazla veri yazdığında meydana gelen bir güvenlik açığıdır. Bu fazla veri, **bitişik bellek alanını üzerine yazarak** geçerli verilerin bozulmasına, kontrol akışının bozulmasına ve potansiyel olarak kötü amaçlı kodun yürütülmesine neden olabilir. Bu sorun genellikle, giriş üzerinde sınırların kontrol edilmediği güvenli olmayan işlevlerin kullanılmasından kaynaklanır.

Bu üzerine yazma sorununun ana nedeni, **kaydedilmiş komut işaretçisi (EIP/RIP)** ve **kaydedilmiş taban işaretçisi (EBP/RBP)**'nin önceki işleve geri dönüş için **yığında depolanmasıdır**. Bu nedenle, bir saldırgan bunları üzerine yazarak programın yürütme akışını **kontrol edebilir**.

Bu zafiyet genellikle bir işlevin **yığına ayrılan miktarın üzerinde bayt kopyaladığı** için ortaya çıkar, bu nedenle yığının diğer kısımlarını üzerine yazabilir.

Bu duruma duyarlı bazı yaygın işlevler: **`strcpy`, `strcat`, `sprintf`, `gets`**... Ayrıca, uzunluk argümanı alan **`fgets`**, **`read` & `memcpy`** gibi işlevler, belirtilen uzunluğun ayrılan uzunluktan büyük olduğu durumlarda duyarlı bir şekilde kullanılabilir.

Örneğin, aşağıdaki işlevler duyarlı olabilir:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Stack Taşmaları Ofsetlerini Bulma

Stack taşmalarını bulmanın en yaygın yolu, çok büyük bir `A` girdisi vermek (örneğin `python3 -c 'print("A"*1000)'`) ve **erişilmeye çalışılan adresin `0x41414141` olduğunu gösteren** bir `Segmentation Fault` almayı beklemektir.

Ayrıca, Stack Overflow zafiyetinin bulunduğunu keşfettikten sonra, **dönüş adresini üzerine yazabileceğiniz ofseti bulmanız gerekecektir**, bunun için genellikle bir **De Bruijn dizisi** kullanılır. Bu, _k_ boyutunda bir alfabeye ve _n_ uzunluğundaki alt dizilere sahip bir dizi olup, **her olası _n_ uzunluğundaki alt dizinin tam olarak bir kez** ardışık bir alt dizi olarak göründüğü döngüsel bir dizidir.

Bu şekilde, EIP'yi kontrol etmek için hangi ofsetin gerektiğini el ile bulmak yerine, bu dizilerden birini dolgu olarak kullanmak ve ardından üzerine yazmayı bitiren baytların ofsetini bulmak mümkündür.

Bunun için genellikle **pwntools** kullanılabilir:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
veya **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Stack Overflow Sömürme

Taşma gerçekleştiğinde (taşma boyutu yeterince büyükse) yığın içindeki yerel değişkenlerin değerlerini **üzerine yazabilirsiniz** ve kaydedilmiş **EBP/RBP ve EIP/RIP'yi (hatta daha fazlasını)** bulana kadar devam edebilirsiniz.\
Bu tür bir zafiyeti istismar etmenin en yaygın yolu, **dönüş adresini değiştirerek** işlev sona erdiğinde **kontrol akışını kullanıcının belirttiği yere yönlendirmektir**.

Ancak, diğer senaryolarda belki sadece **yığında bazı değişken değerlerini üzerine yazmak** istismar için yeterli olabilir (kolay CTF zorluklarında olduğu gibi).

### Ret2win

Bu tür CTF zorluklarında, **asla çağrılmayan** ve **kazanmak için çağrmanız gereken bir işlev** olan bir **işlev** **binary içinde** bulunmaktadır. Bu zorluklar için sadece **dönüş adresini üzerine yazmak için ofseti bulmanız** ve çağrılacak işlevin adresini bulmanız (genellikle [**ASLR**](../common-binary-protections-and-bypasses/aslr/) devre dışı bırakılmış olacaktır) yeterlidir, böylece zafiyetli işlev döndüğünde gizli işlev çağrılacaktır:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Yığın Kabuk Kodu

Bu senaryoda saldırgan, bir kabuk kodunu yığına yerleştirebilir ve kontrol edilen EIP/RIP'yi kabuk koduna atlamak ve keyfi kodu yürütmek için kullanabilir:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### ROP ve Ret2... teknikleri

Bu teknik, önceki tekniğin ana korumasını atlamak için temel çerçevedir: **Yürütülebilir yığın yok (NX)**. Ve bu, ikili dosyadaki mevcut talimatları kötüye kullanarak keyfi komutları yürütmeyi sağlayan diğer teknikleri gerçekleştirmenizi sağlar (ret2lib, ret2syscall...):

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Yığın Taşmaları

Bir taşma her zaman yığında olmayabilir, örneğin **yığın** içinde de olabilir:

{% content-ref url="../heap/heap-overflow.md" %}
[heap-overflow.md](../heap/heap-overflow.md)
{% endcontent-ref %}

## Koruma Türleri

Zafiyetlerin istismarını önlemeye çalışan çeşitli korumalar bulunmaktadır, bunları kontrol edin:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}
