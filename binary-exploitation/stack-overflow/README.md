# Stack Overflow

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Cos'√® uno Stack Overflow

Uno **stack overflow** √® una vulnerabilit√† che si verifica quando un programma scrive pi√π dati nello stack di quanto sia allocato per contenerli. Questi dati in eccesso **sovrascriveranno lo spazio di memoria adiacente**, portando alla corruzione dei dati validi, alla interruzione del flusso di controllo e potenzialmente all'esecuzione di codice dannoso. Questo problema spesso si verifica a causa dell'uso di funzioni non sicure che non effettuano il controllo dei limiti sull'input.

Il problema principale di questa sovrascrittura √® che il **puntatore all'istruzione salvata (EIP/RIP)** e il **puntatore alla base salvata (EBP/RBP)** per tornare alla funzione precedente sono **memorizzati nello stack**. Pertanto, un attaccante sar√† in grado di sovrascrivere quelli e **controllare il flusso di esecuzione del programma**.

La vulnerabilit√† di solito si verifica perch√© una funzione **copia all'interno dello stack pi√π byte di quanti ne siano stati allocati**, quindi √® in grado di sovrascrivere altre parti dello stack.

Alcune funzioni comuni vulnerabili a questo sono: **`strcpy`, `strcat`, `sprintf`, `gets`**... Inoltre, funzioni come **`fgets`**, **`read` & `memcpy`** che richiedono un **argomento di lunghezza**, potrebbero essere utilizzate in modo vulnerabile se la lunghezza specificata √® maggiore di quella allocata.

Ad esempio, le seguenti funzioni potrebbero essere vulnerabili:
```c
void vulnerable() {
char buffer[128];
printf("Enter some text: ");
gets(buffer); // This is where the vulnerability lies
printf("You entered: %s\n", buffer);
}
```
### Trovare gli offset delle vulnerabilit√† di stack overflow

Il modo pi√π comune per trovare le vulnerabilit√† di stack overflow √® inserire un input molto grande di `A` (ad esempio `python3 -c 'print("A"*1000)'`) e aspettarsi un `Segmentation Fault` che indica che si √® cercato di accedere all'**indirizzo `0x41414141`**.

Inoltre, una volta individuata la presenza di una vulnerabilit√† di stack overflow, sar√† necessario trovare l'offset fino a quando sar√† possibile **sovrascrivere l'indirizzo di ritorno**, per questo di solito si utilizza una **sequenza di De Bruijn**. Che per un dato alfabeto di dimensione _k_ e sottosequenze di lunghezza _n_ √® una **sequenza ciclica in cui ogni possibile sottosequenza di lunghezza _n_** appare esattamente una volta come sottosequenza contigua.

In questo modo, anzich√© dover capire manualmente quale offset √® necessario per controllare l'EIP, √® possibile utilizzare una di queste sequenze come padding e quindi trovare l'offset dei byte che hanno finito per sovrascriverlo.

√à possibile utilizzare **pwntools** per questo:
```python
from pwn import *

# Generate a De Bruijn sequence of length 1000 with an alphabet size of 256 (byte values)
pattern = cyclic(1000)

# This is an example value that you'd have found in the EIP/IP register upon crash
eip_value = p32(0x6161616c)
offset = cyclic_find(eip_value)  # Finds the offset of the sequence in the De Bruijn pattern
print(f"The offset is: {offset}")
```
o **GEF**:
```bash
#Patterns
pattern create 200 #Generate length 200 pattern
pattern search "avaaawaa" #Search for the offset of that substring
pattern search $rsp #Search the offset given the content of $rsp
```
## Sfruttare gli Stack Overflow

Durante un overflow (supponendo che la dimensione dell'overflow sia abbastanza grande) sarai in grado di **sovrascrivere** i valori delle variabili locali nello stack fino a raggiungere i salvati **EBP/RBP e EIP/RIP (o anche di pi√π)**.\
Il modo pi√π comune per sfruttare questo tipo di vulnerabilit√† √® **modificare l'indirizzo di ritorno** in modo che quando la funzione termina il **controllo del flusso sar√† reindirizzato ovunque l'utente abbia specificato** in questo puntatore.

Tuttavia, in altri scenari forse **sovrascrivere alcuni valori delle variabili nello stack** potrebbe essere sufficiente per lo sfruttamento (come nelle sfide CTF facili).

### Ret2win

In questo tipo di sfide CTF, c'√® una **funzione** **all'interno** del binario che **non viene mai chiamata** e che **devi chiamare per vincere**. Per queste sfide devi solo trovare l'**offset per sovrascrivere l'indirizzo di ritorno** e **trovare l'indirizzo della funzione** da chiamare (di solito [**ASLR**](../common-binary-protections-and-bypasses/aslr/) sarebbe disabilitato) in modo che quando la funzione vulnerabile ritorna, la funzione nascosta verr√† chiamata:

{% content-ref url="ret2win/" %}
[ret2win](ret2win/)
{% endcontent-ref %}

### Shellcode nello Stack

In questo scenario l'attaccante potrebbe inserire uno shellcode nello stack e sfruttare l'EIP/RIP controllato per saltare allo shellcode ed eseguire codice arbitrario:

{% content-ref url="stack-shellcode/" %}
[stack-shellcode](stack-shellcode/)
{% endcontent-ref %}

### Tecniche ROP & Ret2...

Questa tecnica √® il framework fondamentale per aggirare la principale protezione della tecnica precedente: **No executable stack (NX)**. E permette di eseguire diverse altre tecniche (ret2lib, ret2syscall...) che finiranno per eseguire comandi arbitrari sfruttando istruzioni esistenti nel binario:

{% content-ref url="../rop-return-oriented-programing/" %}
[rop-return-oriented-programing](../rop-return-oriented-programing/)
{% endcontent-ref %}

## Heap Overflow

Un overflow non avviene sempre nello stack, potrebbe anche verificarsi nell'**heap** ad esempio:

{% content-ref url="../libc-heap/heap-overflow.md" %}
[heap-overflow.md](../libc-heap/heap-overflow.md)
{% endcontent-ref %}

## Tipi di protezioni

Ci sono diverse protezioni che cercano di prevenire lo sfruttamento delle vulnerabilit√†, controllale in:

{% content-ref url="../common-binary-protections-and-bypasses/" %}
[common-binary-protections-and-bypasses](../common-binary-protections-and-bypasses/)
{% endcontent-ref %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
