# Onge√Ønitialiseerde Veranderlikes

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

Die kernidee hier is om te verstaan wat gebeur met **onge√Ønitialiseerde veranderlikes aangesien hulle die waarde sal h√™ wat reeds in die toegewysde geheue aan hulle was.** Voorbeeld:

* **Funksie 1: `initializeVariable`**: Ons verklaar 'n veranderlike `x` en ken dit 'n waarde toe, s√™ ons `0x1234`. Hierdie aksie is soortgelyk aan die reservering van 'n plek in die geheue en die plaas van 'n spesifieke waarde daarin.
* **Funksie 2: `useUninitializedVariable`**: Hier verklaar ons 'n ander veranderlike `y` maar ken geen waarde daaraan toe nie. In C word onge√Ønitialiseerde veranderlikes nie outomaties na nul ingestel nie. In plaas daarvan behou hulle die waarde wat laas by hul geheueposisie gestoor was.

Wanneer ons hierdie twee funksies **opeenvolgend** hardloop:

1. In `initializeVariable` word `x` 'n waarde toegeken (`0x1234`), wat 'n spesifieke geheue-adres inneem.
2. In `useUninitializedVariable` word `y` verklaar maar nie 'n waarde daaraan toegeken nie, sodat dit die geheueposisie reg na `x` inneem. As gevolg van die nie-inisialisering van `y`, erf dit uiteindelik die waarde van dieselfde geheueposisie wat deur `x` gebruik is, omdat dit die laaste waarde was wat daar was.

Hierdie gedrag illustreer 'n sleutelkonsep in laevlak-programmering: **Geheuebestuur is krities**, en onge√Ønitialiseerde veranderlikes kan lei tot onvoorspelbare gedrag of sekuriteitskwessies, aangesien hulle moontlik sensitiewe data wat in die geheue agtergelaat is, onbedoeld kan behou.

Onge√Ønitialiseerde stapelveranderlikes kan verskeie sekuriteitsrisiko's inhou soos:

* **Datalek**: Sensitiewe inligting soos wagwoorde, enkripsiesleutels, of persoonlike besonderhede kan blootgestel word as dit in onge√Ønitialiseerde veranderlikes gestoor word, wat aanvallers moontlik in staat stel om hierdie data te lees.
* **Inligtingsoffergawe**: Die inhoud van onge√Ønitialiseerde veranderlikes kan besonderhede oor die program se geheue-uitleg of interne werking blootl√™, wat aanvallers kan help om geteikende aanvalle te ontwikkel.
* **Klaskrake en Onstabiliteit**: Operasies met betrekking tot onge√Ønitialiseerde veranderlikes kan lei tot ongedefinieerde gedrag, wat tot programkrake of onvoorspelbare uitkomste kan lei.
* **Willekeurige Kode-uitvoering**: In sekere scenario's kan aanvallers hierdie kwessies uitbuit om die program se uitvoervloei te verander, wat hulle in staat stel om willekeurige kode uit te voer, wat moontlik afgele√´ kode-uitvoeringsbedreigings kan insluit.

### Voorbeeld
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Hoe Dit Werk:

* **`initializeAndPrint` Funksie**: Hierdie funksie verklaar 'n heelgetal veranderlike `initializedVar`, ken dit die waarde `100` toe, en druk dan beide die geheue-adres en die waarde van die veranderlike af. Hierdie stap is reguit vorentoe en toon hoe 'n ge√Ønisialiseerde veranderlike optree.
* **`demonstreerOnge√ØnisialiseerdeVar` Funksie**: In hierdie funksie verklaar ons 'n heelgetal veranderlike `uninitializedVar` sonder om dit te inisialiseer. Wanneer ons probeer om die waarde af te druk, kan die uitset 'n lukrake nommer toon. Hierdie nommer verteenwoordig enige data wat voorheen by daardie geheue-posisie was. Afhangende van die omgewing en die samesteller, kan die werklike uitset wissel, en soms, vir veiligheid, kan sommige samestellers outomaties veranderlikes na nul inisialiseer, alhoewel hierdie nie op vertrou moet word nie.
* **`main` Funksie**: Die `main` funksie roep beide van die bogenoemde funksies in volgorde aan, wat die teenstelling tussen 'n ge√Ønisialiseerde veranderlike en 'n onge√Ønisialiseerde een demonstreer.

## ARM64 Voorbeeld

Dit verander glad nie in ARM64 nie aangesien plaaslike veranderlikes ook in die stok bestuur word, jy kan [**hierdie voorbeeld nagaan**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) waar dit gewys word.
