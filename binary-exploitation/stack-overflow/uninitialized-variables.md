# Nicht initialisierte Variablen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Die Kernidee hier ist zu verstehen, was mit **nicht initialisierten Variablen passiert, da sie den Wert haben werden, der bereits im ihnen zugewiesenen Speicher war.** Beispiel:

* **Funktion 1: `initializeVariable`**: Wir deklarieren eine Variable `x` und weisen ihr einen Wert zu, sagen wir `0x1234`. Diese Aktion entspricht dem Reservieren eines Speicherplatzes und dem Einf√ºgen eines bestimmten Werts.
* **Funktion 2: `useUninitializedVariable`**: Hier deklarieren wir eine weitere Variable `y`, weisen ihr jedoch keinen Wert zu. In C werden nicht initialisierte Variablen nicht automatisch auf Null gesetzt. Stattdessen behalten sie den zuletzt an ihrem Speicherort gespeicherten Wert bei.

Wenn wir diese beiden Funktionen **sequenziell** ausf√ºhren:

1. In `initializeVariable` wird `x` ein Wert zugewiesen (`0x1234`), der eine bestimmte Speicheradresse belegt.
2. In `useUninitializedVariable` wird `y` deklariert, aber kein Wert zugewiesen, sodass es den Speicherplatz direkt nach `x` einnimmt. Aufgrund der Nichtinitialisierung von `y` erbt es den Wert aus demselben Speicherort, der von `x` verwendet wurde, da dies der letzte Wert war, der dort war.

Dieses Verhalten veranschaulicht ein wichtiges Konzept in der Low-Level-Programmierung: **Speicherverwaltung ist entscheidend**, und nicht initialisierte Variablen k√∂nnen zu unvorhersehbarem Verhalten oder Sicherheitsl√ºcken f√ºhren, da sie m√∂glicherweise unbeabsichtigt sensible Daten enthalten, die im Speicher verblieben sind.

Nicht initialisierte Stapelvariablen k√∂nnten mehrere Sicherheitsrisiken darstellen wie:

* **Datenleck**: Sensible Informationen wie Passw√∂rter, Verschl√ºsselungsschl√ºssel oder pers√∂nliche Daten k√∂nnen offengelegt werden, wenn sie in nicht initialisierten Variablen gespeichert sind, was es Angreifern erm√∂glicht, diese Daten potenziell zu lesen.
* **Informationsweitergabe**: Der Inhalt nicht initialisierter Variablen k√∂nnte Details zur Speicherstruktur des Programms oder internen Abl√§ufen preisgeben, was Angreifern bei der Entwicklung gezielter Exploits helfen k√∂nnte.
* **Abst√ºrze und Instabilit√§t**: Operationen mit nicht initialisierten Variablen k√∂nnen zu undefiniertem Verhalten f√ºhren, was zu Programmabst√ºrzen oder unvorhersehbaren Ergebnissen f√ºhren kann.
* **Willk√ºrliche Codeausf√ºhrung**: In bestimmten Szenarien k√∂nnten Angreifer diese Schwachstellen ausnutzen, um den Programmfluss zu √§ndern und so die Ausf√ºhrung beliebigen Codes zu erm√∂glichen, der m√∂glicherweise Bedrohungen durch die Ausf√ºhrung von Remote-Code enth√§lt.

### Beispiel
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Wie das funktioniert:

* **`initializeAndPrint` Funktion**: Diese Funktion deklariert eine Ganzzahlvariable `initializedVar`, weist ihr den Wert `100` zu und druckt dann sowohl die Speicheradresse als auch den Wert der Variablen aus. Dieser Schritt ist unkompliziert und zeigt, wie sich eine initialisierte Variable verh√§lt.
* **`demonstrateUninitializedVar` Funktion**: In dieser Funktion deklarieren wir eine Ganzzahlvariable `uninitializedVar`, ohne sie zu initialisieren. Wenn wir versuchen, ihren Wert auszudrucken, k√∂nnte die Ausgabe eine Zufallszahl anzeigen. Diese Zahl repr√§sentiert die Daten, die zuvor an dieser Speicherstelle vorhanden waren. Abh√§ngig von der Umgebung und dem Compiler kann die tats√§chliche Ausgabe variieren, und manchmal initialisieren einige Compiler Variablen automatisch auf Null, obwohl man sich nicht darauf verlassen sollte.
* **`main` Funktion**: Die `main` Funktion ruft beide oben genannten Funktionen nacheinander auf und zeigt den Unterschied zwischen einer initialisierten und einer nicht initialisierten Variablen.

## ARM64 Beispiel

Dies √§ndert sich nicht bei ARM64, da lokale Variablen auch im Stack verwaltet werden, Sie k√∂nnen [**dieses Beispiel √ºberpr√ºfen**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/), wo dies gezeigt wird.
