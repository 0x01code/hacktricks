# 未初始化变量

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

这里的核心思想是理解**未初始化变量的情况，因为它们将具有已分配给它们的内存中的值。** 例如：

* **函数1：`initializeVariable`**：我们声明一个变量`x`并为其赋值，比如`0x1234`。这个操作类似于在内存中保留一个位置并放入一个特定的值。
* **函数2：`useUninitializedVariable`**：在这里，我们声明另一个变量`y`，但不为其赋值。在C语言中，未初始化变量不会自动设置为零。相反，它们保留其内存位置上最后存储的任何值。

当我们**按顺序**运行这两个函数时：

1. 在`initializeVariable`中，`x`被赋予一个值（`0x1234`），它占据了一个特定的内存地址。
2. 在`useUninitializedVariable`中，`y`被声明但未赋值，因此它占据了紧随`x`之后的内存位置。由于未初始化`y`，它最终“继承”了与`x`使用的相同内存位置中的值，因为那是上次存储在那里的值。

这种行为展示了低级编程中的一个关键概念：**内存管理至关重要**，未初始化变量可能导致不可预测的行为或安全漏洞，因为它们可能无意中保留在内存中的敏感数据。

### 示例
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### 工作原理：

* **`initializeAndPrint` 函数**：此函数声明一个整数变量 `initializedVar`，将其赋值为 `100`，然后打印变量的内存地址和值。这一步很简单，展示了一个初始化变量的行为。
* **`demonstrateUninitializedVar` 函数**：在此函数中，我们声明一个整数变量 `uninitializedVar`，但没有对其进行初始化。当我们尝试打印其值时，输出可能显示一个随机数。这个数字代表先前在该内存位置的任何数据。根据环境和编译器的不同，实际输出可能有所不同，有时为了安全起见，一些编译器可能会自动将变量初始化为零，但不应依赖于此。
* **`main` 函数**：`main` 函数按顺序调用上述两个函数，展示了初始化变量和未初始化变量之间的对比。
