# 未初期化変数

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法：

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい場合は** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする。
* **ハッキングトリックを共有するために PR を提出して** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の GitHub リポジトリに貢献する。

</details>

## 基本情報

ここでの基本的な考え方は、**未初期化変数がどのように動作するかを理解することです。それらは、それらに割り当てられたメモリ内の値を持つことになります。** 例：

* **関数 1: `initializeVariable`**: 変数 `x` を宣言し、値を割り当てます。たとえば `0x1234` とします。このアクションは、メモリ内の場所を予約し、特定の値を入れることに似ています。
* **関数 2: `useUninitializedVariable`**: ここでは、別の変数 `y` を宣言しますが、値を割り当てません。C言語では、未初期化変数は自動的にゼロに設定されません。代わりに、それらはメモリ位置に最後に格納された値を保持します。

これらの2つの関数を**順次**実行すると：

1. `initializeVariable` では、`x` に値 (`0x1234`) が割り当てられ、特定のメモリアドレスを占有します。
2. `useUninitializedVariable` では、`y` が宣言されますが、値は割り当てられません。したがって、`x` の直後のメモリスポットを取ります。`y` を初期化しなかったため、`x` が使用した同じメモリ位置から値を「継承」することになります。

この動作は、低レベルプログラミングの重要な概念を示しています：**メモリ管理が重要**であり、未初期化変数は予測不可能な動作やセキュリティの脆弱性につながる可能性があります。なぜなら、それらはメモリに残された機密データを意図せず保持する可能性があるからです。

### 例
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### 動作原理：

- **`initializeAndPrint` 関数**：この関数は整数型変数 `initializedVar` を宣言し、値 `100` を割り当て、その後変数のメモリアドレスと値を表示します。このステップは直感的で、初期化された変数の動作を示しています。
- **`demonstrateUninitializedVar` 関数**：この関数では、初期化せずに整数型変数 `uninitializedVar` を宣言します。その値を表示しようとすると、出力にはランダムな数値が表示されるかもしれません。この数値は、以前そのメモリ位置にあったデータを表します。環境やコンパイラによって、実際の出力は異なる場合があり、時には安全のために一部のコンパイラが変数を自動的にゼロに初期化することがありますが、これに依存すべきではありません。
- **`main` 関数**：`main` 関数は上記の両関数を順次呼び出し、初期化された変数と初期化されていない変数の対比を示しています。
