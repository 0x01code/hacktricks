# Variables non initialis√©es

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

L'id√©e principale ici est de comprendre ce qui se passe avec les **variables non initialis√©es car elles auront la valeur qui √©tait d√©j√† dans la m√©moire qui leur a √©t√© attribu√©e.** Exemple :

* **Fonction 1 : `initializeVariable`** : Nous d√©clarons une variable `x` et lui attribuons une valeur, disons `0x1234`. Cette action revient √† r√©server un emplacement en m√©moire et y mettre une valeur sp√©cifique.
* **Fonction 2 : `useUninitializedVariable`** : Ici, nous d√©clarons une autre variable `y` mais ne lui attribuons aucune valeur. En C, les variables non initialis√©es ne sont pas automatiquement d√©finies √† z√©ro. Au lieu de cela, elles conservent la derni√®re valeur stock√©e √† leur emplacement m√©moire.

Lorsque nous ex√©cutons ces deux fonctions **s√©quentiellement** :

1. Dans `initializeVariable`, `x` se voit attribuer une valeur (`0x1234`), qui occupe une adresse m√©moire sp√©cifique.
2. Dans `useUninitializedVariable`, `y` est d√©clar√© mais aucune valeur ne lui est attribu√©e, donc il prend la place m√©moire juste apr√®s `x`. En raison de la non-initialisation de `y`, il finit par "h√©riter" de la valeur du m√™me emplacement m√©moire utilis√© par `x`, car c'est la derni√®re valeur qui s'y trouvait.

Ce comportement illustre un concept cl√© en programmation de bas niveau : **La gestion de la m√©moire est cruciale**, et les variables non initialis√©es peuvent entra√Æner un comportement impr√©visible ou des vuln√©rabilit√©s de s√©curit√©, car elles peuvent involontairement contenir des donn√©es sensibles laiss√©es en m√©moire.

Les variables de pile non initialis√©es pourraient pr√©senter plusieurs risques de s√©curit√© tels que :

* **Fuite de donn√©es** : Des informations sensibles telles que des mots de passe, des cl√©s de chiffrement ou des d√©tails personnels peuvent √™tre expos√©s si elles sont stock√©es dans des variables non initialis√©es, permettant aux attaquants de potentiellement lire ces donn√©es.
* **Divulgation d'informations** : Le contenu des variables non initialis√©es pourrait r√©v√©ler des d√©tails sur la disposition de la m√©moire du programme ou ses op√©rations internes, aidant les attaquants √† d√©velopper des exploits cibl√©s.
* **Crashes et instabilit√©** : Les op√©rations impliquant des variables non initialis√©es peuvent entra√Æner un comportement ind√©fini, conduisant √† des plantages de programme ou √† des r√©sultats impr√©visibles.
* **Ex√©cution de code arbitraire** : Dans certains sc√©narios, les attaquants pourraient exploiter ces vuln√©rabilit√©s pour modifier le flux d'ex√©cution du programme, leur permettant d'ex√©cuter un code arbitraire, qui pourrait inclure des menaces d'ex√©cution de code √† distance.

### Exemple
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Comment cela fonctionne :

* **Fonction `initializeAndPrint`** : Cette fonction d√©clare une variable enti√®re `initializedVar`, lui attribue la valeur `100`, puis affiche √† la fois l'adresse m√©moire et la valeur de la variable. Cette √©tape est simple et montre comment une variable initialis√©e se comporte.
* **Fonction `demonstrateUninitializedVar`** : Dans cette fonction, nous d√©clarons une variable enti√®re `uninitializedVar` sans l'initialiser. Lorsque nous essayons d'afficher sa valeur, la sortie peut montrer un nombre al√©atoire. Ce nombre repr√©sente les donn√©es qui √©taient pr√©c√©demment √† cet emplacement m√©moire. Selon l'environnement et le compilateur, la sortie r√©elle peut varier, et parfois, par mesure de s√©curit√©, certains compilateurs peuvent initialiser automatiquement les variables √† z√©ro, bien que cela ne devrait pas √™tre consid√©r√© comme fiable.
* **Fonction `main`** : La fonction `main` appelle les deux fonctions ci-dessus en s√©quence, d√©montrant la diff√©rence entre une variable initialis√©e et une non initialis√©e.

## Exemple ARM64

Cela ne change pas du tout en ARM64 car les variables locales sont √©galement g√©r√©es dans la pile, vous pouvez [**v√©rifier cet exemple**](https://8ksec.io/arm64-reversing-and-exploitation-part-6-exploiting-an-uninitialized-stack-variable-vulnerability/) o√π cela est montr√©.
