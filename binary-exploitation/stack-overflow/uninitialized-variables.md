# Niezainicjowane zmienne

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe informacje

Główna idea polega na zrozumieniu, co dzieje się z **niezainicjowanymi zmiennymi, ponieważ będą one miały wartość, która była już przypisana do pamięci.** Przykład:

* **Funkcja 1: `initializeVariable`**: Deklarujemy zmienną `x` i przypisujemy jej wartość, powiedzmy `0x1234`. Ta czynność jest podobna do zarezerwowania miejsca w pamięci i umieszczenia w nim określonej wartości.
* **Funkcja 2: `useUninitializedVariable`**: Tutaj deklarujemy inną zmienną `y`, ale nie przypisujemy jej żadnej wartości. W języku C niezainicjowane zmienne nie są automatycznie ustawiane na zero. Zamiast tego zachowują ostatnią wartość przechowywaną na swojej lokalizacji w pamięci.

Gdy uruchamiamy te dwie funkcje **sekwencyjnie**:

1. W `initializeVariable`, `x` otrzymuje wartość (`0x1234`), zajmując określony adres pamięci.
2. W `useUninitializedVariable`, `y` jest deklarowane, ale nie otrzymuje wartości, więc zajmuje miejsce pamięci bezpośrednio po `x`. Ze względu na brak inicjalizacji `y`, kończy się "dziedziczeniem" wartości z tej samej lokalizacji pamięci używanej przez `x`, ponieważ jest to ostatnia wartość, która tam była.

To zachowanie ilustruje kluczowe pojęcie w programowaniu niskopoziomowym: **Zarządzanie pamięcią jest kluczowe**, a niezainicjowane zmienne mogą prowadzić do nieprzewidywalnego zachowania lub podatności na zagrożenia bezpieczeństwa, ponieważ mogą nieumyślnie przechowywać wrażliwe dane pozostawione w pamięci.

### Przykład
```c
#include <stdio.h>

// Function to initialize and print a variable
void initializeAndPrint() {
int initializedVar = 100; // Initialize the variable
printf("Initialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&initializedVar, initializedVar);
}

// Function to demonstrate the behavior of an uninitialized variable
void demonstrateUninitializedVar() {
int uninitializedVar; // Declare but do not initialize
printf("Uninitialized Variable:\n");
printf("Address: %p, Value: %d\n\n", (void*)&uninitializedVar, uninitializedVar);
}

int main() {
printf("Demonstrating Initialized vs. Uninitialized Variables in C\n\n");

// First, call the function that initializes its variable
initializeAndPrint();

// Then, call the function that has an uninitialized variable
demonstrateUninitializedVar();

return 0;
}
```
#### Jak to działa:

* **Funkcja `initializeAndPrint`**: Ta funkcja deklaruje zmienną całkowitą `initializedVar`, przypisuje jej wartość `100`, a następnie drukuje zarówno adres pamięci, jak i wartość zmiennej. Ten krok jest prosty i pokazuje, jak zachowuje się zmienna zainicjowana.
* **Funkcja `demonstrateUninitializedVar`**: W tej funkcji deklarujemy zmienną całkowitą `uninitializedVar` bez jej inicjalizacji. Gdy próbujemy wydrukować jej wartość, wynik może pokazać losową liczbę. Ta liczba reprezentuje dane, które wcześniej znajdowały się pod tym adresem pamięci. W zależności od środowiska i kompilatora, rzeczywisty wynik może się różnić, a czasami, dla bezpieczeństwa, niektóre kompilatory mogą automatycznie inicjować zmienne na zero, chociaż nie należy polegać na tym.
* **Funkcja `main`**: Funkcja `main` wywołuje obie powyższe funkcje sekwencyjnie, demonstrując różnicę między zainicjowaną zmienną a niezainicjowaną.
