# WWW2Exec - GOT/PLT

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## **Podstawowe informacje**

### **GOT: Global Offset Table**

**Global Offset Table (GOT)** to mechanizm używany w binariach dynamicznie łączonych do zarządzania **adresami funkcji zewnętrznych**. Ponieważ te **adresy nie są znane do czasu wykonania** (ze względu na dynamiczne łączenie), GOT zapewnia sposób **dynamicznego aktualizowania adresów tych zewnętrznych symboli** po ich rozwiązaniu.

Każdy wpis w GOT odpowiada symbolowi w zewnętrznych bibliotekach, które binarny może wywołać. Gdy **funkcja jest pierwszy raz wywołana, jej rzeczywisty adres jest rozwiązywany przez dynamiczny łącznik i przechowywany w GOT**. Kolejne wywołania tej samej funkcji używają adresu przechowywanego w GOT, unikając tym samym ponownego rozwiązywania adresu.

### **PLT: Procedure Linkage Table**

**Procedure Linkage Table (PLT)** ściśle współpracuje z GOT i służy jako trampolina do obsługi wywołań funkcji zewnętrznych. Gdy binarny **wywołuje funkcję zewnętrzną po raz pierwszy, kontrola przechodzi do wpisu w PLT związanego z tą funkcją**. Ten wpis PLT jest odpowiedzialny za wywołanie dynamicznego łącznika w celu rozwiązania adresu funkcji, jeśli nie został on jeszcze rozwiązany. Po rozwiązaniu adresu jest on przechowywany w **GOT**.

**Dlatego** wpisy GOT są używane bezpośrednio, gdy adres funkcji zewnętrznej lub zmiennej jest rozwiązany. **Wpisy PLT są używane do ułatwienia początkowego rozwiązania** tych adresów za pomocą dynamicznego łącznika.

## Uzyskanie wykonania

### Sprawdź GOT

Uzyskaj adres tabeli GOT za pomocą: **`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (121).png>)

Zauważ, jak po **załadowaniu** **wykonywalnego** pliku w GEF możesz **zobaczyć** **funkcje**, które znajdują się w **GOT**: `gef➤ x/20x 0xDIR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

Korzystając z GEF, możesz **rozpocząć** sesję **debugowania** i wykonać **`got`** aby zobaczyć tabelę got:

![](<../../.gitbook/assets/image (496).png>)

### GOT2Exec

W binarnym GOT znajdują się **adresy funkcji lub** sekcji **PLT**, która załaduje adres funkcji. Celem tego dowolnego zapisu jest **nadpisanie wpisu GOT** funkcji, która zostanie wykonana później **adresem** PLT funkcji **`system`** na przykład.

Idealnie, **nadpiszesz** **GOT** funkcji, która **zostanie wywołana z kontrolowanymi przez ciebie parametrami** (dzięki czemu będziesz mógł kontrolować parametry przesyłane do funkcji system).

Jeśli **`system`** **nie jest używany** przez skrypt, funkcja systemowa **nie** będzie miała wpisu w PLT. W tym scenariuszu będziesz **musiał najpierw ujawnić adres** funkcji `system`, a następnie nadpisać GOT, aby wskazywał na ten adres.

Możesz zobaczyć adresy PLT za pomocą **`objdump -j .plt -d ./vuln_binary`**

## Wpisy GOT libc

**GOT libc** jest zazwyczaj kompilowany z **częściowym RELRO**, co czyni go atrakcyjnym celem, zakładając, że jest możliwe ustalenie jego adresu ([**ASLR**](../common-binary-protections-and-bypasses/aslr/)).

Powszechne funkcje libc będą wywoływać **inne funkcje wewnętrzne**, których GOT można nadpisać, aby uzyskać wykonanie kodu.

Znajdź [**więcej informacji na temat tej techniki tutaj**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries).

## **Free2system**

W wyzwalaczach eksploatacji sterty często można kontrolować zawartość fragmentów i w pewnym momencie nawet nadpisać tabelę GOT. Prostym trikiem, aby uzyskać RCE, jeśli nie są dostępne żadne gadżety, jest nadpisanie adresu `free` w GOT, aby wskazywał na `system` i zapisanie w fragmencie `"/bin/sh"`. W ten sposób, gdy ten fragment zostanie zwolniony, zostanie wykonane `system("/bin/sh")`.

## **One Gadget**

{% content-ref url="../rop-return-oriented-programing/ret2lib/one-gadget.md" %}
[one-gadget.md](../rop-return-oriented-programing/ret2lib/one-gadget.md)
{% endcontent-ref %}

## **Wykorzystywanie GOT z Heap**

Powszechnym sposobem uzyskania RCE z podatności na stercie jest nadużycie fastbin, aby można było dodać część tabeli GOT do fast bin, dzięki czemu przy każdym przydzieleniu tego fragmentu będzie możliwe **nadpisanie wskaźnika funkcji, zwykle `free`**.\
Następnie, wskazując `free` na `system` i zwalniając fragment, w którym został zapisany `/bin/sh\x00`, zostanie wykonany shell.

Można znaleźć [**przykład tutaj**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk\_extend\_overlapping/#hitcon-trainging-lab13)**.**

## **Zabezpieczenia**

Ochrona **Full RELRO** ma na celu ochronę przed tego rodzaju techniką, rozwiązując wszystkie adresy funkcji podczas uruchamiania binarnego i ustawiając **tabelę GOT jako tylko do odczytu** po tym:

{% content-ref url="../common-binary-protections-and-bypasses/relro.md" %}
[relro.md](../common-binary-protections-and-bypasses/relro.md)
{% endcontent-ref %}
## Odnośniki

* [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
* [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

<details>

<summary><strong>Zacznij od zera i zostań mistrzem hakowania AWS dzięki</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Kup [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>
