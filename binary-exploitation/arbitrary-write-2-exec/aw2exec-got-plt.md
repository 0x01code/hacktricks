# WWW2Exec - GOT/PLT

{% hint style="success" %}
学习并练习AWS Hacking：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习并练习GCP Hacking：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 检查[**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}

## **基本信息**

### **GOT：全局偏移表**

**全局偏移表 (GOT)** 是在动态链接二进制文件中使用的机制，用于管理**外部函数的地址**。由于这些**地址直到运行时才知道**（由于动态链接），GOT 提供了一种在这些外部符号解析后**动态更新这些地址**的方法。

GOT 中的每个条目对应于二进制文件可能调用的外部库中的一个符号。当**首次调用函数时，动态链接器会解析其实际地址并将其存储在 GOT 中**。对同一函数的后续调用使用存储在 GOT 中的地址，从而避免再次解析地址的开销。

### **PLT：过程链接表**

**过程链接表 (PLT)** 与 GOT 密切配合，作为处理对外部函数的调用的跳板。当二进制文件**首次调用外部函数时，控制会传递到与该函数关联的 PLT 条目**。此 PLT 条目负责调用动态链接器以解析函数的地址（如果尚未解析）。地址解析后，将其存储在**GOT** 中。

**因此**，一旦解析外部函数或变量的地址，就直接使用 GOT 条目。**PLT 条目用于通过动态链接器**便于这些地址的初始解析。

## 获取执行

### 检查 GOT

使用以下命令获取 GOT 表的地址：**`objdump -s -j .got ./exec`**

![](<../../.gitbook/assets/image (121).png>)

观察在 GEF 中**加载**可执行文件后，可以**看到**在**GOT** 中的**函数**：`gef➤ x/20x 0xADDR_GOT`

![](<../../.gitbook/assets/image (620) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (2) (2) (2).png>)

使用 GEF，您可以**开始**一个**调试**会话并执行**`got`**以查看 got 表：

![](<../../.gitbook/assets/image (496).png>)

### GOT2Exec

在二进制文件中，GOT 具有**函数的地址或**将加载函数地址的**PLT** 部分的地址。此任意写入的目标是**覆盖将稍后执行的函数的 GOT 条目**，例如，使用**`system`** **函数**的**PLT** 的地址。

理想情况下，您将**覆盖**将由您控制参数调用的**函数**的**GOT**（因此，您将能够控制发送到系统函数的参数）。

如果二进制文件**未使用** **`system`**，则系统函数**将不会**在 PLT 中具有条目。在这种情况下，您将**需要首先泄漏**`system` 函数的地址，然后覆盖 GOT 以指向此地址。

您可以使用**`objdump -j .plt -d ./vuln_binary`** 查看 PLT 地址。

## libc GOT 条目

**libc 的 GOT** 通常使用**部分 RELRO** 编译，这使得它成为一个很好的目标，假设可以找出其地址（[**ASLR**](../common-binary-protections-and-bypasses/aslr/)）。

libc 的常见函数将调用**其他内部函数**，这些函数的 GOT 可能会被覆盖以获取代码执行。

在[**此处找到有关此技术的更多信息**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#1---targetting-libc-got-entries)。

### **Free2system**

在堆利用 CTF 中，通常可以控制块的内容，甚至在某个时刻覆盖 GOT 表。如果没有可用的 one gadgets，一个简单的技巧是将 `free` 的 GOT 地址覆盖为 `system`，并在块内写入 `"/bin/sh"`。这样，当释放此块时，将执行 `system("/bin/sh")`。

### **Strlen2system**

另一种常见技术是将**`strlen`** 的 GOT 地址覆盖为**`system`**，因此如果使用用户输入调用此函数，则可以传递字符串 `"/bin/sh"` 并获得 shell。

此外，如果 `puts` 与用户输入一起使用，则可以将 `strlen` 的 GOT 地址覆盖为 `system` 并传递字符串 `"/bin/sh"` 以获取 shell，因为**`puts` 将使用用户输入调用 `strlen`**。

## **One Gadget**

{% content-ref url="../rop-return-oriented-programing/ret2lib/one-gadget.md" %}
[one-gadget.md](../rop-return-oriented-programing/ret2lib/one-gadget.md)
{% endcontent-ref %}

## **从堆滥用 GOT**

从堆漏洞获取 RCE 的常见方法是滥用 fastbin，以便将 GOT 表的一部分添加到 fast bin 中，因此每当分配该块时，将有可能**覆盖函数指针，通常是 `free`**。\
然后，将 `free` 指向 `system`，并释放写有 `/bin/sh\x00` 的块，将执行 shell。

可以在[**此处找到示例**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/chunk\_extend\_overlapping/#hitcon-trainging-lab13)**。**
## **保护**

**Full RELRO** 保护旨在通过在二进制文件启动时解析所有函数的地址并在此后将 **GOT 表设为只读** 来防止这种技术：

{% content-ref url="../common-binary-protections-and-bypasses/relro.md" %}
[relro.md](../common-binary-protections-and-bypasses/relro.md)
{% endcontent-ref %}

## 参考资料

* [https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite](https://ir0nstone.gitbook.io/notes/types/stack/got-overwrite/exploiting-a-got-overwrite)
* [https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook](https://ir0nstone.gitbook.io/notes/types/stack/one-gadgets-and-malloc-hook)

{% hint style="success" %}
学习并练习 AWS 黑客技术：<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks 培训 AWS 红队专家 (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
学习并练习 GCP 黑客技术：<img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks 培训 GCP 红队专家 (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>支持 HackTricks</summary>

* 查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注** 我们的 **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享黑客技巧。

</details>
{% endhint %}
