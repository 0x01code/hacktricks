# WWW2Exec - .dtors & .fini\_array

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite **va≈°u kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJEM**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## .dtors

{% hint style="danger" %}
Danas je veoma **ƒçudno naƒái binarni fajl sa .dtors sekcijom!**
{% endhint %}

Destruktori su funkcije koje se **izvr≈°avaju pre zavr≈°etka programa** (nakon ≈°to se funkcija `main` zavr≈°i).\
Adrese ovih funkcija se ƒçuvaju unutar **`.dtors`** sekcije binarnog fajla i stoga, ako uspete da **upi≈°ete** adresu **shell koda** u **`__DTOR_END__`**, taj ƒáe se **izvr≈°iti** pre nego ≈°to program zavr≈°i.

Dobijte adresu ove sekcije sa:
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
Obiƒçno ƒáete pronaƒái **DTOR** markere **izmeƒëu** vrednosti `ffffffff` i `00000000`. Dakle, ako vidite samo te vrednosti, to znaƒçi da **nema registrovane funkcije**. Zato **prepi≈°ite** **`00000000`** sa **adresom** **shell koda** kako biste ga izvr≈°ili.

{% hint style="warning" %}
Naravno, prvo morate pronaƒái **mesto za ƒçuvanje shell koda** kako biste ga kasnije mogli pozvati.
{% endhint %}

## **.fini\_array**

Essentially this is a structure with **functions that will be called** before the program finishes, like **`.dtors`**. This is interesting if you can call your **shellcode just jumping to an address**, or in cases where you need to go **back to `main`** again to **exploit the vulnerability a second time**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Napomena da kada se izvr≈°i funkcija iz **`.fini_array`** prelazi se na sledeƒáu, tako da neƒáe biti izvr≈°ena vi≈°e puta (sprjeƒçavajuƒái veƒçne petlje), ali ƒáe vam dati samo 1 **izvr≈°enje funkcije** postavljene ovde.

Napomena da se unosi u `.fini_array` nazivaju u **obrnutom** redosledu, pa verovatno ≈æelite da poƒçnete sa pisanjem od poslednjeg.

#### Veƒçna petlja

Da biste zloupotrebili **`.fini_array`** kako biste dobili veƒçnu petlju, mo≈æete [**proveriti ≈°ta je uraƒëeno ovde**](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)**:** Ako imate najmanje 2 unosa u **`.fini_array`**, mo≈æete:

* Koristite svoj prvi zapis da **ponovo pozovete ranjivu funkciju za proizvoljno pisanje**
* Zatim, izraƒçunajte povratnu adresu na steku koju ƒçuva **`__libc_csu_fini`** (funkcija koja poziva sve funkcije `.fini_array`) i stavite tamo **adresu `__libc_csu_fini`**
* To ƒáe naterati **`__libc_csu_fini`** da pozove sam sebe ponovo izvr≈°avajuƒái ponovo funkcije **`.fini_array`** koje ƒáe pozvati ranjivu WWW funkciju 2 puta: jednom za **proizvoljno pisanje** i jo≈° jednom da ponovo prepi≈°e **povratnu adresu `__libc_csu_fini`** na steku da bi se ponovo pozvao.

{% hint style="danger" %}
Napomena da sa [**Full RELRO**](../common-binary-protections-and-bypasses/relro.md)**,** odeljak **`.fini_array`** je postavljen kao **samo za ƒçitanje**.
{% endhint %}

## link\_map

Kao ≈°to je obja≈°njeno [**u ovom postu**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure), ako program zavr≈°i kori≈°ƒáenjem `return` ili `exit()`, pokrenuƒáe se `__run_exit_handlers()` koji ƒáe pozvati registrovane destruktore.

{% hint style="danger" %}
Ako program izaƒëe putem funkcije **`_exit()`**, pozvaƒáe se **`exit` syscall** i hendleri za izlaz neƒáe biti izvr≈°eni. Dakle, da biste potvrdili da se `__run_exit_handlers()` izvr≈°ava, mo≈æete postaviti prekidnu taƒçku na nju.
{% endhint %}

Va≈æan kod je ([izvor](https://elixir.bootlin.com/glibc/glibc-2.32/source/elf/dl-fini.c#L131)):
```c
ElfW(Dyn) *fini_array = map->l_info[DT_FINI_ARRAY];
if (fini_array != NULL)
{
ElfW(Addr) *array = (ElfW(Addr) *) (map->l_addr + fini_array->d_un.d_ptr);
size_t sz = (map->l_info[DT_FINI_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr)));

while (sz-- > 0)
((fini_t) array[sz]) ();
}
[...]




// This is the d_un structure
ptype l->l_info[DT_FINI_ARRAY]->d_un
type = union {
Elf64_Xword d_val;	// address of function that will be called, we put our onegadget here
Elf64_Addr d_ptr;	// offset from l->l_addr of our structure
}
```
Primetite kako se `map -> l_addr + fini_array -> d_un.d_ptr` koristi za **izraƒçunavanje** pozicije **niza funkcija za pozivanje**.

Postoje **nekoliko opcija**:

* Prepisati vrednost `map->l_addr` kako bi pokazivala na **la≈æni `fini_array`** sa instrukcijama za izvr≈°avanje proizvoljnog koda
* Prepisati unose `l_info[DT_FINI_ARRAY]` i `l_info[DT_FINI_ARRAYSZ]` (koji su vi≈°e-manje uzastopni u memoriji), kako bi pokazivali na la≈ænu strukturu `Elf64_Dyn` koja ƒáe ponovo naterati **`array` da pokazuje na memoriju** kojom upravlja napadaƒç.&#x20;
* [**Ovaj opis**](https://github.com/nobodyisnobody/write-ups/tree/main/DanteCTF.2023/pwn/Sentence.To.Hell) prepisuje `l_info[DT_FINI_ARRAY]` sa adresom kontrolisane memorije u `.bss` koja sadr≈æi la≈æni `fini_array`. Ovaj la≈æni niz sadr≈æi **prvo** [**adresu jednog alata**](../rop-return-oriented-programing/ret2lib/one-gadget.md) koja ƒáe biti izvr≈°ena, a zatim **razliku** izmeƒëu adrese ovog **la≈ænog niza** i vrednosti `map->l_addr` tako da ƒáe `*array` pokazivati na la≈æni niz.
* Prema glavnoj objavi ove tehnike i [**ovom opisu**](https://activities.tjhsst.edu/csc/writeups/angstromctf-2021-wallstreet) ld.so ostavlja pokazivaƒç na steku koji pokazuje na binarni `link_map` u ld.so. Pomoƒáu proizvoljnog pisanja moguƒáe je prepisati ga i naterati da pokazuje na la≈æni `fini_array` koji kontroli≈°e napadaƒç sa adresom [**jednog alata**](../rop-return-oriented-programing/ret2lib/one-gadget.md) na primer.

Nakon prethodnog koda mo≈æete pronaƒái jo≈° jedan interesantan odeljak sa kodom:
```c
/* Next try the old-style destructor.  */
ElfW(Dyn) *fini = map->l_info[DT_FINI];
if (fini != NULL)
DL_CALL_DT_FINI (map, ((void *) map->l_addr + fini->d_un.d_ptr));
}
```
U ovom sluƒçaju bilo bi moguƒáe prebrisati vrednost `map->l_info[DT_FINI]` koja pokazuje na la≈æiranu strukturu `ElfW(Dyn)`. Pronaƒëite [**vi≈°e informacija ovde**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure).

## Prepisivanje TLS-Storage dtor\_list-a u **`__run_exit_handlers`**

Kao ≈°to je [**obja≈°njeno ovde**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite), ako program zavr≈°i putem `return` ili `exit()`, izvr≈°iƒáe se **`__run_exit_handlers()`** koji ƒáe pozvati sve registrovane funkcije destruktora.

Kod iz `_run_exit_handlers()`:
```c
/* Call all functions registered with `atexit' and `on_exit',
in the reverse of the order in which they were registered
perform stdio cleanup, and terminate program execution with STATUS.  */
void
attribute_hidden
__run_exit_handlers (int status, struct exit_function_list **listp,
bool run_list_atexit, bool run_dtors)
{
/* First, call the TLS destructors.  */
#ifndef SHARED
if (&__call_tls_dtors != NULL)
#endif
if (run_dtors)
__call_tls_dtors ();
```
Kod iz **`__call_tls_dtors()`** funkcije:
```c
typedef void (*dtor_func) (void *);
struct dtor_list //struct added
{
dtor_func func;
void *obj;
struct link_map *map;
struct dtor_list *next;
};

[...]
/* Call the destructors.  This is called either when a thread returns from the
initial function or when the process exits via the exit function.  */
void
__call_tls_dtors (void)
{
while (tls_dtor_list)		// parse the dtor_list chained structures
{
struct dtor_list *cur = tls_dtor_list;		// cur point to tls-storage dtor_list
dtor_func func = cur->func;
PTR_DEMANGLE (func);						// demangle the function ptr

tls_dtor_list = tls_dtor_list->next;		// next dtor_list structure
func (cur->obj);
[...]
}
}
```
Za svaku registrovanu funkciju u **`tls_dtor_list`**, demantovace pokazivac iz **`cur->func`** i pozvace je sa argumentom **`cur->obj`**.

Koriscenjem **`tls`** funkcije iz ovog [**forka GEF-a**](https://github.com/bata24/gef), moguce je videti da je **`dtor_list`** veoma **blizu** **stack canary**-ja i **PTR\_MANGLE cookie**-ja. Dakle, prelivanjem preko njega bilo bi moguce **prepisati** **cookie** i **stack canary**.\
Prelivanjem PTR\_MANGLE cookie-ja, bilo bi moguce **zaobici funkciju `PTR_DEMANLE`** postavljanjem je na 0x00, sto znaci da je **`xor`** koji se koristi za dobijanje prave adrese samo adresa koja je konfigurisana. Zatim, pisanjem na **`dtor_list`** moguce je **povezati nekoliko funkcija** sa funkcijom **adrese** i njenim **argumentom.**

Na kraju primetite da sacuvani pokazivac nece biti samo ekskluzivno xorovan sa cookie-jem vec i rotiran za 17 bitova:
```armasm
0x00007fc390444dd4 <+36>:	mov    rax,QWORD PTR [rbx]      --> mangled ptr
0x00007fc390444dd7 <+39>:	ror    rax,0x11		        --> rotate of 17 bits
0x00007fc390444ddb <+43>:	xor    rax,QWORD PTR fs:0x30	--> xor with PTR_MANGLE
```
Dakle, morate uzeti ovo u obzir pre dodavanja nove adrese.

Pronaƒëite primer u [**originalnom postu**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite).

## Ostali izmenjeni pokazivaƒçi u **`__run_exit_handlers`**

Ova tehnika je [**obja≈°njena ovde**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite) i ponovo zavisi od programa **koji izlazi pozivajuƒái `return` ili `exit()`** tako da se poziva **`__run_exit_handlers()`**.

Pogledajmo vi≈°e koda ove funkcije:
```c
while (true)
{
struct exit_function_list *cur;

restart:
cur = *listp;

if (cur == NULL)
{
/* Exit processing complete.  We will not allow any more
atexit/on_exit registrations.  */
__exit_funcs_done = true;
break;
}

while (cur->idx > 0)
{
struct exit_function *const f = &cur->fns[--cur->idx];
const uint64_t new_exitfn_called = __new_exitfn_called;

switch (f->flavor)
{
void (*atfct) (void);
void (*onfct) (int status, void *arg);
void (*cxafct) (void *arg, int status);
void *arg;

case ef_free:
case ef_us:
break;
case ef_on:
onfct = f->func.on.fn;
arg = f->func.on.arg;
PTR_DEMANGLE (onfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
onfct (status, arg);
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_at:
atfct = f->func.at;
PTR_DEMANGLE (atfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
atfct ();
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_cxa:
/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
we must mark this function as ef_free.  */
f->flavor = ef_free;
cxafct = f->func.cxa.fn;
arg = f->func.cxa.arg;
PTR_DEMANGLE (cxafct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
cxafct (arg, status);
__libc_lock_lock (__exit_funcs_lock);
break;
}

if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
/* The last exit function, or another thread, has registered
more exit functions.  Start the loop over.  */
goto restart;
}

*listp = cur->next;
if (*listp != NULL)
/* Don't free the last element in the chain, this is the statically
allocate element.  */
free (cur);
}

__libc_lock_unlock (__exit_funcs_lock);
```
Promenljiva `f` pokazuje na strukturu **`initial`** i u zavisnosti od vrednosti `f->flavor` biƒáe pozvane razliƒçite funkcije.\
Adresa funkcije koja ƒáe biti pozvana biƒáe na razliƒçitom mestu u zavisnosti od vrednosti, ali ƒáe uvek biti **demangleovana**.

Osim toga, u opcijama **`ef_on`** i **`ef_cxa`** takoƒëe je moguƒáe kontrolisati **argument**.

Moguƒáe je proveriti **strukturu `initial`** u sesiji za debagovanje sa GEF pokretanjem **`gef> p initial`**.

Da biste iskoristili ovo, potrebno je ili **procureti ili izbrisati `PTR_MANGLE` kolaƒçiƒá** a zatim prepisati `cxa` unos u initial sa `system('/bin/sh')`.\
Primer ovoga mo≈æete pronaƒái u [**originalnom blog postu o tehnici**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#6---code-execution-via-other-mangled-pointers-in-initial-structure).

<details>

<summary><strong>Nauƒçite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi naƒçini podr≈°ke HackTricks-u:

* Ako ≈æelite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvaniƒçni PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), na≈°u kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridru≈æite se** üí¨ [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi** ili nas **pratite** na **Twitteru** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
