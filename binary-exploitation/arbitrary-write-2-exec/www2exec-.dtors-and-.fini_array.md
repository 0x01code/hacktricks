# WWW2Exec - .dtors & .fini\_array

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## .dtors

{% hint style="danger" %}
De nos jours, il est tr√®s **√©trange de trouver un binaire avec une section .dtors !**
{% endhint %}

Les destructeurs sont des fonctions qui sont **ex√©cut√©es avant la fin du programme** (apr√®s le retour de la fonction `main`).\
Les adresses de ces fonctions sont stock√©es √† l'int√©rieur de la section **`.dtors`** du binaire et donc, si vous parvenez √† **√©crire** l'**adresse** d'un **shellcode** dans **`__DTOR_END__`**, cela sera **ex√©cut√©** avant la fin des programmes.

Obtenez l'adresse de cette section avec :
```bash
objdump -s -j .dtors /exec
rabin -s /exec | grep ‚Äú__DTOR‚Äù
```
G√©n√©ralement, vous trouverez les marqueurs **DTOR** **entre** les valeurs `ffffffff` et `00000000`. Donc, si vous voyez juste ces valeurs, cela signifie qu'**aucune fonction n'est enregistr√©e**. **√âcrasez** donc le **`00000000`** avec l'**adresse** du **shellcode** pour l'ex√©cuter.

{% hint style="warning" %}
Bien s√ªr, vous devez d'abord trouver un **endroit pour stocker le shellcode** afin de pouvoir l'appeler ult√©rieurement.
{% endhint %}

## **.fini\_array**

Essentiellement, il s'agit d'une structure avec des **fonctions qui seront appel√©es** avant la fin du programme, comme pour les **`.dtors`**. Cela est int√©ressant si vous pouvez appeler votre **shellcode en sautant √† une adresse**, ou dans des cas o√π vous devez retourner √† **`main`** pour **exploiter la vuln√©rabilit√© une deuxi√®me fois**.
```bash
objdump -s -j .fini_array ./greeting

./greeting:     file format elf32-i386

Contents of section .fini_array:
8049934 a0850408

#Put your address in 0x8049934
```
Notez que lorsque qu'une fonction de **`.fini_array`** est ex√©cut√©e, elle passe √† la suivante, donc elle ne sera pas ex√©cut√©e plusieurs fois (√©vitant les boucles infinies), mais elle vous donnera √©galement seulement 1 **ex√©cution de la fonction** plac√©e ici.

Notez que les entr√©es dans `.fini_array` sont appel√©es dans l'ordre **inverse**, donc vous voudrez probablement commencer √† √©crire √† partir de la derni√®re.

#### Boucle infinie

Pour abuser de **`.fini_array`** pour obtenir une boucle infinie, vous pouvez [**v√©rifier ce qui a √©t√© fait ici**](https://guyinatuxedo.github.io/17-stack\_pivot/insomnihack18\_onewrite/index.html)**:** Si vous avez au moins 2 entr√©es dans **`.fini_array`**, vous pouvez :

* Utiliser votre premier √©crit pour **appeler √† nouveau la fonction d'√©criture arbitraire vuln√©rable**
* Ensuite, calculer l'adresse de retour dans la pile stock√©e par **`__libc_csu_fini`** (la fonction qui appelle toutes les fonctions `.fini_array`) et y mettre l'**adresse de `__libc_csu_fini`**
* Cela fera que **`__libc_csu_fini`** s'appelle lui-m√™me en ex√©cutant √† nouveau les fonctions de **`.fini_array`** qui appelleront la fonction WWW vuln√©rable 2 fois : une fois pour **l'√©criture arbitraire** et une autre pour √©craser √† nouveau l'**adresse de retour de `__libc_csu_fini`** sur la pile pour s'appeler √† nouveau.

{% hint style="danger" %}
Notez qu'avec [**Full RELRO**](../common-binary-protections-and-bypasses/relro.md)**,** la section **`.fini_array`** est rendue **en lecture seule**.
{% endhint %}

## link\_map

Comme expliqu√© [**dans ce post**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure), si le programme se termine en utilisant `return` ou `exit()`, il ex√©cutera `__run_exit_handlers()` qui appellera les destructeurs enregistr√©s.

{% hint style="danger" %}
Si le programme se termine via la fonction **`_exit()`**, il appellera l'appel syst√®me **`exit`** et les gestionnaires de sortie ne seront pas ex√©cut√©s. Ainsi, pour confirmer que `__run_exit_handlers()` est ex√©cut√©, vous pouvez d√©finir un point d'arr√™t dessus.
{% endhint %}

Le code important est ([source](https://elixir.bootlin.com/glibc/glibc-2.32/source/elf/dl-fini.c#L131)):
```c
ElfW(Dyn) *fini_array = map->l_info[DT_FINI_ARRAY];
if (fini_array != NULL)
{
ElfW(Addr) *array = (ElfW(Addr) *) (map->l_addr + fini_array->d_un.d_ptr);
size_t sz = (map->l_info[DT_FINI_ARRAYSZ]->d_un.d_val / sizeof (ElfW(Addr)));

while (sz-- > 0)
((fini_t) array[sz]) ();
}
[...]




// This is the d_un structure
ptype l->l_info[DT_FINI_ARRAY]->d_un
type = union {
Elf64_Xword d_val;	// address of function that will be called, we put our onegadget here
Elf64_Addr d_ptr;	// offset from l->l_addr of our structure
}
```
Notez comment `map -> l_addr + fini_array -> d_un.d_ptr` est utilis√© pour **calculer** la position du **tableau de fonctions √† appeler**.

Il existe **quelques options** :

* √âcraser la valeur de `map->l_addr` pour qu'elle pointe vers un **faux `fini_array`** avec des instructions pour ex√©cuter un code arbitraire
* √âcraser les entr√©es `l_info[DT_FINI_ARRAY]` et `l_info[DT_FINI_ARRAYSZ]` (qui sont plus ou moins cons√©cutives en m√©moire) pour les faire **pointer vers une structure `Elf64_Dyn` forg√©e** qui fera √† nouveau **pointer `array` vers une zone m√©moire contr√¥l√©e par l'attaquant**.
* [**Cette analyse**](https://github.com/nobodyisnobody/write-ups/tree/main/DanteCTF.2023/pwn/Sentence.To.Hell) √©crase `l_info[DT_FINI_ARRAY]` avec l'adresse d'une m√©moire contr√¥l√©e dans `.bss` contenant un faux `fini_array`. Ce faux tableau contient **d'abord une** [**adresse de one gadget**](../rop-return-oriented-programing/ret2lib/one-gadget.md) qui sera ex√©cut√©e, puis la **diff√©rence** entre l'adresse de ce **faux tableau** et la **valeur de `map->l_addr`** pour que `*array` pointe vers le faux tableau.
* Selon le message principal de cette technique et [**cette analyse**](https://activities.tjhsst.edu/csc/writeups/angstromctf-2021-wallstreet), ld.so laisse un pointeur sur la pile qui pointe vers le `link_map` binaire dans ld.so. Avec une √©criture arbitraire, il est possible de l'√©craser et de le faire pointer vers un faux `fini_array` contr√¥l√© par l'attaquant avec l'adresse d'un [**one gadget**](../rop-return-oriented-programing/ret2lib/one-gadget.md) par exemple.

Apr√®s le code pr√©c√©dent, vous pouvez trouver une autre section int√©ressante avec le code :
```c
/* Next try the old-style destructor.  */
ElfW(Dyn) *fini = map->l_info[DT_FINI];
if (fini != NULL)
DL_CALL_DT_FINI (map, ((void *) map->l_addr + fini->d_un.d_ptr));
}
```
Dans ce cas, il serait possible de remplacer la valeur de `map->l_info[DT_FINI]` pointant vers une structure `ElfW(Dyn)` forg√©e. Trouvez [**plus d'informations ici**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#2---targetting-ldso-link\_map-structure).

## √âcrasement de la liste dtor\_list du stockage TLS dans **`__run_exit_handlers`**

Comme [**expliqu√© ici**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite), si un programme se termine par `return` ou `exit()`, il ex√©cutera **`__run_exit_handlers()`** qui appellera toute fonction de destructeur enregistr√©e.

Code de `_run_exit_handlers()`:
```c
/* Call all functions registered with `atexit' and `on_exit',
in the reverse of the order in which they were registered
perform stdio cleanup, and terminate program execution with STATUS.  */
void
attribute_hidden
__run_exit_handlers (int status, struct exit_function_list **listp,
bool run_list_atexit, bool run_dtors)
{
/* First, call the TLS destructors.  */
#ifndef SHARED
if (&__call_tls_dtors != NULL)
#endif
if (run_dtors)
__call_tls_dtors ();
```
Code de **`__call_tls_dtors()`** :
```c
typedef void (*dtor_func) (void *);
struct dtor_list //struct added
{
dtor_func func;
void *obj;
struct link_map *map;
struct dtor_list *next;
};

[...]
/* Call the destructors.  This is called either when a thread returns from the
initial function or when the process exits via the exit function.  */
void
__call_tls_dtors (void)
{
while (tls_dtor_list)		// parse the dtor_list chained structures
{
struct dtor_list *cur = tls_dtor_list;		// cur point to tls-storage dtor_list
dtor_func func = cur->func;
PTR_DEMANGLE (func);						// demangle the function ptr

tls_dtor_list = tls_dtor_list->next;		// next dtor_list structure
func (cur->obj);
[...]
}
}
```
Pour chaque fonction enregistr√©e dans **`tls_dtor_list`**, elle d√©mangera le pointeur de **`cur->func`** et l'appellera avec l'argument **`cur->obj`**.

En utilisant la fonction **`tls`** de ce [**fork de GEF**](https://github.com/bata24/gef), il est possible de voir que en r√©alit√© la liste des destructeurs (**`dtor_list`**) est tr√®s **proche** du **canari de pile** et du **cookie PTR\_MANGLE**. Ainsi, en cas de d√©passement de tampon, il serait possible de **√©craser** le **cookie** et le **canari de pile**.\
En √©crasant le cookie PTR\_MANGLE, il serait possible de **contourner la fonction `PTR_DEMANLE`** en le d√©finissant √† 0x00, ce qui signifie que le **`xor`** utilis√© pour obtenir l'adresse r√©elle est simplement l'adresse configur√©e. Ensuite, en √©crivant sur la **`dtor_list`**, il est possible de **encha√Æner plusieurs fonctions** avec l'**adresse de la fonction** et son **argument**.

Enfin, notez que le pointeur stock√© sera non seulement xor√© avec le cookie mais √©galement rot√© de 17 bits :
```armasm
0x00007fc390444dd4 <+36>:	mov    rax,QWORD PTR [rbx]      --> mangled ptr
0x00007fc390444dd7 <+39>:	ror    rax,0x11		        --> rotate of 17 bits
0x00007fc390444ddb <+43>:	xor    rax,QWORD PTR fs:0x30	--> xor with PTR_MANGLE
```
Donc, vous devez prendre cela en compte avant d'ajouter une nouvelle adresse.

Trouvez un exemple dans le [**message original**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite).

## Autres pointeurs modifi√©s dans **`__run_exit_handlers`**

Cette technique est [**expliqu√©e ici**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#5---code-execution-via-tls-storage-dtor\_list-overwrite) et d√©pend √† nouveau du programme **qui se termine en appelant `return` ou `exit()`** pour que **`__run_exit_handlers()`** soit appel√©.

V√©rifions plus de code de cette fonction :
```c
while (true)
{
struct exit_function_list *cur;

restart:
cur = *listp;

if (cur == NULL)
{
/* Exit processing complete.  We will not allow any more
atexit/on_exit registrations.  */
__exit_funcs_done = true;
break;
}

while (cur->idx > 0)
{
struct exit_function *const f = &cur->fns[--cur->idx];
const uint64_t new_exitfn_called = __new_exitfn_called;

switch (f->flavor)
{
void (*atfct) (void);
void (*onfct) (int status, void *arg);
void (*cxafct) (void *arg, int status);
void *arg;

case ef_free:
case ef_us:
break;
case ef_on:
onfct = f->func.on.fn;
arg = f->func.on.arg;
PTR_DEMANGLE (onfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
onfct (status, arg);
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_at:
atfct = f->func.at;
PTR_DEMANGLE (atfct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
atfct ();
__libc_lock_lock (__exit_funcs_lock);
break;
case ef_cxa:
/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
we must mark this function as ef_free.  */
f->flavor = ef_free;
cxafct = f->func.cxa.fn;
arg = f->func.cxa.arg;
PTR_DEMANGLE (cxafct);

/* Unlock the list while we call a foreign function.  */
__libc_lock_unlock (__exit_funcs_lock);
cxafct (arg, status);
__libc_lock_lock (__exit_funcs_lock);
break;
}

if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
/* The last exit function, or another thread, has registered
more exit functions.  Start the loop over.  */
goto restart;
}

*listp = cur->next;
if (*listp != NULL)
/* Don't free the last element in the chain, this is the statically
allocate element.  */
free (cur);
}

__libc_lock_unlock (__exit_funcs_lock);
```
La variable `f` pointe vers la structure **`initial`** et en fonction de la valeur de `f->flavor`, diff√©rentes fonctions seront appel√©es.\
Selon la valeur, l'adresse de la fonction √† appeler sera √† un endroit diff√©rent, mais elle sera toujours **d√©mangl√©e**.

De plus, dans les options **`ef_on`** et **`ef_cxa`**, il est √©galement possible de contr√¥ler un **argument**.

Il est possible de v√©rifier la structure **`initial`** lors d'une session de d√©bogage avec GEF en ex√©cutant **`gef> p initial`**.

Pour exploiter cela, vous devez soit **fuir ou effacer le cookie `PTR_MANGLE`** puis √©craser une entr√©e `cxa` dans initial avec `system('/bin/sh')`.\
Vous pouvez trouver un exemple de cela dans le [**article de blog original sur la technique**](https://github.com/nobodyisnobody/docs/blob/main/code.execution.on.last.libc/README.md#6---code-execution-via-other-mangled-pointers-in-initial-structure).

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
