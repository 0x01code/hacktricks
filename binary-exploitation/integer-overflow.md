# Ganzzahl√ºberlauf

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositorys senden.

</details>

## Grundlegende Informationen

Im Herzen eines **Ganzzahl√ºberlaufs** liegt die Begrenzung durch die **Gr√∂√üe** von Datentypen in der Computerprogrammierung und die **Interpretation** der Daten.

Beispielsweise kann ein **8-Bit-Unsigned-Integer** Werte von **0 bis 255** darstellen. Wenn Sie versuchen, den Wert 256 in einem 8-Bit-Unsigned-Integer zu speichern, wird er aufgrund der Begrenzung seiner Speicherkapazit√§t auf 0 zur√ºckgesetzt. Ebenso wird bei einem **16-Bit-Unsigned-Integer**, der Werte von **0 bis 65.535** speichern kann, durch Hinzuf√ºgen von 1 zu 65.535 der Wert auf 0 zur√ºckgesetzt.

Dar√ºber hinaus kann ein **8-Bit-Signed-Integer** Werte von **-128 bis 127** darstellen. Dies liegt daran, dass ein Bit zur Darstellung des Vorzeichens (positiv oder negativ) verwendet wird, sodass 7 Bits zur Darstellung des Betrags verbleiben. Die negativste Zahl wird als **-128** dargestellt (bin√§r `10000000`), und die positivste Zahl ist **127** (bin√§r `01111111`).

### Maximalwerte

F√ºr potenzielle **Web-Schwachstellen** ist es sehr interessant, die maximal unterst√ºtzten Werte zu kennen:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}

Integer-Overflow tritt auf, wenn eine Operation das Maximum oder Minimum eines Datentyps √ºberschreitet. Dies kann zu unerwartetem Verhalten f√ºhren, wie z.B. dem Zur√ºcksetzen des Z√§hlers auf den niedrigsten Wert nach dem Erreichen des Maximums. Integer-Overflow kann von Hackern ausgenutzt werden, um Speicherfehler zu verursachen oder die Kontrolle √ºber ein Programm zu √ºbernehmen. Es ist wichtig, Eingaben zu validieren und √úberlaufbedingungen in Code zu vermeiden, um Sicherheitsl√ºcken zu verhindern.

Ein Beispiel f√ºr Integer-Overflow ist die Verwendung von `malloc` in C, um Speicher f√ºr ein Array zuzuweisen. Wenn die Gr√∂√üe des Arrays mit einem negativen Wert berechnet wird, kann Integer-Overflow auftreten und zu einer zu kleinen Speicherzuweisung f√ºhren, was zu einem Puffer√ºberlauf f√ºhren kann. Es ist wichtig, solche Szenarien zu erkennen und entsprechende Ma√ünahmen zu ergreifen, um Sicherheitsl√ºcken zu vermeiden.

Um Integer-Overflow zu vermeiden, sollten Entwickler sicherstellen, dass alle Berechnungen innerhalb der Grenzen des Datentyps bleiben und Eingaben validiert werden, um √úberlaufbedingungen zu verhindern. Die Verwendung von sicheren Funktionen wie `calloc` anstelle von `malloc` kann ebenfalls dazu beitragen, Integer-Overflow zu vermeiden. Es ist wichtig, sich bewusst zu sein, wie Integer-Overflow auftreten kann, und entsprechende Vorkehrungen zu treffen, um die Sicherheit von Anwendungen zu gew√§hrleisten.

{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Beispiele

### Reines √úberlauf

Das gedruckte Ergebnis wird 0 sein, da wir das Zeichen √ºberlaufen haben:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Vorzeichenbehaftete in vorzeichenlose Konvertierung

Betrachten Sie eine Situation, in der eine vorzeichenbehaftete Ganzzahl aus Benutzereingaben gelesen und dann in einem Kontext verwendet wird, der sie als vorzeichenlose Ganzzahl behandelt, ohne ordnungsgem√§√üe Validierung:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
### Andere Beispiele

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Es wird nur 1B verwendet, um die Gr√∂√üe des Passworts zu speichern, daher ist es m√∂glich, es zu √ºberlaufen und es glauben zu machen, dass seine L√§nge 4 betr√§gt, w√§hrend es tats√§chlich 260 betr√§gt, um den L√§ngenpr√ºfschutz zu umgehen.
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Gegeben ein paar Zahlen, finden Sie mit z3 eine neue Zahl, die mit der ersten multipliziert die zweite ergibt:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Es wird nur 1B verwendet, um die Gr√∂√üe des Passworts zu speichern, daher ist es m√∂glich, es zu √ºberlaufen und es glauben zu machen, dass seine L√§nge 4 betr√§gt, w√§hrend es tats√§chlich 260 betr√§gt, um den L√§ngenpr√ºfschutz zu umgehen und im Stapel die n√§chste lokale Variable zu √ºberschreiben und beide Schutzmechanismen zu umgehen.

## ARM64

Dies **√§ndert sich nicht in ARM64**, wie Sie in [**diesem Blog-Beitrag**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/) sehen k√∂nnen.
