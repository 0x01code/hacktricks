# Ganzzahl√ºberlauf

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Grundlegende Informationen

Im Herzen eines **Ganzzahl√ºberlaufs** liegt die Begrenzung durch die **Gr√∂√üe** von Datentypen in der Computerprogrammierung und die **Interpretation** der Daten.

Beispielsweise kann ein **8-Bit-Unsigned-Integer** Werte von **0 bis 255** darstellen. Wenn Sie versuchen, den Wert 256 in einem 8-Bit-Unsigned-Integer zu speichern, wird er aufgrund der Begrenzung seiner Speicherkapazit√§t auf 0 zur√ºckgesetzt. Ebenso wird bei einem **16-Bit-Unsigned-Integer**, der Werte von **0 bis 65.535** speichern kann, durch Hinzuf√ºgen von 1 zu 65.535 der Wert auf 0 zur√ºckgesetzt.

Dar√ºber hinaus kann ein **8-Bit-Signed-Integer** Werte von **-128 bis 127** darstellen. Dies liegt daran, dass ein Bit zur Darstellung des Vorzeichens (positiv oder negativ) verwendet wird, sodass 7 Bits zur Darstellung des Betrags verbleiben. Die negativste Zahl wird als **-128** dargestellt (bin√§r `10000000`), und die positivste Zahl ist **127** (bin√§r `01111111`).

### Maximalwerte

F√ºr potenzielle **Web-Schwachstellen** ist es sehr interessant, die maximal unterst√ºtzten Werte zu kennen:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}

Integer-√úberlauf tritt auf, wenn eine arithmetische Operation dazu f√ºhrt, dass der Wert einer Variablen √ºber ihren maximalen Wert hinausgeht. Dies kann zu unerwartetem Verhalten der Software f√ºhren, einschlie√ülich potenzieller Sicherheitsl√ºcken. Integer-√úberl√§ufe k√∂nnen in C auftreten, wenn beispielsweise ein Wert zu gro√ü ist, um in den zugewiesenen Speicherbereich zu passen, was zu einem Wrap-around-Effekt f√ºhrt. Entwickler sollten Integer-√úberl√§ufe sorgf√§ltig ber√ºcksichtigen und entsprechende Ma√ünahmen ergreifen, um potenzielle Schwachstellen zu vermeiden. 

Ein Beispiel f√ºr einen Integer-√úberlauf in C k√∂nnte auftreten, wenn eine Variable vom Typ `int` inkrementiert wird und ihren maximalen Wert √ºberschreitet, was zu einem unerwarteten Verhalten f√ºhren kann. Es ist wichtig, solche Szenarien zu identifizieren und zu beheben, um die Sicherheit und Stabilit√§t der Software zu gew√§hrleisten. 

Um Integer-√úberl√§ufe zu vermeiden, k√∂nnen Entwickler Techniken wie die Verwendung von Datentypen mit gr√∂√üerem Wertebereich oder die Implementierung von √úberpr√ºfungen w√§hrend der Ausf√ºhrung verwenden, um sicherzustellen, dass Variablenwerte innerhalb akzeptabler Grenzen bleiben. Durch eine sorgf√§ltige Programmierung und √úberpr√ºfung k√∂nnen potenzielle Integer-√úberl√§ufe vermieden und die Sicherheit von Softwareanwendungen verbessert werden.

{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Beispiele

### Reiner √úberlauf

Das gedruckte Ergebnis wird 0 sein, da wir das Zeichen √ºberlaufen haben:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Vorzeichenbehaftete in vorzeichenlose Konvertierung

Betrachten Sie eine Situation, in der eine vorzeichenbehaftete Ganzzahl aus Benutzereingaben gelesen und dann in einem Kontext verwendet wird, der sie als vorzeichenlose Ganzzahl behandelt, ohne ordnungsgem√§√üe Validierung:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
### Andere Beispiele

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Das Programm validiert nur das letzte Byte einer Zahl, um die Gr√∂√üe des Eingabewerts zu √ºberpr√ºfen. Daher ist es m√∂glich, jede Gr√∂√üe hinzuzuf√ºgen, solange das letzte Byte im erlaubten Bereich liegt. Dann wird der Eingabewert mit einem Buffer Overflow ausgenutzt, der mit einem ret2win ausgef√ºhrt wird.
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Gegeben ein paar Zahlen, finde mit z3 eine neue Zahl, die mit der ersten multipliziert die zweite ergibt:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```

\
