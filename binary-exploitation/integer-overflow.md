# Prekoracenje celih brojeva

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

U srcu **prekoracenja celih brojeva** je ograničenje koje nameću **veličine** podataka u programiranju računara i **interpretacija** podataka.

Na primer, **8-bitni neoznačeni ceo broj** može predstavljati vrednosti od **0 do 255**. Ako pokušate da sačuvate vrednost 256 u 8-bitnom neoznačenom celom broju, ona će se preklopiti na 0 zbog ograničenja njegove skladišne sposobnosti. Slično tome, za **16-bitni neoznačeni ceo broj**, koji može držati vrednosti od **0 do 65.535**, dodavanje 1 na 65.535 će preklopiti vrednost nazad na 0.

Osim toga, **8-bitni označeni ceo broj** može predstavljati vrednosti od **-128 do 127**. To je zato što se jedan bit koristi za predstavljanje znaka (pozitivno ili negativno), ostavljajući 7 bitova za predstavljanje veličine. Najnegativniji broj je predstavljen kao **-128** (binarno `10000000`), a najpozitivniji broj je **127** (binarno `01111111`).

### Maksimalne vrednosti

Za potencijalne **web ranjivosti** veoma je zanimljivo znati maksimalne podržane vrednosti:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}

Integer overflow occurs when an arithmetic operation results in a value that exceeds the maximum size that the data type can hold. This can lead to unexpected behavior in the program, such as wrapping around to a minimum value or causing a buffer overflow.

To prevent integer overflow, always check the result of arithmetic operations to ensure that it does not exceed the maximum value that the data type can hold. Use data types that can accommodate the range of values you expect in your program.

In C, you can use the `INT_MAX` constant from the `<limits.h>` header file to determine the maximum value that an `int` can hold. Similarly, you can use `SIZE_MAX` from `<stdint.h>` to determine the maximum value that a `size_t` can hold.

Be cautious when performing arithmetic operations in C, especially when dealing with user input or dynamically calculated values, to avoid integer overflow vulnerabilities. 

```c
#include <stdio.h>
#include <limits.h>
#include <stdint.h>

int main() {
    int a = INT_MAX;
    size_t b = SIZE_MAX;

    if (a + 1 < a) {
        printf("Integer overflow occurred!\n");
    }

    if (b + 1 < b) {
        printf("Integer overflow occurred!\n");
    }

    return 0;
}
```

In the example above, we check for integer overflow by adding 1 to the maximum values of `int` and `size_t` and comparing them with the original values. If the result is less than the original value, an integer overflow has occurred.
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Primeri

### Čisti prekoračenje

Odštampani rezultat će biti 0 jer smo prekoračili karakter:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Pretvaranje potpisanog u nepotpisani tip

Razmotrite situaciju u kojoj se potpisani ceo broj čita iz korisničkog unosa, a zatim koristi u kontekstu koji ga tretira kao nepotpisani ceo broj, bez odgovarajuće validacije:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
U ovom primeru, ako korisnik unese negativan broj, biće tumačen kao veliki neoznačeni broj zbog načina na koji se tumače binarne vrednosti, što potencijalno može dovesti do neočekivanog ponašanja.

### Ostali Primeri

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Koristi se samo 1B za čuvanje veličine lozinke, pa je moguće prekoračiti je i naterati je da misli da je dužine 4 dok je zapravo 260 kako bi se zaobišla provera dužine
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
*   Dati par brojeva i koristeći z3 pronaći novi broj koji pomnožen sa prvom vrednošću daje drugu vrednost:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Koristi se samo 1B za čuvanje veličine lozinke, pa je moguće prekoračiti je i naterati je da misli da je dužine 4 dok je zapravo 260 kako bi se zaobišla provera dužine i prepisala sledeća lokalna promenljiva na steku i zaobišle obe zaštite

## ARM64

Ovo **se ne menja u ARM64** kao što možete videti u [**ovom blog postu**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
