# Tamsayı Taşması

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

**Tamsayı taşmasının** merkezinde, bilgisayar programlamasındaki veri türlerinin **boyutu** ve verinin **yorumlanması** tarafından uygulanan sınırlama bulunmaktadır.

Örneğin, bir **8-bit işaretsiz tamsayı**, **0 ile 255** arasındaki değerleri temsil edebilir. Bir 8-bit işaretsiz tamsayıya 256 değerini saklamaya çalışırsanız, saklama kapasitesinin sınırlılığı nedeniyle 0'a döner. Benzer şekilde, **16-bit işaretsiz tamsayı** için, **0 ile 65,535** arasındaki değerleri tutabilir, 65,535'e 1 eklemek değeri tekrar 0'a döndürecektir.

Ayrıca, bir **8-bit işaretli tamsayı**, **-128 ile 127** arasındaki değerleri temsil edebilir. Bu, bir bitin işareti (pozitif veya negatif) temsil etmek için kullanılması nedeniyle 7 bitin büyüklüğü temsil etmesi gerektiğinden kaynaklanır. En negatif sayı **-128** olarak temsil edilir (ikili `10000000`), en pozitif sayı ise **127** olarak temsil edilir (ikili `01111111`).

### Maksimum Değerler

Potansiyel **web güvenlik açıkları** için desteklenen maksimum değerleri bilmek çok ilginçtir:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}Integer Taşması

Integer taşması, bir değişkenin maksimum değerini aştığında oluşan bir durumdur. Bu durum, genellikle işlemlerde veya bellek tahsisinde hatalı hesaplamalardan kaynaklanır. Örneğin, bir değişkenin maksimum değeri 255 ise, 256 değeri atanırsa, değişken taşar ve 0 değerine geri döner.

Bu tür bir zafiyet, kötü niyetli saldırganların hedef sistemde istismar ettiği yaygın bir güvenlik açığıdır. Integer taşması, bellek bölgelerinin yanlış şekilde yazılmasına ve hedef sistemde istenmeyen davranışlara neden olabilir. Bu nedenle, yazılım geliştiricilerin bu tür durumları önlemek için dikkatli olmaları önemlidir.{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Örnekler

### Saf taşma

Yazdırılan sonuç, char'ı aştığımız için 0 olacaktır:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### İmzalıdan İmsiz Dönüşüm

Kullanıcı girdisinden okunan bir imzalı tamsayı düşünün ve ardından uygun doğrulama olmadan onu imzalı bir tamsayı olarak işleyen bir bağlamda kullanılır:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Bu örnekte, bir kullanıcı negatif bir sayı girerse, ikili değerlerin nasıl yorumlandığından dolayı bu sayı büyük bir işaretsiz tamsayı olarak yorumlanacaktır, bu da beklenmeyen davranışlara yol açabilir.

### Diğer Örnekler

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Şifrenin boyutunu depolamak için sadece 1B kullanılır, bu nedenle taşması ve uzunluğunun aslında 260 olduğunu düşünerek uzunluk kontrol korumasını atlatmak mümkündür.
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Verilen birkaç sayıyı kullanarak z3'ü kullanarak, birinci sayı ile çarpıldığında ikinci sayıyı verecek yeni bir sayıyı bulun:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Şifrenin boyutunu depolamak için sadece 1B kullanılır, bu nedenle taşması ve uzunluğunun aslında 260 olduğunu düşünerek uzunluk kontrol korumasını atlatmak ve yığında bir sonraki yerel değişkeni geçerek her iki korumayı da atlatmak mümkündür.

## ARM64

Bu, [**bu blog yazısında**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/) görebileceğiniz gibi **ARM64'te değişmez**.

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* **💬 Discord grubuna** katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
