# Estouro de Inteiro

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

No cerne de um **estouro de inteiro** est√° a limita√ß√£o imposta pelo **tamanho** dos tipos de dados na programa√ß√£o de computadores e a **interpreta√ß√£o** dos dados.

Por exemplo, um **inteiro sem sinal de 8 bits** pode representar valores de **0 a 255**. Se voc√™ tentar armazenar o valor 256 em um inteiro sem sinal de 8 bits, ele volta a 0 devido √† limita√ß√£o de sua capacidade de armazenamento. Da mesma forma, para um **inteiro sem sinal de 16 bits**, que pode conter valores de **0 a 65.535**, adicionar 1 a 65.535 far√° com que o valor volte a 0.

Al√©m disso, um **inteiro com sinal de 8 bits** pode representar valores de **-128 a 127**. Isso ocorre porque um bit √© usado para representar o sinal (positivo ou negativo), deixando 7 bits para representar a magnitude. O n√∫mero mais negativo √© representado como **-128** (bin√°rio `10000000`), e o n√∫mero mais positivo √© **127** (bin√°rio `01111111`).

### Valores M√°ximos

Para potenciais **vulnerabilidades web**, √© muito interessante saber os valores m√°ximos suportados:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
## Integer Overflow

Integer overflow occurs when an arithmetic operation results in a value that exceeds the maximum size that the data type can hold. This can lead to unexpected behavior and security vulnerabilities in software.

### Example

```c
#include <stdio.h>

int main() {
    unsigned int x = 4294967295; // Maximum value for an unsigned int
    x = x + 1;
    
    printf("Value of x: %u\n", x);

    return 0;
}
```

In this example, `x` is an unsigned integer with a maximum value of 4294967295. When 1 is added to `x`, it overflows and the value becomes 0 due to the limited size of the data type.

### Mitigation

To prevent integer overflow, always check the result of arithmetic operations to ensure that the value does not exceed the maximum limit of the data type. Using larger data types or libraries that handle overflow conditions can also help mitigate this issue.
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## Exemplos

### Overflow puro

O resultado impresso ser√° 0, pois ocorreu um overflow no char:
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Convers√£o de Assinado para N√£o Assinado

Considere uma situa√ß√£o em que um inteiro assinado √© lido a partir da entrada do usu√°rio e depois usado em um contexto que o trata como um inteiro n√£o assinado, sem uma valida√ß√£o adequada:
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Neste exemplo, se um usu√°rio inserir um n√∫mero negativo, ele ser√° interpretado como um grande inteiro n√£o assinado devido √† forma como os valores bin√°rios s√£o interpretados, potencialmente levando a comportamentos inesperados.

### Outros Exemplos

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Apenas 1B √© usado para armazenar o tamanho da senha, ent√£o √© poss√≠vel estour√°-lo e fazer com que ele pense que tem um comprimento de 4, enquanto na verdade √© 260 para burlar a prote√ß√£o de verifica√ß√£o de comprimento.
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* Dados alguns n√∫meros, descubra usando z3 um novo n√∫mero que, multiplicado pelo primeiro, resultar√° no segundo:&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Apenas 1B √© usado para armazenar o tamanho da senha, ent√£o √© poss√≠vel estour√°-lo e fazer com que ele pense que tem um comprimento de 4, enquanto na verdade √© 260 para burlar a prote√ß√£o de verifica√ß√£o de comprimento e sobrescrever na pilha a pr√≥xima vari√°vel local e burlar ambas as prote√ß√µes

## ARM64

Isso **n√£o muda no ARM64** como voc√™ pode ver neste [**post de blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
