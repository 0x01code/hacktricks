# D√©bordement d'entier

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

- Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
- D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
- **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
- **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

Au c≈ìur d'un **d√©bordement d'entier** se trouve la limitation impos√©e par la **taille** des types de donn√©es en programmation informatique et l'**interpr√©tation** des donn√©es.

Par exemple, un **entier non sign√© sur 8 bits** peut repr√©senter des valeurs de **0 √† 255**. Si vous tentez de stocker la valeur 256 dans un entier non sign√© sur 8 bits, elle revient √† 0 en raison de la limitation de sa capacit√© de stockage. De m√™me, pour un **entier non sign√© sur 16 bits**, qui peut contenir des valeurs de **0 √† 65 535**, ajouter 1 √† 65 535 ram√®nera la valeur √† 0.

De plus, un **entier sign√© sur 8 bits** peut repr√©senter des valeurs de **-128 √† 127**. Cela est d√ª au fait qu'un bit est utilis√© pour repr√©senter le signe (positif ou n√©gatif), laissant 7 bits pour repr√©senter la magnitude. Le nombre le plus n√©gatif est repr√©sent√© par **-128** (binaire `10000000`), et le nombre le plus positif est **127** (binaire `01111111`).

### Valeurs maximales

Pour les potentielles **vuln√©rabilit√©s web**, il est tr√®s int√©ressant de conna√Ætre les valeurs maximales prises en charge :

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
### D√©bordement d'entier

Le d√©bordement d'entier se produit lorsqu'une op√©ration math√©matique d√©passe la capacit√© maximale d'un type de donn√©es. Par exemple, si un entier non sign√© de 8 bits atteint sa valeur maximale de 255 et qu'une op√©ration d'addition suppl√©mentaire est effectu√©e, le r√©sultat sera 0 en raison du d√©bordement.

Les d√©bordements d'entiers peuvent √™tre exploit√©s pour modifier le comportement attendu d'un programme et potentiellement ex√©cuter du code malveillant. Il est important de v√©rifier et de g√©rer correctement les d√©bordements d'entiers dans le code pour √©viter les vuln√©rabilit√©s de s√©curit√©.
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
{% endtab %}
{% endtabs %}

## Exemples

### D√©passement pur

Le r√©sultat imprim√© sera 0 car nous avons d√©pass√© le char :
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### Conversion de sign√© √† non sign√©

Consid√©rez une situation o√π un entier sign√© est lu √† partir de l'entr√©e utilisateur, puis utilis√© dans un contexte qui le traite comme un entier non sign√©, sans validation appropri√©e :
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
Dans cet exemple, si un utilisateur entre un nombre n√©gatif, il sera interpr√©t√© comme un grand entier non sign√© en raison de la fa√ßon dont les valeurs binaires sont interpr√©t√©es, ce qui peut entra√Æner un comportement inattendu.

### Autres Exemples

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* Seulement 1B est utilis√© pour stocker la taille du mot de passe, il est donc possible de le d√©border et de le faire penser qu'il a une longueur de 4 alors qu'il est en r√©alit√© de 260 pour contourner la protection de v√©rification de longueur
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
*   √âtant donn√© quelques nombres, d√©couvrez en utilisant z3 un nouveau nombre qui, multipli√© par le premier, donnera le deuxi√®me :&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* Seulement 1B est utilis√© pour stocker la taille du mot de passe, il est donc possible de le d√©border et de le faire penser qu'il a une longueur de 4 alors qu'il est en r√©alit√© de 260 pour contourner la protection de v√©rification de longueur et √©craser dans la pile la variable locale suivante et contourner les deux protections

## ARM64

Cela **ne change pas en ARM64** comme vous pouvez le voir dans [**cet article de blog**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/).

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
