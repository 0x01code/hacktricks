# 整数オーバーフロー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

## 基本情報

**整数オーバーフロー**の中心には、コンピュータプログラミングのデータ型の**サイズ**とデータの**解釈**によって課せられる制限があります。

例えば、**8ビット符号なし整数**は、**0から255**の値を表すことができます。8ビット符号なし整数に256の値を格納しようとすると、その格納容量の制限により、0にラップアラウンドします。同様に、**16ビット符号なし整数**は、**0から65,535**の値を保持できますが、65,535に1を追加すると値が0に戻ります。

さらに、**8ビット符号付き整数**は、**-128から127**の値を表すことができます。これは、1ビットが符号（正または負）を表すために使用され、残りの7ビットが大きさを表すためです。最も負の数は**-128**（バイナリ `10000000`）で表され、最も正の数は**127**（バイナリ `01111111`）です。

### 最大値

潜在的な**Web脆弱性**に関して、サポートされる最大値を知ることは非常に興味深いです:

{% tabs %}
{% tab title="Rust" %}
```rust
fn main() {

let mut quantity = 2147483647;

let (mul_result, _) = i32::overflowing_mul(32767, quantity);
let (add_result, _) = i32::overflowing_add(1, quantity);

println!("{}", mul_result);
println!("{}", add_result);
}
```
{% endtab %}

{% tab title="C" %}
整数オーバーフローは、整数演算において結果が変数のデータ型の範囲を超える場合に発生します。これは、攻撃者が制御を取るために悪用できる脆弱性を引き起こす可能性があります。例えば、整数オーバーフローを利用して、変数に格納されるべき値よりも大きな値を格納することができ、それによってメモリの破壊や予期しない動作を引き起こすことができます。整数オーバーフローは、バッファオーバーフローと組み合わせて、システムに深刻なセキュリティリスクをもたらす可能性があります。
{% endtab %}
```c
#include <stdio.h>
#include <limits.h>

int main() {
int a = INT_MAX;
int b = 0;
int c = 0;

b = a * 100;
c = a + 1;

printf("%d\n", INT_MAX);
printf("%d\n", b);
printf("%d\n", c);
return 0;
}
```
## 例

### 純粋なオーバーフロー

charをオーバーフローさせたため、印刷される結果は0になります：
```c
#include <stdio.h>

int main() {
unsigned char max = 255; // 8-bit unsigned integer
unsigned char result = max + 1;
printf("Result: %d\n", result); // Expected to overflow
return 0;
}
```
### 符号付きから符号なしへの変換

ユーザー入力から読み取られた符号付き整数が、適切な検証なしに符号なし整数として扱われる状況を考えてみましょう。
```c
#include <stdio.h>

int main() {
int userInput; // Signed integer
printf("Enter a number: ");
scanf("%d", &userInput);

// Treating the signed input as unsigned without validation
unsigned int processedInput = (unsigned int)userInput;

// A condition that might not work as intended if userInput is negative
if (processedInput > 1000) {
printf("Processed Input is large: %u\n", processedInput);
} else {
printf("Processed Input is within range: %u\n", processedInput);
}

return 0;
}
```
### その他の例

* [https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/int\_overflow\_post/index.html)
* パスワードのサイズを格納するのに1Bしか使用されていないため、オーバーフローさせて4の長さだと思わせることが可能で、実際には260であるため、長さチェック保護をバイパスすることができます。
* [https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html](https://guyinatuxedo.github.io/35-integer\_exploitation/puzzle/index.html)
* 与えられた数値の組み合わせから、z3を使用して最初の数値に掛けると2番目の数値になる新しい数値を見つける：&#x20;

```
(((argv[1] * 0x1064deadbeef4601) & 0xffffffffffffffff) == 0xD1038D2E07B42569)
```
* [https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)
* パスワードのサイズを格納するのに1Bしか使用されていないため、オーバーフローさせて4の長さだと思わせることが可能で、実際には260であるため、長さチェック保護をバイパスし、スタック内の次のローカル変数を上書きして両方の保護をバイパスすることができます。

## ARM64

これはARM64でも変わりません。[**このブログポスト**](https://8ksec.io/arm64-reversing-and-exploitation-part-8-exploiting-an-integer-overflow-vulnerability/)で確認できます。
