# BROP - Programu ya Kurudi kwa Uendeshaji kwa Kipofu

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Taarifa Msingi

Lengo la shambulio hili ni kuweza **kutumia ROP kupitia kwa kujaza kijazo bila habari yoyote kuhusu binary inayoweza kudukuliwa**.\
Shambulio hili linategemea hali ifuatayo:

* Udhaifu wa stack na maarifa ya jinsi ya kuchochea hali hiyo.
* Programu ya seva inayojirekebisha baada ya kushindwa.

## Shambulio

### **1. Pata kijazo cha udhaifu** kwa kutuma herufi moja zaidi hadi kosa la seva linagunduliwa

### **2. Jaribu nguvu ya canary** ili kuvuja hilo&#x20;

### **3. Jaribu nguvu ya RBP na RIP** zilizohifadhiwa kwenye stack ili kuzivuja

Unaweza kupata maelezo zaidi kuhusu mchakato huu [hapa (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) na [hapa (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Pata kifaa cha kusimamisha**

Kifaa hiki kimsingi kuruhusu kuthibitisha kwamba kitu cha kuvutia kimeendeshwa na kifaa cha ROP kwa sababu utekelezaji haukushindwa. Kawaida, kifaa hiki kitakuwa kitu kinachosimamisha utekelezaji na kipo mwishoni mwa mnyororo wa ROP unapotafuta vifaa vya ROP kuthibitisha kifaa maalum cha ROP kilitekelezwa

### **5. Pata kifaa cha BROP**

Mbinu hii hutumia kifaa cha [**ret2csu**](ret2csu.md). Na hii ni kwa sababu ikiwa unafikia kifaa hiki katikati ya maagizo fulani unapata vifaa vya kudhibiti **`rsi`** na **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Hivi ndivyo vifaa hivyo vitakavyokuwa:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Gundua jinsi vifaa hivyo vinavyowezesha **kudhibiti 2 hoja** za kazi ya kuita.

Pia, gundua kuwa kifaa cha ret2csu kina **sahihi ya kipekee sana** kwa sababu itakuwa inapopoa usajili 6 kutoka kwenye stack. HIVYO kutuma mnyororo kama:

`'A' * kijazo + canary + rbp + ANUANI + 0xdead * 6 + SIMAMA`

Ikiwa **SIMAMA inatekelezwa**, hii kimsingi inamaanisha **anwani inayopoa usajili 6** kutoka kwenye stack ilitumiwa. Au kwamba anwani iliyotumiwa pia ilikuwa anwani ya SIMAMA.

Ili **kuondoa chaguo hili la mwisho** mnyororo mpya kama ifuatavyo unatekelezwa na haipaswi kutekeleza kifaa cha SIMAMA kuthibitisha ile iliyotangulia ilipopoa usajili 6:

`'A' * kijazo + canary + rbp + ANUANI`

Kwa kujua anwani ya kifaa cha ret2csu, ni rahisi kufikiria anwani za vifaa vya kudhibiti `rsi` na `rdi`.

### 6. Pata PLT

Jedwali la PLT linaweza kutafutwa kutoka 0x400000 au kutoka kwa **anwani iliyovuja ya RIP** kutoka kwenye stack (ikiwa **PIE** inatumika). **Viingilio** vya jedwali hilo vime **tenganishwa na 16B** (0x10B), na wakati kazi moja inaitwa seva haijashindwa hata ikiwa hoja haziko sahihi. Pia, kuangalia anwani ya kuingia katika **PLT + 6B pia hakusababishi kushindwa** kwani ni msimbo wa kwanza unaotekelezwa.

Hivyo, ni rahisi kupata jedwali la PLT kwa kuangalia tabia zifuatazo:

* `'A' * kijazo + canary + rbp + ANUANI + SIMAMA` -> hakuna kushindwa
* `'A' * kijazo + canary + rbp + (ANUANI + 0x6) + SIMAMA` -> hakuna kushindwa
* `'A' * kijazo + canary + rbp + (ANUANI + 0x10) + SIMAMA` -> hakuna kushindwa

### 7. Kupata strcmp

Kazi ya **`strcmp`** inaweka usajili **`rdx`** kwa urefu wa herufi inayolinganishwa. Kumbuka kwamba **`rdx`** ni **hoja ya tatu** na tunahitaji iwe **kubwa kuliko 0** ili baadaye kutumia `write` kuvuja programu.

Inawezekana kupata mahali pa **`strcmp`** katika PLT kulingana na tabia yake kwa kutumia ukweli kwamba sasa tunaweza kudhibiti hoja 2 za kwanza za kazi:

* strcmp(\<anwani isiyosomwa>, \<anwani isiyosomwa>) -> kushindwa
* strcmp(\<anwani isiyosomwa>, \<anwani iliyosomwa>) -> kushindwa
* strcmp(\<anwani iliyosomwa>, \<anwani isiyosomwa>) -> kushindwa
* strcmp(\<anwani iliyosomwa>, \<anwani iliyosomwa>) -> hakuna kushindwa

Inawezekana kuthibitisha hili kwa kuita kila kuingia katika jedwali la PLT au kwa kutumia **njia ya polepole ya PLT** ambayo kimsingi inajumuisha **kuita kuingia katika jedwali la PLT + 0xb** (ambayo inaita **`dlresolve`**) ikifuatiwa kwenye stack na **namba ya kuingia mtu anayetaka kuchunguza** (kuanzia sifuri) kusoma viingilio vyote vya PLT kutoka kwa la kwanza:

* strcmp(\<anwani isiyosomwa>, \<anwani iliyosomwa>) -> kushindwa
* `b'A' * kijazo + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + SIMAMA` -> Itashindwa
* strcmp(\<anwani iliyosomwa>, \<anwani isiyosomwa>) -> kushindwa
* `b'A' * kijazo + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + SIMAMA`&#x20;
* strcmp(\<anwani iliyosomwa>, \<anwani iliyosomwa>) -> hakuna kushindwa
* `b'A' * kijazo + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + SIMAMA`&#x20;

Kumbuka kwamba:

* BROP + 0x7 inaelekeza kwa **`pop RSI; pop R15; ret;`**
* BROP + 0x9 inaelekeza kwa **`pop RDI; ret;`**
* PLT + 0xb inaelekeza kwa wito wa **dl\_resolve**.

Baada ya kupata `strcmp` ni rahisi kuweka **`rdx`** kwa thamani kubwa kuliko 0.

{% hint style="success" %}
Kumbuka kwamba kawaida `rdx` tayari itakuwa na thamani kubwa kuliko 0, hivyo hatua hii inaweza isiwe muhimu.
{% endhint %}
### 8. Kupata Write au sawa

Hatimaye, inahitajika kifaa kinachotolea data ili kutoa data ya binary. Na wakati huu ni **inawezekana kudhibiti vigezo 2 na kuweka `rdx` kuwa kubwa kuliko 0.**

Kuna kazi 3 za kawaida ambazo zinaweza kutumiwa kwa hili:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Hata hivyo, karatasi ya awali inataja tu ile ya **`write`**, hivyo hebu tuzungumzie kuhusu hilo:

Tatizo la sasa ni kwamba hatujui **mahali ambapo kazi ya kuandika iko ndani ya PLT** na hatujui **namba ya fd ya kutuma data kwenye soketi yetu**.

Hata hivyo, tunajua **mahali ambapo jedwali la PLT liko** na ni inawezekana kupata kuandika kulingana na **tabia** yake. Na tunaweza kuunda **mawasiliano kadhaa** na seva na kutumia **FD kubwa** tukitarajia kwamba italingana na baadhi ya mawasiliano yetu.

Saini za tabia za kupata hizo kazi:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ikiwa kuna data iliyochapishwa, basi puts ilipatikana
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ikiwa kuna data iliyochapishwa, basi dprintf ilipatikana
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ikiwa kuna data iliyochapishwa, basi write ilipatikana

## Udukuzi wa Kiotomatiki

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Marejeo

* Karatasi ya awali: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
