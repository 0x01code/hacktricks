# BROP - Körüklü Dönüş Yönlü Programlama

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklam görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin**.
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek paylaşın**.

</details>

## Temel Bilgiler

Bu saldırının amacı, **zararlı bir ikili hakkında hiçbir bilgi olmadan bir ROP'u bir tampon taşması aracılığıyla kötüye kullanabilmektir**.\
Bu saldırı aşağıdaki senaryoya dayanmaktadır:

* Bir yığın güvenlik açığı ve nasıl tetikleneceği hakkında bilgi.
* Bir çökme sonrası yeniden başlatan bir sunucu uygulaması.

## Saldırı

### **1. Hassas ofseti bulma** sunucunun bir arıza tespit edilene kadar bir karakter daha gönderilmesi

### **2. Canary'yi kaba kuvvetle çözme** sızdırmak için&#x20;

### **3. Depolanmış RBP ve RIP'yi kaba kuvvetle çözme** adreslerini sızdırmak için yığında

Bu süreçler hakkında daha fazla bilgiyi [burada (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) ve [burada (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md) bulabilirsiniz.

### **4. Durak cihazını bulma**

Bu cihaz temelde, ROP cihazı tarafından bir şeyin ilginç bir şekilde yürütüldüğünü onaylamaya izin verir çünkü yürütme çökmemiştir. Genellikle, bu cihaz genellikle yürütmenin durmasına neden olan bir şey olacaktır ve belirli bir ROP cihazının yürütüldüğünü doğrulamak için ROP cihazlarını ararken ROP zincirinin sonunda konumlandırılır.

### **5. BROP cihazını bulma**

Bu teknik [**ret2csu**](ret2csu.md) cihazını kullanır. Ve bu, bu cihaza erişirseniz, **`rsi`** ve **`rdi`**'yi kontrol etmek için cihazlar elde edersiniz:

<figure><img src="../../.gitbook/assets/image.png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Bunlar cihazlar olacaktır:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Bu cihazlarla **bir işlevin 2 argümanını kontrol etmek mümkündür**.

Ayrıca, ret2csu cihazının **çok benzersiz bir imzası** olduğuna dikkat edin çünkü yığından 6 kaydı çıkaracak. Bu nedenle, aşağıdaki gibi bir zincir göndermek mümkündür:

`'A' * ofset + canary + rbp + ADRES + 0xdead * 6 + DUR`

Eğer **DUR yürütülürse**, bu temelde yığından 6 kaydı çıkaran bir adresin kullanıldığı anlamına gelir. Veya kullanılan adres aynı zamanda bir DUR adresiydi.

Bu son seçeneği **kaldırmak için** önceki birinin 6 kaydı çıkardığını doğrulamak için aşağıdaki gibi yeni bir zincir yürütülür ve DUR cihazını yürütmemesi gerekir:

`'A' * ofset + canary + rbp + ADRES`

ret2csu cihazının adresini bildiğinizde, **`rsi` ve `rdi`'yi kontrol etmek için cihazların adresini çıkarabilirsiniz**.

### 6. PLT'yi bulma

PLT tablosu, 0x400000'den veya yığın üzerindeki **sızdırılan RIP adresinden** (eğer **PIE** kullanılıyorsa) aranabilir. Tablonun **girişleri** 16B (0x10B) ile ayrılmıştır ve bir işlev çağrıldığında sunucu çökmez, hatta argümanlar doğru değilse. Ayrıca, **PLT + 6B'deki bir giriş adresi de çökmüyor** çünkü bu ilk kodu yürütülen yerdir.

Bu nedenle, PLT tablosunu bulmak için aşağıdaki davranışları kontrol etmek mümkündür:

* `'A' * ofset + canary + rbp + ADRES + DUR` -> çökme olmaz
* `'A' * ofset + canary + rbp + (ADRES + 0x6) + DUR` -> çökme olmaz
* `'A' * ofset + canary + rbp + (ADRES + 0x10) + DUR` -> çökme olmaz

### 7. strcmp'i bulma

**`strcmp`** işlevi, karşılaştırılan dize uzunluğunu belirten **`rdx`** kaydını ayarlar. **`rdx`**'in **üçüncü argüman** olduğunu ve daha sonra programı sızdırmak için `write`'ı kullanabilmek için 0'dan büyük olması gerektiğini unutmayın.

Şimdi, artık fonksiyonların ilk 2 argümanını kontrol edebildiğimiz gerçeğini kullanarak, **`strcmp`**'in PLT'deki konumunu bulmak mümkündür:

* strcmp(\<okunmayan adres>, \<okunmayan adres>) -> çökme
* strcmp(\<okunmayan adres>, \<okunan adres>) -> çökme
* strcmp(\<okunan adres>, \<okunmayan adres>) -> çökme
* strcmp(\<okunan adres>, \<okunan adres>) -> çökme olmaz

Bunu kontrol etmek için PLT tablosunun her girişini çağırarak veya **PLT yavaş yolu**'nu kullanarak yapılabilir. Bu temelde, **PLT tablosundaki bir girişi + 0xb** (ki bu **`dlresolve`**'a çağrı yapar) çağırmak ve yığında **denetlemek istediğiniz giriş numarası** (sıfırdan başlayarak) ile tüm PLT girişlerini taramak anlamına gelir:

* strcmp(\<okunmayan adres>, \<okunan adres>) -> çökme
* `b'A' * ofset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(GİRİŞ) + DUR` -> Çökecek
* strcmp(\<okunan adres>, \<okunmayan adres>) -> çökme
* `b'A' * ofset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(GİRİŞ) + DUR`&#x20;
* strcmp(\<okunan adres>, \<okunan adres>) -> çökme olmaz
* `b'A' * ofset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(GİRİŞ) + DUR`&#x20;

Unutmayın ki:

* BROP + 0x7 **`pop RSI; pop R15; ret;`'e işaret eder**
* BROP + 0x9 **`pop RDI; ret;`'e işaret eder**
* PLT + 0xb **`dl\_resolve`'a bir çağrı yapar**.

`strcmp` bulunduğunda, **`rdx`**'i 0'dan büyük bir değere ayarlamak mümkün olacaktır.

{% hint style="success" %}
Genellikle `rdx` zaten 0'dan büyük bir değere sahip olacaktır, bu nedenle bu adım gerekli olmayabilir.
{% endhint %}
### 8. Write Veya Eşdeğeri Bulma

Son olarak, ikili dosyayı dışa aktarmak için veri dışa aktaran bir araca ihtiyaç duyulmaktadır. Ve bu noktada **2 argümanı kontrol etmek ve `rdx`'i 0'dan büyük ayarlamak mümkündür.**

Bunu yapmak için kötüye kullanılabilecek 3 yaygın fonksiyon bulunmaktadır:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Ancak, orijinal makale sadece **`write`**'ı belirtir, bu yüzden ondan bahsedelim:

Mevcut sorun, **write fonksiyonunun PLT içinde nerede olduğunu bilmiyoruz** ve **verileri soketimize göndermek için bir fd numarası bilmiyoruz**.

Ancak, **PLT tablosunun nerede olduğunu biliyoruz** ve davranışına dayanarak write'ı bulmak mümkündür. Ve sunucuyla **birkaç bağlantı oluşturabiliriz ve yüksek bir FD kullanarak** bağlantılarımızdan bazılarıyla eşleşmesini umabiliriz.

Bu fonksiyonları bulmak için davranış imzaları:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Veri yazdırılıyorsa, puts bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Veri yazdırılıyorsa, dprintf bulundu
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Veri yazdırılıyorsa, write bulundu

## Otomatik Sömürü

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referanslar

* Orijinal makale: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
