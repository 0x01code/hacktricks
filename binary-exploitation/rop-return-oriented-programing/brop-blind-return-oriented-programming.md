# BROP - Blind Return Oriented Programming

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Das Ziel dieses Angriffs ist es, **einen ROP √ºber einen Puffer√ºberlauf ohne Informationen √ºber das verwundbare Bin√§rprogramm zu missbrauchen**.\
Dieser Angriff basiert auf dem folgenden Szenario:

* Eine Stapelverwundbarkeit und das Wissen dar√ºber, wie man sie ausl√∂st.
* Eine Serveranwendung, die nach einem Absturz neu startet.

## Angriff

### **1. Finden Sie den verwundbaren Offset**, indem Sie ein weiteres Zeichen senden, bis ein Fehler des Servers erkannt wird

### **2. Brute-Force-Canary**, um ihn zu **leaken**

### **3. Brute-Force gespeicherte RBP- und RIP-Adressen** im Stapel, um sie zu **leaken**

Weitere Informationen zu diesen Prozessen finden Sie [hier (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) und [hier (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Finden Sie das Stop-Gadget**

Dieses Gadget erm√∂glicht im Wesentlichen die Best√§tigung, dass etwas Interessantes vom ROP-Gadget ausgef√ºhrt wurde, da die Ausf√ºhrung nicht abgest√ºrzt ist. Normalerweise handelt es sich bei diesem Gadget um etwas, das die Ausf√ºhrung **stoppt**, und es befindet sich am Ende der ROP-Kette, wenn nach ROP-Gadgets gesucht wird, um zu best√§tigen, dass ein bestimmtes ROP-Gadget ausgef√ºhrt wurde.

### **5. Finden Sie das BROP-Gadget**

Diese Technik verwendet das [**ret2csu**](ret2csu.md) Gadget. Und das liegt daran, dass, wenn Sie auf dieses Gadget inmitten einiger Anweisungen zugreifen, Gadgets erhalten, um **`rsi`** und **`rdi`** zu steuern:

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Dies w√§ren die Gadgets:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Beachten Sie, wie es mit diesen Gadgets m√∂glich ist, **2 Argumente** einer Funktion zu steuern.

Beachten Sie auch, dass das ret2csu-Gadget eine **sehr eindeutige Signatur** hat, da es 6 Register vom Stapel abruft. Daher wird eine Kette wie folgt gesendet:

`'A' * Offset + Canary + RBP + ADDR + 0xdead * 6 + STOP`

Wenn das **STOP ausgef√ºhrt wird**, bedeutet dies im Grunde genommen, dass eine **Adresse, die 6 Register vom Stapel abruft**, verwendet wurde. Oder dass die verwendete Adresse auch eine STOP-Adresse war.

Um diese letzte Option zu **entfernen**, wird eine neue Kette wie folgt ausgef√ºhrt und sie darf das STOP-Gadget nicht ausf√ºhren, um zu best√§tigen, dass das vorherige Gadget 6 Register abgerufen hat:

`'A' * Offset + Canary + RBP + ADDR`

Nachdem die Adresse des ret2csu-Gadgets gefunden wurde, ist es m√∂glich, die Adresse der Gadgets zur Steuerung von `rsi` und `rdi` zu **ableiten**.

### 6. Finden Sie PLT

Die PLT-Tabelle kann ab 0x400000 oder von der **geleakten RIP-Adresse** vom Stapel aus durchsucht werden (wenn **PIE** verwendet wird). Die **Eintr√§ge** der Tabelle sind **getrennt durch 16B** (0x10B), und wenn eine Funktion aufgerufen wird, st√ºrzt der Server nicht ab, auch wenn die Argumente nicht korrekt sind. Au√üerdem st√ºrzt das √úberpr√ºfen der Adresse eines Eintrags in der **PLT + 6B auch nicht ab**, da es der erste ausgef√ºhrte Code ist.

Daher ist es m√∂glich, die PLT-Tabelle anhand der folgenden Verhaltensweisen zu finden:

* `'A' * Offset + Canary + RBP + ADDR + STOP` -> kein Absturz
* `'A' * Offset + Canary + RBP + (ADDR + 0x6) + STOP` -> kein Absturz
* `'A' * Offset + Canary + RBP + (ADDR + 0x10) + STOP` -> kein Absturz

### 7. Finden Sie strcmp

Die **`strcmp`**-Funktion setzt das Register **`rdx`** auf die L√§nge des zu vergleichenden Strings. Beachten Sie, dass **`rdx`** das **dritte Argument** ist und wir m√∂chten, dass es **gr√∂√üer als 0** ist, um sp√§ter `write` zum Leaken des Programms verwenden zu k√∂nnen.

Es ist m√∂glich, den Speicherort von **`strcmp`** in der PLT anhand seines Verhaltens zu finden, wobei ber√ºcksichtigt wird, dass wir jetzt die ersten 2 Argumente von Funktionen steuern k√∂nnen:

* strcmp(\<nicht lesbare Adresse>, \<nicht lesbare Adresse>) -> Absturz
* strcmp(\<nicht lesbare Adresse>, \<lesbare Adresse>) -> Absturz
* strcmp(\<lesbare Adresse>, \<nicht lesbare Adresse>) -> Absturz
* strcmp(\<lesbare Adresse>, \<lesbare Adresse>) -> kein Absturz

Dies kann √ºberpr√ºft werden, indem jeder Eintrag der PLT-Tabelle aufgerufen wird oder indem der **PLT-Slow-Path** verwendet wird, der im Wesentlichen darin besteht, **einen Eintrag in der PLT-Tabelle + 0xb** (der zu **`dlresolve`** aufruft) aufzurufen, gefolgt im Stapel von der **Eintragsnummer, die man pr√ºfen m√∂chte** (beginnend bei null), um alle PLT-Eintr√§ge vom ersten zu durchsuchen:

* strcmp(\<nicht lesbare Adresse>, \<lesbare Adresse>) -> Absturz
* `b'A' * Offset + Canary + RBP + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Wird abst√ºrzen
* strcmp(\<lesbare Adresse>, \<nicht lesbare Adresse>) -> Absturz
* `b'A' * Offset + Canary + RBP + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;
* strcmp(\<lesbare Adresse>, \<lesbare Adresse>) -> kein Absturz
* `b'A' * Offset + Canary + RBP + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;

Denken Sie daran:

* BROP + 0x7 zeigt auf **`pop RSI; pop R15; ret;`**
* BROP + 0x9 zeigt auf **`pop RDI; ret;`**
* PLT + 0xb zeigt auf einen Aufruf von **dl\_resolve**.

Nachdem `strcmp` gefunden wurde, ist es m√∂glich, **`rdx`** auf einen Wert gr√∂√üer als 0 zu setzen.

{% hint style="success" %}
Beachten Sie, dass `rdx` normalerweise bereits einen Wert gr√∂√üer als 0 enth√§lt, sodass dieser Schritt m√∂glicherweise nicht erforderlich ist.
{% endhint %}
### 8. Finden von Write oder √Ñquivalent

Schlie√ülich wird ein Gadget ben√∂tigt, das Daten exfiltriert, um das Bin√§rprogramm zu exfiltrieren. Und zu diesem Zeitpunkt ist es m√∂glich, **2 Argumente zu kontrollieren und `rdx` gr√∂√üer als 0 zu setzen**.

Es gibt 3 g√§ngige Funktionen, die daf√ºr missbraucht werden k√∂nnten:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Jedoch erw√§hnt das Originaldokument nur die **`write`** Funktion, also lassen Sie uns dar√ºber sprechen:

Das aktuelle Problem ist, dass wir nicht wissen, **wo sich die write-Funktion im PLT befindet** und wir nicht wissen **eine FD-Nummer, um die Daten an unseren Socket zu senden**.

Wir wissen jedoch **wo sich die PLT-Tabelle befindet** und es ist m√∂glich, write basierend auf seinem **Verhalten** zu finden. Und wir k√∂nnen **mehrere Verbindungen** mit dem Server herstellen und einen **hohen FD** verwenden, in der Hoffnung, dass er mit einigen unserer Verbindungen √ºbereinstimmt.

Verhaltenssignaturen zum Auffinden dieser Funktionen:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Wenn Daten gedruckt werden, wurde puts gefunden
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Wenn Daten gedruckt werden, wurde dprintf gefunden
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Wenn Daten gedruckt werden, wurde write gefunden

## Automatische Ausnutzung

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Referenzen

* Originaldokument: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
