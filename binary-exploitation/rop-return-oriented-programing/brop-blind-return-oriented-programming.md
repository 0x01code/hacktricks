# BROP - Blind Return Oriented Programming

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informazioni di Base

Lo scopo di questo attacco √® quello di **sfruttare un ROP tramite un buffer overflow senza alcuna informazione sul binario vulnerabile**.\
Questo attacco si basa sul seguente scenario:

* Una vulnerabilit√† dello stack e la conoscenza di come attivarla.
* Un'applicazione server che si riavvia dopo un crash.

## Attacco

### **1. Trova l'offset vulnerabile** inviando un carattere in pi√π fino a quando non viene rilevato un malfunzionamento del server

### **2. Forza bruta sul canary** per effettuare un **leak**

### **3. Forza bruta sugli indirizzi RBP e RIP** memorizzati nello stack per effettuare un **leak**

√à possibile trovare ulteriori informazioni su questi processi [qui (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) e [qui (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Trova il gadget di stop**

Questo gadget permette fondamentalmente di confermare che √® stato eseguito qualcosa di interessante tramite il gadget ROP perch√© l'esecuzione non √® crashata. Di solito, questo gadget sar√† qualcosa che **ferma l'esecuzione** ed √® posizionato alla fine della catena ROP quando si cercano i gadget ROP per confermare che un determinato gadget ROP √® stato eseguito.

### **5. Trova il gadget BROP**

Questa tecnica utilizza il gadget [**ret2csu**](ret2csu.md). E questo perch√© se si accede a questo gadget nel mezzo di alcune istruzioni si ottengono gadget per controllare **`rsi`** e **`rdi`**:

<figure><img src="../../.gitbook/assets/image.png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Questi sarebbero i gadget:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Nota come con quei gadget √® possibile **controllare 2 argomenti** di una funzione da chiamare.

Inoltre, nota che il gadget ret2csu ha una **firma molto unica** perch√© estrarr√† 6 registri dallo stack. Quindi inviando una catena come:

`'A' * offset + canary + rbp + ADDR + 0xdead * 6 + STOP`

Se viene eseguito lo **STOP**, ci√≤ significa fondamentalmente che √® stato utilizzato un **indirizzo che estrae 6 registri** dallo stack. Oppure che l'indirizzo utilizzato era anche un indirizzo di STOP.

Per **rimuovere questa ultima opzione** viene eseguita una nuova catena come la seguente e non deve eseguire il gadget STOP per confermare che il precedente ha estratto 6 registri:

`'A' * offset + canary + rbp + ADDR`

Conoscendo l'indirizzo del gadget ret2csu, √® possibile **dedurre l'indirizzo dei gadget per controllare `rsi` e `rdi`**.

### 6. Trova il PLT

La tabella PLT pu√≤ essere cercata da 0x400000 o dall'**indirizzo RIP leakato** dallo stack (se viene utilizzato **PIE**). Le **voci** della tabella sono **separate da 16B** (0x10B), e quando viene chiamata una funzione il server non crasha anche se gli argomenti non sono corretti. Inoltre, controllando l'indirizzo di una voce nel **PLT + 6B non crasha** poich√© √® il primo codice eseguito.

Pertanto, √® possibile trovare la tabella PLT controllando i seguenti comportamenti:

* `'A' * offset + canary + rbp + ADDR + STOP` -> nessun crash
* `'A' * offset + canary + rbp + (ADDR + 0x6) + STOP` -> nessun crash
* `'A' * offset + canary + rbp + (ADDR + 0x10) + STOP` -> nessun crash

### 7. Trova strcmp

La funzione **`strcmp`** imposta il registro **`rdx`** alla lunghezza della stringa confrontata. Nota che **`rdx`** √® il **terzo argomento** e deve essere **maggiore di 0** per poter successivamente utilizzare `write` per effettuare un leak del programma.

√à possibile trovare la posizione di **`strcmp`** nella PLT basandosi sul suo comportamento utilizzando il fatto che ora possiamo controllare i primi 2 argomenti delle funzioni:

* strcmp(\<indirizzo non letto>, \<indirizzo non letto>) -> crash
* strcmp(\<indirizzo non letto>, \<indirizzo letto>) -> crash
* strcmp(\<indirizzo letto>, \<indirizzo non letto>) -> crash
* strcmp(\<indirizzo letto>, \<indirizzo letto>) -> nessun crash

√à possibile verificare ci√≤ chiamando ciascuna voce della tabella PLT o utilizzando il **percorso lento PLT** che consiste fondamentalmente nel **chiamare una voce nella tabella PLT + 0xb** (che chiama a **`dlresolve`**) seguito nello stack dal **numero di voce che si desidera esaminare** (a partire da zero) per esaminare tutte le voci della PLT:

* strcmp(\<indirizzo non letto>, \<indirizzo letto>) -> crash
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Crash
* strcmp(\<indirizzo letto>, \<indirizzo non letto>) -> crash
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;
* strcmp(\<indirizzo letto>, \<indirizzo letto>) -> nessun crash
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;

Ricorda che:

* BROP + 0x7 punta a **`pop RSI; pop R15; ret;`**
* BROP + 0x9 punta a **`pop RDI; ret;`**
* PLT + 0xb punta a una chiamata a **dl\_resolve**.

Avendo trovato `strcmp` √® possibile impostare **`rdx`** su un valore maggiore di 0.

{% hint style="success" %}
Nota che di solito `rdx` conterr√† gi√† un valore maggiore di 0, quindi questo passaggio potrebbe non essere necessario.
{% endhint %}
### 8. Trovare Write o equivalente

Infine, √® necessario un gadget che esfiltrer√† i dati per esfiltrare il binario. E in questo momento √® possibile **controllare 2 argomenti e impostare `rdx` maggiore di 0.**

Ci sono 3 funzioni comuni che potrebbero essere abusate per questo:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Tuttavia, il documento originale menziona solo la funzione **`write`**, quindi parliamone:

Il problema attuale √® che non sappiamo **dove si trova la funzione write all'interno del PLT** e non conosciamo **un numero fd per inviare i dati al nostro socket**.

Tuttavia, sappiamo **dove si trova la tabella PLT** ed √® possibile trovare write in base al suo **comportamento**. E possiamo creare **diverse connessioni** con il server e utilizzare un **FD alto** sperando che corrisponda a una delle nostre connessioni.

Firme comportamentali per trovare queste funzioni:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Se vengono stampati dati, allora √® stata trovata puts
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Se vengono stampati dati, allora √® stata trovata dprintf
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Se vengono stampati dati, allora √® stata trovata write

## Sfruttamento Automatico

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Riferimenti

* Documento originale: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
