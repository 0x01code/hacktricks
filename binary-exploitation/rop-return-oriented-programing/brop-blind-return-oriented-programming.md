# BROP - Programa√ß√£o Orientada a Retorno Cega

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

O objetivo deste ataque √© ser capaz de **abusar de um ROP por meio de um estouro de buffer sem nenhuma informa√ß√£o sobre o bin√°rio vulner√°vel**.\
Este ataque √© baseado no seguinte cen√°rio:

* Uma vulnerabilidade de pilha e conhecimento de como ativ√°-la.
* Uma aplica√ß√£o de servidor que reinicia ap√≥s uma falha.

## Ataque

### **1. Encontrar o deslocamento vulner√°vel** enviando um caractere a mais at√© que uma falha no servidor seja detectada

### **2. For√ßar o can√°rio** para vaz√°-lo&#x20;

### **3. For√ßar os endere√ßos RBP e RIP armazenados** na pilha para vaz√°-los

Voc√™ pode encontrar mais informa√ß√µes sobre esses processos [aqui (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) e [aqui (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Encontrar o gadget de parada**

Este gadget basicamente permite confirmar que algo interessante foi executado pelo gadget ROP porque a execu√ß√£o n√£o travou. Geralmente, esse gadget ser√° algo que **interrompe a execu√ß√£o** e √© posicionado no final da cadeia ROP ao procurar gadgets ROP espec√≠ficos que foram executados.

### **5. Encontrar o gadget BROP**

Esta t√©cnica usa o gadget [**ret2csu**](ret2csu.md). E isso ocorre porque se voc√™ acessar esse gadget no meio de algumas instru√ß√µes, voc√™ obt√©m gadgets para controlar **`rsi`** e **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Esses seriam os gadgets:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Observe como com esses gadgets √© poss√≠vel **controlar 2 argumentos** de uma fun√ß√£o a ser chamada.

Al√©m disso, observe que o gadget ret2csu tem uma **assinatura muito √∫nica** porque ele vai desempilhar 6 registradores da pilha. Ent√£o, enviando uma cadeia como:

`'A' * deslocamento + can√°rio + rbp + ADDR + 0xdead * 6 + STOP`

Se o **STOP for executado**, isso basicamente significa que um **endere√ßo que est√° desempilhando 6 registradores** da pilha foi usado. Ou que o endere√ßo usado tamb√©m foi um endere√ßo STOP.

Para **remover esta √∫ltima op√ß√£o** uma nova cadeia como a seguinte √© executada e n√£o deve executar o gadget STOP para confirmar que o anterior desempilhou 6 registradores:

`'A' * deslocamento + can√°rio + rbp + ADDR`

Sabendo o endere√ßo do gadget ret2csu, √© poss√≠vel **inferir o endere√ßo dos gadgets para controlar `rsi` e `rdi`**.

### 6. Encontrar PLT

A tabela PLT pode ser pesquisada a partir de 0x400000 ou do **endere√ßo RIP vazado** da pilha (se **PIE** estiver sendo usado). As **entradas** da tabela s√£o **separadas por 16B** (0x10B), e quando uma fun√ß√£o √© chamada, o servidor n√£o trava mesmo se os argumentos n√£o estiverem corretos. Al√©m disso, verificar o endere√ßo de uma entrada na **PLT + 6B tamb√©m n√£o trava** pois √© o primeiro c√≥digo executado.

Portanto, √© poss√≠vel encontrar a tabela PLT verificando os seguintes comportamentos:

* `'A' * deslocamento + can√°rio + rbp + ADDR + STOP` -> sem travamento
* `'A' * deslocamento + can√°rio + rbp + (ADDR + 0x6) + STOP` -> sem travamento
* `'A' * deslocamento + can√°rio + rbp + (ADDR + 0x10) + STOP` -> sem travamento

### 7. Encontrar strcmp

A fun√ß√£o **`strcmp`** define o registrador **`rdx`** como o comprimento da string sendo comparada. Observe que **`rdx`** √© o **terceiro argumento** e precisamos que ele seja **maior que 0** para posteriormente usar `write` para vazar o programa.

√â poss√≠vel encontrar a localiza√ß√£o do **`strcmp`** na PLT com base em seu comportamento usando o fato de que agora podemos controlar os 2 primeiros argumentos das fun√ß√µes:

* strcmp(\<endere√ßo n√£o lido>, \<endere√ßo n√£o lido>) -> travamento
* strcmp(\<endere√ßo n√£o lido>, \<endere√ßo lido>) -> travamento
* strcmp(\<endere√ßo lido>, \<endere√ßo n√£o lido>) -> travamento
* strcmp(\<endere√ßo lido>, \<endere√ßo lido>) -> sem travamento

√â poss√≠vel verificar isso chamando cada entrada da tabela PLT ou usando o **caminho lento da PLT** que basicamente consiste em **chamar uma entrada na tabela PLT + 0xb** (que chama para **`dlresolve`**) seguido na pilha pelo **n√∫mero de entrada que se deseja sondar** (come√ßando em zero) para escanear todas as entradas da PLT a partir da primeira:

* strcmp(\<endere√ßo n√£o lido>, \<endere√ßo lido>) -> travamento
* `b'A' * deslocamento + can√°rio + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Vai travar
* strcmp(\<endere√ßo lido>, \<endere√ßo n√£o lido>) -> travamento
* `b'A' * deslocamento + can√°rio + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;
* strcmp(\<endere√ßo lido>, \<endere√ßo lido>) -> sem travamento
* `b'A' * deslocamento + can√°rio + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;

Lembre-se de que:

* BROP + 0x7 aponta para **`pop RSI; pop R15; ret;`**
* BROP + 0x9 aponta para **`pop RDI; ret;`**
* PLT + 0xb aponta para uma chamada para **dl\_resolve**.

Tendo encontrado `strcmp`, √© poss√≠vel definir **`rdx`** com um valor maior que 0.

{% hint style="success" %}
Observe que geralmente `rdx` j√° ter√° um valor maior que 0, ent√£o esta etapa pode n√£o ser necess√°ria.
{% endhint %}
### 8. Encontrando Write ou equivalente

Finalmente, √© necess√°rio um gadget que exfiltra dados para exfiltrar o bin√°rio. E neste momento √© poss√≠vel **controlar 2 argumentos e definir `rdx` maior que 0**.

Existem 3 fun√ß√µes comuns que poderiam ser abusadas para isso:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

No entanto, o artigo original menciona apenas o **`write`**, ent√£o vamos falar sobre ele:

O problema atual √© que n√£o sabemos **onde a fun√ß√£o write est√° dentro da PLT** e n√£o sabemos **um n√∫mero de fd para enviar os dados para nosso socket**.

No entanto, sabemos **onde est√° a tabela PLT** e √© poss√≠vel encontrar write com base em seu **comportamento**. E podemos criar **v√°rias conex√µes** com o servidor e usar um **FD alto** esperando que corresponda a algumas de nossas conex√µes.

Assinaturas de comportamento para encontrar essas fun√ß√µes:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Se houver dados impressos, ent√£o puts foi encontrado
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Se houver dados impressos, ent√£o dprintf foi encontrado
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Se houver dados impressos, ent√£o write foi encontrado

## Explora√ß√£o Autom√°tica

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Refer√™ncias

* Artigo original: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
