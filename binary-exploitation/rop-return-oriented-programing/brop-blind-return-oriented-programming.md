# BROP - Programu ya Kurudi kwa Utekelezaji wa Kipofu

{% hint style="success" %}
Jifunze & zoezi la Kuvamia AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**Mafunzo ya HackTricks AWS Timu Nyekundu Mtaalam (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Jifunze & zoezi la Kuvamia GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**Mafunzo ya HackTricks GCP Timu Nyekundu Mtaalam (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>unga mkono HackTricks</summary>

* Angalia [**mpango wa michango**](https://github.com/sponsors/carlospolop)!
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu za kuvamia kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}

## Taarifa Msingi

Lengo la shambulio hili ni kuweza **kutumia ROP kupitia kujaza kijeraha bila habari yoyote kuhusu binary inayoweza kudhuriwa**.\
Shambulio hili linategemea hali ifuatayo:

* Kijeraha cha stack na maarifa ya jinsi ya kukitumia.
* Programu ya seva ambayo huanza upya baada ya kushindwa.

## Shambulio

### **1. Pata offset inayoweza kudhuriwa** kwa kutuma herufi moja zaidi hadi kosa la seva litambuliwe

### **2. Jaribu nguvu ya canary** ili kulivuja&#x20;

### **3. Jaribu nguvu ya RBP na RIP** zilizohifadhiwa kwenye stack ili kulivuja

Unaweza kupata habari zaidi kuhusu mchakato huu [hapa (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) na [hapa (BF Anwani kwenye Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Pata kifaa cha kusimamisha**

Kifaa hiki kimsingi kuruhusu kuthibitisha kwamba kitu cha kuvutia kimeendeshwa na kifaa cha ROP kwa sababu utekelezaji haukushindwa. Kawaida, kifaa hiki kitakuwa kitu kinachosimamisha utekelezaji na kipo mwishoni mwa mnyororo wa ROP wakati wa kutafuta vifaa vya ROP kuthibitisha kifaa cha ROP kilichoendeshwa maalum

### **5. Pata kifaa cha BROP**

Mbinu hii hutumia kifaa cha [**ret2csu**](ret2csu.md). Na hii ni kwa sababu ikiwa unafikia kifaa hiki katikati ya maagizo fulani unapata vifaa vya kudhibiti **`rsi`** na **`rdi`**:

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Hivi ndivyo vifaa hivyo vitakavyokuwa:

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Gundua jinsi vifaa hivyo vinavyowezesha **kudhibiti hoja 2** za kazi ya kuita.

Pia, gundua kuwa kifaa cha ret2csu kina **sahihi ya kipekee sana** kwa sababu kitakuwa kikitoa 6 rejista kutoka kwenye stack. HIVYO kutuma mnyororo kama:

`'A' * offset + canary + rbp + ANWANI + 0xdead * 6 + SIMAMA`

Ikiwa **SIMAMA inatekelezwa**, hii kimsingi inamaanisha **anwani ambayo inapiga 6 rejista** kutoka kwenye stack ilitumiwa. Au kwamba anwani iliyotumiwa pia ilikuwa anwani ya SIMAMA.

Ili **kuondoa chaguo hili la mwisho** mnyororo mpya kama ifuatavyo unatekelezwa na haipaswi kutekeleza kifaa cha SIMAMA kuthibitisha kwamba ile iliyotangulia ilipiga 6 rejista:

`'A' * offset + canary + rbp + ANWANI`

Kwa kujua anwani ya kifaa cha ret2csu, ni rahisi kufikiria anwani za vifaa vya kudhibiti `rsi` na `rdi`.

### 6. Pata PLT

Jedwali la PLT linaweza kutafutwa kutoka 0x400000 au kutoka kwa **anwani iliyovuja ya RIP** kutoka kwenye stack (ikiwa **PIE** inatumika). **Viingilio** vya jedwali hili vime **tenganishwa na 16B** (0x10B), na wakati kazi moja inaitwa seva haishindwi hata ikiwa hoja sio sahihi. Pia, kuangalia anwani ya kuingia katika **PLT + 6B pia haishindwi** kwani ni msimbo wa kwanza unaotekelezwa.

Hivyo, ni rahisi kupata jedwali la PLT kwa kuangalia tabia zifuatazo:

* `'A' * offset + canary + rbp + ANWANI + SIMAMA` -> hakuna kushindwa
* `'A' * offset + canary + rbp + (ANWANI + 0x6) + SIMAMA` -> hakuna kushindwa
* `'A' * offset + canary + rbp + (ANWANI + 0x10) + SIMAMA` -> hakuna kushindwa

### 7. Kupata strcmp

Kazi ya **`strcmp`** inaweka rejista **`rdx`** kwa urefu wa herufi inayolinganishwa. Kumbuka kwamba **`rdx`** ni **hoja ya tatu** na tunahitaji iwe **kubwa kuliko 0** ili baadaye kutumia `write` kulivuja programu.

Inawezekana kupata mahali pa **`strcmp`** katika PLT kulingana na tabia yake kwa kutumia ukweli kwamba sasa tunaweza kudhibiti hoja 2 za kwanza za kazi:

* strcmp(\<anwani isiyosomwa>, \<anwani isiyosomwa>) -> kushindwa
* strcmp(\<anwani isiyosomwa>, \<anwani iliyosomwa>) -> kushindwa
* strcmp(\<anwani iliyosomwa>, \<anwani isiyosomwa>) -> kushindwa
* strcmp(\<anwani iliyosomwa>, \<anwani iliyosomwa>) -> hakuna kushindwa

Inawezekana kuthibitisha hii kwa kuita kila kuingia kwenye jedwali la PLT au kwa kutumia **njia polepole ya PLT** ambayo kimsingi inajumuisha **kuita kuingia kwenye jedwali la PLT + 0xb** (ambayo inaita **`dlresolve`**) ikifuatiwa kwenye stack na **namba ya kuingia mtu anayetaka kuchunguza** (kuanzia sifuri) kusoma viingilio vyote vya PLT kutoka kwa la kwanza:

* strcmp(\<anwani isiyosomwa>, \<anwani iliyosomwa>) -> kushindwa
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + SIMAMA` -> Itashindwa
* strcmp(\<anwani iliyosomwa>, \<anwani isiyosomwa>) -> kushindwa
* `b'A' * offset + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + SIMAMA`&#x20;
* strcmp(\<anwani iliyosomwa>, \<anwani iliyosomwa>) -> hakuna kushindwa
* `b'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + SIMAMA`&#x20;

Kumbuka kwamba:

* BROP + 0x7 inaelekeza kwa **`pop RSI; pop R15; ret;`**
* BROP + 0x9 inaelekeza kwa **`pop RDI; ret;`**
* PLT + 0xb inaelekeza kwa wito wa **dl\_resolve**.

Baada ya kupata `strcmp` ni rahisi kuweka **`rdx`** kwa thamani kubwa kuliko 0.

{% hint style="success" %}
Kumbuka kwamba kawaida `rdx` tayari itakuwa na thamani kubwa kuliko 0, hivyo hatua hii inaweza isiwe muhimu.
{% endhint %}
### 8. Kupata Write au sawa

Hatimaye, inahitajika kifaa kinachotoa data ili kutoa data ya binary. Na wakati huu ni **inawezekana kudhibiti vigezo 2 na kuweka `rdx` kuwa kubwa kuliko 0.**

Kuna kazi 3 za kawaida ambazo zinaweza kutumiwa kwa hili:

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Hata hivyo, karatasi ya awali inataja tu **`write`**, hivyo hebu tuzungumzie kuhusu hilo:

Tatizo la sasa ni kwamba hatujui **mahali ambapo kazi ya kuandika iko ndani ya PLT** na hatujui **namba ya fd ya kutuma data kwa soketi yetu**.

Hata hivyo, tunajua **mahali ambapo jedwali la PLT liko** na ni inawezekana kupata kuandika kulingana na **tabia** yake. Na tunaweza kuunda **mawasiliano kadhaa** na seva na kutumia **FD kubwa** tukitarajia kwamba inalingana na baadhi ya mawasiliano yetu.

Saini za tabia za kupata hizo kazi:

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ikiwa kuna data iliyochapishwa, basi puts ilipatikana
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ikiwa kuna data iliyochapishwa, basi dprintf ilipatikana
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Ikiwa kuna data iliyochapishwa, basi write ilipatikana

## Utekaji wa Kiotomatiki

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## Marejeo

* Karatasi ya awali: [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
