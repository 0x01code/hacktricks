# BROP - Programmation orient√©e retour aveugle

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Informations de base

L'objectif de cette attaque est de pouvoir **abuser d'un ROP via un d√©passement de tampon sans aucune information sur le binaire vuln√©rable**.\
Cette attaque est bas√©e sur le sc√©nario suivant :

* Une vuln√©rabilit√© de pile et la connaissance de comment la d√©clencher.
* Une application serveur qui red√©marre apr√®s un crash.

## Attaque

### **1. Trouver le d√©calage vuln√©rable** en envoyant un caract√®re de plus jusqu'√† ce qu'un dysfonctionnement du serveur soit d√©tect√©

### **2. Forcer le canary** pour le divulguer&#x20;

### **3. Forcer les adresses RBP et RIP stock√©es** dans la pile pour les divulguer

Vous pouvez trouver plus d'informations sur ces processus [ici (BF Forked & Threaded Stack Canaries)](../common-binary-protections-and-bypasses/stack-canaries/bf-forked-stack-canaries.md) et [ici (BF Addresses in the Stack)](../common-binary-protections-and-bypasses/pie/bypassing-canary-and-pie.md).

### **4. Trouver le gadget d'arr√™t**

Ce gadget permet essentiellement de confirmer qu'un √©l√©ment int√©ressant a √©t√© ex√©cut√© par le gadget ROP car l'ex√©cution n'a pas plant√©. En g√©n√©ral, ce gadget va √™tre quelque chose qui **arr√™te l'ex√©cution** et il est positionn√© √† la fin de la cha√Æne ROP lors de la recherche de gadgets ROP pour confirmer qu'un gadget ROP sp√©cifique a √©t√© ex√©cut√©.

### **5. Trouver le gadget BROP**

Cette technique utilise le gadget [**ret2csu**](ret2csu.md). Et c'est parce que si vous acc√©dez √† ce gadget au milieu de certaines instructions, vous obtenez des gadgets pour contr√¥ler **`rsi`** et **`rdi`** :

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt="" width="278"><figcaption><p><a href="https://www.scs.stanford.edu/brop/bittau-brop.pdf">https://www.scs.stanford.edu/brop/bittau-brop.pdf</a></p></figcaption></figure>

Ceux-ci seraient les gadgets :

* `pop rsi; pop r15; ret`
* `pop rdi; ret`

Remarquez comment avec ces gadgets, il est possible de **contr√¥ler 2 arguments** d'une fonction √† appeler.

Remarquez √©galement que le gadget ret2csu a une **signature tr√®s unique** car il va d√©piler 6 registres de la pile. Ainsi, en envoyant une cha√Æne comme :

`'A' * d√©calage + canary + rbp + ADDR + 0xdead * 6 + STOP`

Si le **STOP est ex√©cut√©**, cela signifie essentiellement qu'une **adresse qui d√©pile 6 registres** de la pile a √©t√© utilis√©e. Ou que l'adresse utilis√©e √©tait √©galement une adresse STOP.

Pour **√©liminer cette derni√®re option**, une nouvelle cha√Æne comme celle-ci est ex√©cut√©e et elle ne doit pas ex√©cuter le gadget STOP pour confirmer que le pr√©c√©dent a bien d√©pli√© 6 registres :

`'A' * d√©calage + canary + rbp + ADDR`

En connaissant l'adresse du gadget ret2csu, il est possible de **d√©duire l'adresse des gadgets pour contr√¥ler `rsi` et `rdi`**.

### 6. Trouver PLT

La table PLT peut √™tre recherch√©e √† partir de 0x400000 ou de l'**adresse RIP divulgu√©e** de la pile (si **PIE** est utilis√©). Les **entr√©es** de la table sont **s√©par√©es de 16B** (0x10B), et lorsqu'une fonction est appel√©e, le serveur ne plante pas m√™me si les arguments ne sont pas corrects. De plus, v√©rifier l'adresse d'une entr√©e dans le **PLT + 6B ne plante pas non plus** car c'est le premier code ex√©cut√©.

Par cons√©quent, il est possible de trouver la table PLT en v√©rifiant les comportements suivants :

* `'A' * d√©calage + canary + rbp + ADDR + STOP` -> pas de plantage
* `'A' * d√©calage + canary + rbp + (ADDR + 0x6) + STOP` -> pas de plantage
* `'A' * d√©calage + canary + rbp + (ADDR + 0x10) + STOP` -> pas de plantage

### 7. Trouver strcmp

La fonction **`strcmp`** d√©finit le registre **`rdx`** √† la longueur de la cha√Æne compar√©e. Notez que **`rdx`** est le **troisi√®me argument** et nous devons qu'il soit **sup√©rieur √† 0** pour pouvoir ensuite utiliser `write` pour divulguer le programme.

Il est possible de trouver l'emplacement de **`strcmp`** dans le PLT en fonction de son comportement en utilisant le fait que nous pouvons maintenant contr√¥ler les 2 premiers arguments des fonctions :

* strcmp(\<adresse non lue>, \<adresse non lue>) -> plantage
* strcmp(\<adresse non lue>, \<adresse lue>) -> plantage
* strcmp(\<adresse lue>, \<adresse non lue>) -> plantage
* strcmp(\<adresse lue>, \<adresse lue>) -> pas de plantage

Il est possible de v√©rifier cela en appelant chaque entr√©e de la table PLT ou en utilisant le **chemin lent PLT** qui consiste essentiellement √† **appeler une entr√©e dans la table PLT + 0xb** (qui appelle √† **`dlresolve`**) suivi dans la pile par le **num√©ro d'entr√©e que l'on souhaite sonder** (en commen√ßant par z√©ro) pour scanner toutes les entr√©es PLT √† partir de la premi√®re :

* strcmp(\<adresse non lue>, \<adresse lue>) -> plantage
* `b'A' * d√©calage + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0x300) + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP` -> Va planter
* strcmp(\<adresse lue>, \<adresse non lue>) -> plantage
* `b'A' * d√©calage + canary + rbp + (BROP + 0x9) + p64(0x300) + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;
* strcmp(\<adresse lue>, \<adresse lue>) -> pas de plantage
* `b'A' * d√©calage + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb ) + p64(ENTRY) + STOP`&#x20;

Rappelez-vous que :

* BROP + 0x7 pointe vers **`pop RSI; pop R15; ret;`**
* BROP + 0x9 pointe vers **`pop RDI; ret;`**
* PLT + 0xb pointe vers un appel √† **dl\_resolve**.

Apr√®s avoir trouv√© `strcmp`, il est possible de d√©finir **`rdx`** sur une valeur sup√©rieure √† 0.

{% hint style="success" %}
Notez que g√©n√©ralement `rdx` aura d√©j√† une valeur sup√©rieure √† 0, donc cette √©tape pourrait ne pas √™tre n√©cessaire.
{% endhint %}
### 8. Trouver Write ou √©quivalent

Enfin, il est n√©cessaire d'avoir un gadget qui exfiltre des donn√©es afin d'exfiltrer le binaire. Et √† ce moment-l√†, il est possible de **contr√¥ler 2 arguments et de d√©finir `rdx` plus grand que 0.**

Il existe 3 fonctions courantes qui pourraient √™tre abus√©es √† cette fin :

* `puts(data)`
* `dprintf(fd, data)`
* `write(fd, data, len(data)`

Cependant, le document original ne mentionne que la fonction **`write`**, donc parlons-en :

Le probl√®me actuel est que nous ne savons pas **o√π se trouve la fonction write dans la PLT** et nous ne connaissons pas **un num√©ro de fd pour envoyer les donn√©es √† notre socket**.

Cependant, nous savons **o√π se trouve la table PLT** et il est possible de trouver write en fonction de son **comportement**. Et nous pouvons cr√©er **plusieurs connexions** avec le serveur et utiliser un **FD √©lev√©** en esp√©rant qu'il corresponde √† certaines de nos connexions.

Signatures de comportement pour trouver ces fonctions :

* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + p64(0) + p64(0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Si des donn√©es sont imprim√©es, alors puts a √©t√© trouv√©
* `'A' * offset + canary + rbp + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Si des donn√©es sont imprim√©es, alors dprintf a √©t√© trouv√©
* `'A' * offset + canary + rbp + (BROP + 0x9) + RIP + (BROP + 0x7) + (RIP + 0x1) + p64(0x0) + (PLT + 0xb ) + p64(STRCMP ENTRY) + (BROP + 0x9) + FD + (BROP + 0x7) + RIP + p64(0x0) + (PLT + 0xb) + p64(ENTRY) + STOP`  -> Si des donn√©es sont imprim√©es, alors write a √©t√© trouv√©

## Exploitation Automatique

* [https://github.com/Hakumarachi/Bropper](https://github.com/Hakumarachi/Bropper)

## R√©f√©rences

* Document original : [https://www.scs.stanford.edu/brop/bittau-brop.pdf](https://www.scs.stanford.edu/brop/bittau-brop.pdf)
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/blind-return-oriented-programming-brop)
