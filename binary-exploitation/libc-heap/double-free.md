# Podwójne Zwolnienie

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF** sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) na GitHubie.

</details>

## Podstawowe Informacje

Jeśli zwolnisz blok pamięci więcej niż raz, może to zaburzyć dane alokatora i otworzyć drzwi do ataków. Oto jak to się dzieje: gdy zwalniasz blok pamięci, wraca on do listy wolnych fragmentów (np. "szybki blok"). Jeśli zwolnisz ten sam blok dwa razy z rzędu, alokator wykrywa to i zgłasza błąd. Ale jeśli **zwolnisz inny fragment pomiędzy nimi, sprawdzanie podwójnego zwolnienia jest obejścione**, co powoduje uszkodzenie.

Teraz, gdy poprosisz o nową pamięć (używając `malloc`), alokator może dać ci **blok, który został zwolniony dwukrotnie**. Może to prowadzić do dwóch różnych wskaźników wskazujących na tę samą lokalizację pamięci. Jeśli atakujący kontroluje jeden z tych wskaźników, może zmienić zawartość tej pamięci, co może powodować problemy z bezpieczeństwem lub nawet umożliwić mu wykonanie kodu.

Przykład:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
W tym przykładzie, po zapełnieniu tcache kilkoma zwolnionymi fragmentami (7), kod **zwalnia fragment `h`, następnie fragment `i`, a następnie ponownie `h`, powodując podwójne zwolnienie** (znane również jako duplikat Fast Bin). Otwiera to możliwość otrzymywania nakładających się adresów pamięci podczas ponownego przydzielania, co oznacza, że dwa lub więcej wskaźników mogą wskazywać na ten sam obszar pamięci. Manipulowanie danymi za pomocą jednego wskaźnika może wpłynąć na drugi, tworząc poważne ryzyko bezpieczeństwa i potencjał do eksploatacji.

Wykonując to, zauważ, jak **`i1` i `i2` otrzymały ten sam adres**:

<pre><code>Alokacje początkowe:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Po ponownych przydziałach:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Przykłady

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Możemy przydzielać tylko fragmenty o rozmiarze Fast-Bin, z wyjątkiem rozmiaru `0x70`, co uniemożliwia standardowe nadpisanie `__malloc_hook`.
* Zamiast tego używamy adresów PIE, które zaczynają się od `0x56` jako celu dla Fast Bin dup (1/2 szansy).
* Jednym miejscem, gdzie przechowywane są adresy PIE, jest `main_arena`, która znajduje się wewnątrz Glibc i w pobliżu `__malloc_hook`.
* Celujemy w określony offset `main_arena`, aby przydzielić tam fragment, a następnie kontynuujemy przydzielanie fragmentów, aż dotrzemy do `__malloc_hook`, aby uzyskać wykonanie kodu.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Korzystając z pojemników Tcache i przepełnienia bajtu zerowego, możemy osiągnąć sytuację podwójnego zwolnienia:
* Alokujemy trzy fragmenty o rozmiarze `0x110` (`A`, `B`, `C`)
* Zwalniamy `B`
* Zwalniamy `A` i ponownie przydzielamy, aby skorzystać z przepełnienia bajtu zerowego
* Teraz pole rozmiaru `B` to `0x100`, zamiast `0x111`, więc możemy go ponownie zwolnić
* Mamy jeden pojemnik Tcache o rozmiarze `0x110` i jeden o rozmiarze `0x100`, które wskazują na ten sam adres. Mamy więc podwójne zwolnienie.
* Wykorzystujemy podwójne zwolnienie za pomocą [zatruwania Tcache](tcache-bin-attack.md)

## Odnośniki

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
