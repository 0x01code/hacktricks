# Dvostruko Oslobađanje

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Obuka AWS Crveni Tim Stručnjak (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Obuka GCP Crveni Tim Stručnjak (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili **pratite** nas na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}

## Osnovne Informacije

Ako oslobodite blok memorije više puta, možete poremetiti podatke alokatora i otvoriti vrata napadima. Evo kako se to dešava: kada oslobodite blok memorije, on se vraća u listu slobodnih blokova (npr. "brzi bin"). Ako oslobodite isti blok dva puta zaredom, alokator detektuje to i prijavljuje grešku. Međutim, ako **oslobodite još jedan blok između, provera dvostrukog oslobađanja se zaobilazi**, što uzrokuje korupciju.

Sada, kada zatražite novu memoriju (koristeći `malloc`), alokator vam može dati **blok koji je oslobođen dva puta**. To može dovesti do toga da dva različita pokazivača pokazuju na istu lokaciju memorije. Ako napadač kontroliše jedan od tih pokazivača, može promeniti sadržaj te memorije, što može izazvati sigurnosne probleme ili im čak omogućiti izvršavanje koda.

Primer:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
U ovom primeru, nakon što se tcache popuni sa nekoliko oslobođenih blokova (7), kod **oslobađa blok `h`, zatim blok `i`, a zatim ponovo `h`, uzrokujući dvostruko oslobođavanje** (poznato i kao duplikat brzog bin-a). Ovo otvara mogućnost dobijanja preklapajućih memorijskih adresa prilikom ponovnog dodeljivanja, što znači da dva ili više pokazivača mogu pokazivati na istu memorijsku lokaciju. Manipulisanje podacima putem jednog pokazivača može zatim uticati na drugi, stvarajući kritičan sigurnosni rizik i potencijal za eksploataciju.

Izvršavajući to, primetite kako su **`i1` i `i2` dobili istu adresu**:

<pre><code>Početne alokacije:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Nakon ponovnih dodela:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Primeri

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Možemo alocirati samo blokove veličine Fast-Bin, osim za veličinu `0x70`, što sprečava uobičajeno prepisivanje `__malloc_hook`.
* Umesto toga, koristimo PIE adrese koje počinju sa `0x56` kao cilj za Fast Bin dup (1/2 šanse).
* Jedno mesto gde se čuvaju PIE adrese je u `main_arena`, koja je unutar Glibc-a i blizu `__malloc_hook`.
* Ciljamo određeno odstupanje `main_arena` da alociramo blok tamo i nastavimo sa alociranjem blokova dok ne stignemo do `__malloc_hook` kako bismo dobili izvršenje koda.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Koristeći Tcache binove i prelivanje nulama, možemo postići situaciju dvostrukog oslobođavanja:
* Alociramo tri bloka veličine `0x110` (`A`, `B`, `C`)
* Oslobađamo `B`
* Oslobađamo `A` i ponovo alociramo da bismo koristili prelivanje nulama
* Sada je veličina polja `B` `0x100`, umesto `0x111`, tako da ga možemo ponovo osloboditi
* Imamo jedan Tcache-bin veličine `0x110` i jedan veličine `0x100` koji pokazuju na istu adresu. Dakle, imamo dvostruko oslobođavanje.
* Iskorišćavamo dvostruko oslobođavanje koristeći [Tcache trovanje](tcache-bin-attack.md)

## Reference

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Naučite i vežbajte hakovanje AWS-a:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Naučite i vežbajte hakovanje GCP-a: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Podržite HackTricks</summary>

* Proverite [**planove pretplate**](https://github.com/sponsors/carlospolop)!
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili **telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite hakovanje trikova slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
{% endhint %}
