# Dupla Libera√ß√£o

{% hint style="success" %}
Aprenda e pratique Hacking AWS: <img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Verifique os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}

## Informa√ß√µes B√°sicas

Se voc√™ liberar um bloco de mem√≥ria mais de uma vez, pode bagun√ßar os dados do alocador e abrir portas para ataques. Veja como isso acontece: quando voc√™ libera um bloco de mem√≥ria, ele volta para uma lista de peda√ßos livres (por exemplo, o "fast bin"). Se voc√™ liberar o mesmo bloco duas vezes seguidas, o alocador detecta isso e gera um erro. Mas se voc√™ **liberar outro peda√ßo no meio, a verifica√ß√£o de dupla libera√ß√£o √© contornada**, causando corrup√ß√£o.

Agora, quando voc√™ solicita nova mem√≥ria (usando `malloc`), o alocador pode lhe dar um **bloco que foi liberado duas vezes**. Isso pode levar a dois ponteiros diferentes apontando para a mesma localiza√ß√£o de mem√≥ria. Se um atacante controlar um desses ponteiros, eles podem alterar o conte√∫do dessa mem√≥ria, o que pode causar problemas de seguran√ßa ou at√© permitir que executem c√≥digo.

Exemplo:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
Neste exemplo, ap√≥s preencher o tcache com v√°rios peda√ßos liberados (7), o c√≥digo **libera o peda√ßo `h`, depois o peda√ßo `i` e depois `h` novamente, causando uma dupla libera√ß√£o** (tamb√©m conhecida como Fast Bin dup). Isso abre a possibilidade de receber endere√ßos de mem√≥ria sobrepostos ao realocar, o que significa que dois ou mais ponteiros podem apontar para a mesma localiza√ß√£o de mem√≥ria. Manipular dados por meio de um ponteiro pode ent√£o afetar o outro, criando um risco de seguran√ßa cr√≠tico e potencial para explora√ß√£o.

Ao executar, observe como **`i1` e `i2` obtiveram o mesmo endere√ßo**:

<pre><code>Allocations iniciais:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Ap√≥s realoca√ß√µes:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Exemplos

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* S√≥ podemos alocar peda√ßos do tamanho de Fast Bin, exceto para o tamanho `0x70`, o que impede a substitui√ß√£o usual de `__malloc_hook`.
* Em vez disso, usamos endere√ßos PIE que come√ßam com `0x56` como alvo para Fast Bin dup (1/2 chance).
* Um local onde os endere√ßos PIE s√£o armazenados √© em `main_arena`, que est√° dentro do Glibc e pr√≥ximo a `__malloc_hook`.
* Visamos um deslocamento espec√≠fico de `main_arena` para alocar um peda√ßo l√° e continuar alocando peda√ßos at√© chegar a `__malloc_hook` para obter a execu√ß√£o de c√≥digo.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Usando Tcache bins e um estouro de byte nulo, podemos alcan√ßar uma situa√ß√£o de dupla libera√ß√£o:
* Alocamos tr√™s peda√ßos de tamanho `0x110` (`A`, `B`, `C`).
* Liberamos `B`.
* Liberamos `A` e alocamos novamente para usar o estouro de byte nulo.
* Agora o campo de tamanho de `B` √© `0x100`, em vez de `0x111`, ent√£o podemos liber√°-lo novamente.
* Temos um Tcache-bin de tamanho `0x110` e um de tamanho `0x100` que apontam para o mesmo endere√ßo. Portanto, temos uma dupla libera√ß√£o.
* Aproveitamos a dupla libera√ß√£o usando [Tcache poisoning](tcache-bin-attack.md)

## Refer√™ncias

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Aprenda e pratique Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Aprenda e pratique Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Suporte ao HackTricks</summary>

* Confira os [**planos de assinatura**](https://github.com/sponsors/carlospolop)!
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
{% endhint %}
