# Podwójne Zwolnienie

{% hint style="success" %}
Dowiedz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wesprzyj HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostępnij sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na githubie.

</details>
{% endhint %}

## Podstawowe Informacje

Jeśli zwolnisz blok pamięci więcej niż raz, może to zaburzyć dane alokatora i otworzyć drzwi do ataków. Oto jak to się dzieje: gdy zwalniasz blok pamięci, wraca on do listy wolnych fragmentów (np. "szybki blok"). Jeśli zwolnisz ten sam blok dwa razy z rzędu, alokator wykrywa to i zgłasza błąd. Ale jeśli **zwolnisz inny fragment pomiędzy nimi, sprawdzenie podwójnego zwolnienia jest obejścione**, co powoduje uszkodzenie.

Teraz, gdy prosisz o nową pamięć (używając `malloc`), alokator może dać ci **blok, który został zwolniony dwukrotnie**. Może to prowadzić do dwóch różnych wskaźników wskazujących na tę samą lokalizację pamięci. Jeśli atakujący kontroluje jeden z tych wskaźników, może zmienić zawartość tej pamięci, co może powodować problemy z bezpieczeństwem lub nawet umożliwić mu wykonanie kodu.

Przykład:
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
// Allocate memory for three chunks
char *a = (char *)malloc(10);
char *b = (char *)malloc(10);
char *c = (char *)malloc(10);
char *d = (char *)malloc(10);
char *e = (char *)malloc(10);
char *f = (char *)malloc(10);
char *g = (char *)malloc(10);
char *h = (char *)malloc(10);
char *i = (char *)malloc(10);

// Print initial memory addresses
printf("Initial allocations:\n");
printf("a: %p\n", (void *)a);
printf("b: %p\n", (void *)b);
printf("c: %p\n", (void *)c);
printf("d: %p\n", (void *)d);
printf("e: %p\n", (void *)e);
printf("f: %p\n", (void *)f);
printf("g: %p\n", (void *)g);
printf("h: %p\n", (void *)h);
printf("i: %p\n", (void *)i);

// Fill tcache
free(a);
free(b);
free(c);
free(d);
free(e);
free(f);
free(g);

// Introduce double-free vulnerability in fast bin
free(h);
free(i);
free(h);


// Reallocate memory and print the addresses
char *a1 = (char *)malloc(10);
char *b1 = (char *)malloc(10);
char *c1 = (char *)malloc(10);
char *d1 = (char *)malloc(10);
char *e1 = (char *)malloc(10);
char *f1 = (char *)malloc(10);
char *g1 = (char *)malloc(10);
char *h1 = (char *)malloc(10);
char *i1 = (char *)malloc(10);
char *i2 = (char *)malloc(10);

// Print initial memory addresses
printf("After reallocations:\n");
printf("a1: %p\n", (void *)a1);
printf("b1: %p\n", (void *)b1);
printf("c1: %p\n", (void *)c1);
printf("d1: %p\n", (void *)d1);
printf("e1: %p\n", (void *)e1);
printf("f1: %p\n", (void *)f1);
printf("g1: %p\n", (void *)g1);
printf("h1: %p\n", (void *)h1);
printf("i1: %p\n", (void *)i1);
printf("i2: %p\n", (void *)i1);

return 0;
}
```
W tym przykładzie, po zapełnieniu tcache kilkoma zwolnionymi kawałkami (7), kod **zwalnia kawałek `h`, następnie kawałek `i`, a następnie ponownie `h`, powodując podwójne zwolnienie** (znane również jako duplikat Fast Bin). Otwiera to możliwość otrzymywania nakładających się adresów pamięci podczas ponownego przydziału, co oznacza, że dwa lub więcej wskaźników mogą wskazywać na ten sam obszar pamięci. Manipulowanie danymi za pomocą jednego wskaźnika może wpłynąć na drugi, tworząc poważne ryzyko bezpieczeństwa i potencjał do eksploatacji.

Wykonując to, zauważ, jak **`i1` i `i2` otrzymały ten sam adres**:

<pre><code>Alokacje początkowe:
a: 0xaaab0f0c22a0
b: 0xaaab0f0c22c0
c: 0xaaab0f0c22e0
d: 0xaaab0f0c2300
e: 0xaaab0f0c2320
f: 0xaaab0f0c2340
g: 0xaaab0f0c2360
h: 0xaaab0f0c2380
i: 0xaaab0f0c23a0
Po ponownych przydziałach:
a1: 0xaaab0f0c2360
b1: 0xaaab0f0c2340
c1: 0xaaab0f0c2320
d1: 0xaaab0f0c2300
e1: 0xaaab0f0c22e0
f1: 0xaaab0f0c22c0
g1: 0xaaab0f0c22a0
h1: 0xaaab0f0c2380
<strong>i1: 0xaaab0f0c23a0
</strong><strong>i2: 0xaaab0f0c23a0
</strong></code></pre>

## Przykłady

* [**Dragon Army. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/dragon-army/)
* Możemy tylko alokować kawałki o rozmiarze Fast-Bin, z wyjątkiem rozmiaru `0x70`, co uniemożliwia standardowe nadpisanie `__malloc_hook`.
* Zamiast tego używamy adresów PIE zaczynających się od `0x56` jako cel dla Fast Bin dup (1/2 szansy).
* Jednym miejscem, gdzie przechowywane są adresy PIE, jest `main_arena`, która znajduje się wewnątrz Glibc i w pobliżu `__malloc_hook`.
* Celujemy w określony offset `main_arena`, aby zaalokować tam kawałek i kontynuować alokowanie kawałków, aż dotrzemy do `__malloc_hook`, aby uzyskać wykonanie kodu.
* [**zero_to_hero. PicoCTF**](https://7rocky.github.io/en/ctf/picoctf/binary-exploitation/zero_to_hero/)
* Korzystając z pojemników Tcache i przepełnienia bajtu zerowego, możemy osiągnąć sytuację podwójnego zwolnienia:
* Alokujemy trzy kawałki o rozmiarze `0x110` (`A`, `B`, `C`)
* Zwolniamy `B`
* Zwolniamy `A` i ponownie alokujemy, aby skorzystać z przepełnienia bajtu zerowego
* Teraz pole rozmiaru `B` to `0x100`, zamiast `0x111`, więc możemy ponownie go zwolnić
* Mamy jeden pojemnik Tcache o rozmiarze `0x110` i jeden o rozmiarze `0x100`, które wskazują na ten sam adres. Mamy więc podwójne zwolnienie.
* Wykorzystujemy podwójne zwolnienie za pomocą [zatruwania Tcache](tcache-bin-attack.md)

## Odnośniki

* [https://heap-exploitation.dhavalkapil.com/attacks/double\_free](https://heap-exploitation.dhavalkapil.com/attacks/double\_free)

{% hint style="success" %}
Dowiedz się i ćwicz Hacking AWS:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Dowiedz się i ćwicz Hacking GCP: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Wsparcie dla HackTricks</summary>

* Sprawdź [**plany subskrypcyjne**](https://github.com/sponsors/carlospolop)!
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Udostępniaj sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
{% endhint %}
