# Desbordamiento por uno

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Equipos Rojos de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci칩n B치sica

Tener acceso solo a un desbordamiento por 1 byte permite a un atacante modificar el bit `pre_in_use` del siguiente chunk y como el chunk actual no estar치 en uso, el final del chunk se convierte en la informaci칩n de metadatos del tama침o del chunk anterior.\
Esto permite manipular qu칠 chunks se liberan realmente, potencialmente generando un chunk que contiene otro chunk leg칤timo.

Existen 2 tipos de vulnerabilidades de desbordamiento por uno:

* Byte arbitrario: Permite sobrescribir ese byte con cualquier valor
* Null off by one: Permite sobrescribir ese byte solo con 0x00
* Un ejemplo com칰n de esta vulnerabilidad se puede ver en el siguiente c칩digo donde el comportamiento de strlen y strcpy es inconsistente, lo que permite establecer un byte 0x00 al principio del siguiente chunk.

<details>

<summary>Null off by one</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre otras comprobaciones, ahora cada vez que se libera un fragmento, se compara el tama침o anterior con el tama침o configurado en los metadatos del fragmento, lo que hace que este ataque sea bastante complejo a partir de la versi칩n 2.28.

### Ejemplo de c칩digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque ya no funciona debido al uso de Tcaches.
* Adem치s, si intentas abusar de 칠l usando fragmentos m치s grandes (para que no intervengan las tcaches), obtendr치s el error: `malloc(): invalid next size (unsorted)`

### Objetivo

* Hacer que un fragmento est칠 contenido dentro de otro fragmento para que al tener acceso de escritura sobre ese segundo fragmento se pueda sobrescribir el contenido del fragmento contenido.

### Requisitos

* Desbordamiento de un byte para modificar la informaci칩n de metadatos del tama침o anterior.

### Ataque

* Se reservan 3 fragmentos de memoria (a, b, c) uno tras otro. Luego se libera el del medio. El primero contiene una vulnerabilidad de desbordamiento de un byte y el atacante la abusa con un 0x00 (si el byte anterior era 0x10, har칤a que el fragmento del medio indicara que es 0x10 m치s peque침o de lo que realmente es).
* Luego, se asignan 2 fragmentos m치s peque침os en el fragmento liberado del medio (b), sin embargo, como `b + b->size` nunca actualiza el fragmento c porque la direcci칩n apuntada es m치s peque침a de lo que deber칤a ser.
* Luego, b1 y c se liberan. Como `c - c->prev_size` todav칤a apunta a b (ahora b1), ambos se consolidan en un solo fragmento. Sin embargo, b2 todav칤a est치 dentro, entre b1 y c.
* Finalmente, se realiza un nuevo malloc reclamando esta 치rea de memoria que en realidad va a contener b2, lo que permite al propietario del nuevo malloc controlar el contenido de b2.

Esta imagen explica perfectamente el ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Otros Ejemplos y Referencias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es posible abusar de un desbordamiento de un byte para filtrar una direcci칩n de la heap porque el byte 0x00 del final de una cadena es sobrescrito por el siguiente campo.
* La escritura arbitraria se obtiene abusando del desbordamiento de un byte para hacer que el puntero apunte a otro lugar donde se construir치 una estructura falsa con punteros falsos. Luego, es posible seguir el puntero de esta estructura para obtener escritura arbitraria.
* La direcci칩n de libc se filtra porque si la heap se extiende usando mmap, la memoria asignada por mmap tiene un desplazamiento fijo desde libc.
* Finalmente, se abusa de la escritura arbitraria para escribir en la direcci칩n de \_\_free\_hook con una direcci칩n de `one_gadget`.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Hay una vulnerabilidad de desbordamiento de un byte NULL en la funci칩n `getline` que lee l칤neas de entrada de usuario. Esta funci칩n se utiliza para leer la "clave" del contenido y no el contenido.
