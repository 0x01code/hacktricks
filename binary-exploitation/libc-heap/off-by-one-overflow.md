# Prekoračenje za jedan bajt

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Imajući pristup samo prekoračenju za jedan bajt, napadaču je omogućeno da izmeni polje `size` sledećeg bloka. Ovo omogućava manipulaciju sa blokovima koji su zapravo oslobođeni, potencijalno generišući blok koji sadrži drugi legitimni blok. Eksploatacija je slična [dvostrukom oslobođavanju](double-free.md) ili preklapanju blokova.

Postoje 2 vrste ranjivosti prekoračenja za jedan bajt:

* Proizvoljan bajt: Ova vrsta omogućava prepisivanje tog bajta sa bilo kojom vrednošću
* Nula bajt (off-by-null): Ova vrsta omogućava prepisivanje tog bajta samo sa 0x00
* Čest primer ove ranjivosti može se videti u sledećem kodu gde je ponašanje `strlen` i `strcpy` nekonzistentno, što omogućava postavljanje bajta 0x00 na početku sledećeg bloka.
* Ovo se može iskoristiti sa [House of Einherjar](house-of-einherjar.md).
* Ako se koristi Tcache, ovo se može iskoristiti u situaciju [dvostrukog oslobođavanja](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Među ostalim proverama, sada kada je komad slobodan, prethodna veličina se upoređuje sa veličinom konfigurisanom u metapodacima komada, čineći ovaj napad prilično složenim od verzije 2.28.

### Primer koda:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ovaj napad više ne funkcioniše zbog korišćenja Tcache-ova.
* Štaviše, ako pokušate da ga zloupotrebite koristeći veće komade (tako da Tcache-ovi nisu uključeni), dobićete grešku: `malloc(): invalid next size (unsorted)`

### Cilj

* Da se komad nalazi unutar drugog komada, tako da pisanje pristupa preko tog drugog komada omogućava prepisivanje sadržaja sadržanog komada

### Zahtevi

* Prekoračenje za jedan bajt da se izmeni informacija o metapodacima veličine

### Opšti napad off-by-one

* Alocirajte tri komada `A`, `B` i `C` (recimo veličine 0x20), i još jedan da spreči konsolidaciju sa vršnim komadom.
* Oslobodite `C` (ubacen u 0x20 Tcache listu slobodnih komada).
* Koristite komad `A` da prekoračite na `B`. Zloupotrebite off-by-one da izmenite polje `size` od `B` sa 0x21 na 0x41.
* Sada imamo `B` koji sadrži slobodan komad `C`
* Oslobodite `B` i alocirajte 0x40 komad (biće ponovo postavljen ovde)
* Možemo izmeniti pokazivač `fd` od `C`, koji je i dalje slobodan (Tcache trovanje)

### Off-by-null napad

* Rezervišite 3 komada memorije (a, b, c) jedan za drugim. Zatim se oslobađa srednji komad. Prvi komad sadrži ranjivost prekoračenja za jedan bajt i napadač je zloupotrebljava sa 0x00 (ako je prethodni bajt bio 0x10, to bi navelo srednji komad da pokaže da je 0x10 manji nego što zaista jeste).
* Zatim, još 2 manja komada se alociraju u srednjem oslobođenom komadu (b), međutim, pošto `b + b->size` nikada ne ažurira c komad jer je pokazana adresa manja nego što bi trebalo.
* Zatim se b1 i c oslobađaju. Pošto `c - c->prev_size` i dalje pokazuje na b (sada b1), oba se konsoliduju u jedan komad. Međutim, b2 je i dalje unutar između b1 i c.
* Na kraju, vrši se nova alokacija memorije koja će zapravo sadržati b2, omogućavajući vlasniku nove alokacije da kontroliše sadržaj b2.

Ova slika savršeno objašnjava napad:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Ostali primeri i reference

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one zbog `strlen` koji uzima u obzir polje `size` sledećeg komada.
* Tcache se koristi, pa opšti off-by-one napadi funkcionišu kako bi se dobio proizvoljni zapis sa Tcache trovanjem.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Moguće je zloupotrebiti off-by-one da bi se procurela adresa iz hipa jer bajt 0x00 na kraju stringa biva prepisan sledećim poljem.
* Proizvoljni zapis se dobija zloupotrebom off-by-one zapisa da bi se pokazivač usmerio na drugo mesto gde će biti izgrađena lažna struktura sa lažnim pokazivačima. Zatim je moguće pratiti pokazivač ove strukture da bi se dobio proizvoljni zapis.
* Adresa libc-a procuri jer ako se hip proširi korišćenjem mmap, memorija alocirana pomoću mmap ima fiksni odmak od libc-a.
* Na kraju se zloupotrebljava proizvoljni zapis da bi se upisalo na adresu \_\_free\_hook sa jednim gedžetom.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Postoji NULL off-by-one ranjivost u funkciji `getline` koja čita linije korisničkog unosa. Ova funkcija se koristi za čitanje "ključa" sadržaja, a ne samog sadržaja.
* U objašnjenju se stvara 5 početnih komada:
* komad1 (0x200)
* komad2  (0x50)
* komad5 (0x68)
* komad3 (0x1f8)
* komad4 (0xf0)
* komad odbrane (0x400) da bi se izbegla konsolidacija sa vršnim komadom
* Zatim se oslobađuju komadi 1, 5 i 3, tako da:
* ```python
[ 0x200 Komad 1 (slobodan) ] [ 0x50 Komad 2 ] [ 0x68 Komad 5 (slobodan) ] [ 0x1f8 Komad 3 (slobodan) ] [ 0xf0 Komad 4 ] [ 0x400 Komad odbrane ]
```
* Zatim se zloupotrebljava komad3 (0x1f8) null off-by-one zapisom prev\_size na `0x4e0`.
* Primetite kako veličine početno alociranih komada1, 2, 5 i 3 plus zaglavlja 4 tih komada iznose `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Zatim se oslobađuje komad 4, generišući komad koji troši sve komade do početka:
* ```python
[ 0x4e0 Komad 1-2-5-3 (slobodan) ] [ 0xf0 Komad 4 (korumpiran) ] [ 0x400 Komad odbrane ]
```
* ```python
[ 0x200 Komad 1 (slobodan) ] [ 0x50 Komad 2 ] [ 0x68 Komad 5 (slobodan) ] [ 0x1f8 Komad 3 (slobodan) ] [ 0xf0 Komad 4 ] [ 0x400 Komad odbrane ]
```
* Zatim se alocira `0x200` bajtova popunjavajući originalni komad 1
* I alocira se još 0x200 bajtova i uništava se komad2 i stoga nema curenja i ovo ne funkcioniše? Možda ovo ne bi trebalo da se uradi
* Zatim se alocira još jedan komad sa 0x58 "a" (prepisujući komad2 i dosežući komad5) i menja se `fd` brze binarne grupe komada komada5 usmeravajući ga ka `__malloc_hook`
* Zatim se alocira komad od 0x68 tako da je lažni brzi binarni komad u `__malloc_hook` sledeći brzi binarni komad
* Na kraju, alocira se novi brzi binarni komad od 0x68 i `__malloc_hook` se prepisuje sa adresom `one_gadget`
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repozitorijume.**
