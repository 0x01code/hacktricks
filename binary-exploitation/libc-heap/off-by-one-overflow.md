# Off-by-one-√úberlauf

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Wenn ein Angreifer nur Zugriff auf einen 1B-√úberlauf hat, kann er das `size`-Feld des n√§chsten Chunks √§ndern. Dies erm√∂glicht es, welche Chunks tats√§chlich freigegeben werden, zu manipulieren und potenziell einen Chunk zu erzeugen, der einen anderen legitimen Chunk enth√§lt. Die Ausnutzung √§hnelt dem [doppelten Freigeben](double-free.md) oder √ºberlappenden Chunks.

Es gibt 2 Arten von Off-by-One-Schwachstellen:

* Beliebiges Byte: Diese Art erm√∂glicht das √úberschreiben dieses Bytes mit einem beliebigen Wert.
* Nullbyte (Off-by-Null): Diese Art erm√∂glicht es nur, dieses Byte mit 0x00 zu √ºberschreiben.
* Ein h√§ufiges Beispiel f√ºr diese Schwachstelle ist im folgenden Code zu sehen, in dem das Verhalten von `strlen` und `strcpy` inkonsistent ist, was es erm√∂glicht, ein 0x00-Byte am Anfang des n√§chsten Chunks zu setzen.
* Dies kann mit dem [House of Einherjar](house-of-einherjar.md) ausgenutzt werden.
* Wenn Tcache verwendet wird, kann dies zu einer [doppelten Freigabe](double-free.md) f√ºhren.

<details>

<summary>Off-by-Null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Unter anderem wird nun bei jedem Freigeben eines Chunks die vorherige Gr√∂√üe mit der in den Metadaten des Chunks konfigurierten Gr√∂√üe verglichen, was diesen Angriff ab Version 2.28 ziemlich komplex macht.

### Codebeispiel:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Dieser Angriff funktioniert nicht mehr aufgrund der Verwendung von Tcaches.
* Dar√ºber hinaus erhalten Sie einen Fehler, wenn Sie versuchen, ihn mit gr√∂√üeren Chunks zu missbrauchen (damit Tcaches nicht involviert sind): `malloc(): invalid next size (unsorted)`

### Ziel

* Einen Chunk in einem anderen Chunk enthalten, sodass Schreibzugriff auf diesen zweiten Chunk es erm√∂glicht, den enthaltenen zu √ºberschreiben

### Anforderungen

* Off-by-one-√úberlauf, um die Gr√∂√üenmetadateninformationen zu √§ndern

### Allgemeiner Off-by-One-Angriff

* Reservieren Sie drei Chunks `A`, `B` und `C` (sagen wir Gr√∂√üen 0x20) und einen weiteren, um die Konsolidierung mit dem Top-Chunk zu verhindern.
* Geben Sie `C` frei (eingef√ºgt in die 0x20 Tcache-Freiliste).
* Verwenden Sie Chunk `A`, um auf `B` zu √ºberlaufen. Missbrauchen Sie das Off-by-One, um das `size`-Feld von `B` von 0x21 auf 0x41 zu √§ndern.
* Jetzt haben wir `B`, das den freien Chunk `C` enth√§lt
* Geben Sie `B` frei und reservieren Sie einen 0x40 Chunk (er wird hier erneut platziert)
* Wir k√∂nnen den `fd`-Zeiger von `C` √§ndern, der immer noch frei ist (Tcache-Vergiftung)

### Off-by-Null-Angriff

* 3 Speicherbl√∂cke (a, b, c) werden nacheinander reserviert. Dann wird der mittlere Block freigegeben. Der erste enth√§lt eine Off-by-One-√úberlaufschwachstelle, die vom Angreifer mit einer 0x00 ausgenutzt wird (wenn das vorherige Byte 0x10 war, w√ºrde der mittlere Block anzeigen, dass er 0x10 kleiner ist als er wirklich ist).
* Dann werden 2 kleinere Bl√∂cke im mittleren freigegebenen Block (b) reserviert, jedoch wird `b + b->size` nie den c-Block aktualisieren, da die adressierte Adresse kleiner ist als sie sein sollte.
* Dann werden b1 und c freigegeben. Da `c - c->prev_size` immer noch auf b zeigt (jetzt b1), werden beide in einem Block konsolidiert. B2 befindet sich jedoch immer noch zwischen b1 und c.
* Schlie√ülich wird ein neuer malloc durchgef√ºhrt, der diesen Speicherbereich zur√ºckfordert, der tats√§chlich b2 enthalten wird, was es dem Besitzer des neuen malloc erm√∂glicht, den Inhalt von b2 zu steuern.

Dieses Bild erkl√§rt den Angriff perfekt:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Weitere Beispiele & Referenzen

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one aufgrund von `strlen`, das das `size`-Feld des n√§chsten Chunks ber√ºcksichtigt.
* Tcache wird verwendet, daher funktionieren allgemeine Off-by-One-Angriffe, um eine beliebige Schreibprimitive mit Tcache-Vergiftung zu erhalten.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es ist m√∂glich, ein Off-by-One auszunutzen, um eine Adresse aus dem Heap auszulesen, da das Byte 0x00 am Ende einer Zeichenfolge vom n√§chsten Feld √ºberschrieben wird.
* Durch Ausnutzen des Off-by-One-Schreibens wird eine beliebige Schreibweise erlangt, um den Zeiger auf einen anderen Ort zu setzen, an dem eine gef√§lschte Struktur mit gef√§lschten Zeigern erstellt wird. Dann ist es m√∂glich, dem Zeiger dieser Struktur zu folgen, um eine beliebige Schreibweise zu erhalten.
* Die libc-Adresse wird durch Ausnutzen des beliebigen Schreibens geleakt, da der Heap durch mmap erweitert wird und der von mmap allokierte Speicher einen festen Offset von libc hat.
* Schlie√ülich wird das beliebige Schreiben missbraucht, um in die Adresse von \_\_free\_hook mit einem One-Gadget zu schreiben.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Es gibt eine NULL Off-by-One-Schwachstelle in der `getline`-Funktion, die Benutzereingabezeilen liest. Diese Funktion wird verwendet, um den "Schl√ºssel" des Inhalts zu lesen und nicht den Inhalt.
* **Teilen Sie Ihre Hacking-Tricks, indem Sie Pull Requests an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories senden.**
