# Przepełnienie o jeden

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Podstawowe informacje

Mając dostęp tylko do przepełnienia o jeden bajt, atakujący może zmodyfikować pole `size` z następnego fragmentu. Pozwala to manipulować, które fragmenty są faktycznie zwalniane, potencjalnie generując fragment zawierający inny prawidłowy fragment. Wykorzystanie jest podobne do [podwójnego zwalniania pamięci](double-free.md) lub nakładających się fragmentów.

Istnieją 2 rodzaje podatności na przepełnienie o jeden:

* Dowolny bajt: Ten rodzaj pozwala nadpisać ten bajt dowolną wartością
* Bajt zerowy (off-by-null): Ten rodzaj pozwala nadpisać ten bajt tylko wartością 0x00
* Przykładem takiej podatności może być poniższy kod, w którym zachowanie funkcji `strlen` i `strcpy` jest niekonsekwentne, co pozwala na ustawienie bajtu 0x00 na początku następnego fragmentu.
* Można to wykorzystać za pomocą [House of Einherjar](house-of-einherjar.md).
* Jeśli używany jest Tcache, można to wykorzystać do sytuacji [podwójnego zwalniania pamięci](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Wśród innych sprawdzeń, teraz za każdym razem, gdy kawałek jest zwalniany, rozmiar poprzedni jest porównywany z rozmiarem skonfigurowanym w metadanych kawałka, co sprawia, że ten atak jest dość skomplikowany od wersji 2.28.

### Przykład kodu:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ten atak już nie działa ze względu na użycie Tcaches.
* Ponadto, jeśli spróbujesz go wykorzystać, używając większych kawałków (aby tcaches nie były zaangażowane), otrzymasz błąd: `malloc(): invalid next size (unsorted)`

### Cel

* Umieść kawałek wewnątrz innego kawałka, dzięki czemu dostęp do zapisu na ten drugi kawałek pozwala nadpisać zawarty w nim kawałek

### Wymagania

* Przepełnienie o jeden, aby zmodyfikować informacje o metadanych rozmiaru

### Ogólny atak off-by-one

* Zaalokuj trzy kawałki `A`, `B` i `C` (powiedzmy rozmiary 0x20), oraz kolejny, aby zapobiec konsolidacji z kawałkiem górnym.
* Zwolnij `C` (wstawiony do listy wolnych Tcache 0x20).
* Użyj kawałka `A`, aby przepełnić `B`. Wykorzystaj off-by-one, aby zmodyfikować pole `size` `B` z 0x21 na 0x41.
* Teraz mamy `B` zawierający wolny kawałek `C`
* Zwolnij `B` i zaalokuj kawałek 0x40 (zostanie tu ponownie umieszczony)
* Możemy zmodyfikować wskaźnik `fd` z `C`, który nadal jest wolny (zatrucie Tcache)

### Atak off-by-null

* Rezerwuje się 3 kawałki pamięci (a, b, c) jeden po drugim. Następnie środkowy jest zwalniany. Pierwszy zawiera podatność na przepełnienie o jeden, a atakujący ją z wykorzystaniem 0x00 (jeśli poprzedni bajt był 0x10, sprawi, że środkowy kawałek wskaże, że jest o 0x10 mniejszy, niż w rzeczywistości jest).
* Następnie, w środku zwolnionego kawałka (b) zaalokowano 2 mniejsze kawałki, jednakże, ponieważ `b + b->size` nigdy nie aktualizuje kawałka c, ponieważ adres wskazywany jest mniejszy, niż powinien.
* Następnie, b1 i c są zwalniane. Ponieważ `c - c->prev_size` wciąż wskazuje na b (teraz b1), oba są konsolidowane w jeden kawałek. Jednakże, b2 nadal znajduje się wewnątrz pomiędzy b1 i c.
* W końcu, wykonywane jest nowe przydział pamięci malloc, odzyskując ten obszar pamięci, który faktycznie będzie zawierał b2, pozwalając właścicielowi nowego malloc kontrolować zawartość b2.

To zdjęcie doskonale wyjaśnia atak:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Inne Przykłady & Referencje

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one z powodu `strlen` uwzględniającego pole `size` następnego kawałka.
* Używany jest Tcache, więc ogólne ataki off-by-one działają, aby uzyskać arbitralne pisanie zatruciem Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Możliwe jest wykorzystanie off-by-one do wycieku adresu z heap, ponieważ bajt 0x00 na końcu łańcucha znaków jest nadpisywany przez następne pole.
* Pisanie arbitralne jest uzyskiwane poprzez nadużycie off-by-one write, aby wskaźnik wskazywał na inne miejsce, gdzie zostanie zbudowana fałszywa struktura z fałszywymi wskaźnikami. Następnie możliwe jest śledzenie wskaźnika tej struktury, aby uzyskać arbitralne pisanie.
* Adres libc jest wyciekany, ponieważ jeśli sterta jest rozszerzana za pomocą mmap, pamięć zaalokowana przez mmap ma stały przesunięcie od libc.
* W końcu, nadużywane jest arbitralne pisanie, aby zapisać w adresie \_\_free\_hook z adresem one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Istnieje podatność NULL off-by-one w funkcji `getline`, która czyta linie wejściowe użytkownika. Ta funkcja służy do odczytywania "klucza" zawartości, a nie samej zawartości.
* W opisie 5 początkowych kawałków jest tworzonych:
* kawałek1 (0x200)
* kawałek2  (0x50)
* kawałek5 (0x68)
* kawałek3 (0x1f8)
* kawałek4 (0xf0)
* obrona kawałka (0x400) aby uniknąć konsolidacji z kawałkiem górnym
* Następnie kawałki 1, 5 i 3 są zwalniane, więc:
* ```python
[ 0x200 Kawałek 1 (wolny) ] [ 0x50 Kawałek 2 ] [ 0x68 Kawałek 5 (wolny) ] [ 0x1f8 Kawałek 3 (wolny) ] [ 0xf0 Kawałek 4 ] [ 0x400 Kawałek obrony ]
```
* Następnie nadużywając kawałka3 (0x1f8) wykorzystuje się null off-by-one, zapisując prev\_size na `0x4e0`.
* Zauważ, jak rozmiary początkowo zaalokowanych kawałków1, 2, 5 i 3 plus nagłówki 4 z tych kawałków równają się `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Następnie, kawałek 4 jest zwalniany, generując kawałek, który zużywa wszystkie kawałki aż do początku:
* ```python
[ 0x4e0 Kawałek 1-2-5-3 (wolny) ] [ 0xf0 Kawałek 4 (zepsuty) ] [ 0x400 Kawałek obrony ]
```
* ```python
[ 0x200 Kawałek 1 (wolny) ] [ 0x50 Kawałek 2 ] [ 0x68 Kawałek 5 (wolny) ] [ 0x1f8 Kawałek 3 (wolny) ] [ 0xf0 Kawałek 4 ] [ 0x400 Kawałek obrony ]
```
* Następnie, zaalokowane są `0x200` bajtów wypełniając oryginalny kawałek 1
* I zaalokowane są kolejne 0x200 bajtów i kawałek2 jest zniszczony i dlatego nie ma żadnego wycieku i to nie działa? Być może tego nie powinno się robić
* Następnie, zaalokowano inny kawałek z 0x58 "a" (nadpisując kawałek2 i docierając do kawałka5) i zmodyfikowano `fd` kawałka fast bin kawałka kawałka5 wskazując go na `__malloc_hook`
* Następnie, zaalokowano kawałek o rozmiarze 0x68, więc fałszywy kawałek fast bin w `__malloc_hook` jest następnym kawałkiem fast bin
* W końcu, zaalokowano nowy kawałek fast bin o rozmiarze 0x68 i `__malloc_hook` jest nadpisany adresem `one_gadget`
* **Udostępnij swoje sztuczki hakerskie, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **na githubie.**
