# Off-by-one-√úberlauf

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Grundlegende Informationen

Wenn ein Angreifer nur Zugriff auf einen 1B-√úberlauf hat, kann er das `pre_in_use`-Bit des n√§chsten Chunks √§ndern, und da der aktuelle Chunk nicht verwendet wird, wird das Ende des Chunks zu den Metadateninformationen der vorherigen Chunkgr√∂√üe.\
Dies erm√∂glicht es, zu manipulieren, welche Chunks tats√§chlich freigegeben werden, und potenziell einen Chunk zu erzeugen, der einen anderen legitimen Chunk enth√§lt.

Es gibt 2 Arten von Off-by-One-Schwachstellen:

* Beliebiges Byte: Diese Art erm√∂glicht das √úberschreiben dieses Bytes mit einem beliebigen Wert.
* Null-Off-by-One: Diese Art erm√∂glicht das √úberschreiben dieses Bytes nur mit 0x00.
* Ein h√§ufiges Beispiel f√ºr diese Schwachstelle ist im folgenden Code zu sehen, wo das Verhalten von strlen und strcpy inkonsistent ist, was es erm√∂glicht, ein 0x00-Byte am Anfang des n√§chsten Chunks zu setzen.

<details>

<summary>Null-Off-by-One</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Unter anderem wird jetzt bei jedem Freigeben eines Chunks die vorherige Gr√∂√üe mit der in den Metadaten des Chunks konfigurierten Gr√∂√üe verglichen, was diesen Angriff ab Version 2.28 ziemlich komplex macht.

### Codebeispiel:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Dieser Angriff funktioniert nicht mehr aufgrund der Verwendung von Tcaches.
* Dar√ºber hinaus erhalten Sie einen Fehler, wenn Sie versuchen, ihn mit gr√∂√üeren Chunks zu missbrauchen (damit Tcaches nicht involviert sind): `malloc(): invalid next size (unsorted)`

### Ziel

* Einen Chunk in einem anderen Chunk enthalten lassen, sodass Schreibzugriff auf diesen zweiten Chunk es erm√∂glicht, den enthaltenen zu √ºberschreiben

### Anforderungen

* Off-by-One-√úberlauf, um die vorherigen Gr√∂√üenmetadateninformationen zu √§ndern

### Angriff

* 3 Speicherbl√∂cke (a, b, c) werden nacheinander reserviert. Dann wird der mittlere Block freigegeben. Der erste enth√§lt eine Off-by-One-√úberlauf-Schwachstelle, die vom Angreifer mit einer 0x00 ausgenutzt wird (wenn das vorherige Byte 0x10 war, w√ºrde der mittlere Block anzeigen, dass er um 0x10 kleiner ist als er wirklich ist).
* Dann werden 2 kleinere Bl√∂cke im mittleren freigegebenen Block (b) allokiert, jedoch wird `b + b->size` nie den c-Block aktualisieren, da die adressierte Adresse kleiner ist als sie sein sollte.
* Dann werden b1 und c freigegeben. Da `c - c->prev_size` immer noch auf b zeigt (jetzt b1), werden beide in einem Block konsolidiert. Allerdings befindet sich b2 immer noch zwischen b1 und c.
* Schlie√ülich wird ein neues malloc durchgef√ºhrt, um diesen Speicherbereich zur√ºckzugewinnen, der tats√§chlich b2 enthalten wird, was es dem Besitzer des neuen malloc erm√∂glicht, den Inhalt von b2 zu steuern.

Dieses Bild erkl√§rt den Angriff perfekt:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Weitere Beispiele & Referenzen

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Es ist m√∂glich, einen Off-by-One zu missbrauchen, um eine Adresse aus dem Heap auszulesen, da das Byte 0x00 am Ende eines Strings vom n√§chsten Feld √ºberschrieben wird.
* Ein beliebiges Schreiben wird durch den Missbrauch des Off-by-One-Schreibens erreicht, um den Zeiger auf einen anderen Ort zu setzen, an dem eine gef√§lschte Struktur mit gef√§lschten Zeigern erstellt wird. Dann ist es m√∂glich, dem Zeiger dieser Struktur zu folgen, um ein beliebiges Schreiben zu erhalten.
* Die libc-Adresse wird preisgegeben, weil, wenn der Heap mit mmap erweitert wird, der von mmap allokierte Speicher einen festen Offset von libc hat.
* Schlie√ülich wird das beliebige Schreiben missbraucht, um in die Adresse von \_\_free\_hook mit einem One-Gadget zu schreiben.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Es gibt eine NULL Off-by-One-Schwachstelle in der `getline`-Funktion, die Benutzereingabezeilen liest. Diese Funktion wird verwendet, um den "Schl√ºssel" des Inhalts zu lesen und nicht den Inhalt.
