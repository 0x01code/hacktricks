# Kujaza kwa kosa moja

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

Kwa kupata tu kujaza kwa 1B, mshambuliaji anaweza kubadilisha uga wa `size` kutoka kwa kikundi kinachofuata. Hii inaruhusu kuharibu ni vikundi vipi vilivyofutwa kwa kweli, ikisababisha uundaji wa kikundi kinachojumuisha kikundi kingine halali. Udukuzi huu ni sawa na [kufutwa mara mbili](double-free.md) au vikundi vinavyopishana.

Kuna aina 2 za udhaifu wa kujaza kwa kosa moja:

* Bayti isiyo na kikomo: Aina hii inaruhusu kubadilisha bayti hiyo na thamani yoyote
* Bayti ya Null (kosa la null): Aina hii inaruhusu kubadilisha bayti hiyo tu na 0x00
* Mfano wa kawaida wa udhaifu huu unaweza kuonekana kwenye nambari ifuatayo ambapo tabia ya `strlen` na `strcpy` ni tofauti, ambayo inaruhusu kuweka bayti ya 0x00 mwanzoni mwa kikundi kinachofuata.
* Hii inaweza kudukuliwa na [House of Einherjar](house-of-einherjar.md).
* Ikiwa unatumia Tcache, hii inaweza kutumika kwa hali ya [kufutwa mara mbili](double-free.md). 

<details>

<summary>Kujaza kwa kosa la Null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Miongoni mwa ukaguzi mwingine, sasa wakati kipande kinaachiliwa, ukubwa wa awali unalinganishwa na ukubwa uliowekwa katika metadata ya kipande, hii inafanya shambulio hili kuwa ngumu kutoka toleo la 2.28.

### Mfano wa Kanuni:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Shambulio hili halifanyi kazi tena kutokana na matumizi ya Tcaches.
* Zaidi ya hayo, ukijaribu kulitumia kwa kutumia vipande vikubwa (hivyo tcaches havihusiki), utapata kosa: `malloc(): invalid next size (unsorted)`

### Lengo

* Fanya kipande kiwe kimejumuishwa ndani ya kipande kingine ili upate ufikiaji wa kuandika juu ya kipande cha pili kuruhusu kubadilisha kile kilichomo

### Mahitaji

* Kuvuja kwa kipande kimoja ili kubadilisha habari ya metadata ya ukubwa

### Shambulio la kawaida la off-by-one

* Tenga vipande vitatu `A`, `B` na `C` (semakipimo 0x20), na kingine kuzuia kujumuishwa na kipande cha juu.
* Acha huru `C` (imeingizwa kwenye orodha ya Tcache ya 0x20).
* Tumia kipande `A` kumwaga kwenye `B`. Tumia off-by-one kubadilisha uga wa `ukubwa` wa `B` kutoka 0x21 hadi 0x41.
* Sasa tuna `B` inayomiliki kipande huru `C`
* Acha huru `B` na tenganisha kipande cha 0x40 (kitawekwa hapa tena)
* Tunaweza kubadilisha kielekezi cha `fd` kutoka kwa `C`, ambayo bado iko huru (Tcache poisoning)

### Shambulio la Off-by-null

* Vipande 3 vya kumbukumbu (a, b, c) vinahifadhiwa mmoja baada ya mwingine. Kisha wa kati aachiliwa huru. Cha kwanza kina kasoro ya kumwaga kwa kipande kimoja na muhusika anaitumia na 0x00 (ikiwa kibambo cha awali kilikuwa 0x10 itafanya kipande cha kati kiashiria kuwa kidogo kwa 0x10 kuliko ilivyo kweli).
* Kisha, vipande vidogo 2 zaidi vinatengwa katika kipande kilichofunguliwa katikati (b), hata hivyo, kwani `b + b->ukubwa` kamwe haifanyi kipande c kwa sababu anwani iliyoelekezwa ni ndogo kuliko inavyopaswa.
* Kisha, b1 na c vinawekwa huru. Kwani `c - c->ukubwa_uliotangulia` bado inaelekeza kwa b (sasa b1), vyote viunganishwa katika kipande kimoja. Hata hivyo, b2 bado iko ndani kati ya b1 na c.
* Hatimaye, malloc mpya inafanywa kurudisha eneo hili la kumbukumbu ambalo kimsingi litakuwa na b2, kuruhusu mmiliki wa malloc mpya kudhibiti maudhui ya b2.

Picha hii inaelezea shambulio kikamilifu:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Mifano na Marejeo Mengine

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one kwa sababu ya `strlen` inayozingatia uga wa `ukubwa` wa kipande cha pili.
* Tcache inatumika, hivyo mashambulio ya kawaida ya off-by-one yanafanya kazi kupata msingi wa kuandika wa kiholela na Tcache poisoning.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Inawezekana kutumia off-by-one kuvuja anwani kutoka kwa kumbukumbu kwa sababu ya baiti 0x00 mwishoni mwa mfuatano wa herufi inayobadilishwa na uga unaofuata.
* Kuandika kiholela kunapatikana kwa kutumia off-by-one kuunda kielekezi kionyeshe mahali pengine ambapo muundo wa uwongo na kielekezi cha uwongo vitajengwa. Kisha, inawezekana kufuata kielekezi cha muundo huu ili kupata kuandika kiholela.
* Anwani ya libc inavuja kwa sababu ikiwa kumbukumbu inaongezwa kwa kutumia mmap, kumbukumbu iliyotengwa na mmap ina mbadala wa kudumu kutoka libc.
* Hatimaye kuandika kiholela kunatumika kuandika kwenye anwani ya \_\_free\_hook na kifaa cha moja.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Kuna udhaifu wa off-by-one wa NULL katika kazi ya `getline` inayosoma mistari ya mwingiliano wa mtumiaji. Kazi hii hutumika kusoma "ufunguo" wa maudhui na sio maudhui.
* Katika mwongozo, vipande 5 vya awali vinajengwa:
* kipande1 (0x200)
* kipande2  (0x50)
* kipande5 (0x68)
* kipande3 (0x1f8)
* kipande4 (0xf0)
* ulinzi wa kipande (0x400) ili kuepuka kujumuishwa na kipande cha juu
* Kisha kipande 1, 5 na 3 vinaachiliwa huru, hivyo:
* ```python
[ 0x200 Kipande 1 (huru) ] [ 0x50 Kipande 2 ] [ 0x68 Kipande 5 (huru) ] [ 0x1f8 Kipande 3 (huru) ] [ 0xf0 Kipande 4 ] [ 0x400 Ulinzi wa Kipande ]
```
* Kisha kwa kutumia kipande3 (0x1f8) udhaifu wa off-by-null unatumika kuandika prev\_size kuwa `0x4e0`.
* Angalia jinsi vipimo vya vipande vilivyotengwa awali vya 1, 2, 5 na 3 pamoja na vichwa vya 4 vya vipande hivyo vinavyolingana na `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Kisha, kipande 4 kinaachiliwa huru, kuzalisha kipande kinachotumia vipande vyote hadi mwanzo:
* ```python
[ 0x4e0 Kipande 1-2-5-3 (huru) ] [ 0xf0 Kipande 4 (haribika) ] [ 0x400 Ulinzi wa Kipande ]
```
* ```python
[ 0x200 Kipande 1 (huru) ] [ 0x50 Kipande 2 ] [ 0x68 Kipande 5 (huru) ] [ 0x1f8 Kipande 3 (huru) ] [ 0xf0 Kipande 4 ] [ 0x400 Ulinzi wa Kipande ]
```
* Kisha, vipande `0x200` vinatengwa kujaza kipande cha awali 1
* Na vipande vingine 0x200 vinatengwa na kipande2 kuharibiwa na hivyo hakuna uvujaji wa kufanya kazi na hii haifanyi kazi? Labda hii haipaswi kufanywa
* Kisha, inatenga kipande kingine na "a" 0x58 (ikiandika juu ya kipande2 na kufikia kipande5) na kubadilisha `fd` ya kipande cha fast bin cha kipande5 ikielekeza kwa `__malloc_hook`
* Kisha, kipande cha 0x68 kinatengwa hivyo kipande cha fast bin cha uwongo katika `__malloc_hook` ni kipande cha fast bin kinachofuata
* Hatimaye, kipande kipya cha fast bin cha 0x68 kinatengwa na `__malloc_hook` inaandikwa upya na anwani ya `one_gadget`
* **Shiriki mbinu zako za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
