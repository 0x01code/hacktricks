# Off by one overflow

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Έχοντας μόνο πρόσβαση σε ένα 1B υπερχείλιση επιτρέπει σε έναν εισβολέα να τροποποιήσει το πεδίο `size` από τον επόμενο κομμάτι. Αυτό επιτρέπει να παραποιήσει ποια κομμάτια πραγματικά απελευθερώνονται, πιθανώς δημιουργώντας ένα κομμάτι που περιέχει ένα άλλο νόμιμο κομμάτι. Η εκμετάλλευση είναι παρόμοια με το [διπλό free](double-free.md) ή την επικάλυψη κομματιών.

Υπάρχουν 2 τύποι ευπάθειας off by one:

* Αυθαίρετο byte: Αυτός ο τύπος επιτρέπει την αντικατάσταση αυτού του byte με οποιαδήποτε τιμή
* Μηδενικό byte (off-by-null): Αυτός ο τύπος επιτρέπει την αντικατάσταση αυτού του byte μόνο με 0x00
* Ένα κοινό παράδειγμα αυτής της ευπάθειας μπορεί να δει κανείς στον παρακάτω κώδικα όπου η συμπεριφορά των `strlen` και `strcpy` είναι ασυνεπής, η οποία επιτρέπει την τοποθέτηση ενός byte 0x00 στην αρχή του επόμενου κομματιού.
* Αυτό μπορεί να εκμεταλλευτεί με το [House of Einherjar](house-of-einherjar.md).
* Αν χρησιμοποιείτε Tcache, αυτό μπορεί να εκμεταλλευτεί σε μια κατάσταση [διπλού free](double-free.md). 

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Ανάμεσα σε άλλους ελέγχους, τώρα κάθε φορά που ένα κομμάτι είναι ελεύθερο, συγκρίνεται το προηγούμενο μέγεθος με το μέγεθος που έχει ρυθμιστεί στα μεταδεδομένα του κομματιού, κάνοντας αυτήν την επίθεση αρκετά περίπλοκη από την έκδοση 2.28.

### Παράδειγμα κώδικα:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Αυτή η επίθεση δεν λειτουργεί πλέον λόγω της χρήσης των Tcaches.
* Επιπλέον, αν προσπαθήσετε να το καταχραστείτε χρησιμοποιώντας μεγαλύτερα κομμάτια (έτσι ώστε να μην εμπλέκονται οι tcaches), θα λάβετε το σφάλμα: `malloc(): invalid next size (unsorted)`

### Στόχος

* Κάντε ένα κομμάτι να περιέχεται μέσα σε ένα άλλο κομμάτι, έτσι ώστε η εγγραφή πρόσβασης σε αυτό το δεύτερο κομμάτι να επιτρέπει τον αντικαταστάτη του περιεχόμενου.

### Απαιτήσεις

* Υπερχείλιση ενός byte για να τροποποιήσετε τις πληροφορίες μεταδεδομένων μεγέθους

### Γενική επίθεση off-by-one

* Διατεθούν τρία κομμάτια `A`, `B` και `C` (π.χ. μεγέθη 0x20), και ένα άλλο για να αποτρέψει τη συγχώνευση με το κομμάτι κορυφής.
* Απελευθερώστε το `C` (εισαγμένο στη λίστα ελεύθερων Tcache 0x20).
* Χρησιμοποιήστε το κομμάτι `A` για υπερχείλιση στο `B`. Καταχραστείτε το off-by-one για να τροποποιήσετε το πεδίο `size` του `B` από 0x21 σε 0x41.
* Τώρα έχουμε το `B` που περιέχει το ελεύθερο κομμάτι `C`
* Απελευθερώστε το `B` και εκχωρήστε ένα κομμάτι 0x40 (θα τοποθετηθεί εδώ ξανά)
* Μπορούμε να τροποποιήσουμε το δείκτη `fd` από το `C`, το οποίο είναι ακόμα ελεύθερο (δηλητηρίαση Tcache)

### Επίθεση off-by-null

* Κρατούνται 3 κομμάτια μνήμης (a, b, c) το ένα μετά το άλλο. Στη συνέχεια το μεσαίο απελευθερώνεται. Το πρώτο περιέχει μια ευπάθεια υπερχείλισης ενός byte και ο επιτιθέμενος την καταχρηστεύεται με ένα 0x00 (αν το προηγούμενο byte ήταν 0x10 θα κάνει το μεσαίο κομμάτι να υποδεικνύει ότι είναι 0x10 μικρότερο από ό,τι πραγματικά είναι).
* Στη συνέχεια, δεσμεύονται 2 μικρότερα κομμάτια στο μεσαίο ελεύθερο κομμάτι (b), ωστόσο, καθώς το `b + b->size` δεν ενημερώνει ποτέ το κομμάτι c επειδή η διευθυνση προς την οποία δείχνει είναι μικρότερη από ό,τι θα έπρεπε.
* Στη συνέχεια, απελευθερώνονται τα b1 και c. Καθώς το `c - c->prev_size` εξακολουθεί να δείχνει στο b (τώρα b1), και τα δύο συγχωνεύονται σε ένα κομμάτι. Ωστόσο, το b2 παραμένει μέσα μεταξύ b1 και c.
* Τέλος, γίνεται μια νέα κλήση malloc ανακτώντας αυτήν την περιοχή μνήμης που πρόκειται να περιέχει το b2, επιτρέποντας στον κάτοχο της νέας κλήσης malloc να ελέγχει το περιεχόμενο του b2.

Αυτή η εικόνα εξηγεί τέλεια την επίθεση:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Άλλα Παραδείγματα & Αναφορές

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one λόγω της `strlen` που λαμβάνει υπόψη το πεδίο `size` του επόμενου κομματιού.
* Χρησιμοποιείται η Tcache, έτσι μια γενική επίθεση off-by-one λειτουργεί για να λάβει ένα αυθαίρετο γραπτό πρωτογενές με δηλητηρίαση Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Είναι δυνατό να καταχραστείτε ένα off by one για να διαρρεύσετε μια διεύθυνση από τη στοίβα επειδή το byte 0x00 στο τέλος ενός string αντικαθίσταται από το επόμενο πεδίο.
* Το αυθαίρετο γράψιμο προκύπτει από την κατάχρηση της εγγραφής off by one για να κάνει το δείκτη να δείχνει σε άλλο μέρος όπου θα κατασκευαστεί ένα ψεύτικο struct με ψεύτικους δείκτες. Στη συνέχεια, είναι δυνατό να ακολουθήσετε το δείκτη αυτού του struct για να λάβετε αυθαίρετο γράψιμο.
* Η διεύθυνση της libc διαρρέεται επειδή αν η στοίβα επεκτείνεται χρησιμοποιώντας το mmap, η μνήμη που διατίθεται από το mmap έχει μια σταθερή μετατόπιση από την libc.
* Τέλος, το αυθαίρετο γράψιμο καταχράται για να γράψει στη διεύθυνση του \_\_free\_hook με ένα one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Υπάρχει μια ευπάθεια NULL off by one στη συνάρτηση `getline` που διαβάζει γραμμές εισόδου χρήστη. Αυτή η συνάρτηση χρησιμοποιείται για να διαβάσει το "κλειδί" του περιεχομένου και όχι το περιεχόμενο.
* **Μοιραστείτε τα κόλπα σας στο χάκινγκ υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του GitHub.
