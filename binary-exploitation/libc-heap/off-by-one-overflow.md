# Sfioramento di overflow di uno

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di base

Avere solo accesso a un overflow di 1B consente a un attaccante di modificare il campo `size` del chunk successivo. Ci√≤ consente di manipolare quali chunk vengono effettivamente liberati, generando potenzialmente un chunk che contiene un altro chunk legittimo. L'exploit √® simile a [doppia liberazione](double-free.md) o sovrapposizione di chunk.

Ci sono 2 tipi di vulnerabilit√† di off by one:

* Byte arbitrario: Questo tipo consente di sovrascrivere quel byte con qualsiasi valore
* Byte nullo (off-by-null): Questo tipo consente di sovrascrivere quel byte solo con 0x00
* Un esempio comune di questa vulnerabilit√† pu√≤ essere visto nel seguente codice dove il comportamento di `strlen` e `strcpy` √® inconsistente, il che consente di impostare un byte 0x00 all'inizio del chunk successivo.
* Questo pu√≤ essere sfruttato con il [House of Einherjar](house-of-einherjar.md).
* Se si utilizza Tcache, questo pu√≤ essere sfruttato per una situazione di [doppia liberazione](double-free.md).

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Tra gli altri controlli, ora ogni volta che un chunk viene liberato, la dimensione precedente viene confrontata con la dimensione configurata nel chunk dei metadati, rendendo questo attacco piuttosto complesso dalla versione 2.28.

### Esempio di codice:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Questo attacco non funziona pi√π a causa dell'uso di Tcaches.
* Inoltre, se si cerca di abusarne utilizzando chunk pi√π grandi (cos√¨ che i tcaches non siano coinvolti), si otterr√† l'errore: `malloc(): invalid next size (unsorted)`

### Obiettivo

* Fare in modo che un chunk sia contenuto all'interno di un altro chunk in modo che l'accesso in scrittura su quel secondo chunk permetta di sovrascrivere quello contenuto

### Requisiti

* Overflow di uno in meno per modificare le informazioni sui metadati della dimensione

### Attacco generale di uno in meno

* Allocare tre chunk `A`, `B` e `C` (diciamo di dimensioni 0x20), e un altro per evitare la consolidazione con il chunk superiore.
* Liberare `C` (inserito nella lista di chunk liberi Tcache di 0x20).
* Utilizzare il chunk `A` per fare overflow su `B`. Abusare di uno in meno per modificare il campo `size` di `B` da 0x21 a 0x41.
* Ora abbiamo `B` che contiene il chunk libero `C`
* Liberare `B` e allocare un chunk di 0x40 (verr√† posizionato qui di nuovo)
* Possiamo modificare il puntatore `fd` da `C`, che √® ancora libero (Tcache poisoning)

### Attacco di uno nullo

* Vengono riservati 3 chunk di memoria (a, b, c) uno dopo l'altro. Poi quello centrale viene liberato. Il primo contiene una vulnerabilit√† di overflow di uno in meno e l'attaccante ne abusa con un 0x00 (se il byte precedente fosse 0x10 farebbe s√¨ che il chunk centrale indichi che √® pi√π piccolo di 0x10 di quanto non sia realmente).
* Poi, vengono allocati altri 2 chunk pi√π piccoli nel chunk liberato al centro (b), tuttavia, poich√© `b + b->size` non aggiorna mai il chunk c perch√© l'indirizzo puntato √® pi√π piccolo di quanto dovrebbe.
* Poi, vengono liberati b1 e c. Poich√© `c - c->prev_size` punta ancora a b (ora b1), entrambi vengono consolidati in un unico chunk. Tuttavia, b2 √® ancora all'interno tra b1 e c.
* Infine, viene eseguito un nuovo malloc che reclama questa area di memoria che in realt√† conterr√† b2, consentendo al proprietario del nuovo malloc di controllare il contenuto di b2.

Questa immagine spiega perfettamente l'attacco:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Altri Esempi e Riferimenti

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one a causa di `strlen` che considera il campo `size` del chunk successivo.
* Viene utilizzato Tcache, quindi attacchi generali di uno in meno funzionano per ottenere un primitivo di scrittura arbitraria con Tcache poisoning.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* √à possibile abusare di un uno in meno per ottenere un leak di un indirizzo dalla heap perch√© il byte 0x00 alla fine di una stringa viene sovrascritto dal campo successivo.
* La scrittura arbitraria viene ottenuta abusando del write off by one per far puntare il puntatore in un altro posto dove verr√† costruita una struttura falsa con puntatori falsi. Quindi, √® possibile seguire il puntatore di questa struttura per ottenere una scrittura arbitraria.
* L'indirizzo libc viene leakato perch√© se la heap viene estesa utilizzando mmap, la memoria allocata da mmap ha un offset fisso da libc.
* Infine, la scrittura arbitraria viene abusata per scrivere nell'indirizzo di \_\_free\_hook con un one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* C'√® una vulnerabilit√† NULL off-by-one nella funzione `getline` che legge le righe di input dell'utente. Questa funzione viene utilizzata per leggere la "chiave" del contenuto e non il contenuto.
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>
