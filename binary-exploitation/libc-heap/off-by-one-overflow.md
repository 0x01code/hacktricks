# Przepełnienie o jeden

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów na GitHubie.

</details>

## Podstawowe informacje

Mając dostęp tylko do przepełnienia o 1B, atakujący może zmodyfikować bit `pre_in_use` z następnego fragmentu, a ponieważ bieżący fragment nie jest w użyciu, koniec fragmentu staje się informacją o rozmiarze poprzedniego fragmentu.\
To pozwala manipulować, które fragmenty są faktycznie zwalniane, potencjalnie generując fragment zawierający inny prawidłowy fragment.

Istnieją 2 rodzaje podatności na przepełnienie o jeden:

* Dowolny bajt: Ten rodzaj pozwala nadpisać ten bajt dowolną wartością
* Null off by one: Ten rodzaj pozwala nadpisać ten bajt tylko wartością 0x00
* Powszechnym przykładem tej podatności może być kod, w którym zachowanie funkcji strlen i strcpy jest niekonsekwentne, co pozwala na ustawienie bajtu 0x00 na początku następnego fragmentu.

<details>

<summary>Null off by one</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Wśród innych sprawdzeń, teraz za każdym razem, gdy kawałek jest zwalniany, poprzedni rozmiar jest porównywany z rozmiarem skonfigurowanym w metadanych kawałka, co sprawia, że ten atak jest dość skomplikowany od wersji 2.28.

### Przykład kodu:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ten atak już nie działa ze względu na użycie Tcaches.
* Ponadto, jeśli spróbujesz go wykorzystać, używając większych kawałków (aby tcaches nie były zaangażowane), otrzymasz błąd: `malloc(): invalid next size (unsorted)`

### Cel

* Umieścić kawałek wewnątrz innego kawałka, dzięki czemu dostęp do zapisu na ten drugi kawałek pozwala nadpisać zawarty w nim kawałek

### Wymagania

* Przepełnienie o jeden, aby zmodyfikować informacje metadanych poprzedniego rozmiaru

### Atak

* Rezerwowane są 3 kawałki pamięci (a, b, c) jeden po drugim. Następnie środkowy jest zwalniany. Pierwszy zawiera podatność na przepełnienie o jeden bajt i atakujący ją wykorzystuje z użyciem 0x00 (jeśli poprzedni bajt był 0x10, sprawiłoby to, że środkowy kawałek wskazywałby, że jest o 0x10 mniejszy niż naprawdę).
* Następnie, w środkowym zwolnionym kawałku (b) alokowane są 2 mniejsze kawałki, jednakże, ponieważ `b + b->size` nigdy nie aktualizuje kawałka c, ponieważ wskazany adres jest mniejszy niż powinien.&#x20;
* Następnie, b1 i c są zwalniane. Ponieważ `c - c->prev_size` nadal wskazuje na b (teraz b1), oba są konsolidowane w jeden kawałek. Jednakże, b2 nadal znajduje się w środku między b1 i c.
* W końcu wykonywane jest nowe malloc odzyskujące ten obszar pamięci, który faktycznie będzie zawierał b2, pozwalając właścicielowi nowego malloc kontrolować zawartość b2.

To zdjęcie doskonale wyjaśnia atak:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Inne Przykłady i Odnośniki

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Możliwe jest wykorzystanie przepełnienia o jeden do wycieku adresu z heap, ponieważ bajt 0x00 na końcu łańcucha zostaje nadpisany przez następne pole.
* Zapis dowolny jest uzyskiwany poprzez wykorzystanie przepełnienia o jeden, aby sprawić, że wskaźnik wskazuje na inne miejsce, gdzie zostanie zbudowana fałszywa struktura z fałszywymi wskaźnikami. Następnie możliwe jest śledzenie wskaźnika tej struktury, aby uzyskać zapis dowolny.
* Adres libc jest wyciekany, ponieważ jeśli heap jest rozszerzany za pomocą mmap, pamięć przydzielona przez mmap ma stały przesunięcie od libc.
* W końcu zapis dowolny jest wykorzystywany do zapisania adresu \_\_free\_hook za pomocą one gadgeta.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Istnieje podatność NULL off by one w funkcji `getline`, która czyta linie wejściowe użytkownika. Ta funkcja służy do odczytywania "klucza" zawartości, a nie samej zawartości.
* W opisie 5 początkowych kawałków jest tworzonych:
* kawałek1 (0x200)
* kawałek2  (0x50)
* kawałek5 (0x68)
* kawałek3 (0x1f8)
* kawałek4 (0xf0)
* obrona kawałka (0x400) aby uniknąć konsolidacji z kawałkiem górnym
* Następnie kawałki 1, 5 i 3 są zwalniane, więc:
* ```python
[ 0x200 Kawałek 1 (zwolniony) ] [ 0x50 Kawałek 2 ] [ 0x68 Kawałek 5 (zwolniony) ] [ 0x1f8 Kawałek 3 (zwolniony) ] [ 0xf0 Kawałek 4 ] [ 0x400 Kawałek obrony ]
```
* Następnie nadużywając kawałka3 (0x1f8) wykorzystywane jest null off-by-one, zapisując prev\_size na `0x4e0`.
* Zauważ, jak rozmiary początkowo przydzielonych kawałków1, 2, 5 i 3 plus nagłówki 4 tych kawałków równają się `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Następnie, kawałek 4 jest zwalniany, generując kawałek, który zużywa wszystkie kawałki aż do początku:
* ```python
[ 0x4e0 Kawałek 1-2-5-3 (zwolniony) ] [ 0xf0 Kawałek 4 (zepsuty) ] [ 0x400 Kawałek obrony ]
```
* ```python
[ 0x200 Kawałek 1 (zwolniony) ] [ 0x50 Kawałek 2 ] [ 0x68 Kawałek 5 (zwolniony) ] [ 0x1f8 Kawałek 3 (zwolniony) ] [ 0xf0 Kawałek 4 ] [ 0x400 Kawałek obrony ]
```
* Następnie, przydzielane są `0x200` bajtów wypełniając oryginalny kawałek 1
* I przydzielane są kolejne 0x200 bajtów i kawałek2 jest zniszczony i dlatego nie ma żadnego wycieku i to nie działa? Może tego nie należy robić
* Następnie przydzielany jest kolejny kawałek o długości 0x58 "a" (nadpisując kawałek2 i docierając do kawałka5) i modyfikowany jest `fd` szybkiego kawałka binarnego kawałka5 wskazując na `__malloc_hook`
* Następnie, przydzielany jest kawałek o długości 0x68, więc fałszywy szybki kawałek binarny w `__malloc_hook` jest następnym szybkim kawałkiem binarnym
* W końcu, przydzielany jest nowy szybki kawałek binarny o długości 0x68 i `__malloc_hook` jest nadpisywany adresem `one_gadget`

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF** Sprawdź [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podziel się swoimi sztuczkami hakowania, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
