# Υπερχείλιση ενός byte

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Έχοντας μόνο πρόσβαση σε μια υπερχείλιση 1 byte επιτρέπει σε έναν επιτιθέμενο να τροποποιήσει το bit `pre_in_use` από το επόμενο κομμάτι και καθώς το τρέχον κομμάτι δεν θα είναι σε χρήση, το τέλος του κομματιού γίνεται η πληροφορία μεταδεδομένων μεγέθους του προηγούμενου κομματιού.\
Αυτό επιτρέπει να παραποιηθούν τα κομμάτια που πραγματικά ελευθερώνονται, πιθανώς δημιουργώντας ένα κομμάτι που περιέχει ένα άλλο νόμιμο κομμάτι.

Υπάρχουν 2 τύποι ευπάθειας off by one:

* Αυθαίρετο byte: Αυτός ο τύπος επιτρέπει την αντικατάσταση αυτού του byte με οποιαδήποτε τιμή
* Null off by one: Αυτός ο τύπος επιτρέπει την αντικατάσταση αυτού του byte μόνο με 0x00
* Ένα κοινό παράδειγμα αυτής της ευπάθειας μπορεί να δει κανείς στον παρακάτω κώδικα όπου η συμπεριφορά των strlen και strcpy είναι ασυνεπής, η οποία επιτρέπει την τοποθέτηση ενός byte 0x00 στην αρχή του επόμενου κομματιού.

<details>

<summary>Null off by one</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Μεταξύ άλλων ελέγχων, τώρα κάθε φορά που ένα κομμάτι είναι ελεύθερο, η προηγούμενη μέγεθος συγκρίνεται με το μέγεθος που έχει ρυθμιστεί στα μεταδεδομένα του κομματιού, κάνοντας αυτήν την επίθεση αρκετά πολύπλοκη από την έκδοση 2.28.

### Παράδειγμα Κώδικα:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Αυτή η επίθεση δεν λειτουργεί πλέον λόγω της χρήσης Tcaches.
* Επιπλέον, αν προσπαθήσετε να το καταχραστείτε χρησιμοποιώντας μεγαλύτερα κομμάτια (έτσι ώστε να μην εμπλέκονται οι tcaches), θα λάβετε το σφάλμα: `malloc(): invalid next size (unsorted)`

### Στόχος

* Κάντε ένα κομμάτι να περιέχεται μέσα σε ένα άλλο κομμάτι, έτσι ώστε η εγγραφή πρόσβασης σε αυτό το δεύτερο κομμάτι να επιτρέπει την αντικατάσταση του περιεχόμενου του πρώτου.

### Απαιτήσεις

* Υπερχείλιση ενός byte για να τροποποιήσετε τις πληροφορίες μεταδεδομένων του προηγούμενου μεγέθους

### Επίθεση

* Κρατούνται 3 κομμάτια μνήμης (α, β, γ) ένα μετά το άλλο. Στη συνέχεια το μεσαίο ελευθερώνεται. Το πρώτο περιέχει μια ευπάθεια υπερχείλισης ενός byte και ο επιτιθέμενος την καταχρηστεύεται με ένα 0x00 (αν το προηγούμενο byte ήταν 0x10 θα κάνει το μεσαίο κομμάτι να υποδεικνύει ότι είναι 0x10 μικρότερο από ό,τι πραγματικά είναι).
* Στη συνέχεια, δεσμεύονται 2 μικρότερα κομμάτια στο μέσο ελεύθερο κομμάτι (β), ωστόσο, καθώς `β + μέγεθος β->` δεν ενημερώνει ποτέ το κομμάτι γιατί η διεύθυνση που δείχνεται είναι μικρότερη από ό,τι θα έπρεπε.
* Στη συνέχεια, b1 και c ελευθερώνονται. Καθώς `c - c->prev_size` εξακολουθεί να δείχνει στο b (τώρα b1), και τα δύο συγχωνεύονται σε ένα κομμάτι. Ωστόσο, το b2 παραμένει μέσα μεταξύ b1 και c.
* Τέλος, γίνεται μια νέα κλήση malloc ανακτώντας αυτήν την περιοχή μνήμης που πρόκειται να περιέχει πραγματικά το b2, επιτρέποντας στον κάτοχο του νέου malloc να ελέγχει το περιεχόμενο του b2.

Αυτή η εικόνα εξηγεί τέλεια την επίθεση:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Άλλα Παραδείγματα & Αναφορές

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Είναι δυνατόν να καταχραστείτε ένα off by one για να διαρρεύσετε μια διεύθυνση από τη στοίβα επειδή το byte 0x00 στο τέλος ενός string αντικαθίσταται από το επόμενο πεδίο.
* Η αυθαίρετη εγγραφή επιτυγχάνεται καταχρώμενη την off by one εγγραφή για να κάνει τον δείκτη να δείχνει σε ένα άλλο μέρος όπου θα κατασκευαστεί ένα ψεύτικο struct με ψεύτικους δείκτες. Στη συνέχεια, είναι δυνατόν να ακολουθήσετε τον δείκτη αυτού του struct για να λάβετε αυθαίρετη εγγραφή.
* Η διεύθυνση της libc διαρρέεται επειδή αν η στοίβα επεκτείνεται χρησιμοποιώντας το mmap, η μνήμη που εκχωρείται από το mmap έχει μια σταθερή μετατόπιση από την libc.
* Τέλος, η αυθαίρετη εγγραφή καταχρώντας γράφει στη διεύθυνση του \_\_free\_hook με ένα one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Υπάρχει μια ευπάθεια NULL off by one στη λειτουργία `getline` που διαβάζει γραμμές εισόδου χρήστη. Αυτή η λειτουργία χρησιμοποιείται για να διαβάσει το "κλειδί" του περιεχομένου και όχι το περιεχόμενο.
* Στην ανάλυση δημιουργούνται 5 αρχικά κομμάτια:
* κομμάτι1 (0x200)
* κομμάτι2 (0x50)
* κομμάτι5 (0x68)
* κομμάτι3 (0x1f8)
* κομμάτι4 (0xf0)
* κομμάτι αμυντικής θέσης (0x400) για να αποφευχθεί η συγχώνευση με το κορυφαίο κομμάτι
* Στη συνέχεια τα κομμάτια 1, 5 και 3 ελευθερώνονται, έτσι:
* ```python
[ 0x200 Κομμάτι 1 (ελεύθερο) ] [ 0x50 Κομμάτι 2 ] [ 0x68 Κομμάτι 5 (ελεύθερο) ] [ 0x1f8 Κομμάτι 3 (ελεύθερο) ] [ 0xf0 Κομμάτι 4 ] [ 0x400 Κομμάτι αμυντικής θέσης ]
```
* Στη συνέχεια, καταχρώμενο το κομμάτι3 (0x1f8) η ευπάθεια null off-by-one καταχρώνεται γράφοντας το prev\_size σε `0x4e0`.
* Σημειώστε πως τα μεγέθη των αρχικά εκχωρημένων κομματιών1, 2, 5 και 3 συν τις κεφαλίδες των 4 αυτών των κομματιών ισούνται με `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Στη συνέχεια, το κομμάτι 4 ελευθερώνεται, δημιουργώντας ένα κομμάτι που καταναλώνει όλα τα κομμάτια μέχρι την αρχή:
* ```python
[ 0x4e0 Κομμάτι 1-2-5-3 (ελεύθερο) ] [ 0xf0 Κομμάτι 4 (διεφθαρμένο) ] [ 0x400 Κομμάτι αμυντικής θέσης ]
```
* ```python
[ 0x200 Κομμάτι 1 (ελεύθερο) ] [ 0x50 Κομμάτι 2 ] [ 0x68 Κομμάτι 5 (ελεύθερο) ] [ 0x1f8 Κομμάτι 3 (ελεύθερο) ] [ 0xf0 Κομμάτι 4 ] [ 0x400 Κομμάτι αμυντικής θέσης ]
```
* Στη συνέχεια, διατίθενται `0x200` bytes γεμίζοντας το αρχικό κομμάτι 1
* Και άλλα 0x200 bytes εκχωρούνται και το κομμάτι2 καταστρέφεται και επομένως δεν υπάρχει διαρροή και αυτό δεν λειτουργεί; Ίσως αυτό δεν θα έπρεπε να γίνει
* Στη συνέχεια, εκχωρείται ένα άλλο κομμάτι με 0x58 "a"s (αντικαθιστώντας το κομμάτι2 και φτάνοντας το κομμάτι5) και τροποποιεί το `fd` του γρήγορου κομματιού του κομματιού5 δείχνοντας στο `__malloc_hook`
* Στη συνέχεια, εκχωρείται ένα κομμάτι των 0x68 έτσι ώστε το ψεύτικο γρήγορο κομμάτι στο `__malloc_hook` να είναι το επόμενο γρήγορο κομμάτι
* Τέλος, εκχωρείται ένα νέο γρήγορο
