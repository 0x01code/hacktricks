# Bir birim aşımı

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hacklemeyi öğrenin!</summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Yalnızca 1B birim aşımına erişim sağlamak, saldırganın bir sonraki parçanın `pre_in_use` bitini değiştirmesine olanak tanır ve mevcut parça kullanımda olmadığından, parçanın sonu önceki parça boyutu meta bilgileri haline gelir.\
Bu, hangi parçaların gerçekten serbest bırakıldığını değiştirmeyi sağlar, potansiyel olarak başka bir meşru parçayı içeren bir parça oluşturabilir.

Bir birim aşımı zafiyetinin 2 türü vardır:

* Keyfi byte: Bu tür, o byte'ı herhangi bir değerle üzerine yazmaya olanak tanır
* Null birim aşımı: Bu tür, o byte'ı yalnızca 0x00 ile üzerine yazmaya olanak tanır
* Bu zafiyetin yaygın bir örneği, strlen ve strcpy davranışının tutarsız olduğu aşağıdaki kodda görülebilir, bu da bir sonraki parçanın başlangıcına 0x00 byte ayarlamayı mümkün kılar.

<details>

<summary>Null birim aşımı</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Diğer kontroller arasında, artık bir parça serbest bırakıldığında önceki boyutun, metadatadaki parçanın yapılandırılan boyutuyla karşılaştırıldığı kontrol edilir, bu saldırı 2.28 sürümden itibaren oldukça karmaşık hale getirir.

### Kod Örneği:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Bu saldırı artık Tcaches kullanıldığından çalışmamaktadır.
* Ayrıca, daha büyük parçalar kullanarak (bu durumda tcaches devreye girmez), hata alırsınız: `malloc(): invalid next size (unsorted)`

### Amaç

* Bir parçanın başka bir parçanın içinde bulunmasını sağlamak, böylece ikinci parçaya yazma erişimi, içerilen parçayı üzerine yazmaya olanak tanır

### Gereksinimler

* Önceki boyut metad veri bilgisini değiştirmek için bir birim fazla taşma

### Saldırı

* Bellekte 3 parça (a, b, c) ardışık olarak ayrılmıştır. Ardından ortadaki parça serbest bırakılır. İlk parça bir birim fazla taşma açığına sahiptir ve saldırgan bunu 0x00 ile kötüye kullanır (önceki bayt 0x10 ise, ortadaki parçanın gerçekte olduğundan 0x10 daha küçük olduğunu gösterir).
* Daha sonra, ortadaki serbest bırakılan parçaya (b) 2 daha küçük parça ayrılır, ancak `b + b->size` c parçasını güncellemez çünkü işaret edilen adres olması gereken adresten daha küçüktür.
* Daha sonra, b1 ve c serbest bırakılır. `c - c->prev_size` hala b'yi (şimdi b1) işaret ettiği için, her ikisi de birleştirilir. Ancak, b2 hala b1 ve c arasında içindedir.
* Son olarak, bu bellek alanını geri kazanmak için yeni bir malloc işlemi gerçekleştirilir, bu da aslında b2'yi içerecek ve yeni malloc'un sahibine b2'nin içeriğini kontrol etme olanağı tanır.

Bu resim saldırıyı mükemmel bir şekilde açıklar:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Diğer Örnekler ve Referanslar

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Bir birim fazla taşmayı kullanarak yığın belleğinden bir adres sızdırmak mümkündür çünkü bir dizenin sonundaki 0x00 baytı bir sonraki alan tarafından üzerine yazılır.
* Rastgele yazma, bir birim fazla taşmayı kötüye kullanarak elde edilir, böylece işaretçi başka bir yere işaret edecek sahte bir yapı oluşturulur. Ardından, bu yapıdaki işaretçiyi takip ederek rastgele yazma elde etmek mümkündür.
* Libc adresi sızdırılır çünkü yığın mmap kullanılarak genişletildiğinde, mmap tarafından tahsis edilen belleğin libc'ten sabit bir ofseti vardır.
* Son olarak, rastgele yazma, `__free_hook` adresine bir tek araçla yazmak için kötüye kullanılır.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Kullanıcı giriş satırlarını okuyan `getline` işlevinde NULL bir birim fazla taşma zafiyeti vardır. Bu işlev, içeriğin "anahtarını" okumak için kullanılır.
* Yazım 5 başlangıç parçası oluşturulur:
* parça1 (0x200)
* parça2 (0x50)
* parça5 (0x68)
* parça3 (0x1f8)
* parça4 (0xf0)
* parça savunması (0x400), üst parçayla birleşmesini önlemek için
* Ardından parça 1, 5 ve 3 serbest bırakılır, böylece:
* ```python
[ 0x200 Parça 1 (serbest) ] [ 0x50 Parça 2 ] [ 0x68 Parça 5 (serbest) ] [ 0x1f8 Parça 3 (serbest) ] [ 0xf0 Parça 4 ] [ 0x400 Parça savunması ]
```
* Ardından, parça3 (0x1f8) kötüye kullanılarak null bir birim fazla taşma yazarak prev\_size `0x4e0` olarak yazılır.
* Başlangıçta tahsis edilen parça1, 2, 5 ve 3'ün boyutlarının ve bu parçaların başlıklarının toplamının `0x4e0` olduğuna dikkat edin: `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Ardından, parça 4 serbest bırakılır, tüm parçaları başlangıca kadar tüketen bir parça oluşturur:
* ```python
[ 0x4e0 Parça 1-2-5-3 (serbest) ] [ 0xf0 Parça 4 (bozuk) ] [ 0x400 Parça savunması ]
```
* ```python
[ 0x200 Parça 1 (serbest) ] [ 0x50 Parça 2 ] [ 0x68 Parça 5 (serbest) ] [ 0x1f8 Parça 3 (serbest) ] [ 0xf0 Parça 4 ] [ 0x400 Parça savunması ]
```
* Ardından, orijinal parça 1'i doldurmak için `0x200` bayt tahsis edilir
* Ve başka 0x200 bayt tahsis edilir ve parça2 yok edilir ve bu nedenle hiçbir sızıntı yok ve bu işe yaramaz mı? Belki bunun yapılması gerekmeyebilir
* Ardından, 0x58 "a" ile başka bir parça tahsis edilir (parça2'yi üzerine yazarak parça5'e ulaşır) ve chunk5'in hızlı bin parçasının `__malloc_hook`'a işaret eden `fd`'si değiştirilir
* Son olarak, 0x68'lik bir parça tahsis edilir, böylece `__malloc_hook`'taki sahte hızlı bin parçası, takip edilecek sonraki hızlı bin parçası olur
* Son olarak, 0x68'lik yeni bir hızlı bin parçası tahsis edilir ve `__malloc_hook` bir `one_gadget` adresiyle üzerine yazılır

<details>

<summary><strong>Sıfırdan başlayarak AWS hacklemeyi</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> öğrenin!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki özel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keşfedin
* 💬 **Discord grubuna** katılın veya **telegram grubuna** veya **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)'ı takip edin.
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek paylaşın.

</details>
