# Estouro por um byte

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

Ter apenas acesso a um estouro de 1 byte permite a um atacante modificar o campo `size` do pr√≥ximo chunk. Isso permite manipular quais chunks s√£o realmente liberados, potencialmente gerando um chunk que cont√©m outro chunk leg√≠timo. A explora√ß√£o √© semelhante a um [double free](double-free.md) ou chunks sobrepostos.

Existem 2 tipos de vulnerabilidades de estouro por um byte:

* Byte arbitr√°rio: Esse tipo permite sobrescrever esse byte com qualquer valor
* Byte nulo (off-by-null): Esse tipo permite sobrescrever esse byte apenas com 0x00
* Um exemplo comum dessa vulnerabilidade pode ser visto no c√≥digo a seguir, onde o comportamento de `strlen` e `strcpy` √© inconsistente, o que permite definir um byte 0x00 no in√≠cio do pr√≥ximo chunk.
* Isso pode ser explorado com o [House of Einherjar](house-of-einherjar.md).
* Se estiver usando Tcache, isso pode ser aproveitado para uma situa√ß√£o de [double free](double-free.md). 

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre outras verifica√ß√µes, agora sempre que um chunk √© liberado, o tamanho anterior √© comparado com o tamanho configurado no chunk de metadados, tornando esse ataque bastante complexo a partir da vers√£o 2.28.

### Exemplo de c√≥digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque n√£o est√° mais funcionando devido ao uso de Tcaches.
* Al√©m disso, se voc√™ tentar abusar dele usando chunks maiores (para que as tcaches n√£o estejam envolvidas), voc√™ receber√° o erro: `malloc(): invalid next size (unsorted)`

### Objetivo

* Fazer com que um chunk esteja contido dentro de outro chunk, de modo que o acesso de escrita sobre esse segundo chunk permita sobrescrever o contido

### Requisitos

* Estouro de buffer por um para modificar as informa√ß√µes de metadados de tamanho

### Ataque geral de off-by-one

* Aloque tr√™s chunks `A`, `B` e `C` (digamos tamanhos 0x20), e outro para evitar a consolida√ß√£o com o chunk superior.
* Libere `C` (inserido na lista de libera√ß√£o Tcache de 0x20).
* Use o chunk `A` para transbordar em `B`. Abusa do off-by-one para modificar o campo `size` de `B` de 0x21 para 0x41.
* Agora temos `B` contendo o chunk livre `C`
* Libere `B` e aloque um chunk de 0x40 (ele ser√° colocado aqui novamente)
* Podemos modificar o ponteiro `fd` de `C`, que ainda est√° livre (envenenamento de Tcache)

### Ataque off-by-null

* 3 chunks de mem√≥ria (a, b, c) s√£o reservados um ap√≥s o outro. Em seguida, o do meio √© liberado. O primeiro cont√©m uma vulnerabilidade de estouro por um e o atacante a abusa com um 0x00 (se o byte anterior fosse 0x10, faria com que o chunk do meio indicasse que √© 0x10 menor do que realmente √©).
* Em seguida, 2 chunks menores s√£o alocados no meio do chunk liberado (b), no entanto, como `b + b->size` nunca atualiza o chunk c porque o endere√ßo apontado √© menor do que deveria.
* Em seguida, b1 e c s√£o liberados. Como `c - c->prev_size` ainda aponta para b (agora b1), ambos s√£o consolidados em um √∫nico chunk. No entanto, b2 ainda est√° dentro entre b1 e c.
* Finalmente, √© feito um novo malloc para recuperar esta √°rea de mem√≥ria que na verdade vai conter b2, permitindo ao propriet√°rio do novo malloc controlar o conte√∫do de b2.

Esta imagem explica perfeitamente o ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Outros Exemplos e Refer√™ncias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* Off-by-one devido ao `strlen` considerando o campo `size` do pr√≥ximo chunk.
* Tcache est√° sendo usado, ent√£o ataques gerais de off-by-one funcionam para obter um primitivo de escrita arbitr√°rio com envenenamento de Tcache.
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* √â poss√≠vel abusar de um off-by-one para vazar um endere√ßo do heap porque o byte 0x00 do final de uma string est√° sendo sobrescrito pelo pr√≥ximo campo.
* A escrita arbitr√°ria √© obtida abusando do off-by-one para fazer o ponteiro apontar para outro lugar onde uma estrutura falsa com ponteiros falsos ser√° constru√≠da. Em seguida, √© poss√≠vel seguir o ponteiro desta estrutura para obter escrita arbitr√°ria.
* O endere√ßo do libc √© vazado porque se o heap for estendido usando mmap, a mem√≥ria alocada por mmap tem um deslocamento fixo do libc.
* Finalmente, a escrita arbitr√°ria √© abusada para escrever no endere√ßo de \_\_free\_hook com um one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Existe uma vulnerabilidade de off-by-one NULL na fun√ß√£o `getline` que l√™ linhas de entrada do usu√°rio. Esta fun√ß√£o √© usada para ler a "chave" do conte√∫do e n√£o o conte√∫do.
* No writeup, 5 chunks iniciais s√£o criados:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk de defesa (0x400) para evitar a consolida√ß√£o com o chunk superior
* Em seguida, os chunks 1, 5 e 3 s√£o liberados, ent√£o:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Em seguida, abusando do chunk3 (0x1f8), o off-by-one NULL √© abusado escrevendo o prev\_size para `0x4e0`.
* Observe como os tamanhos dos chunks inicialmente alocados 1, 2, 5 e 3 mais os cabe√ßalhos de 4 desses chunks somam `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Em seguida, o chunk 4 √© liberado, gerando um chunk que consome todos os chunks at√© o in√≠cio:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Em seguida, s√£o alocados `0x200` bytes preenchendo o chunk original 1
* E mais 0x200 bytes s√£o alocados e o chunk2 √© destru√≠do e, portanto, n√£o h√° vazamento e isso n√£o funciona? Talvez isso n√£o devesse ser feito
* Em seguida, √© alocado outro chunk com 0x58 "a"s (sobrescrevendo o chunk2 e alcan√ßando o chunk5) e modifica o ponteiro `fd` do chunk de fast bin de chunk5 apontando para `__malloc_hook`
* Em seguida, √© alocado um chunk de 0x68 para que o chunk de fast bin falso em `__malloc_hook` seja o seguinte chunk de fast bin
* Finalmente, um novo chunk de fast bin de 0x68 √© alocado e `__malloc_hook` √© sobrescrito com um endere√ßo `one_gadget`
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.**
