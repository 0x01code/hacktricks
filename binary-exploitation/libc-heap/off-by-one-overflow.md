# Off by one overflow

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>を使用して、ゼロからヒーローまでAWSハッキングを学びましょう！</summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や、**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする
- **ハッキングトリックを共有するために、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する**

</details>

## 基本情報

1バイトのオーバーフローへのアクセスがあるだけで、攻撃者は次のチャンクの`pre_in_use`ビットを変更でき、現在のチャンクが使用されていないため、チャンクの末尾は前のチャンクのサイズのメタデータ情報になります。\
これにより、実際に解放されるチャンクを操作し、別の正当なチャンクを含むチャンクを生成する可能性があります。

オフバイワンの脆弱性には2種類あります：

- 任意のバイト：この種類はそのバイトを任意の値で上書きできるようにします
- Null off by one：この種類はそのバイトを0x00でのみ上書きできるようにします
- この脆弱性の一般的な例は、次のチャンクの先頭に0x00バイトを設定できるようにする、strlenとstrcpyの挙動が一貫していないコードで見ることができます。

<details>

<summary>Null off by one</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

### 目次

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* この攻撃はTcachesの使用によりもはや機能しません。
* さらに、より大きなチャンクを使用して悪用しようとすると、エラーが発生します：`malloc(): invalid next size (unsorted)`

### ゴール

* チャンクを別のチャンクの中に含ませ、その2番目のチャンクへの書き込みアクセスを許可して、含まれるチャンクを上書きできるようにする

### 必要条件

* 前のサイズのメタデータ情報を変更するためのオフバイワンオーバーフロー

### 攻撃

* メモリの3つのチャンク（a、b、c）が順番に予約されます。次に、中央のチャンクが解放されます。最初のチャンクにはオフバイワンオーバーフローの脆弱性があり、攻撃者はそれを悪用します（前のバイトが0x10であれば、中央のチャンクが実際より0x10小さいと示します）。
* 次に、中央の解放されたチャンク（b）に2つのより小さなチャンクが割り当てられますが、`b + b->size` は c チャンクを更新しないため、指定されたアドレスが適切なサイズよりも小さいためです。
* 次に、b1 と c が解放されます。`c - c->prev_size` はまだ b（今は b1）を指しているため、両方が1つのチャンクに統合されます。ただし、b2 はまだ b1 と c の間にあります。
* 最後に、新しい malloc が実行され、このメモリ領域を再取得し、実際に b2 を含むことになり、新しい malloc の所有者が b2 の内容を制御できるようになります。

この画像は攻撃を完璧に説明しています：

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## その他の例と参考文献

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* オフバイワンを悪用してヒープからアドレスをリークすることが可能です。これは、次のフィールドによって上書きされる文字列の末尾のバイトが0x00であるためです。
* オフバイワンを悪用して、ポインタを別の場所を指すように書き換え、偽のポインタを持つ偽の構造体が構築されるようにすることで、任意の書き込みを取得できます。その後、この構造体のポインタをたどることで、任意の書き込みを取得できます。
* libc アドレスが漏洩するのは、ヒープが mmap を使用して拡張される場合、mmap によって割り当てられたメモリが libc から固定オフセットを持っているためです。
* 最後に、任意の書き込みを悪用して、\_\_free\_hook のアドレスに one gadget を書き込みます。
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* `getline` 関数には、ユーザー入力行を読み取る NULL オフバイワンの脆弱性があります。この関数は、コンテンツの「キー」を読み取るために使用されます。
* 解説では、5つの初期チャンクが作成されます：
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400) トップチャンクとの統合を回避するため
* 次に、chunk 1、5、3 が解放されます：
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* 次に、chunk3 (0x1f8) を悪用して、null オフバイワンを悪用し、prev\_size を `0x4e0` に書き込みます。
* 最初に割り当てられた chunk1、2、5、3 のサイズと、それらのチャンクのヘッダーの合計が `0x4e0` に等しいことに注意してください：`hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* 次に、chunk 4 が解放され、すべてのチャンクを最初から消費するチャンクが生成されます：
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* 次に、元の chunk 1 に 0x200 バイトが割り当てられます
* そして、さらに 0x200 バイトが割り当てられ、chunk2 が破壊され、したがってリークはなく、これは機能しませんか？おそらくこれは行うべきではありません
* 次に、0x58 個の "a" を持つ別のチャンクが割り当てられ（chunk2 を上書きし、chunk5 に到達）、chunk5 のファストビンチャンクの `fd` を `__malloc_hook` を指すように変更します
* 次に、0x68 のチャンクが割り当てられ、`__malloc_hook` の偽のファストビンチャンクが次のファストビンチャンクになります
* 最後に、0x68 の新しいファストビンチャンクが割り当てられ、`__malloc_hook` が `one_gadget` アドレスで上書きされます

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法：

* **HackTricks で企業を宣伝したい** または **HackTricks を PDF でダウンロードしたい** 場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をご確認ください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [Discord グループ](https://discord.gg/hRep4RUj7f)** に参加するか、[telegram グループ](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live) をフォローする
* **HackTricks** と **HackTricks Cloud** の GitHub リポジトリに PR を提出して、あなたのハッキングトリックを共有してください。

</details>
