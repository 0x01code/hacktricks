# Estouro por um byte

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Informa√ß√µes B√°sicas

Ter apenas acesso a um estouro de 1 byte permite a um atacante modificar o bit `pre_in_use` do pr√≥ximo chunk e, como o chunk atual n√£o estar√° em uso, o final do chunk se torna a informa√ß√£o de metadados do tamanho do chunk anterior.\
Isso permite manipular quais chunks est√£o realmente liberados, potencialmente gerando um chunk que cont√©m outro chunk leg√≠timo.

Existem 2 tipos de vulnerabilidades de estouro por um byte:

* Byte arbitr√°rio: Este tipo permite sobrescrever esse byte com qualquer valor
* Null off by one: Este tipo permite sobrescrever esse byte apenas com 0x00
* Um exemplo comum dessa vulnerabilidade pode ser visto no c√≥digo a seguir, onde o comportamento de strlen e strcpy √© inconsistente, o que permite definir um byte 0x00 no in√≠cio do pr√≥ximo chunk.

<details>

<summary>Null off by one</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Entre outras verifica√ß√µes, agora sempre que um chunk √© liberado, o tamanho anterior √© comparado com o tamanho configurado nos metadados do chunk, tornando esse ataque bastante complexo a partir da vers√£o 2.28.

### Exemplo de C√≥digo:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Este ataque n√£o est√° mais funcionando devido ao uso de Tcaches.
* Al√©m disso, se voc√™ tentar abusar dele usando chunks maiores (para que as tcaches n√£o estejam envolvidas), voc√™ receber√° o erro: `malloc(): invalid next size (unsorted)`

### Objetivo

* Fazer um chunk estar contido dentro de outro chunk, de modo que o acesso de escrita sobre esse segundo chunk permita sobrescrever o contido

### Requisitos

* Estouro de um byte para modificar as informa√ß√µes de metadados do tamanho anterior

### Ataque

* 3 chunks de mem√≥ria (a, b, c) s√£o reservados um ap√≥s o outro. Em seguida, o do meio √© liberado. O primeiro cont√©m uma vulnerabilidade de estouro de um byte e o atacante a abusa com um 0x00 (se o byte anterior fosse 0x10, faria com que o chunk do meio indicasse que √© 0x10 menor do que realmente √©).
* Em seguida, 2 chunks menores s√£o alocados no chunk liberado do meio (b), no entanto, como `b + b->size` nunca atualiza o chunk c porque o endere√ßo apontado √© menor do que deveria ser.
* Em seguida, b1 e c s√£o liberados. Como `c - c->prev_size` ainda aponta para b (agora b1), ambos s√£o consolidados em um √∫nico chunk. No entanto, b2 ainda est√° dentro, entre b1 e c.
* Por fim, √© feito um novo malloc para recuperar essa √°rea de mem√≥ria que na verdade vai conter b2, permitindo ao propriet√°rio do novo malloc controlar o conte√∫do de b2.

Esta imagem explica perfeitamente o ataque:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Outros Exemplos e Refer√™ncias

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* √â poss√≠vel abusar de um estouro de um byte para vazar um endere√ßo do heap porque o byte 0x00 do final de uma string est√° sendo sobrescrito pelo pr√≥ximo campo.
* A escrita arbitr√°ria √© obtida abusando do estouro de um byte para fazer o ponteiro apontar para outro lugar onde uma estrutura falsa com ponteiros falsos ser√° constru√≠da. Em seguida, √© poss√≠vel seguir o ponteiro desta estrutura para obter escrita arbitr√°ria.
* O endere√ßo da libc √© vazado porque se o heap for estendido usando mmap, a mem√≥ria alocada por mmap tem um deslocamento fixo da libc.
* Por fim, a escrita arbitr√°ria √© abusada para escrever no endere√ßo de \_\_free\_hook com um one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Existe uma vulnerabilidade de estouro de um byte nulo na fun√ß√£o `getline` que l√™ linhas de entrada do usu√°rio. Esta fun√ß√£o √© usada para ler a "chave" do conte√∫do e n√£o o conte√∫do.
* No writeup, 5 chunks iniciais s√£o criados:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400) para evitar a consolida√ß√£o com o chunk superior
* Em seguida, os chunks 1, 5 e 3 s√£o liberados, ent√£o:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Em seguida, abusando do chunk3 (0x1f8), o estouro de um byte nulo √© abusado escrevendo o prev\_size para `0x4e0`.
* Observe como os tamanhos dos chunks inicialmente alocados 1, 2, 5 e 3 mais os cabe√ßalhos de 4 desses chunks somam `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Em seguida, o chunk 4 √© liberado, gerando um chunk que consome todos os chunks at√© o in√≠cio:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Em seguida, s√£o alocados `0x200` bytes preenchendo o chunk original 1
* E mais 0x200 bytes s√£o alocados e o chunk2 √© destru√≠do e, portanto, n√£o h√° vazamento e isso n√£o funciona? Talvez isso n√£o devesse ser feito
* Em seguida, √© alocado um outro chunk com 0x58 "a"s (sobrescrevendo o chunk2 e alcan√ßando o chunk5) e modifica o `fd` do chunk fast bin de chunk5 apontando para `__malloc_hook`
* Em seguida, √© alocado um chunk de 0x68 para que o chunk fast bin falso em `__malloc_hook` seja o seguinte
* Por fim, um novo chunk fast bin de 0x68 √© alocado e `__malloc_hook` √© sobrescrito com um endere√ßo `one_gadget`

<details>

<summary><strong>Aprenda hacking AWS do zero ao hero com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
