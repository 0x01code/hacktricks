# Off by one overflow

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

其他支持HackTricks的方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github仓库提交PR来分享您的黑客技巧。**

</details>

## 基本信息

仅具有1B溢出访问权限的攻击者可以修改下一个块的`size`字段。这允许篡改实际释放的块，可能生成包含另一个合法块的块。利用类似于[双重释放](double-free.md)或重叠块。

有两种类型的off by one漏洞：

* 任意字节：这种类型允许用任何值覆盖该字节
* 空字节（off-by-null）：这种类型只允许用0x00覆盖该字节
* 这种漏洞的一个常见示例可以在以下代码中看到，其中`strlen`和`strcpy`的行为不一致，这允许在下一个块的开头设置一个0x00字节。
* 这可以利用[House of Einherjar](house-of-einherjar.md)。
* 如果使用Tcache，这可以被利用为[双重释放](double-free.md)情况。

<details>

<summary>Off-by-null</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

在其他检查之外，现在每当一个块被释放时，都会将前一个大小与元数据块中配置的大小进行比较，从2.28版本开始，这使得这种攻击变得相当复杂。

### 代码示例：

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* 由于使用了 Tcaches，此攻击不再起作用。
* 此外，如果尝试使用更大的块来滥用它（以便不涉及 tcaches），则会出现错误：`malloc(): invalid next size (unsorted)`

### 目标

* 使一个块被包含在另一个块内，因此对第二个块的写访问允许覆盖被包含的块

### 要求

* 利用 off-by-one 溢出来修改大小元数据信息

### 一般的 off-by-one 攻击

* 分配三个块 `A`、`B` 和 `C`（假设大小为 0x20），以及另一个块以防止与顶部块合并。
* 释放 `C`（插入到 0x20 Tcache 空闲列表中）。
* 使用块 `A` 对 `B` 进行溢出。滥用 off-by-one 将 `B` 的 `size` 字段从 0x21 修改为 0x41。
* 现在我们有 `B` 包含了空闲块 `C`
* 释放 `B` 并分配一个 0x40 块（它将再次放置在这里）
* 我们可以修改仍然空闲的 `C` 的 `fd` 指针（Tcache 毒化）

### Off-by-null 攻击

* 依次保留 3 个内存块（a、b、c）。然后释放中间的块。第一个包含一个 off by one 溢出漏洞，攻击者利用它使用 0x00（如果前一个字节是 0x10，则会使中间块指示它比实际小 0x10）。
* 然后，在中间释放的块（b）中分配了另外 2 个较小的块，但是由于 `b + b->size` 从未更新 c 块，因为指向的地址比应该的小。
* 然后，b1 和 c 被释放。由于 `c - c->prev_size` 仍然指向 b（现在是 b1），两者被合并为一个块。但是，b2 仍然在 b1 和 c 之间。
* 最后，执行新的 malloc 以重新获取这块内存区域，实际上将包含 b2，从而允许新 malloc 的所有者控制 b2 的内容。

这张图片完美解释了这次攻击：

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## 其他示例和参考资料

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* 由于 `strlen` 考虑到下一个块的 `size` 字段，发生 off-by-one。
* 正在使用 Tcache，因此一般的 off-by-one 攻击可用于通过 Tcache 毒化获得任意写入原语。
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* 可以滥用 off by one 来从堆中泄漏地址，因为字符串末尾的字节 0x00 被下一个字段覆盖。
* 通过滥用 off by one 写入来获得任意写入，使指针指向将构建具有虚假指针的虚假结构的另一个位置成为可能。然后，可以跟随此结构的指针以获得任意写入。
* 泄漏 libc 地址是因为如果使用 mmap 扩展堆，则由 mmap 分配的内存与 libc 有固定的偏移量。
* 最后，滥用任意写入将写入到 \_\_free\_hook 地址的一个单个小工具。
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* 在 `getline` 函数中存在一个 NULL off by one 漏洞，用于读取用户输入行。此函数用于读取内容的“键”，而不是内容。
* 在 writeup 中创建了 5 个初始块：
* chunk1（0x200）
* chunk2（0x50）
* chunk5（0x68）
* chunk3（0x1f8）
* chunk4（0xf0）
* chunk defense（0x400）以避免与顶部块合并
* 然后释放 chunk 1、5 和 3，因此：
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* 然后滥用 chunk3（0x1f8），滥用 null off-by-one 将 prev\_size 写入 `0x4e0`。
* 请注意，最初分配的 chunk1、2、5 和 3 的大小加上这些块的 4 个头部等于 `0x4e0`：`hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* 然后，释放 chunk 4，生成一个消耗所有块直到开头的块：
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* 然后，分配 `0x200` 字节填充原始块 1
* 然后分配另外 0x200 字节，破坏 chunk2，因此没有泄漏，这不起作用？也许不应该这样做
* 然后，分配一个具有 0x58 个“a”的块（覆盖 chunk2 并到达 chunk5），并修改指向 `__malloc_hook` 的快速 bin 块的 `fd`
* 然后，分配一个 0x68 的块，因此 `__malloc_hook` 中的虚假快速 bin 块是以下快速 bin 块
* 最后，分配一个新的 0x68 的快速 bin 块，并用 `one_gadget` 地址覆盖 `__malloc_hook`
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) **和** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **的 GitHub 存储库提交 PR 来分享您的黑客技巧。**
