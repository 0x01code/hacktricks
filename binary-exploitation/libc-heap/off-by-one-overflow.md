# オフバイワンオーバーフロー

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でAWSハッキングをゼロからヒーローまで学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** をフォローする。**
* **ハッキングトリックを共有するには、** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出してください。

</details>

## 基本情報

1バイトのオーバーフローへのアクセスだけで、攻撃者は次のチャンクの `size` フィールドを変更できます。これにより、実際に解放されるチャンクを改ざんし、別の正当なチャンクを含むチャンクを生成することが可能となります。この攻撃は [double free](double-free.md) やオーバーラップするチャンクと類似しています。

オフバイワンの脆弱性には2種類あります:

* 任意のバイト: この種類はそのバイトを任意の値で上書きできます
* ヌルバイト (off-by-null): この種類はそのバイトを 0x00 でのみ上書きできます
* この脆弱性の一般的な例は、`strlen` と `strcpy` の振る舞いが一貫していないコードで見られ、次のチャンクの先頭に 0x00 バイトを設定できることが可能です。
* これは [House of Einherjar](house-of-einherjar.md) で悪用できます。
* Tcache を使用している場合、これは [double free](double-free.md) の状況に活用できます。
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

### 目的

* チャンクを別のチャンクの中に含ませ、その2番目のチャンクへの書き込みアクセスを許可して含まれるものを上書きする

### 要件

* サイズメタデータ情報を変更するためのオフバイワンオーバーフロー

### 一般的なオフバイワン攻撃

* 3つのチャンク `A`、`B`、`C`（サイズ0x20とする）、およびトップチャンクとの統合を防ぐための別のチャンクを割り当てる。
* `C` を解放する（0x20 Tcache フリーリストに挿入）。
* チャンク `A` を使用して `B` にオーバーフローを発生させる。オフバイワンを悪用して `B` の `size` フィールドを0x21から0x41に変更する。
* これで `B` にはフリーチャンク `C` が含まれるようになります。
* `B` を解放し、0x40のチャンクを割り当てる（ここに再配置されます）。
* 依然としてフリーである `C` の `fd` ポインタを変更できます（Tcache 汚染）

### オフバイヌル攻撃

* 3つのメモリチャンク（a、b、c）が順番に予約されます。その後、中央のチャンクが解放されます。最初のチャンクにはオフバイワンオーバーフローの脆弱性があり、攻撃者はそれを0x00で悪用します（前のバイトが0x10であれば、中央のチャンクが実際よりも0x10小さいことを示します）。
* 次に、中央の解放されたチャンク（b）に2つのより小さいチャンク（b1、c）が割り当てられますが、`b + b->size` は c チャンクを更新しないため、指定されたアドレスが適切よりも小さいためです。
* 次に、b1 と c が解放されます。`c - c->prev_size` はまだ b（現在は b1）を指しているため、両方が1つのチャンクに統合されます。ただし、b2 はまだ b1 と c の間にあります。
* 最後に、このメモリ領域を再利用するために新しい malloc が実行され、これにより新しい malloc の所有者が b2 の内容を制御できるようになります。

この画像は攻撃を完璧に説明しています：

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## その他の例と参考文献

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Bon-nie-appetit. HTB Cyber Apocalypse CTF 2022**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/bon-nie-appetit/)
* `strlen` が次のチャンクの `size` フィールドを考慮しているため、オフバイワンが発生しています。
* Tcache が使用されているため、Tcache 汚染を使用して任意の書き込みプリミティブを取得するために一般的なオフバイワン攻撃が機能します。
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* オフバイワンを悪用してヒープからアドレスを漏洩させることが可能です。これは、文字列の末尾のバイト 0x00 が次のフィールドによって上書きされるためです。
* オフバイワンライトを悪用して、ポインタを別の場所を指すようにするために偽の構造体と偽のポインタが構築されます。その後、この構造体のポインタをたどることで任意の書き込みを取得できます。
* ヒープが mmap を使用して拡張されると、mmap によって割り当てられたメモリは libc から固定オフセットを持っていますので、libc アドレスが漏洩します。
* 最後に、任意の書き込みを悪用して、\_\_free\_hook のアドレスに one gadget を書き込みます。
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* ユーザー入力行を読み取る `getline` 関数には NULL オフバイワンの脆弱性があります。この関数はコンテンツの「キー」を読み取るために使用されます。
* 解説では、5つの初期チャンクが作成されます：
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400) トップチャンクとの統合を回避するため
* 次に、chunk 1、5、3 が解放されます：
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* 次に、chunk3 (0x1f8) を悪用して、null オフバイワンが悪用され、prev\_size が `0x4e0` に書き込まれます。
* 最初に割り当てられた chunk1、2、5、3 のサイズと、それらのチャンクのヘッダーの4つの合計が `0x4e0` に等しいことに注意してください：`hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* 次に、chunk 4 が解放され、すべてのチャンクを最初から消費するチャンクが生成されます：
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* 次に、`0x200` バイトが割り当てられ、元の chunk 1 が埋められます。
* そして、さらに0x200バイトが割り当てられ、chunk2 が破壊され、したがってリークはありませんし、これは機能しませんか？おそらくこれは行うべきではありません
* 次に、0x58の "a" で別のチャンクが割り当てられ（chunk2 を上書きし、chunk5 に到達）、chunk5 のファストビンチャンクの `fd` を `__malloc_hook` を指すように変更します。
* 次に、0x68のチャンクが割り当てられ、`__malloc_hook` の偽のファストビンチャンクが次のファストビンチャンクになります。
* 最後に、0x68の新しいファストビンチャンクが割り当てられ、`__malloc_hook` が `one_gadget` アドレスで上書きされます
* **[HackTricks](https://github.com/carlospolop/hacktricks)** および [HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを送信して、あなたのハッキングテクニックを共有してください。
