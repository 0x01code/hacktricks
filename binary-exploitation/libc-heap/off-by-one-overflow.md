# Prekoračenje za jedan bajt

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**Porodicu PEASS**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

Imajući samo pristup prekoračenju za jedan bajt, napadač može da izmeni bit `pre_in_use` sledećeg bloka, a kako trenutni blok neće biti u upotrebi, kraj bloka postaje informacija o veličini prethodnog bloka.\
Ovo omogućava manipulisanje blokovima koji su zapravo oslobođeni, potencijalno generišući blok koji sadrži drugi legitimni blok.

Postoje 2 vrste ranjivosti prekoračenja za jedan bajt:

* Proizvoljan bajt: Ova vrsta omogućava prepisivanje tog bajta sa bilo kojom vrednošću
* Null prekoračenje za jedan bajt: Ova vrsta omogućava prepisivanje tog bajta samo sa 0x00
* Čest primer ove ranjivosti može se videti u sledećem kodu gde je ponašanje funkcija strlen i strcpy nekonzistentno, što omogućava postavljanje bajta 0x00 na početku sledećeg bloka.

<details>

<summary>Null prekoračenje za jedan bajt</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Među ostalim proverama, sada kada je komad slobodan, prethodna veličina se upoređuje sa veličinom konfigurisanom u metapodacima komada, čineći ovaj napad prilično složenim od verzije 2.28.

### Primer koda:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Ovaj napad više ne funkcioniše zbog korišćenja Tcaches.
* Štaviše, ako pokušate da ga zloupotrebite koristeći veće komade (tako da Tcaches nisu uključene), dobićete grešku: `malloc(): invalid next size (unsorted)`

### Cilj

* Da se komad nalazi unutar drugog komada tako da pisanje pristupa nad tim drugim komadom omogućava prepisivanje sadržaja sadržanog komada

### Zahtevi

* Prekoračenje za jedan bajt kako bi se izmenile informacije o prethodnoj veličini metapodataka

### Napad

* Rezervisana su 3 komada memorije (a, b, c) jedan za drugim. Zatim se oslobađa srednji komad. Prvi komad sadrži ranjivost prekoračenja za jedan bajt i napadač je zloupotrebljava sa 0x00 (ako je prethodni bajt bio 0x10, to bi navelo srednji komad da pokaže da je za 0x10 manji nego što zaista jeste).
* Zatim se alociraju još 2 manja komada u oslobađenom srednjem komadu (b), međutim, pošto `b + b->size` nikada ne ažurira komad c jer je pokazana adresa manja nego što bi trebalo.&#x20;
* Zatim se b1 i c oslobađaju. Pošto `c - c->prev_size` i dalje pokazuje na b (sada b1), oba se konsoliduju u jedan komad. Međutim, b2 je i dalje unutar između b1 i c.
* Na kraju, vrši se nova alokacija memorije koja će zauzeti ovu oblast memorije koja će zapravo sadržati b2, omogućavajući vlasniku nove alokacije da kontroliše sadržaj b2.

Ova slika savršeno objašnjava napad:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Ostali primeri i reference

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* Moguće je zloupotrebiti prekoračenje za jedan bajt kako bi se procurela adresa iz hipa jer bajt 0x00 na kraju stringa biva prepisan sledećim poljem.
* Proizvoljno pisanje se dobija zloupotrebom prekoračenja za jedan bajt kako bi se pokazivač usmerio na drugo mesto gde će biti izgrađena lažna struktura sa lažnim pokazivačima. Zatim je moguće pratiti pokazivač ove strukture kako bi se dobilo proizvoljno pisanje.
* Adresa libc-a procuri jer ako se hip proširi korišćenjem mmap, memorija alocirana pomoću mmap ima fiksni odmak od libc-a.
* Na kraju se zloupotrebljava proizvoljno pisanje kako bi se pisalo na adresu \_\_free\_hook sa jednim gedžetom.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* Postoji NULL ranjivost za jedan bajt u funkciji `getline` koja čita linije korisničkog unosa. Ova funkcija se koristi za čitanje "ključa" sadržaja, a ne samog sadržaja.
* U objašnjenju se stvaraju 5 početnih komada:
* komad1 (0x200)
* komad2  (0x50)
* komad5 (0x68)
* komad3 (0x1f8)
* komad4 (0xf0)
* odbrambeni komad (0x400) kako bi se izbeglo konsolidovanje sa vršnim komadom
* Zatim se oslobađaju komadi 1, 5 i 3, tako da:
* ```python
[ 0x200 Komad 1 (slobodan) ] [ 0x50 Komad 2 ] [ 0x68 Komad 5 (slobodan) ] [ 0x1f8 Komad 3 (slobodan) ] [ 0xf0 Komad 4 ] [ 0x400 Odbrambeni komad ]
```
* Zatim se zloupotrebljava komad3 (0x1f8) zloupotrebom null prekoračenja za jedan bajt pisanjem prev\_size u `0x4e0`.
* Primetite kako veličine početno alociranih komada1, 2, 5 i 3 plus zaglavlja 4 tih komada iznose `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Zatim se oslobađa komad 4, generišući komad koji troši sve komade do početka:
* ```python
[ 0x4e0 Komad 1-2-5-3 (slobodan) ] [ 0xf0 Komad 4 (korumpiran) ] [ 0x400 Odbrambeni komad ]
```
* ```python
[ 0x200 Komad 1 (slobodan) ] [ 0x50 Komad 2 ] [ 0x68 Komad 5 (slobodan) ] [ 0x1f8 Komad 3 (slobodan) ] [ 0xf0 Komad 4 ] [ 0x400 Odbrambeni komad ]
```
* Zatim se alocira `0x200` bajtova popunjavajući originalni komad 1
* I alocira se još 0x200 bajtova i uništava se komad2 i stoga nema prokletog procurivanja i ovo ne funkcioniše? Možda ovo ne bi trebalo raditi
* Zatim se alocira još jedan komad sa 0x58 "a" (prepisanje komada2 i dostizanje komada5) i menja se `fd` brze binarne grupe komada komada5 usmeravajući ga ka `__malloc_hook`
* Zatim se alocira komad od 0x68 tako da je lažni brzi binarni komad u `__malloc_hook` sledeći brzi binarni komad
* Na kraju se alocira novi brzi binarni komad od 0x68 i `__malloc_hook` se prepisuje adresom `one_gadget`

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite svoju **kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJAVU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
