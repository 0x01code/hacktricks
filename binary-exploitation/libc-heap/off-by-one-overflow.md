# Sfioramento di un byte

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos di github.

</details>

## Informazioni di base

Avere solo accesso a un overflow di 1 byte consente a un attaccante di modificare il bit `pre_in_use` dal chunk successivo e poich√© il chunk corrente non sar√† in uso, la fine del chunk diventa l'informazione sui metadati della dimensione del chunk precedente.\
Ci√≤ consente di manipolare quali chunk vengono effettivamente liberati, generando potenzialmente un chunk che contiene un altro chunk legittimo.

Ci sono 2 tipi di vulnerabilit√† off by one:

* Byte arbitrario: Questo tipo consente di sovrascrivere quel byte con qualsiasi valore
* Null off by one: Questo tipo consente di sovrascrivere quel byte solo con 0x00
* Un esempio comune di questa vulnerabilit√† pu√≤ essere visto nel seguente codice in cui il comportamento di strlen e strcpy √® inconsistente, il che consente di impostare un byte 0x00 all'inizio del chunk successivo.

<details>

<summary>Null off by one</summary>
```c
// From https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off_by_one/
int main(void)
{
char buffer[40]="";
void *chunk1;
chunk1 = malloc(24);
puts("Get Input");
gets(buffer);
if(strlen(buffer)==24)
{
strcpy(chunk1,buffer);
}
return 0;
}
```
</details>

Tra gli altri controlli, ora ogni volta che un chunk viene liberato, la dimensione precedente viene confrontata con la dimensione configurata nel chunk dei metadati, rendendo questo attacco piuttosto complesso dalla versione 2.28.

### Esempio di Codice:

* [https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c](https://github.com/DhavalKapil/heap-exploitation/blob/d778318b6a14edad18b20421f5a06fa1a6e6920e/assets/files/shrinking\_free\_chunks.c)
* Questo attacco non funziona pi√π a causa dell'uso di Tcaches.
* Inoltre, se si cerca di abusarne utilizzando chunk pi√π grandi (cos√¨ che i tcaches non siano coinvolti), si otterr√† l'errore: `malloc(): invalid next size (unsorted)`

### Obiettivo

* Fare in modo che un chunk sia contenuto all'interno di un altro chunk in modo che l'accesso in scrittura su quel secondo chunk permetta di sovrascrivere quello contenuto

### Requisiti

* Overflow di uno in meno per modificare le informazioni sui metadati della dimensione precedente

### Attacco

* Vengono riservati 3 chunk di memoria (a, b, c) uno dopo l'altro. Poi quello centrale viene liberato. Il primo contiene una vulnerabilit√† di overflow di uno in meno e l'attaccante ne abusa con un 0x00 (se il byte precedente fosse 0x10 farebbe s√¨ che il chunk centrale indichi che √® pi√π piccolo di 0x10 di quanto non sia realmente).
* Successivamente, vengono allocati altri 2 chunk pi√π piccoli all'interno del chunk liberato al centro (b), tuttavia, poich√© `b + b->size` non aggiorna mai il chunk c perch√© l'indirizzo puntato √® pi√π piccolo di quanto dovrebbe essere.&#x20;
* Successivamente, b1 e c vengono liberati. Poich√© `c - c->prev_size` punta ancora a b (ora b1), entrambi vengono consolidati in un unico chunk. Tuttavia, b2 √® ancora all'interno tra b1 e c.
* Infine, viene eseguito un nuovo malloc per reclamare questa area di memoria che in realt√† conterr√† b2, consentendo al proprietario del nuovo malloc di controllare il contenuto di b2.

Questa immagine spiega perfettamente l'attacco:

<figure><img src="../../.gitbook/assets/image (1247).png" alt=""><figcaption><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks">https://heap-exploitation.dhavalkapil.com/attacks/shrinking_free_chunks</a></p></figcaption></figure>

## Altri Esempi e Riferimenti

* [**https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks**](https://heap-exploitation.dhavalkapil.com/attacks/shrinking\_free\_chunks)
* [**Asis CTF 2016 b00ks**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#1-asis-ctf-2016-b00ks)
* √à possibile abusare di un off by one per ottenere un leak di un indirizzo dalla heap perch√© il byte 0x00 alla fine di una stringa viene sovrascritto dal campo successivo.
* La scrittura arbitraria viene ottenuta abusando della scrittura off by one per far puntare il puntatore in un altro luogo dove verr√† costruita una struttura falsa con puntatori falsi. Quindi, √® possibile seguire il puntatore di questa struttura per ottenere una scrittura arbitraria.
* L'indirizzo della libc viene leakato perch√© se la heap viene estesa utilizzando mmap, la memoria allocata da mmap ha un offset fisso dalla libc.
* Infine, la scrittura arbitraria viene abusata per scrivere nell'indirizzo di \_\_free\_hook con un one gadget.
* [**plaidctf 2015 plaiddb**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/off\_by\_one/#instance-2-plaidctf-2015-plaiddb)
* C'√® una vulnerabilit√† NULL off by one nella funzione `getline` che legge le linee di input dell'utente. Questa funzione viene utilizzata per leggere la "chiave" del contenuto e non il contenuto.
* Nel writeup vengono creati 5 chunk iniziali:
* chunk1 (0x200)
* chunk2  (0x50)
* chunk5 (0x68)
* chunk3 (0x1f8)
* chunk4 (0xf0)
* chunk defense (0x400) per evitare la consolidazione con il chunk superiore
* Poi vengono liberati i chunk 1, 5 e 3, quindi:
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Poi abusando del chunk3 (0x1f8) viene abusato il null off-by-one scrivendo il prev\_size a `0x4e0`.
* Notare come le dimensioni dei chunk inizialmente allocati chunk1, 2, 5 e 3 pi√π gli header di 4 di quei chunk equivalgono a `0x4e0`:  `hex(0x1f8 + 0x10 + 0x68 + 0x10 + 0x50 + 0x10 + 0x200) = 0x4e0`
* Poi, il chunk 4 viene liberato, generando un chunk che consuma tutti i chunk fino all'inizio:
* ```python
[ 0x4e0 Chunk 1-2-5-3 (free) ] [ 0xf0 Chunk 4 (corrupted) ] [ 0x400 Chunk defense ]
```
* ```python
[ 0x200 Chunk 1 (free) ] [ 0x50 Chunk 2 ] [ 0x68 Chunk 5 (free) ] [ 0x1f8 Chunk 3 (free) ] [ 0xf0 Chunk 4 ] [ 0x400 Chunk defense ]
```
* Poi, vengono allocati `0x200` byte riempiendo il chunk originale 1
* E altri 0x200 byte vengono allocati e il chunk2 viene distrutto e quindi non c'√® alcun leak e questo non funziona? Forse questo non dovrebbe essere fatto
* Poi, vengono allocati altri chunk con 0x58 "a" (sovrascrivendo chunk2 e raggiungendo chunk5) e si modifica il `fd` del fast bin chunk di chunk5 facendolo puntare a `__malloc_hook`
* Poi, viene allocato un chunk di 0x68 in modo che il fake fast bin chunk in `__malloc_hook` sia il successivo fast bin chunk
* Infine, viene allocato un nuovo fast bin chunk di 0x68 e `__malloc_hook` viene sovrascritto con un indirizzo `one_gadget`

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la **tua azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
