# Heap Oorloop

<details>

<summary><strong>Leer AWS hak vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Basiese Inligting

'n Heap oorloop is soos 'n [**stapel oorloop**](../stack-overflow/) maar in die heap. Dit beteken basies dat 'n spasie in die heap gereserveer was om data te stoor en **die gestoorde data was groter as die gereserveerde spasie.**

In stapeloorlope weet ons dat sekere registers soos die instruksie-aanwyser of die stapelraam van die stapel herstel gaan word en dit moontlik is om dit te misbruik. In die geval van heap oorlope, **word daar nie enige sensitiewe inligting standaard in die heapstuk gestoor wat oorloop kan word nie.** Dit kan egter sensitiewe inligting of aanwysers wees, dus die **kritikaliteit** van hierdie kwesbaarheid **hang af** van **watter data oorskryf kan word** en hoe 'n aanvaller dit kan misbruik.

{% hint style="success" %}
Om oorloopafsette te vind, kan jy dieselfde patrone gebruik as in [**stapeloorlope**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stapeloorlope vs Heapoorlope

In stapeloorlope is die rangskikking en data wat teenwoordig gaan wees in die stapel op die oomblik wanneer die kwesbaarheid geaktiveer kan word, redelik betroubaar. Dit is omdat die stapel line√™r is, altyd toeneem in botsende geheue, in **spesifieke plekke van die program hardloop die stapelgeheue gewoonlik soortgelyke data** en dit het 'n spesifieke struktuur met 'n paar aanwysers aan die einde van die stapelgedeelte wat deur elke funksie gebruik word.

In die geval van 'n heap oorloop is die gebruikte geheue nie line√™r nie, maar **toegewysde stukke is gewoonlik in afsonderlike posisies van geheue** (nie een langs die ander nie) as gevolg van **bins en sones** wat toewysings volgens grootte skei en omdat **vorige vrygemaakte geheue gebruik word** voordat nuwe stukke toegewys word. Dit is **ingewikkeld om die voorwerp te ken wat met die een wat vatbaar is vir 'n heap oorloop gaan bots**. Dus, wanneer 'n heap oorloop gevind word, moet 'n **betroubare manier gevind word om die gewenste voorwerp volgende in geheue te maak** van die een wat oorloop kan word.

Een van die tegnieke wat hiervoor gebruik word, is **Heap Grooming** wat byvoorbeeld gebruik word [**in hierdie pos**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). In die pos word verduidelik hoe wanneer in die iOS-kernel 'n sone uit geheue hardloop om stukke geheue te stoor, dit uitgebrei word met 'n kernbladsy, en hierdie bladsy word verdeel in stukke van die verwagte groottes wat in orde gebruik sou word (tot iOS weergawe 9.2, dan word hierdie stukke op 'n willekeurige manier gebruik om die uitbuiting van hierdie aanvalle te bemoeilik).

Daarom, in die vorige pos waar 'n heap oorloop plaasvind, moet daar 'n manier wees om die oorgeloopde voorwerp te dwing om met 'n slagofferorde te bots, verskeie **`kallocs` word gedwing deur verskeie drade om te probeer verseker dat al die vrye stukke gevul is en dat 'n nuwe bladsy geskep word**.

Om hierdie vulling met voorwerpe van 'n spesifieke grootte te dwing, is die **uitlyn-toewysing wat verband hou met 'n iOS mach-poort** 'n ideale kandidaat. Deur die grootte van die boodskap te skep, is dit moontlik om presies die grootte van `kalloc` toewysing te spesifiseer en wanneer die ooreenstemmende mach-poort vernietig word, sal die ooreenstemmende toewysing dadelik terug na `kfree` vrygestel word.

Dan kan sommige van hierdie plekhouers **vrygestel** word. Die **`kalloc.4096` vrylys vrylaat elemente in 'n laaste-in-eerste-uit-orde**, wat basies beteken dat as sommige plekhouers vrygemaak word en die aanval probeer om verskeie slagoffer voorwerpe toe te ken terwyl dit probeer om die voorwerp vatbaar vir oorloop toe te ken, is dit waarskynlik dat hierdie voorwerp deur 'n slagoffer voorwerp gevolg sal word.

### Voorbeeld libc

[**Op hierdie bladsy**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) is dit moontlik om 'n basiese Heap oorloop-emulasie te vind wat wys hoe om die vorig in gebruik bit van die volgende stuk oor te skryf en die posisie van die vorige grootte is dit moontlik om **'n gebruikte stuk te konsolideer** (deur dit te laat dink dit is ongebruik) en **dit dan weer toe te ken** en sodoende data oor te skryf wat in 'n ander aanwyser ook gebruik word.

'n Ander voorbeeld van [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) wys 'n baie basiese voorbeeld van 'n CTF waar 'n **heap oorloop** misbruik kan word om die wennerfunksie te roep om **die vlag te kry**.

In die [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) voorbeeld is dit moontlik om te sien hoe 'n buffer oorloop misbruik kan word om **in 'n nabygele√´ stuk 'n adres oor te skryf** waar **willekeurige data van die gebruiker** geskryf gaan word.

### Voorbeeld ARM64

Op die bladsy [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) kan jy 'n voorbeeld van 'n heap oorloop vind waar 'n bevel wat uitgevoer gaan word in die volgende stuk vanaf die oorgeloopde stuk gestoor word. Dus, dit is moontlik om die uitgevoerde bevel te wysig deur dit met 'n maklike uitbuiting oor te skryf soos:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Ander voorbeelde

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Ons gebruik 'n Integer Overflow kwesbaarheid om 'n Heap Overflow te kry.
* Ons beskadig aanwysers na 'n funksie binne 'n `struct` van die oorloop stuk om 'n funksie soos `system` in te stel en kode-uitvoering te kry.
