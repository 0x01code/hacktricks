# Heap Overflow

{% hint style="success" %}
Lernen Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
{% endhint %}

## Grundlegende Informationen

Ein Heap Overflow ist wie ein [**Stack Overflow**](../stack-overflow/), aber im Heap. Grunds√§tzlich bedeutet dies, dass im Heap etwas Platz reserviert wurde, um einige Daten zu speichern, und **die gespeicherten Daten gr√∂√üer waren als der reservierte Platz**.

Bei Stack Overflows wissen wir, dass einige Register wie der Instruktionszeiger oder der Stackrahmen vom Stapel wiederhergestellt werden und es m√∂glich sein k√∂nnte, dies auszunutzen. Im Falle von Heap Overflows **wird standardm√§√üig keine sensible Information** im Heap-Chunk gespeichert, der √ºberlaufen werden kann. Es k√∂nnte jedoch sensible Informationen oder Zeiger geben, sodass die **Kritikalit√§t** dieser Schwachstelle davon abh√§ngt, **welche Daten √ºberschrieben werden k√∂nnen** und wie ein Angreifer dies ausnutzen k√∂nnte.

{% hint style="success" %}
Um √úberlauf-Offsets zu finden, k√∂nnen Sie dieselben Muster wie bei [**Stack Overflows**](../stack-overflow/#finding-stack-overflows-offsets) verwenden.
{% endhint %}

### Stack Overflows vs. Heap Overflows

Bei Stack Overflows ist die Anordnung und die Daten, die zum Zeitpunkt auftreten, an dem die Schwachstelle ausgel√∂st werden kann, im Stapel ziemlich zuverl√§ssig. Dies liegt daran, dass der Stapel linear ist, sich immer in kollidierendem Speicher erh√∂ht, an **spezifischen Stellen des Programmablaufs der Stapelspeicher normalerweise √§hnliche Daten speichert** und eine spezifische Struktur mit einigen Zeigern am Ende des Stapelteils hat, die von jeder Funktion verwendet werden.

Im Falle eines Heap Overflows ist der verwendete Speicher jedoch nicht linear, sondern **die allokierten Chunks befinden sich normalerweise an getrennten Speicherpositionen** (nicht nebeneinander), aufgrund von **Bins und Zonen**, die Allokationen nach Gr√∂√üe trennen, und weil **zuvor freigegebener Speicher verwendet wird**, bevor neue Chunks allokiert werden. Es ist **kompliziert zu wissen, welches Objekt mit dem √ºberlaufenden Objekt kollidieren wird**. Wenn also ein Heap Overflow gefunden wird, muss ein **zuverl√§ssiger Weg gefunden werden, um das gew√ºnschte Objekt so zu platzieren, dass es im Speicher direkt neben dem √ºberlaufenden Objekt liegt**.

Eine der Techniken, die daf√ºr verwendet wird, ist **Heap Grooming**, die beispielsweise [**in diesem Beitrag**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) verwendet wird. Im Beitrag wird erkl√§rt, wie im iOS-Kernel, wenn eine Zone keinen Speicher mehr hat, um Speicherbl√∂cke zu speichern, sie um eine Kernelseite erweitert wird, und diese Seite in Chunks der erwarteten Gr√∂√üen aufgeteilt wird, die in aufeinanderfolgender Reihenfolge verwendet werden (bis iOS-Version 9.2, dann werden diese Chunks auf eine randomisierte Weise verwendet, um die Ausnutzung dieser Angriffe zu erschweren).

Daher, in dem vorherigen Beitrag, in dem ein Heap Overflow auftritt, werden mehrere **`kallocs` durch mehrere Threads erzwungen, um sicherzustellen, dass alle freien Chunks gef√ºllt sind und eine neue Seite erstellt wird**.

Um diese F√ºllung mit Objekten einer bestimmten Gr√∂√üe zu erzwingen, ist die **Out-of-Line-Allokation, die mit einem iOS-Mach-Port verbunden ist**, ein idealer Kandidat. Durch die Gestaltung der Gr√∂√üe der Nachricht ist es m√∂glich, die Gr√∂√üe der `kalloc`-Allokation genau anzugeben, und wenn der entsprechende Mach-Port zerst√∂rt wird, wird die entsprechende Allokation sofort an `kfree` zur√ºckgegeben.

Dann k√∂nnen einige dieser Platzhalter **freigegeben** werden. Die **`kalloc.4096`-Freiliste gibt Elemente in einer Last-In-First-Out-Reihenfolge frei**, was im Grunde bedeutet, dass wenn einige Platzhalter freigegeben werden und der Exploit versucht, mehrere Opferobjekte zu allozieren, w√§hrend er versucht, das Objekt, das anf√§llig f√ºr √úberlauf ist, zu allozieren, ist es wahrscheinlich, dass dieses Objekt von einem Opferobjekt gefolgt wird.

### Beispiel libc

[**Auf dieser Seite**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) ist es m√∂glich, eine grundlegende Emulation eines Heap Overflows zu finden, die zeigt, wie durch √úberschreiben des prev-in-use-Bits des n√§chsten Chunks und der Position der prev-Gr√∂√üe ein benutzter Chunk **konsolidiert werden kann** (indem er denkt, er sei unbenutzt) und dann erneut allokiert werden kann, wodurch Daten √ºberschrieben werden, die in einem anderen Zeiger verwendet werden.

Ein weiteres Beispiel aus [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) zeigt ein sehr einfaches Beispiel eines CTF, bei dem ein **Heap Overflow** missbraucht werden kann, um die Gewinnerfunktion aufzurufen und die Flagge zu erhalten.

Im [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) Beispiel ist zu sehen, wie durch Ausnutzen eines Puffer√ºberlaufs es m√∂glich ist, **in einem nahegelegenen Chunk eine Adresse zu √ºberschreiben**, an die **beliebige Daten vom Benutzer** geschrieben werden sollen.

### Beispiel ARM64

Auf der Seite [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) finden Sie ein Beispiel f√ºr einen Heap Overflow, bei dem ein Befehl, der ausgef√ºhrt werden soll, im folgenden Chunk vom √ºberlaufenen Chunk gespeichert ist. Daher ist es m√∂glich, den ausgef√ºhrten Befehl zu √§ndern, indem er mit einem einfachen Exploit √ºberschrieben wird, wie z.B.:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Weitere Beispiele

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Wir nutzen eine Integer-√úberlauf-Schwachstelle, um einen Heap-√úberlauf zu erhalten.
* Wir manipulieren Zeiger auf eine Funktion innerhalb einer `struct` des √ºberlaufenden Chunks, um eine Funktion wie `system` festzulegen und Codeausf√ºhrung zu erhalten.

{% hint style="success" %}
Lernen Sie & √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
{% endhint %}
