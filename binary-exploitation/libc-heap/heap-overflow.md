# Heap Oorloop

<details>

<summary><strong>Leer AWS hak vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Basiese Inligting

'n Heap oorloop is soos 'n [**stapel oorloop**](../stack-overflow/) maar in die heap. Dit beteken basies dat 'n sekere spasie in die heap gereserveer was om data te stoor en **die gestoorde data was groter as die gereserveerde spasie.**

In stapeloorlope weet ons dat sekere registers soos die instruksie-aanwyser of die stapelraam van die stapel herstel gaan word en dit moontlik misbruik kan word. In die geval van heap oorlope **word daar nie enige sensitiewe inligting standaard in die heapstuk gestoor** wat oorloop kan word nie. Dit kan egter sensitiewe inligting of aanwysers wees, dus die **kritikaliteit** van hierdie kwesbaarheid **hang af** van **watter data oorskryf kan word** en hoe 'n aanvaller dit kan misbruik.

{% hint style="success" %}
Om oorloopafsette te vind, kan jy dieselfde patrone gebruik as in [**stapeloorlope**](../stack-overflow/#finding-stack-overflows-offsets).
{% endhint %}

### Stapeloorlope vs Heapoorlope

In stapeloorlope is die rangskikking en data wat teenwoordig gaan wees in die stapel op die oomblik wanneer die kwesbaarheid geaktiveer kan word, redelik betroubaar. Dit is omdat die stapel line√™r is, altyd toeneem in botsende geheue, in **spesifieke plekke van die program hardloop die stapelgeheue gewoonlik soortgelyke data** en dit het 'n spesifieke struktuur met 'n paar aanwysers aan die einde van die stapelgedeelte wat deur elke funksie gebruik word.

In die geval van 'n heap oorloop, omdat die gebruikte geheue nie line√™r is nie maar **toegewysde stukke is gewoonlik in afsonderlike posisies van geheue** (nie een langs die ander nie) as gevolg van **bins en sones** wat toewysings volgens grootte skei en omdat **vorige vrygemaakte geheue gebruik word** voordat nuwe stukke toegewys word. Dit is **ingewikkeld om die voorwerp te ken wat met die een wat vatbaar is vir 'n heap oorloop gaan bots**. Dus, wanneer 'n heap oorloop gevind word, moet 'n **betroubare manier gevind word om te verseker dat die gewenste voorwerp volgende in die geheue is** van die een wat oorloop kan word.

Een van die tegnieke wat hiervoor gebruik word, is **Heap Grooming** wat byvoorbeeld gebruik word [**in hierdie pos**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). In die pos word verduidelik hoe wanneer in die iOS-kernel 'n sone uit geheue raak om stukke geheue te stoor, dit uitgebrei word met 'n kernbladsy, en hierdie bladsy word in stukke van die verwagte groottes verdeel wat in orde gebruik sou word (tot iOS weergawe 9.2, dan word hierdie stukke op 'n willekeurige manier gebruik om die uitbuiting van hierdie aanvalle te bemoeilik).

Daarom, in die vorige pos waar 'n heap oorloop plaasvind, moet daar 'n manier wees om die oorvloeiende voorwerp te dwing om met 'n slagofferorde te bots, verskeie **`kallocs` word gedwing deur verskeie drade om te verseker dat al die vrye stukke gevul is en dat 'n nuwe bladsy geskep word**.

Om hierdie vulling met voorwerpe van 'n spesifieke grootte te dwing, is die **uitlyn-toewysing wat verband hou met 'n iOS mach-poort** 'n ideale kandidaat. Deur die grootte van die boodskap te skep, is dit moontlik om presies die grootte van `kalloc` toewysing te spesifiseer en wanneer die ooreenstemmende mach-poort vernietig word, sal die ooreenstemmende toewysing dadelik terug na `kfree` vrygestel word.

Dan kan sommige van hierdie plekhouers **vrygestel** word. Die **`kalloc.4096` vrylys vry elemente in 'n laaste-in-eerste-uit-orde**, wat basies beteken dat as sommige plekhouers vrygestel word en die aanval probeer om verskeie slagoffer-voorwerpe toe te ken terwyl die voorwerp wat vatbaar is vir oorloop toegewys word, is dit waarskynlik dat hierdie voorwerp deur 'n slagoffer-voorwerp gevolg sal word.

### Voorbeeld libc

[**Op hierdie bladsy**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) is dit moontlik om 'n basiese Heap oorloop-emulasie te vind wat wys hoe om die vorig in gebruik bit van die volgende stuk en die posisie van die vorige grootte te oorskryf, dit moontlik is om 'n gebruikte stuk te **konsolideer** (deur dit te laat dink dit is ongebruik) en dit dan weer toe te ken en data te oorskryf wat in 'n ander aanwyser gebruik word.

'n Ander voorbeeld van [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) wys 'n baie basiese voorbeeld van 'n CTF waar 'n **heap oorloop** misbruik kan word om die wennerfunksie te roep om die vlag te **kry**.

In die [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) voorbeeld is dit moontlik om te sien hoe 'n bufferoorloop misbruik kan word om **in 'n nabygele√´ stuk 'n adres oor te skryf** waar **willekeurige data van die gebruiker** geskryf gaan word.

### Voorbeeld ARM64

Op die bladsy [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) kan jy 'n voorbeeld van 'n heap oorloop vind waar 'n bevel wat uitgevoer gaan word in die volgende stuk vanaf die oorvloeiende stuk gestoor word. Dus, dit is moontlik om die uitgevoerde bevel te wysig deur dit met 'n maklike uitbuiting oor te skryf soos:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
