# Heap Taşması

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile</strong>!</summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

Bir heap taşması, heap'te bir [**yığın taşması**](../stack-overflow/) gibi. Temelde, heap'te belirli bir veriyi depolamak için bir alan ayrılmış ve **depolanan veri ayrılan alandan daha büyük olmuş.**

Yığın taşmalarında, yığından bazı kayıtların (örneğin yönlendirme işaretçisi veya yığın çerçevesi) geri yükleneceğini ve bunun istismar edilebileceğini biliyoruz. Heap taşmalarında ise, taşınabilecek bir **duyarlı bilgi varsayılan olarak** heap parçasında depolanmaz. Bununla birlikte, hassas bilgi veya işaretçiler olabilir, bu nedenle bu zafiyetin **kritikliği**, bu zafiyetten **hangi verilerin üzerine yazılabileceğine** ve bir saldırganın bunu nasıl istismar edebileceğine bağlıdır.

{% hint style="success" %}
Taşma ofsetlerini bulmak için [**yığın taşmalarında**](../stack-overflow/#finding-stack-overflows-offsets) olduğu gibi aynı desenleri kullanabilirsiniz.
{% endhint %}

### Yığın Taşmaları vs. Heap Taşmaları

Yığın taşmalarında, zafiyet tetiklendiğinde yığında bulunan düzen ve veriler oldukça güvenilirdir. Bu, yığının lineer olması, her zaman çarpışan bellekte artması, programın belirli yerlerinde yığın belleğinin genellikle benzer türde verileri depolaması ve her işlevin kullandığı yığın kısmının sonunda bazı işaretçilerle belirli bir yapıya sahip olması nedeniyledir.

Ancak, bir heap taşması durumunda, kullanılan bellek lineer değildir, ancak **ayrılmış pozisyonlarda genellikle ayrılmış parçalar** (yan yana olmayan) vardır çünkü boyuta göre ayrımları ayıran **kutular ve bölgeler** ve **önceki serbest bırakılan bellek** yeni parçalar ayrılmadan önce kullanılır. Bir heap taşması bulunduğunda, taşan nesnenin hafızadaki istenen nesnenin yanında olmasını sağlayacak **güvenilir bir yol bulunması gerekir**.

Bunun için kullanılan tekniklerden biri **Heap Grooming**dir ve örneğin [**bu yazıda**](https://azeria-labs.com/grooming-the-ios-kernel-heap/) kullanılmaktadır. Yazıda, iOS çekirdeğinde bir bölgenin bellekteki bellek parçalarını depolamak için hafızasının tükendiği durumda, bir çekirdek sayfasıyla genişletildiği ve bu sayfanın beklenen boyutlardaki parçalara bölündüğü ve bunların sırayla kullanılacağı açıklanmaktadır (iOS sürüm 9.2'ye kadar, ardından bu parçaların bu saldırıların zorlaştırılması için rastgele bir şekilde kullanıldığı).

Bu nedenle, bir heap taşması gerçekleştiğinde, taşan nesnenin bir kurban sırayla çarpışmasını zorlamak için birkaç **`kalloc`** tarafından zorlanır ve tüm boş parçaların doldurulduğundan ve yeni bir sayfa oluşturulduğundan emin olunmaya çalışılır.

Belirli bir boyuttaki nesnelerle bu doldurmayı zorlamak için, **iOS mach port ile ilişkilendirilmiş dış hattan tahsis** ideal bir adaydır. Mesajın boyutunu şekillendirerek, `kalloc` tahsisinin boyutunu tam olarak belirlemek mümkündür ve karşılık gelen mach portu yok edildiğinde, karşılık gelen tahsis hemen `kfree`'ye geri bırakılacaktır.

Ardından, bu yer tutuculardan bazıları **serbest bırakılabilir**. **`kalloc.4096` serbest listesi, öğeleri son giren ilk çıkan düzeninde serbest bırakır**, bu da temelde bazı yer tutucuların serbest bırakıldığında ve saldırganın taşmaya duyarlı nesneyi ayırmaya çalışırken birkaç kurban nesne tahsis etmeye çalışırken, bu nesnenin bir kurban nesneyi takip edeceği olasılığının yüksek olduğu anlamına gelir.

### Örnek libc

[**Bu sayfada**](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) bir temel Heap taşması emülasyonu bulunabilir. Bir sonraki parçanın kullanımdaki önceki bitini ve önceki boyutun konumunu değiştirerek, kullanılan bir parçayı **birleştirmek mümkündür** (kullanılmadığına inandırarak) ve ardından tekrar tahsis edilerek farklı bir işaretçide kullanılan verilerin üzerine yazılabilir.

[**Protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) örneğinde, bir **heap taşmasının** bayrağı **almak için** kullanılabileceği bir CTF'nin çok temel bir örneği gösterilir.

[**Protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) örneğinde, bir tampon taşmasının istismar edilerek, **kullanıcının gireceği keyfi verilerin yazılacağı bir adrese** yakın bir parçada **üzerine yazılması mümkün olabilir**.

### Örnek ARM64

[https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) sayfasında, bir komutun taşan parçadan bir sonraki parçada depolandığı bir heap taşması örneği bulunabilir. Bu nedenle, basit bir saldırı ile komutun üzerine yazılarak yürütülecek komut değiştirilebilir.
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Diğer örnekler

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Bir Tamsayı Taşma zafiyetini kullanarak Bir Yığın Taşması elde ediyoruz.
* Taşan parçanın içindeki bir `struct`'ın işaretçilerini bozarak bir işlevi `system` gibi bir işlev olarak ayarlıyoruz ve kod yürütme elde ediyoruz.

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
