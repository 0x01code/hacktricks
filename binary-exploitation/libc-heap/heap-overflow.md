# Kujaa kwa Heap

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

Kujaa kwa heap ni kama [**kujaa kwa steki**](../stack-overflow/) lakini kwenye heap. Kimsingi inamaanisha kuwa nafasi fulani ilireserviwa kwenye heap kuhifadhi data fulani na **data iliyohifadhiwa ilikuwa kubwa kuliko nafasi iliyoreserviwa.**

Kwenye kujaa kwa steki tunajua kwamba baadhi ya rejista kama kipima maelekezo au fremu ya steki itarejeshwa kutoka kwenye steki na inaweza kuwa inawezekana kuitumia vibaya hii. Kwenye kujaa kwa heap, **hakuna habari nyeti iliyohifadhiwa kwa chaguo-msingi** kwenye kipande cha heap kinachoweza kujaa. Hata hivyo, inaweza kuwa habari nyeti au pointa, hivyo **umuhimu** wa udhaifu huu **unategemea** ni **data gani inaweza kubadilishwa** na jinsi mshambuliaji anaweza kutumia hii.

{% hint style="success" %}
Ili kupata vishikizo vya kujaa unaweza kutumia mifano ile ile kama kwenye [**kujaa kwa steki**](../stack-overflow/#kupata-vishikizo-vya-kujaa-kwa-steki).
{% endhint %}

### Kujaa kwa Steki vs Kujaa kwa Heap

Kwenye kujaa kwa steki, upangaji na data ambayo itakuwepo kwenye steki wakati udhaifu unaweza kuzinduliwa ni wa kuaminika kwa kiasi kikubwa. Hii ni kwa sababu steki ni mstari, daima unazidi katika kumbukumbu inayogongana, kwenye **maeneo maalum ya kukimbia kwa programu kumbukumbu ya steki kawaida huhifadhi aina sawa ya data** na ina muundo maalum na pointa fulani mwishoni mwa sehemu ya steki inayotumiwa na kila kazi.

Hata hivyo, kwenye kujaa kwa heap, kumbukumbu inayotumiwa sio mstari lakini **vipande vilivyotengwa kawaida viko katika nafasi tofauti za kumbukumbu** (sio moja karibu na nyingine) kwa sababu ya **makorongo na maeneo** yanayotenganisha ugawaji kwa ukubwa na kwa sababu **kumbukumbu iliyotolewa hapo awali inatumika** kabla ya kutenga vipande vipya. Ni **ngumu kujua kitu ambacho kitagongana na kile kilichovunjika** kwa kujaa kwa heap. Kwa hivyo, unapopata kujaa kwa heap, ni muhimu kupata njia **ya kuaminika ya kufanya kitu kilichotaka kiwe kifuatacho kwenye kumbukumbu** kutoka kile kinachoweza kujaa.

Moja ya mbinu zinazotumika kwa hili ni **Kupamba kwa Heap** ambayo hutumiwa kwa mfano [**kwenye chapisho hili**](https://azeria-labs.com/grooming-the-ios-kernel-heap/). Katika chapisho hilo inaelezea jinsi wakati wa kernel wa iOS unapokosa kumbukumbu ya kuhifadhi vipande vya kumbukumbu, inapanua kwa ukurasa wa kernel, na ukurasa huu unagawanywa katika vipande vya ukubwa uliotarajiwa ambavyo vitatumika kwa mpangilio (hadi toleo la iOS 9.2, kisha vipande hivi hutumiwa kwa njia iliyochanganyikiwa ili kufanya ugunduzi wa mashambulizi haya kuwa mgumu).

Kwa hivyo, kwenye chapisho la awali ambapo kujaa kwa heap inatokea, ili kulazimisha kitu kilichovunjika kigongane na mpangaji, **`kallocs` kadhaa zinalazimishwa na nyuzi kadhaa kujaribu kuhakikisha kuwa vipande vyote vilivyotolewa vimejazwa na ukurasa mpya unatengenezwa**.

Ili kulazimisha kujazwa na vitu vya ukubwa maalum, **ugawaji wa nje wa kuhusishwa na mlango wa iOS mach** ni mgombea bora. Kwa kutengeneza ukubwa wa ujumbe, inawezekana kubainisha kwa usahihi ukubwa wa ugawaji wa `kalloc` na wakati mlango wa mach unaohusiana unapoharibiwa, ugawaji unaohusiana utarejeshwa mara moja kwa `kfree`.

Kisha, baadhi ya hizi nafasi zinaweza **kuachiliwa**. **Orodha ya kufungua ya `kalloc.4096` inaweka vipengee kwa mpangilio wa mwisho kuingia kwanza**, ambayo kimsingi inamaanisha kwamba ikiwa baadhi ya nafasi zimeachiliwa na shambulizi linajaribu kuweka vitu vingi waathiriwa wakati ikijaribu kutenga kitu kilichovunjika, ni uwezekano kwamba kitu hiki kitafuatwa na kitu waathiriwa.

### Mfano wa libc

[Kwenye ukurasa huu](https://guyinatuxedo.github.io/27-edit\_free\_chunk/heap\_consolidation\_explanation/index.html) inawezekana kupata uigaji wa kujaa kwa Heap wa msingi unaonyesha jinsi ya kubadilisha biti ya awali inayotumiwa ya kipande kinachofuata na nafasi ya ukubwa wa awali inawezekana **kuunganisha kipande kilichotumiwa** (kwa kufanya ionekane kama haijatumika) na **kisha kutenga tena** ikiwa inawezekana kubadilisha data inayotumiwa kwenye pointa tofauti pia.

Mfano mwingine kutoka [**protostar heap 0**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap0/index.html) unaonyesha mfano wa msingi sana wa CTF ambapo **kujaa kwa heap** inaweza kutumiwa kuita kazi ya mshindi kupata **bendera**.

Kwenye [**protostar heap 1**](https://guyinatuxedo.github.io/24-heap\_overflow/protostar\_heap1/index.html) mfano inawezekana kuona jinsi ya kutumia kujaa kwa buffer inawezekana **kubadilisha kwenye kipande karibu anwani** ambapo **data ya kupindukia kutoka kwa mtumiaji** itaandikwa.

### Mfano wa ARM64

Kwenye ukurasa [https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/](https://8ksec.io/arm64-reversing-and-exploitation-part-1-arm-instruction-set-simple-heap-overflow/) unaweza kupata mfano wa kujaa kwa heap ambapo amri itakayotekelezwa imehifadhiwa kwenye kipande kinachofuata kutoka kwenye kipande kilichojaa. Kwa hivyo, inawezekana kubadilisha amri inayotekelezwa kwa kuiandika upya kwa shambulizi rahisi kama vile:
```bash
python3 -c 'print("/"*0x400+"/bin/ls\x00")' > hax.txt
```
### Mifano mingine

* [**Auth-or-out. Hack The Box**](https://7rocky.github.io/en/ctf/htb-challenges/pwn/auth-or-out/)
* Tunatumia udhaifu wa Kuzidisha Kwa Nambari ya Integer kupata Kujazwa kwa Heap.
* Tunaharibu pointa kwa kazi ndani ya `struct` ya kipande kilichojazwa ili kuweka kazi kama vile `system` na kupata utekelezaji wa nambari.
