# Shambulio la Benki Isiyopangwa

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Taarifa Msingi

Kwa habari zaidi kuhusu ni nini benki isiyopangwa angalia ukurasa huu:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Orodha zisizopangwa zinaweza kuandika anwani kwa `unsorted_chunks (av)` kwenye anwani ya `bk` ya kipande. Kwa hivyo, ikiwa mshambuliaji anaweza **kurekebisha anwani ya kielekezi cha `bk`** katika kipande ndani ya benki isiyopangwa, anaweza kuwa na uwezo wa **kuandika anwani hiyo kwenye anwani isiyojulikana** ambayo inaweza kusaidia kuvuja anwani ya Glibc au kuepuka ulinzi fulani.

Kwa hivyo, kimsingi, shambulio hili linaruhusu **kuweka nambari kubwa kwenye anwani isiyojulikana**. Nambari kubwa hii ni anwani, ambayo inaweza kuwa anwani ya rundo au anwani ya Glibc. Lengo la kawaida ni **`global_max_fast`** kuruhusu kuunda benki za haraka zenye saizi kubwa (na kupita kutoka shambulio la benki isiyopangwa hadi shambulio la benki ya haraka).

{% hint style="success" %}
Kwa kuangalia mfano uliotolewa katika [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) na kutumia 0x4000 na 0x5000 badala ya 0x400 na 0x500 kama saizi za vipande (kuepuka Tcache) inawezekana kuona kwamba **leo** kosa **`malloc(): unsorted double linked list corrupted`** linasababishwa.

Kwa hivyo, shambulio la benki isiyopangwa sasa (miongoni mwa ukaguzi mwingine) pia inahitaji kuweza kurekebisha orodha iliyodoubli ili hii ipuuzwe `victim->bk->fd == victim` au sivyo `victim->fd == av (arena)`, ambayo inamaanisha kwamba anwani ambapo tunataka kuandika lazima iwe na anwani ya kipande bandia katika nafasi yake ya `fd` na kwamba kipande bandia `fd` inaelekeza kwenye uwanja.
{% endhint %}

{% hint style="danger" %}
Tafadhali kumbuka kuwa shambulio hili linaharibu benki isiyopangwa (hivyo ndogo na kubwa pia). Kwa hivyo tunaweza **kutumia vipangi kutoka kwa benki ya haraka sasa** (programu yenye utata zaidi inaweza kufanya vipangi vingine na kugonga), na kuzindua hii tunapaswa **kutenga saizi sawa au programu itaanguka.**

Tafadhali kumbuka kwamba kubadilisha **`global_max_fast`** kunaweza kusaidia katika kesi hii kwa kuamini kwamba benki ya haraka itaweza kushughulikia vipangi vingine vyote hadi kudukua kukamilika.
{% endhint %}

Msimbo kutoka [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) unaelezea vizuri, ingawa ikiwa utabadilisha mallocs kuweka kumbukumbu kubwa ya kutosha ili isimalize kwenye Tcache unaweza kuona kosa lililotajwa hapo awali linalozuia mbinu hii: **`malloc(): unsorted double linked list corrupted`**

## Shambulio la Kuvuja Taarifa la Benki Isiyopangwa

Hii ni dhana ya msingi sana. Vipande katika benki isiyopangwa vitakuwa na viunganishi. Kipande cha kwanza katika benki isiyopangwa kimsingi kitakuwa na viungo vya **`fd`** na **`bk`** **vinaelekeza sehemu ya uwanja mkuu (Glibc)**.\
Kwa hivyo, ikiwa unaweza **kuweka kipande ndani ya benki isiyopangwa na kusoma** (tumia baada ya kufuta) au **kuipanga tena bila kubadilisha angalau 1 ya viunganishi** kisha **kusoma** hiyo, unaweza kupata **uvujaji wa taarifa ya Glibc**.

[**Shambulio linalotumiwa katika andiko hili**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), lilikuwa kutumia muundo wa vipande 4 (A, B, C na D - D ni kuzuia konsolidisheni na kipande cha juu) hivyo kuzidi kwa herufi sifuri katika B kulitumika kufanya C ionyeshe kuwa B haikutumiwa. Pia, katika B data ya `prev_size` ilibadilishwa ili saizi badala ya kuwa saizi ya B iwe A+B.\
Kisha C ilifutwa, na konsolidisheni na A+B (lakini B ilikuwa bado inatumika). Kipande kipya cha saizi ya A kilipangiwa na kisha anwani zilizovuja za libc ziliandikwa kwenye B kutoka ambapo zilivuja.

## Marejeo & Mifano Nyingine

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Lengo ni kubadilisha kigezo la jumla na thamani kubwa kuliko 4869 ili iwezekane kupata bendera na PIE haipo.
* Inawezekana kuzalisha vipande vya saizi za kiholela na kuna kovu la rundo na saizi inayotakiwa.
* Shambulio linaanza kwa kuunda vipande 3: kipande0 kutumia kovu, kipande1 kufanyiwa kovu na kipande2 ili kuzuia konsolidisheni na vipande vilivyotangulia.
* Kisha, kipande1 kinafutwa na kipande0 kinafanyiwa kovu kwenye kielekezi cha `bk` cha kipande1 kinachoelekeza: `bk = magic - 0x10`
* Kisha, kipande3 kinapangiwa saizi sawa na kipande1, ambacho kitazindua shambulio la benki isiyopangwa na kurekebisha thamani ya kigezo la jumla, kuruhusu kupata bendera.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Kazi ya kufunga ina mapungufu kwa sababu ikiwa viashiria vyote viwili vilivyopitishwa ni sawa itarealloc juu yake na kisha kuifuta lakini kurudisha kielekezi kwa eneo hilo lililofutwa ambalo linaweza kutumika.
* Kwa hivyo, **vipande 2 vinavyoundwa**: **kipande0** ambacho kitafungwa na yenyewe na kipande1 kuzuia konsolidisheni na kipande cha juu. Kisha, **kazi ya kufunga inaitwa na kipande0** mara mbili ambayo itasababisha matumizi baada ya kufuta.
* Kisha, **kazi ya `view`** inaitwa na index 2 (ambayo ni index ya kipande baada ya kutumia baada ya kufuta), ambayo ita **vujisha anwani ya libc**.
* Kwa kuwa binary ina ulinzi wa kutoa malloc tu saizi kubwa kuliko **`global_max_fast`** hivyo hakuna fastbin inatumika, shambulio la benki isiyopangwa litatumika kurekebisha kigezo cha jumla `global_max_fast`.
* Kisha, inawezekana kuita kazi ya hariri na index 2 (kielekezi baada ya kutumia baada ya kufuta) na kubadilisha kielekezi cha `bk` kuonyesha `p64(global_max_fast-0x10)`. Kisha, kuunda kipande kipya kutatumia kielekezi kilichofutwa hapo awali (0x20) kutazindua shambulio la benki isiyopangwa kurekebisha `global_max_fast` na thamani kubwa sana, kuruhusu sasa kuunda vipande katika benki za haraka.
* Sasa shambulio la **benki ya haraka** linatekelezwa:
* Kwanza kabisa inagundulika kwamba inawezekana kufanya kazi na **vipande vya haraka vya saizi 200** kwenye eneo la **`__free_hook`**:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Ikiwa tutafanikiwa kupata kipande cha haraka cha ukubwa wa 0x200 katika eneo hili, itakuwa inawezekana kubadilisha pointer ya kazi ambayo itatekelezwa
* Kwa hili, kipande kipya cha ukubwa wa `0xfc` hujengwa na kazi iliyochanganywa huitwa mara mbili na pointer hiyo, njia hii tunapata pointer kwa kipande kilichofutwa cha ukubwa wa `0xfc*2 = 0x1f8` katika bakuli la haraka.
* Kisha, kazi ya kuhariri inaitwa katika kipande hiki kurekebisha anwani ya **`fd`** ya bakuli hili la haraka ili ielekee kwenye kazi ya awali ya **`__free_hook`**.
* Kisha, kipande chenye ukubwa wa `0x1f8` hujengwa ili kupata kutoka kwa bakuli la haraka kipande kisichofaa cha awali hivyo kipande kingine cha ukubwa wa `0x1f8` hujengwa ili kupata kipande cha bakuli la haraka katika **`__free_hook`** ambayo inabadilishwa na anwani ya kazi ya **`system`**.
* Na hatimaye kipande kinachohifadhi string `/bin/sh\x00` huru kwa kuita kazi ya kufuta, kuzindua kazi ya **`__free_hook`** ambayo inaelekeza kwa mfumo na `/bin/sh\x00` kama parameter.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Mfano mwingine wa kutumia kipeperushi cha 1B kufanya kipande cha unsorted bin na kupata libc infoleak na kisha kufanya shambulio la bakuli la haraka kubadilisha kitanzi cha malloc na anwani ya one gadget
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Tunaweza tu kutenga vipande vya ukubwa zaidi ya `0x100`.
* Badilisha `global_max_fast` kwa kutumia shambulio la Unsorted Bin (inafanya kazi 1/16 ya wakati kutokana na ASLR, kwa sababu tunahitaji kurekebisha bits 12, lakini lazima tuweke bits 16).
* Shambulio la Fast Bin kubadilisha safu ya kimataifa ya vipande. Hii hutoa msingi wa kusoma/ku
