# Unsorted Bin Attack

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 처음부터 전문가까지 배우세요!</strong></summary>

HackTricks를 지원하는 다른 방법:

- **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- 여러분의 해킹 기술을 공유하려면 [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소로 PR을 제출하세요.

</details>

## 기본 정보

unsorted bin이 무엇인지에 대한 자세한 정보는 다음 페이지를 참조하세요:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

정렬되지 않은 목록은 `unsorted_chunks (av)`의 주소를 청크의 `bk` 주소에 쓸 수 있습니다. 따라서, 공격자가 정렬되지 않은 bin 내부의 청크에서 `bk` 포인터의 주소를 **수정할 수 있다면**, 임의의 주소에 해당 주소를 쓸 수 있게 되어 Glibc 주소를 노출하거나 일부 방어를 우회하는 데 도움이 될 수 있습니다.

따라서, 기본적으로 이 공격은 **임의의 주소에 큰 숫자를 설정**할 수 있게 합니다. 이 큰 숫자는 힙 주소 또는 Glibc 주소일 수 있습니다. 전형적인 대상은 **`global_max_fast`**이며, 이를 통해 더 큰 크기의 빠른 bin bin을 생성할 수 있게 되어 정렬되지 않은 bin 공격에서 빠른 bin 공격으로 전환할 수 있습니다.

{% hint style="success" %}
[https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle)에서 제공된 예제를 살펴보고 0x400과 0x500 대신에 0x4000과 0x5000을 사용하여 (Tcache를 피하기 위해) **현재** 오류 **`malloc(): unsorted double linked list corrupted`**가 트리거되는 것을 볼 수 있습니다.

따라서, 이제 이 정렬되지 않은 bin 공격은 (다른 확인 사항과 함께) 또한 `victim->bk->fd == victim` 또는 `victim->fd == av (arena)`로 이중 링크드 리스트를 수정할 수 있어야 하므로, 쓰고자 하는 주소는 가짜 청크의 `fd` 위치에 가짜 청크의 `fd`가 아레나를 가리키도록 있어야 합니다.
{% endhint %}

{% hint style="danger" %}
이 공격은 정렬되지 않은 bin을 손상시킵니다 (따라서 작은 bin과 큰 bin도 손상됨). 따라서 이제 **이제 빠른 bin에서 할당만 사용할 수 있습니다** (더 복잡한 프로그램은 다른 할당을 수행하고 충돌할 수 있음) 및 이를 트리거하려면 **동일한 크기로 할당해야 합니다.**

**`global_max_fast`**를 덮어쓰면 빠른 bin이 모든 다른 할당을 처리할 수 있을 것이라는 믿음을 가지고 이 문제를 해결할 수 있습니다.
{% endhint %}

[**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html)의 코드는 이를 매우 잘 설명하지만, malloc을 수정하여 Tcache에 끝나지 않도록 충분히 큰 메모리를 할당하면 이전에 언급한 오류가 발생하여 이 기술을 방지하는 것을 볼 수 있습니다: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak Attack

이것은 실제로 매우 기본적인 개념입니다. 정렬되지 않은 bin의 청크에는 포인터가 있습니다. 정렬되지 않은 bin의 첫 번째 청크는 실제로 **`fd`** 및 **`bk`** 링크가 **주요 아레나(Glibc)의 일부를 가리킵니다**.\
따라서, **unsorted bin에 청크를 넣고** (사용 후 해제) **읽거나** 다시 **할당하여 적어도 1개의 포인터를 덮어쓰지 않고** 그 후 **읽으면**, **Glibc 정보 누출**을 얻을 수 있습니다.

이 [**글에서 사용된 공격**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html)은 4개의 청크 구조 (A, B, C 및 D - D는 상단 청크와의 통합을 방지하기 위한 것)를 남용하여 B의 널 바이트 오버플로우를 사용하여 C가 B가 사용되지 않았음을 나타내도록 만들었습니다. 또한, B에서 `prev_size` 데이터가 수정되어 B의 크기가 B의 크기가 아닌 A+B가 되었습니다.\
그런 다음 C가 해제되고 A+B와 통합되었지만 B는 여전히 사용 중이었습니다. 크기 A의 새로운 청크가 할당되고 그런 다음 libc 유출 주소가 B로 쓰여져 유출되었습니다.

## 참고 및 다른 예제

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* 글로벌 변수를 4869보다 큰 값으로 덮어쓰기 위한 목표이며, PIE가 활성화되지 않았습니다.
* 임의의 크기의 청크를 생성하고 원하는 크기의 힙 오버플로우가 있습니다.
* 공격은 3개의 청크를 생성하여 시작됩니다: 오버플로우를 남용하기 위한 청크0, 오버플로우될 청크1 및 이전 청크들이 통합되지 않도록 하는 청크2.
* 그런 다음, 청크1이 해제되고 청크0이 오버플로우되어 `bk` 포인터가 `bk = magic - 0x10`를 가리키도록 합니다.
* 그런 다음, 청크3이 청크1과 동일한 크기로 할당되어 정렬되지 않은 bin 공격을 트리거하고 글로벌 변수의 값을 수정하여 플래그를 획득할 수 있게 합니다.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* 병합 함수는 두 인덱스가 동일한 경우 다시 할당하고 그 후에 해제하지만 그 해제된 영역을 가리키는 포인터를 반환할 수 있습니다.
* 따라서, **2개의 청크가 생성**되며, **자신과 병합될 청크0**과 상단 청크와의 통합을 방지하기 위한 청크1이 생성됩니다. 그런 다음, **청크0으로 병합 함수가 두 번 호출**되어 사용 후 해제가 발생합니다.
* 그런 다음, **`view`** 함수가 사용 후 해제된 청크의 인덱스인 2로 호출되어 **libc 주소를 누출**합니다.
* 바이너리가 **`global_max_fast`**보다 큰 크기의 malloc만 허용하는 보호를 가지고 있기 때문에 fastbin을 사용하지 않으므로 정렬되지 않은 bin 공격이 사용되어 **global_max_fast를 덮어쓰기** 위해 사용됩니다.
* 그런 다음, 사용 후 해제 포인터인 인덱스 2로 편집 함수를 호출하여 `bk` 포인터를 `p64(global_max_fast-0x10)`을 가리키도록 덮어쓰고, 이전에 손상된 해제 주소(0x20)를 사용하여 **정렬되지 않은 bin 공격**을 트리거하여 `global_max_fast`를 덮어쓰고 이제 빠른 bin에서 청크를 생성할 수 있게 합니다.
* 이제 **빠른 bin 공격**이 수행됩니다:
* 먼저 **`__free_hook` 위치에 크기 200의 빠른 청크**를 사용할 수 있다는 것을 발견합니다:
* <pre class="language-c"><code class="lang-c">gef➤  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef➤  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* 만약 이 위치에 크기가 0x200인 fast chunk를 얻을 수 있다면 실행될 함수 포인터를 덮어쓸 수 있을 것입니다.
* 이를 위해 크기가 `0xfc`인 새로운 청크가 생성되고 해당 포인터로 두 번 병합 함수가 호출되어 `0xfc*2 = 0x1f8` 크기의 해제된 청크에 대한 포인터를 얻습니다.
* 그런 다음, 이 청크에서 **`fd`** 주소를 이전 **`__free_hook`** 함수를 가리키도록 수정하기 위해 편집 함수가 호출됩니다.
* 그런 다음, 크기가 `0x1f8`인 청크가 생성되어 이전에 쓸모없는 청크를 fast bin에서 검색하여 **`__free_hook`**에 있는 다른 청크를 얻기 위해 크기가 `0x1f8`인 또 다른 청크가 생성됩니다. 이는 **`system`** 함수의 주소로 덮어쓰입니다.
* 마지막으로 `/bin/sh\x00` 문자열을 포함하는 청크가 삭제 함수를 호출하여 해제되고, **`__free_hook`** 함수가 트리거되어 `/bin/sh\x00`을 매개변수로 하는 **`system`** 함수를 가리킵니다.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* 언소트된 bin에서 청크를 통합하고 libc 정보 누출을 수행한 다음 fast bin 공격을 수행하여 malloc 후크를 원 갓젯 주소로 덮어쓰는 예제
* [**로봇 공장. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* 우리는 크기가 `0x100`보다 큰 청크만 할당할 수 있습니다.
* Unsorted Bin 공격을 사용하여 `global_max_fast`를 덮어쓰기 (ASLR로 인해 1/16의 확률로 작동, 12비트를 수정해야 하지만 16비트를 수정해야 함).
* 글로벌 배열의 청크를 수정하기 위한 Fast Bin 공격. 이는 임의의 읽기/쓰기 기본 기능을 제공하며, GOT를 수정하고 일부 함수를 `system`으로 지정할 수 있게 합니다.
