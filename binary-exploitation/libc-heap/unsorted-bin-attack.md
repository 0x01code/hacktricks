# Unsorted Bin Attack

{% hint style="success" %}
Lernen Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
{% endhint %}

## Grundlegende Informationen

F√ºr weitere Informationen dar√ºber, was ein unsortierter Bin ist, √ºberpr√ºfen Sie diese Seite:

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

Unsortierte Listen k√∂nnen die Adresse zu `unsorted_chunks (av)` in der `bk`-Adresse des Chunks schreiben. Daher kann ein Angreifer, wenn er die Adresse des `bk`-Zeigers in einem Chunk im unsortierten Bin **√§ndern kann**, in der Lage sein, **diese Adresse an eine beliebige Adresse zu schreiben**, was hilfreich sein k√∂nnte, um Glibc-Adressen zu leaken oder einige Verteidigungen zu umgehen.

Also erm√∂glicht dieser Angriff im Grunde genommen, **eine gro√üe Zahl an einer beliebigen Adresse zu setzen**. Diese gro√üe Zahl ist eine Adresse, die eine Heap-Adresse oder eine Glibc-Adresse sein k√∂nnte. Ein typisches Ziel ist **`global_max_fast`**, um die Erstellung von Fast-Bin-Bins mit gr√∂√üeren Gr√∂√üen zu erm√∂glichen (und von einem unsortierten Bin-Angriff zu einem Fast-Bin-Angriff √ºberzugehen).

{% hint style="success" %}
Wenn Sie sich das Beispiel unter [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#principle) ansehen und 0x4000 und 0x5000 anstelle von 0x400 und 0x500 als Chunk-Gr√∂√üen verwenden (um Tcache zu vermeiden), k√∂nnen Sie sehen, dass heutzutage der Fehler **`malloc(): unsorted double linked list corrupted`** ausgel√∂st wird.

Daher erfordert dieser unsortierte Bin-Angriff jetzt (unter anderen √úberpr√ºfungen) auch, dass die doppelt verkettete Liste korrigiert werden kann, sodass dies umgangen wird `victim->bk->fd == victim` oder nicht `victim->fd == av (arena)`, was bedeutet, dass die Adresse, an der wir schreiben m√∂chten, die Adresse des gef√§lschten Chunks an ihrer `fd`-Position haben muss und dass der gef√§lschte Chunk `fd` auf die Arena zeigt.
{% endhint %}

{% hint style="danger" %}
Beachten Sie, dass dieser Angriff den unsortierten Bin besch√§digt (daher auch klein und gro√ü). Daher k√∂nnen wir jetzt nur noch **Zuweisungen aus dem Fast-Bin verwenden** (ein komplexeres Programm k√∂nnte andere Zuweisungen durchf√ºhren und abst√ºrzen), und um dies auszul√∂sen, m√ºssen wir **die gleiche Gr√∂√üe zuweisen, oder das Programm wird abst√ºrzen**.

Beachten Sie, dass das √úberschreiben von **`global_max_fast`** in diesem Fall hilfreich sein k√∂nnte, in der Annahme, dass der Fast-Bin in der Lage sein wird, sich um alle anderen Zuweisungen zu k√ºmmern, bis das Exploit abgeschlossen ist.
{% endhint %}

Der Code von [**guyinatuxedo**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/unsorted\_explanation/index.html) erkl√§rt dies sehr gut, obwohl, wenn Sie die mallocs so √§ndern, dass sie Speicher in ausreichender Gr√∂√üe zuweisen, sodass sie nicht in einem Tcache enden, k√∂nnen Sie sehen, dass der zuvor erw√§hnte Fehler auftritt und diese Technik verhindert: **`malloc(): unsorted double linked list corrupted`**

## Unsorted Bin Infoleak-Angriff

Dies ist eigentlich ein sehr grundlegendes Konzept. Die Chunks im unsortierten Bin werden Zeiger haben. Der erste Chunk im unsortierten Bin wird tats√§chlich die **`fd`**- und **`bk`**-Links haben, die auf einen Teil der Hauptarena (Glibc) zeigen.\
Daher, wenn Sie **einen Chunk in einen unsortierten Bin platzieren und ihn lesen** k√∂nnen (use after free) oder **ihn erneut zuweisen, ohne mindestens 1 der Zeiger zu √ºberschreiben**, um ihn dann **zu lesen**, k√∂nnen Sie ein **Glibc-Infoleak** haben.

Ein √§hnlicher [**Angriff, der in diesem Write-up verwendet wurde**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw18\_alienVSsamurai/index.html), bestand darin, eine 4-Chunks-Struktur (A, B, C und D - D diente nur dazu, eine Konsolidierung mit dem Top-Chunk zu verhindern) zu missbrauchen, sodass ein Null-Byte-√úberlauf in B verwendet wurde, um C anzuzeigen, dass B nicht verwendet wurde. Au√üerdem wurde in B die Daten `prev_size` ge√§ndert, sodass die Gr√∂√üe anstelle der Gr√∂√üe von B A+B war.\
Dann wurde C deallokiert und mit A+B konsolidiert (aber B war immer noch in Benutzung). Es wurde ein neuer Chunk der Gr√∂√üe A allokiert, und dann wurden die geleakten Adressen von libc in B geschrieben, von wo aus sie geleakt wurden.

## Referenzen & Weitere Beispiele

* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/unsorted\_bin\_attack/#hitcon-training-lab14-magic-heap)
* Das Ziel besteht darin, eine globale Variable mit einem Wert gr√∂√üer als 4869 zu √ºberschreiben, um die Flagge zu erhalten, wobei PIE nicht aktiviert ist.
* Es ist m√∂glich, Chunks beliebiger Gr√∂√üe zu generieren, und es gibt einen Heap-√úberlauf mit der gew√ºnschten Gr√∂√üe.
* Der Angriff beginnt mit der Erstellung von 3 Chunks: Chunk0, um den √úberlauf zu missbrauchen, Chunk1, um √ºberlaufen zu werden, und Chunk2, damit der Top-Chunk die vorherigen nicht konsolidiert.
* Dann wird Chunk1 freigegeben und Chunk0 wird √ºberlaufen, sodass der `bk`-Zeiger von Chunk1 auf `bk = magic - 0x10` zeigt.
* Anschlie√üend wird Chunk3 mit derselben Gr√∂√üe wie Chunk1 allokiert, was den unsortierten Bin-Angriff ausl√∂st und den Wert der globalen Variablen √§ndert, sodass es m√∂glich ist, die Flagge zu erhalten.
* [**https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html**](https://guyinatuxedo.github.io/31-unsortedbin\_attack/0ctf16\_zerostorage/index.html)
* Die Merge-Funktion ist anf√§llig, da sie, wenn beide √ºbergebenen Indizes gleich sind, darauf reallociert und dann freigegeben wird, aber einen Zeiger auf diesen freigegebenen Bereich zur√ºckgibt, der verwendet werden kann.
* Daher werden **2 Chunks erstellt**: **Chunk0**, der mit sich selbst zusammengef√ºhrt wird, und Chunk1, um eine Konsolidierung mit dem Top-Chunk zu verhindern. Dann wird die **Merge-Funktion zweimal mit Chunk0** aufgerufen, was zu einem Use-after-Free f√ºhrt.
* Dann wird die **`view`**-Funktion mit Index 2 aufgerufen (der Index des Use-after-Free-Chunks), was eine libc-Adresse **leakt**.
* Da das Bin√§rprogramm Schutzmechanismen hat, um nur Gr√∂√üen gr√∂√üer als **`global_max_fast`** zu allozieren, sodass kein Fastbin verwendet wird, wird ein unsortierter Bin-Angriff verwendet, um die globale Variable `global_max_fast` zu √ºberschreiben.
* Dann ist es m√∂glich, die Edit-Funktion mit dem Index 2 (dem Use-after-Free-Zeiger) aufzurufen und den `bk`-Zeiger so zu √ºberschreiben, dass er auf `p64(global_max_fast-0x10)` zeigt. Anschlie√üend wird durch das Erstellen eines neuen Chunks die zuvor kompromittierte freie Adresse (0x20) verwendet, um den unsortierten Bin-Angriff auszul√∂sen und das `global_max_fast` zu √ºberschreiben, wobei ein sehr gro√üer Wert erreicht wird, der es nun erm√∂glicht, Chunks in Fast-Bins zu erstellen.
* Nun wird ein **Fast-Bin-Angriff** durchgef√ºhrt:
* Zun√§chst wird festgestellt, dass es m√∂glich ist, mit schnellen **Chunks der Gr√∂√üe 200** am Speicherort **`__free_hook`** zu arbeiten:
* <pre class="language-c"><code class="lang-c">gef‚û§  p &#x26;__free_hook
$1 = (void (**)(void *, const void *)) 0x7ff1e9e607a8 &#x3C;__free_hook>
gef‚û§  x/60gx 0x7ff1e9e607a8 - 0x59
<strong>0x7ff1e9e6074f: 0x0000000000000000      0x0000000000000200
</strong>0x7ff1e9e6075f: 0x0000000000000000      0x0000000000000000
0x7ff1e9e6076f &#x3C;list_all_lock+15>:      0x0000000000000000      0x0000000000000000
0x7ff1e9e6077f &#x3C;_IO_stdfile_2_lock+15>: 0x0000000000000000      0x0000000000000000
</code></pre>
* Wenn es uns gelingt, einen schnellen Chunk der Gr√∂√üe 0x200 an dieser Stelle zu erhalten, wird es m√∂glich sein, einen Funktionszeiger zu √ºberschreiben, der ausgef√ºhrt wird.
* Daf√ºr wird ein neuer Chunk der Gr√∂√üe `0xfc` erstellt und die zusammengef√ºhrte Funktion wird zweimal mit diesem Zeiger aufgerufen, auf diese Weise erhalten wir einen Zeiger auf einen freigegebenen Chunk der Gr√∂√üe `0xfc*2 = 0x1f8` im schnellen Bin.
* Dann wird die Edit-Funktion in diesem Chunk aufgerufen, um die **`fd`**-Adresse dieses schnellen Bins so zu √§ndern, dass sie auf die vorherige **`__free_hook`**-Funktion zeigt.
* Anschlie√üend wird ein Chunk der Gr√∂√üe `0x1f8` erstellt, um aus dem schnellen Bin den vorherigen nutzlosen Chunk abzurufen, sodass ein weiterer Chunk der Gr√∂√üe `0x1f8` erstellt wird, um einen schnellen Bin-Chunk im **`__free_hook`** zu erhalten, der mit der Adresse der **`system`**-Funktion √ºberschrieben wird.
* Und schlie√ülich wird ein Chunk mit dem String `/bin/sh\x00` freigegeben, indem die L√∂schfunktion aufgerufen wird, die die **`__free_hook`**-Funktion ausl√∂st, die auf system mit `/bin/sh\x00` als Parameter zeigt.
* **CTF** [**https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html**](https://guyinatuxedo.github.io/33-custom\_misc\_heap/csaw19\_traveller/index.html)
* Ein weiteres Beispiel f√ºr die Ausnutzung eines 1B-√úberlaufs, um Chunks im unsortierten Bin zu konsolidieren und eine libc-Infoleak zu erhalten und dann einen schnellen Bin-Angriff durchzuf√ºhren, um den malloc-Hook mit einer One-Gadget-Adresse zu √ºberschreiben
* [**Robot Factory. BlackHat MEA CTF 2022**](https://7rocky.github.io/en/ctf/other/blackhat-ctf/robot-factory/)
* Wir k√∂nnen nur Chunks der Gr√∂√üe gr√∂√üer als `0x100` zuweisen.
* √úberschreiben Sie `global_max_fast` mithilfe eines Unsorted Bin-Angriffs (funktioniert 1/16 Mal aufgrund von ASLR, da wir 12 Bits √§ndern m√ºssen, aber 16 Bits √§ndern m√ºssen).
* Schneller Bin-Angriff, um ein globales Array von Chunks zu √§ndern. Dies erm√∂glicht ein beliebiges Lese-/Schreib-Primitive, mit dem das GOT ge√§ndert und eine Funktion so eingestellt werden kann, dass sie auf `system` zeigt.

{% hint style="success" %}
Lernen & √ºben Sie AWS-Hacking:<img src="/.gitbook/assets/arte.png" alt="" data-size="line">[**HackTricks Training AWS Red Team Expert (ARTE)**](https://training.hacktricks.xyz/courses/arte)<img src="/.gitbook/assets/arte.png" alt="" data-size="line">\
Lernen & √ºben Sie GCP-Hacking: <img src="/.gitbook/assets/grte.png" alt="" data-size="line">[**HackTricks Training GCP Red Team Expert (GRTE)**<img src="/.gitbook/assets/grte.png" alt="" data-size="line">](https://training.hacktricks.xyz/courses/grte)

<details>

<summary>Unterst√ºtzen Sie HackTricks</summary>

* √úberpr√ºfen Sie die [**Abonnementpl√§ne**](https://github.com/sponsors/carlospolop)!
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
{% endhint %}
