# 强制之屋



<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我们 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 基本信息

### 代码

* 这种技术已被修补（[**在此处**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)），并产生此错误：`malloc(): corrupted top size`
* 您可以尝试[**这里的代码**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)进行测试。

### 目标

* 此攻击的目标是能够在特定地址分配一个块。

### 要求

* 允许覆盖顶部块头部大小（例如-1）的溢出。
* 能够控制堆分配的大小

### 攻击

如果攻击者想要在地址P中分配一个块以覆盖这里的值。他首先通过将顶部块大小覆盖为`-1`（可能通过溢出）来开始。这确保了malloc不会为任何分配使用mmap，因为顶部块始终有足够的空间。

然后，计算顶部块地址和目标空间之间的距离以进行分配。这是因为将以该大小执行malloc以将顶部块移动到该位置。这就是差异/大小可以轻松计算的方式：
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
因此，分配大小为`target - old_top - 4*sizeof(long)`（4个long是因为顶部块和分配时新块的元数据）将移动顶部块到我们想要覆盖的地址。\
然后，再次执行malloc以获取一个包含要写入目标地址开头的数据的块。

### 参考资料和其他示例

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* 本场景的目标是ret2win，需要修改将被调用的函数地址为ret2win函数的地址
* 二进制文件存在一个溢出，可以被滥用以修改顶部块的大小，修改为-1或p64(0xffffffffffffffff)
* 然后，计算要覆盖的指针存在的位置的地址，并从当前顶部块的位置到那里的差异被`malloc`分配
* 最后，分配一个新的块，其中包含将被ret2win函数覆盖的所需目标
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* 在`Input your name:`中存在一个初始漏洞，允许从堆中泄漏一个地址
* 然后在`Org:`和`Host:`功能中，当要求**org name**时，可以填充`s`指针的64B，堆栈中跟随`v2`地址，然后跟随指定的**host name**。然后，由于strcpy将把s的内容复制到大小为64B的块中，因此可以使用**host name**中放入的数据**覆盖顶部块的大小**。
* 现在具有任意写入权限，`atoi`的GOT被覆盖为printf的地址。可以使用`%24$p`泄漏`IO_2_1_stderr`的地址。有了这个libc泄漏，就可以再次用`system`的地址覆盖`atoi`的GOT，并调用它传递参数`/bin/sh`
* 另一种方法[在这篇其他文章中提出](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud)，是将`free`覆盖为`puts`，然后将`atoi@got`的地址添加到稍后将被释放的指针中，以便泄漏，然后使用此泄漏再次将`atoi@got`覆盖为`system`并调用它传递`/bin/sh`。
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* 存在UAF允许重用未清除指针的已释放块。由于存在一些读取方法，因此可以在这里将指针写入GOT中的free函数以泄漏libc地址，然后调用读取函数。
* 然后，使用House of force（滥用UAF）覆盖左侧空间的大小为-1，分配足够大的块以到达free hook，然后分配另一个包含free hook的块。然后，在hook中写入`system`的地址，在一个块中写入`"/bin/sh"`，最后释放包含该字符串内容的块。
