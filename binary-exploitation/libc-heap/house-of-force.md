# House of Force

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

## Grundlegende Informationen

### Code

* Diese Technik wurde gepatcht ([**hier**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c)) und f√ºhrt zu diesem Fehler: `malloc(): corrupted top size`
* Sie k√∂nnen den [**Code von hier**](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html) ausprobieren, um ihn zu testen, wenn Sie m√∂chten.

### Ziel

* Das Ziel dieses Angriffs ist es, einen Chunk an einer bestimmten Adresse zu allozieren.

### Anforderungen

* Ein √úberlauf, der es erm√∂glicht, die Gr√∂√üe des Top-Chunk-Headers zu √ºberschreiben (z. B. -1).
* Die F√§higkeit, die Gr√∂√üe der Heap-Allokation zu kontrollieren

### Angriff

Wenn ein Angreifer einen Chunk an der Adresse P allozieren m√∂chte, um einen Wert hier zu √ºberschreiben, beginnt er damit, die Top-Chunk-Gr√∂√üe mit `-1` zu √ºberschreiben (vielleicht mit einem √úberlauf). Dadurch wird sichergestellt, dass malloc keine mmap f√ºr eine beliebige Allokation verwendet, da der Top-Chunk immer gen√ºgend Platz haben wird.

Berechnen Sie dann den Abstand zwischen der Adresse des Top-Chunks und dem Zielraum zur Allokation. Dies liegt daran, dass eine malloc mit dieser Gr√∂√üe durchgef√ºhrt wird, um den Top-Chunk an diese Position zu verschieben. So kann der Unterschied/die Gr√∂√üe leicht berechnet werden:
```c
// From https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c#L59C2-L67C5
/*
* The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):
* new_top = old_top + nb
* nb = new_top - old_top
* req + 2sizeof(long) = new_top - old_top
* req = new_top - old_top - 2sizeof(long)
* req = target - 2sizeof(long) - old_top - 2sizeof(long)
* req = target - old_top - 4*sizeof(long)
*/
```
Daher wird durch die Allokation einer Gr√∂√üe von `Ziel - old_top - 4*sizeof(long)` (die 4 longs sind aufgrund der Metadaten des Top-Chunks und des neuen Chunks, wenn allokiert) der Top-Chunk an die Adresse verschoben, die wir √ºberschreiben m√∂chten.\
Dann wird ein weiteres malloc durchgef√ºhrt, um einen Chunk zu erhalten, der die am Anfang der Daten zu schreibende Zieladresse enth√§lt.

### Referenzen & Weitere Beispiele

* [https://github.com/shellphish/how2heap/tree/master](https://github.com/shellphish/how2heap/tree/master?tab=readme-ov-file)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/)
* [https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force](https://heap-exploitation.dhavalkapil.com/attacks/house\_of\_force)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.27/house\_of\_force.c)
* [https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/house\_force\_exp/index.html)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#hitcon-training-lab-11)
* Das Ziel dieses Szenarios ist ein ret2win, bei dem die Adresse einer Funktion, die von der Adresse der ret2win-Funktion aufgerufen wird, ge√§ndert werden muss.
* Die Bin√§rdatei hat einen √úberlauf, der ausgenutzt werden kann, um die Gr√∂√üe des Top-Chunks zu √§ndern, der auf -1 oder p64(0xffffffffffffffff) ge√§ndert wird.
* Anschlie√üend wird die Adresse berechnet, an der der zu √ºberschreibende Zeiger existiert, und der Unterschied von der aktuellen Position des Top-Chunks dorthin wird mit `malloc` allokiert.
* Schlie√ülich wird ein neuer Chunk allokiert, der dieses gew√ºnschte Ziel enth√§lt, das durch die ret2win-Funktion √ºberschrieben wird.
* [https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp](https://shift--crops-hatenablog-com.translate.goog/entry/2016/03/21/171249?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=en&\_x\_tr\_pto=wapp)
* Im `Geben Sie Ihren Namen ein:` gibt es eine anf√§ngliche Schwachstelle, die es erm√∂glicht, eine Adresse aus dem Heap zu leaken.
* Dann ist es in der Funktionalit√§t `Org:` und `Host:` m√∂glich, die 64B des `s`-Zeigers mit dem **Org-Name** zu f√ºllen, der im Stack von der Adresse von v2 gefolgt wird, die dann vom angegebenen **Host-Name** gefolgt wird. Da dann strcpy die Inhalte von s in einen Chunk der Gr√∂√üe 64B kopiert, ist es m√∂glich, **die Gr√∂√üe des Top-Chunks mit den Daten zu √ºberschreiben**, die im **Host-Namen** enthalten sind.
* Jetzt, da ein beliebiges Schreiben m√∂glich ist, wurde das GOT von `atoi` auf die Adresse von printf √ºberschrieben. Es war m√∂glich, die Adresse von `IO_2_1_stderr` _mit_ `%24$p` zu leaken. Und mit diesem libc-Leak war es m√∂glich, das GOT von `atoi` erneut mit der Adresse von `system` zu √ºberschreiben und es mit `/bin/sh` als Parameter aufzurufen.
* Eine alternative Methode [die in diesem anderen Writeup vorgeschlagen wurde](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_force/#2016-bctf-bcloud), besteht darin, `free` mit `puts` zu √ºberschreiben und dann die Adresse von `atoi@got` in den Zeiger zu setzen, der sp√§ter freigegeben wird, sodass sie geleakt wird und mit diesem Leak erneut `atoi@got` mit `system` √ºberschrieben und mit `/bin/sh` aufgerufen werden kann.
* [https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html](https://guyinatuxedo.github.io/41-house\_of\_force/bkp16\_cookbook/index.html)
* Es gibt eine UAF, die es erm√∂glicht, einen Chunk wiederzuverwenden, der ohne L√∂schen des Zeigers freigegeben wurde. Da es einige Lese-Methoden gibt, ist es m√∂glich, eine libc-Adresse zu leaken, indem ein Zeiger auf die freie Funktion im GOT geschrieben und dann die Lese-Funktion aufgerufen wird.
* Dann wurde House of Force (unter Ausnutzung des UAF) verwendet, um die Gr√∂√üe des verbleibenden Speicherplatzes mit -1 zu √ºberschreiben, einen ausreichend gro√üen Chunk zu allozieren, um zum freien Hook zu gelangen, und dann einen weiteren Chunk zu allozieren, der den freien Hook enth√§lt. Dann wird in den Hook die Adresse von `system` geschrieben, in einen Chunk `"/bin/sh"` geschrieben und schlie√ülich der Chunk mit diesem String-Inhalt freigegeben.
