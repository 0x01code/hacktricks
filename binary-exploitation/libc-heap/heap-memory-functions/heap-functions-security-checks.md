# Contr√¥les de s√©curit√© des fonctions de tas

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## unlink

Pour plus d'informations, consultez :

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Il s'agit d'un r√©sum√© des contr√¥les effectu√©s :

* V√©rifier si la taille indiqu√©e du fragment est la m√™me que `prev_size` indiqu√© dans le fragment suivant
* Message d'erreur : `taille corrompue par rapport √† prev_size`
* V√©rifiez √©galement que `P->fd->bk == P` et `P->bk->fw == P`
* Message d'erreur : `liste doublement cha√Æn√©e corrompue`
* Si le fragment n'est pas petit, v√©rifiez que `P->fd_nextsize->bk_nextsize == P` et `P->bk_nextsize->fd_nextsize == P`
* Message d'erreur : `liste doublement cha√Æn√©e corrompue (non petite)`

## \_int\_malloc

Pour plus d'informations, consultez :

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Contr√¥les pendant la recherche de fastbin :**
* Si le fragment est mal align√© :
* Message d'erreur : `malloc() : fragment fastbin non align√© d√©tect√© 2`
* Si le fragment suivant est mal align√© :
* Message d'erreur : `malloc() : fragment fastbin non align√© d√©tect√©`
* Si le fragment retourn√© a une taille incorrecte en raison de son index dans le fastbin :
* Message d'erreur : `malloc() : corruption de m√©moire (rapide)`
* Si un fragment utilis√© pour remplir le tcache est mal align√© :
* Message d'erreur : `malloc() : fragment fastbin non align√© d√©tect√© 3`
* **Contr√¥les pendant la recherche de small bin :**
* Si `victim->bk->fd != victim` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e smallbin corrompue`
* **Contr√¥les pendant la consolidation** effectu√©s pour chaque fragment fastbin :&#x20;
* Si le fragment est mal align√©, d√©clencher :
* Message d'erreur : `malloc_consolidate() : fragment fastbin non align√© d√©tect√©`
* Si le fragment a une taille diff√©rente de celle qu'il devrait en raison de l'index dans lequel il se trouve :
* Message d'erreur : `malloc_consolidate() : taille de fragment non valide`
* Si le fragment pr√©c√©dent n'est pas utilis√© et que le fragment pr√©c√©dent a une taille diff√©rente de celle indiqu√©e par prev_chunk :
* Message d'erreur : `taille corrompue par rapport √† prev_size dans fastbins`
* **Contr√¥les pendant la recherche de la liste non tri√©e** :
* Si la taille du fragment est √©trange (trop petite ou trop grande) :&#x20;
* Message d'erreur : `malloc() : taille non valide (non tri√©e)`
* Si la taille du fragment suivant est √©trange (trop petite ou trop grande) :
* Message d'erreur : `malloc() : taille suivante non valide (non tri√©e)`
* Si la taille pr√©c√©dente indiqu√©e par le fragment suivant diff√®re de la taille du fragment :
* Message d'erreur : `malloc() : taille next->prev_size non concordante (non tri√©e)`
* Si non `victim->bck->fd == victim` ou non `victim->fd == av (ar√®ne)` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e non tri√©e corrompue`
* Comme nous v√©rifions toujours le dernier, son fd devrait toujours pointer vers la structure de l'ar√®ne.
* Si le fragment suivant n'indique pas que le pr√©c√©dent est utilis√© :
* Message d'erreur : `malloc() : next->prev_inuse non valide (non tri√©e)`
* Si `fwd->bk_nextsize->fd_nextsize != fwd` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e largebin corrompue (nextsize)`
* Si `fwd->bk->fd != fwd` :
* Message d'erreur : `malloc() : liste doublement cha√Æn√©e largebin corrompue (bk)`
* **Contr√¥les pendant la recherche de large bin (par index)** :
* `bck->fd-> bk != bck` :
* Message d'erreur : `malloc() : fragments non tri√©s corrompus`
* **Contr√¥les pendant la recherche de large bin (suivant plus grand)** :
* `bck->fd-> bk != bck` :
* Message d'erreur : `malloc() : fragments non tri√©s corrompus2`
* **Contr√¥les pendant l'utilisation du fragment Top** :
* `chunksize(av->top) > av->system_mem` :
* Message d'erreur : `malloc() : taille top corrompue`

## `tcache_get_n`

* **Contr√¥les dans `tcache_get_n` :**
* Si le fragment est mal align√© :
* Message d'erreur : `malloc() : fragment tcache non align√© d√©tect√©`

## `tcache_thread_shutdown`

* **Contr√¥les dans `tcache_thread_shutdown` :**
* Si le fragment est mal align√© :
* Message d'erreur : `tcache_thread_shutdown() : fragment tcache non align√© d√©tect√©`

## `__libc_realloc`

* **Contr√¥les dans `__libc_realloc` :**
* Si l'ancien pointeur est mal align√© ou si la taille √©tait incorrecte :
* Message d'erreur : `realloc() : pointeur non valide`

## `_int_free`

Pour plus d'informations, consultez :

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Contr√¥les au d√©but de `_int_free` :**
* Le pointeur est align√© :
* Message d'erreur : `free() : pointeur non valide`
* Taille sup√©rieure √† `MINSIZE` et taille √©galement align√©e :
* Message d'erreur : `free() : taille non valide`
* **Contr√¥les dans `_int_free` tcache :**
* S'il y a plus d'entr√©es que `mp_.tcache_count` :
* Message d'erreur : `free() : trop de fragments d√©tect√©s dans le tcache`
* Si l'entr√©e n'est pas align√©e :
* Message d'erreur : `free() : fragment non align√© d√©tect√© dans le tcache 2`
* Si le fragment lib√©r√© a d√©j√† √©t√© lib√©r√© et est pr√©sent comme fragment dans le tcache :
* Message d'erreur : `free() : double lib√©ration d√©tect√©e dans le tcache 2`
* **Contr√¥les dans `_int_free` fast bin :**
* Si la taille du fragment est invalide (trop grande ou trop petite) d√©clencher :
* Message d'erreur : `free() : taille suivante non valide (rapide)`
* Si le fragment ajout√© √©tait d√©j√† en haut du fast bin :
* Message d'erreur : `double lib√©ration ou corruption (fasttop)`
* Si la taille du fragment en haut a une taille diff√©rente du fragment que nous ajoutons :
* Message d'erreur : `entr√©e fastbin non valide (libre)`
## **`_int_free_merge_chunk`**

* **V√©rifications dans `_int_free_merge_chunk`:**
* Si le chunk est le chunk sup√©rieur:
* Message d'erreur: `double free or corruption (top)`
* Si le chunk suivant est en dehors des limites de l'ar√®ne:
* Message d'erreur: `double free or corruption (out)`
* Si le chunk n'est pas marqu√© comme utilis√© (dans le prev\_inuse du chunk suivant):
* Message d'erreur: `double free or corruption (!prev)`
* Si le chunk suivant a une taille trop petite ou trop grande:
* Message d'erreur: `free(): invalid next size (normal)`
* Si le chunk pr√©c√©dent n'est pas utilis√©, il tentera de consolider. Mais, si `prev_size` diff√®re de la taille indiqu√©e dans le chunk pr√©c√©dent:
* Message d'erreur: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **V√©rifications dans `_int_free_create_chunk`:**
* En ajoutant un chunk dans le bac non tri√©, v√©rifiez si `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Message d'erreur: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **V√©rifications dans `do_check_malloc_state`:**
* Si le chunk fast bin est mal align√©:
* Message d'erreur: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **V√©rifications dans `malloc_consolidate`:**
* Si le chunk fast bin est mal align√©:
* Message d'erreur: `malloc_consolidate(): unaligned fastbin chunk detected`
* Si la taille du chunk fast bin est incorrecte:
* Message d'erreur: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **V√©rifications dans `_int_realloc`:**
* La taille est trop grande ou trop petite:
* Message d'erreur: `realloc(): invalid old size`
* La taille du chunk suivant est trop grande ou trop petite:
* Message d'erreur: `realloc(): invalid next size`

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
