# Verifica√ß√µes de Seguran√ßa das Fun√ß√µes de Heap

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## unlink

Para mais informa√ß√µes, verifique:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Este √© um resumo das verifica√ß√µes realizadas:

* Verificar se o tamanho indicado do chunk √© o mesmo que o `prev_size` indicado no pr√≥ximo chunk
* Mensagem de erro: `corrupted size vs. prev_size`
* Verificar tamb√©m se `P->fd->bk == P` e `P->bk->fw == P`
* Mensagem de erro: `corrupted double-linked list`
* Se o chunk n√£o √© pequeno, verificar se `P->fd_nextsize->bk_nextsize == P` e `P->bk_nextsize->fd_nextsize == P`
* Mensagem de erro: `corrupted double-linked list (not small)`

## \_int\_malloc

Para mais informa√ß√µes, verifique:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Verifica√ß√µes durante a busca de fast bin:**
* Se o chunk estiver desalinhado:
* Mensagem de erro: `malloc(): unaligned fastbin chunk detected 2`
* Se o chunk √† frente estiver desalinhado:
* Mensagem de erro: `malloc(): unaligned fastbin chunk detected`
* Se o chunk retornado tiver um tamanho incorreto devido ao seu √≠ndice no fast bin:
* Mensagem de erro: `malloc(): memory corruption (fast)`
* Se algum chunk usado para preencher o tcache estiver desalinhado:
* Mensagem de erro: `malloc(): unaligned fastbin chunk detected 3`
* **Verifica√ß√µes durante a busca de small bin:**
* Se `victim->bk->fd != victim`:
* Mensagem de erro: `malloc(): smallbin double linked list corrupted`
* **Verifica√ß√µes durante a consolida√ß√£o** realizadas para cada chunk de fast bin:&#x20;
* Se o chunk estiver desalinhado, acionar:
* Mensagem de erro: `malloc_consolidate(): unaligned fastbin chunk detected`
* Se o chunk tiver um tamanho diferente do que deveria devido ao √≠ndice em que est√°:
* Mensagem de erro: `malloc_consolidate(): invalid chunk size`
* Se o chunk anterior n√£o estiver em uso e o chunk anterior tiver um tamanho diferente do indicado por prev\_chunk:
* Mensagem de erro: `corrupted size vs. prev_size in fastbins`
* **Verifica√ß√µes durante a busca de unsorted bin**:
* Se o tamanho do chunk estiver estranho (muito pequeno ou muito grande):&#x20;
* Mensagem de erro: `malloc(): invalid size (unsorted)`
* Se o tamanho do pr√≥ximo chunk estiver estranho (muito pequeno ou muito grande):
* Mensagem de erro: `malloc(): invalid next size (unsorted)`
* Se o tamanho anterior indicado pelo pr√≥ximo chunk diferir do tamanho do chunk:
* Mensagem de erro: `malloc(): mismatching next->prev_size (unsorted)`
* Se n√£o `victim->bck->fd == victim` ou n√£o `victim->fd == av (arena)`:
* Mensagem de erro: `malloc(): unsorted double linked list corrupted`
* Como sempre estamos verificando o √∫ltimo, seu fd deve estar sempre apontando para a estrutura da arena.
* Se o pr√≥ximo chunk n√£o estiver indicando que o anterior est√° em uso:
* Mensagem de erro: `malloc(): invalid next->prev_inuse (unsorted)`
* Se `fwd->bk_nextsize->fd_nextsize != fwd`:
* Mensagem de erro: `malloc(): largebin double linked list corrupted (nextsize)`
* Se `fwd->bk->fd != fwd`:
* Mensagem de erro: `malloc(): largebin double linked list corrupted (bk)`
* **Verifica√ß√µes durante a busca de large bin (por √≠ndice):**
* `bck->fd-> bk != bck`:
* Mensagem de erro: `malloc(): corrupted unsorted chunks`
* **Verifica√ß√µes durante a busca de large bin (pr√≥ximo maior):**
* `bck->fd-> bk != bck`:
* Mensagem de erro: `malloc(): corrupted unsorted chunks2`
* **Verifica√ß√µes durante o uso do Top chunk:**
* `chunksize(av->top) > av->system_mem`:
* Mensagem de erro: `malloc(): corrupted top size`

## `tcache_get_n`

* **Verifica√ß√µes em `tcache_get_n`:**
* Se o chunk estiver desalinhado:
* Mensagem de erro: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **Verifica√ß√µes em `tcache_thread_shutdown`:**
* Se o chunk estiver desalinhado:
* Mensagem de erro: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **Verifica√ß√µes em `__libc_realloc`:**
* Se o ponteiro antigo estiver desalinhado ou o tamanho estiver incorreto:
* Mensagem de erro: `realloc(): invalid pointer`

## `_int_free`

Para mais informa√ß√µes, verifique:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Verifica√ß√µes durante o in√≠cio do `_int_free`:**
* Ponteiro est√° alinhado:
* Mensagem de erro: `free(): invalid pointer`
* Tamanho maior que `MINSIZE` e tamanho tamb√©m alinhado:
* Mensagem de erro: `free(): invalid size`
* **Verifica√ß√µes no tcache de `_int_free`:**
* Se houver mais entradas do que `mp_.tcache_count`:
* Mensagem de erro: `free(): too many chunks detected in tcache`
* Se a entrada n√£o estiver alinhada:
* Mensagem de erro: `free(): unaligned chunk detected in tcache 2`
* Se o chunk liberado j√° foi liberado e est√° presente como chunk no tcache:
* Mensagem de erro: `free(): double free detected in tcache 2`
* **Verifica√ß√µes no fast bin de `_int_free`:**
* Se o tamanho do chunk for inv√°lido (muito grande ou pequeno) acionar:
* Mensagem de erro: `free(): invalid next size (fast)`
* Se o chunk adicionado j√° estiver no topo do fast bin:
* Mensagem de erro: `double free or corruption (fasttop)`
* Se o tamanho do chunk no topo tiver um tamanho diferente do chunk que estamos adicionando:
* Mensagem de erro: `invalid fastbin entry (free)`
## **`_int_free_merge_chunk`**

* **Verifica√ß√µes em `_int_free_merge_chunk`:**
* Se o chunk √© o chunk superior:
* Mensagem de erro: `double free or corruption (top)`
* Se o pr√≥ximo chunk est√° fora dos limites da arena:
* Mensagem de erro: `double free or corruption (out)`
* Se o chunk n√£o est√° marcado como usado (no prev\_inuse do chunk seguinte):
* Mensagem de erro: `double free or corruption (!prev)`
* Se o pr√≥ximo chunk tem um tamanho muito pequeno ou muito grande:
* Mensagem de erro: `free(): invalid next size (normal)`
* Se o chunk anterior n√£o est√° em uso, ele tentar√° consolidar. Mas, se o `prev_size` difere do tamanho indicado no chunk anterior:
* Mensagem de erro: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **Verifica√ß√µes em `_int_free_create_chunk`:**
* Ao adicionar um chunk no bin n√£o ordenado, verificar se `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Mensagem de erro: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **Verifica√ß√µes em `do_check_malloc_state`:**
* Se o chunk do fast bin estiver desalinhado:
* Mensagem de erro: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **Verifica√ß√µes em `malloc_consolidate`:**
* Se o chunk do fast bin estiver desalinhado:
* Mensagem de erro: `malloc_consolidate(): unaligned fastbin chunk detected`
* Se o tamanho do chunk do fast bin estiver incorreto:
* Mensagem de erro: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **Verifica√ß√µes em `_int_realloc`:**
* Tamanho √© muito grande ou muito pequeno:
* Mensagem de erro: `realloc(): invalid old size`
* Tamanho do pr√≥ximo chunk √© muito grande ou muito pequeno:
* Mensagem de erro: `realloc(): invalid next size`
