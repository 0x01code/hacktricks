# Έλεγχοι Ασφάλειας Συναρτήσεων Heap

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε την [**Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## unlink

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="unlink.md" %}
[unlink.md](unlink.md)
{% endcontent-ref %}

Αυτό είναι ένα σύνοψη των πραγματοποιημένων ελέγχων:

* Έλεγχος εάν το υποδειγμένο μέγεθος του κομματιού είναι το ίδιο με το `prev_size` που υποδεικνύεται στο επόμενο κομμάτι
* Μήνυμα σφάλματος: `corrupted size vs. prev_size`
* Έλεγχος επίσης ότι `P->fd->bk == P` και `P->bk->fw == P`
* Μήνυμα σφάλματος: `corrupted double-linked list`
* Αν το κομμάτι δεν είναι μικρό, ελέγξτε ότι `P->fd_nextsize->bk_nextsize == P` και `P->bk_nextsize->fd_nextsize == P`
* Μήνυμα σφάλματος: `corrupted double-linked list (not small)`

## \_int\_malloc

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="malloc-and-sysmalloc.md" %}
[malloc-and-sysmalloc.md](malloc-and-sysmalloc.md)
{% endcontent-ref %}

* **Έλεγχοι κατά τη διάρκεια της αναζήτησης fast bin:**
* Αν το κομμάτι δεν είναι συμμετρικό:
* Μήνυμα σφάλματος: `malloc(): unaligned fastbin chunk detected 2`
* Αν το εμπρός κομμάτι δεν είναι συμμετρικό:
* Μήνυμα σφάλματος: `malloc(): unaligned fastbin chunk detected`
* Αν το επιστρεφόμενο κομμάτι έχει μέγεθος που δεν είναι σωστό λόγω της θέσης του στο fast bin:
* Μήνυμα σφάλματος: `malloc(): memory corruption (fast)`
* Αν οποιοδήποτε κομμάτι που χρησιμοποιείται για να γεμίσει το tcache δεν είναι συμμετρικό:
* Μήνυμα σφάλματος: `malloc(): unaligned fastbin chunk detected 3`
* **Έλεγχοι κατά τη διάρκεια της αναζήτησης small bin:**
* Αν `victim->bk->fd != victim`:
* Μήνυμα σφάλματος: `malloc(): smallbin double linked list corrupted`
* **Έλεγχοι κατά τη συγχώνευση** που πραγματοποιούνται για κάθε κομμάτι fast bin:&#x20;
* Αν το κομμάτι δεν είναι συμμετρικό ενεργοποίηση:
* Μήνυμα σφάλματος: `malloc_consolidate(): unaligned fastbin chunk detected`
* Αν το κομμάτι έχει διαφορετικό μέγεθος από αυτό που θα έπρεπε λόγω της θέσης του:
* Μήνυμα σφάλματος: `malloc_consolidate(): invalid chunk size`
* Αν το προηγούμενο κομμάτι δεν είναι σε χρήση και το προηγούμενο κομμάτι έχει μέγεθος διαφορετικό από αυτό που υποδεικνύεται από το prev\_chunk:
* Μήνυμα σφάλματος: `corrupted size vs. prev_size in fastbins`
* **Έλεγχοι κατά τη διάρκεια της αναζήτησης unsorted bin**:
* Αν το μέγεθος του κομματιού είναι παράξενο (πολύ μικρό ή πολύ μεγάλο):&#x20;
* Μήνυμα σφάλματος: `malloc(): invalid size (unsorted)`
* Αν το μέγεθος του επόμενου κομματιού είναι παράξενο (πολύ μικρό ή πολύ μεγάλο):
* Μήνυμα σφάλματος: `malloc(): invalid next size (unsorted)`
* Αν το προηγούμενο μέγεθος που υποδεικνύεται από το επόμενο κομμάτι διαφέρει από το μέγεθος του κομματιού:
* Μήνυμα σφάλματος: `malloc(): mismatching next->prev_size (unsorted)`
* Αν δεν είναι `victim->bck->fd == victim` ή όχι `victim->fd == av (arena)`:
* Μήνυμα σφάλματος: `malloc(): unsorted double linked list corrupted`
* Καθώς ελέγχουμε πάντα το τελευταίο, το fd του πρέπει να δείχνει πάντα στη δομή της αρένας.
* Αν το επόμενο κομμάτι δεν υποδεικνύει ότι το προηγούμενο είναι σε χρήση:
* Μήνυμα σφάλματος: `malloc(): invalid next->prev_inuse (unsorted)`
* Αν `fwd->bk_nextsize->fd_nextsize != fwd`:
* Μήνυμα σφάλματος: `malloc(): largebin double linked list corrupted (nextsize)`
* Αν `fwd->bk->fd != fwd`:
* Μήνυμα σφάλματος: `malloc(): largebin double linked list corrupted (bk)`
* **Έλεγχοι κατά τη διάρκεια της αναζήτησης large bin (με βάση το ευρετήριο):**
* `bck->fd-> bk != bck`:
* Μήνυμα σφάλματος: `malloc(): corrupted unsorted chunks`
* **Έλεγχοι κατά τη διάρκεια της αναζήτησης large bin (επόμενο μεγαλύτερο):**
* `bck->fd-> bk != bck`:
* Μήνυμα σφάλματος: `malloc(): corrupted unsorted chunks2`
* **Έλεγχοι κατά τη διάρκεια της χρήσης Top chunk:**
* `chunksize(av->top) > av->system_mem`:
* Μήνυμα σφάλματος: `malloc(): corrupted top size`

## `tcache_get_n`

* **Έλεγχοι στο `tcache_get_n`:**
* Αν το κομμάτι δεν είναι συμμετρικό:
* Μήνυμα σφάλματος: `malloc(): unaligned tcache chunk detected`

## `tcache_thread_shutdown`

* **Έλεγχοι στο `tcache_thread_shutdown`:**
* Αν το κομμάτι δεν είναι συμμετρικό:
* Μήνυμα σφάλματος: `tcache_thread_shutdown(): unaligned tcache chunk detected`

## `__libc_realloc`

* **Έλεγχοι στο `__libc_realloc`:**
* Αν το παλιό δείκτης δεν είναι συμμετρικός ή το μέγεθος ήταν εσφαλμένο:
* Μήνυμα σφάλματος: `realloc(): invalid pointer`

## `_int_free`

Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="free.md" %}
[free.md](free.md)
{% endcontent-ref %}

* **Έλεγχοι κατά την έναρξη του `_int_free`:**
* Ο δείκτης είναι συμμετρικός:
* Μήνυμα σφάλματος: `free(): invalid pointer`
* Μέγεθος μεγαλύτερο από το `MINSIZE` και επίσης συμμετρικό:
* Μήνυμα σφάλματος: `free(): invalid size`
* **Έλεγχοι στο `_int_free` tcache:**
* Αν υπάρχουν περισσότερες καταχωρήσεις από `mp_.tcache_count`:
* Μήνυμα σφάλματος: `free(): too many chunks detected in tcache`
* Αν η καταχώρηση δεν είναι συμμετρική:
* Μήνυμα σφάλματος: `free(): unaligned chunk detected in tcache 2`
* Αν το απελευθερωμένο κομμάτι είχε ήδη απελευθερωθεί και υπάρχει ως κομμάτι στο tcache:
* Μήνυμα σφάλματος: `free(): double free detected in tcache 2`
* **Έλεγχοι στο `_int_free` fast bin:**
* Αν το μέγεθος του κομματιού είναι μη έγκυρο (πολύ μεγάλο ή μικρό) ενεργοποίηση:
* Μήνυμα σφάλματος: `free(): invalid next size (fast)`
* Αν το προστιθέμενο κομμάτι ήταν ήδη στην κορυφή του fast bin:
* Μήνυμα σφάλματος: `double free or corruption (fasttop)`
* Αν το μέγεθος του κομματιού στην κορυφή έχει διαφορετικό μέγεθος από το κομμάτι που προσθέτουμε:
* Μήνυμα σφάλματος: `invalid fastbin entry (free)`
## **`_int_free_merge_chunk`**

* **Έλεγχοι στο `_int_free_merge_chunk`:**
* Αν το κομμάτι είναι το κορυφαίο κομμάτι:
* Μήνυμα σφάλματος: `double free or corruption (top)`
* Αν το επόμενο κομμάτι βρίσκεται εκτός των ορίων της αρένας:
* Μήνυμα σφάλματος: `double free or corruption (out)`
* Αν το κομμάτι δεν είναι σημασιοδοτημένο ως χρησιμοποιημένο (στο prev\_inuse από το επόμενο κομμάτι):
* Μήνυμα σφάλματος: `double free or corruption (!prev)`
* Αν το επόμενο κομμάτι έχει πολύ μικρό ή πολύ μεγάλο μέγεθος:
* Μήνυμα σφάλματος: `free(): invalid next size (normal)`
* Αν το προηγούμενο κομμάτι δεν είναι σε χρήση, θα προσπαθήσει να συγχωνεύσει. Αλλά, αν το `prev_size` διαφέρει από το μέγεθος που υποδεικνύεται στο προηγούμενο κομμάτι:
* Μήνυμα σφάλματος: `corrupted size vs. prev_size while consolidating`

## **`_int_free_create_chunk`**

* **Έλεγχοι στο `_int_free_create_chunk`:**
* Προσθήκη ενός κομματιού στον μη ταξινομημένο κάδο, ελέγξτε αν `unsorted_chunks(av)->fd->bk == unsorted_chunks(av)`:
* Μήνυμα σφάλματος: `free(): corrupted unsorted chunks`

## `do_check_malloc_state`

* **Έλεγχοι στο `do_check_malloc_state`:**
* Αν το fast bin κομμάτι δεν είναι σωστά στοιχισμένο:
* Μήνυμα σφάλματος: `do_check_malloc_state(): unaligned fastbin chunk detected`

## `malloc_consolidate`

* **Έλεγχοι στο `malloc_consolidate`:**
* Αν το fast bin κομμάτι δεν είναι σωστά στοιχισμένο:
* Μήνυμα σφάλματος: `malloc_consolidate(): unaligned fastbin chunk detected`
* Αν το μέγεθος του fast bin κομματιού δεν είναι σωστό:
* Μήνυμα σφάλματος: `malloc_consolidate(): invalid chunk size`

## `_int_realloc`

* **Έλεγχοι στο `_int_realloc`:**
* Το μέγεθος είναι πολύ μεγάλο ή πολύ μικρό:
* Μήνυμα σφάλματος: `realloc(): invalid old size`
* Το μέγεθος του επόμενου κομματιού είναι πολύ μεγάλο ή πολύ μικρό:
* Μήνυμα σφάλματος: `realloc(): invalid next size`
