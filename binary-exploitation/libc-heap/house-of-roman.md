# House of Roman

<details>

<summary><strong>htARTE (HackTricks AWS Red Team 전문가)로부터 AWS 해킹을 처음부터 전문가까지 배우세요!</strong></summary>

HackTricks를 지원하는 다른 방법:

- **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드하고 싶다면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
- [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
- 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
- **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기술을 공유하세요.

</details>

## 기본 정보

이 기법은 가짜 fastbins, unsorted\_bin 공격 및 상대적 덮어쓰기를 통해 누출 없이 RCE를 가능케 하는 매우 흥미로운 기법이었습니다. 그러나 [**패치되었습니다**](https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c).

### 코드

* 예제는 [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)에서 찾을 수 있습니다.

### 목표

* 상대적인 포인터를 악용하여 RCE

### 요구 사항

* fastbin 및 unsorted bin 포인터 편집
* 작동할 확률이 0.02%인 12비트의 무작위성을 브루트 포스해야 함

## 공격 단계

### 파트 1: Fastbin Chunk가 \_\_malloc\_hook을 가리키도록 함

여러 청크를 생성합니다:

* `fastbin_victim` (0x60, 오프셋 0): 나중에 힙 포인터를 LibC 값으로 가리키도록 나중에 편집할 UAF 청크
* `chunk2` (0x80, 오프셋 0x70): 좋은 정렬을 위해
* `main_arena_use` (0x80, 오프셋 0x100)
* `relative_offset_heap` (0x60, 오프셋 0x190): 'main\_arena\_use' 청크에서의 상대적 오프셋

그런 다음 `free(main_arena_use)`를 수행하여 이 청크를 unsorted 목록에 배치하고 `fd` 및 `bk` 포인터 모두에서 `main_arena + 0x68`을 가리키는 포인터를 얻게 됩니다.

이제 `fd` 및 `bk` 포인터에서 `main_arena + 0x68`을 가리키는 포인터를 포함할 것이므로 새로운 청크 `fake_libc_chunk(0x60)`가 할당됩니다.

그런 다음 `relative_offset_heap` 및 `fastbin_victim`을 해제합니다.
```c
/*
Current heap layout:
0x0:   fastbin_victim       - size 0x70
0x70:  alignment_filler     - size 0x90
0x100: fake_libc_chunk      - size 0x70 (contains a fd ptr to main_arena + 0x68)
0x170: leftover_main        - size 0x20
0x190: relative_offset_heap - size 0x70

bin layout:
fastbin:  fastbin_victim -> relative_offset_heap
unsorted: leftover_main
*/
```
* &#x20;`fastbin_victim`은 `relative_offset_heap`을 가리키는 `fd`를 가지고 있습니다.
* &#x20;`relative_offset_heap`은 `fake_libc_chunk`로부터의 거리 오프셋이며, `main_arena + 0x68`을 가리키는 포인터를 포함합니다.
* `fastbin_victim.fd`의 마지막 바이트를 변경함으로써 `fastbin_victim`이 `main_arena + 0x68`을 가리키도록 만들 수 있습니다.

이전 동작을 위해 공격자는 `fastbin_victim`의 `fd` 포인터를 수정할 수 있어야 합니다.

그런 다음, `main_arena + 0x68`은 그다지 흥미로운 것이 아니므로 포인터가 **`__malloc_hook`**을 가리키도록 수정합니다.

`__memalign_hook`은 일반적으로 `0x7f`로 시작하고 그 앞에는 0으로 채워지므로, `0x70` fast bin의 값으로 가짜로 만들 수 있습니다. 주소의 마지막 4비트는 **랜덤**이므로 원하는 위치를 가리키도록 끝을 맞출 수 있는 가능성은 `2^4=16`입니다. 따라서 여기서는 BF 공격을 수행하여 청크가 다음과 같이 끝나도록 합니다: **`0x70: fastbin_victim -> fake_libc_chunk -> (__malloc_hook - 0x23)`**.

(나머지 바이트에 대한 자세한 내용은 [how2heap](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)의 설명을 확인하십시오. BF가 작동하지 않으면 프로그램이 중단됩니다 (작동할 때까지 다시 시작하십시오).

그런 다음, 처음 2개의 fast bin 청크를 제거하기 위해 2개의 malloc이 수행되고, 세 번째 malloc이 수행되어 **`__malloc_hook:`**에서 청크를 얻습니다.
```c
malloc(0x60);
malloc(0x60);
uint8_t* malloc_hook_chunk = malloc(0x60);
```
### 파트 2: Unsorted\_bin 공격

더 많은 정보를 원하시면 아래를 확인하세요:

{% content-ref url="unsorted-bin-attack.md" %}
[unsorted-bin-attack.md](unsorted-bin-attack.md)
{% endcontent-ref %}

기본적으로는 `chunk->bk`에 지정된 위치로 `main_arena + 0x68`을 쓸 수 있게 합니다. 그리고 우리는 공격에 `__malloc_hook`을 선택합니다. 그런 다음 덮어쓴 후에 상대적 덮어쓰기를 사용하여 `one_gadget`을 가리키게 할 것입니다.

이를 위해 청크를 가져와서 **unsorted bin**에 넣기 시작합니다:
```c
uint8_t* unsorted_bin_ptr = malloc(0x80);
malloc(0x30); // Don't want to consolidate

puts("Put chunk into unsorted_bin\n");
// Free the chunk to create the UAF
free(unsorted_bin_ptr);
```
이 청크에서 UAF를 사용하여 `unsorted_bin_ptr->bk`를 `__malloc_hook` 주소로 지정합니다 (이전에 우리는 이를 무차별 대입했습니다).

{% hint style="danger" %}
이 공격은 unsorted bin을 손상시키므로 이제 **빠른 bin에서 할당만 사용할 수 있습니다** (더 복잡한 프로그램은 다른 할당을 수행하고 충돌할 수 있음), 이를 트리거하기 위해 **동일한 크기로 할당해야 합니다.**
{% endhint %}

따라서, `__malloc_hook`을 `unsorted_bin_ptr->bk`에 설정한 후에 `main_arena + 0x68`에 쓰기를 트리거하기 위해 우리는 단순히 **`malloc(0x80)`**을 수행해야 합니다.

### 단계 3: \_\_malloc\_hook을 시스템으로 설정

첫 번째 단계에서 `__malloc_hook`을 포함하는 청크를 제어하게 되었고(변수 `malloc_hook_chunk`), 두 번째 단계에서 여기에 `main_arena + 0x68`을 쓸 수 있었습니다.

이제, `malloc_hook_chunk`에서 부분 덮어쓰기를 악용하여 거기에 쓴 libc 주소(`main_arena + 0x68`)를 사용하여 **`one_gadget` 주소를 지정**합니다.

여기서 **12비트의 무작위성을 무차별 대입해야** 합니다([how2heap](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)의 [예시](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)에서 자세한 정보 확인).

마지막으로, 올바른 주소가 덮어쓰여지면 **`malloc`을 호출하고 `one_gadget`을 트리거**합니다.

## 참고 자료

* [https://github.com/shellphish/how2heap](https://github.com/shellphish/how2heap)
* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.23/house\_of\_roman.c)
* [https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_roman/](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_roman/)
