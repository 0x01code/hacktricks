# 堆

## 堆基础

堆基本上是程序在请求数据时可以存储数据的地方，通过调用诸如**`malloc`**、`calloc`等函数。此外，当这些内存不再需要时，可以通过调用函数**`free`**来释放。

正如所示，堆就在二进制文件加载到内存后面（查看`[heap]`部分）：

<figure><img src="../../.gitbook/assets/image (1241).png" alt=""><figcaption></figcaption></figure>

### 基本块分配

当请求将一些数据存储在堆中时，堆的一些空间将被分配给它。这个空间将属于一个bin，并且只有请求的数据 + bin头部的空间 + 最小bin大小偏移量将被保留给块。目标是尽可能保留最少的内存，而不会使查找每个块的位置变得复杂。为此，使用元数据块信息来知道每个已使用/空闲块的位置。

有不同的方式来保留空间，主要取决于使用的bin，但一般的方法是：

* 程序首先请求一定量的内存。
* 如果在块列表中有足够大的可用块来满足请求，它将被使用。
* 这甚至可能意味着可用块的一部分将用于此请求，其余部分将被添加到块列表中。
* 如果列表中没有可用块，但已分配的堆内存中仍有空间，堆管理器将创建一个新块。
* 如果没有足够的堆空间来分配新块，堆管理器会要求内核扩展分配给堆的内存，然后使用这个内存来生成新块。
* 如果一切失败，`malloc`返回null。

请注意，如果请求的**内存超过阈值**，将使用**`mmap`**来映射请求的内存。

## 竞技场

在**多线程**应用程序中，堆管理器必须防止可能导致崩溃的**竞争条件**。最初，这是通过使用**全局互斥锁**来实现的，以确保一次只有一个线程可以访问堆，但这会导致由于互斥锁引起的瓶颈而出现**性能问题**。

为了解决这个问题，ptmalloc2堆分配器引入了“竞技场”，其中**每个竞技场**充当一个**独立的堆**，具有其**自己的**数据**结构**和**互斥锁**，允许多个线程执行堆操作而不会相互干扰，只要它们使用不同的竞技场。

默认的“主”竞技场处理单线程应用程序的堆操作。当**添加新线程**时，堆管理器为它们分配**次要竞技场**以减少争用。它首先尝试将每个新线程附加到未使用的竞技场，如有必要，创建新的竞技场，对于32位系统的限制是CPU核心数量的2倍，对于64位系统是8倍。一旦达到限制，**线程必须共享竞技场**，可能导致争用。

与主竞技场不同，主竞技场使用`brk`系统调用扩展，次要竞技场使用`mmap`和`mprotect`创建“子堆”来模拟堆行为，允许灵活管理多线程操作的内存。

### 子堆

子堆用作多线程应用程序中次要竞技场的内存储备，允许它们独立增长和管理自己的堆区域，与主堆不同，它们是如何运作的：

1. **初始堆与子堆**：
* 初始堆位于程序二进制文件之后的内存中，并使用`sbrk`系统调用扩展。
* 次要竞技场使用的子堆是通过`mmap`创建的，这是一个系统调用，用于映射指定的内存区域。
2. **使用`mmap`进行内存保留**：
* 当堆管理器创建一个子堆时，它通过`mmap`保留了一个大块内存。此保留不会立即分配内存；它只是指定其他系统进程或分配不应使用的区域。
* 默认情况下，32位进程的子堆保留大小为1 MB，64位进程为64 MB。
3. **使用`mprotect`逐步扩展**：
* 初始将保留的内存区域标记为`PROT_NONE`，表示内核暂时不需要为此空间分配物理内存。
* 为了“增长”子堆，堆管理器使用`mprotect`将页面权限从`PROT_NONE`更改为`PROT_READ | PROT_WRITE`，促使内核为先前保留的地址分配物理内存。这一步骤逐步允许子堆根据需要扩展。
* 一旦整个子堆耗尽，堆管理器将创建一个新的子堆以继续分配。

### heap\_info <a href="#heap_info" id="heap_info"></a>

此结构体分配了堆的相关信息。此外，堆内存在进行更多分配后可能不再连续，此结构体也将存储该信息。
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/arena.c#L837

typedef struct _heap_info
{
mstate ar_ptr; /* Arena for this heap. */
struct _heap_info *prev; /* Previous heap. */
size_t size;   /* Current size in bytes. */
size_t mprotect_size; /* Size in bytes that has been mprotected
PROT_READ|PROT_WRITE.  */
size_t pagesize; /* Page size used when allocating the arena.  */
/* Make sure the following data is properly aligned, particularly
that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
MALLOC_ALIGNMENT. */
char pad[-3 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
```
### malloc\_state

**每个堆**（主堆或其他线程的堆）都有一个**`malloc_state`结构。**\
值得注意的是，**主堆的`malloc_state`**结构是**libc中的全局变量**（因此位于libc内存空间）。\
对于线程堆的**`malloc_state`**结构，它们位于**各自线程的“堆”**中。

从这个结构中有一些有趣的事情需要注意（见下面的C代码）：

* `__libc_lock_define (, mutex);` 用于确保堆中的这个结构一次只能被一个线程访问
* 标志：
* ```c
#define NONCONTIGUOUS_BIT     (2U)

#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)
#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)
#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)
#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)
```
* `mchunkptr bins[NBINS * 2 - 2];` 包含指向小、大和未排序**bins**的**第一个和最后一个chunk**的指针（-2是因为索引0未被使用）
* 因此，这些bins的**第一个chunk**将具有指向此结构的**反向指针**，而这些bins的**最后一个chunk**将具有指向此结构的**前向指针。** 这基本上意味着，如果您可以**泄漏主堆中的这些地址**，您将获得指向**libc**中该结构的指针。
* 结构体 `struct malloc_state *next;` 和 `struct malloc_state *next_free;` 是堆的链表
* `top` chunk是最后一个“chunk”，基本上是**堆中剩余的所有空间**。一旦顶部chunk为空，堆就完全被使用，需要请求更多空间。
* `last reminder` chunk来自这样的情况：没有可用的确切大小的chunk，因此会分割一个更大的chunk，将剩余部分放在这里。
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/malloc/malloc.c#L1812

struct malloc_state
{
/* Serialize access.  */
__libc_lock_define (, mutex);

/* Flags (formerly in max_fast).  */
int flags;

/* Set if the fastbin chunks contain recently inserted free blocks.  */
/* Note this is a bool but not all targets support atomics on booleans.  */
int have_fastchunks;

/* Fastbins */
mfastbinptr fastbinsY[NFASTBINS];

/* Base of the topmost chunk -- not otherwise kept in a bin */
mchunkptr top;

/* The remainder from the most recent split of a small request */
mchunkptr last_remainder;

/* Normal bins packed as described above */
mchunkptr bins[NBINS * 2 - 2];

/* Bitmap of bins */
unsigned int binmap[BINMAPSIZE];

/* Linked list */
struct malloc_state *next;

/* Linked list for free arenas.  Access to this field is serialized
by free_list_lock in arena.c.  */
struct malloc_state *next_free;

/* Number of threads attached to this arena.  0 if the arena is on
the free list.  Access to this field is serialized by
free_list_lock in arena.c.  */
INTERNAL_SIZE_T attached_threads;

/* Memory allocated from the system in this arena.  */
INTERNAL_SIZE_T system_mem;
INTERNAL_SIZE_T max_system_mem;
};
```
### malloc\_chunk

这个结构体代表内存的一个特定块。对于已分配和未分配的块，各个字段具有不同的含义。
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
struct malloc_chunk {
INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */
INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk;
/* Only used for large blocks: pointer to next larger size.  */
struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */
struct malloc_chunk* bk_nextsize;
};

typedef struct malloc_chunk* mchunkptr;
```
正如之前所述，这些块还包含一些元数据，非常好地在这张图片中表示：

<figure><img src="../../.gitbook/assets/image (1242).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

元数据通常为0x08B，使用最后3位来指示当前块大小：

* `A`：如果为1，则来自子堆，如果为0，则在主堆中
* `M`：如果为1，则此块是使用mmap分配的空间的一部分，而不是堆的一部分
* `P`：如果为1，则前一个块正在使用中

然后是用户数据的空间，最后是0x08B，用于指示可用时的前一个块大小（或在分配时存储用户数据）。

此外，当可用时，用户数据还用于包含一些数据：

* **`fd`**：指向下一个块的指针
* **`bk`**：指向前一个块的指针
* **`fd_nextsize`**：指向列表中比自身小的第一个块的指针
* **`bk_nextsize`**：指向列表中比自身大的第一个块的指针

<figure><img src="../../.gitbook/assets/image (1243).png" alt=""><figcaption><p><a href="https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png">https://azeria-labs.com/wp-content/uploads/2019/03/chunk-allocated-CS.png</a></p></figcaption></figure>

{% hint style="info" %}
请注意，通过这种方式链接列表可以避免需要注册每个块的数组。
{% endhint %}

### 块指针

当使用malloc时，返回一个指向可以写入内容的指针（就在头部之后），但是，在管理块时，需要一个指向头部（元数据）开头的指针。\
为了进行这些转换，使用以下函数：
```c
// https://github.com/bminor/glibc/blob/master/malloc/malloc.c

/* Convert a chunk address to a user mem pointer without correcting the tag.  */
#define chunk2mem(p) ((void*)((char*)(p) + CHUNK_HDR_SZ))

/* Convert a user mem pointer to a chunk address and extract the right tag.  */
#define mem2chunk(mem) ((mchunkptr)tag_at (((char*)(mem) - CHUNK_HDR_SZ)))

/* The smallest possible chunk */
#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))

/* The smallest size we can malloc is an aligned minimal chunk */

#define MINSIZE  \
(unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))
```
### 对齐和最小尺寸

指向块的指针和 `0x0f` 必须为 0。
```c
// From https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/generic/malloc-size.h#L61
#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)

// https://github.com/bminor/glibc/blob/a07e000e82cb71238259e674529c37c12dc7d423/sysdeps/i386/malloc-alignment.h
#define MALLOC_ALIGNMENT 16


// https://github.com/bminor/glibc/blob/master/malloc/malloc.c
/* Check if m has acceptable alignment */
#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p) \
((uintptr_t)(MALLOC_ALIGNMENT == CHUNK_HDR_SZ ? (p) : chunk2mem (p)) \
& MALLOC_ALIGN_MASK)


/* pad request bytes into a usable size -- internal version */
/* Note: This must be a macro that evaluates to a compile time constant
if passed a literal constant.  */
#define request2size(req)                                         \
(((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
MINSIZE :                                                      \
((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/* Check if REQ overflows when padded and aligned and if the resulting
value is less than PTRDIFF_T.  Returns the requested size or
MINSIZE in case the value is less than MINSIZE, or 0 if any of the
previous checks fail.  */
static inline size_t
checked_request2size (size_t req) __nonnull (1)
{
if (__glibc_unlikely (req > PTRDIFF_MAX))
return 0;

/* When using tagged memory, we cannot share the end of the user
block with the header for the next chunk, so ensure that we
allocate blocks that are rounded up to the granule size.  Take
care not to overflow from close to MAX_SIZE_T to a small
number.  Ideally, this would be part of request2size(), but that
must be a macro that produces a compile time constant if passed
a constant literal.  */
if (__glibc_unlikely (mtag_enabled))
{
/* Ensure this is not evaluated if !mtag_enabled, see gcc PR 99551.  */
asm ("");

req = (req + (__MTAG_GRANULE_SIZE - 1)) &
~(size_t)(__MTAG_GRANULE_SIZE - 1);
}

return request2size (req);
}
```
### 获取块数据并修改元数据

这些函数通过接收一个指向块的指针来工作，并且对于检查/设置元数据非常有用：

* 检查块标志
```c
// From https://github.com/bminor/glibc/blob/master/malloc/malloc.c


/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
from a non-main arena.  This is only set immediately before handing
the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* Check for chunk from main arena.  */
#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)

/* Mark a chunk as not being on the main arena.  */
#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)
```
* 大小和指向其他块的指针
```c
/*
Bits to mask off when extracting size

Note: IS_MMAPPED is intentionally not masked off from size field in
macros for which mmapped chunks should never be seen. This should
cause helpful core dumps to occur if it is tried by accident by
people extending or adapting this malloc.
*/
#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))

/* Like chunksize, but do not mask SIZE_BITS.  */
#define chunksize_nomask(p)         ((p)->mchunk_size)

/* Ptr to next physical malloc_chunk. */
#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))

/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define prev_size(p) ((p)->mchunk_prev_size)

/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */
#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))

/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */
#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))

/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))
```
* 初始化堆
```c
/* extract p's inuse bit */
#define inuse(p)							      \
((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)

/* set/clear chunk as being inuse without otherwise disturbing */
#define set_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE

#define clear_inuse(p)							      \
((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)


/* check/set/clear inuse bits in known places */
#define inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)

#define set_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)

#define clear_inuse_bit_at_offset(p, s)					      \
(((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))
```
* 设置头部和页脚（当块编号在使用时）
```c
/* Set size at head, without disturbing its use bit */
#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))

/* Set size/use field */
#define set_head(p, s)       ((p)->mchunk_size = (s))

/* Set size at footer (only when chunk is not in use) */
#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))
```
* 获取块内真正可用数据的大小
```c
#pragma GCC poison mchunk_size
#pragma GCC poison mchunk_prev_size

/* This is the size of the real usable data in the chunk.  Not valid for
dumped heap chunks.  */
#define memsize(p)                                                    \
(__MTAG_GRANULE_SIZE > SIZE_SZ && __glibc_unlikely (mtag_enabled) ? \
chunksize (p) - CHUNK_HDR_SZ :                                    \
chunksize (p) - CHUNK_HDR_SZ + (chunk_is_mmapped (p) ? 0 : SIZE_SZ))

/* If memory tagging is enabled the layout changes to accommodate the granule
size, this is wasteful for small allocations so not done by default.
Both the chunk header and user data has to be granule aligned.  */
_Static_assert (__MTAG_GRANULE_SIZE <= CHUNK_HDR_SZ,
"memory tagging is not supported with large granule.");

static __always_inline void *
tag_new_usable (void *ptr)
{
if (__glibc_unlikely (mtag_enabled) && ptr)
{
mchunkptr cp = mem2chunk(ptr);
ptr = __libc_mtag_tag_region (__libc_mtag_new_tag (ptr), memsize (cp));
}
return ptr;
}
```
## 例子

### 快速堆示例

快速堆示例来自[https://guyinatuxedo.github.io/25-heap/index.html](https://guyinatuxedo.github.io/25-heap/index.html)，但是在arm64上：
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void main(void)
{
char *ptr;
ptr = malloc(0x10);
strcpy(ptr, "panda");
}
```
在主函数的末尾设置一个断点，让我们找出信息存储在哪里：

<figure><img src="../../.gitbook/assets/image (1239).png" alt=""><figcaption></figcaption></figure>

可以看到字符串"panda"被存储在`0xaaaaaaac12a0`（这是由`x0`内的malloc返回的地址）。检查它之前的0x10个字节，可以看到`0x0`表示**前一个块未被使用**（长度为0），而这个块的长度为`0x21`。

额外保留的空间（0x21-0x10=0x11）来自于**添加的头部**（0x10），0x1并不意味着0x21B被保留，而是当前头部长度的最后3位具有一些特殊含义。由于长度始终是16字节对齐的（在64位机器上），这些位实际上永远不会被长度数字使用。
```
0x1:     Previous in Use     - Specifies that the chunk before it in memory is in use
0x2:     Is MMAPPED          - Specifies that the chunk was obtained with mmap()
0x4:     Non Main Arena      - Specifies that the chunk was obtained from outside of the main arena
```
### 多线程示例

<details>

<summary>多线程</summary>
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/types.h>


void* threadFuncMalloc(void* arg) {
printf("Hello from thread 1\n");
char* addr = (char*) malloc(1000);
printf("After malloc and before free in thread 1\n");
free(addr);
printf("After free in thread 1\n");
}

void* threadFuncNoMalloc(void* arg) {
printf("Hello from thread 2\n");
}


int main() {
pthread_t t1;
void* s;
int ret;
char* addr;

printf("Before creating thread 1\n");
getchar();
ret = pthread_create(&t1, NULL, threadFuncMalloc, NULL);
getchar();

printf("Before creating thread 2\n");
ret = pthread_create(&t1, NULL, threadFuncNoMalloc, NULL);

printf("Before exit\n");
getchar();

return 0;
}
```
</details>

调试前面的示例，可以看到一开始只有1个 arena：

<figure><img src="../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

然后，在调用第一个线程，即调用 malloc 的线程后，会创建一个新的 arena：

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

在其中可以找到一些块：

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

## Bins & 内存分配/释放

查看 bins 是什么，它们是如何组织的，以及内存是如何分配和释放的：

{% content-ref url="bins-and-memory-allocations.md" %}
[bins-and-memory-allocations.md](bins-and-memory-allocations.md)
{% endcontent-ref %}

## 堆函数安全检查

堆中涉及的函数在执行操作之前会执行某些检查，以确保堆没有被破坏：

{% content-ref url="heap-memory-functions/heap-functions-security-checks.md" %}
[heap-functions-security-checks.md](heap-memory-functions/heap-functions-security-checks.md)
{% endcontent-ref %}

## 参考资料

* [https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/](https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/)
* [https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)
