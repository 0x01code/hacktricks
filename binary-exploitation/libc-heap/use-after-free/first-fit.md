# First Fit

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>を使用して、<strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong>！</summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい**または **HackTricks をPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをご覧ください
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)をフォローする
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください**

</details>

## **First Fit**

glibcを使用してプログラム内のメモリを解放すると、異なる "bins" がメモリチャンクを管理するために使用されます。ここでは、2つの一般的なシナリオ、つまりunsorted binsとfastbinsの簡略化された説明を示します。

### Unsorted Bins

高速チャンクでないメモリチャンクを解放すると、それはunsorted binに移動します。このbinは、新しく解放されたチャンクが前方（"head"）に追加されるリストのように機能します。新しいメモリチャンクを要求すると、アロケータはunsorted binを後方（"tail"）から見て、十分に大きなチャンクを見つけます。unsorted binからのチャンクが必要なサイズよりも大きい場合、そのチャンクは分割され、前半部分が返され、残りの部分はbinに残ります。

例:

* 300バイト（`a`）を割り当て、次に250バイト（`b`）を割り当て、`a`を解放してから再度250バイト（`c`）を要求します。
* `a`を解放すると、unsorted binに移動します。
* 次に250バイトを要求すると、アロケータは`a`を末尾で見つけ、それを分割して、リクエストに合う部分を返し、残りをbinに保持します。
* `c`は以前の`a`を指し示し、`a`で埋められます。
```c
char *a = malloc(300);
char *b = malloc(250);
free(a);
char *c = malloc(250);
```
### Fastbins

Fastbinsは小さなメモリチャンクに使用されます。unsorted binsとは異なり、fastbinsは新しいチャンクを先頭に追加し、最後に追加されたものが最初に取り出される（LIFO）動作を作成します。もしメモリの小さなチャンクをリクエストすると、アロケータはfastbinの先頭から取り出します。

例：

- 20バイトずつ4つのチャンク（`a`、`b`、`c`、`d`）を割り当てます。
- 任意の順序でそれらを解放すると、解放されたチャンクはfastbinの先頭に追加されます。
- その後20バイトのチャンクをリクエストすると、アロケータはfastbinの先頭から最も最近解放されたチャンクを返します。
```c
char *a = malloc(20);
char *b = malloc(20);
char *c = malloc(20);
char *d = malloc(20);
free(a);
free(b);
free(c);
free(d);
a = malloc(20);   // d
b = malloc(20);   // c
c = malloc(20);   // b
d = malloc(20);   // a
```
## その他の参考文献と例

* [**https://heap-exploitation.dhavalkapil.com/attacks/first\_fit**](https://heap-exploitation.dhavalkapil.com/attacks/first\_fit)
* [**https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/**](https://8ksec.io/arm64-reversing-and-exploitation-part-2-use-after-free/)
* ARM64。Use after free: ユーザーオブジェクトを生成し、解放し、解放されたチャンクを取得し、その位置に書き込むことで、**前のユーザー->パスワード**の位置を上書きします。ユーザーを再利用して、**パスワードチェックをバイパス**します。
* [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/use\_after\_free/#example)
* プログラムではノートを作成できます。ノートには、malloc(8)でノート情報（呼び出される可能性のある関数へのポインタを持つ）とノートの内容を持つ別のmalloc(\<size>)へのポインタがあります。
* 攻撃は、ノート情報サイズよりも大きなmallocコンテンツを持つ2つのノート（note0とnote1）を作成し、それらを解放して高速ビン（またはtcache）に入れることです。
* 次に、コンテンツサイズが8の別のノート（note2）を作成します。コンテンツはノート1になり、チャンクが再利用されるため、関数ポインタをwin関数を指すように変更し、note1をUse-After-Freeして新しい関数ポインタを呼び出します。
* [**https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/pico\_areyouroot/index.html)
* 一部のメモリを割り当て、必要な値を書き込み、解放し、再割り当てすることが可能で、以前のデータがまだ残っているため、新しい期待される構造体に従って処理され、値を設定するかフラグを取得することが可能です。
* [**https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html**](https://guyinatuxedo.github.io/26-heap\_grooming/swamp19\_heapgolf/index.html)
* この場合、最初に割り当てられた特定のチャンクに4を書き込む必要があります（それらをすべて強制的に解放した後でも）。 新しく割り当てられた各チャンクには、配列インデックスの番号が格納されます。 次に、4つのチャンク（最初に割り当てられたものを含む）を割り当て、最後のチャンクにはその中に4が含まれています。それらを解放し、最初のチャンクを再割り当てし、最後に解放された最後のチャンク（4が含まれているチャンク）を使用します。
