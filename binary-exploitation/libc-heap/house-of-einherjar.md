# House of Einherjar

<details>

<summary><strong>제로부터 영웅이 될 때까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team 전문가)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** **트위터** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 요령을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소로 PR을 제출하세요.

</details>

## 기본 정보

### 코드

* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.35/house\_of\_einherjar.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.35/house\_of\_einherjar.c)에서 예제 확인
* 또는 [https://guyinatuxedo.github.io/42-house\_of\_einherjar/house\_einherjar\_exp/index.html#house-of-einherjar-explanation](https://guyinatuxedo.github.io/42-house\_of\_einherjar/house\_einherjar\_exp/index.html#house-of-einherjar-explanation)에서 확인 (tcache를 채워야 할 수도 있음)

### 목표

* 거의 모든 특정 주소에 메모리를 할당하는 것

### 요구 사항

* 청크를 할당하려는 경우 가짜 청크를 생성:
* 자신을 가리키도록 포인터를 설정하여 무결성 검사를 우회
* 한 청크에서 다음 청크로의 널 바이트를 통한 1바이트 오버플로우를 사용하여 `PREV_INUSE` 플래그 수정
* 오버플로우된 청크의 `prev_size`에 자신과 가짜 청크 사이의 차이를 표시
* 가짜 청크 크기도 무결성 검사를 우회하기 위해 동일한 크기로 설정되어야 함
* 이러한 청크를 구성하려면 힙 누수가 필요

### 공격

* 공격자가 제어하는 청크 내에 `fd`와 `bk`로 가리키는 가짜 청크 `A`가 생성됨
* 다른 2개의 청크 (`B` 및 `C`)가 할당됨
* `B`에서 1바이트 오버플로우를 악용하여 `prev in use` 비트를 지우고 `prev_size` 데이터를 `C` 청크가 할당된 위치와 이전에 생성된 가짜 `A` 청크 사이의 차이로 덮어씀
* 이 `prev_size` 및 가짜 청크 `A`의 크기는 체크를 우회하기 위해 동일해야 함
* 그런 다음 tcache를 채움
* 그런 다음 `C`를 해제하여 가짜 청크 `A`와 통합
* 그런 다음 새로운 청크 `D`가 생성되는데, 이는 가짜 `A` 청크에서 시작하여 `B` 청크를 덮음
* Einherjar의 집이 여기서 끝남
* 이것은 fast bin 공격이나 Tcache 독감으로 계속될 수 있음:
* `B`를 해제하여 fast bin / Tcache에 추가
* `B`의 `fd`를 덮어쓰어 `D` 청크를 악용하여 대상 주소를 가리키도록 함 (이는 `B`를 포함하고 있는 `D` 청크를 포함)
* 그런 다음 2개의 malloc을 수행하고 두 번째 malloc은 **대상 주소를 할당**할 것임

## 참고 및 다른 예제

* [https://github.com/shellphish/how2heap/blob/master/glibc\_2.35/house\_of\_einherjar.c](https://github.com/shellphish/how2heap/blob/master/glibc\_2.35/house\_of\_einherjar.c)
* **CTF** [**https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_einherjar/#2016-seccon-tinypad**](https://ctf-wiki.mahaloz.re/pwn/linux/glibc-heap/house\_of\_einherjar/#2016-seccon-tinypad)
* 포인터를 해제한 후에는 널로 초기화되지 않으므로 여전히 데이터에 액세스할 수 있음. 따라서 청크가 정렬되지 않은 바구니에 배치되고 포함된 포인터를 누출시키고 (libc 누출) 그 포인터에서 누출된 힙 주소를 얻은 후 새 힙이 정렬되지 않은 바구니에 배치되어 얻은 포인터에서 힙 주소를 누출시킴.
* [**baby-talk. DiceCTF 2024**](https://7rocky.github.io/en/ctf/other/dicectf/baby-talk/)
* `strtok`에서의 널 바이트 오버플로우 버그
* House of Einherjar를 사용하여 중첩된 청크 상황을 얻고 임의 쓰기 원시를 얻기 위해 Tcache 독감을 마무리함.
