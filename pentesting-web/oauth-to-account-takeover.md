# OAuth zur √úbernahme von Konten

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}


## Grundlegende Informationen <a href="#d4a8" id="d4a8"></a>

OAuth bietet verschiedene Versionen, mit grundlegenden Einblicken unter [OAuth 2.0-Dokumentation](https://oauth.net/2/). Diese Diskussion konzentriert sich haupts√§chlich auf den weit verbreiteten [OAuth 2.0-Autorisierungscode-Grant-Typ](https://oauth.net/2/grant-types/authorization-code/), der ein **Autorisierungsframework bereitstellt, das einer Anwendung erm√∂glicht, auf das Konto eines Benutzers in einer anderen Anwendung zuzugreifen oder Aktionen durchzuf√ºhren** (der Autorisierungsserver).

Betrachten Sie eine hypothetische Website _**https://example.com**_, die dazu dient, **alle Ihre Social-Media-Beitr√§ge** anzuzeigen, einschlie√ülich privater Beitr√§ge. Um dies zu erreichen, wird OAuth 2.0 eingesetzt. _https://example.com_ wird um Ihre Erlaubnis bitten, **auf Ihre Social-Media-Beitr√§ge zuzugreifen**. Daraufhin erscheint ein Zustimmungsbildschirm auf _https://socialmedia.com_, der die **angeforderten Berechtigungen und den Antrag stellenden Entwickler** auflistet. Nach Ihrer Autorisierung erh√§lt _https://example.com_ die M√∂glichkeit, **in Ihrem Namen auf Ihre Beitr√§ge zuzugreifen**.

Es ist wichtig, die folgenden Komponenten im OAuth 2.0-Framework zu verstehen:

- **Ressourcenbesitzer**: Sie als **Benutzer/Entit√§t** autorisieren den Zugriff auf Ihre Ressource, wie z.B. Ihre Social-Media-Konto-Beitr√§ge.
- **Ressourcenserver**: Der **Server, der authentifizierte Anfragen verwaltet**, nachdem die Anwendung im Namen des `Ressourcenbesitzers` ein `Zugriffstoken` erhalten hat, z.B. **https://socialmedia.com**.
- **Client-Anwendung**: Die **Anwendung, die die Autorisierung anfordert** vom `Ressourcenbesitzer`, wie z.B. **https://example.com**.
- **Autorisierungsserver**: Der **Server, der `Zugriffstoken` ausstellt** an die `Client-Anwendung` nach erfolgreicher Authentifizierung des `Ressourcenbesitzers` und Sicherung der Autorisierung, z.B. **https://socialmedia.com**.
- **client\_id**: Ein √∂ffentlicher, eindeutiger Bezeichner f√ºr die Anwendung.
- **client\_secret:** Ein vertraulicher Schl√ºssel, der nur der Anwendung und dem Autorisierungsserver bekannt ist und zur Generierung von `Zugriffstoken` verwendet wird.
- **response\_type**: Ein Wert, der den **Typ des angeforderten Tokens** angibt, wie z.B. `code`.
- **scope**: Das **Zugriffsniveau**, das die `Client-Anwendung` vom `Ressourcenbesitzer` anfordert.
- **redirect\_uri**: Die **URL, zu der der Benutzer nach der Autorisierung umgeleitet wird**. Diese muss in der Regel mit der vorregistrierten Umleitungs-URL √ºbereinstimmen.
- **state**: Ein Parameter zum **Aufrechterhalten von Daten w√§hrend der Umleitung des Benutzers zum und vom Autorisierungsserver**. Seine Einzigartigkeit ist entscheidend, um als **CSRF-Schutzmechanismus** zu dienen.
- **grant\_type**: Ein Parameter, der **den Grant-Typ und den Typ des zur√ºckzugebenden Tokens** angibt.
- **code**: Der Autorisierungscode vom `Autorisierungsserver`, der zusammen mit `client_id` und `client_secret` von der Client-Anwendung verwendet wird, um ein `Zugriffstoken` zu erhalten.
- **access\_token**: Das **Token, das die Client-Anwendung f√ºr API-Anfragen** im Namen des `Ressourcenbesitzers` verwendet.
- **refresh\_token**: Erm√∂glicht es der Anwendung, **ein neues `Zugriffstoken` zu erhalten, ohne den Benutzer erneut zur Eingabe aufzufordern**.

### Ablauf

Der **tats√§chliche OAuth-Ablauf** erfolgt wie folgt:

1. Sie navigieren zu [https://example.com](https://example.com) und w√§hlen die Schaltfl√§che "Mit Social Media integrieren".
2. Die Website sendet dann eine Anfrage an [https://socialmedia.com](https://socialmedia.com), um Ihre Autorisierung zu erhalten, damit die Anwendung von https://example.com auf Ihre Beitr√§ge zugreifen kann. Die Anfrage ist strukturiert als:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Sie werden dann mit einer Zustimmungsseite pr√§sentiert.

4. Nach Ihrer Zustimmung sendet Social Media eine Antwort an die `redirect_uri` mit den Parametern `code` und `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com verwendet diesen `code` zusammen mit seiner `client_id` und `client_secret`, um eine serverseitige Anfrage zu stellen und im Auftrag von Ihnen ein `access_token` zu erhalten, das den Zugriff auf die von Ihnen zugestimmten Berechtigungen erm√∂glicht:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Schlie√ülich endet der Prozess, wenn https://beispiel.com Ihren `access_token` verwendet, um einen API-Aufruf an Social Media zu t√§tigen, um Zugriff zu erhalten.

## Schwachstellen <a href="#323a" id="323a"></a>

### Offene redirect\_uri <a href="#cc36" id="cc36"></a>

Die `redirect_uri` ist f√ºr die Sicherheit bei OAuth- und OpenID-Implementierungen entscheidend, da sie angibt, wohin sensible Daten wie Autorisierungscodes nach der Autorisierung gesendet werden. Wenn sie falsch konfiguriert ist, k√∂nnten Angreifer diese Anfragen auf b√∂sartige Server umleiten und so Account-√úbernahmen erm√∂glichen.

Die Ausbeutungstechniken variieren je nach Validierungslogik des Autorisierungsservers. Sie reichen von streichenden Pfad√ºbereinstimmungen bis zur Akzeptanz jeder URL innerhalb der angegebenen Dom√§ne oder Unterverzeichnisses. H√§ufige Ausbeutungsmethoden umfassen offene Weiterleitungen, Pfadtraversierung, Ausnutzung schwacher Regexes und HTML-Injektionen zum Diebstahl von Tokens.

Neben `redirect_uri` sind auch andere OAuth- und OpenID-Parameter wie `client_uri`, `policy_uri`, `tos_uri` und `initiate_login_uri` anf√§llig f√ºr Weiterleitungsangriffe. Diese Parameter sind optional und ihre Unterst√ºtzung variiert je nach Server.

F√ºr diejenigen, die einen OpenID-Server ins Visier nehmen, listet der Entdeckungsendpunkt (`**.well-known/openid-configuration**`) oft wertvolle Konfigurationsdetails wie `registration_endpoint`, `request_uri_parameter_supported` und "`require_request_uri_registration`. Diese Details k√∂nnen dabei helfen, den Registrierungsendpunkt und andere Konfigurationsdetails des Servers zu identifizieren.

### XSS in Redirect-Implementierung <a href="#bda5" id="bda5"></a>

Wie in diesem Bug-Bounty-Bericht erw√§hnt [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) k√∂nnte es m√∂glich sein, dass die Redirect-**URL in der Antwort** des Servers nach der Authentifizierung des Benutzers **reflektiert wird und anf√§llig f√ºr XSS ist**. M√∂glicher Payload zum Testen:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Unzureichende Behandlung des Zustandsparameters <a href="#bda5" id="bda5"></a>

Bei OAuth-Implementierungen kann der Missbrauch oder das Weglassen des **`state`-Parameters** das Risiko von **Cross-Site Request Forgery (CSRF)**-Angriffen erheblich erh√∂hen. Diese Schwachstelle tritt auf, wenn der `state`-Parameter entweder **nicht verwendet wird, als statischer Wert verwendet wird oder nicht ordnungsgem√§√ü validiert wird**, was es Angreifern erm√∂glicht, CSRF-Schutzmechanismen zu umgehen.

Angreifer k√∂nnen dies ausnutzen, indem sie den Autorisierungsprozess abfangen, um ihr Konto mit dem Konto eines Opfers zu verkn√ºpfen, was zu potenziellen **Account-√úbernahmen** f√ºhrt. Dies ist besonders kritisch in Anwendungen, in denen OAuth f√ºr **Authentifizierungszwecke** verwendet wird.

Beispiele f√ºr diese Schwachstelle wurden in verschiedenen **CTF-Herausforderungen** und **Hacking-Plattformen** dokumentiert, was ihre praktischen Auswirkungen verdeutlicht. Das Problem erstreckt sich auch auf Integrationen mit Drittanbieterdiensten wie **Slack**, **Stripe** und **PayPal**, wo Angreifer Benachrichtigungen oder Zahlungen auf ihre Konten umleiten k√∂nnen.

Eine ordnungsgem√§√üe Behandlung und Validierung des **`state`-Parameters** sind entscheidend, um sich gegen CSRF zu sch√ºtzen und den OAuth-Fluss abzusichern.

### Vor der Account-√úbernahme <a href="#ebe4" id="ebe4"></a>

1. **Ohne E-Mail-Verifizierung bei der Kontenerstellung**: Angreifer k√∂nnen vorsorglich ein Konto mit der E-Mail des Opfers erstellen. Wenn das Opfer sp√§ter einen Drittanbieterdienst f√ºr die Anmeldung verwendet, k√∂nnte die Anwendung versehentlich dieses Drittanbieterkonto mit dem vorab erstellten Konto des Angreifers verkn√ºpfen, was zu unbefugtem Zugriff f√ºhrt.

2. **Ausnutzen der laxen OAuth-E-Mail-Verifizierung**: Angreifer k√∂nnen OAuth-Dienste ausnutzen, die keine E-Mail-Verifizierung durchf√ºhren, indem sie sich bei ihrem Dienst registrieren und dann die Kontoe-Mail in die des Opfers √§ndern. Diese Methode birgt √§hnlich wie das erste Szenario ein Risiko f√ºr unbefugten Kontozugriff, jedoch √ºber einen anderen Angriffsvektor.

### Offenlegung von Geheimnissen <a href="#e177" id="e177"></a>

Die Identifizierung und der Schutz geheimer OAuth-Parameter sind entscheidend. W√§hrend die **`client_id`** sicher offengelegt werden kann, birgt die Offenlegung des **`client_secret`** erhebliche Risiken. Wenn das `client_secret` kompromittiert ist, k√∂nnen Angreifer die Identit√§t und das Vertrauen der Anwendung ausnutzen, um **Benutzerzugriffstoken** und private Informationen zu stehlen.

Eine h√§ufige Schwachstelle entsteht, wenn Anwendungen f√§lschlicherweise den Austausch des Autorisierungscodes f√ºr ein Zugriffstoken auf der Client-Seite anstelle der Server-Seite behandeln. Dieser Fehler f√ºhrt zur Offenlegung des `client_secret`, was es Angreifern erm√∂glicht, `access_tokens` unter dem Deckmantel der Anwendung zu generieren. Dar√ºber hinaus k√∂nnten Angreifer durch Social Engineering Privilegien eskalieren, indem sie zus√§tzliche Berechtigungen zur OAuth-Autorisierung hinzuf√ºgen und so den vertrauensw√ºrdigen Status der Anwendung weiter ausnutzen.

### Bruteforce des Client Secrets

Sie k√∂nnen versuchen, das **Client-Secret bruteforcen** eines Dienstanbieters mit dem Identit√§tsanbieter, um Konten zu stehlen.\
Die Anfrage an BF k√∂nnte √§hnlich aussehen:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer-Header leckt Code + State

Sobald der Client den **Code und den Status** hat, ist es anf√§llig, wenn es **im Referer-Header erscheint**, wenn er zu einer anderen Seite navigiert.

### Zugriffstoken im Browserverlauf gespeichert

Gehen Sie zum **Browserverlauf und √ºberpr√ºfen Sie, ob das Zugriffstoken dort gespeichert ist**.

### Dauerhafter Autorisierungscode

Der **Autorisierungscode sollte nur f√ºr kurze Zeit g√ºltig sein, um das Zeitfenster zu begrenzen, in dem ein Angreifer ihn stehlen und verwenden kann**.

### Autorisierungs-/Auffrischungstoken nicht an den Client gebunden

Wenn Sie den **Autorisierungscode erhalten und mit einem anderen Client verwenden k√∂nnen, k√∂nnen Sie andere Konten √ºbernehmen**.

### Erfolgreiche Pfade, XSS, Iframes & Post-Nachrichten zum Lecken von Code- & Statuswerten

**[√úberpr√ºfen Sie diesen Beitrag](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)**

### AWS Cognito <a href="#bda5" id="bda5"></a>

In diesem Bug-Bounty-Bericht: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) k√∂nnen Sie sehen, dass das **Token**, das **AWS Cognito** dem Benutzer zur√ºckgibt, m√∂glicherweise **ausreichende Berechtigungen hat, um die Benutzerdaten zu √ºberschreiben**. Daher, wenn Sie die **Benutzer-E-Mail-Adresse in eine andere Benutzer-E-Mail-Adresse √§ndern k√∂nnen**, k√∂nnten Sie in der Lage sein, **andere Konten zu √ºbernehmen**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
F√ºr weitere detaillierte Informationen dar√ºber, wie man AWS Cognito missbrauchen kann, siehe:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Missbrauch von Tokens anderer Apps <a href="#bda5" id="bda5"></a>

Wie in [**diesem Bericht erw√§hnt**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), k√∂nnten OAuth-Flows, die erwarten, den **Token** (und nicht einen Code) zu erhalten, verwundbar sein, wenn sie nicht √ºberpr√ºfen, ob der Token zur App geh√∂rt.

Dies liegt daran, dass ein **Angreifer** eine **Anwendung erstellen k√∂nnte, die OAuth unterst√ºtzt und sich mit Facebook anmeldet** (zum Beispiel) in seiner eigenen Anwendung. Dann, sobald ein Opfer sich mit Facebook in der **Anwendung des Angreifers anmeldet**, k√∂nnte der Angreifer den **OAuth-Token des Benutzers, der seiner Anwendung gegeben wurde, erhalten und verwenden, um sich in der OAuth-Anwendung des Opfers mit dem Token des Opfers anzumelden**.

{% hint style="danger" %}
Daher, wenn es dem Angreifer gelingt, den Benutzer dazu zu bringen, seine eigene OAuth-Anwendung zu nutzen, wird er in der Lage sein, das Konto des Opfers in Anwendungen zu √ºbernehmen, die einen Token erwarten und nicht √ºberpr√ºfen, ob der Token an ihre App-ID vergeben wurde.
{% endhint %}

### Zwei Links & Cookie <a href="#bda5" id="bda5"></a>

Laut [**diesem Bericht**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f) war es m√∂glich, ein Opfer dazu zu bringen, eine Seite mit einer **returnUrl** zu √∂ffnen, die auf den Host des Angreifers zeigt. Diese Information w√ºrde in einem Cookie (RU) gespeichert und in einem **sp√§teren Schritt** w√ºrde der **Prompt** den **Benutzer fragen**, ob er Zugriff auf diesen Host des Angreifers geben m√∂chte.

Um diesen Prompt zu umgehen, war es m√∂glich, einen Tab zu √∂ffnen, um den **OAuth-Flow** zu initiieren, der dieses RU-Cookie mit der **returnUrl** setzen w√ºrde, den Tab zu schlie√üen, bevor der Prompt angezeigt wird, und einen neuen Tab ohne diesen Wert zu √∂ffnen. Dann wird der **Prompt nicht √ºber den Host des Angreifers informieren**, aber das Cookie w√ºrde darauf gesetzt sein, so dass der **Token an den Host des Angreifers gesendet wird** in der Weiterleitung.

### SSRF-Parameter <a href="#bda5" id="bda5"></a>

**[√úberpr√ºfen Sie diese Forschung](https://portswigger.net/research/hidden-oauth-attack-vectors) f√ºr weitere Details zu dieser Technik.**

Die dynamische Client-Registrierung in OAuth dient als ein weniger offensichtlicher, aber kritischer Vektor f√ºr Sicherheitsl√ºcken, insbesondere f√ºr **Server-seitige Anfragef√§lschungen (SSRF)**-Angriffe. Dieser Endpunkt erm√∂glicht es OAuth-Servern, Details √ºber Client-Anwendungen zu erhalten, einschlie√ülich sensibler URLs, die ausgenutzt werden k√∂nnten.

**Hauptpunkte:**

- Die **dynamische Client-Registrierung** ist oft auf `/register` abgebildet und akzeptiert Details wie `client_name`, `client_secret`, `redirect_uris` und URLs f√ºr Logos oder JSON Web Key Sets (JWKs) √ºber POST-Anfragen.
- Diese Funktion entspricht den in **RFC7591** und **OpenID Connect Registration 1.0** festgelegten Spezifikationen, die Parameter enthalten, die potenziell anf√§llig f√ºr SSRF sind.
- Der Registrierungsprozess kann Server unbeabsichtigt verschiedenen SSRF-Risiken aussetzen:
- **`logo_uri`**: Eine URL f√ºr das Logo der Client-Anwendung, das vom Server abgerufen werden k√∂nnte, um SSRF auszul√∂sen oder zu XSS zu f√ºhren, wenn die URL falsch behandelt wird.
- **`jwks_uri`**: Eine URL zum JWK-Dokument des Clients, das bei b√∂sartiger Gestaltung den Server dazu bringen kann, ausgehende Anfragen an einen vom Angreifer kontrollierten Server zu senden.
- **`sector_identifier_uri`**: Verweist auf ein JSON-Array von `redirect_uris`, das der Server abrufen k√∂nnte, was eine SSRF-M√∂glichkeit schafft.
- **`request_uris`**: Listet erlaubte Anforderungs-URIs f√ºr den Client auf, die ausgenutzt werden k√∂nnen, wenn der Server diese URIs zu Beginn des Autorisierungsprozesses abruft.

**Ausbeutungsstrategie:**

- SSRF kann ausgel√∂st werden, indem ein neuer Client mit b√∂sartigen URLs in Parametern wie `logo_uri`, `jwks_uri` oder `sector_identifier_uri` registriert wird.
- W√§hrend eine direkte Ausnutzung √ºber `request_uris` durch Whitelist-Steuerungen gemildert werden kann, kann die Bereitstellung eines vorregistrierten, vom Angreifer kontrollierten `request_uri` SSRF w√§hrend der Autorisierungsphase erleichtern.

## Race Conditions bei OAuth-Anbietern

Wenn die Plattform, die Sie testen, ein OAuth-Anbieter ist, [**lesen Sie dies, um m√∂gliche Race Conditions zu testen**](race-condition.md).

## Referenzen

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)


<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
