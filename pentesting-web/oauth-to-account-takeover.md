# OAuth vers la prise de contr√¥le de compte

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informations de base <a href="#d4a8" id="d4a8"></a>

Il existe plusieurs versions d'OAuth, vous pouvez lire [https://oauth.net/2/](https://oauth.net/2/) pour obtenir une compr√©hension de base.

Dans cet article, nous nous concentrerons sur le flux le plus courant que vous rencontrerez aujourd'hui, qui est le [type d'autorisation de code d'autorisation OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/). En essence, OAuth fournit aux d√©veloppeurs un **m√©canisme d'autorisation permettant √† une application d'acc√©der √† des donn√©es ou d'effectuer certaines actions contre votre compte, depuis une autre application** (le serveur d'autorisation).

Par exemple, disons que le site _**https://yourtweetreader.com**_ a une fonctionnalit√© pour **afficher tous les tweets que vous avez jamais envoy√©s**, y compris les tweets priv√©s. Pour ce faire, OAuth 2.0 est introduit. _https://yourtweetreader.com_ vous demandera d'**autoriser leur application Twitter √† acc√©der √† tous vos Tweets**. Une page de consentement appara√Ætra sur _https://twitter.com_ affichant quelles **permissions sont demand√©es**, et qui est le d√©veloppeur qui les demande. Une fois que vous autorisez la demande, _https://yourtweetreader.com_ sera **capable d'acc√©der √† vos Tweets en votre nom**.

√âl√©ments importants √† comprendre dans un contexte OAuth 2.0 :

* **propri√©taire de la ressource** : Le `propri√©taire de la ressource` est l'**utilisateur/entit√©** accordant l'acc√®s √† leur ressource prot√©g√©e, comme leurs Tweets de compte Twitter. Dans cet exemple, ce serait **vous**.
* **serveur de ressources** : Le `serveur de ressources` est le **serveur g√©rant les requ√™tes authentifi√©es** apr√®s que l'application a obtenu un `jeton d'acc√®s` au nom du `propri√©taire de la ressource`. Dans cet exemple, ce serait **https://twitter.com**
* **application cliente** : L'`application cliente` est l'**application demandant l'autorisation** du `propri√©taire de la ressource`. Dans cet exemple, ce serait **https://yourtweetreader.com**.
* **serveur d'autorisation** : Le `serveur d'autorisation` est le **serveur √©mettant des `jetons d'acc√®s`** √† l'`application cliente` **apr√®s avoir authentifi√© avec succ√®s** le `propri√©taire de la ressource` et obtenu l'autorisation. Dans l'exemple ci-dessus, ce serait **https://twitter.com**
* **client_id** : Le `client_id` est l'**identifiant de l'application**. C'est un identifiant unique **public, non secret**.
* **client_secret** : Le `client_secret` est un **secret connu uniquement de l'application et du serveur d'autorisation**. Il est utilis√© pour g√©n√©rer des `jetons d'acc√®s`
* **response_type** : Le `response_type` est une valeur d√©taillant **quel type de jeton** est demand√©, tel que `code`
* **scope** : Le `scope` est le **niveau d'acc√®s demand√©** que l'`application cliente` demande au `propri√©taire de la ressource`
* **redirect_uri** : Le `redirect_uri` est l'**URL vers laquelle l'utilisateur est redirig√© apr√®s que l'autorisation est compl√®te**. Cela doit g√©n√©ralement correspondre √† l'URL de redirection que vous avez pr√©alablement enregistr√©e avec le service
* **state** : Le param√®tre `state` peut **conserver des donn√©es entre le moment o√π l'utilisateur est dirig√© vers le serveur d'autorisation et son retour**. Il est important que cela soit une valeur unique car il sert de m√©canisme de protection contre les **CSRF** s'il contient une valeur unique ou al√©atoire par requ√™te
* **grant_type** : Le param√®tre `grant_type` explique **quel est le type de subvention**, et quel jeton va √™tre retourn√©
* **code** : Ce `code` est le code d'autorisation re√ßu du `serveur d'autorisation` qui sera dans le param√®tre de cha√Æne de requ√™te ‚Äúcode‚Äù dans cette requ√™te. Ce code est utilis√© conjointement avec le `client_id` et le `client_secret` par l'application cliente pour r√©cup√©rer un `jeton d'acc√®s`
* **access_token** : Le `access_token` est le **jeton que l'application cliente utilise pour effectuer des requ√™tes API** au nom d'un `propri√©taire de la ressource`
* **refresh_token** : Le `refresh_token` permet √† une application d'**obtenir un nouveau `jeton d'acc√®s` sans solliciter l'utilisateur**

### Exemple r√©el

En rassemblant tout cela, voici √† quoi ressemble un **flux OAuth r√©el** :

1. Vous visitez [https://yourtweetreader.com](https://yourtweetreader.com) et cliquez sur le bouton ‚ÄúInt√©grer avec Twitter‚Äù.
2. [https://yourtweetreader.com](https://yourtweetreader.com) envoie une demande √† [https://twitter.com](https://twitter.com) vous demandant, en tant que propri√©taire de la ressource, d'autoriser l'application Twitter de https://yourtweetreader.com √† acc√©der √† vos Tweets. La demande ressemblera √† :
```
https://twitter.com/auth
?response_type=code
&client_id=yourtweetreader_clientId
&redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
&scope=readTweets
&state=kasodk9d1jd992k9klaskdh123
```
3\. Une page de consentement s'affichera :

![](https://miro.medium.com/max/1215/1\*y66EY3Fn2qn-NPI9nhZC7A.png)

4\. Une fois accept√©, Twitter enverra une requ√™te au `redirect_uri` avec les param√®tres `code` et `state` :
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123
```
5\. [https://yourtweetreader.com](https://yourtweetreader.com) va ensuite prendre ce `code`, et en utilisant l'`client_id` et l'`client_secret` de leur application, va faire une demande depuis le serveur pour r√©cup√©rer un `access_token` en votre nom, ce qui leur permettra d'acc√©der aux permissions auxquelles vous avez consenti :
```
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", "client_secret": "yourtweetreader_clientSecret", "code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}
```
6\. Finalement, le flux est complet et [https://yourtweetreader.com](https://yourtweetreader.com) effectuera un appel API √† Twitter avec votre `access_token` pour acc√©der √† vos Tweets.

## D√©couvertes de Bug Bounty <a href="#323a" id="323a"></a>

Maintenant, la partie int√©ressante ! Il y a beaucoup de choses qui peuvent mal tourner dans une impl√©mentation OAuth, voici les diff√©rentes cat√©gories de bugs que je vois fr√©quemment :

### Configuration faible de redirect\_uri <a href="#cc36" id="cc36"></a>

Le `redirect_uri` est tr√®s important car **des donn√©es sensibles, telles que le `code`, sont ajout√©es √† cette URL** apr√®s autorisation. Si le `redirect_uri` peut √™tre redirig√© vers un **serveur contr√¥l√© par un attaquant**, cela signifie que l'attaquant peut potentiellement **prendre le contr√¥le du compte d'une victime** en utilisant le `code` lui-m√™me, et en acc√©dant aux donn√©es de la victime.

La mani√®re dont cela va √™tre exploit√© variera selon le serveur d'autorisation. **Certains** vont **uniquement accepter** le chemin **`redirect_uri` exact sp√©cifi√© dans l'application cliente**, mais certains vont **accepter n'importe quoi** dans le m√™me domaine ou sous-r√©pertoire du `redirect_uri`.

Selon la logique g√©r√©e par le serveur, il existe un certain nombre de techniques pour contourner un `redirect_uri`. Dans une situation o√π un `redirect_uri` est [https://yourtweetreader.com](https://yourtweetreader.com)/callback, celles-ci incluent :

* Redirections ouvertes : [`https://yourtweetreader.com`](https://yourtweetreader.com)`/callback?redirectUrl=https://evil.com`
* Travers√©e de chemin : `https://yourtweetreader.com/callback/../redirect?url=https://evil.com`
* Regexes faibles de `redirect_uri` : `https://yourtweetreader.com.evil.com`
* Injection HTML et vol de tokens via l'en-t√™te referer : `https://yourtweetreader.com/callback/home/attackerimg.jpg`

**D'autres param√®tres** qui peuvent √™tre vuln√©rables aux Redirections Ouvertes sont :

* **client\_uri** - URL de la page d'accueil de l'application cliente
* **policy\_uri** - URL que l'application cliente Partie Fiable fournit pour que l'utilisateur final puisse lire comment ses donn√©es de profil seront utilis√©es.
* **tos\_uri** - URL que l'application cliente Partie Fiable fournit pour que l'utilisateur final puisse lire les conditions de service de la Partie Fiable.
* **initiate\_login\_uri** - URI utilisant le sch√©ma https qui peut √™tre utilis√© par un tiers pour initier une connexion par le RP. Devrait √©galement √™tre utilis√© pour la redirection c√¥t√© client.

Tous ces param√®tres sont **optionnels selon les sp√©cifications OAuth et OpenID** et ne sont pas toujours pris en charge sur un serveur particulier, il est donc toujours utile d'identifier quels param√®tres sont pris en charge sur votre serveur.

Si vous ciblez un serveur OpenID, le point de d√©couverte √† \*\*`.well-known/openid-configuration`\*\* contient parfois des param√®tres tels que "_registration\_endpoint_", "_request\_uri\_parameter\_supported_", et "_require\_request\_uri\_registration_". Ceux-ci peuvent vous aider √† trouver le point de terminaison d'inscription et d'autres valeurs de configuration du serveur.

### XSS dans l'impl√©mentation de redirection <a href="#bda5" id="bda5"></a>

Comme mentionn√© dans ce rapport de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) il se peut que l'URL de redirection **soit refl√©t√©e dans la r√©ponse** du serveur apr√®s l'authentification de l'utilisateur, √©tant **vuln√©rable au XSS**. Payload possible √† tester :
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Gestion incorrecte du param√®tre `state` <a href="#bda5" id="bda5"></a>

Tr√®s souvent, le param√®tre **`state` est compl√®tement omis ou utilis√© de mani√®re incorrecte**. Si un param√®tre `state` est **inexistant**, **ou une valeur statique** qui ne change jamais, le flux OAuth sera tr√®s probablement **vuln√©rable au CSRF**. Parfois, m√™me s'il existe un param√®tre `state`, **l'application peut ne faire aucune validation de ce param√®tre** et une attaque fonctionnera. La mani√®re d'exploiter cela serait de passer par le processus d'autorisation sur votre propre compte, et de mettre en pause juste apr√®s avoir autoris√©. Vous rencontrerez alors une requ√™te telle que :
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
```
Apr√®s avoir re√ßu cette requ√™te, vous pouvez alors **abandonner la requ√™te car ces codes sont g√©n√©ralement √† usage unique**. Vous pouvez ensuite envoyer cette URL √† un **utilisateur connect√©, et cela ajoutera votre compte √† leur compte**. Au premier abord, cela peut ne pas sembler tr√®s sensible puisque vous ajoutez simplement votre compte √† celui d'une victime. Cependant, de nombreuses impl√©mentations OAuth sont utilis√©es √† des fins de connexion, donc si vous pouvez ajouter votre compte Google qui est utilis√© pour vous connecter, vous pourriez potentiellement r√©aliser une **prise de contr√¥le de compte** en un seul clic, car se connecter avec votre compte Google vous donnerait acc√®s au compte de la victime.

Vous pouvez trouver un **exemple** √† ce sujet dans ce [**compte-rendu de CTF**](https://github.com/gr455/ctf-writeups/blob/master/hacktivity20/notes\_surfer.md) et dans la **machine HTB appel√©e Oouch**.

J'ai √©galement vu le param√®tre `state` utilis√© comme valeur de redirection suppl√©mentaire √† plusieurs reprises. L'application utilisera `redirect_uri` pour la redirection initiale, mais ensuite le param√®tre `state` comme une seconde redirection qui pourrait contenir le `code` dans les param√®tres de requ√™te, ou l'en-t√™te referer.

Un point important √† noter est que cela ne s'applique pas seulement aux situations de connexion et de prise de contr√¥le de compte. J'ai vu des mauvaises configurations dans :

* Les int√©grations Slack permettant √† un attaquant d'ajouter leur compte Slack comme destinataire de toutes les notifications/messages
* Les int√©grations Stripe permettant √† un attaquant de remplacer les informations de paiement et d'accepter les paiements des clients de la victime
* Les int√©grations PayPal permettant √† un attaquant d'ajouter leur compte PayPal au compte de la victime, ce qui d√©poserait l'argent sur le PayPal de l'attaquant

### Avant la prise de contr√¥le de compte <a href="#ebe4" id="ebe4"></a>

L'un des autres probl√®mes courants que je vois est lorsque les applications permettent de "Se connecter avec X" mais aussi avec un nom d'utilisateur/mot de passe. Il y a 2 fa√ßons diff√©rentes d'attaquer cela :

1. Si l'application **ne n√©cessite pas de v√©rification de l'email lors de la cr√©ation du compte**, essayez **de cr√©er un compte avec l'adresse email d'une victime et un mot de passe d'attaquant** avant que la victime ne se soit enregistr√©e. Si la **victime** essaie ensuite de s'enregistrer ou de se connecter **avec un tiers**, comme Google, il est possible que l'application fasse une recherche, voie que l'email est d√©j√† enregistr√©, puis **lie leur compte Google au compte cr√©√© par l'attaquant**. C'est une "**prise de contr√¥le de compte pr√©alable**" o√π un attaquant aura acc√®s au compte de la victime s'il l'a cr√©√© avant que la victime ne s'enregistre.
2. Si une **application OAuth ne n√©cessite pas de v√©rification de l'email**, essayez de vous inscrire avec cette application OAuth puis changez l'adresse email pour une **adresse email de la victime**. Le m√™me probl√®me que ci-dessus pourrait exister, mais vous l'attaqueriez dans l'autre sens et obtiendriez l'acc√®s au compte de la victime pour une prise de contr√¥le de compte.

### Divulgation de secrets <a href="#e177" id="e177"></a>

Il est tr√®s important de reconna√Ætre **quels param√®tres OAuth sont secrets**, et de les prot√©ger. Par exemple, divulguer le `client_id` est parfaitement acceptable et n√©cessaire, mais divulguer le **`client_secret` est dangereux**. Si cela est divulgu√©, l'**attaquant** peut potentiellement **abuser de la confiance et de l'identit√© de l'application cliente de confiance pour voler les `access_tokens` des utilisateurs et les informations/acc√®s priv√©s pour leurs comptes int√©gr√©s**. Pour revenir √† notre exemple pr√©c√©dent, un probl√®me que j'ai vu est d'effectuer cette √©tape depuis le client, au lieu du serveur :

_5._ [_https://yourtweetreader.com_](https://yourtweetreader.com) _prendra ensuite ce `code`, et en utilisant l'`client_id` et l'`client_secret` de leur application, fera une requ√™te depuis le serveur pour r√©cup√©rer un `access_token` en votre nom, ce qui leur permettra d'acc√©der aux permissions auxquelles vous avez consenti._

**Si cela est fait depuis le client, le `client_secret` sera divulgu√© et les utilisateurs pourront g√©n√©rer des `access_tokens` au nom de l'application**. Avec un peu d'ing√©nierie sociale, ils peuvent √©galement **ajouter plus de scopes √† l'autorisation OAuth** et tout semblera l√©gitime car la requ√™te proviendra de l'application cliente de confiance.

### Bruteforce du Client Secret

Vous pouvez essayer de **bruteforcer le `client_secret`** d'un fournisseur de services avec le fournisseur d'identit√© afin d'essayer de voler des comptes.\
La requ√™te de BF peut ressembler √† :
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Fuite du Header Referer avec Code + √âtat

Une fois que le client a le **code et l'√©tat**, s'ils sont **refl√©t√©s dans le header Referer** lorsqu'il navigue vers une autre page, alors il est vuln√©rable.

### Jeton d'Acc√®s Stock√© dans l'Historique du Navigateur

Allez dans **l'historique du navigateur et v√©rifiez si le jeton d'acc√®s y est enregistr√©**.

### Code d'Autorisation √âternel

Le **code d'autorisation devrait avoir une dur√©e de vie limit√©e pour r√©duire la fen√™tre de temps pendant laquelle un attaquant peut le voler et l'utiliser**.

### Jeton d'Autorisation/Actualisation non li√© au client

Si vous pouvez obtenir le **code d'autorisation et l'utiliser avec un client diff√©rent, alors vous pouvez prendre le contr√¥le d'autres comptes**.

### Chemins Heureux, XSS, Iframes & Messages Post pour fuite de code & valeurs d'√©tat

### AWS Cognito <a href="#bda5" id="bda5"></a>

Dans ce rapport de bug bounty : [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) vous pouvez voir que le **token** que **AWS Cognito** renvoie √† l'utilisateur peut avoir **assez de permissions pour √©craser les donn√©es de l'utilisateur**. Par cons√©quent, si vous pouvez **changer l'email de l'utilisateur pour un autre email d'utilisateur**, vous pourriez √™tre capable de **prendre le contr√¥le** d'autres comptes.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Pour plus d'informations d√©taill√©es sur la mani√®re d'abuser d'AWS Cognito, consultez :

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abuser des tokens d'autres applications <a href="#bda5" id="bda5"></a>

Comme [**mentionn√© dans ce compte-rendu**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), les flux OAuth qui s'attendent √† recevoir le **token** (et non un code) pourraient √™tre vuln√©rables s'ils ne v√©rifient pas que le token appartient √† l'application.

Cela est d√ª au fait qu'un **attaquant** pourrait cr√©er une **application prenant en charge OAuth et se connecter avec Facebook** (par exemple) dans sa propre application. Ensuite, une fois qu'une victime se connecte avec Facebook dans l'**application de l'attaquant**, l'attaquant pourrait obtenir le **token OAuth de l'utilisateur donn√© √† son application, et l'utiliser pour se connecter dans l'application OAuth de la victime en utilisant le token de l'utilisateur de la victime**.

{% hint style="danger" %}
Par cons√©quent, si l'attaquant parvient √† faire acc√©der l'utilisateur √† sa propre application OAuth, il pourra prendre le contr√¥le du compte de la victime dans les applications qui s'attendent √† un token et qui ne v√©rifient pas si le token a √©t√© accord√© √† leur ID d'application.
{% endhint %}

### Deux liens & cookie <a href="#bda5" id="bda5"></a>

Selon [**ce compte-rendu**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), il √©tait possible de faire ouvrir par une victime une page avec un **returnUrl** pointant vers l'h√¥te de l'attaquant. Cette information serait **stock√©e dans un cookie (RU)** et dans une **√©tape ult√©rieure**, l'**invite** demandera √† l'**utilisateur** s'il souhaite donner acc√®s √† cet h√¥te de l'attaquant.

Pour contourner cette invite, il √©tait possible d'ouvrir un onglet pour initier le **flux Oauth** qui d√©finirait ce cookie RU en utilisant le **returnUrl**, de fermer l'onglet avant que l'invite ne soit affich√©e, et d'ouvrir un nouvel onglet sans cette valeur. Ensuite, l'**invite n'informera pas sur l'h√¥te de l'attaquant**, mais le cookie serait d√©fini pour lui, donc le **token sera envoy√© √† l'h√¥te de l'attaquant** dans la redirection.

### Param√®tres SSRFs <a href="#bda5" id="bda5"></a>

L'une des URL cach√©es que vous pourriez manquer est le **point de terminaison d'enregistrement de client dynamique**. Afin d'authentifier les utilisateurs avec succ√®s, les serveurs OAuth doivent conna√Ætre les d√©tails de l'application cliente, tels que le "client\_name", "client\_secret", "redirect\_uris", etc. Ces d√©tails peuvent √™tre fournis via une configuration locale, mais les serveurs d'autorisation OAuth peuvent √©galement avoir un **point de terminaison d'enregistrement sp√©cial**. Ce point de terminaison est normalement mapp√© sur "/register" et accepte les requ√™tes POST avec le format suivant :
```json
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
"application_type": "web",
"redirect_uris": ["https://client.example.org/callback"],
"client_name": "My Example",
"logo_uri": "https://client.example.org/logo.png",
"subject_type": "pairwise",
"sector_identifier_uri": "https://example.org/rdrct_uris.json",
"token_endpoint_auth_method": "client_secret_basic",
"jwks_uri": "https://client.example.org/public_keys.jwks",
"contacts": ["ve7jtb@example.org"],
"request_uris": ["https://client.example.org/rf.txt"]
}
```
```markdown
Il existe deux sp√©cifications qui d√©finissent les param√®tres dans cette requ√™te : [RFC7591](https://tools.ietf.org/html/rfc7591) pour OAuth et [Openid Connect Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html#rfc.section.3.1).

Comme vous pouvez le voir ici, un certain nombre de ces valeurs sont transmises via des r√©f√©rences URL et semblent √™tre des cibles potentielles pour [Server Side Request Forgery](https://portswigger.net/web-security/ssrf). En m√™me temps, la plupart des serveurs que nous avons test√©s ne r√©solvent pas imm√©diatement ces URL lorsqu'ils re√ßoivent une demande d'inscription. Au lieu de cela, ils **enregistrent simplement ces param√®tres et les utilisent plus tard pendant le flux d'autorisation OAuth**. En d'autres termes, c'est plus comme un SSRF de second ordre, ce qui rend la d√©tection en bo√Æte noire plus difficile.

Les param√®tres suivants sont particuli√®rement int√©ressants pour les attaques SSRF :

* **logo\_uri** - URL qui fait r√©f√©rence √† un **logo pour l'application cliente**. **Apr√®s avoir enregistr√© un client**, vous pouvez essayer d'appeler le point de terminaison d'autorisation OAuth ("/authorize") en utilisant votre nouveau "client\_id". Apr√®s la connexion, le serveur vous demandera d'approuver la demande et **peut afficher l'image √† partir du "logo\_uri"**. Si le **serveur r√©cup√®re l'image par lui-m√™me**, le SSRF devrait √™tre d√©clench√© par cette √©tape. Alternativement, le serveur peut simplement inclure le logo via une balise **client-side "\<img>"**. Bien que cela ne conduise pas √† SSRF, cela peut conduire √† **XSS si l'URL n'est pas √©chapp√©e**.
*   **jwks\_uri** - URL pour le document JSON Web Key Set \[JWK] du client. Ce jeu de cl√©s est n√©cessaire sur le serveur pour valider les requ√™tes sign√©es faites au point de terminaison du jeton lors de l'utilisation de JWT pour l'authentification du client \[RFC7523]. Pour tester le SSRF dans ce param√®tre, **enregistrez une nouvelle application cliente avec un "jwks\_uri" malveillant**, effectuez le processus d'autorisation pour **obtenir un code d'autorisation pour n'importe quel utilisateur, puis r√©cup√©rez le point de terminaison "/token"** avec le corps suivant :

`POST /oauth/token HTTP/1.1`\
`...`\
```
`grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion=eyJhbGci...`

Si vuln√©rable, le **serveur devrait effectuer une requ√™te HTTP de serveur √† serveur vers le "jwks\_uri" fourni** car il a besoin de cette cl√© pour v√©rifier la validit√© du param√®tre "client\_assertion" dans votre requ√™te. Cela sera probablement seulement une **vuln√©rabilit√© SSRF aveugle**, car le serveur attend une r√©ponse JSON appropri√©e.
* **sector\_identifier\_uri** - Cette URL fait r√©f√©rence √† un fichier avec un seul **tableau JSON de valeurs redirect\_uri**. Si pris en charge, le serveur peut **r√©cup√©rer cette valeur d√®s que vous soumettez la demande d'inscription dynamique**. Si cela n'est pas r√©cup√©r√© imm√©diatement, essayez d'effectuer une autorisation pour ce client sur le serveur. Comme il a besoin de conna√Ætre les redirect\_uris pour compl√©ter le flux d'autorisation, cela forcera le serveur √† faire une requ√™te √† votre sector\_identifier\_uri malveillant.
*   **request\_uris** - Un tableau des **request\_uris autoris√©s pour ce client**. Le param√®tre "request\_uri" peut √™tre pris en charge sur le point de terminaison d'autorisation pour fournir une URL qui contient un JWT avec les informations de la demande (voir [https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2)).

M√™me si l'inscription dynamique du client n'est pas activ√©e, ou si elle n√©cessite une authentification, nous pouvons essayer de r√©aliser un SSRF sur le point de terminaison d'autorisation simplement en utilisant "request\_uri":\\

`GET /authorize?response_type=code%20id_token&client_id=sclient1&request_uri=https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt`

Note : ne confondez pas ce param√®tre avec "redirect\_uri". Le "redirect\_uri" est utilis√© pour la redirection apr√®s autorisation, tandis que **"request\_uri" est r√©cup√©r√© par le serveur au d√©but du processus d'autorisation**.

En m√™me temps, de nombreux serveurs que nous avons vus n'autorisent pas des valeurs "request\_uri" arbitraires : ils n'autorisent que des URL pr√©alablement enregistr√©es pendant le processus d'inscription du client. C'est pourquoi nous devons fournir "request\_uris": "https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt" au pr√©alable.

## Conditions de course chez les fournisseurs OAuth

Si la plateforme que vous testez est un fournisseur OAuth [**lisez ceci pour tester d'√©ventuelles conditions de course**](race-condition.md).

## R√©f√©rences

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF** Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
```
