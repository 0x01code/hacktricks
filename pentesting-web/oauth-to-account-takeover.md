# OAuth per Account takeover

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Informazioni di base <a href="#d4a8" id="d4a8"></a>

OAuth offre varie versioni, con informazioni di base accessibili alla [documentazione di OAuth 2.0](https://oauth.net/2/). Questa discussione si concentra principalmente sul tipo di concessione del codice di autorizzazione di OAuth 2.0, ampiamente utilizzato, fornendo un **framework di autorizzazione che consente a un'applicazione di accedere o eseguire azioni sull'account di un utente in un'altra applicazione** (il server di autorizzazione).

Considera un sito web ipotetico _**https://example.com**_, progettato per **mostrare tutti i tuoi post sui social media**, inclusi quelli privati. Per raggiungere questo obiettivo, viene utilizzato OAuth 2.0. _https://example.com_ richieder√† il tuo permesso per **accedere ai tuoi post sui social media**. Di conseguenza, comparir√† una schermata di consenso su _https://socialmedia.com_, che illustra le **autorizzazioni richieste e lo sviluppatore che effettua la richiesta**. Dopo la tua autorizzazione, _https://example.com_ acquisir√† la capacit√† di **accedere ai tuoi post per tuo conto**.

√à fondamentale comprendere i seguenti componenti all'interno del framework di OAuth 2.0:

- **proprietario della risorsa**: Tu, come **utente/entit√†**, autorizzi l'accesso alla tua risorsa, come i tuoi post sui social media.
- **server della risorsa**: Il **server che gestisce le richieste autenticate** dopo che l'applicazione ha ottenuto un `access token` per conto del `proprietario della risorsa`, ad esempio **https://socialmedia.com**.
- **applicazione client**: L'**applicazione che richiede l'autorizzazione** dal `proprietario della risorsa`, come **https://example.com**.
- **server di autorizzazione**: Il **server che emette gli `access token`** all'applicazione client dopo l'autenticazione riuscita del `proprietario della risorsa` e l'ottenimento dell'autorizzazione, ad esempio **https://socialmedia.com**.
- **client\_id**: Un identificatore pubblico e univoco per l'applicazione.
- **client\_secret**: Una chiave confidenziale, nota solo all'applicazione e al server di autorizzazione, utilizzata per generare gli `access_token`.
- **response\_type**: Un valore che specifica **il tipo di token richiesto**, come `code`.
- **scope**: Il **livello di accesso** richiesto dall'applicazione client dal `proprietario della risorsa`.
- **redirect\_uri**: L'**URL a cui l'utente viene reindirizzato dopo l'autorizzazione**. Di solito deve corrispondere all'URL di reindirizzamento pre-registrato.
- **state**: Un parametro per **mantenere i dati durante il reindirizzamento dell'utente da e verso il server di autorizzazione**. La sua unicit√† √® fondamentale per fungere da **meccanismo di protezione CSRF**.
- **grant\_type**: Un parametro che indica **il tipo di concessione e il tipo di token restituito**.
- **code**: Il codice di autorizzazione dal `server di autorizzazione`, utilizzato insieme a `client_id` e `client_secret` dall'applicazione client per acquisire un `access_token`.
- **access\_token**: Il **token che l'applicazione client utilizza per le richieste API** per conto del `proprietario della risorsa`.
- **refresh\_token**: Consente all'applicazione di **ottenere un nuovo `access_token` senza richiedere nuovamente l'autorizzazione dell'utente**.

### Flusso

Il **flusso effettivo di OAuth** procede come segue:

1. Accedi a [https://example.com](https://example.com) e seleziona il pulsante "Integra con i social media".
2. Il sito invia quindi una richiesta a [https://socialmedia.com](https://socialmedia.com) chiedendo la tua autorizzazione per consentire all'applicazione di https://example.com di accedere ai tuoi post. La richiesta √® strutturata come:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ti viene quindi presentata una pagina di consenso.

4. Dopo aver dato il tuo consenso, Social Media invia una risposta all'`redirect_uri` con i parametri `code` e `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utilizza questo `code`, insieme al suo `client_id` e `client_secret`, per effettuare una richiesta lato server al fine di ottenere un `access_token` per tuo conto, consentendo l'accesso alle autorizzazioni a cui hai acconsentito:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Infine, il processo si conclude quando https://example.com utilizza il tuo `access_token` per effettuare una chiamata API ai Social Media per accedere.

## Vulnerabilit√† <a href="#323a" id="323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

Il `redirect_uri` √® fondamentale per la sicurezza nelle implementazioni di OAuth e OpenID, in quanto indica dove vengono inviati i dati sensibili, come i codici di autorizzazione, dopo l'autorizzazione. Se configurato in modo errato, potrebbe consentire agli attaccanti di reindirizzare tali richieste a server malevoli, consentendo il takeover dell'account.

Le tecniche di sfruttamento variano in base alla logica di convalida del server di autorizzazione. Possono variare dalla corrispondenza rigorosa del percorso all'accettazione di qualsiasi URL all'interno del dominio o della sottodirectory specificata. I metodi comuni di sfruttamento includono reindirizzamenti aperti, attraversamento di percorso, sfruttamento di regex deboli e iniezione HTML per il furto di token.

Oltre a `redirect_uri`, altri parametri di OAuth e OpenID come `client_uri`, `policy_uri`, `tos_uri` e `initiate_login_uri` sono anche suscettibili ad attacchi di reindirizzamento. Questi parametri sono opzionali e il loro supporto varia tra i server.

Per coloro che mirano a un server OpenID, il punto di scoperta (`**.well-known/openid-configuration**`) elenca spesso dettagli di configurazione preziosi come `registration_endpoint`, `request_uri_parameter_supported` e "`require_request_uri_registration`. Questi dettagli possono aiutare nell'individuazione del punto di registrazione e di altre specifiche di configurazione del server.

### XSS nell'implementazione del reindirizzamento <a href="#bda5" id="bda5"></a>

Come menzionato in questo rapporto di bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), potrebbe essere possibile che l'URL di reindirizzamento venga riflettuto nella risposta del server dopo l'autenticazione dell'utente, risultando vulnerabile a XSS. Payload possibile da testare:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Gestione impropria del parametro di stato <a href="#bda5" id="bda5"></a>

Nelle implementazioni di OAuth, l'uso improprio o l'omissione del **parametro di stato** pu√≤ aumentare significativamente il rischio di attacchi di **Cross-Site Request Forgery (CSRF)**. Questa vulnerabilit√† si verifica quando il parametro di stato non viene utilizzato, viene utilizzato come valore statico o non viene correttamente convalidato, consentendo agli attaccanti di eludere le protezioni CSRF.

Gli attaccanti possono sfruttare questa vulnerabilit√† intercettando il processo di autorizzazione per collegare il proprio account a quello della vittima, portando a potenziali **account takeover**. Questo √® particolarmente critico nelle applicazioni in cui OAuth viene utilizzato per scopi di **autenticazione**.

Sono stati documentati esempi reali di questa vulnerabilit√† in vari **CTF challenges** e **piattaforme di hacking**, evidenziando le sue implicazioni pratiche. Il problema si estende anche alle integrazioni con servizi di terze parti come **Slack**, **Stripe** e **PayPal**, dove gli attaccanti possono reindirizzare notifiche o pagamenti ai propri account.

La gestione e la convalida corrette del parametro di stato sono cruciali per proteggersi da CSRF e garantire la sicurezza del flusso OAuth.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Senza verifica dell'email durante la creazione dell'account**: Gli attaccanti possono creare preventivamente un account utilizzando l'email della vittima. Se successivamente la vittima utilizza un servizio di terze parti per effettuare il login, l'applicazione potrebbe erroneamente collegare questo account di terze parti all'account pre-creato dell'attaccante, consentendo l'accesso non autorizzato.

2. **Sfruttare la verifica delle email di OAuth poco rigorosa**: Gli attaccanti possono sfruttare i servizi OAuth che non verificano le email registrandosi con il proprio servizio e successivamente modificando l'email dell'account con quella della vittima. Questo metodo comporta un rischio simile di accesso non autorizzato all'account, simile al primo scenario ma attraverso un diverso vettore di attacco.

### Divulgazione di segreti <a href="#e177" id="e177"></a>

Identificare e proteggere i parametri segreti di OAuth √® fondamentale. Mentre il **`client_id`** pu√≤ essere divulgato in modo sicuro, rivelare il **`client_secret`** comporta rischi significativi. Se il `client_secret` viene compromesso, gli attaccanti possono sfruttare l'identit√† e la fiducia dell'applicazione per **rubare gli `access_tokens`** degli utenti e le informazioni private.

Una vulnerabilit√† comune si verifica quando le applicazioni gestiscono erroneamente lo scambio del codice di autorizzazione per un `access_token` lato client anzich√© lato server. Questo errore porta all'esposizione del `client_secret`, consentendo agli attaccanti di generare `access_tokens` sotto mentite spoglie dell'applicazione. Inoltre, attraverso l'ingegneria sociale, gli attaccanti potrebbero ottenere privilegi aggiuntivi aggiungendo ulteriori ambiti all'autorizzazione OAuth, sfruttando ulteriormente lo status fidato dell'applicazione.

### Brute force del client secret

Puoi provare a **forzare il client\_secret** di un provider di servizi con l'identity provider per cercare di rubare account.
La richiesta per il BF potrebbe assomigliare a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header che rivela il Codice + Stato

Una volta che il client ha il **codice e lo stato**, se viene **riflesso nell'intestazione Referer** quando si passa a una pagina diversa, allora √® vulnerabile.

### Access Token memorizzato nella cronologia del browser

Vai alla **cronologia del browser e controlla se l'access token √® salvato l√¨**.

### Codice di autorizzazione eterno

Il **codice di autorizzazione dovrebbe vivere solo per un certo periodo di tempo per limitare la finestra temporale in cui un attaccante pu√≤ rubarlo e usarlo**.

### Token di autorizzazione/refresh non legato al client

Se puoi ottenere il **codice di autorizzazione e usarlo con un client diverso, allora puoi prendere il controllo di altri account**.

### Percorsi felici, XSS, Iframe e Post Messages per rivelare valori di codice e stato

**[Controlla questo post](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)**

### AWS Cognito <a href="#bda5" id="bda5"></a>

In questo rapporto di bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puoi vedere che il **token** che **AWS Cognito** restituisce all'utente potrebbe avere **permessi sufficienti per sovrascrivere i dati dell'utente**. Pertanto, se puoi **cambiare l'email dell'utente con un'email di un altro utente**, potresti essere in grado di **prendere il controllo** di altri account.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Per informazioni pi√π dettagliate su come sfruttare AWS Cognito, controlla:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Sfruttare i token di altre app <a href="#bda5" id="bda5"></a>

Come [**menzionato in questo articolo**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), i flussi OAuth che si aspettano di ricevere il **token** (e non un codice) potrebbero essere vulnerabili se non verificano che il token appartenga all'app.

Ci√≤ perch√© un **attaccante** potrebbe creare un **applicazione che supporta OAuth e accedere con Facebook** (ad esempio) nella sua stessa applicazione. Quindi, una volta che una vittima accede con Facebook nell'**applicazione dell'attaccante**, l'attaccante potrebbe ottenere il **token OAuth dell'utente fornito alla sua applicazione e usarlo per accedere all'app OAuth della vittima utilizzando il token dell'utente della vittima**.

{% hint style="danger" %}
Pertanto, se l'attaccante riesce a far accedere l'utente alla sua stessa applicazione OAuth, sar√† in grado di prendere il controllo dell'account della vittima nelle applicazioni che si aspettano un token e non verificano se il token √® stato concesso al loro ID app.
{% endhint %}

### Due link e cookie <a href="#bda5" id="bda5"></a>

Secondo [**questo articolo**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era possibile far aprire una pagina alla vittima con un **returnUrl** che puntava all'host dell'attaccante. Queste informazioni sarebbero **memorizzate in un cookie (RU)** e in un **passaggio successivo**, il **prompt** chieder√† all'**utente** se desidera concedere l'accesso a quell'host dell'attaccante.

Per eludere questo prompt, era possibile aprire una scheda per avviare il **flusso OAuth** che imposterebbe questo cookie RU utilizzando il **returnUrl**, chiudere la scheda prima che venga mostrato il prompt e aprire una nuova scheda senza quel valore. Quindi, il **prompt non informer√† sull'host dell'attaccante**, ma il cookie sar√† impostato su di esso, quindi il **token verr√† inviato all'host dell'attaccante** nella reindirizzamento.

### Parametri SSRF <a href="#bda5" id="bda5"></a>

**[Controlla questa ricerca](https://portswigger.net/research/hidden-oauth-attack-vectors) per ulteriori dettagli su questa tecnica.**

La registrazione dinamica del client in OAuth funge da vettore meno ovvio ma critico per le vulnerabilit√† di sicurezza, in particolare per gli attacchi di **Server-Side Request Forgery (SSRF)**. Questo endpoint consente ai server OAuth di ricevere dettagli sulle applicazioni client, inclusi URL sensibili che potrebbero essere sfruttati.

**Punti chiave:**

- La **registrazione dinamica del client** √® spesso mappata su `/register` e accetta dettagli come `client_name`, `client_secret`, `redirect_uris` e URL per loghi o set di chiavi JSON (JWKs) tramite richieste POST.
- Questa funzionalit√† aderisce alle specifiche descritte in **RFC7591** e **OpenID Connect Registration 1.0**, che includono parametri potenzialmente vulnerabili a SSRF.
- Il processo di registrazione pu√≤ esporre involontariamente i server a SSRF in diversi modi:
- **`logo_uri`**: un URL per il logo dell'applicazione client che potrebbe essere recuperato dal server, innescando SSRF o portando a XSS se l'URL viene gestito in modo errato.
- **`jwks_uri`**: un URL per il documento JWK del client, che se creato male pu√≤ indurre il server a effettuare richieste in uscita verso un server controllato dall'attaccante.
- **`sector_identifier_uri`**: fa riferimento a un array JSON di `redirect_uris`, che il server potrebbe recuperare, creando un'opportunit√† di SSRF.
- **`request_uris`**: elenca gli URI di richiesta consentiti per il client, che possono essere sfruttati se il server recupera questi URI all'inizio del processo di autorizzazione.

**Strategia di sfruttamento:**

- L'SSRF pu√≤ essere innescato registrando un nuovo client con URL dannosi nei parametri come `logo_uri`, `jwks_uri` o `sector_identifier_uri`.
- Sebbene lo sfruttamento diretto tramite `request_uris` possa essere mitigato da controlli di whitelist, fornire un `request_uri` pre-registrato controllato dall'attaccante pu√≤ facilitare l'SSRF durante la fase di autorizzazione.

## Race Conditions nei provider OAuth

Se la piattaforma che stai testando √® un provider OAuth, [**leggi questo per testare possibili Race Conditions**](race-condition.md).

## Riferimenti

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF**, controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repos.**

</details>
