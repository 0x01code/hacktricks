# OAuth to Account takeover

<details>

<summary><strong>Learn AWS hacking from zero to hero with</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Other ways to support HackTricks:

* If you want to see your **company advertised in HackTricks** or **download HackTricks in PDF** Check the [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Get the [**official PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Discover [**The PEASS Family**](https://opensea.io/collection/the-peass-family), our collection of exclusive [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Join the** 💬 [**Discord group**](https://discord.gg/hRep4RUj7f) or the [**telegram group**](https://t.me/peass) or **follow** us on **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Share your hacking tricks by submitting PRs to the** [**HackTricks**](https://github.com/carlospolop/hacktricks) and [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth 提供了各种版本，基础信息可以在 [OAuth 2.0 documentation](https://oauth.net/2/) 中找到。本讨论主要集中在广泛使用的 [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/) 上，提供了一个**授权框架，使应用程序能够访问或在另一个应用程序（授权服务器）上的用户账户上执行操作**。

考虑一个假设的网站 _**https://example.com**_，旨在**展示你所有的社交媒体帖子**，包括私人帖子。为实现这一点，使用了 OAuth 2.0。_https://example.com_ 将请求你**访问你的社交媒体帖子**的权限。因此，在 _https://socialmedia.com_ 上会出现一个同意屏幕，概述**请求的权限和发出请求的开发者**。在你授权后，_https://example.com_ 将能够**代表你访问你的帖子**。

理解 OAuth 2.0 框架中的以下组件是至关重要的：

* **resource owner**: 你，作为**用户/实体**，授权访问你的资源，如你的社交媒体账户帖子。
* **resource server**: **管理经过身份验证的请求的服务器**，在应用程序代表 `resource owner` 获得 `access token` 后，例如 **https://socialmedia.com**。
* **client application**: **寻求 `resource owner` 授权的应用程序**，如 **https://example.com**。
* **authorization server**: **在成功验证 `resource owner` 并获得授权后向 `client application` 发放 `access tokens` 的服务器**，例如 **https://socialmedia.com**。
* **client\_id**: 应用程序的公共、唯一标识符。
* **client\_secret:** 仅应用程序和授权服务器知道的机密密钥，用于生成 `access_tokens`。
* **response\_type**: 指定**请求的令牌类型**的值，如 `code`。
* **scope**: `client application` 请求的**访问级别**。
* **redirect\_uri**: **用户授权后重定向的 URL**。通常必须与预注册的重定向 URL 一致。
* **state**: 一个参数，用于**在用户重定向到授权服务器和从授权服务器返回时保持数据**。其唯一性对于作为**CSRF 保护机制**至关重要。
* **grant\_type**: 指示**授权类型和返回的令牌类型**的参数。
* **code**: 来自 `authorization server` 的授权代码，`client application` 使用 `client_id` 和 `client_secret` 与之配合以获取 `access_token`。
* **access\_token**: **client application 代表 `resource owner` 进行 API 请求时使用的令牌**。
* **refresh\_token**: 使应用程序能够**在不重新提示用户的情况下获取新的 `access_token`**。

### Flow

**实际的 OAuth 流程**如下：

1. 你导航到 [https://example.com](https://example.com) 并选择“与社交媒体集成”按钮。
2. 该网站然后向 [https://socialmedia.com](https://socialmedia.com) 发送请求，要求你授权 https://example.com 的应用程序访问你的帖子。请求的结构如下：
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 然后会出现一个同意页面。
4. 在您批准后，Social Media 会将带有 `code` 和 `state` 参数的响应发送到 `redirect_uri`：
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com 利用这个 `code`，连同它的 `client_id` 和 `client_secret`，发起一个服务器端请求以获取一个 `access_token`，从而代表你访问你同意的权限：
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. 最后，https://example.com 使用你的 `access_token` 向 Social Media 发起 API 调用以访问

## 漏洞 <a href="#id-323a" id="id-323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

`redirect_uri` 在 OAuth 和 OpenID 实现中对安全性至关重要，因为它指示授权后将敏感数据（如授权代码）发送到哪里。如果配置错误，可能允许攻击者将这些请求重定向到恶意服务器，从而实现账户接管。

利用技术因授权服务器的验证逻辑而异。它们可以从严格的路径匹配到接受指定域或子目录内的任何 URL。常见的利用方法包括开放重定向、路径遍历、利用弱正则表达式和 HTML 注入以窃取令牌。

除了 `redirect_uri`，其他 OAuth 和 OpenID 参数如 `client_uri`、`policy_uri`、`tos_uri` 和 `initiate_login_uri` 也容易受到重定向攻击。这些参数是可选的，它们的支持在各服务器之间有所不同。

对于那些针对 OpenID 服务器的人来说，发现端点（`**.well-known/openid-configuration**`）通常列出有价值的配置细节，如 `registration_endpoint`、`request_uri_parameter_supported` 和 `require_request_uri_registration`。这些细节有助于识别注册端点和服务器的其他配置细节。

### XSS in redirect implementation <a href="#bda5" id="bda5"></a>

正如这个漏洞赏金报告中提到的 [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html)，可能存在重定向 **URL 在用户认证后被反映在服务器响应中**，从而 **易受 XSS 攻击**。可能的测试有效载荷：
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - 不当处理 state 参数 <a href="#bda5" id="bda5"></a>

在 OAuth 实现中，**`state` 参数**的误用或省略会显著增加**跨站请求伪造 (CSRF)** 攻击的风险。当 `state` 参数**未使用、使用静态值或未正确验证**时，会导致攻击者绕过 CSRF 保护。

攻击者可以通过拦截授权过程，将他们的账户与受害者的账户链接，从而导致潜在的**账户接管**。这在使用 OAuth 进行**身份验证**的应用程序中尤为关键。

在各种**CTF 挑战**和**黑客平台**中，已经记录了这种漏洞的实际例子，突显了其实际影响。该问题还扩展到与第三方服务（如 **Slack**、**Stripe** 和 **PayPal**）的集成，攻击者可以将通知或付款重定向到他们的账户。

正确处理和验证**`state` 参数**对于防范 CSRF 和保护 OAuth 流程至关重要。

### 预账户接管 <a href="#ebe4" id="ebe4"></a>

1. **在创建账户时没有电子邮件验证**：攻击者可以预先使用受害者的电子邮件创建账户。如果受害者稍后使用第三方服务登录，应用程序可能会无意中将此第三方账户链接到攻击者预先创建的账户，从而导致未经授权的访问。
2. **利用松散的 OAuth 电子邮件验证**：攻击者可能利用不验证电子邮件的 OAuth 服务，通过注册他们的服务，然后将账户电子邮件更改为受害者的。这种方法同样存在未经授权的账户访问风险，类似于第一种情况，但通过不同的攻击向量。

### 秘密泄露 <a href="#e177" id="e177"></a>

识别和保护秘密的 OAuth 参数至关重要。虽然**`client_id`**可以安全公开，但泄露**`client_secret`**会带来重大风险。如果 `client_secret` 被泄露，攻击者可以利用应用程序的身份和信任来**窃取用户 `access_tokens`** 和私人信息。

常见的漏洞出现在应用程序错误地在客户端而不是服务器端处理授权 `code` 换取 `access_token` 的过程中。这种错误导致 `client_secret` 的暴露，使攻击者能够以应用程序的名义生成 `access_tokens`。此外，通过社会工程，攻击者可以通过添加额外的范围来提升 OAuth 授权的权限，进一步利用应用程序的信任状态。

### Client Secret 暴力破解

你可以尝试对服务提供商的 **client\_secret** 进行暴力破解，以尝试窃取账户。\
暴力破解请求可能类似于：
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header 泄露 Code 和 State

一旦客户端获得了 **code 和 state**，如果它们在浏览到不同页面时被 **反映在 Referer header 中**，那么它是脆弱的。

### 访问令牌存储在浏览器历史记录中

查看 **浏览器历史记录并检查访问令牌是否保存在其中**。

### 永久授权码

**授权码应该只存在一段时间，以限制攻击者窃取和使用它的时间窗口**。

### 授权/刷新令牌未绑定到客户端

如果你能获得 **授权码并使用不同的客户端，那么你可以接管其他账户**。

### Happy Paths, XSS, Iframes 和 Post Messages 泄露 code 和 state 值

[**查看这篇文章**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

在这个漏洞赏金报告中：[**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) 你可以看到 **AWS Cognito** 返回给用户的 **令牌** 可能具有 **足够的权限来覆盖用户数据**。因此，如果你能 **将用户邮箱更改为其他用户的邮箱**，你可能能够 **接管** 其他账户。
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
有关如何滥用 AWS cognito 的详细信息，请查看：

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### 滥用其他应用程序的令牌 <a href="#bda5" id="bda5"></a>

如[**这篇文章中提到的**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts)，如果 OAuth 流程期望接收**令牌**（而不是代码），并且不检查令牌是否属于该应用程序，则可能存在漏洞。

这是因为**攻击者**可以创建一个**支持 OAuth 并使用 Facebook 登录**的**应用程序**（例如）。然后，一旦受害者在**攻击者的应用程序**中使用 Facebook 登录，攻击者就可以获取**用户授予其应用程序的 OAuth 令牌，并使用该令牌登录受害者的 OAuth 应用程序**。

{% hint style="danger" %}
因此，如果攻击者设法让用户访问其自己的 OAuth 应用程序，他将能够接管那些期望令牌且不检查令牌是否授予其应用程序 ID 的应用程序中的受害者账户。
{% endhint %}

### 两个链接和 cookie <a href="#bda5" id="bda5"></a>

根据[**这篇文章**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f)，可以让受害者打开一个带有指向攻击者主机的**returnUrl**的页面。此信息将**存储在 cookie (RU) 中**，并且在**后续步骤**中，**提示**将**询问**用户是否愿意授予该攻击者主机访问权限。

为了绕过此提示，可以打开一个标签页以启动**Oauth 流程**，该流程将使用**returnUrl**设置此 RU cookie，在显示提示之前关闭标签页，然后打开一个没有该值的新标签页。然后，**提示不会通知攻击者的主机**，但 cookie 将设置为它，因此**令牌将在重定向中发送到攻击者的主机**。

### 提示交互绕过 <a href="#bda5" id="bda5"></a>

如[**此视频**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q)中所述，一些 OAuth 实现允许指示**`prompt`** GET 参数为 None (**`&prompt=none`**)，以**防止用户在网络提示中被要求确认**已授予的访问权限，如果他们已经登录平台。

### response\_mode

如[**此视频**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q)中所述，可以指示参数**`response_mode`**以指示希望代码在最终 URL 中提供的位置：

* `response_mode=query` -> 代码在 GET 参数中提供：`?code=2397rf3gu93f`
* `response_mode=fragment` -> 代码在 URL 片段参数中提供 `#code=2397rf3gu93f`
* `response_mode=form_post` -> 代码在带有名为 `code` 的输入和值的 POST 表单中提供
* `response_mode=web_message` -> 代码在 post 消息中发送：`window.opener.postMessage({"code": "asdasdasd...`

### SSRFs 参数 <a href="#bda5" id="bda5"></a>

[**查看此研究**](https://portswigger.net/research/hidden-oauth-attack-vectors) **了解此技术的更多详细信息。**

OAuth 中的动态客户端注册是安全漏洞的一个不太明显但至关重要的向量，特别是针对**服务器端请求伪造 (SSRF)** 攻击。此端点允许 OAuth 服务器接收有关客户端应用程序的详细信息，包括可能被利用的敏感 URL。

**关键点：**

* **动态客户端注册**通常映射到 `/register` 并接受 `client_name`、`client_secret`、`redirect_uris` 和用于徽标或 JSON Web Key Sets (JWKs) 的 URL 等详细信息，通过 POST 请求。
* 此功能遵循 **RFC7591** 和 **OpenID Connect Registration 1.0** 中规定的规范，这些规范包括可能易受 SSRF 攻击的参数。
* 注册过程可能会在多种方式下无意中暴露服务器以进行 SSRF 攻击：
* **`logo_uri`**：客户端应用程序徽标的 URL，服务器可能会获取该 URL，从而触发 SSRF 或在 URL 处理不当时导致 XSS。
* **`jwks_uri`**：客户端的 JWK 文档的 URL，如果恶意构造，可能会导致服务器向攻击者控制的服务器发出出站请求。
* **`sector_identifier_uri`**：引用 `redirect_uris` 的 JSON 数组，服务器可能会获取该数组，从而创建 SSRF 机会。
* **`request_uris`**：列出客户端的允许请求 URI，如果服务器在授权过程开始时获取这些 URI，则可能被利用。

**利用策略：**

* 可以通过在 `logo_uri`、`jwks_uri` 或 `sector_identifier_uri` 等参数中注册带有恶意 URL 的新客户端来触发 SSRF。
* 虽然通过 `request_uris` 的直接利用可能会被白名单控制所缓解，但在授权阶段提供预先注册的、攻击者控制的 `request_uri` 可以促进 SSRF。

## OAuth 提供者竞态条件

如果您正在测试的平台是 OAuth 提供者，请[**阅读此内容以测试可能的竞态条件**](race-condition.md)。

## 参考资料

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>从零到英雄学习 AWS 黑客技术</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您希望在 HackTricks 中**宣传您的公司**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 周边**](https://peass.creator-spring.com)
* 发现[**The PEASS Family**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live) **上关注我们**。
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 仓库提交 PR 来分享您的黑客技巧**。

</details>
