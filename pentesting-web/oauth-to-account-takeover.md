# OAuth to Account takeover

<details>

<summary><strong>Μάθετε AWS hacking από το μηδέν μέχρι τον ήρωα με</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή **να κατεβάσετε το HackTricks σε PDF** Ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή την [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Basic Information <a href="#d4a8" id="d4a8"></a>

OAuth προσφέρει διάφορες εκδόσεις, με βασικές πληροφορίες διαθέσιμες στο [OAuth 2.0 documentation](https://oauth.net/2/). Αυτή η συζήτηση επικεντρώνεται κυρίως στον ευρέως χρησιμοποιούμενο [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), παρέχοντας ένα **πλαίσιο εξουσιοδότησης που επιτρέπει σε μια εφαρμογή να έχει πρόσβαση ή να εκτελεί ενέργειες σε έναν λογαριασμό χρήστη σε άλλη εφαρμογή** (ο εξουσιοδοτικός διακομιστής).

Σκεφτείτε έναν υποθετικό ιστότοπο _**https://example.com**_, σχεδιασμένο να **προβάλλει όλες τις αναρτήσεις σας στα κοινωνικά μέσα**, συμπεριλαμβανομένων των ιδιωτικών. Για να το επιτύχει αυτό, χρησιμοποιείται το OAuth 2.0. Το _https://example.com_ θα ζητήσει την άδειά σας για να **έχει πρόσβαση στις αναρτήσεις σας στα κοινωνικά μέσα**. Κατά συνέπεια, θα εμφανιστεί μια οθόνη συναίνεσης στο _https://socialmedia.com_, που θα περιγράφει τις **άδειες που ζητούνται και τον προγραμματιστή που κάνει το αίτημα**. Μετά την εξουσιοδότησή σας, το _https://example.com_ αποκτά τη δυνατότητα να **έχει πρόσβαση στις αναρτήσεις σας εκ μέρους σας**.

Είναι απαραίτητο να κατανοήσετε τα ακόλουθα στοιχεία στο πλαίσιο του OAuth 2.0:

* **resource owner**: Εσείς, ως **χρήστης/οντότητα**, εξουσιοδοτείτε την πρόσβαση στον πόρο σας, όπως οι αναρτήσεις του λογαριασμού σας στα κοινωνικά μέσα.
* **resource server**: Ο **διακομιστής που διαχειρίζεται τα αυθεντικοποιημένα αιτήματα** αφού η εφαρμογή έχει εξασφαλίσει ένα `access token` εκ μέρους του `resource owner`, π.χ., **https://socialmedia.com**.
* **client application**: Η **εφαρμογή που ζητά εξουσιοδότηση** από τον `resource owner`, όπως **https://example.com**.
* **authorization server**: Ο **διακομιστής που εκδίδει `access tokens`** στην `client application` μετά την επιτυχή αυθεντικοποίηση του `resource owner` και την εξασφάλιση της εξουσιοδότησης, π.χ., **https://socialmedia.com**.
* **client\_id**: Ένας δημόσιος, μοναδικός αναγνωριστικός κωδικός για την εφαρμογή.
* **client\_secret:** Ένα εμπιστευτικό κλειδί, γνωστό μόνο στην εφαρμογή και τον εξουσιοδοτικό διακομιστή, που χρησιμοποιείται για τη δημιουργία `access_tokens`.
* **response\_type**: Μια τιμή που καθορίζει **τον τύπο του token που ζητείται**, όπως `code`.
* **scope**: Το **επίπεδο πρόσβασης** που ζητά η `client application` από τον `resource owner`.
* **redirect\_uri**: Η **URL στην οποία ανακατευθύνεται ο χρήστης μετά την εξουσιοδότηση**. Συνήθως πρέπει να ευθυγραμμίζεται με την προεγγεγραμμένη URL ανακατεύθυνσης.
* **state**: Ένας παράμετρος για **τη διατήρηση δεδομένων κατά την ανακατεύθυνση του χρήστη προς και από τον εξουσιοδοτικό διακομιστή**. Η μοναδικότητά του είναι κρίσιμη για να λειτουργεί ως **μηχανισμός προστασίας CSRF**.
* **grant\_type**: Ένας παράμετρος που υποδεικνύει **τον τύπο της επιχορήγησης και τον τύπο του token που θα επιστραφεί**.
* **code**: Ο κωδικός εξουσιοδότησης από τον `authorization server`, που χρησιμοποιείται σε συνδυασμό με το `client_id` και το `client_secret` από την client application για την απόκτηση ενός `access_token`.
* **access\_token**: Το **token που χρησιμοποιεί η client application για αιτήματα API** εκ μέρους του `resource owner`.
* **refresh\_token**: Επιτρέπει στην εφαρμογή να **αποκτήσει ένα νέο `access_token` χωρίς να επαναπροτρέπει τον χρήστη**.

### Flow

Η **πραγματική ροή του OAuth** προχωρά ως εξής:

1. Πλοηγείστε στο [https://example.com](https://example.com) και επιλέγετε το κουμπί “Integrate with Social Media”.
2. Ο ιστότοπος στέλνει ένα αίτημα στο [https://socialmedia.com](https://socialmedia.com) ζητώντας την εξουσιοδότησή σας για να επιτρέψει στην εφαρμογή του https://example.com να έχει πρόσβαση στις αναρτήσεις σας. Το αίτημα είναι δομημένο ως εξής:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Στη συνέχεια, σας παρουσιάζεται μια σελίδα συναίνεσης.
4. Μετά την έγκρισή σας, το Social Media στέλνει μια απάντηση στο `redirect_uri` με τις παραμέτρους `code` και `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com χρησιμοποιεί αυτόν τον `code`, μαζί με το `client_id` και το `client_secret`, για να κάνει ένα server-side αίτημα για να αποκτήσει ένα `access_token` εκ μέρους σας, επιτρέποντας την πρόσβαση στις άδειες που συναινέσατε:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Τέλος, η διαδικασία ολοκληρώνεται καθώς το https://example.com χρησιμοποιεί το `access_token` σας για να κάνει μια κλήση API στο Social Media για πρόσβαση

## Ευπάθειες <a href="#id-323a" id="id-323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

Το `redirect_uri` είναι κρίσιμο για την ασφάλεια στις υλοποιήσεις OAuth και OpenID, καθώς κατευθύνει πού αποστέλλονται ευαίσθητα δεδομένα, όπως κωδικοί εξουσιοδότησης, μετά την εξουσιοδότηση. Αν είναι εσφαλμένα διαμορφωμένο, θα μπορούσε να επιτρέψει σε επιτιθέμενους να ανακατευθύνουν αυτά τα αιτήματα σε κακόβουλους διακομιστές, επιτρέποντας την κατάληψη λογαριασμού.

Οι τεχνικές εκμετάλλευσης ποικίλλουν ανάλογα με τη λογική επικύρωσης του διακομιστή εξουσιοδότησης. Μπορούν να κυμαίνονται από αυστηρή αντιστοίχιση διαδρομής έως αποδοχή οποιουδήποτε URL εντός του καθορισμένου τομέα ή υποκαταλόγου. Κοινές μέθοδοι εκμετάλλευσης περιλαμβάνουν open redirects, path traversal, εκμετάλλευση αδύναμων regexes και HTML injection για κλοπή token.

Εκτός από το `redirect_uri`, άλλες παράμετροι OAuth και OpenID όπως `client_uri`, `policy_uri`, `tos_uri`, και `initiate_login_uri` είναι επίσης ευάλωτες σε επιθέσεις ανακατεύθυνσης. Αυτές οι παράμετροι είναι προαιρετικές και η υποστήριξή τους ποικίλλει ανάλογα με τους διακομιστές.

Για όσους στοχεύουν έναν διακομιστή OpenID, το discovery endpoint (`**.well-known/openid-configuration**`) συχνά παραθέτει πολύτιμες λεπτομέρειες διαμόρφωσης όπως `registration_endpoint`, `request_uri_parameter_supported`, και "`require_request_uri_registration`. Αυτές οι λεπτομέρειες μπορούν να βοηθήσουν στον εντοπισμό του registration endpoint και άλλων συγκεκριμένων ρυθμίσεων του διακομιστή.

### XSS στην υλοποίηση ανακατεύθυνσης <a href="#bda5" id="bda5"></a>

Όπως αναφέρεται σε αυτήν την αναφορά bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) μπορεί να είναι δυνατόν το redirect **URL να αντανακλάται στην απόκριση** του διακομιστή μετά την αυθεντικοποίηση του χρήστη, όντας **ευάλωτο σε XSS**. Πιθανό payload για δοκιμή:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Ακατάλληλος χειρισμός της παραμέτρου state <a href="#bda5" id="bda5"></a>

Στις υλοποιήσεις OAuth, η κακή χρήση ή η παράλειψη της **παραμέτρου `state`** μπορεί να αυξήσει σημαντικά τον κίνδυνο επιθέσεων **Cross-Site Request Forgery (CSRF)**. Αυτή η ευπάθεια προκύπτει όταν η παράμετρος `state` είτε **δεν χρησιμοποιείται, χρησιμοποιείται ως στατική τιμή, είτε δεν επικυρώνεται σωστά**, επιτρέποντας στους επιτιθέμενους να παρακάμψουν τις προστασίες CSRF.

Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτό το γεγονός αναχαιτίζοντας τη διαδικασία εξουσιοδότησης για να συνδέσουν τον λογαριασμό τους με τον λογαριασμό του θύματος, οδηγώντας σε πιθανές **καταλήψεις λογαριασμών**. Αυτό είναι ιδιαίτερα κρίσιμο σε εφαρμογές όπου το OAuth χρησιμοποιείται για **σκοπούς αυθεντικοποίησης**.

Πραγματικά παραδείγματα αυτής της ευπάθειας έχουν τεκμηριωθεί σε διάφορες **CTF προκλήσεις** και **πλατφόρμες hacking**, υπογραμμίζοντας τις πρακτικές της επιπτώσεις. Το ζήτημα επεκτείνεται επίσης σε ενσωματώσεις με υπηρεσίες τρίτων όπως **Slack**, **Stripe**, και **PayPal**, όπου οι επιτιθέμενοι μπορούν να ανακατευθύνουν ειδοποιήσεις ή πληρωμές στους λογαριασμούς τους.

Ο σωστός χειρισμός και η επικύρωση της **παραμέτρου `state`** είναι κρίσιμα για την προστασία από CSRF και την ασφάλεια της ροής OAuth.

### Προ Κατάληψη Λογαριασμού <a href="#ebe4" id="ebe4"></a>

1. **Χωρίς Επαλήθευση Email κατά τη Δημιουργία Λογαριασμού**: Οι επιτιθέμενοι μπορούν να δημιουργήσουν προληπτικά έναν λογαριασμό χρησιμοποιώντας το email του θύματος. Εάν το θύμα αργότερα χρησιμοποιήσει μια υπηρεσία τρίτου για σύνδεση, η εφαρμογή μπορεί ακούσια να συνδέσει αυτόν τον λογαριασμό τρίτου με τον προδημιουργημένο λογαριασμό του επιτιθέμενου, οδηγώντας σε μη εξουσιοδοτημένη πρόσβαση.
2. **Εκμετάλλευση Χαλαρής Επαλήθευσης Email στο OAuth**: Οι επιτιθέμενοι μπορεί να εκμεταλλευτούν υπηρεσίες OAuth που δεν επαληθεύουν τα emails, εγγραφόμενοι με την υπηρεσία τους και στη συνέχεια αλλάζοντας το email του λογαριασμού στο email του θύματος. Αυτή η μέθοδος παρομοίως κινδυνεύει από μη εξουσιοδοτημένη πρόσβαση λογαριασμού, παρόμοια με το πρώτο σενάριο αλλά μέσω διαφορετικού διαύλου επίθεσης.

### Διαρροή Μυστικών <a href="#e177" id="e177"></a>

Η αναγνώριση και η προστασία των μυστικών παραμέτρων OAuth είναι κρίσιμη. Ενώ το **`client_id`** μπορεί να αποκαλυφθεί με ασφάλεια, η αποκάλυψη του **`client_secret`** ενέχει σημαντικούς κινδύνους. Εάν το `client_secret` παραβιαστεί, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν την ταυτότητα και την εμπιστοσύνη της εφαρμογής για να **κλέψουν `access_tokens` χρηστών** και ιδιωτικές πληροφορίες.

Μια κοινή ευπάθεια προκύπτει όταν οι εφαρμογές χειρίζονται λανθασμένα την ανταλλαγή του κωδικού εξουσιοδότησης (`code`) για ένα `access_token` στην πλευρά του πελάτη αντί για την πλευρά του διακομιστή. Αυτό το λάθος οδηγεί στην έκθεση του `client_secret`, επιτρέποντας στους επιτιθέμενους να δημιουργήσουν `access_tokens` υπό το πρόσχημα της εφαρμογής. Επιπλέον, μέσω κοινωνικής μηχανικής, οι επιτιθέμενοι θα μπορούσαν να κλιμακώσουν τα προνόμια προσθέτοντας επιπλέον πεδία στην εξουσιοδότηση OAuth, εκμεταλλευόμενοι περαιτέρω την εμπιστευτική κατάσταση της εφαρμογής.

### Client Secret Bruteforce

Μπορείτε να προσπαθήσετε να **bruteforce το client\_secret** ενός παρόχου υπηρεσιών με τον πάροχο ταυτότητας για να προσπαθήσετε να κλέψετε λογαριασμούς.\
Το αίτημα για BF μπορεί να μοιάζει με:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Μόλις ο πελάτης έχει τον **κωδικό και την κατάσταση**, αν **αντικατοπτρίζεται μέσα στην κεφαλίδα Referer** όταν περιηγείται σε διαφορετική σελίδα, τότε είναι ευάλωτο.

### Access Token Stored in Browser History

Πηγαίνετε στο **ιστορικό του προγράμματος περιήγησης και ελέγξτε αν το access token είναι αποθηκευμένο εκεί**.

### Everlasting Authorization Code

Ο **κωδικός εξουσιοδότησης θα πρέπει να ζει μόνο για κάποιο χρονικό διάστημα για να περιορίσει το χρονικό παράθυρο όπου ένας επιτιθέμενος μπορεί να τον κλέψει και να τον χρησιμοποιήσει**.

### Authorization/Refresh Token not bound to client

Αν μπορείτε να πάρετε τον **κωδικό εξουσιοδότησης και να τον χρησιμοποιήσετε με διαφορετικό πελάτη, τότε μπορείτε να καταλάβετε άλλους λογαριασμούς**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Ελέγξτε αυτήν την ανάρτηση**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Σε αυτήν την αναφορά bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) μπορείτε να δείτε ότι το **token** που δίνει πίσω στον χρήστη το **AWS Cognito** μπορεί να έχει **αρκετές άδειες για να αντικαταστήσει τα δεδομένα του χρήστη**. Επομένως, αν μπορείτε να **αλλάξετε το email του χρήστη με ένα διαφορετικό email χρήστη**, μπορεί να είστε σε θέση να **καταλάβετε** άλλους λογαριασμούς.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Για περισσότερες λεπτομέρειες σχετικά με το πώς να εκμεταλλευτείτε το AWS cognito δείτε:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Εκμετάλλευση tokens άλλων εφαρμογών <a href="#bda5" id="bda5"></a>

Όπως [**αναφέρεται σε αυτό το άρθρο**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), οι ροές OAuth που αναμένουν να λάβουν το **token** (και όχι έναν κωδικό) θα μπορούσαν να είναι ευάλωτες αν δεν ελέγχουν ότι το token ανήκει στην εφαρμογή.

Αυτό συμβαίνει επειδή ένας **επιτιθέμενος** θα μπορούσε να δημιουργήσει μια **εφαρμογή που υποστηρίζει OAuth και να συνδεθεί με το Facebook** (για παράδειγμα) στη δική του εφαρμογή. Στη συνέχεια, μόλις ένα θύμα συνδεθεί με το Facebook στην **εφαρμογή του επιτιθέμενου**, ο επιτιθέμενος θα μπορούσε να πάρει το **OAuth token του χρήστη που δόθηκε στην εφαρμογή του και να το χρησιμοποιήσει για να συνδεθεί στην εφαρμογή OAuth του θύματος χρησιμοποιώντας το token του χρήστη του θύματος**.

{% hint style="danger" %}
Επομένως, αν ο επιτιθέμενος καταφέρει να κάνει τον χρήστη να αποκτήσει πρόσβαση στη δική του εφαρμογή OAuth, θα μπορέσει να πάρει τον έλεγχο του λογαριασμού του θύματος σε εφαρμογές που αναμένουν ένα token και δεν ελέγχουν αν το token δόθηκε στο δικό τους app ID.
{% endhint %}

### Δύο σύνδεσμοι & cookie <a href="#bda5" id="bda5"></a>

Σύμφωνα με [**αυτό το άρθρο**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ήταν δυνατό να κάνετε ένα θύμα να ανοίξει μια σελίδα με ένα **returnUrl** που δείχνει στον host του επιτιθέμενου. Αυτή η πληροφορία θα **αποθηκευόταν σε ένα cookie (RU)** και σε ένα **μεταγενέστερο βήμα** το **prompt** θα **ρωτούσε** τον **χρήστη** αν θέλει να δώσει πρόσβαση στον host του επιτιθέμενου.

Για να παρακάμψετε αυτό το prompt, ήταν δυνατό να ανοίξετε μια καρτέλα για να ξεκινήσετε τη **ροή OAuth** που θα ρύθμιζε αυτό το cookie RU χρησιμοποιώντας το **returnUrl**, να κλείσετε την καρτέλα πριν εμφανιστεί το prompt και να ανοίξετε μια νέα καρτέλα χωρίς αυτή την τιμή. Στη συνέχεια, το **prompt δεν θα ενημερώσει για τον host του επιτιθέμενου**, αλλά το cookie θα έχει ρυθμιστεί σε αυτόν, οπότε το **token θα σταλεί στον host του επιτιθέμενου** στην ανακατεύθυνση.

### Παράκαμψη αλληλεπίδρασης με το Prompt <a href="#bda5" id="bda5"></a>

Όπως εξηγείται σε [**αυτό το βίντεο**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), ορισμένες υλοποιήσεις OAuth επιτρέπουν την ένδειξη της παραμέτρου GET **`prompt`** ως None (**`&prompt=none`**) για να **αποτρέψουν τους χρήστες από το να ερωτηθούν να επιβεβαιώσουν** την παρεχόμενη πρόσβαση σε ένα prompt στον ιστό αν είναι ήδη συνδεδεμένοι στην πλατφόρμα.

### response\_mode

Όπως [**εξηγείται σε αυτό το βίντεο**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), μπορεί να είναι δυνατό να υποδείξετε την παράμετρο **`response_mode`** για να υποδείξετε πού θέλετε να παρασχεθεί ο κωδικός στην τελική URL:

* `response_mode=query` -> Ο κωδικός παρέχεται μέσα σε μια παράμετρο GET: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Ο κωδικός παρέχεται μέσα στην παράμετρο fragment της URL `#code=2397rf3gu93f`
* `response_mode=form_post` -> Ο κωδικός παρέχεται μέσα σε μια φόρμα POST με ένα input που ονομάζεται `code` και την τιμή
* `response_mode=web_message` -> Ο κωδικός αποστέλλεται σε ένα μήνυμα post: `window.opener.postMessage({"code": "asdasdasd...`

### Παράμετροι SSRFs <a href="#bda5" id="bda5"></a>

[**Δείτε αυτή την έρευνα**](https://portswigger.net/research/hidden-oauth-attack-vectors) **για περισσότερες λεπτομέρειες αυτής της τεχνικής.**

Η Δυναμική Εγγραφή Πελατών στο OAuth λειτουργεί ως ένας λιγότερο προφανής αλλά κρίσιμος παράγοντας για ευπάθειες ασφαλείας, ειδικά για επιθέσεις **Server-Side Request Forgery (SSRF)**. Αυτό το endpoint επιτρέπει στους διακομιστές OAuth να λαμβάνουν λεπτομέρειες σχετικά με τις εφαρμογές πελατών, συμπεριλαμβανομένων ευαίσθητων URLs που θα μπορούσαν να εκμεταλλευτούν.

**Βασικά Σημεία:**

* Η **Δυναμική Εγγραφή Πελατών** συχνά αντιστοιχίζεται στο `/register` και δέχεται λεπτομέρειες όπως `client_name`, `client_secret`, `redirect_uris` και URLs για λογότυπα ή JSON Web Key Sets (JWKs) μέσω αιτημάτων POST.
* Αυτή η δυνατότητα ακολουθεί τις προδιαγραφές που ορίζονται στα **RFC7591** και **OpenID Connect Registration 1.0**, οι οποίες περιλαμβάνουν παραμέτρους που ενδέχεται να είναι ευάλωτες σε SSRF.
* Η διαδικασία εγγραφής μπορεί ακούσια να εκθέσει διακομιστές σε SSRF με διάφορους τρόπους:
* **`logo_uri`**: Ένα URL για το λογότυπο της εφαρμογής πελάτη που μπορεί να ανακτηθεί από τον διακομιστή, προκαλώντας SSRF ή οδηγώντας σε XSS αν το URL δεν διαχειριστεί σωστά.
* **`jwks_uri`**: Ένα URL στο έγγραφο JWK του πελάτη, το οποίο αν είναι κακόβουλα κατασκευασμένο, μπορεί να προκαλέσει τον διακομιστή να κάνει εξερχόμενα αιτήματα σε έναν διακομιστή που ελέγχεται από τον επιτιθέμενο.
* **`sector_identifier_uri`**: Αναφέρεται σε έναν πίνακα JSON των `redirect_uris`, τον οποίο ο διακομιστής μπορεί να ανακτήσει, δημιουργώντας μια ευκαιρία για SSRF.
* **`request_uris`**: Λίστα επιτρεπόμενων URIs αιτημάτων για τον πελάτη, τα οποία μπορούν να εκμεταλλευτούν αν ο διακομιστής ανακτήσει αυτά τα URIs στην αρχή της διαδικασίας εξουσιοδότησης.

**Στρατηγική Εκμετάλλευσης:**

* Το SSRF μπορεί να ενεργοποιηθεί με την εγγραφή ενός νέου πελάτη με κακόβουλα URLs σε παραμέτρους όπως `logo_uri`, `jwks_uri` ή `sector_identifier_uri`.
* Ενώ η άμεση εκμετάλλευση μέσω `request_uris` μπορεί να μετριαστεί από ελέγχους λίστας επιτρεπόμενων, η παροχή ενός προεγγεγραμμένου, ελεγχόμενου από τον επιτιθέμενο `request_uri` μπορεί να διευκολύνει το SSRF κατά τη φάση εξουσιοδότησης.

## Race Conditions σε παρόχους OAuth

Αν η πλατφόρμα που δοκιμάζετε είναι πάροχος OAuth [**διαβάστε αυτό για να δοκιμάσετε πιθανές Race Conditions**](race-condition.md).

## Αναφορές

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Μάθετε hacking στο AWS από το μηδέν μέχρι τον ήρωα με</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή **να κατεβάσετε το HackTricks σε PDF** δείτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο github.

</details>
