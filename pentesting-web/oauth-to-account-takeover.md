# OAuth to Account takeover

<details>

<summary><strong>Aprende hacking de AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Informaci√≥n B√°sica <a href="#d4a8" id="d4a8"></a>

OAuth ofrece varias versiones, con informaci√≥n fundamental accesible en [OAuth 2.0 documentation](https://oauth.net/2/). Esta discusi√≥n se centra principalmente en el ampliamente utilizado [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), proporcionando un **marco de autorizaci√≥n que permite a una aplicaci√≥n acceder o realizar acciones en la cuenta de un usuario en otra aplicaci√≥n** (el servidor de autorizaci√≥n).

Considera un sitio web hipot√©tico _**https://example.com**_, dise√±ado para **mostrar todas tus publicaciones en redes sociales**, incluidas las privadas. Para lograr esto, se emplea OAuth 2.0. _https://example.com_ solicitar√° tu permiso para **acceder a tus publicaciones en redes sociales**. En consecuencia, aparecer√° una pantalla de consentimiento en _https://socialmedia.com_, detallando los **permisos solicitados y el desarrollador que realiza la solicitud**. Tras tu autorizaci√≥n, _https://example.com_ obtiene la capacidad de **acceder a tus publicaciones en tu nombre**.

Es esencial comprender los siguientes componentes dentro del marco de OAuth 2.0:

* **resource owner**: T√∫, como **usuario/entidad**, autorizas el acceso a tu recurso, como las publicaciones de tu cuenta de redes sociales.
* **resource server**: El **servidor que gestiona las solicitudes autenticadas** despu√©s de que la aplicaci√≥n ha asegurado un `access token` en nombre del `resource owner`, por ejemplo, **https://socialmedia.com**.
* **client application**: La **aplicaci√≥n que busca autorizaci√≥n** del `resource owner`, como **https://example.com**.
* **authorization server**: El **servidor que emite `access tokens`** a la `client application` tras la autenticaci√≥n exitosa del `resource owner` y asegurar la autorizaci√≥n, por ejemplo, **https://socialmedia.com**.
* **client\_id**: Un identificador p√∫blico y √∫nico para la aplicaci√≥n.
* **client\_secret:** Una clave confidencial, conocida solo por la aplicaci√≥n y el servidor de autorizaci√≥n, utilizada para generar `access_tokens`.
* **response\_type**: Un valor que especifica **el tipo de token solicitado**, como `code`.
* **scope**: El **nivel de acceso** que la `client application` est√° solicitando del `resource owner`.
* **redirect\_uri**: La **URL a la que se redirige al usuario despu√©s de la autorizaci√≥n**. Esto t√≠picamente debe alinearse con la URL de redirecci√≥n pre-registrada.
* **state**: Un par√°metro para **mantener datos a trav√©s de la redirecci√≥n del usuario hacia y desde el servidor de autorizaci√≥n**. Su unicidad es cr√≠tica para servir como un **mecanismo de protecci√≥n CSRF**.
* **grant\_type**: Un par√°metro que indica **el tipo de concesi√≥n y el tipo de token que se devolver√°**.
* **code**: El c√≥digo de autorizaci√≥n del `authorization server`, utilizado junto con `client_id` y `client_secret` por la client application para adquirir un `access_token`.
* **access\_token**: El **token que la client application usa para solicitudes API** en nombre del `resource owner`.
* **refresh\_token**: Permite a la aplicaci√≥n **obtener un nuevo `access_token` sin volver a solicitar al usuario**.

### Flujo

El **flujo real de OAuth** procede de la siguiente manera:

1. Navegas a [https://example.com](https://example.com) y seleccionas el bot√≥n ‚ÄúIntegrar con Redes Sociales‚Äù.
2. El sitio env√≠a una solicitud a [https://socialmedia.com](https://socialmedia.com) pidiendo tu autorizaci√≥n para permitir que la aplicaci√≥n de https://example.com acceda a tus publicaciones. La solicitud est√° estructurada como:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Luego se te presenta una p√°gina de consentimiento.
4. Tras tu aprobaci√≥n, Social Media env√≠a una respuesta al `redirect_uri` con los par√°metros `code` y `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com utiliza este `code`, junto con su `client_id` y `client_secret`, para hacer una solicitud del lado del servidor y obtener un `access_token` en tu nombre, permitiendo el acceso a los permisos a los que diste tu consentimiento:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Finalmente, el proceso concluye cuando https://example.com emplea tu `access_token` para hacer una llamada API a Social Media para acceder

## Vulnerabilidades <a href="#id-323a" id="id-323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

El `redirect_uri` es crucial para la seguridad en implementaciones de OAuth y OpenID, ya que dirige a d√≥nde se env√≠an los datos sensibles, como los c√≥digos de autorizaci√≥n, despu√©s de la autorizaci√≥n. Si est√° mal configurado, podr√≠a permitir a los atacantes redirigir estas solicitudes a servidores maliciosos, habilitando la toma de control de cuentas.

Las t√©cnicas de explotaci√≥n var√≠an seg√∫n la l√≥gica de validaci√≥n del servidor de autorizaci√≥n. Pueden ir desde la coincidencia estricta de rutas hasta aceptar cualquier URL dentro del dominio o subdirectorio especificado. Los m√©todos comunes de explotaci√≥n incluyen redirecciones abiertas, recorrido de rutas, explotaci√≥n de regex d√©biles e inyecci√≥n de HTML para el robo de tokens.

Adem√°s de `redirect_uri`, otros par√°metros de OAuth y OpenID como `client_uri`, `policy_uri`, `tos_uri` e `initiate_login_uri` tambi√©n son susceptibles a ataques de redirecci√≥n. Estos par√°metros son opcionales y su soporte var√≠a entre servidores.

Para aquellos que apuntan a un servidor OpenID, el endpoint de descubrimiento (`**.well-known/openid-configuration**`) a menudo lista detalles de configuraci√≥n valiosos como `registration_endpoint`, `request_uri_parameter_supported` y "`require_request_uri_registration`. Estos detalles pueden ayudar a identificar el endpoint de registro y otros aspectos espec√≠ficos de la configuraci√≥n del servidor.

### XSS en la implementaci√≥n de redirecci√≥n <a href="#bda5" id="bda5"></a>

Como se menciona en este informe de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) podr√≠a ser posible que la **URL de redirecci√≥n se refleje en la respuesta** del servidor despu√©s de que el usuario se autentique, siendo **vulnerable a XSS**. Posible payload para probar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Manejo inadecuado del par√°metro state <a href="#bda5" id="bda5"></a>

En implementaciones de OAuth, el mal uso u omisi√≥n del **par√°metro `state`** puede aumentar significativamente el riesgo de ataques de **Cross-Site Request Forgery (CSRF)**. Esta vulnerabilidad surge cuando el par√°metro `state` **no se usa, se usa como un valor est√°tico o no se valida correctamente**, permitiendo a los atacantes eludir las protecciones CSRF.

Los atacantes pueden explotar esto interceptando el proceso de autorizaci√≥n para vincular su cuenta con la cuenta de la v√≠ctima, lo que puede llevar a **secuestros de cuentas**. Esto es especialmente cr√≠tico en aplicaciones donde OAuth se utiliza para **prop√≥sitos de autenticaci√≥n**.

Ejemplos reales de esta vulnerabilidad se han documentado en varios **desaf√≠os CTF** y **plataformas de hacking**, destacando sus implicaciones pr√°cticas. El problema tambi√©n se extiende a integraciones con servicios de terceros como **Slack**, **Stripe** y **PayPal**, donde los atacantes pueden redirigir notificaciones o pagos a sus cuentas.

El manejo y la validaci√≥n adecuados del **par√°metro `state`** son cruciales para protegerse contra CSRF y asegurar el flujo de OAuth.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Sin verificaci√≥n de correo electr√≥nico en la creaci√≥n de cuentas**: Los atacantes pueden crear una cuenta de manera preventiva utilizando el correo electr√≥nico de la v√≠ctima. Si la v√≠ctima luego usa un servicio de terceros para iniciar sesi√≥n, la aplicaci√≥n podr√≠a vincular inadvertidamente esta cuenta de terceros con la cuenta pre-creada por el atacante, lo que lleva a un acceso no autorizado.
2. **Explotaci√≥n de la verificaci√≥n de correo electr√≥nico laxa de OAuth**: Los atacantes pueden explotar servicios OAuth que no verifican correos electr√≥nicos registr√°ndose con su servicio y luego cambiando el correo electr√≥nico de la cuenta al de la v√≠ctima. Este m√©todo presenta un riesgo similar de acceso no autorizado, similar al primer escenario pero a trav√©s de un vector de ataque diferente.

### Divulgaci√≥n de secretos <a href="#e177" id="e177"></a>

Identificar y proteger los par√°metros secretos de OAuth es crucial. Mientras que el **`client_id`** puede ser divulgado de manera segura, revelar el **`client_secret`** presenta riesgos significativos. Si el `client_secret` se ve comprometido, los atacantes pueden explotar la identidad y la confianza de la aplicaci√≥n para **robar `access_tokens`** de usuarios e informaci√≥n privada.

Una vulnerabilidad com√∫n surge cuando las aplicaciones manejan incorrectamente el intercambio del `code` de autorizaci√≥n por un `access_token` en el lado del cliente en lugar del lado del servidor. Este error lleva a la exposici√≥n del `client_secret`, permitiendo a los atacantes generar `access_tokens` bajo la apariencia de la aplicaci√≥n. Adem√°s, a trav√©s de ingenier√≠a social, los atacantes podr√≠an escalar privilegios a√±adiendo alcances adicionales a la autorizaci√≥n de OAuth, explotando a√∫n m√°s el estado de confianza de la aplicaci√≥n.

### Client Secret Bruteforce

Puedes intentar **bruteforce el client\_secret** de un proveedor de servicios con el proveedor de identidad para intentar robar cuentas.\
La solicitud para BF puede parecerse a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Una vez que el cliente tiene el **code y state**, si est√° **reflejado dentro del encabezado Referer** cuando navega a una p√°gina diferente, entonces es vulnerable.

### Access Token Stored in Browser History

Ve al **historial del navegador y verifica si el access token est√° guardado all√≠**.

### Everlasting Authorization Code

El **authorization code deber√≠a vivir solo por un tiempo limitado para limitar la ventana de tiempo en la que un atacante puede robarlo y usarlo**.

### Authorization/Refresh Token not bound to client

Si puedes obtener el **authorization code y usarlo con un cliente diferente, entonces puedes tomar el control de otras cuentas**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Revisa este post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

En este informe de bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puedes ver que el **token** que **AWS Cognito** devuelve al usuario podr√≠a tener **suficientes permisos para sobrescribir los datos del usuario**. Por lo tanto, si puedes **cambiar el correo electr√≥nico del usuario por un correo electr√≥nico diferente**, podr√≠as **tomar el control** de otras cuentas.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para obtener informaci√≥n m√°s detallada sobre c√≥mo abusar de AWS cognito, consulta:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abusando de tokens de otras Apps <a href="#bda5" id="bda5"></a>

Como [**mencionado en este art√≠culo**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), los flujos de OAuth que esperan recibir el **token** (y no un c√≥digo) podr√≠an ser vulnerables si no verifican que el token pertenece a la aplicaci√≥n.

Esto se debe a que un **atacante** podr√≠a crear una **aplicaci√≥n que soporte OAuth y login con Facebook** (por ejemplo) en su propia aplicaci√≥n. Luego, una vez que una v√≠ctima inicie sesi√≥n con Facebook en la **aplicaci√≥n del atacante**, el atacante podr√≠a obtener el **token OAuth del usuario dado a su aplicaci√≥n y usarlo para iniciar sesi√≥n en la aplicaci√≥n OAuth de la v√≠ctima usando el token del usuario de la v√≠ctima**.

{% hint style="danger" %}
Por lo tanto, si el atacante logra que el usuario acceda a su propia aplicaci√≥n OAuth, podr√° tomar el control de la cuenta de la v√≠ctima en aplicaciones que esperan un token y no verifican si el token fue otorgado a su ID de aplicaci√≥n.
{% endhint %}

### Dos enlaces y cookie <a href="#bda5" id="bda5"></a>

Seg√∫n [**este art√≠culo**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era posible hacer que una v√≠ctima abriera una p√°gina con un **returnUrl** apuntando al host del atacante. Esta informaci√≥n se **almacenar√≠a en una cookie (RU)** y en un **paso posterior** el **prompt** **preguntar√°** al **usuario** si quiere dar acceso a ese host del atacante.

Para evitar este prompt, era posible abrir una pesta√±a para iniciar el **flujo OAuth** que establecer√≠a esta cookie RU usando el **returnUrl**, cerrar la pesta√±a antes de que se muestre el prompt y abrir una nueva pesta√±a sin ese valor. Luego, el **prompt no informar√° sobre el host del atacante**, pero la cookie estar√≠a configurada para ello, por lo que el **token se enviar√° al host del atacante** en la redirecci√≥n.

### Bypass de Interacci√≥n de Prompt <a href="#bda5" id="bda5"></a>

Como se explica en [**este video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), algunas implementaciones de OAuth permiten indicar el par√°metro GET **`prompt`** como None (**`&prompt=none`**) para **evitar que se le pida al usuario confirmar** el acceso dado en un prompt en la web si ya est√°n logueados en la plataforma.

### response\_mode

Como [**se explica en este video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), podr√≠a ser posible indicar el par√°metro **`response_mode`** para indicar d√≥nde quieres que se proporcione el c√≥digo en la URL final:

* `response_mode=query` -> El c√≥digo se proporciona dentro de un par√°metro GET: `?code=2397rf3gu93f`
* `response_mode=fragment` -> El c√≥digo se proporciona dentro del par√°metro de fragmento de la URL `#code=2397rf3gu93f`
* `response_mode=form_post` -> El c√≥digo se proporciona dentro de un formulario POST con un input llamado `code` y el valor
* `response_mode=web_message` -> El c√≥digo se env√≠a en un mensaje post: `window.opener.postMessage({"code": "asdasdasd...`

### Par√°metros SSRFs <a href="#bda5" id="bda5"></a>

[**Consulta esta investigaci√≥n**](https://portswigger.net/research/hidden-oauth-attack-vectors) **para m√°s detalles de esta t√©cnica.**

El Registro Din√°mico de Clientes en OAuth sirve como un vector menos obvio pero cr√≠tico para vulnerabilidades de seguridad, espec√≠ficamente para ataques de **Server-Side Request Forgery (SSRF)**. Este endpoint permite a los servidores OAuth recibir detalles sobre aplicaciones cliente, incluidas URLs sensibles que podr√≠an ser explotadas.

**Puntos Clave:**

* El **Registro Din√°mico de Clientes** a menudo se mapea a `/register` y acepta detalles como `client_name`, `client_secret`, `redirect_uris` y URLs para logos o JSON Web Key Sets (JWKs) a trav√©s de solicitudes POST.
* Esta caracter√≠stica se adhiere a las especificaciones establecidas en **RFC7591** y **OpenID Connect Registration 1.0**, que incluyen par√°metros potencialmente vulnerables a SSRF.
* El proceso de registro puede exponer inadvertidamente a los servidores a SSRF de varias maneras:
* **`logo_uri`**: Una URL para el logo de la aplicaci√≥n cliente que podr√≠a ser recuperada por el servidor, desencadenando SSRF o llevando a XSS si la URL se maneja incorrectamente.
* **`jwks_uri`**: Una URL al documento JWK del cliente, que si est√° maliciosamente dise√±ado, puede causar que el servidor haga solicitudes salientes a un servidor controlado por el atacante.
* **`sector_identifier_uri`**: Hace referencia a un array JSON de `redirect_uris`, que el servidor podr√≠a recuperar, creando una oportunidad de SSRF.
* **`request_uris`**: Lista las URIs de solicitud permitidas para el cliente, que pueden ser explotadas si el servidor recupera estas URIs al inicio del proceso de autorizaci√≥n.

**Estrategia de Explotaci√≥n:**

* SSRF puede ser desencadenado registrando un nuevo cliente con URLs maliciosas en par√°metros como `logo_uri`, `jwks_uri` o `sector_identifier_uri`.
* Mientras que la explotaci√≥n directa a trav√©s de `request_uris` puede ser mitigada por controles de lista blanca, suministrar una `request_uri` pre-registrada y controlada por el atacante puede facilitar SSRF durante la fase de autorizaci√≥n.

## Condiciones de Carrera en proveedores de OAuth

Si la plataforma que est√°s probando es un proveedor de OAuth [**lee esto para probar posibles Condiciones de Carrera**](race-condition.md).

## Referencias

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Aprende hacking de AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
