# OAuth to Account takeover

<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa katika HackTricks** au **kupakua HackTricks katika PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**rasmi PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za hacking kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Taarifa za Msingi <a href="#d4a8" id="d4a8"></a>

OAuth inatoa matoleo mbalimbali, na maarifa ya msingi yanapatikana kwenye [OAuth 2.0 documentation](https://oauth.net/2/). Majadiliano haya yanajikita zaidi kwenye [OAuth 2.0 authorization code grant type](https://oauth.net/2/grant-types/authorization-code/), ikitoa **mfumo wa idhini unaowezesha programu kupata au kutekeleza vitendo kwenye akaunti ya mtumiaji katika programu nyingine** (seva ya idhini).

Fikiria tovuti ya kinadharia _**https://example.com**_, iliyoundwa **kuonyesha machapisho yako yote ya mitandao ya kijamii**, pamoja na yale ya faragha. Ili kufanikisha hili, OAuth 2.0 inatumika. _https://example.com_ itaomba ruhusa yako **kupata machapisho yako ya mitandao ya kijamii**. Kwa hiyo, skrini ya idhini itaonekana kwenye _https://socialmedia.com_, ikielezea **ruhusa zinazotakiwa na msanidi programu anayefanya ombi**. Ukiruhusu, _https://example.com_ itapata uwezo wa **kupata machapisho yako kwa niaba yako**.

Ni muhimu kuelewa vipengele vifuatavyo ndani ya mfumo wa OAuth 2.0:

* **resource owner**: Wewe, kama **mtumiaji/kiumbe**, unaruhusu kupata rasilimali yako, kama machapisho yako ya akaunti ya mitandao ya kijamii.
* **resource server**: **Seva inayosimamia maombi yaliyothibitishwa** baada ya programu kupata `access token` kwa niaba ya `resource owner`, mfano, **https://socialmedia.com**.
* **client application**: **Programu inayotafuta idhini** kutoka kwa `resource owner`, kama **https://example.com**.
* **authorization server**: **Seva inayotoa `access tokens`** kwa `client application` baada ya uthibitisho wa mafanikio wa `resource owner` na kupata idhini, mfano, **https://socialmedia.com**.
* **client\_id**: Kitambulisho cha kipekee cha umma kwa programu.
* **client\_secret:** Ufunguo wa siri, unaojulikana tu kwa programu na seva ya idhini, unaotumika kwa kuzalisha `access_tokens`.
* **response\_type**: Thamani inayobainisha **aina ya tokeni inayotakiwa**, kama `code`.
* **scope**: **Kiwango cha upatikanaji** ambacho `client application` inataka kutoka kwa `resource owner`.
* **redirect\_uri**: **URL ambayo mtumiaji atarejeshwa baada ya idhini**. Hii kawaida lazima iendane na URL ya kuelekeza iliyosajiliwa awali.
* **state**: Kigezo cha **kudumisha data wakati wa kuelekeza mtumiaji kwenda na kutoka kwa seva ya idhini**. Upekee wake ni muhimu kwa kutumika kama **mfumo wa ulinzi wa CSRF**.
* **grant\_type**: Kigezo kinachoonyesha **aina ya grant na aina ya tokeni itakayorejeshwa**.
* **code**: Msimbo wa idhini kutoka kwa `authorization server`, unaotumika pamoja na `client_id` na `client_secret` na programu ya mteja kupata `access_token`.
* **access\_token**: **Tokeni ambayo programu ya mteja inatumia kwa maombi ya API** kwa niaba ya `resource owner`.
* **refresh\_token**: Inawezesha programu **kupata `access_token` mpya bila kumwomba mtumiaji tena**.

### Mtiririko

**Mtiririko halisi wa OAuth** unaendelea kama ifuatavyo:

1. Unatembelea [https://example.com](https://example.com) na kuchagua kitufe cha ‚ÄúIntegrate with Social Media‚Äù.
2. Tovuti hiyo kisha inatuma ombi kwa [https://socialmedia.com](https://socialmedia.com) ikiomba idhini yako kuruhusu programu ya https://example.com kupata machapisho yako. Ombi limeundwa kama:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Kisha unaonyeshwa ukurasa wa idhini.
4. Baada ya idhini yako, Mitandao ya Kijamii hutuma majibu kwa `redirect_uri` na vigezo vya `code` na `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com hutumia `code` hii, pamoja na `client_id` na `client_secret`, kufanya ombi la upande wa seva kupata `access_token` kwa niaba yako, ikiruhusu upatikanaji wa ruhusa ulizokubali:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Hatimaye, mchakato unakamilika kama https://example.com inavyotumia `access_token` yako kufanya API call kwa Social Media kupata

## Udhaifu <a href="#id-323a" id="id-323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

`redirect_uri` ni muhimu kwa usalama katika utekelezaji wa OAuth na OpenID, kwani inaelekeza mahali data nyeti, kama vile authorization codes, zinapotumwa baada ya kuidhinishwa. Ikiwa imekosewa, inaweza kuruhusu washambuliaji kuelekeza maombi haya kwa seva za hasidi, kuwezesha kuchukua akaunti.

Mbinu za unyonyaji hutofautiana kulingana na mantiki ya uthibitishaji ya seva ya idhini. Zinaweza kuanzia kulinganisha njia kali hadi kukubali URL yoyote ndani ya kikoa au subdirectory maalum. Mbinu za kawaida za unyonyaji ni pamoja na open redirects, path traversal, kutumia regex dhaifu, na HTML injection kwa wizi wa token.

Mbali na `redirect_uri`, vigezo vingine vya OAuth na OpenID kama `client_uri`, `policy_uri`, `tos_uri`, na `initiate_login_uri` pia vinaweza kushambuliwa na redirection attacks. Vigezo hivi ni vya hiari na msaada wao hutofautiana kati ya seva.

Kwa wale wanaolenga seva ya OpenID, endpoint ya ugunduzi (`**.well-known/openid-configuration**`) mara nyingi inaorodhesha maelezo muhimu ya usanidi kama `registration_endpoint`, `request_uri_parameter_supported`, na "`require_request_uri_registration`. Maelezo haya yanaweza kusaidia katika kutambua registration endpoint na maelezo mengine ya usanidi wa seva.

### XSS katika utekelezaji wa redirect <a href="#bda5" id="bda5"></a>

Kama ilivyotajwa katika ripoti hii ya bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) inawezekana kwamba redirect **URL inaakisiwa katika majibu** ya seva baada ya mtumiaji kuidhinishwa, ikiwa **inayoweza kushambuliwa na XSS**. Payload inayowezekana kujaribu:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Utunzaji usio sahihi wa kipengele cha state <a href="#bda5" id="bda5"></a>

Katika utekelezaji wa OAuth, matumizi mabaya au upungufu wa **`state` parameter** unaweza kuongeza kwa kiasi kikubwa hatari ya mashambulizi ya **Cross-Site Request Forgery (CSRF)**. Udhaifu huu hutokea wakati `state` parameter haijatumika, inatumika kama thamani ya static, au haijathibitishwa ipasavyo, kuruhusu washambuliaji kupita ulinzi wa CSRF.

Washambuliaji wanaweza kutumia udhaifu huu kwa kuingilia mchakato wa idhini ili kuunganisha akaunti yao na akaunti ya mwathirika, na kusababisha uwezekano wa **kuteka akaunti**. Hii ni muhimu sana katika programu ambapo OAuth inatumika kwa **madhumuni ya uthibitishaji**.

Mifano halisi ya udhaifu huu imeandikwa katika **CTF challenges** na **hacking platforms** mbalimbali, ikionyesha athari zake za vitendo. Tatizo hili pia linaenea kwa miunganisho na huduma za wahusika wa tatu kama **Slack**, **Stripe**, na **PayPal**, ambapo washambuliaji wanaweza kuelekeza arifa au malipo kwenye akaunti zao.

Utunzaji na uthibitishaji sahihi wa **`state` parameter** ni muhimu kwa kulinda dhidi ya CSRF na kuhakikisha usalama wa mtiririko wa OAuth.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Bila Uthibitishaji wa Barua Pepe wakati wa Kuunda Akaunti**: Washambuliaji wanaweza kuunda akaunti mapema kwa kutumia barua pepe ya mwathirika. Ikiwa mwathirika baadaye atatumia huduma ya wahusika wa tatu kwa kuingia, programu inaweza kwa bahati mbaya kuunganisha akaunti hiyo ya wahusika wa tatu na akaunti iliyoundwa na mshambuliaji, na kusababisha upatikanaji usioidhinishwa.
2. **Kutumia Ulegevu wa Uthibitishaji wa Barua Pepe wa OAuth**: Washambuliaji wanaweza kutumia huduma za OAuth ambazo hazithibitishi barua pepe kwa kujisajili na huduma yao na kisha kubadilisha barua pepe ya akaunti kuwa ya mwathirika. Njia hii pia inahatarisha upatikanaji usioidhinishwa wa akaunti, sawa na hali ya kwanza lakini kupitia njia tofauti ya shambulio.

### Uvujaji wa Siri <a href="#e177" id="e177"></a>

Kutambua na kulinda siri za OAuth ni muhimu. Wakati **`client_id`** inaweza kufichuliwa kwa usalama, kufichua **`client_secret`** kuna hatari kubwa. Ikiwa `client_secret` itavujika, washambuliaji wanaweza kutumia utambulisho na uaminifu wa programu kuiba **`access_tokens`** za watumiaji na taarifa za kibinafsi.

Udhaifu wa kawaida hutokea wakati programu zinashughulikia kimakosa kubadilishana `code` ya idhini kwa `access_token` upande wa mteja badala ya upande wa seva. Kosa hili husababisha kufichuliwa kwa `client_secret`, kuruhusu washambuliaji kuzalisha `access_tokens` kwa jina la programu. Zaidi ya hayo, kupitia uhandisi wa kijamii, washambuliaji wanaweza kuongeza ruhusa kwa kuongeza scopes za ziada kwenye idhini ya OAuth, na zaidi kutumia hali ya kuaminika ya programu.

### Client Secret Bruteforce

Unaweza kujaribu **bruteforce client\_secret** ya mtoa huduma na mtoa utambulisho ili kujaribu kuiba akaunti.\
Ombi la BF linaweza kuonekana kama:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Mara tu mteja anapopata **code na state**, ikiwa **imeakisiwa ndani ya kichwa cha Referer** anapovinjari kwenye ukurasa tofauti, basi ni hatarishi.

### Access Token Stored in Browser History

Nenda kwenye **historia ya kivinjari na uangalie kama access token imehifadhiwa humo**.

### Everlasting Authorization Code

**Authorization code inapaswa kuishi kwa muda tu ili kupunguza dirisha la muda ambapo mshambulizi anaweza kuiba na kuitumia**.

### Authorization/Refresh Token not bound to client

Ikiwa unaweza kupata **authorization code na kuitumia na mteja tofauti basi unaweza kuchukua akaunti za wengine**.

### Happy Paths, XSS, Iframes & Post Messages to leak code & state values

[**Angalia chapisho hili**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

Katika ripoti hii ya bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) unaweza kuona kwamba **token** ambayo **AWS Cognito** inampa mtumiaji inaweza kuwa na **ruhusa za kutosha kubadilisha data za mtumiaji**. Kwa hivyo, ikiwa unaweza **kubadilisha barua pepe ya mtumiaji kwa barua pepe tofauti ya mtumiaji**, unaweza kuwa na uwezo wa **kuchukua akaunti** za wengine.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Kwa maelezo zaidi kuhusu jinsi ya kutumia vibaya AWS cognito angalia:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Kutumia vibaya tokeni za Apps zingine <a href="#bda5" id="bda5"></a>

Kama [**ilivyotajwa katika maandishi haya**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), OAuth flows zinazotarajia kupokea **token** (na siyo code) zinaweza kuwa na udhaifu ikiwa hazikagui kama token inamilikiwa na app.

Hii ni kwa sababu **mshambuliaji** anaweza kuunda **application inayounga mkono OAuth na kuingia na Facebook** (kwa mfano) katika application yake mwenyewe. Kisha, mara tu mwathirika anapoingia na Facebook katika **application ya mshambuliaji**, mshambuliaji anaweza kupata **OAuth token ya mtumiaji iliyotolewa kwa application yake, na kuitumia kuingia katika application ya OAuth ya mwathirika kwa kutumia token ya mtumiaji wa mwathirika**.

{% hint style="danger" %}
Kwa hiyo, ikiwa mshambuliaji atafanikiwa kumfanya mtumiaji aingie katika application yake ya OAuth, ataweza kuchukua akaunti ya mwathirika katika applications zinazotarajia token na hazikagui kama token ilitolewa kwa ID ya app yao.
{% endhint %}

### Viungo viwili & cookie <a href="#bda5" id="bda5"></a>

Kulingana na [**maandishi haya**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), ilikuwa inawezekana kumfanya mwathirika afungue ukurasa na **returnUrl** inayoelekeza kwa host ya mshambuliaji. Taarifa hii ingeweza **kuhifadhiwa katika cookie (RU)** na katika **hatua ya baadaye** **prompt** itamuuliza **mtumiaji** kama anataka kutoa ruhusa kwa host ya mshambuliaji.

Ili kupita prompt hii, ilikuwa inawezekana kufungua tab kuanzisha **Oauth flow** ambayo ingeweka cookie hii ya RU kwa kutumia **returnUrl**, kufunga tab kabla ya prompt kuonyeshwa, na kufungua tab mpya bila thamani hiyo. Kisha, **prompt haitaarifu kuhusu host ya mshambuliaji**, lakini cookie ingekuwa imewekwa kwake, hivyo **token itatumwa kwa host ya mshambuliaji** katika redirection.

### Kupita Mwingiliano wa Prompt <a href="#bda5" id="bda5"></a>

Kama ilivyoelezwa katika [**video hii**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), baadhi ya utekelezaji wa OAuth huruhusu kuonyesha **`prompt`** GET parameter kama None (**`&prompt=none`**) ili **kuzuia watumiaji kuulizwa kuthibitisha** ruhusa iliyotolewa katika prompt kwenye wavuti ikiwa tayari wameingia kwenye jukwaa.

### response\_mode

Kama [**ilivyoelezwa katika video hii**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), inaweza kuwa inawezekana kuonyesha parameter **`response_mode`** kuonyesha wapi unataka code itolewe katika URL ya mwisho:

* `response_mode=query` -> Code inatolewa ndani ya GET parameter: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Code inatolewa ndani ya URL fragment parameter `#code=2397rf3gu93f`
* `response_mode=form_post` -> Code inatolewa ndani ya fomu ya POST na input inayoitwa `code` na thamani
* `response_mode=web_message` -> Code inatumwa katika ujumbe wa post: `window.opener.postMessage({"code": "asdasdasd...`

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Angalia utafiti huu**](https://portswigger.net/research/hidden-oauth-attack-vectors) **Kwa maelezo zaidi ya mbinu hii.**

Dynamic Client Registration katika OAuth hutumika kama vector muhimu lakini isiyo dhahiri kwa udhaifu wa usalama, hasa kwa mashambulizi ya **Server-Side Request Forgery (SSRF)**. Endpoint hii inaruhusu OAuth servers kupokea maelezo kuhusu client applications, ikiwa ni pamoja na URLs nyeti ambazo zinaweza kutumiwa vibaya.

**Mambo Muhimu:**

* **Dynamic Client Registration** mara nyingi inahusishwa na `/register` na inakubali maelezo kama `client_name`, `client_secret`, `redirect_uris`, na URLs za logos au JSON Web Key Sets (JWKs) kupitia POST requests.
* Kipengele hiki kinazingatia vipimo vilivyowekwa katika **RFC7591** na **OpenID Connect Registration 1.0**, ambavyo vinajumuisha parameters zinazoweza kuwa na udhaifu wa SSRF.
* Mchakato wa usajili unaweza kwa bahati mbaya kufichua servers kwa SSRF kwa njia kadhaa:
* **`logo_uri`**: URL ya logo ya client application ambayo inaweza kufikiwa na server, ikisababisha SSRF au kupelekea XSS ikiwa URL itashughulikiwa vibaya.
* **`jwks_uri`**: URL ya hati ya JWK ya client, ambayo ikiwa imeundwa kwa nia mbaya, inaweza kusababisha server kufanya maombi ya nje kwa server inayodhibitiwa na mshambuliaji.
* **`sector_identifier_uri`**: Inarejelea array ya JSON ya `redirect_uris`, ambayo server inaweza kufikia, ikitoa fursa ya SSRF.
* **`request_uris`**: Orodha ya URIs za maombi zinazokubalika kwa client, ambazo zinaweza kutumiwa vibaya ikiwa server itafikia URIs hizi mwanzoni mwa mchakato wa ruhusa.

**Mkakati wa Kunyonywa:**

* SSRF inaweza kuchochewa kwa kusajili client mpya na URLs za nia mbaya katika parameters kama `logo_uri`, `jwks_uri`, au `sector_identifier_uri`.
* Wakati unyonyaji wa moja kwa moja kupitia `request_uris` unaweza kupunguzwa na udhibiti wa whitelist, kutoa `request_uri` iliyosajiliwa awali na kudhibitiwa na mshambuliaji inaweza kuwezesha SSRF wakati wa awamu ya ruhusa.

## OAuth providers Race Conditions

Ikiwa jukwaa unalolijaribu ni mtoa huduma wa OAuth [**soma hili ili kujaribu Race Conditions zinazowezekana**](race-condition.md).

## Marejeleo

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Jifunze udukuzi wa AWS kutoka sifuri hadi mtaalamu na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia zingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa katika HackTricks** au **kupakua HackTricks katika PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **fuata** sisi kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
