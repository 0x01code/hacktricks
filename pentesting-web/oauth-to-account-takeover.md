# OAuth zur Konto√ºbernahme

<details>

<summary><strong>Lerne AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn du deine **Firma in HackTricks bewerben** oder **HackTricks als PDF herunterladen** m√∂chtest, sieh dir die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop) an!
* Hol dir das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecke [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere exklusive Sammlung von [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Tritt der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folge** uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teile deine Hacking-Tricks, indem du PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichst.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Grundlegende Informationen <a href="#d4a8" id="d4a8"></a>

OAuth bietet verschiedene Versionen, mit grundlegenden Einblicken zug√§nglich unter [OAuth 2.0 Dokumentation](https://oauth.net/2/). Diese Diskussion konzentriert sich haupts√§chlich auf den weit verbreiteten [OAuth 2.0 Authorization Code Grant Type](https://oauth.net/2/grant-types/authorization-code/), der ein **Autorisierungsframework bietet, das es einer Anwendung erm√∂glicht, auf das Konto eines Benutzers in einer anderen Anwendung zuzugreifen oder Aktionen durchzuf√ºhren** (der Autorisierungsserver).

Betrachten wir eine hypothetische Website _**https://example.com**_, die **alle deine Social-Media-Posts, einschlie√ülich privater, anzeigen soll**. Um dies zu erreichen, wird OAuth 2.0 verwendet. _https://example.com_ wird um deine Erlaubnis bitten, **auf deine Social-Media-Posts zuzugreifen**. Folglich erscheint ein Zustimmungsbildschirm auf _https://socialmedia.com_, der die **angeforderten Berechtigungen und den Entwickler, der die Anfrage stellt**, aufzeigt. Nach deiner Autorisierung erh√§lt _https://example.com_ die M√∂glichkeit, **in deinem Namen auf deine Posts zuzugreifen**.

Es ist wichtig, die folgenden Komponenten innerhalb des OAuth 2.0 Frameworks zu verstehen:

* **resource owner**: Du, als **Benutzer/Entit√§t**, autorisierst den Zugriff auf deine Ressource, wie deine Social-Media-Posts.
* **resource server**: Der **Server, der authentifizierte Anfragen verwaltet**, nachdem die Anwendung ein `access token` im Namen des `resource owner` gesichert hat, z.B. **https://socialmedia.com**.
* **client application**: Die **Anwendung, die die Autorisierung vom `resource owner` anfordert**, wie **https://example.com**.
* **authorization server**: Der **Server, der `access tokens` an die `client application` ausstellt**, nachdem die erfolgreiche Authentifizierung des `resource owner` und die Sicherung der Autorisierung erfolgt ist, z.B. **https://socialmedia.com**.
* **client\_id**: Ein √∂ffentlicher, eindeutiger Bezeichner f√ºr die Anwendung.
* **client\_secret:** Ein vertraulicher Schl√ºssel, der nur der Anwendung und dem Autorisierungsserver bekannt ist und zur Generierung von `access_tokens` verwendet wird.
* **response\_type**: Ein Wert, der **den Typ des angeforderten Tokens** angibt, wie `code`.
* **scope**: Das **Zugriffslevel**, das die `client application` vom `resource owner` anfordert.
* **redirect\_uri**: Die **URL, zu der der Benutzer nach der Autorisierung umgeleitet wird**. Diese muss typischerweise mit der vorregistrierten Umleitungs-URL √ºbereinstimmen.
* **state**: Ein Parameter, um **Daten √ºber die Umleitung des Benutzers zum und vom Autorisierungsserver hinweg beizubehalten**. Seine Einzigartigkeit ist entscheidend, um als **CSRF-Schutzmechanismus** zu dienen.
* **grant\_type**: Ein Parameter, der **den Grant-Typ und den Typ des zur√ºckzugebenden Tokens** angibt.
* **code**: Der Autorisierungscode vom `authorization server`, der zusammen mit `client_id` und `client_secret` von der Client-Anwendung verwendet wird, um ein `access_token` zu erhalten.
* **access\_token**: Das **Token, das die Client-Anwendung f√ºr API-Anfragen im Namen des `resource owner` verwendet**.
* **refresh\_token**: Erm√∂glicht der Anwendung, **ein neues `access_token` zu erhalten, ohne den Benutzer erneut zu fragen**.

### Ablauf

Der **tats√§chliche OAuth-Ablauf** verl√§uft wie folgt:

1. Du navigierst zu [https://example.com](https://example.com) und w√§hlst die Schaltfl√§che ‚ÄûMit Social Media integrieren‚Äú.
2. Die Seite sendet dann eine Anfrage an [https://socialmedia.com](https://socialmedia.com), um deine Autorisierung zu bitten, damit die Anwendung von https://example.com auf deine Posts zugreifen kann. Die Anfrage ist wie folgt strukturiert:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Sie werden dann mit einer Einwilligungsseite konfrontiert.
4. Nach Ihrer Zustimmung sendet Social Media eine Antwort an die `redirect_uri` mit den Parametern `code` und `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com verwendet diesen `code` zusammen mit seiner `client_id` und `client_secret`, um eine serverseitige Anfrage zu stellen, um ein `access_token` in Ihrem Namen zu erhalten, wodurch der Zugriff auf die von Ihnen zugestimmten Berechtigungen erm√∂glicht wird:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Schlie√ülich endet der Prozess, wenn https://example.com dein `access_token` verwendet, um einen API-Aufruf an Social Media zu machen, um darauf zuzugreifen.

## Schwachstellen <a href="#id-323a" id="id-323a"></a>

### Open redirect\_uri <a href="#cc36" id="cc36"></a>

Die `redirect_uri` ist entscheidend f√ºr die Sicherheit in OAuth- und OpenID-Implementierungen, da sie bestimmt, wohin sensible Daten wie Autorisierungscodes nach der Autorisierung gesendet werden. Wenn sie falsch konfiguriert ist, k√∂nnte es Angreifern erm√∂glichen, diese Anfragen zu b√∂sartigen Servern umzuleiten, was eine Konto√ºbernahme erm√∂glicht.

Die Ausnutzungstechniken variieren je nach Validierungslogik des Autorisierungsservers. Sie k√∂nnen von striktem Pfadabgleich bis hin zur Akzeptanz jeder URL innerhalb der angegebenen Domain oder Unterverzeichnis reichen. H√§ufige Ausnutzungsmethoden umfassen offene Umleitungen, Pfadtraversierung, Ausnutzung schwacher Regexes und HTML-Injektion zum Token-Diebstahl.

Neben `redirect_uri` sind auch andere OAuth- und OpenID-Parameter wie `client_uri`, `policy_uri`, `tos_uri` und `initiate_login_uri` anf√§llig f√ºr Umleitungsangriffe. Diese Parameter sind optional und ihre Unterst√ºtzung variiert je nach Server.

F√ºr diejenigen, die einen OpenID-Server ins Visier nehmen, listet der Discovery-Endpunkt (`**.well-known/openid-configuration**`) oft wertvolle Konfigurationsdetails wie `registration_endpoint`, `request_uri_parameter_supported` und "`require_request_uri_registration`. Diese Details k√∂nnen helfen, den Registrierungsendpunkt und andere Konfigurationsspezifika des Servers zu identifizieren.

### XSS in der Redirect-Implementierung <a href="#bda5" id="bda5"></a>

Wie in diesem Bug-Bounty-Bericht erw√§hnt [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) k√∂nnte es m√∂glich sein, dass die Redirect-**URL in der Antwort** des Servers nach der Authentifizierung des Benutzers reflektiert wird und **anf√§llig f√ºr XSS** ist. M√∂gliche Nutzlast zum Testen:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Unsachgem√§√üe Handhabung des state-Parameters <a href="#bda5" id="bda5"></a>

In OAuth-Implementierungen kann der Missbrauch oder das Weglassen des **`state`-Parameters** das Risiko von **Cross-Site Request Forgery (CSRF)**-Angriffen erheblich erh√∂hen. Diese Schwachstelle entsteht, wenn der `state`-Parameter entweder **nicht verwendet, als statischer Wert verwendet oder nicht ordnungsgem√§√ü validiert** wird, wodurch Angreifer CSRF-Schutzma√ünahmen umgehen k√∂nnen.

Angreifer k√∂nnen dies ausnutzen, indem sie den Autorisierungsprozess abfangen, um ihr Konto mit dem Konto des Opfers zu verkn√ºpfen, was zu potenziellen **Konten√ºbernahmen** f√ºhrt. Dies ist besonders kritisch in Anwendungen, bei denen OAuth f√ºr **Authentifizierungszwecke** verwendet wird.

Reale Beispiele f√ºr diese Schwachstelle wurden in verschiedenen **CTF-Challenges** und **Hacking-Plattformen** dokumentiert, was ihre praktischen Auswirkungen verdeutlicht. Das Problem erstreckt sich auch auf Integrationen mit Drittanbieterdiensten wie **Slack**, **Stripe** und **PayPal**, bei denen Angreifer Benachrichtigungen oder Zahlungen auf ihre Konten umleiten k√∂nnen.

Die ordnungsgem√§√üe Handhabung und Validierung des **`state`-Parameters** ist entscheidend f√ºr den Schutz vor CSRF und die Sicherung des OAuth-Flows.

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Ohne E-Mail-Verifizierung bei der Kontoerstellung**: Angreifer k√∂nnen im Voraus ein Konto mit der E-Mail des Opfers erstellen. Wenn das Opfer sp√§ter einen Drittanbieterdienst f√ºr die Anmeldung verwendet, k√∂nnte die Anwendung dieses Drittanbieter-Konto versehentlich mit dem vom Angreifer erstellten Konto verkn√ºpfen, was zu unbefugtem Zugriff f√ºhrt.
2. **Ausnutzung laxen OAuth-E-Mail-Verifizierungen**: Angreifer k√∂nnen OAuth-Dienste ausnutzen, die E-Mails nicht verifizieren, indem sie sich bei ihrem Dienst registrieren und dann die Kontoe-Mail auf die des Opfers √§ndern. Diese Methode birgt √§hnliche Risiken f√ºr unbefugten Kontozugriff, √§hnlich wie im ersten Szenario, jedoch √ºber einen anderen Angriffsvektor.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Die Identifizierung und der Schutz geheimer OAuth-Parameter sind entscheidend. W√§hrend der **`client_id`** sicher offengelegt werden kann, birgt die Offenlegung des **`client_secret`** erhebliche Risiken. Wenn das `client_secret` kompromittiert wird, k√∂nnen Angreifer die Identit√§t und das Vertrauen der Anwendung ausnutzen, um **Benutzer-`access_tokens`** und private Informationen zu stehlen.

Eine h√§ufige Schwachstelle entsteht, wenn Anwendungen den Austausch des Autorisierungs-`codes` gegen ein `access_token` f√§lschlicherweise clientseitig statt serverseitig abwickeln. Dieser Fehler f√ºhrt zur Offenlegung des `client_secret`, wodurch Angreifer `access_tokens` im Namen der Anwendung generieren k√∂nnen. Dar√ºber hinaus k√∂nnten Angreifer durch Social Engineering Privilegien eskalieren, indem sie zus√§tzliche Scopes zur OAuth-Autorisierung hinzuf√ºgen und den vertrauensw√ºrdigen Status der Anwendung weiter ausnutzen.

### Client Secret Bruteforce

Man kann versuchen, das **client\_secret** eines Dienstanbieters mit dem Identit√§tsanbieter zu bruteforcen, um Konten zu stehlen.\
Die Anfrage zum BF k√∂nnte √§hnlich aussehen wie:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header leaking Code + State

Sobald der Client den **Code und State** hat, ist er **anf√§llig**, wenn er beim Wechseln zu einer anderen Seite **im Referer-Header reflektiert wird**.

### Access Token im Browser-Verlauf gespeichert

Gehe zum **Browser-Verlauf und √ºberpr√ºfe, ob der Access Token dort gespeichert ist**.

### Everlasting Authorization Code

Der **Authorization Code sollte nur f√ºr eine begrenzte Zeit g√ºltig sein, um das Zeitfenster zu begrenzen, in dem ein Angreifer ihn stehlen und verwenden kann**.

### Authorization/Refresh Token nicht an Client gebunden

Wenn du den **Authorization Code erhalten und ihn mit einem anderen Client verwenden kannst, dann kannst du andere Konten √ºbernehmen**.

### Happy Paths, XSS, Iframes & Post Messages zum Leaken von Code- und State-Werten

[**Check this post**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In diesem Bug-Bounty-Bericht: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) kannst du sehen, dass der **Token**, den **AWS Cognito** dem Benutzer zur√ºckgibt, m√∂glicherweise **ausreichende Berechtigungen hat, um die Benutzerdaten zu √ºberschreiben**. Daher, wenn du die **Benutzer-E-Mail in eine andere E-Mail √§ndern kannst**, k√∂nntest du m√∂glicherweise **andere Konten √ºbernehmen**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
F√ºr detailliertere Informationen dar√ºber, wie man AWS Cognito missbraucht, siehe:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Missbrauch von Tokens anderer Apps <a href="#bda5" id="bda5"></a>

Wie in [**diesem Artikel**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) erw√§hnt, k√∂nnten OAuth-Flows, die erwarten, den **Token** (und nicht einen Code) zu erhalten, anf√§llig sein, wenn sie nicht √ºberpr√ºfen, ob der Token zur App geh√∂rt.

Dies liegt daran, dass ein **Angreifer** eine **Anwendung mit OAuth-Unterst√ºtzung erstellen und sich mit Facebook** (zum Beispiel) in seiner eigenen Anwendung anmelden k√∂nnte. Sobald ein Opfer sich mit Facebook in der **Anwendung des Angreifers** anmeldet, k√∂nnte der Angreifer den **OAuth-Token des Benutzers erhalten, der seiner Anwendung gegeben wurde, und ihn verwenden, um sich in der OAuth-Anwendung des Opfers mit dem Token des Opfers anzumelden**.

{% hint style="danger" %}
Wenn es dem Angreifer gelingt, den Benutzer dazu zu bringen, seine eigene OAuth-Anwendung zu nutzen, kann er das Konto des Opfers in Anwendungen √ºbernehmen, die einen Token erwarten und nicht √ºberpr√ºfen, ob der Token ihrer App-ID zugewiesen wurde.
{% endhint %}

### Zwei Links & Cookie <a href="#bda5" id="bda5"></a>

Laut [**diesem Artikel**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f) war es m√∂glich, ein Opfer dazu zu bringen, eine Seite mit einer **returnUrl** zu √∂ffnen, die auf den Host des Angreifers zeigt. Diese Information w√ºrde in einem **Cookie (RU)** gespeichert und in einem **sp√§teren Schritt** w√ºrde der **Prompt** den **Benutzer** fragen, ob er dem Host des Angreifers Zugriff gew√§hren m√∂chte.

Um diesen Prompt zu umgehen, war es m√∂glich, einen Tab zu √∂ffnen, um den **Oauth-Flow** zu initiieren, der dieses RU-Cookie mit der **returnUrl** setzt, den Tab zu schlie√üen, bevor der Prompt angezeigt wird, und einen neuen Tab ohne diesen Wert zu √∂ffnen. Dann w√ºrde der **Prompt nicht √ºber den Host des Angreifers informieren**, aber das Cookie w√§re darauf gesetzt, sodass der **Token an den Host des Angreifers** in der Weiterleitung gesendet wird.

### Prompt-Interaktions-Umgehung <a href="#bda5" id="bda5"></a>

Wie in [**diesem Video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q) erkl√§rt, erlauben einige OAuth-Implementierungen die Angabe des **`prompt`** GET-Parameters als None (**`&prompt=none`**), um **zu verhindern, dass Benutzer aufgefordert werden, den gegebenen Zugriff zu best√§tigen**, wenn sie bereits in der Plattform eingeloggt sind.

### response\_mode

Wie in [**diesem Video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q) erkl√§rt, k√∂nnte es m√∂glich sein, den Parameter **`response_mode`** anzugeben, um anzugeben, wo der Code in der endg√ºltigen URL bereitgestellt werden soll:

* `response_mode=query` -> Der Code wird in einem GET-Parameter bereitgestellt: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Der Code wird im URL-Fragment-Parameter bereitgestellt `#code=2397rf3gu93f`
* `response_mode=form_post` -> Der Code wird in einem POST-Formular mit einem Eingabefeld namens `code` und dem Wert bereitgestellt
* `response_mode=web_message` -> Der Code wird in einer Post-Nachricht gesendet: `window.opener.postMessage({"code": "asdasdasd...`

### SSRFs Parameter <a href="#bda5" id="bda5"></a>

[**Siehe diese Forschung**](https://portswigger.net/research/hidden-oauth-attack-vectors) **f√ºr weitere Details zu dieser Technik.**

Die dynamische Client-Registrierung in OAuth dient als weniger offensichtlicher, aber kritischer Vektor f√ºr Sicherheitsl√ºcken, insbesondere f√ºr **Server-Side Request Forgery (SSRF)**-Angriffe. Dieser Endpunkt erm√∂glicht es OAuth-Servern, Details √ºber Client-Anwendungen zu erhalten, einschlie√ülich sensibler URLs, die ausgenutzt werden k√∂nnten.

**Wichtige Punkte:**

* **Dynamische Client-Registrierung** ist oft auf `/register` abgebildet und akzeptiert Details wie `client_name`, `client_secret`, `redirect_uris` und URLs f√ºr Logos oder JSON Web Key Sets (JWKs) √ºber POST-Anfragen.
* Diese Funktion h√§lt sich an die Spezifikationen in **RFC7591** und **OpenID Connect Registration 1.0**, die Parameter enthalten, die potenziell anf√§llig f√ºr SSRF sind.
* Der Registrierungsprozess kann Server auf verschiedene Weise unbeabsichtigt SSRF aussetzen:
* **`logo_uri`**: Eine URL f√ºr das Logo der Client-Anwendung, die vom Server abgerufen werden k√∂nnte, was SSRF ausl√∂sen oder zu XSS f√ºhren kann, wenn die URL falsch gehandhabt wird.
* **`jwks_uri`**: Eine URL zum JWK-Dokument des Clients, die, wenn b√∂sartig gestaltet, den Server dazu bringen kann, ausgehende Anfragen an einen vom Angreifer kontrollierten Server zu senden.
* **`sector_identifier_uri`**: Verweist auf ein JSON-Array von `redirect_uris`, das der Server abrufen k√∂nnte, was eine SSRF-M√∂glichkeit schafft.
* **`request_uris`**: Listet erlaubte Anforderungs-URIs f√ºr den Client auf, die ausgenutzt werden k√∂nnen, wenn der Server diese URIs zu Beginn des Autorisierungsprozesses abruft.

**Exploitation-Strategie:**

* SSRF kann ausgel√∂st werden, indem ein neuer Client mit b√∂sartigen URLs in Parametern wie `logo_uri`, `jwks_uri` oder `sector_identifier_uri` registriert wird.
* W√§hrend die direkte Ausnutzung √ºber `request_uris` durch Whitelist-Kontrollen gemildert werden kann, kann die Bereitstellung einer vorregistrierten, vom Angreifer kontrollierten `request_uri` SSRF w√§hrend der Autorisierungsphase erleichtern.

## OAuth-Anbieter Race Conditions

Wenn die Plattform, die Sie testen, ein OAuth-Anbieter ist, [**lesen Sie dies, um m√∂gliche Race Conditions zu testen**](race-condition.md).

## Referenzen

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Lerne AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihre **Firma in HackTricks bewerben** oder **HackTricks als PDF herunterladen** m√∂chten, sehen Sie sich die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop) an!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repos einreichen.

</details>
