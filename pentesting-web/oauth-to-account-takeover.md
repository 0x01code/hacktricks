# OAuth vers la prise de contr√¥le de compte

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informations de base <a href="#d4a8" id="d4a8"></a>

Il existe plusieurs versions d'OAuth, vous pouvez lire [https://oauth.net/2/](https://oauth.net/2/) pour avoir une compr√©hension de base.

Dans cet article, nous nous concentrerons sur le flux le plus courant que vous rencontrerez aujourd'hui, qui est le [type de subvention de code d'autorisation OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/). En substance, OAuth fournit aux d√©veloppeurs un **m√©canisme d'autorisation pour permettre √† une application d'acc√©der √† des donn√©es ou d'effectuer certaines actions contre votre compte, √† partir d'une autre application** (le serveur d'autorisation).

Par exemple, supposons que le site web _**https://yourtweetreader.com**_ ait une fonctionnalit√© pour **afficher tous les tweets que vous avez jamais envoy√©s**, y compris les tweets priv√©s. Pour ce faire, OAuth 2.0 est introduit. _https://yourtweetreader.com_ vous demandera d'**autoriser leur application Twitter √† acc√©der √† tous vos tweets**. Une page de consentement appara√Ætra sur _https://twitter.com_ affichant les **autorisations demand√©es**, et qui est le d√©veloppeur qui le demande. Une fois que vous avez autoris√© la demande, _https://yourtweetreader.com_ sera **en mesure d'acc√©der √† vos tweets en votre nom**.

Les √©l√©ments importants √† comprendre dans un contexte OAuth 2.0 :

* **propri√©taire de la ressource** : Le `propri√©taire de la ressource` est l'**utilisateur/entit√©** accordant l'acc√®s √† sa ressource prot√©g√©e, telle que ses tweets de compte Twitter. Dans cet exemple, ce serait **vous**.
* **serveur de ressources** : Le `serveur de ressources` est le **serveur qui g√®re les demandes authentifi√©es** apr√®s que l'application a obtenu un `jeton d'acc√®s` au nom du `propri√©taire de la ressource`. Dans cet exemple, ce serait **https://twitter.com**
* **application cliente** : L'`application cliente` est l'**application qui demande l'autorisation** du `propri√©taire de la ressource`. Dans cet exemple, ce serait **https://yourtweetreader.com**.
* **serveur d'autorisation** : Le `serveur d'autorisation` est le **serveur qui √©met des `jetons d'acc√®s`** √† l'`application cliente` **apr√®s avoir authentifi√© avec succ√®s** le `propri√©taire de la ressource` et obtenu l'autorisation. Dans l'exemple ci-dessus, ce serait **https://twitter.com**
* **client\_id** : Le `client_id` est l'**identifiant de l'application**. Il s'agit d'un identifiant unique public, **non secret**.
* **client\_secret** : Le `client_secret` est un **secret connu uniquement de l'application et du serveur d'autorisation**. Cela est utilis√© pour g√©n√©rer des `jetons d'acc√®s`.
* **response\_type** : Le `response_type` est une valeur pour d√©tailler **quel type de jeton** est demand√©, tel que `code`
* **scope** : Le `scope` est le **niveau d'acc√®s demand√©** que l'`application cliente` demande du `propri√©taire de la ressource`
* **redirect\_uri** : Le `redirect_uri` est l'**URL vers laquelle l'utilisateur est redirig√© apr√®s la fin de l'autorisation**. Cela doit g√©n√©ralement correspondre √† l'URL de redirection que vous avez pr√©c√©demment enregistr√©e aupr√®s du service
* **state** : Le param√®tre `state` peut **persister les donn√©es entre la redirection de l'utilisateur vers le serveur d'autorisation et le retour**. Il est important que cela soit une valeur unique car il sert de **m√©canisme de protection CSRF** s'il contient une valeur unique ou al√©atoire par demande
* **grant\_type** : Le param√®tre `grant_type` explique **quel est le type de subvention**, et quel jeton va √™tre retourn√©
* **code** : Ce `code` est le code d'autorisation re√ßu du `serveur d'autorisation` qui sera dans le param√®tre de cha√Æne de requ√™te "code" dans cette demande. Ce code est utilis√© conjointement avec le `client_id` et le `client_secret` par l'application cliente pour r√©cup√©rer un `jeton d'acc√®s`
* **access\_token** : Le `access_token` est le **jeton que l'application cliente utilise pour effectuer des demandes API** au nom d'un `propri√©taire de la ressource`
* **refresh\_token** : Le `refresh_token` permet √† une application d'**obtenir un nouveau `jeton d'acc√®s` sans demander √† l'utilisateur**

### Exemple r√©el

En mettant tout cela ensemble, voici √† quoi ressemble un **flux OAuth r√©el** :

1. Vous visitez [https://yourtweetreader.com](https://yourtweetreader.com) et cliquez sur le bouton "Int√©grer avec Twitter".
2. [https://yourtweetreader.com](https://yourtweetreader.com) envoie une demande √† [https://twitter.com](https://twitter.com) vous demandant, le propri√©taire de la ressource, d'autoriser l'application Twitter de https://yourtweetreader.com √† acc√©der √† vos tweets. La demande ressemblera √† :
```
https://twitter.com/auth
 ?response_type=code
 &client_id=yourtweetreader_clientId
 &redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
 &scope=readTweets
 &state=kasodk9d1jd992k9klaskdh123
```
3\. Vous serez invit√© √† une page de consentement :

![](https://miro.medium.com/max/1215/1\*y66EY3Fn2qn-NPI9nhZC7A.png)

4\. Une fois accept√©, Twitter enverra une demande de retour √† l'`redirect_uri` avec les param√®tres `code` et `state`:
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123
```
5\. Ensuite, [https://yourtweetreader.com](https://yourtweetreader.com) prendra ce `code` et, en utilisant l'`client_id` et le `client_secret` de leur application, fera une demande depuis le serveur pour r√©cup√©rer un `access_token` en votre nom, ce qui leur permettra d'acc√©der aux autorisations auxquelles vous avez consenti :
```
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", "client_secret": "yourtweetreader_clientSecret", "code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}
```
6\. Enfin, le flux est complet et [https://yourtweetreader.com](https://yourtweetreader.com) fera un appel API √† Twitter avec votre `access_token` pour acc√©der √† vos Tweets.

## D√©couvertes de Bug Bounty <a href="#323a" id="323a"></a>

Maintenant, la partie int√©ressante ! Il y a de nombreuses choses qui peuvent mal tourner dans une impl√©mentation OAuth, voici les diff√©rentes cat√©gories de bugs que je vois fr√©quemment :

### Configuration de `redirect_uri` faible <a href="#cc36" id="cc36"></a>

Le `redirect_uri` est tr√®s important car des donn√©es sensibles, telles que le `code`, sont ajout√©es √† cette URL apr√®s l'autorisation. Si le `redirect_uri` peut √™tre redirig√© vers un serveur **contr√¥l√© par un attaquant**, cela signifie que l'attaquant peut potentiellement **prendre le contr√¥le du compte d'une victime** en utilisant le `code` lui-m√™me et en acc√©dant aux donn√©es de la victime.

La fa√ßon dont cela va √™tre exploit√© va varier en fonction du serveur d'autorisation. **Certains** n'accepteront que le m√™me chemin exact de `redirect_uri` sp√©cifi√© dans l'application cliente, mais certains accepteront **n'importe quoi** dans le m√™me domaine ou sous-r√©pertoire de `redirect_uri`.

En fonction de la logique g√©r√©e par le serveur, il existe plusieurs techniques pour contourner un `redirect_uri`. Dans une situation o√π un `redirect_uri` est [https://yourtweetreader.com](https://yourtweetreader.com)/callback, celles-ci incluent :

* Redirections ouvertes : [`https://yourtweetreader.com`](https://yourtweetreader.com)`/callback?redirectUrl=https://evil.com`
* Travers√©e de chemin : `https://yourtweetreader.com/callback/../redirect?url=https://evil.com`
* Regexes de `redirect_uri` faibles : `https://yourtweetreader.com.evil.com`
* Injection HTML et vol de jetons via l'en-t√™te referer : `https://yourtweetreader.com/callback/home/attackerimg.jpg`

**D'autres param√®tres** qui peuvent √™tre vuln√©rables aux redirections ouvertes sont :

* **client_uri** - URL de la page d'accueil de l'application cliente
* **policy_uri** - URL que l'application cliente Relying Party fournit afin que l'utilisateur final puisse lire comment ses donn√©es de profil seront utilis√©es.
* **tos_uri** - URL que le client Relying Party fournit afin que l'utilisateur final puisse lire les conditions d'utilisation de la Relying Party.
* **initiate_login_uri** - URI utilisant le sch√©ma https qu'un tiers peut utiliser pour initier une connexion par le RP. Doit √©galement √™tre utilis√© pour la redirection c√¥t√© client.

Tous ces param√®tres sont **optionnels selon les sp√©cifications OAuth et OpenID** et ne sont pas toujours pris en charge sur un serveur particulier, il est donc toujours utile d'identifier quels param√®tres sont pris en charge sur votre serveur.

Si vous ciblez un serveur OpenID, le point de d√©couverte √† \*\*`.well-known/openid-configuration`\*\* contient parfois des param√®tres tels que "_registration\_endpoint_", "_request\_uri\_parameter\_supported_", et "_require\_request\_uri\_registration_". Cela peut vous aider √† trouver le point de terminaison d'enregistrement et d'autres valeurs de configuration de serveur.

### XSS dans l'impl√©mentation de redirection <a href="#bda5" id="bda5"></a>

Comme mentionn√© dans ce rapport de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html), il est possible que l'URL de redirection soit refl√©t√©e dans la r√©ponse du serveur apr√®s l'authentification de l'utilisateur, √©tant **vuln√©rable √† XSS**. Charge utile possible √† tester :
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Mauvaise gestion du param√®tre d'√©tat <a href="#bda5" id="bda5"></a>

Tr√®s souvent, le **param√®tre `state` est compl√®tement omis ou utilis√© de mani√®re incorrecte**. Si un param√®tre d'√©tat est **inexistant**, ou une valeur statique qui ne change jamais, le flux OAuth sera tr√®s probablement **vuln√©rable aux attaques CSRF**. Parfois, m√™me s'il y a un param√®tre `state`, l'**application pourrait ne pas valider le param√®tre** et une attaque r√©ussira. La fa√ßon d'exploiter cela serait de passer par le processus d'autorisation sur votre propre compte, et de faire une pause juste apr√®s l'autorisation. Vous rencontrerez alors une demande telle que:
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
```
Une fois que vous avez re√ßu cette demande, vous pouvez **abandonner la demande car ces codes sont g√©n√©ralement √† usage unique**. Vous pouvez ensuite envoyer cette URL √† un **utilisateur connect√©, et cela ajoutera votre compte √† leur compte**. Au d√©but, cela peut ne pas sembler tr√®s sensible car vous ajoutez simplement votre compte au compte d'une victime. Cependant, de nombreuses impl√©mentations OAuth sont destin√©es √† des fins de connexion, donc si vous pouvez ajouter votre compte Google qui est utilis√© pour vous connecter, vous pourriez potentiellement effectuer une **prise de contr√¥le de compte** en un seul clic, car vous connecter avec votre compte Google vous donnerait acc√®s au compte de la victime.

Vous pouvez trouver un **exemple** √† ce sujet dans ce [**write-up CTF**](https://github.com/gr455/ctf-writeups/blob/master/hacktivity20/notes\_surfer.md) et dans la **bo√Æte HTB appel√©e Oouch**.

J'ai √©galement vu le param√®tre d'√©tat utilis√© comme une valeur de redirection suppl√©mentaire plusieurs fois. L'application utilisera `redirect_uri` pour la redirection initiale, mais ensuite le param√®tre `state` comme une deuxi√®me redirection qui pourrait contenir le `code` dans les param√®tres de requ√™te, ou le header referer.

Une chose importante √† noter est que cela ne s'applique pas seulement aux situations de connexion et de prise de contr√¥le de compte. J'ai vu des erreurs de configuration dans :

* Les int√©grations Slack permettant √† un attaquant d'ajouter son compte Slack en tant que destinataire de toutes les notifications/messages
* Les int√©grations Stripe permettant √† un attaquant de remplacer les informations de paiement et d'accepter des paiements des clients de la victime
* Les int√©grations PayPal permettant √† un attaquant d'ajouter son compte PayPal au compte de la victime, ce qui d√©poserait de l'argent sur le compte PayPal de l'attaquant

### Pr√©-prise de contr√¥le de compte <a href="#ebe4" id="ebe4"></a>

L'un des autres probl√®mes les plus courants que je vois est lorsque les applications permettent de "Se connecter avec X" mais aussi un nom d'utilisateur/mot de passe. Il y a 2 fa√ßons diff√©rentes d'attaquer cela :

1. Si l'application ne **n√©cessite pas de v√©rification d'e-mail lors de la cr√©ation de compte**, essayez de **cr√©er un compte avec l'adresse e-mail de la victime et un mot de passe d'attaquant** avant que la victime ne se soit inscrite. Si la **victime** essaie ensuite de s'inscrire ou de se connecter **avec un tiers**, comme Google, il est possible que l'application fasse une recherche, voie que l'e-mail est d√©j√† enregistr√©, puis **lie leur compte Google au compte cr√©√© par l'attaquant**. C'est une "prise de contr√¥le de compte pr√©alable" o√π un attaquant aura acc√®s au compte de la victime s'il l'a cr√©√© avant que la victime ne s'inscrive.
2. Si une **application OAuth ne n√©cessite pas de v√©rification d'e-mail**, essayez de vous inscrire avec cette application OAuth avec l'adresse e-mail de la **victime**. Le m√™me probl√®me que ci-dessus pourrait exister, mais vous attaqueriez dans l'autre sens et acc√©deriez au compte de la victime pour une prise de contr√¥le de compte.

### Divulgation de secrets <a href="#e177" id="e177"></a>

Il est tr√®s important de reconna√Ætre **lesquels des nombreux param√®tres OAuth sont secrets**, et de les prot√©ger. Par exemple, divulguer le `client_id` est parfaitement acceptable et n√©cessaire, mais divulguer le **`client_secret` est dangereux**. Si cela est divulgu√©, l'**attaquant** peut potentiellement **abuser de la confiance et de l'identit√© de l'application client de confiance pour voler les `access_tokens` des utilisateurs et les informations/acc√®s priv√©s pour leurs comptes int√©gr√©s**. Revenons √† notre exemple pr√©c√©dent, un probl√®me que j'ai vu est de r√©aliser cette √©tape depuis le client, au lieu du serveur :

_5._ [_https://yourtweetreader.com_](https://yourtweetreader.com) _prendra ensuite ce `code`, et en utilisant l'`client_id` et le `client_secret` de leur application, fera une demande depuis le serveur pour r√©cup√©rer un `access_token` en votre nom, ce qui leur permettra d'acc√©der aux autorisations auxquelles vous avez consenti._

**Si cela est fait depuis le client, le `client_secret` sera divulgu√© et les utilisateurs pourront g√©n√©rer des `access_tokens` au nom de l'application**. Avec un peu d'ing√©nierie sociale, ils peuvent √©galement **ajouter plus de port√©es √† l'autorisation OAuth** et tout cela semblera l√©gitime car la demande viendra de l'application client de confiance.

### Bruteforce du secret client

Vous pouvez essayer de **bruteforcer le secret client** d'un fournisseur de services avec le fournisseur d'identit√© afin d'essayer de voler des comptes.\
La demande de BF peut ressembler √† :
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Fuite de l'en-t√™te Referer avec le code + l'√©tat

Une fois que le client a le **code et l'√©tat**, s'il est **r√©fl√©chi dans l'en-t√™te Referer** lorsqu'il navigue vers une autre page, alors il est vuln√©rable.

### Jeton d'acc√®s stock√© dans l'historique du navigateur

Acc√©dez √† l'**historique du navigateur et v√©rifiez si le jeton d'acc√®s est enregistr√©**.

### Code d'autorisation √©ternel

Le **code d'autorisation ne doit vivre que pendant un certain temps pour limiter la fen√™tre de temps pendant laquelle un attaquant peut le voler et l'utiliser**.

### Jeton d'autorisation/rafra√Æchissement non li√© au client

Si vous pouvez obtenir le **code d'autorisation et l'utiliser avec un client diff√©rent, vous pouvez prendre le contr√¥le d'autres comptes**.

### Chemins heureux, XSS, Iframes et messages postaux pour divulguer les valeurs de code et d'√©tat



### AWS Cognito <a href="#bda5" id="bda5"></a>

Dans ce rapport de prime de bug: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/), vous pouvez voir que le **jeton** que **AWS Cognito** renvoie √† l'utilisateur peut avoir **suffisamment de permissions pour √©craser les donn√©es utilisateur**. Par cons√©quent, si vous pouvez **changer l'e-mail de l'utilisateur pour un e-mail d'utilisateur diff√©rent**, vous pourriez √™tre en mesure de **prendre le contr√¥le** d'autres comptes.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
    "CodeDeliveryDetailsList": [
        {
            "Destination": "i***@f***.com",
            "DeliveryMedium": "EMAIL",
            "AttributeName": "email"
        }
    ]
}
```
Pour plus d'informations d√©taill√©es sur la fa√ßon d'abuser d'AWS Cognito, consultez :

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Param√®tres SSRF <a href="#bda5" id="bda5"></a>

L'un des URL cach√©s que vous pourriez manquer est le **point d'extr√©mit√© d'enregistrement de client dynamique**. Afin d'authentifier avec succ√®s les utilisateurs, les serveurs OAuth ont besoin de conna√Ætre les d√©tails de l'application cliente, tels que le "client_name", "client_secret", "redirect_uris", et ainsi de suite. Ces d√©tails peuvent √™tre fournis via une configuration locale, mais les serveurs d'autorisation OAuth peuvent √©galement avoir un **point d'extr√©mit√© d'enregistrement sp√©cial**. Cet endpoint est normalement mapp√© sur "/register" et accepte des requ√™tes POST avec le format suivant :
```json
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
 "application_type": "web",
 "redirect_uris": ["https://client.example.org/callback"],
 "client_name": "My Example",
 "logo_uri": "https://client.example.org/logo.png",
 "subject_type": "pairwise",
 "sector_identifier_uri": "https://example.org/rdrct_uris.json",
 "token_endpoint_auth_method": "client_secret_basic",
 "jwks_uri": "https://client.example.org/public_keys.jwks",
 "contacts": ["ve7jtb@example.org"],
 "request_uris": ["https://client.example.org/rf.txt"]
}
```
Il y a deux sp√©cifications qui d√©finissent les param√®tres de cette requ√™te: [RFC7591](https://tools.ietf.org/html/rfc7591) pour OAuth et [Openid Connect Registration 1.0](https://openid.net/specs/openid-connect-registration-1\_0.html#rfc.section.3.1).

Comme vous pouvez le voir ici, un certain nombre de ces valeurs sont transmises via des r√©f√©rences d'URL et ressemblent √† des cibles potentielles pour [Server Side Request Forgery](https://portswigger.net/web-security/ssrf). En m√™me temps, la plupart des serveurs que nous avons test√©s ne r√©solvent pas imm√©diatement ces URL lorsqu'ils re√ßoivent une demande d'enregistrement. Au lieu de cela, ils **enregistrent simplement ces param√®tres et les utilisent plus tard pendant le flux d'autorisation OAuth**. En d'autres termes, il s'agit plut√¥t d'une SSRF de deuxi√®me ordre, ce qui rend la d√©tection en bo√Æte noire plus difficile.

Les param√®tres suivants sont particuli√®rement int√©ressants pour les attaques SSRF:

* **logo\_uri** - URL qui fait r√©f√©rence √† un **logo pour l'application cliente**. **Apr√®s avoir enregistr√© un client**, vous pouvez essayer d'appeler le point de terminaison d'autorisation OAuth ("/authorize") en utilisant votre nouveau "client\_id". Apr√®s la connexion, le serveur vous demandera d'approuver la demande et **peut afficher l'image de "logo\_uri"**. Si le **serveur r√©cup√®re l'image par lui-m√™me**, la SSRF devrait √™tre d√©clench√©e √† cette √©tape. Alternativement, le serveur peut simplement inclure le logo via une **balise "\<img>" c√¥t√© client**. Bien que cela ne conduise pas √† une SSRF, cela peut conduire √† une **XSS si l'URL n'est pas √©chapp√©e**.
*   **jwks\_uri** - URL pour le document JSON Web Key Set \[JWK\] du client. Ce jeu de cl√©s est n√©cessaire sur le serveur pour valider les demandes sign√©es effectu√©es vers le point de terminaison de jeton lors de l'utilisation de JWT pour l'authentification du client \[RFC7523\]. Pour tester la SSRF dans ce param√®tre, **enregistrez une nouvelle application cliente avec un "jwks\_uri" malveillant**, effectuez le processus d'autorisation pour **obtenir un code d'autorisation pour n'importe quel utilisateur, puis r√©cup√©rez le point de terminaison "/token"** avec le corps suivant:

    `POST /oauth/token HTTP/1.1`\
    `...`\
    \`\`\
    `grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion=eyJhbGci...`

    Si vuln√©rable, le **serveur devrait effectuer une requ√™te HTTP serveur √† serveur vers le "jwks\_uri" fourni** car il a besoin de cette cl√© pour v√©rifier la validit√© du param√®tre "client\_assertion" dans votre demande. Ce sera probablement seulement une **vuln√©rabilit√© SSRF aveugle cependant**, car le serveur s'attend √† une r√©ponse JSON appropri√©e.
* **sector\_identifier\_uri** - Cette URL fait r√©f√©rence √† un fichier avec un seul **tableau JSON de valeurs redirect\_uri**. Si pris en charge, le serveur peut **r√©cup√©rer cette valeur d√®s que vous soumettez la demande d'enregistrement dynamique**. Si cela n'est pas r√©cup√©r√© imm√©diatement, essayez d'effectuer une autorisation pour ce client sur le serveur. Comme il doit conna√Ætre les redirect\_uris pour terminer le flux d'autorisation, cela forcera le serveur √† effectuer une demande √† votre sector\_identifier\_uri malveillant.
*   **request\_uris** - Un tableau des **request\_uris autoris√©es pour ce client**. Le param√®tre "request\_uri" peut √™tre pris en charge sur le point de terminaison d'autorisation pour fournir une URL qui contient un JWT avec les informations de demande (voir [https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2](https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2)).

    M√™me si l'enregistrement dynamique du client n'est pas activ√©, ou s'il n√©cessite une authentification, nous pouvons essayer de r√©aliser une SSRF sur le point de terminaison d'autorisation simplement en utilisant "request\_uri":\\

    `GET /authorize?response_type=code%20id_token&client_id=sclient1&request_uri=https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt`

    Note: ne confondez pas ce param√®tre avec "redirect\_uri". Le "redirect\_uri" est utilis√© pour la redirection apr√®s l'autorisation, tandis que **"request\_uri" est r√©cup√©r√© par le serveur au d√©but du processus d'autorisation**.

    En m√™me temps, de nombreux serveurs que nous avons vus n'autorisent pas des valeurs "request\_uri" arbitraires: ils n'autorisent que des URL figurant sur une liste blanche qui ont √©t√© pr√©-enregistr√©es lors du processus d'enregistrement du client. C'est pourquoi nous devons fournir "request\_uris": "https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt" au pr√©alable.

## Conditions de course des fournisseurs OAuth

Si la plateforme que vous testez est un fournisseur OAuth, [**lisez ceci pour tester les conditions de course possibles**](race-condition.md).

## R√©f√©rences

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©**? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks**? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF**? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
