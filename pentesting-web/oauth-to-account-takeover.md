# OAuth를 통한 계정 탈취

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 <a href="https://training.hacktricks.xyz/courses/arte"><strong>AWS 해킹을 처음부터 전문가까지 배우세요</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **HackTricks에 귀사를 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 굿즈**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [텔레그램 그룹](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 요령을 공유**하세요.

</details>

<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## 기본 정보 <a href="#d4a8" id="d4a8"></a>

OAuth는 여러 버전을 제공하며, 기본적인 통찰력은 [OAuth 2.0 문서](https://oauth.net/2/)에서 확인할 수 있습니다. 이 토론은 주로 널리 사용되는 [OAuth 2.0 인가 코드 그랜트 유형](https://oauth.net/2/grant-types/authorization-code/)에 중점을 두며, **응용 프로그램이 다른 응용 프로그램(인가 서버)의 사용자 계정에 액세스하거나 작업을 수행할 수 있는 인가 프레임워크**를 제공합니다.

가정적인 웹사이트 _**https://example.com**_은 **모든 소셜 미디어 게시물을 쇼케이스**하기 위해 OAuth 2.0을 사용합니다. _https://example.com_은 **소셜 미디어 게시물에 액세스**하도록 권한을 요청합니다. 결과적으로 _https://socialmedia.com_에서 **요청되는 권한 및 요청을 하는 개발자**를 설명하는 동의 화면이 표시됩니다. 귀하의 승인 후, _https://example.com_은 **귀하를 대신하여 귀하의 게시물에 액세스**할 수 있게 됩니다.

OAuth 2.0 프레임워크 내에서 다음 구성 요소를 이해하는 것이 중요합니다:

- **리소스 소유자**: 귀하는 **사용자/엔티티**로서 귀하의 리소스에 대한 액세스를 승인합니다(예: 소셜 미디어 계정 게시물).
- **리소스 서버**: `액세스 토큰`을 확보한 후 `리소스 소유자`를 대신하여 인증된 요청을 처리하는 **서버**, 예: **https://socialmedia.com**.
- **클라이언트 응용 프로그램**: `리소스 소유자`로부터 인가를 받는 **응용 프로그램**, 예: **https://example.com**.
- **인가 서버**: `리소스 소유자`의 성공적인 인증 및 권한 부여 후 `클라이언트 응용 프로그램`에 `액세스 토큰`을 발급하는 **서버**, 예: **https://socialmedia.com**.
- **client\_id**: 응용 프로그램을 위한 공개적이고 고유한 식별자.
- **client\_secret**: 응용 프로그램과 인가 서버만 알고 있는 비밀 키로, `액세스 토큰`을 생성하는 데 사용됩니다.
- **response\_type**: 요청되는 **토큰 유형을 지정하는 값**, 예: `code`.
- **scope**: `클라이언트 응용 프로그램`이 `리소스 소유자`로부터 요청하는 **액세스 수준**.
- **redirect\_uri**: **인가 후 사용자가 리디렉션되는 URL**입니다. 일반적으로 사전 등록된 리디렉션 URL과 일치해야 합니다.
- **state**: **사용자의 인가 서버로부터 리디렉션 및 다시 리디렉션하는 동안 데이터를 유지**하는 매개변수입니다. 그것의 고유성은 **CSRF 보호 메커니즘**으로서 중요합니다.
- **grant\_type**: **부여 유형 및 반환될 토큰 유형을 나타내는** 매개변수입니다.
- **code**: `인가 서버`에서의 인가 코드로, `클라이언트 응용 프로그램`이 `client_id` 및 `client_secret`과 함께 `액세스 토큰`을 획득하는 데 사용됩니다.
- **access\_token**: `리소스 소유자`를 대신하여 `API 요청`에 사용되는 **토큰**입니다.
- **refresh\_token**: 응용 프로그램이 **사용자에게 다시 프롬프팅하지 않고 새 `액세스 토큰`을 얻을 수 있게 하는** 토큰입니다.

### 흐름

**실제 OAuth 흐름**은 다음과 같이 진행됩니다:

1. [https://example.com](https://example.com)으로 이동하여 "소셜 미디어와 통합" 버튼을 선택합니다.
2. 해당 사이트는 귀하의 게시물에 액세스할 수 있도록 https://example.com의 응용 프로그램에 권한을 부여하도록 [https://socialmedia.com](https://socialmedia.com)에 요청을 보냅니다. 요청은 다음과 같이 구성됩니다:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. 동의 페이지가 표시됩니다.

4. 승인 후에, 소셜 미디어는 `redirect_uri`로 `code` 및 `state` 매개변수를 포함한 응답을 보냅니다:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com은 `code`를 사용하여 당신을 대신하여 `access_token`을 얻기 위해 서버 측 요청을 만듭니다. 이때 `client_id`와 `client_secret`를 함께 사용합니다. 이로써 당신이 동의한 권한에 액세스할 수 있게 됩니다:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. 마지막으로, 프로세스는 https://example.com이 `access_token`을 사용하여 API 호출을 수행하여 소셜 미디어에 액세스합니다.

## 취약점 <a href="#323a" id="323a"></a>

### Open redirect_uri <a href="#cc36" id="cc36"></a>

`redirect_uri`는 OAuth 및 OpenID 구현에서 보안에 중요한 역할을 합니다. 이는 인가 코드와 같은 민감한 데이터가 인가 후에 전송되는 위치를 지시하기 때문입니다. 잘못 구성된 경우, 공격자가 이러한 요청을 악의적인 서버로 리디렉션하여 계정 탈취를 가능케 할 수 있습니다.

악용 기술은 인가 서버의 유효성 검사 논리에 따라 다양합니다. 엄격한 경로 일치부터 지정된 도메인 또는 하위 디렉토리 내의 모든 URL을 허용하는 것까지 다양합니다. 일반적인 악용 방법으로는 오픈 리다이렉트, 경로 순회, 약한 정규식 악용 및 토큰 도난을 위한 HTML 삽입이 있습니다.

`redirect_uri` 외에도 `client_uri`, `policy_uri`, `tos_uri`, `initiate_login_uri`와 같은 다른 OAuth 및 OpenID 매개변수도 리디렉션 공격에 취약합니다. 이러한 매개변수는 선택 사항이며 지원 범위가 서버마다 다릅니다.

OpenID 서버를 대상으로 하는 경우, 발견 엔드포인트(`**.well-known/openid-configuration**`)는 종종 `registration_endpoint`, `request_uri_parameter_supported`, "`require_request_uri_registration`과 같은 가치 있는 구성 세부 정보를 나열합니다. 이러한 세부 정보는 등록 엔드포인트 및 서버의 기타 구성 세부 정보를 식별하는 데 도움이 될 수 있습니다.

### 리디렉트 구현에서의 XSS <a href="#bda5" id="bda5"></a>

이 버그 바운티 보고서 [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html)에서 언급된 바에 따르면 리디렉트 **URL이 사용자가 인증한 후 서버 응답에 반영**될 수 있으며 **XSS에 취약**할 수 있습니다. 테스트할 가능한 페이로드:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - 상태 매개변수 처리 부적절 <a href="#bda5" id="bda5"></a>

OAuth 구현에서 **`state` 매개변수**의 오용 또는 누락은 **Cross-Site Request Forgery (CSRF)** 공격 위험을 크게 증가시킬 수 있습니다. 이 취약점은 `state` 매개변수가 **사용되지 않거나 정적 값으로 사용되거나 적절하게 유효성이 검사되지 않을 때** 발생하며, 이를 통해 공격자가 CSRF 보호를 우회할 수 있습니다.

공격자는 권한 부여 프로세스를 가로채어 자신의 계정을 피해자의 계정과 연결하여 **계정 탈취**로 이어질 수 있습니다. 이는 특히 OAuth가 **인증 목적으로 사용되는 애플리케이션**에서 매우 중요합니다.

이러한 취약점의 실제 사례는 다양한 **CTF 챌린지** 및 **해킹 플랫폼**에서 문서화되어 있으며, 실제 적용 가능성을 강조합니다. 이 문제는 **Slack**, **Stripe**, **PayPal**과 같은 제3자 서비스와의 통합에도 영향을 미치며, 공격자가 알림이나 결제를 자신의 계정으로 리디렉션할 수 있습니다.

**`state` 매개변수**의 적절한 처리와 유효성 검사는 CSRF에 대비하고 OAuth 흐름을 안전하게 보호하는 데 중요합니다.

### 계정 탈취 전 <a href="#ebe4" id="ebe4"></a>

1. **계정 생성 시 이메일 확인 없음**: 공격자는 피해자의 이메일을 사용하여 미리 계정을 생성할 수 있습니다. 피해자가 나중에 로그인을 위해 제3자 서비스를 사용하는 경우, 애플리케이션이 이 제3자 계정을 실수로 공격자가 미리 생성한 계정에 연결할 수 있어 무단 액세스로 이어질 수 있습니다.

2. **느슨한 OAuth 이메일 확인 악용**: 공격자는 이메일을 확인하지 않는 OAuth 서비스를 악용하여 서비스에 등록한 후 계정 이메일을 피해자의 이메일로 변경할 수 있습니다. 이 방법은 첫 번째 시나리오와 유사하게 무단 계정 액세스의 위험을 초래하지만 다른 공격 벡터를 통해 이루어집니다.

### 비밀 노출 <a href="#e177" id="e177"></a>

비밀 OAuth 매개변수를 식별하고 보호하는 것이 중요합니다. **`client_id`**는 안전하게 공개될 수 있지만 **`client_secret`**를 공개하면 중대한 위험을 초래할 수 있습니다. `client_secret`가 노출되면 공격자가 응용 프로그램의 신원과 신뢰를 악용하여 사용자 `access_token` 및 개인 정보를 **도용**할 수 있습니다.

응용 프로그램이 권한 `code`을 `access_token`으로 교환하는 것을 서버 측이 아닌 클라이언트 측에서 잘못 처리하는 경우 일반적인 취약점이 발생합니다. 이 실수로 `client_secret`가 노출되어 공격자가 응용 프로그램의 위장으로 `access_token`을 생성할 수 있게 됩니다. 더 나아가 사회 공학을 통해 공격자는 OAuth 권한에 추가적인 범위를 추가하여 응용 프로그램의 신뢰 상태를 더 악용할 수 있습니다.

### 클라이언트 시크릿 브루트포스

서비스 제공자의 클라이언트 시크릿을 **브루트포스**하여 ID 제공자와 함께 계정을 도용하려고 시도할 수 있습니다.\
BF에 대한 요청은 다음과 유사할 수 있습니다:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer 헤더 누설 코드 + State

클라이언트가 **코드와 상태**를 가지고 있으면, 다른 페이지로 이동할 때 **Referer 헤더에 반영**되어 있다면 취약합니다.

### 브라우저 히스토리에 저장된 액세스 토큰

**브라우저 히스토리로 이동하여 액세스 토큰이 저장되어 있는지 확인**합니다.

### 영구적인 인가 코드

**인가 코드는 공격자가 그것을 도용하고 사용할 수 있는 시간 창을 제한하기 위해 일정 시간 동안만 유지**되어야 합니다.

### 클라이언트에 바인딩되지 않은 인가/새로고침 토큰

**인가 코드를 가져와 다른 클라이언트에서 사용할 수 있다면 다른 계정을 탈취**할 수 있습니다.

### Happy Paths, XSS, Iframes 및 Post Messages를 사용하여 코드 및 상태 값 누출

**[이 게시물을 확인하세요](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)**

### AWS Cognito <a href="#bda5" id="bda5"></a>

이 버그 바운티 보고서에서: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) **AWS Cognito**가 사용자에게 돌려주는 **토큰**에는 **사용자 데이터를 덮어쓸 충분한 권한**이 있을 수 있습니다. 따라서, **다른 사용자 이메일로 사용자 이메일을 변경**할 수 있다면, 다른 사람의 계정을 **탈취**할 수 있을 수도 있습니다.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
### 다른 앱 토큰 남용 <a href="#bda5" id="bda5"></a>

[**이 글에서 언급된 것**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts)과 같이, **토큰**(코드가 아닌)을 받기를 기대하는 OAuth 플로우는 토큰이 해당 앱에 속해 있는지 확인하지 않으면 취약할 수 있습니다.

이는 **공격자**가 **OAuth를 지원하는 애플리케이션을 만들고 Facebook으로 로그인**한 다음 피해자가 **공격자의 애플리케이션**에서 Facebook으로 로그인하면, **공격자가 사용자의 OAuth 토큰을 획득하여 사용자의 토큰을 사용하여 피해자 OAuth 애플리케이션에 로그인할 수 있기 때문입니다**.

{% hint style="danger" %}
따라서, 공격자가 사용자가 자신의 OAuth 애플리케이션에 액세스하도록 관리하면, 토큰이 그들의 앱 ID에 부여되었는지 확인하지 않는 애플리케이션에서 피해자 계정을 탈취할 수 있게 될 것입니다.
{% endhint %}

### 두 링크 및 쿠키 <a href="#bda5" id="bda5"></a>

[**이 글에 따르면**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), 피해자가 **공격자의 호스트를 가리키는 returnUrl**이 있는 페이지를 열도록 만들 수 있었으며, 이 정보는 쿠키(RU)에 **저장**되며 **나중 단계에서** **프롬프트**가 **사용자**에게 **해당 공격자 호스트에 액세스를 허용할지 물어볼 것**입니다.

이 프롬프트를 우회하기 위해 **Oauth 플로우를 시작하는 탭을 열어** 이 returnUrl을 설정하는 **RU 쿠키를 설정**하고, 프롬프트가 표시되기 전에 탭을 닫고 해당 값이 없는 새 탭을 열 수 있습니다. 그러면 **프롬프트는 공격자 호스트에 대해 알리지 않을 것**이지만 쿠키는 그것으로 설정되어 있기 때문에 **토큰이 리디렉션에서 공격자 호스트로 전송**될 것입니다.

### SSRF 매개변수 <a href="#bda5" id="bda5"></a>

**[이 연구를 확인하십시오](https://portswigger.net/research/hidden-oauth-attack-vectors) 이 기술의 자세한 내용을 확인하십시오.**

OAuth의 동적 클라이언트 등록은 **서버 측 요청 위조(SSRF)** 공격을 위한 중요한 벡터로 작용하는데, 이는 명시적이지 않지만 보안 취약점을 가질 수 있습니다. 이 엔드포인트는 OAuth 서버가 클라이언트 애플리케이션에 대한 세부 정보를 수신하도록 하며, 이는 악용될 수 있는 민감한 URL을 포함합니다.

**주요 포인트:**

- **동적 클라이언트 등록**은 주로 `/register`에 매핑되며, `client_name`, `client_secret`, `redirect_uris`, 로고 또는 JSON Web Key Sets (JWKs)의 URL과 같은 세부 정보를 POST 요청을 통해 수락합니다.
- 이 기능은 **RFC7591** 및 **OpenID Connect Registration 1.0**에서 제시된 사양을 준수하며, SSRF에 취약할 수 있는 매개변수를 포함합니다.
- 등록 프로세스는 여러 가지 방법으로 서버가 SSRF에 노출되도록 할 수 있습니다:
- **`logo_uri`**: 서버에서 가져올 수 있는 클라이언트 애플리케이션 로고의 URL로, SSRF를 트리거하거나 URL이 잘못 처리되면 XSS로 이어질 수 있습니다.
- **`jwks_uri`**: 악의적으로 작성된 클라이언트의 JWK 문서에 대한 URL은 서버가 악성 서버로 외부 요청을 수행하도록 할 수 있습니다.
- **`sector_identifier_uri`**: `redirect_uris`의 JSON 배열을 참조하며, 서버가 이를 가져와 SSRF 기회를 만들 수 있습니다.
- **`request_uris`**: 클라이언트에 대한 허용된 요청 URI 목록으로, 서버가 권한 부여 프로세스 시작 시 이러한 URI를 가져오면 악용될 수 있습니다.

**악용 전략:**

- `logo_uri`, `jwks_uri`, 또는 `sector_identifier_uri`와 같은 매개변수에 악의적인 URL을 포함하여 새 클라이언트를 등록함으로써 SSRF를 트리거할 수 있습니다.
- `request_uris`를 통한 직접적인 악용은 화이트리스트 제어를 통해 완화될 수 있지만, 사전 등록된 공격자가 제어하는 `request_uri`를 제공함으로써 권한 부여 단계 중에 SSRF를 용이하게 할 수 있습니다.
