# OAuth para Tomada de Conta

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informa√ß√µes B√°sicas <a href="#d4a8" id="d4a8"></a>

Existem algumas vers√µes diferentes de OAuth, voc√™ pode ler [https://oauth.net/2/](https://oauth.net/2/) para obter um entendimento b√°sico.

Neste artigo, vamos nos concentrar no fluxo mais comum que voc√™ encontrar√° hoje, que √© o [tipo de concess√£o de c√≥digo de autoriza√ß√£o OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/). Em ess√™ncia, o OAuth fornece aos desenvolvedores um **mecanismo de autoriza√ß√£o para permitir que uma aplica√ß√£o acesse dados ou execute certas a√ß√µes contra sua conta, a partir de outra aplica√ß√£o** (o servidor de autoriza√ß√£o).

Por exemplo, digamos que o site _**https://yourtweetreader.com**_ tenha funcionalidade para **exibir todos os tweets que voc√™ j√° enviou**, incluindo tweets privados. Para fazer isso, o OAuth 2.0 √© introduzido. _https://yourtweetreader.com_ pedir√° que voc√™ **autorize sua aplica√ß√£o do Twitter a acessar todos os seus Tweets**. Uma p√°gina de consentimento aparecer√° em _https://twitter.com_ exibindo quais **permiss√µes est√£o sendo solicitadas**, e quem √© o desenvolvedor que as solicita. Uma vez que voc√™ autorize a solicita√ß√£o, _https://yourtweetreader.com_ ser√° **capaz de acessar seus Tweets em seu nome**.

Elementos que s√£o importantes entender em um contexto de OAuth 2.0:

* **propriet√°rio do recurso**: O `propriet√°rio do recurso` √© o **usu√°rio/entidade** concedendo acesso ao seu recurso protegido, como seus Tweets da conta do Twitter. Neste exemplo, seria **voc√™**.
* **servidor de recursos**: O `servidor de recursos` √© o **servidor que lida com solicita√ß√µes autenticadas** ap√≥s a aplica√ß√£o ter obtido um `token de acesso` em nome do `propriet√°rio do recurso`. Neste exemplo, seria **https://twitter.com**
* **aplica√ß√£o cliente**: A `aplica√ß√£o cliente` √© a **aplica√ß√£o solicitando autoriza√ß√£o** do `propriet√°rio do recurso`. Neste exemplo, seria **https://yourtweetreader.com**.
* **servidor de autoriza√ß√£o**: O `servidor de autoriza√ß√£o` √© o **servidor que emite `tokens de acesso`** para a `aplica√ß√£o cliente` **ap√≥s autenticar com sucesso** o `propriet√°rio do recurso` e obter autoriza√ß√£o. No exemplo acima, seria **https://twitter.com**
* **client_id**: O `client_id` √© o **identificador para a aplica√ß√£o**. Este √© um identificador √∫nico, **n√£o secreto** e p√∫blico.
* **client_secret**: O `client_secret` √© um **segredo conhecido apenas pela aplica√ß√£o e pelo servidor de autoriza√ß√£o**. Isso √© usado para gerar `tokens de acesso`
* **response_type**: O `response_type` √© um valor que detalha **qual tipo de token** est√° sendo solicitado, como `code`
* **scope**: O `scope` √© o **n√≠vel de acesso solicitado** que a `aplica√ß√£o cliente` est√° pedindo do `propriet√°rio do recurso`
* **redirect_uri**: O `redirect_uri` √© a **URL para a qual o usu√°rio √© redirecionado ap√≥s a autoriza√ß√£o estar completa**. Geralmente, deve corresponder √† URL de redirecionamento que voc√™ registrou previamente com o servi√ßo
* **state**: O par√¢metro `state` pode **persistir dados entre o usu√°rio ser direcionado ao servidor de autoriza√ß√£o e voltar novamente**. √â importante que este seja um valor √∫nico, pois serve como um **mecanismo de prote√ß√£o contra CSRF** se contiver um valor √∫nico ou aleat√≥rio por solicita√ß√£o
* **grant_type**: O par√¢metro `grant_type` explica **qual √© o tipo de concess√£o**, e qual token ser√° retornado
* **code**: Este `code` √© o c√≥digo de autoriza√ß√£o recebido do `servidor de autoriza√ß√£o` que estar√° no par√¢metro de string de consulta ‚Äúcode‚Äù nesta solicita√ß√£o. Este c√≥digo √© usado em conjunto com o `client_id` e `client_secret` pela aplica√ß√£o cliente para buscar um `token de acesso`
* **access_token**: O `access_token` √© o **token que a aplica√ß√£o cliente usa para fazer solicita√ß√µes de API** em nome de um `propriet√°rio do recurso`
* **refresh_token**: O `refresh_token` permite que uma aplica√ß√£o **obtenha um novo `token de acesso` sem solicitar ao usu√°rio**

### Exemplo Real

Juntando tudo isso, aqui est√° como um **fluxo real de OAuth parece**:

1. Voc√™ visita [https://yourtweetreader.com](https://yourtweetreader.com) e clica no bot√£o ‚ÄúIntegrar com o Twitter‚Äù.
2. [https://yourtweetreader.com](https://yourtweetreader.com) envia uma solicita√ß√£o para [https://twitter.com](https://twitter.com) pedindo a voc√™, o propriet√°rio do recurso, para autorizar a aplica√ß√£o do Twitter de https://yourtweetreader.com a acessar seus Tweets. A solicita√ß√£o ser√° assim:
```
https://twitter.com/auth
?response_type=code
&client_id=yourtweetreader_clientId
&redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
&scope=readTweets
&state=kasodk9d1jd992k9klaskdh123
```
3\. Voc√™ ser√° direcionado para uma p√°gina de consentimento:

![](https://miro.medium.com/max/1215/1\*y66EY3Fn2qn-NPI9nhZC7A.png)

4\. Uma vez aceito, o Twitter enviar√° uma requisi√ß√£o de volta para o `redirect_uri` com os par√¢metros `code` e `state`:
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123
```
5\. [https://yourtweetreader.com](https://yourtweetreader.com) ent√£o usar√° esse `code`, e utilizando o `client_id` e `client_secret` da aplica√ß√£o, far√° uma solicita√ß√£o do servidor para recuperar um `access_token` em seu nome, o que permitir√° a eles acessar as permiss√µes √†s quais voc√™ consentiu:
```
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", "client_secret": "yourtweetreader_clientSecret", "code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}
```
6\. Finalmente, o fluxo est√° completo e [https://yourtweetreader.com](https://yourtweetreader.com) far√° uma chamada de API para o Twitter com seu `access_token` para acessar seus Tweets.

## Descobertas de Bug Bounty <a href="#323a" id="323a"></a>

Agora, a parte interessante! H√° muitas coisas que podem dar errado em uma implementa√ß√£o OAuth, aqui est√£o as diferentes categorias de bugs que eu vejo frequentemente:

### Configura√ß√£o fraca de redirect\_uri <a href="#cc36" id="cc36"></a>

O `redirect_uri` √© muito importante porque **dados sens√≠veis, como o `code`, s√£o anexados a esta URL** ap√≥s a autoriza√ß√£o. Se o `redirect_uri` puder ser redirecionado para um **servidor controlado pelo atacante**, isso significa que o atacante pode potencialmente **tomar controle da conta de uma v√≠tima** usando o `code` por conta pr√≥pria e ganhando acesso aos dados da v√≠tima.

A maneira como isso ser√° explorado vai variar de acordo com o servidor de autoriza√ß√£o. **Alguns** v√£o **aceitar apenas** o mesmo caminho exato de **`redirect_uri` especificado na aplica√ß√£o cliente**, mas alguns v√£o **aceitar qualquer coisa** no mesmo dom√≠nio ou subdiret√≥rio do `redirect_uri`.

Dependendo da l√≥gica tratada pelo servidor, h√° uma s√©rie de t√©cnicas para contornar um `redirect_uri`. Em uma situa√ß√£o onde um `redirect_uri` √© [https://yourtweetreader.com](https://yourtweetreader.com)/callback, estas incluem:

* Redirecionamentos abertos: [`https://yourtweetreader.com`](https://yourtweetreader.com)`/callback?redirectUrl=https://evil.com`
* Traversal de caminho: `https://yourtweetreader.com/callback/../redirect?url=https://evil.com`
* Regexes fracos de `redirect_uri`: `https://yourtweetreader.com.evil.com`
* Inje√ß√£o de HTML e roubo de tokens via cabe√ßalho referer: `https://yourtweetreader.com/callback/home/attackerimg.jpg`

**Outros par√¢metros** que podem ser vulner√°veis a Redirecionamentos Abertos s√£o:

* **client\_uri** - URL da p√°gina inicial da aplica√ß√£o cliente
* **policy\_uri** - URL que a aplica√ß√£o cliente Parte Confiante fornece para que o usu√°rio final possa ler sobre como seus dados de perfil ser√£o usados.
* **tos\_uri** - URL que a aplica√ß√£o cliente Parte Confiante fornece para que o usu√°rio final possa ler sobre os termos de servi√ßo da Parte Confiante.
* **initiate\_login\_uri** - URI usando o esquema https que um terceiro pode usar para iniciar um login pela RP. Tamb√©m deve ser usado para redirecionamento do lado do cliente.

Todos esses par√¢metros s√£o **opcionais de acordo com as especifica√ß√µes OAuth e OpenID** e nem sempre s√£o suportados em um servidor espec√≠fico, ent√£o vale sempre a pena identificar quais par√¢metros s√£o suportados no seu servidor.

Se voc√™ mirar em um servidor OpenID, o ponto de descoberta em \*\*`.well-known/openid-configuration`\*\* √†s vezes cont√©m par√¢metros como "_registration\_endpoint_", "_request\_uri\_parameter\_supported_", e "_require\_request\_uri\_registration_". Estes podem ajud√°-lo a encontrar o ponto de registro e outros valores de configura√ß√£o do servidor.

### XSS na implementa√ß√£o de redirecionamento <a href="#bda5" id="bda5"></a>

Como mencionado neste relat√≥rio de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) pode ser poss√≠vel que a URL de redirecionamento **esteja sendo refletida na resposta** do servidor ap√≥s o usu√°rio se autenticar, sendo **vulner√°vel a XSS**. Payload poss√≠vel para teste:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Tratamento inadequado do par√¢metro state <a href="#bda5" id="bda5"></a>

Muito frequentemente, o **par√¢metro `state` √© completamente omitido ou usado de maneira incorreta**. Se um par√¢metro state √© **inexistente**, **ou um valor est√°tico** que nunca muda, o fluxo OAuth provavelmente ser√° **vulner√°vel a CSRF**. √Äs vezes, mesmo que exista um par√¢metro `state`, a **aplica√ß√£o pode n√£o fazer nenhuma valida√ß√£o do par√¢metro** e um ataque funcionar√°. A maneira de explorar isso seria passar pelo processo de autoriza√ß√£o na sua pr√≥pria conta e pausar logo ap√≥s autorizar. Voc√™ ent√£o se deparar√° com uma solicita√ß√£o como:
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
```
Ap√≥s receber essa solicita√ß√£o, voc√™ pode **descartar a solicita√ß√£o, pois esses c√≥digos s√£o tipicamente de uso √∫nico**. Em seguida, voc√™ pode enviar esta URL para um **usu√°rio logado, e ela adicionar√° sua conta √† conta dele**. A princ√≠pio, isso pode n√£o parecer muito sens√≠vel, j√° que voc√™ est√° simplesmente adicionando sua conta √† conta de uma v√≠tima. No entanto, muitas implementa√ß√µes de OAuth s√£o para fins de login, ent√£o, se voc√™ puder adicionar sua conta do Google, que √© usada para fazer login, voc√™ poderia potencialmente realizar um **Account Takeover** com um √∫nico clique, pois fazer login com sua conta do Google daria acesso √† conta da v√≠tima.

Voc√™ pode encontrar um **exemplo** sobre isso neste [**CTF writeup**](https://github.com/gr455/ctf-writeups/blob/master/hacktivity20/notes\_surfer.md) e na **HTB box chamada Oouch**.

Tamb√©m vi o par√¢metro state sendo usado como um valor de redirecionamento adicional v√°rias vezes. O aplicativo usar√° `redirect_uri` para o redirecionamento inicial, mas depois o par√¢metro `state` como um segundo redirecionamento que poderia conter o `code` dentro dos par√¢metros da query, ou no cabe√ßalho referer.

Uma coisa importante a notar √© que isso n√£o se aplica apenas a situa√ß√µes de login e account takeover. Vi configura√ß√µes incorretas em:

* Integra√ß√µes do Slack permitindo que um atacante adicione sua conta do Slack como destinat√°rio de todas as notifica√ß√µes/mensagens
* Integra√ß√µes do Stripe permitindo que um atacante substitua informa√ß√µes de pagamento e aceite pagamentos dos clientes da v√≠tima
* Integra√ß√µes do PayPal permitindo que um atacante adicione sua conta do PayPal √† conta da v√≠tima, o que depositaria dinheiro na conta do PayPal do atacante

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

Um dos outros problemas mais comuns que vejo √© quando aplicativos permitem "Sign in with X", mas tamb√©m username/password. Existem 2 maneiras diferentes de atacar isso:

1. Se o aplicativo **n√£o exigir verifica√ß√£o de e-mail na cria√ß√£o da conta**, tente **criar uma conta com o e-mail de uma v√≠tima e senha do atacante** antes de a v√≠tima se registrar. Se a **v√≠tima** ent√£o tentar se registrar ou fazer login **com um terceiro**, como o Google, √© poss√≠vel que o aplicativo fa√ßa uma busca, veja que o e-mail j√° est√° registrado e ent√£o **vincule sua conta do Google √† conta criada pelo atacante**. Isso √© um "**pre account takeover**" onde um atacante ter√° acesso √† conta da v√≠tima se a criou antes do registro da v√≠tima.
2. Se um **aplicativo OAuth n√£o exigir verifica√ß√£o de e-mail**, tente se inscrever com esse aplicativo OAuth e depois mude o endere√ßo de e-mail para o **e-mail de uma v√≠tima**. O mesmo problema acima poderia existir, mas voc√™ estaria atacando de outra dire√ß√£o e obtendo acesso √† conta da v√≠tima para um account takeover.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

√â muito importante reconhecer **quais dos muitos par√¢metros OAuth s√£o secretos** e proteg√™-los. Por exemplo, vazar o `client_id` √© perfeitamente aceit√°vel e necess√°rio, mas vazar o **`client_secret` √© perigoso**. Se isso for vazado, o **atacante** pode potencialmente **abusar da confian√ßa e identidade do aplicativo cliente confi√°vel para roubar `access_tokens` do usu√°rio e informa√ß√µes/acesso privado para suas contas integradas**. Voltando ao nosso exemplo anterior, um problema que vi √© realizar esta etapa do cliente, em vez do servidor:

_5._ [_https://yourtweetreader.com_](https://yourtweetreader.com) _ent√£o pegar√° esse `code`, e usando o `client_id` e `client_secret` do aplicativo, far√° uma solicita√ß√£o do servidor para recuperar um `access_token` em seu nome, o que permitir√° a eles acessar as permiss√µes √†s quais voc√™ consentiu._

**Se isso for feito do cliente, o `client_secret` ser√° vazado e os usu√°rios poder√£o gerar `access_tokens` em nome do aplicativo**. Com um pouco de engenharia social, eles tamb√©m podem **adicionar mais escopos √† autoriza√ß√£o OAuth** e tudo parecer√° leg√≠timo, pois a solicita√ß√£o vir√° do aplicativo cliente confi√°vel.

### Client Secret Bruteforce

Voc√™ pode tentar **bruteforce o `client_secret`** de um provedor de servi√ßo com o provedor de identidade para tentar roubar contas.\
A solicita√ß√£o para BF pode parecer semelhante a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Cabe√ßalho Referer vazando C√≥digo + Estado

Uma vez que o cliente tem o **c√≥digo e estado**, se estes s√£o **refletidos dentro do cabe√ßalho Referer** quando ele navega para uma p√°gina diferente, ent√£o est√° vulner√°vel.

### Token de Acesso Armazenado no Hist√≥rico do Navegador

V√° para o **hist√≥rico do navegador e verifique se o token de acesso est√° salvo l√°**.

### C√≥digo de Autoriza√ß√£o Permanente

O **c√≥digo de autoriza√ß√£o deve viver apenas por algum tempo para limitar a janela de tempo onde um atacante pode roubar e us√°-lo**.

### Token de Autoriza√ß√£o/Atualiza√ß√£o n√£o vinculado ao cliente

Se voc√™ pode obter o **c√≥digo de autoriza√ß√£o e us√°-lo com um cliente diferente, ent√£o voc√™ pode assumir o controle de outras contas**.

### Caminhos Felizes, XSS, Iframes & Post Messages para vazar valores de c√≥digo & estado

### AWS Cognito <a href="#bda5" id="bda5"></a>

Neste relat√≥rio de bug bounty: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) voc√™ pode ver que o **token** que o **AWS Cognito** devolve ao usu√°rio pode ter **permiss√µes suficientes para sobrescrever os dados do usu√°rio**. Portanto, se voc√™ pode **mudar o email do usu√°rio por um email de outro usu√°rio**, voc√™ pode ser capaz de **assumir o controle** de outras contas.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para mais informa√ß√µes detalhadas sobre como abusar do AWS cognito, confira:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abusando de tokens de outros Apps <a href="#bda5" id="bda5"></a>

Como [**mencionado neste relat√≥rio**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), fluxos OAuth que esperam receber o **token** (e n√£o um c√≥digo) podem ser vulner√°veis se n√£o verificarem que o token pertence ao app.

Isso ocorre porque um **atacante** poderia criar uma **aplica√ß√£o suportando OAuth e fazer login com o Facebook** (por exemplo) em sua pr√≥pria aplica√ß√£o. Ent√£o, uma vez que uma v√≠tima fa√ßa login com o Facebook na **aplica√ß√£o do atacante**, o atacante poderia obter o **token OAuth do usu√°rio dado √† sua aplica√ß√£o e us√°-lo para fazer login na aplica√ß√£o OAuth da v√≠tima usando o token do usu√°rio da v√≠tima**.

{% hint style="danger" %}
Portanto, se o atacante conseguir fazer com que o usu√°rio acesse sua pr√≥pria aplica√ß√£o OAuth, ele poder√° assumir o controle da conta da v√≠tima em aplica√ß√µes que est√£o esperando um token e n√£o est√£o verificando se o token foi concedido ao ID de seu app.
{% endhint %}

### Dois links & cookie <a href="#bda5" id="bda5"></a>

De acordo com [**este relat√≥rio**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era poss√≠vel fazer com que uma v√≠tima abrisse uma p√°gina com um **returnUrl** apontando para o host do atacante. Essa informa√ß√£o seria **armazenada em um cookie (RU)** e em uma **etapa posterior** o **prompt** ir√° **perguntar** ao **usu√°rio** se ele quer dar acesso ao host do atacante.

Para contornar este prompt, era poss√≠vel abrir uma aba para iniciar o **fluxo Oauth** que configuraria este cookie RU usando o **returnUrl**, fechar a aba antes que o prompt fosse exibido e abrir uma nova aba sem esse valor. Ent√£o, o **prompt n√£o informar√° sobre o host do atacante**, mas o cookie estaria configurado para ele, ent√£o o **token seria enviado para o host do atacante** no redirecionamento.

### Par√¢metros SSRFs <a href="#bda5" id="bda5"></a>

Uma das URLs ocultas que voc√™ pode perder √© o **ponto de registro de cliente din√¢mico**. Para autenticar usu√°rios com sucesso, os servidores OAuth precisam conhecer detalhes sobre a aplica√ß√£o cliente, como "client\_name", "client\_secret", "redirect\_uris", entre outros. Esses detalhes podem ser fornecidos via configura√ß√£o local, mas os servidores de autoriza√ß√£o OAuth tamb√©m podem ter um **ponto de registro especial**. Este ponto normalmente √© mapeado para "/register" e aceita solicita√ß√µes POST com o seguinte formato:
```json
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
"application_type": "web",
"redirect_uris": ["https://client.example.org/callback"],
"client_name": "My Example",
"logo_uri": "https://client.example.org/logo.png",
"subject_type": "pairwise",
"sector_identifier_uri": "https://example.org/rdrct_uris.json",
"token_endpoint_auth_method": "client_secret_basic",
"jwks_uri": "https://client.example.org/public_keys.jwks",
"contacts": ["ve7jtb@example.org"],
"request_uris": ["https://client.example.org/rf.txt"]
}
```
Existem duas especifica√ß√µes que definem par√¢metros nesta solicita√ß√£o: [RFC7591](https://tools.ietf.org/html/rfc7591) para OAuth e [Openid Connect Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html#rfc.section.3.1).

Como voc√™ pode ver aqui, v√°rios desses valores s√£o passados por refer√™ncias de URL e parecem alvos potenciais para [Server Side Request Forgery](https://portswigger.net/web-security/ssrf). Ao mesmo tempo, a maioria dos servidores que testamos n√£o resolve essas URLs imediatamente ao receberem uma solicita√ß√£o de registro. Em vez disso, eles apenas **salvam esses par√¢metros e os usam mais tarde durante o fluxo de autoriza√ß√£o OAuth**. Em outras palavras, isso √© mais como um SSRF de segunda ordem, o que torna a detec√ß√£o de caixa-preta mais dif√≠cil.

Os seguintes par√¢metros s√£o particularmente interessantes para ataques SSRF:

* **logo\_uri** - URL que referencia um **logotipo para o aplicativo cliente**. **Ap√≥s registrar um cliente**, voc√™ pode tentar chamar o ponto de extremidade de autoriza√ß√£o OAuth ("/authorize") usando seu novo "client\_id". Ap√≥s o login, o servidor pedir√° para voc√™ aprovar a solicita√ß√£o e **pode exibir a imagem do "logo\_uri"**. Se o **servidor buscar a imagem por si mesmo**, o SSRF deve ser acionado por esta etapa. Alternativamente, o servidor pode apenas incluir o logotipo por meio de uma **tag "\<img>" do lado do cliente**. Embora isso n√£o leve a SSRF, pode levar a **XSS se a URL n√£o for escapada**.
*   **jwks\_uri** - URL para o documento do conjunto de chaves da Web JSON \[JWK] do cliente. Este conjunto de chaves √© necess√°rio no servidor para validar solicita√ß√µes assinadas feitas ao ponto de extremidade do token ao usar JWTs para autentica√ß√£o do cliente \[RFC7523]. Para testar SSRF neste par√¢metro, **registre um novo aplicativo cliente com um "jwks\_uri" malicioso**, realize o processo de autoriza√ß√£o para **obter um c√≥digo de autoriza√ß√£o para qualquer usu√°rio e, em seguida, busque o ponto de extremidade "/token"** com o seguinte corpo:

`POST /oauth/token HTTP/1.1`\
`...`\
\`\`\
`grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion=eyJhbGci...`

Se vulner√°vel, o **servidor deve realizar uma solicita√ß√£o HTTP de servidor para servidor para o "jwks\_uri" fornecido** porque precisa dessa chave para verificar a validade do par√¢metro "client\_assertion" em sua solicita√ß√£o. Isso provavelmente ser√° apenas uma **vulnerabilidade SSRF cega**, j√° que o servidor espera uma resposta JSON adequada.
* **sector\_identifier\_uri** - Esta URL referencia um arquivo com um √∫nico **array JSON de valores redirect\_uri**. Se suportado, o servidor pode **buscar esse valor assim que voc√™ enviar a solicita√ß√£o de registro din√¢mico**. Se isso n√£o for buscado imediatamente, tente realizar a autoriza√ß√£o para este cliente no servidor. Como ele precisa saber os redirect\_uris para completar o fluxo de autoriza√ß√£o, isso for√ßar√° o servidor a fazer uma solicita√ß√£o ao seu sector\_identifier\_uri malicioso.
*   **request\_uris** - Um array dos **request\_uris permitidos para este cliente**. O par√¢metro "request\_uri" pode ser suportado no ponto de extremidade de autoriza√ß√£o para fornecer uma URL que cont√©m um JWT com as informa√ß√µes da solicita√ß√£o (veja [https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2)).

Mesmo que o registro de cliente din√¢mico n√£o esteja habilitado, ou exija autentica√ß√£o, podemos tentar realizar SSRF no ponto de extremidade de autoriza√ß√£o simplesmente usando "request\_uri":\\

`GET /authorize?response_type=code%20id_token&client_id=sclient1&request_uri=https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt`

Nota: n√£o confunda este par√¢metro com "redirect\_uri". O "redirect\_uri" √© usado para redirecionamento ap√≥s autoriza√ß√£o, enquanto **"request\_uri" √© buscado pelo servidor no in√≠cio do processo de autoriza√ß√£o**.

Ao mesmo tempo, muitos servidores que vimos n√£o permitem valores arbitr√°rios de "request\_uri": eles apenas permitem URLs na lista de permiss√µes que foram pr√©-registrados durante o processo de registro do cliente. √â por isso que precisamos fornecer "request\_uris": "https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt" antecipadamente.

## Condi√ß√µes de Corrida em Provedores OAuth

Se a plataforma que voc√™ est√° testando √© um provedor OAuth [**leia isto para testar poss√≠veis Condi√ß√µes de Corrida**](race-condition.md).

## Refer√™ncias

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**merchandising oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>
