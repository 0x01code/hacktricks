# OAuth na Rekening Oorname

<details>

<summary><strong>Leer AWS hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks geadverteer wil sien** of **HackTricks in PDF wil aflaai** Kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou hacking truuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Basiese Inligting <a href="#d4a8" id="d4a8"></a>

OAuth bied verskeie weergawes, met fundamentele insigte beskikbaar by [OAuth 2.0 dokumentasie](https://oauth.net/2/). Hierdie bespreking fokus hoofsaaklik op die wyd gebruikte [OAuth 2.0 autorisasie kode toekenning tipe](https://oauth.net/2/grant-types/authorization-code/), wat 'n **autorisasie raamwerk bied wat 'n toepassing in staat stel om toegang te verkry tot of aksies uit te voer op 'n gebruiker se rekening in 'n ander toepassing** (die autorisasie bediener).

Oorweeg 'n hipotetiese webwerf _**https://example.com**_, ontwerp om **al jou sosiale media plasings te vertoon**, insluitend privaates. Om dit te bereik, word OAuth 2.0 gebruik. _https://example.com_ sal jou toestemming vra om **toegang tot jou sosiale media plasings te verkry**. Gevolglik sal 'n toestemmingskerm verskyn op _https://socialmedia.com_, wat die **toestemmings wat gevra word en die ontwikkelaar wat die versoek maak** uiteensit. Na jou autorisasie, kry _https://example.com_ die vermo√´ om **toegang tot jou plasings namens jou te verkry**.

Dit is noodsaaklik om die volgende komponente binne die OAuth 2.0 raamwerk te verstaan:

* **resource owner**: Jy, as die **gebruiker/entiteit**, gee toestemming vir toegang tot jou hulpbron, soos jou sosiale media rekening plasings.
* **resource server**: Die **bediener wat geverifieerde versoeke hanteer** nadat die toepassing 'n `access token` namens die `resource owner` verkry het, bv. **https://socialmedia.com**.
* **client application**: Die **toepassing wat autorisasie soek** van die `resource owner`, soos **https://example.com**.
* **authorization server**: Die **bediener wat `access tokens` uitreik** aan die `client application` na suksesvolle verifikasie van die `resource owner` en verkryging van autorisasie, bv. **https://socialmedia.com**.
* **client\_id**: 'n Publieke, unieke identifiseerder vir die toepassing.
* **client\_secret:** 'n Vertroulike sleutel, slegs bekend aan die toepassing en die autorisasie bediener, gebruik vir die generering van `access_tokens`.
* **response\_type**: 'n Waarde wat **die tipe token wat versoek word** spesifiseer, soos `code`.
* **scope**: Die **vlak van toegang** wat die `client application` van die `resource owner` versoek.
* **redirect\_uri**: Die **URL waarna die gebruiker herlei word na autorisasie**. Dit moet tipies ooreenstem met die vooraf-geregistreerde herleidings URL.
* **state**: 'n Parameter om **data te behou oor die gebruiker se herleiding na en van die autorisasie bediener**. Die uniekheid daarvan is krities om te dien as 'n **CSRF beskermingsmeganisme**.
* **grant\_type**: 'n Parameter wat **die toekenning tipe en die tipe token wat teruggestuur moet word** aandui.
* **code**: Die autorisasie kode van die `authorization server`, gebruik saam met `client_id` en `client_secret` deur die client application om 'n `access_token` te verkry.
* **access\_token**: Die **token wat die client application gebruik vir API versoeke** namens die `resource owner`.
* **refresh\_token**: Stel die toepassing in staat om **'n nuwe `access_token` te verkry sonder om die gebruiker weer te vra**.

### Vloei

Die **werklike OAuth vloei** verloop soos volg:

1. Jy navigeer na [https://example.com](https://example.com) en kies die ‚ÄúIntegreer met Sosiale Media‚Äù knoppie.
2. Die webwerf stuur dan 'n versoek na [https://socialmedia.com](https://socialmedia.com) wat jou toestemming vra om https://example.com se toepassing toegang tot jou plasings te gee. Die versoek is gestruktureer as:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Jy word dan met 'n toestemmingsbladsy voorgestel.
4. Na jou goedkeuring stuur Social Media 'n reaksie na die `redirect_uri` met die `code` en `state` parameters:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com gebruik hierdie `code`, saam met sy `client_id` en `client_secret`, om 'n bediener-kant versoek te maak om 'n `access_token` namens jou te verkry, wat toegang tot die toestemmings wat jy goedgekeur het, moontlik maak:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Uiteindelik, die proses eindig wanneer https://example.com jou `access_token` gebruik om 'n API-oproep na Social Media te maak om toegang te verkry

## Kwesbaarhede <a href="#id-323a" id="id-323a"></a>

### Oop redirect\_uri <a href="#cc36" id="cc36"></a>

Die `redirect_uri` is deurslaggewend vir sekuriteit in OAuth en OpenID implementasies, aangesien dit aandui waar sensitiewe data, soos magtigingskodes, gestuur word na magtiging. As dit verkeerd gekonfigureer is, kan dit aanvallers toelaat om hierdie versoeke na kwaadwillige bedieners te herlei, wat rekeningoorname moontlik maak.

Eksploitasietegnieke wissel gebaseer op die magtigingsbediener se valideringslogika. Dit kan wissel van streng padpassing tot die aanvaarding van enige URL binne die gespesifiseerde domein of subgids. Algemene eksploitasie metodes sluit in oop herleidings, padtraversering, die uitbuiting van swak regexes, en HTML-inspuiting vir token diefstal.

Behalwe `redirect_uri`, is ander OAuth en OpenID parameters soos `client_uri`, `policy_uri`, `tos_uri`, en `initiate_login_uri` ook vatbaar vir herleidingsaanvalle. Hierdie parameters is opsioneel en hul ondersteuning wissel oor bedieners.

Vir diegene wat 'n OpenID-bediener teiken, lys die ontdekking eindpunt (`**.well-known/openid-configuration**`) dikwels waardevolle konfigurasie besonderhede soos `registration_endpoint`, `request_uri_parameter_supported`, en "`require_request_uri_registration`. Hierdie besonderhede kan help om die registrasie eindpunt en ander konfigurasie spesifikasies van die bediener te identifiseer.

### XSS in herleiding implementering <a href="#bda5" id="bda5"></a>

Soos genoem in hierdie bug bounty verslag [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) mag dit moontlik wees dat die herleiding **URL in die reaksie** van die bediener gereflekteer word nadat die gebruiker geverifieer het, wat **vatbaar is vir XSS**. Moontlike las om te toets:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Onbehoorlike hantering van die state parameter <a href="#bda5" id="bda5"></a>

In OAuth-implementasies kan die misbruik of weglating van die **`state` parameter** die risiko van **Cross-Site Request Forgery (CSRF)** aanvalle aansienlik verhoog. Hierdie kwesbaarheid ontstaan wanneer die `state` parameter √≥f **nie gebruik word nie, as 'n statiese waarde gebruik word, of nie behoorlik gevalideer word nie**, wat aanvallers toelaat om CSRF-beskermings te omseil.

Aanvallers kan dit uitbuit deur die magtigingsproses te onderskep om hul rekening met 'n slagoffer se rekening te koppel, wat kan lei tot potensi√´le **rekeningoorname**. Dit is veral krities in toepassings waar OAuth vir **verifikasiedoeleindes** gebruik word.

Werklike voorbeelde van hierdie kwesbaarheid is gedokumenteer in verskeie **CTF-uitdagings** en **hacking platforms**, wat die praktiese implikasies daarvan beklemtoon. Die probleem strek ook tot integrasies met derdeparty-dienste soos **Slack**, **Stripe**, en **PayPal**, waar aanvallers kennisgewings of betalings na hul rekeninge kan herlei.

Behoorlike hantering en validering van die **`state` parameter** is noodsaaklik vir die beveiliging teen CSRF en die beveiliging van die OAuth-vloei.

### Voor Rekeningoorname <a href="#ebe4" id="ebe4"></a>

1. **Sonder E-posverifikasie by Rekening Skepping**: Aanvallers kan vooraf 'n rekening skep met die slagoffer se e-pos. As die slagoffer later 'n derdeparty-diens vir aanmelding gebruik, kan die toepassing per ongeluk hierdie derdeparty-rekening aan die aanvaller se vooraf-geskepte rekening koppel, wat lei tot ongemagtigde toegang.
2. **Uitbuiting van Lakse OAuth E-posverifikasie**: Aanvallers kan OAuth-dienste wat nie e-posse verifieer nie uitbuit deur met hul diens te registreer en dan die rekening-e-pos na die slagoffer s'n te verander. Hierdie metode hou soortgelyke risiko's vir ongemagtigde rekeningtoegang in, soortgelyk aan die eerste scenario, maar deur 'n ander aanvalsvector.

### Blootstelling van Geheime <a href="#e177" id="e177"></a>

Die identifisering en beskerming van geheime OAuth-parameters is van kardinale belang. Terwyl die **`client_id`** veilig bekend gemaak kan word, hou die onthulling van die **`client_secret`** beduidende risiko's in. As die `client_secret` gekompromitteer word, kan aanvallers die identiteit en vertroue van die toepassing uitbuit om **gebruiker `access_tokens`** en privaat inligting te steel.

'n Algemene kwesbaarheid ontstaan wanneer toepassings per ongeluk die uitruiling van die magtigings `code` vir 'n `access_token` aan die kli√´ntkant hanteer eerder as die bedienerkant. Hierdie fout lei tot die blootstelling van die `client_secret`, wat aanvallers in staat stel om `access_tokens` te genereer onder die dekmantel van die toepassing. Verder, deur sosiale ingenieurswese, kan aanvallers voorregte verhoog deur bykomende scopes by die OAuth-magtiging te voeg, wat die toepassing se vertroude status verder uitbuit.

### Kli√´nt Geheime Bruteforce

Jy kan probeer om die **client\_secret** van 'n diensverskaffer met die identiteitsverskaffer te **bruteforce** om te probeer om rekeninge te steel.\
Die versoek om BF mag lyk soos:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer Header wat Kode + Staat lek

Sodra die kli√´nt die **kode en staat** het, as dit **gereflekteer word binne die Referer header** wanneer hy na 'n ander bladsy blaai, dan is dit kwesbaar.

### Toegangsteken Gestoor in Blaaier Geskiedenis

Gaan na die **blaaier geskiedenis en kyk of die toegangsteken daar gestoor is**.

### Ewigdurende Magtigingskode

Die **magtigingskode moet net vir 'n tyd leef om die tydvenster te beperk waarin 'n aanvaller dit kan steel en gebruik**.

### Magtigings-/Herverfris Teken nie aan kli√´nt gebind nie

As jy die **magtigingskode kan kry en dit met 'n ander kli√´nt kan gebruik, dan kan jy ander rekeninge oorneem**.

### Gelukkige Paaie, XSS, Iframes & Post Boodskappe om kode & staat waardes te lek

[**Kyk na hierdie pos**](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)

### AWS Cognito <a href="#bda5" id="bda5"></a>

In hierdie foutjagverslag: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) kan jy sien dat die **token** wat **AWS Cognito** aan die gebruiker teruggee, dalk **genoeg regte het om die gebruikersdata oor te skryf**. Daarom, as jy die **gebruiker se e-pos na 'n ander gebruiker se e-pos kan verander**, kan jy dalk **ander rekeninge oorneem**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Vir meer gedetailleerde inligting oor hoe om AWS cognito te misbruik, kyk:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Misbruik van ander Apps tokens <a href="#bda5" id="bda5"></a>

Soos [**genoem in hierdie skrywe**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), kan OAuth vloei wat verwag om die **token** (en nie 'n kode nie) te ontvang, kwesbaar wees as hulle nie nagaan dat die token aan die app behoort nie.

Dit is omdat 'n **aanvaller** 'n **toepassing wat OAuth ondersteun en met Facebook aanmeld** (byvoorbeeld) in sy eie toepassing kan skep. Dan, sodra 'n slagoffer met Facebook in die **aanvaller se toepassing** aanmeld, kan die aanvaller die **OAuth token van die gebruiker wat aan sy toepassing gegee is, kry en dit gebruik om in die slagoffer se OAuth toepassing aan te meld met die slagoffer se gebruiker token**.

{% hint style="danger" %}
Daarom, as die aanvaller daarin slaag om die gebruiker toegang te gee tot sy eie OAuth toepassing, sal hy die slagoffer se rekening kan oorneem in toepassings wat 'n token verwag en nie nagaan of die token aan hul app ID gegee is nie.
{% endhint %}

### Twee skakels & koekie <a href="#bda5" id="bda5"></a>

Volgens [**hierdie skrywe**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), was dit moontlik om 'n slagoffer 'n bladsy te laat oopmaak met 'n **returnUrl** wat na die aanvaller se gasheer wys. Hierdie inligting sou **in 'n koekie (RU) gestoor word** en in 'n **later stap** sal die **prompt** die **gebruiker vra** of hy toegang wil gee tot daardie aanvaller se gasheer.

Om hierdie prompt te omseil, was dit moontlik om 'n oortjie oop te maak om die **Oauth vloei** te begin wat hierdie RU koekie sou stel deur die **returnUrl** te gebruik, die oortjie toe te maak voordat die prompt gewys word, en 'n nuwe oortjie oop te maak sonder daardie waarde. Dan sal die **prompt nie oor die aanvaller se gasheer inlig nie**, maar die koekie sal daarop gestel wees, sodat die **token na die aanvaller se gasheer gestuur sal word** in die herleiding.

### Prompt Interaksie Omseiling <a href="#bda5" id="bda5"></a>

Soos verduidelik in [**hierdie video**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), laat sommige OAuth implementasies toe om die **`prompt`** GET parameter as None (**`&prompt=none`**) aan te dui om **te verhoed dat gebruikers gevra word om die gegewe toegang te bevestig** in 'n prompt op die web as hulle reeds op die platform aangemeld is.

### response\_mode

Soos [**in hierdie video verduidelik**](https://www.youtube.com/watch?v=n9x7\_J\_a\_7Q), kan dit moontlik wees om die parameter **`response_mode`** aan te dui om aan te dui waar jy die kode in die finale URL wil h√™:

* `response_mode=query` -> Die kode word binne 'n GET parameter verskaf: `?code=2397rf3gu93f`
* `response_mode=fragment` -> Die kode word binne die URL fragment parameter verskaf `#code=2397rf3gu93f`
* `response_mode=form_post` -> Die kode word binne 'n POST vorm met 'n invoer genaamd `code` en die waarde verskaf
* `response_mode=web_message` -> Die kode word in 'n post boodskap gestuur: `window.opener.postMessage({"code": "asdasdasd...`

### SSRFs parameters <a href="#bda5" id="bda5"></a>

[**Kyk na hierdie navorsing**](https://portswigger.net/research/hidden-oauth-attack-vectors) **vir verdere besonderhede van hierdie tegniek.**

Dinamiese Kli√´nt Registrasie in OAuth dien as 'n minder voor die hand liggende maar kritieke vektor vir sekuriteitskwesbaarhede, spesifiek vir **Server-Side Request Forgery (SSRF)** aanvalle. Hierdie eindpunt laat OAuth bedieners toe om besonderhede oor kli√´nt toepassings te ontvang, insluitend sensitiewe URL's wat uitgebuit kan word.

**Sleutel Punte:**

* **Dinamiese Kli√´nt Registrasie** word dikwels na `/register` gemap en aanvaar besonderhede soos `client_name`, `client_secret`, `redirect_uris`, en URL's vir logo's of JSON Web Key Sets (JWKs) via POST versoeke.
* Hierdie funksie voldoen aan spesifikasies uiteengesit in **RFC7591** en **OpenID Connect Registration 1.0**, wat parameters insluit wat potensieel kwesbaar is vir SSRF.
* Die registrasieproses kan per ongeluk bedieners blootstel aan SSRF op verskeie maniere:
* **`logo_uri`**: 'n URL vir die kli√´nt toepassing se logo wat deur die bediener opgevra kan word, wat SSRF kan veroorsaak of tot XSS kan lei as die URL verkeerd hanteer word.
* **`jwks_uri`**: 'n URL na die kli√´nt se JWK dokument, wat as dit kwaadwillig opgestel is, die bediener kan veroorsaak om uitgaande versoeke na 'n aanvaller-beheerde bediener te maak.
* **`sector_identifier_uri`**: Verwys na 'n JSON skikking van `redirect_uris`, wat die bediener kan opvra, wat 'n SSRF geleentheid skep.
* **`request_uris`**: Lys toegelate versoek URL's vir die kli√´nt, wat uitgebuit kan word as die bediener hierdie URL's aan die begin van die magtigingsproses opvra.

**Eksploitasie Strategie:**

* SSRF kan veroorsaak word deur 'n nuwe kli√´nt te registreer met kwaadwillige URL's in parameters soos `logo_uri`, `jwks_uri`, of `sector_identifier_uri`.
* Terwyl direkte eksploitasie via `request_uris` moontlik deur witlysbeheermaatre√´ls beperk kan word, kan die verskaffing van 'n vooraf-geregistreerde, aanvaller-beheerde `request_uri` SSRF fasiliteer tydens die magtigingsfase.

## OAuth verskaffers Wedlooptoestande

As die platform wat jy toets 'n OAuth verskaffer is, [**lees dit om moontlike Wedlooptoestande te toets**](race-condition.md).

## Verwysings

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Leer AWS hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks geadverteer wil sien** of **HackTricks in PDF wil aflaai** Kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou hacking truuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
