# OAuth a Toma de control de cuenta

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Informaci√≥n B√°sica <a href="#d4a8" id="d4a8"></a>

Existen varias versiones de OAuth, puedes leer [https://oauth.net/2/](https://oauth.net/2/) para obtener una comprensi√≥n b√°sica.

En este art√≠culo, nos centraremos en el flujo m√°s com√∫n que encontrar√°s hoy en d√≠a, que es el [tipo de concesi√≥n de c√≥digo de autorizaci√≥n OAuth 2.0](https://oauth.net/2/grant-types/authorization-code/). En esencia, OAuth proporciona a los desarrolladores un **mecanismo de autorizaci√≥n para permitir que una aplicaci√≥n acceda a datos o realice ciertas acciones contra tu cuenta, desde otra aplicaci√≥n** (el servidor de autorizaci√≥n).

Por ejemplo, digamos que el sitio web _**https://yourtweetreader.com**_ tiene funcionalidad para **mostrar todos los tweets que has enviado**, incluyendo tweets privados. Para hacer esto, se introduce OAuth 2.0. _https://yourtweetreader.com_ te pedir√° que **autorices su aplicaci√≥n de Twitter para acceder a todos tus Tweets**. Aparecer√° una p√°gina de consentimiento en _https://twitter.com_ mostrando qu√© **permisos se est√°n solicitando**, y qui√©n es el desarrollador que lo solicita. Una vez que autorices la solicitud, _https://yourtweetreader.com_ ser√° **capaz de acceder a tus Tweets en tu nombre**.

Elementos que son importantes entender en un contexto de OAuth 2.0:

* **propietario del recurso**: El `propietario del recurso` es el **usuario/entidad** que otorga acceso a su recurso protegido, como sus Tweets de la cuenta de Twitter. En este ejemplo, ser√≠as **t√∫**.
* **servidor de recursos**: El `servidor de recursos` es el **servidor que maneja las solicitudes autenticadas** despu√©s de que la aplicaci√≥n ha obtenido un `token de acceso` en nombre del `propietario del recurso`. En este ejemplo, ser√≠a **https://twitter.com**
* **aplicaci√≥n cliente**: La `aplicaci√≥n cliente` es la **aplicaci√≥n que solicita autorizaci√≥n** del `propietario del recurso`. En este ejemplo, ser√≠a **https://yourtweetreader.com**.
* **servidor de autorizaci√≥n**: El `servidor de autorizaci√≥n` es el **servidor que emite `tokens de acceso`** a la `aplicaci√≥n cliente` **despu√©s de autenticar con √©xito** al `propietario del recurso` y obtener autorizaci√≥n. En el ejemplo anterior, ser√≠a **https://twitter.com**
* **client\_id**: El `client_id` es el **identificador de la aplicaci√≥n**. Este es un identificador √∫nico **p√∫blico y no secreto**.
* **client\_secret:** El `client_secret` es un **secreto conocido solo por la aplicaci√≥n y el servidor de autorizaci√≥n**. Esto se utiliza para generar `tokens de acceso`
* **response\_type**: El `response_type` es un valor que detalla **qu√© tipo de token** se est√° solicitando, como `code`
* **scope**: El `scope` es el **nivel de acceso solicitado** que la `aplicaci√≥n cliente` est√° pidiendo al `propietario del recurso`
* **redirect\_uri**: El `redirect_uri` es la **URL a la que se redirige al usuario despu√©s de que la autorizaci√≥n est√° completa**. Esto generalmente debe coincidir con la URL de redirecci√≥n que previamente has registrado con el servicio
* **state**: El par√°metro `state` puede **persistir datos entre que el usuario es dirigido al servidor de autorizaci√≥n y de nuevo**. Es importante que este sea un valor √∫nico ya que sirve como un **mecanismo de protecci√≥n contra CSRF** si contiene un valor √∫nico o aleatorio por solicitud
* **grant\_type**: El par√°metro `grant_type` explica **cu√°l es el tipo de concesi√≥n**, y qu√© token va a ser devuelto
* **code**: Este `code` es el c√≥digo de autorizaci√≥n recibido del `servidor de autorizaci√≥n` que estar√° en el par√°metro de cadena de consulta ‚Äúcode‚Äù en esta solicitud. Este c√≥digo se utiliza en conjunto con el `client_id` y `client_secret` por la aplicaci√≥n cliente para obtener un `token de acceso`
* **access\_token**: El `access_token` es el **token que la aplicaci√≥n cliente utiliza para hacer solicitudes de API** en nombre de un `propietario del recurso`
* **refresh\_token**: El `refresh_token` permite a una aplicaci√≥n **obtener un nuevo `token de acceso` sin solicitar al usuario**

### Ejemplo Real

Junt√°ndolo todo, as√≠ es como se ve un **flujo real de OAuth**:

1. Visitas [https://yourtweetreader.com](https://yourtweetreader.com) y haces clic en el bot√≥n "Integrar con Twitter".
2. [https://yourtweetreader.com](https://yourtweetreader.com) env√≠a una solicitud a [https://twitter.com](https://twitter.com) pidi√©ndote, el propietario del recurso, que autorices la aplicaci√≥n de Twitter de https://yourtweetreader.com para acceder a tus Tweets. La solicitud se ver√° as√≠:
```
https://twitter.com/auth
?response_type=code
&client_id=yourtweetreader_clientId
&redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
&scope=readTweets
&state=kasodk9d1jd992k9klaskdh123
```
3\. Se le mostrar√° una p√°gina de consentimiento:

![](https://miro.medium.com/max/1215/1\*y66EY3Fn2qn-NPI9nhZC7A.png)

4\. Una vez aceptado, Twitter enviar√° una solicitud de regreso a la `redirect_uri` con los par√°metros `code` y `state`:
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123
```
5\. [https://yourtweetreader.com](https://yourtweetreader.com) tomar√° ese `code`, y utilizando el `client_id` y `client_secret` de su aplicaci√≥n, har√° una solicitud desde el servidor para recuperar un `access_token` en tu nombre, lo cual les permitir√° acceder a los permisos a los que diste tu consentimiento:
```
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", "client_secret": "yourtweetreader_clientSecret", "code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}
```
6\. Finalmente, el flujo est√° completo y [https://yourtweetreader.com](https://yourtweetreader.com) har√° una llamada API a Twitter con tu `access_token` para acceder a tus Tweets.

## Hallazgos de Bug Bounty <a href="#323a" id="323a"></a>

¬°Ahora, la parte interesante! Hay muchas cosas que pueden salir mal en una implementaci√≥n de OAuth, aqu√≠ est√°n las diferentes categor√≠as de errores que veo con frecuencia:

### Configuraci√≥n d√©bil de redirect\_uri <a href="#cc36" id="cc36"></a>

El `redirect_uri` es muy importante porque **datos sensibles, como el `code`, se a√±aden a esta URL** despu√©s de la autorizaci√≥n. Si el `redirect_uri` puede ser redirigido a un **servidor controlado por un atacante**, esto significa que el atacante puede potencialmente **tomar control de la cuenta de una v√≠ctima** utilizando el `code` por s√≠ mismos, y ganando acceso a los datos de la v√≠ctima.

La forma en que esto se va a explotar variar√° seg√∫n el servidor de autorizaci√≥n. **Algunos** solo **aceptar√°n** el mismo **camino de `redirect_uri` exacto que se especific√≥ en la aplicaci√≥n cliente**, pero algunos **aceptar√°n cualquier cosa** en el mismo dominio o subdirectorio del `redirect_uri`.

Dependiendo de la l√≥gica manejada por el servidor, hay una serie de t√©cnicas para evadir un `redirect_uri`. En una situaci√≥n donde un `redirect_uri` es [https://yourtweetreader.com](https://yourtweetreader.com)/callback, estas incluyen:

* Redirecciones abiertas: [`https://yourtweetreader.com`](https://yourtweetreader.com)`/callback?redirectUrl=https://evil.com`
* Traversal de ruta: `https://yourtweetreader.com/callback/../redirect?url=https://evil.com`
* Regexes d√©biles de `redirect_uri`: `https://yourtweetreader.com.evil.com`
* Inyecci√≥n de HTML y robo de tokens a trav√©s del encabezado referer: `https://yourtweetreader.com/callback/home/attackerimg.jpg`

**Otros par√°metros** que pueden ser vulnerables a Redirecciones Abiertas son:

* **client\_uri** - URL de la p√°gina de inicio de la aplicaci√≥n cliente
* **policy\_uri** - URL que la aplicaci√≥n cliente Parte Confiante proporciona para que el usuario final pueda leer sobre c√≥mo se utilizar√°n sus datos de perfil.
* **tos\_uri** - URL que la aplicaci√≥n cliente Parte Confiante proporciona para que el usuario final pueda leer sobre los t√©rminos de servicio de la Parte Confiante.
* **initiate\_login\_uri** - URI utilizando el esquema https que un tercero puede usar para iniciar un inicio de sesi√≥n por el RP. Tambi√©n debe usarse para redirecci√≥n del lado del cliente.

Todos estos par√°metros son **opcionales seg√∫n las especificaciones de OAuth y OpenID** y no siempre son compatibles en un servidor particular, por lo que siempre vale la pena identificar qu√© par√°metros son compatibles en tu servidor.

Si tu objetivo es un servidor OpenID, el punto de descubrimiento en \*\*`.well-known/openid-configuration`\*\* a veces contiene par√°metros como "_registration\_endpoint_", "_request\_uri\_parameter\_supported_", y "_require\_request\_uri\_registration_". Estos pueden ayudarte a encontrar el punto de registro y otros valores de configuraci√≥n del servidor.

### XSS en la implementaci√≥n de redirecci√≥n <a href="#bda5" id="bda5"></a>

Como se menciona en este informe de bug bounty [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) podr√≠a ser posible que la URL de redirecci√≥n **se refleje en la respuesta** del servidor despu√©s de que el usuario se autentique, siendo **vulnerable a XSS**. Posible payload para probar:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Manejo inadecuado del par√°metro state <a href="#bda5" id="bda5"></a>

Muy a menudo, el par√°metro **`state` se omite por completo o se usa de manera incorrecta**. Si un par√°metro `state` es **inexistente**, **o un valor est√°tico** que nunca cambia, el flujo OAuth probablemente ser√° **vulnerable a CSRF**. A veces, incluso si hay un par√°metro `state`, la **aplicaci√≥n podr√≠a no realizar ninguna validaci√≥n del par√°metro** y un ataque funcionar√°. La forma de explotar esto ser√≠a pasar por el proceso de autorizaci√≥n en tu propia cuenta y pausar justo despu√©s de autorizar. Entonces te encontrar√°s con una solicitud como:
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
```
Despu√©s de recibir esta solicitud, puedes **descartar la solicitud ya que estos c√≥digos suelen ser de un solo uso**. Luego puedes enviar esta URL a un **usuario con sesi√≥n iniciada, y se agregar√° tu cuenta a su cuenta**. Al principio, esto podr√≠a no parecer muy sensible ya que simplemente est√°s agregando tu cuenta a la cuenta de una v√≠ctima. Sin embargo, muchas implementaciones de OAuth son para fines de inicio de sesi√≥n, por lo que si puedes agregar tu cuenta de Google que se utiliza para iniciar sesi√≥n, podr√≠as potencialmente realizar un **Account Takeover** con un solo clic, ya que iniciar sesi√≥n con tu cuenta de Google te dar√≠a acceso a la cuenta de la v√≠ctima.

Puedes encontrar un **ejemplo** sobre esto en este [**CTF writeup**](https://github.com/gr455/ctf-writeups/blob/master/hacktivity20/notes\_surfer.md) y en el **HTB box llamado Oouch**.

Tambi√©n he visto que el par√°metro state se utiliza como un valor de redirecci√≥n adicional varias veces. La aplicaci√≥n utilizar√° `redirect_uri` para la redirecci√≥n inicial, pero luego el par√°metro `state` como una segunda redirecci√≥n que podr√≠a contener el `code` dentro de los par√°metros de consulta, o en el encabezado referer.

Una cosa importante a tener en cuenta es que esto no solo se aplica a situaciones de inicio de sesi√≥n y toma de control de cuentas. He visto malas configuraciones en:

* Integraciones de Slack que permiten a un atacante agregar su cuenta de Slack como destinatario de todas las notificaciones/mensajes
* Integraciones de Stripe que permiten a un atacante sobrescribir la informaci√≥n de pago y aceptar pagos de los clientes de la v√≠ctima
* Integraciones de PayPal que permiten a un atacante agregar su cuenta de PayPal a la cuenta de la v√≠ctima, lo que depositar√≠a dinero en la PayPal del atacante

### Pre Account Takeover <a href="#ebe4" id="ebe4"></a>

Uno de los problemas m√°s comunes que veo es cuando las aplicaciones permiten "Iniciar sesi√≥n con X" pero tambi√©n con nombre de usuario/contrase√±a. Hay 2 formas diferentes de atacar esto:

1. Si la aplicaci√≥n **no requiere verificaci√≥n de correo electr√≥nico al crear una cuenta**, intenta **crear una cuenta con la direcci√≥n de correo electr√≥nico de una v√≠ctima y una contrase√±a del atacante** antes de que la v√≠ctima se haya registrado. Si la **v√≠ctima** luego intenta registrarse o iniciar sesi√≥n **con un tercero**, como Google, es posible que la aplicaci√≥n haga una b√∫squeda, vea que el correo electr√≥nico ya est√° registrado y luego **vincule su cuenta de Google a la cuenta creada por el atacante**. Esto es un "**pre account takeover**" donde un atacante tendr√° acceso a la cuenta de la v√≠ctima si la cre√≥ antes de que la v√≠ctima se registrara.
2. Si una **aplicaci√≥n OAuth no requiere verificaci√≥n de correo electr√≥nico**, intenta registrarte con esa aplicaci√≥n OAuth y luego cambia la direcci√≥n de correo electr√≥nico por la **direcci√≥n de correo electr√≥nico de una v√≠ctima**. El mismo problema que se mencion√≥ anteriormente podr√≠a existir, pero estar√≠as atac√°ndolo desde la otra direcci√≥n y obteniendo acceso a la cuenta de la v√≠ctima para un account takeover.

### Disclosure of Secrets <a href="#e177" id="e177"></a>

Es muy importante reconocer **cu√°les de los muchos par√°metros de OAuth son secretos** y protegerlos. Por ejemplo, filtrar el `client_id` est√° perfectamente bien y es necesario, pero filtrar el **`client_secret` es peligroso**. Si esto se filtra, el **atacante** puede potencialmente **abusar de la confianza e identidad de la aplicaci√≥n cliente de confianza para robar `access_tokens` de usuario e informaci√≥n/acceso privado para sus cuentas integradas**. Volviendo a nuestro ejemplo anterior, un problema que he visto es realizar este paso desde el cliente, en lugar del servidor:

_5._ [_https://yourtweetreader.com_](https://yourtweetreader.com) _entonces tomar√° ese `code`, y utilizando el `client_id` y `client_secret` de su aplicaci√≥n, har√° una solicitud desde el servidor para recuperar un `access_token` en tu nombre, lo que les permitir√° acceder a los permisos a los que diste tu consentimiento._

**Si esto se hace desde el cliente, el `client_secret` se filtrar√° y los usuarios podr√°n generar `access_tokens` en nombre de la aplicaci√≥n**. Con un poco de ingenier√≠a social, tambi√©n pueden **agregar m√°s alcances a la autorizaci√≥n de OAuth** y todo parecer√° leg√≠timo ya que la solicitud vendr√° de la aplicaci√≥n cliente de confianza.

### Client Secret Bruteforce

Puedes intentar **bruteforce el `client_secret`** de un proveedor de servicios con el proveedor de identidad para intentar robar cuentas.\
La solicitud para BF puede parecerse a:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Encabezado Referer filtrando C√≥digo + Estado

Una vez que el cliente tiene el **c√≥digo y estado**, si se **refleja dentro del encabezado Referer** cuando navega a una p√°gina diferente, entonces es vulnerable.

### Token de Acceso Almacenado en el Historial del Navegador

Ve al **historial del navegador y verifica si el token de acceso est√° guardado all√≠**.

### C√≥digo de Autorizaci√≥n Permanente

El **c√≥digo de autorizaci√≥n deber√≠a vivir solo por un tiempo para limitar la ventana de tiempo donde un atacante puede robarlo y usarlo**.

### Token de Autorizaci√≥n/Actualizaci√≥n no vinculado al cliente

Si puedes obtener el **c√≥digo de autorizaci√≥n y usarlo con un cliente diferente, entonces puedes tomar control de otras cuentas**.

### Caminos Felices, XSS, Iframes y Mensajes Post para filtrar valores de c√≥digo y estado

### AWS Cognito <a href="#bda5" id="bda5"></a>

En este informe de recompensa por errores: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) puedes ver que el **token** que **AWS Cognito** devuelve al usuario podr√≠a tener **suficientes permisos para sobrescribir los datos del usuario**. Por lo tanto, si puedes **cambiar el correo electr√≥nico del usuario por el de otro usuario**, podr√≠as ser capaz de **tomar control** de otras cuentas.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
Para obtener informaci√≥n m√°s detallada sobre c√≥mo abusar de AWS Cognito, consulta:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Abusando de tokens de otras aplicaciones <a href="#bda5" id="bda5"></a>

Como se [**menciona en este art√≠culo**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts), los flujos de OAuth que esperan recibir el **token** (y no un c√≥digo) podr√≠an ser vulnerables si no verifican que el token pertenece a la aplicaci√≥n.

Esto se debe a que un **atacante** podr√≠a crear una **aplicaci√≥n compatible con OAuth e iniciar sesi√≥n con Facebook** (por ejemplo) en su propia aplicaci√≥n. Luego, una vez que una v√≠ctima inicia sesi√≥n con Facebook en la **aplicaci√≥n del atacante**, el atacante podr√≠a obtener el **token OAuth del usuario otorgado a su aplicaci√≥n y usarlo para iniciar sesi√≥n en la aplicaci√≥n OAuth de la v√≠ctima utilizando el token del usuario de la v√≠ctima**.

{% hint style="danger" %}
Por lo tanto, si el atacante logra que el usuario acceda a su propia aplicaci√≥n OAuth, podr√° tomar control de la cuenta de la v√≠ctima en aplicaciones que esperan un token y no verifican si el token fue otorgado a su ID de aplicaci√≥n.
{% endhint %}

### Dos enlaces y una cookie <a href="#bda5" id="bda5"></a>

Seg√∫n [**este art√≠culo**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f), era posible hacer que una v√≠ctima abriera una p√°gina con un **returnUrl** apuntando al host del atacante. Esta informaci√≥n se **almacenar√≠a en una cookie (RU)** y en un **paso posterior** el **prompt** **preguntar√°** al **usuario** si quiere dar acceso al host del atacante.

Para evitar este prompt, era posible abrir una pesta√±a para iniciar el **flujo de Oauth** que configurar√≠a esta cookie RU usando el **returnUrl**, cerrar la pesta√±a antes de que se mostrara el prompt y abrir una nueva pesta√±a sin ese valor. Entonces, el **prompt no informar√° sobre el host del atacante**, pero la cookie estar√≠a configurada para √©l, por lo que el **token se enviar√≠a al host del atacante** en la redirecci√≥n.

### Par√°metros de SSRFs <a href="#bda5" id="bda5"></a>

Una de las URLs ocultas que podr√≠as pasar por alto es el **punto final de registro de cliente din√°mico**. Para autenticar usuarios con √©xito, los servidores OAuth necesitan conocer detalles sobre la aplicaci√≥n cliente, como el "client\_name", "client\_secret", "redirect\_uris", etc. Estos detalles se pueden proporcionar a trav√©s de la configuraci√≥n local, pero los servidores de autorizaci√≥n OAuth tambi√©n pueden tener un **punto final de registro especial**. Este punto final normalmente est√° mapeado a "/register" y acepta solicitudes POST con el siguiente formato:
```json
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
"application_type": "web",
"redirect_uris": ["https://client.example.org/callback"],
"client_name": "My Example",
"logo_uri": "https://client.example.org/logo.png",
"subject_type": "pairwise",
"sector_identifier_uri": "https://example.org/rdrct_uris.json",
"token_endpoint_auth_method": "client_secret_basic",
"jwks_uri": "https://client.example.org/public_keys.jwks",
"contacts": ["ve7jtb@example.org"],
"request_uris": ["https://client.example.org/rf.txt"]
}
```
Hay dos especificaciones que definen par√°metros en esta solicitud: [RFC7591](https://tools.ietf.org/html/rfc7591) para OAuth y [Openid Connect Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html#rfc.section.3.1).

Como puedes ver aqu√≠, varios de estos valores se pasan a trav√©s de referencias URL y parecen objetivos potenciales para [Server Side Request Forgery](https://portswigger.net/web-security/ssrf). Al mismo tiempo, la mayor√≠a de los servidores que hemos probado no resuelven estas URLs inmediatamente cuando reciben una solicitud de registro. En su lugar, simplemente **guardan estos par√°metros y los usan m√°s tarde durante el flujo de autorizaci√≥n OAuth**. En otras palabras, esto es m√°s como un SSRF de segundo orden, lo que hace que la detecci√≥n de caja negra sea m√°s dif√≠cil.

Los siguientes par√°metros son particularmente interesantes para ataques SSRF:

* **logo\_uri** - URL que hace referencia a un **logotipo para la aplicaci√≥n cliente**. **Despu√©s de registrar un cliente**, puedes intentar llamar al punto final de autorizaci√≥n OAuth ("/authorize") usando tu nuevo "client\_id". Despu√©s del inicio de sesi√≥n, el servidor te pedir√° que apruebes la solicitud y **puede mostrar la imagen del "logo\_uri"**. Si el **servidor obtiene la imagen por s√≠ mismo**, el SSRF deber√≠a activarse en este paso. Alternativamente, el servidor puede simplemente incluir el logotipo a trav√©s de una etiqueta **cliente-side "\<img>"**. Aunque esto no conduce a SSRF, puede llevar a **XSS si la URL no est√° escapada**.
*   **jwks\_uri** - URL para el documento del conjunto de claves web JSON del cliente \[JWK]. Este conjunto de claves es necesario en el servidor para validar solicitudes firmadas hechas al punto final del token cuando se usan JWTs para la autenticaci√≥n del cliente \[RFC7523]. Para probar SSRF en este par√°metro, **registra una nueva aplicaci√≥n cliente con un "jwks\_uri" malicioso**, realiza el proceso de autorizaci√≥n para **obtener un c√≥digo de autorizaci√≥n para cualquier usuario y luego solicita el punto final "/token"** con el siguiente cuerpo:

`POST /oauth/token HTTP/1.1`\
`...`\
\`\`\
`grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion=eyJhbGci...`

Si es vulnerable, el **servidor deber√≠a realizar una solicitud HTTP de servidor a servidor al "jwks\_uri" suministrado** porque necesita esta clave para verificar la validez del par√°metro "client\_assertion" en tu solicitud. Esto probablemente solo ser√° una vulnerabilidad SSRF ciega, ya que el servidor espera una respuesta JSON adecuada.
* **sector\_identifier\_uri** - Esta URL hace referencia a un archivo con un √∫nico **array JSON de valores de redirect\_uri**. Si es compatible, el servidor puede **obtener este valor tan pronto como env√≠es la solicitud de registro din√°mico**. Si esto no se obtiene de inmediato, intenta realizar la autorizaci√≥n para este cliente en el servidor. Como necesita conocer los redirect\_uris para completar el flujo de autorizaci√≥n, esto obligar√° al servidor a realizar una solicitud a tu sector\_identifier\_uri malicioso.
*   **request\_uris** - Un array de los **request\_uris permitidos para este cliente**. El par√°metro "request\_uri" puede ser compatible con el punto final de autorizaci√≥n para proporcionar una URL que contenga un JWT con la informaci√≥n de la solicitud (ver [https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2](https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2)).

Incluso si el registro de cliente din√°mico no est√° habilitado, o requiere autenticaci√≥n, podemos intentar realizar SSRF en el punto final de autorizaci√≥n simplemente usando "request\_uri":\\

`GET /authorize?response_type=code%20id_token&client_id=sclient1&request_uri=https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt`

Nota: no confundas este par√°metro con "redirect\_uri". El "redirect\_uri" se utiliza para la redirecci√≥n despu√©s de la autorizaci√≥n, mientras que **"request\_uri" es obtenido por el servidor al inicio del proceso de autorizaci√≥n**.

Al mismo tiempo, muchos servidores que hemos visto no permiten valores arbitrarios de "request\_uri": solo permiten URLs en la lista blanca que se pre-registraron durante el proceso de registro del cliente. Por eso necesitamos suministrar "request\_uris": "https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt" de antemano.

## Condiciones de Carrera en Proveedores de OAuth

Si la plataforma que est√°s probando es un proveedor de OAuth [**lee esto para probar posibles Condiciones de Carrera**](race-condition.md).

## Referencias

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
