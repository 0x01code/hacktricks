# OAuth zur √úbernahme von Konten

<details>

<summary><strong>Lernen Sie das Hacken von AWS von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## Grundlegende Informationen <a href="#d4a8" id="d4a8"></a>

OAuth bietet verschiedene Versionen, wobei grundlegende Einblicke unter [OAuth 2.0-Dokumentation](https://oauth.net/2/) verf√ºgbar sind. Diese Diskussion konzentriert sich haupts√§chlich auf den weit verbreiteten [OAuth 2.0-Autorisierungscode-Grant-Typ](https://oauth.net/2/grant-types/authorization-code/), der ein **Autorisierungsframework bereitstellt, das einer Anwendung erm√∂glicht, auf das Konto eines Benutzers in einer anderen Anwendung zuzugreifen oder Aktionen durchzuf√ºhren** (der Autorisierungsserver).

Nehmen wir an, es gibt eine hypothetische Website _**https://example.com**_, die dazu dient, **alle Ihre Social-Media-Beitr√§ge** einschlie√ülich privater Beitr√§ge anzuzeigen. Um dies zu erreichen, wird OAuth 2.0 verwendet. _https://example.com_ wird um Ihre Erlaubnis bitten, **auf Ihre Social-Media-Beitr√§ge zuzugreifen**. Daraufhin wird auf _https://socialmedia.com_ ein Zustimmungsbildschirm angezeigt, auf dem die **beantragten Berechtigungen und der Antragsteller** angezeigt werden. Nach Ihrer Autorisierung erh√§lt _https://example.com_ die M√∂glichkeit, **in Ihrem Namen auf Ihre Beitr√§ge zuzugreifen**.

Es ist wichtig, die folgenden Komponenten im Rahmen des OAuth 2.0-Frameworks zu verstehen:

- **Ressourceninhaber**: Sie als **Benutzer/Entit√§t** autorisieren den Zugriff auf Ihre Ressource, z. B. Ihre Social-Media-Kontobeitr√§ge.
- **Ressourcenserver**: Der **Server, der authentifizierte Anfragen verwaltet**, nachdem die Anwendung im Namen des Ressourceninhabers einen `Access Token` erhalten hat, z. B. **https://socialmedia.com**.
- **Client-Anwendung**: Die **Anwendung, die Autorisierung beantragt**, vom `Ressourceninhaber`, wie z. B. **https://example.com**.
- **Autorisierungsserver**: Der **Server, der `Access Tokens` ausstellt**, an die `Client-Anwendung`, nach erfolgreicher Authentifizierung des `Ressourceninhabers` und Erteilung der Autorisierung, z. B. **https://socialmedia.com**.
- **client\_id**: Eine √∂ffentliche, eindeutige Kennung f√ºr die Anwendung.
- **client\_secret:** Ein vertraulicher Schl√ºssel, der nur der Anwendung und dem Autorisierungsserver bekannt ist und zur Generierung von `Access Tokens` verwendet wird.
- **response\_type**: Ein Wert, der den **Typ des angeforderten Tokens** angibt, z. B. `code`.
- **scope**: Das **Zugriffsniveau**, das von der `Client-Anwendung` vom `Ressourceninhaber` angefordert wird.
- **redirect\_uri**: Die **URL, zu der der Benutzer nach der Autorisierung umgeleitet wird**. Diese muss in der Regel mit der vorregistrierten Umleitungs-URL √ºbereinstimmen.
- **state**: Ein Parameter, um **Daten √ºber die Weiterleitung des Benutzers zum und vom Autorisierungsserver zu speichern**. Seine Eindeutigkeit ist entscheidend, um als **CSRF-Schutzmechanismus** zu dienen.
- **grant\_type**: Ein Parameter, der **den Grant-Typ und den Typ des zur√ºckzugebenden Tokens** angibt.
- **code**: Der Autorisierungscode vom `Autorisierungsserver`, der zusammen mit `client_id` und `client_secret` von der Client-Anwendung verwendet wird, um einen `Access Token` zu erhalten.
- **access\_token**: Der **Token, den die Client-Anwendung f√ºr API-Anfragen** im Namen des `Ressourceninhabers` verwendet.
- **refresh\_token**: Erm√∂glicht der Anwendung, **einen neuen `Access Token` zu erhalten, ohne den Benutzer erneut zur Eingabe aufzufordern**.

### Ablauf

Der **tats√§chliche OAuth-Ablauf** erfolgt wie folgt:

1. Sie navigieren zu [https://example.com](https://example.com) und w√§hlen die Schaltfl√§che "Mit Social Media integrieren" aus.
2. Die Website sendet dann eine Anfrage an [https://socialmedia.com](https://socialmedia.com), um Ihre Autorisierung zur Erlaubnis des Zugriffs der Anwendung von https://example.com auf Ihre Beitr√§ge zu erhalten. Die Anfrage ist wie folgt strukturiert:
```
https://socialmedia.com/auth
?response_type=code
&client_id=example_clientId
&redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
&scope=readPosts
&state=randomString123
```
3. Ihnen wird dann eine Zustimmungsseite angezeigt.

4. Nach Ihrer Zustimmung sendet Social Media eine Antwort an die `redirect_uri` mit den Parametern `code` und `state`:
```
https://example.com?code=uniqueCode123&state=randomString123
```
5. https://example.com verwendet diesen `code` zusammen mit seiner `client_id` und `client_secret`, um eine serverseitige Anfrage zu stellen und im Auftrag von Ihnen einen `access_token` zu erhalten. Dadurch wird der Zugriff auf die von Ihnen genehmigten Berechtigungen erm√∂glicht:
```
POST /oauth/access_token
Host: socialmedia.com
...{"client_id": "example_clientId", "client_secret": "example_clientSecret", "code": "uniqueCode123", "grant_type": "authorization_code"}
```
6. Schlie√ülich schlie√üt der Prozess ab, wenn https://example.com Ihren `access_token` verwendet, um einen API-Aufruf an Social Media zum Zugriff aufzurufen.

## Schwachstellen <a href="#323a" id="323a"></a>

### Offene redirect\_uri <a href="#cc36" id="cc36"></a>

Die `redirect_uri` ist f√ºr die Sicherheit bei OAuth- und OpenID-Implementierungen entscheidend, da sie angibt, wohin sensible Daten wie Autorisierungscodes nach der Autorisierung gesendet werden. Wenn sie falsch konfiguriert ist, k√∂nnte dies Angreifern erm√∂glichen, diese Anfragen an b√∂sartige Server umzuleiten und so Account-√úbernahmen zu erm√∂glichen.

Die Ausnutzungstechniken variieren je nach Validierungslogik des Autorisierungsservers. Sie k√∂nnen von streichem Pfadabgleich bis zur Akzeptanz jeder URL innerhalb der angegebenen Dom√§ne oder Unterverzeichnis reichen. H√§ufige Ausbeutungsmethoden umfassen offene Weiterleitungen, Pfadtraversierung, Ausnutzung schwacher Regexes und HTML-Injektion zur Token-Diebstahl.

Neben `redirect_uri` sind auch andere OAuth- und OpenID-Parameter wie `client_uri`, `policy_uri`, `tos_uri` und `initiate_login_uri` anf√§llig f√ºr Weiterleitungsangriffe. Diese Parameter sind optional und ihre Unterst√ºtzung variiert je nach Server.

F√ºr diejenigen, die einen OpenID-Server ins Visier nehmen, listet der Entdeckungsendpunkt (`**.well-known/openid-configuration**`) oft wertvolle Konfigurationsdetails wie `registration_endpoint`, `request_uri_parameter_supported` und "`require_request_uri_registration`. Diese Details k√∂nnen dabei helfen, den Registrierungsendpunkt und andere konkrete Konfigurationen des Servers zu identifizieren.

### XSS in der Weiterleitungsimplementierung <a href="#bda5" id="bda5"></a>

Wie in diesem Bug-Bounty-Bericht [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) erw√§hnt, ist es m√∂glich, dass die Weiterleitungs-URL in der Antwort des Servers nach der Authentifizierung des Benutzers reflektiert wird und somit anf√§llig f√ºr XSS ist. M√∂glicher Payload zum Testen:
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - Unsachgem√§√üer Umgang mit dem Zustandsparameter <a href="#bda5" id="bda5"></a>

Bei OAuth-Implementierungen kann der Missbrauch oder das Weglassen des **`state`-Parameters** das Risiko von **Cross-Site Request Forgery (CSRF)**-Angriffen erheblich erh√∂hen. Diese Sicherheitsl√ºcke tritt auf, wenn der `state`-Parameter entweder **nicht verwendet wird, als statischer Wert verwendet wird oder nicht ordnungsgem√§√ü validiert wird**, was Angreifern erm√∂glicht, CSRF-Schutzma√ünahmen zu umgehen.

Angreifer k√∂nnen dies ausnutzen, indem sie den Autorisierungsprozess abfangen, um ihr Konto mit dem Konto eines Opfers zu verkn√ºpfen, was zu potenziellen **Account Takeovers** f√ºhrt. Dies ist besonders kritisch in Anwendungen, in denen OAuth f√ºr **Authentifizierungszwecke** verwendet wird.

Reale Beispiele f√ºr diese Sicherheitsl√ºcke wurden in verschiedenen **CTF-Herausforderungen** und **Hacking-Plattformen** dokumentiert, was ihre praktischen Auswirkungen verdeutlicht. Das Problem betrifft auch Integrationen mit Drittanbieterdiensten wie **Slack**, **Stripe** und **PayPal**, bei denen Angreifer Benachrichtigungen oder Zahlungen auf ihre Konten umleiten k√∂nnen.

Ein ordnungsgem√§√üer Umgang und eine Validierung des **`state`-Parameters** sind entscheidend, um sich gegen CSRF zu sch√ºtzen und den OAuth-Fluss abzusichern.

### Vor Account Takeover <a href="#ebe4" id="ebe4"></a>

1. **Ohne E-Mail-Verifizierung bei der Kontenerstellung**: Angreifer k√∂nnen vorbeugend ein Konto mit der E-Mail-Adresse des Opfers erstellen. Wenn das Opfer sp√§ter einen Drittanbieterdienst f√ºr die Anmeldung verwendet, kann die Anwendung versehentlich dieses Drittanbieterkonto mit dem vorab erstellten Konto des Angreifers verkn√ºpfen, was zu unbefugtem Zugriff f√ºhrt.

2. **Ausnutzung der laxen OAuth-E-Mail-Verifizierung**: Angreifer k√∂nnen OAuth-Dienste ausnutzen, die E-Mails nicht √ºberpr√ºfen, indem sie sich mit ihrem Dienst registrieren und dann die E-Mail-Adresse des Kontos auf die des Opfers √§ndern. Diese Methode birgt √§hnliche Risiken f√ºr unbefugten Zugriff auf das Konto wie das erste Szenario, jedoch √ºber einen anderen Angriffsvektor.

### Offenlegung von Geheimnissen <a href="#e177" id="e177"></a>

Die Identifizierung und der Schutz geheimer OAuth-Parameter sind entscheidend. W√§hrend die **`client_id`** sicher offengelegt werden kann, birgt die Offenlegung des **`client_secret`** erhebliche Risiken. Wenn das `client_secret` kompromittiert ist, k√∂nnen Angreifer die Identit√§t und das Vertrauen der Anwendung ausnutzen, um Benutzer-`access_tokens` und private Informationen zu stehlen.

Eine h√§ufige Sicherheitsl√ºcke entsteht, wenn Anwendungen den Austausch des Autorisierungs-`code` gegen einen `access_token` auf der Client-Seite anstelle der Server-Seite fehlerhaft behandeln. Dieser Fehler f√ºhrt zur Offenlegung des `client_secret`, was Angreifern erm√∂glicht, `access_tokens` unter dem Deckmantel der Anwendung zu generieren. Dar√ºber hinaus k√∂nnten Angreifer durch Social Engineering Privilegien eskalieren, indem sie zus√§tzliche Scopes zur OAuth-Autorisierung hinzuf√ºgen und den vertrauensw√ºrdigen Status der Anwendung weiter ausnutzen.

### Client Secret Bruteforce

Sie k√∂nnen versuchen, den **Client-Secret** eines Dienstanbieters mit dem Identit√§tsanbieter zu **bruteforcen**, um Konten zu stehlen.\
Die Anfrage an BF k√∂nnte √§hnlich aussehen:
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer-Header leckt Code + State

Wenn der Client den **Code und den State** hat und dieser im **Referer-Header reflektiert wird**, wenn er zu einer anderen Seite wechselt, dann ist er anf√§llig.

### Zugriffstoken im Browserverlauf gespeichert

Gehen Sie zum **Browserverlauf und √ºberpr√ºfen Sie, ob das Zugriffstoken dort gespeichert ist**.

### Ewiger Autorisierungscode

Der **Autorisierungscode sollte nur f√ºr kurze Zeit g√ºltig sein, um das Zeitfenster zu begrenzen, in dem ein Angreifer ihn stehlen und verwenden kann**.

### Autorisierungs-/Auffrischungstoken nicht an den Client gebunden

Wenn Sie den **Autorisierungscode erhalten und mit einem anderen Client verwenden k√∂nnen, k√∂nnen Sie andere Konten √ºbernehmen**.

### Happy Paths, XSS, Iframes & Post Messages zum Auslesen von Code- und State-Werten

**[√úberpr√ºfen Sie diesen Beitrag](https://labs.detectify.com/writeups/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)**

### AWS Cognito <a href="#bda5" id="bda5"></a>

In diesem Bug-Bounty-Bericht: [**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) k√∂nnen Sie sehen, dass das **Token**, das **AWS Cognito** dem Benutzer zur√ºckgibt, m√∂glicherweise **ausreichende Berechtigungen hat, um die Benutzerdaten zu √ºberschreiben**. Wenn Sie also die **E-Mail-Adresse des Benutzers in eine andere E-Mail-Adresse √§ndern k√∂nnen**, k√∂nnen Sie m√∂glicherweise **andere Konten √ºbernehmen**.
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
F√ºr weitere detaillierte Informationen dar√ºber, wie man AWS Cognito missbrauchen kann, siehe:

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### Missbrauch von Tokens anderer Apps <a href="#bda5" id="bda5"></a>

Wie in diesem [**Artikel**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts) erw√§hnt, k√∂nnen OAuth-Flows, die erwarten, dass das **Token** (und nicht ein Code) empfangen wird, anf√§llig sein, wenn sie nicht √ºberpr√ºfen, ob das Token zur App geh√∂rt.

Dies liegt daran, dass ein **Angreifer** eine **Anwendung erstellen** k√∂nnte, die OAuth unterst√ºtzt und sich mit Facebook (zum Beispiel) in seiner eigenen Anwendung anmeldet. Sobald ein Opfer sich mit Facebook in der **Anwendung des Angreifers** anmeldet, kann der Angreifer das **OAuth-Token des Benutzers erhalten, das seiner Anwendung gegeben wurde, und es verwenden, um sich in der OAuth-Anwendung des Opfers mit dem Token des Opfers anzumelden**.

{% hint style="danger" %}
Daher kann der Angreifer, wenn es ihm gelingt, den Benutzer dazu zu bringen, seine eigene OAuth-Anwendung zu nutzen, das Konto des Opfers in Anwendungen √ºbernehmen, die ein Token erwarten und nicht √ºberpr√ºfen, ob das Token ihrer App-ID zugewiesen wurde.
{% endhint %}

### Zwei Links & Cookie <a href="#bda5" id="bda5"></a>

Laut [**diesem Artikel**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f) war es m√∂glich, ein Opfer dazu zu bringen, eine Seite mit einer **returnUrl** zu √∂ffnen, die auf den Host des Angreifers verweist. Diese Informationen w√ºrden in einem Cookie (RU) gespeichert und in einem **sp√§teren Schritt** w√ºrde der **Prompt** den **Benutzer** fragen, ob er Zugriff auf den Host des Angreifers gew√§hren m√∂chte.

Um diesen Prompt zu umgehen, war es m√∂glich, einen Tab zu √∂ffnen, um den **OAuth-Flow** zu initiieren, der dieses RU-Cookie mit der **returnUrl** setzen w√ºrde, den Tab zu schlie√üen, bevor der Prompt angezeigt wird, und einen neuen Tab ohne diesen Wert zu √∂ffnen. Der **Prompt informiert nicht √ºber den Host des Angreifers**, aber das Cookie wird darauf gesetzt, sodass das **Token an den Host des Angreifers** bei der Weiterleitung gesendet wird.

### SSRF-Parameter <a href="#bda5" id="bda5"></a>

**[√úberpr√ºfen Sie diese Forschung](https://portswigger.net/research/hidden-oauth-attack-vectors) f√ºr weitere Details zu dieser Technik.**

Die dynamische Client-Registrierung in OAuth dient als weniger offensichtlicher, aber kritischer Vektor f√ºr Sicherheitsl√ºcken, insbesondere f√ºr **Server-seitige Anfragenf√§lschung (SSRF)**-Angriffe. Dieser Endpunkt erm√∂glicht es OAuth-Servern, Details √ºber Client-Anwendungen zu erhalten, einschlie√ülich sensibler URLs, die ausgenutzt werden k√∂nnten.

**Hauptpunkte:**

- Die dynamische Client-Registrierung ist oft auf `/register` abgebildet und akzeptiert Details wie `client_name`, `client_secret`, `redirect_uris` und URLs f√ºr Logos oder JSON Web Key Sets (JWKs) √ºber POST-Anfragen.
- Diese Funktion entspricht den in **RFC7591** und **OpenID Connect Registration 1.0** festgelegten Spezifikationen, die Parameter enthalten, die anf√§llig f√ºr SSRF sein k√∂nnen.
- Der Registrierungsprozess kann Server versehentlich SSRF auf verschiedene Arten aussetzen:
- **`logo_uri`**: Eine URL f√ºr das Logo der Client-Anwendung, das vom Server abgerufen werden k√∂nnte und SSRF ausl√∂st oder zu XSS f√ºhrt, wenn die URL falsch behandelt wird.
- **`jwks_uri`**: Eine URL zum JWK-Dokument des Clients, das bei b√∂sartiger Gestaltung den Server dazu veranlassen kann, ausgehende Anfragen an einen vom Angreifer kontrollierten Server zu stellen.
- **`sector_identifier_uri`**: Verweist auf ein JSON-Array von `redirect_uris`, das der Server abrufen k√∂nnte und so eine SSRF-M√∂glichkeit schafft.
- **`request_uris`**: Listet erlaubte Anforderungs-URIs f√ºr den Client auf, die ausgenutzt werden k√∂nnen, wenn der Server diese URIs zu Beginn des Autorisierungsprozesses abruft.

**Ausbeutungsstrategie:**

- SSRF kann ausgel√∂st werden, indem ein neuer Client mit b√∂sartigen URLs in Parametern wie `logo_uri`, `jwks_uri` oder `sector_identifier_uri` registriert wird.
- W√§hrend eine direkte Ausbeutung √ºber `request_uris` durch Whitelist-Steuerungen gemildert werden kann, kann die Bereitstellung einer vorregistrierten, vom Angreifer kontrollierten `request_uri` SSRF w√§hrend der Autorisierungsphase erleichtern.

## Rennbedingungen bei OAuth-Anbietern

Wenn die Plattform, die Sie testen, ein OAuth-Anbieter ist, [**lesen Sie dies, um m√∂gliche Rennbedingungen zu testen**](race-condition.md).

## Referenzen

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder folgen Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
