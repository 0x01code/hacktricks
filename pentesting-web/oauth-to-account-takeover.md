# OAuth 至账户接管

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks 中看到您的公司广告** 或 **下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFT 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## 基本信息 <a href="#d4a8" id="d4a8"></a>

OAuth 有几个不同的版本，您可以阅读 [https://oauth.net/2/](https://oauth.net/2/) 以获得基本了解。

在本文中，我们将重点介绍您今天最常见的流程，即 [OAuth 2.0 授权码授权类型](https://oauth.net/2/grant-types/authorization-code/)。本质上，OAuth 为开发者提供了一种**授权机制，允许一个应用程序访问数据或代表您的账户在另一个应用程序**（授权服务器）中执行某些操作。

例如，假设网站 _**https://yourtweetreader.com**_ 有功能可以**显示您发送的所有推文**，包括私人推文。为此，引入了 OAuth 2.0。_https://yourtweetreader.com_ 将要求您**授权他们的 Twitter 应用程序访问您的所有推文**。一个同意页面将在 _https://twitter.com_ 弹出，显示正在请求的**权限**，以及请求它的开发者是谁。一旦您授权请求，_https://yourtweetreader.com_ 将能够**代表您访问您的推文**。

在 OAuth 2.0 上下文中理解的重要元素：

* **资源拥有者**：`资源拥有者` 是**用户/实体**，授权访问其受保护资源，例如他们的 Twitter 账户推文。在这个例子中，这将是**您**。
* **资源服务器**：`资源服务器` 是**处理应用程序获得 `access token` 代表 `资源拥有者` 后的认证请求的服务器**。在这个例子中，这将是 **https://twitter.com**
* **客户端应用程序**：`客户端应用程序` 是**请求 `资源拥有者` 授权的应用程序**。在这个例子中，这将是 **https://yourtweetreader.com**。
* **授权服务器**：`授权服务器` 是**在成功认证 `资源拥有者` 并获得授权后向 `客户端应用程序` 发放 `access tokens` 的服务器**。在上面的例子中，这将是 **https://twitter.com**
* **client\_id**：`client_id` 是**应用程序的标识符**。这是一个公开的、**非秘密**的唯一标识符。
* **client\_secret：** `client_secret` 是**只有应用程序和授权服务器知道的秘密**。这用于生成 `access_tokens`
* **response\_type**：`response_type` 是一个值，详细说明**正在请求哪种类型的令牌**，例如 `code`
* **scope**：`scope` 是**客户端应用程序**从 `资源拥有者` 请求的**访问级别**
* **redirect\_uri**：`redirect_uri` 是**授权完成后用户被重定向到的 URL**。这通常必须与您之前已经注册的服务的重定向 URL 匹配
* **state**：`state` 参数可以**在用户被引导到授权服务器并再次返回之间保持数据**。这是一个重要的唯一值，因为如果它包含每个请求的唯一或随机值，它将作为**CSRF 保护机制**
* **grant\_type**：`grant_type` 参数解释了**授权类型是什么**，以及将返回哪种令牌
* **code**：这个 `code` 是从 `授权服务器` 收到的授权码，将在此请求的查询字符串参数“code”中。这个代码与 `client_id` 和 `client_secret` 结合使用，由客户端应用程序获取 `access_token`
* **access\_token**：`access_token` 是**客户端应用程序用来代表 `资源拥有者` 发出 API 请求的令牌**
* **refresh\_token**：`refresh_token` 允许应用程序**获得新的 `access_token` 而无需提示用户**

### 真实示例

将所有这些放在一起，这是一个**真实的 OAuth 流程**看起来像：

1. 您访问 [https://yourtweetreader.com](https://yourtweetreader.com) 并点击“与 Twitter 集成”按钮。
2. [https://yourtweetreader.com](https://yourtweetreader.com) 向 [https://twitter.com](https://twitter.com) 发送请求，要求您，资源拥有者，授权 https://yourtweetreader.com 的 Twitter 应用程序访问您的推文。请求将看起来像：
```
https://twitter.com/auth
?response_type=code
&client_id=yourtweetreader_clientId
&redirect_uri=https%3A%2F%2Fyourtweetreader.com%2Fcallback
&scope=readTweets
&state=kasodk9d1jd992k9klaskdh123
```
3\. 您将看到一个同意页面：

![](https://miro.medium.com/max/1215/1\*y66EY3Fn2qn-NPI9nhZC7A.png)

4\. 一旦接受，Twitter 将会向 `redirect_uri` 发送一个带有 `code` 和 `state` 参数的请求：
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1&state=kasodk9d1jd992k9klaskdh123
```
5\. [https://yourtweetreader.com](https://yourtweetreader.com) 将会使用它们应用的 `client_id` 和 `client_secret`，带着那个 `code`，从服务器发起请求以代表你获取一个 `access_token`，这将允许它们访问你同意的权限：
```
POST /oauth/access_token
Host: twitter.com
...{"client_id": "yourtweetreader_clientId", "client_secret": "yourtweetreader_clientSecret", "code": "asd91j3jd91j92j1j9d1", "grant_type": "authorization_code"}
```
6\. 最终，流程完成，[https://yourtweetreader.com](https://yourtweetreader.com) 将使用您的 `access_token` 调用 Twitter 的 API 来访问您的推文。

## Bug Bounty 发现 <a href="#323a" id="323a"></a>

现在来到了有趣的部分！OAuth 实现中可能出现很多问题，以下是我经常看到的不同类别的漏洞：

### 弱 redirect\_uri 配置 <a href="#cc36" id="cc36"></a>

`redirect_uri` 非常重要，因为 **敏感数据，如 `code` 会在授权后附加到这个 URL 上**。如果 `redirect_uri` 可以被重定向到 **攻击者控制的服务器**，这意味着攻击者可以通过使用 `code` 来 **接管受害者的账户**，并获取受害者的数据。

这将如何被利用将因授权服务器而异。**一些** 服务器将 **只接受** 与客户端应用程序中指定的完全相同的 **`redirect_uri` 路径**，但有些服务器将 **接受** 同一域名或 `redirect_uri` 的子目录中的任何内容。

根据服务器处理的逻辑，有许多技术可以绕过 `redirect_uri`。在 `redirect_uri` 是 [https://yourtweetreader.com](https://yourtweetreader.com)/callback 的情况下，包括：

* 开放重定向：[`https://yourtweetreader.com`](https://yourtweetreader.com)`/callback?redirectUrl=https://evil.com`
* 路径遍历：`https://yourtweetreader.com/callback/../redirect?url=https://evil.com`
* 弱 `redirect_uri` 正则表达式：`https://yourtweetreader.com.evil.com`
* HTML 注入并通过 referer 头窃取令牌：`https://yourtweetreader.com/callback/home/attackerimg.jpg`

**其他可能** 容易受到开放重定向攻击的参数包括：

* **client\_uri** - 客户端应用程序主页的 URL
* **policy\_uri** - 依赖方客户端应用程序提供的 URL，以便最终用户可以阅读有关如何使用其个人资料数据的信息。
* **tos\_uri** - 依赖方客户端提供的 URL，以便最终用户可以阅读依赖方的服务条款。
* **initiate\_login\_uri** - 使用 https 方案的 URI，第三方可以用它来启动 RP 的登录。也应该用于客户端重定向。

所有这些参数根据 OAuth 和 OpenID 规范都是 **可选的**，并不总是在特定服务器上得到支持，因此，始终值得识别您的服务器上支持哪些参数。

如果您的目标是 OpenID 服务器，位于 **`.well-known/openid-configuration`** 的发现端点有时包含参数，如 "_registration\_endpoint_"、"_request\_uri\_parameter\_supported_" 和 "_require\_request\_uri\_registration_"。这些可以帮助您找到注册端点和其他服务器配置值。

### 在重定向实现中的 XSS <a href="#bda5" id="bda5"></a>

如这个 bug bounty 报告 [https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html](https://blog.dixitaditya.com/2021/11/19/account-takeover-chain.html) 中提到的，可能的情况是，在用户认证后，重定向 **URL 被反映在服务器的响应中**，从而 **容易受到 XSS 的攻击**。可以测试的有效载荷：
```
https://app.victim.com/login?redirectUrl=https://app.victim.com/dashboard</script><h1>test</h1>
```
### CSRF - 状态参数处理不当 <a href="#bda5" id="bda5"></a>

很多时候，**`state` 参数要么被完全忽略，要么使用方式错误**。如果一个状态参数是**不存在的**，**或者是一个永远不变的静态值**，那么 OAuth 流程很可能会**容易受到 CSRF 攻击**。有时候，即使存在 `state` 参数，**应用程序可能不会对该参数进行任何验证**，攻击就会成功。利用这个漏洞的方法是，在你自己的账户上进行授权过程，并在授权后立即暂停。然后你会遇到这样一个请求：
```
https://yourtweetreader.com?code=asd91j3jd91j92j1j9d1
```
在您收到此请求后，您可以**放弃该请求，因为这些代码通常是一次性使用的**。然后，您可以将此 URL 发送给**已登录用户，它将把您的账户添加到他们的账户中**。起初，这听起来可能不是很敏感，因为您只是将您的账户添加到受害者的账户中。然而，许多 OAuth 实现是用于登录目的，所以如果您可以添加您的 Google 账户用于登录，您可能只需单击一次就能执行**账户接管**，因为使用您的 Google 账户登录将使您能够访问受害者的账户。

您可以在这个[**CTF 写up**](https://github.com/gr455/ctf-writeups/blob/master/hacktivity20/notes\_surfer.md)和名为 Oouch 的**HTB 盒子**中找到一个**例子**。

我还看到 `state` 参数被多次用作额外的重定向值。应用程序将使用 `redirect_uri` 进行初始重定向，但随后将使用 `state` 参数作为第二次重定向，其中可能包含查询参数中的 `code`，或者是 referer 头。

需要注意的一件重要事情是，这不仅仅适用于登录和账户接管类型的情况。我见过的错误配置包括：

* Slack 集成允许攻击者将他们的 Slack 账户添加为所有通知/消息的接收者
* Stripe 集成允许攻击者覆盖支付信息并接受受害者客户的付款
* PayPal 集成允许攻击者将他们的 PayPal 账户添加到受害者的账户中，这将把钱存入攻击者的 PayPal

### 账户接管前 <a href="#ebe4" id="ebe4"></a>

我看到的另一个较常见的问题是，应用程序允许“使用 X 登录”，但也允许用户名/密码。攻击这个问题有两种不同的方法：

1. 如果应用程序**不要求在创建账户时验证电子邮件**，尝试**使用受害者的电子邮件地址和攻击者密码创建账户**，在受害者注册之前。如果**受害者**随后尝试注册或**使用第三方登录**，例如 Google，应用程序可能会进行查找，看到该电子邮件已经注册，然后**将他们的 Google 账户链接到攻击者创建的账户**。这是一种“**账户接管前**”，如果攻击者在受害者注册之前创建了账户，他们将能够访问受害者的账户。
2. 如果**OAuth 应用不要求电子邮件验证**，尝试使用该 OAuth 应用注册，然后将电子邮件地址更改为**受害者的电子邮件地址**。上述相同的问题可能存在，但您将从另一个方向攻击它，并获得对受害者账户的访问权限以进行账户接管。

### 泄露秘密 <a href="#e177" id="e177"></a>

识别**哪些 OAuth 参数是秘密的**并保护它们非常重要。例如，泄露 `client_id` 是完全可以的并且是必要的，但泄露**`client_secret` 是危险的**。如果泄露了，**攻击者**可能会**滥用受信任客户端应用程序的信任和身份，窃取用户 `access_tokens` 和他们集成账户的私人信息/访问权限**。回到我们之前的例子，我看到的一个问题是从客户端而不是服务器执行此步骤：

_5._ [_https://yourtweetreader.com_](https://yourtweetreader.com) _然后将使用该应用程序的 `client_id` 和 `client_secret`，从服务器发出请求以代表您检索 `access_token`，这将允许他们访问您同意的权限。_

**如果这是从客户端完成的，`client_secret` 将被泄露，用户将能够代表应用程序生成 `access_tokens`**。通过一些社会工程学，他们还可以**向 OAuth 授权中添加更多范围**，并且这一切都会显得合法，因为请求将来自受信任的客户端应用程序。

### 客户端秘密暴力破解

您可以尝试**暴力破解服务提供商的 client\_secret**，与身份提供者一起尝试窃取账户。\
BF 请求可能看起来类似于：
```
POST /token HTTP/1.1
content-type: application/x-www-form-urlencoded
host: 10.10.10.10:3000
content-length: 135
Connection: close

code=77515&redirect_uri=http%3A%2F%2F10.10.10.10%3A3000%2Fcallback&grant_type=authorization_code&client_id=public_client_id&client_secret=[bruteforce]
```
### Referer 头泄露 Code + State

一旦客户端拥有了 **code 和 state**，如果在他浏览到不同页面时这些信息被**反射在 Referer 头中**，那么它就是脆弱的。

### 访问令牌存储在浏览器历史记录中

转到**浏览器历史记录并检查访问令牌是否保存在那里**。

### 永久有效的授权码

**授权码应该只存在一段时间，以限制攻击者窃取和使用它的时间窗口**。

### 授权/刷新令牌未绑定到客户端

如果你能获取**授权码并将其与不同的客户端一起使用，那么你可以接管其他账户**。

### 快乐路径、XSS、Iframes 和 Post Messages 泄露 code & state 值

### AWS Cognito <a href="#bda5" id="bda5"></a>

在这个漏洞赏金报告中：[**https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/**](https://security.lauritz-holtmann.de/advisories/flickr-account-takeover/) 你可以看到 **AWS Cognito** 返回给用户的**令牌**可能拥有**足够的权限来覆盖用户数据**。因此，如果你能**将用户电子邮件更改为其他用户的电子邮件**，你可能能够**接管**其他账户。
```bash
# Read info of the user
aws cognito-idp get-user --region us-east-1 --access-token eyJraWQiOiJPVj[...]

# Change email address
aws cognito-idp update-user-attributes --region us-east-1 --access-token eyJraWQ[...] --user-attributes Name=email,Value=imaginary@flickr.com
{
"CodeDeliveryDetailsList": [
{
"Destination": "i***@f***.com",
"DeliveryMedium": "EMAIL",
"AttributeName": "email"
}
]
}
```
有关如何滥用 AWS cognito 的更多详细信息，请查看：

{% embed url="https://cloud.hacktricks.xyz/pentesting-cloud/aws-pentesting/aws-unauthenticated-enum-access/aws-cognito-unauthenticated-enum" %}

### 滥用其他应用的 tokens <a href="#bda5" id="bda5"></a>

如[**这篇文章**](https://salt.security/blog/oh-auth-abusing-oauth-to-take-over-millions-of-accounts)所述，如果 OAuth 流程期望接收**token**（而不是代码），并且没有检查 token 是否属于应用，那么它们可能会受到攻击。

这是因为**攻击者**可以创建一个支持 OAuth 的**应用程序并使用 Facebook 登录**（例如）到他自己的应用程序中。然后，一旦受害者在**攻击者的应用程序**中使用 Facebook 登录，攻击者就可以获取**用户授予他的应用程序的 OAuth token，并使用它登录受害者的 OAuth 应用程序，使用受害者的用户 token**。

{% hint style="danger" %}
因此，如果攻击者设法让用户访问他自己的 OAuth 应用程序，他将能够接管在期望 token 且没有检查 token 是否被授予他们的应用 ID 的应用程序中的受害者账户。
{% endhint %}

### 两个链接 & cookie <a href="#bda5" id="bda5"></a>

根据[**这篇文章**](https://medium.com/@metnew/why-electron-apps-cant-store-your-secrets-confidentially-inspect-option-a49950d6d51f)，可以让受害者打开一个页面，其中的 **returnUrl** 指向攻击者的主机。这些信息将被**存储在 cookie (RU)** 中，并在**后续步骤**中，**提示**会**询问**用户是否愿意授权访问那个攻击者的主机。

为了绕过这个提示，可以打开一个标签页来启动**Oauth 流程**，该流程将使用**returnUrl**设置这个 RU cookie，然后在提示显示之前关闭标签页，并打开一个没有该值的新标签页。然后，**提示不会告知攻击者的主机**，但 cookie 会被设置为它，所以**token 将被发送到攻击者的主机**中进行重定向。

### SSRFs 参数 <a href="#bda5" id="bda5"></a>

你可能会错过的一个隐藏 URL 是**动态客户端注册端点**。为了成功地认证用户，OAuth 服务器需要知道有关客户端应用程序的详细信息，例如 "client\_name"、"client\_secret"、"redirect\_uris" 等。这些细节可以通过本地配置提供，但 OAuth 授权服务器也可能有一个**特殊的注册端点**。这个端点通常映射到 "/register" 并接受以下格式的 POST 请求：
```json
POST /connect/register HTTP/1.1
Content-Type: application/json
Host: server.example.com
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJ ...

{
"application_type": "web",
"redirect_uris": ["https://client.example.org/callback"],
"client_name": "My Example",
"logo_uri": "https://client.example.org/logo.png",
"subject_type": "pairwise",
"sector_identifier_uri": "https://example.org/rdrct_uris.json",
"token_endpoint_auth_method": "client_secret_basic",
"jwks_uri": "https://client.example.org/public_keys.jwks",
"contacts": ["ve7jtb@example.org"],
"request_uris": ["https://client.example.org/rf.txt"]
}
```
以下是定义此请求中参数的两个规范：用于OAuth的[RFC7591](https://tools.ietf.org/html/rfc7591)和[Openid Connect Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html#rfc.section.3.1)。

如您所见，这里有许多值通过URL引用传递，并且看起来像是[服务器端请求伪造](https://portswigger.net/web-security/ssrf)的潜在目标。同时，我们测试过的大多数服务器在接收注册请求时并不立即解析这些URL。相反，它们只是**保存这些参数并在OAuth授权流程中稍后使用它们**。换句话说，这更像是二阶SSRF，这使得黑盒检测更加困难。

以下参数对于SSRF攻击特别有趣：

* **logo\_uri** - 引用**客户端应用程序的logo**的URL。**注册客户端后**，您可以尝试使用新的"client\_id"调用OAuth授权端点("/authorize")。登录后，服务器将要求您批准请求，并**可能会显示来自"logo\_uri"的图像**。如果**服务器自己获取图像**，则应该在此步骤触发SSRF。或者，服务器可能只是通过**客户端的"<img>"标签**包含logo。虽然这不会导致SSRF，但如果URL未转义，可能会导致**XSS**。
*   **jwks\_uri** - 客户端的JSON Web Key Set \[JWK]文档的URL。服务器需要这个密钥集来验证使用JWT进行客户端认证时对令牌端点发出的签名请求\[RFC7523]。为了测试此参数中的SSRF，**注册一个带有恶意"jwks\_uri"的新客户端应用程序**，执行授权过程以**获取任何用户的授权码，然后使用以下正文获取"/token"端点**：

`POST /oauth/token HTTP/1.1`\
`...`\
\`\`\
`grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer&client_assertion=eyJhbGci...`

如果存在漏洞，**服务器应该执行对提供的"jwks\_uri"的服务器到服务器HTTP请求**，因为它需要这个密钥来检查您请求中的"client\_assertion"参数的有效性。这可能只是一个**盲目的SSRF漏洞**，因为服务器期望一个正确的JSON响应。
* **sector\_identifier\_uri** - 此URL引用一个包含单个**JSON数组的redirect\_uri值**的文件。如果支持，服务器可能**在您提交动态注册请求后立即获取此值**。如果不是立即获取，请尝试在服务器上为此客户端执行授权。由于它需要知道redirect\_uris以完成授权流程，这将迫使服务器向您的恶意sector\_identifier\_uri发出请求。
*   **request\_uris** - 此客户端**允许的request\_uris数组**。授权端点可能支持"request\_uri"参数，以提供包含请求信息的JWT的URL（参见[https://openid.net/specs/openid-connect-core-1\_0.html#rfc.section.6.2](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.6.2)）。

即使动态客户端注册未启用，或者它需要认证，我们也可以简单地使用"request\_uri"在授权端点上尝试执行SSRF：\\

`GET /authorize?response_type=code%20id_token&client_id=sclient1&request_uri=https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt`

注意：不要将此参数与"redirect\_uri"混淆。"redirect\_uri"用于授权后的重定向，而**"request\_uri"是服务器在授权过程开始时获取的**。

同时，我们看到的许多服务器不允许任意的"request\_uri"值：它们只允许在客户端注册过程中预先注册的白名单URL。这就是为什么我们需要事先提供"request\_uris": "https://ybd1rc7ylpbqzygoahtjh6v0frlh96.burpcollaborator.net/request.jwt"。

## OAuth提供商的竞态条件

如果您正在测试的平台是OAuth提供商[**阅读此内容以测试可能的竞态条件**](race-condition.md)。

## 参考资料

* [**https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1**](https://medium.com/a-bugz-life/the-wondeful-world-of-oauth-bug-bounty-edition-af3073b354c1)
* [**https://portswigger.net/research/hidden-oauth-attack-vectors**](https://portswigger.net/research/hidden-oauth-attack-vectors)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客攻击！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方的PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>
