# Upgrade de Header Smuggling

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas t√©cnicas de hacking enviando PRs para o [reposit√≥rio hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

### HTTP2 Sobre Texto Claro (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

Uma conex√£o HTTP normalmente dura apenas durante a dura√ß√£o de uma √∫nica solicita√ß√£o. No entanto, H2C ou "**http2 sobre texto claro**" √© onde uma conex√£o http normal transit√≥ria √© atualizada para uma conex√£o persistente que usa o protocolo bin√°rio http2 para se comunicar continuamente em vez de uma solicita√ß√£o usando o protocolo http em texto simples.

A segunda parte do smuggling ocorre quando um **proxy reverso √© usado**. Normalmente, quando solicita√ß√µes http s√£o feitas a um proxy reverso, o proxy lidar√° com a solicita√ß√£o, processar√° uma s√©rie de regras de roteamento, encaminhar√° a solicita√ß√£o para o backend e, em seguida, retornar√° a resposta. Quando uma solicita√ß√£o http inclui um cabe√ßalho `Connection: Upgrade`, como para uma conex√£o websocket, o **proxy reverso manter√° a conex√£o persistente** entre o cliente e o servidor, **permitindo a comunica√ß√£o cont√≠nua necess√°ria para esses protocolos**. Para uma conex√£o H2C, o RFC requer que 3 cabe√ßalhos estejam presentes:
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
Ent√£o, onde est√° o bug? **Ao atualizar uma conex√£o, o proxy reverso frequentemente deixar√° de lidar com solicita√ß√µes individuais**, assumindo que, uma vez estabelecida a conex√£o, seu trabalho de roteamento est√° conclu√≠do. Usando o H2C Smuggling, podemos contornar as regras que um proxy reverso usa ao processar solicita√ß√µes, como roteamento baseado em caminho, autentica√ß√£o ou processamento WAF, desde que possamos estabelecer uma conex√£o H2C primeiro.

![](<../.gitbook/assets/image (454).png>)

### Proxies Vulner√°veis <a href="#exploitation" id="exploitation"></a>

Observe a explica√ß√£o da vulnerabilidade que o servidor proxy precisa **encaminhar o cabe√ßalho Upgrade**, e √†s vezes o **cabe√ßalho Connection** tamb√©m precisa ser encaminhado com sucesso.

Por padr√£o, os seguintes servi√ßos **encaminham** o **Upgrade** e os cabe√ßalhos **Connection** durante o proxy-pass, permitindo assim o h2c smuggling out-of-the-box:

* HAProxy
* Traefik
* Nuster

Por padr√£o, esses servi√ßos **n√£o** encaminham ambos os cabe√ßalhos Upgrade e Connection durante o proxy-pass, mas **podem ser configurados de maneira insegura** (passando cabe√ßalhos Upgrade e Connection n√£o filtrados):

* AWS ALB/CLB
* NGINX
* Apache
* Squid
* Varnish
* Kong
* Envoy
* Apache Traffic Server

### Explora√ß√£o <a href="#exploitation" id="exploitation"></a>

A postagem original do blog aponta que nem todos os servidores encaminhar√£o os cabe√ßalhos necess√°rios para uma atualiza√ß√£o de conex√£o H2C compat√≠vel. Isso significa que balanceadores de carga como AWS ALB/CLB, NGINX e Apache Traffic Server, entre outros, **impedir√£o uma conex√£o H2C por padr√£o**. No entanto, no final da postagem do blog, ele menciona que "nem todos os back-ends eram compat√≠veis, e poder√≠amos **testar com a variante n√£o compat√≠vel `Connection: Upgrade`, em que o valor `HTTP2-Settings` √© omitido do cabe√ßalho `Connection`**".

{% hint style="danger" %}
Observe que, mesmo que a URL de `proxy_pass` (o ponto final para o qual o proxy encaminha a conex√£o) aponte para um **caminho** espec√≠fico, como `http://backend:9999/socket.io`, a conex√£o ser√° estabelecida com `http://backend:9999`, para que voc√™ possa **acessar qualquer outro caminho dentro desse endpoint interno abusando dessa t√©cnica. Portanto, n√£o importa se um caminho √© especificado na URL de proxy\_pass.**
{% endhint %}

Usando as ferramentas [**https://github.com/BishopFox/h2csmuggler**](https://github.com/BishopFox/h2csmuggler) **e** [**https://github.com/assetnote/h2csmuggler**](https://github.com/assetnote/h2csmuggler), voc√™ pode tentar **contornar as prote√ß√µes impostas** pelo proxy estabelecendo uma conex√£o H2C e acessar recursos protegidos pelo proxy.

Siga este link para [**mais informa√ß√µes sobre essa vulnerabilidade no Nginx**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection).

## Smuggling de Websocket

Semelhante √† t√©cnica anterior, esta **em vez disso** de criar um **t√∫nel HTTP2** para um endpoint acess√≠vel por meio de um proxy, criar√° um **t√∫nel Websocket** para o mesmo prop√≥sito, **contornando as limita√ß√µes potenciais dos proxies** e falando diretamente com o endpoint:

![](<../.gitbook/assets/image (651) (2) (1).png>)

### Cen√°rio 1

Temos um backend que exp√µe uma **API WebSocket p√∫blica** e tamb√©m tem uma **API REST interna n√£o dispon√≠vel** externamente. Um cliente mal-intencionado deseja acessar a API REST interna.

No **primeiro** passo, o cliente envia uma **solicita√ß√£o de atualiza√ß√£o** para o proxy reverso, mas com uma **vers√£o de protocolo incorreta** dentro do cabe√ßalho `Sec-WebSocket-Version`. O **proxy** n√£o valida o cabe√ßalho `Sec-WebSocket-Version` e pensa que a **solicita√ß√£o de atualiza√ß√£o est√° correta**. Al√©m disso, ele traduz a solicita√ß√£o para o backend.

No segundo passo, o backend envia **resposta com o c√≥digo de status `426` porque a vers√£o do protocolo est√° incorreta** dentro do cabe√ßalho `Sec-WebSocket-Version`. No entanto, o **proxy reverso n√£o verifica** a resposta suficiente do backend (incluindo o c√≥digo de status) e **pensa que o backend est√° pronto para a comunica√ß√£o WebSocket**. Al√©m disso, ele traduz a solicita√ß√£o para o cliente.

Finalmente, o **proxy reverso pensa** que a **conex√£o WebSocket est√° estabelecida entre o cliente e o backend**. Na realidade, n√£o h√° conex√£o WebSocket - o backend recusou a solicita√ß√£o de atualiza√ß√£o. Ao mesmo tempo, o proxy mant√©m a conex√£o TCP ou TLS entre o cliente e o backend em estado aberto. **O cliente pode facilmente acessar a API REST privada enviando uma solicita√ß√£o HTTP sobre a conex√£o.**

![](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

Foi descoberto que os seguintes proxies reversos s√£o afetados:

* Varnish - a equipe se recusou a corrigir o problema descrito.
* Envoy proxy 1.8.0 (ou mais antigo) - em vers√µes mais recentes, o mecanismo de atualiza√ß√£o foi alterado.
* Outros - TBA.

### Cen√°rio 2

A maioria dos proxies reversos (por exemplo, NGINX) **verifica o c√≥digo de status do backend** durante a parte de handshake. Isso torna o ataque mais dif√≠cil, mas n√£o imposs√≠vel.

Vamos observar o segundo cen√°rio. Temos um backend que exp√µe uma API WebSocket p√∫blica e uma API REST p√∫blica para verifica√ß√£o de integridade e tamb√©m tem uma **API REST interna n√£o dispon√≠vel** externamente. Um cliente mal-intencionado deseja acessar a API REST interna. O NGINX √© usado como proxy reverso. A API WebSocket est√° dispon√≠vel no caminho `/api/socket.io/` e a API de verifica√ß√£o de integridade no caminho `/api/health`.

A API de verifica√ß√£o de integridade √© invocada enviando uma solicita√ß√£o POST, o par√¢metro com o nome `u` controla a URL. O backend alcan√ßa o recurso externo e retorna o c√≥digo de status de volta ao cliente.

No **primeiro** passo, o cliente envia uma solicita√ß√£o POST para invocar a **API de verifica√ß√£o de integridade, mas com um cabe√ßalho HTTP adicional `Upgrade: websocket`**. O NGINX pensa que √© uma **solicita√ß√£o de atualiza√ß√£o normal**, ele procura apenas o cabe√ßalho `Upgrade`, ignorando outras partes da solicita√ß√£o. Al√©m disso, o proxy traduz a solicita√ß√£o para o backend.

No **segundo** passo, o backend invoca a API de verifica√ß√£o de integridade. Ele alcan√ßa o recurso externo controlado por usu√°rios mal-intencionados que retorna a **resposta HTTP com o c√≥digo de status `101`**. O backend traduz essa resposta para o proxy reverso. Como o NGINX valida apenas o c√≥digo de status, **ele pensar√° que o backend est√° pronto para a comunica√ß√£o WebSocket**.
