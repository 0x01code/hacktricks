# 헤더 스머글링 업그레이드

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **Hacking 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 저장소에 제출**하세요.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 더 빠르게 수정하세요. Intruder는 공격 대상을 추적하고 적극적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) 오늘.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## H2C 스머글링 <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

### HTTP2 Over Cleartext (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C 또는 **http2 over cleartext**는 일반적인 HTTP 연결을 **지속적인 연결**로 업그레이드하여 일시적인 HTTP 연결의 표준에서 벗어납니다. 이 업그레이드된 연결은 지속적인 통신을 위해 http2 이진 프로토콜을 사용하며 평문 HTTP의 단일 요청 방식과는 다릅니다.

스머글링 문제의 핵심은 **리버스 프록시**의 사용입니다. 일반적으로 리버스 프록시는 HTTP 요청을 처리하고 백엔드로 전달한 다음 백엔드의 응답을 반환합니다. 그러나 HTTP 요청에 `Connection: Upgrade` 헤더가 포함되어 있는 경우 (웹소켓 연결과 함께 자주 볼 수 있음), 리버스 프록시는 클라이언트와 서버 사이에 **지속적인 연결을 유지**하여 특정 프로토콜에서 필요한 지속적인 교환을 용이하게 합니다. H2C 연결의 경우 RFC 준수를 위해 세 가지 특정 헤더가 있어야 합니다:
``` 
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
취약점은 연결을 업그레이드 한 후에, 리버스 프록시가 개별 요청을 처리하는 것을 중단하고 라우팅 작업이 연결 설정 후에 완료되었다고 가정할 때 발생합니다. H2C 스머글링을 악용하면 H2C 연결이 성공적으로 시작된 경우 요청 처리 중에 적용된 리버스 프록시 규칙, 예를 들어 경로 기반 라우팅, 인증 및 WAF 처리를 우회할 수 있습니다.

### 취약한 프록시 <a href="#exploitation" id="exploitation"></a>

취약점은 리버스 프록시가 `Upgrade` 및 때로는 `Connection` 헤더를 처리하는 방식에 따라 달라집니다. 다음 프록시는 프록시 패스 중에 이러한 헤더를 기본적으로 전달하여 H2C 스머글링을 자동으로 활성화합니다.

- HAProxy
- Traefik
- Nuster

반대로, 다음 서비스는 프록시 패스 중에 두 헤더를 기본적으로 전달하지 않습니다. 그러나 불안전하게 구성되어 `Upgrade` 및 `Connection` 헤더를 무제한으로 전달할 수 있습니다.

- AWS ALB/CLB
- NGINX
- Apache
- Squid
- Varnish
- Kong
- Envoy
- Apache Traffic Server

### 악용 <a href="#exploitation" id="exploitation"></a>

준수하는 H2C 연결 업그레이드에 필요한 헤더를 기본적으로 전달하는 서버는 모두 아니라는 점을 주목해야 합니다. 따라서 AWS ALB/CLB, NGINX 및 Apache Traffic Server 등의 서버는 H2C 연결을 차단합니다. 그러나 일부 백엔드가 표준에 준수하지 않는 `Connection: Upgrade` 변형으로 테스트하는 것이 좋습니다. 이 경우 `Connection` 헤더에서 `HTTP2-Settings` 값을 제외합니다. 일부 백엔드는 표준을 준수하지 않을 수 있습니다.

{% hint style="danger" %}
`proxy_pass` URL에서 지정된 특정 **경로** (예: `http://backend:9999/socket.io`)와 관계없이 설정된 연결은 기본적으로 `http://backend:9999`로 설정됩니다. 이를 통해 이 기술을 활용하여 해당 내부 엔드포인트 내의 모든 경로와 상호 작용할 수 있습니다. 따라서 `proxy_pass` URL에서 경로를 지정하는 것은 액세스를 제한하지 않습니다.
{% endhint %}

[**h2csmuggler by BishopFox**](https://github.com/BishopFox/h2csmuggler) 및 [**h2csmuggler by assetnote**](https://github.com/assetnote/h2csmuggler) 도구를 사용하면 H2C 연결을 설정하여 프록시가 적용한 보호 기능을 우회하여 프록시로 보호된 리소스에 액세스할 수 있습니다.

특히 NGINX에 대한 자세한 정보는 [**이 자세한 리소스**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection)를 참조하십시오.

# 웹소켓 스머글링

웹소켓 스머글링은 프록시를 통해 액세스할 수 있는 엔드포인트로의 HTTP2 터널을 생성하는 것과 달리, 웹소켓 터널을 생성하여 프록시 제한을 우회하고 엔드포인트와 직접 통신하는 것입니다.

## 시나리오 1

이 시나리오에서는 공개 WebSocket API와 접근할 수 없는 내부 REST API를 제공하는 백엔드가 악의적인 클라이언트의 대상이 됩니다. 클라이언트는 내부 REST API에 액세스하기 위해 다음과 같은 단계를 거쳐 공격을 수행합니다.

1. 클라이언트는 헤더의 잘못된 `Sec-WebSocket-Version` 프로토콜 버전을 포함한 업그레이드 요청을 리버스 프록시에 보냅니다. 리버스 프록시는 `Sec-WebSocket-Version` 헤더를 유효성 검사하지 못하고 업그레이드 요청을 유효하다고 판단하고 백엔드로 전달합니다.
2. 백엔드는 `Sec-WebSocket-Version` 헤더에 잘못된 프로토콜 버전이 포함되어 있음을 나타내는 상태 코드 `426`로 응답합니다. 리버스 프록시는 백엔드의 응답 상태를 무시하고 WebSocket 통신이 준비되었다고 가정하고 응답을 클라이언트로 전달합니다.
3. 결과적으로, 리버스 프록시는 클라이언트와 백엔드 간에 WebSocket 연결이 설정된 것으로 오해합니다. 하지만 실제로는 백엔드가 업그레이드 요청을 거부했습니다. 그럼에도 불구하고 프록시는 클라이언트와 백엔드 간에 열린 TCP 또는 TLS 연결을 유지하여 클라이언트가 이 연결을 통해 비공개 REST API에 제한 없이 액세스할 수 있도록 합니다.

영향을 받는 리버스 프록시에는 이 문제를 해결하지 않은 Varnish와 Envoy 프록시 버전 1.8.0 이전 버전이 포함되며, 이후 버전에서는 업그레이드 메커니즘이 변경되었을 수 있습니다. 다른 프록시도 취약할 수 있습니다.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

## 시나리오 2

이 시나리오에서는 공개 WebSocket API와 공개 REST API(헬스 체크용) 및 접근할 수 없는 내부 REST API를 제공하는 백엔드가 포함됩니다. 이 공격은 다음과 같은 단계를 거쳐 진행됩니다.

1. 클라이언트는 헬스 체크 API를 트리거하기 위해 POST 요청을 보냅니다. 이 요청에는 추가적인 HTTP 헤더 `Upgrade: websocket`이 포함됩니다. 리버스 프록시로 작동하는 NGINX는 이를 `Upgrade` 헤더만으로 표준적인 업그레이드 요청으로 해석하고 요청의 다른 측면을 무시하고 백엔드로 전달합니다.
2. 백엔드는 헬스 체크 API를 실행하여 공격자가 제어하는 외부 리소스에 도달하고 상태 코드 `101`을 반환하는 HTTP 응답을 받습니다. 이 응답은 백엔드에게 전달되고 NGINX로 전달되면서 프록시를 속이고 상태 코드만을 확인하여 WebSocket 연결이 설정된 것으로 오해하게
