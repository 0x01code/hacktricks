# Upgrade Header Smuggling

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

### H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

#### HTTP2 √ºber Klartext (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C oder **http2 √ºber Klartext** weicht von der Norm transienter HTTP-Verbindungen ab, indem es eine Standard-HTTP-Verbindung **auf eine persistente** aktualisiert. Diese aktualisierte Verbindung verwendet das bin√§re http2-Protokoll f√ºr die fortlaufende Kommunikation, im Gegensatz zur einmaligen Anfrage von Klartext-HTTP.

Der Kern des Schmuggelproblems entsteht durch die Verwendung eines **Reverse-Proxys**. Normalerweise verarbeitet der Reverse-Proxy HTTP-Anfragen und leitet sie an das Backend weiter, um anschlie√üend die Antwort des Backends zur√ºckzugeben. Wenn jedoch der Header `Connection: Upgrade` in einer HTTP-Anfrage vorhanden ist (√ºblicherweise bei WebSocket-Verbindungen zu sehen), **pflegt der Reverse-Proxy eine persistente Verbindung** zwischen Client und Server, um den kontinuierlichen Austausch zu erm√∂glichen, der von bestimmten Protokollen ben√∂tigt wird. F√ºr H2C-Verbindungen erfordert die Einhaltung des RFC das Vorhandensein von drei spezifischen Headern:
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
Die Schwachstelle tritt auf, wenn der Reverse-Proxy nach einem Verbindungsupgrade aufh√∂rt, einzelne Anfragen zu verwalten und davon ausgeht, dass seine Routing-Aufgabe nach der Verbindungseinrichtung abgeschlossen ist. Die Ausnutzung von H2C Smuggling erm√∂glicht die Umgehung von Reverse-Proxy-Regeln, die w√§hrend der Anfrageverarbeitung angewendet werden, wie z. B. routingbasiertes Routing, Authentifizierung und WAF-Verarbeitung, vorausgesetzt, dass eine H2C-Verbindung erfolgreich hergestellt wurde.

#### Anf√§llige Proxies <a href="#exploitation" id="exploitation"></a>

Die Schwachstelle h√§ngt von der Behandlung der `Upgrade`- und manchmal `Connection`-Header durch den Reverse-Proxy ab. Die folgenden Proxies leiten diese Header w√§hrend des Proxy-Passes inh√§rent weiter, was H2C Smuggling inh√§rent erm√∂glicht:

* HAProxy
* Traefik
* Nuster

Im Gegensatz dazu leiten diese Dienste die beiden Header w√§hrend des Proxy-Passes nicht inh√§rent weiter. Sie k√∂nnen jedoch unsicher konfiguriert sein und das ungefilterte Weiterleiten von `Upgrade`- und `Connection`-Headern erm√∂glichen:

* AWS ALB/CLB
* NGINX
* Apache
* Squid
* Varnish
* Kong
* Envoy
* Apache Traffic Server

#### Ausnutzung <a href="#exploitation" id="exploitation"></a>

Es ist wichtig zu beachten, dass nicht alle Server die f√ºr ein konformes H2C-Verbindungsupgrade erforderlichen Header inh√§rent weiterleiten. Daher blockieren Server wie AWS ALB/CLB, NGINX und Apache Traffic Server nat√ºrlicherweise H2C-Verbindungen. Es ist dennoch sinnvoll, es mit der nicht konformen `Connection: Upgrade`-Variante zu testen, die den Wert `HTTP2-Settings` aus dem `Connection`-Header ausschlie√üt, da einige Backends m√∂glicherweise nicht den Standards entsprechen.

{% hint style="danger" %}
Unabh√§ngig vom spezifischen **Pfad**, der in der `proxy_pass`-URL festgelegt ist (z. B. `http://backend:9999/socket.io`), wird die hergestellte Verbindung standardm√§√üig auf `http://backend:9999` zur√ºckgesetzt. Dies erm√∂glicht die Interaktion mit jedem Pfad innerhalb dieses internen Endpunkts unter Verwendung dieser Technik. Folglich beschr√§nkt die Angabe eines Pfads in der `proxy_pass`-URL nicht den Zugriff.
{% endhint %}

Die Tools [**h2csmuggler von BishopFox**](https://github.com/BishopFox/h2csmuggler) und [**h2csmuggler von assetnote**](https://github.com/assetnote/h2csmuggler) erleichtern Versuche, **von Proxys auferlegte Schutzma√ünahmen zu umgehen**, indem eine H2C-Verbindung hergestellt wird, wodurch der Zugriff auf Ressourcen erm√∂glicht wird, die durch den Proxy gesch√ºtzt sind.

F√ºr weitere Informationen zu dieser Schwachstelle, insbesondere zu NGINX, siehe [**diese ausf√ºhrliche Ressource**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection).

## Websocket Smuggling

Im Gegensatz zur Erstellung eines HTTP2-Tunnels zu einem √ºber einen Proxy erreichbaren Endpunkt richtet Websocket Smuggling einen Websocket-Tunnel ein, um potenzielle Proxy-Einschr√§nkungen zu umgehen und die direkte Kommunikation mit dem Endpunkt zu erleichtern.

### Szenario 1

In diesem Szenario zielt ein b√∂sartiger Client auf einen Backend ab, der eine √∂ffentliche WebSocket-API neben einer nicht zug√§nglichen internen REST-API anbietet. Der Angriff erfolgt in mehreren Schritten:

1. Der Client initiiert, indem er eine Upgrade-Anfrage an den Reverse-Proxy mit einer falschen `Sec-WebSocket-Version`-Protokollversion im Header sendet. Der Proxy, der den `Sec-WebSocket-Version`-Header nicht validiert, h√§lt die Upgrade-Anfrage f√ºr g√ºltig und leitet sie an das Backend weiter.
2. Das Backend antwortet mit dem Statuscode `426`, der die falsche Protokollversion im `Sec-WebSocket-Version`-Header angibt. Der Reverse-Proxy, der den Antwortstatus des Backends √ºbersieht, geht davon aus, dass die WebSocket-Kommunikation bereit ist und leitet die Antwort an den Client weiter.
3. Folglich wird der Reverse-Proxy in die Irre gef√ºhrt und glaubt, dass eine WebSocket-Verbindung zwischen Client und Backend hergestellt wurde, w√§hrend das Backend tats√§chlich die Upgrade-Anfrage abgelehnt hat. Trotzdem unterh√§lt der Proxy eine offene TCP- oder TLS-Verbindung zwischen Client und Backend, was dem Client uneingeschr√§nkten Zugriff auf die private REST-API √ºber diese Verbindung erm√∂glicht.

Betroffene Reverse-Proxys sind Varnish, die sich weigerten, das Problem anzugehen, und Envoy-Proxy Version 1.8.0 oder √§lter, wobei sp√§tere Versionen den Upgrade-Mechanismus ge√§ndert haben. Andere Proxys k√∂nnen ebenfalls anf√§llig sein.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

### Szenario 2

Dieses Szenario betrifft ein Backend mit einer √∂ffentlichen WebSocket-API und einer √∂ffentlichen REST-API f√ºr die Gesundheitspr√ºfung sowie einer nicht zug√§nglichen internen REST-API. Der komplexere Angriff umfasst die folgenden Schritte:

1. Der Client sendet eine POST-Anfrage, um die Health-Check-API auszul√∂sen, und f√ºgt einen zus√§tzlichen HTTP-Header `Upgrade: websocket` hinzu. NGINX, der als Reverse-Proxy fungiert, interpretiert dies als Standard-Upgrade-Anfrage basierend ausschlie√ülich auf dem `Upgrade`-Header, ohne die anderen Aspekte der Anfrage zu ber√ºcksichtigen, und leitet sie an das Backend weiter.
2. Das Backend f√ºhrt die Health-Check-API aus und greift auf eine vom Angreifer kontrollierte externe Ressource zu, die eine HTTP-Antwort mit dem Statuscode `101` zur√ºckgibt. Diese Antwort, sobald sie vom Backend empfangen und an NGINX weitergeleitet wird, t√§uscht den Proxy, da er nur den Statuscode validiert, in den Glauben, dass eine WebSocket-Verbindung aufgrund des Statuscodes hergestellt wurde.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

> **Warnung:** Die Komplexit√§t dieser Technik steigt, da sie die F√§higkeit erfordert, mit einem Endpunkt zu interagieren, der einen Statuscode 101 zur√ºckgeben kann.

Letztendlich wird NGINX get√§uscht und glaubt, dass eine WebSocket-Verbindung zwischen Client und Backend besteht. In Wirklichkeit besteht keine solche Verbindung; die Health-Check-REST-API war das Ziel. Dennoch h√§lt der Reverse-Proxy die Verbindung offen, was es dem Client erm√∂glicht, √ºber sie auf die private REST-API zuzugreifen.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png)

Die meisten Reverse-Proxys sind anf√§llig f√ºr dieses Szenario, aber die Ausnutzung h√§ngt von einem externen SSRF-Schwachstellen ab, die in der Regel als geringf√ºgiges Problem angesehen wird.

#### Labs

√úberpr√ºfen Sie die Labs, um beide Szenarien unter [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git) zu testen.

### Referenzen

* [https://blog.assetnote.io/2021/03/18/h2c-smuggling/](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
* [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
* [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)


**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
