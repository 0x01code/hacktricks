# Actualizaci√≥n de Header Smuggling

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!

- Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)

- **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Comparte tus trucos de hacking enviando PR al [repositorio de hacktricks](https://github.com/carlospolop/hacktricks) y al [repositorio de hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>

## H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

### HTTP2 sobre texto claro (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

Una conexi√≥n HTTP normalmente dura solo durante la duraci√≥n de una sola solicitud. Sin embargo, H2C o "**http2 sobre texto claro**" es donde una conexi√≥n http transitoria normal se actualiza a una conexi√≥n persistente que utiliza el protocolo binario http2 para comunicarse continuamente en lugar de una solicitud utilizando el protocolo http en texto plano.

La segunda parte del smuggling ocurre cuando se utiliza un **proxy inverso**. Normalmente, cuando se realizan solicitudes http a un proxy inverso, el proxy manejar√° la solicitud, procesar√° una serie de reglas de enrutamiento, luego reenviar√° la solicitud al backend y luego devolver√° la respuesta. Cuando una solicitud http incluye un encabezado `Connection: Upgrade`, como para una conexi√≥n websocket, el proxy inverso mantendr√° la conexi√≥n persistente entre el cliente y el servidor, lo que permite la comunicaci√≥n continua necesaria para estos protocolos. Para una conexi√≥n H2C, el RFC requiere que est√©n presentes 3 encabezados:
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
¬øD√≥nde est√° el error? **Al actualizar una conexi√≥n, el proxy inverso a menudo dejar√° de manejar solicitudes individuales**, asumiendo que una vez que se ha establecido la conexi√≥n, su trabajo de enrutamiento est√° hecho. Usando H2C Smuggling, podemos evitar las reglas que un proxy inverso usa al procesar solicitudes, como el enrutamiento basado en la ruta, la autenticaci√≥n o el procesamiento de WAF, siempre que podamos establecer una conexi√≥n H2C primero.

![](<../.gitbook/assets/image (454).png>)

### Proxies Vulnerables <a href="#exploitation" id="exploitation"></a>

Tenga en cuenta que, seg√∫n la explicaci√≥n de la vulnerabilidad, el servidor proxy necesita **reenviar el encabezado Upgrade**, y a veces tambi√©n es necesario reenviar el **encabezado Connection** con √©xito.

Por defecto, los siguientes servicios **s√≠** reenv√≠an **Upgrade** y **Connection headers** durante el proxy-pass, lo que permite la h2c smuggling de manera predeterminada:

* HAProxy
* Traefik
* Nuster

Por defecto, estos servicios **no** reenv√≠an ambos encabezados Upgrade y Connection durante el proxy-pass, pero **se pueden configurar de manera insegura** (pasando encabezados Upgrade y Connection sin filtrar):

* AWS ALB/CLB
* NGINX
* Apache
* Squid
* Varnish
* Kong
* Envoy
* Apache Traffic Server

### Explotaci√≥n <a href="#exploitation" id="exploitation"></a>

La publicaci√≥n original del blog se√±ala que no todos los servidores reenviar√°n los encabezados necesarios para una actualizaci√≥n de conexi√≥n H2C compatible. Esto significa que los equilibradores de carga como AWS ALB/CLB, NGINX y Apache Traffic Server, entre otros, **impedir√°n una conexi√≥n H2C por defecto**. Sin embargo, al final de la publicaci√≥n del blog, menciona que "no todos los backends eran compatibles, y podr√≠amos **probar con la variante no compatible `Connection: Upgrade`, donde se omite el valor `HTTP2-Settings` del encabezado `Connection`**".

{% hint style="danger" %}
Tenga en cuenta que incluso si la URL de `proxy_pass` (el punto final al que el proxy reenv√≠a la conexi√≥n) apuntaba a una **ruta** espec√≠fica, como `http://backend:9999/socket.io`, la conexi√≥n se establecer√° con `http://backend:9999`, por lo que puede **contactar cualquier otra ruta dentro de ese punto final interno abusando de esta t√©cnica. Por lo tanto, no importa si se especifica una ruta en la URL de proxy_pass.**
{% endhint %}

Usando las herramientas [**https://github.com/BishopFox/h2csmuggler**](https://github.com/BishopFox/h2csmuggler) **y** [**https://github.com/assetnote/h2csmuggler**](https://github.com/assetnote/h2csmuggler), puede intentar **evadir las protecciones impuestas** por el proxy estableciendo una conexi√≥n H2C y acceder a los recursos protegidos por el proxy.

Siga este enlace para obtener [**m√°s informaci√≥n sobre esta vulnerabilidad en Nginx**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection).

## Smuggling de Websocket

Similar a la t√©cnica anterior, esta **en lugar de crear un t√∫nel HTTP2** a un punto final accesible a trav√©s de un proxy, crear√° un **t√∫nel Websocket** con el mismo prop√≥sito, **evadiendo las limitaciones potenciales de los proxies** y hablando directamente con el punto final:

![](<../.gitbook/assets/image (651) (2) (1).png>)

### Escenario 1

Tenemos un backend que expone una **API WebSocket p√∫blica** y tambi√©n tiene una **API REST interna no disponible** desde el exterior. Un cliente malintencionado quiere acceder a la API REST interna.

En el **primer** paso, el cliente env√≠a una **solicitud de actualizaci√≥n** al proxy inverso, pero con una **versi√≥n de protocolo incorrecta** dentro del encabezado `Sec-WebSocket-Version`. El **proxy** no valida el encabezado `Sec-WebSocket-Version` y cree que la **solicitud de actualizaci√≥n es correcta**. Luego, traduce la solicitud al backend.

En el segundo paso, el backend env√≠a una **respuesta con el c√≥digo de estado `426` porque la versi√≥n del protocolo es incorrecta** dentro del encabezado `Sec-WebSocket-Version`. Sin embargo, el **proxy inverso no verifica** suficientemente la respuesta del backend (incluido el c√≥digo de estado) y **cree que el backend est√° listo para la comunicaci√≥n WebSocket**. Luego, traduce la solicitud al cliente.

Finalmente, el **proxy inverso cree** que se ha establecido una **conexi√≥n WebSocket entre el cliente y el backend**. En realidad, no hay una conexi√≥n WebSocket: el backend rechaz√≥ la solicitud de actualizaci√≥n. Al mismo tiempo, el proxy mantiene la conexi√≥n TCP o TLS entre el cliente y el backend en estado abierto. **El cliente puede acceder f√°cilmente a la API REST privada enviando una solicitud HTTP a trav√©s de la conexi√≥n.**

![](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

Se descubri√≥ que los siguientes proxies inversos se ven afectados:

* Varnish - el equipo se neg√≥ a solucionar el problema descrito.
* Envoy proxy 1.8.0 (o anterior) - en versiones m√°s nuevas, el mecanismo de actualizaci√≥n ha cambiado.
* Otros - TBA.

### Escenario 2

La mayor√≠a de los proxies inversos (por ejemplo, NGINX) **verifican el c√≥digo de estado del backend** durante la parte de handshake. Esto hace que el ataque sea m√°s dif√≠cil pero no imposible.

Observemos el segundo escenario. Tenemos un backend que expone una **API WebSocket p√∫blica** y una **API REST p√∫blica para la comprobaci√≥n de salud** y tambi√©n tiene una **API REST interna no disponible** desde el exterior. Un cliente malintencionado quiere acceder a la API REST interna. Se utiliza NGINX como proxy inverso. La API WebSocket est√° disponible en la ruta `/api/socket.io/` y la API de comprobaci√≥n de salud en la ruta `/api/health`.

La API de comprobaci√≥n de salud se invoca enviando una solicitud POST, el par√°metro con el nombre `u` controla la URL. El backend alcanza el recurso externo y devuelve el c√≥digo de estado al cliente.

En el **primer** paso, el cliente env√≠a una solicitud POST para invocar la **API de comprobaci√≥n de salud pero con un encabezado HTTP adicional `Upgrade: websocket`**. NGINX cree que es una **solicitud de actualizaci√≥n normal**, solo busca el encabezado `Upgrade` omitiendo otras partes de la solicitud. Luego, el proxy traduce la solicitud al backend.

En el **segundo** paso, el backend invoca la API de comprobaci√≥n de salud. Alcanza el recurso externo controlado por usuarios malintencionados que devuelve una **respuesta HTTP con el c√≥digo de estado `101`**. El backend traduce esa respuesta al proxy inverso. Dado que NGINX valida solo el c√≥digo de estado, **creer√° que el backend est√° listo para la comunicaci√≥n WebSocket**. Luego, traduce la solicitud al cliente.

![](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

{% hint style="warning" %}
Observe c√≥mo este escenario es mucho m√°s complejo de explotar, ya que debe poder contactar alg√∫n punto final que **devuelva el c√≥digo de estado 101**.
{% endhint %}

Finalmente, **NGINX cree que se ha establecido
