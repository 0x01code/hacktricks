# ヘッダースマグリングのアップグレード

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>でゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい** 場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live) をフォローする**
* **ハッキングトリックを共有するために、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

### H2Cスマグリング <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

#### クリアテキスト上のHTTP2（H2C） <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C、または **クリアテキスト上のhttp2** は、標準のHTTP **接続を永続的なものにアップグレード** することで、一時的なHTTP接続の通常から逸脱します。このアップグレードされた接続は、平文のHTTPの単一リクエストの性質とは異なり、継続的な通信のためにhttp2バイナリプロトコルを利用します。

スマグリングの問題の核心は、**リバースプロキシ** の使用に起因します。通常、リバースプロキシはHTTPリクエストを処理し、バックエンドに転送してからバックエンドの応答を返します。ただし、HTTPリクエストに `Connection: Upgrade` ヘッダーが存在する場合（websocket接続で一般的に見られる）、リバース **プロキシはクライアントとサーバーの間に永続的な接続を維持** し、特定のプロトコルで必要な連続した交換を容易にします。H2C接続の場合、RFCへの遵守には、3つの特定のヘッダーが存在する必要があります。
```
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
脆弱性は、接続をアップグレードした後、リバースプロキシが個々のリクエストを処理するのをやめ、ルーティングの仕事が接続確立後に完了したと仮定すると発生します。H2Cスマグリングを悪用することで、リクエスト処理中に適用されるリバースプロキシのルール（パスベースのルーティング、認証、WAF処理など）を回避することが可能となります。これは、H2C接続が正常に確立された場合に適用されます。

#### 脆弱なプロキシ <a href="#exploitation" id="exploitation"></a>

この脆弱性は、リバースプロキシが`Upgrade`および時には`Connection`ヘッダーをどのように処理するかに依存します。次のプロキシは、プロキシパス中にこれらのヘッダーを暗黙的に転送し、それによってH2Cスマグリングを可能にします：

* HAProxy
* Traefik
* Nuster

一方、次のサービスは、プロキシパス中にこれらのヘッダーを暗黙的に転送しません。ただし、`Upgrade`および`Connection`ヘッダーをフィルタリングせずに転送するように不適切に構成されている可能性があります：

* AWS ALB/CLB
* NGINX
* Apache
* Squid
* Varnish
* Kong
* Envoy
* Apache Traffic Server

#### 悪用 <a href="#exploitation" id="exploitation"></a>

重要なのは、すべてのサーバーが、準拠したH2C接続のアップグレードに必要なヘッダーを暗黙的に転送するわけではないということです。そのため、AWS ALB/CLB、NGINX、Apache Traffic Serverなどのサーバーは、通常、H2C接続をブロックします。それでも、`Connection: Upgrade`バリアント（`Connection`ヘッダーから`HTTP2-Settings`値を除外したもの）でテストする価値があります。なぜなら、一部のバックエンドが標準に準拠していない可能性があるからです。

{% hint style="danger" %}
`proxy_pass` URL内で指定された特定の**パス**（例：`http://backend:9999/socket.io`）に関係なく、確立された接続は常に`http://backend:9999`にデフォルトします。これにより、このテクニックを利用して、その内部エンドポイント内の任意のパスとやり取りすることが可能となります。したがって、`proxy_pass` URL内でパスを指定してもアクセスが制限されるわけではありません。
{% endhint %}

[**BishopFoxのh2csmuggler**](https://github.com/BishopFox/h2csmuggler)および[**assetnoteのh2csmuggler**](https://github.com/assetnote/h2csmuggler)というツールは、H2C接続を確立することで、リバースプロキシによって適用される保護を回避し、プロキシによって保護されているリソースにアクセスする試みを支援します。

この脆弱性に関する詳細情報、特にNGINXに関する情報については、[**この詳細なリソース**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection)を参照してください。

## Websocketスマグリング

Websocketスマグリングは、プロキシを介してアクセス可能なエンドポイントへのHTTP2トンネルを作成するのとは異なり、Websocketトンネルを確立してプロキシの制限をバイパスし、エンドポイントとの直接通信を容易にするものです。

### シナリオ1

このシナリオでは、公開WebSocket APIとアクセスできない内部REST APIを提供するバックエンドが、内部REST APIへのアクセスを求める悪意のあるクライアントによって標的にされます。攻撃は以下の手順で展開されます：

1. クライアントは、ヘッダー内の正しくない`Sec-WebSocket-Version`プロトコルバージョンを持つUpgradeリクエストをリバースプロキシに送信します。リバースプロキシは`Sec-WebSocket-Version`ヘッダーを検証できないため、Upgradeリクエストを有効と認識し、バックエンドに転送します。
2. バックエンドは、`Sec-WebSocket-Version`ヘッダーで正しくないプロトコルバージョンを示すステータスコード`426`で応答します。リバースプロキシはバックエンドの応答ステータスを見落とし、WebSocket通信の準備が整ったと誤解し、その応答をクライアントに中継します。
3. 結果として、リバースプロキシは、クライアントとバックエンドの間にWebSocket接続が確立されたと誤解しますが、実際にはバックエンドがUpgradeリクエストを拒否していたため、そのような接続は存在しません。それにもかかわらず、プロキシはクライアントとバックエンドの間にオープンなTCPまたはTLS接続を維持し、クライアントがこの接続を通じてプライベートREST APIに無制限にアクセスできるようにします。

影響を受けるリバースプロキシには、この問題に対処しなかったVarnishや、バージョン1.8.0以前のEnvoyプロキシなどが含まれます。他のプロキシも影響を受ける可能性があります。

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

### シナリオ2

このシナリオでは、公開WebSocket APIと公開REST API（ヘルスチェック用）を持つバックエンドが、アクセスできない内部REST APIを持っています。より複雑な攻撃は、以下の手順を含みます：

1. クライアントは、追加のHTTPヘッダー`Upgrade: websocket`を含むPOSTリクエストを送信してヘルスチェックAPIをトリガーします。リバースプロキシとして機能するNGINXは、`Upgrade`ヘッダーに基づいて標準のUpgradeリクエストとしてこれを解釈し、リクエストの他の側面を無視してバックエンドに転送します。
2. バックエンドはヘルスチェックAPIを実行し、攻撃者が制御する外部リソースに到達してHTTPレスポンスを返します。このレスポンスは、バックエンドに受信され、NGINXに転送されると、ステータスコード`101`を持つHTTPレスポンスによって、プロキシはステータスコードのみを検証するため、WebSocket接続が確立されたと誤解します。

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

> **警告:** このテクニックの複雑さは、ステータスコード101を返すエンドポイントとやり取りできる能力が必要となるため、増加します。

最終的に、NGINXはクライアントとバックエンドの間にWebSocket接続が存在すると誤解します。実際にはそのような接続は存在せず、ヘルスチェックREST APIが標的となります。それでも、リバースプロキシは接続を維持し、クライアントがこの接続を介してプライベートREST APIにアクセスできるようにします。

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png)

ほとんどのリバースプロキシはこのシナリオに対して脆弱ですが、悪用は通常、低重要度の問題と見なされる外部SSRF脆弱性の存在に依存します。

#### ラボ

両方のシナリオをテストするためのラボは、[https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)で確認できます。

### 参考文献

* [https://blog.assetnote.io/2021/03/18/h2c-smuggling/](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
* [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
* [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)
