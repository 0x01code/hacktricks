# Upgrade Header Smuggling

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† che contano di pi√π in modo da poterle correggere pi√π velocemente. Intruder traccia la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## H2C Smuggling <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

### HTTP2 su testo in chiaro (H2C) <a href="#http2-over-cleartext-h2c" id="http2-over-cleartext-h2c"></a>

H2C, o **http2 su testo in chiaro**, si discosta dalla norma delle connessioni HTTP transitorie aggiornando una connessione HTTP standard a una persistente. Questa connessione aggiornata utilizza il protocollo binario http2 per la comunicazione continua, a differenza della natura di una singola richiesta dell'HTTP in chiaro.

Il fulcro del problema di smuggling sorge con l'uso di un **reverse proxy**. Di solito, il reverse proxy elabora e inoltra le richieste HTTP al backend, restituendo la risposta del backend successivamente. Tuttavia, quando l'intestazione `Connection: Upgrade` √® presente in una richiesta HTTP (comunemente vista con le connessioni websocket), il reverse proxy **mantiene una connessione persistente** tra client e server, facilitando lo scambio continuo richiesto da determinati protocolli. Per le connessioni H2C, il rispetto del RFC richiede la presenza di tre intestazioni specifiche:
``` 
Upgrade: h2c
HTTP2-Settings: AAMAAABkAARAAAAAAAIAAAAA
Connection: Upgrade, HTTP2-Settings
```
La vulnerabilit√† si manifesta quando, dopo l'aggiornamento di una connessione, il reverse proxy smette di gestire singole richieste, assumendo che il suo compito di instradamento sia completo dopo l'instaurazione della connessione. Sfruttare l'H2C Smuggling consente di eludere le regole del reverse proxy applicate durante l'elaborazione delle richieste, come l'instradamento basato sul percorso, l'autenticazione e l'elaborazione WAF, a condizione che una connessione H2C venga avviata con successo.

### Proxy Vulnerabili <a href="#exploitation" id="exploitation"></a>

La vulnerabilit√† dipende dalla gestione da parte del reverse proxy degli header `Upgrade` e talvolta `Connection`. I seguenti proxy inoltrano inherentemente questi header durante il proxy-pass, abilitando di conseguenza l'H2C smuggling:

- HAProxy
- Traefik
- Nuster

Al contrario, questi servizi non inoltrano inherentemente entrambi gli header durante il proxy-pass. Tuttavia, potrebbero essere configurati in modo insicuro, consentendo l'inoltro non filtrato degli header `Upgrade` e `Connection`:

- AWS ALB/CLB
- NGINX
- Apache
- Squid
- Varnish
- Kong
- Envoy
- Apache Traffic Server

### Sfruttamento <a href="#exploitation" id="exploitation"></a>

√à importante notare che non tutti i server inoltrano inherentemente gli header necessari per un aggiornamento della connessione H2C conforme. Pertanto, server come AWS ALB/CLB, NGINX e Apache Traffic Server, tra gli altri, bloccano naturalmente le connessioni H2C. Tuttavia, vale la pena testare la variante non conforme `Connection: Upgrade`, che esclude il valore `HTTP2-Settings` dall'header `Connection`, poich√© alcuni backend potrebbero non conformarsi agli standard.

{% hint style="danger" %}
Indipendentemente dal **percorso** specifico designato nell'URL `proxy_pass` (ad esempio, `http://backend:9999/socket.io`), la connessione stabilita predefinita √® `http://backend:9999`. Ci√≤ consente l'interazione con qualsiasi percorso all'interno di quel punto finale interno, sfruttando questa tecnica. Di conseguenza, la specifica di un percorso nell'URL `proxy_pass` non limita l'accesso.
{% endhint %}

Gli strumenti [**h2csmuggler di BishopFox**](https://github.com/BishopFox/h2csmuggler) e [**h2csmuggler di assetnote**](https://github.com/assetnote/h2csmuggler) facilitano i tentativi di **eludere le protezioni imposte dal proxy** stabilendo una connessione H2C, consentendo cos√¨ l'accesso alle risorse protette dal proxy.

Per ulteriori informazioni su questa vulnerabilit√†, in particolare riguardo a NGINX, fare riferimento a [**questa risorsa dettagliata**](../network-services-pentesting/pentesting-web/nginx.md#proxy\_set\_header-upgrade-and-connection).

# Websocket Smuggling

Lo smuggling di Websocket, a differenza della creazione di un tunnel HTTP2 verso un endpoint accessibile tramite un proxy, stabilisce un tunnel Websocket per eludere eventuali limitazioni del proxy e facilitare la comunicazione diretta con l'endpoint.

## Scenario 1

In questo scenario, un backend che offre un'API WebSocket pubblica insieme a un'API REST interna non accessibile viene preso di mira da un client malevolo che cerca di accedere all'API REST interna. L'attacco si sviluppa in diversi passaggi:

1. Il client inizia inviando una richiesta di Upgrade al reverse proxy con una versione di protocollo `Sec-WebSocket-Version` errata nell'header. Il proxy, non riuscendo a convalidare l'header `Sec-WebSocket-Version`, ritiene la richiesta di Upgrade valida e la inoltra al backend.
2. Il backend risponde con un codice di stato `426`, indicando la versione di protocollo errata nell'header `Sec-WebSocket-Version`. Il reverse proxy, ignorando lo stato di risposta del backend, assume che la comunicazione WebSocket sia pronta e inoltra la risposta al client.
3. Di conseguenza, il reverse proxy viene ingannato nel credere che sia stata stabilita una connessione WebSocket tra il client e il backend, mentre in realt√† il backend ha respinto la richiesta di Upgrade. Nonostante ci√≤, il proxy mantiene una connessione TCP o TLS aperta tra il client e il backend, consentendo al client di accedere senza restrizioni all'API REST privata tramite questa connessione.

I reverse proxy interessati includono Varnish, che ha rifiutato di affrontare il problema, e la versione 1.8.0 o precedente di Envoy proxy, con versioni successive che hanno modificato il meccanismo di aggiornamento. Altri proxy potrebbero essere vulnerabili.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/2-4.png)

## Scenario 2

Questo scenario coinvolge un backend con un'API WebSocket pubblica e un'API REST pubblica per il controllo dello stato di salute, insieme a un'API REST interna non accessibile. L'attacco, pi√π complesso, prevede i seguenti passaggi:

1. Il client invia una richiesta POST per attivare l'API di controllo dello stato di salute, includendo un header HTTP aggiuntivo `Upgrade: websocket`. NGINX, che funge da reverse proxy, interpreta ci√≤ come una richiesta di Upgrade standard basata esclusivamente sull'header `Upgrade`, trascurando gli altri aspetti della richiesta, e la inoltra al backend.
2. Il backend esegue l'API di controllo dello stato di salute, raggiungendo una risorsa esterna controllata dall'attaccante che restituisce una risposta HTTP con codice di stato `101`. Questa risposta, una volta ricevuta dal backend e inoltrata a NGINX, inganna il proxy facendogli credere che sia stata stabilita una connessione WebSocket grazie alla sua convalida solo del codice di stato.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-4.png)

> **Avviso:** La complessit√† di questa tecnica aumenta poich√© richiede la capacit√† di interagire con un endpoint in grado di restituire un codice di stato 101.

In definitiva, NGINX viene ingannato nel credere che esista una connessione WebSocket tra il client e il backend. In realt√†, tale connessione non esiste; l'API REST di controllo dello stato di salute era l'obiettivo. Tuttavia, il reverse proxy mantiene la connessione aperta, consentendo al client di accedere all'API REST privata tramite essa.

![https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png](https://github.com/0ang3el/websocket-smuggle/raw/master/img/3-5.png)

La maggior parte dei reverse proxy √® vulnerabile a questo scenario, ma lo sfruttamento dipende dalla presenza di una vulnerabilit√† SSRF esterna, generalmente considerata un problema di bassa gravit√†.

### Laboratori

Verificare i laboratori per testare entrambi gli scenari su [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

## Riferimenti

* [https://blog.assetnote.io/2021/03/18/h2c-smuggling/](https://blog.assetnote.io/2021/03/18/h2c-smuggling/)
* [https://bishopfox.com/blog/h2c-smuggling-request](https://bishopfox.com/blog/h2c-smuggling-request)
* [https://github.com/0ang3el/websocket-smuggle.git](https://github.com/0ang3el/websocket-smuggle.git)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† pi√π importanti in modo da poterle correggere pi√π rapidamente. Intruder monitora la tua superficie di attacco, esegue scansioni proattive delle minacce, individua problemi
