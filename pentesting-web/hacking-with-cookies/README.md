# 쿠키 해킹

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* 회사를 **HackTricks에서 광고**하거나 **PDF로 HackTricks 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 자신의 해킹 기법을 공유하세요.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 빠르게 수정할 수 있습니다. Intruder는 공격 대상 범위를 추적하고 적극적인 위협 스캔을 실행하여 API부터 웹 애플리케이션 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm_source=referral&utm_campaign=hacktricks) 오늘.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## 쿠키 속성

쿠키는 사용자의 브라우저에서 동작을 제어하는 여러 속성과 함께 제공됩니다. 다음은 이러한 속성에 대한 설명입니다.

### Expires와 Max-Age

쿠키의 만료 날짜는 `Expires` 속성에 의해 결정됩니다. 반대로, `Max-age` 속성은 쿠키가 삭제되기까지의 시간을 초 단위로 정의합니다. **더 최신의 관행을 반영하는 `Max-age`를 선택하세요.**

### Domain

쿠키를 수신하는 호스트는 `Domain` 속성으로 지정됩니다. 기본적으로 이는 쿠키를 발행한 호스트로 설정되며 하위 도메인은 포함되지 않습니다. 그러나 `Domain` 속성이 명시적으로 설정되면 하위 도메인도 포함됩니다. 이는 쿠키를 하위 도메인 간에 공유해야 하는 시나리오에 유용한 제한이 적은 옵션으로 `Domain=mozilla.org`와 같이 설정하면 `developer.mozilla.org`와 같은 하위 도메인에서 쿠키에 액세스할 수 있습니다.

### Path

`Path` 속성은 `Cookie` 헤더를 보내기 위해 요청된 URL에 반드시 포함되어야 하는 특정 URL 경로를 나타냅니다. 이 속성은 `/` 문자를 디렉토리 구분자로 간주하여 하위 디렉토리에서도 일치할 수 있습니다.

### 정렬 규칙

두 개의 쿠키가 동일한 이름을 가질 때, 보내는 쿠키는 다음을 기준으로 선택됩니다:
- 요청된 URL에서 가장 긴 경로와 일치하는 쿠키.
- 경로가 동일한 경우, 가장 최근에 설정된 쿠키.

### SameSite

- `SameSite` 속성은 제3자 도메인에서 시작된 요청에 쿠키가 전송되는지 여부를 지정합니다. 다음과 같은 세 가지 설정이 제공됩니다:
- **Strict**: 제3자 요청에서 쿠키의 전송을 제한합니다.
- **Lax**: 제3자 웹사이트에서 시작된 GET 요청과 함께 쿠키를 전송할 수 있습니다.
- **None**: 어떤 제3자 도메인에서도 쿠키를 전송할 수 있습니다.

쿠키를 구성할 때 이러한 속성을 이해하면 다양한 시나리오에서 예상대로 동작하도록 할 수 있습니다.


| **요청 유형** | **예제 코드**                   | **쿠키 전송 시** |
| ---------------- | ---------------------------------- | --------------------- |
| 링크             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| 프리렌더        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| 폼 GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| 폼 POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| 이미지            | \<img src="...">                   | NetSet\*, None        |

[Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/)에서 가져온 표이며 약간 수정되었습니다.\
_**SameSite**_ 속성이 있는 쿠키는 로그인 세션이 필요한 CSRF 공격을 완화시킵니다.

**\*Chrome80 (2019년 2월)부터는 SameSite 속성이 없는 쿠키의 기본 동작이 lax로 변경**됩니다 ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
임시로 이 변경을 적용한 후에는 Chrome에서 **SameSite 정책이 없는 쿠키는 처음 2분 동안 None으로 처리되고 그 후에는 상위 수준의 교차 사이트 POST 요청에 대해 Lax로 처리**됩니다.

## 쿠키 플래그

### HttpOnly

이것은 **클라이언트**가 쿠키에 액세스하는 것을 방지합니다 (예: `document.cookie`를 통한 **Javascript**를 통한 액세스).

#### **우회 방법**

* 페이지가 요청의 응답으로 쿠키를 **전송하는 경우** (예: **PHPinfo** 페이지에서), XSS를 악용하여 이 페이지로 요청을 보내고 응답에서 쿠키를 **훔칠 수 있습니다** (예제는 [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/)에서 확인하세요).
* 이 기법은 서버의 응답으로 **TRACE** **HTTP** 요청을 보내면 해당 요청이 전송된 쿠키를 반영합니다. 이 기술은 **교차 사이트 추적**이라고 합니다.
* 이 기술은 **현대적인 브라우저에서 JS에서 TRACE** 요청을 보내는 것을 허용하지 않음으로써 회피됩니다. 그러나 특정 소프트웨어에서 `\r\nTRACE` 대신 `TRACE`를 IE6.0 SP2에 보내는 등 이를 우회하는 방법이 발견되었습니다.
* 다른 방법은 브라우저의 제로데이 취약점을 악용하는 것입니다.
* 쿠키 자체를 넘치게 하는 공격을 수행하여 **HttpOnly 쿠키를 덮어쓸 수 있습니다**:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* [**쿠키 스머글링**](./#cookie-smuggling) 공격을 사용하여 이러한 쿠키를 유출할 수 있습니다.

### Secure

요청은 **HTTPS
## 쿠키 접두사

`__Secure-`로 시작하는 쿠키는 HTTPS로 보호되는 페이지에서 `secure` 플래그와 함께 설정되어야 합니다.

`__Host-`로 시작하는 쿠키는 다음 조건을 충족해야 합니다:
- `secure` 플래그와 함께 설정되어야 합니다.
- HTTPS로 보호되는 페이지에서 생성되어야 합니다.
- 도메인을 지정하지 않도록 금지되어 하위 도메인으로의 전송을 방지합니다.
- 이러한 쿠키의 경로는 `/`로 설정되어야 합니다.

`__Host-`로 시작하는 쿠키는 상위 도메인이나 하위 도메인으로 전송되지 않도록 허용되지 않습니다. 이 제한은 응용 프로그램 쿠키를 격리하는 데 도움이 됩니다. 따라서 모든 응용 프로그램 쿠키에 `__Host-` 접두사를 사용하여 보안과 격리를 강화하는 것이 좋은 관행으로 간주됩니다.

## 쿠키 공격

커스텀 쿠키에 민감한 데이터가 포함되어 있는 경우 (특히 CTF를 진행 중인 경우) 해당 쿠키를 확인해야 합니다. Base64 또는 유사한 형식으로 인코딩된 쿠키는 종종 디코딩될 수 있습니다. 이 취약점을 통해 공격자는 쿠키의 내용을 변경하고 수정된 데이터를 다시 쿠키에 인코딩하여 다른 사용자로 위장할 수 있습니다.

### 세션 하이재킹

이 공격은 사용자의 쿠키를 도용하여 응용 프로그램 내에서 무단으로 계정에 액세스하는 것을 목표로 합니다. 도용한 쿠키를 사용하여 공격자는 정상 사용자로 위장할 수 있습니다.

### 세션 픽스에이션

이 시나리오에서 공격자는 피해자가 특정 쿠키를 사용하여 로그인하도록 속입니다. 응용 프로그램이 로그인 시 새로운 쿠키를 할당하지 않는 경우, 원래의 쿠키를 소유한 공격자는 피해자로 위장할 수 있습니다. 이 기술은 공격자가 제공한 쿠키로 피해자가 로그인하는 것에 의존합니다.

**하위 도메인에서 XSS를 발견**하거나 **하위 도메인을 제어**하는 경우, 다음을 읽으세요:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### 세션 기부

여기서 공격자는 피해자를 설득하여 공격자의 세션 쿠키를 사용하도록 합니다. 자신의 계정에 로그인된 것으로 착각하는 피해자는 실수로 공격자의 계정에서 작업을 수행하게 됩니다.

**하위 도메인에서 XSS를 발견**하거나 **하위 도메인을 제어**하는 경우, 다음을 읽으세요:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT 쿠키](../hacking-jwt-json-web-tokens.md)

위의 링크를 클릭하여 JWT에 가능한 결함에 대해 설명하는 페이지에 액세스하세요.

쿠키에 사용되는 JSON Web Tokens (JWT)도 취약점을 가질 수 있습니다. 가능한 결함과 그것을 악용하는 방법에 대한 자세한 정보는 링크된 JWT 해킹 문서를 참조하세요.

### 크로스 사이트 요청 위조 (CSRF)

이 공격은 로그인한 사용자가 현재 인증된 웹 응용 프로그램에서 원하지 않는 작업을 실행하도록 강제합니다. 공격자는 취약한 사이트로의 모든 요청과 함께 자동으로 전송되는 쿠키를 악용할 수 있습니다.

### 빈 쿠키

(자세한 내용은 [원본 연구](https://blog.ankursundara.com/cookie-bugs/)를 확인하세요)
브라우저는 이름이 없는 쿠키를 생성할 수 있도록 허용합니다. 이는 JavaScript를 통해 다음과 같이 증명될 수 있습니다:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
결과적으로 전송된 쿠키 헤더는 `a=v1; test value; b=v2;`입니다. 흥미롭게도, 빈 이름 쿠키가 설정되면 쿠키를 조작할 수 있으며, 빈 쿠키를 특정 값으로 설정하여 다른 쿠키를 제어할 수 있습니다:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
이로 인해 브라우저는 `a`라는 이름의 쿠키와 값 `b`로 해석되는 쿠키 헤더를 보냅니다.

#### Chrome 버그: 유니코드 서로 대응하는 코드포인트 문제

Chrome에서, 유니코드 서로 대응하는 코드포인트가 쿠키에 포함되어 있으면 `document.cookie`가 손상되어 이후에는 빈 문자열을 반환합니다.
```js
document.cookie = "\ud800=meep";
```
이로 인해 `document.cookie`은 비어있는 문자열을 출력하며, 영구적인 손상을 나타냅니다.

#### 구문 분석 문제로 인한 쿠키 스머글링

(자세한 내용은 [원본 연구](https://blog.ankursundara.com/cookie-bugs/)를 확인하세요.)
Java (Jetty, TomCat, Undertow) 및 Python (Zope, cherrypy, web.py, aiohttp, bottle, webob)을 포함한 여러 웹 서버들은 오래된 RFC2965 지원으로 인해 쿠키 문자열을 잘못 처리합니다. 이들은 쿠키 값에 세미콜론이 포함되어 있더라도 이중 따옴표로 묶인 쿠키 값을 단일 값으로 읽습니다. 일반적으로 세미콜론은 키-값 쌍을 구분해야 합니다.
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### 쿠키 주입 취약점

(자세한 내용은 [원본 연구](https://blog.ankursundara.com/cookie-bugs/)를 확인하세요.)
Undertow, Zope 및 Python의 `http.cookie.SimpleCookie` 및 `http.cookie.BaseCookie`를 사용하는 서버들이 쿠키를 잘못 파싱하여 쿠키 주입 공격의 기회를 만들어냅니다. 이러한 서버들은 새로운 쿠키의 시작을 제대로 구분하지 못하고 있어 공격자가 쿠키를 위조할 수 있게 합니다:

- Undertow는 세미콜론 없이 따옴표로 묶인 값 바로 뒤에 새로운 쿠키를 기대합니다.
- Zope는 다음 쿠키를 구문 분석하기 위해 쉼표를 찾습니다.
- Python의 쿠키 클래스는 공백 문자에서 구문 분석을 시작합니다.

이 취약점은 쿠키 기반 CSRF 보호에 의존하는 웹 애플리케이션에서 특히 위험하며, 공격자가 위조된 CSRF 토큰 쿠키를 주입하여 보안 조치를 우회할 수 있게 합니다. 이 문제는 Python이 중복된 쿠키 이름을 처리하는 방식에 의해 악화되며, 마지막 발생이 이전 것을 덮어쓰는 경우에 대한 우려도 제기됩니다. 또한, 보안되지 않은 컨텍스트에서 `__Secure-` 및 `__Host-` 쿠키에 대한 우려가 제기되며, 쿠키가 위조 가능한 백엔드 서버로 전달될 때 인가 우회로 이어질 수 있습니다.


### 추가로 취약한 쿠키 확인

#### **기본적인 확인 사항**

* **쿠키**가 **로그인**할 때마다 **동일**합니다.
* 로그아웃하고 동일한 쿠키를 사용해보세요.
* 동일한 계정에 대해 2개의 장치(또는 브라우저)를 사용하여 로그인을 시도해보세요.
* 쿠키에 어떤 정보가 있는지 확인하고 수정해보세요.
* 거의 동일한 사용자 이름으로 여러 계정을 생성하고 유사성을 확인해보세요.
* "**나를 기억해**" 옵션이 있는지 확인하여 작동 방식을 확인하세요. 취약할 수 있는 경우, 항상 **나를 기억해** 쿠키만 사용하세요.
* 비밀번호를 변경한 후에도 이전 쿠키가 여전히 작동하는지 확인하세요.

#### **고급 쿠키 공격**

쿠키가 로그인할 때마다 동일하게 유지된다면 (또는 거의 유사하게 유지된다면), 이는 쿠키가 계정의 일부 필드와 관련이 있다는 것을 의미합니다 (아마도 사용자 이름). 그런 경우 다음을 시도할 수 있습니다:

* 매우 **유사한** 사용자 이름으로 많은 **계정**을 생성하고 알고리즘이 어떻게 작동하는지 **추측**해보세요.
* **사용자 이름을 브루트포스**해보세요. 쿠키가 사용자 이름의 인증 방법으로만 저장된다면, 사용자 이름이 "**admin**"인 계정을 생성하고 쿠키의 각 **비트**를 브루트포스할 수 있습니다.
* **패딩 오라클**을 시도해보세요 (쿠키의 내용을 복호화할 수 있습니다). **padbuster**를 사용하세요.

**패딩 오라클 - Padbuster 예제**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster는 여러 번 시도하고 어떤 조건이 오류 조건(유효하지 않은 조건)인지 묻습니다.

그런 다음 쿠키의 복호화를 시작합니다(몇 분이 걸릴 수 있음).

공격이 성공적으로 수행되었다면, 원하는 문자열을 암호화해 볼 수 있습니다. 예를 들어, **user=administrator**를 **암호화**하려면
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
이 실행은 문자열 **user=administrator**을 포함하여 올바르게 암호화되고 인코딩된 쿠키를 제공합니다.

**CBC-MAC**

쿠키는 일부 값을 가질 수 있고 CBC를 사용하여 서명될 수 있습니다. 그런 다음 값의 무결성은 동일한 값으로 CBC를 사용하여 생성된 서명입니다. IV로 널 벡터를 사용하는 것이 권장되므로 이러한 무결성 확인은 취약할 수 있습니다.

**공격**

1. 사용자 이름 **administ**의 서명을 가져옵니다. = **t**
2. 사용자 이름 **rator\x00\x00\x00 XOR t**의 서명을 가져옵니다. = **t'**
3. 쿠키에 값 **administrator+t'**를 설정합니다. (**t'**는 **(rator\x00\x00\x00 XOR t) XOR t**의 유효한 서명이 될 것입니다. = **rator\x00\x00\x00**

**ECB**

쿠키가 ECB를 사용하여 암호화되었다면 취약할 수 있습니다.\
로그인할 때 받는 쿠키는 항상 동일해야 합니다.

**탐지 및 공격 방법:**

거의 동일한 데이터 (사용자 이름, 비밀번호, 이메일 등)로 2명의 사용자를 생성하고 주어진 쿠키 내에서 어떤 패턴을 발견하려고 시도합니다.

예를 들어 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"라는 사용자를 생성하고 쿠키 내에 어떤 패턴이 있는지 확인합니다 (ECB는 동일한 키로 모든 블록을 암호화하므로 사용자 이름이 암호화되면 동일한 암호화된 바이트가 나타날 수 있습니다).

사용된 블록 크기로 패턴이 있어야 합니다. 따라서 "a"의 암호화된 패턴을 알고 있다면 사용자 이름을 생성할 수 있습니다: "a"\*(블록의 크기)+"admin". 그런 다음 쿠키에서 "a" 블록의 암호화된 패턴을 삭제할 수 있습니다. 그러면 사용자 이름이 "admin"인 쿠키를 얻을 수 있습니다.

## 참고 자료

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 더 빠르게 수정하세요. Intruder는 공격 표면을 추적하고 예방적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) 오늘.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
