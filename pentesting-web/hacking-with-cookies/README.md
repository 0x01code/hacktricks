# Cookies Hacking

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 如果您在**网络安全公司**工作？您想在**HackTricks**中看到您的**公司广告**吗？或者您想要访问**PEASS的最新版本或以PDF格式下载HackTricks**？查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)系列
* 获取[**官方PEASS & HackTricks周边商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享您的黑客技巧。**

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到最重要的漏洞，以便您能更快修复它们。Intruder 跟踪您的攻击面，运行主动威胁扫描，在您的整个技术栈中找到问题，从API到web应用程序和云系统。今天就[**免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Cookies 属性

### Expires & Max-Age

* `Expires` 设置一个过期日期，用于删除cookie
* `Max-age` 设置时间（以秒为单位），cookie将被删除 **（使用这个，现在不是2009年了）**

### **Domain**

`Domain` 属性指定**哪些主机可以接收cookie**。如果未指定，默认为**设置cookie的同一主机**，_**不包括子域**_。**如果指定了`Domain`**，则**子域始终包括在内**。因此，指定`Domain`比省略它的限制性要小。然而，当子域需要共享用户信息时，这可能是有帮助的。

例如，如果您设置了`Domain=mozilla.org`，cookie可以在像`developer.mozilla.org`这样的子域上使用。但如果您不这样做，cookie将不会发送到子域。

如果一个**子域**`sub.example.com`**设置了一个cookie**，其_domain_属性为**`.example.com`**，它将在对**父域的请求中被**发送**。

### **Path**

`Path` 属性指示**请求的URL中必须存在的URL路径以发送`Cookie`头**。`%x2F` ("/") 字符被视为目录分隔符，子目录也会匹配。

#### 顺序

当2个cookie具有**相同的名称**时，发送的是：

* 具有与URL路径匹配的**最长路径**的那个
* 如果两者路径相同，则是**最新**的那个

### SameSite

这将指示浏览器是否可以**从其他域发送**cookie。它有3个可能的值：

* **Strict**：cookie不会随第三方网站的请求一起发送。
* **Lax**：cookie将随第三方网站发起的GET请求一起发送。
* **None**：cookie可以从任何第三方域发送

| **请求类型** | **示例代码**                   | **发送Cookies的情况** |
| ------------ | ------------------------------ | --------------------- |
| 链接         | \<a href="...">\</a>           | NotSet\*, Lax, None   |
| 预渲染       | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| 表单GET      | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| 表单POST     | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe       | \<iframe src="...">\</iframe>  | NotSet\*, None        |
| AJAX         | $.get("...")                   | NotSet\*, None        |
| 图片         | \<img src="...">               | NetSet\*, None        |

表格来自[Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/)并进行了轻微修改。\
带有_**SameSite**_属性的cookie将**减轻需要登录会话的CSRF攻击**。

**\*注意，从Chrome80（2019年2月）开始，没有samesite属性的cookie的默认行为将是lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/))。\
请注意，临时地，在应用此更改后，Chrome中没有SameSite**政策**的cookie将在**前2分钟内被视为None**，然后对于顶级跨站点POST请求，将被视为Lax。
## Cookie 标志

### HttpOnly

这避免了**客户端**访问 cookie（例如通过 **Javascript**：`document.cookie`）

#### **绕过方法**

* 如果页面在请求的响应中**发送 cookie**（例如在 **PHPinfo** 页面中），可以通过 XSS 发送请求到这个页面并**窃取响应中的 cookie**（查看示例 [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/)）。
* 可以通过 **TRACE** **HTTP** 请求绕过，因为如果服务器允许此 HTTP 方法，其响应将反映发送的 cookie。这种技术称为**跨站点跟踪**。
* 现代浏览器通过不允许从 JS 发送 TRACE 请求来避免这种技术。然而，已经在特定软件中发现了一些绕过方法，比如向 IE6.0 SP2 发送 `\r\nTRACE` 而不是 `TRACE`。
* 另一种方法是利用浏览器的零日漏洞。
* 可以通过执行 Cookie Jar 溢出攻击来**覆盖 HttpOnly cookie**：

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* 可以使用[**Cookie 偷运**](./#cookie-smuggling)攻击来泄露这些 cookie

### Secure

请求将**仅**在通过安全通道（通常是 **HTTPS**）传输时发送 cookie。

## Cookie 前缀

**`__Secure-` 前缀**：必须在安全页面（HTTPS）上设置 `secure` 标志。

**`__Host-` 前缀**：必须设置 `secure` 标志，必须来自安全页面（HTTPS），不能指定域（因此，不会发送到子域），路径必须是 `/`。

`__Host-` 前缀的 cookie 不能发送到超级域（从子域到域的 cookie）或子域（从域到子域的 cookie），因此，如果你想隔离应用程序的 cookie，用 `__Host-` 作为前缀是个不错的主意。

## Cookie 攻击

如果你发现某种自定义 cookie 包含敏感数据（会话 ID、用户名、电子邮件等），你绝对应该尝试利用它

### 解码 cookie

如果 **cookie** 使用了某种 **Base 编码**（如 Base64）或类似的，你可能能够**解码它**，**更改** **内容** 并**冒充**任意用户。

### 会话劫持

窃取 cookie 并使用它在应用程序中冒充用户

### 会话固定

攻击者从网页获取 cookie 并发送链接给受害者，让其**使用同一个 cookie 登录**。如果用户登录时 cookie 没有更改，这可能很有用，因为攻击者可以通过 cookie 冒充用户。

如果你在**子域中发现 XSS** 或者你**控制一个子域**，请阅读：

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### 会话捐赠

攻击者将自己的会话发送给受害者。受害者会看到他已经登录，并会认为他在自己的账户内，但**操作将在攻击者的账户内执行**。

如果你在**子域中发现 XSS** 或者你**控制一个子域**，请阅读：

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT Cookie](../hacking-jwt-json-web-tokens.md)

点击上面的链接访问解释 JWT 可能存在的缺陷的页面。

### 空 Cookie

浏览器允许带有空名称的 cookie
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // empty name
document.cookie = "b=v2"
```
这导致发送了以下cookie头：
```
a=v1; test value; b=v2;
```
更有趣的是，如果你有某种方式可以让你**设置空的 cookie**，你就可以**控制任何其他的 cookie**：
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // this sets the empty cookie to a=b
```
虽然在浏览器内部，这被设置为名为空的cookie，它将导致**发送的cookie头部：**
```
a=b;
```
意味着，每个web服务器都会解析它，将cookie `a` 设置为值 `b`。

### Chrome Bug - document.cookie损坏 <a href="#chrome-bugdocumentcookie-corruption" id="chrome-bugdocumentcookie-corruption"></a>

如果在设置cookie时包含了一个unicode代理码点，`document.cookie` 将会被永久损坏并返回一个空字符串。
```js
document.cookie
// "a=b;"
document.cookie = "\ud800=meep";
document.cookie
// ""
```
### Cookie走私

多个Web服务器，包括Java Web服务器Jetty、TomCat、Undertow，以及Python Web框架Zope，还有像cherrypy、web.py、aiohttp server、bottle和webob这样的Python Web服务器/框架，由于仍支持RFC2965（一种过时的cookie引用机制，使用RFC2616定义的引用字符串），被发现**错误解析cookie字符串**。

具体来说，**这些服务器在遇到双引号（dquoted）的cookie值时会继续读取cookie字符串，即使遇到分号也是如此**。这是有问题的，因为**分号应该用来分隔cookie字符串中的键值对**。

例如，如果**浏览器发送三个cookie，RENDER\_TEXT、JSESSIONID**和**ASDF：**
```basic
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
这些服务器将它们解释为**单个cookie值**，而不是三个独立的cookies。

这导致了一个安全风险：如果攻击者获得了跨站脚本（XSS）访问权限，他们可以利用这个漏洞来**窃取敏感cookies，如HttpOnly cookies**。

### Cookie注入

许多web服务器，包括Java的Undertow、Python的Zope，以及使用Python的stdlib http.cookie.SimpleCookie和http.cookie.BaseCookie的服务器，被发现**错误解析cookies，使用错误的分隔符来开始下一个cookie名称/值对**。这允许攻击者在只控制一个cookie值的情况下**伪造多个cookies**。

在**Undertow**的情况下，它在**引号结束的**cookie值之后立即开始解析下一个cookie，而不等待分号：
```bash
LANGUAGE="en-us" CSRF_TOKEN="SPOOFED_VALUE"
```
**Zope** 在一个**逗号**后开始解析下一个cookie：
```bash
LANGUAGE=en-us,CSRF_TOKEN=SPOOFED_VALUE
```
And **Python's SimpleCookie** 和 **BaseCookie** 会在遇到**空格**字符时立即开始解析下一个cookie：
```
LANGUAGE=en-us CSRF_TOKEN=SPOOFED_VALUE
```
```markdown
因此，像是 **cherrypy**、**web.py**、**aiohttp** 服务器、**bottle** 和 **webob**（Pyramid, TurboGears）等服务器都容易受到这种攻击的影响。

这个问题带来了重大的**安全隐患**。例如，如果一个网页应用使用基于**cookie的CSRF保护**，攻击者可以**注入**一个伪造的**CSRF-token cookie**来绕过这种保护。此外，在Python的http.cookie包中，最后一个重复的cookie名称会覆盖之前的所有同名cookie，这使得这种攻击尤其容易实施。

此外，**`__Secure-`** 和 **`__Host-`** cookie的**伪造**可以在不安全的环境中被滥用。同时，在cookie被传递到后端服务器的配置中，如果后端服务器容易受到伪造攻击而前端服务器不是，**cookie注入可能导致授权绕过**。

### 额外的易受攻击的Cookies检查

#### **基本检查**

* 每次**登录**时，**cookie**都是**相同**的。
* 注销后尝试使用相同的cookie。
* 尝试使用2个设备（或浏览器）登录同一个账户，使用相同的cookie。
* 检查cookie中是否有任何信息并尝试修改它。
* 尝试创建几个用户名几乎相同的账户，检查是否可以看到相似之处。
* 检查是否存在“**记住我**”选项，看看它是如何工作的。如果存在且可能容易受到攻击，始终使用**记住我**的cookie，不使用任何其他cookie。
* 检查在你更改密码后之前的cookie是否仍然有效。

#### **高级cookies攻击**

如果登录时cookie保持不变（或几乎不变），这可能意味着cookie与你账户的某个字段（可能是用户名）有关。然后你可以：

* 尝试创建很多用户名非常**相似**的**账户**，并尝试**猜测**算法是如何工作的。
* 尝试**暴力破解用户名**。如果cookie仅作为你用户名的认证方法保存，那么你可以创建一个用户名为“**Bmin**”的账户，并**暴力破解**你cookie的每一个**比特**，因为你尝试的某个cookie将是属于“**admin**”的那个。
* 尝试**Padding Oracle**（你可以解密cookie的内容）。使用**padbuster**。

**Padding Oracle - Padbuster 示例**
```
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster 会进行多次尝试，并询问您哪种条件是错误条件（即无效的条件）。

然后它将开始解密 cookie（这可能需要几分钟）

如果攻击成功执行，那么您可以尝试加密您选择的字符串。例如，如果您想要**加密** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
执行后，您将得到一个正确加密和编码的cookie，其中包含字符串 **user=administrator**。

**CBC-MAC**

可能有些cookie包含某些值，并使用CBC进行签名。那么，该值的完整性就是通过使用相同的值与CBC创建的签名。由于建议使用空向量作为IV，这种完整性检查可能存在漏洞。

**攻击方法**

1. 获取用户名 **administ** 的签名 = **t**
2. 获取用户名 **rator\x00\x00\x00 XOR t** 的签名 = **t'**
3. 在cookie中设置值 **administrator+t'**（**t'** 将是 **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** 的有效签名）

**ECB**

如果cookie使用ECB加密，它可能会受到攻击。\
当您登录时，您收到的cookie应该始终相同。

**如何检测和攻击：**

创建两个数据几乎相同的用户（用户名、密码、电子邮件等），并尝试在给定的cookie中发现某种模式。

例如，创建一个名为 "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" 的用户，并检查cookie中是否有任何模式（由于ECB使用相同的密钥加密每个块，如果用户名被加密，相同的加密字节可能会出现）。

应该有一个模式（使用块的大小）。因此，知道一堆 "a" 是如何加密的，您可以创建一个用户名："a"\*(块的大小)+"admin"。然后，您可以从cookie中删除一个 "a" 块的加密模式。这样您就会拥有用户名为 "admin" 的cookie。

## 参考资料

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到对您最重要的漏洞，以便您能更快修复它们。Intruder 跟踪您的攻击面，运行主动威胁扫描，在您的整个技术栈中找到问题，从API到web应用程序和云系统。[**免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)今天。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 如果您在**网络安全公司**工作？您想在HackTricks中看到您的**公司广告**？或者您想要访问**PEASS的最新版本或下载HackTricks的PDF**？查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)系列。
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)。
* **加入**[**💬**](https://emojipedia.org/speech-balloon/)[**Discord群组**](https://discord.gg/hRep4RUj7f)或[**telegram群组**](https://t.me/peass)或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* 通过向[**hacktricks repo**](https://github.com/carlospolop/hacktricks)和[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud)提交PR，**分享您的黑客技巧**。

</details>
