# Çerez Hacking

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek.

</details>

## Çerez Özellikleri

Çerezler, kullanıcının tarayıcısındaki davranışlarını kontrol eden birkaç özellikle birlikte gelir. İşte bu özelliklerin bir özetini daha pasif bir sesle açıklayanlar:

### Expires ve Max-Age

Bir çerezin son kullanma tarihi, `Expires` özelliği tarafından belirlenir. Buna karşılık, `Max-age` özelliği bir çerezin silineceği süreyi saniye cinsinden tanımlar. **Daha modern uygulamaları yansıttığı için `Max-age`'i tercih edin.**

### Domain

Bir çerezi alacak ana bilgisayarlar, `Domain` özelliği tarafından belirtilir. Varsayılan olarak, bu, çerezi veren ana bilgisayara ayarlanır, alt alanlarını içermez. Ancak, `Domain` özelliği açıkça belirlendiğinde, alt alanları da kapsar. Bu, `Domain` özelliğinin belirtilmesini, alt alanlar arasında çerez paylaşımının gerektiği senaryolar için daha az kısıtlayıcı bir seçenek haline getirir. Örneğin, `Domain=mozilla.org` ayarlanarak, çerezlerin `developer.mozilla.org` gibi alt alanlarda erişilebilir olmasını sağlar.

### Path

`Path` özelliği, gönderilen URL'de bulunması gereken belirli bir URL yolunu gösterir. Bu özellik, `/` karakterini bir dizin ayırıcı olarak kabul eder, alt dizinlerde eşleşmelere izin verir.

### Sıralama Kuralları

Aynı isme sahip iki çerez olduğunda, gönderim için seçilen çerez şu kriterlere dayanır:

* İstenen URL'deki en uzun yola uyan çerez.
* Yollar aynıysa, en son ayarlanan çerez.

### SameSite

* `SameSite` özelliği, çerezlerin üçüncü taraf alanlarından kaynaklanan isteklerde gönderilip gönderilmeyeceğini belirler. Üç ayar sunar:
* **Strict**: Çerezi üçüncü taraf isteklerinde gönderilmesini kısıtlar.
* **Lax**: Üçüncü taraf web siteleri tarafından başlatılan GET istekleriyle çerezin gönderilmesine izin verir.
* **None**: Çerezi herhangi bir üçüncü taraf alanından göndermeye izin verir.

Çerezleri yapılandırırken, bu özellikleri anlamak, farklı senaryolarda beklenen şekilde davranmalarını sağlamaya yardımcı olabilir.

| **İstek Türü** | **Örnek Kod**                   | **Çerezler Gönderildiğinde** |
| ---------------- | ---------------------------------- | --------------------- |
| Bağlantı             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Önizleme        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Resim            | \<img src="...">                   | NetSet\*, None        |

Tablo [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) tarafından ve hafifçe değiştirilmiştir.\
_Bir **SameSite** özelliğine sahip çerez, oturum gerektiren CSRF saldırılarını **önleyecektir**._

**\*Unutmayın ki Chrome80'den (şubat/2019) itibaren, bir çerezin samesite özelliği olmayan bir çerezin varsayılan davranışı lax olacaktır** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Bu değişiklik uygulandıktan sonra, **Chrome'da SameSite politikası olmayan çerezlerin** **ilk 2 dakika boyunca None** olarak **işlem göreceğini ve ardından üst düzey çapraz site POST isteği için Lax** olarak işlem göreceğini **unutmayın.**

## Çerez Bayrakları

### HttpOnly

Bu, **istemcinin** çereze erişmesini engeller (Örneğin **Javascript** aracılığıyla: `document.cookie`)

#### **Atlatmalar**

* Eğer sayfa, isteklerin yanıtı olarak çerezleri gönderiyorsa (örneğin bir **PHPinfo** sayfasında), XSS'yi kötüye kullanarak bu sayfaya bir istek gönderip yanıttan çerezleri **çalmak mümkün olabilir** (örneği [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/) adresinde bulabilirsiniz).
* Bu, sunucudan gelen yanıt olarak **TRACE** **HTTP** istekleriyle atlatılabilir (bu HTTP yöntemi mevcutsa). Bu teknik **Cross-Site Tracking** olarak adlandırılır.
* Bu teknik, **modern tarayıcılar tarafından JS'den TRACE** isteği göndermeye izin verilmeyerek önlendi. Ancak, IE6.0 SP2 gibi belirli yazılımlarda `\r\nTRACE` yerine `TRACE` göndererek bu kısıtlamaları atlatan bazı yöntemler bulunmuştur.
* Başka bir yol, tarayıcıların sıfır/gün açıklarının sömürülmesidir.
* Bir Çerez Kavanozu taşması saldırısı gerçekleştirerek **HttpOnly çerezlerin üzerine yazılabilir**:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Bu çerezleri dışarıya çıkarmak için [**Çerez Kaçırma**](./#cookie-smuggling) saldırısını kullanmak mümkündür

### Secure

İstek, yalnızca güvenli bir kanal üzerinden iletiliyorsa (genellikle **HTTPS**), çerezi yalnızca bir HTTP isteğinde gönderecektir.

## Çerez Önekleri

`__Secure-` ile başlayan çerezlerin, HTTPS ile korunan sayfalardan gelen sayfalarda `secure` bayrağı ile birlikte ayarlanması gerekmektedir.

`__Host-` ile başlayan çerezler için birkaç koşulun karşılanması gerekmektedir:

* `secure` bayrağı ile ayarlanmalıdır.
* HTTPS ile korunan bir sayfadan kaynaklanmalıdır.
* Alt alanlara iletilmesini engelleyen bir alan belirtmemelidir.
* Bu çerezlerin yolu `/` olarak ayarlanmalıdır.

`__Host-` ile başlayan çerezlerin süper alanlara veya alt alanlara gönderilmesine izin verilmediğini belirtmek önemlidir. Bu kısıtlama, uygulama çerezlerini izole etmeye yardımcı olur. Bu nedenle, tüm uygulama çerezleri için `__Host-` önekini kullanmak, güvenliği ve izolasyonu artırmak için iyi bir uygulama olarak düşünülebilir.
## Çerez Saldırıları

Eğer özel bir çerez hassas veriler içeriyorsa kontrol edin (özellikle bir CTF oynuyorsanız), zira zayıf olabilir.

### Çerezlerin Kodunu Çözme ve Manipüle Etme

Çerezlere gömülmüş hassas veriler her zaman incelenmelidir. Base64 veya benzer formatlarda kodlanmış çerezler genellikle çözülebilir. Bu zayıflık, saldırganların çerez içeriğini değiştirip modifiye ettikleri verileri tekrar çereze kodlayarak diğer kullanıcıları taklit etmelerine olanak tanır.

### Oturum Kaçırma (Session Hijacking)

Bu saldırı, bir kullanıcının çerezini çalarak bir uygulamadaki hesabına izinsiz erişim sağlamayı içerir. Çalınan çerez kullanılarak, bir saldırgan meşru kullanıcıyı taklit edebilir.

### Oturum Sabitleme (Session Fixation)

Bu senaryoda, bir saldırgan bir kurbanı belirli bir çerez kullanmaya ikna eder. Uygulama giriş yaptıktan sonra yeni bir çerez atamazsa, saldırgan, orijinal çereze sahip olarak kurbanı taklit edebilir. Bu teknik, kurbanın saldırgan tarafından sağlanan bir çerezle giriş yapmasına dayanır.

Eğer bir **alt alan adında XSS** bulduysanız veya bir **alt alan adını kontrol ediyorsanız**, okuyun:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Oturum Bağışı (Session Donation)

Burada, saldırgan kurbanı saldırganın oturum çerezini kullanmaya ikna eder. Kendi hesabına giriş yaptığına inanan kurban, aslında saldırganın hesabı bağlamında yanlışlıkla işlemler gerçekleştirir.

Eğer bir **alt alan adında XSS** bulduysanız veya bir **alt alan adını kontrol ediyorsanız**, okuyun:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT Çerezleri](../hacking-jwt-json-web-tokens.md)

Potansiyel JWT hatalarını açıklayan bir sayfaya erişmek için önceki bağlantıya tıklayın.

Çerezlerde kullanılan JSON Web Token'lar (JWT) de zayıflıklar içerebilir. Potansiyel hatalar ve bunları nasıl sömürüleceği hakkında detaylı bilgi için, JWT'yi hacklemekle ilgili belgeye erişmek önerilir.

### Cross-Site Request Forgery (CSRF)

Bu saldırı, oturum açmış bir kullanıcıyı, mevcut kimlik doğrulama yapılmış bir web uygulamasında istenmeyen eylemleri gerçekleştirmeye zorlar. Saldırganlar, her istekle otomatik olarak gönderilen çerezleri sömürebilirler.

### Boş Çerezler

(Daha fazla detay için [orijinal araştırmaya](https://blog.ankursundara.com/cookie-bugs/) bakın) Tarayıcılar, ismi olmayan çerezlerin oluşturulmasına izin verir, bu JavaScript ile aşağıdaki gibi gösterilebilir:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
The result in the sent cookie header is `a=v1; test value; b=v2;`. Intriguingly, this allows for the manipulation of cookies if an empty name cookie is set, potentially controlling other cookies by setting the empty cookie to a specific value:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
#### Chrome Hatası: Unicode Yedek Kod Nokta Sorunu

Chrome'da, bir Unicode yedek kod noktası bir set çerezi parçasıysa, `document.cookie` bozulur ve ardından boş bir dize döndürür:
```js
document.cookie = "\ud800=meep";
```
Bu, `document.cookie`'nin boş bir dize çıktısı vermesine neden olarak kalıcı bozulmaya işaret eder.

#### Ayrıştırma Sorunları Nedeniyle Çerez Kaçırma

(Daha fazla ayrıntı için [orijinal araştırmaya](https://blog.ankursundara.com/cookie-bugs/) bakın) Java (Jetty, TomCat, Undertow) ve Python (Zope, cherrypy, web.py, aiohttp, bottle, webob) dahil birçok web sunucusu, eski RFC2965 desteğinden kaynaklanan çerez dizelerini yanlış işler. Çift tırnakla çevrili bir çerez değeri, normalde anahtar-değer çiftlerini ayıran noktalı virgüller içerse bile tek bir değer olarak okunur:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Çerez Enjeksiyonu Güvenlik Açıklıkları

(Sonuçları[orijinal araştırmada](https://blog.ankursundara.com/cookie-bugs/) kontrol edin) Sunucuların, özellikle Undertow, Zope ve Python'ın `http.cookie.SimpleCookie` ve `http.cookie.BaseCookie` kullanarak çerezleri yanlış ayrıştırması, çerez enjeksiyon saldırıları için fırsatlar yaratır. Bu sunucular yeni çerezlerin başlangıcını düzgün bir şekilde sınırlamazlar, saldırganlara çerezleri sahtelemelerine olanak tanır:

* Undertow, bir tırnak içindeki bir değerden sonra noktalı virgül olmadan hemen yeni bir çerez bekler.
* Zope, bir sonraki çerezi ayrıştırmaya başlamak için bir virgül arar.
* Python'ın çerez sınıfları, boşluk karakterinde ayrışmaya başlar.

Bu zayıflık, çerez tabanlı CSRF korumasına güvenen web uygulamalarında özellikle tehlikelidir, çünkü saldırganlara sahte CSRF belirteci çerezleri enjekte etmelerine ve güvenlik önlemlerini atlamalarına olanak tanır. Sorun, Python'ın yinelenen çerez adlarını işleme şekli tarafından kötüleştirilir, burada son oluşum öncekileri geçersiz kılar. Ayrıca, güvensiz bağlamlarda `__Secure-` ve `__Host-` çerezleri için endişeleri artırır ve çerezlerin sahteciliğe duyarlı arka uç sunucularına iletilmesi durumunda yetkilendirme atlamalarına yol açabilir.

### Ekstra Savunmasız Çerez Kontrolleri

#### **Temel kontroller**

* **Çerez**, her **giriş** yaptığınızda **aynı** olmalıdır.
* Çıkış yapın ve aynı çerezi kullanmaya çalışın.
* Aynı çerezi kullanarak aynı hesaba 2 cihazda (veya tarayıcıda) giriş yapmaya çalışın.
* Çerezde herhangi bir bilgi olup olmadığını kontrol edin ve değiştirmeye çalışın.
* Neredeyse aynı kullanıcı adıyla birkaç hesap oluşturun ve benzerlikleri görebilir misiniz kontrol edin.
* Varsa "**beni hatırla**" seçeneğini kontrol edin ve nasıl çalıştığını görün. Varsa ve savunmasız olabilirse, her zaman sadece **beni hatırla** çerezini kullanın, başka bir çerez olmadan.
* Şifrenizi değiştirdikten sonra önceki çerezin hala çalışıp çalışmadığını kontrol edin.

#### **Gelişmiş çerez saldırıları**

Eğer giriş yaptığınızda çerez aynı kalıyorsa (veya neredeyse aynı), bu muhtemelen çerezin hesabınızın bir alanıyla ilişkili olduğu anlamına gelir (muhtemelen kullanıcı adı). O zaman şunları yapabilirsiniz:

* Çok sayıda **hesap** oluşturun ve kullanıcı adları çok **benzer** olsun ve algoritmanın nasıl çalıştığını **tahmin** etmeye çalışın.
* **Kullanıcı adını brute force** deneyin. Eğer çerez sadece kullanıcı adınız için bir kimlik doğrulama yöntemi olarak kaydediyorsa, o zaman "**Bmin**" kullanıcı adıyla bir hesap oluşturabilir ve çerezinizin her bir **bitini** brute force edebilirsiniz çünkü deneyeceğiniz çerezlerden biri "**admin**"e ait olacaktır.
* **Padding Oracle** deneyin (çerezin içeriğini şifreleyebilirsiniz). **Padbuster** kullanın.

**Padding Oracle - Padbuster örnekleri**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster birkaç deneme yapacak ve hangi koşulun hata koşulu olduğunu soracak (geçerli olmayan).

Daha sonra çerezin şifresini çözmeye başlayacak (birkaç dakika sürebilir).

Saldırı başarıyla gerçekleştirildiyse, istediğiniz bir dizeyi şifrelemeyi deneyebilirsiniz. Örneğin, eğer **user=admin** şifrelemek isterseniz
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Bu işlem, içinde **user=administrator** dizesi bulunan çerezin doğru bir şekilde şifrelenmiş ve kodlanmış halini verecektir.

**CBC-MAC**

Belki bir çerez bir değere sahip olabilir ve CBC kullanılarak imzalanabilir. Sonra, değerin bütünlüğü, aynı değeri kullanarak CBC kullanarak oluşturulan imza olacaktır. IV olarak bir nul vektörü kullanılması önerildiği için, bu tür bütünlük kontrolü savunmasız olabilir.

**Saldırı**

1. Kullanıcı adı **administ**'in imzasını al = **t**
2. Kullanıcı adı **rator\x00\x00\x00 XOR t**'nin imzasını al = **t'**
3. Çerezde değeri **administrator+t'** olarak ayarla (**t'**, **(rator\x00\x00\x00 XOR t) XOR t**'nin geçerli bir imzası olacaktır = **rator\x00\x00\x00**

**ECB**

Çerez ECB kullanılarak şifrelendiyse savunmasız olabilir.\
Giriş yaptığınızda aldığınız çerez her zaman aynı olmalıdır.

**Nasıl tespit edilir ve saldırılır:**

Neredeyse aynı verilere sahip 2 kullanıcı oluşturun (kullanıcı adı, şifre, e-posta vb.) ve verilen çerezde bir desen keşfetmeye çalışın

Örneğin "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" adında bir kullanıcı oluşturun ve çerezde herhangi bir desen olup olmadığını kontrol edin (ECB, her bloğu aynı anahtarla şifrelediği için, kullanıcı adı şifrelendiğinde aynı şifrelenmiş baytlar görünebilir).

Bir desen olmalıdır (kullanılan blok boyutunda). Bu nedenle, bir grup "a"nın nasıl şifrelendiğini bildiğinizde, "a"\*(blok boyutu)+"admin" şeklinde bir kullanıcı adı oluşturabilirsiniz. Sonra, "a" bloğunun şifrelenmiş desenini çerezden silebilirsiniz. Ve kullanıcı adı "admin"in çerezine sahip olabilirsiniz.

## Referanslar

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR göndererek.

</details>
