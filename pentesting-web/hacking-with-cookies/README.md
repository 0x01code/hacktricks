# Cookies Hacking

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Cookie-Attribute

Cookies verf√ºgen √ºber mehrere Attribute, die ihr Verhalten im Browser des Benutzers steuern. Hier ist eine √úbersicht √ºber diese Attribute in einer eher passiven Sprache:

### Ablaufdatum und Max-Age

Das Ablaufdatum eines Cookies wird durch das Attribut `Expires` bestimmt. Umgekehrt definiert das Attribut `Max-Age` die Zeit in Sekunden, bis ein Cookie gel√∂scht wird. **W√§hlen Sie `Max-Age`, da es modernere Praktiken widerspiegelt.**

### Domain

Die Hosts, die ein Cookie erhalten sollen, werden durch das Attribut `Domain` angegeben. Standardm√§√üig ist dies auf den Host festgelegt, der das Cookie ausgestellt hat, ohne seine Subdomains einzubeziehen. Wenn jedoch das Attribut `Domain` explizit festgelegt ist, umfasst es auch Subdomains. Dies macht die Spezifikation des Attributs `Domain` zu einer weniger restriktiven Option, die in Szenarien n√ºtzlich ist, in denen ein Cookie√ºbertragung √ºber Subdomains erforderlich ist. Beispielsweise erm√∂glicht das Festlegen von `Domain=mozilla.org`, dass Cookies auf seinen Subdomains wie `developer.mozilla.org` zug√§nglich sind.

### Pfad

Ein spezifischer URL-Pfad, der in der angeforderten URL vorhanden sein muss, damit der `Cookie`-Header gesendet wird, wird durch das Attribut `Path` angezeigt. Dieses Attribut betrachtet das `/`-Zeichen als Verzeichnistrennzeichen und erm√∂glicht √úbereinstimmungen in Unterverzeichnissen.

### Reihenfolgeregeln

Wenn zwei Cookies denselben Namen haben, wird das zum Senden ausgew√§hlte Cookie basierend auf folgendem ausgew√§hlt:

* Das Cookie, das am l√§ngsten mit dem Pfad in der angeforderten URL √ºbereinstimmt.
* Das zuletzt gesetzte Cookie, wenn die Pfade identisch sind.

### SameSite

* Das Attribut `SameSite` gibt an, ob Cookies bei Anfragen von Drittanbieterdomains gesendet werden. Es bietet drei Einstellungen:
* **Strict**: Beschr√§nkt das Senden des Cookies bei Anfragen von Drittanbietern.
* **Lax**: Erm√∂glicht das Senden des Cookies bei GET-Anfragen, die von Websites von Drittanbietern initiiert wurden.
* **None**: Erlaubt das Senden des Cookies von jeder Drittanbieterdomain.

Beachten Sie, dass beim Konfigurieren von Cookies das Verst√§ndnis dieser Attribute dazu beitragen kann, sicherzustellen, dass sie sich in verschiedenen Szenarien wie erwartet verhalten.

| **Anforderungstyp** | **Beispielcode**                   | **Cookies gesendet, wenn** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Formular GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Formular POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Bild            | \<img src="...">                   | NetSet\*, None        |

Tabelle von [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) und leicht modifiziert.\
Ein Cookie mit _**SameSite**_ Attribut wird **CSRF-Angriffe abmildern**, bei denen eine angemeldete Sitzung erforderlich ist.

**\*Beachten Sie, dass ab Chrome80 (Feb/2019) das Standardverhalten eines Cookies ohne ein Cookie-Samesite-Attribut lax sein wird** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Beachten Sie vor√ºbergehend, dass die **Cookies ohne eine SameSite-Richtlinie** in Chrome w√§hrend der **ersten 2 Minuten als None** und dann als Lax f√ºr Cross-Site-POST-Anforderungen auf h√∂chster Ebene behandelt werden.

## Cookies-Flags

### HttpOnly

Dies verhindert, dass der **Client** auf das Cookie zugreift (zum Beispiel √ºber **Javascript** wie `document.cookie`)

#### **Umgehungen**

* Wenn die Seite die Cookies als Antwort auf eine Anfrage sendet (zum Beispiel auf einer **PHPinfo**-Seite), ist es m√∂glich, XSS zu missbrauchen, um eine Anfrage an diese Seite zu senden und die Cookies aus der Antwort zu **stehlen** (siehe ein Beispiel unter [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Dies k√∂nnte mit **TRACE** **HTTP**-Anfragen umgangen werden, da die Antwort des Servers (falls diese HTTP-Methode verf√ºgbar ist) die gesendeten Cookies widerspiegelt. Diese Technik wird als **Cross-Site Tracking** bezeichnet.
* Moderne Browser verhindern diese Technik, indem sie das Senden einer TRACE-Anfrage von JS nicht zulassen. Einige Umgehungen wurden jedoch in spezifischer Software gefunden, wie z.B. das Senden von `\r\nTRACE` anstelle von `TRACE` an IE6.0 SP2.
* Ein anderer Weg ist die Ausnutzung von Zero-Day-Schwachstellen der Browser.
* Es ist m√∂glich, **HttpOnly-Cookies zu √ºberschreiben**, indem ein Cookie-Jar-√úberlaufangriff durchgef√ºhrt wird:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Es ist m√∂glich, einen [**Cookie-Smuggling**](./#cookie-smuggling)-Angriff zu verwenden, um diese Cookies zu exfiltrieren

### Secure

Die Anfrage sendet das Cookie **nur**, wenn die Anfrage √ºber einen sicheren Kanal √ºbertragen wird (typischerweise **HTTPS**).

## Cookies-Pr√§fixe

Cookies, die mit `__Secure-` versehen sind, m√ºssen zusammen mit der `secure`-Flag von Seiten gesetzt werden, die durch HTTPS gesichert sind.

F√ºr Cookies, die mit `__Host-` versehen sind, m√ºssen mehrere Bedingungen erf√ºllt sein:

* Sie m√ºssen mit der `secure`-Flag gesetzt werden.
* Sie m√ºssen von einer durch HTTPS gesicherten Seite stammen.
* Es ist verboten, eine Domain anzugeben, um ihre √úbertragung an Subdomains zu verhindern.
* Der Pfad f√ºr diese Cookies muss auf `/` festgelegt sein.

Es ist wichtig zu beachten, dass Cookies, die mit `__Host-` versehen sind, nicht an Superdomains oder Subdomains gesendet werden d√ºrfen. Diese Einschr√§nkung tr√§gt dazu bei, Anwendungscookies zu isolieren. Daher kann die Verwendung des Pr√§fix `__Host-` f√ºr alle Anwendungscookies als bew√§hrte Praxis zur Verbesserung von Sicherheit und Isolierung betrachtet werden.
### √úberschreiben von Cookies

Eine der Schutzma√ünahmen f√ºr mit `__Host-` vorangestellten Cookies besteht darin, zu verhindern, dass sie von Subdomains √ºberschrieben werden. Dies verhindert beispielsweise [**Cookie-Tossing-Angriffe**](cookie-tossing.md). In dem Vortrag [**Cookie Crumbles: Enth√ºllung von Schwachstellen bei der Web-Sitzungsintegrit√§t**](https://www.youtube.com/watch?v=F_wAzF4a7Xg) ([**Paper**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) wurde dargestellt, dass es m√∂glich war, `__HOST-` vorangestellte Cookies von Subdomains aus zu setzen, indem man den Parser austrickste, zum Beispiel durch Hinzuf√ºgen von "=" am Anfang oder am Anfang und am Ende...:

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Oder in PHP war es m√∂glich, **andere Zeichen am Anfang** des Cookie-Namens hinzuzuf√ºgen, die durch Unterstrichzeichen ersetzt werden sollten, was das √úberschreiben von `__HOST-`-Cookies erm√∂glichte:

<figure><img src="../../.gitbook/assets/image (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Cookie-Angriffe

Wenn ein benutzerdefinierter Cookie sensible Daten enth√§lt, √ºberpr√ºfen Sie ihn (insbesondere wenn Sie an einem CTF teilnehmen), da er anf√§llig sein k√∂nnte.

### Dekodieren und Manipulieren von Cookies

In Cookies eingebettete sensible Daten sollten immer √ºberpr√ºft werden. Cookies, die in Base64 oder √§hnlichen Formaten codiert sind, k√∂nnen oft dekodiert werden. Diese Schwachstelle erm√∂glicht es Angreifern, den Inhalt des Cookies zu √§ndern und sich als andere Benutzer auszugeben, indem sie ihre modifizierten Daten zur√ºck in das Cookie codieren.

### Sitzungs√ºbernahme

Bei diesem Angriff wird ein Benutzercookie gestohlen, um unbefugten Zugriff auf sein Konto in einer Anwendung zu erhalten. Indem der gestohlene Cookie verwendet wird, kann ein Angreifer den legitimen Benutzer imitieren.

### Sitzungsfestlegung

In diesem Szenario t√§uscht ein Angreifer ein Opfer, ein bestimmtes Cookie zum Einloggen zu verwenden. Wenn die Anwendung beim Einloggen kein neues Cookie vergibt, kann der Angreifer, der das urspr√ºngliche Cookie besitzt, das Opfer imitieren. Diese Technik basiert darauf, dass das Opfer sich mit einem vom Angreifer bereitgestellten Cookie einloggt.

Wenn Sie ein **XSS in einer Subdomain** gefunden haben oder Sie eine **Subdomain kontrollieren**, lesen Sie:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Sitzungsspende

Hier √ºberzeugt der Angreifer das Opfer, das Sitzungscookie des Angreifers zu verwenden. Das Opfer, das glaubt, in sein eigenes Konto eingeloggt zu sein, wird unbeabsichtigt Aktionen im Kontext des Kontos des Angreifers ausf√ºhren.

Wenn Sie ein **XSS in einer Subdomain** gefunden haben oder Sie eine **Subdomain kontrollieren**, lesen Sie:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT-Cookies](../hacking-jwt-json-web-tokens.md)

Klicken Sie auf den vorherigen Link, um auf eine Seite zuzugreifen, die m√∂gliche Schwachstellen bei JWT erkl√§rt.

JSON Web Tokens (JWT), die in Cookies verwendet werden, k√∂nnen ebenfalls Schwachstellen aufweisen. F√ºr detaillierte Informationen zu potenziellen Schwachstellen und wie man sie ausnutzen kann, wird empfohlen, das verlinkte Dokument zum Hacken von JWT zu lesen.

### Cross-Site Request Forgery (CSRF)

Dieser Angriff zwingt einen eingeloggten Benutzer, unerw√ºnschte Aktionen auf einer Webanwendung auszuf√ºhren, f√ºr die er derzeit authentifiziert ist. Angreifer k√∂nnen Cookies ausnutzen, die automatisch mit jeder Anfrage an die verwundbare Website gesendet werden.

### Leere Cookies

(Weitere Details finden Sie in der [Originalforschung](https://blog.ankursundara.com/cookie-bugs/)) Browser erlauben die Erstellung von Cookies ohne Namen, was durch JavaScript wie folgt demonstriert werden kann:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Der Wert im gesendeten Cookie-Header lautet `a=v1; test value; b=v2;`. Interessanterweise erm√∂glicht dies die Manipulation von Cookies, wenn ein Cookie mit leerem Namen gesetzt wird, wodurch m√∂glicherweise andere Cookies kontrolliert werden k√∂nnen, indem das leere Cookie auf einen bestimmten Wert gesetzt wird:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
#### Chrome-Bug: Unicode-Ersatzcodepunkt-Problem

In Chrome wird, wenn ein Unicode-Ersatzcodepunkt Teil eines gesetzten Cookies ist, `document.cookie` besch√§digt, und gibt anschlie√üend einen leeren String zur√ºck:
```js
document.cookie = "\ud800=meep";
```
Dies f√ºhrt dazu, dass `document.cookie` eine leere Zeichenfolge ausgibt, was auf eine dauerhafte Besch√§digung hinweist.

#### Cookie-Schmuggel aufgrund von Parsing-Problemen

(Weitere Details finden Sie in der [Originalforschung](https://blog.ankursundara.com/cookie-bugs/)) Mehrere Webserver, darunter solche von Java (Jetty, TomCat, Undertow) und Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), behandeln Cookie-Zeichenfolgen fehlerhaft aufgrund veralteter RFC2965-Unterst√ºtzung. Sie lesen einen in doppelte Anf√ºhrungszeichen gesetzten Cookie-Wert als einzelnen Wert, auch wenn er Semikolons enth√§lt, die normalerweise Schl√ºssel-Wert-Paare trennen sollten:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie-Injection-Schwachstellen

(Weitere Details finden Sie in der [urspr√ºnglichen Forschung](https://blog.ankursundara.com/cookie-bugs/)) Die fehlerhafte Analyse von Cookies durch Server, insbesondere Undertow, Zope und solche, die Python's `http.cookie.SimpleCookie` und `http.cookie.BaseCookie` verwenden, er√∂ffnet M√∂glichkeiten f√ºr Cookie-Injection-Angriffe. Diese Server vers√§umen es, den Beginn neuer Cookies ordnungsgem√§√ü zu begrenzen, was es Angreifern erm√∂glicht, Cookies zu f√§lschen:

- Undertow erwartet ein neues Cookie unmittelbar nach einem in Anf√ºhrungszeichen gesetzten Wert ohne Semikolon.
- Zope sucht nach einem Komma, um mit der Analyse des n√§chsten Cookies zu beginnen.
- Die Cookie-Klassen von Python beginnen mit der Analyse bei einem Leerzeichen.

Diese Schwachstelle ist besonders gef√§hrlich in Webanwendungen, die auf cookiebasierten CSRF-Schutz angewiesen sind, da sie es Angreifern erm√∂glicht, gef√§lschte CSRF-Token-Cookies einzuf√ºgen und m√∂glicherweise Sicherheitsma√ünahmen zu umgehen. Das Problem wird durch die Behandlung von doppelten Cookienamen in Python versch√§rft, wobei das letzte Auftreten fr√ºhere √ºberschreibt. Es wirft auch Bedenken hinsichtlich der `__Secure-` und `__Host-`-Cookies in unsicheren Kontexten auf und k√∂nnte zu Autorisierungsumgehungen f√ºhren, wenn Cookies an anf√§llige Backend-Server weitergeleitet werden, die anf√§llig f√ºr Spoofing sind.

### Zus√§tzliche √úberpr√ºfungen f√ºr gef√§hrdete Cookies

#### **Grundlegende √úberpr√ºfungen**

- Der **Cookie** ist jedes Mal **gleich**, wenn Sie sich **anmelden**.
- Melden Sie sich ab und versuchen Sie denselben Cookie zu verwenden.
- Versuchen Sie, sich mit 2 Ger√§ten (oder Browsern) am selben Konto mit demselben Cookie anzumelden.
- √úberpr√ºfen Sie, ob der Cookie Informationen enth√§lt und versuchen Sie, diese zu √§ndern.
- Versuchen Sie, mehrere Konten mit fast demselben Benutzernamen zu erstellen und pr√ºfen Sie, ob √Ñhnlichkeiten erkennbar sind.
- √úberpr√ºfen Sie die Option "**Angemeldet bleiben**", falls vorhanden, um zu sehen, wie sie funktioniert. Wenn sie vorhanden ist und gef√§hrdet sein k√∂nnte, verwenden Sie immer nur den Cookie von **Angemeldet bleiben** ohne andere Cookies.
- √úberpr√ºfen Sie, ob der vorherige Cookie auch nach einer Passwort√§nderung funktioniert.

#### **Fortgeschrittene Cookie-Angriffe**

Wenn der Cookie beim Einloggen gleich bleibt (oder fast gleich), bedeutet dies wahrscheinlich, dass der Cookie mit einem Feld Ihres Kontos zusammenh√§ngt (wahrscheinlich dem Benutzernamen). Dann k√∂nnen Sie:

- Versuchen Sie, viele **Konten** mit sehr **√§hnlichen** Benutzernamen zu erstellen und versuchen Sie zu **erraten**, wie der Algorithmus funktioniert.
- Versuchen Sie, den Benutzernamen **bruteforce**. Wenn der Cookie nur als Authentifizierungsmethode f√ºr Ihren Benutzernamen gespeichert wird, k√∂nnen Sie ein Konto mit dem Benutzernamen "**Bmin**" erstellen und jeden einzelnen **Bit** Ihres Cookies **bruteforcen**, da einer der Cookies, den Sie ausprobieren werden, zu "**admin**" geh√∂rt.
- Versuchen Sie **Padding Oracle** (Sie k√∂nnen den Inhalt des Cookies entschl√ºsseln). Verwenden Sie **padbuster**.

**Padding Oracle - Padbuster-Beispiele**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster wird mehrere Versuche unternehmen und Sie nach der Fehlerbedingung fragen (die ung√ºltige).

Dann wird es beginnen, das Cookie zu entschl√ºsseln (es kann mehrere Minuten dauern).

Wenn der Angriff erfolgreich war, k√∂nnten Sie versuchen, einen String Ihrer Wahl zu verschl√ºsseln. Zum Beispiel, wenn Sie **user=administrator** **verschl√ºsseln** m√∂chten.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Diese Ausf√ºhrung gibt Ihnen das Cookie korrekt verschl√ºsselt und codiert mit dem String **user=administrator** darin.

**CBC-MAC**

M√∂glicherweise hat ein Cookie einen Wert und k√∂nnte mit CBC signiert werden. Dann ist die Integrit√§t des Werts die Signatur, die durch Verwendung von CBC mit dem gleichen Wert erstellt wurde. Da empfohlen wird, als IV einen Nullvektor zu verwenden, k√∂nnte diese Art der Integrit√§tspr√ºfung anf√§llig sein.

**Der Angriff**

1. Erhalten Sie die Signatur des Benutzernamens **administ** = **t**
2. Erhalten Sie die Signatur des Benutzernamens **rator\x00\x00\x00 XOR t** = **t'**
3. Setzen Sie im Cookie den Wert **administrator+t'** (**t'** wird eine g√ºltige Signatur von **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00** sein

**ECB**

Wenn das Cookie mit ECB verschl√ºsselt ist, k√∂nnte es anf√§llig sein.\
Wenn Sie sich einloggen, muss das Cookie, das Sie erhalten, immer dasselbe sein.

**Wie man erkennt und angreift:**

Erstellen Sie 2 Benutzer mit fast denselben Daten (Benutzername, Passwort, E-Mail usw.) und versuchen Sie, ein Muster im gegebenen Cookie zu entdecken

Erstellen Sie einen Benutzer namens zum Beispiel "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" und √ºberpr√ºfen Sie, ob im Cookie ein Muster vorhanden ist (da ECB mit demselben Schl√ºssel jeden Block verschl√ºsselt, k√∂nnten dieselben verschl√ºsselten Bytes erscheinen, wenn der Benutzername verschl√ºsselt ist).

Es sollte ein Muster geben (mit der Gr√∂√üe eines verwendeten Blocks). Daher k√∂nnen Sie, wenn Sie wissen, wie eine Menge von "a" verschl√ºsselt ist, einen Benutzernamen erstellen: "a"\*(Gr√∂√üe des Blocks)+"admin". Dann k√∂nnten Sie das verschl√ºsselte Muster eines Blocks von "a" aus dem Cookie l√∂schen. Und Sie haben das Cookie des Benutzernamens "admin".

## Referenzen

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

**Try Hard Security Group**

<figure><img src="/.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
