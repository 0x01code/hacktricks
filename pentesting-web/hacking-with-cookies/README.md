# Piratage de Cookies

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trouvez les vulnérabilités les plus importantes afin de pouvoir les corriger plus rapidement. Intruder suit votre surface d'attaque, effectue des analyses de menace proactives, trouve des problèmes dans l'ensemble de votre pile technologique, des API aux applications web et aux systèmes cloud. [**Essayez-le gratuitement**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) dès aujourd'hui.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Attributs des Cookies

### Expires & Max-Age

* `Expires` définit une date d'expiration pour la suppression d'un cookie
* `Max-age` définit le temps en secondes avant la suppression d'un cookie **(utilisez cela, nous ne sommes plus en 2009)**

### **Domaine**

L'attribut `Domain` spécifie **quels hôtes peuvent recevoir un cookie**. S'il n'est pas spécifié, l'attribut **par défaut** est l'**hôte lui-même**, _**à l'exclusion des sous-domaines**_. **Si `Domain` est spécifié**, alors **les sous-domaines sont toujours inclus**. Par conséquent, spécifier `Domain` est moins restrictif que l'omission. Cependant, cela peut être utile lorsque les sous-domaines doivent partager des informations sur un utilisateur.

Par exemple, si vous définissez `Domain=mozilla.org`, les cookies sont disponibles sur des sous-domaines tels que `developer.mozilla.org`. Mais si vous ne le faites pas, le cookie ne sera pas envoyé aux sous-domaines.

Si un **sous-domaine** `sub.example.com` **définit un cookie** avec l'attribut _domain_ de **`.example.com`**, il sera **envoyé** avec les requêtes vers le **domaine parent**.

### **Chemin**

L'attribut `Path` indique un **chemin d'URL qui doit exister dans l'URL demandée pour envoyer l'en-tête `Cookie`**. Le caractère `%x2F` ("/") est considéré comme un séparateur de répertoire, et les sous-répertoires correspondent également.

#### Ordre

Lorsque 2 cookies ont le **même nom**, celui qui est envoyé est :

* Celui avec le **chemin le plus long** correspondant au chemin de l'URL
* Le **plus récent** si les deux ont le même chemin

### SameSite

Cela indiquera au navigateur si le **cookie** peut être envoyé **à partir d'autres domaines**. Il a 3 valeurs possibles :

* **Strict** : Le cookie ne sera pas envoyé avec une requête par des sites tiers.
* **Lax** : Le cookie sera envoyé avec la requête GET initiée par des sites tiers.
* **None** : Le cookie est envoyé depuis n'importe quel domaine tiers.

| **Type de requête** | **Code d'exemple**                  | **Cookies envoyés lorsque** |
| ------------------- | ---------------------------------- | --------------------------- |
| Lien                | \<a href="...">\</a>               | NotSet\*, Lax, None         |
| Préchargement       | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None         |
| Formulaire GET      | \<form method="GET" action="...">  | NotSet\*, Lax, None         |
| Formulaire POST     | \<form method="POST" action="..."> | NotSet\*, None              |
| iframe              | \<iframe src="...">\</iframe>      | NotSet\*, None              |
| AJAX                | $.get("...")                       | NotSet\*, None              |
| Image               | \<img src="...">                   | NetSet\*, None              |

Tableau provenant de [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) et légèrement modifié.\
Un cookie avec l'attribut _**SameSite**_ permettra de **mitiger les attaques CSRF** où une session connectée est nécessaire.

**\*Notez qu'à partir de Chrome80 (fév/2019), le comportement par défaut d'un cookie sans attribut SameSite sera lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Notez que temporairement, après l'application de ce changement, les **cookies sans politique SameSite** dans Chrome seront **traités comme None** pendant les **2 premières minutes, puis comme Lax pour les requêtes POST inter-sites de premier niveau**.
## Drapeaux des cookies

### HttpOnly

Cela empêche le **client** d'accéder au cookie (via **Javascript** par exemple: `document.cookie`)

#### **Contournements**

* Si la page envoie les cookies en tant que réponse d'une requête (par exemple dans une page **PHPinfo**), il est possible d'exploiter la faille XSS pour envoyer une requête à cette page et **voler les cookies** de la réponse (consultez un exemple sur [https://hackcommander.github.io/pentesting-article-1/)](https://hackcommander.github.io/pentesting-article-1/)
* Cela peut être contourné avec des requêtes **TRACE** **HTTP** car la réponse du serveur (si cette méthode HTTP est disponible) reflétera les cookies envoyés. Cette technique s'appelle le **suivi entre sites**.
* Cette technique est évitée par les **navigateurs modernes en n'autorisant pas l'envoi d'une requête TRACE** depuis JS. Cependant, des contournements ont été trouvés dans des logiciels spécifiques, comme l'envoi de `\r\nTRACE` au lieu de `TRACE` à IE6.0 SP2.
* Une autre méthode consiste à exploiter des vulnérabilités zero/day des navigateurs.
* Il est possible de **remplacer les cookies HttpOnly** en effectuant une attaque de débordement de Cookie Jar :

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Il est possible d'utiliser une attaque de [**smuggling de cookies**](./#cookie-smuggling) pour exfiltrer ces cookies.

### Secure

La requête enverra le cookie **uniquement** si la requête est transmise via un canal sécurisé (typiquement **HTTPS**).

## Préfixes des cookies

Préfixe **`__Secure-`** : doit être défini avec le drapeau `secure` à partir d'une page sécurisée (HTTPS).

Préfixe **`__Host-`** : doit être défini avec le drapeau `secure`, doit provenir d'une page sécurisée (HTTPS), ne doit pas avoir de domaine spécifié (et donc, n'est pas envoyé aux sous-domaines), et le chemin doit être `/`.

Les cookies préfixés par **`__Host-`** ne peuvent pas être envoyés aux superdomaines (cookies des sous-domaines vers les domaines) ou aux sous-domaines (cookies des domaines vers les sous-domaines), donc, si vous souhaitez isoler les cookies de votre application, préfixer tout avec `__Host-` n'est pas une mauvaise idée.

## Attaques des cookies

Si vous trouvez un type de cookie personnalisé contenant des données sensibles (sessionID, nom d'utilisateur, e-mails, etc.), vous devriez certainement essayer de l'exploiter.

### Décodage du cookie

Si le **cookie** utilise un **encodage de base** (comme Base64) ou similaire, vous pourrez peut-être le **décoder**, **modifier** le **contenu** et **usurper** des utilisateurs arbitraires.

### Détournement de session

Vol d'un cookie et utilisation pour se faire passer pour l'utilisateur dans une application.

### Fixation de session

L'attaquant obtient un cookie à partir d'une page web et envoie un lien à la victime pour **se connecter en utilisant le même cookie**. Si le cookie n'est pas modifié lorsqu'un utilisateur se connecte, cela peut être utile car l'attaquant pourrait être en mesure de se faire passer pour l'utilisateur grâce à un cookie.

Si vous trouvez un **XSS dans un sous-domaine** ou que vous **contrôlez un sous-domaine**, lisez :

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Don de session

L'attaquant envoie sa propre session à la victime. La victime verra qu'elle est déjà connectée et supposera qu'elle est dans son compte, mais **les actions seront effectuées dans le compte de l'attaquant**.

Si vous trouvez un **XSS dans un sous-domaine** ou que vous **contrôlez un sous-domaine**, lisez :

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [Cookie JWT](../hacking-jwt-json-web-tokens.md)

Cliquez sur le lien précédent pour accéder à une page expliquant les failles possibles dans les JWT.

### Cookie vide

Les navigateurs autorisent un cookie avec un nom vide.
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // empty name
document.cookie = "b=v2"
```
Cela entraîne l'envoi de l'en-tête cookie suivant :
```
a=v1; test value; b=v2;
```
Plus intéressant encore, si vous disposez d'un vecteur qui vous permet d'une manière ou d'une autre de **définir le cookie vide**, vous pouvez **contrôler n'importe quel autre cookie** :
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // this sets the empty cookie to a=b
```
Bien que, en interne dans le navigateur, cela soit défini comme un cookie sans nom, cela se traduira par l'en-tête du cookie envoyé :
```
a=b;
```
Cela signifie que chaque serveur web l'interprétera comme le cookie `a` étant défini avec la valeur `b`.

### Bug Chrome - corruption de document.cookie <a href="#chrome-bugdocumentcookie-corruption" id="chrome-bugdocumentcookie-corruption"></a>

Si un point de code de substitution Unicode est présent dans un cookie défini, `document.cookie` sera corrompu de manière permanente et renverra une chaîne vide.
```js
document.cookie
// "a=b;"
document.cookie = "\ud800=meep";
document.cookie
// ""
```
### Contrebande de cookies

Plusieurs serveurs web, y compris les serveurs Java Jetty, TomCat, Undertow, et le framework web Python Zope, ainsi que les serveurs/frameworks web Python tels que cherrypy, web.py, aiohttp server, bottle et webob, sont **incapables d'analyser correctement les chaînes de cookies** en raison du support restant pour RFC2965, un mécanisme de citation de cookies obsolète qui utilise RFC2616 pour la définition d'une chaîne entre guillemets.

Plus précisément, **ces serveurs continuent de lire une chaîne de cookies lorsqu'ils rencontrent une valeur de cookie entre guillemets doubles (dquoted), même si un point-virgule est rencontré**. Cela pose problème car **les points-virgules sont censés séparer les paires clé-valeur** dans la chaîne de cookies.

Par exemple, si un **navigateur envoie trois cookies, RENDER\_TEXT, JSESSIONID,** et **ASDF:**
```basic
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
Ces serveurs les interprètent comme faisant partie d'une **seule valeur de cookie** plutôt que de trois cookies distincts.

Cela entraîne un risque de sécurité : si un attaquant obtient un accès cross-site scripting (XSS), il peut utiliser cette faille pour **exfiltrer des cookies sensibles tels que les cookies HttpOnly**.

### Injection de cookie

De nombreux serveurs Web, dont Undertow de Java, Zope de Python et ceux utilisant http.cookie.SimpleCookie et http.cookie.BaseCookie de la bibliothèque standard de Python, ont été trouvés pour **analyser incorrectement les cookies, en utilisant de mauvais délimiteurs pour commencer la prochaine paire nom/valeur de cookie**. Cela permet à un attaquant de **fausser plusieurs cookies tout en ne contrôlant qu'une seule valeur de cookie**.

Dans le cas d'**Undertow**, il commence à analyser le cookie suivant immédiatement après la **fin d'une valeur de cookie entre guillemets**, sans attendre un point-virgule :
```bash
LANGUAGE="en-us" CSRF_TOKEN="SPOOFED_VALUE"
```
**Zope** commence à analyser le cookie suivant sur une **virgule** :
```bash
LANGUAGE=en-us,CSRF_TOKEN=SPOOFED_VALUE
```
Et **SimpleCookie de Python** et **BaseCookie** commencent immédiatement à analyser le cookie suivant sur un caractère **espace** :
```
LANGUAGE=en-us CSRF_TOKEN=SPOOFED_VALUE
```
En conséquence, des serveurs tels que **cherrypy**, **web.py**, le serveur **aiohttp**, **bottle** et **webob** (Pyramid, TurboGears) sont tous vulnérables à ce type d'attaque.

Ce problème présente des **implications de sécurité** importantes. Par exemple, si une application web utilise une **protection CSRF basée sur les cookies**, un attaquant peut **injecter** un **cookie de jeton CSRF falsifié** pour contourner cette protection. De plus, le dernier cookie portant le même nom dans les packages http.cookie de Python remplace tous les précédents, ce qui rend ce type d'attaque particulièrement facile.

De plus, le **falsification** des cookies **`__Secure-`** et **`__Host-`** peut être exploitée dans un contexte non sécurisé. De plus, dans une configuration où les cookies sont transmis à un serveur backend, une **injection de cookie pourrait entraîner des contournements d'autorisation** si le serveur backend est vulnérable à la falsification mais que le serveur frontend ne l'est pas.

### Vérifications supplémentaires des cookies vulnérables

#### **Vérifications de base**

* Le **cookie** est le **même** à chaque fois que vous **vous connectez**.
* Déconnectez-vous et essayez d'utiliser le même cookie.
* Essayez de vous connecter avec 2 appareils (ou navigateurs) sur le même compte en utilisant le même cookie.
* Vérifiez si le cookie contient des informations et essayez de le modifier.
* Essayez de créer plusieurs comptes avec des noms d'utilisateur presque identiques et vérifiez s'il y a des similitudes.
* Vérifiez l'option "**se souvenir de moi**" si elle existe pour voir comment elle fonctionne. Si elle existe et peut être vulnérable, utilisez toujours le cookie de **se souvenir de moi** sans aucun autre cookie.
* Vérifiez si le cookie précédent fonctionne même après avoir changé le mot de passe.

#### **Attaques avancées sur les cookies**

Si le cookie reste le même (ou presque) lorsque vous vous connectez, cela signifie probablement que le cookie est lié à un champ de votre compte (probablement le nom d'utilisateur). Vous pouvez alors :

* Essayez de créer de nombreux **comptes** avec des noms d'utilisateur très **similaires** et essayez de **deviner** comment fonctionne l'algorithme.
* Essayez de **forcer le nom d'utilisateur**. Si le cookie ne sert qu'à l'authentification de votre nom d'utilisateur, vous pouvez créer un compte avec le nom d'utilisateur "**Bmin**" et **forcer** chaque **bit** de votre cookie car l'un des cookies que vous essayerez sera celui appartenant à "**admin**".
* Essayez **Padding Oracle** (vous pouvez décrypter le contenu du cookie). Utilisez **padbuster**.

**Padding Oracle - Exemples de Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster effectuera plusieurs tentatives et vous demandera quelle condition est la condition d'erreur (celle qui n'est pas valide).

Ensuite, il commencera à décrypter le cookie (cela peut prendre plusieurs minutes).

Si l'attaque a réussi, vous pouvez essayer de chiffrer une chaîne de votre choix. Par exemple, si vous souhaitez **chiffrer** **user=administrateur**.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Cette exécution vous donnera le cookie correctement chiffré et encodé avec la chaîne **user=administrator** à l'intérieur.

**CBC-MAC**

Il est possible qu'un cookie ait une valeur et soit signé en utilisant CBC. Ainsi, l'intégrité de la valeur est la signature créée en utilisant CBC avec la même valeur. Comme il est recommandé d'utiliser un vecteur IV nul, ce type de vérification d'intégrité peut être vulnérable.

**L'attaque**

1. Obtenez la signature de l'utilisateur **administ** = **t**
2. Obtenez la signature de l'utilisateur **rator\x00\x00\x00 XOR t** = **t'**
3. Définissez dans le cookie la valeur **administrator+t'** (**t'** sera une signature valide de **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Si le cookie est chiffré en utilisant ECB, il peut être vulnérable.\
Lorsque vous vous connectez, le cookie que vous recevez doit toujours être le même.

**Comment détecter et attaquer :**

Créez 2 utilisateurs avec des données presque identiques (nom d'utilisateur, mot de passe, e-mail, etc.) et essayez de découvrir un certain schéma à l'intérieur du cookie donné.

Créez un utilisateur appelé par exemple "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" et vérifiez s'il y a un schéma dans le cookie (comme ECB chiffre avec la même clé chaque bloc, les mêmes octets chiffrés peuvent apparaître si le nom d'utilisateur est chiffré).

Il devrait y avoir un schéma (avec la taille d'un bloc utilisé). Ainsi, en connaissant la façon dont un tas de "a" est chiffré, vous pouvez créer un nom d'utilisateur : "a"\*(taille du bloc)+"admin". Ensuite, vous pouvez supprimer le schéma chiffré d'un bloc de "a" du cookie. Et vous aurez le cookie de l'utilisateur "admin".

## Références

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trouvez les vulnérabilités les plus importantes afin de pouvoir les corriger plus rapidement. Intruder suit votre surface d'attaque, effectue des analyses de menaces proactives, trouve des problèmes dans l'ensemble de votre pile technologique, des API aux applications web et aux systèmes cloud. [**Essayez-le gratuitement**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) dès aujourd'hui.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Vous travaillez dans une **entreprise de cybersécurité** ? Vous souhaitez voir votre **entreprise annoncée dans HackTricks** ? ou souhaitez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
