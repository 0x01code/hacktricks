# Hacking dei Cookie

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† pi√π importanti in modo da poterle correggere pi√π velocemente. Intruder traccia la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi stesso.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Attributi dei Cookie

I cookie sono dotati di diversi attributi che ne controllano il comportamento nel browser dell'utente. Ecco una panoramica di questi attributi in una voce pi√π passiva:

### Scadenza e Max-Age

La data di scadenza di un cookie √® determinata dall'attributo `Expires`. Al contrario, l'attributo `Max-age` definisce il tempo in secondi fino alla cancellazione di un cookie. **Optare per `Max-age` in quanto riflette pratiche pi√π moderne.**

### Dominio

Gli host che ricevono un cookie sono specificati dall'attributo `Domain`. Per impostazione predefinita, questo √® impostato sull'host che ha emesso il cookie, senza includere i suoi sottodomini. Tuttavia, quando l'attributo `Domain` √® impostato esplicitamente, comprende anche i sottodomini. Ci√≤ rende la specifica dell'attributo `Domain` una opzione meno restrittiva, utile per scenari in cui √® necessario condividere cookie tra sottodomini. Ad esempio, impostando `Domain=mozilla.org` i cookie sono accessibili anche sui suoi sottodomini come `developer.mozilla.org`.

### Percorso

Un percorso URL specifico che deve essere presente nell'URL richiesto affinch√© l'intestazione `Cookie` venga inviata √® indicato dall'attributo `Path`. Questo attributo considera il carattere `/` come separatore di directory, consentendo corrispondenze anche nelle sottodirectory.

### Regole di ordinamento

Quando due cookie hanno lo stesso nome, quello scelto per l'invio si basa su:
- Il cookie che corrisponde al percorso pi√π lungo nell'URL richiesto.
- Il cookie impostato pi√π di recente se i percorsi sono identici.

### SameSite

- L'attributo `SameSite` indica se i cookie vengono inviati nelle richieste provenienti da domini di terze parti. Offre tre impostazioni:
- **Strict**: Limita l'invio del cookie nelle richieste di terze parti.
- **Lax**: Consente l'invio del cookie con richieste GET avviate da siti web di terze parti.
- **None**: Consente l'invio del cookie da qualsiasi dominio di terze parti.

Ricorda, durante la configurazione dei cookie, la comprensione di questi attributi pu√≤ aiutare a garantire che si comportino come previsto in diversi scenari.


| **Tipo di richiesta** | **Codice di esempio**               | **Cookie inviati quando** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Immagine            | \<img src="...">                   | NetSet\*, None        |

Tabella da [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) e leggermente modificata.\
Un cookie con l'attributo _**SameSite**_ **mitiga gli attacchi CSRF** in cui √® necessaria una sessione di accesso.

**\*Nota che a partire da Chrome80 (feb/2019) il comportamento predefinito di un cookie senza un attributo samesite** **sar√† lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Nota che temporaneamente, dopo l'applicazione di questa modifica, i **cookie senza una politica SameSite** in Chrome verranno **trattati come None** durante i **primi 2 minuti e poi come Lax per le richieste POST cross-site di primo livello.**

## Flag dei Cookie

### HttpOnly

Questo impedisce al **client** di accedere al cookie (tramite **Javascript**, ad esempio: `document.cookie`)

#### **Bypass**

* Se la pagina sta **inviando i cookie come risposta** di una richiesta (ad esempio in una pagina **PHPinfo**), √® possibile sfruttare l'XSS per inviare una richiesta a questa pagina e **rubare i cookie** dalla risposta (controlla un esempio in [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Questo pu√≤ essere bypassato con richieste **TRACE** **HTTP** poich√© la risposta dal server (se questo metodo HTTP √® disponibile) rifletter√† i cookie inviati. Questa tecnica √® chiamata **Cross-Site Tracking**.
* Questa tecnica viene evitata dai **browser moderni che non consentono l'invio di una richiesta TRACE** da JS. Tuttavia, sono state trovate alcune bypass a questo in software specifici come l'invio di `\r\nTRACE` invece di `TRACE` a IE6.0 SP2.
* Un altro modo √® lo sfruttamento di vulnerabilit√† zero/day dei browser.
* √à possibile **sovrascrivere i cookie HttpOnly** eseguendo un attacco di overflow del Cookie Jar:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* √à possibile utilizzare l'attacco di [**Cookie Smuggling**](./#cookie-smuggling) per esfiltrare questi cookie

### Secure

La richiesta invier√† il cookie solo in una richiesta HTTP se la richiesta viene trasmessa su un canale sicuro (tipicamente **HTTPS**).
## Prefissi dei Cookie

I cookie con prefisso `__Secure-` devono essere impostati insieme al flag `secure` nelle pagine che sono protette da HTTPS.

Per i cookie con prefisso `__Host-`, devono essere soddisfatte diverse condizioni:
- Devono essere impostati con il flag `secure`.
- Devono provenire da una pagina protetta da HTTPS.
- Non √® consentito specificare un dominio, impedendo cos√¨ la trasmissione ai sottodomini.
- Il percorso per questi cookie deve essere impostato su `/`.

√à importante notare che i cookie con prefisso `__Host-` non possono essere inviati a superdomini o sottodomini. Questa restrizione aiuta a isolare i cookie dell'applicazione. Pertanto, l'utilizzo del prefisso `__Host-` per tutti i cookie dell'applicazione pu√≤ essere considerato una buona pratica per migliorare la sicurezza e l'isolamento.

## Attacchi ai Cookie

Se un cookie personalizzato contiene dati sensibili, controllalo (soprattutto se stai giocando a un CTF), poich√© potrebbe essere vulnerabile.

### Decodifica e Manipolazione dei Cookie

I dati sensibili incorporati nei cookie dovrebbero sempre essere esaminati attentamente. I cookie codificati in Base64 o formati simili possono spesso essere decodificati. Questa vulnerabilit√† consente agli attaccanti di modificare il contenuto del cookie e impersonare altri utenti codificando i loro dati modificati nel cookie.

### Hijacking di Sessione

Questo attacco consiste nel rubare il cookie di un utente per ottenere accesso non autorizzato al suo account all'interno di un'applicazione. Utilizzando il cookie rubato, un attaccante pu√≤ impersonare l'utente legittimo.

### Fixation di Sessione

In questo scenario, un attaccante inganna una vittima affinch√© utilizzi un cookie specifico per effettuare l'accesso. Se l'applicazione non assegna un nuovo cookie al momento del login, l'attaccante, avendo il cookie originale, pu√≤ impersonare la vittima. Questa tecnica si basa sul fatto che la vittima effettua il login con un cookie fornito dall'attaccante.

Se hai trovato un **XSS in un sottodominio** o **controlli un sottodominio**, leggi:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Donazione di Sessione

Qui, l'attaccante convince la vittima a utilizzare il cookie di sessione dell'attaccante. La vittima, credendo di essere loggata nel proprio account, compir√† involontariamente azioni nel contesto dell'account dell'attaccante.

Se hai trovato un **XSS in un sottodominio** o **controlli un sottodominio**, leggi:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [Cookie JWT](../hacking-jwt-json-web-tokens.md)

Clicca sul link precedente per accedere a una pagina che spiega possibili difetti nei JWT.

I JSON Web Tokens (JWT) utilizzati nei cookie possono presentare anche vulnerabilit√†. Per informazioni approfondite su possibili difetti e su come sfruttarli, si consiglia di accedere al documento collegato sull'hacking di JWT.

### Cross-Site Request Forgery (CSRF)

Questo attacco costringe un utente con accesso a eseguire azioni indesiderate su un'applicazione web in cui √® attualmente autenticato. Gli attaccanti possono sfruttare i cookie che vengono inviati automaticamente con ogni richiesta al sito vulnerabile.

### Cookie Vuoti

(Consulta ulteriori dettagli nella [ricerca originale](https://blog.ankursundara.com/cookie-bugs/))
I browser consentono la creazione di cookie senza nome, che pu√≤ essere dimostrato tramite JavaScript come segue:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Il risultato nell'intestazione del cookie inviato √® `a=v1; valore di prova; b=v2;`. In modo intrigante, ci√≤ consente la manipolazione dei cookie se viene impostato un cookie con nome vuoto, potenzialmente controllando altri cookie impostando il cookie vuoto su un valore specifico:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
Ci√≤ porta il browser a inviare un'intestazione del cookie interpretata da ogni server web come un cookie chiamato `a` con un valore `b`.

#### Bug di Chrome: Problema dei punti di codice surrogati Unicode

In Chrome, se un punto di codice surrogato Unicode fa parte di un cookie impostato, `document.cookie` diventa corrotto, restituendo successivamente una stringa vuota:
```js
document.cookie = "\ud800=meep";
```
Ci√≤ comporta che `document.cookie` restituisce una stringa vuota, indicando una corruzione permanente.

#### Smuggling dei Cookie a causa di problemi di parsing

(Verifica ulteriori dettagli nella [ricerca originale](https://blog.ankursundara.com/cookie-bugs/))
Diversi server web, tra cui quelli di Java (Jetty, TomCat, Undertow) e Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), gestiscono in modo errato le stringhe dei cookie a causa del supporto obsoleto di RFC2965. Leggono un valore del cookie tra virgolette doppie come un singolo valore anche se include punti e virgola, che normalmente dovrebbero separare le coppie chiave-valore:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Vulnerabilit√† di Iniezione di Cookie

(Verifica ulteriori dettagli nella [ricerca originale](https://blog.ankursundara.com/cookie-bugs/))
L'errata interpretazione dei cookie da parte dei server, in particolare Undertow, Zope e quelli che utilizzano `http.cookie.SimpleCookie` e `http.cookie.BaseCookie` di Python, crea opportunit√† per attacchi di iniezione di cookie. Questi server non delimitano correttamente l'inizio di nuovi cookie, consentendo agli attaccanti di falsificare i cookie:

- Undertow si aspetta un nuovo cookie immediatamente dopo un valore tra virgolette senza punto e virgola.
- Zope cerca una virgola per iniziare l'analisi del cookie successivo.
- Le classi dei cookie di Python iniziano l'analisi su un carattere di spazio.

Questa vulnerabilit√† √® particolarmente pericolosa nelle applicazioni web che si basano sulla protezione CSRF basata sui cookie, in quanto consente agli attaccanti di iniettare cookie falsificati di token CSRF, potenzialmente eludendo le misure di sicurezza. Il problema √® aggravato dalla gestione dei cookie duplicati di Python, dove l'ultima occorrenza prevale su quelle precedenti. Solleva anche preoccupazioni per i cookie `__Secure-` e `__Host-` in contesti non sicuri e potrebbe portare a bypass dell'autorizzazione quando i cookie vengono passati a server back-end suscettibili di falsificazione.


### Controlli Extra per Cookie Vulnerabili

#### **Controlli di base**

* Il **cookie** √® **sempre lo stesso** ogni volta che effettui il **login**.
* Effettua il logout e prova a utilizzare lo stesso cookie.
* Prova a effettuare il login con 2 dispositivi (o browser) nello stesso account utilizzando lo stesso cookie.
* Verifica se il cookie contiene informazioni e prova a modificarlo.
* Prova a creare diversi account con username quasi identici e verifica se puoi trovare delle somiglianze.
* Verifica l'opzione "**ricordami**" se esiste per vedere come funziona. Se esiste e potrebbe essere vulnerabile, utilizza sempre il cookie di **ricordami** senza altri cookie.
* Verifica se il cookie precedente funziona anche dopo aver cambiato la password.

#### **Attacchi avanzati ai cookie**

Se il cookie rimane lo stesso (o quasi) quando effettui il login, ci√≤ probabilmente significa che il cookie √® correlato a qualche campo del tuo account (probabilmente l'username). Quindi puoi:

* Prova a creare molti **account** con username molto **simili** e cerca di **indovinare** come funziona l'algoritmo.
* Prova a **forzare** l'username. Se il cookie salva solo come metodo di autenticazione per il tuo username, puoi creare un account con username "**Bmin**" e **forzare** ogni singolo **bit** del tuo cookie perch√© uno dei cookie che proverai sar√† quello appartenente a "**admin**".
* Prova **Padding** **Oracle** (puoi decrittare il contenuto del cookie). Usa **padbuster**.

**Padding Oracle - Esempi di Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster effettuer√† diversi tentativi e ti chieder√† quale condizione √® la condizione di errore (quella non valida).

Successivamente inizier√† a decifrare il cookie (potrebbe richiedere diversi minuti).

Se l'attacco √® stato eseguito con successo, potresti provare a crittografare una stringa a tua scelta. Ad esempio, se volessi **crittografare** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Questa esecuzione ti dar√† il cookie correttamente crittografato e codificato con la stringa **user=administrator** al suo interno.

**CBC-MAC**

Forse un cookie potrebbe avere un valore e potrebbe essere firmato utilizzando CBC. Quindi, l'integrit√† del valore √® la firma creata utilizzando CBC con lo stesso valore. Poich√© √® consigliabile utilizzare come IV un vettore nullo, questo tipo di controllo di integrit√† potrebbe essere vulnerabile.

**L'attacco**

1. Ottieni la firma dell'username **administ** = **t**
2. Ottieni la firma dell'username **rator\x00\x00\x00 XOR t** = **t'**
3. Imposta nel cookie il valore **administrator+t'** (**t'** sar√† una firma valida di **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Se il cookie √® crittografato utilizzando ECB potrebbe essere vulnerabile.\
Quando effettui l'accesso, il cookie che ricevi deve essere sempre lo stesso.

**Come rilevare e attaccare:**

Crea 2 utenti con dati quasi identici (username, password, email, ecc.) e cerca di scoprire qualche schema all'interno del cookie fornito

Crea un utente chiamato ad esempio "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" e verifica se c'√® qualche schema nel cookie (poich√© ECB crittografa con la stessa chiave ogni blocco, gli stessi byte crittografati potrebbero apparire se l'username √® crittografato).

Dovrebbe esserci uno schema (con la dimensione di un blocco utilizzato). Quindi, sapendo come sono crittografati un gruppo di "a", puoi creare un username: "a"\*(dimensione del blocco)+"admin". Quindi, puoi eliminare lo schema crittografato di un blocco di "a" dal cookie. E avrai il cookie dell'username "admin".

## Riferimenti

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† che contano di pi√π in modo da poterle correggere pi√π velocemente. Intruder traccia la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi stesso.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
