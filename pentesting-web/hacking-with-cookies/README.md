# Hackeo de Cookies

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** 춰Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hackeo enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

**Grupo de Seguridad Try Hard**

<figure><img src="../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Atributos de las Cookies

Las cookies vienen con varios atributos que controlan su comportamiento en el navegador del usuario. Aqu칤 tienes una descripci칩n de estos atributos en una voz m치s pasiva:

### Caduca y Max-Age

La fecha de caducidad de una cookie est치 determinada por el atributo `Expires`. Por otro lado, el atributo `Max-age` define el tiempo en segundos hasta que una cookie se elimina. **Opta por `Max-age` ya que refleja pr치cticas m치s modernas.**

### Dominio

Los hosts que reciben una cookie est치n especificados por el atributo `Domain`. Por defecto, esto se establece en el host que emiti칩 la cookie, sin incluir sus subdominios. Sin embargo, cuando se establece expl칤citamente el atributo `Domain`, tambi칠n abarca los subdominios. Esto hace que la especificaci칩n del atributo `Domain` sea una opci칩n menos restrictiva, 칰til para escenarios donde es necesaria la compartici칩n de cookies entre subdominios. Por ejemplo, establecer `Domain=mozilla.org` hace que las cookies sean accesibles en sus subdominios como `developer.mozilla.org`.

### Ruta

Una ruta URL espec칤fica que debe estar presente en la URL solicitada para que se env칤e el encabezado `Cookie` est치 indicada por el atributo `Path`. Este atributo considera el car치cter `/` como un separador de directorios, permitiendo coincidencias en subdirectorios tambi칠n.

### Reglas de Orden

Cuando dos cookies tienen el mismo nombre, la elecci칩n de cu치l enviar se basa en:

* La cookie que coincide con la ruta m치s larga en la URL solicitada.
* La cookie m치s recientemente establecida si las rutas son id칠nticas.

### SameSite

* El atributo `SameSite` dicta si las cookies se env칤an en solicitudes originadas desde dominios de terceros. Ofrece tres configuraciones:
* **Strict**: Restringe que la cookie se env칤e en solicitudes de terceros.
* **Lax**: Permite que la cookie se env칤e con solicitudes GET iniciadas por sitios web de terceros.
* **None**: Permite que la cookie se env칤e desde cualquier dominio de terceros.

Recuerda que al configurar cookies, comprender estos atributos puede ayudar a garantizar que se comporten como se espera en diferentes escenarios.

| **Tipo de Solicitud** | **C칩digo de Ejemplo**               | **Cookies Enviadas Cuando** |
| --------------------- | ---------------------------------- | --------------------------- |
| Enlace               | \<a href="...">\</a>               | NotSet\*, Lax, None         |
| Precarga             | \<link rel="precarga" href=".."/>   | NotSet\*, Lax, None         |
| Formulario GET        | \<form method="GET" action="...">  | NotSet\*, Lax, None         |
| Formulario POST       | \<form method="POST" action="..."> | NotSet\*, None              |
| iframe               | \<iframe src="...">\</iframe>      | NotSet\*, None              |
| AJAX                 | $.get("...")                       | NotSet\*, None              |
| Imagen               | \<img src="...">                   | NetSet\*, None              |

Tabla de [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) y ligeramente modificada.\
Una cookie con el atributo _**SameSite**_ ayudar치 a **mitigar ataques CSRF** donde se necesita una sesi칩n iniciada.

**\*Ten en cuenta que a partir de Chrome80 (feb/2019) el comportamiento predeterminado de una cookie sin un atributo samesite** **ser치 laxo** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Ten en cuenta que temporalmente, despu칠s de aplicar este cambio, las **cookies sin una pol칤tica SameSite** en Chrome se tratar치n como None durante los **primeros 2 minutos y luego como Lax para solicitudes POST entre sitios de nivel superior.**

## Banderas de las Cookies

### HttpOnly

Esto evita que el **cliente** acceda a la cookie (por ejemplo, a trav칠s de **Javascript** con `document.cookie`)

#### **Bypasses**

* Si la p치gina est치 **enviando las cookies como respuesta** de una solicitud (por ejemplo, en una p치gina **PHPinfo**), es posible abusar del XSS para enviar una solicitud a esta p치gina y **robar las cookies** de la respuesta (consulta un ejemplo en [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Esto podr칤a ser evitado con solicitudes **HTTP TRACE** ya que la respuesta del servidor (si este m칠todo HTTP est치 disponible) reflejar치 las cookies enviadas. Esta t칠cnica se llama **Cross-Site Tracking**.
* Esta t칠cnica es evitada por **navegadores modernos al no permitir el env칤o de una solicitud TRACE** desde JS. Sin embargo, se han encontrado algunas formas de evadir esto en software espec칤fico como enviar `\r\nTRACE` en lugar de `TRACE` a IE6.0 SP2.
* Otra forma es la explotaci칩n de vulnerabilidades zero/day de los navegadores.
* Es posible **sobrescribir cookies HttpOnly** realizando un ataque de desbordamiento de Cookie Jar:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Es posible utilizar un ataque de [**Cookie Smuggling**](./#cookie-smuggling) para extraer estas cookies

### Secure

La solicitud **solo** enviar치 la cookie en una solicitud HTTP si la solicitud se transmite a trav칠s de un canal seguro (t칤picamente **HTTPS**).

## Prefijos de las Cookies

Las cookies con prefijo `__Secure-` deben ser establecidas junto con la bandera `secure` en p치ginas que est치n aseguradas por HTTPS.

Para las cookies con prefijo `__Host-`, se deben cumplir varias condiciones:

* Deben ser establecidas con la bandera `secure`.
* Deben originarse desde una p치gina asegurada por HTTPS.
* Se proh칤be especificar un dominio para estas cookies, evitando su transmisi칩n a subdominios.
* La ruta para estas cookies debe establecerse en `/`.

Es importante tener en cuenta que las cookies con prefijo `__Host-` no est치n permitidas para ser enviadas a superdominios o subdominios. Esta restricci칩n ayuda a aislar las cookies de la aplicaci칩n. Por lo tanto, utilizar el prefijo `__Host-` para todas las cookies de la aplicaci칩n puede considerarse una buena pr치ctica para mejorar la seguridad y el aislamiento.
### Sobrescribiendo cookies

Entonces, una de las protecciones de las cookies con prefijo `__Host-` es evitar que sean sobrescritas desde subdominios. Previniendo, por ejemplo, ataques de [**Cookie Tossing**](cookie-tossing.md). En la charla [**Cookie Crumbles: Revelando Vulnerabilidades de Integridad de Sesi칩n Web**](https://www.youtube.com/watch?v=F\_wAzF4a7Xg) ([**documento**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) se presenta que era posible establecer cookies con prefijo `__HOST-` desde subdominios, enga침ando al analizador, por ejemplo, agregando "=" al principio o al principio y al final...:

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

O en PHP era posible agregar **otros caracteres al principio** del nombre de la cookie que iban a ser **reemplazados por caracteres de guion bajo**, permitiendo sobrescribir cookies `__HOST-`:

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Ataques a Cookies

Si una cookie personalizada contiene datos sensibles, rev칤sela (especialmente si est치 participando en un CTF), ya que podr칤a ser vulnerable.

### Decodificaci칩n y Manipulaci칩n de Cookies

Los datos sensibles incrustados en las cookies siempre deben ser examinados. Las cookies codificadas en Base64 u otros formatos similares a menudo pueden ser decodificadas. Esta vulnerabilidad permite a los atacantes alterar el contenido de la cookie e impersonar a otros usuarios codificando sus datos modificados de vuelta en la cookie.

### Secuestro de Sesi칩n

Este ataque implica robar la cookie de un usuario para obtener acceso no autorizado a su cuenta dentro de una aplicaci칩n. Al utilizar la cookie robada, un atacante puede hacerse pasar por el usuario leg칤timo.

### Fijaci칩n de Sesi칩n

En este escenario, un atacante enga침a a una v칤ctima para que use una cookie espec칤fica para iniciar sesi칩n. Si la aplicaci칩n no asigna una nueva cookie al iniciar sesi칩n, el atacante, que posee la cookie original, puede hacerse pasar por la v칤ctima. Esta t칠cnica depende de que la v칤ctima inicie sesi칩n con una cookie proporcionada por el atacante.

Si encuentras un **XSS en un subdominio** o **controlas un subdominio**, lee:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Donaci칩n de Sesi칩n

Aqu칤, el atacante convence a la v칤ctima de usar la cookie de sesi칩n del atacante. La v칤ctima, creyendo que ha iniciado sesi칩n en su propia cuenta, realizar치 acciones inadvertidamente en el contexto de la cuenta del atacante.

Si encuentras un **XSS en un subdominio** o **controlas un subdominio**, lee:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [Cookies JWT](../hacking-jwt-json-web-tokens.md)

Haz clic en el enlace anterior para acceder a una p치gina que explica posibles fallas en JWT.

Los Tokens Web JSON (JWT) utilizados en cookies tambi칠n pueden presentar vulnerabilidades. Para obtener informaci칩n detallada sobre posibles fallas y c칩mo explotarlas, se recomienda acceder al documento vinculado sobre el hacking de JWT.

### Falsificaci칩n de Petici칩n entre Sitios (CSRF)

Este ataque obliga a un usuario con sesi칩n iniciada a ejecutar acciones no deseadas en una aplicaci칩n web en la que actualmente est치 autenticado. Los atacantes pueden explotar cookies que se env칤an autom치ticamente con cada solicitud al sitio vulnerable.

### Cookies Vac칤as

(Consulta m치s detalles en la [investigaci칩n original](https://blog.ankursundara.com/cookie-bugs/)) Los navegadores permiten la creaci칩n de cookies sin un nombre, lo cual se puede demostrar a trav칠s de JavaScript de la siguiente manera:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
El resultado en la cabecera de la cookie enviada es `a=v1; valor de prueba; b=v2;`. Curiosamente, esto permite la manipulaci칩n de cookies si se establece una cookie con nombre vac칤o, potencialmente controlando otras cookies al establecer la cookie vac칤a en un valor espec칤fico:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
#### Problema de Chrome: Problema de Punto de C칩digo de Sustituci칩n Unicode

En Chrome, si un punto de c칩digo de sustituci칩n Unicode es parte de una cookie establecida, `document.cookie` se corrompe, devolviendo posteriormente una cadena vac칤a:
```js
document.cookie = "\ud800=meep";
```
Esto resulta en que `document.cookie` produzca una cadena vac칤a, lo que indica corrupci칩n permanente.

#### Contrabando de Cookies Debido a Problemas de An치lisis

(Consulte m치s detalles en la [investigaci칩n original](https://blog.ankursundara.com/cookie-bugs/)) Varios servidores web, incluidos los de Java (Jetty, TomCat, Undertow) y Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), manejan incorrectamente las cadenas de cookies debido al soporte desactualizado de RFC2965. Leen un valor de cookie entre comillas dobles como un 칰nico valor incluso si incluye puntos y comas, que normalmente deber칤an separar pares clave-valor:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Vulnerabilidades de Inyecci칩n de Cookies

(Consulte m치s detalles en la [investigaci칩n original](https://blog.ankursundara.com/cookie-bugs/)) El an치lisis incorrecto de cookies por parte de servidores, notablemente Undertow, Zope y aquellos que utilizan `http.cookie.SimpleCookie` y `http.cookie.BaseCookie` de Python, crea oportunidades para ataques de inyecci칩n de cookies. Estos servidores no delimitan correctamente el inicio de nuevas cookies, lo que permite a los atacantes falsificar cookies:

- Undertow espera una nueva cookie inmediatamente despu칠s de un valor entre comillas sin punto y coma.
- Zope busca una coma para comenzar a analizar la siguiente cookie.
- Las clases de cookies de Python comienzan el an치lisis en un car치cter de espacio.

Esta vulnerabilidad es particularmente peligrosa en aplicaciones web que dependen de la protecci칩n CSRF basada en cookies, ya que permite a los atacantes inyectar cookies de tokens CSRF falsificados, potencialmente eludiendo medidas de seguridad. El problema se agrava por el manejo de nombres de cookies duplicados en Python, donde la 칰ltima ocurrencia anula las anteriores. Tambi칠n plantea preocupaciones para las cookies `__Secure-` y `__Host-` en contextos inseguros y podr칤a llevar a elusiones de autorizaci칩n cuando las cookies se env칤an a servidores backend susceptibles a falsificaciones.

### Comprobaciones Extra de Cookies Vulnerables

#### **Comprobaciones b치sicas**

- La **cookie** es la **misma** cada vez que te **conectas**.
- Cierra la sesi칩n e intenta usar la misma cookie.
- Intenta iniciar sesi칩n con 2 dispositivos (o navegadores) en la misma cuenta usando la misma cookie.
- Verifica si la cookie tiene alguna informaci칩n y trata de modificarla.
- Intenta crear varias cuentas con nombres de usuario casi iguales y verifica si puedes ver similitudes.
- Verifica la opci칩n de "**recordarme**" si existe para ver c칩mo funciona. Si existe y podr칤a ser vulnerable, siempre utiliza la cookie de **recordarme** sin ninguna otra cookie.
- Comprueba si la cookie anterior sigue funcionando incluso despu칠s de cambiar la contrase침a.

#### **Ataques avanzados a cookies**

Si la cookie permanece igual (o casi igual) cuando inicias sesi칩n, esto probablemente significa que la cookie est치 relacionada con alg칰n campo de tu cuenta (probablemente el nombre de usuario). Entonces puedes:

- Intenta crear muchas **cuentas** con nombres de usuario muy **similares** e intenta **adivinar** c칩mo funciona el algoritmo.
- Intenta **bruteforce al nombre de usuario**. Si la cookie se guarda solo como un m칠todo de autenticaci칩n para tu nombre de usuario, entonces puedes crear una cuenta con el nombre de usuario "**Bmin**" y **bruteforce** cada **bit** de tu cookie porque una de las cookies que intentar치s ser치 la que pertenece a "**admin**".
- Prueba el **Padding Oracle** (puedes descifrar el contenido de la cookie). Usa **padbuster**.

**Padding Oracle - Ejemplos de Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster realizar치 varios intentos y te preguntar치 cu치l es la condici칩n de error (la que no es v치lida).

Luego comenzar치 a descifrar la cookie (puede tardar varios minutos).

Si el ataque se ha realizado con 칠xito, entonces podr칤as intentar cifrar una cadena de tu elecci칩n. Por ejemplo, si quisieras **cifrar** **user=administrator**.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Esta ejecuci칩n te dar치 la cookie correctamente encriptada y codificada con la cadena **user=administrator** en su interior.

**CBC-MAC**

Tal vez una cookie podr칤a tener alg칰n valor y estar firmada usando CBC. Entonces, la integridad del valor es la firma creada usando CBC con el mismo valor. Como se recomienda usar un vector IV nulo, este tipo de verificaci칩n de integridad podr칤a ser vulnerable.

**El ataque**

1. Obtener la firma del nombre de usuario **administ** = **t**
2. Obtener la firma del nombre de usuario **rator\x00\x00\x00 XOR t** = **t'**
3. Establecer en la cookie el valor **administrator+t'** (**t'** ser치 una firma v치lida de **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Si la cookie est치 encriptada usando ECB podr칤a ser vulnerable.\
Cuando inicias sesi칩n, la cookie que recibes siempre tiene que ser la misma.

**C칩mo detectar y atacar:**

Crear 2 usuarios con datos casi id칠nticos (nombre de usuario, contrase침a, correo electr칩nico, etc.) e intentar descubrir alg칰n patr칩n dentro de la cookie proporcionada.

Crear un usuario llamado, por ejemplo, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" y verificar si hay alg칰n patr칩n en la cookie (como ECB encripta con la misma clave cada bloque, los mismos bytes encriptados podr칤an aparecer si el nombre de usuario est치 encriptado).

Deber칤a haber un patr칩n (con el tama침o de un bloque utilizado). Entonces, sabiendo c칩mo est치n encriptadas un mont칩n de "a" puedes crear un nombre de usuario: "a"\*(tama침o del bloque)+"admin". Luego, podr칤as eliminar el patr칩n encriptado de un bloque de "a" de la cookie. Y tendr치s la cookie del nombre de usuario "admin".

## Referencias

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

**Try Hard Security Group**

<figure><img src="../../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Obt칠n la [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤guenos** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
