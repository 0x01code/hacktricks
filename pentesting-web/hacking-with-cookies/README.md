# Hacking de Cookies

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m치s para que puedas arreglarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol칩gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Atributos de Cookies

### Expires & Max-Age

* `Expires` establece una fecha de caducidad para cuando se elimina una cookie
* `Max-age` establece el tiempo en segundos para cuando se eliminar치 una cookie **(usa esto, ya no estamos en 2009)**

### **Domain**

El atributo `Domain` especifica **qu칠 hosts pueden recibir una cookie**. Si no se especifica, el atributo **por defecto** es el **mismo host** que estableci칩 la cookie, _**excluyendo subdominios**_. **Si se especifica `Domain`**, entonces **los subdominios siempre est치n incluidos**. Por lo tanto, especificar `Domain` es menos restrictivo que omitirlo. Sin embargo, puede ser 칰til cuando los subdominios necesitan compartir informaci칩n sobre un usuario.

Por ejemplo, si estableces `Domain=mozilla.org`, las cookies est치n disponibles en subdominios como `developer.mozilla.org`. Pero si no lo haces, la cookie no se enviar치 a subdominios.

Si un **subdominio** `sub.example.com` **establece una cookie** con atributo _domain_ de **`.example.com`**, se **enviar치** en solicitudes al **dominio principal.**

### **Path**

El atributo `Path` indica un **camino URL que debe existir en la URL solicitada para enviar el encabezado `Cookie`**. El car치cter `%x2F` ("/") se considera un separador de directorios, y los subdirectorios tambi칠n coinciden.

#### Orden

Cuando 2 cookies tienen el **mismo nombre**, la que se env칤a es:

* La que tiene el **camino m치s largo** que coincide con el camino URL
* La **m치s nueva** si ambas tienen el mismo camino

### SameSite

Esto indicar치 al navegador si la **cookie** puede ser enviada **desde otros dominios**. Tiene 3 valores posibles:

* **Strict**: La cookie no se enviar치 junto con una solicitud por sitios web de terceros.
* **Lax**: La cookie se enviar치 junto con la solicitud GET iniciada por sitios web de terceros.
* **None**: La cookie se env칤a desde cualquier dominio de terceros

| **Tipo de Solicitud** | **C칩digo de Ejemplo**                   | **Cookies Enviadas Cuando** |
| --------------------- | --------------------------------------- | --------------------------- |
| Link                  | \<a href="...">\</a>                    | NotSet\*, Lax, None         |
| Prerender             | \<link rel="prerender" href=".."/>      | NotSet\*, Lax, None         |
| Form GET              | \<form method="GET" action="...">       | NotSet\*, Lax, None         |
| Form POST             | \<form method="POST" action="...">      | NotSet\*, None              |
| iframe                | \<iframe src="...">\</iframe>           | NotSet\*, None              |
| AJAX                  | $.get("...")                            | NotSet\*, None              |
| Imagen                | \<img src="...">                        | NetSet\*, None              |

Tabla de [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) y ligeramente modificada.\
Una cookie con atributo _**SameSite**_ **mitigar치 ataques CSRF** donde se necesita una sesi칩n iniciada.

**\*Nota que desde Chrome80 (feb/2019) el comportamiento por defecto de una cookie sin un atributo samesite** **ser치 lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Nota que temporalmente, despu칠s de aplicar este cambio, las **cookies sin una pol칤tica SameSite** en Chrome ser치n **tratadas como None** durante los **primeros 2 minutos y luego como Lax para solicitudes POST de nivel superior entre sitios.**

## Banderas de Cookies

### HttpOnly

Esto evita que el **cliente** acceda a la cookie (Por ejemplo, mediante **Javascript**: `document.cookie`)

#### **Bypasses**

* Si la p치gina est치 **enviando las cookies como respuesta** de una solicitud (por ejemplo, en una p치gina **PHPinfo**), es posible abusar del XSS para enviar una solicitud a esta p치gina y **robar las cookies** de la respuesta (consulta un ejemplo en [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/)).
* Esto podr칤a ser evitado con solicitudes **HTTP TRACE** ya que la respuesta del servidor (si este m칠todo HTTP est치 disponible) reflejar치 las cookies enviadas. Esta t칠cnica se llama **Cross-Site Tracking**.
* Esta t칠cnica es evitada por **navegadores modernos al no permitir enviar una solicitud TRACE** desde JS. Sin embargo, se han encontrado algunos bypasses a esto en software espec칤fico como enviar `\r\nTRACE` en lugar de `TRACE` a IE6.0 SP2.
* Otra forma es la explotaci칩n de vulnerabilidades zero/day de los navegadores.
* Es posible **sobrescribir cookies HttpOnly** realizando un ataque de desbordamiento de Cookie Jar:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Es posible usar el ataque de [**Cookie Smuggling**](./#cookie-smuggling) para exfiltrar estas cookies

### Secure

La solicitud **solo** enviar치 la cookie en una solicitud HTTP si la solicitud se transmite a trav칠s de un canal seguro (t칤picamente **HTTPS**).

## Prefijos de Cookies

**`__Secure-` prefijo**: debe establecerse con la bandera `secure` desde una p치gina segura (HTTPS).

**`__Host-` prefijo**: debe establecerse con la bandera `secure`, debe ser de una p치gina segura (HTTPS), no debe tener un dominio especificado (y por lo tanto, no se env칤an a subdominios), y el camino debe ser `/`.

Las cookies con prefijo `__Host-` no pueden enviarse a superdominios (cookies de subdominios a dominios) o subdominios (cookies de dominios a subdominios), por lo tanto, si quieres aislar las cookies de tu aplicaci칩n, prefijar todo con `__Host-` no es una mala idea.

## Ataques con Cookies

Si encuentras alg칰n tipo de cookie personalizada que contenga datos sensibles (sessionID, nombre de usuario, correos electr칩nicos, etc.) definitivamente deber칤as intentar explotarla

### Decodificaci칩n de la cookie

Si la **cookie** est치 utilizando alg칰n **cifrado Base** (como Base64) o similar, podr칤as ser capaz de **decodificarla**, **cambiar** el **contenido** e **impersonar** usuarios arbitrarios.

### Secuestro de Sesi칩n

Robar una cookie y usarla para impersonar al usuario dentro de una aplicaci칩n

### Fijaci칩n de Sesi칩n

El atacante obtiene una cookie de una p치gina web y env칤a un enlace a la v칤ctima para **iniciar sesi칩n usando la misma cookie**. Si la cookie no cambia cuando un usuario inicia sesi칩n, esto podr칤a ser 칰til porque el atacante podr칤a ser capaz de impersonar al usuario a trav칠s de una cookie.

Si encontraste un **XSS en un subdominio** o **controlas un subdominio**, lee:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Donaci칩n de Sesi칩n

El atacante env칤a su propia sesi칩n a la v칤ctima. La v칤ctima ver치 que ya ha iniciado sesi칩n y supondr치 que est치 dentro de su cuenta, pero **las acciones se realizar치n dentro de la cuenta del atacante**.

Si encontraste un **XSS en un subdominio** o **controlas un subdominio**, lee:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT Cookie](../hacking-jwt-json-web-tokens.md)

Haz clic en el enlace anterior para acceder a una p치gina que explica posibles fallos en JWT.

### Cookie Vac칤a

Los navegadores permiten una cookie con un nombre vac칤o
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // empty name
document.cookie = "b=v2"
```
Esto resulta en la cabecera de cookie enviada:
```
a=v1; test value; b=v2;
```
M치s interesante a칰n, si tienes un vector que de alguna manera te permite **establecer la cookie vac칤a**, puedes **controlar cualquier otra cookie**:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // this sets the empty cookie to a=b
```
Aunque internamente en el navegador, esto se establece como la cookie nombrada vac칤a, resultar치 en el **encabezado de cookie enviado:**
```
a=b;
```
### Bug de Chrome - corrupci칩n de document.cookie <a href="#chrome-bugdocumentcookie-corruption" id="chrome-bugdocumentcookie-corruption"></a>

Si un punto de c칩digo sustituto unicode est치 en una cookie establecida, `document.cookie` se corromper치 permanentemente y devolver치 una cadena vac칤a.
```js
document.cookie
// "a=b;"
document.cookie = "\ud800=meep";
document.cookie
// ""
```
### Contrabando de Cookies

Varios servidores web, incluyendo servidores Java como Jetty, TomCat, Undertow, y el framework web de Python Zope, as칤 como servidores/frameworks web de Python como cherrypy, web.py, aiohttp server, bottle y webob, se han encontrado con que **interpretan incorrectamente las cadenas de cookies** debido al soporte obsoleto para RFC2965, un mecanismo de citaci칩n de cookies anticuado que utiliza RFC2616 para la definici칩n de una cadena entre comillas.

Espec칤ficamente, **estos servidores contin칰an leyendo una cadena de cookies cuando encuentran un valor de cookie entre comillas dobles (dquoted), incluso si se encuentra un punto y coma**. Esto es problem치tico porque **los puntos y coma se supone que separan pares clave-valor** en la cadena de cookies.

Por ejemplo, si un **navegador env칤a tres cookies, RENDER\_TEXT, JSESSIONID,** y **ASDF:**
```basic
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
estos servidores los interpretan como parte de un **valor de cookie 칰nico** en lugar de tres cookies separadas.

Esto conlleva un riesgo de seguridad: si un atacante obtiene acceso a scripting entre sitios (XSS), pueden usar este error para **exfiltrar cookies sensibles como las cookies HttpOnly**.

### Inyecci칩n de Cookies

Se ha descubierto que muchos servidores web, incluyendo el Undertow de Java, el Zope de Python y aquellos que utilizan http.cookie.SimpleCookie y http.cookie.BaseCookie de la biblioteca est치ndar de Python, **analizan incorrectamente las cookies, utilizando delimitadores incorrectos para iniciar el siguiente par nombre/valor de cookie**. Esto permite a un atacante **falsificar m칰ltiples cookies mientras solo controla el valor de una cookie**.

En el caso de **Undertow**, comienza a analizar la siguiente cookie inmediatamente despu칠s del **final de un valor de cookie entre comillas**, sin esperar un punto y coma:
```bash
LANGUAGE="en-us" CSRF_TOKEN="SPOOFED_VALUE"
```
**Zope** comienza a analizar la siguiente cookie en una **coma**:
```bash
LANGUAGE=en-us,CSRF_TOKEN=SPOOFED_VALUE
```
Y **Python's SimpleCookie** y **BaseCookie** comienzan inmediatamente a analizar la siguiente cookie en un car치cter de **espacio**:
```
LANGUAGE=en-us CSRF_TOKEN=SPOOFED_VALUE
```
Como resultado, servidores como **cherrypy**, **web.py**, **aiohttp** server, **bottle** y **webob** (Pyramid, TurboGears) son todos vulnerables a este tipo de ataque.

Este problema presenta significativas **implicaciones de seguridad**. Por ejemplo, si una aplicaci칩n web utiliza **protecci칩n CSRF basada en cookies**, un atacante puede **inyectar** una **cookie de token CSRF** falsificada para eludir esta protecci칩n. Adem치s, el 칰ltimo nombre de cookie duplicado en los paquetes http.cookie de Python anula cualquier otro anterior, lo que facilita especialmente este tipo de ataque.

Adem치s, el **spoofing** de cookies **`__Secure-`** y **`__Host-`** puede ser abusado en un contexto inseguro. Tambi칠n, en una configuraci칩n donde las cookies se pasan a un servidor backend, **la inyecci칩n de cookies podr칤a llevar a elusiones de autorizaci칩n** si el servidor backend es susceptible al spoofing pero el servidor frontend no lo es.

### Verificaciones de Cookies Extra Vulnerables

#### **Verificaciones b치sicas**

* La **cookie** es **igual** cada vez que haces **login**.
* Cierra sesi칩n e intenta usar la misma cookie.
* Intenta iniciar sesi칩n con 2 dispositivos (o navegadores) en la misma cuenta usando la misma cookie.
* Verifica si la cookie tiene alguna informaci칩n y trata de modificarla.
* Intenta crear varias cuentas con nombres de usuario casi iguales y verifica si puedes ver similitudes.
* Verifica la opci칩n de "**recu칠rdame**" si existe para ver c칩mo funciona. Si existe y podr칤a ser vulnerable, siempre usa la cookie de **recu칠rdame** sin ninguna otra cookie.
* Verifica si la cookie anterior funciona incluso despu칠s de cambiar la contrase침a.

#### **Ataques avanzados con cookies**

Si la cookie permanece igual (o casi) cuando inicias sesi칩n, esto probablemente significa que la cookie est치 relacionada con alg칰n campo de tu cuenta (probablemente el nombre de usuario). Entonces puedes:

* Intentar crear muchas **cuentas** con nombres de usuario muy **similares** e intentar **adivinar** c칩mo funciona el algoritmo.
* Intentar **fuerza bruta en el nombre de usuario**. Si la cookie se guarda solo como un m칠todo de autenticaci칩n para tu nombre de usuario, entonces puedes crear una cuenta con el nombre de usuario "**Bmin**" y **fuerza bruta** cada **bit** de tu cookie porque una de las cookies que intentar치s ser치 la que pertenece a "**admin**".
* Intentar **Padding Oracle** (puedes descifrar el contenido de la cookie). Usa **padbuster**.

**Padding Oracle - Ejemplos de Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster realizar치 varios intentos y te preguntar치 cu치l es la condici칩n de error (la que no es v치lida).

Luego comenzar치 a descifrar la cookie (puede tardar varios minutos)

Si el ataque se ha realizado con 칠xito, entonces podr칤as intentar cifrar una cadena de tu elecci칩n. Por ejemplo, si quisieras **cifrar** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Esta ejecuci칩n te dar치 la cookie correctamente cifrada y codificada con la cadena **user=administrator** dentro.

**CBC-MAC**

Quiz치s una cookie podr칤a tener alg칰n valor y podr칤a estar firmada usando CBC. Entonces, la integridad del valor es la firma creada al usar CBC con el mismo valor. Como se recomienda usar como IV un vector nulo, este tipo de verificaci칩n de integridad podr칤a ser vulnerable.

**El ataque**

1. Obt칠n la firma del nombre de usuario **administ** = **t**
2. Obt칠n la firma del nombre de usuario **rator\x00\x00\x00 XOR t** = **t'**
3. Establece en la cookie el valor **administrator+t'** (**t'** ser치 una firma v치lida de **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Si la cookie est치 cifrada usando ECB, podr칤a ser vulnerable.\
Cuando inicias sesi칩n, la cookie que recibes siempre debe ser la misma.

**C칩mo detectar y atacar:**

Crea 2 usuarios con datos casi id칠nticos (nombre de usuario, contrase침a, correo electr칩nico, etc.) e intenta descubrir alg칰n patr칩n dentro de la cookie dada.

Crea un usuario llamado, por ejemplo, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" y verifica si hay alg칰n patr칩n en la cookie (como ECB cifra con la misma clave cada bloque, los mismos bytes cifrados podr칤an aparecer si el nombre de usuario est치 cifrado).

Deber칤a haber un patr칩n (con el tama침o de un bloque utilizado). Entonces, sabiendo c칩mo se cifra un mont칩n de "a", puedes crear un nombre de usuario: "a"\*(tama침o del bloque)+"admin". Luego, podr칤as eliminar el patr칩n cifrado de un bloque de "a" de la cookie. Y tendr치s la cookie del nombre de usuario "admin".

## Referencias

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan m치s para que puedas solucionarlas m치s r치pido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnol칩gico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pru칠balo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
