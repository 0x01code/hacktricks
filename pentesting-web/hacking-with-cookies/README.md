# Cookies Hacking

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Schwachstellen, damit Sie sie schneller beheben k√∂nnen. Intruder verfolgt Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch und findet Probleme in Ihrer gesamten Technologie-Stack, von APIs √ºber Webanwendungen bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Cookie-Attribute

Cookies haben mehrere Attribute, die ihr Verhalten im Browser des Benutzers steuern. Hier ist eine √úbersicht √ºber diese Attribute in einer passiveren Sprache:

### Ablaufdatum und Max-Age

Das Ablaufdatum eines Cookies wird durch das Attribut `Expires` bestimmt. Das Attribut `Max-Age` hingegen definiert die Zeit in Sekunden, bis ein Cookie gel√∂scht wird. **Verwenden Sie `Max-Age`, da es moderneren Praktiken entspricht.**

### Domain

Die Hosts, die ein Cookie erhalten sollen, werden durch das Attribut `Domain` angegeben. Standardm√§√üig ist dies auf den Host festgelegt, der das Cookie ausgestellt hat, ohne seine Subdomains einzuschlie√üen. Wenn jedoch das Attribut `Domain` explizit festgelegt ist, umfasst es auch Subdomains. Dies macht die Spezifikation des Attributs `Domain` zu einer weniger restriktiven Option, die in Szenarien n√ºtzlich ist, in denen das Teilen von Cookies √ºber Subdomains erforderlich ist. Wenn beispielsweise `Domain=mozilla.org` festgelegt ist, sind Cookies auf seinen Subdomains wie `developer.mozilla.org` zug√§nglich.

### Pfad

Ein spezifischer URL-Pfad, der in der angeforderten URL vorhanden sein muss, damit der `Cookie`-Header gesendet wird, wird durch das Attribut `Path` angegeben. Dieses Attribut betrachtet das `/`-Zeichen als Verzeichnistrennzeichen und erm√∂glicht √úbereinstimmungen in Unterverzeichnissen.

### Reihenfolgeregeln

Wenn zwei Cookies denselben Namen haben, wird das zum Senden ausgew√§hlte Cookie basierend auf folgenden Kriterien ausgew√§hlt:
- Das Cookie, das am l√§ngsten mit dem Pfad in der angeforderten URL √ºbereinstimmt.
- Das zuletzt gesetzte Cookie, wenn die Pfade identisch sind.

### SameSite

- Das Attribut `SameSite` legt fest, ob Cookies bei Anfragen von Drittanbieter-Domains gesendet werden. Es bietet drei Einstellungen:
- **Strict**: Beschr√§nkt das Senden des Cookies auf Anfragen von Drittanbieter-Websites.
- **Lax**: Erlaubt das Senden des Cookies bei GET-Anfragen, die von Drittanbieter-Websites initiiert werden.
- **None**: Erlaubt das Senden des Cookies von jeder Drittanbieter-Domain.

Beachten Sie, dass beim Konfigurieren von Cookies das Verst√§ndnis dieser Attribute dazu beitragen kann, sicherzustellen, dass sie in verschiedenen Szenarien wie erwartet funktionieren.


| **Anforderungstyp** | **Beispielcode**                   | **Gesendete Cookies, wenn** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Formular GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Formular POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Bild            | \<img src="...">                   | NetSet\*, None        |

Tabelle von [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) und leicht modifiziert.\
Ein Cookie mit dem Attribut _**SameSite**_ wird **CSRF-Angriffe abwehren**, bei denen eine angemeldete Sitzung erforderlich ist.

**\*Beachten Sie, dass ab Chrome80 (Feb/2019) das Standardverhalten eines Cookies ohne ein SameSite-Cookie-Attribut lax sein wird** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Beachten Sie vor√ºbergehend, dass die **Cookies ohne SameSite-Richtlinie** in Chrome w√§hrend der **ersten 2 Minuten als None** und anschlie√üend als Lax f√ºr Cross-Site-POST-Anfragen auf oberster Ebene behandelt werden.

## Cookies-Flags

### HttpOnly

Dies verhindert, dass der **Client** auf das Cookie zugreift (z. B. √ºber **Javascript**: `document.cookie`)

#### **Umgehungen**

* Wenn die Seite die Cookies als Antwort auf eine Anfrage sendet (z. B. in einer **PHPinfo**-Seite), ist es m√∂glich, XSS auszunutzen, um eine Anfrage an diese Seite zu senden und die Cookies aus der Antwort zu stehlen (siehe ein Beispiel unter [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Dies kann mit **TRACE**-**HTTP**-Anfragen umgangen werden, da die Antwort des Servers (sofern diese HTTP-Methode verf√ºgbar ist) die gesendeten Cookies widerspiegelt. Diese Technik wird als **Cross-Site Tracking** bezeichnet.
* Moderne Browser verhindern diese Technik, indem sie das Senden einer TRACE-Anfrage von JS nicht zulassen. Es wurden jedoch einige Umgehungen f√ºr bestimmte Software gefunden, z. B. das Senden von `\r\nTRACE` anstelle von `TRACE` an IE6.0 SP2.
* Eine andere M√∂glichkeit besteht in der Ausnutzung von Zero-Day-Schwachstellen der Browser.
* Es ist m√∂glich, HttpOnly-Cookies zu √ºberschreiben, indem ein Cookie Jar Overflow-Angriff durchgef√ºhrt wird:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* Es ist m√∂glich, den [**Cookie Smuggling**](./#cookie-smuggling)-Angriff zu verwenden, um diese Cookies zu exfiltrieren

### Secure

Die Anfrage sendet das Cookie **nur**, wenn die Anfrage √ºber einen sicheren Kanal √ºbertragen wird (in der Regel **HTTPS**).
## Cookie-Pr√§fixe

Cookies mit dem Pr√§fix `__Secure-` m√ºssen zusammen mit dem `secure`-Flag von Seiten gesetzt werden, die durch HTTPS gesichert sind.

Bei Cookies mit dem Pr√§fix `__Host-` m√ºssen mehrere Bedingungen erf√ºllt sein:
- Sie m√ºssen mit dem `secure`-Flag gesetzt werden.
- Sie m√ºssen von einer durch HTTPS gesicherten Seite stammen.
- Sie d√ºrfen keine Dom√§ne angeben, um ihre √úbertragung an Subdom√§nen zu verhindern.
- Der Pfad f√ºr diese Cookies muss auf `/` gesetzt sein.

Es ist wichtig zu beachten, dass Cookies mit dem Pr√§fix `__Host-` nicht an Superdom√§nen oder Subdom√§nen gesendet werden d√ºrfen. Diese Einschr√§nkung tr√§gt zur Isolierung von Anwendungscookies bei. Daher kann die Verwendung des Pr√§fixes `__Host-` f√ºr alle Anwendungscookies als bew√§hrte Methode zur Verbesserung von Sicherheit und Isolierung betrachtet werden.

## Cookie-Angriffe

Wenn ein benutzerdefiniertes Cookie sensible Daten enth√§lt, √ºberpr√ºfen Sie es (insbesondere wenn Sie ein CTF spielen), da es m√∂glicherweise anf√§llig ist.

### Dekodieren und Manipulieren von Cookies

Sensible Daten, die in Cookies eingebettet sind, sollten immer √ºberpr√ºft werden. Cookies, die in Base64 oder √§hnlichen Formaten codiert sind, k√∂nnen oft dekodiert werden. Diese Schwachstelle erm√∂glicht es Angreifern, den Inhalt des Cookies zu √§ndern und ihre modifizierten Daten wieder in das Cookie zu codieren, um sich als andere Benutzer auszugeben.

### Session-Hijacking

Bei diesem Angriff wird das Cookie eines Benutzers gestohlen, um unbefugten Zugriff auf sein Konto in einer Anwendung zu erlangen. Indem das gestohlene Cookie verwendet wird, kann ein Angreifer sich als legitimer Benutzer ausgeben.

### Session-Fixierung

In diesem Szenario t√§uscht ein Angreifer ein Opfer, ein bestimmtes Cookie zur Anmeldung zu verwenden. Wenn die Anwendung beim Login kein neues Cookie zuweist, kann der Angreifer, der im Besitz des urspr√ºnglichen Cookies ist, das Opfer imitieren. Diese Technik basiert darauf, dass das Opfer sich mit einem vom Angreifer bereitgestellten Cookie anmeldet.

Wenn Sie eine **XSS in einer Subdom√§ne** gefunden haben oder eine **Subdom√§ne kontrollieren**, lesen Sie:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Session-Spende

Hier √ºberzeugt der Angreifer das Opfer, das Sitzungscookie des Angreifers zu verwenden. Das Opfer glaubt, dass es in sein eigenes Konto eingeloggt ist und f√ºhrt unwissentlich Aktionen im Kontext des Kontos des Angreifers aus.

Wenn Sie eine **XSS in einer Subdom√§ne** gefunden haben oder eine **Subdom√§ne kontrollieren**, lesen Sie:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [JWT-Cookies](../hacking-jwt-json-web-tokens.md)

Klicken Sie auf den vorherigen Link, um eine Seite aufzurufen, die m√∂gliche Schwachstellen in JWT erkl√§rt.

JSON Web Tokens (JWT), die in Cookies verwendet werden, k√∂nnen ebenfalls Sicherheitsl√ºcken aufweisen. F√ºr detaillierte Informationen zu potenziellen Schwachstellen und deren Ausnutzung wird empfohlen, das verlinkte Dokument zum Hacking von JWT aufzurufen.

### Cross-Site Request Forgery (CSRF)

Dieser Angriff zwingt einen eingeloggten Benutzer, unerw√ºnschte Aktionen auf einer Webanwendung auszuf√ºhren, f√ºr die er derzeit authentifiziert ist. Angreifer k√∂nnen Cookies ausnutzen, die automatisch mit jeder Anfrage an die verwundbare Website gesendet werden.

### Leere Cookies

(Weitere Details finden Sie in der [Originalforschung](https://blog.ankursundara.com/cookie-bugs/))
Browser erlauben die Erstellung von Cookies ohne Namen, was durch JavaScript wie folgt demonstriert werden kann:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Das Ergebnis im gesendeten Cookie-Header lautet `a=v1; Testwert; b=v2;`. Interessanterweise erm√∂glicht dies die Manipulation von Cookies, wenn ein Cookie mit leerem Namen gesetzt wird. Dadurch k√∂nnen m√∂glicherweise andere Cookies kontrolliert werden, indem das leere Cookie auf einen bestimmten Wert gesetzt wird:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
Dies f√ºhrt dazu, dass der Browser einen Cookie-Header sendet, der von jedem Webserver als ein Cookie mit dem Namen `a` und dem Wert `b` interpretiert wird.

#### Chrome-Bug: Unicode-Surrogat-Codepunkt-Problem

In Chrome wird `document.cookie` besch√§digt, wenn ein Unicode-Surrogat-Codepunkt Teil eines gesetzten Cookies ist, und gibt anschlie√üend einen leeren String zur√ºck.
```js
document.cookie = "\ud800=meep";
```
Dies f√ºhrt dazu, dass `document.cookie` eine leere Zeichenkette ausgibt, was auf eine dauerhafte Besch√§digung hinweist.

#### Cookie-Schmuggel aufgrund von Parsing-Problemen

(Weitere Details finden Sie in der [urspr√ºnglichen Forschung](https://blog.ankursundara.com/cookie-bugs/))
Mehrere Webserver, darunter solche von Java (Jetty, TomCat, Undertow) und Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), behandeln Cookie-Zeichenketten fehlerhaft aufgrund veralteter RFC2965-Unterst√ºtzung. Sie lesen einen in doppelte Anf√ºhrungszeichen gesetzten Cookie-Wert als einzelnen Wert, auch wenn er Semikolons enth√§lt, die normalerweise Schl√ºssel-Wert-Paare trennen sollten:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Cookie-Injection-Schwachstellen

(Weitere Details finden Sie in der [Originalforschung](https://blog.ankursundara.com/cookie-bugs/))
Die fehlerhafte Analyse von Cookies durch Server, insbesondere Undertow, Zope und solche, die Python's `http.cookie.SimpleCookie` und `http.cookie.BaseCookie` verwenden, er√∂ffnet M√∂glichkeiten f√ºr Cookie-Injection-Angriffe. Diese Server trennen neue Cookies nicht ordnungsgem√§√ü ab, was Angreifern erm√∂glicht, gef√§lschte Cookies einzuschleusen:

- Undertow erwartet ein neues Cookie unmittelbar nach einem in Anf√ºhrungszeichen gesetzten Wert ohne Semikolon.
- Zope sucht nach einem Komma, um das n√§chste Cookie zu analysieren.
- Die Cookie-Klassen von Python beginnen mit der Analyse an einem Leerzeichen.

Diese Schwachstelle ist besonders gef√§hrlich in Webanwendungen, die auf cookie-basierter CSRF-Schutzma√ünahmen beruhen, da sie Angreifern erm√∂glicht, gef√§lschte CSRF-Token-Cookies einzuschleusen und m√∂glicherweise Sicherheitsma√ünahmen zu umgehen. Das Problem wird durch den Umgang von Python mit doppelten Cookie-Namen versch√§rft, wobei das letzte Auftreten fr√ºhere √ºberschreibt. Es bestehen auch Bedenken hinsichtlich der `__Secure-` und `__Host-`-Cookies in unsicheren Kontexten, die zu Autorisierungsumgehungen f√ºhren k√∂nnten, wenn Cookies an anf√§llige Backend-Server weitergeleitet werden.

### Zus√§tzliche √úberpr√ºfungen f√ºr gef√§hrdete Cookies

#### **Grundlegende √úberpr√ºfungen**

* Das **Cookie** ist jedes Mal **identisch**, wenn Sie sich **anmelden**.
* Melden Sie sich ab und versuchen Sie, das gleiche Cookie zu verwenden.
* Versuchen Sie, sich mit 2 Ger√§ten (oder Browsern) mit demselben Cookie bei demselben Konto anzumelden.
* √úberpr√ºfen Sie, ob das Cookie Informationen enth√§lt und versuchen Sie, es zu √§ndern.
* Versuchen Sie, mehrere Konten mit fast demselben Benutzernamen zu erstellen und pr√ºfen Sie, ob √Ñhnlichkeiten erkennbar sind.
* √úberpr√ºfen Sie die Option "**Remember me**", sofern vorhanden, um zu sehen, wie sie funktioniert. Wenn sie vorhanden ist und gef√§hrdet sein k√∂nnte, verwenden Sie immer das Cookie von **Remember me** ohne ein anderes Cookie.
* √úberpr√ºfen Sie, ob das vorherige Cookie auch nach dem √Ñndern des Passworts funktioniert.

#### **Fortgeschrittene Cookie-Angriffe**

Wenn das Cookie beim Anmelden gleich bleibt (oder fast gleich), bedeutet dies wahrscheinlich, dass das Cookie mit einem Feld Ihres Kontos zusammenh√§ngt (wahrscheinlich dem Benutzernamen). Dann k√∂nnen Sie Folgendes versuchen:

* Versuchen Sie, viele Konten mit sehr √§hnlichen Benutzernamen zu erstellen und versuchen Sie, den Algorithmus zu erraten.
* Versuchen Sie, den Benutzernamen per **Brute-Force** zu ermitteln. Wenn das Cookie nur als Authentifizierungsmethode f√ºr Ihren Benutzernamen gespeichert wird, k√∂nnen Sie ein Konto mit dem Benutzernamen "**Bmin**" erstellen und jedes einzelne **Bit** Ihres Cookies per Brute-Force ausprobieren, da eines der Cookies, die Sie ausprobieren werden, dem des Benutzernamens "**admin**" geh√∂ren wird.
* Versuchen Sie **Padding Oracle** (Sie k√∂nnen den Inhalt des Cookies entschl√ºsseln). Verwenden Sie **padbuster**.

**Padding Oracle - Padbuster-Beispiele**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster wird mehrere Versuche unternehmen und Sie nach der Fehlerbedingung fragen (diejenige, die nicht g√ºltig ist).

Dann beginnt es mit der Entschl√ºsselung des Cookies (dies kann mehrere Minuten dauern).

Wenn der Angriff erfolgreich war, k√∂nnen Sie versuchen, einen beliebigen String zu verschl√ºsseln. Zum Beispiel, wenn Sie **user=administrator** **verschl√ºsseln** m√∂chten.
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Diese Ausf√ºhrung liefert Ihnen das Cookie korrekt verschl√ºsselt und mit dem String **user=administrator** darin codiert.

**CBC-MAC**

M√∂glicherweise hat ein Cookie einen Wert und wird mit CBC signiert. Die Integrit√§t des Werts ist dann die Signatur, die mit CBC und demselben Wert erstellt wird. Da empfohlen wird, einen Nullvektor als IV zu verwenden, k√∂nnte diese Art der Integrit√§tspr√ºfung anf√§llig sein.

**Der Angriff**

1. Erhalten Sie die Signatur des Benutzernamens **administ** = **t**
2. Erhalten Sie die Signatur des Benutzernamens **rator\x00\x00\x00 XOR t** = **t'**
3. Setzen Sie im Cookie den Wert **administrator+t'** (**t'** wird eine g√ºltige Signatur von **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Wenn das Cookie mit ECB verschl√ºsselt ist, k√∂nnte es anf√§llig sein.\
Wenn Sie sich anmelden, muss das empfangene Cookie immer dasselbe sein.

**Wie man erkennt und angreift:**

Erstellen Sie 2 Benutzer mit fast denselben Daten (Benutzername, Passwort, E-Mail usw.) und versuchen Sie, ein Muster im gegebenen Cookie zu entdecken.

Erstellen Sie einen Benutzer mit dem Namen "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" und pr√ºfen Sie, ob im Cookie ein Muster vorhanden ist (da ECB mit demselben Schl√ºssel jeden Block verschl√ºsselt, k√∂nnen dieselben verschl√ºsselten Bytes auftreten, wenn der Benutzername verschl√ºsselt wird).

Es sollte ein Muster geben (mit der Gr√∂√üe eines verwendeten Blocks). Daher k√∂nnen Sie, wenn Sie wissen, wie eine Reihe von "a" verschl√ºsselt wird, einen Benutzernamen erstellen: "a"\*(Gr√∂√üe des Blocks)+"admin". Dann k√∂nnen Sie das verschl√ºsselte Muster eines Blocks von "a" aus dem Cookie l√∂schen. Und Sie haben das Cookie des Benutzernamens "admin".

## Referenzen

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Schwachstellen, damit Sie sie schneller beheben k√∂nnen. Intruder verfolgt Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch und findet Probleme in Ihrer gesamten Technologie-Stack, von APIs √ºber Webanwendungen bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder folgen Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repos senden.

</details>
