# Hacking dei Cookies

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**La Famiglia PEASS**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusivi [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

**Try Hard Security Group**

<figure><img src="../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

***

## Attributi dei Cookies

I cookies sono dotati di diversi attributi che ne controllano il comportamento nel browser dell'utente. Ecco un elenco di questi attributi in una voce pi√π passiva:

### Scadenza e Max-Age

La data di scadenza di un cookie √® determinata dall'attributo `Expires`. Al contrario, l'attributo `Max-age` definisce il tempo in secondi prima che un cookie venga eliminato. **Optare per `Max-age` poich√© riflette pratiche pi√π moderne.**

### Dominio

Gli host che ricevono un cookie sono specificati dall'attributo `Domain`. Per impostazione predefinita, questo √® impostato sull'host che ha emesso il cookie, escludendo i suoi sottodomini. Tuttavia, quando l'attributo `Domain` √® esplicitamente impostato, esso comprende anche i sottodomini. Questo rende la specifica dell'attributo `Domain` una opzione meno restrittiva, utile per scenari in cui √® necessario condividere i cookie tra i sottodomini. Ad esempio, impostando `Domain=mozilla.org` rende i cookie accessibili sui suoi sottodomini come `developer.mozilla.org`.

### Percorso

Un percorso URL specifico che deve essere presente nell'URL richiesto affinch√© l'intestazione `Cookie` venga inviata √® indicato dall'attributo `Path`. Questo attributo considera il carattere `/` come separatore di directory, consentendo corrispondenze anche nelle sottodirectory.

### Regole di Ordinamento

Quando due cookie hanno lo stesso nome, quello scelto per l'invio si basa su:

* Il cookie che corrisponde al percorso pi√π lungo nell'URL richiesto.
* Il cookie impostato pi√π di recente se i percorsi sono identici.

### SameSite

* L'attributo `SameSite` detta se i cookie vengono inviati su richieste provenienti da domini di terze parti. Offre tre impostazioni:
* **Strict**: Limita il cookie dall'essere inviato su richieste di terze parti.
* **Lax**: Consente al cookie di essere inviato con richieste GET avviate da siti web di terze parti.
* **None**: Permette al cookie di essere inviato da qualsiasi dominio di terze parti.

Ricorda, configurando i cookie, la comprensione di questi attributi pu√≤ aiutare a garantire che si comportino come previsto in diversi scenari.

| **Tipo di Richiesta** | **Codice di Esempio**                   | **Cookie Inviati Quando** |
| ---------------- | ---------------------------------- | --------------------- |
| Link             | \<a href="...">\</a>               | NotSet\*, Lax, None   |
| Prerender        | \<link rel="prerender" href=".."/> | NotSet\*, Lax, None   |
| Form GET         | \<form method="GET" action="...">  | NotSet\*, Lax, None   |
| Form POST        | \<form method="POST" action="..."> | NotSet\*, None        |
| iframe           | \<iframe src="...">\</iframe>      | NotSet\*, None        |
| AJAX             | $.get("...")                       | NotSet\*, None        |
| Immagine            | \<img src="...">                   | NetSet\*, None        |

Tabella da [Invicti](https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/) e leggermente modificata.\
Un cookie con attributo _**SameSite**_ **mitiga gli attacchi CSRF** dove √® necessaria una sessione autenticata.

**\*Nota che da Chrome80 (feb/2019) il comportamento predefinito di un cookie senza un attributo samesite** **sar√† lax** ([https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/](https://www.troyhunt.com/promiscuous-cookies-and-their-impending-death-via-the-samesite-policy/)).\
Nota che temporaneamente, dopo l'applicazione di questa modifica, i **cookie senza una politica SameSite** **in Chrome verranno trattati come None** durante i **primi 2 minuti e poi come Lax per richieste POST cross-site di alto livello.**

## Bandiere dei Cookies

### HttpOnly

Questo impedisce al **client** di accedere al cookie (tramite **Javascript** ad esempio: `document.cookie`)

#### **Bypass**

* Se la pagina sta **inviando i cookie come risposta** di una richiesta (ad esempio in una pagina **PHPinfo**), √® possibile sfruttare la XSS per inviare una richiesta a questa pagina e **rubare i cookie** dalla risposta (controlla un esempio in [https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/](https://hackcommander.github.io/posts/2022/11/12/bypass-httponly-via-php-info-page/).
* Questo potrebbe essere bypassato con richieste **TRACE** **HTTP** poich√© la risposta dal server (se questo metodo HTTP √® disponibile) rifletter√† i cookie inviati. Questa tecnica √® chiamata **Cross-Site Tracking**.
* Questa tecnica √® evitata dai **browser moderni che non permettono l'invio di una richiesta TRACE** da JS. Tuttavia, sono stati trovati alcuni bypass a questo in software specifici come l'invio di `\r\nTRACE` invece di `TRACE` a IE6.0 SP2.
* Un altro modo √® lo sfruttamento di vulnerabilit√† zero/day dei browser.
* √à possibile **sovrascrivere i cookie HttpOnly** eseguendo un attacco di overflow del Cookie Jar:

{% content-ref url="cookie-jar-overflow.md" %}
[cookie-jar-overflow.md](cookie-jar-overflow.md)
{% endcontent-ref %}

* √à possibile utilizzare l'attacco [**Cookie Smuggling**](./#cookie-smuggling) per esfiltrare questi cookie

### Secure

La richiesta invier√† il cookie solo in una richiesta HTTP solo se la richiesta viene trasmessa su un canale sicuro (tipicamente **HTTPS**).

## Prefissi dei Cookies

I cookies prefissati con `__Secure-` devono essere impostati insieme alla bandiera `secure` dalle pagine che sono protette da HTTPS.

Per i cookies prefissati con `__Host-`, devono essere soddisfatte diverse condizioni:

* Devono essere impostati con la bandiera `secure`.
* Devono provenire da una pagina protetta da HTTPS.
* √à vietato specificare un dominio per questi cookie, impedendo la loro trasmissione ai sottodomini.
* Il percorso per questi cookie deve essere impostato su `/`.

√à importante notare che i cookies prefissati con `__Host-` non sono consentiti di essere inviati a superdomini o sottodomini. Questa restrizione aiuta nell'isolamento dei cookies dell'applicazione. Pertanto, l'utilizzo del prefisso `__Host-` per tutti i cookies dell'applicazione pu√≤ essere considerato una buona pratica per migliorare la sicurezza e l'isolamento.
### Sovrascrittura dei cookies

Quindi, una delle protezioni dei cookies con prefisso `__Host-` √® quella di impedirne la sovrascrittura da parte dei subdomini. Ad esempio, impedendo gli [**attacchi di Cookie Tossing**](cookie-tossing.md). Nel talk [**Cookie Crumbles: Unveiling Web Session Integrity Vulnerabilities**](https://www.youtube.com/watch?v=F\_wAzF4a7Xg) ([**documento**](https://www.usenix.org/system/files/usenixsecurity23-squarcina.pdf)) √® stato presentato che era possibile impostare i cookies con prefisso `__HOST-` dai subdomini, ingannando il parser, ad esempio, aggiungendo "=" all'inizio o all'inizio e alla fine...:

<figure><img src="../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

Oppure in PHP era possibile aggiungere **altri caratteri all'inizio** del nome del cookie che sarebbero stati **sostituiti da caratteri di sottolineatura**, consentendo di sovrascrivere i cookies `__HOST-`:

<figure><img src="../../.gitbook/assets/image (1).png" alt="" width="373"><figcaption></figcaption></figure>

## Attacchi ai Cookies

Se un cookie personalizzato contiene dati sensibili, controllalo (specialmente se stai partecipando a un CTF), poich√© potrebbe essere vulnerabile.

### Decodifica e Manipolazione dei Cookies

I dati sensibili incorporati nei cookies dovrebbero sempre essere esaminati attentamente. I cookies codificati in Base64 o formati simili possono spesso essere decodificati. Questa vulnerabilit√† consente agli attaccanti di modificare il contenuto del cookie e impersonare altri utenti codificando i loro dati modificati all'interno del cookie.

### Dirottamento di Sessione

Questo attacco comporta il furto del cookie di un utente per ottenere l'accesso non autorizzato al loro account all'interno di un'applicazione. Utilizzando il cookie rubato, un attaccante pu√≤ impersonare l'utente legittimo.

### Fissazione di Sessione

In questo scenario, un attaccante inganna una vittima affinch√© utilizzi un cookie specifico per effettuare l'accesso. Se l'applicazione non assegna un nuovo cookie al momento del login, l'attaccante, possedendo il cookie originale, pu√≤ impersonare la vittima. Questa tecnica si basa sul fatto che la vittima effettua l'accesso con un cookie fornito dall'attaccante.

Se hai trovato un **XSS in un subdominio** o **controlli un subdominio**, leggi:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### Donazione di Sessione

Qui, l'attaccante convince la vittima a utilizzare il cookie di sessione dell'attaccante. La vittima, credendo di essere loggata nel proprio account, eseguir√† involontariamente azioni nel contesto dell'account dell'attaccante.

Se hai trovato un **XSS in un subdominio** o **controlli un subdominio**, leggi:

{% content-ref url="cookie-tossing.md" %}
[cookie-tossing.md](cookie-tossing.md)
{% endcontent-ref %}

### [Cookies JWT](../hacking-jwt-json-web-tokens.md)

Clicca sul link precedente per accedere a una pagina che spiega possibili difetti nei JWT.

I JSON Web Tokens (JWT) utilizzati nei cookies possono presentare vulnerabilit√†. Per informazioni dettagliate su potenziali difetti e su come sfruttarli, si consiglia di consultare il documento collegato sull'hacking dei JWT.

### Forgery di Richieste Cross-Site (CSRF)

Questo attacco costringe un utente loggato a eseguire azioni indesiderate su un'applicazione web in cui √® attualmente autenticato. Gli attaccanti possono sfruttare i cookies che vengono inviati automaticamente con ogni richiesta al sito vulnerabile.

### Cookies Vuoti

(Consulta ulteriori dettagli nella [ricerca originale](https://blog.ankursundara.com/cookie-bugs/)) I browser consentono la creazione di cookies senza nome, che possono essere dimostrati tramite JavaScript come segue:
```js
document.cookie = "a=v1"
document.cookie = "=test value;" // Setting an empty named cookie
document.cookie = "b=v2"
```
Il risultato nell'intestazione del cookie inviato √® `a=v1; valore di prova; b=v2;`. In modo intrigante, ci√≤ consente la manipolazione dei cookie se viene impostato un cookie con nome vuoto, potenzialmente controllando altri cookie impostando il cookie vuoto su un valore specifico:
```js
function setCookie(name, value) {
document.cookie = `${name}=${value}`;
}

setCookie("", "a=b"); // Setting the empty cookie modifies another cookie's value
```
Questo porta il browser a inviare un'intestazione del cookie interpretata da ogni server web come un cookie chiamato `a` con un valore `b`.

#### Bug di Chrome: Problema dei Punti di Codice Surrogati Unicode

In Chrome, se un punto di codice surrogato Unicode fa parte di un cookie impostato, `document.cookie` diventa corrotto, restituendo successivamente una stringa vuota:
```js
document.cookie = "\ud800=meep";
```
Questo comporta che `document.cookie` produca una stringa vuota, indicando una corruzione permanente.

#### Traffico di Cookie a Causa di Problemi di Parsing

(Controlla ulteriori dettagli nella [ricerca originale](https://blog.ankursundara.com/cookie-bugs/)) Diversi server web, tra cui quelli in Java (Jetty, TomCat, Undertow) e Python (Zope, cherrypy, web.py, aiohttp, bottle, webob), gestiscono in modo errato le stringhe dei cookie a causa del supporto obsoleto di RFC2965. Leggono un valore del cookie tra virgolette doppie come un singolo valore anche se include punti e virgola, che normalmente dovrebbero separare le coppie chiave-valore:
```
RENDER_TEXT="hello world; JSESSIONID=13371337; ASDF=end";
```
#### Vulnerabilit√† di Iniezione di Cookie

(Consulta ulteriori dettagli nella [ricerca originale](https://blog.ankursundara.com/cookie-bugs/)) L'errata interpretazione dei cookie da parte dei server, in particolare Undertow, Zope e quelli che utilizzano `http.cookie.SimpleCookie` e `http.cookie.BaseCookie` di Python, crea opportunit√† per attacchi di iniezione di cookie. Questi server non delimitano correttamente l'inizio di nuovi cookie, consentendo agli attaccanti di falsificare i cookie:

- Undertow si aspetta un nuovo cookie immediatamente dopo un valore tra virgolette senza punto e virgola.
- Zope cerca una virgola per iniziare l'analisi del cookie successivo.
- Le classi dei cookie di Python iniziano l'analisi su un carattere di spazio.

Questa vulnerabilit√† √® particolarmente pericolosa nelle applicazioni web che si basano sulla protezione CSRF basata sui cookie, poich√© consente agli attaccanti di iniettare cookie falsificati del token CSRF, bypassando potenzialmente le misure di sicurezza. Il problema √® aggravato dal modo in cui Python gestisce i nomi dei cookie duplicati, dove l'ultima occorrenza sovrascrive quelle precedenti. Solleva anche preoccupazioni per i cookie `__Secure-` e `__Host-` in contesti non sicuri e potrebbe portare a bypass dell'autorizzazione quando i cookie vengono passati a server back-end suscettibili di falsificazione.

### Controlli Extra sui Cookie Vulnerabili

#### **Controlli di base**

- Il **cookie** √® **sempre lo stesso** ogni volta che **effettui il login**.
- Esegui il logout e prova a utilizzare lo stesso cookie.
- Prova a effettuare il login con 2 dispositivi (o browser) nello stesso account utilizzando lo stesso cookie.
- Controlla se il cookie contiene informazioni e prova a modificarlo.
- Prova a creare diversi account con username quasi identici e controlla se riesci a vedere somiglianze.
- Controlla l'opzione "**ricordami**" se esiste per capire come funziona. Se esiste e potrebbe essere vulnerabile, utilizza sempre il cookie del **ricordami** senza altri cookie.
- Verifica se il cookie precedente funziona anche dopo aver cambiato la password.

#### **Attacchi avanzati ai cookie**

Se il cookie rimane lo stesso (o quasi) quando effettui il login, probabilmente significa che il cookie √® correlato a qualche campo del tuo account (probabilmente l'username). Quindi puoi:

- Prova a creare molti **account** con username molto **simili** e cerca di **indovinare** come funziona l'algoritmo.
- Prova a **forzare l'username**. Se il cookie salva solo come metodo di autenticazione per il tuo username, puoi creare un account con username "**Bmin**" e **forzare** ogni singolo **bit** del tuo cookie perch√© uno dei cookie che proverai sar√† quello appartenente a "**admin**".
- Prova l'**Oracle di Padding** (puoi decrittare il contenuto del cookie). Usa **padbuster**.

**Oracle di Padding - Esempi di Padbuster**
```bash
padbuster <URL/path/when/successfully/login/with/cookie> <COOKIE> <PAD[8-16]>
# When cookies and regular Base64
padbuster http://web.com/index.php u7bvLewln6PJPSAbMb5pFfnCHSEd6olf 8 -cookies auth=u7bvLewln6PJPSAbMb5pFfnCHSEd6olf

# If Base64 urlsafe or hex-lowercase or hex-uppercase --encoding parameter is needed, for example:
padBuster http://web.com/home.jsp?UID=7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6
7B216A634951170FF851D6CC68FC9537858795A28ED4AAC6 8 -encoding 2
```
Padbuster far√† diversi tentativi e ti chieder√† quale condizione √® l'errore (quella non valida).

Successivamente inizier√† a decifrare il cookie (potrebbero essere necessari diversi minuti)

Se l'attacco √® stato eseguito con successo, potresti provare a crittografare una stringa a tua scelta. Ad esempio, se volessi **crittografare** **user=administrator**
```
padbuster http://web.com/index.php 1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== 8 -cookies thecookie=1dMjA5hfXh0jenxJQ0iW6QXKkzAGIWsiDAKV3UwJPT2lBP+zAD0D0w== -plaintext user=administrator
```
Questo esecuzione ti dar√† il cookie correttamente criptato e codificato con la stringa **user=administrator** all'interno.

**CBC-MAC**

Forse un cookie potrebbe avere un certo valore e potrebbe essere firmato usando CBC. Quindi, l'integrit√† del valore √® la firma creata usando CBC con lo stesso valore. Poich√© √® consigliabile utilizzare un vettore IV nullo, questo tipo di controllo di integrit√† potrebbe essere vulnerabile.

**L'attacco**

1. Ottenere la firma dell'username **administ** = **t**
2. Ottenere la firma dell'username **rator\x00\x00\x00 XOR t** = **t'**
3. Impostare nel cookie il valore **administrator+t'** (**t'** sar√† una firma valida di **(rator\x00\x00\x00 XOR t) XOR t** = **rator\x00\x00\x00**

**ECB**

Se il cookie √® criptato usando ECB potrebbe essere vulnerabile.\
Quando effettui il login, il cookie che ricevi deve essere sempre lo stesso.

**Come rilevare e attaccare:**

Crea 2 utenti con dati quasi identici (username, password, email, ecc.) e cerca di scoprire qualche schema all'interno del cookie fornito

Crea un utente chiamato ad esempio "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" e controlla se c'√® qualche schema nel cookie (poich√© ECB cripta con la stessa chiave ogni blocco, gli stessi byte criptati potrebbero apparire se l'username √® criptato).

Dovrebbe esserci uno schema (con la dimensione di un blocco utilizzato). Quindi, sapendo come sono criptati un gruppo di "a" puoi creare un username: "a"\*(dimensione del blocco)+"admin". Quindi, potresti eliminare lo schema criptato di un blocco di "a" dal cookie. E avrai il cookie dell'username "admin".

## Riferimenti

* [https://blog.ankursundara.com/cookie-bugs/](https://blog.ankursundara.com/cookie-bugs/)
* [https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd](https://www.linkedin.com/posts/rickey-martin-24533653\_100daysofhacking-penetrationtester-ethicalhacking-activity-7016286424526180352-bwDd)

**Try Hard Security Group**

<figure><img src="../.gitbook/assets/telegram-cloud-document-1-5159108904864449420.jpg" alt=""><figcaption></figcaption></figure>

{% embed url="https://discord.gg/tryhardsecurity" %}

<details>

<summary><strong>Impara l'hacking AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se desideri vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PIANI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
