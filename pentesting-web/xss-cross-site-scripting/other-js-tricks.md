# Misc JS Tricks & Relevant Info

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hacklemeyi öğrenin<strong>!</strong></summary>

* Bir **cybersecurity şirketinde** çalışıyor musunuz? **Şirketinizi HackTricks'te reklamını görmek** ister misiniz? veya **PEASS'ın en son sürümüne veya HackTricks'i PDF olarak indirmek** ister misiniz? [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonunu.
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin.
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter**'da beni takip edin 🐦[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Hacking hilelerinizi** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ve** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ile göndererek paylaşın**.

</details>

## Javascript Fuzzing

### Geçerli JS Yorum Karakterleri

```javascript
//This is a 1 line comment
/* This is a multiline comment*/
#!This is a 1 line comment, but "#!" must to be at the beggining of the line
-->This is a 1 line comment, but "-->" must to be at the beggining of the line


for (let j = 0; j < 128; j++) {
for (let k = 0; k < 128; k++) {
for (let l = 0; l < 128; l++) {
if (j == 34 || k ==34 || l ==34)
continue;
if (j == 0x0a || k ==0x0a || l ==0x0a)
continue;
if (j == 0x0d || k ==0x0d || l ==0x0d)
continue;
if (j == 0x3c || k ==0x3c || l ==0x3c)
continue;
if (
(j == 47 && k == 47)
||(k == 47 && l == 47)
)
continue;
try {
var cmd = String.fromCharCode(j) + String.fromCharCode(k) + String.fromCharCode(l) + 'a.orange.ctf"';
eval(cmd);
} catch(e) {
var err = e.toString().split('\n')[0].split(':')[0];
if (err === 'SyntaxError' || err === "ReferenceError")
continue
err = e.toString().split('\n')[0]
}
console.log(err,cmd);
}
}
}
//From: https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#bounty-pl33z

// From: Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 43). Kindle Edition.
log=[];
for(let i=0;i<=0xff;i++){
for(let j=0;j<=0xfff;j++){
try {
eval(`${String.fromCodePoint(i,j)}%$£234$`)
log.push([i,j])
}catch(e){}
}
}
console.log(log)//[35,33],[47,47]
```

### Geçerli JS Yeni Satır Karakterleri

JavaScript'te yeni satır karakterlerini temsil etmek için kullanılan bazı geçerli karakterler vardır. Bu karakterler, metin içinde yeni bir satır başlatmak veya metni daha okunabilir hale getirmek için kullanılabilir. İşte bazı yaygın kullanılan geçerli JS yeni satır karakterleri:

* : Yeni bir satır başlatır.
* : Satır başını geri sarar.
* `\r`: Yeni bir satır başlatır ve satır başını geri sarar.
* `\u2028`: Unicode karakteriyle yeni bir satır başlatır.
* `\u2029`: Unicode karakteriyle yeni bir paragraf başlatır.

Bu karakterleri kullanarak JavaScript kodunuzda yeni satırlar ekleyebilir ve kodunuzu daha düzenli hale getirebilirsiniz.

```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10) //0x0a
String.fromCharCode(13) //0x0d
String.fromCharCode(8232) //0xe2 0x80 0xa8
String.fromCharCode(8233) //0xe2 0x80 0xa8

for (let j = 0; j < 65536; j++) {
try {
var cmd = '"aaaaa";'+String.fromCharCode(j) + '-->a.orange.ctf"';
eval(cmd);
} catch(e) {
var err = e.toString().split('\n')[0].split(':')[0];
if (err === 'SyntaxError' || err === "ReferenceError")
continue;
err = e.toString().split('\n')[0]
}
console.log(`[${err}]`,j,cmd);
}
//From: https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#bounty-pl33z
```

### Geçerli JS Boşlukları fonksiyon çağrısında

When performing a function call in JavaScript, it is possible to use different types of spaces to separate the function name from the opening parenthesis. This can be useful in evading certain security measures that may be in place.

The following types of spaces can be used:

* **Regular space**: This is the standard space character that is commonly used for separating words. It can be represented by the Unicode character `\u0020`.
* **Non-breaking space**: This is a space character that prevents line breaks from occurring at its position. It can be represented by the Unicode character `\u00A0`.
* **Zero-width space**: This is a space character that is not visible when rendered, but still takes up space. It can be represented by the Unicode character `\u200B`.

By using these different types of spaces, it is possible to bypass filters or detection mechanisms that may be looking for specific characters or patterns in the function call. However, it is important to note that this technique may not work in all cases, as security measures can vary depending on the specific implementation.

```javascript
// Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (pp. 40-41). Kindle Edition.

// Check chars that can be put in between in func name and the ()
function x(){}

log=[];
for(let i=0;i<=0x10ffff;i++){
try {
eval(`x${String.fromCodePoint(i)}()`)
log.push(i)
}catch(e){}
}

console.log(log)v//9,10,11,12,13,32,160,5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,813 232,8233,8239,8287,12288,65279
```

### **Dize Oluşturmak için Geçerli Karakterler**

The following characters can be used to generate strings in various scenarios:

Aşağıdaki karakterler çeşitli senaryolarda dizeler oluşturmak için kullanılabilir:

* **Alphanumeric Characters**: These are the combination of uppercase and lowercase letters (A-Z, a-z) and numbers (0-9).
* **Alfasayısal Karakterler**: Bunlar büyük ve küçük harflerin (A-Z, a-z) ve sayıların (0-9) kombinasyonudur.
* **Special Characters**: These include symbols such as !, @, #, $, %, ^, &, \*, (, ), -, \_, +, =, {, }, \[, ], |, , :, ;, ", ', <, >, ,, ., ?, /, and \~.
* **Özel Karakterler**: Bunlar !, @, #, $, %, ^, &, \*, (, ), -, \_, +, =, {, }, \[, ], |, , :, ;, ", ', <, >, ,, ., ?, / ve \~ gibi semboller içerir.
* **Whitespace Characters**: These are spaces, tabs, and line breaks.
* **Boşluk Karakterleri**: Bunlar boşluklar, sekme boşlukları ve satır sonlarıdır.
* **Control Characters**: These are non-printable characters such as null (\0), backspace (\b), form feed (\f), newline (\n), carriage return (\r), horizontal tab (\t), and vertical tab (\v).
* **Kontrol Karakterleri**: Bunlar yazdırılamayan karakterlerdir ve null (\0), backspace (\b), form feed (\f), newline (\n), carriage return (\r), horizontal tab (\t) ve vertical tab (\v) gibi karakterleri içerir.
* **Unicode Characters**: These are characters from the Unicode character set, which includes a wide range of characters from different languages and scripts.
* **Unicode Karakterleri**: Bunlar farklı dillerden ve yazı sistemlerinden geniş bir karakter yelpazesini içeren Unicode karakter kümesinden gelen karakterlerdir.

```javascript
// Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (pp. 41-42). Kindle Edition.

// Check which pairs of chars can make something be a valid string
log=[];
for(let i=0;i<=0x10ffff;i++){
try {
eval(`${String.fromCodePoint(i)}%$£234${String.fromCodePoint(i)}`)
log.push(i)
}catch(e){}
}
console.log(log) //34,39,47,96
//single quote, quotes, backticks & // (regex)
```

### **Surrogate Pairs BF (Yedek Çiftler BF)**

Bu teknik XSS için çok kullanışlı olmayabilir, ancak WAF korumalarını atlamak için kullanışlı olabilir. Bu python kodu, giriş olarak 2 bayt alır ve yüksek yedek çiftin son baytını ve düşük yedek çiftin son baytını arayan bir yedek çift bulur.

```python
def unicode(findHex):
for i in range(0,0xFFFFF):
H = hex(int(((i - 0x10000) / 0x400) + 0xD800))
h = chr(int(H[-2:],16))
L = hex(int(((i - 0x10000) % 0x400 + 0xDC00)))
l = chr(int(L[-2:],16))
if(h == findHex[0]) and (l == findHex[1]):
print(H.replace("0x","\\u")+L.replace("0x","\\u"))
```

Daha fazla bilgi:

* [https://github.com/dreadlocked/ctf-writeups/blob/master/nn8ed/README.md](https://github.com/dreadlocked/ctf-writeups/blob/master/nn8ed/README.md)
* [https://mathiasbynens.be/notes/javascript-unicode](https://mathiasbynens.be/notes/javascript-unicode) [https://mathiasbynens.be/notes/javascript-encoding](https://mathiasbynens.be/notes/javascript-encoding)

### `javascript{}:` Protokolü Fuzzing'i

```javascript
// Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 34). Kindle Edition.
log=[];
let anchor = document.createElement('a');
for(let i=0;i<=0x10ffff;i++){
anchor.href = `javascript${String.fromCodePoint(i)}:`;
if(anchor.protocol === 'javascript:') {
log.push(i);
}
}
console.log(log)//9,10,13,58
// Note that you could BF also other possitions of the use of multiple chars

// Test one option
let anchor = document.createElement('a');
anchor.href = `javascript${String.fromCodePoint(58)}:alert(1337)`;
anchor.append('Click me')
document.body.append(anchor)

// Another way to test
<a href="&#12;javascript:alert(1337)">Test</a>
```

### URL Fuzzing

URL Fuzzing, ayrıca bilinen adıyla URL keşfi, bir web uygulamasının URL yapısını ve parametrelerini keşfetmek için kullanılan bir tekniktir. Bu teknik, web uygulamasının davranışını anlamak ve potansiyel güvenlik açıklarını tespit etmek için kullanılır. URL Fuzzing, farklı URL yapıları ve parametre değerleriyle istekler göndererek hedef web uygulamasının tepkisini analiz eder. Bu sayede, güvenlik açıkları, hatalı yapılandırılmış parametreler veya giriş doğrulama zayıflıkları gibi potansiyel zayıf noktaları tespit etmek mümkün olabilir.

URL Fuzzing için çeşitli araçlar ve yöntemler mevcuttur. Bu araçlar, otomatik olarak farklı URL yapıları ve parametre değerleriyle istekler göndererek hedef web uygulamasını test eder. Bu sayede, potansiyel güvenlik açıkları hızlı bir şekilde tespit edilebilir. URL Fuzzing, özellikle Cross-Site Scripting (XSS), SQL enjeksiyonu, dizin keşfi gibi yaygın web uygulaması güvenlik açıklarını tespit etmek için etkili bir tekniktir.

URL Fuzzing, web uygulamalarının güvenlik açıklarını tespit etmek için kullanılan önemli bir pentesting tekniğidir. Bu teknik, web uygulamalarının güvenliğini artırmak ve potansiyel saldırıları önlemek için kullanılan bir yöntemdir.

```javascript
// Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (pp. 36-37). Kindle Edition.

// Before the protocol
a=document.createElement('a');
log=[];
for(let i=0;i<=0x10ffff;i++){
a.href = `${String.fromCodePoint(i)}https://hacktricks.xyz`;
if(a.hostname === 'hacktricks.xyz'){
log.push(i);
}
}
console.log(log) //0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32

// Between the slashes
a=document.createElement('a');
log=[];
for(let i=0;i<=0x10ffff;i++){
a.href = `/${String.fromCodePoint(i)}/hacktricks.xyz`;
if(a.hostname === 'hacktricks.xyz'){
log.push(i);
}
}
console.log(log) //9,10,13,47,92
```

### HTML Fuzzing

HTML Fuzzing, HTML Fazlama olarak da bilinir, web uygulamalarında XSS açıklarını bulmak için kullanılan bir tekniktir. Bu teknik, web uygulamasına giriş parametrelerine farklı HTML etiketleri, öznitelikleri ve değerleri enjekte ederek gerçekleştirilir. Bu sayede, web uygulamasının nasıl tepki verdiği ve potansiyel XSS açıklarının olup olmadığı test edilir.

HTML Fazlama, otomatik araçlar veya elle yapılan testlerle gerçekleştirilebilir. Otomatik araçlar, farklı HTML etiketleri ve değerlerini otomatik olarak enjekte ederek web uygulamasını test eder. Elle yapılan testlerde ise, farklı HTML etiketleri ve değerleri manuel olarak giriş parametrelerine eklenir ve web uygulamasının tepkisi gözlemlenir.

HTML Fazlama, web uygulamalarında XSS açıklarını bulmak için etkili bir tekniktir. Bu teknik sayesinde, web uygulamasının güvenlik açıkları tespit edilerek gerekli önlemler alınabilir.

```javascript
// Heyes, Gareth. JavaScript for hackers: Learn to think like a hacker (p. 38). Kindle Edition.

// Fuzzing chars that can close an HTML comment

let log=[];
let div = document.createElement('div');
for(let i=0;i<=0x10ffff;i++){
div.innerHTML=`<!----${String.fromCodePoint(i)}><span></span>-->`;
if(div.querySelector('span')){
log.push(i);
}
}
console.log(log)//33,45,62
```

## **Atributları Analiz Etmek**

Portswigger'ın **Hackability inspector** aracı, bir javascript nesnesinin **atributlarını analiz etmeye** yardımcı olur. Kontrol edin: [https://portswigger-labs.net/hackability/inspector/?input=x.contentWindow\&html=%3Ciframe%20src=//subdomain1.portswigger-labs.net%20id=x%3E](https://portswigger-labs.net/hackability/inspector/?input=x.contentWindow\&html=%3Ciframe%20src=//subdomain1.portswigger-labs.net%20id=x%3E)

## **.map js dosyaları**

* .map js dosyalarını indirmek için bir hile: [https://medium.com/@bitthebyte/javascript-for-bug-bounty-hunters-part-2-f82164917e7](https://medium.com/@bitthebyte/javascript-for-bug-bounty-hunters-part-2-f82164917e7)
* Bu dosyaları analiz etmek için bu aracı kullanabilirsiniz: [https://github.com/paazmaya/shuji](https://github.com/paazmaya/shuji)

## "--" Atama

Azaltma operatörü `--` aynı zamanda bir atamadır. Bu operatör, bir değeri alır ve ardından bir azaltma işlemi yapar. Eğer bu değer bir sayı değilse, `NaN` olarak ayarlanır. Bu, değişkenlerin içeriğini ortamdan **kaldırmak** için kullanılabilir.

![](<../../.gitbook/assets/image (553).png>)

![](<../../.gitbook/assets/image (554).png>)

## Fonksiyon Hileleri

### .call ve .apply

Bir fonksiyonun **`.call`** yöntemi, fonksiyonu **çalıştırmak** için kullanılır.\
Varsayılan olarak beklediği **ilk argüman**, **`this`** değeridir ve eğer **hiçbir şey** sağlanmazsa, bu değer **`window`** olur (eğer **`strict mode`** kullanılmıyorsa).

```javascript
function test_call(){
console.log(this.value); //baz
}
new_this={value:"hey!"}
test_call.call(new_this);

// To pass more arguments, just pass then inside .call()
function test_call() {
console.log(arguments[0]); //"arg1"
console.log(arguments[1]); //"arg2"
console.log(this); //[object Window]
}
test_call.call(null, "arg1", "arg2")

// If you use the "use strict" directive "this" will be null instead of window:
function test_call() {
"use strict";
console.log(this); //null
}
test_call.call(null)

//The apply function is pretty much exactly the same as the call function with one important difference, you can supply an array of arguments in the second argument:
function test_apply() {
console.log(arguments[0]); //"arg1"
console.log(arguments[1]); //"arg2"
console.log(this); //[object Window]
}
test_apply.apply(null, ["arg1", "arg2"])
```

### Ok işlevleri

Ok işlevleri, işlevleri tek bir satırda daha kolay bir şekilde oluşturmanıza olanak tanır (anladıysanız).

```javascript
// Traditional
function (a){ return a + 1; }
// Arrow forms
a => a + 100;
a => {a + 100};

// Traditional
function (a, b){ return a + b + 1; }
// Arrow
(a, b) => a + b + 100;

// Tradictional no args
let a = 4;
let b = 2;
function (){ return a + b + 1; }

// Arrow
let a = 4;
let b = 2;
() => a + b + 1;
```

Öyleyse, önceki işlevlerin çoğu aslında işe yaramaz çünkü onları kaydetmiyoruz ve çağırmak için bir yer yok. Örnek olarak `plusone` işlevini oluşturmak:

```javascript
// Traductional
function plusone (a){ return a + 1; }

//Arrow
plusone = a => a + 100;
```

### Bind fonksiyonu

Bind fonksiyonu, **`this`** nesnesini ve verilen **parametreleri değiştirerek** bir **fonksiyonun kopyasını oluşturmaya** olanak sağlar.

```javascript
//This will use the this object and print "Hello World"
var fn = function ( param1, param2 ) {
console.info( this, param1, param2 );
}
fn('Hello', 'World')

//This will still use the this object and print "Hello World"
var copyFn = fn.bind();
copyFn('Hello', 'World')

//This will use the "console" object as "this" object inside the function and print "fixingparam1 Hello"
var bindFn_change = fn.bind(console, "fixingparam1");
bindFn_change('Hello', 'World')

//This will still use the this object and print "fixingparam1 Hello"
var bindFn_thisnull = fn.bind(null, "fixingparam1");
bindFn_change('Hello', 'World')

//This will still use the this object and print "fixingparam1 Hello"
var bindFn_this = fn.bind(this, "fixingparam1");
bindFn_change('Hello', 'World')
```

{% hint style="info" %}
Dikkat, **`bind`** kullanarak, fonksiyon çağrıldığında kullanılacak olan **`this`** nesnesini manipüle edebilirsiniz.
{% endhint %}

### Fonksiyon kodu sızıntısı

Bir fonksiyonun nesnesine **erişebiliyorsanız**, o fonksiyonun **kodunu alabilirsiniz**.

```javascript
function afunc(){
return 1+1;
}
console.log(afunc.toString()); //This will print the code of the function
console.log(String(afunc)); //This will print the code of the function
console.log(this.afunc.toString()); //This will print the code of the function
console.log(global.afunc.toString()); //This will print the code of the function
```

Eğer **fonksiyonun bir adı yoksa**, yine de **fonksiyon kodunu** içeriden yazdırabilirsiniz:

```javascript
(function (){ return arguments.callee.toString(); })()
(function (){ return arguments[0]; })("arg0")
```

Bir fonksiyonun (hatta yorumlar dahil) kodunu başka bir fonksiyondan çıkarmak için bazı **rastgele** yöntemler:

```javascript
(function (){ return retFunc => String(arguments[0]) })(a=>{/* Hidden commment */})()
(function (){ return retFunc => Array(arguments[0].toString()) })(a=>{/* Hidden commment */})()
(function (){ return String(this)}).bind(()=>{ /* Hidden commment */ })()
(u=>(String(u)))(_=>{ /* Hidden commment */ })
(u=>_=>(String(u)))(_=>{ /* Hidden commment */ })()
```

## Sandbox Kaçışı - Pencere nesnesini kurtarma

Pencere nesnesi, alert veya eval gibi global olarak tanımlanmış fonksiyonlara erişmeyi sağlar.

{% code overflow="wrap" %}
```javascript
// Some ways to access window
window.eval("alert(1)")
frames
globalThis
parent
self
top //If inside a frame, this is top most window

// Access window from document
document.defaultView.alert(1)
// Access document from a node object
node = document.createElement('div')
node.ownerDocument.defaultView.alert(1)

// There is a path property on each error event whose last element is the window
<img src onerror=event.path.pop().alert(1337)>
// In other browsers the method is
<img src onerror=event.composedPath().pop().alert(1337)>
// In case of svg, the "event" object is called "evt"
<svg><image href=1 onerror=evt.composedPath().pop().alert(1337)>

// Abusing Error.prepareStackTrace to get Window back
Error.prepareStackTrace=function(error, callSites){
2   callSites.shift().getThis().alert(1337);
3 };
4 new Error().stack

// From an HTML event
// Events from HTML are executed in this context
with(document) {
with(element) {
//executed event
}
}
// Because of that with(document) it's possible to access properties of document like:
<img src onerror=defaultView.alert(1337)>
<img src onerror=s=createElement('script');s.append('alert(1337)');appendChild(s)>
```
{% endcode %}

## Değere erişimde kesme noktası

```javascript
Object.defineProperty(window, 'value', {
  get: function() {
    debugger;
    return this._value;
  },
  set: function(val) {
    this._value = val;
  }
});
```

This JavaScript code sets a breakpoint whenever the `value` property is accessed. When the property is accessed, the `debugger` statement is triggered, allowing you to inspect the code execution at that point. This can be useful for debugging and understanding how the code is interacting with the `value` property.

Bu JavaScript kodu, `value` özelliğine her erişildiğinde bir kesme noktası ayarlar. Özellik erişildiğinde, `debugger` ifadesi tetiklenir ve kodun o noktadaki yürütmesini incelemenizi sağlar. Bu, hata ayıklama yapmak ve kodun `value` özelliğiyle nasıl etkileşimde bulunduğunu anlamak için kullanışlı olabilir.

```javascript
// Stop when a property in sessionStorage or localStorage is set/get
// via getItem or setItem functions
sessionStorage.getItem = localStorage.getItem  = function(prop) {
debugger;
return sessionStorage[prop];
}

localStorage.setItem = function(prop, val) {
debugger;
localStorage[prop] = val;
}
```

```javascript
// Stop when anyone sets or gets the property "ppmap" in any object
// For example sessionStorage.ppmap
// "123".ppmap
// Useful to find where weird properties are being set or accessed
// or to find where prototype pollutions are occurring

function debugAccess(obj, prop, debugGet=true){

var origValue = obj[prop];

Object.defineProperty(obj, prop, {
get: function () {
if ( debugGet )
debugger;
return origValue;
},
set: function(val) {
debugger;
origValue = val;
}
});
};

debugAccess(Object.prototype, 'ppmap')
```

## Otomatik Tarayıcı Erişimi için test yükleri

Sometimes, during the testing phase, it is necessary to automate the process of accessing a web page with different payloads to test for vulnerabilities. This can be achieved using various tools and techniques.

Bazen test aşamasında, zafiyetleri test etmek için farklı yüklerle bir web sayfasına otomatik erişim sağlama sürecini otomatikleştirmek gerekebilir. Bu, çeşitli araçlar ve teknikler kullanılarak gerçekleştirilebilir.

One approach is to use headless browsers, such as Puppeteer or Selenium, which allow you to control a browser programmatically. These tools can be used to navigate to a specific URL and execute JavaScript code, including payloads, on the target page.

Bir yaklaşım, Puppeteer veya Selenium gibi başsız tarayıcıları kullanmaktır. Bu araçlar, bir tarayıcıyı programatik olarak kontrol etmenizi sağlar. Bu araçlar, hedef sayfada belirli bir URL'ye gitmek ve yükler de dahil olmak üzere JavaScript kodunu yürütmek için kullanılabilir.

Another option is to use browser automation frameworks like PhantomJS or CasperJS. These frameworks provide APIs that allow you to script interactions with web pages, including the execution of JavaScript payloads.

Başka bir seçenek, PhantomJS veya CasperJS gibi tarayıcı otomasyon çerçevelerini kullanmaktır. Bu çerçeveler, JavaScript yüklerinin yürütülmesi de dahil olmak üzere web sayfalarıyla etkileşimleri betimlemenize olanak sağlayan API'ler sağlar.

By automating the process of accessing web pages with different payloads, you can quickly test for cross-site scripting (XSS) vulnerabilities and identify potential security issues in your web application.

Farklı yüklerle web sayfalarına otomatik erişimi sağlayarak, çapraz site komut dosyası (XSS) zafiyetlerini hızlı bir şekilde test edebilir ve web uygulamanızdaki potansiyel güvenlik sorunlarını tespit edebilirsiniz.

```javascript
//Taken from https://github.com/svennergr/writeups/blob/master/inti/0621/README.md
const puppeteer = require("puppeteer");

const realPasswordLength = 3000;
async function sleep(ms) {
return new Promise((resolve) => setTimeout(resolve, ms));
}

(async () => {
const browser = await puppeteer.launch();
const page = await browser.newPage();
//Loop to iterate through different values
for (let i = 0; i < 10000; i += 100) {
console.log(`Run number ${i}`);
const input = `${"0".repeat(i)}${realPasswordLength}`;
console.log(`  https://challenge-0621.intigriti.io/passgen.php?passwordLength=${input}&allowNumbers=true&allowSymbols=true&timestamp=1624556811000`);
//Go to the page
await page.goto(
`https://challenge-0621.intigriti.io/passgen.php?passwordLength=${input}&allowNumbers=true&allowSymbols=true&timestamp=1624556811000`
);
//Call function "generate()" inside the page
await page.evaluate("generate()");
//Get node inner text from an HTML element
const passwordContent = await page.$$eval(
".alert .page-content",
(node) => node[0].innerText
);
//Transform the content and print it in console
const plainPassword = passwordContent.replace("Your password is: ", "");
if (plainPassword.length != realPasswordLength) {
console.log(i, plainPassword.length, plainPassword);
}

await sleep(1000);
}
await browser.close();
})();
```

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

* Bir **cybersecurity şirketinde çalışıyor musunuz**? **Şirketinizi HackTricks'te reklamını görmek** ister misiniz? veya **PEASS'ın en son sürümüne veya HackTricks'i PDF olarak indirmek** ister misiniz? [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonunu.
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin.
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter**'da beni takip edin 🐦[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Hacking hilelerinizi** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **ve** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **ile göndererek paylaşın.**

</details>
