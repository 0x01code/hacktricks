<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **Hacking 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 저장소에 제출**하세요.

</details>


# SAML 개요

**보안 주장 마크업 언어 (SAML)**는 식별 공급자 (IdP)가 서비스 제공자 (SP)로 인증 자격 증명을 보내는 데 사용되어 단일 로그인 (SSO)을 용이하게 합니다. 이 접근 방식은 여러 웹 사이트에서 동일한 자격 증명 세트를 사용하여 여러 로그인의 관리를 간소화합니다. SAML은 IdP와 SP 간의 표준화된 통신을 위해 XML을 활용하여 사용자 신원의 인증을 서비스 권한 부여와 연결합니다.

## SAML과 OAuth의 비교

- **SAML**은 기업에게 SSO 로그인 보안을 더욱 효과적으로 제공하기 위해 맞춤화되었습니다.
- **OAuth**는 모바일 친화적이며 JSON을 사용하며 Google 및 Twitter와 같은 회사들의 공동 노력으로 설계되었습니다.

# SAML 인증 흐름

**자세한 내용은 [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)에서 전체 게시물을 확인하세요**. 이것은 요약입니다:

SAML 인증 프로세스는 다음과 같은 단계로 이루어집니다. 스키마에서 설명된 대로:

![https://epi052.gitlab.io/notes-to-self/img/saml/saml-flow.jpg](https://epi052.gitlab.io/notes-to-self/img/saml/saml-flow.jpg)

1. **리소스 액세스 시도**: 사용자가 보호된 리소스에 액세스를 시도합니다.
2. **SAML 요청 생성**: SP는 사용자를 인식하지 못하고 SAML 요청을 생성합니다.
3. **IdP로 리디렉션**: 사용자는 SAML 요청이 사용자의 브라우저를 통해 IdP로 리디렉션됩니다.
4. **IdP가 요청 수신**: IdP는 SAML 요청을 수신합니다.
5. **IdP에서 인증**: IdP는 사용자를 인증합니다.
6. **사용자 유효성 검사**: IdP는 사용자의 자격 증명이 요청된 리소스에 액세스할 수 있는지 확인합니다.
7. **SAML 응답 생성**: IdP는 필요한 주장을 포함한 SAML 응답을 생성합니다.
8. **SP의 ACS URL로 리디렉션**: 사용자는 SP의 Assertion Consumer Service (ACS) URL로 리디렉션됩니다.
9. **SAML 응답 유효성 검사**: ACS는 SAML 응답을 유효성 검사합니다.
10. **리소스 액세스 승인**: 초기에 요청된 리소스에 대한 액세스가 승인됩니다.

# SAML 요청 예제

사용자가 [https://shibdemo-sp1.test.edu/secure/](https://shibdemo-sp1.test.edu/secure/)에서 안전한 리소스에 액세스를 요청하는 시나리오를 고려해보겠습니다. SP는 인증 부족을 식별하고 SAML 요청을 생성합니다:
```
GET /secure/ HTTP/1.1
Host: shibdemo-sp1.test.edu
...
```
SAML 요청의 원본은 다음과 같습니다:
```xml
<?xml version="1.0"?>
<samlp:AuthnRequest ...
</samlp:AuthnRequest>
```
이 요청의 주요 요소는 다음과 같습니다:
- **AssertionConsumerServiceURL**: IdP가 SAML 응답을 인증 후 전송해야 할 위치를 지정합니다.
- **Destination**: 요청이 전송되는 IdP의 주소입니다.
- **ProtocolBinding**: SAML 프로토콜 메시지의 전송 방법을 정의합니다.
- **saml:Issuer**: 요청을 시작한 엔티티를 식별합니다.

SAML 요청 생성 후, SP는 **302 리디렉션**을 통해 브라우저를 IdP로 이동시키고, SAML 요청을 HTTP 응답의 **Location** 헤더에 인코딩하여 전송합니다. **RelayState** 매개변수는 트랜잭션 동안 상태 정보를 유지하여 SP가 SAML 응답을 받을 때 초기 리소스 요청을 인식할 수 있도록 합니다. **SAMLRequest** 매개변수는 원시 XML 스니펫의 압축 및 인코딩된 버전으로, Deflate 압축과 base64 인코딩을 사용합니다.


# SAML 응답 예시

[여기에서 전체 SAML 응답을 찾을 수 있습니다](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/). 응답의 주요 구성 요소는 다음과 같습니다:

- **ds:Signature**: 이 부분은 XML 서명으로, 주장의 발행자의 무결성과 신뢰성을 보장합니다. 예시의 SAML 응답에는 메시지와 주장을 위한 두 개의 `ds:Signature` 요소가 포함되어 있습니다.
- **saml:Assertion**: 이 부분은 사용자의 신원과 가능한 다른 속성에 대한 정보를 포함합니다.
- **saml:Subject**: 주장의 모든 문장의 주요 주체를 지정합니다.
- **saml:StatusCode**: 해당 요청에 대한 작업의 상태를 나타냅니다.
- **saml:Conditions**: 주장의 유효 시간 및 지정된 서비스 제공자와 같은 조건에 대한 세부 정보를 제공합니다.
- **saml:AuthnStatement**: 주장의 주체가 IdP에 의해 인증되었음을 확인합니다.
- **saml:AttributeStatement**: 주장의 주체를 설명하는 속성을 포함합니다.

SAML 응답 이후, 프로세스에는 IdP로의 302 리디렉션이 포함됩니다. 이는 서비스 제공자의 Assertion Consumer Service (ACS) URL로의 POST 요청으로 이어집니다. POST 요청에는 `RelayState` 및 `SAMLResponse` 매개변수가 포함됩니다. ACS는 SAML 응답을 처리하고 유효성을 검증하는 역할을 담당합니다.

POST 요청을 받고 SAML 응답을 검증한 후, 사용자가 최초로 요청한 보호된 리소스에 대한 액세스가 허용됩니다. 이는 `/secure/` 엔드포인트로의 `GET` 요청과 리소스에 대한 성공적인 액세스를 나타내는 `200 OK` 응답으로 설명됩니다.


# XML 서명

XML 서명은 XML 트리 전체 또는 특정 요소에 서명할 수 있는 다재다능한 기능을 가지고 있습니다. 이는 응답 요소뿐만 아니라 모든 XML 개체에 적용할 수 있습니다. 아래는 XML 서명의 주요 유형입니다:

### XML 서명의 기본 구조
XML 서명은 다음과 같은 필수 요소로 구성됩니다:
```xml
<Signature>
<SignedInfo>
<CanonicalizationMethod />
<SignatureMethod />
<Reference>
<Transforms />
<DigestMethod />
<DigestValue />
</Reference>
...
</SignedInfo>
<SignatureValue />
<KeyInfo />
<Object />
</Signature>
```
각 `Reference` 요소는 URI 속성으로 식별 가능한 특정 리소스에 대한 서명을 나타냅니다.

### XML 서명의 유형

1. **Enveloped Signature**: 이 유형의 서명은 서명하는 리소스의 하위 항목이며, 즉 서명은 서명된 내용과 동일한 XML 구조 내에 포함됩니다.

예시:
```xml
<samlp:Response ... ID="..." ... >
...
<ds:Signature>
<ds:SignedInfo>
...
<ds:Reference URI="#...">
...
</ds:Reference>
</ds:SignedInfo>
</ds:Signature>
...
</samlp:Response>
```

Enveloped 서명에서 `ds:Transform` 요소는 `enveloped-signature` 알고리즘을 통해 서명이 포함되었음을 지정합니다.

2. **Enveloping Signature**: Enveloped 서명과는 달리, Enveloping 서명은 서명되는 리소스를 랩합니다.

예시:
```xml
<ds:Signature>
<ds:SignedInfo>
...
<ds:Reference URI="#...">
...
</ds:Reference>
</ds:SignedInfo>
<samlp:Response ... ID="..." ... >
...
</samlp:Response>
</ds:Signature>
```

3. **Detached Signature**: 이 유형은 서명하는 내용과 별개로 존재합니다. 서명과 내용은 독립적으로 존재하지만 둘 사이의 링크가 유지됩니다.

예시:
```xml
<samlp:Response ... ID="..." ... >
...
</samlp:Response>
<ds:Signature>
<ds:SignedInfo>
...
<ds:Reference URI="#...">
...
</ds:Reference>
</ds:SignedInfo>
</ds:Signature>
```

결론적으로, XML 서명은 XML 문서를 보호하기 위한 유연한 방법을 제공하며, 각 유형은 다른 구조적 및 보안 요구를 충족시킵니다.


## 참고 자료
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로에서 영웅까지 AWS 해킹 배우기<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks에서 **회사 광고를 보거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 상품**](https://peass.creator-spring.com)을 구매하세요.
* 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
