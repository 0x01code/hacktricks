<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong>を使って、ゼロからヒーローまでAWSハッキングを学びましょう！</summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい場合**は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter**で私をフォローする🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)。
- **HackTricks**と**HackTricks Cloud**のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>


# SAML概要

**Security Assertion Markup Language（SAML）**は、アイデンティティプロバイダー（IdP）がサービスプロバイダー（SP）に認証資格情報を送信できるようにするオープン標準です。基本的に、複数のウェブサイトで1つの資格情報セットを使用できるシングルサインオン（SSO）を可能にします。これにより、複数のログイン（例：メール、CRMソフトウェア、Active Directoryなど）の管理が簡素化されます。SAMLは、IdPとSPの間でユーザーのアイデンティティ認証をサービスの認可とリンクするためにXMLを使用して標準化された通信を容易にします。

# SAMLとOAuthの比較

**SAML**と**OAuth**は両方ともインターネットログインを効率化しますが、それぞれの違いがあります：

- **SAML**は企業により多くの制御を提供し、SSOログインのセキュリティを向上させます。
- **OAuth**はモバイルフレンドリーであり、JSONを利用し、GoogleとTwitterによって共同開発されました。

# SAML認証フロー

詳細については、[https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)から完全な投稿を確認してください。これは要約です：

SAML認証プロセスには、次のステップが関与します（スキーマで示されています）：

![https://epi052.gitlab.io/notes-to-self/img/saml/saml-flow.jpg](https://epi052.gitlab.io/notes-to-self/img/saml/saml-flow.jpg)

1. **リソースアクセス試行**：ユーザーが保護されたリソースにアクセスしようとします。
2. **SAMLリクエスト生成**：SPはユーザーを認識せず、SAMLリクエストを生成します。
3. **IdPへのリダイレクト**：ユーザーはIdPにリダイレクトされ、SAMLリクエストがユーザーのブラウザを介して渡されます。
4. **IdPがリクエストを受信**：IdPはSAMLリクエストを受信します。
5. **IdPでの認証**：IdPがユーザーを認証します。
6. **ユーザーの検証**：IdPはユーザーのリクエストされたリソースへのアクセス権を検証します。
7. **SAMLレスポンスの作成**：IdPは必要なアサーションを含むSAMLレスポンスを生成します。
8. **SPのACS URLへのリダイレクト**：ユーザーはSPのAssertion Consumer Service（ACS）URLにリダイレクトされます。
9. **SAMLレスポンスの検証**：ACSがSAMLレスポンスを検証します。
10. **リソースアクセスが許可される**：最初にリクエストされたリソースへのアクセスが許可されます。

# SAMLリクエストの例

セキュアリソースへのアクセスをリクエストするユーザーのシナリオを考えてみましょう：[https://shibdemo-sp1.test.edu/secure/](https://shibdemo-sp1.test.edu/secure/)。SPは認証の欠如を特定し、SAMLリクエストを生成します：
```
GET /secure/ HTTP/1.1
Host: shibdemo-sp1.test.edu
...
```
SAMLリクエストの生データは次のようになります：
```xml
<?xml version="1.0"?>
<samlp:AuthnRequest ...
</samlp:AuthnRequest>
```
- **AssertionConsumerServiceURL**: IdPがSAMLレスポンスを認証後に送信する場所を指定します。
- **Destination**: リクエストが送信されるIdPのアドレスです。
- **ProtocolBinding**: SAMLプロトコルメッセージの送信方法を定義します。
- **saml:Issuer**: リクエストを開始したエンティティを識別します。

SAMLリクエストの生成後、SPは**302リダイレクト**を返し、ブラウザをSAMLリクエストをHTTPレスポンスの**Location**ヘッダにエンコードしてIdPにリダイレクトします。**RelayState**パラメータはトランザクション全体で状態情報を維持し、SPがSAMLレスポンスを受け取った際に初期リソースリクエストを認識することを保証します。**SAMLRequest**パラメータは、生のXMLスニペットの圧縮およびエンコードされたバージョンであり、Deflate圧縮とbase64エンコーディングを使用します。


# SAMLレスポンスの例

[こちらで完全なSAMLレスポンスを見つけることができます](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)。レスポンスの主要なコンポーネントは次のとおりです：

- **ds:Signature**: このセクションはXML署名で、アサーションの発行者の整合性と信頼性を保証します。例のSAMLレスポンスには、メッセージ用とアサーション用の2つの`ds:Signature`要素が含まれています。
- **saml:Assertion**: この部分には、ユーザーのアイデンティティや他の属性に関する情報が含まれています。
- **saml:Subject**: アサーション内のすべてのステートメントの主題を指定します。
- **saml:StatusCode**: 対応するリクエストに対する操作のステータスを表します。
- **saml:Conditions**: アサーションの有効期間や指定されたサービスプロバイダのような条件の詳細を示します。
- **saml:AuthnStatement**: IdPがアサーションの主題を認証したことを確認します。
- **saml:AttributeStatement**: アサーションの主題を記述する属性が含まれています。

SAMLレスポンスの後、プロセスにはIdPからの302リダイレクトが含まれます。これにより、サービスプロバイダのAssertion Consumer Service（ACS）URLに対するPOSTリクエストが行われます。POSTリクエストには`RelayState`および`SAMLResponse`パラメータが含まれます。ACSはSAMLレスポンスの処理と検証を担当します。

POSTリクエストを受信し、SAMLレスポンスが検証されると、ユーザーが最初にリクエストした保護されたリソースへのアクセスが許可されます。これは、`GET`リクエストが`/secure/`エンドポイントに対して行われ、成功したリソースへのアクセスを示す`200 OK`レスポンスで示されます。


# XML署名

XML署名は多目的であり、XMLツリー全体または特定の要素に署名することができます。これはレスポンス要素だけでなく、任意のXMLオブジェクトに適用できます。以下はXML署名の主要なタイプです：

### XML署名の基本構造
XML署名には、次に示す基本要素が含まれます：
```xml
<Signature>
<SignedInfo>
<CanonicalizationMethod />
<SignatureMethod />
<Reference>
<Transforms />
<DigestMethod />
<DigestValue />
</Reference>
...
</SignedInfo>
<SignatureValue />
<KeyInfo />
<Object />
</Signature>
```
各`Reference`要素は、URI属性によって識別される特定のリソースを示します。

### XML署名の種類

1. **封入署名**：このタイプの署名は、署名されるリソースの子孫であり、署名は署名されたコンテンツと同じXML構造内に含まれていることを意味します。

例：
```xml
<samlp:Response ... ID="..." ... >
...
<ds:Signature>
<ds:SignedInfo>
...
<ds:Reference URI="#...">
...
</ds:Reference>
</ds:SignedInfo>
</ds:Signature>
...
</samlp:Response>
```

封入署名では、`ds:Transform`要素が`enveloped-signature`アルゴリズムを介して封入されていることを指定します。

2. **包含署名**：封入署名とは対照的に、包含署名は署名されるリソースを包み込みます。

例：
```xml
<ds:Signature>
<ds:SignedInfo>
...
<ds:Reference URI="#...">
...
</ds:Reference>
</ds:SignedInfo>
<samlp:Response ... ID="..." ... >
...
</samlp:Response>
</ds:Signature>
```

3. **分離署名**：このタイプは、署名とコンテンツが独立して存在しますが、両者の間にリンクが維持されます。

例：
```xml
<samlp:Response ... ID="..." ... >
...
</samlp:Response>
<ds:Signature>
<ds:SignedInfo>
...
<ds:Reference URI="#...">
...
</ds:Reference>
</ds:SignedInfo>
</ds:Signature>
```

結論として、XML署名はXMLドキュメントを保護する柔軟な方法を提供し、各タイプが異なる構造上のニーズやセキュリティ上のニーズを満たします。


# 参考文献
* [https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/](https://epi052.gitlab.io/notes-to-self/blog/2019-03-07-how-to-test-saml-a-methodology/)
