En este POST se explicará un ejemplo usando java.io.Serializable.

# Serializable

La interfaz Java `Serializable` (`java.io.Serializable`) es una interfaz de marcador que sus clases deben implementar si van a ser **serializadas** y **deserializadas**. La serialización de objetos Java (escritura) se realiza con [ObjectOutputStream](http://tutorials.jenkov.com/java-io/objectoutputstream.html) y la deserialización (lectura) se realiza con [ObjectInputStream](http://tutorials.jenkov.com/java-io/objectinputstream.html).

Veamos un ejemplo con una **clase Persona** que es **serializable**. Esta clase **sobrescribe la función readObject**, por lo que cuando **cualquier objeto** de esta **clase** se **deserializa**, esta **función** se va a **ejecutar**.\
En el ejemplo, la **función readObject** de la clase Persona llama a la función `eat()` de su mascota y la función `eat()` de un perro (por alguna razón) llama a un **calc.exe**. **Vamos a ver cómo serializar y deserializar un objeto Persona para ejecutar esta calculadora:**
```java
import java.io.Serializable;
import java.io.*;

public class TestDeserialization {
    interface Animal {
        public void eat();
    }
    //Class must implements Serializable to be serializable
    public static class Cat implements Animal,Serializable {
        @Override
        public void eat() {
            System.out.println("cat eat fish");
        }
    }
    //Class must implements Serializable to be serializable
    public static class Dog implements Animal,Serializable {
        @Override
        public void eat() {
            try {
                Runtime.getRuntime().exec("calc");
            } catch (IOException e) {
                e.printStackTrace();
            }
            System.out.println("dog eat bone");
        }
    }
    //Class must implements Serializable to be serializable
    public static class Person implements Serializable {
        private Animal pet;
        public Person(Animal pet){
            this.pet = pet;
        }
        //readObject implementation, will call the readObject from ObjectInputStream  and then call pet.eat()
        private void readObject(java.io.ObjectInputStream stream)
                throws IOException, ClassNotFoundException {
            pet = (Animal) stream.readObject();
            pet.eat();
        }
    }
    public static void GeneratePayload(Object instance, String file)
            throws Exception {
        //Serialize the constructed payload and write it to the file
        File f = new File(file);
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
        out.writeObject(instance);
        out.flush();
        out.close();
    }
    public static void payloadTest(String file) throws Exception {
        //Read the written payload and deserialize it
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
        Object obj = in.readObject();
        System.out.println(obj);
        in.close();
    }
    public static void main(String[] args) throws Exception {
        // Example to call Person with a Dog
        Animal animal = new Dog();
        Person person = new Person(animal);
        GeneratePayload(person,"test.ser");
        payloadTest("test.ser");
        // Example to call Person with a Cat
        //Animal animal = new Cat();
        //Person person = new Person(animal);
        //GeneratePayload(person,"test.ser");
        //payloadTest("test.ser");
    }
}
```
Este ejemplo fue tomado de [https://medium.com/@knownsec404team/java-deserialization-tool-gadgetinspector-first-glimpse-74e99e493649](https://medium.com/@knownsec404team/java-deserialization-tool-gadgetinspector-first-glimpse-74e99e493649)

## Conclusión

Como se puede ver en este ejemplo muy básico, la "vulnerabilidad" aquí aparece porque la función **readObject** está **llamando a otras funciones vulnerables**.
