# HTTP/2ダウングレードにおけるリクエストスマグリング

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でゼロからヒーローまでAWSハッキングを学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>

## 起源

この脆弱性の主な起源は、**リバースプロキシ**がクライアントと**HTTP/2**を使用して**通信**し、その後、その**通信**を**バックエンドサーバー**との**HTTP/1.1**へと**変換**するという事実にあります。

![](<../../.gitbook/assets/image (636) (1).png>)

このアプローチの問題は、**ユーザー**が**HTTP/2通信**で不必要に**ヘッダー**を**注入**することができ、プロキシによって**チェックされない**可能性があることです。しかし、それらが**HTTP/1.1通信**に**盲目的に注入される**と、**リクエストスマグリング攻撃が実行される**可能性があります。

## 例

### H2.CL Desync

HTTP/2の仕様では、**Content-Lengthヘッダーは必要ではないが示されることがある**とされています。したがって、**リバースプロキシ**はユーザーが送信したすべてのコンテンツをリクエストとして**扱います**が、**HTTP/1.1へダウングレードする**と、この**ヘッダー**が**リクエスト**に**注入**され、その結果、**バックエンドはリクエストを2つの異なるリクエストとして扱う**ことになります。以下の画像を参照してください：

![](<../../.gitbook/assets/image (639).png>)

### H2.TE Desync URL Token Hijack

HTTP/2の仕様では、**接続固有のヘッダーフィールドを含むメッセージは不正形式として扱われるべき...しかし、このルールに従わない場合、脆弱です**。

この技術はAWSのロードバランサーで悪用されたため、ユーザーが攻撃者が制御するサーバーを指すHostヘッダーにアクセスするようにすると、彼らはそのサーバーにアクセスすることになります。

![](<../../.gitbook/assets/image (631) (1).png>)

### H2.TE Desync Header Hijack

これは前述の技術とまったく同じですが、リクエストをチェックしたJamesは、クライアントが彼に自分の認証情報を送信するよう求めていることに気づきました。そこで彼はサーバーを変更して、CORSを許可し、人々の認証情報を彼に送信するようにしました：

![](<../../.gitbook/assets/image (662) (1) (1) (1) (1) (1).png>)

### H2.TE via Request Header Injection

**HTTP/2では許可されていない文字をヘッダーに入れることはできません**が、サーバーがこのルールを**尊重していない**場合、通信がHTTP/1.1に**ダウングレード**されたときに**任意のヘッダーを注入**することができます。

この場合、**Transfer-Encodingヘッダーが注入されました**。

![](<../../.gitbook/assets/image (648) (1) (1) (1) (1) (1).png>)

### H2.TE via Header Name Injection

HTTP/2では、一部のサーバーがヘッダー名に**コロンを入れることを許可しており**、それを使って次のようにヘッダー名の中に新しいヘッダーを注入することができます：

![](<../../.gitbook/assets/image (632) (1).png>)

内容のないヘッダーを送信するために新しい行文字だけを入れた場合、リクエストは**無効**として扱われることに注意してください：

![](<../../.gitbook/assets/image (647) (1) (1) (1).png>)

### H2.TE via Request Line Injection

この場合、注入はリクエストライン内で実行されました：

![](<../../.gitbook/assets/image (640) (1).png>)

### URL Prefix Injection

HTTP/2接続のスキーム内で、パスで示されたものを上書きする完全なURLを送信することができるかもしれません：

![](<../../.gitbook/assets/image (661) (1) (1).png>)

### Request Line Injection via spaces

![](<../../.gitbook/assets/image (641) (1).png>)

## フロントエンド->バックエンド接続の再利用

時々、HTTPリクエストスマグリング攻撃を実行すると**自分自身にしか攻撃できない**ことがあります。これは、リバースプロキシがIPごとにバックエンドサーバーとの**異なる接続を使用する**ことを決定したためかもしれません。

**その制限があっても**、**認証バイパス**、内部ヘッダーのリーク、**キャッシュデセプションおよびキャッシュポイズニング**攻撃などの攻撃を実行することができます。

通常、この制限は存在しないため、他の人が使用しているリバースプロキシとバックエンド間の接続に**リクエストをスマグル**することができますが、**プロキシ**が**同じIPからの接続でさえ接続を再利用しない**可能性もあります（この種の攻撃にとってかなり厳しい制限）。

![](<../../.gitbook/assets/image (646) (1) (1).png>)

最も厳しい制限（接続の再利用なし）では、Time Basedテクニックで脆弱性を検出しますが、テストすると「偽陽性」であることがわかります。

### トンネリング確認

**エンドポイントが脆弱であるかどうかを確認する**方法の一つは、1つに**2つの完全なリクエストをスマグル**することです。

**HTTP/1.1**の**問題**は、2つのHTTPレスポンスを**受け取った場合**、エンドポイントが**脆弱だったかどうか**わからず、**「スマグルされた」リクエストがただの通常のリクエストとして扱われたかどうか**がわからないことです。

しかし、この技術は**HTTP/2**で使用できます。なぜなら、エンドポイントが**脆弱**でリクエストを1つスマグルした場合、リバースプロキシからのレスポンスにスマグルされたリクエストへのレスポンスの**ヘッダーが見える**からです：

![](<../../.gitbook/assets/image (652) (1) (1) (1).png>)

### トンネルビジョン問題

別の問題があります。正当なリクエストへの**レスポンス**に**Content-Length**が**含まれている**場合、**リバースプロキシ**はそこで指定されたバイト数だけを**読み取り**、スマグルされたリクエストからのレスポンスを読むことができません。

しかし、**HEAD**リクエストにはボディが**含まれていません**が、通常はGETリクエストであったかのように**Content-Length**が**含まれています**。したがって、POSTリクエストの代わりに**HEAD**リクエストを送信することで、スマグルされたリクエストのレスポンスのHEAD Content-Lengthバイトを**読むことができます**。

![](<../../.gitbook/assets/image (628) (1) (1).png>)

### トンネリングを介した内部ヘッダーのリーク

アプリケーション内に**POST** **パラメーター**が見つかり、その**内容**が**レスポンス**に**反映される**場合、HTTP/2リクエストヘッダー内にHTTP/1.1の\r\n文字を注入してみることができます。そうすると、プロキシによって新しく注入されたヘッダーがPOSTパラメーターに追加され、レスポンスで反映されることになります：

![](<../../.gitbook/assets/image (656) (1) (1).png>)

この場合、**攻撃者**は**最初の** **リクエスト**への**レスポンス**のみに関心があり、スマグルされた無効な2番目のリクエストへのリクエストを読む必要はありません。

{% hint style="info" %}
この攻撃を**ウェブの異なる部分（方法、パス...）**に対して使用すると、異なるバックエンドが使用され、**異なる機密情報がリークされる**可能性があります。
{% endhint %}

### トンネリングを介したキャッシュポイズニング

このシナリオでは、**キャッシュがポイズニングされる** **URL**に対して**HEAD**リクエストを送信しながら、**ペイロードを含むレスポンスコンテンツ**（おそらくXSSペイロード）を持つ**リクエストをスマグル**します。

HEADレスポンスに`Content-Type: text/html`が含まれているため、リバースプロキシはスマグルされたリクエストへの**全レスポンスがHEAD**リクエストのボディであると考えるため、**XSSペイロード**は、ページがXSSに脆弱でなくても**HTMLとして扱われます**。

![](<../../.gitbook/assets/image (659) (1).png>)

## 隠されたHTTP/2

通常、サーバーはTLSハンドシェイクのALPNフィールドを介してサポートを広告しますが、広告しないものもあります。

`curl --http2 --http2-prior-knowledge`を使用して簡単に検出できます。

## ツール

* Burp拡張機能: HTTPリクエストスマグラー
* [https://github.com/neex/http2smugl](https://github.com/neex/http2smugl)

## 参考文献

* こちらのトークでは、ここで示されたすべての技術について完璧に説明しています: [https://www.youtube.com/watch?v=rHxVVeM9R-M](https://www.youtube.com/watch?v=rHxVVeM9R-M)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)でゼロからヒーローまでAWSハッキングを学ぶ</strong></summary>

HackTricksをサポートする他の方法:

* **HackTricksにあなたの会社を広告したい**、または**HackTricksをPDFでダウンロードしたい**場合は、[**サブスクリプションプラン**](https://github.com/sponsors/carlospolop)をチェックしてください。
* [**公式PEASS & HackTricksグッズ**](https://peass.creator-spring.com)を入手する
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見する、私たちの独占的な[**NFTs**](https://opensea.io/collection/the-peass-family)のコレクション
* 💬 [**Discordグループ**](https://discord.gg/hRep4RUj7f)に**参加する**か、[**telegramグループ**](https://t.me/peass)に参加するか、**Twitter** 🐦 [**@carlospolopm**](https://twitter.com/carlospolopm)を**フォローする**。
* [**HackTricks**](https://github.com/carlospolop/hacktricks)と[**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud)のgithubリポジトリにPRを提出して、あなたのハッキングのコツを共有する。

</details>
