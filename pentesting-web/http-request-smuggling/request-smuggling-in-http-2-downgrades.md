# HTTP/2 降级中的请求走私

<details>

<summary><strong>从零开始学习 AWS 黑客攻击直到成为英雄</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks** 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>

## 起源

这个漏洞的主要来源是**反向代理**将使用 **HTTP/2** 与**客户端**通信，然后将该通信**转换**为与**后端服务器**的 **HTTP/1.1**。

![](<../../.gitbook/assets/image (636) (1).png>)

这种方法的问题在于，**用户**将能够在**HTTP/2 通信**中**注入**不必要的**头部**，这些头部可能**不会被代理检查**。但是，当这些头部在 **HTTP/1.1 通信**中**盲目注入**时，**可以执行请求走私攻击**。

## 示例

### H2.CL Desync

HTTP/2 规范指出**Content-Length 头部不是必需的，但可以指示**。因此，**反向代理**将**处理用户发送的所有内容**作为请求，但是，当**降级到 HTTP/1.1**时，这个**头部**将被**注入**到**请求**中，因此，**后端将把请求视为两个不同的请求**，如下图所示：

![](<../../.gitbook/assets/image (639).png>)

### H2.TE Desync URL Token 劫持

HTTP/2 规范还指出，**包含特定于连接的头部字段的任何消息必须被视为格式错误的...但如果你不遵循这个规则，你就会变得脆弱**。

这种技术在 AWS 负载均衡器上被滥用，因此确保用户访问一个指向攻击者控制的服务器的 Host 头部将使他们访问该服务器。

![](<../../.gitbook/assets/image (631) (1).png>)

### H2.TE Desync 头部劫持

这与之前的技术完全相同，但在检查请求时，James 注意到客户要求将他们的凭据发送给他，所以他只是修改了他的服务器，允许 CORS 将人们的凭据发送给他：

![](<../../.gitbook/assets/image (662) (1) (1) (1) (1) (1).png>)

### H2.TE 通过请求头部注入

**HTTP/2 也不允许在头部中放置不允许的字符**，但如果服务器**不遵守**这个规则，你可以在通信**降级**到 HTTP/1.1 时**注入任意头部**。

在这种情况下**注入了 Transfer-Encoding 头部**。

![](<../../.gitbook/assets/image (648) (1) (1) (1) (1) (1).png>)

### H2.TE 通过头部名称注入

HTTP/2 在某些服务器上允许你在头部名称中放置**冒号**，并且通过**冒号**你可以像这样在头部名称中注入一个新的头部：

![](<../../.gitbook/assets/image (632) (1).png>)

注意，如果你只放置换行字符发送一个没有内容的头部，请求将被视为**无效**：

![](<../../.gitbook/assets/image (647) (1) (1) (1).png>)

### H2.TE 通过请求行注入

在这种情况下，注入是在请求行内执行的：

![](<../../.gitbook/assets/image (640) (1).png>)

### URL 前缀注入

在 HTTP/2 连接的方案中，你可能能够发送一个完整的 URL，它将覆盖路径中指示的 URL：

![](<../../.gitbook/assets/image (661) (1) (1).png>)

### 通过空格进行请求行注入

![](<../../.gitbook/assets/image (641) (1).png>)

## 前端->后端连接复用

有时你会发现，在执行 HTTP 请求走私攻击时**你只能攻击自己**。这可能是因为反向代理决定**对每个 IP 使用不同的与后端的连接**。

注意，即使有这个**限制**，你仍然可以执行像**授权绕过**、内部头部泄露以及**缓存欺骗和缓存投毒**攻击。

通常这种限制不存在，所以你可以**将请求走私到其他人正在使用的反向代理和后端之间的连接**中，但甚至**有可能**代理**甚至不会重用来自同一 IP 的连接**（对这种攻击来说是相当严重的限制）。

![](<../../.gitbook/assets/image (646) (1) (1).png>)

在最严重的限制（不复用连接）中，你会使用基于时间的技术检测到漏洞，但在测试时你会发现它是一个“假阳性”。

### 隧道确认

一种**确认**端点是否**脆弱**但连接**在“隧道”内**的方法是**将 2 个完整的请求走私**进 1 个。

**HTTP/1.1**的**问题**在于，如果你**收到 2 个 HTTP 响应**，你**不知道**端点是否**脆弱**，或者它不是，而**“走私”的请求只是被当作常规请求处理**。

然而，这种技术可以**在 HTTP/2 中使用**，因为如果端点**脆弱**并且你走私了一个请求，你将在反向代理的响应中看到**对走私请求的响应的头部**：

![](<../../.gitbook/assets/image (652) (1) (1) (1).png>)

### 隧道视觉问题

可能还有另一个问题，如果对合法请求的**响应**包含**Content-Length**，那么**反向代理**只会**读取那里指定的字节数，不再多读，所以你将无法读取来自走私请求的响应**。

然而，**HEAD** 请求**不包含正文**，但它通常**包含** **Content-Length**，就像请求是 GET 请求一样。因此，发送一个**HEAD** 请求**而不是 POST** 请求，你可以**读取走私请求响应的 HEAD Content-Length** 字节。

![](<../../.gitbook/assets/image (628) (1) (1).png>)

### 通过隧道泄露内部头部

如果你在应用程序内找到一个**POST** **参数**，其**内容**将在**响应**中**反映**，那么你可以尝试在 HTTP/2 请求头部中注入 HTTP/1.1 \r\n 字符，这样代理新注入的头部将被附加在将在响应中反映的 POST 参数中：

![](<../../.gitbook/assets/image (656) (1) (1).png>)

注意，在这种情况下，**攻击者**只关心对**第一个**请求的**响应**，他不需要读取对走私的无效第二个请求的请求。

{% hint style="info" %}
使用这种攻击**针对网页的不同部分（方法、路径...）**可能会导致使用不同的后端，并且**泄露不同的敏感信息**
{% endhint %}

### 通过隧道进行缓存投毒

在这种情况下，发送一个**HEAD** 请求到**URL**，**其缓存**将被**投毒**，同时**走私**一个**请求**，其**响应内容将包含有效载荷**（可能是某些 XSS 有效载荷）。

由于**HEAD 响应包含 `Content-Type: text/html`**，并且因为反向代理认为**对走私请求的整个响应是 HEAD** 请求的正文，**XSS 有效载荷**将被**视为 HTML**，即使页面没有对 XSS 脆弱。

![](<../../.gitbook/assets/image (659) (1).png>)

## 隐藏的 HTTP/2

通常服务器通过 TLS 握手中的 ALPN 字段宣布支持，但有些不是。

可以使用 `curl --http2 --http2-prior-knowledge` 轻松检测。

## 工具

* Burp 扩展：HTTP 请求走私者
* [https://github.com/neex/http2smugl](https://github.com/neex/http2smugl)

## 参考

* 这个演讲完美地解释了这里指出的所有技术：[https://www.youtube.com/watch?v=rHxVVeM9R-M](https://www.youtube.com/watch?v=rHxVVeM9R-M)

<details>

<summary><strong>从零开始学习 AWS 黑客攻击直到成为英雄</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS 红队专家)</strong></a><strong>！</strong></summary>

支持 HackTricks 的其他方式：

* 如果您想在 **HackTricks** 中看到您的**公司广告**或**下载 HackTricks 的 PDF**，请查看[**订阅计划**](https://github.com/sponsors/carlospolop)！
* 获取[**官方 PEASS & HackTricks 商品**](https://peass.creator-spring.com)
* 发现[**PEASS 家族**](https://opensea.io/collection/the-peass-family)，我们独家的[**NFTs 集合**](https://opensea.io/collection/the-peass-family)
* **加入** 💬 [**Discord 群组**](https://discord.gg/hRep4RUj7f) 或 [**telegram 群组**](https://t.me/peass) 或在 **Twitter** 🐦 上**关注**我 [**@carlospolopm**](https://twitter.com/carlospolopm)**。**
* **通过向** [**HackTricks**](https://github.com/carlospolop/hacktricks) 和 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 仓库提交 PR 来**分享您的黑客技巧**。

</details>
