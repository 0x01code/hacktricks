# Request Smuggling en Downgrades de HTTP/2

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

## Or칤genes

El principal origen de esta vulnerabilidad es el hecho de que el **reverse proxy** va a **comunicarse con el cliente** usando **HTTP/2** pero luego va a **transformar** esa **comunicaci칩n** con el **servidor back-end** a **HTTP/1.1**.

![](<../../.gitbook/assets/image (636) (1).png>)

El problema con este enfoque es que el **usuario** va a poder **inyectar** **encabezados** innecesarios en la **comunicaci칩n HTTP/2** que probablemente **no ser치n verificados** por el proxy. Pero luego, cuando estos son **inyectados a ciegas en la comunicaci칩n HTTP/1.1**, **se puede realizar un ataque de request smuggling**.

## Ejemplos

### Desincronizaci칩n H2.CL

La especificaci칩n de HTTP/2 indica que el **encabezado Content-Length no es necesario pero puede ser indicado**. Por lo tanto, el **reverse proxy** tratar치 todo el contenido enviado por los usuarios como la solicitud, pero luego, al **degradar a HTTP/1.1**, este **encabezado** va a ser **inyectado** en la **solicitud** y por lo tanto, el **servidor back-end tratar치 la solicitud como 2 solicitudes diferentes** como puedes ver en la imagen a continuaci칩n:

![](<../../.gitbook/assets/image (639).png>)

### Secuestro de Token de URL H2.TE Desync

La especificaci칩n de HTTP/2 tambi칠n indica que **cualquier mensaje que contenga campos de encabezado espec칤ficos de la conexi칩n DEBE ser tratado como malformado... pero si no sigues esta regla, eres vulnerable**.

Esta t칠cnica fue abusada en el balanceador de carga de AWS, por lo que asegurarse de que los usuarios accedan a un encabezado Host apuntando a un servidor controlado por el atacante har치 que accedan a ese servidor.

![](<../../.gitbook/assets/image (631) (1).png>)

### Secuestro de Encabezado H2.TE Desync

Esta es exactamente la misma t칠cnica que antes, pero revisando las solicitudes James not칩 que los clientes le ped칤an enviarle sus credenciales, as칤 que simplemente modific칩 su servidor para permitir CORS para enviarle las credenciales de las personas:

![](<../../.gitbook/assets/image (662) (1) (1) (1) (1) (1).png>)

### H2.TE v칤a Inyecci칩n de Encabezado de Solicitud

**HTTP/2 tampoco permitir치 poner caracteres no permitidos en los encabezados**, pero si el servidor **no respeta** esta regla, puedes **inyectar encabezados arbitrarios** cuando la comunicaci칩n se **degrada** a HTTP/1.1.

En este caso **se inyect칩 el encabezado Transfer-Encoding**.

![](<../../.gitbook/assets/image (648) (1) (1) (1) (1) (1).png>)

### H2.TE v칤a Inyecci칩n de Nombre de Encabezado

HTTP/2 en algunos servidores te permite poner un **dos puntos en el nombre del encabezado, y con un** puedes inyectar un nuevo encabezado dentro del nombre del encabezado como esto:

![](<../../.gitbook/assets/image (632) (1).png>)

Nota que si pones solo los caracteres de nueva l칤nea enviando un encabezado sin contenido, la solicitud va a ser tratada como **inv치lida**:

![](<../../.gitbook/assets/image (647) (1) (1) (1).png>)

### H2.TE v칤a Inyecci칩n de L칤nea de Solicitud

En este caso la inyecci칩n se realiz칩 dentro de la l칤nea de solicitud:

![](<../../.gitbook/assets/image (640) (1).png>)

### Inyecci칩n de Prefijo de URL

Dentro del esquema de la conexi칩n HTTP/2 podr칤as ser capaz de enviar una URL completa que sobrescribir치 la indicada en el camino:

![](<../../.gitbook/assets/image (661) (1) (1).png>)

### Inyecci칩n de L칤nea de Solicitud v칤a espacios

![](<../../.gitbook/assets/image (641) (1).png>)

## Reutilizaci칩n de conexi칩n frontend->backend

A veces encontrar치s que al realizar un ataque de HTTP Request Smuggling **solo puedes atacarte a ti mismo**. Esto podr칤a ser porque el reverse proxy ha decidido **usar una conexi칩n diferente con el servidor back-end** por IP.

Nota que **incluso** con esa **restricci칩n** todav칤a puedes realizar ataques como **bypasses de autorizaci칩n**, fuga de encabezados internos y ataques de **enga침o y envenenamiento de cach칠**.

Usualmente esta restricci칩n no existe por lo que puedes **introducir solicitudes en la conexi칩n entre el reverse proxy y el back end** que otras personas est치n usando, pero es incluso **posible** que el **proxy** no **reutilice una conexi칩n con conexiones de la misma IP** (restricci칩n bastante pesada para este tipo de ataque).

![](<../../.gitbook/assets/image (646) (1) (1).png>)

En la restricci칩n m치s pesada (sin reutilizaci칩n de conexi칩n) detectar치s la vulnerabilidad con la t칠cnica basada en tiempo, pero luego al probarla encontrar치s que es un "falso positivo".

### Confirmaci칩n de T칰nel

Una forma de **confirmar** si el **punto final es vulnerable** pero la conexi칩n est치 **dentro de un "t칰nel"** es **introducir 2 solicitudes completas** en 1.

El **problema** con **HTTP/1.1** es que si **recibes 2 respuestas HTTP** no **sabes** si el punto final era **vulnerable** o no lo es y la **solicitud "introducida"** fue solo tratada como una solicitud regular.

Sin embargo, esta t칠cnica se puede usar **en HTTP/2** porque si el punto final era **vulnerable** y introdujiste una solicitud, ver치s los **encabezados de la respuesta a la solicitud introducida en la respuesta del reverse proxy**:

![](<../../.gitbook/assets/image (652) (1) (1) (1).png>)

### Problema de Visi칩n de T칰nel

Podr칤a haber otro problema, si la **respuesta** a la solicitud leg칤tima **contiene** un **Content-Length**, el **reverse proxy** solo va a **leer los bytes especificados all칤 y no m치s, por lo que no podr치s leer la respuesta de la solicitud introducida.**

Sin embargo, la solicitud **HEAD** **no contiene cuerpo** pero usualmente **contiene** el **Content-Length** como si la solicitud fuera un GET. Por lo tanto, enviando una solicitud **HEAD** **en lugar de una POST** puedes **leer los bytes del Content-Length de HEAD** de la respuesta de la solicitud introducida.

![](<../../.gitbook/assets/image (628) (1) (1).png>)

### Fuga de Encabezados Internos v칤a T칰nel

Si encuentras un **par치metro POST** dentro de la aplicaci칩n cuyo **contenido** va a ser **reflejado** en la **respuesta**, entonces puedes intentar inyectar caracteres HTTP/1.1 \r\n dentro de un encabezado de solicitud HTTP/2 para que los nuevos encabezados inyectados por el proxy se a침adan en el par치metro POST que ser치 reflejado en la respuesta:

![](<../../.gitbook/assets/image (656) (1) (1).png>)

Nota que en este caso el **atacante** solo se preocupa por la **respuesta** a la **primera** **solicitud**, no necesita leer la solicitud a la segunda solicitud inv치lida introducida.

{% hint style="info" %}
Usar este ataque **contra diferentes partes de la web (m칠todo, camino...)** puede llevar a que se usen diferentes back-ends y **se filtre diferente informaci칩n sensible**
{% endhint %}

### Envenenamiento de Cach칠 v칤a T칰nel

En este escenario se env칤a una solicitud **HEAD** a la **URL** **cuya** **cach칠** va a ser **envenenada** mientras se **introduce** una **solicitud** cuyo **contenido de la respuesta contendr치 el payload** (quiz치s alg칰n payload XSS).

Debido al hecho de que la **respuesta HEAD contiene el `Content-Type: text/html`** y porque el reverse proxy piensa que la **respuesta completa a la solicitud introducida es el cuerpo de la solicitud HEAD**, el **payload XSS** va a ser **tratado como HTML** incluso si la p치gina no era vulnerable a XSS.

![](<../../.gitbook/assets/image (659) (1).png>)

## HTTP/2 Oculto

Normalmente los servidores anuncian el soporte a trav칠s del campo ALPN en el handshake TLS, pero algunos no lo hacen.

Se puede detectar f치cilmente usando `curl --http2 --http2-prior-knowledge`

## Herramientas

* Extensi칩n de Burp: HTTP Request Smuggler
* [https://github.com/neex/http2smugl](https://github.com/neex/http2smugl)

## Referencias

* Esta charla explica perfectamente todas las t칠cnicas indicadas aqu칤: [https://www.youtube.com/watch?v=rHxVVeM9R-M](https://www.youtube.com/watch?v=rHxVVeM9R-M)

<details>

<summary><strong>Aprende hacking en AWS de cero a h칠roe con</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Otras formas de apoyar a HackTricks:

* Si quieres ver a tu **empresa anunciada en HackTricks** o **descargar HackTricks en PDF** revisa los [**PLANES DE SUSCRIPCI칍N**](https://github.com/sponsors/carlospolop)!
* Consigue el [**merchandising oficial de PEASS & HackTricks**](https://peass.creator-spring.com)
* Descubre [**La Familia PEASS**](https://opensea.io/collection/the-peass-family), nuestra colecci칩n de [**NFTs**](https://opensea.io/collection/the-peass-family) exclusivos
* **칔nete al** 游눫 [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s칤gueme** en **Twitter** 游냕 [**@carlospolopm**](https://twitter.com/carlospolopm)**.**
* **Comparte tus trucos de hacking enviando PRs a los repositorios de github de** [**HackTricks**](https://github.com/carlospolop/hacktricks) y [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
