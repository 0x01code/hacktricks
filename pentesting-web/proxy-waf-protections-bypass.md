# 프록시 / WAF 보호 우회

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)를 통해 제로에서 영웅까지 AWS 해킹 배우기</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>!</strong></a></summary>

HackTricks를 지원하는 다른 방법:

* **회사가 HackTricks에 광고되길 원하거나 HackTricks를 PDF로 다운로드**하고 싶다면 [**구독 요금제**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* **💬 [디스코드 그룹](https://discord.gg/hRep4RUj7f)에 가입하거나 [텔레그램 그룹](https://t.me/peass)에 가입하거나** **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)**를 팔로우하세요.**
* **해킹 트릭을 공유하려면 PR을** [**HackTricks**](https://github.com/carlospolop/hacktricks) **및** [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) **깃허브 저장소에 제출하세요.**

</details>

## 경로 이름 조작을 사용하여 Nginx ACL 규칙 우회 <a href="#heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules" id="heading-pathname-manipulation-bypassing-reverse-proxies-and-load-balancers-security-rules"></a>

기술 [이 연구에서](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies).

Nginx 규칙 예시:
```plaintext
location = /admin {
deny all;
}

location = /admin/ {
deny all;
}
```
### **NodeJS - Express**

| Nginx Version | **Node.js Bypass Characters** |
| ------------- | ----------------------------- |
| 1.22.0        | `\xA0`                        |
| 1.21.6        | `\xA0`                        |
| 1.20.2        | `\xA0`, `\x09`, `\x0C`        |
| 1.18.0        | `\xA0`, `\x09`, `\x0C`        |
| 1.16.1        | `\xA0`, `\x09`, `\x0C`        |

### **Flask**

| Nginx Version | **Flask Bypass Characters**                                    |
| ------------- | -------------------------------------------------------------- |
| 1.22.0        | `\x85`, `\xA0`                                                 |
| 1.21.6        | `\x85`, `\xA0`                                                 |
| 1.20.2        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.18.0        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |
| 1.16.1        | `\x85`, `\xA0`, `\x1F`, `\x1E`, `\x1D`, `\x1C`, `\x0C`, `\x0B` |

### **Spring Boot**

| Nginx Version | **Spring Boot Bypass Characters** |
| ------------- | --------------------------------- |
| 1.22.0        | `;`                               |
| 1.21.6        | `;`                               |
| 1.20.2        | `\x09`, `;`                       |
| 1.18.0        | `\x09`, `;`                       |
| 1.16.1        | `\x09`, `;`                       |

### **PHP-FPM**

Nginx FPM configuration:
```plaintext
location = /admin.php {
deny all;
}

location ~ \.php$ {
include snippets/fastcgi-php.conf;
fastcgi_pass unix:/run/php/php8.1-fpm.sock;
}
```
Nginx는 `/admin.php`에 대한 액세스를 차단하도록 구성되어 있지만, `/admin.php/index.php`에 액세스하여 이를 우회할 수 있습니다.

### 방지 방법
```plaintext
location ~* ^/admin {
deny all;
}
```
## Mod Security 규칙 우회 <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 경로 혼란

[**이 게시물**](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/)에서는 ModSecurity v3 (3.0.12 버전까지)이 `REQUEST_FILENAME` 변수를 부적절하게 구현했음을 설명했습니다. 이 변수는 액세스된 경로를 포함해야 했지만 (매개변수 시작까지), 경로를 가져 오기 위해 URL 디코딩을 수행했기 때문에 이 변수가 제대로 구현되지 않았습니다.\
따라서 Mod Security에서 `http://example.com/foo%3f';alert(1);foo=`와 같은 요청은 `%3f`가 URL 경로를 끝내는 `?`로 변환되어 경로가 `/foo`일 것으로 가정하지만, 실제로 서버가 받게 될 경로는 `/foo%3f';alert(1);foo=`가 됩니다.

변수 `REQUEST_BASENAME` 및 `PATH_INFO`도 이 버그의 영향을 받았습니다.

Mod Security의 버전 2에서도 비슷한 문제가 발생했는데, 이는 백업 파일과 관련된 특정 확장자를 가진 파일에 액세스를 방지하는 보호 기능을 우회할 수 있었습니다 (예: `.bak`). 단순히 점을 URL 인코딩 된 `%2e`로 보내면 가능했습니다. 예를 들어: `https://example.com/backup%2ebak`.

## AWS WAF ACL 우회 <a href="#heading-bypassing-aws-waf-acl" id="heading-bypassing-aws-waf-acl"></a>

### 형식이 잘못된 헤더

[이 연구](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)는 AWS WAF 규칙을 우회할 수 있었던 HTTP 헤더에 "형식이 잘못된" 헤더를 보내어 AWS에서는 제대로 구문 분석되지 않았지만 백엔드 서버에서는 구문 분석되는 방법으로 우회할 수 있었습니다.

예를 들어, 다음 요청을 SQL 인젝션을 포함한 헤더 X-Query로 보내는 것:
```http
GET / HTTP/1.1\r\n
Host: target.com\r\n
X-Query: Value\r\n
\t' or '1'='1' -- \r\n
Connection: close\r\n
\r\n
```
AWS WAF를 우회하는 것이 가능했었는데, 이는 AWS WAF가 헤더 값의 다음 줄이 해당 값의 일부라는 것을 이해하지 못했기 때문이었습니다. 반면 NODEJS 서버는 이를 이해했었습니다 (해당 문제는 수정되었습니다).

## 참고 자료

* [https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies](https://rafa.hashnode.dev/exploiting-http-parsers-inconsistencies)
* [https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass/](https://blog.sicuranext.com/modsecurity-path-confusion-bugs-bypass)

<details>

<summary><strong>htARTE (HackTricks AWS Red Team Expert)</strong>를 통해 제로부터 AWS 해킹을 전문가로 배우세요!</summary>

HackTricks를 지원하는 다른 방법:

* **회사를 HackTricks에서 광고하거나 PDF로 다운로드하고 싶다면** [**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)를 확인하세요!
* [**공식 PEASS & HackTricks 스왜그**](https://peass.creator-spring.com)를 구매하세요
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)를 발견하세요, 당사의 독점 [**NFTs**](https://opensea.io/collection/the-peass-family) 컬렉션
* 💬 [**Discord 그룹**](https://discord.gg/hRep4RUj7f) 또는 [**텔레그램 그룹**](https://t.me/peass)에 **가입**하거나 **트위터** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)를 **팔로우**하세요.
* 해킹 트릭을 공유하려면 [**HackTricks**](https://github.com/carlospolop/hacktricks) 및 [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github 저장소에 PR을 제출하세요.

</details>
